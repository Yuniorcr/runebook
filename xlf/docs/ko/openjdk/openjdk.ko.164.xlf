<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="48563266c944d99d9eaba5e60d33852a238c2d45" translate="yes" xml:space="preserve">
          <source>Weak reference objects, which do not prevent their referents from being made finalizable, finalized, and then reclaimed. Weak references are most often used to implement canonicalizing mappings.</source>
          <target state="translated">약한 참조 객체. 참조 객체의 최종화, 마무리 및 재생을 방해하지 않습니다. 약한 참조는 표준 매핑을 구현하는 데 가장 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="03229c3ce0e1d4a5dea21e64ed5a7a21dd50346b" translate="yes" xml:space="preserve">
          <source>WeakHashMap</source>
          <target state="translated">WeakHashMap</target>
        </trans-unit>
        <trans-unit id="9f578a1ece44744875548c14accd3ab118f52f96" translate="yes" xml:space="preserve">
          <source>WeakHashMap.clear()</source>
          <target state="translated">WeakHashMap.clear()</target>
        </trans-unit>
        <trans-unit id="cac8951d07963c9661fb7627c7267795d5e7a4f2" translate="yes" xml:space="preserve">
          <source>WeakHashMap.containsKey()</source>
          <target state="translated">WeakHashMap.containsKey()</target>
        </trans-unit>
        <trans-unit id="356e80282ac519184e65c488908383906447f348" translate="yes" xml:space="preserve">
          <source>WeakHashMap.containsValue()</source>
          <target state="translated">WeakHashMap.containsValue()</target>
        </trans-unit>
        <trans-unit id="60be0515876f006e6ca1cd3d7d552af9ccd01ffe" translate="yes" xml:space="preserve">
          <source>WeakHashMap.entrySet()</source>
          <target state="translated">WeakHashMap.entrySet()</target>
        </trans-unit>
        <trans-unit id="e49f5cd6e00c4432b7ebd63f64c70d97e2bfbb24" translate="yes" xml:space="preserve">
          <source>WeakHashMap.forEach()</source>
          <target state="translated">WeakHashMap.forEach()</target>
        </trans-unit>
        <trans-unit id="19b9a321a4f1bd958cc8610a953bd1ee99035128" translate="yes" xml:space="preserve">
          <source>WeakHashMap.get()</source>
          <target state="translated">WeakHashMap.get()</target>
        </trans-unit>
        <trans-unit id="a5a9ba4e04afb8fcdfc19b61079a8ebd40110696" translate="yes" xml:space="preserve">
          <source>WeakHashMap.isEmpty()</source>
          <target state="translated">WeakHashMap.isEmpty()</target>
        </trans-unit>
        <trans-unit id="7bd691f3c04552e56d59d519f1a4666a626cae68" translate="yes" xml:space="preserve">
          <source>WeakHashMap.keySet()</source>
          <target state="translated">WeakHashMap.keySet()</target>
        </trans-unit>
        <trans-unit id="3e34f391baf109443d3eca81db8e406c21247e08" translate="yes" xml:space="preserve">
          <source>WeakHashMap.put()</source>
          <target state="translated">WeakHashMap.put()</target>
        </trans-unit>
        <trans-unit id="b834ab3cef7770bc9b59513aef17274348ef63ed" translate="yes" xml:space="preserve">
          <source>WeakHashMap.putAll()</source>
          <target state="translated">WeakHashMap.putAll()</target>
        </trans-unit>
        <trans-unit id="51c4de9f87dd1095d9471573ff074fdefaf0db3e" translate="yes" xml:space="preserve">
          <source>WeakHashMap.remove()</source>
          <target state="translated">WeakHashMap.remove()</target>
        </trans-unit>
        <trans-unit id="77d99b79dc28fd6bd9db3b97d88184d2de438fd0" translate="yes" xml:space="preserve">
          <source>WeakHashMap.replaceAll()</source>
          <target state="translated">WeakHashMap.replaceAll()</target>
        </trans-unit>
        <trans-unit id="42ea52208a3ce498ea844af7690268dde31e784f" translate="yes" xml:space="preserve">
          <source>WeakHashMap.size()</source>
          <target state="translated">WeakHashMap.size()</target>
        </trans-unit>
        <trans-unit id="8bc55d91cb214228db71f61c09b537092b4bec12" translate="yes" xml:space="preserve">
          <source>WeakHashMap.values()</source>
          <target state="translated">WeakHashMap.values()</target>
        </trans-unit>
        <trans-unit id="5ea903ebda4f9f28f642d78e916dc09051395c95" translate="yes" xml:space="preserve">
          <source>WeakReference</source>
          <target state="translated">WeakReference</target>
        </trans-unit>
        <trans-unit id="bf85b22fdda959fc428f30bfb2a0f068edc191bf" translate="yes" xml:space="preserve">
          <source>WebRowSet</source>
          <target state="translated">WebRowSet</target>
        </trans-unit>
        <trans-unit id="fd2fe2179b44fad347e37ec201d26ab520f15318" translate="yes" xml:space="preserve">
          <source>WebSocket</source>
          <target state="translated">WebSocket</target>
        </trans-unit>
        <trans-unit id="8d50debedf657789eb83e5bb579d738443688767" translate="yes" xml:space="preserve">
          <source>WebSocket has an input and an output side. These sides are independent from each other. A side can either be open or closed. Once closed, the side remains closed. WebSocket messages are sent through a &lt;code&gt;WebSocket&lt;/code&gt; and received through a &lt;code&gt;WebSocket.Listener&lt;/code&gt; associated with it. Messages can be sent until the WebSocket's output is closed, and received until the WebSocket's input is closed.</source>
          <target state="translated">WebSocket has an input and an output side. These sides are independent from each other. A side can either be open or closed. Once closed, the side remains closed. WebSocket messages are sent through a &lt;code&gt;WebSocket&lt;/code&gt; and received through a &lt;code&gt;WebSocket.Listener&lt;/code&gt; associated with it. Messages can be sent until the WebSocket's output is closed, and received until the WebSocket's input is closed.</target>
        </trans-unit>
        <trans-unit id="9e7c0e37606b1f794c1372d83eddadb351ac3d9c" translate="yes" xml:space="preserve">
          <source>WebSocket.Builder</source>
          <target state="translated">WebSocket.Builder</target>
        </trans-unit>
        <trans-unit id="0de0866691e65f5871dab18f5e7b17347cdabb10" translate="yes" xml:space="preserve">
          <source>WebSocket.Listener</source>
          <target state="translated">WebSocket.Listener</target>
        </trans-unit>
        <trans-unit id="e5ae2288a1ae365d9dae39add24416582095231c" translate="yes" xml:space="preserve">
          <source>WebSocketHandshakeException</source>
          <target state="translated">WebSocketHandshakeException</target>
        </trans-unit>
        <trans-unit id="5656b9b79b0316fc611a9c30d2ffac25228b8371" translate="yes" xml:space="preserve">
          <source>Wednesday</source>
          <target state="translated">Wednesday</target>
        </trans-unit>
        <trans-unit id="10b774684253b67ed6046c62d38b42b91e852330" translate="yes" xml:space="preserve">
          <source>Week 0 of January 2009</source>
          <target state="translated">2009 년 1 월 0 주</target>
        </trans-unit>
        <trans-unit id="7b27856c3025a48dfd145f75086cda19de2ee70e" translate="yes" xml:space="preserve">
          <source>Week 1 of 2009</source>
          <target state="translated">2009 년 1 주차</target>
        </trans-unit>
        <trans-unit id="e0b134e5cd0d67c325ab9181f61674f7eb847f4f" translate="yes" xml:space="preserve">
          <source>Week 1 of January 2009</source>
          <target state="translated">2009 년 1 월 1 주</target>
        </trans-unit>
        <trans-unit id="0273a235d369407f5bc0d09e86dc0804188d2c3d" translate="yes" xml:space="preserve">
          <source>Week 1 of week-based-year 2009</source>
          <target state="translated">2009 년 주중 1 주차</target>
        </trans-unit>
        <trans-unit id="61c045f9f24b3b90a55c9f64fb89b4cf33f3dbdd" translate="yes" xml:space="preserve">
          <source>Week 2 of 2009</source>
          <target state="translated">2009 년 2 주</target>
        </trans-unit>
        <trans-unit id="16159932e1ca3544ef8dd1d77e4cd53b696ac5c6" translate="yes" xml:space="preserve">
          <source>Week 2 of January 2009</source>
          <target state="translated">2009 년 1 월 2 주</target>
        </trans-unit>
        <trans-unit id="651b78362b5aaa1728d942efc5ee0ee574ce4c00" translate="yes" xml:space="preserve">
          <source>Week 2 of week-based-year 2009</source>
          <target state="translated">2009 년 주중 2 주차</target>
        </trans-unit>
        <trans-unit id="fc5ccf6381813c151159e75357417f783c0aec41" translate="yes" xml:space="preserve">
          <source>Week 5 of December 2008</source>
          <target state="translated">2008 년 12 월 5 주</target>
        </trans-unit>
        <trans-unit id="a6c2f210f4569dac04f3823e9662a42bc6ce2da1" translate="yes" xml:space="preserve">
          <source>Week 52 of week-based-year 2008</source>
          <target state="translated">2008 년 주별 52 주</target>
        </trans-unit>
        <trans-unit id="de9cd5103d931eb33add540394a1f571fcdcca10" translate="yes" xml:space="preserve">
          <source>Week 53 of 2008</source>
          <target state="translated">2008 년 53 주</target>
        </trans-unit>
        <trans-unit id="6c46029aa17fb600a21cad6bd08e77301e063307" translate="yes" xml:space="preserve">
          <source>Week Based Year</source>
          <target state="translated">주별 연도</target>
        </trans-unit>
        <trans-unit id="0fcbe34401d64884bb36657832164bedeaa60659" translate="yes" xml:space="preserve">
          <source>Week Of Month</source>
          <target state="translated">달의 주</target>
        </trans-unit>
        <trans-unit id="f295af822500a48f0431b7b363da9a13a414b828" translate="yes" xml:space="preserve">
          <source>Week Of Year and Week Year</source>
          <target state="translated">올해의 주와 주</target>
        </trans-unit>
        <trans-unit id="cf20b17dedbd2fa061bb084e6e427c23883b04dc" translate="yes" xml:space="preserve">
          <source>Week based years</source>
          <target state="translated">주별 년</target>
        </trans-unit>
        <trans-unit id="89443bf2616153b1df032a1eb1df761e955b11a3" translate="yes" xml:space="preserve">
          <source>Week in month</source>
          <target state="translated">달의 주</target>
        </trans-unit>
        <trans-unit id="cadc38e9abe6dd9dd6fcc84c98869fbd77cea946" translate="yes" xml:space="preserve">
          <source>Week in year</source>
          <target state="translated">연중 주</target>
        </trans-unit>
        <trans-unit id="66de1cb2f3c93d7fd3d3a0a272c173e1b5c911b9" translate="yes" xml:space="preserve">
          <source>Week of Month</source>
          <target state="translated">이달의 주</target>
        </trans-unit>
        <trans-unit id="d6c62cdc6501a8ecf111466d9a326e871d8b8b6e" translate="yes" xml:space="preserve">
          <source>Week of Year</source>
          <target state="translated">올해의 주</target>
        </trans-unit>
        <trans-unit id="c19474894e0551ed2105ef8e4012a429b6bad40c" translate="yes" xml:space="preserve">
          <source>Week one (1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the month. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the month. If the first week starts after the start of the month then the period before is week zero (0).</source>
          <target state="translated">Week one (1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt; days in the month. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the month. If the first week starts after the start of the month then the period before is week zero (0).</target>
        </trans-unit>
        <trans-unit id="74d6db712bf03a49e67556ff1aec1f683642d8c2" translate="yes" xml:space="preserve">
          <source>Week one (1) is the week starting on the &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the month. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the month. If the first week starts after the start of the month then the period before is week zero (0).</source>
          <target state="translated">첫째 주 (1)는 &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt; 에서 시작하여 그 달 에 최소한 &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt; 일이있는 주입니다. 따라서 &lt;code&gt;minDays&lt;/code&gt; 주는 매월 시작하기 최소 min 일 전까지 시작할 수 있습니다 . 월이 시작된 후 첫 번째 주가 시작되면 이전 기간은 0 주입니다.</target>
        </trans-unit>
        <trans-unit id="12d77cb8838ad5fb792309f27517ce73b66b3ed1" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</source>
          <target state="translated">Week one(1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt; days in the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</target>
        </trans-unit>
        <trans-unit id="ceffe96a6e332c6dd3063a343f6124a6b5ee6477" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. Thus, week one may start before the start of the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</source>
          <target state="translated">Week one(1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt; days in the year. Thus, week one may start before the start of the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</target>
        </trans-unit>
        <trans-unit id="4f6f45d858ed4016de445396b12998ca4b8aad27" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the year. If the first week starts after the start of the year then the period before is week zero (0).</source>
          <target state="translated">Week one(1) is the week starting on the &lt;a href=&quot;#getFirstDayOfWeek()&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt; where there are at least &lt;a href=&quot;#getMinimalDaysInFirstWeek()&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt; days in the year. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the year. If the first week starts after the start of the year then the period before is week zero (0).</target>
        </trans-unit>
        <trans-unit id="44f1f99446cb5330dbad01f12f044f5a225971e2" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</source>
          <target state="translated">1 주차 (1)는 &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt; 에서 시작 하여 그해 에 적어도 &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt; 일이있는 주입니다. 첫 번째 주가 연도가 시작된 후 시작되면 이전 기간은 전년도 마지막 주입니다.</target>
        </trans-unit>
        <trans-unit id="59d424ddfaa661a922cb86607e9a3548d6b3e08f" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. Thus, week one may start before the start of the year. If the first week starts after the start of the year then the period before is in the last week of the previous year.</source>
          <target state="translated">1 주차 (1)는 &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt; 에서 시작 하여 그해 에 적어도 &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt; 일이있는 주입니다. 따라서 1 주차는 연초 전에 시작될 수 있습니다. 첫 번째 주가 연도가 시작된 후 시작되면 이전 기간은 전년도 마지막 주입니다.</target>
        </trans-unit>
        <trans-unit id="edf457af9ac86c639d6fa25a82d99903848d2cc3" translate="yes" xml:space="preserve">
          <source>Week one(1) is the week starting on the &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt;&lt;code&gt;getFirstDayOfWeek()&lt;/code&gt;&lt;/a&gt; where there are at least &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt;&lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt;&lt;/a&gt; days in the year. Thus, week one may start up to &lt;code&gt;minDays&lt;/code&gt; days before the start of the year. If the first week starts after the start of the year then the period before is week zero (0).</source>
          <target state="translated">1 주차 (1)는 &lt;a href=&quot;weekfields#getFirstDayOfWeek--&quot;&gt; &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; &lt;/a&gt; 에서 시작 하여 그해 에 적어도 &lt;a href=&quot;weekfields#getMinimalDaysInFirstWeek--&quot;&gt; &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; &lt;/a&gt; 일이있는 주입니다. 따라서 1 주차 는 연도가 시작되기 &lt;code&gt;minDays&lt;/code&gt; 일 전까지 시작할 수 있습니다 . 첫 번째 주가 연도가 시작된 후 시작되면 이전 기간은 0 주입니다.</target>
        </trans-unit>
        <trans-unit id="21523175d42396f1b83a7d224bcef6c78db04431" translate="yes" xml:space="preserve">
          <source>Week year</source>
          <target state="translated">주년</target>
        </trans-unit>
        <trans-unit id="0f3cd7a23e2be7e3002b8bffb3ed9ec37177e7b2" translate="yes" xml:space="preserve">
          <source>WeekFields</source>
          <target state="translated">WeekFields</target>
        </trans-unit>
        <trans-unit id="22700d348b3e11d9fd6613090889ec190de727aa" translate="yes" xml:space="preserve">
          <source>WeekFields instances are singletons; for each unique combination of &lt;code&gt;firstDayOfWeek&lt;/code&gt; and &lt;code&gt;minimalDaysInFirstWeek&lt;/code&gt; the same instance will be returned.</source>
          <target state="translated">WeekFields instances are singletons; for each unique combination of &lt;code&gt;firstDayOfWeek&lt;/code&gt; and &lt;code&gt;minimalDaysInFirstWeek&lt;/code&gt; the same instance will be returned.</target>
        </trans-unit>
        <trans-unit id="718dae35ec7f29671d329f016891913ac6dd0953" translate="yes" xml:space="preserve">
          <source>WeekFields instances are singletons; for each unique combination of &lt;code&gt;firstDayOfWeek&lt;/code&gt; and &lt;code&gt;minimalDaysInFirstWeek&lt;/code&gt; the the same instance will be returned.</source>
          <target state="translated">WeekFields 인스턴스는 싱글 톤입니다. &lt;code&gt;firstDayOfWeek&lt;/code&gt; 와 &lt;code&gt;minimalDaysInFirstWeek&lt;/code&gt; 의 고유 한 조합마다 동일한 인스턴스가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="44d5d3a1e1dee13721fd9eb305d4686b3f9e55b7" translate="yes" xml:space="preserve">
          <source>WeekFields provides five fields, &lt;a href=&quot;#dayOfWeek()&quot;&gt;&lt;code&gt;dayOfWeek()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#weekOfMonth()&quot;&gt;&lt;code&gt;weekOfMonth()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#weekOfYear()&quot;&gt;&lt;code&gt;weekOfYear()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#weekOfWeekBasedYear()&quot;&gt;&lt;code&gt;weekOfWeekBasedYear()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#weekBasedYear()&quot;&gt;&lt;code&gt;weekBasedYear()&lt;/code&gt;&lt;/a&gt; that provide access to the values from any &lt;a href=&quot;temporal&quot;&gt;temporal object&lt;/a&gt;.</source>
          <target state="translated">WeekFields provides five fields, &lt;a href=&quot;#dayOfWeek()&quot;&gt; &lt;code&gt;dayOfWeek()&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#weekOfMonth()&quot;&gt; &lt;code&gt;weekOfMonth()&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#weekOfYear()&quot;&gt; &lt;code&gt;weekOfYear()&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#weekOfWeekBasedYear()&quot;&gt; &lt;code&gt;weekOfWeekBasedYear()&lt;/code&gt; &lt;/a&gt;, and &lt;a href=&quot;#weekBasedYear()&quot;&gt; &lt;code&gt;weekBasedYear()&lt;/code&gt; &lt;/a&gt; that provide access to the values from any &lt;a href=&quot;temporal&quot;&gt;temporal object&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="89a2292f88acbc8f0e38aee8edbc776ed1156087" translate="yes" xml:space="preserve">
          <source>WeekFields provides five fields, &lt;a href=&quot;weekfields#dayOfWeek--&quot;&gt;&lt;code&gt;dayOfWeek()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weekfields#weekOfMonth--&quot;&gt;&lt;code&gt;weekOfMonth()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weekfields#weekOfYear--&quot;&gt;&lt;code&gt;weekOfYear()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weekfields#weekOfWeekBasedYear--&quot;&gt;&lt;code&gt;weekOfWeekBasedYear()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;weekfields#weekBasedYear--&quot;&gt;&lt;code&gt;weekBasedYear()&lt;/code&gt;&lt;/a&gt; that provide access to the values from any &lt;a href=&quot;temporal&quot;&gt;temporal object&lt;/a&gt;.</source>
          <target state="translated">WeekFields는 모든 &lt;a href=&quot;temporal&quot;&gt;임시 객체&lt;/a&gt; 의 값에 액세스 할 수있는 &lt;a href=&quot;weekfields#dayOfWeek--&quot;&gt; &lt;code&gt;dayOfWeek()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;weekfields#weekOfMonth--&quot;&gt; &lt;code&gt;weekOfMonth()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;weekfields#weekOfYear--&quot;&gt; &lt;code&gt;weekOfYear()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;weekfields#weekOfWeekBasedYear--&quot;&gt; &lt;code&gt;weekOfWeekBasedYear()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;weekfields#weekBasedYear--&quot;&gt; &lt;code&gt;weekBasedYear()&lt;/code&gt; &lt;/a&gt; 5 개의 필드 를 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="6cb3080d6ff8341db52a2cdfe428e6fe7cfdc77d" translate="yes" xml:space="preserve">
          <source>WeekFields.dayOfWeek()</source>
          <target state="translated">WeekFields.dayOfWeek()</target>
        </trans-unit>
        <trans-unit id="63de50e0e26b59f3d9fe368fff1375c932f6dc68" translate="yes" xml:space="preserve">
          <source>WeekFields.equals()</source>
          <target state="translated">WeekFields.equals()</target>
        </trans-unit>
        <trans-unit id="307be796ddd4af18d3ea219c21738d280f71a9f6" translate="yes" xml:space="preserve">
          <source>WeekFields.getFirstDayOfWeek()</source>
          <target state="translated">WeekFields.getFirstDayOfWeek()</target>
        </trans-unit>
        <trans-unit id="9eb1a32786064c34464f305adb94564c93fc3d6a" translate="yes" xml:space="preserve">
          <source>WeekFields.getMinimalDaysInFirstWeek()</source>
          <target state="translated">WeekFields.getMinimalDaysInFirstWeek()</target>
        </trans-unit>
        <trans-unit id="0f4344dbb38df7c1dd4475092ee3cc1b31b7a1dc" translate="yes" xml:space="preserve">
          <source>WeekFields.hashCode()</source>
          <target state="translated">WeekFields.hashCode()</target>
        </trans-unit>
        <trans-unit id="f5a7902f43adfba0ce22ee041b83a1d8e9b00d05" translate="yes" xml:space="preserve">
          <source>WeekFields.of()</source>
          <target state="translated">WeekFields.of()</target>
        </trans-unit>
        <trans-unit id="0d111eab407e09a34fda6c1f334ea981ad02f8d3" translate="yes" xml:space="preserve">
          <source>WeekFields.toString()</source>
          <target state="translated">WeekFields.toString()</target>
        </trans-unit>
        <trans-unit id="f7d24644a2eae9dfbf214b9d12aa277c6a89292c" translate="yes" xml:space="preserve">
          <source>WeekFields.weekBasedYear()</source>
          <target state="translated">WeekFields.weekBasedYear()</target>
        </trans-unit>
        <trans-unit id="6ed8a499946db10836e56570eaad12d34de1b1e4" translate="yes" xml:space="preserve">
          <source>WeekFields.weekOfMonth()</source>
          <target state="translated">WeekFields.weekOfMonth()</target>
        </trans-unit>
        <trans-unit id="f94cf8e74a33d036b43c60e0a361b7ab911bc24a" translate="yes" xml:space="preserve">
          <source>WeekFields.weekOfWeekBasedYear()</source>
          <target state="translated">WeekFields.weekOfWeekBasedYear()</target>
        </trans-unit>
        <trans-unit id="2788abb8d6fe59a50dbde8e26f797c0be24e8bc7" translate="yes" xml:space="preserve">
          <source>WeekFields.weekOfYear()</source>
          <target state="translated">WeekFields.weekOfYear()</target>
        </trans-unit>
        <trans-unit id="7d75266a53b99ce4d80d337862ea1edd8ba1b1a1" translate="yes" xml:space="preserve">
          <source>Weeks</source>
          <target state="translated">Weeks</target>
        </trans-unit>
        <trans-unit id="8df986efff37f1cf0680e8b945fdb0be0bb07b78" translate="yes" xml:space="preserve">
          <source>Weight is the overall 'weight' of the glyph in the line. Generally it is proportional to the size of the font. Glyphs with larger weight are allocated a correspondingly larger amount of the change in space.</source>
          <target state="translated">Weight is the overall 'weight' of the glyph in the line. Generally it is proportional to the size of the font. Glyphs with larger weight are allocated a correspondingly larger amount of the change in space.</target>
        </trans-unit>
        <trans-unit id="20ac2f25a966eb781339ca5e0fe0f7f875b9cfc8" translate="yes" xml:space="preserve">
          <source>Well known port for registry.</source>
          <target state="translated">Well known port for registry.</target>
        </trans-unit>
        <trans-unit id="b5ceaaaab5693bd089df6a3f31655e313dce3989" translate="yes" xml:space="preserve">
          <source>Well-formed country/region values have the form &lt;code&gt;[a-zA-Z]{2} | [0-9]{3}&lt;/code&gt;</source>
          <target state="translated">올바른 형식의 국가 / 지역 값은 &lt;code&gt;[a-zA-Z]{2} | [0-9]{3}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0fe9a9ddb38f6c4d512e9dbb79376b8ca30e2bf0" translate="yes" xml:space="preserve">
          <source>Well-formed keys are single characters from the set &lt;code&gt;[0-9a-zA-Z]&lt;/code&gt;. Well-formed values have the form &lt;code&gt;SUBTAG ('-' SUBTAG)*&lt;/code&gt; where for the key 'x' &lt;code&gt;SUBTAG = [0-9a-zA-Z]{1,8}&lt;/code&gt; and for other keys &lt;code&gt;SUBTAG = [0-9a-zA-Z]{2,8}&lt;/code&gt; (that is, 'x' allows single-character subtags).</source>
          <target state="translated">올바른 형식의 키는 세트 &lt;code&gt;[0-9a-zA-Z]&lt;/code&gt; 의 단일 문자입니다 . &lt;code&gt;SUBTAG ('-' SUBTAG)*&lt;/code&gt; 형식의 값은 SUBTAG ( '-'SUBTAG) * 형식입니다. 여기서 ' &lt;code&gt;SUBTAG = [0-9a-zA-Z]{1,8}&lt;/code&gt; 및 기타 키 &lt;code&gt;SUBTAG = [0-9a-zA-Z]{2,8}&lt;/code&gt; (즉, 'x'는 단일 문자 하위 태그를 허용합니다).</target>
        </trans-unit>
        <trans-unit id="6162cb572cd0fa07269f9f853edbaab78da2fbaa" translate="yes" xml:space="preserve">
          <source>Well-formed language values have the form &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt;. Note that this is not the full BCP47 language production, since it excludes extlang. They are not needed since modern three-letter language codes replace them.</source>
          <target state="translated">Well-formed language values have the form &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt; . Note that this is not the full BCP47 language production, since it excludes extlang. They are not needed since modern three-letter language codes replace them.</target>
        </trans-unit>
        <trans-unit id="a50506c60f4a43fce22721c5603adee4e842c36f" translate="yes" xml:space="preserve">
          <source>Well-formed language values have the form &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt;. Note that this is not the the full BCP47 language production, since it excludes extlang. They are not needed since modern three-letter language codes replace them.</source>
          <target state="translated">올바른 형식의 언어 값은 &lt;code&gt;[a-zA-Z]{2,8}&lt;/code&gt; 형식 입니다. 이것은 extlang을 제외하기 때문에 전체 BCP47 언어 제작이 아닙니다. 현대의 3 문자 언어 코드로 대체되므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="858fa2509ca423136e7cf31f512c6eefb90eeb81" translate="yes" xml:space="preserve">
          <source>Well-formed script values have the form &lt;code&gt;[a-zA-Z]{4}&lt;/code&gt;</source>
          <target state="translated">올바른 형식의 스크립트 값은 &lt;code&gt;[a-zA-Z]{4}&lt;/code&gt; 형식입니다.</target>
        </trans-unit>
        <trans-unit id="f4d5d35b51d9cbb55387c8e6d28bc1a22d820b0a" translate="yes" xml:space="preserve">
          <source>Well-formed variant values have the form &lt;code&gt;SUBTAG
   (('_'|'-') SUBTAG)*&lt;/code&gt; where &lt;code&gt;SUBTAG =
   [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}&lt;/code&gt;. (Note: BCP 47 only uses hyphen ('-') as a delimiter, this is more lenient).</source>
          <target state="translated">&lt;code&gt;SUBTAG (('_'|'-') SUBTAG)*&lt;/code&gt; 형식의 변형 값은 SUBTAG (( '_'| '-') SUBTAG) * 형식입니다. 여기서 &lt;code&gt;SUBTAG = [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}&lt;/code&gt; . (참고 : BCP 47은 구분 기호로 하이픈 ( '-') 만 사용하므로보다 관대합니다.)</target>
        </trans-unit>
        <trans-unit id="ce95843c87158992b2858d825f7a237360e6b63f" translate="yes" xml:space="preserve">
          <source>West pane</source>
          <target state="translated">West pane</target>
        </trans-unit>
        <trans-unit id="c9e4b6efb7854b9fa304410f366631e4c9b775f3" translate="yes" xml:space="preserve">
          <source>What is an Attribute?</source>
          <target state="translated">속성이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="301ddf4fd686c9921c42e78bd43366e889d8837c" translate="yes" xml:space="preserve">
          <source>What is the offset along the minor axis</source>
          <target state="translated">What is the offset along the minor axis</target>
        </trans-unit>
        <trans-unit id="c587c6fc95a9107db0097d9b15fd1d5ffc2e7330" translate="yes" xml:space="preserve">
          <source>What is the span along the major axis.</source>
          <target state="translated">What is the span along the major axis.</target>
        </trans-unit>
        <trans-unit id="8dbf8f4ff843b6789ff963d498444a2edfc85fed" translate="yes" xml:space="preserve">
          <source>What is the span along the minor axis.</source>
          <target state="translated">What is the span along the minor axis.</target>
        </trans-unit>
        <trans-unit id="e1253f057c65c5140688cb6f74eaff535608ffb8" translate="yes" xml:space="preserve">
          <source>What operation was being attempted when a conflict occurred</source>
          <target state="translated">What operation was being attempted when a conflict occurred</target>
        </trans-unit>
        <trans-unit id="3dc6bced115a4ebb63076f833d6f3f46734f7360" translate="yes" xml:space="preserve">
          <source>What the &lt;code&gt;java.sql&lt;/code&gt; Package Contains</source>
          <target state="translated">What the &lt;code&gt;java.sql&lt;/code&gt; Package Contains</target>
        </trans-unit>
        <trans-unit id="dae0b4b4d87d6d1381813d3114a08a7d3cf1d6f4" translate="yes" xml:space="preserve">
          <source>What the JDBC&amp;trade; 4.3 API Includes</source>
          <target state="translated">What the JDBC&amp;trade; 4.3 API Includes</target>
        </trans-unit>
        <trans-unit id="f523aaaa18b102076687e4244d4e07bb6f436a11" translate="yes" xml:space="preserve">
          <source>What the Permission Allows</source>
          <target state="translated">권한이 허용하는 것</target>
        </trans-unit>
        <trans-unit id="373c94003a259747dc5ca0b92f838b2b5acf5d59" translate="yes" xml:space="preserve">
          <source>What this means is that the ClassLoader may be wrapped in another ClassLoader for security or other reasons.</source>
          <target state="translated">이것은 보안 또는 다른 이유로 ClassLoader가 다른 ClassLoader에 래핑 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ca20440fd173e3537d3dbdf1472c311d148f0f89" translate="yes" xml:space="preserve">
          <source>What's returned by &lt;code&gt;AccessibleJEditorPaneHTML.getAccessibleText&lt;/code&gt;.</source>
          <target state="translated">What's returned by &lt;code&gt;AccessibleJEditorPaneHTML.getAccessibleText&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caf5d2a20376b8ede2618bea6b71d51812f11949" translate="yes" xml:space="preserve">
          <source>What's returned by &lt;code&gt;AccessibleJEditorPaneHTML.getAccessibleText&lt;/code&gt;. Provides support for &lt;code&gt;AccessibleHypertext&lt;/code&gt; in case there is an HTML document being displayed in this &lt;code&gt;JEditorPane&lt;/code&gt;.</source>
          <target state="translated">What's returned by &lt;code&gt;AccessibleJEditorPaneHTML.getAccessibleText&lt;/code&gt; . Provides support for &lt;code&gt;AccessibleHypertext&lt;/code&gt; in case there is an HTML document being displayed in this &lt;code&gt;JEditorPane&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c62f541df771dc9c17e6db7806198f01ce3df87" translate="yes" xml:space="preserve">
          <source>Whatever the</source>
          <target state="translated">무엇이든</target>
        </trans-unit>
        <trans-unit id="89357495a0b5512bbc9f5bc66b16ee57716aba68" translate="yes" xml:space="preserve">
          <source>Whatever the &lt;a href=&quot;#groupname&quot;&gt;named-capturing group&lt;/a&gt; &quot;name&quot; matched</source>
          <target state="translated">무엇이든 &lt;a href=&quot;#groupname&quot;&gt;명명 된 캡처 그룹&lt;/a&gt; &quot;name&quot;이 (가) 일치하는</target>
        </trans-unit>
        <trans-unit id="183f14f8a35d4f7ed23e203448b1fd0af728304e" translate="yes" xml:space="preserve">
          <source>When 'value' is no longer valid then the getter method is invoked for the attribute. The 'lastUpdatedTimeStamp' field and `value' fields are updated.</source>
          <target state="translated">'value'가 더 이상 유효하지 않으면 속성에 대해 getter 메소드가 호출됩니다. 'lastUpdatedTimeStamp'필드와 'value'필드가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="c20d6596c0516c20ee93280ced0b8c1583308051" translate="yes" xml:space="preserve">
          <source>When 'value' is no longer valid then the operation method is invoked. The 'lastUpdatedTimeStamp' field and `value' fields are updated.</source>
          <target state="translated">'value'가 더 이상 유효하지 않으면 조작 메소드가 호출됩니다. 'lastUpdatedTimeStamp'필드와 'value'필드가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="7ad7cf61a538ac9682cd9c38c51af1051f6daf5e" translate="yes" xml:space="preserve">
          <source>When 'value' is valid, 'value' is returned.</source>
          <target state="translated">'value'가 유효하면 'value'가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7333d8d0058642dce5b6ba018287a61a8e12ae52" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt; is called, a listener is selected if it was added with a null &lt;a href=&quot;notificationfilter&quot;&gt;&lt;code&gt;NotificationFilter&lt;/code&gt;&lt;/a&gt;, or if &lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; returns true for the notification being sent. The call to &lt;code&gt;NotificationFilter.isNotificationEnabled&lt;/code&gt; takes place in the thread that called &lt;code&gt;sendNotification&lt;/code&gt;. Then, for each selected listener, &lt;a href=&quot;../../../java.base/java/util/concurrent/executor#execute(java.lang.Runnable)&quot;&gt;&lt;code&gt;executor.execute&lt;/code&gt;&lt;/a&gt; is called with a command that calls the &lt;code&gt;handleNotification&lt;/code&gt; method.</source>
          <target state="translated">When &lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt; is called, a listener is selected if it was added with a null &lt;a href=&quot;notificationfilter&quot;&gt; &lt;code&gt;NotificationFilter&lt;/code&gt; &lt;/a&gt;, or if &lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt; returns true for the notification being sent. The call to &lt;code&gt;NotificationFilter.isNotificationEnabled&lt;/code&gt; takes place in the thread that called &lt;code&gt;sendNotification&lt;/code&gt; . Then, for each selected listener, &lt;a href=&quot;../../../java.base/java/util/concurrent/executor#execute(java.lang.Runnable)&quot;&gt; &lt;code&gt;executor.execute&lt;/code&gt; &lt;/a&gt; is called with a command that calls the &lt;code&gt;handleNotification&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="720701165d46b861473379cd54f2570d2c747f20" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#value-field&quot;&gt;value&lt;/a&gt; was set.</source>
          <target state="translated">&lt;a href=&quot;#value-field&quot;&gt;가치가&lt;/a&gt; 있을 때 이 설정</target>
        </trans-unit>
        <trans-unit id="2787518abc9792a673e362e95dc630f0312e2d2c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#waitFor()&quot;&gt;&lt;code&gt;waitFor()&lt;/code&gt;&lt;/a&gt; returns successfully the CompletableFuture is &lt;a href=&quot;../util/concurrent/completablefuture#complete(T)&quot;&gt;completed&lt;/a&gt; regardless of the exit status of the process. This implementation may consume a lot of memory for thread stacks if a large number of processes are waited for concurrently.</source>
          <target state="translated">When &lt;a href=&quot;#waitFor()&quot;&gt; &lt;code&gt;waitFor()&lt;/code&gt; &lt;/a&gt; returns successfully the CompletableFuture is &lt;a href=&quot;../util/concurrent/completablefuture#complete(T)&quot;&gt;completed&lt;/a&gt; regardless of the exit status of the process. This implementation may consume a lot of memory for thread stacks if a large number of processes are waited for concurrently.</target>
        </trans-unit>
        <trans-unit id="0b41c0f3ed6f8adeecdcc86bb85da400ea38c18d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;../../../org/xml/sax/contenthandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)&quot;&gt;&lt;code&gt;ContentHandler.startElement(String, String, String, Attributes)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../org/xml/sax/contenthandler#endElement(java.lang.String,java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;ContentHandler.endElement(String, String, String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../../org/xml/sax/contenthandler#startDocument()&quot;&gt;&lt;code&gt;ContentHandler.startDocument()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../../org/xml/sax/contenthandler#endDocument()&quot;&gt;&lt;code&gt;ContentHandler.endDocument()&lt;/code&gt;&lt;/a&gt; are invoked on a &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt;, the same method on the user-specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; must be invoked for the same event before the callback returns.</source>
          <target state="translated">When &lt;a href=&quot;../../../org/xml/sax/contenthandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)&quot;&gt; &lt;code&gt;ContentHandler.startElement(String, String, String, Attributes)&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;../../../org/xml/sax/contenthandler#endElement(java.lang.String,java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;ContentHandler.endElement(String, String, String)&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;../../../org/xml/sax/contenthandler#startDocument()&quot;&gt; &lt;code&gt;ContentHandler.startDocument()&lt;/code&gt; &lt;/a&gt;, or &lt;a href=&quot;../../../org/xml/sax/contenthandler#endDocument()&quot;&gt; &lt;code&gt;ContentHandler.endDocument()&lt;/code&gt; &lt;/a&gt; are invoked on a &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;, the same method on the user-specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt; must be invoked for the same event before the callback returns.</target>
        </trans-unit>
        <trans-unit id="eb0c4944d21938573c8de12446d041f26931fa10" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt; is called, a listener is selected if it was added with a null &lt;a href=&quot;notificationfilter&quot;&gt;&lt;code&gt;NotificationFilter&lt;/code&gt;&lt;/a&gt;, or if &lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; returns true for the notification being sent. The call to &lt;code&gt;NotificationFilter.isNotificationEnabled&lt;/code&gt; takes place in the thread that called &lt;code&gt;sendNotification&lt;/code&gt;. Then, for each selected listener, &lt;a href=&quot;../../java/util/concurrent/executor#execute-java.lang.Runnable-&quot;&gt;&lt;code&gt;executor.execute&lt;/code&gt;&lt;/a&gt; is called with a command that calls the &lt;code&gt;handleNotification&lt;/code&gt; method.</source>
          <target state="translated">&lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt; 이 호출 될 때 리스너가 null &lt;a href=&quot;notificationfilter&quot;&gt; &lt;code&gt;NotificationFilter&lt;/code&gt; &lt;/a&gt; 와 함께 추가 되었거나 &lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt; 가 전송되는 알림에 대해 true를 리턴 하면 리스너가 선택됩니다 . &lt;code&gt;NotificationFilter.isNotificationEnabled&lt;/code&gt; 호출 은 &lt;code&gt;sendNotification&lt;/code&gt; 이라는 스레드에서 발생합니다 . 그런 다음 선택한 각 리스너에 대해 &lt;code&gt;handleNotification&lt;/code&gt; 을 호출하는 명령으로 &lt;a href=&quot;../../java/util/concurrent/executor#execute-java.lang.Runnable-&quot;&gt; &lt;code&gt;executor.execute&lt;/code&gt; &lt;/a&gt; 가 호출됩니다. 메소드 .</target>
        </trans-unit>
        <trans-unit id="ca53de9dd5a05f67d73beacc0a06e218c4b8b4f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;FRACTIONALMETRICS&lt;/code&gt; are enabled, the true font design metrics are scaled by the point size and used for layout with sub-pixel accuracy. The average density of glyphs and total length of a long string of characters will therefore more closely match the theoretical design of the font, but readability may be affected since individual pairs of characters may not always appear to be consistent distances apart depending on how the sub-pixel accumulation of the glyph origins meshes with the device pixel grid. Enabling this hint may be desirable when text layout is being performed that must be consistent across a wide variety of output resolutions. Specifically, this hint may be desirable in situations where the layout of text is being previewed on a low resolution device like a screen for output that will eventually be rendered on a high resolution printer or typesetting device.</source>
          <target state="translated">When &lt;code&gt;FRACTIONALMETRICS&lt;/code&gt; are enabled, the true font design metrics are scaled by the point size and used for layout with sub-pixel accuracy. The average density of glyphs and total length of a long string of characters will therefore more closely match the theoretical design of the font, but readability may be affected since individual pairs of characters may not always appear to be consistent distances apart depending on how the sub-pixel accumulation of the glyph origins meshes with the device pixel grid. Enabling this hint may be desirable when text layout is being performed that must be consistent across a wide variety of output resolutions. Specifically, this hint may be desirable in situations where the layout of text is being previewed on a low resolution device like a screen for output that will eventually be rendered on a high resolution printer or typesetting device.</target>
        </trans-unit>
        <trans-unit id="3907f83b19a6bc999820d92454ce9500f2d86571" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SSLSocket&lt;/code&gt;s are first created, no handshaking is done so that applications may first set their communication preferences: what cipher suites to use, whether the socket should be in client or server mode, etc. However, security is always provided by the time that application data is sent over the connection.</source>
          <target state="translated">때 &lt;code&gt;SSLSocket&lt;/code&gt; 소켓 그러나 보안은 항상 시간이에 의해 제공되는 클라이언트 또는 서버 모드 등으로 수 있는지 여부, 사용에 어떤 암호 스위트 : S가 먼저 만들어지고 더 핸드 쉐이크는 응용 프로그램이 먼저 통신 환경을 설정할 수 있도록 수행되지 않습니다 응용 프로그램 데이터가 연결을 통해 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2865b5a1279039e3aa9655c29d186fd9156ffb33" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SecurityManager&lt;/code&gt; is installed, the invoking thread must be granted this permission in order to replace the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt;. If permission is not granted, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</source>
          <target state="translated">When &lt;code&gt;SecurityManager&lt;/code&gt; is installed, the invoking thread must be granted this permission in order to replace the current &lt;code&gt;KeyboardFocusManager&lt;/code&gt; . If permission is not granted, a &lt;code&gt;SecurityException&lt;/code&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="aec348ffd93df939ed7064797ce4b1223e7792d9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; attempts to install the newly computed value, if the state is still at &lt;code&gt;2N&lt;/code&gt;, the class value will be initialized with the computed value, advancing it to state &lt;code&gt;2N+1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 새로 계산 된 값을 설치하려고 할 때 상태가 여전히 &lt;code&gt;2N&lt;/code&gt; 이면 클래스 값은 계산 된 값으로 초기화되어 상태를 &lt;code&gt;2N+1&lt;/code&gt; 상태로 진행 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f789b0022722a1185a4c15638dba2438089f1c62" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;jdk.io.permissionsUseCanonicalPath&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, an invalid &lt;code&gt;FilePermission&lt;/code&gt; does not equal to any object except for itself, even if they are created using the same invalid path.</source>
          <target state="translated">When &lt;code&gt;jdk.io.permissionsUseCanonicalPath&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; , an invalid &lt;code&gt;FilePermission&lt;/code&gt; does not equal to any object except for itself, even if they are created using the same invalid path.</target>
        </trans-unit>
        <trans-unit id="586cdea8cb0e9df3dba6780f86611e27368352ca" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;myButton&lt;/code&gt; is pressed, the statement &lt;code&gt;frame.toFront()&lt;/code&gt; will be executed. One could get the same effect, with some additional compile-time type safety, by defining a new implementation of the &lt;code&gt;ActionListener&lt;/code&gt; interface and adding an instance of it to the button:</source>
          <target state="translated">때 &lt;code&gt;myButton&lt;/code&gt; 누르면 문 &lt;code&gt;frame.toFront()&lt;/code&gt; 이 실행됩니다. &lt;code&gt;ActionListener&lt;/code&gt; 인터페이스 의 새로운 구현을 정의하고 그 인스턴스를 버튼에 추가함으로써 추가적인 컴파일 타임 유형 안전을 통해 동일한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0904a47635f2e7b7777a12e80e944727838b0aa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;remove&lt;/code&gt; or &lt;code&gt;insertString&lt;/code&gt; is invoked on the &lt;code&gt;DocumentFilter&lt;/code&gt;, the &lt;code&gt;DocumentFilter&lt;/code&gt; may callback into the &lt;code&gt;FilterBypass&lt;/code&gt; multiple times, or for different regions, but it should not callback into the &lt;code&gt;FilterBypass&lt;/code&gt; after returning from the &lt;code&gt;remove&lt;/code&gt; or &lt;code&gt;insertString&lt;/code&gt; method.</source>
          <target state="translated">When &lt;code&gt;remove&lt;/code&gt; or &lt;code&gt;insertString&lt;/code&gt; is invoked on the &lt;code&gt;DocumentFilter&lt;/code&gt; , the &lt;code&gt;DocumentFilter&lt;/code&gt; may callback into the &lt;code&gt;FilterBypass&lt;/code&gt; multiple times, or for different regions, but it should not callback into the &lt;code&gt;FilterBypass&lt;/code&gt; after returning from the &lt;code&gt;remove&lt;/code&gt; or &lt;code&gt;insertString&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="b7b9af0e4285748c91632c575b592ae96d9c9970" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setAutoCreateRowSorter(true)&lt;/code&gt; is invoked, a &lt;code&gt;
 TableRowSorter&lt;/code&gt; is immediately created and installed on the table. While the &lt;code&gt;autoCreateRowSorter&lt;/code&gt; property remains &lt;code&gt;true&lt;/code&gt;, every time the model is changed, a new &lt;code&gt;
 TableRowSorter&lt;/code&gt; is created and set as the table's row sorter. The default value for the &lt;code&gt;autoCreateRowSorter&lt;/code&gt; property is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">When &lt;code&gt;setAutoCreateRowSorter(true)&lt;/code&gt; is invoked, a &lt;code&gt; TableRowSorter&lt;/code&gt; is immediately created and installed on the table. While the &lt;code&gt;autoCreateRowSorter&lt;/code&gt; property remains &lt;code&gt;true&lt;/code&gt; , every time the model is changed, a new &lt;code&gt; TableRowSorter&lt;/code&gt; is created and set as the table's row sorter. The default value for the &lt;code&gt;autoCreateRowSorter&lt;/code&gt; property is &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcc753ccd7f4f147341d78ae6bbdfd159682020f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setMaximum&lt;/code&gt; is called, the maximum value is changed, and other values (including the minimum, the visible amount, and the current scroll bar value) are changed to be consistent with the new maximum.</source>
          <target state="translated">When &lt;code&gt;setMaximum&lt;/code&gt; is called, the maximum value is changed, and other values (including the minimum, the visible amount, and the current scroll bar value) are changed to be consistent with the new maximum.</target>
        </trans-unit>
        <trans-unit id="634dff626ecd014481529c2d6290cf015b2f06a2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setMinimum&lt;/code&gt; is called, the minimum value is changed, and other values (including the maximum, the visible amount, and the current scroll bar value) are changed to be consistent with the new minimum.</source>
          <target state="translated">When &lt;code&gt;setMinimum&lt;/code&gt; is called, the minimum value is changed, and other values (including the maximum, the visible amount, and the current scroll bar value) are changed to be consistent with the new minimum.</target>
        </trans-unit>
        <trans-unit id="6366d90e5b77dc1a2fecffb2e332c4bd6f6dd999" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;setValue&lt;/code&gt; is called on the sum spring, &lt;code&gt;s3&lt;/code&gt;, the strain in &lt;code&gt;s3&lt;/code&gt; is calculated using one of the formulas above. Once the strain of the sum is known, the &lt;em&gt;value&lt;/em&gt;s of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; are then set so that they are have a strain equal to that of the sum. The formulas are evaluated so as to take rounding errors into account and ensure that the sum of the &lt;em&gt;value&lt;/em&gt;s of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; is exactly equal to the &lt;em&gt;value&lt;/em&gt; of &lt;code&gt;s3&lt;/code&gt;.</source>
          <target state="translated">When &lt;code&gt;setValue&lt;/code&gt; is called on the sum spring, &lt;code&gt;s3&lt;/code&gt; , the strain in &lt;code&gt;s3&lt;/code&gt; is calculated using one of the formulas above. Once the strain of the sum is known, the &lt;em&gt;value&lt;/em&gt;s of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; are then set so that they are have a strain equal to that of the sum. The formulas are evaluated so as to take rounding errors into account and ensure that the sum of the &lt;em&gt;value&lt;/em&gt;s of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; is exactly equal to the &lt;em&gt;value&lt;/em&gt; of &lt;code&gt;s3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56200bf85aca75288ef457ae1d31ce485573f186" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;targetSize&lt;/code&gt; is outside the [MIN, MAX] range, the algorithm sets all sizes to their appropriate limiting value (maximum or minimum).</source>
          <target state="translated">When &lt;code&gt;targetSize&lt;/code&gt; is outside the [MIN, MAX] range, the algorithm sets all sizes to their appropriate limiting value (maximum or minimum).</target>
        </trans-unit>
        <trans-unit id="1dab6c6877815ac1b0667bd54ac4119d91348f67" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;this&lt;/code&gt; instance has an undefined field, this conversion relies on the &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; default for its corresponding field. A notable difference between XML Schema 1.0 date/time datatypes and &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; is that Timezone value is optional for date/time datatypes and it is a required field for &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt;. See javadoc for &lt;code&gt;java.util.TimeZone.getDefault()&lt;/code&gt; on how the default is determined. To explicitly specify the &lt;code&gt;TimeZone&lt;/code&gt; instance, see &lt;a href=&quot;#toGregorianCalendar(java.util.TimeZone,java.util.Locale,javax.xml.datatype.XMLGregorianCalendar)&quot;&gt;&lt;code&gt;toGregorianCalendar(TimeZone, Locale, XMLGregorianCalendar)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">When &lt;code&gt;this&lt;/code&gt; instance has an undefined field, this conversion relies on the &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; default for its corresponding field. A notable difference between XML Schema 1.0 date/time datatypes and &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; is that Timezone value is optional for date/time datatypes and it is a required field for &lt;code&gt;java.util.GregorianCalendar&lt;/code&gt; . See javadoc for &lt;code&gt;java.util.TimeZone.getDefault()&lt;/code&gt; on how the default is determined. To explicitly specify the &lt;code&gt;TimeZone&lt;/code&gt; instance, see &lt;a href=&quot;#toGregorianCalendar(java.util.TimeZone,java.util.Locale,javax.xml.datatype.XMLGregorianCalendar)&quot;&gt; &lt;code&gt;toGregorianCalendar(TimeZone, Locale, XMLGregorianCalendar)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="df87c54daa5b6b22cd03fdfcb4a354ce9aff9581" translate="yes" xml:space="preserve">
          <source>When FEATURE_SECURE_PROCESSING is enabled, it is recommended that implementations restrict external connections by default, though this may cause problems for applications that process XML/XSD/XSL with external references.</source>
          <target state="translated">When FEATURE_SECURE_PROCESSING is enabled, it is recommended that implementations restrict external connections by default, though this may cause problems for applications that process XML/XSD/XSL with external references.</target>
        </trans-unit>
        <trans-unit id="1fe0e12bc1e4fbc587d188553680ac3198949110" translate="yes" xml:space="preserve">
          <source>When FLAG_SERIALIZABLE is set in &lt;code&gt;flags&lt;/code&gt;, the function objects will implement &lt;code&gt;Serializable&lt;/code&gt;, and will have a &lt;code&gt;writeReplace&lt;/code&gt; method that returns an appropriate &lt;a href=&quot;serializedlambda&quot;&gt;&lt;code&gt;SerializedLambda&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;caller&lt;/code&gt; class must have an appropriate &lt;code&gt;$deserializeLambda$&lt;/code&gt; method, as described in &lt;a href=&quot;serializedlambda&quot;&gt;&lt;code&gt;SerializedLambda&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">FLAG_SERIALIZABLE이 &lt;code&gt;flags&lt;/code&gt; 로 설정되면 함수 객체는 &lt;code&gt;Serializable&lt;/code&gt; 을 구현 하고 적절한 &lt;a href=&quot;serializedlambda&quot;&gt; &lt;code&gt;SerializedLambda&lt;/code&gt; &lt;/a&gt; 를 반환하는 &lt;code&gt;writeReplace&lt;/code&gt; 메서드를 갖게됩니다 . &lt;code&gt;caller&lt;/code&gt; 클래스는 적절한 있어야합니다 &lt;code&gt;$deserializeLambda$&lt;/code&gt; 에 설명 된대로 방법을 &lt;a href=&quot;serializedlambda&quot;&gt; &lt;code&gt;SerializedLambda&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c646c0ac257bca0396e71fe9d4cc99c62c09c803" translate="yes" xml:space="preserve">
          <source>When JNDI constructs an initial context, the context's environment is initialized with properties defined in the environment parameter passed to the constructor, the system properties, and the application resource files. See &lt;a href=&quot;initialcontext#ENVIRONMENT&quot;&gt;&lt;code&gt;InitialContext&lt;/code&gt;&lt;/a&gt; for details. This initial environment is then inherited by other context instances.</source>
          <target state="translated">When JNDI constructs an initial context, the context's environment is initialized with properties defined in the environment parameter passed to the constructor, the system properties, and the application resource files. See &lt;a href=&quot;initialcontext#ENVIRONMENT&quot;&gt; &lt;code&gt;InitialContext&lt;/code&gt; &lt;/a&gt; for details. This initial environment is then inherited by other context instances.</target>
        </trans-unit>
        <trans-unit id="78166e3e3d24c054685e7318d257481464f62c87" translate="yes" xml:space="preserve">
          <source>When JNDI constructs an initial context, the context's environment is initialized with properties defined in the environment parameter passed to the constructor, the system properties, the applet parameters, and the application resource files. See &lt;a href=&quot;initialcontext#ENVIRONMENT&quot;&gt;&lt;code&gt;InitialContext&lt;/code&gt;&lt;/a&gt; for details. This initial environment is then inherited by other context instances.</source>
          <target state="translated">JNDI가 초기 컨텍스트를 구성 할 때 컨텍스트 환경은 생성자에 전달 된 환경 매개 변수, 시스템 특성, 애플릿 매개 변수 및 애플리케이션 자원 파일에 정의 된 특성으로 초기화됩니다. 자세한 내용은 &lt;a href=&quot;initialcontext#ENVIRONMENT&quot;&gt; &lt;code&gt;InitialContext&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. 그런 다음이 초기 환경은 다른 컨텍스트 인스턴스에 의해 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="bcf229951ee0f52a0b20411c8b8db39b24c97b2e" translate="yes" xml:space="preserve">
          <source>When Java Sound is used to handle system exclusive data that is being received using MIDI wire protocol, it should place the data in one or more &lt;code&gt;SysexMessages&lt;/code&gt;. In this case, the length of the system exclusive data is not known in advance; the end of the system exclusive data is marked by an end-of-exclusive flag (0xF7) in the MIDI wire byte stream.</source>
          <target state="translated">MIDI 와이어 프로토콜을 사용하여 수신중인 시스템 독점 데이터를 처리하기 위해 Java Sound를 사용하는 경우 하나 이상의 &lt;code&gt;SysexMessages&lt;/code&gt; 에 데이터를 배치해야합니다 . 이 경우 시스템 독점 데이터의 길이는 미리 알려져 있지 않습니다. 시스템 배타적 데이터의 끝은 MIDI 와이어 바이트 스트림에서 배타적 종료 플래그 (0xF7)로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3dab1f00d125a2ba1bd6dc4a77821fdb53b85de1" translate="yes" xml:space="preserve">
          <source>When LoginContext uses a caller-specified Configuration, the caller does not require any createLoginContext AuthPermission. The LoginContext saves the &lt;code&gt;AccessControlContext&lt;/code&gt; for the caller, and invokes the configured modules from within an &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; call constrained by that context. This means the caller context (stored when the LoginContext was created) must have sufficient permissions to perform any security-sensitive tasks that the modules may perform.</source>
          <target state="translated">LoginContext가 호출자 지정 구성을 사용하는 경우 호출자는 createLoginContext AuthPermission을 요구하지 않습니다. LoginContext는 호출자 의 &lt;code&gt;AccessControlContext&lt;/code&gt; 를 저장하고 해당 컨텍스트에 의해 제한되는 &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; 호출 내에서 구성된 모듈을 호출합니다 . 이는 호출자 컨텍스트 (LoginContext가 작성 될 때 저장 됨)에 모듈이 수행 할 수있는 보안에 민감한 작업을 수행 할 수있는 충분한 권한이 있어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cb8e6ccdc860924e083cd3b27c25e020271479ff" translate="yes" xml:space="preserve">
          <source>When LoginContext uses the installed Configuration, the caller requires the createLoginContext.&lt;em&gt;name&lt;/em&gt; and possibly createLoginContext.other AuthPermissions. Furthermore, the LoginContext will invoke configured modules from within an &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; call so that modules that perform security-sensitive tasks (such as connecting to remote hosts, and updating the Subject) will require the respective permissions, but the callers of the LoginContext will not require those permissions.</source>
          <target state="translated">LoginContext가 설치된 구성을 사용하는 경우 호출자는 createLoginContext가 필요합니다. &lt;em&gt;이름&lt;/em&gt; 및 가능하면 createLoginContext.other AuthPermissions. 또한 LoginContext는 &lt;code&gt;AccessController.doPrivileged&lt;/code&gt; 호출 내에서 구성된 모듈을 호출 하여 보안에 민감한 작업 (예 : 원격 호스트 연결 및 주제 업데이트)을 수행하는 모듈에는 각각의 권한이 필요하지만 LoginContext의 호출자는 이러한 권한이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b505aae2a5e2bff9bbd6708f806b82cbadb154a8" translate="yes" xml:space="preserve">
          <source>When W3C XML Schema validation is being performed, in the case where an element has a union type, the &lt;a href=&quot;../../../org/w3c/dom/typeinfo&quot;&gt;&lt;code&gt;TypeInfo&lt;/code&gt;&lt;/a&gt; returned by a call to &lt;code&gt;getElementTypeInfo()&lt;/code&gt; from the startElement event will be the union type. The &lt;code&gt;TypeInfo&lt;/code&gt; returned by a call from the endElement event will be the actual member type used to validate the element.</source>
          <target state="translated">When W3C XML Schema validation is being performed, in the case where an element has a union type, the &lt;a href=&quot;../../../org/w3c/dom/typeinfo&quot;&gt; &lt;code&gt;TypeInfo&lt;/code&gt; &lt;/a&gt; returned by a call to &lt;code&gt;getElementTypeInfo()&lt;/code&gt; from the startElement event will be the union type. The &lt;code&gt;TypeInfo&lt;/code&gt; returned by a call from the endElement event will be the actual member type used to validate the element.</target>
        </trans-unit>
        <trans-unit id="815b4cfc283610afe0ea69050a522abe02ee7ab9" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; is specified, a &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; will work as a filter and basically copy the incoming events to the specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">When a &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt; is specified, a &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt; will work as a filter and basically copy the incoming events to the specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ed0149faee2af012851081107e6df3815ec1f855" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../validation/schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; is non-null, a parser will use a validator created from it to validate documents before it passes information down to the application.</source>
          <target state="translated">When a &lt;a href=&quot;../validation/schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt; is non-null, a parser will use a validator created from it to validate documents before it passes information down to the application.</target>
        </trans-unit>
        <trans-unit id="0c5f84dadcd17bdac77318bfd9b493ef7c34d713" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Boolean&lt;/code&gt; return type is requested, &lt;code&gt;Boolean.TRUE&lt;/code&gt; is returned if one or more nodes were selected; otherwise, &lt;code&gt;Boolean.FALSE&lt;/code&gt; is returned.</source>
          <target state="translated">When a &lt;code&gt;Boolean&lt;/code&gt; return type is requested, &lt;code&gt;Boolean.TRUE&lt;/code&gt; is returned if one or more nodes were selected; otherwise, &lt;code&gt;Boolean.FALSE&lt;/code&gt; is returned.</target>
        </trans-unit>
        <trans-unit id="e2dfe78f2ad4f3813f1c14b93d0ec0c6be233cf4" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Calendar&lt;/code&gt; is in non-lenient mode, it throws an exception if there is any inconsistency in its calendar fields. For example, a &lt;code&gt;GregorianCalendar&lt;/code&gt; always produces &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; values between 1 and the length of the month. A non-lenient &lt;code&gt;GregorianCalendar&lt;/code&gt; throws an exception upon calculating its time or calendar field values if any out-of-range field value has been set.</source>
          <target state="translated">때 &lt;code&gt;Calendar&lt;/code&gt; 엄밀 모드의 달력 필드에 불일치가있는 경우, 그것은 예외가 발생합니다. 예를 들어 &lt;code&gt;GregorianCalendar&lt;/code&gt; 는 항상 1과 월 길이 사이의 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 값을 생성 합니다. 범위를 벗어난 필드 값이 설정된 경우 시간 또는 달력 필드 값을 계산할 때 무의미한 &lt;code&gt;GregorianCalendar&lt;/code&gt; 가 예외를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="42293990f57bc3f88207c3a41721f4ff5a428cf3" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;CompletionStage&lt;/code&gt; returned from &lt;a href=&quot;websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)&quot;&gt;&lt;code&gt;Listener.onClose&lt;/code&gt;&lt;/a&gt; completes, the &lt;code&gt;WebSocket&lt;/code&gt; will send a Close message that has the same code the received message has and an empty reason.</source>
          <target state="translated">When a &lt;code&gt;CompletionStage&lt;/code&gt; returned from &lt;a href=&quot;websocket.listener#onClose(java.net.http.WebSocket,int,java.lang.String)&quot;&gt; &lt;code&gt;Listener.onClose&lt;/code&gt; &lt;/a&gt; completes, the &lt;code&gt;WebSocket&lt;/code&gt; will send a Close message that has the same code the received message has and an empty reason.</target>
        </trans-unit>
        <trans-unit id="a356f25179772d20743b3c684279064beb377fbf" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;DatagramSocket&lt;/code&gt; is created the initial setting of &lt;code&gt;SO_REUSEADDR&lt;/code&gt; is disabled.</source>
          <target state="translated">때 &lt;code&gt;DatagramSocket&lt;/code&gt; 로이 생성의 초기 설정 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="43ae46b786a991e294be5fd4ff96fd7edcdce9c4" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Descriptor&lt;/code&gt; is used, the fields of interest are these:</source>
          <target state="translated">&lt;code&gt;Descriptor&lt;/code&gt; 사용될 때 관심 분야는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8380d9c546aba4d2b7dbbdb71fb24b8c1ed97298" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;DocumentFragment&lt;/code&gt; is inserted into a &lt;code&gt;Document&lt;/code&gt; (or indeed any other &lt;code&gt;Node&lt;/code&gt; that may take children) the children of the &lt;code&gt;DocumentFragment&lt;/code&gt; and not the &lt;code&gt;DocumentFragment&lt;/code&gt; itself are inserted into the &lt;code&gt;Node&lt;/code&gt;. This makes the &lt;code&gt;DocumentFragment&lt;/code&gt; very useful when the user wishes to create nodes that are siblings; the &lt;code&gt;DocumentFragment&lt;/code&gt; acts as the parent of these nodes so that the user can use the standard methods from the &lt;code&gt;Node&lt;/code&gt; interface, such as &lt;code&gt;Node.insertBefore&lt;/code&gt; and &lt;code&gt;Node.appendChild&lt;/code&gt;.</source>
          <target state="translated">When a &lt;code&gt;DocumentFragment&lt;/code&gt; is inserted into a &lt;code&gt;Document&lt;/code&gt; (or indeed any other &lt;code&gt;Node&lt;/code&gt; that may take children) the children of the &lt;code&gt;DocumentFragment&lt;/code&gt; and not the &lt;code&gt;DocumentFragment&lt;/code&gt; itself are inserted into the &lt;code&gt;Node&lt;/code&gt; . This makes the &lt;code&gt;DocumentFragment&lt;/code&gt; very useful when the user wishes to create nodes that are siblings; the &lt;code&gt;DocumentFragment&lt;/code&gt; acts as the parent of these nodes so that the user can use the standard methods from the &lt;code&gt;Node&lt;/code&gt; interface, such as &lt;code&gt;Node.insertBefore&lt;/code&gt; and &lt;code&gt;Node.appendChild&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9b7e8c421f422ce7ad6e056801a9b14403ef2ba" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;JoinRowSet&lt;/code&gt; object is created, it is empty. The first &lt;code&gt;RowSet&lt;/code&gt; object to be added becomes the basis for the &lt;code&gt;JOIN&lt;/code&gt; relationship. Applications must determine which column in each of the &lt;code&gt;RowSet&lt;/code&gt; objects to be added to the &lt;code&gt;JoinRowSet&lt;/code&gt; object should be the match column. All of the &lt;code&gt;RowSet&lt;/code&gt; objects must contain a match column, and the values in each match column must be ones that can be compared to values in the other match columns. The columns do not have to have the same name, though they often do, and they do not have to store the exact same data type as long as the data types can be compared.</source>
          <target state="translated">When a &lt;code&gt;JoinRowSet&lt;/code&gt; object is created, it is empty. The first &lt;code&gt;RowSet&lt;/code&gt; object to be added becomes the basis for the &lt;code&gt;JOIN&lt;/code&gt; relationship. Applications must determine which column in each of the &lt;code&gt;RowSet&lt;/code&gt; objects to be added to the &lt;code&gt;JoinRowSet&lt;/code&gt; object should be the match column. All of the &lt;code&gt;RowSet&lt;/code&gt; objects must contain a match column, and the values in each match column must be ones that can be compared to values in the other match columns. The columns do not have to have the same name, though they often do, and they do not have to store the exact same data type as long as the data types can be compared.</target>
        </trans-unit>
        <trans-unit id="1ecb2985dc99729b931217f288615f118958b74e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;LookAndFeel&lt;/code&gt; is installed the &lt;code&gt;UIManager&lt;/code&gt; does not check that an entry exists for all ui class ids. As such, random exceptions will occur if the current look and feel has not provided a value for a particular ui class id and an instance of the &lt;code&gt;JComponent&lt;/code&gt; subclass is created.</source>
          <target state="translated">When a &lt;code&gt;LookAndFeel&lt;/code&gt; is installed the &lt;code&gt;UIManager&lt;/code&gt; does not check that an entry exists for all ui class ids. As such, random exceptions will occur if the current look and feel has not provided a value for a particular ui class id and an instance of the &lt;code&gt;JComponent&lt;/code&gt; subclass is created.</target>
        </trans-unit>
        <trans-unit id="db057955ab30883a5287d3d1d0441c5297d96c2f" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;MathContext&lt;/code&gt; object is supplied with a precision setting of 0 (for example, &lt;a href=&quot;mathcontext#UNLIMITED&quot;&gt;&lt;code&gt;MathContext.UNLIMITED&lt;/code&gt;&lt;/a&gt;), arithmetic operations are exact, as are the arithmetic methods which take no &lt;code&gt;MathContext&lt;/code&gt; object. (This is the only behavior that was supported in releases prior to 5.) As a corollary of computing the exact result, the rounding mode setting of a &lt;code&gt;MathContext&lt;/code&gt; object with a precision setting of 0 is not used and thus irrelevant. In the case of divide, the exact quotient could have an infinitely long decimal expansion; for example, 1 divided by 3. If the quotient has a nonterminating decimal expansion and the operation is specified to return an exact result, an &lt;code&gt;ArithmeticException&lt;/code&gt; is thrown. Otherwise, the exact result of the division is returned, as done for other operations.</source>
          <target state="translated">때 &lt;code&gt;MathContext&lt;/code&gt; 객체 (예를 들어, 0의 정밀도가 설정된 공급 &lt;a href=&quot;mathcontext#UNLIMITED&quot;&gt; &lt;code&gt;MathContext.UNLIMITED&lt;/code&gt; &lt;/a&gt; ), 연산은 더 취하지 연산 방법이며, 정확한되어 &lt;code&gt;MathContext&lt;/code&gt; 개체. (이것은 5 이전의 릴리스에서 지원 된 유일한 동작입니다.) 정확한 결과를 계산하기 위한 정밀도 설정이 0 인 &lt;code&gt;MathContext&lt;/code&gt; 객체 의 반올림 모드 설정은 사용되지 않으므로 관련이 없습니다. 나누기의 경우 정확한 몫은 무한 길이의 십진수 확장을 가질 수 있습니다. 예를 들어, 1을 3으로 나눈 값 몫에 끝나지 않는 10 진수 확장이 있고 정확한 결과를 반환하도록 연산이 지정된 경우 &lt;code&gt;ArithmeticException&lt;/code&gt; 던졌습니다. 그렇지 않으면 다른 작업에서와 같이 정확한 분할 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0cea0471bcac1fec9656ca87e5e77807a3aadf7c" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Node&lt;/code&gt; is copied using the &lt;code&gt;cloneNode&lt;/code&gt; method the &lt;code&gt;EventListener&lt;/code&gt;s attached to the source &lt;code&gt;Node&lt;/code&gt; are not attached to the copied &lt;code&gt;Node&lt;/code&gt;. If the user wishes the same &lt;code&gt;EventListener&lt;/code&gt;s to be added to the newly created copy the user must add them manually.</source>
          <target state="translated">When a &lt;code&gt;Node&lt;/code&gt; is copied using the &lt;code&gt;cloneNode&lt;/code&gt; method the &lt;code&gt;EventListener&lt;/code&gt; s attached to the source &lt;code&gt;Node&lt;/code&gt; are not attached to the copied &lt;code&gt;Node&lt;/code&gt; . If the user wishes the same &lt;code&gt;EventListener&lt;/code&gt; s to be added to the newly created copy the user must add them manually.</target>
        </trans-unit>
        <trans-unit id="8c8fb24cbf878544c9fafb9bba4f04c53ebcb063" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;PKIXParameters&lt;/code&gt; object is created, this flag is set to true. This setting reflects the most common (and simplest) strategy for processing policy qualifiers. Applications that want to use a more sophisticated policy must set this flag to false.</source>
          <target state="translated">때 &lt;code&gt;PKIXParameters&lt;/code&gt; 객체가 생성되고,이 플래그는 true로 설정됩니다. 이 설정은 정책 한정자를 처리하기위한 가장 일반적이고 가장 간단한 전략을 반영합니다. 보다 정교한 정책을 사용하려는 응용 프로그램은이 플래그를 false로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1fecae07ed08389b98c0a767668b060b64f63995" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;PKIXParameters&lt;/code&gt; object is created, this flag is set to true. This setting reflects the most common strategy for checking revocation, since each service provider must support revocation checking to be PKIX compliant. Sophisticated applications should set this flag to false when it is not practical to use a PKIX service provider's default revocation checking mechanism or when an alternative revocation checking mechanism is to be substituted (by also calling the &lt;a href=&quot;#addCertPathChecker(java.security.cert.PKIXCertPathChecker)&quot;&gt;&lt;code&gt;addCertPathChecker&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setCertPathCheckers(java.util.List)&quot;&gt;&lt;code&gt;setCertPathCheckers&lt;/code&gt;&lt;/a&gt; methods).</source>
          <target state="translated">When a &lt;code&gt;PKIXParameters&lt;/code&gt; object is created, this flag is set to true. This setting reflects the most common strategy for checking revocation, since each service provider must support revocation checking to be PKIX compliant. Sophisticated applications should set this flag to false when it is not practical to use a PKIX service provider's default revocation checking mechanism or when an alternative revocation checking mechanism is to be substituted (by also calling the &lt;a href=&quot;#addCertPathChecker(java.security.cert.PKIXCertPathChecker)&quot;&gt; &lt;code&gt;addCertPathChecker&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;#setCertPathCheckers(java.util.List)&quot;&gt; &lt;code&gt;setCertPathCheckers&lt;/code&gt; &lt;/a&gt; methods).</target>
        </trans-unit>
        <trans-unit id="e2e645d09fe7ffd9051e432a2e16d92d9eb058b1" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;PKIXParameters&lt;/code&gt; object is created, this flag is set to true. This setting reflects the most common strategy for checking revocation, since each service provider must support revocation checking to be PKIX compliant. Sophisticated applications should set this flag to false when it is not practical to use a PKIX service provider's default revocation checking mechanism or when an alternative revocation checking mechanism is to be substituted (by also calling the &lt;a href=&quot;pkixparameters#addCertPathChecker-java.security.cert.PKIXCertPathChecker-&quot;&gt;&lt;code&gt;addCertPathChecker&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;pkixparameters#setCertPathCheckers-java.util.List-&quot;&gt;&lt;code&gt;setCertPathCheckers&lt;/code&gt;&lt;/a&gt; methods).</source>
          <target state="translated">때 &lt;code&gt;PKIXParameters&lt;/code&gt; 객체가 생성되고,이 플래그는 true로 설정됩니다. 이 설정은 해지 확인을위한 가장 일반적인 전략을 반영합니다. 각 서비스 공급자는 해지 확인을 지원하여 PKIX를 준수해야하기 때문입니다. 정교한 응용 프로그램은 PKIX 서비스 공급자의 기본 해지 확인 메커니즘을 사용하는 것이 실용적이지 않거나 대체 해지 확인 메커니즘을 대체 할 때 ( &lt;a href=&quot;pkixparameters#addCertPathChecker-java.security.cert.PKIXCertPathChecker-&quot;&gt; &lt;code&gt;addCertPathChecker&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;pkixparameters#setCertPathCheckers-java.util.List-&quot;&gt; &lt;code&gt;setCertPathCheckers&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여)이 플래그를 false로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e1bdbad97a0491d45ccc56940a6c55eb21cbca0d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ResourceBundle&lt;/code&gt; was inherited or specified through the &lt;a href=&quot;#setResourceBundle(java.util.ResourceBundle)&quot;&gt;&lt;code&gt;setResourceBundle&lt;/code&gt;&lt;/a&gt; method, then that &lt;code&gt;ResourceBundle&lt;/code&gt; will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a &lt;code&gt;ResourceBundle&lt;/code&gt; object, using the default Locale at the time of logging.</source>
          <target state="translated">When a &lt;code&gt;ResourceBundle&lt;/code&gt; was inherited or specified through the &lt;a href=&quot;#setResourceBundle(java.util.ResourceBundle)&quot;&gt; &lt;code&gt;setResourceBundle&lt;/code&gt; &lt;/a&gt; method, then that &lt;code&gt;ResourceBundle&lt;/code&gt; will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a &lt;code&gt;ResourceBundle&lt;/code&gt; object, using the default Locale at the time of logging.</target>
        </trans-unit>
        <trans-unit id="c511cae88643a751f32e0d10e8a985db173ad353" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ResourceBundle&lt;/code&gt; was inherited or specified through the &lt;a href=&quot;logger#setResourceBundle-java.util.ResourceBundle-&quot;&gt;&lt;code&gt;setResourceBundle&lt;/code&gt;&lt;/a&gt; method, then that &lt;code&gt;ResourceBundle&lt;/code&gt; will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a &lt;code&gt;ResourceBundle&lt;/code&gt; object, using the default Locale at the time of logging.</source>
          <target state="translated">&lt;code&gt;ResourceBundle&lt;/code&gt; 이 &lt;a href=&quot;logger#setResourceBundle-java.util.ResourceBundle-&quot;&gt; &lt;code&gt;setResourceBundle&lt;/code&gt; &lt;/a&gt; 메소드를 통해 상속되거나 지정 되면 해당 &lt;code&gt;ResourceBundle&lt;/code&gt; 이 사용됩니다. 그렇지 않으면 로거가 자원 번들 이름 만 가지고 있거나 상속 한 경우, 해당 자원 번들 이름은 로깅시 기본 로케일을 사용하여 &lt;code&gt;ResourceBundle&lt;/code&gt; 오브젝트에 맵핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7a5a177904b96f015c06307ad10fbc63f60c2f8" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ResultSet&lt;/code&gt; is closed, any &lt;code&gt;ResultSetMetaData&lt;/code&gt; instances that were created by calling the &lt;code&gt;getMetaData&lt;/code&gt; method remain accessible.</source>
          <target state="translated">When a &lt;code&gt;ResultSet&lt;/code&gt; is closed, any &lt;code&gt;ResultSetMetaData&lt;/code&gt; instances that were created by calling the &lt;code&gt;getMetaData&lt;/code&gt; method remain accessible.</target>
        </trans-unit>
        <trans-unit id="b33e9674235e0636be1c47ce12e9e34568e5c11d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Scanner&lt;/code&gt; is closed, it will close its input source if the source implements the &lt;a href=&quot;../io/closeable&quot;&gt;&lt;code&gt;Closeable&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">때 &lt;code&gt;Scanner&lt;/code&gt; 닫히고, 상기 소스 구현할 경우 입력 소스 밀접한 것 &lt;a href=&quot;../io/closeable&quot;&gt; &lt;code&gt;Closeable&lt;/code&gt; &lt;/a&gt; 인터페이스.</target>
        </trans-unit>
        <trans-unit id="af91e23da41d9929e2e507d4f86a71d5504d82ff" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ServerSocket&lt;/code&gt; is created the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is not defined. Applications can use &lt;a href=&quot;#getReuseAddress()&quot;&gt;&lt;code&gt;getReuseAddress()&lt;/code&gt;&lt;/a&gt; to determine the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">When a &lt;code&gt;ServerSocket&lt;/code&gt; is created the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt; is not defined. Applications can use &lt;a href=&quot;#getReuseAddress()&quot;&gt; &lt;code&gt;getReuseAddress()&lt;/code&gt; &lt;/a&gt; to determine the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d0ea93fe34d0cbcc920144a03e28605555397e46" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ServerSocket&lt;/code&gt; is created the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is not defined. Applications can use &lt;a href=&quot;serversocket#getReuseAddress--&quot;&gt;&lt;code&gt;getReuseAddress()&lt;/code&gt;&lt;/a&gt; to determine the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;ServerSocket&lt;/code&gt; 의이 생성의 초기 설정 &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 가&lt;/a&gt; 정의되어 있지 않습니다. 애플리케이션은 &lt;a href=&quot;serversocket#getReuseAddress--&quot;&gt; &lt;code&gt;getReuseAddress()&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt; 의 초기 설정을 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0455bab8e7854f1380ef3d296a0c738fc6d405a" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Socket&lt;/code&gt; is created the initial setting of &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is disabled.</source>
          <target state="translated">때 &lt;code&gt;Socket&lt;/code&gt; 생성의 초기 설정 &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 는&lt;/a&gt; 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2fee0877683a4237d7d04165c6386560ed02539f" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;double&lt;/code&gt; must be used as a source for a &lt;code&gt;BigDecimal&lt;/code&gt;, note that this constructor provides an exact conversion; it does not give the same result as converting the &lt;code&gt;double&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;a href=&quot;../lang/double#toString(double)&quot;&gt;&lt;code&gt;Double.toString(double)&lt;/code&gt;&lt;/a&gt; method and then using the &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor. To get that result, use the &lt;code&gt;static&lt;/code&gt;&lt;a href=&quot;#valueOf(double)&quot;&gt;&lt;code&gt;valueOf(double)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">When a &lt;code&gt;double&lt;/code&gt; must be used as a source for a &lt;code&gt;BigDecimal&lt;/code&gt; , note that this constructor provides an exact conversion; it does not give the same result as converting the &lt;code&gt;double&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;a href=&quot;../lang/double#toString(double)&quot;&gt; &lt;code&gt;Double.toString(double)&lt;/code&gt; &lt;/a&gt; method and then using the &lt;a href=&quot;#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt; constructor. To get that result, use the &lt;code&gt;static&lt;/code&gt; &lt;a href=&quot;#valueOf(double)&quot;&gt; &lt;code&gt;valueOf(double)&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="1a039e1d49f70a273c394bc527a427829f3c4985" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;double&lt;/code&gt; must be used as a source for a &lt;code&gt;BigDecimal&lt;/code&gt;, note that this constructor provides an exact conversion; it does not give the same result as converting the &lt;code&gt;double&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt; using the &lt;a href=&quot;../lang/double#toString-double-&quot;&gt;&lt;code&gt;Double.toString(double)&lt;/code&gt;&lt;/a&gt; method and then using the &lt;a href=&quot;bigdecimal#BigDecimal-java.lang.String-&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor. To get that result, use the &lt;code&gt;static&lt;/code&gt;&lt;a href=&quot;bigdecimal#valueOf-double-&quot;&gt;&lt;code&gt;valueOf(double)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">때 &lt;code&gt;double&lt;/code&gt; A에 대한 소스로 사용되어야합니다 &lt;code&gt;BigDecimal&lt;/code&gt; 를 ,이 생성자은 정확한 변환을 실시하는 것에주의 &lt;a href=&quot;../lang/double#toString-double-&quot;&gt; &lt;code&gt;Double.toString(double)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;a href=&quot;bigdecimal#BigDecimal-java.lang.String-&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt; 생성자 를 사용 하여 &lt;code&gt;double&lt;/code&gt; 을 &lt;code&gt;String&lt;/code&gt; 으로 변환하는 것과 동일한 결과를 제공하지 않습니다 . 결과를 얻으려면 &lt;code&gt;static&lt;/code&gt; &lt;a href=&quot;bigdecimal#valueOf-double-&quot;&gt; &lt;code&gt;valueOf(double)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6527806b79e3b486f23af62691038fe376e23d6f" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;java.lang.Error&lt;/code&gt; occurs in the agent it should be caught and re-thrown as a &lt;code&gt;RuntimeErrorException&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;java.lang.Error&lt;/code&gt; 에이전트에서 java.lang.Error 가 발생 를 잡아서 &lt;code&gt;RuntimeErrorException&lt;/code&gt; 으로 다시 던져야 합니다.</target>
        </trans-unit>
        <trans-unit id="0a1362f6628b563d356e949983f03f9000a84379" translate="yes" xml:space="preserve">
          <source>When a BoundedRange model is used with a scrollbar the extent defines the length of the scrollbar knob (aka the &quot;thumb&quot; or &quot;elevator&quot;). The extent usually represents how much of the object being scrolled is visible. When used with a slider, the extent determines how much the value can &quot;jump&quot;, for example when the user presses PgUp or PgDn.</source>
          <target state="translated">When a BoundedRange model is used with a scrollbar the extent defines the length of the scrollbar knob (aka the &quot;thumb&quot; or &quot;elevator&quot;). The extent usually represents how much of the object being scrolled is visible. When used with a slider, the extent determines how much the value can &quot;jump&quot;, for example when the user presses PgUp or PgDn.</target>
        </trans-unit>
        <trans-unit id="9c90ea452e81ba4569ae99ffac2958ce33a2a19f" translate="yes" xml:space="preserve">
          <source>When a BoundedRange model is used with a scrollbar the value specifies the origin of the scrollbar knob (aka the &quot;thumb&quot; or &quot;elevator&quot;). The value usually represents the origin of the visible part of the object being scrolled.</source>
          <target state="translated">When a BoundedRange model is used with a scrollbar the value specifies the origin of the scrollbar knob (aka the &quot;thumb&quot; or &quot;elevator&quot;). The value usually represents the origin of the visible part of the object being scrolled.</target>
        </trans-unit>
        <trans-unit id="2a2d8c26085a986f69098405e00452247f97fcb7" translate="yes" xml:space="preserve">
          <source>When a Driver class is loaded, it should create an instance of itself and register it with the DriverManager. This means that a user can load and register a driver by calling:</source>
          <target state="translated">When a Driver class is loaded, it should create an instance of itself and register it with the DriverManager. This means that a user can load and register a driver by calling:</target>
        </trans-unit>
        <trans-unit id="ac2232cc133cdbf38b6f9aa25e3da077f2459d69" translate="yes" xml:space="preserve">
          <source>When a JVM is launched in a way that indicates an agent class. In that case an &lt;code&gt;Instrumentation&lt;/code&gt; instance is passed to the &lt;code&gt;premain&lt;/code&gt; method of the agent class.</source>
          <target state="translated">에이전트 클래스를 나타내는 방식으로 JVM이 시작된 경우 이 경우 &lt;code&gt;Instrumentation&lt;/code&gt; 인스턴스에 전달 &lt;code&gt;premain&lt;/code&gt; 에이전트 클래스 방법.</target>
        </trans-unit>
        <trans-unit id="bc6710d50791c1a74ebb5f190790f0fa28c0deca" translate="yes" xml:space="preserve">
          <source>When a JVM provides a mechanism to start agents sometime after the JVM is launched. In that case an &lt;code&gt;Instrumentation&lt;/code&gt; instance is passed to the &lt;code&gt;agentmain&lt;/code&gt; method of the agent code.</source>
          <target state="translated">JVM이 JVM을 시작한 후 언젠가 에이전트를 시작하는 메커니즘을 제공하는 경우 이 경우 &lt;code&gt;Instrumentation&lt;/code&gt; 인스턴스가 에이전트 코드 의 &lt;code&gt;agentmain&lt;/code&gt; 메소드로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe6f53c2c934674a6688b208d3ae4e419bb93e41" translate="yes" xml:space="preserve">
          <source>When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named &lt;code&gt;main&lt;/code&gt; of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:</source>
          <target state="translated">Java Virtual Machine이 시작되면 일반적으로 단일 비 데몬 스레드가 있습니다 (일반적으로 지정된 클래스의 &lt;code&gt;main&lt;/code&gt; 이라는 메서드를 호출 함 ). Java Virtual Machine은 다음 중 하나가 발생할 때까지 스레드를 계속 실행합니다.</target>
        </trans-unit>
        <trans-unit id="679be8f92ef7e9ad73d5185ae525f63b8b428a90" translate="yes" xml:space="preserve">
          <source>When a Java program runs, a large number of &lt;code&gt;Graphics&lt;/code&gt; objects can be created within a short time frame. Although the finalization process of the garbage collector also disposes of the same system resources, it is preferable to manually free the associated resources by calling this method rather than to rely on a finalization process which may not run to completion for a long period of time.</source>
          <target state="translated">When a Java program runs, a large number of &lt;code&gt;Graphics&lt;/code&gt; objects can be created within a short time frame. Although the finalization process of the garbage collector also disposes of the same system resources, it is preferable to manually free the associated resources by calling this method rather than to rely on a finalization process which may not run to completion for a long period of time.</target>
        </trans-unit>
        <trans-unit id="591e6c34b6ba8d6f3eeb6796c729752f095528e6" translate="yes" xml:space="preserve">
          <source>When a LogRecord is passed into the logging framework it logically belongs to the framework and should no longer be used or updated by the client application.</source>
          <target state="translated">LogRecord가 로깅 프레임 워크에 전달되면 논리적으로 프레임 워크에 속하며 더 이상 클라이언트 애플리케이션에서 사용하거나 업데이트하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="760cbf62cac395bf976d73378ca4ebfb39c0855a" translate="yes" xml:space="preserve">
          <source>When a MenuElement receives an event from a KeyListener, it should never process the event directly.</source>
          <target state="translated">When a MenuElement receives an event from a KeyListener, it should never process the event directly.</target>
        </trans-unit>
        <trans-unit id="f3e01acb00e3633472670e98ba3b82778f6c5de9" translate="yes" xml:space="preserve">
          <source>When a MenuElement receives an event from a KeyListener, it should never process the event directly. Instead all MenuElements should call this method with the event.</source>
          <target state="translated">When a MenuElement receives an event from a KeyListener, it should never process the event directly. Instead all MenuElements should call this method with the event.</target>
        </trans-unit>
        <trans-unit id="3a264f4f3f88ff6f8c7f2e0d665633e1f71e9b05" translate="yes" xml:space="preserve">
          <source>When a MenuElement receives an event from a MouseListener, it should never process the event directly.</source>
          <target state="translated">When a MenuElement receives an event from a MouseListener, it should never process the event directly.</target>
        </trans-unit>
        <trans-unit id="4d11ed3673e1ba2ba2cacee39f6b7d24eb7ebca6" translate="yes" xml:space="preserve">
          <source>When a MenuElement receives an event from a MouseListener, it should never process the event directly. Instead all MenuElements should call this method with the event.</source>
          <target state="translated">When a MenuElement receives an event from a MouseListener, it should never process the event directly. Instead all MenuElements should call this method with the event.</target>
        </trans-unit>
        <trans-unit id="b38b56c9df7506bfe3ea2ad2db230dd732a913c0" translate="yes" xml:space="preserve">
          <source>When a SAX2 driver is providing these events, all other events must be properly nested within start/end entity events. There is no additional requirement that events from &lt;a href=&quot;declhandler&quot;&gt;&lt;code&gt;DeclHandler&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../dtdhandler&quot;&gt;&lt;code&gt;DTDHandler&lt;/code&gt;&lt;/a&gt; be properly ordered.</source>
          <target state="translated">When a SAX2 driver is providing these events, all other events must be properly nested within start/end entity events. There is no additional requirement that events from &lt;a href=&quot;declhandler&quot;&gt; &lt;code&gt;DeclHandler&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;../dtdhandler&quot;&gt; &lt;code&gt;DTDHandler&lt;/code&gt; &lt;/a&gt; be properly ordered.</target>
        </trans-unit>
        <trans-unit id="ca65f59c344aab5c1b12d68027c6ad5c16f0ae24" translate="yes" xml:space="preserve">
          <source>When a Standard MBean is made from the &lt;code&gt;CacheControlMBean&lt;/code&gt;, the usual rules mean that it will have an attribute called &lt;code&gt;CacheSize&lt;/code&gt; of type &lt;code&gt;long&lt;/code&gt;. The &lt;code&gt;@Units&lt;/code&gt; annotation, given the above definition, will ensure that the &lt;a href=&quot;mbeanattributeinfo&quot;&gt;&lt;code&gt;MBeanAttributeInfo&lt;/code&gt;&lt;/a&gt; for this attribute will have a &lt;code&gt;Descriptor&lt;/code&gt; that has a field called &lt;code&gt;units&lt;/code&gt; with corresponding value &lt;code&gt;bytes&lt;/code&gt;.</source>
          <target state="translated">표준 MBean이 &lt;code&gt;CacheControlMBean&lt;/code&gt; 에서 작성 될 때 , 일반적인 규칙은 그것이 &lt;code&gt;long&lt;/code&gt; 유형의 &lt;code&gt;CacheSize&lt;/code&gt; 라는 속성을 갖음 을 의미합니다 . &lt;code&gt;@Units&lt;/code&gt; 상기 정의 주어진 주석, 상기 확인한다 &lt;a href=&quot;mbeanattributeinfo&quot;&gt; &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; &lt;/a&gt; 이 속성은 것 &lt;code&gt;Descriptor&lt;/code&gt; 필드는 호출 한 &lt;code&gt;units&lt;/code&gt; 대응 값을 &lt;code&gt;bytes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbdb2811ada49ec4e07a613aa3a52601e1be6d55" translate="yes" xml:space="preserve">
          <source>When a TCP connection is closed the connection may remain in a timeout state for a period of time after the connection is closed (typically known as the &lt;code&gt;TIME_WAIT&lt;/code&gt; state or &lt;code&gt;2MSL&lt;/code&gt; wait state). For applications using a well known socket address or port it may not be possible to bind a socket to the required &lt;code&gt;SocketAddress&lt;/code&gt; if there is a connection in the timeout state involving the socket address or port.</source>
          <target state="translated">TCP 연결이 닫히면 연결이 닫힌 후 일정 시간 동안 (종종 &lt;code&gt;TIME_WAIT&lt;/code&gt; 상태 또는 &lt;code&gt;2MSL&lt;/code&gt; 대기 상태) 연결이 시간 초과 상태로 유지 될 수 있습니다 . 잘 알려진 소켓 주소 또는 포트를 사용하는 응용 프로그램의 경우 소켓 주소 또는 포트와 관련된 시간 초과 상태에 연결이 있으면 필요한 &lt;code&gt;SocketAddress&lt;/code&gt; 에 소켓을 바인딩하지 못할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35d883e644cee8d8bc00892c83d14b9e68a7c0d4" translate="yes" xml:space="preserve">
          <source>When a TemplatesHandler object is used as a ContentHandler for the parsing of transformation instructions, it creates a Templates object, which the caller can get once the SAX events have been completed.</source>
          <target state="translated">When a TemplatesHandler object is used as a ContentHandler for the parsing of transformation instructions, it creates a Templates object, which the caller can get once the SAX events have been completed.</target>
        </trans-unit>
        <trans-unit id="a41e85f29028d8394c11ed11faa2b621db688b13" translate="yes" xml:space="preserve">
          <source>When a URL string (a &lt;code&gt;String&lt;/code&gt; of the form &lt;em&gt;scheme_id:rest_of_name&lt;/em&gt;) is passed as a name parameter to any method, a URL context factory for handling that scheme is located and used to resolve the URL. If no such factory is found, the initial context specified by &lt;code&gt;&quot;java.naming.factory.initial&quot;&lt;/code&gt; is used. Similarly, when a &lt;code&gt;CompositeName&lt;/code&gt; object whose first component is a URL string is passed as a name parameter to any method, a URL context factory is located and used to resolve the first name component. See &lt;a href=&quot;spi/namingmanager#getURLContext(java.lang.String,java.util.Hashtable)&quot;&gt;&lt;code&gt;NamingManager.getURLContext()&lt;/code&gt;&lt;/a&gt; for a description of how URL context factories are located.</source>
          <target state="translated">When a URL string (a &lt;code&gt;String&lt;/code&gt; of the form &lt;em&gt;scheme_id:rest_of_name&lt;/em&gt;) is passed as a name parameter to any method, a URL context factory for handling that scheme is located and used to resolve the URL. If no such factory is found, the initial context specified by &lt;code&gt;&quot;java.naming.factory.initial&quot;&lt;/code&gt; is used. Similarly, when a &lt;code&gt;CompositeName&lt;/code&gt; object whose first component is a URL string is passed as a name parameter to any method, a URL context factory is located and used to resolve the first name component. See &lt;a href=&quot;spi/namingmanager#getURLContext(java.lang.String,java.util.Hashtable)&quot;&gt; &lt;code&gt;NamingManager.getURLContext()&lt;/code&gt; &lt;/a&gt; for a description of how URL context factories are located.</target>
        </trans-unit>
        <trans-unit id="2f10e21dabecf61050cfb5e9bd4dbd4d574ca5d4" translate="yes" xml:space="preserve">
          <source>When a URL string (a &lt;code&gt;String&lt;/code&gt; of the form &lt;em&gt;scheme_id:rest_of_name&lt;/em&gt;) is passed as a name parameter to any method, a URL context factory for handling that scheme is located and used to resolve the URL. If no such factory is found, the initial context specified by &lt;code&gt;&quot;java.naming.factory.initial&quot;&lt;/code&gt; is used. Similarly, when a &lt;code&gt;CompositeName&lt;/code&gt; object whose first component is a URL string is passed as a name parameter to any method, a URL context factory is located and used to resolve the first name component. See &lt;a href=&quot;spi/namingmanager#getURLContext-java.lang.String-java.util.Hashtable-&quot;&gt;&lt;code&gt;&lt;code&gt;NamingManager.getURLContext()&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; for a description of how URL context factories are located.</source>
          <target state="translated">URL 문자열 ( &lt;em&gt;scheme_id : rest_of_name&lt;/em&gt; 형식 의 &lt;code&gt;String&lt;/code&gt; )이 이름 매개 변수로 메소드에 전달되면 해당 스킴을 처리하기위한 URL 컨텍스트 팩토리가 찾아 URL을 해석하는 데 사용됩니다. 그러한 팩토리를 찾지 못하면 &lt;code&gt;&quot;java.naming.factory.initial&quot;&lt;/code&gt; 로 지정된 초기 컨텍스트 가 사용됩니다. 마찬가지로, 첫 번째 구성 요소가 URL 문자열 인 &lt;code&gt;CompositeName&lt;/code&gt; 오브젝트가 이름 매개 변수로 메소드에 전달되면 URL 컨텍스트 팩토리가 위치하여 첫 번째 이름 구성 요소를 해석하는 데 사용됩니다. URL 컨텍스트 팩토리의 위치에 대한 설명은 &lt;a href=&quot;spi/namingmanager#getURLContext-java.lang.String-java.util.Hashtable-&quot;&gt; &lt;code&gt;&lt;code&gt;NamingManager.getURLContext()&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="429dc27d49480e2ab4eab569d5adf4cd4c7c135e" translate="yes" xml:space="preserve">
          <source>When a VolatileImage object is created, limited system resources such as video memory (VRAM) may be allocated in order to support the image. When a VolatileImage object is no longer used, it may be garbage-collected and those system resources will be returned, but this process does not happen at guaranteed times. Applications that create many VolatileImage objects (for example, a resizing window may force recreation of its back buffer as the size changes) may run out of optimal system resources for new VolatileImage objects simply because the old objects have not yet been removed from the system. (New VolatileImage objects may still be created, but they may not perform as well as those created in accelerated memory). The flush method may be called at any time to proactively release the resources used by a VolatileImage so that it does not prevent subsequent VolatileImage objects from being accelerated. In this way, applications can have more control over the state of the resources taken up by obsolete VolatileImage objects.</source>
          <target state="translated">When a VolatileImage object is created, limited system resources such as video memory (VRAM) may be allocated in order to support the image. When a VolatileImage object is no longer used, it may be garbage-collected and those system resources will be returned, but this process does not happen at guaranteed times. Applications that create many VolatileImage objects (for example, a resizing window may force recreation of its back buffer as the size changes) may run out of optimal system resources for new VolatileImage objects simply because the old objects have not yet been removed from the system. (New VolatileImage objects may still be created, but they may not perform as well as those created in accelerated memory). The flush method may be called at any time to proactively release the resources used by a VolatileImage so that it does not prevent subsequent VolatileImage objects from being accelerated. In this way, applications can have more control over the state of the resources taken up by obsolete VolatileImage objects.</target>
        </trans-unit>
        <trans-unit id="432971c4a856cab249165ae9a9e506665b76935a" translate="yes" xml:space="preserve">
          <source>When a button is pressed and released, AWT sends an instance of &lt;code&gt;ActionEvent&lt;/code&gt; to the button, by calling &lt;code&gt;processEvent&lt;/code&gt; on the button. The button's &lt;code&gt;processEvent&lt;/code&gt; method receives all events for the button; it passes an action event along by calling its own &lt;code&gt;processActionEvent&lt;/code&gt; method. The latter method passes the action event on to any action listeners that have registered an interest in action events generated by this button.</source>
          <target state="translated">When a button is pressed and released, AWT sends an instance of &lt;code&gt;ActionEvent&lt;/code&gt; to the button, by calling &lt;code&gt;processEvent&lt;/code&gt; on the button. The button's &lt;code&gt;processEvent&lt;/code&gt; method receives all events for the button; it passes an action event along by calling its own &lt;code&gt;processActionEvent&lt;/code&gt; method. The latter method passes the action event on to any action listeners that have registered an interest in action events generated by this button.</target>
        </trans-unit>
        <trans-unit id="2dffdc7e8d88a4030ccf25d0b91c9d8a92081e9c" translate="yes" xml:space="preserve">
          <source>When a call to the &lt;code&gt;next&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;, the cursor is positioned after the last row. Any invocation of a &lt;code&gt;ResultSet&lt;/code&gt; method which requires a current row will result in a &lt;code&gt;SQLException&lt;/code&gt; being thrown. If the result set type is &lt;code&gt;TYPE_FORWARD_ONLY&lt;/code&gt;, it is vendor specified whether their JDBC driver implementation will return &lt;code&gt;false&lt;/code&gt; or throw an &lt;code&gt;SQLException&lt;/code&gt; on a subsequent call to &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">When a call to the &lt;code&gt;next&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt; , the cursor is positioned after the last row. Any invocation of a &lt;code&gt;ResultSet&lt;/code&gt; method which requires a current row will result in a &lt;code&gt;SQLException&lt;/code&gt; being thrown. If the result set type is &lt;code&gt;TYPE_FORWARD_ONLY&lt;/code&gt; , it is vendor specified whether their JDBC driver implementation will return &lt;code&gt;false&lt;/code&gt; or throw an &lt;code&gt;SQLException&lt;/code&gt; on a subsequent call to &lt;code&gt;next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcde7f6440e70bd0233d9ec912e740d889f8535e" translate="yes" xml:space="preserve">
          <source>When a call to the &lt;code&gt;previous&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;, the cursor is positioned before the first row. Any invocation of a &lt;code&gt;ResultSet&lt;/code&gt; method which requires a current row will result in a &lt;code&gt;SQLException&lt;/code&gt; being thrown.</source>
          <target state="translated">When a call to the &lt;code&gt;previous&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt; , the cursor is positioned before the first row. Any invocation of a &lt;code&gt;ResultSet&lt;/code&gt; method which requires a current row will result in a &lt;code&gt;SQLException&lt;/code&gt; being thrown.</target>
        </trans-unit>
        <trans-unit id="8a83c0113229dd8663248a6bb840a6358d3593d9" translate="yes" xml:space="preserve">
          <source>When a callback method on the specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; throws an exception, the same exception object must be thrown from the &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; should not be notified of such an exception.</source>
          <target state="translated">When a callback method on the specified &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt; throws an exception, the same exception object must be thrown from the &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt;. The &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt; should not be notified of such an exception.</target>
        </trans-unit>
        <trans-unit id="084f36ff7f74614b43cbed478a2f7b49522f6609" translate="yes" xml:space="preserve">
          <source>When a check box menu item is selected, AWT sends an item event to the item. Since the event is an instance of &lt;code&gt;ItemEvent&lt;/code&gt;, the &lt;code&gt;processEvent&lt;/code&gt; method examines the event and passes it along to &lt;code&gt;processItemEvent&lt;/code&gt;. The latter method redirects the event to any &lt;code&gt;ItemListener&lt;/code&gt; objects that have registered an interest in item events generated by this menu item.</source>
          <target state="translated">When a check box menu item is selected, AWT sends an item event to the item. Since the event is an instance of &lt;code&gt;ItemEvent&lt;/code&gt; , the &lt;code&gt;processEvent&lt;/code&gt; method examines the event and passes it along to &lt;code&gt;processItemEvent&lt;/code&gt; . The latter method redirects the event to any &lt;code&gt;ItemListener&lt;/code&gt; objects that have registered an interest in item events generated by this menu item.</target>
        </trans-unit>
        <trans-unit id="d040f2e41b4f688b6bbac9b4fc04238f264f901c" translate="yes" xml:space="preserve">
          <source>When a client application is designed to remotely access MXBeans for a running virtual machine whose version is different than the version on which the application is running, it should prepare to catch &lt;a href=&quot;../../../../java.base/java/io/invalidobjectexception&quot;&gt;&lt;code&gt;InvalidObjectException&lt;/code&gt;&lt;/a&gt; which is thrown when an MXBean proxy receives a name of an enum constant which is missing in the enum class loaded in the client application. If thrown, &lt;a href=&quot;../../../../java.base/java/io/invalidobjectexception&quot;&gt;&lt;code&gt;InvalidObjectException&lt;/code&gt;&lt;/a&gt; will be wrappped in &lt;a href=&quot;../../../../java.base/java/lang/reflect/undeclaredthrowableexception&quot;&gt;&lt;code&gt;UndeclaredThrowableException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">When a client application is designed to remotely access MXBeans for a running virtual machine whose version is different than the version on which the application is running, it should prepare to catch &lt;a href=&quot;../../../../java.base/java/io/invalidobjectexception&quot;&gt; &lt;code&gt;InvalidObjectException&lt;/code&gt; &lt;/a&gt; which is thrown when an MXBean proxy receives a name of an enum constant which is missing in the enum class loaded in the client application. If thrown, &lt;a href=&quot;../../../../java.base/java/io/invalidobjectexception&quot;&gt; &lt;code&gt;InvalidObjectException&lt;/code&gt; &lt;/a&gt; will be wrappped in &lt;a href=&quot;../../../../java.base/java/lang/reflect/undeclaredthrowableexception&quot;&gt; &lt;code&gt;UndeclaredThrowableException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="902b9d017a9bed0402d7a996f72e41d3f25ab7ec" translate="yes" xml:space="preserve">
          <source>When a client application is designed to remotely access MXBeans for a running virtual machine whose version is different than the version on which the application is running, it should prepare to catch &lt;a href=&quot;../../io/invalidobjectexception&quot;&gt;&lt;code&gt;InvalidObjectException&lt;/code&gt;&lt;/a&gt; which is thrown when an MXBean proxy receives a name of an enum constant which is missing in the enum class loaded in the client application.</source>
          <target state="translated">클라이언트 애플리케이션이 실행중인 가상 머신의 애플리케이션이 실행중인 버전과 다른 버전의 MXBean에 원격으로 액세스하도록 설계 되면 MXBean 프록시가 열거 형 상수의 이름을 수신 할 때 발생하는 &lt;a href=&quot;../../io/invalidobjectexception&quot;&gt; &lt;code&gt;InvalidObjectException&lt;/code&gt; &lt;/a&gt; 을 포착하도록 준비해야합니다. 클라이언트 애플리케이션에로드 된 enum 클래스에서 누락되었습니다.</target>
        </trans-unit>
        <trans-unit id="7205693021c9fb69b57353ca24035c13ecb1c484" translate="yes" xml:space="preserve">
          <source>When a client connects to a server using the JMX Remote API, it is possible that they do not have the same version of the JMX specification. The version of the JMX specification described here is version 1.4. Previous versions were 1.0, 1.1, and 1.2. (There was no 1.3.) The standard JMX Remote API is defined to work with version 1.2 onwards, so in standards-based deployment the only interoperability questions that arise concern version 1.2 onwards.</source>
          <target state="translated">클라이언트가 JMX Remote API를 사용하여 서버에 연결하면 동일한 버전의 JMX 스펙이 없을 수 있습니다. 여기에 설명 된 JMX 스펙의 버전은 1.4입니다. 이전 버전은 1.0, 1.1 및 1.2입니다. (1.3이 없었습니다.) 표준 JMX Remote API는 버전 1.2 이상에서 작동하도록 정의되었으므로 표준 기반 배치에서는 버전 1.2 이상에서 발생하는 유일한 상호 운용성 질문입니다.</target>
        </trans-unit>
        <trans-unit id="9ecf260d1def47441248c5413c0dd40de5045eac" translate="yes" xml:space="preserve">
          <source>When a client needs to print a job using the client's desired resolution exactly (no more, no less), the client specifies an instance of class &lt;code&gt;PrinterResolution&lt;/code&gt; as an attribute of the Print Job. This will fail if the Print Job doesn't support that exact resolution, and &lt;code&gt;Fidelity&lt;/code&gt; is set to true.</source>
          <target state="translated">When a client needs to print a job using the client's desired resolution exactly (no more, no less), the client specifies an instance of class &lt;code&gt;PrinterResolution&lt;/code&gt; as an attribute of the Print Job. This will fail if the Print Job doesn't support that exact resolution, and &lt;code&gt;Fidelity&lt;/code&gt; is set to true.</target>
        </trans-unit>
        <trans-unit id="c8a48941832ba5a4328e80c08b8ffedc13963178" translate="yes" xml:space="preserve">
          <source>When a client needs to print a job using the client's desired resolution exactly (no more, no less), the client specifies an instance of class PrinterResolution as an attribute of the Print Job. This will fail if the Print Job doesn't support that exact resolution, and Fidelity is set to true.</source>
          <target state="translated">클라이언트가 클라이언트가 원하는 해상도를 정확하게 사용하여 작업을 인쇄해야하는 경우 클라이언트는 PrinterResolution 클래스의 인스턴스를 인쇄 작업의 속성으로 지정합니다. 인쇄 작업이 정확한 해상도를 지원하지 않고 Fidelity가 true로 설정되어 있으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a335dacd4eaf5c3bce2ba4fb08c4775392c61b2f" translate="yes" xml:space="preserve">
          <source>When a client searches looking for a printer that supports the client's desired resolution exactly (no more, no less), the client specifies an instance of class &lt;code&gt;PrinterResolution&lt;/code&gt; indicating the exact resolution the client wants. Only printers supporting that exact resolution will match the search.</source>
          <target state="translated">클라이언트가 클라이언트가 원하는 해상도를 정확하게 지원하는 프린터를 검색 할 때 (더 이상도 그 이하도 아님) 클라이언트 는 클라이언트가 원하는 정확한 해상도를 나타내는 &lt;code&gt;PrinterResolution&lt;/code&gt; 클래스의 인스턴스를 지정합니다 . 정확한 해상도를 지원하는 프린터 만 검색과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7de20097d88ff779f4bae860f8ac5bfcc78b886f" translate="yes" xml:space="preserve">
          <source>When a client searches looking for a printer that supports the client's desired resolution exactly (no more, no less), the client specifies an instance of class PrinterResolution indicating the exact resolution the client wants. Only printers supporting that exact resolution will match the search.</source>
          <target state="translated">클라이언트가 클라이언트의 원하는 해상도를 정확하게 (더 이상, 더 이상) 지원하지 않는 프린터를 찾을 때 클라이언트는 클라이언트가 원하는 정확한 해상도를 나타내는 PrinterResolution 클래스의 인스턴스를 지정합니다. 정확한 해상도를 지원하는 프린터 만 검색과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="af75d22b50227d1fb5318634310fcd020e5b369c" translate="yes" xml:space="preserve">
          <source>When a coded character set is used exclusively with a single character-encoding scheme then the corresponding charset is usually named for the coded character set; otherwise a charset is usually named for the encoding scheme and, possibly, the locale of the coded character sets that it supports. Hence &lt;code&gt;US-ASCII&lt;/code&gt; is both the name of a coded character set and of the charset that encodes it, while &lt;code&gt;EUC-JP&lt;/code&gt; is the name of the charset that encodes the JIS X 0201, JIS X 0208, and JIS X 0212 coded character sets for the Japanese language.</source>
          <target state="translated">코드화 된 문자 세트가 단일 문자 인코딩 체계와 함께 독점적으로 사용되는 경우 해당 문자 세트는 일반적으로 코드화 된 문자 세트의 이름이 지정됩니다. 그렇지 않은 경우, 캐릭터 세트는 일반적으로 인코딩 방식과, 지원되는 코드화 된 문자 세트의 로케일로 이름이 지정됩니다. 따라서 &lt;code&gt;US-ASCII&lt;/code&gt; 는 코드화 된 문자 세트와이를 인코딩하는 문자 세트 의 이름이며 &lt;code&gt;EUC-JP&lt;/code&gt; 는 JIS X 0201, JIS X 0208 및 JIS X 0212 코드화 된 문자 세트를 인코딩하는 문자 세트의 이름입니다. 일본어</target>
        </trans-unit>
        <trans-unit id="359074a92233f14fabd3c8c60b9f6a18661913d1" translate="yes" xml:space="preserve">
          <source>When a column is adjusted in the UI, adjust the next column the opposite way.</source>
          <target state="translated">UI에서 열이 조정되면 반대 방식으로 다음 열을 조정합니다.</target>
        </trans-unit>
        <trans-unit id="abc368889970e1798a7b82782b317df91eb75a92" translate="yes" xml:space="preserve">
          <source>When a concrete &lt;code&gt;DragGestureRecognizer&lt;/code&gt; instance detects a drag initiating gesture on the &lt;code&gt;Component&lt;/code&gt; it is associated with, it fires a &lt;a href=&quot;draggestureevent&quot;&gt;&lt;code&gt;DragGestureEvent&lt;/code&gt;&lt;/a&gt; to the &lt;code&gt;DragGestureListener&lt;/code&gt; registered on its unicast event source for &lt;code&gt;DragGestureListener&lt;/code&gt; events. This &lt;code&gt;DragGestureListener&lt;/code&gt; is responsible for causing the associated &lt;code&gt;DragSource&lt;/code&gt; to start the Drag and Drop operation (if appropriate).</source>
          <target state="translated">구체적인 경우 &lt;code&gt;DragGestureRecognizer&lt;/code&gt; 인스턴스에 드래그 개시 제스처 (gesture) 감지 &lt;code&gt;Component&lt;/code&gt; 가와 연관되어, 그것은 발사 &lt;a href=&quot;draggestureevent&quot;&gt; &lt;code&gt;DragGestureEvent&lt;/code&gt; &lt;/a&gt; 받는 &lt;code&gt;DragGestureListener&lt;/code&gt; 에 대한 유니 캐스트 이벤트 소스에 등록되어 &lt;code&gt;DragGestureListener&lt;/code&gt; 이벤트를. 이 &lt;code&gt;DragGestureListener&lt;/code&gt; 는 관련 &lt;code&gt;DragSource&lt;/code&gt; 가 드래그 앤 드롭 작업을 시작 하도록하는 역할을 합니다 (해당되는 경우).</target>
        </trans-unit>
        <trans-unit id="53280a61faf78dcb3ec848c2e2ddbf8b1f48355d" translate="yes" xml:space="preserve">
          <source>When a constructor or getter method that takes a &lt;code&gt;Map&lt;/code&gt; object is called, the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the SQL type of the UDT being custom mapped. The driver creates an instance of &lt;code&gt;SQLInputImpl&lt;/code&gt;, populating it with the attributes of the UDT. The driver then passes the input stream to the method &lt;code&gt;SQLData.readSQL&lt;/code&gt;, which in turn calls the &lt;code&gt;SQLInputImpl&lt;/code&gt; methods to read the attributes from the input stream.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 개체 를 사용하는 생성자 또는 getter 메서드 가 호출되면 JDBC 드라이버는 &lt;code&gt;SQLData.getSQLType&lt;/code&gt; 메서드 를 호출하여 사용자 지정 매핑되는 UDT의 SQL 유형을 결정합니다. 드라이버는 &lt;code&gt;SQLInputImpl&lt;/code&gt; 의 인스턴스를 생성 하여 UDT의 속성으로 채 웁니다. 그런 다음 드라이버는 입력 스트림을 &lt;code&gt;SQLData.readSQL&lt;/code&gt; 메소드로 전달하고 , 그러면 &lt;code&gt;SQLInputImpl&lt;/code&gt; 메소드를 호출 하여 입력 스트림에서 속성을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5046ecec5b32705f3cc717979a666d129f7eb365" translate="yes" xml:space="preserve">
          <source>When a context method that may return response controls is invoked, response controls from the previous method invocation are cleared. &lt;code&gt;getResponseControls()&lt;/code&gt; returns all of the response controls generated by LDAP operations used by the context method in the order received from the LDAP server. Invoking &lt;code&gt;getResponseControls()&lt;/code&gt; does not clear the response controls. You can call it many times (and get back the same controls) until the next context method that may return controls is invoked.</source>
          <target state="translated">응답 제어를 리턴 할 수있는 컨텍스트 메소드가 호출되면 이전 메소드 호출의 응답 제어가 지워집니다. &lt;code&gt;getResponseControls()&lt;/code&gt; 는 컨텍스트 메소드가 사용하는 LDAP 조작에 의해 생성 된 모든 응답 제어를 LDAP 서버로부터 수신 된 순서로 리턴합니다. &lt;code&gt;getResponseControls()&lt;/code&gt; 호출 해도 응답 제어가 지워지지 않습니다. 컨트롤을 반환 할 수있는 다음 컨텍스트 메서드가 호출 될 때까지 여러 번 호출하고 동일한 컨트롤을 다시 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d82dfd1d5fb556b3eaa04ee5dbf7ee49fcca1a9" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry in the directory has been modified. The event &lt;a href=&quot;watchevent#count()&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is &lt;code&gt;1&lt;/code&gt; or greater.</source>
          <target state="translated">이 이벤트에 대해 디렉토리가 등록되면 디렉토리 의 항목이 수정 된 것이 관찰되면 &lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt; 가 대기열에 추가됩니다. 이 이벤트의 이벤트 &lt;a href=&quot;watchevent#count()&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;1&lt;/code&gt; 이상입니다.</target>
        </trans-unit>
        <trans-unit id="451ee1cb627eed78bb98b62c3c2b734285d519cd" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry in the directory has been modified. The event &lt;a href=&quot;watchevent#count--&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is &lt;code&gt;1&lt;/code&gt; or greater.</source>
          <target state="translated">이 이벤트에 디렉토리가 등록되면 디렉토리 의 항목이 수정 된 것을 발견 하면 &lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt; 가 대기합니다. 이 이벤트의 이벤트 &lt;a href=&quot;watchevent#count--&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;1&lt;/code&gt; 이상입니다.</target>
        </trans-unit>
        <trans-unit id="54c77a330dd41951e46e4b4a1e88cbe19100d080" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry is created in the directory or renamed into the directory. The event &lt;a href=&quot;watchevent#count()&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">이 이벤트에 대한 디렉토리가 등록되면 디렉토리 에 항목이 생성되거나 디렉토리로 이름이 변경된 것이 관찰 될 때 &lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt; 가 대기열에 추가됩니다. 이 이벤트의 이벤트 &lt;a href=&quot;watchevent#count()&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 는 항상 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="acde6e0c9e549621383ae5222820b57635b1abdb" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry is created in the directory or renamed into the directory. The event &lt;a href=&quot;watchevent#count--&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">이 이벤트에 디렉토리가 등록되면 디렉토리 에서 항목이 작성되거나 디렉토리로 이름이 바뀐 것을 발견 하면 &lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt; 가 대기합니다. 이 이벤트의 이벤트 &lt;a href=&quot;watchevent#count--&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 는 항상 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a027f021c399f6f07c85633b797d323c94d4cfee" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry is deleted or renamed out of the directory. The event &lt;a href=&quot;watchevent#count()&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">이 이벤트에 대해 디렉토리가 등록되면 항목이 디렉토리에서 삭제되거나 이름이 변경된 것이 관찰되면 &lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt; 가 대기열에 추가됩니다. 이 이벤트의 이벤트 &lt;a href=&quot;watchevent#count()&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 는 항상 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4aa389d8c3635d68f9942230af80f43edbcdf866" translate="yes" xml:space="preserve">
          <source>When a directory is registered for this event then the &lt;a href=&quot;watchkey&quot;&gt;&lt;code&gt;WatchKey&lt;/code&gt;&lt;/a&gt; is queued when it is observed that an entry is deleted or renamed out of the directory. The event &lt;a href=&quot;watchevent#count--&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; for this event is always &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">이 이벤트에 디렉토리가 등록되면 항목이 디렉토리에서 삭제되거나 이름이 바뀐 것을 발견 하면 &lt;a href=&quot;watchkey&quot;&gt; &lt;code&gt;WatchKey&lt;/code&gt; &lt;/a&gt; 가 대기합니다. 이 이벤트의 이벤트 &lt;a href=&quot;watchevent#count--&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 는 항상 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="134eb2244461f191f7d57bf1761d699a4a619aa5" translate="yes" xml:space="preserve">
          <source>When a document is first made available via the DOM, there is only one &lt;code&gt;Text&lt;/code&gt; node for each block of text. Users may create adjacent &lt;code&gt;Text&lt;/code&gt; nodes that represent the contents of a given element without any intervening markup, but should be aware that there is no way to represent the separations between these nodes in XML or HTML, so they will not (in general) persist between DOM editing sessions. The &lt;code&gt;Node.normalize()&lt;/code&gt; method merges any such adjacent &lt;code&gt;Text&lt;/code&gt; objects into a single node for each block of text.</source>
          <target state="translated">DOM을 통해 문서를 처음 사용할 수있게되면 각 텍스트 블록에 대해 하나의 &lt;code&gt;Text&lt;/code&gt; 노드 만 있습니다. 사용자는 중간에 마크 업없이 주어진 요소의 내용을 나타내는 인접한 &lt;code&gt;Text&lt;/code&gt; 노드를 만들 수 있지만 이러한 노드 간의 구분을 XML 또는 HTML로 나타낼 수있는 방법이 없으므로 (일반적으로) 서로간에 지속되지 않습니다. DOM 편집 세션. &lt;code&gt;Node.normalize()&lt;/code&gt; 메소드는 이러한 인접 병합 &lt;code&gt;Text&lt;/code&gt; 각 텍스트 블록에 대해 하나의 노드에 오브젝트.</target>
        </trans-unit>
        <trans-unit id="b4da85dd003901db71000007023e7612e6748206" translate="yes" xml:space="preserve">
          <source>When a drag gesture occurs, the &lt;code&gt;DragSource&lt;/code&gt;'s startDrag() method shall be invoked in order to cause processing of the user's navigational gestures and delivery of Drag and Drop protocol notifications. A &lt;code&gt;DragSource&lt;/code&gt; shall only permit a single Drag and Drop operation to be current at any one time, and shall reject any further startDrag() requests by throwing an &lt;code&gt;IllegalDnDOperationException&lt;/code&gt; until such time as the extant operation is complete.</source>
          <target state="translated">드래그 제스처가 발생 하면 사용자의 탐색 제스처를 처리하고 드래그 앤 드롭 프로토콜 알림을 전달하기 위해 &lt;code&gt;DragSource&lt;/code&gt; 의 startDrag () 메서드가 호출되어야합니다. &lt;code&gt;DragSource&lt;/code&gt; 단일 드래그 앤 드롭 동작 중 어느 하나의 시점을 할 수 있도록한다 만, 및 던지는 더하여 startDrag () 요청을 거부한다 &lt;code&gt;IllegalDnDOperationException&lt;/code&gt; 을 현존하는 작동이 완료되는 때까지.</target>
        </trans-unit>
        <trans-unit id="c6e54cb2e2ced5f516b5c3c711efdeb13fed62ee" translate="yes" xml:space="preserve">
          <source>When a file system is constructed to access the contents of a file as a file system then it is highly implementation specific if the returned URI represents the given path in the file system or it represents a &lt;em&gt;compound&lt;/em&gt; URI that encodes the URI of the enclosing file system. A format for compound URIs is not defined in this release; such a scheme may be added in a future release.</source>
          <target state="translated">파일 시스템이 파일의 파일 내용으로 파일의 내용에 액세스하도록 구성된 경우 반환 된 URI가 파일 시스템의 지정된 경로를 나타내거나 파일 시스템의 URI를 인코딩 하는 &lt;em&gt;복합&lt;/em&gt; URI를 나타내는 경우 구현에 따라 다릅니다. . 복합 릴리스의 형식은이 릴리스에서 정의되지 않았습니다. 이러한 구성표는 향후 릴리스에서 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="920d75d308d8cfd3c9e9c09baeeb65ab14384dc3" translate="yes" xml:space="preserve">
          <source>When a file system provides access to a set of &lt;a href=&quot;../filestore&quot;&gt;&lt;code&gt;file-systems&lt;/code&gt;&lt;/a&gt; that are not homogeneous then only some of the file systems may support ACLs. The &lt;a href=&quot;../filestore#supportsFileAttributeView(java.lang.Class)&quot;&gt;&lt;code&gt;supportsFileAttributeView&lt;/code&gt;&lt;/a&gt; method can be used to test if a file system supports ACLs.</source>
          <target state="translated">파일 시스템 이 동종이 아닌 &lt;a href=&quot;../filestore&quot;&gt; &lt;code&gt;file-systems&lt;/code&gt; &lt;/a&gt; 집합에 대한 액세스를 제공하면 일부 파일 시스템 만 ACL을 지원할 수 있습니다. &lt;a href=&quot;../filestore#supportsFileAttributeView(java.lang.Class)&quot;&gt; &lt;code&gt;supportsFileAttributeView&lt;/code&gt; 의&lt;/a&gt; 파일 시스템이 ACL을 지원하는 경우 방법은 테스트하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f8424e3622daa52db1d5d000f4c2d226449bfeb" translate="yes" xml:space="preserve">
          <source>When a file system provides access to a set of &lt;a href=&quot;../filestore&quot;&gt;&lt;code&gt;file-systems&lt;/code&gt;&lt;/a&gt; that are not homogeneous then only some of the file systems may support ACLs. The &lt;a href=&quot;../filestore#supportsFileAttributeView-java.lang.Class-&quot;&gt;&lt;code&gt;supportsFileAttributeView&lt;/code&gt;&lt;/a&gt; method can be used to test if a file system supports ACLs.</source>
          <target state="translated">파일 시스템 이 동종이 아닌 &lt;a href=&quot;../filestore&quot;&gt; &lt;code&gt;file-systems&lt;/code&gt; &lt;/a&gt; 세트에 대한 액세스를 제공하는 경우 일부 파일 시스템 만 ACL을 지원할 수 있습니다. &lt;a href=&quot;../filestore#supportsFileAttributeView-java.lang.Class-&quot;&gt; &lt;code&gt;supportsFileAttributeView&lt;/code&gt; 의&lt;/a&gt; 파일 시스템이 ACL을 지원하는 경우 방법은 테스트하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2513b009af422c9e2dc954b7cd7076a8523df7e6" translate="yes" xml:space="preserve">
          <source>When a filter is provided, the implementation will call out to the filter as it is constructing the DOM tree structure.</source>
          <target state="translated">필터가 제공되면 구현은 DOM 트리 구조를 구성 할 때 필터를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b140beb62778d75da1fe8212e3da055f629c25ea" translate="yes" xml:space="preserve">
          <source>When a filter is provided, the implementation will call out to the filter as it is constructing the DOM tree structure. The filter can choose to remove elements from the document being constructed, or to terminate the parsing early.</source>
          <target state="translated">필터가 제공되면 구현은 DOM 트리 구조를 구성 할 때 필터를 호출합니다. 필터는 생성중인 문서에서 요소를 제거하거나 파싱을 조기에 종료하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="563c181caf51bc9ca81a53828adbe47768c2b0e3" translate="yes" xml:space="preserve">
          <source>When a flush occurs on a newly created node, it is made persistent, as are any ancestors (and descendants) that have yet to be made persistent. Note however that any preference value changes in ancestors are</source>
          <target state="translated">새로 작성된 노드에서 플러시가 발생하면 아직 지속되지 않은 조상 (및 자손)과 마찬가지로 플러시가 지속됩니다. 그러나 조상의 환경 설정 값 변경은</target>
        </trans-unit>
        <trans-unit id="1d4a0847838b4b0259eb6a3663209d9fef15018e" translate="yes" xml:space="preserve">
          <source>When a frame is in maximized state the system supplies some defaults bounds. This method allows some or all of those system supplied values to be overridden.</source>
          <target state="translated">프레임이 최대화 된 상태 일 때 시스템은 일부 기본 경계를 제공합니다. 이 메서드를 사용하면 시스템 제공 값의 일부 또는 전부를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14b01570d43320be8d365211a70fea5fddceea53" translate="yes" xml:space="preserve">
          <source>When a guarded delegator is created from a guarded pair, the pair is wrapped in a new method handle &lt;code&gt;M&lt;/code&gt;, which is permanently associated with the switch point that created it. Each pair consists of a target &lt;code&gt;T&lt;/code&gt; and a fallback &lt;code&gt;F&lt;/code&gt;. While the switch point is valid, invocations to &lt;code&gt;M&lt;/code&gt; are delegated to &lt;code&gt;T&lt;/code&gt;. After it is invalidated, invocations are delegated to &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">보호 된 델리 게이터가 보호 된 쌍에서 생성되면이 쌍은 새로운 메서드 핸들 &lt;code&gt;M&lt;/code&gt; 에 래핑됩니다.이 메서드 는 스위치를 생성 한 스위치 지점과 영구적으로 연결됩니다. 각 쌍은 대상 &lt;code&gt;T&lt;/code&gt; 와 폴백 &lt;code&gt;F&lt;/code&gt; 로 구성됩니다 . 전환점이 유효하지만 &lt;code&gt;M&lt;/code&gt; 에 대한 호출 은 &lt;code&gt;T&lt;/code&gt; 에 위임됩니다 . 무효화 된 후, 호출은 &lt;code&gt;F&lt;/code&gt; 에 위임됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e4ff9b2bc60835e3eb9b787ed7b76295168a994" translate="yes" xml:space="preserve">
          <source>When a listener instance invokes &lt;code&gt;NamingEvent.getEventContext()&lt;/code&gt;, it must take into account the possibility that other threads will be working with that context concurrently. Likewise, when a listener is registered via &lt;code&gt;addNamingListener()&lt;/code&gt;, the registering thread must take into account the likely possibility that the service provider will later invoke the listeners in newly-created threads. As &lt;code&gt;Context&lt;/code&gt; instances are not guaranteed to be thread-safe in general, all context operations must be synchronized as needed.</source>
          <target state="translated">리스너 인스턴스가 &lt;code&gt;NamingEvent.getEventContext()&lt;/code&gt; 를 호출 할 때 다른 스레드가 해당 컨텍스트와 동시에 작업 할 가능성을 고려해야합니다. 마찬가지로 리스너가 &lt;code&gt;addNamingListener()&lt;/code&gt; 를 통해 등록되면 등록 스레드는 서비스 제공자가 나중에 새로 작성된 스레드에서 리스너를 호출 할 가능성을 고려해야합니다. 로 &lt;code&gt;Context&lt;/code&gt; 인스턴스가 스레드 안전 일반적으로 보장되지 않습니다 필요에 따라, 모든 상황에 맞는 동작을 동기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf04634d7ff1db386d9b9db0fb748a111b1c6a04" translate="yes" xml:space="preserve">
          <source>When a listener registers for events with a context, the context might need to do some internal processing in order to collect information required to generate the events. The context, for example, might need to make a request to the server to register interest in changes on the server that will eventually be translated into events. If an exception occurs that prevents information about the events from being collected, the listener will never be notified of the events. When such an exception occurs, a &lt;code&gt;NamingExceptionEvent&lt;/code&gt; is fired to notify the listener. The listener's &lt;code&gt;namingExceptionThrown()&lt;/code&gt; method is invoked, as shown in the sample code above, and the listener is automatically deregistered.</source>
          <target state="translated">리스너가 컨텍스트에 이벤트를 등록 할 때, 이벤트를 생성하는 데 필요한 정보를 수집하기 위해 컨텍스트가 내부 처리를 수행해야 할 수도 있습니다. 예를 들어, 컨텍스트는 결국 이벤트로 변환 될 서버의 변경 사항에 관심을 등록하기 위해 서버에 요청해야 할 수도 있습니다. 이벤트에 대한 정보가 수집되지 못하게하는 예외가 발생하면 리스너에게 이벤트에 대한 알림을받지 않습니다. 이러한 예외가 발생 하면 리스너에게 알리기 위해 &lt;code&gt;NamingExceptionEvent&lt;/code&gt; 가 발생합니다. 위의 샘플 코드에 표시된대로 리스너의 &lt;code&gt;namingExceptionThrown()&lt;/code&gt; 메소드가 호출되고 리스너가 자동으로 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="88240763f016e704f50f91eea618ff29da324203" translate="yes" xml:space="preserve">
          <source>When a menu item is selected, AWT sends an action event to the menu item. Since the event is an instance of &lt;code&gt;ActionEvent&lt;/code&gt;, the &lt;code&gt;processEvent&lt;/code&gt; method examines the event and passes it along to &lt;code&gt;processActionEvent&lt;/code&gt;. The latter method redirects the event to any &lt;code&gt;ActionListener&lt;/code&gt; objects that have registered an interest in action events generated by this menu item.</source>
          <target state="translated">메뉴 항목이 선택되면 AWT는 메뉴 항목에 조치 이벤트를 보냅니다. 이벤트의 예이므로 &lt;code&gt;ActionEvent&lt;/code&gt; 를 상기 &lt;code&gt;processEvent&lt;/code&gt; 있어서 이벤트를 검사에 따라이를 전달 &lt;code&gt;processActionEvent&lt;/code&gt; . 후자의 메소드 는이 메뉴 항목에 의해 생성 된 조치 이벤트에 대한 관심을 등록한 모든 &lt;code&gt;ActionListener&lt;/code&gt; 오브젝트로 이벤트를 리디렉션합니다 .</target>
        </trans-unit>
        <trans-unit id="90dd254c09d1c776ecf5c2349e720c462b943059" translate="yes" xml:space="preserve">
          <source>When a method handle is obtained by executing an &lt;code&gt;ldc&lt;/code&gt; instruction of a &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; constant, and the target method is marked as a variable arity method (with the modifier bit &lt;code&gt;0x0080&lt;/code&gt;), the method handle will accept multiple arities, as if the method handle constant were created by means of a call to &lt;code&gt;asVarargsCollector&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; 상수 의 &lt;code&gt;ldc&lt;/code&gt; 명령을 실행하여 메소드 핸들을 확보 하고 대상 메소드가 가변 arity 메소드 (수정 자 비트 &lt;code&gt;0x0080&lt;/code&gt; )로 표시되면 메소드 핸들은 메소드 핸들 상수가 &lt;code&gt;asVarargsCollector&lt;/code&gt; 를 호출하여 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="dc59d96f42634aad08455afa57812c0140efcb78" translate="yes" xml:space="preserve">
          <source>When a method handle to a virtual method is invoked, the method is always looked up in the receiver (that is, the first argument).</source>
          <target state="translated">가상 메소드에 대한 메소드 핸들이 호출되면 메소드는 항상 수신자 (즉, 첫 번째 인수)에서 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="ac3ed4c5aa8581e47e6e1d20592079740b067ad7" translate="yes" xml:space="preserve">
          <source>When a method such as list(), listBindings(), or search() returns a NamingEnumeration, any exceptions encountered are reserved until all results have been returned. At the end of the enumeration, the exception is thrown (by hasMore());</source>
          <target state="translated">list (), listBindings () 또는 search ()와 같은 메서드가 NamingEnumeration을 반환하면 모든 결과가 반환 될 때까지 발생한 예외가 예약됩니다. 열거가 끝나면 예외가 발생합니다 (hasMore ()에 의해).</target>
        </trans-unit>
        <trans-unit id="c77f58a997936db72fbff2f59c022214ac8f5bcc" translate="yes" xml:space="preserve">
          <source>When a module declares that the provider class is created by a provider factory then this method returns the return type of its public static &quot;&lt;code&gt;provider()&lt;/code&gt;&quot; method.</source>
          <target state="translated">모듈이 공급자 클래스가 공급자 팩토리에 의해 생성되었다고 선언하면이 메서드는 공용 정적 &quot; &lt;code&gt;provider()&lt;/code&gt; &quot;메서드 의 반환 유형을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="98cbaeab94a8ea21799291ebebb2b9e8ca8b5128" translate="yes" xml:space="preserve">
          <source>When a module is deprecated, the use of that module in &lt;code&gt;
 requires&lt;/code&gt;, but not in &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;opens&lt;/code&gt; clauses causes a warning to be issued. A module being deprecated does &lt;em&gt;not&lt;/em&gt; cause warnings to be issued for uses of types within the module.</source>
          <target state="translated">모듈이 더 이상 사용되지 않는 경우 해당 모듈을 &lt;code&gt; requires&lt;/code&gt; 에서 사용하지만 &lt;code&gt;exports&lt;/code&gt; 또는 &lt;code&gt;opens&lt;/code&gt; 절 에서는 사용하지 않으면 경고가 발생합니다. 더 이상 사용되지 &lt;em&gt;않는&lt;/em&gt; 모듈은 모듈 내의 유형 사용에 대한 경고를 발행 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d555a5a6abfd38f83f82a291e707b2b58a5605e9" translate="yes" xml:space="preserve">
          <source>When a mouse button is clicked, events are generated and sent to the registered &lt;code&gt;MouseListener&lt;/code&gt;s. The state of modal keys can be retrieved using &lt;a href=&quot;inputevent#getModifiers()&quot;&gt;&lt;code&gt;InputEvent.getModifiers()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;inputevent#getModifiersEx()&quot;&gt;&lt;code&gt;InputEvent.getModifiersEx()&lt;/code&gt;&lt;/a&gt;. The button mask returned by &lt;a href=&quot;inputevent#getModifiers()&quot;&gt;&lt;code&gt;InputEvent.getModifiers()&lt;/code&gt;&lt;/a&gt; reflects only the button that changed state, not the current state of all buttons. (Note: Due to overlap in the values of ALT_MASK/BUTTON2_MASK and META_MASK/BUTTON3_MASK, this is not always true for mouse events involving modifier keys). To get the state of all buttons and modifier keys, use &lt;a href=&quot;inputevent#getModifiersEx()&quot;&gt;&lt;code&gt;InputEvent.getModifiersEx()&lt;/code&gt;&lt;/a&gt;. The button which has changed state is returned by &lt;a href=&quot;#getButton()&quot;&gt;&lt;code&gt;getButton()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">마우스 버튼을 클릭하면 이벤트가 생성되어 등록 된 &lt;code&gt;MouseListener&lt;/code&gt; 로 전송됩니다 . 모달 키의 상태는 &lt;a href=&quot;inputevent#getModifiers()&quot;&gt; &lt;code&gt;InputEvent.getModifiers()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;inputevent#getModifiersEx()&quot;&gt; &lt;code&gt;InputEvent.getModifiersEx()&lt;/code&gt; &lt;/a&gt; 사용하여 검색 할 수 있습니다 . &lt;a href=&quot;inputevent#getModifiers()&quot;&gt; &lt;code&gt;InputEvent.getModifiers()&lt;/code&gt; &lt;/a&gt; 반환 된 버튼 마스크 는 모든 버튼의 현재 상태가 아닌 상태를 변경 한 버튼 만 반영합니다. (참고 : ALT_MASK / BUTTON2_MASK 및 META_MASK / BUTTON3_MASK 값이 겹치기 때문에 수정 자 키가 포함 된 마우스 이벤트의 경우 항상 해당되지는 않습니다.) 모든 버튼 및 수정 자 키의 상태를 가져 오려면 &lt;a href=&quot;inputevent#getModifiersEx()&quot;&gt; &lt;code&gt;InputEvent.getModifiersEx()&lt;/code&gt; &lt;/a&gt; . 상태가 변경된 버튼은 &lt;a href=&quot;#getButton()&quot;&gt; &lt;code&gt;getButton()&lt;/code&gt; &lt;/a&gt; 에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="00112656e542a277ccbb970384f5707477b0e0b9" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt; object is created, initially this field is set to null. This field will &lt;em&gt;NOT&lt;/em&gt; be inherited to &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt;s, or &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt;s that are created from this &lt;a href=&quot;schemafactory&quot;&gt;&lt;code&gt;SchemaFactory&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새 &lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt; 객체가 생성되면 처음에이 필드는 null로 설정됩니다. 이 필드는 이 &lt;a href=&quot;schemafactory&quot;&gt; &lt;code&gt;SchemaFactory&lt;/code&gt; &lt;/a&gt; 에서 생성 된 &lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt; 로 상속 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3e086a8e7068102271cf7d6fcc1d6a613e3a6593" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;validator&quot;&gt;&lt;code&gt;Validator&lt;/code&gt;&lt;/a&gt; object is created, initially this field is set to null.</source>
          <target state="translated">새 &lt;a href=&quot;validator&quot;&gt; &lt;code&gt;Validator&lt;/code&gt; &lt;/a&gt; 객체가 생성되면 처음에이 필드는 null로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="55a52e9d9430d2238010dc383d8d5a916e167cd6" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; object is created, initially this field is set to null.</source>
          <target state="translated">새 &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; &lt;/a&gt; 객체가 생성되면 처음에이 필드는 null로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a16476348451a202ec7241c549e271abf68b5efa" translate="yes" xml:space="preserve">
          <source>When a new connection is accepted then the resulting &lt;code&gt;
 AsynchronousSocketChannel&lt;/code&gt; will be bound to the same &lt;a href=&quot;asynchronouschannelgroup&quot;&gt;&lt;code&gt;AsynchronousChannelGroup&lt;/code&gt;&lt;/a&gt; as this channel. If the group is &lt;a href=&quot;asynchronouschannelgroup#isShutdown()&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; and a connection is accepted, then the connection is closed, and the operation completes with an &lt;code&gt;
 IOException&lt;/code&gt; and cause &lt;a href=&quot;shutdownchannelgroupexception&quot;&gt;&lt;code&gt;ShutdownChannelGroupException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새 연결이 수락되면 결과 &lt;code&gt; AsynchronousSocketChannel&lt;/code&gt; 이이 채널 과 동일한 &lt;a href=&quot;asynchronouschannelgroup&quot;&gt; &lt;code&gt;AsynchronousChannelGroup&lt;/code&gt; 에&lt;/a&gt; 바인딩됩니다 . 그룹이 &lt;a href=&quot;asynchronouschannelgroup#isShutdown()&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt; 되고 연결이 수락되면 연결이 닫히고 작업이 &lt;code&gt; IOException&lt;/code&gt; 과 함께 완료되고 &lt;a href=&quot;shutdownchannelgroupexception&quot;&gt; &lt;code&gt;ShutdownChannelGroupException&lt;/code&gt; 이&lt;/a&gt; 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="eaa5aba63dd9f02bc423da3760cc790334dde37c" translate="yes" xml:space="preserve">
          <source>When a new connection is accepted then the resulting &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; will be bound to the same &lt;a href=&quot;asynchronouschannelgroup&quot;&gt;&lt;code&gt;AsynchronousChannelGroup&lt;/code&gt;&lt;/a&gt; as this channel. If the group is &lt;a href=&quot;asynchronouschannelgroup#isShutdown--&quot;&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/a&gt; and a connection is accepted, then the connection is closed, and the operation completes with an &lt;code&gt;IOException&lt;/code&gt; and cause &lt;a href=&quot;shutdownchannelgroupexception&quot;&gt;&lt;code&gt;ShutdownChannelGroupException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새 연결이 수락되면 결과 &lt;code&gt;AsynchronousSocketChannel&lt;/code&gt; 이이 채널 과 동일한 &lt;a href=&quot;asynchronouschannelgroup&quot;&gt; &lt;code&gt;AsynchronousChannelGroup&lt;/code&gt; 에&lt;/a&gt; 바인딩됩니다 . 그룹이 &lt;a href=&quot;asynchronouschannelgroup#isShutdown--&quot;&gt; &lt;code&gt;shutdown&lt;/code&gt; &lt;/a&gt; 되고 연결이 승인되면 연결이 닫히고 작업이 &lt;code&gt;IOException&lt;/code&gt; 으로 완료되고 &lt;a href=&quot;shutdownchannelgroupexception&quot;&gt; &lt;code&gt;ShutdownChannelGroupException&lt;/code&gt; 이&lt;/a&gt; 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="b6d8a70cca16fc1a092f3e5b3fb7136e528d4e86" translate="yes" xml:space="preserve">
          <source>When a numeric shaper is defined, the text is first processed by the shaper before any other analysis of the text is performed.</source>
          <target state="translated">숫자 셰이퍼가 정의되면 텍스트의 다른 분석이 수행되기 전에 셰이퍼가 텍스트를 먼저 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f20b7bb9a7a0ed971069cd4bd43c35163e0303e3" translate="yes" xml:space="preserve">
          <source>When a printer controls more than one output device, this reason indicates that one or more output devices are stopped.</source>
          <target state="translated">프린터가 둘 이상의 출력 장치를 제어하는 ​​경우이 이유는 하나 이상의 출력 장치가 중지되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="57b0000a9696b1c366c87328582e275d001b7acb" translate="yes" xml:space="preserve">
          <source>When a printer controls more than one output device, this reason indicates that one or more output devices are stopped. If the reason's severity is a report, fewer than half of the output devices are stopped. If the reason's severity is a warning, half or more but fewer than all of the output devices are stopped.</source>
          <target state="translated">프린터가 둘 이상의 출력 장치를 제어 할 때 하나 이상의 출력 장치가 중지되었음을 나타냅니다. 이유의 심각도가 보고서 인 경우 출력 장치의 절반 미만이 중지됩니다. 이유의 심각도가 경고 인 경우, 모든 출력 장치의 절반 이상이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="ccb21bbf1cfa3412cab733738537427c4a4c474e" translate="yes" xml:space="preserve">
          <source>When a proxy selector is registered, for instance, a subclass of URLConnection class should call the &lt;a href=&quot;#select(java.net.URI)&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; method for each URL request so that the proxy selector can decide if a direct, or proxied connection should be used. The &lt;a href=&quot;#select(java.net.URI)&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; method returns an iterator over a collection with the preferred connection approach.</source>
          <target state="translated">예를 들어 프록시 선택기가 등록되면 URLConnection 클래스의 하위 클래스가 각 URL 요청에 대해 &lt;a href=&quot;#select(java.net.URI)&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 메서드를 호출 하여 프록시 선택기가 직접 연결 또는 프록시 연결을 사용해야하는지 결정할 수 있습니다. &lt;a href=&quot;#select(java.net.URI)&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 방법은 추천의 접속 방법으로 컬렉션의 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48145dbd368db04ca5f1dc84946f81ac044581d7" translate="yes" xml:space="preserve">
          <source>When a proxy selector is registered, for instance, a subclass of URLConnection class should call the &lt;a href=&quot;proxyselector#select-java.net.URI-&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; method for each URL request so that the proxy selector can decide if a direct, or proxied connection should be used. The &lt;a href=&quot;proxyselector#select-java.net.URI-&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; method returns an iterator over a collection with the preferred connection approach.</source>
          <target state="translated">예를 들어 프록시 선택기가 등록되면 URLConnection 클래스의 하위 클래스가 각 URL 요청에 대해 &lt;a href=&quot;proxyselector#select-java.net.URI-&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 메소드를 호출 하여 프록시 선택기가 직접 연결 또는 프록시 연결을 사용해야하는지 여부를 결정할 수 있습니다. &lt;a href=&quot;proxyselector#select-java.net.URI-&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 방법은 추천의 접속 방법으로 컬렉션의 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0d0a0a75e5df0269d9b48018fdf0251b8588033" translate="yes" xml:space="preserve">
          <source>When a rendering or image manipulation operation produces a color value that must be stored into a destination, it must first convert that color into a form suitable for storing into the destination image or surface. Minimally, the color components must be converted to bit representations and ordered in the correct order or an index into a color lookup table must be chosen before the data can be stored into the destination memory. Without this minimal conversion, the data in the destination would likely represent random, incorrect or possibly even unsupported values. Algorithms to quickly convert the results of rendering operations into the color format of most common destinations are well known and fairly optimal to execute.</source>
          <target state="translated">렌더링 또는 이미지 조작 작업이 대상에 저장해야하는 색상 값을 생성하는 경우 먼저 해당 색상을 대상 이미지 또는 표면에 저장하기에 적합한 형식으로 변환해야합니다. 최소한 색상 구성 요소를 비트 표현으로 변환하고 올바른 순서로 정렬하거나 데이터를 대상 메모리에 저장하기 전에 색상 조회 테이블에 대한 인덱스를 선택해야합니다. 이 최소한의 변환이 없으면 대상의 데이터가 임의의 값, 부정확하거나 지원되지 않는 값을 나타낼 수 있습니다. 렌더링 작업의 결과를 가장 일반적인 대상의 색상 형식으로 빠르게 변환하는 알고리즘은 잘 알려져 있으며 실행하기에 상당히 최적입니다.</target>
        </trans-unit>
        <trans-unit id="7a3bf5e738a9141b4b95997a3f1e19dc1b7157d4" translate="yes" xml:space="preserve">
          <source>When a rowset gets its data from a relational database, it executes a command (a query) that produces a &lt;code&gt;ResultSet&lt;/code&gt; object. This query is the command that is set for the &lt;code&gt;RowSet&lt;/code&gt; object's command property. The rowset populates itself with data by reading the data from the &lt;code&gt;ResultSet&lt;/code&gt; object into itself. If the query contains placeholders for values to be set, the &lt;code&gt;BaseRowSet&lt;/code&gt; setter methods are used to set these values. All setter methods allow these values to be set to &lt;code&gt;null&lt;/code&gt; if required.</source>
          <target state="translated">행 집합이 관계형 데이터베이스에서 데이터를 가져 오면 &lt;code&gt;ResultSet&lt;/code&gt; 개체 를 생성하는 명령 (쿼리)을 실행 합니다. 이 쿼리는 &lt;code&gt;RowSet&lt;/code&gt; 개체의 명령 속성에 대해 설정된 명령입니다 . 행 집합은 &lt;code&gt;ResultSet&lt;/code&gt; 개체 에서 데이터를 읽어 데이터로 채워집니다 . 쿼리에 설정할 값에 대한 자리 표시자가 포함 된 경우 &lt;code&gt;BaseRowSet&lt;/code&gt; setter 메서드를 사용하여 이러한 값을 설정합니다. 모든 setter 메서드는 필요한 경우 이러한 값을 &lt;code&gt;null&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="758869419d156f27990d997e0fa9fce2a685beea" translate="yes" xml:space="preserve">
          <source>When a scanner throws an &lt;a href=&quot;inputmismatchexception&quot;&gt;&lt;code&gt;InputMismatchException&lt;/code&gt;&lt;/a&gt;, the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method.</source>
          <target state="translated">스캐너가 &lt;a href=&quot;inputmismatchexception&quot;&gt; &lt;code&gt;InputMismatchException&lt;/code&gt; 을&lt;/a&gt; throw하면 스캐너는 예외를 일으킨 토큰을 전달하지 않으므로 다른 방법으로 검색하거나 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="817af58e7bcbe10748b284737a339517287e3c10" translate="yes" xml:space="preserve">
          <source>When a scroll bar is used to select a range of values, the visible amount is used to represent the range of values that are currently visible. The size of the scroll bar's bubble (also called a thumb or scroll box), usually gives a visual representation of the relationship of the visible amount to the range of the scroll bar. Note that depending on platform, the value of the visible amount property may not be visually indicated by the size of the bubble.</source>
          <target state="translated">스크롤 막대를 사용하여 값 범위를 선택하면 표시되는 양이 현재 표시되는 값 범위를 나타내는 데 사용됩니다. 스크롤 막대의 거품 크기 (썸 또는 스크롤 상자라고도 함)는 일반적으로 스크롤 막대 범위에 대한 가시적 양의 관계를 시각적으로 나타냅니다. 플랫폼에 따라 표시량 속성의 값이 거품의 크기로 시각적으로 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a853e62233343e776fbd44333e92601acc2febbe" translate="yes" xml:space="preserve">
          <source>When a security manager is installed and it denies access to a file (or directory), then it is ignored and not included in the stream.</source>
          <target state="translated">보안 관리자가 설치되고 파일 (또는 디렉토리)에 대한 액세스를 거부하면 무시되며 스트림에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e74c73e1d683b9fecd0a717afa160e6920257abc" translate="yes" xml:space="preserve">
          <source>When a security manager is installed and it denies access to a file (or directory), then it is ignored and the visitor is not invoked for that file (or directory).</source>
          <target state="translated">보안 관리자가 설치되고 파일 (또는 디렉토리)에 대한 액세스를 거부하면 해당 파일 (또는 디렉토리)에 대한 방문자가 호출되지 않고 방문자가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61d88ca5288dc5b3be9b25739812ea67777f1b62" translate="yes" xml:space="preserve">
          <source>When a security manager is installed, it is invoked to check access to the each root directory. If denied, the root directory is not returned by the iterator. In the case of the default provider, the &lt;a href=&quot;../../lang/securitymanager#checkRead(java.lang.String)&quot;&gt;&lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt;&lt;/a&gt; method is invoked to check read access to each root directory. It is system dependent if the permission checks are done when the iterator is obtained or during iteration.</source>
          <target state="translated">보안 관리자가 설치되면 각 루트 디렉토리에 대한 액세스를 확인하기 위해 호출됩니다. 거부 된 경우 루트 디렉터리는 반복기에 의해 반환되지 않습니다. 기본 공급자의 경우 각 루트 디렉터리에 대한 읽기 액세스를 확인하기 위해 &lt;a href=&quot;../../lang/securitymanager#checkRead(java.lang.String)&quot;&gt; &lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt; &lt;/a&gt; 메서드가 호출됩니다. 반복기가 확보 될 때 또는 반복 중에 권한 검사가 수행되는지 여부는 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3b16d1c9ade5f68deff8b6a72ad86abd212f522b" translate="yes" xml:space="preserve">
          <source>When a security manager is installed, it is invoked to check access to the each root directory. If denied, the root directory is not returned by the iterator. In the case of the default provider, the &lt;a href=&quot;../../lang/securitymanager#checkRead-java.lang.String-&quot;&gt;&lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt;&lt;/a&gt; method is invoked to check read access to each root directory. It is system dependent if the permission checks are done when the iterator is obtained or during iteration.</source>
          <target state="translated">보안 관리자가 설치되면 각 루트 디렉토리에 대한 액세스를 확인하기 위해 호출됩니다. 거부되면 루트 디렉토리는 반복자에 의해 리턴되지 않습니다. 기본 제공자의 경우 각 루트 디렉토리에 대한 읽기 액세스를 확인하기 위해 &lt;a href=&quot;../../lang/securitymanager#checkRead-java.lang.String-&quot;&gt; &lt;code&gt;SecurityManager.checkRead(String)&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. 반복기가 확보 될 때 또는 반복 중에 권한 점검이 수행되는지 여부는 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="bd8e3e90bc0a4ad1eaf1fe672cd6021d8ff59c73" translate="yes" xml:space="preserve">
          <source>When a service provider needs to determine the value of a property, it will generally take that value directly from the environment. A service provider may define provider-specific properties to be placed in its own provider resource file. In that case it should merge values as described in the previous paragraph.</source>
          <target state="translated">서비스 공급자가 속성 값을 결정해야하는 경우 일반적으로 해당 값을 환경에서 직접 가져옵니다. 서비스 제공자는 자신의 제공자 자원 파일에 배치 할 제공자 특정 특성을 정의 할 수 있습니다. 이 경우 이전 단락에서 설명한대로 값을 병합해야합니다.</target>
        </trans-unit>
        <trans-unit id="7807fd2cea76f3e1ce4a83a545e5b3a3ae40080e" translate="yes" xml:space="preserve">
          <source>When a service provider receives a response control, it uses control factories to return the specific/appropriate control class implementation.</source>
          <target state="translated">서비스 제공자는 응답 제어를 받으면 제어 팩토리를 사용하여 특정 / 적절한 제어 클래스 구현을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3ade58d0e25bc018ea163c0cdad7f4b776c6ab39" translate="yes" xml:space="preserve">
          <source>When a service provider receives response controls, it uses the &lt;code&gt;ControlFactory&lt;/code&gt; class to produce specific classes that implement the &lt;code&gt;Control&lt;/code&gt; interface.</source>
          <target state="translated">서비스 제공자는 응답 제어를 수신하면 &lt;code&gt;ControlFactory&lt;/code&gt; 클래스를 사용 하여 &lt;code&gt;Control&lt;/code&gt; 인터페이스 를 구현하는 특정 클래스를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="3d30b140cad70a65f78e1eb56376dbfbaf7a9533" translate="yes" xml:space="preserve">
          <source>When a single argument is parsed more than once in the string, the last match will be the final result of the parsing. For example,</source>
          <target state="translated">문자열에서 단일 인수가 두 번 이상 구문 분석되면 마지막 일치가 구문 분석의 최종 결과입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="058e1674f7a000873c2028dd6c1dc5cce20b5b83" translate="yes" xml:space="preserve">
          <source>When a socket is connected, &lt;a href=&quot;#receive(java.net.DatagramPacket)&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#send(java.net.DatagramPacket)&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;&lt;b&gt;will not perform any security checks&lt;/b&gt; on incoming and outgoing packets, other than matching the packet's and the socket's address and port. On a send operation, if the packet's address is set and the packet's address and the socket's address do not match, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. A socket connected to a multicast address may only be used to send packets.</source>
          <target state="translated">소켓이 연결되면 &lt;a href=&quot;#receive(java.net.DatagramPacket)&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#send(java.net.DatagramPacket)&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;&lt;b&gt; 은&lt;/b&gt; 패킷과 소켓의 주소 및 포트 일치를 제외하고 수신 및 송신 패킷에 &lt;b&gt;대한 보안 검사&lt;/b&gt; 를 &lt;b&gt;수행하지 않습니다&lt;/b&gt; . 송신 동작에서 패킷의 주소가 설정되어 있고 패킷의 주소와 소켓의 주소가 일치하지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다. 멀티 캐스트 주소에 연결된 소켓은 패킷 전송에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b152721196e9350030fbce80cc3060686ce54e33" translate="yes" xml:space="preserve">
          <source>When a socket is connected, &lt;a href=&quot;datagramsocket#receive-java.net.DatagramPacket-&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datagramsocket#send-java.net.DatagramPacket-&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;&lt;b&gt;will not perform any security checks&lt;/b&gt; on incoming and outgoing packets, other than matching the packet's and the socket's address and port. On a send operation, if the packet's address is set and the packet's address and the socket's address do not match, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown. A socket connected to a multicast address may only be used to send packets.</source>
          <target state="translated">소켓이 연결되면 &lt;a href=&quot;datagramsocket#receive-java.net.DatagramPacket-&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;datagramsocket#send-java.net.DatagramPacket-&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt;&lt;b&gt; 은&lt;/b&gt; 패킷 및 소켓 주소 및 포트와 일치하는 것 외에는 들어오고 나가는 패킷에 &lt;b&gt;대한 보안 검사&lt;/b&gt; 를 &lt;b&gt;수행하지 않습니다&lt;/b&gt; . 송신 작업에서 패킷 주소가 설정되고 패킷 주소와 소켓 주소가 일치하지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다. 멀티 캐스트 주소에 연결된 소켓은 패킷을 보내는 데만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a75cd6f6c3582a34b8ac5dfdb077e4af32675c83" translate="yes" xml:space="preserve">
          <source>When a socket subscribes to a multicast group/port, it receives datagrams sent by other hosts to the group/port, as do all other members of the group and port. A socket relinquishes membership in a group by the leaveGroup(InetAddress addr) method. &lt;b&gt; Multiple MulticastSocket's&lt;/b&gt; may subscribe to a multicast group and port concurrently, and they will all receive group datagrams.</source>
          <target state="translated">소켓이 멀티 캐스트 그룹 / 포트에 가입하면 그룹 및 포트의 다른 모든 구성원과 마찬가지로 다른 호스트가 그룹 / 포트로 보낸 데이터 그램을 수신합니다. 소켓은 leaveGroup (InetAddress addr) 메소드에 의해 그룹의 멤버쉽을 포기합니다. &lt;b&gt;다중 멀티 캐스트&lt;/b&gt; 소켓은 멀티 캐스트 그룹과 포트를 동시에 구독 할 수 있으며 모두 그룹 데이터 그램을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="1542ee008a8e9f826667c4f42290447523aa89a6" translate="yes" xml:space="preserve">
          <source>When a stack is first created, it contains no items.</source>
          <target state="translated">스택을 처음 만들면 항목이 없습니다.</target>
        </trans-unit>
        <trans-unit id="58680ac2a710c1c3ec572a26747c8ac4bf37321d" translate="yes" xml:space="preserve">
          <source>When a subclass is replacing objects it must insure that either a complementary substitution must be made during deserialization or that the substituted object is compatible with every field where the reference will be stored. Objects whose type is not a subclass of the type of the field or array element abort the serialization by raising an exception and the object is not be stored.</source>
          <target state="translated">서브 클래스가 객체를 교체 할 때는 역 직렬화 중에 보완적인 대체가 이루어져야하거나 대체 된 객체가 참조가 저장 될 모든 필드와 호환되는지 확인해야합니다. 유형이 필드 또는 배열 요소 유형의 서브 클래스가 아닌 오브젝트는 예외를 발생시켜 직렬화를 중단하고 오브젝트가 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4af4456165693adbeda480b45292ea0c955ff233" translate="yes" xml:space="preserve">
          <source>When a subclass is replacing objects it must insure that the substituted object is compatible with every field where the reference will be stored. Objects whose type is not a subclass of the type of the field or array element abort the serialization by raising an exception and the object is not be stored.</source>
          <target state="translated">서브 클래스가 객체를 교체 할 때는 대체 된 객체가 참조가 저장 될 모든 필드와 호환되는지 확인해야합니다. 유형이 필드 또는 배열 요소 유형의 서브 클래스가 아닌 오브젝트는 예외를 발생시켜 직렬화를 중단하고 오브젝트가 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e26d84240a67b35d599a0931c437428256b549e1" translate="yes" xml:space="preserve">
          <source>When a subclass overrides a &lt;code&gt;visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; method, the new method can cause the enclosed elements to be scanned in the default way by calling &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt;. In this fashion, the concrete visitor can control the ordering of traversal over the component elements with respect to the additional processing; for example, consistently calling &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; at the start of the overridden methods will yield a preorder traversal, etc. If the component elements should be traversed in some other order, instead of calling &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt;, an overriding visit method should call &lt;code&gt;scan&lt;/code&gt; with the elements in the desired order.</source>
          <target state="translated">서브 클래스가 &lt;code&gt;visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; 메소드를 대체 할 때 , 새 메소드는 &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; 를 호출하여 기본 방식으로 닫힌 요소를 스캔 할 수 있습니다 . 이러한 방식으로, 콘크리트 방문자는 추가 처리와 관련하여 구성 요소를 가로 지르는 순서를 제어 할 수있다. 예를 들어, 재정의 된 메소드의 시작 부분에서 지속적으로 &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; 를 호출 하면 사전 주문 순회 등이 발생합니다. &lt;code&gt;super.visit&lt;i&gt;XYZ&lt;/i&gt;&lt;/code&gt; 를 호출하는 대신 컴포넌트 요소를 다른 순서로 순회 해야하는 경우 대체 방문 메소드는 원하는 순서대로 요소를 &lt;code&gt;scan&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="1982004121a817c184d129a04a27e56f1d2b9c31" translate="yes" xml:space="preserve">
          <source>When a subclass overrides a &lt;code&gt;visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; method, the new method can cause the enclosed elements to be scanned in the default way by calling &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt;. In this fashion, the concrete visitor can control the ordering of traversal over the component elements with respect to the additional processing; for example, consistently calling &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; at the start of the overridden methods will yield a preorder traversal, etc. If the component elements should be traversed in some other order, instead of calling &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt;, an overriding visit method should call &lt;code&gt;scan&lt;/code&gt; with the elements in the desired order.</source>
          <target state="translated">하위 클래스가 &lt;code&gt;visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; 메서드를 재정의 할 때 새 메서드는 &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; 를 호출하여 포함 된 요소를 기본 방식으로 스캔하도록 할 수 있습니다 . 이러한 방식으로 구체적인 방문자는 추가 처리와 관련하여 구성 요소에 대한 순회 순서를 제어 할 수 있습니다. 예를 들어, 재정의 된 메서드의 시작 부분에서 지속적으로 &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; 를 호출 하면 사전 주문 순회 등이 생성됩니다. 구성 요소 요소를 다른 순서로 순회해야하는 경우 &lt;code&gt;super.visit&lt;i&gt;Xyz&lt;/i&gt;&lt;/code&gt; 를 호출하는 대신 재정의하는 방문 메서드는 다음을 호출해야합니다. 원하는 순서로 요소를 &lt;code&gt;scan&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9929247187f11924a98b560a646e45a4e67ae3c7" translate="yes" xml:space="preserve">
          <source>When a submitted task is cancelled before it is run, execution is suppressed. By default, such a cancelled task is not automatically removed from the work queue until its delay elapses. While this enables further inspection and monitoring, it may also cause unbounded retention of cancelled tasks. To avoid this, set &lt;a href=&quot;scheduledthreadpoolexecutor#setRemoveOnCancelPolicy-boolean-&quot;&gt;&lt;code&gt;setRemoveOnCancelPolicy(boolean)&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;, which causes tasks to be immediately removed from the work queue at time of cancellation.</source>
          <target state="translated">제출 된 작업이 실행되기 전에 취소되면 실행이 억제됩니다. 기본적으로 이러한 취소 된 작업은 지연 시간이 경과 할 때까지 작업 대기열에서 자동으로 제거되지 않습니다. 이를 통해 추가 검사 및 모니터링을 수행 할 수 있지만 취소 된 작업을 무제한 보유 할 수도 있습니다. 이를 방지하려면 &lt;a href=&quot;scheduledthreadpoolexecutor#setRemoveOnCancelPolicy-boolean-&quot;&gt; &lt;code&gt;setRemoveOnCancelPolicy(boolean)&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오. 그러면 취소시 작업 큐에서 작업이 즉시 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b44cdb1f4c54b9f9c38dd96a59f19c9b972ead75" translate="yes" xml:space="preserve">
          <source>When a submitted task is cancelled before it is run, execution is suppressed. By default, such a cancelled task is not automatically removed from the work queue until its delay elapses. While this enables further inspection and monitoring, it may also cause unbounded retention of cancelled tasks. To avoid this, use &lt;a href=&quot;#setRemoveOnCancelPolicy(boolean)&quot;&gt;&lt;code&gt;setRemoveOnCancelPolicy(boolean)&lt;/code&gt;&lt;/a&gt; to cause tasks to be immediately removed from the work queue at time of cancellation.</source>
          <target state="translated">제출 된 작업이 실행되기 전에 취소되면 실행이 억제됩니다. 기본적으로 이러한 취소 된 작업은 지연이 경과 할 때까지 작업 대기열에서 자동으로 제거되지 않습니다. 이를 통해 추가 검사 및 모니터링이 가능하지만 취소 된 작업을 무제한 보존 할 수도 있습니다. 이를 방지하려면 &lt;a href=&quot;#setRemoveOnCancelPolicy(boolean)&quot;&gt; &lt;code&gt;setRemoveOnCancelPolicy(boolean)&lt;/code&gt; &lt;/a&gt; 를 사용 하여 취소시 작업 대기열에서 작업을 즉시 제거합니다.</target>
        </trans-unit>
        <trans-unit id="10b74fcebd08424b7bb7bf29fe6e5a17d846f581" translate="yes" xml:space="preserve">
          <source>When a system exclusive message is read from a MIDI file, it always has a defined length. Data from a system exclusive message from a MIDI file should be stored in the data array of a &lt;code&gt;SysexMessage&lt;/code&gt; as follows: the system exclusive message status byte (0xF0 or 0xF7), all message data bytes, and finally the end-of-exclusive flag (0xF7). The length reported by the &lt;code&gt;SysexMessage&lt;/code&gt; object is therefore the length of the system exclusive data plus two: one byte for the status byte and one for the end-of-exclusive flag.</source>
          <target state="translated">시스템 독점 메시지는 MIDI 파일에서 읽을 때 항상 정의 된 길이를 갖습니다. MIDI 파일에서 시스템 독점 메시지의 데이터 는 다음과 같이 &lt;code&gt;SysexMessage&lt;/code&gt; 의 데이터 배열에 저장해야 합니다. 시스템 독점 메시지 상태 바이트 (0xF0 또는 0xF7), 모든 메시지 데이터 바이트 및 마지막으로 독점 종료 플래그 ( 0xF7). &lt;code&gt;SysexMessage&lt;/code&gt; 오브젝트에 의해보고되는 길이는 시스템 독점 데이터의 길이에 2를 더한 것입니다. 상태 바이트의 경우 1 바이트와 배타적 종료 플래그의 경우 1입니다.</target>
        </trans-unit>
        <trans-unit id="89b880bb7b0e20e4a94653fd28147b76b402fbeb" translate="yes" xml:space="preserve">
          <source>When a thread &lt;code&gt;T&lt;/code&gt; queries a class value in state &lt;code&gt;2N&lt;/code&gt;, the thread first attempts to initialize the class value to state &lt;code&gt;2N+1&lt;/code&gt; by invoking &lt;code&gt;computeValue&lt;/code&gt; and installing the resulting value.</source>
          <target state="translated">스레드 &lt;code&gt;T&lt;/code&gt; 가 상태 &lt;code&gt;2N&lt;/code&gt; 에서 클래스 값을 쿼리 할 때 스레드는 먼저 &lt;code&gt;computeValue&lt;/code&gt; 를 호출 하고 결과 값을 설치하여 클래스 값을 상태 &lt;code&gt;2N+1&lt;/code&gt; 로 초기화하려고 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="d0bb71d68a413b1e3688231ebd3a0fe5821666fc" translate="yes" xml:space="preserve">
          <source>When a thread &lt;code&gt;T&lt;/code&gt; removes a class value in state &lt;code&gt;2N&lt;/code&gt;, nothing happens, since the class value is already uninitialized. Otherwise, the state is advanced atomically to &lt;code&gt;2N+1&lt;/code&gt;.</source>
          <target state="translated">스레드 &lt;code&gt;T&lt;/code&gt; 가 상태 &lt;code&gt;2N&lt;/code&gt; 에서 클래스 값을 제거 하면 클래스 값이 이미 초기화되지 않았으므로 아무 일도 일어나지 않습니다. 그렇지 않으면 상태는 원자 적으로 &lt;code&gt;2N+1&lt;/code&gt; 로 진행 됩니다.</target>
        </trans-unit>
        <trans-unit id="5f150b9d52841cfe078b29c41afb5606285d9203" translate="yes" xml:space="preserve">
          <source>When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; using &lt;a href=&quot;thread#getUncaughtExceptionHandler()&quot;&gt;&lt;code&gt;Thread.getUncaughtExceptionHandler()&lt;/code&gt;&lt;/a&gt; and will invoke the handler's &lt;code&gt;uncaughtException&lt;/code&gt; method, passing the thread and the exception as arguments. If a thread has not had its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; explicitly set, then its &lt;code&gt;ThreadGroup&lt;/code&gt; object acts as its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;. If the &lt;code&gt;ThreadGroup&lt;/code&gt; object has no special requirements for dealing with the exception, it can forward the invocation to the &lt;a href=&quot;thread#getDefaultUncaughtExceptionHandler()&quot;&gt;default uncaught exception handler&lt;/a&gt;.</source>
          <target state="translated">포착되지 않은 예외로 인해 스레드가 종료 되려고 할 때 Java 가상 머신은 &lt;a href=&quot;thread#getUncaughtExceptionHandler()&quot;&gt; &lt;code&gt;Thread.getUncaughtExceptionHandler()&lt;/code&gt; &lt;/a&gt; 사용하여 해당 스레드의 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; 를 쿼리 하고 핸들러의 &lt;code&gt;uncaughtException&lt;/code&gt; 메소드를 호출 하여 스레드와 예외를 인수로 전달합니다. 스레드에 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; 가 명시 적으로 설정 되지 않은 경우 해당 &lt;code&gt;ThreadGroup&lt;/code&gt; 객체는 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; 역할을합니다 . 경우 &lt;code&gt;ThreadGroup&lt;/code&gt; 오브젝트가 예외를 취급하는 특수한 요구 사항이 없습니다, 그것은에 호출을 전달할 수 있습니다 &lt;a href=&quot;thread#getDefaultUncaughtExceptionHandler()&quot;&gt;기본 캐치되지 않는 예외 핸들러를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77fe3f278ecb8fc0ec8c3db5bded17a3ac83c0e0" translate="yes" xml:space="preserve">
          <source>When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; using &lt;a href=&quot;thread#getUncaughtExceptionHandler--&quot;&gt;&lt;code&gt;Thread.getUncaughtExceptionHandler()&lt;/code&gt;&lt;/a&gt; and will invoke the handler's &lt;code&gt;uncaughtException&lt;/code&gt; method, passing the thread and the exception as arguments. If a thread has not had its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; explicitly set, then its &lt;code&gt;ThreadGroup&lt;/code&gt; object acts as its &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;. If the &lt;code&gt;ThreadGroup&lt;/code&gt; object has no special requirements for dealing with the exception, it can forward the invocation to the &lt;a href=&quot;thread#getDefaultUncaughtExceptionHandler--&quot;&gt;default uncaught exception handler&lt;/a&gt;.</source>
          <target state="translated">포착되지 않은 예외로 인해 스레드가 종료 되려고하면 Java Virtual Machine은 &lt;a href=&quot;thread#getUncaughtExceptionHandler--&quot;&gt; &lt;code&gt;Thread.getUncaughtExceptionHandler()&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; 에 대해 스레드를 조회 하고 처리기의 &lt;code&gt;uncaughtException&lt;/code&gt; 메소드를 호출 하여 스레드와 예외를 인수로 전달합니다. 스레드에 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; 가 명시 적으로 설정 되어 있지 않으면 &lt;code&gt;ThreadGroup&lt;/code&gt; 객체가 &lt;code&gt;UncaughtExceptionHandler&lt;/code&gt; 역할을합니다 . 경우 &lt;code&gt;ThreadGroup&lt;/code&gt; 오브젝트가 예외를 취급하는 특수한 요구 사항이 없습니다, 그것은에 호출을 전달할 수 있습니다 &lt;a href=&quot;thread#getDefaultUncaughtExceptionHandler--&quot;&gt;기본 캐치되지 않는 예외 핸들러를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="895317443968ac47f3f92d75cb96a37c77319964" translate="yes" xml:space="preserve">
          <source>When a three part address is specified, the last part is interpreted as a 16-bit quantity and placed in the right most two bytes of the network address. This makes the three part address format convenient for specifying Class B net- work addresses as 128.net.host.</source>
          <target state="translated">3 개의 부품 주소가 지정되면 마지막 부품은 16 비트 수량으로 해석되어 네트워크 주소의 가장 오른쪽 2 바이트에 배치됩니다. 따라서 클래스 B 네트워크 주소를 128.net.host로 지정할 때 세 부분 주소 형식이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="55c955456f3e00fb19bba01a0a16d6dc85d4343f" translate="yes" xml:space="preserve">
          <source>When a toolkit-modal dialog is shown from an applet, it blocks all other applets in the browser. When launching applications from Java Web Start, its windows (such as the security dialog) may also be blocked by toolkit-modal dialogs, shown from these applications.</source>
          <target state="translated">툴킷-모달 대화 상자가 애플릿에서 표시되면 브라우저에서 다른 모든 애플릿을 차단합니다. Java Web Start에서 응용 프로그램을 시작할 때 해당 창 (예 : 보안 대화 상자)도 이러한 응용 프로그램에서 표시되는 툴킷 모달 대화 상자에 의해 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29a6c60ea1ad71509b0284da02c6071f09ce9c45" translate="yes" xml:space="preserve">
          <source>When a two part address is supplied, the last part is interpreted as a 24-bit quantity and placed in the right most three bytes of the network address. This makes the two part address format convenient for specifying Class A network addresses as net.host.</source>
          <target state="translated">2 개의 부품 주소가 제공되면 마지막 부품은 24 비트 수량으로 해석되어 네트워크 주소의 가장 오른쪽 3 바이트에 배치됩니다. 따라서 클래스 A 네트워크 주소를 net.host로 지정하는 데 두 부분 주소 형식이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="50fa67634b29d9a508bc8a6003503fb30f4c5d33" translate="yes" xml:space="preserve">
          <source>When a type map with an entry for the base type is supplied to the methods &lt;code&gt;getArray&lt;/code&gt; and &lt;code&gt;getResultSet&lt;/code&gt;, the mapping it contains will be used to map the elements of the &lt;code&gt;ARRAY&lt;/code&gt; value. If no type map is supplied, which would typically be the case, the connection's type map is used by default. If the connection's type map or a type map supplied to a method has no entry for the base type, the elements are mapped according to the standard mapping.</source>
          <target state="translated">기본 유형에 대한 항목이있는 유형 맵이 &lt;code&gt;getArray&lt;/code&gt; 및 &lt;code&gt;getResultSet&lt;/code&gt; 메소드에 제공되면 포함 된 맵핑이 &lt;code&gt;ARRAY&lt;/code&gt; 값 의 요소를 맵핑하는 데 사용됩니다 . 일반적으로 유형 맵이 제공되지 않으면 연결의 유형 맵이 기본적으로 사용됩니다. 연결의 유형 맵 또는 메소드에 제공된 유형 맵에 기본 유형에 대한 항목이없는 경우 요소는 표준 매핑에 따라 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="6aa8db231eb18f002bb271b220e13400b3ee853b" translate="yes" xml:space="preserve">
          <source>When a variable &lt;code&gt;{i}&lt;/code&gt; appears in a search filter, it indicates that the filter argument &lt;code&gt;filterArgs[i]&lt;/code&gt; is to be used in that place. Such variables may be used wherever an &lt;em&gt;attr&lt;/em&gt;, &lt;em&gt;value&lt;/em&gt;, or &lt;em&gt;matchingrule&lt;/em&gt; production appears in the filter grammar of RFC 2254, section 4. When a string-valued filter argument is substituted for a variable, the filter is interpreted as if the string were given in place of the variable, with any characters having special significance within filters (such as &lt;code&gt;'*'&lt;/code&gt;) having been escaped according to the rules of RFC 2254.</source>
          <target state="translated">변수 &lt;code&gt;{i}&lt;/code&gt; 가 검색 필터에 나타나면 필터 인수 &lt;code&gt;filterArgs[i]&lt;/code&gt; 가 해당 위치에서 사용됨을 나타냅니다 . 이러한 변수는 RFC 2254, 섹션 4의 필터 문법에 &lt;em&gt;attr&lt;/em&gt; , &lt;em&gt;value&lt;/em&gt; 또는 &lt;em&gt;matchingrule&lt;/em&gt; 생성이 나타날 때마다 사용될 수 있습니다 . 문자열 값 필터 인수가 변수로 대체되면 필터는 문자열이 다음과 같이 해석됩니다. RFC 2254의 규칙에 따라 필터 내에서 특별한 의미를 갖는 문자 (예 : &lt;code&gt;'*'&lt;/code&gt; )가 이스케이프 된 변수의 위치 .</target>
        </trans-unit>
        <trans-unit id="a223dab9f441fba936619f7975da0a97a57c63a7" translate="yes" xml:space="preserve">
          <source>When a very large ASCII value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt; parameter, it may be more practical to send it via a &lt;code&gt;java.io.InputStream&lt;/code&gt; object. A JDBC technology-enabled driver will read the data from the stream as needed until it reaches end-of-file. The driver will do any necessary conversion from ASCII to the database &lt;code&gt;CHAR&lt;/code&gt; format.</source>
          <target state="translated">매우 큰 ASCII 값이 &lt;code&gt;LONGVARCHAR&lt;/code&gt; 매개 변수에 입력 되면 &lt;code&gt;java.io.InputStream&lt;/code&gt; 객체 를 통해 전송하는 것이 더 실용적 일 수 있습니다 . JDBC 기술 사용 드라이버는 파일 끝에 도달 할 때까지 필요에 따라 스트림에서 데이터를 읽습니다. 드라이버는 ASCII에서 데이터베이스 &lt;code&gt;CHAR&lt;/code&gt; 형식으로 필요한 모든 변환을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="fcd897e7054adc322a89f61811e83785269eb890" translate="yes" xml:space="preserve">
          <source>When a very large Unicode value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt; parameter, it may be more practical to send it via a &lt;code&gt;Reader&lt;/code&gt; object. A JDBC technology-enabled driver will read the data from the stream as needed until it reaches end-of-file. The driver will do any necessary conversion from Unicode to the database &lt;code&gt;CHAR&lt;/code&gt; format. The byte format of the Unicode stream must be Java UTF-8, as defined in the Java Virtual Machine Specification.</source>
          <target state="translated">&lt;code&gt;LONGVARCHAR&lt;/code&gt; 매개 변수에 매우 큰 유니 코드 값이 입력 되면 &lt;code&gt;Reader&lt;/code&gt; 개체 를 통해 보내는 것이 더 실용적 일 수 있습니다 . JDBC 기술 사용 드라이버는 파일 끝에 도달 할 때까지 필요에 따라 스트림에서 데이터를 읽습니다. 드라이버는 유니 코드에서 데이터베이스 &lt;code&gt;CHAR&lt;/code&gt; 형식으로 필요한 모든 변환을 수행 합니다. 유니 코드 스트림의 바이트 형식은 Java Virtual Machine 사양에 정의 된대로 Java UTF-8이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1e04bc4facdf8d539c4270ddd0aa73a722158aa2" translate="yes" xml:space="preserve">
          <source>When a very large Unicode value is input to a &lt;code&gt;LONGVARCHAR&lt;/code&gt; parameter, it may be more practical to send it via a &lt;code&gt;java.io.InputStream&lt;/code&gt; object. A JDBC technology-enabled driver will read the data from the stream as needed, until it reaches end-of-file. The driver will do any necessary conversion from Unicode to the database &lt;code&gt;CHAR&lt;/code&gt; format. The byte format of the Unicode stream must be Java UTF-8, as defined in the Java Virtual Machine Specification.</source>
          <target state="translated">매우 큰 유니 코드 값이 &lt;code&gt;LONGVARCHAR&lt;/code&gt; 매개 변수에 입력 되면 &lt;code&gt;java.io.InputStream&lt;/code&gt; 객체 를 통해 보내는 것이 더 실용적 일 수 있습니다 . JDBC 기술 사용 드라이버는 파일 끝에 도달 할 때까지 필요에 따라 스트림에서 데이터를 읽습니다. 드라이버는 유니 코드에서 데이터베이스 &lt;code&gt;CHAR&lt;/code&gt; 형식으로 필요한 모든 변환을 수행 합니다. 유니 코드 스트림의 바이트 형식은 Java Virtual Machine 사양에 정의 된대로 Java UTF-8이어야합니다.</target>
        </trans-unit>
        <trans-unit id="adc578dc87370a608ed5a2be5460fe895888ac7d" translate="yes" xml:space="preserve">
          <source>When a very large binary value is input to a &lt;code&gt;LONGVARBINARY&lt;/code&gt; parameter, it may be more practical to send it via a &lt;code&gt;java.io.InputStream&lt;/code&gt; object. A JDBC technology-enabled driver will read the data from the stream as needed until it reaches end-of-file.</source>
          <target state="translated">&lt;code&gt;LONGVARBINARY&lt;/code&gt; 매개 변수에 매우 큰 이진 값이 입력 되면 &lt;code&gt;java.io.InputStream&lt;/code&gt; 객체 를 통해 전송하는 것이 더 실용적 일 수 있습니다 . JDBC 기술 사용 드라이버는 파일 끝에 도달 할 때까지 필요에 따라 스트림에서 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e2c2469b19a3494bf3f5739b9534978d0c5455a7" translate="yes" xml:space="preserve">
          <source>When adding providers to the cache, the &lt;a href=&quot;serviceloader#iterator--&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; processes resources in the order that the &lt;a href=&quot;../lang/classloader#getResources-java.lang.String-&quot;&gt;&lt;code&gt;ClassLoader.getResources(String)&lt;/code&gt;&lt;/a&gt; method finds the service configuration files.</source>
          <target state="translated">캐시에 제공자를 추가 할 때 &lt;a href=&quot;serviceloader#iterator--&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../lang/classloader#getResources-java.lang.String-&quot;&gt; &lt;code&gt;ClassLoader.getResources(String)&lt;/code&gt; &lt;/a&gt; 메소드가 서비스 구성 파일을 찾는 순서대로 자원을 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="a3a63ad56f11301a43466ccd3853e7b3ff64e5a3" translate="yes" xml:space="preserve">
          <source>When all modules have been enumerated then a readability graph is computed, and in conjunction with the module exports and service use, checked for consistency.</source>
          <target state="translated">모든 모듈이 열거되면 가독성 그래프가 계산되고 모듈 내보내기 및 서비스 사용과 함께 일관성을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="bcd60d3bee845f9fdd7a82c5e0d643e282800575" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is set, the callee will report all the errors found in sources to the handler. If the handler throws an exception, it will abort the schema compilation and the same exception will be thrown from this method. Also, after an error is reported to a handler, the callee is allowed to abort the further processing by throwing it. If an error handler is not set, the callee will throw the first error it finds in the sources.</source>
          <target state="translated">때 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt; 설정되면, 수신자는 핸들러 소스에있는 모든 오류를보고합니다. 처리기가 예외를 throw하면 스키마 컴파일이 중단되고이 메서드에서 동일한 예외가 throw됩니다. 또한 오류가 핸들러에보고 된 후 호출 수신자는 오류를 발생시켜 추가 처리를 중단 할 수 있습니다. 오류 처리기가 설정되지 않은 경우 호출 수신자는 소스에서 찾은 첫 번째 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="bb2dce23419118f6b8331bfb0b7c1d8142491745" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;../inputsource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt; is used to provide an entity's character stream, this method returns the encoding provided in that input stream.</source>
          <target state="translated">때 &lt;a href=&quot;../inputsource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; 를는&lt;/a&gt; 엔티티의 문자 스트림을 제공하기 위해 사용되며,이 방법은 입력 스트림에 제공된 부호화를 반환한다.</target>
        </trans-unit>
        <trans-unit id="4e81b728c5aff55890dffac2c0a02554a169937e" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;SSLSocket&lt;/code&gt; is first created, no handshaking is done so that applications may first set their communication preferences: what cipher suites to use, whether the socket should be in client or server mode, etc. However, security is always provided by the time that application data is sent over the connection.</source>
          <target state="translated">때 &lt;code&gt;SSLSocket&lt;/code&gt; 사용에 어떤 암호 스위트 소켓 그러나 보안은 항상 시간이에 의해 제공되는 클라이언트 또는 서버 모드 등에 있어야 여부 : 처음 생성되는 응용 프로그램은 먼저 통신 환경 설정을 할 수 있도록, 더 핸드 쉐이크가 수행되지 않습니다 애플리케이션 데이터는 연결을 통해 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="5c164b99953c48a40b73ea8b2b0ca7202f7ca056" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;XMLSignature&lt;/code&gt; containing this reference is generated, the specified &lt;code&gt;transforms&lt;/code&gt; (if non-null) are applied to the specified &lt;code&gt;result&lt;/code&gt;. The &lt;code&gt;Transforms&lt;/code&gt; element of the resulting &lt;code&gt;Reference&lt;/code&gt; element is set to the concatenation of the &lt;code&gt;appliedTransforms&lt;/code&gt; and &lt;code&gt;transforms&lt;/code&gt;.</source>
          <target state="translated">이 참조를 포함 하는 &lt;code&gt;XMLSignature&lt;/code&gt; 가 생성되면 지정된 &lt;code&gt;transforms&lt;/code&gt; (null이 아닌 경우)이 지정된 &lt;code&gt;result&lt;/code&gt; 적용됩니다 . 결과 &lt;code&gt;Reference&lt;/code&gt; 요소 의 &lt;code&gt;Transforms&lt;/code&gt; 요소 는 &lt;code&gt;appliedTransforms&lt;/code&gt; 및 &lt;code&gt;transforms&lt;/code&gt; 의 연결로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcaddb468356d4ee2035b39f238ba71251cf9ad5" translate="yes" xml:space="preserve">
          <source>When an Externalizable object is reconstructed, an instance is created using the public no-arg constructor, then the readExternal method called. Serializable objects are restored by reading them from an ObjectInputStream.</source>
          <target state="translated">Externalizable 객체가 재구성되면, 인수없는 public 생성자를 사용하여 인스턴스가 생성되고 readExternal 메소드가 호출됩니다. 직렬화 가능 오브젝트는 ObjectInputStream에서 읽음으로써 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="fb8f935efcf55f08e7d5d19a4cd9f7c5f2edf11a" translate="yes" xml:space="preserve">
          <source>When an MBean emits a notification, it considers each listener that has been added with &lt;a href=&quot;#addNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; and not subsequently removed with &lt;a href=&quot;#removeNotificationListener(javax.management.NotificationListener)&quot;&gt;&lt;code&gt;removeNotificationListener&lt;/code&gt;&lt;/a&gt;. If a filter was provided with that listener, and if the filter's &lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; method returns false, the listener is ignored. Otherwise, the listener's &lt;a href=&quot;notificationlistener#handleNotification(javax.management.Notification,java.lang.Object)&quot;&gt;&lt;code&gt;handleNotification&lt;/code&gt;&lt;/a&gt; method is called with the notification, as well as the handback object that was provided to &lt;code&gt;addNotificationListener&lt;/code&gt;.</source>
          <target state="translated">MBean이 알림을 생성 할 때 &lt;a href=&quot;#addNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt; 로 추가 된 후 &lt;a href=&quot;#removeNotificationListener(javax.management.NotificationListener)&quot;&gt; &lt;code&gt;removeNotificationListener&lt;/code&gt; 로&lt;/a&gt; 제거되지 않은 각 리스너를 고려합니다 . 해당 리스너와 함께 필터가 제공되고 필터의 &lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt; 메서드가 false를 반환하면 리스너는 무시됩니다. 그렇지 않으면 리스너의 &lt;a href=&quot;notificationlistener#handleNotification(javax.management.Notification,java.lang.Object)&quot;&gt; &lt;code&gt;handleNotification&lt;/code&gt; &lt;/a&gt; 메소드가 알림 및 &lt;code&gt;addNotificationListener&lt;/code&gt; 에 제공된 핸드백 객체와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa3ea13008a777f73a92e7a4bb586fabfda6d863" translate="yes" xml:space="preserve">
          <source>When an MBean emits a notification, it considers each listener that has been added with &lt;a href=&quot;notificationbroadcaster#addNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; and not subsequently removed with &lt;a href=&quot;#removeNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt;&lt;code&gt;removeNotificationListener&lt;/code&gt;&lt;/a&gt;. If a filter was provided with that listener, and if the filter's &lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; method returns false, the listener is ignored. Otherwise, the listener's &lt;a href=&quot;notificationlistener#handleNotification(javax.management.Notification,java.lang.Object)&quot;&gt;&lt;code&gt;handleNotification&lt;/code&gt;&lt;/a&gt; method is called with the notification, as well as the handback object that was provided to &lt;code&gt;addNotificationListener&lt;/code&gt;.</source>
          <target state="translated">MBean이 알림을 생성 할 때 &lt;a href=&quot;notificationbroadcaster#addNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt; 로 추가 된 후 &lt;a href=&quot;#removeNotificationListener(javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt; &lt;code&gt;removeNotificationListener&lt;/code&gt; 로&lt;/a&gt; 제거되지 않은 각 리스너를 고려합니다 . 해당 리스너와 함께 필터가 제공되고 필터의 &lt;a href=&quot;notificationfilter#isNotificationEnabled(javax.management.Notification)&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt; 메서드가 false를 반환하면 리스너는 무시됩니다. 그렇지 않으면 리스너의 &lt;a href=&quot;notificationlistener#handleNotification(javax.management.Notification,java.lang.Object)&quot;&gt; &lt;code&gt;handleNotification&lt;/code&gt; &lt;/a&gt; 메소드가 알림 및 &lt;code&gt;addNotificationListener&lt;/code&gt; 에 제공된 핸드백 객체와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="45b4eddc256c7dd0ed23de01764919b7450154dc" translate="yes" xml:space="preserve">
          <source>When an MBean emits a notification, it considers each listener that has been added with &lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; and not subsequently removed with &lt;a href=&quot;notificationbroadcaster#removeNotificationListener-javax.management.NotificationListener-&quot;&gt;&lt;code&gt;removeNotificationListener&lt;/code&gt;&lt;/a&gt;. If a filter was provided with that listener, and if the filter's &lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; method returns false, the listener is ignored. Otherwise, the listener's &lt;a href=&quot;notificationlistener#handleNotification-javax.management.Notification-java.lang.Object-&quot;&gt;&lt;code&gt;handleNotification&lt;/code&gt;&lt;/a&gt; method is called with the notification, as well as the handback object that was provided to &lt;code&gt;addNotificationListener&lt;/code&gt;.</source>
          <target state="translated">MBean가 통지를 &lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt; , addNotificationListener 에 추가되어 나중에 &lt;a href=&quot;notificationbroadcaster#removeNotificationListener-javax.management.NotificationListener-&quot;&gt; &lt;code&gt;removeNotificationListener&lt;/code&gt; 로&lt;/a&gt; 제거되지 않은 각 리스너가 고려 됩니다 . 해당 리스너와 함께 필터가 제공되고 필터의 &lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt; 메소드가 false를 리턴하면 리스너가 무시됩니다. 그렇지 않으면 리스너의 &lt;a href=&quot;notificationlistener#handleNotification-javax.management.Notification-java.lang.Object-&quot;&gt; &lt;code&gt;handleNotification&lt;/code&gt; &lt;/a&gt; 메소드가 알림과 함께 &lt;code&gt;addNotificationListener&lt;/code&gt; 에 제공된 핸드백 오브젝트와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b71b50e0adb800b8bc569793e796446befc75eb6" translate="yes" xml:space="preserve">
          <source>When an MBean emits a notification, it considers each listener that has been added with &lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; and not subsequently removed with &lt;a href=&quot;notificationemitter#removeNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;removeNotificationListener&lt;/code&gt;&lt;/a&gt;. If a filter was provided with that listener, and if the filter's &lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt;&lt;code&gt;isNotificationEnabled&lt;/code&gt;&lt;/a&gt; method returns false, the listener is ignored. Otherwise, the listener's &lt;a href=&quot;notificationlistener#handleNotification-javax.management.Notification-java.lang.Object-&quot;&gt;&lt;code&gt;handleNotification&lt;/code&gt;&lt;/a&gt; method is called with the notification, as well as the handback object that was provided to &lt;code&gt;addNotificationListener&lt;/code&gt;.</source>
          <target state="translated">MBean가 통지를 &lt;a href=&quot;notificationbroadcaster#addNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt; , addNotificationListener 에 추가되어 나중에 &lt;a href=&quot;notificationemitter#removeNotificationListener-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;removeNotificationListener&lt;/code&gt; 로&lt;/a&gt; 제거되지 않은 각 리스너가 고려 됩니다 . 해당 리스너와 함께 필터가 제공되고 필터의 &lt;a href=&quot;notificationfilter#isNotificationEnabled-javax.management.Notification-&quot;&gt; &lt;code&gt;isNotificationEnabled&lt;/code&gt; &lt;/a&gt; 메소드가 false를 리턴하면 리스너가 무시됩니다. 그렇지 않으면 리스너의 &lt;a href=&quot;notificationlistener#handleNotification-javax.management.Notification-java.lang.Object-&quot;&gt; &lt;code&gt;handleNotification&lt;/code&gt; &lt;/a&gt; 메소드가 알림과 함께 &lt;code&gt;addNotificationListener&lt;/code&gt; 에 제공된 핸드백 오브젝트와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a7fc36f9fbd29ea8d2c562e9942118b86a45c61" translate="yes" xml:space="preserve">
          <source>When an MBean is registered in an MBean Server, if it is of a subclass of &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt; and if it does not implement the interface &lt;a href=&quot;privateclassloader&quot;&gt;&lt;code&gt;PrivateClassLoader&lt;/code&gt;&lt;/a&gt;, it is added to the end of the MBean Server's &lt;code&gt;ClassLoaderRepository&lt;/code&gt;. If it is subsequently unregistered from the MBean Server, it is removed from the &lt;code&gt;ClassLoaderRepository&lt;/code&gt;.</source>
          <target state="translated">MBean이 MBean 서버에 등록 될 때 &lt;a href=&quot;../../../../java.base/java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt; 의 서브 클래스이고 &lt;a href=&quot;privateclassloader&quot;&gt; &lt;code&gt;PrivateClassLoader&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하지 않으면 MBean 서버의 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 끝에 추가됩니다 . 이후에 MBean 서버에서 등록이 해제되면 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc7e40c74e30e9bdda780e2f49b9064de3f28184" translate="yes" xml:space="preserve">
          <source>When an MBean is registered in an MBean Server, if it is of a subclass of &lt;a href=&quot;../../../java/lang/classloader&quot;&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/a&gt; and if it does not implement the interface &lt;a href=&quot;privateclassloader&quot;&gt;&lt;code&gt;PrivateClassLoader&lt;/code&gt;&lt;/a&gt;, it is added to the end of the MBean Server's &lt;code&gt;ClassLoaderRepository&lt;/code&gt;. If it is subsequently unregistered from the MBean Server, it is removed from the &lt;code&gt;ClassLoaderRepository&lt;/code&gt;.</source>
          <target state="translated">MBean가 MBean 서버에 등록 될 때, 그것이 그것이 &lt;a href=&quot;../../../java/lang/classloader&quot;&gt; &lt;code&gt;ClassLoader&lt;/code&gt; &lt;/a&gt; 의 서브 클래스에 있고 &lt;a href=&quot;privateclassloader&quot;&gt; &lt;code&gt;PrivateClassLoader&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하지 않으면 MBean 서버의 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 의 끝에 추가됩니다 . 이후에 MBean Server에서 등록이 해제되면 &lt;code&gt;ClassLoaderRepository&lt;/code&gt; 에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="196aa3134ab9e8ce892612894f6293eb271a9ead" translate="yes" xml:space="preserve">
          <source>When an MBean is registered or unregistered in the MBean server a &lt;a href=&quot;mbeanservernotification&quot;&gt;&lt;code&gt;MBeanServerNotification&lt;/code&gt;&lt;/a&gt; Notification is emitted. To register an object as listener to MBeanServerNotifications you should call the MBean server method &lt;a href=&quot;#addNotificationListener(javax.management.ObjectName,javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;ObjectName&lt;/code&gt; the &lt;code&gt;ObjectName&lt;/code&gt; of the &lt;a href=&quot;mbeanserverdelegate&quot;&gt;&lt;code&gt;MBeanServerDelegate&lt;/code&gt;&lt;/a&gt;. This &lt;code&gt;ObjectName&lt;/code&gt; is:</source>
          <target state="translated">MBean이 MBean 서버에 등록 또는 등록 해제되면 &lt;a href=&quot;mbeanservernotification&quot;&gt; &lt;code&gt;MBeanServerNotification&lt;/code&gt; &lt;/a&gt; 알림이 생성됩니다. MBeanServerNotification를에 청취자와 같은 객체를 등록하려면 당신은의 MBean 서버 메소드 호출해야 &lt;a href=&quot;#addNotificationListener(javax.management.ObjectName,javax.management.NotificationListener,javax.management.NotificationFilter,java.lang.Object)&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;ObjectName&lt;/code&gt; &lt;code&gt;ObjectName&lt;/code&gt; 의 &lt;a href=&quot;mbeanserverdelegate&quot;&gt; &lt;code&gt;MBeanServerDelegate&lt;/code&gt; 를&lt;/a&gt; . 이 &lt;code&gt;ObjectName&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6757f09ba74310403e9527263bc5d5dd7e032018" translate="yes" xml:space="preserve">
          <source>When an MBean is registered or unregistered in the MBean server a &lt;a href=&quot;mbeanservernotification&quot;&gt;&lt;code&gt;MBeanServerNotification&lt;/code&gt;&lt;/a&gt; Notification is emitted. To register an object as listener to MBeanServerNotifications you should call the MBean server method &lt;a href=&quot;mbeanserver#addNotificationListener-javax.management.ObjectName-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt;&lt;code&gt;addNotificationListener&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;ObjectName&lt;/code&gt; the &lt;code&gt;ObjectName&lt;/code&gt; of the &lt;a href=&quot;mbeanserverdelegate&quot;&gt;&lt;code&gt;MBeanServerDelegate&lt;/code&gt;&lt;/a&gt;. This &lt;code&gt;ObjectName&lt;/code&gt; is:</source>
          <target state="translated">MBean이 MBean 서버에 등록 또는 등록 해제되면 &lt;a href=&quot;mbeanservernotification&quot;&gt; &lt;code&gt;MBeanServerNotification&lt;/code&gt; &lt;/a&gt; Notification이 생성됩니다. MBeanServerNotification를에 청취자와 같은 객체를 등록하려면 당신은의 MBean 서버 메소드 호출해야 &lt;a href=&quot;mbeanserver#addNotificationListener-javax.management.ObjectName-javax.management.NotificationListener-javax.management.NotificationFilter-java.lang.Object-&quot;&gt; &lt;code&gt;addNotificationListener&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;ObjectName&lt;/code&gt; &lt;code&gt;ObjectName&lt;/code&gt; 의 &lt;a href=&quot;mbeanserverdelegate&quot;&gt; &lt;code&gt;MBeanServerDelegate&lt;/code&gt; 를&lt;/a&gt; . 이 &lt;code&gt;ObjectName&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="182378d05279b361f0377c3dd82675fe9375ff7d" translate="yes" xml:space="preserve">
          <source>When an SSL handshake completes, new security parameters will have been established. Those parameters always include the security keys used to protect messages. They may also include parameters associated with a new &lt;em&gt;session&lt;/em&gt; such as authenticated peer identity and a new SSL cipher suite.</source>
          <target state="translated">SSL 핸드 셰이크가 완료되면 새로운 보안 매개 변수가 설정됩니다. 이러한 매개 변수에는 항상 메시지를 보호하는 데 사용되는 보안 키가 포함됩니다. 또한 인증 된 피어 ID 및 새 SSL 암호 제품군과 같은 새 &lt;em&gt;세션&lt;/em&gt; 과 관련된 매개 변수를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ab2123a1562813d9a5533055c9f0e64f556bdbf" translate="yes" xml:space="preserve">
          <source>When an action is performed, editing is ended.</source>
          <target state="translated">작업이 수행되면 편집이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="86ee98b1741c7d393fb679867d1afb4d7f15770b" translate="yes" xml:space="preserve">
          <source>When an agent is specified at JVM launch time this attribute specifies the agent class. That is, the class containing the &lt;code&gt;premain&lt;/code&gt; method. When an agent is specified at JVM launch time this attribute is required. If the attribute is not present the JVM will abort. Note: this is a class name, not a file name or path.</source>
          <target state="translated">JVM 시작 시간에 에이전트가 지정되면이 속성은 에이전트 클래스를 지정합니다. 즉, &lt;code&gt;premain&lt;/code&gt; 메서드를 포함하는 클래스 입니다. JVM 시작시 에이전트가 지정되면이 속성이 필요합니다. 속성이 없으면 JVM이 중단됩니다. 참고 : 이것은 파일 이름이나 경로가 아닌 클래스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f644b84769be94f27ad2e7583fcb5ad584a687f8" translate="yes" xml:space="preserve">
          <source>When an applet is first created, an applet stub is attached to it using the applet's &lt;code&gt;setStub&lt;/code&gt; method. This stub serves as the interface between the applet and the browser environment or applet viewer environment in which the application is running.</source>
          <target state="translated">애플릿이 처음 작성 될 때 애플릿의 &lt;code&gt;setStub&lt;/code&gt; 메소드를 사용하여 애플릿 스텁이 첨부됩니다 . 이 스텁은 애플릿과 애플리케이션이 실행중인 브라우저 환경 또는 애플릿 뷰어 환경 간의 인터페이스 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="bc9d555379c259dbd7e0e693ef8d791db7a25111" translate="yes" xml:space="preserve">
          <source>When an application adds two or more &lt;code&gt;RowSet&lt;/code&gt; objects to a &lt;code&gt;JoinRowSet&lt;/code&gt; object, the order of the indexes in the array is particularly important. Each index of the array maps directly to the corresponding index of the previously added &lt;code&gt;RowSet&lt;/code&gt; object. If overlap or underlap occurs, the match column data is maintained in the event an additional &lt;code&gt;Joinable&lt;/code&gt; RowSet is added and needs to relate to the match column data. Therefore, applications can set multiple match columns in any order, but this order has a direct effect on the outcome of the &lt;code&gt;SQL&lt;/code&gt; JOIN.</source>
          <target state="translated">응용 프로그램이 둘 이상의 &lt;code&gt;RowSet&lt;/code&gt; 객체를 &lt;code&gt;JoinRowSet&lt;/code&gt; 객체에 추가 할 때 배열의 인덱스 순서가 특히 중요합니다. 배열의 각 인덱스는 이전에 추가 된 &lt;code&gt;RowSet&lt;/code&gt; 개체 의 해당 인덱스에 직접 매핑됩니다 . 오버랩 또는 언더 랩이 발생하면 추가 &lt;code&gt;Joinable&lt;/code&gt; RowSet이 추가되고 일치 열 데이터와 관련되어야하는 경우 일치 열 데이터가 유지됩니다. 따라서 애플리케이션은 임의의 순서로 여러 일치 열을 설정할 수 있지만이 순서는 &lt;code&gt;SQL&lt;/code&gt; JOIN 의 결과에 직접적인 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="6004d4830cb9cc2c843dbf654b352672ce73e9de" translate="yes" xml:space="preserve">
          <source>When an application asks to place a character at the position (</source>
          <target state="translated">응용 프로그램에서 위치 (</target>
        </trans-unit>
        <trans-unit id="9e03b89ff80e4bbb4d4255c8faad4eca56a28340" translate="yes" xml:space="preserve">
          <source>When an application calls a method that changes a row, such as the &lt;code&gt;CachedRowSet&lt;/code&gt; methods &lt;code&gt;insertRow&lt;/code&gt;, &lt;code&gt;updateRow&lt;/code&gt;, or &lt;code&gt;deleteRow&lt;/code&gt;, that method calls &lt;code&gt;notifyRowChanged&lt;/code&gt; internally. An application &lt;b&gt;should&lt;/b&gt; never invoke this method directly.</source>
          <target state="translated">애플리케이션이 &lt;code&gt;CachedRowSet&lt;/code&gt; 메소드 &lt;code&gt;insertRow&lt;/code&gt; , &lt;code&gt;updateRow&lt;/code&gt; 또는 &lt;code&gt;deleteRow&lt;/code&gt; 와 같이 행을 변경하는 메소드를 호출하면 해당 메소드는 내부적으로 &lt;code&gt;notifyRowChanged&lt;/code&gt; 를 호출합니다 . 응용 프로그램 &lt;b&gt;은&lt;/b&gt; 이 메서드를 직접 호출 &lt;b&gt;해서는&lt;/b&gt; 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c0cfa980c0a07be7b7ee79a3cef57eca20e01cc7" translate="yes" xml:space="preserve">
          <source>When an application calls a method to move the cursor, that method moves the cursor and then calls this method internally. An application &lt;b&gt;should&lt;/b&gt; never invoke this method directly.</source>
          <target state="translated">응용 프로그램이 커서를 이동하는 메서드를 호출하면 해당 메서드가 커서를 이동 한 다음이 메서드를 내부적으로 호출합니다. 응용 프로그램 &lt;b&gt;은&lt;/b&gt; 이 메서드를 직접 호출 &lt;b&gt;해서는&lt;/b&gt; 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d78e161e7c07f3b2a15255e1f4967a9555bee575" translate="yes" xml:space="preserve">
          <source>When an application calls methods that change the entire contents of the &lt;code&gt;RowSet&lt;/code&gt; object, such as the &lt;code&gt;CachedRowSet&lt;/code&gt; methods &lt;code&gt;execute&lt;/code&gt;, &lt;code&gt;populate&lt;/code&gt;, &lt;code&gt;restoreOriginal&lt;/code&gt;, or &lt;code&gt;release&lt;/code&gt;, that method calls &lt;code&gt;notifyRowSetChanged&lt;/code&gt; internally (either directly or indirectly). An application &lt;b&gt;should&lt;/b&gt; never invoke this method directly.</source>
          <target state="translated">응용 프로그램 이 &lt;code&gt;CachedRowSet&lt;/code&gt; 메서드 &lt;code&gt;execute&lt;/code&gt; , &lt;code&gt;populate&lt;/code&gt; , &lt;code&gt;restoreOriginal&lt;/code&gt; 또는 &lt;code&gt;release&lt;/code&gt; 와 같이 &lt;code&gt;RowSet&lt;/code&gt; 객체 의 전체 내용을 변경 하는 메서드를 호출하면 해당 메서드는 내부적으로 (직접 또는 간접적으로) &lt;code&gt;notifyRowSetChanged&lt;/code&gt; 를 호출합니다 . 응용 프로그램 &lt;b&gt;은&lt;/b&gt; 이 메서드를 직접 호출 &lt;b&gt;해서는&lt;/b&gt; 안됩니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a36226b3193ab064f255bcf6893a6f62f93d1f4e" translate="yes" xml:space="preserve">
          <source>When an application calls the method &lt;code&gt;DataSource.getConnection&lt;/code&gt;, it gets back a &lt;code&gt;Connection&lt;/code&gt; object. If connection pooling is being done, that &lt;code&gt;Connection&lt;/code&gt; object is actually a handle to a &lt;code&gt;PooledConnection&lt;/code&gt; object, which is a physical connection.</source>
          <target state="translated">애플리케이션이 &lt;code&gt;DataSource.getConnection&lt;/code&gt; 메소드를 호출하면 &lt;code&gt;Connection&lt;/code&gt; 객체를 다시 가져옵니다 . 연결 풀링이 수행되는 경우 해당 &lt;code&gt;Connection&lt;/code&gt; 개체는 실제로 물리적 연결 인 &lt;code&gt;PooledConnection&lt;/code&gt; 개체에 대한 핸들 입니다.</target>
        </trans-unit>
        <trans-unit id="7d4d70ec9b9f3f954ef0f33460a4d65e403bee71" translate="yes" xml:space="preserve">
          <source>When an application calls the method &lt;code&gt;PreparedStatement.setObject&lt;/code&gt;, the driver checks to see whether the value to be written is a UDT with a custom mapping. If it is, there will be an entry in a type map containing the &lt;code&gt;Class&lt;/code&gt; object for the class that implements &lt;code&gt;SQLData&lt;/code&gt; for this UDT. If the value to be written is an instance of &lt;code&gt;SQLData&lt;/code&gt;, the driver will create an instance of &lt;code&gt;SQLOutputImpl&lt;/code&gt; and pass it to the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt;. The method &lt;code&gt;writeSQL&lt;/code&gt; in turn calls the appropriate &lt;code&gt;SQLOutputImpl.writeXXX&lt;/code&gt; methods to write data from the &lt;code&gt;SQLData&lt;/code&gt; object to the &lt;code&gt;SQLOutputImpl&lt;/code&gt; output stream as the representation of an SQL user-defined type.</source>
          <target state="translated">애플리케이션이 &lt;code&gt;PreparedStatement.setObject&lt;/code&gt; 메서드를 호출하면 드라이버는 기록 될 값이 사용자 지정 매핑이있는 UDT인지 확인합니다. 그럴 경우이 UDT에 대해 &lt;code&gt;SQLData&lt;/code&gt; 를 구현하는 클래스에 대한 &lt;code&gt;Class&lt;/code&gt; 개체를 포함하는 유형 맵에 항목이 있습니다 . 기록 할 값이 &lt;code&gt;SQLData&lt;/code&gt; 인스턴스 인 경우 드라이버는 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 인스턴스를 만들어 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 메서드에 전달합니다 . 메소드 &lt;code&gt;writeSQL&lt;/code&gt; 차례로 적절한 호출 &lt;code&gt;SQLOutputImpl.writeXXX&lt;/code&gt; 의 로부터 쓰기 데이터 방법 &lt;code&gt;SQLData&lt;/code&gt; 받는 객체 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 를 SQL 사용자 정의 유형의 표현으로 출력 스트림.</target>
        </trans-unit>
        <trans-unit id="b7f5bb0538901d5f24c63eabe24a7b4f807abe0b" translate="yes" xml:space="preserve">
          <source>When an application calls the method &lt;code&gt;PreparedStatement.setObject&lt;/code&gt;, the driver checks to see whether the value to be written is a UDT with a custom mapping. If it is, there will be an entry in a type map containing the Class object for the class that implements &lt;code&gt;SQLData&lt;/code&gt; for this UDT. If the value to be written is an instance of &lt;code&gt;SQLData&lt;/code&gt;, the driver will create an instance of &lt;code&gt;SQLOutputImpl&lt;/code&gt; and pass it to the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt;. The method &lt;code&gt;writeSQL&lt;/code&gt; in turn calls the appropriate &lt;code&gt;SQLOutputImpl&lt;/code&gt; writer methods to write data from the &lt;code&gt;SQLData&lt;/code&gt; object to the &lt;code&gt;SQLOutputImpl&lt;/code&gt; output stream as the representation of an SQL user-defined type.</source>
          <target state="translated">애플리케이션이 &lt;code&gt;PreparedStatement.setObject&lt;/code&gt; 메서드를 호출하면 드라이버는 기록 될 값이 사용자 지정 매핑이있는 UDT인지 확인합니다. 그럴 경우이 UDT에 대해 &lt;code&gt;SQLData&lt;/code&gt; 를 구현하는 클래스에 대한 클래스 개체를 포함하는 유형 맵에 항목이 있습니다 . 기록 할 값이 &lt;code&gt;SQLData&lt;/code&gt; 인스턴스 인 경우 드라이버는 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 인스턴스를 만들어 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 메서드에 전달합니다 . &lt;code&gt;writeSQL&lt;/code&gt; 메소드 는 적절한 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 기록기 메소드를 호출 하여 &lt;code&gt;SQLData&lt;/code&gt; 오브젝트에서 &lt;code&gt;SQLOutputImpl&lt;/code&gt; 로 데이터를 기록합니다. SQL 사용자 정의 유형의 표현으로 출력 스트림.</target>
        </trans-unit>
        <trans-unit id="547bc639ed55a09b200965d2bc5a9106a8333ba6" translate="yes" xml:space="preserve">
          <source>When an application closes a connection, it calls the &lt;code&gt;Connection&lt;/code&gt; method &lt;code&gt;close&lt;/code&gt;. When connection pooling is being done, the connection pool manager is notified because it has registered itself as a &lt;code&gt;ConnectionEventListener&lt;/code&gt; object using the &lt;code&gt;ConnectionPool&lt;/code&gt; method &lt;code&gt;addConnectionEventListener&lt;/code&gt;. The connection pool manager deactivates the handle to the &lt;code&gt;PooledConnection&lt;/code&gt; object and returns the &lt;code&gt;PooledConnection&lt;/code&gt; object to the pool of connections so that it can be used again. Thus, when an application closes its connection, the underlying physical connection is recycled rather than being closed.</source>
          <target state="translated">애플리케이션이 연결을 닫을 때 &lt;code&gt;Connection&lt;/code&gt; 메서드 &lt;code&gt;close&lt;/code&gt; 를 호출합니다 . 연결 풀링이 완료되면 연결 풀 관리자가 &lt;code&gt;ConnectionPool&lt;/code&gt; 메소드 &lt;code&gt;addConnectionEventListener&lt;/code&gt; 를 사용하여 &lt;code&gt;ConnectionEventListener&lt;/code&gt; 객체 로 등록 되었으므로 알림을받습니다 . 연결 풀 관리자는 &lt;code&gt;PooledConnection&lt;/code&gt; 개체에 대한 핸들을 비활성화하고 다시 사용할 수 있도록 &lt;code&gt;PooledConnection&lt;/code&gt; 개체를 연결 풀에 반환 합니다. 따라서 애플리케이션이 연결을 닫을 때 기본 물리적 연결이 닫히지 않고 재활용됩니다.</target>
        </trans-unit>
        <trans-unit id="a52c11dc01aed368f150065ba6a405d66f8451bf" translate="yes" xml:space="preserve">
          <source>When an application creates a new client socket, the socket implementation factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation.</source>
          <target state="translated">응용 프로그램이 새 클라이언트 소켓 을 작성할 때 실제 소켓 구현을 작성하기 위해 소켓 구현 팩토리의 &lt;code&gt;createSocketImpl&lt;/code&gt; 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5070d5027d76071608fcfd8560f9541c493b061d" translate="yes" xml:space="preserve">
          <source>When an application creates a new datagram socket, the socket implementation factory's &lt;code&gt;createDatagramSocketImpl&lt;/code&gt; method is called to create the actual datagram socket implementation.</source>
          <target state="translated">애플리케이션이 새 데이터 그램 소켓 을 작성할 때 실제 데이터 그램 소켓 구현을 작성하기 위해 소켓 구현 팩토리의 &lt;code&gt;createDatagramSocketImpl&lt;/code&gt; 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="53f882e0daa369f43672720af27805bcd63f9c59" translate="yes" xml:space="preserve">
          <source>When an application creates a new server socket, the socket implementation factory's &lt;code&gt;createSocketImpl&lt;/code&gt; method is called to create the actual socket implementation.</source>
          <target state="translated">응용 프로그램이 새 서버 소켓 을 작성할 때 실제 소켓 구현을 작성하기 위해 소켓 구현 팩토리의 &lt;code&gt;createSocketImpl&lt;/code&gt; 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d3c0e2a071e7ad4e860991ae113034c7a8699231" translate="yes" xml:space="preserve">
          <source>When an application is deployed, it will generally have several codebase directories and JARs in its classpath. JNDI locates (using &lt;a href=&quot;../../../java.base/java/lang/classloader#getResources(java.lang.String)&quot;&gt;&lt;code&gt;ClassLoader.getResources()&lt;/code&gt;&lt;/a&gt;) all &lt;em&gt;application resource files&lt;/em&gt; named &lt;code&gt;jndi.properties&lt;/code&gt; in the classpath. In addition, if the Java installation directory contains a built-in properties file, typically &lt;code&gt;conf/jndi.properties&lt;/code&gt;, JNDI treats it as an additional application resource file. All of the properties contained in these files are placed into the environment of the initial context. This environment is then inherited by other contexts.</source>
          <target state="translated">애플리케이션이 배포되면 일반적으로 클래스 경로에 여러 개의 코드베이스 디렉토리와 JAR이 있습니다. JNDI는 클래스 경로에서 &lt;code&gt;jndi.properties&lt;/code&gt; 라는 이름의 모든 &lt;em&gt;애플리케이션 리소스 파일을&lt;/em&gt; 찾습니다 ( &lt;a href=&quot;../../../java.base/java/lang/classloader#getResources(java.lang.String)&quot;&gt; &lt;code&gt;ClassLoader.getResources()&lt;/code&gt; &lt;/a&gt; ) . 또한 Java 설치 디렉토리에 기본 제공 속성 파일 (일반적으로 &lt;code&gt;conf/jndi.properties&lt;/code&gt; )이 포함 된 경우 JNDI는이를 추가 응용 프로그램 리소스 파일로 처리합니다. 이러한 파일에 포함 된 모든 속성은 초기 컨텍스트의 환경에 배치됩니다. 이 환경은 다른 컨텍스트에서 상속됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6192da6041396e436b94b26592fc040462f804dd" translate="yes" xml:space="preserve">
          <source>When an application is deployed, it will generally have several codebase directories and JARs in its classpath. Similarly, when an applet is deployed, it will have a codebase and archives specifying where to find the applet's classes. JNDI locates (using &lt;a href=&quot;../../java/lang/classloader#getResources-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;ClassLoader.getResources()&lt;/code&gt;&lt;/code&gt;&lt;/a&gt;) all &lt;em&gt;application resource files&lt;/em&gt; named &lt;code&gt;jndi.properties&lt;/code&gt; in the classpath. In addition, if the file</source>
          <target state="translated">응용 프로그램이 배포되면 일반적으로 클래스 경로에 여러 코드베이스 디렉터리와 JAR이 있습니다. 마찬가지로 애플릿이 배포되면 애플릿의 클래스를 찾을 위치를 지정하는 코드베이스 및 아카이브가 있습니다. JNDI는 클래스 경로에서 &lt;code&gt;jndi.properties&lt;/code&gt; 라는 모든 &lt;em&gt;애플리케이션 자원 파일을&lt;/em&gt; 찾습니다 ( &lt;a href=&quot;../../java/lang/classloader#getResources-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;ClassLoader.getResources()&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; ) . 또한 파일이&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ca3e625936706dd988b4e97b8710fc50248f15ec" translate="yes" xml:space="preserve">
          <source>When an attribute list is supplied as part of a &lt;a href=&quot;documenthandler#startElement(java.lang.String,org.xml.sax.AttributeList)&quot;&gt;&lt;code&gt;startElement&lt;/code&gt;&lt;/a&gt; event, the list will return valid results only during the scope of the event; once the event handler returns control to the parser, the attribute list is invalid. To save a persistent copy of the attribute list, use the SAX1 &lt;a href=&quot;helpers/attributelistimpl&quot;&gt;&lt;code&gt;AttributeListImpl&lt;/code&gt;&lt;/a&gt; helper class.</source>
          <target state="translated">속성 목록이 &lt;a href=&quot;documenthandler#startElement(java.lang.String,org.xml.sax.AttributeList)&quot;&gt; &lt;code&gt;startElement&lt;/code&gt; &lt;/a&gt; 이벤트의 일부로 제공되면 목록은 이벤트 범위 동안에 만 유효한 결과를 반환합니다. 이벤트 핸들러가 파서에 제어를 반환하면 속성 목록이 유효하지 않습니다. 속성 목록의 영구 사본을 저장하려면 SAX1 &lt;a href=&quot;helpers/attributelistimpl&quot;&gt; &lt;code&gt;AttributeListImpl&lt;/code&gt; &lt;/a&gt; 도우미 클래스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ff3262456581061805ec48c0da1d47a0d84ee27" translate="yes" xml:space="preserve">
          <source>When an event is dispatched to a listener, the listener method (such as &lt;code&gt;objectChanged()&lt;/code&gt;) may be executed in a thread other than the one in which the call to &lt;code&gt;addNamingListener()&lt;/code&gt; was executed. The choice of which thread to use is made by the service provider. When an event is dispatched to multiple listeners, the service provider may choose (and is generally encouraged) to execute the listener methods concurrently in separate threads.</source>
          <target state="translated">이벤트가 리스너에 전달되면 리스너 메소드 (예 : &lt;code&gt;objectChanged()&lt;/code&gt; )가 &lt;code&gt;addNamingListener()&lt;/code&gt; 에 대한 호출이 실행 된 스레드 이외의 스레드에서 실행될 수 있습니다 . 사용할 스레드 선택은 서비스 공급자가 선택합니다. 이벤트가 여러 리스너로 디스패치 될 때 서비스 제공자는 리스너 메소드를 별도의 스레드에서 동시에 실행하도록 선택할 수 있습니다 (일반적으로 권장됩니다).</target>
        </trans-unit>
        <trans-unit id="c246ece3865225c2043f5d0d8ebe7428a4313f31" translate="yes" xml:space="preserve">
          <source>When an event is reported to indicate that a file in a watched directory has been modified then there is no guarantee that the program (or programs) that have modified the file have completed. Care should be taken to coordinate access with other programs that may be updating the file. The &lt;a href=&quot;../channels/filechannel&quot;&gt;&lt;code&gt;FileChannel&lt;/code&gt;&lt;/a&gt; class defines methods to lock regions of a file against access by other programs.</source>
          <target state="translated">감시 된 디렉토리의 파일이 수정되었음을 나타내는 이벤트가보고되면 파일을 수정 한 프로그램이 완료되었다는 보장이 없습니다. 파일을 업데이트하는 다른 프로그램과의 액세스를 조정하도록주의해야합니다. &lt;a href=&quot;../channels/filechannel&quot;&gt; &lt;code&gt;FileChannel&lt;/code&gt; &lt;/a&gt; 클래스는 다른 프로그램에 의한 액세스로부터 파일의 잠금 지역에 메소드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="bf730b9455534606824acbf9cbbe082f2399a34d" translate="yes" xml:space="preserve">
          <source>When an event occurs on a &lt;code&gt;RowSet&lt;/code&gt; object, one of the &lt;code&gt;RowSetListener&lt;/code&gt; methods will be sent to all registered listeners to notify them of the event. An &lt;code&gt;Event&lt;/code&gt; object is supplied to the &lt;code&gt;RowSetListener&lt;/code&gt; method so that the listener can use it to find out which &lt;code&gt;RowSet&lt;/code&gt; object is the source of the event.</source>
          <target state="translated">&lt;code&gt;RowSet&lt;/code&gt; 객체에서 이벤트가 발생 하면 &lt;code&gt;RowSetListener&lt;/code&gt; 메소드 중 하나가 등록 된 모든 리스너에게 전송되어 이벤트를 알립니다. &lt;code&gt;Event&lt;/code&gt; 객체는에 공급 &lt;code&gt;RowSetListener&lt;/code&gt; 리스너가있는 찾아 사용할 수 있도록 방법 &lt;code&gt;RowSet&lt;/code&gt; 객체가 이벤트의 소스입니다.</target>
        </trans-unit>
        <trans-unit id="46c3263910b048a89e5d5d0939bdd2c5ae531805" translate="yes" xml:space="preserve">
          <source>When an exception is thrown by a factory, the exception is passed on to the caller of &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt;. The search for other factories that may produce a non-null answer is halted. A factory should only throw an exception if it is sure that it is the only intended factory and that no other factories should be tried. If this factory cannot create an object using the arguments supplied, it should return null.</source>
          <target state="translated">팩토리에서 예외가 발생하면 &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt; 호출자에게 예외가 전달됩니다 . 널이 아닌 응답을 생성 할 수있는 다른 팩토리에 대한 검색이 중지됩니다. 팩토리가 유일한 팩토리이고 다른 팩토리를 시도해서는 안되는 경우에만 팩토리에서 예외를 처리해야합니다. 이 팩토리가 제공된 인수를 사용하여 객체를 만들 수 없으면 null을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="86e9ee1cb6edb165bdea53c864741fcfebb100c1" translate="yes" xml:space="preserve">
          <source>When an exception is thrown by a factory, the exception is passed on to the caller of &lt;code&gt;NamingManager.getStateToBind()&lt;/code&gt; and &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt;. The search for other factories that may produce a non-null answer is halted. A factory should only throw an exception if it is sure that it is the only intended factory and that no other factories should be tried. If this factory cannot create an object using the arguments supplied, it should return null.</source>
          <target state="translated">팩토리에서 예외가 발생하면 &lt;code&gt;NamingManager.getStateToBind()&lt;/code&gt; 및 &lt;code&gt;DirectoryManager.getStateToBind()&lt;/code&gt; 호출자에게 예외가 전달됩니다 . 널이 아닌 응답을 생성 할 수있는 다른 팩토리에 대한 검색이 중지됩니다. 팩토리가 유일한 팩토리이고 다른 팩토리를 시도해서는 안되는 경우에만 팩토리에서 예외를 처리해야합니다. 이 팩토리가 제공된 인수를 사용하여 객체를 만들 수 없으면 null을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="f619bd42e631fde289b18b2557593f0674f15c8e" translate="yes" xml:space="preserve">
          <source>When an exception is thrown by an object factory, the exception is passed on to the caller of &lt;code&gt;DirectoryManager.getObjectInstance()&lt;/code&gt;. The search for other factories that may produce a non-null answer is halted. An object factory should only throw an exception if it is sure that it is the only intended factory and that no other object factories should be tried. If this factory cannot create an object using the arguments supplied, it should return null.</source>
          <target state="translated">객체 팩토리에서 예외가 발생하면 &lt;code&gt;DirectoryManager.getObjectInstance()&lt;/code&gt; 호출자에게 예외가 전달됩니다 . 널이 아닌 응답을 생성 할 수있는 다른 팩토리에 대한 검색이 중지됩니다. 오브젝트 팩토리가 유일한 팩토리이고 다른 오브젝트 팩토리를 시도해서는 안되는 경우에만 오브젝트 팩토리가 예외를 처리해야합니다. 이 팩토리가 제공된 인수를 사용하여 객체를 만들 수 없으면 null을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="92d645b31af0488c8796e3e157fa1f6cd126e2c8" translate="yes" xml:space="preserve">
          <source>When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a &lt;a href=&quot;securedirectorystream&quot;&gt;&lt;code&gt;SecureDirectoryStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구현이 레이스없는 방식으로 실행되는 디렉토리의 항목에 대한 작업을 지원하면 반환 된 디렉토리 스트림은 &lt;a href=&quot;securedirectorystream&quot;&gt; &lt;code&gt;SecureDirectoryStream&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2052382560398859691564bf3c293b964fc894ad" translate="yes" xml:space="preserve">
          <source>When an input source is set (using the &lt;code&gt;setInput&lt;/code&gt; method), it may be marked as &quot;seek forward only&quot;. This setting means that images contained within the input source will only be read in order, possibly allowing the reader to avoid caching portions of the input containing data associated with images that have been read previously.</source>
          <target state="translated">입력 소스가 설정되면 ( &lt;code&gt;setInput&lt;/code&gt; 메소드를 사용하여 ) &quot;seek forward only&quot;로 표시 될 수 있습니다. 이 설정은 입력 소스에 포함 된 이미지가 순서 대로만 읽히므로 독자는 이전에 읽은 이미지와 관련된 데이터가 포함 된 입력의 일부를 캐싱하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="7d2fac9efec8951293a4b9ad29501c8bcc43c755" translate="yes" xml:space="preserve">
          <source>When an instance of this class is used as a delegate for the implementation of the BeanContext protocols (and its subprotocols) there exists a 'chicken and egg' problem during deserialization</source>
          <target state="translated">이 클래스의 인스턴스가 BeanContext 프로토콜 (및 그 서브 프로토콜)의 구현을위한 델리게이트로 사용될 때 deserialization 중에 'chicken and egg'문제가 있습니다</target>
        </trans-unit>
        <trans-unit id="f93de7fe2101ac2a970987b76df77b95b8fe1afa" translate="yes" xml:space="preserve">
          <source>When an interior node in the namespace tree has been renamed, the topmost node which is part of the listener's scope should used to generate a rename event. The extent to which this can be supported is provider-specific. For example, a service might generate rename notifications for all descendants of the changed interior node and the corresponding provider might not be able to prevent those notifications from being propagated to the listeners.</source>
          <target state="translated">네임 스페이스 트리의 내부 노드 이름이 바뀌면 리스너 범위의 일부인 최상위 노드가 이름 바꾸기 이벤트를 생성하는 데 사용해야합니다. 이를 지원할 수있는 범위는 공급자마다 다릅니다. 예를 들어, 서비스는 변경된 내부 노드의 모든 하위 항목에 대해 이름 바꾸기 알림을 생성 할 수 있으며 해당 제공자는 해당 알림이 리스너로 전파되는 것을 막을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd4237ea9c386be63cd7b4f69745e762d3518611" translate="yes" xml:space="preserve">
          <source>When an item is selected or deselected by the user, AWT sends an instance of &lt;code&gt;ItemEvent&lt;/code&gt; to the list. When the user double-clicks on an item in a scrolling list, AWT sends an instance of &lt;code&gt;ActionEvent&lt;/code&gt; to the list following the item event. AWT also generates an action event when the user presses the return key while an item in the list is selected.</source>
          <target state="translated">사용자가 항목을 선택하거나 선택 취소하면 AWT는 &lt;code&gt;ItemEvent&lt;/code&gt; 인스턴스 를 목록으로 보냅니다 . 사용자가 스크롤 목록에서 항목을 두 번 클릭하면 AWT는 &lt;code&gt;ActionEvent&lt;/code&gt; 인스턴스를 항목 이벤트 다음에 오는 목록으로 보냅니다 . AWT는 목록의 항목이 선택되는 동안 사용자가 리턴 키를 누를 때도 조치 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e732ae7cab683d25453439abc7257c33de065d2b" translate="yes" xml:space="preserve">
          <source>When an item's state changes, editing is ended.</source>
          <target state="translated">항목의 상태가 변경되면 편집이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="fbb2b60ef4c108dabfab274ea6d643ccbd813a96" translate="yes" xml:space="preserve">
          <source>When an m-let text file is loaded, an instance of each MBean specified in the file is created and registered.</source>
          <target state="translated">m-let 텍스트 파일이로드되면 파일에 지정된 각 MBean의 인스턴스가 작성되고 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="a6d8aaee8e31c5a9c8176090117cbab7f1fb2776" translate="yes" xml:space="preserve">
          <source>When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used to create a thread, starting the thread causes the object's &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing thread.</source>
          <target state="translated">&lt;code&gt;Runnable&lt;/code&gt; 인터페이스를 구현하는 객체 를 사용하여 스레드를 만드는 경우 스레드를 시작하면 개별적으로 실행되는 스레드에서 객체의 &lt;code&gt;run&lt;/code&gt; 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d44aeda78b237a6dbd1402c72d9234eba39323f7" translate="yes" xml:space="preserve">
          <source>When an object is registered in the MBean Server using the &lt;code&gt;registerMBean&lt;/code&gt; or &lt;code&gt;createMBean&lt;/code&gt; methods of the &lt;a href=&quot;mbeanserver&quot;&gt;&lt;code&gt;MBeanServer&lt;/code&gt;&lt;/a&gt; interface, the object's class is examined to determine what type of MBean it is:</source>
          <target state="translated">&lt;a href=&quot;mbeanserver&quot;&gt; &lt;code&gt;MBeanServer&lt;/code&gt; &lt;/a&gt; 인터페이스 의 &lt;code&gt;registerMBean&lt;/code&gt; 또는 &lt;code&gt;createMBean&lt;/code&gt; 메소드를 사용하여 MBean 서버에 오브젝트를 등록 하면 오브젝트의 클래스가 MBean 유형을 판별하기 위해 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="c2972251c7a28b4528fe63074ce4c9c1bf8739a3" translate="yes" xml:space="preserve">
          <source>When an object named &quot;x/y&quot; is subsequently deleted, the corresponding &lt;code&gt;NamingEvent&lt;/code&gt; (&lt;code&gt;evt&lt;/code&gt;) must contain:</source>
          <target state="translated">&quot;x / y&quot;라는 이름의 오브젝트가 이후에 삭제되면 해당하는 &lt;code&gt;NamingEvent&lt;/code&gt; ( &lt;code&gt;evt&lt;/code&gt; )에 다음이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4d30c71c9ef35dac87516151638b387d22978a40" translate="yes" xml:space="preserve">
          <source>When an object of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt; is passed as an argument to an SQL statement, the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the kind of SQL datum being passed to the database. The driver then creates an instance of &lt;code&gt;SQLOutput&lt;/code&gt; and passes it to the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt;. The method &lt;code&gt;writeSQL&lt;/code&gt; in turn calls the appropriate &lt;code&gt;SQLOutput&lt;/code&gt;</source>
          <target state="translated">인터페이스 &lt;code&gt;SQLData&lt;/code&gt; 를 구현하는 클래스의 개체가 SQL 문에 인수로 전달되면 JDBC 드라이버는 &lt;code&gt;SQLData.getSQLType&lt;/code&gt; 메서드 를 호출 하여 데이터베이스에 전달되는 SQL 데이터의 종류를 결정합니다. 그런 다음 드라이버는 &lt;code&gt;SQLOutput&lt;/code&gt; 인스턴스를 만들고 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 메서드에 전달합니다 . &lt;code&gt;writeSQL&lt;/code&gt; 메소드 는 차례로 적절한 &lt;code&gt;SQLOutput&lt;/code&gt; 을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="918b1ed8da41a8cca49ec39767c9d3ef9075b75b" translate="yes" xml:space="preserve">
          <source>When an observable object is newly created, its set of observers is empty. Two observers are considered the same if and only if the &lt;code&gt;equals&lt;/code&gt; method returns true for them.</source>
          <target state="translated">관찰 가능한 객체가 새로 생성되면 관찰자 세트가 비어 있습니다. &lt;code&gt;equals&lt;/code&gt; 메소드가 true를 리턴 하는 경우에만 두 개의 옵저버가 동일한 것으로 간주 됩니다.</target>
        </trans-unit>
        <trans-unit id="784d4ec1dda97713a3424a2f8d9aa99d1febb449" translate="yes" xml:space="preserve">
          <source>When an observed attribute crosses the high threshold, if the &lt;em&gt;notify high&lt;/em&gt; flag is true, then a notification is sent. Subsequent crossings of the high threshold value will not trigger further notifications until the gauge value becomes less than or equal to the low threshold.</source>
          <target state="translated">관찰 된 속성이 상한 임계 값을 초과 할 때, &lt;em&gt;통지 상한&lt;/em&gt; 플래그가 참이면 통지가 전송됩니다. 이후에 높은 임계 값을 초과하면 게이지 값이 낮은 임계 값 이하가 될 때까지 추가 알림이 트리거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f5d6ec3eb5a523cc7305bf106145613183ee461" translate="yes" xml:space="preserve">
          <source>When an observed attribute crosses the low threshold, if the &lt;em&gt;notify low&lt;/em&gt; flag is true, then a notification is sent. Subsequent crossings of the low threshold value will not trigger further notifications until the gauge value becomes greater than or equal to the high threshold.</source>
          <target state="translated">관찰 된 속성이 하한 임계 값을 초과 할 때 &lt;em&gt;알림 낮음&lt;/em&gt; 플래그가 true이면 알림이 전송됩니다. 이후에 낮은 임계 값을 초과하면 게이지 값이 높은 임계 값 이상이 될 때까지 추가 알림이 트리거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8376d748bc3d8b953550a26d5a316d63742f727e" translate="yes" xml:space="preserve">
          <source>When an output device is stopped, the device usually indicates its condition in human readable form locally at the device. A client can obtain more complete device status remotely by querying the printer's &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; attributes.</source>
          <target state="translated">출력 장치가 중지되면 장치는 일반적으로 장치에서 로컬로 사람이 읽을 수있는 형태로 상태를 나타냅니다. 클라이언트는 프린터의 &lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt; 속성 을 쿼리하여 원격으로보다 완전한 장치 상태를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="147224cc677f556536d5eca49857d3c86cec24ef" translate="yes" xml:space="preserve">
          <source>When associating an object to a key on a node using &lt;code&gt;Node.setUserData()&lt;/code&gt; the application can provide a handler that gets called when the node the object is associated to is being cloned, imported, or renamed.</source>
          <target state="translated">&lt;code&gt;Node.setUserData()&lt;/code&gt; 사용하여 객체를 노드의 키에 연결할 때 응용 프로그램은 객체가 연결된 노드가 복제, 가져 오기 또는 이름이 변경 될 때 호출되는 핸들러를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d8993fa1903e158d7bbd09f3a46e487c5d7d23f" translate="yes" xml:space="preserve">
          <source>When associating an object to a key on a node using &lt;code&gt;Node.setUserData()&lt;/code&gt; the application can provide a handler that gets called when the node the object is associated to is being cloned, imported, or renamed. This can be used by the application to implement various behaviors regarding the data it associates to the DOM nodes. This interface defines that handler.</source>
          <target state="translated">&lt;code&gt;Node.setUserData()&lt;/code&gt; 사용하여 객체를 노드의 키에 연결할 때 응용 프로그램은 객체가 연결된 노드가 복제, 가져 오기 또는 이름이 변경 될 때 호출되는 핸들러를 제공 할 수 있습니다. 이는 애플리케이션이 DOM 노드에 연결하는 데이터와 관련된 다양한 동작을 구현하는 데 사용할 수 있습니다. 이 인터페이스는 해당 핸들러를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="18f4b7b2881c180a5a41a1bfe21bf07fe45c228a" translate="yes" xml:space="preserve">
          <source>When automatic drag handling is enabled, most look and feels begin a drag-and-drop operation when the user presses the mouse button over the preview panel. Some look and feels might not support automatic drag and drop; they will ignore this property. You can work around such look and feels by modifying the component to directly call the &lt;code&gt;exportAsDrag&lt;/code&gt; method of a &lt;code&gt;TransferHandler&lt;/code&gt;.</source>
          <target state="translated">자동 드래그 처리가 활성화 된 경우 대부분의 룩앤필은 사용자가 미리보기 패널에서 마우스 버튼을 누를 때 드래그 앤 드롭 작업을 시작합니다. 일부 룩앤필은 자동 드래그 앤 드롭을 지원하지 않을 수 있습니다. 그들은이 속성을 무시합니다. &lt;code&gt;TransferHandler&lt;/code&gt; 의 &lt;code&gt;exportAsDrag&lt;/code&gt; 메서드 를 직접 호출하도록 구성 요소를 수정하여 이러한 모양과 느낌을 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a5f68a5a8fdb6dc2c715dafb047525f1aa4d5b6" translate="yes" xml:space="preserve">
          <source>When automatic drag handling is enabled, most look and feels begin a drag-and-drop operation whenever the user presses the mouse button over an item and then moves the mouse a few pixels. Setting this property to &lt;code&gt;true&lt;/code&gt; can therefore have a subtle effect on how selections behave.</source>
          <target state="translated">자동 드래그 처리가 활성화되면 대부분의 룩앤필은 사용자가 항목 위에 마우스 버튼을 누른 다음 마우스를 몇 픽셀 이동할 때마다 드래그 앤 드롭 작업을 시작합니다. 따라서이 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 선택이 작동하는 방식에 미묘한 영향을 미칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eb0988bb2d24757a9d15f5c99e1e1f5bc8136ae" translate="yes" xml:space="preserve">
          <source>When automatic redirection occurs, the request method of the redirected request may be modified depending on the specific &lt;code&gt;30X&lt;/code&gt; status code, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt; RFC 7231&lt;/a&gt;. In addition, the &lt;code&gt;301&lt;/code&gt; and &lt;code&gt;302&lt;/code&gt; status codes cause a &lt;code&gt;POST&lt;/code&gt; request to be converted to a &lt;code&gt;GET&lt;/code&gt; in the redirected request.</source>
          <target state="translated">자동 리디렉션이 발생하면 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231에&lt;/a&gt; 지정된대로 특정 &lt;code&gt;30X&lt;/code&gt; 상태 코드 에 따라 리디렉션 된 요청의 요청 방법이 수정 될 수 있습니다 . 또한 &lt;code&gt;301&lt;/code&gt; 및 &lt;code&gt;302&lt;/code&gt; 상태 코드 는 리디렉션 된 요청에서 &lt;code&gt;POST&lt;/code&gt; 요청이 &lt;code&gt;GET&lt;/code&gt; 으로 변환되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="cf1414265b010571580fbf696282e71d50cfa5f8" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;lockedMonitors&lt;/code&gt; and &lt;code&gt;lockedSynchronizers&lt;/code&gt; parameters are &lt;code&gt;false&lt;/code&gt;, it is equivalent to calling:</source>
          <target state="translated">두 경우 &lt;code&gt;lockedMonitors&lt;/code&gt; 및 &lt;code&gt;lockedSynchronizers&lt;/code&gt; 매개 변수는 &lt;code&gt;false&lt;/code&gt; , 그것을 호출하는 것과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="b0e8b092db7bbf9a9c972f6aa3306da587cceac0" translate="yes" xml:space="preserve">
          <source>When both the number of rows and the number of columns have been set to non-zero values, either by a constructor or by the &lt;code&gt;setRows&lt;/code&gt; and &lt;code&gt;setColumns&lt;/code&gt; methods, the number of columns specified is ignored. Instead, the number of columns is determined from the specified number of rows and the total number of components in the layout. So, for example, if three rows and two columns have been specified and nine components are added to the layout, they will be displayed as three rows of three columns. Specifying the number of columns affects the layout only when the number of rows is set to zero.</source>
          <target state="translated">생성 자나 &lt;code&gt;setRows&lt;/code&gt; 및 &lt;code&gt;setColumns&lt;/code&gt; 메소드에 의해 행 수와 열 수가 0이 아닌 값으로 설정되면 지정된 열 수가 무시됩니다. 대신 열 수는 지정된 행 수와 레이아웃의 총 구성 요소 수에 따라 결정됩니다. 예를 들어, 3 개의 행과 2 개의 열이 지정되고 9 개의 구성 요소가 레이아웃에 추가 된 경우 3 개 열의 3 개 행으로 표시됩니다. 열 수를 지정하면 행 수가 0으로 설정된 경우에만 레이아웃에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="3bb6d7fddd6b84f1b1c496762483d19e659acc05" translate="yes" xml:space="preserve">
          <source>When cached value was set.</source>
          <target state="translated">캐시 된 값이 설정된 경우</target>
        </trans-unit>
        <trans-unit id="045851de97f115ee864c6b5dbe8a118c8574969c" translate="yes" xml:space="preserve">
          <source>When called by the printing system the &lt;code&gt;Printable&lt;/code&gt; must inspect and honour the supplied PageFormat parameter as well as the page index. The format of the page to be drawn is specified by the supplied PageFormat. The size, orientation and imageable area of the page is therefore already determined and rendering must be within this imageable area. This is key to correct printing behaviour, and it has the implication that the client has the responsibility of tracking what content belongs on the specified page.</source>
          <target state="translated">인쇄 시스템에서 호출 할 때 &lt;code&gt;Printable&lt;/code&gt; 은 제공된 PageFormat 매개 변수와 페이지 색인을 검사하고 준수해야합니다. 그릴 페이지의 형식은 제공된 PageFormat에 의해 지정됩니다. 따라서 페이지의 크기, 방향 및 이미지 가능 영역은 이미 결정되어 있으며 렌더링은이 이미지 가능 영역 내에 있어야합니다. 이것은 올바른 인쇄 동작의 핵심이며 클라이언트가 지정된 페이지에 속한 콘텐츠를 추적 할 책임이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ce13d27b64835af608fbc58b333cc41ac2796b65" translate="yes" xml:space="preserve">
          <source>When called off the</source>
          <target state="translated">꺼질 때</target>
        </trans-unit>
        <trans-unit id="866ffa00bf7dcbeb92203e393cd8afd478ae5220" translate="yes" xml:space="preserve">
          <source>When called with &lt;a href=&quot;#invokeExact(java.lang.Object...)&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;, the adapter invokes the target with no argument changes. (&lt;em&gt;Note:&lt;/em&gt; This behavior is different from a &lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt;fixed arity collector&lt;/a&gt;, since it accepts a whole array of indeterminate length, rather than a fixed number of arguments.)</source>
          <target state="translated">&lt;a href=&quot;#invokeExact(java.lang.Object...)&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; &lt;/a&gt; 와 함께 호출되면 어댑터는 인수 변경없이 대상을 호출합니다. ( &lt;em&gt;참고 :&lt;/em&gt; 이 동작은 &lt;a href=&quot;#asCollector(java.lang.Class,int)&quot;&gt;고정 된 인수&lt;/a&gt; 개수가 아닌 불확실한 길이의 전체 배열을 받아들이 기 때문에 고정 arity 수집기 와 다릅니다 .)</target>
        </trans-unit>
        <trans-unit id="b53c0fffa0b51e47d71e7136baf9352bd22f9aa3" translate="yes" xml:space="preserve">
          <source>When called with &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt;&lt;code&gt;invokeExact&lt;/code&gt;&lt;/a&gt;, the adapter invokes the target with no argument changes. (&lt;em&gt;Note:&lt;/em&gt; This behavior is different from a &lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt;fixed arity collector&lt;/a&gt;, since it accepts a whole array of indeterminate length, rather than a fixed number of arguments.)</source>
          <target state="translated">호출 할 때 &lt;a href=&quot;methodhandle#invokeExact-java.lang.Object...-&quot;&gt; &lt;code&gt;invokeExact&lt;/code&gt; &lt;/a&gt; , 어댑터는 인수없이 변경으로 목표를 호출합니다. ( &lt;em&gt;참고 :&lt;/em&gt; 이 동작은 고정 된 수의 인수가 아닌 불확정 한 길이의 전체 배열을 허용하므로 &lt;a href=&quot;methodhandle#asCollector-java.lang.Class-int-&quot;&gt;고정 된 arity 수집기&lt;/a&gt; 와 다릅니다 .)</target>
        </trans-unit>
        <trans-unit id="31883d2c4cae1cb71309d37302c9eb9553a801df" translate="yes" xml:space="preserve">
          <source>When called with plain, inexact &lt;a href=&quot;#invoke(java.lang.Object...)&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt;, if the caller type is the same as the adapter, the adapter invokes the target as with &lt;code&gt;invokeExact&lt;/code&gt;. (This is the normal behavior for &lt;code&gt;invoke&lt;/code&gt; when types match.)</source>
          <target state="translated">단순하고 정확하지 않은 &lt;a href=&quot;#invoke(java.lang.Object...)&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; 로 호출&lt;/a&gt; 될 때 호출자 유형이 어댑터와 &lt;code&gt;invokeExact&lt;/code&gt; 어댑터는 invokeExact 와 마찬가지로 대상을 호출합니다 . (이것은 유형이 일치 할 때 &lt;code&gt;invoke&lt;/code&gt; 의 정상적인 동작입니다 .)</target>
        </trans-unit>
        <trans-unit id="4a0161ca009c0dbbc06ce2b6680929152732b54d" translate="yes" xml:space="preserve">
          <source>When called with plain, inexact &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt;, if the caller type is the same as the adapter, the adapter invokes the target as with &lt;code&gt;invokeExact&lt;/code&gt;. (This is the normal behavior for &lt;code&gt;invoke&lt;/code&gt; when types match.)</source>
          <target state="translated">일반 부정확 한 &lt;a href=&quot;methodhandle#invoke-java.lang.Object...-&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; 로 호출&lt;/a&gt; 할 때 호출자 유형이 어댑터와 동일하면 어댑터는 &lt;code&gt;invokeExact&lt;/code&gt; 에서와 같이 대상을 호출합니다 . 유형이 일치 할 때 &lt;code&gt;invoke&lt;/code&gt; 대한 일반적인 동작입니다 .</target>
        </trans-unit>
        <trans-unit id="d2f5017e66f8dea9b28eb6f14ce79dfd0d322eb3" translate="yes" xml:space="preserve">
          <source>When called, indicates that compression should end with the current contents of the input buffer.</source>
          <target state="translated">호출되면 압축이 입력 버퍼의 현재 내용으로 끝나야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f8858e1ea3fd1c36363ba040b10db093a73798d1" translate="yes" xml:space="preserve">
          <source>When called, the adapter replaces a trailing array argument by the array's elements, each as its own argument to the target. (The order of the arguments is preserved.) They are converted pairwise by casting and/or unboxing to the types of the trailing parameters of the target. Finally the target is called. What the target eventually returns is returned unchanged by the adapter.</source>
          <target state="translated">호출되면 어댑터는 후행 배열 인수를 배열의 요소 (대상마다 고유 한 인수)로 대체합니다. (인수의 순서는 유지됩니다.) 대상의 후행 매개 변수 유형으로 캐스트 및 / 또는 언 박싱하여 쌍으로 변환됩니다. 마지막으로 대상이 호출됩니다. 대상이 결국 리턴하는 것은 어댑터에 의해 변경되지 않은 상태로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="32698ba91a41a47b1415719cfb3ee4d88be1ebde" translate="yes" xml:space="preserve">
          <source>When called, the adapter replaces its trailing &lt;code&gt;arrayLength&lt;/code&gt; arguments by a single new array of type &lt;code&gt;arrayType&lt;/code&gt;, whose elements comprise (in order) the replaced arguments. Finally the target is called. What the target eventually returns is returned unchanged by the adapter.</source>
          <target state="translated">호출되면 어댑터는 후행 &lt;code&gt;arrayLength&lt;/code&gt; 인수를 &lt;code&gt;arrayType&lt;/code&gt; 유형의 단일 새 배열로 대체합니다.이 배열의 요소는 대체 된 인수를 (순서대로) 구성합니다. 마지막으로 대상이 호출됩니다. 대상이 결국 리턴하는 것은 어댑터에 의해 변경되지 않은 상태로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1d41427d5f2ba9b4f876eb45c993fa83acbb6861" translate="yes" xml:space="preserve">
          <source>When called, the bound handle inserts the given value &lt;code&gt;x&lt;/code&gt; as a new leading argument to the target. The other arguments are also passed unchanged. What the target eventually returns is returned unchanged by the bound handle.</source>
          <target state="translated">호출되면 바인딩 된 핸들은 주어진 값 &lt;code&gt;x&lt;/code&gt; 를 새로운 선행 인수로 대상에 삽입합니다 . 다른 인수도 변경되지 않은 채 전달됩니다. 타겟이 돌려주는 것은 바운드 핸들에 의해 변경되지 않은 상태로 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="07e47dd6263746d4e6b3656f67f0733f7b685387" translate="yes" xml:space="preserve">
          <source>When called, the handle will treat the first argument as a receiver and dispatch on the receiver's type to determine which method implementation to enter. (The dispatching action is identical with that performed by an &lt;code&gt;invokevirtual&lt;/code&gt; or &lt;code&gt;invokeinterface&lt;/code&gt; instruction.)</source>
          <target state="translated">호출되면 핸들은 첫 번째 인수를 수신자로 취급하고 입력 할 메소드 구현을 판별하기 위해 수신자의 유형을 디스패치합니다. 디스패치 작업은 &lt;code&gt;invokevirtual&lt;/code&gt; 또는 &lt;code&gt;invokeinterface&lt;/code&gt; 명령에 의해 수행되는 작업과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="84c71118f0cab56f92d54fd7df74c2d3e7d46279" translate="yes" xml:space="preserve">
          <source>When called, the handle will treat the first argument as a receiver and, for non-private methods, dispatch on the receiver's type to determine which method implementation to enter. For private methods the named method in &lt;code&gt;refc&lt;/code&gt; will be invoked on the receiver. (The dispatching action is identical with that performed by an &lt;code&gt;invokevirtual&lt;/code&gt; or &lt;code&gt;invokeinterface&lt;/code&gt; instruction.)</source>
          <target state="translated">호출 될 때 핸들은 첫 번째 인수를 수신자로 취급하고 비공개 메서드가 아닌 경우 입력 할 메서드 구현을 결정하기 위해 수신자의 유형을 디스패치합니다. 개인 메서드의 경우 &lt;code&gt;refc&lt;/code&gt; 의 명명 된 메서드 가 수신자에서 호출됩니다. (파견 작업은 &lt;code&gt;invokevirtual&lt;/code&gt; 또는 &lt;code&gt;invokeinterface&lt;/code&gt; 명령에 의해 수행되는 작업과 동일 합니다.)</target>
        </trans-unit>
        <trans-unit id="ddf5901ed93495490773362c9912bfbbd03d6639" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;parseWithContext&lt;/code&gt;, the values of the following configuration parameters will be ignored and their default values will always be used instead: &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-validate&quot;&gt;validate&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-validate-if-schema&quot;&gt;validate-if-schema&lt;/a&gt;&quot;, and &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-element-content-whitespace&quot;&gt;element-content-whitespace&lt;/a&gt;&quot;. Other parameters will be treated normally, and the parser is expected to call the &lt;code&gt;LSParserFilter&lt;/code&gt; just as if a whole document was parsed.</source>
          <target state="translated">&lt;code&gt;parseWithContext&lt;/code&gt; 를 호출 할 때 다음 구성 매개 변수의 값이 무시되고 기본값 인 &quot; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-validate&quot;&gt;validate&lt;/a&gt; &quot;, &quot; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-validate-if-schema&quot;&gt;validate-if-schema&lt;/a&gt; &quot;및 &quot; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-element-content-whitespace&quot;&gt;element-content-whitespace&lt;/a&gt; &quot;가 대신 사용됩니다. 다른 매개 변수는 정상적으로 처리되며 구문 분석기는 전체 문서가 구문 분석 된 것처럼 &lt;code&gt;LSParserFilter&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2391920a3b69011b129eed441073582d616d0af6" translate="yes" xml:space="preserve">
          <source>When changes are made to this &lt;code&gt;DirContext&lt;/code&gt;, the effect on enumerations returned by prior calls to this method is undefined.</source>
          <target state="translated">이 &lt;code&gt;DirContext&lt;/code&gt; 가 변경되면 ,이 메소드의 이전 호출에 의해 반환 된 열거에 대한 영향은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="903b7e48a00f4b84896728035808586f9ae200f1" translate="yes" xml:space="preserve">
          <source>When color data is stored in an image of this type, the closest color in the colormap is determined by the &lt;code&gt;IndexColorModel&lt;/code&gt; and the resulting index is stored. Approximation and loss of alpha or color components can result, depending on the colors in the &lt;code&gt;IndexColorModel&lt;/code&gt; colormap.</source>
          <target state="translated">컬러 데이터가이 유형의 이미지에 저장 될 때, 컬러 맵에서 가장 가까운 컬러는 &lt;code&gt;IndexColorModel&lt;/code&gt; 에 의해 결정되고 결과 인덱스가 저장됩니다. &lt;code&gt;IndexColorModel&lt;/code&gt; 컬러 맵 의 색상에 따라 알파 또는 색상 구성 요소의 근사치 및 손실이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="596a1e26a91b27916ea68a39d5613c909fc17bd2" translate="yes" xml:space="preserve">
          <source>When comparing corresponding components of two URIs, if one component is undefined but the other is defined then the first is considered to be less than the second. Unless otherwise noted, string components are ordered according to their natural, case-sensitive ordering as defined by the &lt;a href=&quot;../lang/comparable#compareTo(T)&quot;&gt;&lt;code&gt;String.compareTo&lt;/code&gt;&lt;/a&gt; method. String components that are subject to encoding are compared by comparing their raw forms rather than their encoded forms.</source>
          <target state="translated">두 URI의 해당 구성 요소를 비교할 때 한 구성 요소가 정의되지 않았지만 다른 구성 요소가 정의되어 있으면 첫 번째 구성 요소가 두 번째 구성 요소보다 작은 것으로 간주됩니다. 달리 명시되지 않는 한, 문자열 구성 요소는 &lt;a href=&quot;../lang/comparable#compareTo(T)&quot;&gt; &lt;code&gt;String.compareTo&lt;/code&gt; &lt;/a&gt; 메서드에 정의 된대로 대소 문자를 구분하는 자연스러운 순서에 따라 정렬됩니다 . 인코딩이 적용되는 문자열 구성 요소는 인코딩 된 형식이 아닌 원시 형식을 비교하여 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="a1a9496b1bc6bdad32600169e992ba4825384491" translate="yes" xml:space="preserve">
          <source>When comparing corresponding components of two URIs, if one component is undefined but the other is defined then the first is considered to be less than the second. Unless otherwise noted, string components are ordered according to their natural, case-sensitive ordering as defined by the &lt;a href=&quot;../lang/comparable#compareTo-T-&quot;&gt;&lt;code&gt;String.compareTo&lt;/code&gt;&lt;/a&gt; method. String components that are subject to encoding are compared by comparing their raw forms rather than their encoded forms.</source>
          <target state="translated">두 URI의 해당 구성 요소를 비교할 때 한 구성 요소는 정의되어 있지 않지만 다른 구성 요소는 정의 된 경우 첫 번째 구성 요소는 두 번째 구성 요소보다 작은 것으로 간주됩니다. 달리 언급되지 않는 한, 문자열 구성 요소는 &lt;a href=&quot;../lang/comparable#compareTo-T-&quot;&gt; &lt;code&gt;String.compareTo&lt;/code&gt; &lt;/a&gt; 메소드에 정의 된대로 자연스럽고 대소 문자를 구분하는 순서에 따라 정렬됩니다 . 인코딩 대상 문자열 구성 요소는 인코딩 된 형식이 아닌 원시 형식을 비교하여 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="3f5a301cfb1a53cc09533b6df9b74c243edd2ccf" translate="yes" xml:space="preserve">
          <source>When comparing two version strings, the elements of their corresponding components are compared in pointwise fashion. If one component is longer than the other, but otherwise equal to it, then the first component is considered the greater of the two; otherwise, if two corresponding elements are integers then they are compared as such; otherwise, at least one of the elements is a string, so the other is converted into a string if it is an integer and the two are compared lexicographically. Trailing integer elements with the value zero are ignored.</source>
          <target state="translated">두 버전 문자열을 비교할 때 해당 구성 요소의 요소가 포인트 방식으로 비교됩니다. 한 구성 요소가 다른 구성 요소보다 길지만 같으면 첫 번째 구성 요소가 두 구성 요소 중 더 큰 것으로 간주됩니다. 그렇지 않으면 두 개의 대응하는 요소가 정수이면 그와 같이 비교됩니다. 그렇지 않으면 요소 중 하나 이상이 문자열이므로 다른 요소는 정수이고 두 요소가 사 전적으로 비교되면 문자열로 변환됩니다. 값이 0 인 후행 정수 요소는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="766794f1dde5c4c93fc09600ddd1b32f8b44bbe1" translate="yes" xml:space="preserve">
          <source>When comparing two version strings, the value of &lt;code&gt;$OPT&lt;/code&gt;, if present, may or may not be significant depending on the chosen comparison method. The comparison methods &lt;a href=&quot;#compareTo(java.lang.Runtime.Version)&quot;&gt;&lt;code&gt;compareTo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#compareToIgnoreOptional(java.lang.Runtime.Version)&quot;&gt;&lt;code&gt;compareToIgnoreOptional()&lt;/code&gt;&lt;/a&gt; should be used consistently with the corresponding methods &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;&lt;code&gt;equals()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#equalsIgnoreOptional(java.lang.Object)&quot;&gt;&lt;code&gt;equalsIgnoreOptional()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 버전 문자열을 비교할 때 &lt;code&gt;$OPT&lt;/code&gt; 값이있는 경우 선택한 비교 방법에 따라 중요 할 수도 있고 그렇지 않을 수도 있습니다. 비교 메서드 &lt;a href=&quot;#compareTo(java.lang.Runtime.Version)&quot;&gt; &lt;code&gt;compareTo()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#compareToIgnoreOptional(java.lang.Runtime.Version)&quot;&gt; &lt;code&gt;compareToIgnoreOptional()&lt;/code&gt; &lt;/a&gt; 은 해당 메서드 &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt; &lt;code&gt;equals()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#equalsIgnoreOptional(java.lang.Object)&quot;&gt; &lt;code&gt;equalsIgnoreOptional()&lt;/code&gt; &lt;/a&gt; 과 일관되게 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2103fe1187cedfb38f65d7ce9c0819c612ec17eb" translate="yes" xml:space="preserve">
          <source>When computing a date and time from the calendar fields, there may be insufficient information for the computation (such as only year and month with no day of month), or there may be inconsistent information (such as Tuesday, July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). &lt;code&gt;Calendar&lt;/code&gt; will resolve calendar field values to determine the date and time in the following way.</source>
          <target state="translated">일정 관리 필드에서 날짜 및 시간을 계산할 때 계산에 필요한 정보가 충분하지 않거나 (예 : 월이없는 연도 및 월과 같이) 일치하지 않는 정보가있을 수 있습니다 (1996 년 7 월 15 일 화요일) )-1996 년 7 월 15 일은 실제로 월요일입니다). &lt;code&gt;Calendar&lt;/code&gt; 은 달력 필드 값을 확인하여 다음과 같은 방식으로 날짜와 시간을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="0dcc686243f0157dc4e782a735e5dde3570a33bc" translate="yes" xml:space="preserve">
          <source>When concatenated with a class attribute name, indicates the format of that attribute, using the layout language specified in the JSR 200 specification.</source>
          <target state="translated">클래스 속성 이름과 연결되면 JSR 200 스펙에 지정된 레이아웃 언어를 사용하여 해당 속성의 형식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bb74f60e238e6eeac7b5d4c50c88953481c44a68" translate="yes" xml:space="preserve">
          <source>When concatenated with a code attribute name, indicates the format of that attribute.</source>
          <target state="translated">코드 속성 이름과 연결되면 해당 속성의 형식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1e9e7edd39470beed21937a91c20e5bb29b65a00" translate="yes" xml:space="preserve">
          <source>When concatenated with a code attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]&lt;/code&gt;. The special strings &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">코드 속성 이름과 연결되면 해당 속성의 형식을 나타냅니다. 예를 들어,이 옵션의 효과는 &lt;code&gt;pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]&lt;/code&gt; 내장되어 있습니다. 특수 문자열 &lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c481650236192705c8984496664400b25ae4018" translate="yes" xml:space="preserve">
          <source>When concatenated with a code attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]&lt;/code&gt;. The special strings &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">코드 속성 이름과 연결되면 해당 속성의 형식을 나타냅니다. 예를 들어,이 옵션의 효과는 &lt;code&gt;pack.code.attribute.LocalVariableTable=NH[PHOHRUHRSHH]&lt;/code&gt; 내장되어 있습니다. 특수 문자열 &lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ceb1ddea1eb879c6878c1a1d7674d5ebeef2e985" translate="yes" xml:space="preserve">
          <source>When concatenated with a field attribute name, indicates the format of that attribute.</source>
          <target state="translated">필드 속성 이름과 연결되면 해당 속성의 형식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="47883ebf03b00718b34fcc759408570310a33897" translate="yes" xml:space="preserve">
          <source>When concatenated with a field attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.field.attribute.Deprecated=&lt;/code&gt;. The special strings &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">필드 속성 이름과 연결되면 해당 속성의 형식을 나타냅니다. 예를 들어,이 옵션의 효과는 &lt;code&gt;pack.field.attribute.Deprecated=&lt;/code&gt; 내장되어 있습니다. 특수 문자열 &lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="69b68d3b1ed8dc49253990c27eccbd09190abb43" translate="yes" xml:space="preserve">
          <source>When concatenated with a field attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.field.attribute.Deprecated=&lt;/code&gt;. The special strings &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">필드 속성 이름과 연결되면 해당 속성의 형식을 나타냅니다. 예를 들어,이 옵션의 효과는 &lt;code&gt;pack.field.attribute.Deprecated=&lt;/code&gt; 내장되어 있습니다. 특수 문자열 &lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="33a1709395545b56f118dfdd106e7258d9b8f06b" translate="yes" xml:space="preserve">
          <source>When concatenated with a method attribute name, indicates the format of that attribute.</source>
          <target state="translated">메서드 속성 이름과 연결되면 해당 속성의 형식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c8da13828fde7c93e320323d44f6b62e3d17a27c" translate="yes" xml:space="preserve">
          <source>When concatenated with a method attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.method.attribute.Exceptions=NH[RCH]&lt;/code&gt;. The special strings &lt;a href=&quot;#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">메서드 속성 이름과 연결되면 해당 속성의 형식을 나타냅니다. 예를 들어,이 옵션의 효과는 &lt;code&gt;pack.method.attribute.Exceptions=NH[RCH]&lt;/code&gt; 내장되어 있습니다. 특수 문자열 &lt;a href=&quot;#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b1b39538a51627baa398137ae5124f3674a47944" translate="yes" xml:space="preserve">
          <source>When concatenated with a method attribute name, indicates the format of that attribute. For example, the effect of this option is built in: &lt;code&gt;pack.method.attribute.Exceptions=NH[RCH]&lt;/code&gt;. The special strings &lt;a href=&quot;pack200.packer#ERROR&quot;&gt;&lt;code&gt;ERROR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pack200.packer#STRIP&quot;&gt;&lt;code&gt;STRIP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pack200.packer#PASS&quot;&gt;&lt;code&gt;PASS&lt;/code&gt;&lt;/a&gt; are also allowed.</source>
          <target state="translated">메소드 속성 이름과 연결되면 해당 속성의 형식을 나타냅니다. 예를 들어,이 옵션의 효과는 &lt;code&gt;pack.method.attribute.Exceptions=NH[RCH]&lt;/code&gt; 내장되어 있습니다. 특수 문자열 &lt;a href=&quot;pack200.packer#ERROR&quot;&gt; &lt;code&gt;ERROR&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;pack200.packer#STRIP&quot;&gt; &lt;code&gt;STRIP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;pack200.packer#PASS&quot;&gt; &lt;code&gt;PASS&lt;/code&gt; &lt;/a&gt; 도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="715e1e84dcaa0489832f5e6cede42eba32b7afd9" translate="yes" xml:space="preserve">
          <source>When constructed as fair, threads contend for entry using an approximately arrival-order policy. When the currently held lock is released, either the longest-waiting single writer thread will be assigned the write lock, or if there is a group of reader threads waiting longer than all waiting writer threads, that group will be assigned the read lock.</source>
          <target state="translated">공정한 것으로 구성 될 때, 스레드는 대략 도착 순서 정책을 사용하여 입장을 위해 경쟁합니다. 현재 보유 된 잠금이 해제되면 가장 오래 대기중인 단일 작성기 스레드에 쓰기 잠금이 지정되거나 모든 대기 작성기 스레드보다 오래 대기하는 판독기 스레드 그룹이 있으면 해당 그룹에 읽기 잠금이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="61fbad8d5157fa12e2924a0b101d7488fca8edd0" translate="yes" xml:space="preserve">
          <source>When constructed as non-fair (the default), the order of entry to the read and write lock is unspecified, subject to reentrancy constraints. A nonfair lock that is continuously contended may indefinitely postpone one or more reader or writer threads, but will normally have higher throughput than a fair lock.</source>
          <target state="translated">불공평 (기본값)으로 구성된 경우 읽기 및 쓰기 잠금 항목의 순서는 지정되지 않으며 재진입 제약 조건이 적용됩니다. 지속적으로 유지되는 불공정 잠금은 하나 이상의 판독기 또는 기록기 스레드를 무기한 연기 할 수 있지만 보통 공정 잠금보다 처리량이 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="0e952a0329782ab3d664a78b3d191c4eda125051" translate="yes" xml:space="preserve">
          <source>When constructing a JAR url via &lt;code&gt;new URL(context, spec)&lt;/code&gt;, the following rules apply:</source>
          <target state="translated">&lt;code&gt;new URL(context, spec)&lt;/code&gt; 통해 JAR URL을 구성 할 때 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="41c8b69db960d9e4b36a2e8b2f092f79ddba9a4f" translate="yes" xml:space="preserve">
          <source>When constructing new JavaFileObjects, the file manager must determine where to create them. For example, if a file manager manages regular files on a file system, it would most likely have a current/working directory to use as default location when creating or finding files. A number of hints can be provided to a file manager as to where to create files. Any file manager might choose to ignore these hints.</source>
          <target state="translated">새 JavaFileObject를 구성 할 때 파일 관리자는이를 작성할 위치를 결정해야합니다. 예를 들어, 파일 관리자가 파일 시스템에서 일반 파일을 관리하는 경우 파일을 작성하거나 찾을 때 기본 위치로 사용할 현재 / 작업 디렉토리가있을 것입니다. 파일 관리자에게 파일 작성 위치에 대한 힌트를 제공 할 수 있습니다. 모든 파일 관리자는이 힌트를 무시하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a964eaa3b3cf4ad1eed4195c0e00287e21036db6" translate="yes" xml:space="preserve">
          <source>When converting back to &lt;code&gt;ZonedDateTime&lt;/code&gt;, if the local date-time is in an overlap, then the offset will be retained if possible, otherwise the earlier offset will be used. If in a gap, the local date-time will be adjusted forward by the length of the gap.</source>
          <target state="translated">&lt;code&gt;ZonedDateTime&lt;/code&gt; 으로 다시 변환 할 때 로컬 날짜-시간이 겹치는 경우 가능한 경우 오프셋이 유지되고, 그렇지 않으면 이전 오프셋이 사용됩니다. 간격이 있으면 현지 날짜-시간이 간격의 길이만큼 앞으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="da70171e9e306ca307ebacfcf0e847c01479df72" translate="yes" xml:space="preserve">
          <source>When copy of the object is retrieved (via the &lt;code&gt;get&lt;/code&gt; method), if the class is not available locally, it will be loaded from the appropriate location (specified the URL annotated with the class descriptor when the class was serialized.</source>
          <target state="translated">객체의 복사본을 가져올 때 ( &lt;code&gt;get&lt;/code&gt; 메서드 를 통해 ) 클래스를 로컬에서 사용할 수없는 경우 해당 위치에서로드됩니다 (클래스가 직렬화 될 때 클래스 설명 자로 주석이 달린 URL 지정).</target>
        </trans-unit>
        <trans-unit id="335335544c2a50cfd694c3a55d6ae8a94af447f1" translate="yes" xml:space="preserve">
          <source>When copying a float or double source to an integral type destination, each source sample is cast to the destination type. When copying an integral type source to a float or double destination, the source is first converted to a 32-bit int (if necessary), using the above rules for integral types, and then the int is cast to float or double.</source>
          <target state="translated">부동 또는 이중 소스를 정수 유형 대상에 복사 할 때 각 소스 샘플은 대상 유형으로 캐스트됩니다. 정수 유형 소스를 float 또는 double 대상에 복사 할 때 소스는 먼저 정수 유형에 대한 위의 규칙을 사용하여 32 비트 int (필요한 경우)로 변환 된 다음 int가 float 또는 double로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="3ade72b52f46fe9735881965253dded0d6c147b2" translate="yes" xml:space="preserve">
          <source>When created, the default implementation of &lt;code&gt;ActivationGroup&lt;/code&gt; will override the system properties with the properties requested when its &lt;code&gt;ActivationGroupDesc&lt;/code&gt; was created, and will set a &lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; as the default system security manager. If your application requires specific properties to be set when objects are activated in the group, the application should create a special &lt;code&gt;Properties&lt;/code&gt; object containing these properties, then create an &lt;code&gt;ActivationGroupDesc&lt;/code&gt; with the &lt;code&gt;Properties&lt;/code&gt; object, and use &lt;code&gt;ActivationGroup.createGroup&lt;/code&gt; before creating any &lt;code&gt;ActivationDesc&lt;/code&gt;s (before the default &lt;code&gt;ActivationGroupDesc&lt;/code&gt; is created). If your application requires the use of a security manager other than &lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt;, in the ActivativationGroupDescriptor properties list you can set &lt;code&gt;java.security.manager&lt;/code&gt; property to the name of the security manager you would like to install.</source>
          <target state="translated">만들 때의 기본 구현 &lt;code&gt;ActivationGroup&lt;/code&gt; 의 속성과 시스템 속성을 재정의합니다 그 때 요청 &lt;code&gt;ActivationGroupDesc&lt;/code&gt; 을가 생성 및 설정합니다 &lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt; 기본 시스템 보안 관리자로. 개체가 그룹에서 활성화 될 때 응용 프로그램 설정을 할 특정 속성을 필요로하는 경우, 응용 프로그램이 특별한 만들어야 &lt;code&gt;Properties&lt;/code&gt; 이러한 속성을 포함하는 객체, 다음 생성 &lt;code&gt;ActivationGroupDesc&lt;/code&gt; 을 와 &lt;code&gt;Properties&lt;/code&gt; 개체 및 사용 &lt;code&gt;ActivationGroup.createGroup&lt;/code&gt; 를을 어떤 만들기 전에 &lt;code&gt;ActivationDesc&lt;/code&gt; 전에 (들 기본 &lt;code&gt;ActivationGroupDesc&lt;/code&gt; 생성됨). 애플리케이션 에서 &lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt; 이외의 보안 관리자를 사용해야하는 경우 ActivativationGroupDescriptor 속성 목록에서 &lt;code&gt;java.security.manager&lt;/code&gt; 속성을 설치하려는 보안 관리자의 이름으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="330033318b9b32fd36ddd46bb1ced3469157a8be" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;ChoiceFormat&lt;/code&gt;, you must specify an array of formats and an array of limits. The length of these arrays must be the same. For example,</source>
          <target state="translated">&lt;code&gt;ChoiceFormat&lt;/code&gt; 을 작성할 때 형식 배열과 한계 배열을 지정해야합니다. 이 배열의 길이는 같아야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="09c8af312b3d6fd01641b9e7028cc827b52cff1d" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;Graphics2D&lt;/code&gt; object, the &lt;code&gt;GraphicsConfiguration&lt;/code&gt; specifies the &lt;a id=&quot;deftransform&quot;&gt;default transform&lt;/a&gt; for the target of the &lt;code&gt;Graphics2D&lt;/code&gt; (a &lt;a href=&quot;component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;image&quot;&gt;&lt;code&gt;Image&lt;/code&gt;&lt;/a&gt;). This default transform maps the user space coordinate system to screen and printer device coordinates such that the origin maps to the upper left hand corner of the target region of the device with increasing X coordinates extending to the right and increasing Y coordinates extending downward. The scaling of the default transform is set to identity for those devices that are close to 72 dpi, such as screen devices. The scaling of the default transform is set to approximately 72 user space coordinates per square inch for high resolution devices, such as printers. For image buffers, the default transform is the &lt;code&gt;Identity&lt;/code&gt; transform.</source>
          <target state="translated">만들 때 &lt;code&gt;Graphics2D&lt;/code&gt; 객체의 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 를이 지정 &lt;a id=&quot;deftransform&quot;&gt;기본 변환&lt;/a&gt; 의 대상에 대한 &lt;code&gt;Graphics2D&lt;/code&gt; 의 (A &lt;a href=&quot;component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;image&quot;&gt; &lt;code&gt;Image&lt;/code&gt; &lt;/a&gt;). 이 기본 변환은 사용자 공간 좌표계를 화면 및 프린터 장치 좌표에 매핑하여 원점이 오른쪽으로 확장되는 X 좌표와 아래쪽으로 확장되는 증가하는 Y 좌표와 함께 장치의 대상 영역의 왼쪽 상단 모서리에 매핑되도록합니다. 기본 변환의 배율은 화면 장치와 같이 72dpi에 가까운 장치의 ID로 설정됩니다. 기본 변환의 배율은 프린터와 같은 고해상도 장치의 경우 제곱 인치당 약 72 개의 사용자 공간 좌표로 설정됩니다. 이미지 버퍼의 경우 기본 변환은 &lt;code&gt;Identity&lt;/code&gt; 변환입니다.</target>
        </trans-unit>
        <trans-unit id="8c146d0b369274554520e962246ecbdade5c4558" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;KerberosKey&lt;/code&gt; using the &lt;a href=&quot;#%3Cinit%3E(javax.security.auth.kerberos.KerberosPrincipal,char%5B%5D,java.lang.String)&quot;&gt;&lt;code&gt;KerberosKey(KerberosPrincipal, char[], String)&lt;/code&gt;&lt;/a&gt; constructor, an implementation may accept non-IANA algorithm names (For example, &quot;ArcFourMac&quot; for &quot;rc4-hmac&quot;), but the &lt;a href=&quot;#getAlgorithm()&quot;&gt;&lt;code&gt;getAlgorithm()&lt;/code&gt;&lt;/a&gt; method must always return the IANA algorithm name.</source>
          <target state="translated">&lt;a href=&quot;#%3Cinit%3E(javax.security.auth.kerberos.KerberosPrincipal,char%5B%5D,java.lang.String)&quot;&gt; &lt;code&gt;KerberosKey(KerberosPrincipal, char[], String)&lt;/code&gt; &lt;/a&gt; 생성자를 사용하여 &lt;code&gt;KerberosKey&lt;/code&gt; 를 만들 때 구현에서 비 IANA 알고리즘 이름 (예 : &quot;rc4-hmac&quot;의 경우 &quot;ArcFourMac&quot;)을 허용 할 수 있지만 &lt;a href=&quot;#getAlgorithm()&quot;&gt; &lt;code&gt;getAlgorithm()&lt;/code&gt; &lt;/a&gt; 메서드는 항상 IANA 알고리즘 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9b38bad41028682d65ecb4198fe6abc7015b87c2" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;Paper&lt;/code&gt; object, it is the application's responsibility to ensure that the paper size and the imageable area are compatible. For example, if the paper size is changed from 11 x 17 to 8.5 x 11, the application might need to reduce the imageable area so that whatever is printed fits on the page.</source>
          <target state="translated">&lt;code&gt;Paper&lt;/code&gt; 개체를 만들 때 용지 크기와 이미지 가능 영역이 호환되는지 확인하는 것은 응용 프로그램의 책임입니다. 예를 들어 용지 크기가 11 x 17에서 8.5 x 11로 변경된 경우 응용 프로그램은 인쇄되는 내용이 페이지에 맞도록 이미지 가능 영역을 줄여야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f380ad1809365a52c2f779b295ad176ba7cee1fe" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;TimeZone&lt;/code&gt;, the specified custom time zone ID is normalized in the following syntax:</source>
          <target state="translated">&lt;code&gt;TimeZone&lt;/code&gt; 을 작성할 때 지정된 사용자 정의 시간대 ID는 다음 구문으로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="105221734ccfc8a498e02b002ab64f6bd84a44d9" translate="yes" xml:space="preserve">
          <source>When creating a connector client or server, it is possible to supply an object of type &lt;a href=&quot;../../../../java.base/java/util/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; that defines additional parameters. Each entry in this Map has a key that is a string and an associated value whose type is appropriate for that key. The standard keys defined by the JMX Remote API all begin with the string &quot;&lt;code&gt;jmx.remote.&lt;/code&gt;&quot;. The document &lt;em&gt;JMX Remote API&lt;/em&gt; lists these standard keys.</source>
          <target state="translated">커넥터 클라이언트 또는 서버를 만들 때 추가 매개 변수를 정의하는 &lt;a href=&quot;../../../../java.base/java/util/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 유형의 개체를 제공 할 수 있습니다 . 이 맵의 각 항목에는 문자열 인 키와 해당 키에 적합한 유형의 관련 값이 있습니다. JMX 원격 API에 의해 정의 된 표준 키는 모두 &quot; &lt;code&gt;jmx.remote.&lt;/code&gt; &quot; 문자열로 시작합니다 . 문서 &lt;em&gt;JMX 원격 API&lt;/em&gt; 는 이러한 표준 키를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="b9ab1915b79f38ba00b3dd084c59f43fd7b1a097" translate="yes" xml:space="preserve">
          <source>When creating a connector client or server, it is possible to supply an object of type &lt;a href=&quot;../../../java/util/map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; that defines additional parameters. Each entry in this Map has a key that is a string and an associated value whose type is appropriate for that key. The standard keys defined by the JMX Remote API all begin with the string &quot;&lt;code&gt;jmx.remote.&lt;/code&gt;&quot;. The document &lt;em&gt;JMX Remote API&lt;/em&gt; lists these standard keys.</source>
          <target state="translated">커넥터 클라이언트 또는 서버를 작성할 때 추가 매개 변수를 정의하는 &lt;a href=&quot;../../../java/util/map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 유형의 오브젝트를 제공 할 수 있습니다 . 이 맵의 각 항목에는 문자열 인 키와 해당 키에 적합한 유형의 값이 있습니다. JMX Remote API로 정의 된 표준 키는 모두 &quot; &lt;code&gt;jmx.remote.&lt;/code&gt; &quot; 문자열로 시작합니다 . &lt;em&gt;JMX Remote API&lt;/em&gt; 문서 에는 이러한 표준 키가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="96d5bb0b77a90195ba6f2cbc3333bf0e862753f3" translate="yes" xml:space="preserve">
          <source>When creating a new file this option is a &lt;em&gt;hint&lt;/em&gt; that the new file will be sparse. This option is ignored when not creating a new file.</source>
          <target state="translated">새 파일을 만들 때이 옵션은 새 파일이 드물다 는 &lt;em&gt;힌트&lt;/em&gt; 입니다. 새 파일을 만들지 않으면이 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c39abb2d7aabb3ded864546db651700da7057721" translate="yes" xml:space="preserve">
          <source>When creating a subclass of InitialContext, use this method as follows. Define a new method that uses this method to get an initial context of the desired subclass.</source>
          <target state="translated">InitialContext의 서브 클래스를 작성할 때이 메소드를 다음과 같이 사용하십시오. 이 메소드를 사용하여 원하는 서브 클래스의 초기 컨텍스트를 얻는 새 메소드를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="d46d936e93bb8a599591119f0d596c9ab0f11f7e" translate="yes" xml:space="preserve">
          <source>When data has been received, the &lt;code&gt;WebSocket&lt;/code&gt; invokes a receive method. Methods &lt;code&gt;onText&lt;/code&gt;, &lt;code&gt;onBinary&lt;/code&gt;, &lt;code&gt;onPing&lt;/code&gt; and &lt;code&gt;onPong&lt;/code&gt; must return a &lt;code&gt;CompletionStage&lt;/code&gt; that completes once the message has been received by the listener. If a listener's method returns &lt;code&gt;null&lt;/code&gt; rather than a &lt;code&gt;CompletionStage&lt;/code&gt;, &lt;code&gt;WebSocket&lt;/code&gt; will behave as if the listener returned a &lt;code&gt;CompletionStage&lt;/code&gt; that is already completed normally.</source>
          <target state="translated">데이터가 수신되면 &lt;code&gt;WebSocket&lt;/code&gt; 은 수신 메소드를 호출합니다. &lt;code&gt;onText&lt;/code&gt; , &lt;code&gt;onBinary&lt;/code&gt; , &lt;code&gt;onPing&lt;/code&gt; 및 &lt;code&gt;onPong&lt;/code&gt; 메소드 는 리스너가 메시지를 수신 하면 &lt;code&gt;CompletionStage&lt;/code&gt; 되는 CompletionStage 를 반환해야합니다 . 리스너의 메서드가 &lt;code&gt;CompletionStage&lt;/code&gt; 대신 &lt;code&gt;null&lt;/code&gt; 을 반환 하면 &lt;code&gt;WebSocket&lt;/code&gt; 은 리스너 가 이미 정상적으로 완료된 &lt;code&gt;CompletionStage&lt;/code&gt; 를 반환 한 것처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="020fc5ad194f669ea119d61b8cd7bdd1712118d0" translate="yes" xml:space="preserve">
          <source>When data is being transported using MIDI wire protocol, a &lt;a href=&quot;shortmessage&quot;&gt;&lt;code&gt;ShortMessage&lt;/code&gt;&lt;/a&gt; with the status value &lt;code&gt;0xFF&lt;/code&gt; represents a system reset message. In MIDI files, this same status value denotes a &lt;code&gt;MetaMessage&lt;/code&gt;. The types of meta-message are distinguished from each other by the first byte that follows the status byte &lt;code&gt;0xFF&lt;/code&gt;. The subsequent bytes are data bytes. As with system exclusive messages, there are an arbitrary number of data bytes, depending on the type of &lt;code&gt;MetaMessage&lt;/code&gt;.</source>
          <target state="translated">MIDI 유선 프로토콜을 사용하여 데이터를 전송할 때 상태 값이 &lt;code&gt;0xFF&lt;/code&gt; 인&lt;a href=&quot;shortmessage&quot;&gt; &lt;code&gt;ShortMessage&lt;/code&gt; &lt;/a&gt; 는 시스템 재설정 메시지를 나타냅니다. MIDI 파일에서이 동일한 상태 값은 &lt;code&gt;MetaMessage&lt;/code&gt; 를 나타냅니다 . 메타 메시지의 유형은 상태 바이트 &lt;code&gt;0xFF&lt;/code&gt; 뒤에 오는 첫 번째 바이트로 서로 구별됩니다 . 후속 바이트는 데이터 바이트입니다. 시스템 독점 메시지와 마찬가지로 &lt;code&gt;MetaMessage&lt;/code&gt; 유형에 따라 임의의 데이터 바이트 수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="61fdfc98284714085a633464250d1ada20371927" translate="yes" xml:space="preserve">
          <source>When data is being transported using MIDI wire protocol, a &lt;code&gt;&lt;a href=&quot;shortmessage&quot;&gt;&lt;code&gt;ShortMessage&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; with the status value &lt;code&gt;0xFF&lt;/code&gt; represents a system reset message. In MIDI files, this same status value denotes a &lt;code&gt;MetaMessage&lt;/code&gt;. The types of meta-message are distinguished from each other by the first byte that follows the status byte &lt;code&gt;0xFF&lt;/code&gt;. The subsequent bytes are data bytes. As with system exclusive messages, there are an arbitrary number of data bytes, depending on the type of &lt;code&gt;MetaMessage&lt;/code&gt;.</source>
          <target state="translated">MIDI 와이어 프로토콜을 사용하여 데이터를 전송하는 경우 상태 값이 &lt;code&gt;0xFF&lt;/code&gt; 인 &lt;code&gt;&lt;a href=&quot;shortmessage&quot;&gt;&lt;code&gt;ShortMessage&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 는 시스템 재설정 메시지를 나타냅니다. MIDI 파일에서 이와 동일한 상태 값은 &lt;code&gt;MetaMessage&lt;/code&gt; 를 나타냅니다 . 메타 메시지의 유형은 상태 바이트 &lt;code&gt;0xFF&lt;/code&gt; 다음에 오는 첫 번째 바이트로 서로 구별됩니다 . 후속 바이트는 데이터 바이트입니다. 시스템 독점 메시지와 마찬가지로 &lt;code&gt;MetaMessage&lt;/code&gt; 유형에 따라 임의의 수의 데이터 바이트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="538871f766ab351c2d645502820fda06341f2446" translate="yes" xml:space="preserve">
          <source>When decoding, the &lt;code&gt;UTF-16&lt;/code&gt; charset interprets the byte-order mark at the beginning of the input stream to indicate the byte-order of the stream but defaults to big-endian if there is no byte-order mark; when encoding, it uses big-endian byte order and writes a big-endian byte-order mark.</source>
          <target state="translated">디코딩시 &lt;code&gt;UTF-16&lt;/code&gt; 문자 세트는 입력 스트림의 시작 부분에서 바이트 순서 표시를 해석하여 스트림의 바이트 순서를 표시하지만 바이트 순서 표시가 없으면 기본적으로 빅 엔디안으로 설정됩니다. 인코딩시 빅 엔디안 바이트 순서를 사용하고 빅 엔디안 바이트 순서 표시를 씁니다.</target>
        </trans-unit>
        <trans-unit id="5d918b0ea7fbe3a38f352e3c01e13aa510f07228" translate="yes" xml:space="preserve">
          <source>When decoding, the &lt;code&gt;UTF-16BE&lt;/code&gt; and &lt;code&gt;UTF-16LE&lt;/code&gt; charsets interpret the initial byte-order marks as a &lt;small&gt;ZERO-WIDTH NON-BREAKING SPACE&lt;/small&gt;; when encoding, they do not write byte-order marks.</source>
          <target state="translated">디코딩시 &lt;code&gt;UTF-16BE&lt;/code&gt; 및 &lt;code&gt;UTF-16LE&lt;/code&gt; 문자 세트는 초기 바이트 순서 표시를 &lt;small&gt;ZERO-WIDTH NON-BREAKING SPACE&lt;/small&gt; 로 해석합니다 . 인코딩 할 때 바이트 순서 표시를 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1bbaedc1e7a3af98446547c47a00777304dd4bc" translate="yes" xml:space="preserve">
          <source>When designing applications that use the &lt;code&gt;JTable&lt;/code&gt; it is worth paying close attention to the data structures that will represent the table's data. The &lt;code&gt;DefaultTableModel&lt;/code&gt; is a model implementation that uses a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Vector&lt;/code&gt;s of &lt;code&gt;Object&lt;/code&gt;s to store the cell values. As well as copying the data from an application into the &lt;code&gt;DefaultTableModel&lt;/code&gt;, it is also possible to wrap the data in the methods of the &lt;code&gt;TableModel&lt;/code&gt; interface so that the data can be passed to the &lt;code&gt;JTable&lt;/code&gt; directly, as in the example above. This often results in more efficient applications because the model is free to choose the internal representation that best suits the data. A good rule of thumb for deciding whether to use the &lt;code&gt;AbstractTableModel&lt;/code&gt; or the &lt;code&gt;DefaultTableModel&lt;/code&gt; is to use the &lt;code&gt;AbstractTableModel&lt;/code&gt; as the base class for creating subclasses and the &lt;code&gt;DefaultTableModel&lt;/code&gt; when subclassing is not required.</source>
          <target state="translated">&lt;code&gt;JTable&lt;/code&gt; 을 사용하는 응용 프로그램을 설계 할 때 테이블의 데이터를 나타내는 데이터 구조에 세심한주의를 기울일 필요가 있습니다. &lt;code&gt;DefaultTableModel&lt;/code&gt; 사용하는 모델 구현 &lt;code&gt;Vector&lt;/code&gt; 의 &lt;code&gt;Vector&lt;/code&gt; 의의 &lt;code&gt;Object&lt;/code&gt; 셀 값을 저장할들. 애플리케이션에서 &lt;code&gt;DefaultTableModel&lt;/code&gt; 로 데이터를 복사하는 것뿐만 아니라 데이터가 &lt;code&gt;JTable&lt;/code&gt; 로 전달 될 수 있도록 &lt;code&gt;TableModel&lt;/code&gt; 인터페이스 의 메소드에 데이터를 래핑하는 것도 가능합니다.위의 예에서와 같이 직접. 모델이 데이터에 가장 적합한 내부 표현을 자유롭게 선택할 수 있기 때문에 종종 더 효율적인 응용 프로그램이 생성됩니다. &lt;code&gt;AbstractTableModel&lt;/code&gt; 또는 &lt;code&gt;DefaultTableModel&lt;/code&gt; 을 사용할지 여부를 결정하는 좋은 방법은 &lt;code&gt;AbstractTableModel&lt;/code&gt; 을 서브 클래스 생성을위한 기본 클래스로 사용하고 서브 클래 싱이 필요하지 않은 경우 &lt;code&gt;DefaultTableModel&lt;/code&gt; 을 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="59dd531cc5c7b8c2c34d67569898edd73dd7c276" translate="yes" xml:space="preserve">
          <source>When developing your bean, you can implement the bean features required for your application task omitting the rest of the &lt;code&gt;BeanInfo&lt;/code&gt; features. They will be obtained through the automatic analysis by using the low-level reflection of the bean methods and applying standard design patterns. You have an opportunity to provide additional bean information through various descriptor classes.</source>
          <target state="translated">Bean을 개발할 때 나머지 &lt;code&gt;BeanInfo&lt;/code&gt; 기능을 생략하여 애플리케이션 태스크에 필요한 Bean 기능을 구현할 수 있습니다. 그것들은 빈 메소드의 저수준 반영을 사용하고 표준 디자인 패턴을 적용하여 자동 분석을 통해 얻을 수 있습니다. 다양한 디스크립터 클래스를 통해 추가 Bean 정보를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e298bb1eb347b2cc28bf3c3db8299caa60036f9" translate="yes" xml:space="preserve">
          <source>When disabled, the scaled design metrics are rounded or adjusted to integer distances for layout. The distances between any specific pair of glyphs will be more uniform on the device, but the density and total length of long strings may no longer match the theoretical intentions of the font designer. Disabling this hint will typically produce more readable results on low resolution devices like computer monitors.</source>
          <target state="translated">비활성화하면 확장 된 디자인 메트릭이 반올림되거나 레이아웃의 정수 거리로 조정됩니다. 특정 글리프 쌍 사이의 거리는 장치에서 더 균일하지만 긴 문자열의 밀도와 총 길이는 더 이상 글꼴 디자이너의 이론적 의도와 일치하지 않을 수 있습니다. 이 힌트를 비활성화하면 일반적으로 컴퓨터 모니터와 같은 저해상도 장치에서 더 읽기 쉬운 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="984d0d26836dd3f7be2af922a5a2560cc3df5fe1" translate="yes" xml:space="preserve">
          <source>When displaying the &lt;code&gt;JToolTip&lt;/code&gt;, the &lt;code&gt;ToolTipManager&lt;/code&gt; chooses to use a lightweight &lt;code&gt;JPanel&lt;/code&gt; if it fits.</source>
          <target state="translated">표시 용하는 경우 &lt;code&gt;JToolTip&lt;/code&gt; 을 의 &lt;code&gt;ToolTipManager&lt;/code&gt; 에는 경량 사용하도록 선택 &lt;code&gt;JPanel&lt;/code&gt; 가 적합합니다.</target>
        </trans-unit>
        <trans-unit id="6d1107a71bf9e4fe0583e9859fa2adb2225f96b2" translate="yes" xml:space="preserve">
          <source>When displaying the &lt;code&gt;JToolTip&lt;/code&gt;, the &lt;code&gt;ToolTipManager&lt;/code&gt; chooses to use a lightweight &lt;code&gt;JPanel&lt;/code&gt; if it fits. This method allows you to disable this feature. You have to do disable it if your application mixes light weight and heavy weights components.</source>
          <target state="translated">표시 용하는 경우 &lt;code&gt;JToolTip&lt;/code&gt; 을 의 &lt;code&gt;ToolTipManager&lt;/code&gt; 에는 경량 사용하도록 선택 &lt;code&gt;JPanel&lt;/code&gt; 가 적합합니다. 이 방법을 사용하면이 기능을 비활성화 할 수 있습니다. 응용 프로그램이 가벼운 구성 요소와 무거운 구성 요소를 함께 사용하는 경우 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c8c9e94fef6a9d661fc4f926a9c52a00769d2e8" translate="yes" xml:space="preserve">
          <source>When dragging a component, reassigning it to the drag layer ensures that it is positioned over every other component in the container. When finished dragging, it can be reassigned to its normal layer.</source>
          <target state="translated">구성 요소를 드래그 할 때 드래그 레이어에 다시 할당하면 컨테이너의 다른 모든 구성 요소 위에 배치됩니다. 드래그가 끝나면 일반 레이어에 다시 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="509eab7dc545a495647c552331312cb067390e94" translate="yes" xml:space="preserve">
          <source>When drawing operations are performed, pixels which are the current color are changed to the specified color, and vice versa.</source>
          <target state="translated">그리기 작업을 수행하면 현재 색상 인 픽셀이 지정된 색상으로 변경되고 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f7dc328ec17b4ced8684c2b7e2f146a6ba17ed33" translate="yes" xml:space="preserve">
          <source>When editing, this will be the Component that is doing the actual editing.</source>
          <target state="translated">편집 할 때 실제 편집을 수행하는 컴포넌트가됩니다.</target>
        </trans-unit>
        <trans-unit id="1145f6b1027e817559c57cddc450ec5598c076bb" translate="yes" xml:space="preserve">
          <source>When elements are specified individually, this method provides a convenient way to add a few elements to an existing collection:</source>
          <target state="translated">요소가 개별적으로 지정된 경우이 메소드는 기존 콜렉션에 몇 가지 요소를 추가하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f0547e7d1fe9e7682b31c5b8e679a8b7cf7cdac7" translate="yes" xml:space="preserve">
          <source>When encoding a String, the following rules apply:</source>
          <target state="translated">문자열을 인코딩 할 때 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2886df50730aa358b631dfc37a5f87ecf532d285" translate="yes" xml:space="preserve">
          <source>When entering full-screen mode, all the translucency effects are reset for the window. Its shape is set to &lt;code&gt;null&lt;/code&gt;, the opacity value is set to 1.0f, and the background color alpha is set to 255 (completely opaque). These values are not restored when returning to windowed mode.</source>
          <target state="translated">전체 화면 모드로 들어가면 창에 대한 모든 반투명 효과가 재설정됩니다. 모양은 &lt;code&gt;null&lt;/code&gt; 로 설정되고 불투명도 값은 1.0f로 설정되며 배경색 알파는 255 (완전 불투명)로 설정됩니다. 이 값은 창 모드로 돌아갈 때 복원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80c01c7c80e86af37db5c501ac99fcd713939de9" translate="yes" xml:space="preserve">
          <source>When entering full-screen mode, if the window to be used as a full-screen window is not visible, this method will make it visible. It will remain visible when returning to windowed mode.</source>
          <target state="translated">전체 화면 모드로 들어갈 때 전체 화면 창으로 사용할 창이 표시되지 않으면이 방법을 사용하면 표시됩니다. 창 모드로 돌아 가면 계속 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5f295f2bcf4f51adce71cb39e573a72525869fe4" translate="yes" xml:space="preserve">
          <source>When errors are found by the validator, the parser is responsible to report them to the user-specified &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; (or if the error handler is not set, ignore them or throw them), just like any other errors found by the parser itself. In other words, if the user-specified &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is set, it must receive those errors, and if not, they must be treated according to the implementation specific default error handling rules.</source>
          <target state="translated">유효성 검사기에서 오류를 발견하면 파서는 파서 자체에서 발견 한 다른 오류와 마찬가지로 사용자 지정 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt; 에 오류 를보고해야합니다 (또는 오류 처리기가 설정되지 않은 경우 무시하거나 throw). 즉, 사용자 지정 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt; 가 설정되면 해당 오류를 수신해야하며 그렇지 않은 경우 구현 특정 기본 오류 처리 규칙에 따라 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="519e81f7ec22f984619e01262e1e5c7f97e82d8a" translate="yes" xml:space="preserve">
          <source>When executed in parallel, multiple intermediate results may be instantiated, populated, and merged so as to maintain isolation of mutable data structures. Therefore, even when executed in parallel with non-thread-safe data structures (such as &lt;code&gt;ArrayList&lt;/code&gt;), no additional synchronization is needed for a parallel reduction.</source>
          <target state="translated">병렬로 실행될 때, 가변 데이터 구조의 격리를 유지하기 위해 다수의 중간 결과가 인스턴스화되고, 채워지고, 병합 될 수있다. 따라서 스레드로부터 안전하지 않은 데이터 구조 (예 : &lt;code&gt;ArrayList&lt;/code&gt; ) 와 병렬로 실행될 때에도 병렬 감소를 위해 추가 동기화가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e56182ec56b64aac2076f02ce7d0f6f5838a88a0" translate="yes" xml:space="preserve">
          <source>When expanding the services that a module uses or provides then the onus is on the agent to ensure that the service type will be accessible at each instrumentation site where the service type is used. This method does not check if the service type is a member of the module or in a package exported to the module by another module that it reads.</source>
          <target state="translated">모듈이 사용하거나 제공하는 서비스를 확장 할 때 서비스 유형이 사용되는 각 계측 사이트에서 서비스 유형에 액세스 할 수 있도록 에이전트에 대한 책임이 있습니다. 이 메서드는 서비스 유형이 모듈의 구성원인지 또는 읽은 다른 모듈에서 모듈로 내 보낸 패키지에 있는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f0b5af857f1afde8bd6a1ceed3f08040c8b1571" translate="yes" xml:space="preserve">
          <source>When factor is, for example, 0.5f the result represents 'the mid-point' of its input - an operation that is useful for centering components in a container.</source>
          <target state="translated">예를 들어 factor가 0.5f이면 결과는 입력의 '중간 점'을 나타냅니다. 이는 컨테이너의 구성 요소를 중앙에 배치하는 데 유용한 작업입니다.</target>
        </trans-unit>
        <trans-unit id="d7ba7db81667141a1f9fae4de090c1beacde1d2f" translate="yes" xml:space="preserve">
          <source>When first constructed, an &lt;code&gt;X509CRLSelector&lt;/code&gt; has no criteria enabled and each of the &lt;code&gt;get&lt;/code&gt; methods return a default value (&lt;code&gt;null&lt;/code&gt;). Therefore, the &lt;a href=&quot;#match(java.security.cert.CRL)&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; method would return &lt;code&gt;true&lt;/code&gt; for any &lt;code&gt;X509CRL&lt;/code&gt;. Typically, several criteria are enabled (by calling &lt;a href=&quot;#setIssuers(java.util.Collection)&quot;&gt;&lt;code&gt;setIssuers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setDateAndTime(java.util.Date)&quot;&gt;&lt;code&gt;setDateAndTime&lt;/code&gt;&lt;/a&gt;, for instance) and then the &lt;code&gt;X509CRLSelector&lt;/code&gt; is passed to &lt;a href=&quot;certstore#getCRLs(java.security.cert.CRLSelector)&quot;&gt;&lt;code&gt;CertStore.getCRLs&lt;/code&gt;&lt;/a&gt; or some similar method.</source>
          <target state="translated">처음 생성 될 때 &lt;code&gt;X509CRLSelector&lt;/code&gt; 에는 사용 가능한 기준이 없으며 각 &lt;code&gt;get&lt;/code&gt; 메소드는 기본값 ( &lt;code&gt;null&lt;/code&gt; )을 리턴 합니다. 따라서 &lt;a href=&quot;#match(java.security.cert.CRL)&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; 메서드는 모든 &lt;code&gt;X509CRL&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 일반적으로 몇 가지 기준이 활성화되고 ( 예를 들어 &lt;a href=&quot;#setIssuers(java.util.Collection)&quot;&gt; &lt;code&gt;setIssuers&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#setDateAndTime(java.util.Date)&quot;&gt; &lt;code&gt;setDateAndTime&lt;/code&gt; &lt;/a&gt; 을 호출 하여) &lt;code&gt;X509CRLSelector&lt;/code&gt; 가 &lt;a href=&quot;certstore#getCRLs(java.security.cert.CRLSelector)&quot;&gt; &lt;code&gt;CertStore.getCRLs&lt;/code&gt; &lt;/a&gt; 또는 유사한 메서드에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9649a12169ece945cbfdacee36bb86668bdc338e" translate="yes" xml:space="preserve">
          <source>When first constructed, an &lt;code&gt;X509CRLSelector&lt;/code&gt; has no criteria enabled and each of the &lt;code&gt;get&lt;/code&gt; methods return a default value (&lt;code&gt;null&lt;/code&gt;). Therefore, the &lt;a href=&quot;x509crlselector#match-java.security.cert.CRL-&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; method would return &lt;code&gt;true&lt;/code&gt; for any &lt;code&gt;X509CRL&lt;/code&gt;. Typically, several criteria are enabled (by calling &lt;a href=&quot;x509crlselector#setIssuers-java.util.Collection-&quot;&gt;&lt;code&gt;setIssuers&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;x509crlselector#setDateAndTime-java.util.Date-&quot;&gt;&lt;code&gt;setDateAndTime&lt;/code&gt;&lt;/a&gt;, for instance) and then the &lt;code&gt;X509CRLSelector&lt;/code&gt; is passed to &lt;a href=&quot;certstore#getCRLs-java.security.cert.CRLSelector-&quot;&gt;&lt;code&gt;CertStore.getCRLs&lt;/code&gt;&lt;/a&gt; or some similar method.</source>
          <target state="translated">&lt;code&gt;X509CRLSelector&lt;/code&gt; 가 처음 생성 될 때 기준을 사용할 수 없으며 각 &lt;code&gt;get&lt;/code&gt; 메소드가 기본값 ( &lt;code&gt;null&lt;/code&gt; )을 리턴 합니다. 따라서 &lt;a href=&quot;x509crlselector#match-java.security.cert.CRL-&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; 메소드는 모든 &lt;code&gt;X509CRL&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 일반적으로 몇 가지 기준 (예 : &lt;a href=&quot;x509crlselector#setIssuers-java.util.Collection-&quot;&gt; &lt;code&gt;setIssuers&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;x509crlselector#setDateAndTime-java.util.Date-&quot;&gt; &lt;code&gt;setDateAndTime&lt;/code&gt; &lt;/a&gt; 을 호출하여)을 활성화 한 다음 &lt;code&gt;X509CRLSelector&lt;/code&gt; 를 &lt;a href=&quot;certstore#getCRLs-java.security.cert.CRLSelector-&quot;&gt; &lt;code&gt;CertStore.getCRLs&lt;/code&gt; &lt;/a&gt; 또는 유사한 메소드로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="20860ac3af47ff5e6527ceeb9db68080e38b9d93" translate="yes" xml:space="preserve">
          <source>When first constructed, an &lt;code&gt;X509CertSelector&lt;/code&gt; has no criteria enabled and each of the &lt;code&gt;get&lt;/code&gt; methods return a default value (&lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; for the &lt;a href=&quot;#getBasicConstraints()&quot;&gt;&lt;code&gt;getBasicConstraints&lt;/code&gt;&lt;/a&gt; method). Therefore, the &lt;a href=&quot;#match(java.security.cert.Certificate)&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; method would return &lt;code&gt;true&lt;/code&gt; for any &lt;code&gt;X509Certificate&lt;/code&gt;. Typically, several criteria are enabled (by calling &lt;a href=&quot;#setIssuer(javax.security.auth.x500.X500Principal)&quot;&gt;&lt;code&gt;setIssuer&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setKeyUsage(boolean%5B%5D)&quot;&gt;&lt;code&gt;setKeyUsage&lt;/code&gt;&lt;/a&gt;, for instance) and then the &lt;code&gt;X509CertSelector&lt;/code&gt; is passed to &lt;a href=&quot;certstore#getCertificates(java.security.cert.CertSelector)&quot;&gt;&lt;code&gt;CertStore.getCertificates&lt;/code&gt;&lt;/a&gt; or some similar method.</source>
          <target state="translated">처음 생성 될 때 &lt;code&gt;X509CertSelector&lt;/code&gt; 에는 사용 가능한 기준이 없으며 각 &lt;code&gt;get&lt;/code&gt; 메소드는 기본값 ( &lt;a href=&quot;#getBasicConstraints()&quot;&gt; &lt;code&gt;getBasicConstraints&lt;/code&gt; &lt;/a&gt; 메소드의 경우 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;-1&lt;/code&gt; ) 을 리턴합니다 . 따라서 &lt;a href=&quot;#match(java.security.cert.Certificate)&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; 메서드는 모든 &lt;code&gt;X509Certificate&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 일반적으로 몇 가지 기준이 활성화되고 (예 : &lt;a href=&quot;#setIssuer(javax.security.auth.x500.X500Principal)&quot;&gt; &lt;code&gt;setIssuer&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#setKeyUsage(boolean%5B%5D)&quot;&gt; &lt;code&gt;setKeyUsage&lt;/code&gt; &lt;/a&gt; 호출 ) &lt;code&gt;X509CertSelector&lt;/code&gt; 가 &lt;a href=&quot;certstore#getCertificates(java.security.cert.CertSelector)&quot;&gt; &lt;code&gt;CertStore.getCertificates&lt;/code&gt; &lt;/a&gt; 또는 유사한 메서드에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="d650c98b41df8d2991fdd69b36d1bd6550c57b66" translate="yes" xml:space="preserve">
          <source>When first constructed, an &lt;code&gt;X509CertSelector&lt;/code&gt; has no criteria enabled and each of the &lt;code&gt;get&lt;/code&gt; methods return a default value (&lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; for the &lt;a href=&quot;x509certselector#getBasicConstraints--&quot;&gt;&lt;code&gt;getBasicConstraints&lt;/code&gt;&lt;/a&gt; method). Therefore, the &lt;a href=&quot;x509certselector#match-java.security.cert.Certificate-&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; method would return &lt;code&gt;true&lt;/code&gt; for any &lt;code&gt;X509Certificate&lt;/code&gt;. Typically, several criteria are enabled (by calling &lt;a href=&quot;x509certselector#setIssuer-javax.security.auth.x500.X500Principal-&quot;&gt;&lt;code&gt;setIssuer&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;x509certselector#setKeyUsage-boolean:A-&quot;&gt;&lt;code&gt;setKeyUsage&lt;/code&gt;&lt;/a&gt;, for instance) and then the &lt;code&gt;X509CertSelector&lt;/code&gt; is passed to &lt;a href=&quot;certstore#getCertificates-java.security.cert.CertSelector-&quot;&gt;&lt;code&gt;CertStore.getCertificates&lt;/code&gt;&lt;/a&gt; or some similar method.</source>
          <target state="translated">최초로 구축 &lt;code&gt;X509CertSelector&lt;/code&gt; 의은 어떤 기준이 포함되지 않기 때문에 각각 &lt;code&gt;get&lt;/code&gt; 방법 (디폴트 값을 반환 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;-1&lt;/code&gt; 위한 &lt;a href=&quot;x509certselector#getBasicConstraints--&quot;&gt; &lt;code&gt;getBasicConstraints&lt;/code&gt; 의&lt;/a&gt; 방법). 따라서 &lt;a href=&quot;x509certselector#match-java.security.cert.Certificate-&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; 메소드는 모든 &lt;code&gt;X509Certificate&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 일반적으로 몇 가지 기준 (예 : &lt;a href=&quot;x509certselector#setIssuer-javax.security.auth.x500.X500Principal-&quot;&gt; &lt;code&gt;setIssuer&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;x509certselector#setKeyUsage-boolean:A-&quot;&gt; &lt;code&gt;setKeyUsage&lt;/code&gt; &lt;/a&gt; 호출)을 사용하도록 설정 한 다음 &lt;code&gt;X509CertSelector&lt;/code&gt; 를 &lt;a href=&quot;certstore#getCertificates-java.security.cert.CertSelector-&quot;&gt; &lt;code&gt;CertStore.getCertificates&lt;/code&gt; &lt;/a&gt; 또는 유사한 메소드로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="6bdbc4072fa0aa2a890b6aafd2d77f59bcdf8288" translate="yes" xml:space="preserve">
          <source>When flip contents are &lt;code&gt;BACKGROUND&lt;/code&gt;, the contents of the back buffer are cleared with the background color after flipping.</source>
          <target state="translated">반전 내용이 &lt;code&gt;BACKGROUND&lt;/code&gt; 인 경우 반전 후 백 버퍼의 내용이 배경색 으로 지워집니다.</target>
        </trans-unit>
        <trans-unit id="63cdfb20b747808fb558b523ddbdc11e871de470" translate="yes" xml:space="preserve">
          <source>When flip contents are &lt;code&gt;COPIED&lt;/code&gt;, the contents of the back buffer are copied to the front buffer when flipping.</source>
          <target state="translated">뒤집기 내용이 &lt;code&gt;COPIED&lt;/code&gt; 인 경우 뒤집을 때 백 버퍼의 내용이 전면 버퍼로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="b82198f8743b3ee395f98263a6da347029744bd3" translate="yes" xml:space="preserve">
          <source>When flip contents are &lt;code&gt;PRIOR&lt;/code&gt;, the contents of the back buffer are the prior contents of the front buffer (a true page flip).</source>
          <target state="translated">플립 컨텐츠가 &lt;code&gt;PRIOR&lt;/code&gt; 인 경우 백 버퍼의 컨텐츠는 프론트 버퍼의 이전 컨텐츠입니다 (진정한 페이지 플립).</target>
        </trans-unit>
        <trans-unit id="6e1e2b99b6522b5b56f0b7775f1acd75a21bc115" translate="yes" xml:space="preserve">
          <source>When flip contents are &lt;code&gt;UNDEFINED&lt;/code&gt;, the contents of the back buffer are undefined after flipping.</source>
          <target state="translated">반전 내용이 &lt;code&gt;UNDEFINED&lt;/code&gt; 이면 반전 후 백 버퍼의 내용이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ff93d04cdedfee3d54c1d406cb192a14d80e305" translate="yes" xml:space="preserve">
          <source>When formatting, if the temporal object contains a date, then it will be converted to a date in the override chronology. Whether the temporal contains a date is determined by querying the &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;EPOCH_DAY&lt;/code&gt;&lt;/a&gt; field. Any time or zone will be retained unaltered unless overridden.</source>
          <target state="translated">서식을 지정할 때 임시 개체에 날짜가 포함되어 있으면 재정의 연대기의 날짜로 변환됩니다. 시간에 날짜가 포함되는지 여부는 &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 필드 를 쿼리하여 결정됩니다 . 재정의되지 않는 한 모든 시간 또는 영역은 변경되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c46c21d901a51405a6408d147e04ecbd8a3f7e31" translate="yes" xml:space="preserve">
          <source>When formatting, if the temporal object contains an instant, then it will be converted to a zoned date-time using the override zone. Whether the temporal is an instant is determined by querying the &lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt;&lt;code&gt;INSTANT_SECONDS&lt;/code&gt;&lt;/a&gt; field. If the input has a chronology then it will be retained unless overridden. If the input does not have a chronology, such as &lt;code&gt;Instant&lt;/code&gt;, then the ISO chronology will be used.</source>
          <target state="translated">서식을 지정할 때 임시 개체에 순간 개체가 포함 된 경우 재정의 영역을 사용하여 영역 날짜 / 시간으로 변환됩니다. 시간이 순간인지 여부는 &lt;a href=&quot;../temporal/chronofield#INSTANT_SECONDS&quot;&gt; &lt;code&gt;INSTANT_SECONDS&lt;/code&gt; &lt;/a&gt; 필드 를 쿼리하여 결정됩니다 . 입력에 연대기가있는 경우 재정의되지 않는 한 입력이 유지됩니다. 입력에 &lt;code&gt;Instant&lt;/code&gt; 와 같은 연대기가없는 경우 ISO 연대기가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e3ccef18e16794ea6e4ca8f3deb0092f315cf23d" translate="yes" xml:space="preserve">
          <source>When four parts are specified, each is interpreted as a byte of data and assigned, from left to right, to the four bytes of an IPv4 address.</source>
          <target state="translated">4 개의 부분이 지정되면 각각은 데이터 바이트로 해석되고 왼쪽에서 오른쪽으로 IPv4 주소의 4 바이트에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="774dda26093b2a90cd6b2fb725005764df15f2fa" translate="yes" xml:space="preserve">
          <source>When getting a run with no explicit attributes specified (i.e., calling &lt;a href=&quot;#getRunStart()&quot;&gt;&lt;code&gt;getRunStart()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#getRunLimit()&quot;&gt;&lt;code&gt;getRunLimit()&lt;/code&gt;&lt;/a&gt;), any contiguous text segments having the same attributes (the same set of attribute/value pairs) are treated as separate runs if the attributes have been given to those text segments separately.</source>
          <target state="translated">명시 적 속성이 지정되지 않은 실행을 &lt;a href=&quot;#getRunStart()&quot;&gt; &lt;code&gt;getRunStart()&lt;/code&gt; &lt;/a&gt; (즉, getRunStart () 및 &lt;a href=&quot;#getRunLimit()&quot;&gt; &lt;code&gt;getRunLimit()&lt;/code&gt; &lt;/a&gt; 호출 ) 동일한 속성 (동일한 속성 / 값 쌍 집합)을 가진 연속 텍스트 세그먼트는 속성이 지정된 경우 별도의 실행으로 처리됩니다. 해당 텍스트 세그먼트에 별도로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1ae85906e6fddb6d1dc408436e61d763b88ac485" translate="yes" xml:space="preserve">
          <source>When getting a run with no explicit attributes specified (i.e., calling &lt;a href=&quot;attributedcharacteriterator#getRunStart--&quot;&gt;&lt;code&gt;getRunStart()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;attributedcharacteriterator#getRunLimit--&quot;&gt;&lt;code&gt;getRunLimit()&lt;/code&gt;&lt;/a&gt;), any contiguous text segments having the same attributes (the same set of attribute/value pairs) are treated as separate runs if the attributes have been given to those text segments separately.</source>
          <target state="translated">명시 적 속성이 지정되지 않은 실행을 &lt;a href=&quot;attributedcharacteriterator#getRunStart--&quot;&gt; &lt;code&gt;getRunStart()&lt;/code&gt; &lt;/a&gt; (예 : getRunStart () 및 &lt;a href=&quot;attributedcharacteriterator#getRunLimit--&quot;&gt; &lt;code&gt;getRunLimit()&lt;/code&gt; &lt;/a&gt; 호출 ), 속성이 동일한 경우 동일한 속성 (동일한 속성 / 값 쌍 세트)을 가진 인접한 텍스트 세그먼트는 별도의 실행으로 처리됩니다. 해당 텍스트 세그먼트에 개별적으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b5ba05bc071c59eee04254d6fa68df75d14578d6" translate="yes" xml:space="preserve">
          <source>When initially formatting a value if the length of the string is less than the length of the mask, two things can happen. Either the placeholder string will be used, or the placeholder character will be used. Precedence is given to the placeholder string. For example:</source>
          <target state="translated">문자열의 길이가 마스크의 길이보다 작은 경우 처음에 값을 형식화 할 때 두 가지 일이 발생할 수 있습니다. 자리 표시 자 문자열이 사용되거나 자리 표시 자 문자가 사용됩니다. 자리 표시 자 문자열에 우선 순위가 지정됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="8dd1bcbc018d3b4bb41eefe5512da3834ff920d7" translate="yes" xml:space="preserve">
          <source>When invoked on an &lt;code&gt;ArrayType&lt;/code&gt; instance, the &lt;a href=&quot;opentype#getClassName()&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method returns the class name of the array instances it describes (following the rules defined by the &lt;a href=&quot;../../../../java.base/java/lang/class#getName()&quot;&gt;&lt;code&gt;getName&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;java.lang.Class&lt;/code&gt;), not the class name of the array elements (which is returned by a call to &lt;code&gt;getElementOpenType().getClassName()&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ArrayType&lt;/code&gt; 인스턴스에서 호출 될 때 &lt;a href=&quot;opentype#getClassName()&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt; 메소드는 설명하는 배열 인스턴스의 클래스 이름을 리턴합니다 ( &lt;code&gt;java.lang.Class&lt;/code&gt; 의 &lt;a href=&quot;../../../../java.base/java/lang/class#getName()&quot;&gt; &lt;code&gt;getName&lt;/code&gt; &lt;/a&gt; 메소드에 정의 된 규칙에 따라 ). &lt;code&gt;getElementOpenType().getClassName()&lt;/code&gt; )에 대한 호출 .</target>
        </trans-unit>
        <trans-unit id="302acd17292bb6cb5b2e63e5ea447c50cffa715c" translate="yes" xml:space="preserve">
          <source>When invoked on an &lt;code&gt;ArrayType&lt;/code&gt; instance, the &lt;a href=&quot;opentype#getClassName--&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method returns the class name of the array instances it describes (following the rules defined by the &lt;a href=&quot;../../../java/lang/class#getName--&quot;&gt;&lt;code&gt;getName&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;java.lang.Class&lt;/code&gt;), not the class name of the array elements (which is returned by a call to &lt;code&gt;getElementOpenType().getClassName()&lt;/code&gt;).</source>
          <target state="translated">온 호출되면 &lt;code&gt;ArrayType&lt;/code&gt; 의 인스턴스의 &lt;a href=&quot;opentype#getClassName--&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt; 메소드가 복귀 (의해 정의 된 규칙에 따라이를 설명 배열 인스턴스의 클래스 이름 &lt;a href=&quot;../../../java/lang/class#getName--&quot;&gt; &lt;code&gt;getName&lt;/code&gt; 의&lt;/a&gt; 방법 &lt;code&gt;java.lang.Class&lt;/code&gt; 에 의해 반환) 배열 요소 아닌 클래스 이름 ( 를 호출 &lt;code&gt;getElementOpenType().getClassName()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="580b70b0aa9940a4d315897412a3c8e6a50c10fb" translate="yes" xml:space="preserve">
          <source>When it is desirable to group together a number of Permission objects of the same type, the &lt;code&gt;newPermissionCollection&lt;/code&gt; method on that particular type of Permission object should first be called. The default behavior (from the Permission class) is to simply return null. Subclasses of class Permission override the method if they need to store their permissions in a particular PermissionCollection object in order to provide the correct semantics when the &lt;code&gt;PermissionCollection.implies&lt;/code&gt; method is called. If a non-null value is returned, that PermissionCollection must be used. If null is returned, then the caller of &lt;code&gt;newPermissionCollection&lt;/code&gt; is free to store permissions of the given type in any PermissionCollection they choose (one that uses a Hashtable, one that uses a Vector, etc).</source>
          <target state="translated">동일한 유형의 여러 Permission 객체를 그룹화하는 것이 바람직한 경우 해당 특정 유형의 Permission 객체에 대한 &lt;code&gt;newPermissionCollection&lt;/code&gt; 메소드를 먼저 호출해야합니다. Permission 클래스의 기본 동작은 단순히 null을 반환하는 것입니다. &lt;code&gt;PermissionCollection.implies&lt;/code&gt; 메소드가 호출 될 때 올바른 의미를 제공하기 위해 Permission 클래스의 서브 클래스가 특정 PermissionCollection 오브젝트에 권한을 저장해야하는 경우 메소드를 대체합니다 . 널이 아닌 값이 리턴되면 해당 PermissionCollection을 사용해야합니다. null이 반환되면 &lt;code&gt;newPermissionCollection&lt;/code&gt; 의 호출자 선택한 PermissionCollection (해시 테이블을 사용하는 것, 벡터를 사용하는 것 등)에 주어진 유형의 권한을 자유롭게 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce33c85f5d00ceaaf151e94b617d0fd035ff89e8" translate="yes" xml:space="preserve">
          <source>When leaf Views (such as LabelView) are rendering they should call into this method.</source>
          <target state="translated">리프 뷰 (예 : LabelView)가 렌더링 될 때이 메서드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf1e959633bde681b0bed5cc3b7b643970517499" translate="yes" xml:space="preserve">
          <source>When leaf Views (such as LabelView) are rendering they should call into this method. If a highlight is in the given region it will be drawn immediately.</source>
          <target state="translated">리프 뷰 (예 : LabelView)가 렌더링 될 때이 메서드를 호출해야합니다. 강조 표시가 지정된 영역에 있으면 즉시 그려집니다.</target>
        </trans-unit>
        <trans-unit id="174a6496db7aea116f5760d2cbbff2da29431d36" translate="yes" xml:space="preserve">
          <source>When loading or instantiating a service provider in a module, &lt;code&gt;
 ServiceConfigurationError&lt;/code&gt; can be thrown for the following reasons:</source>
          <target state="translated">모듈에서 서비스 공급자를로드하거나 인스턴스화 할 때 다음과 같은 이유로 &lt;code&gt; ServiceConfigurationError&lt;/code&gt; 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4328d60614b67a469dcc46dc7b40428e7a16ab80" translate="yes" xml:space="preserve">
          <source>When locating modules then any exceptions or errors thrown by the &lt;code&gt;find&lt;/code&gt; or &lt;code&gt;findAll&lt;/code&gt; methods of the underlying module finders will be propagated to the caller of the resulting module finder's &lt;code&gt;find&lt;/code&gt; or &lt;code&gt;findAll&lt;/code&gt; methods.</source>
          <target state="translated">모듈을 &lt;code&gt;find&lt;/code&gt; 때 기본 모듈 파인더의 &lt;code&gt;findAll&lt;/code&gt; 또는 findAll 메소드에서 발생한 예외 또는 오류 는 결과 모듈 파인더의 &lt;code&gt;find&lt;/code&gt; 또는 &lt;code&gt;findAll&lt;/code&gt; 메소드 의 호출자에게 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="16ba2f01e5d521afc7a1d8765c061f6962009acc" translate="yes" xml:space="preserve">
          <source>When locking and unlocking occur in different scopes, care must be taken to ensure that all code that is executed while the lock is held is protected by try-finally or try-catch to ensure that the lock is released when necessary.</source>
          <target state="translated">잠금 및 잠금 해제가 다른 범위에서 발생하는 경우 잠금이 유지되는 동안 실행되는 모든 코드가 try-finally 또는 try-catch로 보호되어 필요할 때 잠금이 해제되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0d60a7362268503ac5f29c4e995b665bfa49ca4" translate="yes" xml:space="preserve">
          <source>When logging is enabled for the given level, the default implementation for this method calls &lt;code&gt;this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);&lt;/code&gt;</source>
          <target state="translated">지정된 수준에 대해 로깅이 활성화 된 경우이 메서드의 기본 구현은 &lt;code&gt;this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b48d582b593f5a0b71b33ebfba543a2007aa703" translate="yes" xml:space="preserve">
          <source>When logging is enabled for the given level, the default implementation for this method calls &lt;code&gt;this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);&lt;/code&gt;</source>
          <target state="translated">지정된 수준에 대해 로깅이 활성화 된 경우이 메서드의 기본 구현은 &lt;code&gt;this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1dd8bd9ca02efdcd9732b7cf62a3e53ee34a950" translate="yes" xml:space="preserve">
          <source>When logging is enabled for the given level, the default implementation for this method calls &lt;code&gt;this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);&lt;/code&gt;</source>
          <target state="translated">지정된 수준에 대해 로깅이 활성화되면이 메서드에 대한 기본 구현은 &lt;code&gt;this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6e7f5643792532437bd221471efc47beceaab52" translate="yes" xml:space="preserve">
          <source>When looking for a &lt;code&gt;ResourceBundle&lt;/code&gt;, the logger will first look at whether a bundle was specified using &lt;a href=&quot;#setResourceBundle(java.util.ResourceBundle)&quot;&gt;&lt;code&gt;setResourceBundle&lt;/code&gt;&lt;/a&gt;, and then only whether a resource bundle name was specified through the &lt;a href=&quot;#getLogger(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;getLogger&lt;/code&gt;&lt;/a&gt; factory method. If no &lt;code&gt;ResourceBundle&lt;/code&gt; or no resource bundle name is found, then it will use the nearest &lt;code&gt;ResourceBundle&lt;/code&gt; or resource bundle name inherited from its parent tree.</source>
          <target state="translated">&lt;code&gt;ResourceBundle&lt;/code&gt; 을 찾을 때 로거는 먼저 &lt;a href=&quot;#setResourceBundle(java.util.ResourceBundle)&quot;&gt; &lt;code&gt;setResourceBundle&lt;/code&gt; 을&lt;/a&gt; 사용하여 번들이 지정되었는지 여부를 확인한 다음 &lt;a href=&quot;#getLogger(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;getLogger&lt;/code&gt; &lt;/a&gt; 팩토리 메소드를 통해 리소스 번들 이름이 지정되었는지 여부 만 확인합니다 . 어떤 경우 &lt;code&gt;ResourceBundle&lt;/code&gt; 또는 전혀 자원 번들 이름이 발견되지 않는, 그것은 가장 가까운 사용 &lt;code&gt;ResourceBundle&lt;/code&gt; 하거나 부모 트리에서 상속 번들 이름을 자원.</target>
        </trans-unit>
        <trans-unit id="1a0408130f81738a723c33c438670c4461590e47" translate="yes" xml:space="preserve">
          <source>When looking for a &lt;code&gt;ResourceBundle&lt;/code&gt;, the logger will first look at whether a bundle was specified using &lt;a href=&quot;logger#setResourceBundle-java.util.ResourceBundle-&quot;&gt;&lt;code&gt;setResourceBundle&lt;/code&gt;&lt;/a&gt;, and then only whether a resource bundle name was specified through the &lt;a href=&quot;logger#getLogger-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;getLogger&lt;/code&gt;&lt;/a&gt; factory method. If no &lt;code&gt;ResourceBundle&lt;/code&gt; or no resource bundle name is found, then it will use the nearest &lt;code&gt;ResourceBundle&lt;/code&gt; or resource bundle name inherited from its parent tree.</source>
          <target state="translated">&lt;code&gt;ResourceBundle&lt;/code&gt; 을 찾을 때 로거는 먼저 &lt;a href=&quot;logger#setResourceBundle-java.util.ResourceBundle-&quot;&gt; &lt;code&gt;setResourceBundle&lt;/code&gt; 을&lt;/a&gt; 사용하여 번들이 지정되었는지 여부를 확인한 다음 &lt;a href=&quot;logger#getLogger-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;getLogger&lt;/code&gt; &lt;/a&gt; 팩토리 메소드를 통해 자원 번들 이름이 지정되었는지 여부를 확인합니다 . 어떤 경우 &lt;code&gt;ResourceBundle&lt;/code&gt; 또는 전혀 자원 번들 이름이 발견되지 않는, 그것은 가장 가까운 사용 &lt;code&gt;ResourceBundle&lt;/code&gt; 하거나 부모 트리에서 상속 번들 이름을 자원.</target>
        </trans-unit>
        <trans-unit id="0a8e75474aa9a3fb3f0db3e2785307495315a60e" translate="yes" xml:space="preserve">
          <source>When looking up a time zone name, the &lt;a href=&quot;resourcebundle.control#getCandidateLocales(java.lang.String,java.util.Locale)&quot;&gt;default &lt;code&gt;Locale&lt;/code&gt;search path of &lt;code&gt;ResourceBundle&lt;/code&gt;&lt;/a&gt; derived from the specified &lt;code&gt;locale&lt;/code&gt; is used. (No &lt;a href=&quot;resourcebundle.control#getFallbackLocale(java.lang.String,java.util.Locale)&quot;&gt;fallback &lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt; search is performed.) If a time zone name in any &lt;code&gt;Locale&lt;/code&gt; of the search path, including &lt;a href=&quot;locale#ROOT&quot;&gt;&lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/a&gt;, is found, the name is returned. Otherwise, a string in the &lt;a href=&quot;#NormalizedCustomID&quot;&gt;normalized custom ID format&lt;/a&gt; is returned.</source>
          <target state="translated">시간대 이름을 조회 할 때 지정된 &lt;code&gt;locale&lt;/code&gt; 에서 파생 된 &lt;a href=&quot;resourcebundle.control#getCandidateLocales(java.lang.String,java.util.Locale)&quot;&gt; &lt;code&gt;ResourceBundle&lt;/code&gt; &lt;/a&gt; 의 기본 &lt;code&gt;Locale&lt;/code&gt; 검색 경로 가 사용됩니다. ( &lt;a href=&quot;resourcebundle.control#getFallbackLocale(java.lang.String,java.util.Locale)&quot;&gt;폴백 &lt;/a&gt; &lt;code&gt;Locale&lt;/code&gt; 검색은 수행 되지 않습니다 .) &lt;a href=&quot;locale#ROOT&quot;&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt; 를&lt;/a&gt; 포함하여 검색 경로의 &lt;code&gt;Locale&lt;/code&gt; 에서 시간대 이름 이 발견되면 이름이 리턴됩니다. 그렇지 않으면 &lt;a href=&quot;#NormalizedCustomID&quot;&gt;정규화 된 사용자 지정 ID 형식&lt;/a&gt; 의 문자열 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b9993ef66f72f6a538299eeaaa5c894846a8a38b" translate="yes" xml:space="preserve">
          <source>When looking up a time zone name, the &lt;a href=&quot;resourcebundle.control#getCandidateLocales-java.lang.String-java.util.Locale-&quot;&gt;default &lt;code&gt;Locale&lt;/code&gt; search path of &lt;code&gt;ResourceBundle&lt;/code&gt;&lt;/a&gt; derived from the specified &lt;code&gt;locale&lt;/code&gt; is used. (No &lt;a href=&quot;resourcebundle.control#getFallbackLocale-java.lang.String-java.util.Locale-&quot;&gt;fallback &lt;code&gt;Locale&lt;/code&gt;&lt;/a&gt; search is performed.) If a time zone name in any &lt;code&gt;Locale&lt;/code&gt; of the search path, including &lt;a href=&quot;locale#ROOT&quot;&gt;&lt;code&gt;Locale.ROOT&lt;/code&gt;&lt;/a&gt;, is found, the name is returned. Otherwise, a string in the &lt;a href=&quot;#NormalizedCustomID&quot;&gt;normalized custom ID format&lt;/a&gt; is returned.</source>
          <target state="translated">시간대 이름을 &lt;a href=&quot;resourcebundle.control#getCandidateLocales-java.lang.String-java.util.Locale-&quot;&gt;검색&lt;/a&gt; 할 때 지정된 &lt;code&gt;locale&lt;/code&gt; 에서 파생 된 &lt;code&gt;ResourceBundle&lt;/code&gt; 의 기본 &lt;code&gt;Locale&lt;/code&gt; 검색 경로 가 사용됩니다. &lt;a href=&quot;resourcebundle.control#getFallbackLocale-java.lang.String-java.util.Locale-&quot;&gt;폴백 &lt;/a&gt; &lt;code&gt;Locale&lt;/code&gt; 검색이 수행 되지 않습니다 . &lt;a href=&quot;locale#ROOT&quot;&gt; &lt;code&gt;Locale.ROOT&lt;/code&gt; 를&lt;/a&gt; 포함하여 검색 경로의 &lt;code&gt;Locale&lt;/code&gt; 에서 표준 시간대 이름 이 발견되면 이름이 반환됩니다. 그렇지 않으면 &lt;a href=&quot;#NormalizedCustomID&quot;&gt;정규화 된 사용자 정의 ID 형식&lt;/a&gt; 의 문자열 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="82f732f406e110c12eb9e6c2262a006ddaeaa4e2" translate="yes" xml:space="preserve">
          <source>When mapping resource bundle names to &lt;code&gt;ResourceBundle&lt;/code&gt; objects, the logger will first try to use the Thread's &lt;a href=&quot;../../../../java.base/java/lang/thread#getContextClassLoader()&quot;&gt;context class loader&lt;/a&gt; to map the given resource bundle name to a &lt;code&gt;ResourceBundle&lt;/code&gt;. If the thread context class loader is &lt;code&gt;null&lt;/code&gt;, it will try the &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;system class loader&lt;/a&gt; instead. If the &lt;code&gt;ResourceBundle&lt;/code&gt; is still not found, it will use the class loader of the first caller of the &lt;a href=&quot;#getLogger(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;getLogger&lt;/code&gt;&lt;/a&gt; factory method.</source>
          <target state="translated">리소스 번들 이름을 &lt;code&gt;ResourceBundle&lt;/code&gt; 객체에 매핑 할 때 로거는 먼저 Thread의 &lt;a href=&quot;../../../../java.base/java/lang/thread#getContextClassLoader()&quot;&gt;컨텍스트 클래스 로더&lt;/a&gt; 를 사용하여 주어진 리소스 번들 이름을 &lt;code&gt;ResourceBundle&lt;/code&gt; 에 매핑 하려고합니다 . 스레드 컨텍스트 클래스 로더가 &lt;code&gt;null&lt;/code&gt; 인 경우 대신 &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;시스템 클래스 로더&lt;/a&gt; 를 시도합니다 . 는 IF &lt;code&gt;ResourceBundle&lt;/code&gt; 아직 발견되지 않은, 그것의 첫 번째 호출 측의 클래스 로더를 사용합니다 &lt;a href=&quot;#getLogger(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;getLogger&lt;/code&gt; 의&lt;/a&gt; 팩토리 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="be5fb3253fce93d08c0e8b8dd053dbdf2da012a3" translate="yes" xml:space="preserve">
          <source>When mapping resource bundle names to &lt;code&gt;ResourceBundle&lt;/code&gt; objects, the logger will first try to use the Thread's &lt;a href=&quot;../../lang/thread#getContextClassLoader--&quot;&gt;context class loader&lt;/a&gt; to map the given resource bundle name to a &lt;code&gt;ResourceBundle&lt;/code&gt;. If the thread context class loader is &lt;code&gt;null&lt;/code&gt;, it will try the &lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt;system class loader&lt;/a&gt; instead. If the &lt;code&gt;ResourceBundle&lt;/code&gt; is still not found, it will use the class loader of the first caller of the &lt;a href=&quot;logger#getLogger-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;getLogger&lt;/code&gt;&lt;/a&gt; factory method.</source>
          <target state="translated">자원 번들 이름을 &lt;code&gt;ResourceBundle&lt;/code&gt; 오브젝트에 맵핑 할 때 , 로거는 먼저 스레드의 &lt;a href=&quot;../../lang/thread#getContextClassLoader--&quot;&gt;컨텍스트 클래스 로더&lt;/a&gt; 를 사용하여 제공된 자원 번들 이름을 &lt;code&gt;ResourceBundle&lt;/code&gt; 에 맵핑 하려고 시도합니다 . 스레드 컨텍스트 클래스 로더가 &lt;code&gt;null&lt;/code&gt; 인 경우 &lt;a href=&quot;../../lang/classloader#getSystemClassLoader--&quot;&gt;시스템 클래스 로더를&lt;/a&gt; 대신 시도합니다 . 는 IF &lt;code&gt;ResourceBundle&lt;/code&gt; 아직 발견되지 않은, 그것의 첫 번째 호출 측의 클래스 로더를 사용합니다 &lt;a href=&quot;logger#getLogger-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;getLogger&lt;/code&gt; 의&lt;/a&gt; 팩토리 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="5817dccb8a24dc56e1279e061808065c8af108b0" translate="yes" xml:space="preserve">
          <source>When multiple certificates are available for use in a handshake, the implementation chooses what it considers the &quot;best&quot; certificate chain available, and transmits that to the other side. This method allows the caller to know which certificate chain was actually sent.</source>
          <target state="translated">핸드 셰이크에서 여러 인증서를 사용할 수있는 경우 구현시 사용 가능한 &quot;최상의&quot;인증서 체인을 고려하여 다른쪽으로 전송합니다. 이 메소드를 사용하면 호출자가 실제로 전송 된 인증서 체인을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3c423c16dcc60cd6b3423d29ca5549e570d4cde" translate="yes" xml:space="preserve">
          <source>When multiple certificates are available for use in a handshake, the implementation chooses what it considers the &quot;best&quot; certificate chain available, and transmits that to the other side. This method allows the caller to know which certificate chain was actually used.</source>
          <target state="translated">핸드 셰이크에서 여러 인증서를 사용할 수있는 경우 구현시 사용 가능한 &quot;최상의&quot;인증서 체인을 고려하여 다른쪽으로 전송합니다. 이 메소드를 사용하면 호출자가 실제로 사용 된 인증서 체인을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e850be999ec8886286adca7b7397c7e98dbc4504" translate="yes" xml:space="preserve">
          <source>When multiple mouse buttons are pressed, each press, release, and click results in a separate event.</source>
          <target state="translated">여러 개의 마우스 버튼을 눌렀을 때 눌렀다 떼고 클릭 할 때마다 별도의 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b583a6caec2f5a60ad8b2a97fc56411186997e09" translate="yes" xml:space="preserve">
          <source>When multiple threads attempt updates, map operations and the remapping function may be called multiple times.</source>
          <target state="translated">여러 스레드가 업데이트를 시도 할 때 매핑 작업과 다시 매핑 기능이 여러 번 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="421a63f8d081ab15313773fe4ca2f494ee90642e" translate="yes" xml:space="preserve">
          <source>When names are tested for equality, attribute types, both binary and string values, are case-insensitive. String values with different but equivalent usage of quoting, escaping, or UTF8-hex-encoding are considered equal. The order of components in multi-valued RDNs (such as &quot;ou=Sales+cn=Bob&quot;) is not significant.</source>
          <target state="translated">이름이 동일한 지 테스트 할 때 이진 및 문자열 값 모두의 속성 유형은 대소 문자를 구분합니다. 인용, 이스케이프 또는 UTF8- 헥스 인코딩의 사용법은 다르지만 동등한 문자열 값은 동일한 것으로 간주됩니다. 다중 값 RDN의 구성 요소 순서 (예 : &quot;ou = Sales + cn = Bob&quot;)는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6883b8562675f0154aa3d30123f4e8a85ff6259b" translate="yes" xml:space="preserve">
          <source>When not already closed, the &lt;code&gt;close&lt;/code&gt; method of &lt;code&gt;
 FilterOutputStream&lt;/code&gt; calls its &lt;code&gt;flush&lt;/code&gt; method, and then calls the &lt;code&gt;close&lt;/code&gt; method of its underlying output stream.</source>
          <target state="translated">아직 닫히지 않은 경우 &lt;code&gt; FilterOutputStream&lt;/code&gt; 의 &lt;code&gt;close&lt;/code&gt; 메서드 는 &lt;code&gt;flush&lt;/code&gt; 메서드를 호출 한 다음 기본 출력 스트림 의 &lt;code&gt;close&lt;/code&gt; 메서드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4a545d4bb404c11d8dba04dd5da469b88f7c0cfb" translate="yes" xml:space="preserve">
          <source>When not using the try-with-resources construct, then directory stream's &lt;code&gt;close&lt;/code&gt; method should be invoked after iteration is completed so as to free any resources held for the open directory.</source>
          <target state="translated">try-with-resources 구문을 사용하지 않는 경우, 반복이 완료된 후 디렉토리 스트림의 &lt;code&gt;close&lt;/code&gt; 메소드를 호출하여 열린 디렉토리에 보유 된 모든 자원을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0eff43acb661f5302995be06d4dfab4083a1196" translate="yes" xml:space="preserve">
          <source>When one of the &lt;code&gt;showXxxDialog&lt;/code&gt; methods returns an integer, the possible values are:</source>
          <target state="translated">&lt;code&gt;showXxxDialog&lt;/code&gt; 메서드 중 하나가 정수를 반환하는 경우 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="08da4f2fc44fc2ee4201a796e38c5af9ee0a82e4" translate="yes" xml:space="preserve">
          <source>When one of those methods is invoked, its behavior is to delegate to a corresponding method on an instance of this class. The details of how each method delegates to the provider instance is described in the documentation for each particular method. See the documentation for &lt;a href=&quot;rmiclassloader&quot;&gt;&lt;code&gt;RMIClassLoader&lt;/code&gt;&lt;/a&gt; for a description of how a provider instance is chosen.</source>
          <target state="translated">이러한 메서드 중 하나가 호출 될 때 동작은이 클래스의 인스턴스에있는 해당 메서드에 위임하는 것입니다. 각 메서드가 공급자 인스턴스에 위임하는 방법에 대한 자세한 내용은 각 특정 메서드에 대한 설명서에 설명되어 있습니다. 제공자 인스턴스가 선택되는 방법에 대한 설명은 &lt;a href=&quot;rmiclassloader&quot;&gt; &lt;code&gt;RMIClassLoader&lt;/code&gt; 에&lt;/a&gt; 대한 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61d8ce27b955b14a389038bf014cbe85cc67752c" translate="yes" xml:space="preserve">
          <source>When one sends a message to a multicast group, &lt;b&gt;all&lt;/b&gt; subscribing recipients to that host and port receive the message (within the time-to-live range of the packet, see below). The socket needn't be a member of the multicast group to send messages to it.</source>
          <target state="translated">멀티 캐스트 그룹에 메시지를 보내면 해당 호스트 및 포트에 가입 한 &lt;b&gt;모든&lt;/b&gt; 받는 사람이 메시지를받습니다 (패킷의 유효 시간 범위 내에서 아래 참조). 소켓은 메시지를 보내기 위해 멀티 캐스트 그룹의 구성원 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c665e1ac4c57d3ccf2437d891eb0ae431f77c0f" translate="yes" xml:space="preserve">
          <source>When only one part is given, the value is stored directly in the network address without any byte rearrangement.</source>
          <target state="translated">한 부분 만 제공하면 값이 바이트 재 배열없이 네트워크 주소에 직접 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="1875b9065ed910ca6ec4ee04408f7621f55c467c" translate="yes" xml:space="preserve">
          <source>When opening an existing file, the file is first truncated to a size of 0 bytes. This option is ignored when the file is opened only for reading.</source>
          <target state="translated">기존 파일을 열 때 파일은 먼저 0 바이트 크기로 잘립니다. 읽기 전용으로 파일을 열면이 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="55ad5bbbd836b22033fccd6daca4b9d44a123e8e" translate="yes" xml:space="preserve">
          <source>When output streaming is enabled, authentication and redirection cannot be handled automatically. A &lt;a href=&quot;httpretryexception&quot;&gt;HttpRetryException&lt;/a&gt; will be thrown when reading the response if authentication or redirection are required. This exception can be queried for the details of the error.</source>
          <target state="translated">출력 스트리밍이 활성화되면 인증 및 리디렉션을 자동으로 처리 할 수 ​​없습니다. &lt;a href=&quot;httpretryexception&quot;&gt;HttpRetryException는&lt;/a&gt; 인증 또는 리디렉션이 필요한 경우 응답을 읽을 때 발생합니다. 오류에 대한 자세한 내용은이 예외를 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="0a1daf55edfb1251014f98d686349fc2cf29836a" translate="yes" xml:space="preserve">
          <source>When output streaming is enabled, authentication and redirection cannot be handled automatically. A HttpRetryException will be thrown when reading the response if authentication or redirection are required. This exception can be queried for the details of the error.</source>
          <target state="translated">출력 스트리밍이 활성화되면 인증 및 리디렉션을 자동으로 처리 할 수 ​​없습니다. 인증 또는 리디렉션이 필요한 경우 응답을 읽을 때 HttpRetryException이 발생합니다. 오류에 대한 자세한 내용은이 예외를 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="70789a8a89c99dae4c53ce0b0096f13062e5be96" translate="yes" xml:space="preserve">
          <source>When output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into zip file entry's &lt;code&gt;date and time fields&lt;/code&gt; in &lt;code&gt;standard
 MS-DOS date and time format&lt;/code&gt;), and the extended timestamp fields in &lt;code&gt;optional extra data&lt;/code&gt; in UTC time.</source>
          <target state="translated">ZIP 파일 또는 ZIP 파일 형식의 출력 스트림으로 출력 할 때이 방법으로 설정 한 마지막 수정 시간 은 &lt;code&gt;standard MS-DOS date and time format&lt;/code&gt; 으로 zip 파일 항목의 &lt;code&gt;date and time fields&lt;/code&gt; 에 저장되며 확장 된 타임 스탬프 필드는 &lt;code&gt;optional extra data&lt;/code&gt; UTC 시간의 데이터 .</target>
        </trans-unit>
        <trans-unit id="fc606ceb2f424146aad8bdb4fde4bd8dd7c5761f" translate="yes" xml:space="preserve">
          <source>When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt; method. This should ensure that the first element returned by the stream is the same resource that the &lt;code&gt;getResource(String)&lt;/code&gt; method would return.</source>
          <target state="translated">이 메서드를 재정의 할 때 구현시 모든 위임이 &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt; 메서드 와 일치하는지 확인하는 것이 좋습니다 . 이것은 스트림이 반환하는 첫 번째 요소가 &lt;code&gt;getResource(String)&lt;/code&gt; 메서드가 반환 하는 것과 동일한 리소스인지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="33b67f1448d9e46c92a5dd8ca3e0c7d32d1730ae" translate="yes" xml:space="preserve">
          <source>When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;classloader#getResource-java.lang.String-&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt; method. This should ensure that the first element returned by the Enumeration's &lt;code&gt;nextElement&lt;/code&gt; method is the same resource that the &lt;code&gt;getResource(String)&lt;/code&gt; method would return.</source>
          <target state="translated">이 메소드를 오버라이드 (override) 할 때는, 구현이 모든 위임이 &lt;a href=&quot;classloader#getResource-java.lang.String-&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt; 메소드 와 일치하는 것을 보증 할 것을 권장합니다 . 이렇게하면 Enumeration의 &lt;code&gt;nextElement&lt;/code&gt; 메소드가 리턴 한 첫 번째 요소 가 &lt;code&gt;getResource(String)&lt;/code&gt; 메소드가 리턴 하는 동일한 자원인지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="059fdccbaa1b79359a5fe3e6137c458d9b8b9713" translate="yes" xml:space="preserve">
          <source>When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;classloader#getResources-java.lang.String-&quot;&gt;&lt;code&gt;getResources(String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드를 오버라이드 (override) 할 때는, 구현이 모든 위임이 &lt;a href=&quot;classloader#getResources-java.lang.String-&quot;&gt; &lt;code&gt;getResources(String)&lt;/code&gt; &lt;/a&gt; 메소드 와 일치하는 것을 보증 할 것을 권장합니다 .</target>
        </trans-unit>
        <trans-unit id="bc58d21adb8af8af625121a5b2b080c75e23b139" translate="yes" xml:space="preserve">
          <source>When parsing in lenient mode, only the hours are mandatory - minutes and seconds are optional. The colons are required if the specified pattern contains a colon. If the specified pattern is &quot;+HH&quot;, the presence of colons is determined by whether the character after the hour digits is a colon or not. If the offset cannot be parsed then an exception is thrown unless the section of the formatter is optional.</source>
          <target state="translated">관대 모드로 구문 분석 할 때 시간 만 필수이며 분과 초는 선택 사항입니다. 지정된 패턴에 콜론이 포함 된 경우 콜론이 필요합니다. 지정된 패턴이 &quot;+ HH&quot;이면 콜론의 존재 여부는 시간 숫자 뒤의 문자가 콜론인지 여부에 따라 결정됩니다. 오프셋을 구문 분석 할 수없는 경우 포맷터의 섹션이 선택 사항이 아닌 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bcac0e3e99ade4d27a61abe4610e8ad6c3973f0" translate="yes" xml:space="preserve">
          <source>When parsing in strict mode, the input must contain the mandatory and optional elements are defined by the specified pattern. If the offset cannot be parsed then an exception is thrown unless the section of the formatter is optional.</source>
          <target state="translated">엄격 모드에서 구문 분석 할 때 입력에는 필수 및 선택적 요소가 지정된 패턴으로 정의되어 있어야합니다. 오프셋을 구문 분석 할 수없는 경우 포맷터의 섹션이 선택 사항이 아닌 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="631f29a71edc58dfc93bdc965a349f3c402f1d37" translate="yes" xml:space="preserve">
          <source>When parsing in strict mode, the number of parsed digits must be between the minimum and maximum width. In strict mode, if the minimum and maximum widths are equal and there is no decimal point then the parser will participate in adjacent value parsing, see &lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt;&lt;code&gt;appendValue(java.time.temporal.TemporalField,int)&lt;/code&gt;&lt;/a&gt;. When parsing in lenient mode, the minimum width is considered to be zero and the maximum is nine.</source>
          <target state="translated">엄격 모드에서 구문 분석 할 때 구문 분석 된 숫자의 수는 최소 너비와 최대 너비 사이 여야합니다. Strict 모드에서 최소 및 최대 너비가 같고 소수점이 없으면 파서가 인접 값 구문 분석에 참여 합니다. &lt;a href=&quot;#appendValue(java.time.temporal.TemporalField,int)&quot;&gt; &lt;code&gt;appendValue(java.time.temporal.TemporalField,int)&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 관대 모드에서 구문 분석 할 때 최소 너비는 0으로 간주되고 최대 너비는 9입니다.</target>
        </trans-unit>
        <trans-unit id="88186acbb81a8c14eb592e644ed27a9e055dc197" translate="yes" xml:space="preserve">
          <source>When parsing in strict mode, the number of parsed digits must be between the minimum and maximum width. When parsing in lenient mode, the minimum width is considered to be zero and the maximum is nine.</source>
          <target state="translated">엄격 모드에서 구문 분석 할 때 구문 분석 된 숫자의 수는 최소 너비와 최대 너비 사이 여야합니다. 무의식 모드에서 구문 분석 할 때 최소 너비는 0으로 간주되고 최대는 9입니다.</target>
        </trans-unit>
        <trans-unit id="d50f0289d83049487a7e415ef71230bcec841f7c" translate="yes" xml:space="preserve">
          <source>When parsing in strict mode, the number of parsed digits must match the fractional digits. When parsing in lenient mode, any number of fractional digits from zero to nine are accepted.</source>
          <target state="translated">엄격 모드에서 구문 분석 할 때 구문 분석 된 숫자의 숫자는 소수 자릿수와 일치해야합니다. 무의식 모드에서 구문 분석 할 때 0에서 9까지의 소수 자릿수가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="398b9ccde24d723bc63ead376818c485f7b9a32f" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated from 0 to 1 in strict and smart mode. In lenient mode the value is not validated. It is combined with &lt;code&gt;HOUR_OF_AMPM&lt;/code&gt; to form &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; by multiplying the {AMPM_OF_DAY} value by 12.</source>
          <target state="translated">이 필드를 구문 분석 할 때이 값은 다음과 동일하게 작동합니다. 엄격하고 스마트 한 모드에서 값의 유효성은 0에서 1까지입니다. 무의미한 모드에서는 값의 유효성이 검사되지 않습니다. {AMPM_OF_DAY} 값에 12를 곱하여 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 과 결합하여 &lt;code&gt;HOUR_OF_AMPM&lt;/code&gt; 를 형성 합니다.</target>
        </trans-unit>
        <trans-unit id="fc167eb2f61a597fa4fcdf11893ccfde6bdc0602" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated from 0 to 11 in strict and smart mode. In lenient mode the value is not validated. It is combined with &lt;code&gt;AMPM_OF_DAY&lt;/code&gt; to form &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; by multiplying the {AMPM_OF_DAY} value by 12.</source>
          <target state="translated">이 필드를 구문 분석 할 때 다음과 동일하게 작동합니다. 엄격하고 스마트 한 모드에서 값은 0에서 11까지 유효합니다. 무의미한 모드에서는 값의 유효성이 검사되지 않습니다. {AMPM_OF_DAY} 값에 12를 곱하여 &lt;code&gt;AMPM_OF_DAY&lt;/code&gt; 와 결합하여 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 를 형성 합니다.</target>
        </trans-unit>
        <trans-unit id="957785487bc5a171742676f4c57e468f23bbf945" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated from 1 to 12 in strict mode and from 0 to 12 in smart mode. In lenient mode the value is not validated. The field is converted to an &lt;code&gt;HOUR_OF_AMPM&lt;/code&gt; with the same value, unless the value is 12, in which case it is converted to 0.</source>
          <target state="translated">이 필드를 구문 분석 할 때이 값은 다음과 같습니다. 엄격 모드에서는 1에서 12까지, 스마트 모드에서는 0에서 12까지 값이 검증됩니다. 무의미한 모드에서는 값의 유효성이 검사되지 않습니다. 값이 12가 아닌 경우 필드는 동일한 값 을 가진 &lt;code&gt;HOUR_OF_AMPM&lt;/code&gt; 으로 변환 되며이 경우 0으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="392153078b1342cc9b804c5665b0c975ca3bc7c5" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated from 1 to 24 in strict mode and from 0 to 24 in smart mode. In lenient mode the value is not validated. The field is converted to an &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; with the same value, unless the value is 24, in which case it is converted to 0.</source>
          <target state="translated">이 필드를 구문 분석 할 때이 값은 다음과 같습니다. 엄격 모드에서는 1에서 24까지, 스마트 모드에서는 0에서 24까지 값이 검증됩니다. 무의미한 모드에서는 값의 유효성이 검사되지 않습니다. 값이 24가 아닌 경우 필드는 동일한 값으로 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 로 변환 되며이 경우 0으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="99eb9e50057d1c711aa0384492b14a1cc96c9df7" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode.</source>
          <target state="translated">이 필드를 구문 분석 할 때 다음과 동일하게 작동합니다. 값은 엄격하고 스마트 모드에서는 유효하지만 무성한 모드에서는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fc9716f73232473fc7fb6cbb3857d50c0ce6738" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is combined with &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; and &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; to produce a &lt;code&gt;LocalTime&lt;/code&gt;. In lenient mode, any excess days are added to the parsed date, or made available via &lt;a href=&quot;../format/datetimeformatter#parsedExcessDays()&quot;&gt;&lt;code&gt;DateTimeFormatter.parsedExcessDays()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 필드를 구문 분석 할 때 다음과 동일하게 작동합니다. 값은 엄격 및 스마트 모드에서 유효성이 검증되지만 관대 모드에서는 검증되지 않습니다. 이 필드는 &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; , &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; 및 &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; 와 결합되어 &lt;code&gt;LocalTime&lt;/code&gt; 을 생성합니다 . 관대 모드에서는 초과 날짜가 구문 분석 된 날짜에 추가되거나 &lt;a href=&quot;../format/datetimeformatter#parsedExcessDays()&quot;&gt; &lt;code&gt;DateTimeFormatter.parsedExcessDays()&lt;/code&gt; &lt;/a&gt; 를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ddaf4c446a794e052910439758bc7ef035eeef6" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is combined with &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; and &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; to produce a &lt;code&gt;LocalTime&lt;/code&gt;. In lenient mode, any excess days are added to the parsed date, or made available via &lt;a href=&quot;../format/datetimeformatter#parsedExcessDays--&quot;&gt;&lt;code&gt;DateTimeFormatter.parsedExcessDays()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 필드를 구문 분석 할 때 다음과 동일하게 작동합니다. 값은 엄격하고 스마트 모드에서는 유효하지만 무성한 모드에서는 유효하지 않습니다. 이 필드는 &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; , &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; 및 &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; 와 결합되어 &lt;code&gt;LocalTime&lt;/code&gt; 을 생성합니다 . 무자비한 모드에서는 초과 날짜가 구문 분석 된 날짜에 추가되거나 &lt;a href=&quot;../format/datetimeformatter#parsedExcessDays--&quot;&gt; &lt;code&gt;DateTimeFormatter.parsedExcessDays()&lt;/code&gt; &lt;/a&gt; 를 통해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ae9bc249b42914740d59028697394c29456af8c" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is resolved in combination with &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt; to produce &lt;code&gt;NANO_OF_SECOND&lt;/code&gt;.</source>
          <target state="translated">이 필드를 구문 분석 할 때 다음과 동일하게 작동합니다. 값은 엄격하고 스마트 모드에서는 유효하지만 무성한 모드에서는 유효하지 않습니다. 이 필드는 &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt; 를 생성하기 위해 &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; 와 함께 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="a924c762f617440d33adf98834b01ed6f029b945" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is resolved in combination with &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; and &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt;.</source>
          <target state="translated">이 필드를 구문 분석 할 때 다음과 동일하게 작동합니다. 값은 엄격하고 스마트 모드에서는 유효하지만 무성한 모드에서는 유효하지 않습니다. 이 필드는 &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; 및 &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt; 와 함께 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8dbf53e5aefb77318b4486598a6313d9b941472" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The field is resolved in combination with &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; to produce &lt;code&gt;NANO_OF_SECOND&lt;/code&gt;.</source>
          <target state="translated">이 필드를 구문 분석 할 때 다음과 동일하게 작동합니다. 값은 엄격하고 스마트 모드에서는 유효하지만 무성한 모드에서는 유효하지 않습니다. 이 필드는 &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; 와 함께 해결되어 NANO_OF_SECOND 를 생성 &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c800d57db7922ab39c14b13ae86f803dc109a26b" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt;, &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">이 필드를 구문 분석 할 때 다음과 동일하게 작동합니다. 값은 엄격하고 스마트 모드에서는 유효하지만 무성한 모드에서는 유효하지 않습니다. 값은 &lt;code&gt;MICRO_OF_SECOND&lt;/code&gt; , &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; , &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; 및 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 필드 를 형성 하도록 분할 됩니다.</target>
        </trans-unit>
        <trans-unit id="c294e00d68fa9137c919614e2026adac17298586" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt;, &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">이 필드를 구문 분석 할 때 다음과 동일하게 작동합니다. 값은 엄격하고 스마트 모드에서는 유효하지만 무성한 모드에서는 유효하지 않습니다. 값은 &lt;code&gt;MILLI_OF_SECOND&lt;/code&gt; , &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; , &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; 및 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 필드 를 형성 하도록 분할 됩니다.</target>
        </trans-unit>
        <trans-unit id="f645cbf7fae3ea37f1aeb723d42fd638100f86e8" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">이 필드를 구문 분석 할 때 다음과 동일하게 작동합니다. 값은 엄격하고 스마트 모드에서는 유효하지만 무성한 모드에서는 유효하지 않습니다. 값은 &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; 및 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 필드로 분할 됩니다.</target>
        </trans-unit>
        <trans-unit id="1be57e4bffee0d932e9b78c3b2c86a25070821da" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;NANO_OF_SECOND&lt;/code&gt;, &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt;, &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">이 필드를 구문 분석 할 때 다음과 동일하게 작동합니다. 값은 엄격하고 스마트 모드에서는 유효하지만 무성한 모드에서는 유효하지 않습니다. 값은 &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; , &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; , &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; 및 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 필드 를 형성 하도록 분할 됩니다.</target>
        </trans-unit>
        <trans-unit id="375544438a835cc62e84a73073301cc45d0d9edd" translate="yes" xml:space="preserve">
          <source>When parsing this field it behaves equivalent to the following: The value is validated in strict and smart mode but not in lenient mode. The value is split to form &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt;, &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; and &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; fields.</source>
          <target state="translated">이 필드를 구문 분석 할 때 다음과 동일하게 작동합니다. 값은 엄격하고 스마트 모드에서는 유효하지만 무성한 모드에서는 유효하지 않습니다. 이 값은 &lt;code&gt;SECOND_OF_MINUTE&lt;/code&gt; , &lt;code&gt;MINUTE_OF_HOUR&lt;/code&gt; 및 &lt;code&gt;HOUR_OF_DAY&lt;/code&gt; 필드 로 분할 됩니다.</target>
        </trans-unit>
        <trans-unit id="4cd8446097afcf131ca40bba9bd5d77aaa9438f7" translate="yes" xml:space="preserve">
          <source>When parsing, there are two distinct cases to consider. If a chronology has been parsed directly from the text, perhaps because &lt;a href=&quot;datetimeformatterbuilder#appendChronologyId()&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder.appendChronologyId()&lt;/code&gt;&lt;/a&gt; was used, then this override chronology has no effect. If no zone has been parsed, then this override chronology will be used to interpret the &lt;code&gt;ChronoField&lt;/code&gt; values into a date according to the date resolving rules of the chronology.</source>
          <target state="translated">파싱 ​​할 때 고려해야 할 두 가지 사례가 있습니다. &lt;a href=&quot;datetimeformatterbuilder#appendChronologyId()&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder.appendChronologyId()&lt;/code&gt; &lt;/a&gt; 가 사용 되었기 때문에 연대기가 텍스트에서 직접 구문 분석 된 경우이 재정의 연대기가 효과가 없습니다. 영역이 구문 분석되지 않은 경우이 재정의 연대기는 연대의 규칙을 확인하는 날짜에 따라 &lt;code&gt;ChronoField&lt;/code&gt; 값을 날짜로 해석하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="f28daa7170bb1fcc870df5a101d2c5b9ccdbc619" translate="yes" xml:space="preserve">
          <source>When parsing, there are two distinct cases to consider. If a chronology has been parsed directly from the text, perhaps because &lt;a href=&quot;datetimeformatterbuilder#appendChronologyId--&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder.appendChronologyId()&lt;/code&gt;&lt;/a&gt; was used, then this override chronology has no effect. If no zone has been parsed, then this override chronology will be used to interpret the &lt;code&gt;ChronoField&lt;/code&gt; values into a date according to the date resolving rules of the chronology.</source>
          <target state="translated">구문 분석 할 때 고려해야 할 두 가지 경우가 있습니다. &lt;a href=&quot;datetimeformatterbuilder#appendChronologyId--&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder.appendChronologyId()&lt;/code&gt; &lt;/a&gt; 가 사용 되어 연대기를 텍스트에서 직접 구문 분석 한 경우이 재정의 연대기를 적용 할 수 없습니다. 영역을 구문 분석하지 않은 경우이 재정의 연대기를 사용하여 연대기 의 날짜 해결 규칙에 따라 &lt;code&gt;ChronoField&lt;/code&gt; 값을 날짜로 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="be3406dfdd119662bd0b600c9668e269a43af897" translate="yes" xml:space="preserve">
          <source>When parsing, there are two distinct cases to consider. If a zone has been parsed directly from the text, perhaps because &lt;a href=&quot;datetimeformatterbuilder#appendZoneId()&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder.appendZoneId()&lt;/code&gt;&lt;/a&gt; was used, then this override zone has no effect. If no zone has been parsed, then this override zone will be included in the result of the parse where it can be used to build instants and date-times.</source>
          <target state="translated">파싱 ​​할 때 고려해야 할 두 가지 사례가 있습니다. 영역이 텍스트에서 직접 구문 분석 된 경우 아마도 &lt;a href=&quot;datetimeformatterbuilder#appendZoneId()&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder.appendZoneId()&lt;/code&gt; &lt;/a&gt; 가 사용 되었기 때문에이 재정의 영역은 효과가 없습니다. 영역이 구문 분석되지 않은 경우이 재정의 영역이 구문 분석 결과에 포함되어 인스턴트 및 날짜-시간을 빌드하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a965e09e870a4e87e4a218aed3653bd2efbce188" translate="yes" xml:space="preserve">
          <source>When parsing, there are two distinct cases to consider. If a zone has been parsed directly from the text, perhaps because &lt;a href=&quot;datetimeformatterbuilder#appendZoneId--&quot;&gt;&lt;code&gt;DateTimeFormatterBuilder.appendZoneId()&lt;/code&gt;&lt;/a&gt; was used, then this override zone has no effect. If no zone has been parsed, then this override zone will be included in the result of the parse where it can be used to build instants and date-times.</source>
          <target state="translated">구문 분석 할 때 고려해야 할 두 가지 경우가 있습니다. &lt;a href=&quot;datetimeformatterbuilder#appendZoneId--&quot;&gt; &lt;code&gt;DateTimeFormatterBuilder.appendZoneId()&lt;/code&gt; &lt;/a&gt; 가 사용 되었기 때문에 텍스트에서 영역을 직접 구문 분석 한 경우이 재정의 영역이 적용되지 않습니다. 영역을 구문 분석하지 않은 경우이 재정의 영역은 구문 분석 결과에 포함되어 인스턴트 및 날짜-시간을 작성하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cf15c2cadbf1d2f9101df44d9400a393f3cd777" translate="yes" xml:space="preserve">
          <source>When passing information to a Java subprocess, &lt;a href=&quot;#EnvironmentVSSystemProperties&quot;&gt;system properties&lt;/a&gt; are generally preferred over environment variables.</source>
          <target state="translated">정보를 Java 서브 프로세스로 전달할 때 일반적으로 환경 변수보다 &lt;a href=&quot;#EnvironmentVSSystemProperties&quot;&gt;시스템 특성&lt;/a&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="678a637edd80c217c54e61b9e25c8439ebfa7bf7" translate="yes" xml:space="preserve">
          <source>When passing information to a Java subprocess, &lt;a href=&quot;system#EnvironmentVSSystemProperties&quot;&gt;system properties&lt;/a&gt; are generally preferred over environment variables.</source>
          <target state="translated">정보를 Java 서브 프로세스로 전달할 때 일반적으로 환경 변수보다 &lt;a href=&quot;system#EnvironmentVSSystemProperties&quot;&gt;시스템 특성&lt;/a&gt; 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="468a7461c40962d54c04cec0adab0486b4f75193" translate="yes" xml:space="preserve">
          <source>When pending counts can be precomputed, they can be established in the constructor:</source>
          <target state="translated">보류중인 카운트를 미리 계산할 수있는 경우 생성자에서 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee906d2367a93c8434f7349879af51a79dadb0c5" translate="yes" xml:space="preserve">
          <source>When possible this simply changes the name of the given node, otherwise this creates a new node with the specified name and replaces the existing node with the new node as described below.</source>
          <target state="translated">가능한 경우 단순히 주어진 노드의 이름을 변경합니다. 그렇지 않으면 지정된 이름으로 새 노드를 만들고 아래 설명 된대로 기존 노드를 새 노드로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="1d9df05f42f191fd30f4013d3bc48c1dc951d2b7" translate="yes" xml:space="preserve">
          <source>When processing logging output, if a Handler encounters problems then rather than throwing an Exception back to the issuer of the logging call (who is unlikely to be interested) the Handler should call its associated ErrorManager.</source>
          <target state="translated">로깅 출력을 처리 할 때 처리기에 문제가 발생하면 로깅 호출의 발행자 (관심이없는 사람)에게 예외를 다시 발생시키는 대신 처리기는 연결된 ErrorManager를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e179726ee6a6f7644de1db6d67bff96f348bf5e" translate="yes" xml:space="preserve">
          <source>When providing implementations for the new methods in the subclass, use this newly defined method to get the initial context.</source>
          <target state="translated">서브 클래스에서 새 메소드에 대한 구현을 제공 할 때 새로 정의 된이 메소드를 사용하여 초기 컨텍스트를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="ac5bba685209949c2cc3f67e3cab5d31b729dde6" translate="yes" xml:space="preserve">
          <source>When reading a document if a CRLF is encountered a property with this name is added and the value will be &quot;\r\n&quot;.</source>
          <target state="translated">문서를 읽을 때 CRLF가 발견되면이 이름의 속성이 추가되고 값은 &quot;\ r \ n&quot;이됩니다.</target>
        </trans-unit>
        <trans-unit id="093663f9827304bad79b038495f5092c12dadca2" translate="yes" xml:space="preserve">
          <source>When reading a provider-configuration file, or loading or instantiating a provider class named in a provider-configuration file, then &lt;code&gt;
 ServiceConfigurationError&lt;/code&gt; can be thrown for the following reasons:</source>
          <target state="translated">공급자 구성 파일을 읽거나 공급자 구성 파일에 이름이 지정된 공급자 클래스를로드 또는 인스턴스화 할 때 다음과 같은 이유로 &lt;code&gt; ServiceConfigurationError&lt;/code&gt; 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff2175fd5a0c9824ca3682906ca8e8c785a2e2f5" translate="yes" xml:space="preserve">
          <source>When reading an image, its per-stream and per-image metadata is made available as an &lt;code&gt;IIOMetadata&lt;/code&gt; object. The internals of this object are specific to the plug-in that created it. Its contents may be accessed in the form of an XML &lt;code&gt;Document&lt;/code&gt;, which is implemented as a tree of &lt;code&gt;IIOMetadataNode&lt;/code&gt; objects.</source>
          <target state="translated">이미지를 읽을 때 스트림 별 및 이미지 당 메타 데이터를 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체 로 사용할 수 있습니다 . 이 객체의 내부는 해당 객체를 생성 한 플러그인에 따라 다릅니다. 컨텐츠는 &lt;code&gt;IIOMetadataNode&lt;/code&gt; 객체 의 트리로 구현되는 XML &lt;code&gt;Document&lt;/code&gt; 형식으로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c064a445936071cf19ecbcb598a24cd0f5fcf1e9" translate="yes" xml:space="preserve">
          <source>When reading from a standard &lt;code&gt;InputStream&lt;/code&gt;, it may be necessary to save previously read information in a cache since the underlying stream does not allow data to be re-read. Similarly, when writing to a standard &lt;code&gt;OutputStream&lt;/code&gt;, a cache may be used to allow a previously written value to be changed before flushing it to the final destination.</source>
          <target state="translated">표준 &lt;code&gt;InputStream&lt;/code&gt; 에서 읽을 때는 기본 스트림에서 데이터를 다시 읽을 수 없으므로 이전에 읽은 정보를 캐시에 저장해야 할 수도 있습니다. 마찬가지로, 표준 &lt;code&gt;OutputStream&lt;/code&gt; 에 쓸 때 , 최종 목적지로 플러시하기 전에 이전에 쓴 값을 변경할 수 있도록 캐시를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="967c7f2fd4e6ef5e74644bcb7e0d2a8f5a951bbd" translate="yes" xml:space="preserve">
          <source>When reading, a &lt;code&gt;TIFFDirectory&lt;/code&gt; may be created by passing the value returned by &lt;a href=&quot;../../imagereader#getImageMetadata(int)&quot;&gt;&lt;code&gt;ImageReader.getImageMetadata()&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;#createFromMetadata(javax.imageio.metadata.IIOMetadata)&quot;&gt;&lt;code&gt;createFromMetadata()&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;tifffield&quot;&gt;&lt;code&gt;TIFFField&lt;/code&gt;&lt;/a&gt;s in the directory may then be obtained using the accessor methods provided in this class.</source>
          <target state="translated">읽을 때 &lt;code&gt;TIFFDirectory&lt;/code&gt; 는 &lt;a href=&quot;../../imagereader#getImageMetadata(int)&quot;&gt; &lt;code&gt;ImageReader.getImageMetadata()&lt;/code&gt; &lt;/a&gt; 가 반환 한 값 을 &lt;a href=&quot;#createFromMetadata(javax.imageio.metadata.IIOMetadata)&quot;&gt; &lt;code&gt;createFromMetadata()&lt;/code&gt; &lt;/a&gt; 에 전달하여 만들 수 있습니다 . 디렉토리 의 &lt;a href=&quot;tifffield&quot;&gt; &lt;code&gt;TIFFField&lt;/code&gt; &lt;/a&gt; 는이 클래스에 제공된 접근 자 메서드를 사용하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d63913965696a9f9c40e306e81ce84323b71ddc" translate="yes" xml:space="preserve">
          <source>When reading, if the layout of the destination has been set using this method, each call to an &lt;code&gt;ImageReader&lt;/code&gt;&lt;code&gt;read&lt;/code&gt; method will return a new &lt;code&gt;BufferedImage&lt;/code&gt; using the format specified by the supplied type specifier. As a side effect, any destination &lt;code&gt;BufferedImage&lt;/code&gt; set by &lt;code&gt;ImageReadParam.setDestination(BufferedImage)&lt;/code&gt; will no longer be set as the destination. In other words, this method may be thought of as calling &lt;code&gt;setDestination((BufferedImage)null)&lt;/code&gt;.</source>
          <target state="translated">읽을 때 대상의 레이아웃이이 메소드를 사용하여 설정된 경우 &lt;code&gt;ImageReader&lt;/code&gt; &lt;code&gt;read&lt;/code&gt; 메소드를 호출 할 때마다 제공된 유형 지정자가 지정한 형식을 사용하여 새 &lt;code&gt;BufferedImage&lt;/code&gt; 를 리턴 합니다. 부작용 으로 &lt;code&gt;ImageReadParam.setDestination(BufferedImage)&lt;/code&gt; 의해 설정된 대상 &lt;code&gt;BufferedImage&lt;/code&gt; 는 더 이상 대상으로 설정되지 않습니다. 즉,이 메소드는 &lt;code&gt;setDestination((BufferedImage)null)&lt;/code&gt; 을 호출하는 것으로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5b68a7995942b34e6fb81c415ca17f384da8a72" translate="yes" xml:space="preserve">
          <source>When reading, the region to be written within the destination &lt;code&gt;BufferedImage&lt;/code&gt; will start at this offset and have a width and height determined by the source region of interest, the subsampling parameters, and the destination bounds.</source>
          <target state="translated">읽을 때 대상 &lt;code&gt;BufferedImage&lt;/code&gt; 내에 작성 될 영역 은이 오프셋에서 시작하며 관심있는 소스 영역, 서브 샘플링 매개 변수 및 대상 경계에 의해 결정된 너비와 높이를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="948c72e84f23a6d80190a196cfc3c27ca22ecf53" translate="yes" xml:space="preserve">
          <source>When replacing a leaf this will attempt to make sure there is a newline present if one is needed. This may result in an additional element being inserted. Consider, if you were to replace a character element that contained a newline with &amp;lt;img&amp;gt; this would create two elements, one for the image, and one for the newline.</source>
          <target state="translated">리프를 교체 할 때 필요한 경우 개행이 있는지 확인합니다. 이로 인해 추가 요소가 삽입 될 수 있습니다. 줄 바꿈이 포함 된 문자 요소를 &amp;lt;img&amp;gt;로 바꾸면 이미지와 줄 바꿈에 각각 하나씩 두 개의 요소가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e4073d7c2224019b5107064c858d7e912ce2c1aa" translate="yes" xml:space="preserve">
          <source>When requested by setting the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-normalize-characters&quot;&gt;normalize-characters&lt;/a&gt;&quot; on &lt;code&gt;LSSerializer&lt;/code&gt; to true, character normalization is performed according to the definition of &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm&quot;&gt;fully normalized&lt;/a&gt; characters included in appendix E of [&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt;] on all data to be serialized, both markup and character data. The character normalization process affects only the data as it is being written; it does not alter the DOM's view of the document after serialization has completed.</source>
          <target state="translated">&lt;code&gt;LSSerializer&lt;/code&gt; 의 &quot; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-normalize-characters&quot;&gt;normalize-characters&lt;/a&gt; &quot; 매개 변수 를 true 로 설정하여 요청하면 마크 업 및 문자 데이터 모두 직렬화 할 모든 데이터에 대해 [ &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/&quot;&gt;XML 1.1&lt;/a&gt; ] 의 부록 E에 포함 된 &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-fullnorm&quot;&gt;완전 정규화 된&lt;/a&gt; 문자 의 정의에 따라 문자 정규화가 수행됩니다 . 문자 정규화 프로세스는 기록되는 데이터에만 영향을줍니다. 직렬화가 완료된 후 문서의 DOM보기를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9829ac48f456c01c997a54312f4d28ae239840e5" translate="yes" xml:space="preserve">
          <source>When requesting a Namespace URI by prefix, the following table describes the returned Namespace URI value for all possible prefix values:</source>
          <target state="translated">접두사로 네임 스페이스 URI를 요청할 때 다음 표에서는 가능한 모든 접두사 값에 대해 반환 된 네임 스페이스 URI 값을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8c473adada2bf0879238d13edc56b7303e5f6472" translate="yes" xml:space="preserve">
          <source>When requesting a prefix by Namespace URI, the following table describes the returned prefix value for all Namespace URI values:</source>
          <target state="translated">네임 스페이스 URI로 접두사를 요청할 때 다음 표는 모든 네임 스페이스 URI 값에 대해 반환되는 접두사 값을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4469f523c26a6a607eb001a67af246e496c67ea8" translate="yes" xml:space="preserve">
          <source>When requesting prefixes by Namespace URI, the following table describes the returned prefixes value for all Namespace URI values:</source>
          <target state="translated">네임 스페이스 URI로 접두사를 요청할 때 다음 표는 모든 네임 스페이스 URI 값에 대해 반환 된 접두사 값을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="47eff58ddedc0bc2eb7327683e454ec2dfb1f6d0" translate="yes" xml:space="preserve">
          <source>When resolving time fields, the map will be altered and null returned. When resolving date fields, the date is normally returned from the method, with the map altered to remove the resolved fields. However, it would also be acceptable for the date fields to be resolved into other &lt;code&gt;ChronoField&lt;/code&gt; instances that can produce a date, such as &lt;code&gt;EPOCH_DAY&lt;/code&gt;.</source>
          <target state="translated">시간 필드를 해결할 때 맵이 변경되고 null이 반환됩니다. 날짜 필드를 해석 할 때 분석 된 필드를 제거하기 위해 맵이 변경되어 메소드에서 날짜가 정상적으로 리턴됩니다. 그러나 날짜 필드를 날짜 를 생성 할 수있는 다른 &lt;code&gt;ChronoField&lt;/code&gt; 인스턴스 (예 : &lt;code&gt;EPOCH_DAY&lt;/code&gt; ) 로 해석 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d8cf7bc5f7e0ab67c20394ce506b32ad70404b7" translate="yes" xml:space="preserve">
          <source>When returning to windowed mode from an exclusive full-screen window, any display changes made by calling &lt;code&gt;setDisplayMode&lt;/code&gt; are automatically restored to their original state.</source>
          <target state="translated">배타적 전체 화면 창에서 창 모드로 돌아갈 때 &lt;code&gt;setDisplayMode&lt;/code&gt; 를 호출하여 변경된 모든 디스플레이 는 자동으로 원래 상태로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="ed495f5df0234ba9158fa7c63e4629f640c9c226" translate="yes" xml:space="preserve">
          <source>When run the following is produced.</source>
          <target state="translated">실행하면 다음이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="71220676e6e26c91102efdd4c23b78003dc6007b" translate="yes" xml:space="preserve">
          <source>When running in an environment which supports modules, processors are encouraged to include the module prefix when describing their supported annotation types. The method &lt;a href=&quot;abstractprocessor#getSupportedAnnotationTypes()&quot;&gt;&lt;code&gt;AbstractProcessor.getSupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt; provides support for stripping off the module prefix when running in an environment without modules.</source>
          <target state="translated">모듈을 지원하는 환경에서 실행할 때 프로세서는 지원되는 주석 유형을 설명 할 때 모듈 접두사를 포함하는 것이 좋습니다. &lt;a href=&quot;abstractprocessor#getSupportedAnnotationTypes()&quot;&gt; &lt;code&gt;AbstractProcessor.getSupportedAnnotationTypes&lt;/code&gt; &lt;/a&gt; 메소드 는 모듈이없는 환경에서 실행할 때 모듈 접두어를 제거하는 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b2e3a16dad606054ad91ef38f6e33de06fd97381" translate="yes" xml:space="preserve">
          <source>When sending a request that contains a body, the HTTP Client subscribes to the request's &lt;code&gt;BodyPublisher&lt;/code&gt; in order to receive the flow of outgoing request body data. The normal semantics of &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber&quot;&gt;&lt;code&gt;Flow.Subscriber&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt;&lt;code&gt;Flow.Publisher&lt;/code&gt;&lt;/a&gt; are implemented by the HTTP Client and are expected from &lt;code&gt;BodyPublisher&lt;/code&gt; implementations. Each outgoing request results in one HTTP Client &lt;code&gt;Subscriber&lt;/code&gt; subscribing to the &lt;code&gt;BodyPublisher&lt;/code&gt; in order to provide the sequence of byte buffers containing the request body. Instances of &lt;code&gt;
 ByteBuffer&lt;/code&gt; published by the publisher must be allocated by the publisher, and must not be accessed after being published to the HTTP Client. These subscriptions complete normally when the request body is fully sent, and can be canceled or terminated early through error. If a request needs to be resent for any reason, then a new subscription is created which is expected to generate the same data as before.</source>
          <target state="translated">본문이 포함 된 요청을 보낼 때 HTTP 클라이언트 는 나가는 요청 본문 데이터의 흐름을 수신하기 위해 요청의 &lt;code&gt;BodyPublisher&lt;/code&gt; 를 구독합니다 . &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.subscriber&quot;&gt; &lt;code&gt;Flow.Subscriber&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt; &lt;code&gt;Flow.Publisher&lt;/code&gt; &lt;/a&gt; 의 일반적인 의미 는 HTTP 클라이언트에 의해 구현되며 &lt;code&gt;BodyPublisher&lt;/code&gt; 구현 에서 예상됩니다 . 각 나가는 요청 은 요청 본문을 포함하는 바이트 버퍼 시퀀스를 제공하기 위해 하나의 HTTP 클라이언트 &lt;code&gt;Subscriber&lt;/code&gt; 가 &lt;code&gt;BodyPublisher&lt;/code&gt; 를 구독하게합니다 . &lt;code&gt; ByteBuffer&lt;/code&gt; 의 인스턴스게시자가 게시 한 것은 게시자가 할당해야하며 HTTP 클라이언트에 게시 된 후에는 액세스해서는 안됩니다. 이러한 구독은 요청 본문이 완전히 전송되면 정상적으로 완료되며 오류를 통해 조기에 취소하거나 종료 할 수 있습니다. 어떤 이유로 든 요청을 다시 보내야하는 경우 이전과 동일한 데이터를 생성 할 것으로 예상되는 새 구독이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="76363a09529976afbe0f0801c413175b6a84dc98" translate="yes" xml:space="preserve">
          <source>When sending timer notifications, the timer updates the notification sequence number irrespective of the notification type.</source>
          <target state="translated">타이머 알림을 보낼 때 타이머는 알림 유형에 관계없이 알림 시퀀스 번호를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="e95bdd8162adf9968f7adc4afbf013d6f5093728" translate="yes" xml:space="preserve">
          <source>When serializing an &lt;code&gt;Element&lt;/code&gt;, the element is passed to the filter before any of its attributes are passed to the filter. Namespace declaration attributes, and default attributes (except in the case when &quot; discard-default-content&quot; is set to &lt;code&gt;false&lt;/code&gt;), are never passed to the filter.</source>
          <target state="translated">&lt;code&gt;Element&lt;/code&gt; 를 직렬화 할 때 요소는 속성이 필터에 전달되기 전에 필터로 전달됩니다. 네임 스페이스 선언 속성 및 기본 속성 ( &quot;waste-default-content&quot;가 &lt;code&gt;false&lt;/code&gt; 로 설정된 경우 제외 )은 필터에 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="016bd53a30e369ac9500dd916cae37c51e43c195" translate="yes" xml:space="preserve">
          <source>When setting or getting the &lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; or &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; fields, &lt;code&gt;Calendar&lt;/code&gt; must determine the first week of the month or year as a reference point. The first week of a month or year is defined as the earliest seven day period beginning on &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; and containing at least &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; days of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow it. Note that the normalized numbering returned by &lt;code&gt;get()&lt;/code&gt; may be different. For example, a specific &lt;code&gt;Calendar&lt;/code&gt; subclass may designate the week before week 1 of a year as week &lt;code&gt;&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; of the previous year.</source>
          <target state="translated">&lt;code&gt;WEEK_OF_MONTH&lt;/code&gt; 또는 &lt;code&gt;WEEK_OF_YEAR&lt;/code&gt; 필드를 설정하거나 가져올 때 &lt;code&gt;Calendar&lt;/code&gt; 은 월 또는 연도의 첫 번째 주를 기준점으로 결정해야합니다. 월 또는 연도의 첫 번째주는 &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; 에서 시작하여 해당 월 또는 연도의 최소 &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; 일을 포함 하는 가장 빠른 7 일 기간으로 정의됩니다 . 주 번호는 ..., -1, 0이 첫 주 앞에옵니다. 2, 3 번의 번호가 매겨져 있습니다. &lt;code&gt;get()&lt;/code&gt; 의해 반환 된 정규화 된 번호는 다를 수 있습니다. 예를 들어, 특정 &lt;code&gt;Calendar&lt;/code&gt; 하위 클래스는 1 년 전 1 주 전을 전년도 &lt;code&gt;&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; 주로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d95cdd09e08dbf61e5dd1557a78ec0a6f3ed5062" translate="yes" xml:space="preserve">
          <source>When setting the filter, it should be stateless and idempotent, reporting the same result when passed the same arguments.</source>
          <target state="translated">필터를 설정할 때 동일한 인수를 전달할 때 동일한 결과를보고하는 상태 비 저장 및 멱등이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6a17a22214c7c2e160d3cfa1f6db1fc4e32a144d" translate="yes" xml:space="preserve">
          <source>When setting this field, the value is allowed to be partially lenient, taking any value from 1 to 92. If the quarter has less than 92 days, then day 92, and potentially day 91, is in the following quarter.</source>
          <target state="translated">이 필드를 설정하면 1에서 92 사이의 값을 사용하여 값이 부분적으로 관 대해집니다. 분기가 92 일 미만이면 92 일, 잠재적으로 91 일은 다음 분기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="669b10bb52f2a514a970d8c5edffcfcd75525b6b" translate="yes" xml:space="preserve">
          <source>When setting up a print job, a client specifies two things: &lt;b&gt;print data&lt;/b&gt; and &lt;b&gt;processing instructions.&lt;/b&gt; The print data is the actual content to be printed. The processing instructions tell the printer how to print the print data, such as: what media to use, how many copies to print, and whether to print on one or both sides of a sheet. The client specifies these processing instructions with the attribute definitions of the Java Print Service API.</source>
          <target state="translated">인쇄 작업을 설정할 때 클라이언트는 &lt;b&gt;인쇄 데이터&lt;/b&gt; 와 &lt;b&gt;처리 지침의&lt;/b&gt; 두 가지를 지정합니다 &lt;b&gt;. &lt;/b&gt;인쇄 데이터는 인쇄 할 실제 내용입니다. 처리 지침은 프린터에 인쇄 매체 인쇄 방법 (사용할 용지, 인쇄 매수, 한면 또는 양면 인쇄 여부)을 알려줍니다. 클라이언트는 Java 처리 서비스 API의 속성 정의를 사용하여 이러한 처리 지시 사항을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="992deb8ce4de81a3a8e6eef7b845fb57e8e29bfe" translate="yes" xml:space="preserve">
          <source>When specified at the doc level, an attribute applies just to that one doc. When specified at the Print Request level, an attribute applies to the whole job, including all the docs in the job. However, an attribute specified at the doc level overrides an attribute in the same category specified at the Print Request level.</source>
          <target state="translated">문서 레벨에서 지정된 경우 속성은 해당 문서 하나에 만 적용됩니다. 인쇄 요청 레벨에서 지정된 경우 속성은 작업의 모든 문서를 포함하여 전체 작업에 적용됩니다. 그러나 문서 수준에서 지정된 속성은 인쇄 요청 수준에서 지정된 동일한 범주의 속성보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="812c36aefe75f1f01b1e22e1de7ca89fc2466e0d" translate="yes" xml:space="preserve">
          <source>When submitting a print job to a printer, the client provides the attributes describing the characteristics of the print data, such as the document name, and how the print data should be printed, such as double-sided, five copies. If a print job consists of multiple pieces of print data, different pieces might have different processing instructions, such as 8 x 11 inch media for the first document, and 11 x 17 inch media for another document.</source>
          <target state="translated">클라이언트는 인쇄 작업을 프린터에 제출할 때 문서 이름과 같은 인쇄 데이터의 특성과 양면 5 부와 같은 인쇄 데이터 인쇄 방법을 설명하는 속성을 제공합니다. 인쇄 작업이 여러 개의 인쇄 데이터로 구성된 경우 각 조각마다 첫 번째 문서의 경우 8 x 11 인치 용지, 다른 문서의 경우 11 x 17 인치 용지와 같은 다른 처리 지침이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e9ff7cc584e16b6ab10015ab9bcdd0ba01476c5" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 해당하는 새로운 추상 주석 값 방문자 클래스도 도입됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 전체 또는 일부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cee9708c809ea2c5706271d9f5de6094df8928a" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 해당하는 새로운 추상 요소 방문자 클래스도 도입됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 전체 또는 일부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="103e345f76c16d48cafc8a85f69a007ae6fc9260" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 해당하는 새로운 추상 유형 방문자 클래스도 도입됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 전체 또는 일부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0634269e692a9a236845f34b129b30b4ad1d950" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 해당하는 새로운 추상 주석 값 방문자 클래스도 도입됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 전체 또는 일부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bd8fde8037f05021ae5406815b06bfefd44e332" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown(javax.lang.model.element.AnnotationValue,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새 언어 수준에 해당하는 새 단순 주석 값 방문자 클래스도 도입됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 전체 또는 일부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03ec6c25b6d376081732b85e415911f8c6ec0d3e" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown-javax.lang.model.element.AnnotationValue-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown-javax.lang.model.element.AnnotationValue-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 추상 어노테이션 값 방문자 클래스도 새로운 언어 레벨에 맞게 소개 될 것입니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 일부 또는 전부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05ff925b46ec11d08257cdc7e971c5f6bf2e8675" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown-javax.lang.model.element.AnnotationValue-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple annotation value visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstractannotationvaluevisitor6#visitUnknown-javax.lang.model.element.AnnotationValue-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 간단한 어노테이션 값 방문자 클래스도 새로운 언어 레벨에 맞게 소개됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 일부 또는 전부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27c4228447106a355af0159031dee75cd1cf6476" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 추상 요소 종류 방문자 클래스도 새로운 언어 수준에 맞게 도입됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 전체 또는 일부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6211be69d40865a23b57629a99ebded376b30392" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 해당하는 새로운 추상 요소 방문자 클래스도 도입됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 전체 또는 일부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c6e97c8e268ce1819909e688b39f6199c9409ae" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new element scanner visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 해당하는 새로운 요소 스캐너 방문자 클래스도 도입됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 전체 또는 일부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86581670b2bf6977794da9d077dabee784e08b42" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstractelementvisitor6#visitUnknown(javax.lang.model.element.Element,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 해당하는 새로운 단순 요소 방문자 클래스도 도입됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 전체 또는 일부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="044c236c1377724dc963f7b253a1633adebf4edd" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 대응하기 위해 새로운 추상 요소 종류의 방문자 클래스도 도입 될 것입니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 일부 또는 전부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="710e79e570a5917821dfd7344c3f17284d9a4964" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 대응하기 위해 새로운 추상 요소 방문자 클래스도 도입 될 것입니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 일부 또는 전부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf2a73437432866576d26e93ec38ac98756a0ab7" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new element scanner visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 대응하기 위해 새로운 요소 스캐너 방문자 클래스도 도입 될 것입니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 일부 또는 전부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d632be78f99f513b8aa8e1b7f5cb5683a59ff22f" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple element visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstractelementvisitor6#visitUnknown-javax.lang.model.element.Element-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 대응하기 위해 새로운 간단한 요소 방문자 클래스도 도입 될 것입니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 일부 또는 전부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="425c228d797e1d155d3a9aacad4b65a7e3cd8fc7" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 해당하는 새로운 추상 유형 방문자 클래스도 도입됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 전체 또는 일부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca02dde6bf89fc22036125452b0233a9a4bb4fe0" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 해당하는 새로운 단순 유형 방문자 클래스도 도입됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 전체 또는 일부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06a03ed21f6890e3698866751eba23ff67280af0" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new type kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstracttypevisitor6#visitUnknown(javax.lang.model.type.TypeMirror,P)&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 유형의 방문자 클래스도 새로운 언어 수준에 맞게 도입됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 전체 또는 일부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31a71bf88455082c4bc48a8526d303b8ca6d7ee4" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new abstract type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 해당하는 새로운 추상 유형 방문자 클래스도 도입됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 일부 또는 전부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0bd9887b4dede673a8a857fd6f562d2e6651e7c" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new simple type visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 단순 레벨 방문자 클래스도 새로운 언어 레벨에 맞게 소개됩니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 일부 또는 전부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5e7913304df13157eca5adf23774332e392edc0" translate="yes" xml:space="preserve">
          <source>When such a new visit method is added, the default implementation in this class will be to call the &lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt;&lt;code&gt;visitUnknown&lt;/code&gt;&lt;/a&gt; method. A new type kind visitor class will also be introduced to correspond to the new language level; this visitor will have different default behavior for the visit method in question. When the new visitor is introduced, all or portions of this visitor may be deprecated.</source>
          <target state="translated">이러한 새 방문 메소드가 추가되면이 클래스의 기본 구현은 &lt;a href=&quot;abstracttypevisitor6#visitUnknown-javax.lang.model.type.TypeMirror-P-&quot;&gt; &lt;code&gt;visitUnknown&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것입니다. 새로운 언어 수준에 대응하기 위해 새로운 유형의 방문자 클래스도 소개 될 것입니다. 이 방문자는 해당 방문 방법에 대해 다른 기본 동작을 갖습니다. 새 방문자가 소개되면이 방문자의 일부 또는 전부가 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7169edd82e18117207c8b43effbe612c3734164e" translate="yes" xml:space="preserve">
          <source>When symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;same&lt;/code&gt;&lt;/a&gt; file as &lt;code&gt;other&lt;/code&gt; is implementation dependent. For example, if this path is &lt;code&gt;&quot;/a/b&quot;&lt;/code&gt; and the given path is &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; then the resulting relative path may be &lt;code&gt;
 &quot;../x&quot;&lt;/code&gt;. If &lt;code&gt;&quot;b&quot;&lt;/code&gt; is a symbolic link then is implementation dependent if &lt;code&gt;&quot;a/b/../x&quot;&lt;/code&gt; would locate the same file as &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt;.</source>
          <target state="translated">심볼릭 링크가 지원되는 경우이 경로에 대해 분석 될 때 결과 경로 가 &lt;code&gt;other&lt;/code&gt; 파일과 &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;same&lt;/code&gt; &lt;/a&gt; 파일 을 찾는 데 사용할 수있는 경로를 생성하는지 여부 는 구현에 따라 다릅니다. 예를 &lt;code&gt; &quot;../x&quot;&lt;/code&gt; 경로가 &lt;code&gt;&quot;/a/b&quot;&lt;/code&gt; 이고 지정된 경로가 &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; 이면 결과 상대 경로는 &quot;../x&quot; 가 될 수 있습니다 . 경우 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 심볼릭 링크는 다음 구현에 의존하는 경우 &lt;code&gt;&quot;a/b/../x&quot;&lt;/code&gt; 와 같은 파일을 찾을 것 &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21130ee63b47bcee22d5206a3b440986ec034278" translate="yes" xml:space="preserve">
          <source>When symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;same&lt;/code&gt;&lt;/a&gt; file as &lt;code&gt;other&lt;/code&gt; is implementation dependent. For example, if this path is &lt;code&gt;&quot;/a/b&quot;&lt;/code&gt; and the given path is &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; then the resulting relative path may be &lt;code&gt;&quot;../x&quot;&lt;/code&gt;. If &lt;code&gt;&quot;b&quot;&lt;/code&gt; is a symbolic link then is implementation dependent if &lt;code&gt;&quot;a/b/../x&quot;&lt;/code&gt; would locate the same file as &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt;.</source>
          <target state="translated">심볼릭 링크가 지원되면이 경로에 대해 해석 될 때 결과 경로 가 &lt;code&gt;other&lt;/code&gt; 파일과 &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;same&lt;/code&gt; &lt;/a&gt; 파일 을 찾는 데 사용할 수있는 경로를 생성하는지 여부 는 구현에 따라 다릅니다. 예를 들어,이 경로가 &lt;code&gt;&quot;/a/b&quot;&lt;/code&gt; 이고 지정된 경로가 &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; 이면 결과 상대 경로는 &lt;code&gt;&quot;../x&quot;&lt;/code&gt; 일 수 있습니다 . 경우 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 심볼릭 링크는 다음 구현에 의존하는 경우 &lt;code&gt;&quot;a/b/../x&quot;&lt;/code&gt; 와 같은 파일을 찾을 것 &lt;code&gt;&quot;/a/x&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9201aa7cc9fa88f4813925552674c147d8b25ef5" translate="yes" xml:space="preserve">
          <source>When testing the user-information, path, query, fragment, authority, or scheme-specific parts of two URIs for equality, the raw forms rather than the encoded forms of these components are compared and the hexadecimal digits of escaped octets are compared without regard to case.</source>
          <target state="translated">두 URI의 사용자 정보, 경로, 쿼리, 조각, 권한 또는 체계 별 부분이 동일한 지 테스트 할 때 이러한 구성 요소의 인코딩 된 형식이 아닌 원시 형식을 비교하고 이스케이프 된 옥텟의 16 진수를 고려하지 않고 비교합니다. 경우에.</target>
        </trans-unit>
        <trans-unit id="2cb5a2d45e0a1e497d3635ca731bd3fec76abfbe" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#enter()&quot;&gt;&lt;code&gt;enter()&lt;/code&gt;&lt;/a&gt; method is called, the current thread is blocked until the loop is terminated by the &lt;a href=&quot;#exit()&quot;&gt;&lt;code&gt;exit()&lt;/code&gt;&lt;/a&gt; method. Also, a new event loop is started on the event dispatch thread, which may or may not be the current thread. The loop can be terminated on any thread by calling its &lt;a href=&quot;#exit()&quot;&gt;&lt;code&gt;exit()&lt;/code&gt;&lt;/a&gt; method. After the loop is terminated, the &lt;code&gt;SecondaryLoop&lt;/code&gt; object can be reused to run a new nested event loop.</source>
          <target state="translated">(가)시 &lt;a href=&quot;#enter()&quot;&gt; &lt;code&gt;enter()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 루프가 종료 될 때까지, 현재 스레드가 차단되는 &lt;a href=&quot;#exit()&quot;&gt; &lt;code&gt;exit()&lt;/code&gt; &lt;/a&gt; 방법. 또한 새로운 이벤트 루프는 현재 스레드 일 수도 있고 아닐 수도있는 이벤트 디스패치 스레드에서 시작됩니다. 루프는 &lt;a href=&quot;#exit()&quot;&gt; &lt;code&gt;exit()&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 모든 스레드에서 종료 할 수 있습니다 . 루프가 종료 된 후 &lt;code&gt;SecondaryLoop&lt;/code&gt; 객체를 재사용하여 새 중첩 이벤트 루프를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93c5bf1f5d3d11b7b3d1d812715baf3c9fe0fecb" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; is null, the implementation will behave as if the following &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt;&lt;code&gt;LSResourceResolver&lt;/code&gt;&lt;/a&gt; is set:</source>
          <target state="translated">때 &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; 나이&lt;/a&gt; 널 (null)이며, 구현은 다음과 같은 경우로 동작합니다 &lt;a href=&quot;../../../org/w3c/dom/ls/lsresourceresolver&quot;&gt; &lt;code&gt;LSResourceResolver&lt;/code&gt; 나이&lt;/a&gt; 설정됩니다</target>
        </trans-unit>
        <trans-unit id="9c71a117a0d78807772c45691dff3b7188404bd9" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is null, the implementation will behave as if the following &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is set:</source>
          <target state="translated">때 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt; 널 (null)이 다음처럼 구현 동작합니다 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; 를이&lt;/a&gt; 설정은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="349843d9371dc6f3aced62d1709febefa1cdc8d8" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;objectinputfilter#checkInput(java.io.ObjectInputFilter.FilterInfo)&quot;&gt;&lt;code&gt;checkInput&lt;/code&gt;&lt;/a&gt; method is invoked it is given access to the current class, the array length, the current number of references already read from the stream, the depth of nested calls to &lt;a href=&quot;#readObject()&quot;&gt;&lt;code&gt;readObject&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#readUnshared()&quot;&gt;&lt;code&gt;readUnshared&lt;/code&gt;&lt;/a&gt;, and the implementation dependent number of bytes consumed from the input stream.</source>
          <target state="translated">때 &lt;a href=&quot;objectinputfilter#checkInput(java.io.ObjectInputFilter.FilterInfo)&quot;&gt; &lt;code&gt;checkInput&lt;/code&gt; 의&lt;/a&gt; 방법은 호출이 현재 클래스, 배열의 길이에 대한 액세스 권한이 부여되고, 이미 스트림에 중첩 된 호출의 깊이에서 읽을 참조의 현재 수 &lt;a href=&quot;#readObject()&quot;&gt; &lt;code&gt;readObject&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#readUnshared()&quot;&gt; &lt;code&gt;readUnshared&lt;/code&gt; 를&lt;/a&gt; , 바이트의 구현에 의존 수는에서 소비 입력 스트림.</target>
        </trans-unit>
        <trans-unit id="ab0a44a62ffe84a96b19e3bf378964ba73e0fcca" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CachedRowSet&lt;/code&gt; method &lt;code&gt;acceptChanges&lt;/code&gt; is called, it delegates to the &lt;code&gt;RowSet&lt;/code&gt; object's &lt;code&gt;SyncProvider&lt;/code&gt; object. How the writer provided by that &lt;code&gt;SyncProvider&lt;/code&gt; object is implemented determines what level (grade) of checking for conflicts will be done. After all checking for conflicts is completed and one or more conflicts has been found, the method &lt;code&gt;acceptChanges&lt;/code&gt; throws a &lt;code&gt;SyncProviderException&lt;/code&gt; object. The application can catch the exception and use it to obtain a &lt;code&gt;SyncResolver&lt;/code&gt; object.</source>
          <target state="translated">때 &lt;code&gt;CachedRowSet&lt;/code&gt; 방법 &lt;code&gt;acceptChanges&lt;/code&gt; 받는 사람, 위임라고 &lt;code&gt;RowSet&lt;/code&gt; 객체의 &lt;code&gt;SyncProvider&lt;/code&gt; 객체입니다. 해당 &lt;code&gt;SyncProvider&lt;/code&gt; 개체에서 제공하는 작성기 가 구현 되는 방법에 따라 충돌 검사가 수행되는 수준 (등급)이 결정됩니다. 모든 충돌 검사가 완료되고 하나 이상의 충돌이 발견되면 &lt;code&gt;acceptChanges&lt;/code&gt; 메소드 가 &lt;code&gt;SyncProviderException&lt;/code&gt; 객체를 발생시킵니다. 애플리케이션은 예외를 포착하고이를 사용하여 &lt;code&gt;SyncResolver&lt;/code&gt; 오브젝트 를 확보 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72afefcfd2d2b20f95a8bc304631fb4c64f7b278" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the byte array.</source>
          <target state="translated">때 &lt;code&gt;HttpResponse&lt;/code&gt; 객체가 리턴 본체 완전히 바이트 어레이에 기록되었다.</target>
        </trans-unit>
        <trans-unit id="0d9e780897f9f330f634a20683b4c50779ddf071" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the consumer.</source>
          <target state="translated">때 &lt;code&gt;HttpResponse&lt;/code&gt; 에의 객체가 반환되고, 몸이 완전히 소비자에 기록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba9826c0dffb73820d59d4df3c02f81a55a41d8a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the file and &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;HttpResponse.body()&lt;/code&gt;&lt;/a&gt; returns a &lt;code&gt;Path&lt;/code&gt; object for the file. The returned &lt;code&gt;Path&lt;/code&gt; is the combination of the supplied directory name and the file name supplied by the server. If the destination directory does not exist or cannot be written to, then the response will fail with an &lt;a href=&quot;../../../../java.base/java/io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;HttpResponse&lt;/code&gt; 에의 객체가 반환되고, 몸이 완전히 파일에 기록 된 &lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;HttpResponse.body()&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;Path&lt;/code&gt; 파일에 대한 객체. 반환 된 &lt;code&gt;Path&lt;/code&gt; 는 제공된 디렉토리 이름과 서버에서 제공 한 파일 이름의 조합입니다. 대상 디렉토리가 없거나 쓸 수없는 경우 &lt;a href=&quot;../../../../java.base/java/io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 으로&lt;/a&gt; 응답이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="ae8fe4cf9af58eae2641375733a0acff7ecc038a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the file, and &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;HttpResponse.body()&lt;/code&gt;&lt;/a&gt; returns a reference to its &lt;a href=&quot;../../../../java.base/java/nio/file/path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;HttpResponse&lt;/code&gt; 에의 객체가 반환되고, 몸이 완전히 파일에 기록하고있다 &lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;HttpResponse.body()&lt;/code&gt; &lt;/a&gt; 의에 대한 참조를 반환 &lt;a href=&quot;../../../../java.base/java/nio/file/path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f8b7f93bc4b770c2f3611214ea9f4ae4a8f5b0d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body has been completely written to the string.</source>
          <target state="translated">때 &lt;code&gt;HttpResponse&lt;/code&gt; 에의 객체가 반환되고, 몸은 완전히 문자열로 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="d434402a35c684d119251a82bd168ecbc741dd91" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the body may not have been completely received.</source>
          <target state="translated">&lt;code&gt;HttpResponse&lt;/code&gt; 개체가 반환 될 때 본문이 완전히 수신되지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e5ca13755a6bfd06a017657997d9818861116f6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the response headers will have been completely read, but the body may not have been fully received yet. The &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;HttpResponse.body()&lt;/code&gt;&lt;/a&gt; method returns a &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt;&lt;code&gt;Publisher&lt;list&gt;&amp;gt;&lt;/list&gt;&lt;/code&gt;&lt;/a&gt; from which the body response bytes can be obtained as they are received. The publisher can and must be subscribed to only once.</source>
          <target state="translated">때 &lt;code&gt;HttpResponse&lt;/code&gt; 에의 객체가 반환됩니다 응답 헤더 읽기 완전히되었습니다하지만, 몸은 아직 완전히 접수되지 않았을 수 있습니다. &lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;HttpResponse.body()&lt;/code&gt; &lt;/a&gt; 메소드는 반환 &lt;a href=&quot;../../../../java.base/java/util/concurrent/flow.publisher&quot;&gt; &lt;code&gt;Publisher&lt;list&gt;&amp;gt;&lt;/list&gt;&lt;/code&gt; &lt;/a&gt;수신 된 본문 응답 바이트를 얻을 수 있습니다. 게시자는 한 번만 구독 할 수 있으며 구독해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b1d642a866048552e189045dd9a35591fae905b" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;HttpResponse&lt;/code&gt; object is returned, the response headers will have been completely read, but the body may not have been fully received yet. The &lt;a href=&quot;httpresponse#body()&quot;&gt;&lt;code&gt;HttpResponse.body()&lt;/code&gt;&lt;/a&gt; method returns an &lt;a href=&quot;../../../../java.base/java/io/inputstream&quot;&gt;&lt;code&gt;InputStream&lt;/code&gt;&lt;/a&gt; from which the body can be read as it is received.</source>
          <target state="translated">때 &lt;code&gt;HttpResponse&lt;/code&gt; 에의 객체가 반환됩니다 응답 헤더 읽기 완전히되었습니다하지만, 몸은 아직 완전히 접수되지 않았을 수 있습니다. &lt;a href=&quot;httpresponse#body()&quot;&gt; &lt;code&gt;HttpResponse.body()&lt;/code&gt; &lt;/a&gt; 메소드는 반환 &lt;a href=&quot;../../../../java.base/java/io/inputstream&quot;&gt; &lt;code&gt;InputStream&lt;/code&gt; &lt;/a&gt; 가 수신 될 때 신체가 판독 할 수있는이.</target>
        </trans-unit>
        <trans-unit id="1ee08c821ac6ffd8d690cbbc08d004846b4f65e3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Printable&lt;/code&gt; is obtained from a client-supplied &lt;code&gt;Pageable&lt;/code&gt; then the client may provide different PageFormats for each page index. Calculations of page breaks must account for this.</source>
          <target state="translated">클라이언트가 제공 한 &lt;code&gt;Pageable&lt;/code&gt; 에서 &lt;code&gt;Printable&lt;/code&gt; 을 가져 오면 클라이언트는 각 페이지 인덱스에 대해 다른 PageFormats를 제공 할 수 있습니다. 페이지 나누기를 계산할 때이를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8da723286e46b5dcc04253d5d4b818f47a7e075f" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;RowSet&lt;/code&gt; object changes one of its rows, changes all of it rows, or moves its cursor, it also notifies each listener that is registered with it. The listener reacts by carrying out its implementation of the notification method called on it.</source>
          <target state="translated">때 &lt;code&gt;RowSet&lt;/code&gt; 객체가 1 행을 변경, 또한 그 등록되어 각 청취자에게 통지, 그것의 모든 행을 변경하는, 또는 커서를 움직인다. 리스너는 호출 된 알림 메소드를 구현하여 반응합니다.</target>
        </trans-unit>
        <trans-unit id="ee7ac132993577ecd59468c3647a9e567b53ac77" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;add&lt;/code&gt; method is called to add a Permission, the Permission is stored in the appropriate PermissionCollection. If no such collection exists yet, the Permission object's class is determined and the &lt;code&gt;newPermissionCollection&lt;/code&gt; method is called on that class to create the PermissionCollection and add it to the Permissions object. If &lt;code&gt;newPermissionCollection&lt;/code&gt; returns null, then a default PermissionCollection that uses a hashtable will be created and used. Each hashtable entry stores a Permission object as both the key and the value.</source>
          <target state="translated">때 &lt;code&gt;add&lt;/code&gt; 메소드가 호출 해 Permission를 추가, Permission는 적절한 PermissionCollection에 저장됩니다. 이러한 컬렉션이 아직 존재하지 않으면 Permission 객체의 클래스가 결정되고 해당 클래스에서 &lt;code&gt;newPermissionCollection&lt;/code&gt; 메서드가 호출되어 PermissionCollection을 만들어 Permissions 객체에 추가합니다. 경우 &lt;code&gt;newPermissionCollection&lt;/code&gt; 널 (null)을 반환 한 후 해시 테이블을 사용하는 디폴트의 PermissionCollection가 작성되어 사용됩니다. 각 해시 테이블 항목은 Permission 객체를 키와 값으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="b88d575b7afc2c5eb726273e486f2105b12c75a9" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;cellRenderer&lt;/code&gt; or &lt;code&gt;cellEditor&lt;/code&gt; parameter is &lt;code&gt;null&lt;/code&gt;, a default value provided by the &lt;code&gt;JTable&lt;/code&gt;&lt;code&gt;getDefaultRenderer&lt;/code&gt; or &lt;code&gt;getDefaultEditor&lt;/code&gt; method, respectively, is used to provide defaults based on the type of the data in this column. This column-centric rendering strategy can be circumvented by overriding the &lt;code&gt;getCellRenderer&lt;/code&gt; methods in &lt;code&gt;JTable&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;cellRenderer&lt;/code&gt; 의 또는 &lt;code&gt;cellEditor&lt;/code&gt; 가 매개 변수가 &lt;code&gt;null&lt;/code&gt; 은에 의해 제공되는 디폴트 값 &lt;code&gt;JTable&lt;/code&gt; &lt;code&gt;getDefaultRenderer&lt;/code&gt; 또는 &lt;code&gt;getDefaultEditor&lt;/code&gt; 에 있어서, 각각이 항목의 데이터의 타입에 기초하여 디폴트 값을 제공하는데 사용된다. 이 열 중심 렌더링 전략은 &lt;code&gt;JTable&lt;/code&gt; 의 &lt;code&gt;getCellRenderer&lt;/code&gt; 메서드를 재정 의하여 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bda165d83525f9548659c3eec7e03d20271f7a7" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;getCallerClass&lt;/code&gt; method is called from a method that is the bottom most frame on the stack, for example, &lt;code&gt;static public void main&lt;/code&gt; method launched by the &lt;code&gt;java&lt;/code&gt; launcher, or a method invoked from a JNI attached thread, &lt;code&gt;IllegalCallerException&lt;/code&gt; is thrown.</source>
          <target state="translated">때 &lt;code&gt;getCallerClass&lt;/code&gt; 의 방법은 예를 들어, 스택에 바닥 가장 프레임을하는 방법에서 호출 &lt;code&gt;static public void main&lt;/code&gt; 에 의해 시작 방법 &lt;code&gt;java&lt;/code&gt; 실행, 또는 방법은 JNI 첨부 된 스레드에서 호출, &lt;code&gt;IllegalCallerException&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5d8cbad25caa72fa532ed2521b7fd96e96a6b5fa" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;invokevirtual&lt;/code&gt; is executed after linking, the receiving VarHandle's access mode type is first checked by the JVM to ensure that it matches the symbolic type descriptor. If the type match fails, it means that the access mode method which the caller is invoking is not present on the individual VarHandle being invoked.</source>
          <target state="translated">링크 후 &lt;code&gt;invokevirtual&lt;/code&gt; 이 실행될 때 수신 VarHandle의 액세스 모드 유형은 먼저 JVM에서 기호 유형 설명자와 일치하는지 확인합니다. 유형 일치가 실패하면 호출자가 호출하는 액세스 모드 메서드가 호출되는 개별 VarHandle에 존재하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d4ff583386f934e25bcb252a53631116c45f985a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;invokevirtual&lt;/code&gt; is executed after linking, the receiving method handle's type is first checked by the JVM to ensure that it matches the symbolic type descriptor. If the type match fails, it means that the method which the caller is invoking is not present on the individual method handle being invoked.</source>
          <target state="translated">링크 후 &lt;code&gt;invokevirtual&lt;/code&gt; 이 실행될 때 수신 메소드 핸들의 유형을 먼저 JVM에서 확인하여 기호 유형 설명자와 일치하는지 확인하십시오. 유형 일치가 실패하면 호출자가 호출중인 메소드가 호출중인 개별 메소드 핸들에 존재하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8226f6246b0d0b9cfb2a7ab0e96a44673f4a1c3a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;keyIdentifier&lt;/code&gt; field of &lt;code&gt;AuthorityKeyIdentifier&lt;/code&gt; is populated, the value is usually taken from the &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension in the issuer's certificate. Note, however, that the result of &lt;code&gt;X509Certificate.getExtensionValue(&amp;lt;SubjectKeyIdentifier Object
 Identifier&amp;gt;)&lt;/code&gt; on the issuer's certificate may NOT be used directly as the input to &lt;code&gt;setAuthorityKeyIdentifier&lt;/code&gt;. This is because the SubjectKeyIdentifier contains only a KeyIdentifier OCTET STRING, and not a SEQUENCE of KeyIdentifier, GeneralNames, and CertificateSerialNumber. In order to use the extension value of the issuer certificate's &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension, it will be necessary to extract the value of the embedded &lt;code&gt;KeyIdentifier&lt;/code&gt; OCTET STRING, then DER encode this OCTET STRING inside a SEQUENCE. For more details on SubjectKeyIdentifier, see &lt;a href=&quot;#setSubjectKeyIdentifier(byte%5B%5D)&quot;&gt;&lt;code&gt;setSubjectKeyIdentifier(byte[] subjectKeyID)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;AuthorityKeyIdentifier&lt;/code&gt; 의 &lt;code&gt;keyIdentifier&lt;/code&gt; 필드 가 채워지면 값은 일반적으로 발급자의 인증서에있는 &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; 확장에서 가져옵니다 . 그러나 발급자의 인증서에 대한 &lt;code&gt;X509Certificate.getExtensionValue(&amp;lt;SubjectKeyIdentifier Object Identifier&amp;gt;)&lt;/code&gt; 의 결과는 &lt;code&gt;setAuthorityKeyIdentifier&lt;/code&gt; 에 대한 입력으로 직접 사용되지 않을 수 있습니다 . 이는 SubjectKeyIdentifier에 KeyIdentifier, GeneralNames 및 CertificateSerialNumber의 SEQUENCE가 아닌 KeyIdentifier OCTET STRING 만 포함되기 때문입니다. 발급자 인증서의 &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; 확장 의 확장 값을 사용하려면 포함 된 값을 추출해야합니다. &lt;code&gt;KeyIdentifier&lt;/code&gt; OCTET STRING, 그런 다음 DER이이 OCTET STRING을 SEQUENCE 안에 인코딩합니다. SubjectKeyIdentifier에 대한 자세한 내용은 &lt;a href=&quot;#setSubjectKeyIdentifier(byte%5B%5D)&quot;&gt; &lt;code&gt;setSubjectKeyIdentifier(byte[] subjectKeyID)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="834601037ab0662f3396b5a79222cc36559945fd" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;keyIdentifier&lt;/code&gt; field of &lt;code&gt;AuthorityKeyIdentifier&lt;/code&gt; is populated, the value is usually taken from the &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension in the issuer's certificate. Note, however, that the result of &lt;code&gt;X509Certificate.getExtensionValue(&amp;lt;SubjectKeyIdentifier Object
 Identifier&amp;gt;)&lt;/code&gt; on the issuer's certificate may NOT be used directly as the input to &lt;code&gt;setAuthorityKeyIdentifier&lt;/code&gt;. This is because the SubjectKeyIdentifier contains only a KeyIdentifier OCTET STRING, and not a SEQUENCE of KeyIdentifier, GeneralNames, and CertificateSerialNumber. In order to use the extension value of the issuer certificate's &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; extension, it will be necessary to extract the value of the embedded &lt;code&gt;KeyIdentifier&lt;/code&gt; OCTET STRING, then DER encode this OCTET STRING inside a SEQUENCE. For more details on SubjectKeyIdentifier, see &lt;a href=&quot;x509certselector#setSubjectKeyIdentifier-byte:A-&quot;&gt;&lt;code&gt;setSubjectKeyIdentifier(byte[] subjectKeyID)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;AuthorityKeyIdentifier&lt;/code&gt; 의 &lt;code&gt;keyIdentifier&lt;/code&gt; 필드 가 채워지면, 값은 일반적으로 발행자 인증서 의 &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; 확장에서 가져옵니다 . 그러나 발행자의 인증서에 대한 &lt;code&gt;X509Certificate.getExtensionValue(&amp;lt;SubjectKeyIdentifier Object Identifier&amp;gt;)&lt;/code&gt; 결과는 &lt;code&gt;setAuthorityKeyIdentifier&lt;/code&gt; 의 입력으로 직접 사용될 수 없습니다 . 이는 SubjectKeyIdentifier에 KeyIdentifier, GeneralNames 및 CertificateSerialNumber의 시퀀스가 ​​아닌 KeyIdentifier OCTET STRING 만 포함하기 때문입니다. 발급자 인증서 &lt;code&gt;SubjectKeyIdentifier&lt;/code&gt; 확장 의 확장 값을 사용하려면 포함 된 값을 추출해야합니다. &lt;code&gt;KeyIdentifier&lt;/code&gt; OCTET STRING을 누른 다음이 OCTET STRING을 SEQUENCE 내에서 DER 인코딩합니다. SubjectKeyIdentifier에 대한 자세한 내용은 &lt;a href=&quot;x509certselector#setSubjectKeyIdentifier-byte:A-&quot;&gt; &lt;code&gt;setSubjectKeyIdentifier(byte[] subjectKeyID)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8d5a455eaa9bae77e2400ec125089de5958ee67" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;nextToken&lt;/code&gt; method encounters a string constant, the &lt;code&gt;ttype&lt;/code&gt; field is set to the string delimiter and the &lt;code&gt;sval&lt;/code&gt; field is set to the body of the string.</source>
          <target state="translated">경우 &lt;code&gt;nextToken&lt;/code&gt; 의 방법은 문자열 상수 발생은 &lt;code&gt;ttype&lt;/code&gt; 의 필드는 문자열 분리로 설정되고 &lt;code&gt;sval&lt;/code&gt; 이 필드는 문자열의 신체에 설정된다.</target>
        </trans-unit>
        <trans-unit id="479c547e4f51a87c5259ae916511976a07f64d0b" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;object&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method writes an SQL &lt;code&gt;NULL&lt;/code&gt; to the stream.</source>
          <target state="translated">때 &lt;code&gt;object&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; ,이 방법은 SQL의 기록 &lt;code&gt;NULL&lt;/code&gt; 를 스트림에.</target>
        </trans-unit>
        <trans-unit id="a7c8af093f9042d418aa0a04feb575a30082784d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;registerApplicationClasspathSpis&lt;/code&gt; method is called, additional service provider instances will be discovered using &lt;a href=&quot;../../../../java.base/java/util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;registerApplicationClasspathSpis&lt;/code&gt; 의 메소드가 호출 될 때, 추가 서비스 제공 인스턴스를 사용하여 발견됩니다 &lt;a href=&quot;../../../../java.base/java/util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fad260ae6f20782961df5b3d238d1f3fbcb7ca36" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;registerApplicationClasspathSpis&lt;/code&gt; method is called, service provider instances declared in the meta-information section of JAR files on the application class path are loaded. To declare a service provider, a &lt;code&gt;services&lt;/code&gt; subdirectory is placed within the &lt;code&gt;META-INF&lt;/code&gt; directory that is present in every JAR file. This directory contains a file for each service provider interface that has one or more implementation classes present in the JAR file. For example, if the JAR file contained a class named &lt;code&gt;com.mycompany.imageio.MyFormatReaderSpi&lt;/code&gt; which implements the &lt;code&gt;ImageReaderSpi&lt;/code&gt; interface, the JAR file would contain a file named:</source>
          <target state="translated">때 &lt;code&gt;registerApplicationClasspathSpis&lt;/code&gt; 의 메소드가 호출 될 때, 어플리케이션의 클래스 패스에 JAR 파일의 메타 정보 섹션에서 선언 된 서비스 프로 바이더 인스턴스가로드됩니다. 서비스 제공자를 선언하기 위해 &lt;code&gt;services&lt;/code&gt; 서브 디렉토리는 모든 JAR 파일에 있는 &lt;code&gt;META-INF&lt;/code&gt; 디렉토리 내에 있습니다. 이 디렉토리에는 JAR 파일에 하나 이상의 구현 클래스가있는 각 서비스 제공자 인터페이스에 대한 파일이 있습니다. 예를 들어 JAR 파일 에 &lt;code&gt;ImageReaderSpi&lt;/code&gt; 인터페이스 를 구현하는 &lt;code&gt;com.mycompany.imageio.MyFormatReaderSpi&lt;/code&gt; 라는 클래스 가 포함 된 경우 JAR 파일에는 다음과 같은 이름의 파일이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="800a8722fdd5697538b5f0c521ac05a66ca1b2c2" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;value&lt;/code&gt; property changes, &lt;code&gt;ChangeListeners&lt;/code&gt; are notified. &lt;code&gt;SpinnerModel&lt;/code&gt; may choose to notify the &lt;code&gt;ChangeListeners&lt;/code&gt; under other circumstances.</source>
          <target state="translated">때 &lt;code&gt;value&lt;/code&gt; 속성이 변경 &lt;code&gt;ChangeListeners&lt;/code&gt; 에이 통지됩니다. &lt;code&gt;SpinnerModel&lt;/code&gt; 은 다른 상황 에서 &lt;code&gt;ChangeListeners&lt;/code&gt; 에 알리도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="515adaec2191bebc2d2c17a699cb4b4c2d2e4592" translate="yes" xml:space="preserve">
          <source>When the BasicAttributes class needs to create an Attribute, it uses BasicAttribute. There is no other dependency on BasicAttribute.</source>
          <target state="translated">BasicAttributes 클래스는 속성을 작성해야 할 때 BasicAttribute를 사용합니다. BasicAttribute에 대한 다른 종속성은 없습니다.</target>
        </trans-unit>
        <trans-unit id="3ec9901f8b0995c7d238dee247f5bc92ba92c9c8" translate="yes" xml:space="preserve">
          <source>When the DBMS does not store time zone information, the driver will use the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;TIME&lt;/code&gt; value to send to the database. With a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the date taking into account a custom time zone. If no &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the time zone of the Virtual Machine that is running the application.</source>
          <target state="translated">DBMS가 표준 시간대 정보를 저장하지 않을 때 드라이버는 주어진 &lt;code&gt;Calendar&lt;/code&gt; 개체를 사용 하여 데이터베이스에 보낼 SQL &lt;code&gt;TIME&lt;/code&gt; 값을 구성 합니다. A를 &lt;code&gt;Calendar&lt;/code&gt; 사용자 정의 시간대를 계정에 객체, 드라이버는 날짜 복용을 계산할 수 있습니다. &lt;code&gt;Calendar&lt;/code&gt; 개체가 지정 되지 않은 경우 드라이버는 응용 프로그램을 실행하는 가상 시스템의 표준 시간대를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="45a7b9314633389caa68b45c357b57d0f9fe579c" translate="yes" xml:space="preserve">
          <source>When the DBMS does not store time zone information, the driver will use the given &lt;code&gt;Calendar&lt;/code&gt; object to construct the SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value to send to the database. With a &lt;code&gt;Calendar&lt;/code&gt; object, the driver can calculate the timestamp taking into account a custom time zone. If no &lt;code&gt;Calendar&lt;/code&gt; object is specified, the driver uses the time zone of the Virtual Machine that is running the application.</source>
          <target state="translated">DBMS가 시간대 정보를 저장하지 않는 경우 드라이버는 주어진 &lt;code&gt;Calendar&lt;/code&gt; 개체를 사용 하여 데이터베이스로 보낼 SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; 값을 구성 합니다. A를 &lt;code&gt;Calendar&lt;/code&gt; 사용자 정의 시간대를 계정에 객체, 드라이버는 타임 스탬프 복용을 계산할 수 있습니다. &lt;code&gt;Calendar&lt;/code&gt; 개체가 지정 되지 않은 경우 드라이버는 응용 프로그램을 실행하는 가상 시스템의 표준 시간대를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e2b0cfb7cdca209b8227f0135c9ead5e644da49f" translate="yes" xml:space="preserve">
          <source>When the JNDI class library needs to determine the value of a property, it does so by merging the values from the following two sources, in order:</source>
          <target state="translated">JNDI 클래스 라이브러리가 특성 값을 판별해야하는 경우 다음 두 소스의 값을 순서대로 병합하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8ff307d52b74a9d5a00fe0eeed0ad2b6f63f945d" translate="yes" xml:space="preserve">
          <source>When the JVM materializes a &lt;code&gt;MethodType&lt;/code&gt; from a descriptor string, all classes named in the descriptor must be accessible, and will be loaded. (But the classes need not be initialized, as is the case with a &lt;code&gt;CONSTANT_Class&lt;/code&gt;.) This loading may occur at any time before the &lt;code&gt;MethodType&lt;/code&gt; object is first derived.</source>
          <target state="translated">JVM 이 설명자 문자열에서 &lt;code&gt;MethodType&lt;/code&gt; 을 구체화 할 때 설명자에 이름이 지정된 모든 클래스에 액세스 할 수 있어야하며로드됩니다. (그러나 &lt;code&gt;CONSTANT_Class&lt;/code&gt; 의 경우와 같이 클래스를 초기화 할 필요는 없습니다 .)이 로딩은 &lt;code&gt;MethodType&lt;/code&gt; 객체가 처음 파생 되기 전에 언제든지 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="242f542a50d3a5d71e04513db113467fef250729" translate="yes" xml:space="preserve">
          <source>When the JVM processes bytecode containing signature polymorphic calls, it will successfully link any such call, regardless of its symbolic type descriptor. (In order to retain type safety, the JVM will guard such calls with suitable dynamic type checks, as described elsewhere.)</source>
          <target state="translated">JVM이 서명 다형성 호출을 포함하는 바이트 코드를 처리 할 때 기호 유형 설명자에 관계없이 해당 호출을 성공적으로 링크합니다. (유형 안전을 유지하기 위해 JVM은 다른 곳에서 설명 된대로 적절한 동적 유형 검사로 이러한 호출을 보호합니다.)</target>
        </trans-unit>
        <trans-unit id="2193c7a9c7d458a9821bb858408d7793d0ae7d86" translate="yes" xml:space="preserve">
          <source>When the Java Virtual Machine first starts, it determines if the system property &lt;code&gt;java.compiler&lt;/code&gt; exists. (System properties are accessible through &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt;&lt;code&gt;System.getProperty(String)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;system#getProperty-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;System.getProperty(String, String)&lt;/code&gt;&lt;/a&gt;. If so, it is assumed to be the name of a library (with a platform-dependent exact location and type); &lt;a href=&quot;system#loadLibrary-java.lang.String-&quot;&gt;&lt;code&gt;System.loadLibrary(java.lang.String)&lt;/code&gt;&lt;/a&gt; is called to load that library. If this loading succeeds, the function named &lt;code&gt;java_lang_Compiler_start()&lt;/code&gt; in that library is called.</source>
          <target state="translated">JVM (Java Virtual Machine)이 처음 시작되면 시스템 특성 &lt;code&gt;java.compiler&lt;/code&gt; 가 존재 하는지 판별 합니다. (시스템 특성은 &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt; &lt;code&gt;System.getProperty(String)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;system#getProperty-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;System.getProperty(String, String)&lt;/code&gt; &lt;/a&gt; 통해 액세스 할 수 있습니다 . 그렇다면, 플랫폼의 정확한 위치 및 유형을 가진 라이브러리 이름 인 것으로 간주됩니다. &lt;a href=&quot;system#loadLibrary-java.lang.String-&quot;&gt; &lt;code&gt;System.loadLibrary(java.lang.String)&lt;/code&gt; &lt;/a&gt; 해당 라이브러리를로드하기 위해 (java.lang.String) 이 호출됩니다.로드가 성공하면 해당 라이브러리에서 &lt;code&gt;java_lang_Compiler_start()&lt;/code&gt; 라는 함수 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ddddab91c8fcafe94a4c994027d61bf864bf4c44" translate="yes" xml:space="preserve">
          <source>When the Java virtual machine has no stack trace information about a thread or &lt;code&gt;maxDepth == 0&lt;/code&gt;, the stack trace in the &lt;code&gt;ThreadInfo&lt;/code&gt; object will be an empty array of &lt;code&gt;StackTraceElement&lt;/code&gt;.</source>
          <target state="translated">Java 가상 머신에 스레드 또는 &lt;code&gt;maxDepth == 0&lt;/code&gt; 에 대한 스택 추적 정보가없는 경우 &lt;code&gt;ThreadInfo&lt;/code&gt; 객체 의 스택 추적 은 &lt;code&gt;StackTraceElement&lt;/code&gt; 의 빈 배열이 됩니다.</target>
        </trans-unit>
        <trans-unit id="38db82049f33225d933e0b41a46907899f2d6c86" translate="yes" xml:space="preserve">
          <source>When the LoginContext uses the installed Configuration (instead of a caller-specified Configuration, see above), then this LoginContext must wrap any caller-specified or default CallbackHandler implementation in a new CallbackHandler implementation whose &lt;code&gt;handle&lt;/code&gt; method implementation invokes the specified CallbackHandler's &lt;code&gt;handle&lt;/code&gt; method in a &lt;code&gt;java.security.AccessController.doPrivileged&lt;/code&gt; call constrained by the caller's current &lt;code&gt;AccessControlContext&lt;/code&gt;.</source>
          <target state="translated">LoginContext에 설치된 구성 (대신 발신자가 지정한 구성의, 위 참조)를 사용하는 경우,이 LoginContext에서는 그의 새로운 해 CallbackHandler 구현에 호출자 지정 또는 디폴트의 CallbackHandler 구현을 포장해야한다 &lt;code&gt;handle&lt;/code&gt; 방법을 구현 지정된 해 CallbackHandler의 호출 &lt;code&gt;handle&lt;/code&gt; A의 방법을 &lt;code&gt;java.security.AccessController.doPrivileged&lt;/code&gt; 호출은 호출자의 현재 &lt;code&gt;AccessControlContext&lt;/code&gt; 에 의해 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="5cf48683ff79ab19b22e2f40ce14d8b39cb8a4f9" translate="yes" xml:space="preserve">
          <source>When the MAX and MIN bounds are hit</source>
          <target state="translated">MAX 및 MIN 경계에 도달하면</target>
        </trans-unit>
        <trans-unit id="d4284eca7ac5f100fd0fbfcaaa47ff80683f124b" translate="yes" xml:space="preserve">
          <source>When the OOBINLINE option is set, any TCP urgent data received on the socket will be received through the socket input stream.</source>
          <target state="translated">OOBINLINE 옵션이 설정되면 소켓에 수신 된 TCP 긴급 데이터는 소켓 입력 스트림을 통해 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="59ad08ab5cdf3a4c4f05c736af38894997dad527" translate="yes" xml:space="preserve">
          <source>When the OOBINLINE option is set, any TCP urgent data received on the socket will be received through the socket input stream. When the option is disabled (which is the default) urgent data is silently discarded.</source>
          <target state="translated">OOBINLINE 옵션이 설정되면 소켓에서 수신 된 모든 TCP 긴급 데이터는 소켓 입력 스트림을 통해 수신됩니다. 옵션이 비활성화되면 (기본값) 긴급 데이터는 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="9833dcc09e733a827020ccf648bcb6cd4665e7ef" translate="yes" xml:space="preserve">
          <source>When the Open Type is &lt;code&gt;CompositeType&lt;/code&gt;, the corresponding mapped Java type (&lt;em&gt;opendata(J)&lt;/em&gt;) is &lt;a href=&quot;openmbean/compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt;. The mapping from an instance of &lt;em&gt;J&lt;/em&gt; to a &lt;code&gt;CompositeData&lt;/code&gt; corresponding to the &lt;code&gt;CompositeType&lt;/code&gt; just described is done as follows. First, if &lt;em&gt;J&lt;/em&gt; implements the interface &lt;a href=&quot;openmbean/compositedataview&quot;&gt;&lt;code&gt;CompositeDataView&lt;/code&gt;&lt;/a&gt;, then that interface's &lt;a href=&quot;openmbean/compositedataview#toCompositeData(javax.management.openmbean.CompositeType)&quot;&gt;&lt;code&gt;toCompositeData&lt;/code&gt;&lt;/a&gt; method is called to do the conversion. Otherwise, the &lt;code&gt;CompositeData&lt;/code&gt; is constructed by calling the getter for each item and converting it to the corresponding Open Data type. Thus, a getter such as</source>
          <target state="translated">Open Type이 &lt;code&gt;CompositeType&lt;/code&gt; 이면 해당 매핑 된 Java 유형 ( &lt;em&gt;opendata (J)&lt;/em&gt; )은 &lt;a href=&quot;openmbean/compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt; 입니다. 인스턴스의 매핑 &lt;em&gt;J&lt;/em&gt; (A)에 &lt;code&gt;CompositeData&lt;/code&gt; 에 대응 &lt;code&gt;CompositeType&lt;/code&gt; 와 다음처럼 설명이 이루어진다. 먼저 &lt;em&gt;J가 &lt;/em&gt;&lt;a href=&quot;openmbean/compositedataview&quot;&gt; &lt;code&gt;CompositeDataView&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하면 해당 인터페이스의 &lt;a href=&quot;openmbean/compositedataview#toCompositeData(javax.management.openmbean.CompositeType)&quot;&gt; &lt;code&gt;toCompositeData&lt;/code&gt; &lt;/a&gt; 메서드가 호출되어 변환을 수행합니다. 그렇지 않으면 각 항목에 대해 getter를 호출하고 해당 Open Data 유형으로 변환 하여 &lt;code&gt;CompositeData&lt;/code&gt; 를 구성합니다. 따라서 다음과 같은 게터</target>
        </trans-unit>
        <trans-unit id="dabf2aef104d7b63f254f09d8ef274526085868a" translate="yes" xml:space="preserve">
          <source>When the Open Type is &lt;code&gt;CompositeType&lt;/code&gt;, the corresponding mapped Java type (&lt;em&gt;opendata(J)&lt;/em&gt;) is &lt;a href=&quot;openmbean/compositedata&quot;&gt;&lt;code&gt;CompositeData&lt;/code&gt;&lt;/a&gt;. The mapping from an instance of &lt;em&gt;J&lt;/em&gt; to a &lt;code&gt;CompositeData&lt;/code&gt; corresponding to the &lt;code&gt;CompositeType&lt;/code&gt; just described is done as follows. First, if &lt;em&gt;J&lt;/em&gt; implements the interface &lt;a href=&quot;openmbean/compositedataview&quot;&gt;&lt;code&gt;CompositeDataView&lt;/code&gt;&lt;/a&gt;, then that interface's &lt;a href=&quot;openmbean/compositedataview#toCompositeData-javax.management.openmbean.CompositeType-&quot;&gt;&lt;code&gt;toCompositeData&lt;/code&gt;&lt;/a&gt; method is called to do the conversion. Otherwise, the &lt;code&gt;CompositeData&lt;/code&gt; is constructed by calling the getter for each item and converting it to the corresponding Open Data type. Thus, a getter such as</source>
          <target state="translated">Open Type이 &lt;code&gt;CompositeType&lt;/code&gt; 인 경우, 대응하는 맵핑 된 Java 유형 ( &lt;em&gt;opendata (J)&lt;/em&gt; )은 &lt;a href=&quot;openmbean/compositedata&quot;&gt; &lt;code&gt;CompositeData&lt;/code&gt; &lt;/a&gt; 입니다. 인스턴스의 매핑 &lt;em&gt;J&lt;/em&gt; (A)에 &lt;code&gt;CompositeData&lt;/code&gt; 에 대응 &lt;code&gt;CompositeType&lt;/code&gt; 와 다음처럼 설명이 이루어진다. 먼저 &lt;em&gt;J가 &lt;/em&gt;&lt;a href=&quot;openmbean/compositedataview&quot;&gt; &lt;code&gt;CompositeDataView&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하면 해당 인터페이스의 &lt;a href=&quot;openmbean/compositedataview#toCompositeData-javax.management.openmbean.CompositeType-&quot;&gt; &lt;code&gt;toCompositeData&lt;/code&gt; &lt;/a&gt; 메소드가 호출되어 변환을 수행합니다. 그렇지 않으면 각 항목에 대해 getter를 호출하고 해당 Open Data 유형으로 변환 하여 &lt;code&gt;CompositeData&lt;/code&gt; 를 구성합니다. 따라서 다음과 같은 게터</target>
        </trans-unit>
        <trans-unit id="6807cd6ed53e44e911717bb50e25ffb553b8f9ce" translate="yes" xml:space="preserve">
          <source>When the access permissions are set at file creation time then the actual value of the permissions may differ that the value of the attribute object. The reasons for this are implementation specific. On UNIX systems, for example, a process has a &lt;em&gt;umask&lt;/em&gt; that impacts the permission bits of newly created files. Where an implementation supports the setting of the access permissions, and the underlying file system supports access permissions, then it is required that the value of the actual access permissions will be equal or less than the value of the attribute provided to the &lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; methods. In other words, the file may be more secure than requested.</source>
          <target state="translated">파일 생성시 액세스 권한이 설정되면 권한의 실제 값이 속성 개체의 값과 다를 수 있습니다. 그 이유는 구현에 따라 다릅니다. 예를 들어 UNIX 시스템에서 프로세스에는 새로 생성 된 파일의 권한 비트에 영향 을주는 &lt;em&gt;umask&lt;/em&gt; 가 있습니다. 구현이 액세스 권한 설정을 지원하고 기본 파일 시스템이 액세스 권한을 지원하는 경우 실제 액세스 권한 값은 &lt;a href=&quot;../files#createFile(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../files#createDirectory(java.nio.file.Path,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt; 메소드에 제공된 속성 값보다 작거나 같아야 합니다. . 즉, 파일이 요청 된 것보다 더 안전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cc6a806fe924f827c1be349c2dda336ff41691d" translate="yes" xml:space="preserve">
          <source>When the access permissions are set at file creation time then the actual value of the permissions may differ that the value of the attribute object. The reasons for this are implementation specific. On UNIX systems, for example, a process has a &lt;em&gt;umask&lt;/em&gt; that impacts the permission bits of newly created files. Where an implementation supports the setting of the access permissions, and the underlying file system supports access permissions, then it is required that the value of the actual access permissions will be equal or less than the value of the attribute provided to the &lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createFile&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;createDirectory&lt;/code&gt;&lt;/a&gt; methods. In other words, the file may be more secure than requested.</source>
          <target state="translated">파일 작성시 액세스 권한이 설정되면 권한의 실제 값이 속성 오브젝트의 값과 다를 수 있습니다. 그 이유는 구현에 따라 다릅니다. 예를 들어, UNIX 시스템에서 프로세스에는 새로 작성된 파일의 권한 비트에 영향 을주는 &lt;em&gt;umask&lt;/em&gt; 가 있습니다. 구현이 액세스 권한 설정을 지원하고 기본 파일 시스템이 액세스 권한을 지원하는 경우 실제 액세스 권한의 값은 &lt;a href=&quot;../files#createFile-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createFile&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../files#createDirectory-java.nio.file.Path-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;createDirectory&lt;/code&gt; &lt;/a&gt; 메소드에 제공된 속성 값보다 작거나 같아야 합니다. . 즉, 파일이 요청 된 것보다 안전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69569ad21e8363df8daeddf8b551ab74285ca4d0" translate="yes" xml:space="preserve">
          <source>When the adapter is called, the length of the supplied &lt;code&gt;array&lt;/code&gt; argument is queried as if by &lt;code&gt;array.length&lt;/code&gt; or &lt;code&gt;arraylength&lt;/code&gt; bytecode. If the adapter accepts a zero-length trailing array argument, the supplied &lt;code&gt;array&lt;/code&gt; argument can either be a zero-length array or &lt;code&gt;null&lt;/code&gt;; otherwise, the adapter will throw a &lt;code&gt;NullPointerException&lt;/code&gt; if the array is &lt;code&gt;null&lt;/code&gt; and throw an &lt;a href=&quot;../illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; if the array does not have the correct number of elements.</source>
          <target state="translated">어댑터가 호출되면 제공된 &lt;code&gt;array&lt;/code&gt; 인수 의 길이 가 &lt;code&gt;array.length&lt;/code&gt; 또는 &lt;code&gt;arraylength&lt;/code&gt; 바이트 코드 에서처럼 쿼리됩니다 . 어댑터가 길이가 0 인 후행 배열 인수를 허용하는 경우 제공된 &lt;code&gt;array&lt;/code&gt; 인수는 길이가 0 인 배열이거나 &lt;code&gt;null&lt;/code&gt; 일 수 있습니다 . 그렇지 않으면 어댑터는 배열이 &lt;code&gt;null&lt;/code&gt; 인 경우 &lt;code&gt;NullPointerException&lt;/code&gt; 을 throw 하고 배열에 올바른 요소 수가 없으면 &lt;a href=&quot;../illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을&lt;/a&gt; throw합니다 .</target>
        </trans-unit>
        <trans-unit id="f27103f429183890d7b676c4e6d53958062dc5b7" translate="yes" xml:space="preserve">
          <source>When the application provides a filter, the serializer will call out to the filter before serializing each Node.</source>
          <target state="translated">응용 프로그램이 필터를 제공하면 직렬 변환기는 각 노드를 직렬화하기 전에 필터를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="eafdeecdd692ae88f791f406318133fd82c05cf0" translate="yes" xml:space="preserve">
          <source>When the application provides a filter, the serializer will call out to the filter before serializing each Node. The filter implementation can choose to remove the node from the stream or to terminate the serialization early.</source>
          <target state="translated">응용 프로그램이 필터를 제공하면 직렬 변환기는 각 노드를 직렬화하기 전에 필터를 호출합니다. 필터 구현은 스트림에서 노드를 제거하거나 직렬화를 조기에 종료하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b18b14612d284db82e4ae58a49b67bd2c4968f17" translate="yes" xml:space="preserve">
          <source>When the attribute at the head of the stream is an SQL &lt;code&gt;NULL&lt;/code&gt; the method returns &lt;code&gt;null&lt;/code&gt;. If the attribute is an SQL structured or distinct type, it determines the SQL type of the attribute at the head of the stream. If the stream's type map has an entry for that SQL type, the driver constructs an object of the appropriate class and calls the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; on that object, which reads additional data from the stream, using the protocol described for that method.</source>
          <target state="translated">스트림의 헤드에있는 속성이 SQL &lt;code&gt;NULL&lt;/code&gt; 이면 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 속성이 SQL 구조화 또는 고유 한 유형 인 경우 스트림의 헤드에있는 속성의 SQL 유형을 판별합니다. 스트림의 유형 맵에 해당 SQL 유형에 대한 항목이있는 경우 드라이버는 해당 클래스의 개체를 생성하고 해당 개체에 대해 &lt;code&gt;SQLData.readSQL&lt;/code&gt; 메서드 를 호출하여 해당 메서드 에 대해 설명 된 프로토콜을 사용하여 스트림에서 추가 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="67e1e670368e0408444ca57de73d1a38a08a71cb" translate="yes" xml:space="preserve">
          <source>When the client is running a later version than the server, certain newer features may not be available, as detailed in the next sections. The client can determine the server's version by examining the &lt;a href=&quot;mbeanserverdelegatembean#getSpecificationVersion()&quot;&gt;&lt;code&gt;SpecificationVersion&lt;/code&gt;&lt;/a&gt; attribute of the &lt;code&gt;
        MBeanServerDelegate&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 서버보다 최신 버전을 실행중인 경우 다음 섹션에서 자세히 설명하는 특정 최신 기능을 사용하지 못할 수 있습니다. 클라이언트는 &lt;code&gt; MBeanServerDelegate&lt;/code&gt; 의 &lt;a href=&quot;mbeanserverdelegatembean#getSpecificationVersion()&quot;&gt; &lt;code&gt;SpecificationVersion&lt;/code&gt; &lt;/a&gt; 속성을 검사하여 서버의 버전을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3dd6047101821af20c03ece3438348c43a2a0666" translate="yes" xml:space="preserve">
          <source>When the client is running a later version than the server, certain newer features may not be available, as detailed in the next sections. The client can determine the server's version by examining the &lt;a href=&quot;mbeanserverdelegatembean#getSpecificationVersion--&quot;&gt;&lt;code&gt;SpecificationVersion&lt;/code&gt;&lt;/a&gt; attribute of the &lt;code&gt;MBeanServerDelegate&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 서버보다 최신 버전을 실행하는 경우 다음 섹션에서 자세히 설명하는 것처럼 특정 최신 기능을 사용하지 못할 수 있습니다. 클라이언트는 &lt;code&gt;MBeanServerDelegate&lt;/code&gt; 의 &lt;a href=&quot;mbeanserverdelegatembean#getSpecificationVersion--&quot;&gt; &lt;code&gt;SpecificationVersion&lt;/code&gt; &lt;/a&gt; 속성을 검사하여 서버의 버전을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5656bb0d523a39fd577359655a0712dc9a981a5c" translate="yes" xml:space="preserve">
          <source>When the condition &lt;a href=&quot;condition#await()&quot;&gt;waiting&lt;/a&gt; methods are called the lock is released and, before they return, the lock is reacquired and the lock hold count restored to what it was when the method was called.</source>
          <target state="translated">조건 &lt;a href=&quot;condition#await()&quot;&gt;대기&lt;/a&gt; 메서드가 호출되면 잠금이 해제되고 반환되기 전에 잠금이 다시 획득되고 잠금 보유 횟수가 메서드가 호출되었을 때의 값으로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="d87e1d90469eb807a66798a3412565993b14ba79" translate="yes" xml:space="preserve">
          <source>When the condition &lt;a href=&quot;condition#await()&quot;&gt;waiting&lt;/a&gt; methods are called the write lock is released and, before they return, the write lock is reacquired and the lock hold count restored to what it was when the method was called.</source>
          <target state="translated">조건 &lt;a href=&quot;condition#await()&quot;&gt;대기&lt;/a&gt; 메서드가 호출되면 쓰기 잠금이 해제되고 반환되기 전에 쓰기 잠금이 다시 획득되고 잠금 보유 횟수가 메서드가 호출되었을 때의 값으로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="5b2259ec0cf9dd1eabb68562ba1068a405b4ffb3" translate="yes" xml:space="preserve">
          <source>When the condition &lt;a href=&quot;condition#await--&quot;&gt;waiting&lt;/a&gt; methods are called the lock is released and, before they return, the lock is reacquired and the lock hold count restored to what it was when the method was called.</source>
          <target state="translated">조건 &lt;a href=&quot;condition#await--&quot;&gt;대기&lt;/a&gt; 메소드가 호출되면 잠금이 해제되고 리턴되기 전에 잠금이 다시 획득되고 잠금 보류 계수가 메소드 호출 당시의 상태로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="79dff109a2169a02dd1a4794f9a2ae88690f5d47" translate="yes" xml:space="preserve">
          <source>When the condition &lt;a href=&quot;condition#await--&quot;&gt;waiting&lt;/a&gt; methods are called the write lock is released and, before they return, the write lock is reacquired and the lock hold count restored to what it was when the method was called.</source>
          <target state="translated">조건 &lt;a href=&quot;condition#await--&quot;&gt;대기&lt;/a&gt; 메소드가 호출 잠금으로 해제되고 리턴되기 전에 쓰기 잠금이 재 취득되고 잠금 보류 계수가 메소드 호출 당시의 상태로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="16423c8ea158b78447a1469fc88d081d49349aa7" translate="yes" xml:space="preserve">
          <source>When the connection is no longer needed, the client and server applications should each close both sides of their respective connection. For &lt;code&gt;SSLSocket&lt;/code&gt; objects, for example, an application can call &lt;a href=&quot;../../../java/net/socket#shutdownOutput()&quot;&gt;&lt;code&gt;Socket.shutdownOutput()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../java/io/outputstream#close()&quot;&gt;&lt;code&gt;OutputStream.close()&lt;/code&gt;&lt;/a&gt; for output strean close and call &lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt;&lt;code&gt;Socket.shutdownInput()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../java/io/inputstream#close()&quot;&gt;&lt;code&gt;InputStream.close()&lt;/code&gt;&lt;/a&gt; for input stream close. Note that in some cases, closing the input stream may depend on the peer's output stream being closed first. If the connection is not closed in an orderly manner (for example &lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt;&lt;code&gt;Socket.shutdownInput()&lt;/code&gt;&lt;/a&gt; is called before the peer's write closure notification has been received), exceptions may be raised to indicate that an error has occurred. Once an &lt;code&gt;SSLSocket&lt;/code&gt; is closed, it is not reusable: a new &lt;code&gt;SSLSocket&lt;/code&gt; must be created.</source>
          <target state="translated">연결이 더 이상 필요하지 않은 경우 클라이언트 및 서버 응용 프로그램은 각각 연결의 양쪽을 모두 닫아야합니다. 예 를 들어 &lt;code&gt;SSLSocket&lt;/code&gt; 객체의 경우 애플리케이션은 출력 스트림 닫기를 위해 &lt;a href=&quot;../../../java/net/socket#shutdownOutput()&quot;&gt; &lt;code&gt;Socket.shutdownOutput()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java/io/outputstream#close()&quot;&gt; &lt;code&gt;OutputStream.close()&lt;/code&gt; &lt;/a&gt; 를 호출 하고 입력 스트림 닫기를 위해 &lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt; &lt;code&gt;Socket.shutdownInput()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java/io/inputstream#close()&quot;&gt; &lt;code&gt;InputStream.close()&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다 . 경우에 따라 입력 스트림을 닫는 것은 피어의 출력 스트림이 먼저 닫히는 것에 따라 달라질 수 있습니다. 연결이 순서대로 닫히지 않은 경우 (예 : &lt;a href=&quot;../../../java/net/socket#shutdownInput()&quot;&gt; &lt;code&gt;Socket.shutdownInput()&lt;/code&gt; &lt;/a&gt;피어의 쓰기 종료 알림이 수신되기 전에 호출 됨) 오류가 발생했음을 나타내는 예외가 발생할 수 있습니다. 일단 &lt;code&gt;SSLSocket&lt;/code&gt; 닫혀, 그것은 재사용되지 않습니다 : 새 &lt;code&gt;SSLSocket&lt;/code&gt; 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0cd6246ef32e2e28cb6a34b88aea8b151567df6" translate="yes" xml:space="preserve">
          <source>When the context is no longer needed, the application should call &lt;a href=&quot;#dispose()&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; to release any system resources the context may be using.</source>
          <target state="translated">컨텍스트가 더 이상 필요하지 않은 경우 응용 프로그램은 &lt;a href=&quot;#dispose()&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt; 를 호출 하여 컨텍스트에서 사용할 수있는 시스템 리소스를 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c9937e2f6e05020b636f955f2f392f42a8a5be9" translate="yes" xml:space="preserve">
          <source>When the datum at the head of the stream is an SQL &lt;code&gt;NULL&lt;/code&gt;, the method returns &lt;code&gt;null&lt;/code&gt;. If the datum is an SQL structured or distinct type, it determines the SQL type of the datum at the head of the stream. If the stream's type map has an entry for that SQL type, the driver constructs an object of the appropriate class and calls the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; on that object, which reads additional data from the stream, using the protocol described for that method.</source>
          <target state="translated">스트림의 헤드에있는 데이터가 SQL &lt;code&gt;NULL&lt;/code&gt; 인 경우 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 데이터가 SQL 구조화 된 유형이거나 고유 한 유형 인 경우 스트림의 선두에있는 데이터의 SQL 유형을 결정합니다. 스트림의 유형 맵에 해당 SQL 유형에 대한 항목이있는 경우 드라이버는 적절한 클래스의 객체를 생성하고 해당 객체에 대해 &lt;code&gt;SQLData.readSQL&lt;/code&gt; 메서드 를 호출하여 해당 메서드 에 대해 설명 된 프로토콜을 사용하여 스트림에서 추가 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="1c57fa8db99fc971d583cc8742f486aed25eac72" translate="yes" xml:space="preserve">
          <source>When the datum at the head of the stream is an SQL &lt;code&gt;NULL&lt;/code&gt;, this method returns &lt;code&gt;null&lt;/code&gt;. If the datum is an SQL structured or distinct type with a custom mapping, this method determines the SQL type of the datum at the head of the stream, constructs an object of the appropriate class, and calls the method &lt;code&gt;SQLData.readSQL&lt;/code&gt; on that object. The &lt;code&gt;readSQL&lt;/code&gt; method then calls the appropriate &lt;code&gt;SQLInputImpl.readXXX&lt;/code&gt; methods to retrieve the attribute values from the stream.</source>
          <target state="translated">스트림의 헤드에있는 데이터가 SQL &lt;code&gt;NULL&lt;/code&gt; 인 경우이 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 데이텀이 사용자 지정 매핑이있는 SQL 구조화 또는 고유 한 유형 인 경우이 메서드는 스트림의 헤드에서 데이텀의 SQL 유형을 결정하고 적절한 클래스의 개체를 생성하고 해당 개체에 대해 &lt;code&gt;SQLData.readSQL&lt;/code&gt; 메서드 를 호출 합니다. &lt;code&gt;readSQL&lt;/code&gt; 가 된 후, 방법은 적절한 호출 &lt;code&gt;SQLInputImpl.readXXX&lt;/code&gt; 의 스트림으로부터 속성 값을 검색하는 방법.</target>
        </trans-unit>
        <trans-unit id="0207ee2dfd538e974d952ff6af0b2a657d033d63" translate="yes" xml:space="preserve">
          <source>When the dialog is shown, the specified file is selected. The kind of selection depends on the file existence, the dialog type, and the native platform. E.g., the file could be highlighted in the file list, or a file name editbox could be populated with the file name.</source>
          <target state="translated">대화 상자가 표시되면 지정된 파일이 선택됩니다. 선택 유형은 파일 존재, 대화 상자 유형 및 기본 플랫폼에 따라 다릅니다. 예를 들어, 파일 목록에서 파일을 강조 표시하거나 파일 이름 편집 상자에 파일 이름을 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c397667a78f1a660562462490477701fa7482ccb" translate="yes" xml:space="preserve">
          <source>When the driver determines that the &lt;code&gt;setNetworkTimeout&lt;/code&gt; timeout value has expired, the JDBC driver marks the connection closed and releases any resources held by the connection.</source>
          <target state="translated">드라이버가 &lt;code&gt;setNetworkTimeout&lt;/code&gt; 시간 초과 값이 만료되었음을 확인하면 JDBC 드라이버는 연결이 닫힌 상태로 표시하고 연결이 보유한 모든 리소스를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="4cd824f5c7e1568ccbcd115d44b4eb96a3accf69" translate="yes" xml:space="preserve">
          <source>When the environment property &quot;java.naming.factory.initial&quot; is non-null, the InitialContext constructor will attempt to create the initial context specified therein. At that time, the initial context factory involved might throw an exception if a problem is encountered. However, it is provider implementation-dependent when it verifies and indicates to the users of the initial context any environment property- or connection- related problems. It can do so lazily--delaying until an operation is performed on the context, or eagerly, at the time the context is constructed.</source>
          <target state="translated">환경 특성 &quot;java.naming.factory.initial&quot;이 널이 아닌 경우 InitialContext 생성자는 지정된 초기 컨텍스트를 작성하려고 시도합니다. 이때 문제가 발생하면 관련된 초기 컨텍스트 팩토리에서 예외가 발생할 수 있습니다. 그러나 초기 컨텍스트 사용자에게 환경 특성 또는 연결 관련 문제점을 확인하고 표시 할 때 제공자 구현에 따라 다릅니다. 컨텍스트에서 작업이 수행 될 때까지 또는 컨텍스트가 구성 될 때 간절히 지연 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e1fbcb7e24cac03595809d83a43116184df4d35" translate="yes" xml:space="preserve">
          <source>When the feature is &lt;code&gt;false&lt;/code&gt;, the implementation will processing XML according to the XML specifications without regard to possible implementation limits.</source>
          <target state="translated">기능이 &lt;code&gt;false&lt;/code&gt; 인 경우 구현은 가능한 구현 제한에 관계없이 XML 사양에 따라 XML을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="09c83d44797e06cf825594da62f38b3618a765cb" translate="yes" xml:space="preserve">
          <source>When the file system uses an ACL model that differs from the NFSv4 defined ACL model, then this method returns an ACL that is the translation of the ACL to the NFSv4 ACL model.</source>
          <target state="translated">파일 시스템이 NFSv4 정의 ACL 모델과 다른 ACL 모델을 사용하는 경우이 메소드는 ACL을 NFSv4 ACL 모델로 변환하는 ACL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="34c8ca9cd568392c4eb67ef03c9038a10b794d59" translate="yes" xml:space="preserve">
          <source>When the initial context is constructed, its environment is initialized with properties defined in the environment parameter passed to the constructor, and in any &lt;a href=&quot;context#RESOURCEFILES&quot; id=&quot;ENVIRONMENT&quot;&gt;application resource files&lt;/a&gt;. In addition, a small number of standard JNDI properties may be specified as system properties or as applet parameters (through the use of &lt;a href=&quot;context#APPLET&quot;&gt;&lt;code&gt;Context.APPLET&lt;/code&gt;&lt;/a&gt;). These special properties are listed in the field detail sections of the &lt;a href=&quot;context#field_detail&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ldap/ldapcontext#field_detail&quot;&gt;&lt;code&gt;LdapContext&lt;/code&gt;&lt;/a&gt; interface documentation.</source>
          <target state="translated">초기 컨텍스트가 구성되면 해당 환경은 생성자에 전달 된 environment 매개 변수 및 모든 &lt;a href=&quot;context#RESOURCEFILES&quot; id=&quot;ENVIRONMENT&quot;&gt;애플리케이션 자원 파일에&lt;/a&gt; 정의 된 특성으로 초기화됩니다 . 또한 적은 수의 표준 JNDI 특성을 시스템 특성 또는 애플릿 매개 변수로 지정할 수 있습니다 ( &lt;a href=&quot;context#APPLET&quot;&gt; &lt;code&gt;Context.APPLET&lt;/code&gt; &lt;/a&gt; 사용 ). 이러한 특수 특성은 &lt;a href=&quot;context#field_detail&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ldap/ldapcontext#field_detail&quot;&gt; &lt;code&gt;LdapContext&lt;/code&gt; &lt;/a&gt; 인터페이스 문서 의 필드 세부 사항 섹션에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f2e2ab8bd29748019ef4bf990564b30618f21a2" translate="yes" xml:space="preserve">
          <source>When the initial context is constructed, its environment is initialized with properties defined in the environment parameter passed to the constructor, and in any &lt;a href=&quot;context#RESOURCEFILES&quot;&gt;application resource files&lt;/a&gt;.</source>
          <target state="translated">초기 컨텍스트가 생성되면 해당 환경은 생성자에 전달 된 환경 매개 변수와 모든 &lt;a href=&quot;context#RESOURCEFILES&quot;&gt;애플리케이션 리소스 파일에&lt;/a&gt; 정의 된 속성으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="696a039c384cd3258c09a0ffb67d7220e4c8e54b" translate="yes" xml:space="preserve">
          <source>When the intern method is invoked, if the pool already contains a string equal to this &lt;code&gt;String&lt;/code&gt; object as determined by the &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;&lt;code&gt;equals(Object)&lt;/code&gt;&lt;/a&gt; method, then the string from the pool is returned. Otherwise, this &lt;code&gt;String&lt;/code&gt; object is added to the pool and a reference to this &lt;code&gt;String&lt;/code&gt; object is returned.</source>
          <target state="translated">인턴 메서드가 호출 될 때 풀 에 &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt; &lt;code&gt;equals(Object)&lt;/code&gt; &lt;/a&gt; 메서드에 의해 결정된 &lt;code&gt;String&lt;/code&gt; 객체와 동일한 문자열이 이미 포함되어 있으면 풀 의 문자열이 반환됩니다. 그렇지 않으면,이 &lt;code&gt;String&lt;/code&gt; 객체가 풀에 추가되고이에 대한 참조 &lt;code&gt;String&lt;/code&gt; 객체가 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="3af901ecd46db6d3c503ad63c889dcb1df5223cb" translate="yes" xml:space="preserve">
          <source>When the intern method is invoked, if the pool already contains a string equal to this &lt;code&gt;String&lt;/code&gt; object as determined by the &lt;a href=&quot;string#equals-java.lang.Object-&quot;&gt;&lt;code&gt;equals(Object)&lt;/code&gt;&lt;/a&gt; method, then the string from the pool is returned. Otherwise, this &lt;code&gt;String&lt;/code&gt; object is added to the pool and a reference to this &lt;code&gt;String&lt;/code&gt; object is returned.</source>
          <target state="translated">인턴 메소드가 호출 될 때, &lt;a href=&quot;string#equals-java.lang.Object-&quot;&gt; &lt;code&gt;equals(Object)&lt;/code&gt; &lt;/a&gt; 메소드에 의해 판별 된대로 풀에이 &lt;code&gt;String&lt;/code&gt; 오브젝트와 동일한 문자열이 이미 포함되어 있으면 풀 의 문자열이 리턴됩니다. 그렇지 않으면,이 &lt;code&gt;String&lt;/code&gt; 객체가 풀에 추가되고이에 대한 참조 &lt;code&gt;String&lt;/code&gt; 객체가 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="f8bbc3f973b7168a4616c7de9f75c0600151427a" translate="yes" xml:space="preserve">
          <source>When the job is in the &lt;code&gt;PROCESSING&lt;/code&gt; state, the entire job state includes the detailed status represented in the printer's &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; attributes.</source>
          <target state="translated">작업이 &lt;code&gt;PROCESSING&lt;/code&gt; 상태이면 전체 작업 상태에는 프린터의 &lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt; 속성에 표시된 자세한 상태가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a58835a2387f608fd8e7fa6effa626edf3d2325" translate="yes" xml:space="preserve">
          <source>When the job is in the PROCESSING state, the entire job state includes the detailed status represented in the printer's &lt;a href=&quot;printerstate&quot;&gt;&lt;code&gt;PrinterState&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;printerstatereasons&quot;&gt;&lt;code&gt;PrinterStateReasons&lt;/code&gt;&lt;/a&gt; attributes.</source>
          <target state="translated">작업이 처리 중 상태 인 경우 전체 작업 상태에는 프린터의 &lt;a href=&quot;printerstate&quot;&gt; &lt;code&gt;PrinterState&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;printerstatereasons&quot;&gt; &lt;code&gt;PrinterStateReasons&lt;/code&gt; &lt;/a&gt; 속성에 표시된 상세 상태가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="66a9921b5b8623505ad852c1a7dd9d532fe13cfc" translate="yes" xml:space="preserve">
          <source>When the keepalive option is set for a TCP socket and no data has been exchanged across the socket in either direction for 2 hours (NOTE: the actual value is implementation dependent), TCP automatically sends a keepalive probe to the peer.</source>
          <target state="translated">TCP 소켓에 대해 keepalive 옵션이 설정되고 2 시간 동안 어느 방향 으로든 소켓을 통해 데이터가 교환되지 않은 경우 (참고 : 실제 값은 구현에 따라 다름) TCP는 자동으로 Keepalive 프로브를 피어에 보냅니다.</target>
        </trans-unit>
        <trans-unit id="bb6061dea9059e4de3096353b5e5aab377ef19b3" translate="yes" xml:space="preserve">
          <source>When the keepalive option is set for a TCP socket and no data has been exchanged across the socket in either direction for 2 hours (NOTE: the actual value is implementation dependent), TCP automatically sends a keepalive probe to the peer. This probe is a TCP segment to which the peer must respond. One of three responses is expected: 1. The peer responds with the expected ACK. The application is not notified (since everything is OK). TCP will send another probe following another 2 hours of inactivity. 2. The peer responds with an RST, which tells the local TCP that the peer host has crashed and rebooted. The socket is closed. 3. There is no response from the peer. The socket is closed. The purpose of this option is to detect if the peer host crashes. Valid only for TCP socket: SocketImpl</source>
          <target state="translated">keepalive 옵션이 TCP 소켓에 대해 설정되고 2 시간 동안 어느 방향 으로든 소켓을 통해 데이터가 교환되지 않은 경우 (참고 : 실제 값은 구현에 따라 다름) TCP는 keepalive 프로브를 자동으로 피어에 보냅니다. 이 프로브는 피어가 응답해야하는 TCP 세그먼트입니다. 세 가지 응답 중 하나가 예상됩니다. 1. 피어가 예상 된 ACK로 응답합니다. 응용 프로그램에 알림이 표시되지 않습니다 (모든 것이 정상이므로). TCP는 2 시간 동안 활동이 없으면 다른 프로브를 보냅니다. 2. 피어는 RST로 응답하여 피어 호스트가 충돌하여 재부팅되었음을 로컬 TCP에 알려줍니다. 소켓이 닫혀 있습니다. 3. 피어로부터 응답이 없습니다. 소켓이 닫혀 있습니다. 이 옵션의 목적은 피어 호스트가 충돌하는지 감지하는 것입니다. TCP 소켓에만 유효합니다 : SocketImpl</target>
        </trans-unit>
        <trans-unit id="866732f7e1f1ba8888b09a311866448987c8a922" translate="yes" xml:space="preserve">
          <source>When the languageTag argument contains an extlang subtag, the first such subtag is used as the language, and the primary language subtag and other extlang subtags are ignored:</source>
          <target state="translated">languageTag 인수에 extlang 하위 태그가 포함 된 경우 첫 번째 하위 태그가 언어로 사용되며 기본 언어 하위 태그 및 기타 extlang 하위 태그는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ed36ba14c7223ab42eda132f49f243999c7fe2b2" translate="yes" xml:space="preserve">
          <source>When the listener is notified of an event, the listener may in invoked in a thread other than the one in which &lt;code&gt;addNamingListener()&lt;/code&gt; is executed. Care must be taken when multiple threads are accessing the same &lt;code&gt;EventContext&lt;/code&gt; concurrently. See the &lt;a href=&quot;package-summary#THREADING&quot;&gt;package description&lt;/a&gt; for more information on threading issues.</source>
          <target state="translated">리스너에 이벤트가 통지되면 &lt;code&gt;addNamingListener()&lt;/code&gt; 가 실행 되는 스레드 이외의 스레드에서 리스너가 호출 될 수 있습니다 . 여러 스레드가 동일한 &lt;code&gt;EventContext&lt;/code&gt; 에 동시에 액세스하는 경우주의해야합니다 . 스레딩 문제에 대한 자세한 내용은 &lt;a href=&quot;package-summary#THREADING&quot;&gt;패키지 설명&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d9cde70e42ddbed9e83b6ac5078af513cb772df" translate="yes" xml:space="preserve">
          <source>When the locale has neither script nor extensions, the result is the same as in Java 6 and prior.</source>
          <target state="translated">로케일에 스크립트 나 확장자가 없으면 결과는 Java 6 이전과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1b1fe4c6f5b74a16eccbbff7c89d6b2a2b6653a7" translate="yes" xml:space="preserve">
          <source>When the look and feel is changed, &lt;code&gt;UIManager&lt;/code&gt; alters only the look and feel defaults; the developer and system defaults are not altered by the &lt;code&gt;UIManager&lt;/code&gt; in any way.</source>
          <target state="translated">룩앤필이 변경되면 &lt;code&gt;UIManager&lt;/code&gt; 는 룩앤필 기본값 만 변경합니다. 개발자 및 시스템 기본값은 어떤 식 으로든 &lt;code&gt;UIManager&lt;/code&gt; 에 의해 변경되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="93d0b3309dfdbd682000d72cebceb5604b73431a" translate="yes" xml:space="preserve">
          <source>When the loop is called, the loop input values are saved in locals, to be passed to every clause function. These locals are loop invariant.</source>
          <target state="translated">루프가 호출되면 루프 입력 값이 모든 절 함수에 전달되도록 로컬에 저장됩니다. 이러한 지역은 루프 불변입니다.</target>
        </trans-unit>
        <trans-unit id="007b0e1775e7a297cd0ad9889941a2a02fa5ed07" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;acceptChanges&lt;/code&gt; encounters conflicts, the &lt;code&gt;SyncProvider&lt;/code&gt; object creates a &lt;code&gt;SyncProviderException&lt;/code&gt; object and sets it with the new &lt;code&gt;SyncResolver&lt;/code&gt; object. The method &lt;code&gt;acceptChanges&lt;/code&gt; will throw this exception, which the application can then catch and use to retrieve the &lt;code&gt;SyncResolver&lt;/code&gt; object it contains. The following code snippet uses the &lt;code&gt;SyncProviderException&lt;/code&gt; method &lt;code&gt;getSyncResolver&lt;/code&gt; to get the &lt;code&gt;SyncResolver&lt;/code&gt; object</source>
          <target state="translated">상기 방법의 경우 &lt;code&gt;acceptChanges&lt;/code&gt; 만남 충돌 상기 &lt;code&gt;SyncProvider&lt;/code&gt; 객체가 생성 &lt;code&gt;SyncProviderException&lt;/code&gt; 객체와 함께 새로운 세트를 &lt;code&gt;SyncResolver&lt;/code&gt; 개체. &lt;code&gt;acceptChanges&lt;/code&gt; 메소드 는이 예외를 발생 시키며, 애플리케이션은이를 포착하여 여기에 포함 된 &lt;code&gt;SyncResolver&lt;/code&gt; 오브젝트 를 검색하는 데 사용할 수 있습니다. 다음 코드 스 니펫은 &lt;code&gt;SyncProviderException&lt;/code&gt; 메소드 &lt;code&gt;getSyncResolver&lt;/code&gt; 를 사용 하여 &lt;code&gt;SyncResolver&lt;/code&gt; 객체 를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="761ffe43252810926439462ad9f307e7fa5b5d7e" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;acceptChanges&lt;/code&gt; executes successfully, in addition to writing changes to the data source, it makes the values in the current row be the values in the original row.</source>
          <target state="translated">&lt;code&gt;acceptChanges&lt;/code&gt; 메소드가 성공적으로 실행되면 데이터 소스에 변경 사항을 기록하는 것 외에도 현재 행의 값이 원래 행의 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="eacefaf622ae1cba296aa64de13b41c77b34ebc2" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;acceptChanges&lt;/code&gt; is executed, the &lt;code&gt;CachedRowSet&lt;/code&gt; object's writer, a &lt;code&gt;RowSetWriterImpl&lt;/code&gt; object, is called behind the scenes to write the changes made to the rowset to the underlying data source. The writer is implemented to make a connection to the data source and write updates to it.</source>
          <target state="translated">&lt;code&gt;acceptChanges&lt;/code&gt; 메서드 가 실행되면 &lt;code&gt;CachedRowSet&lt;/code&gt; 개체의 작성기 인 &lt;code&gt;RowSetWriterImpl&lt;/code&gt; 개체가 백그라운드에서 호출되어 행 집합에 대한 변경 내용을 기본 데이터 원본에 기록합니다. 작성기는 데이터 소스에 연결하고 업데이트를 작성하도록 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="f0a87c8c83eb227ae747569302b9215bbb8f49c6" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;getConnection&lt;/code&gt; is called, the &lt;code&gt;DriverManager&lt;/code&gt; will attempt to locate a suitable driver from amongst those loaded at initialization and those loaded explicitly using the same class loader as the current application.</source>
          <target state="translated">&lt;code&gt;getConnection&lt;/code&gt; 메소드 가 호출되면 &lt;code&gt;DriverManager&lt;/code&gt; 는 초기화시로드 된 드라이버와 현재 애플리케이션과 동일한 클래스 로더를 사용하여 명시 적으로로드 된 드라이버 중에서 적절한 드라이버를 찾으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="64b1a414ef040f7d4a015e56bd76285cd50c4d87" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;getObject&lt;/code&gt; is called with an object of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;, the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the SQL type of the UDT being custom mapped. The driver creates an instance of &lt;code&gt;SQLInputImpl&lt;/code&gt;, populating it with the attributes of the UDT. The driver then passes the input stream to the method &lt;code&gt;SQLData.readSQL&lt;/code&gt;, which in turn calls the &lt;code&gt;SQLInputImpl&lt;/code&gt; reader methods to read the attributes from the input stream.</source>
          <target state="translated">방법되면 &lt;code&gt;getObject&lt;/code&gt; 인터페이스를 구현하는 클래스의 객체로 호출 &lt;code&gt;SQLData&lt;/code&gt; , JDBC 드라이버는 메소드 호출을 &lt;code&gt;SQLData.getSQLType&lt;/code&gt; 커스텀 매핑되는 UDT의 SQL 유형을 결정합니다. 드라이버는 &lt;code&gt;SQLInputImpl&lt;/code&gt; 의 인스턴스를 생성 하여 UDT의 속성으로 채 웁니다. 그런 다음 드라이버는 입력 스트림을 &lt;code&gt;SQLData.readSQL&lt;/code&gt; 메소드로 전달하고 , 그러면 &lt;code&gt;SQLInputImpl&lt;/code&gt; 리더 메소드를 호출 하여 입력 스트림에서 속성을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="fc2f4707a729deed0932994b739ae33c7d74de2f" translate="yes" xml:space="preserve">
          <source>When the method &lt;code&gt;getObject&lt;/code&gt; is called with an object of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;, the JDBC driver calls the method &lt;code&gt;SQLData.getSQLType&lt;/code&gt; to determine the SQL type of the user-defined type (UDT) being custom mapped. The driver creates an instance of &lt;code&gt;SQLInput&lt;/code&gt;, populating it with the attributes of the UDT. The driver then passes the input stream to the method &lt;code&gt;SQLData.readSQL&lt;/code&gt;, which in turn calls the &lt;code&gt;SQLInput&lt;/code&gt; reader methods in its implementation for reading the attributes from the input stream.</source>
          <target state="translated">방법 때 &lt;code&gt;getObject&lt;/code&gt; 인터페이스 구현하는 클래스의 객체로 호출 &lt;code&gt;SQLData&lt;/code&gt; 상기 JDBC 드라이버는 메소드 호출 &lt;code&gt;SQLData.getSQLType&lt;/code&gt; 맞춤 매핑되는 사용자 정의 타입 (UDT)의 SQL 타입을 결정한다. 드라이버는 &lt;code&gt;SQLInput&lt;/code&gt; 의 인스턴스를 생성 하여 UDT의 속성으로 채 웁니다. 그런 다음 드라이버는 입력 스트림을 &lt;code&gt;SQLData.readSQL&lt;/code&gt; 메서드로 전달합니다. 그러면 입력 스트림 에서 속성을 읽기 위해 해당 구현에서 &lt;code&gt;SQLInput&lt;/code&gt; 판독기 메서드를 차례로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a7076acb7964a150cbcde4cd84fa0a6df2b7d477" translate="yes" xml:space="preserve">
          <source>When the node being renamed is an &lt;code&gt;Attr&lt;/code&gt; that is attached to an &lt;code&gt;Element&lt;/code&gt;, the node is first removed from the &lt;code&gt;Element&lt;/code&gt; attributes map. Then, once renamed, either by modifying the existing node or creating a new one as described above, it is put back.</source>
          <target state="translated">이름이 변경되는 노드가 &lt;code&gt;Element&lt;/code&gt; 에 연결된 &lt;code&gt;Attr&lt;/code&gt; 인 경우 노드는 먼저 &lt;code&gt;Element&lt;/code&gt; 속성 맵 에서 제거 됩니다. 그런 다음 기존 노드를 수정하거나 위에서 설명한대로 새 노드를 생성하여 이름을 변경하면 다시 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="c89febf12ab0e3c4977c50a6e144102ca2b758a1" translate="yes" xml:space="preserve">
          <source>When the node being renamed is an &lt;code&gt;Element&lt;/code&gt; only the specified attributes are moved, default attributes originated from the DTD are updated according to the new element name. In addition, the implementation may update default attributes from other schemas. Applications should use &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; to guarantee these attributes are up-to-date.</source>
          <target state="translated">이름이 변경되는 노드가 &lt;code&gt;Element&lt;/code&gt; 경우 지정된 속성 만 이동되고 DTD에서 생성 된 기본 속성은 새 요소 이름에 따라 업데이트됩니다. 또한 구현시 다른 스키마의 기본 속성을 업데이트 할 수 있습니다. 응용 프로그램은 &lt;code&gt;Document.normalizeDocument()&lt;/code&gt; 를 사용 하여 이러한 속성이 최신 상태인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3f2c7cd9cb9265342d2a6fc6218dfca1e62cee5" translate="yes" xml:space="preserve">
          <source>When the output method is &quot;xml&quot;, the version value specifies the version of XML to be used for outputting the result tree. The default value for the xml output method is 1.0. When the output method is &quot;html&quot;, the version value indicates the version of the HTML. The default value for the xml output method is 4.0, which specifies that the result should be output as HTML conforming to the HTML 4.0 Recommendation [HTML]. If the output method is &quot;text&quot;, the version property is ignored.</source>
          <target state="translated">출력 방법이 &quot;xml&quot;인 경우 버전 값은 결과 트리를 출력하는 데 사용할 XML 버전을 지정합니다. xml 출력 방법의 기본값은 1.0입니다. 출력 방법이 &quot;html&quot;인 경우 버전 값은 HTML의 버전을 나타냅니다. xml 출력 방법의 기본값은 4.0이며, 결과가 HTML 4.0 권장 사항 [HTML]을 준수하는 HTML로 출력되어야 함을 지정합니다. 출력 방법이 &quot;text&quot;이면 version 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f8a5f29e1d264a025ea5669456267893f0f08fec" translate="yes" xml:space="preserve">
          <source>When the parse fails, use ParsePosition.getErrorIndex() to find out where in the string the parsing failed. The returned error index is the starting offset of the sub-patterns that the string is comparing with. For example, if the parsing string &quot;AAA {0} BBB&quot; is comparing against the pattern &quot;AAD {0} BBB&quot;, the error index is 0. When an error occurs, the call to this method will return null. If the source is null, return an empty array.</source>
          <target state="translated">구문 분석이 실패하면 ParsePosition.getErrorIndex ()를 사용하여 문자열에서 구문 분석이 실패한 위치를 찾으십시오. 반환 된 오류 인덱스는 문자열이 비교하는 하위 패턴의 시작 오프셋입니다. 예를 들어, 구문 분석 문자열 &quot;AAA {0} BBB&quot;가 패턴 &quot;AAD {0} BBB&quot;와 비교되는 경우 오류 색인은 0입니다. 오류가 발생하면이 메소드에 대한 호출은 널을 리턴합니다. 소스가 null의 경우, 비어있는 배열을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="72cc5d6ed97f5b594ccc044348c9065ad0416c01" translate="yes" xml:space="preserve">
          <source>When the parser encounters a word token that has the format of a double precision floating-point number, it treats the token as a number rather than a word, by setting the &lt;code&gt;ttype&lt;/code&gt; field to the value &lt;code&gt;TT_NUMBER&lt;/code&gt; and putting the numeric value of the token into the &lt;code&gt;nval&lt;/code&gt; field.</source>
          <target state="translated">파서가 배정도 부동 소수점 숫자 형식의 단어 토큰을 발견하면 &lt;code&gt;ttype&lt;/code&gt; 필드를 &lt;code&gt;TT_NUMBER&lt;/code&gt; 값 으로 설정하고 토큰 의 숫자 값을 입력하여 토큰을 단어가 아닌 숫자로 처리합니다. &lt;code&gt;nval&lt;/code&gt; 필드.</target>
        </trans-unit>
        <trans-unit id="78bae3a9fd2477af6b829cef33248071afc46dc2" translate="yes" xml:space="preserve">
          <source>When the peer was not able to identify itself (for example; no certificate, the particular cipher suite being used does not support authentication, or no peer authentication was established during SSL handshaking) this exception is thrown.</source>
          <target state="translated">피어가 자신을 식별 할 수없는 경우 (예 : 인증서가없는 경우 사용중인 특정 암호 스위트가 인증을 지원하지 않거나 SSL 핸드 쉐이킹 중에 피어 인증이 설정되지 않은 경우)이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e0488e20002eb573a021336f9689d0df5866d2de" translate="yes" xml:space="preserve">
          <source>When the precision setting is not 0, the rules of &lt;code&gt;BigDecimal&lt;/code&gt; arithmetic are broadly compatible with selected modes of operation of the arithmetic defined in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those standards, &lt;code&gt;BigDecimal&lt;/code&gt; includes many rounding modes, which were mandatory for division in &lt;code&gt;BigDecimal&lt;/code&gt; releases prior to 5. Any conflicts between these ANSI standards and the &lt;code&gt;BigDecimal&lt;/code&gt; specification are resolved in favor of &lt;code&gt;BigDecimal&lt;/code&gt;.</source>
          <target state="translated">정밀도 설정이 0이 아닌 경우 &lt;code&gt;BigDecimal&lt;/code&gt; 산술 규칙은 ANSI X3.274-1996 및 ANSI X3.274-1996 / AM 1-2000 (섹션 7.4)에 정의 된 산술 연산 모드와 광범위하게 호환됩니다. 이러한 표준과는 달리, &lt;code&gt;BigDecimal&lt;/code&gt; 와 의 제산으로 필수였다 많은 둥근 모드가 포함 &lt;code&gt;BigDecimal&lt;/code&gt; 를가 이러한 ANSI 표준과 간의 충돌 전 5에 출시 &lt;code&gt;BigDecimal&lt;/code&gt; 스펙에 찬성 해결 &lt;code&gt;BigDecimal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5843d706baf770064c5e4bf338f1a63714ad7a1d" translate="yes" xml:space="preserve">
          <source>When the representation class is a URL, the print service itself accesses and downloads the document directly from its URL address, without involving the client. The service may be some form of network print service which is executing in a different environment. This means you should not use a URL print data flavor to print a document at a restricted URL that the client can see but the printer cannot see. This also means you should not use a URL print data flavor to print a document stored in a local file that is not available at a URL accessible independently of the client. For example, a file that is not served up by an HTTP server or FTP server. To print such documents, let the client open an input stream on the URL or file and use an input stream data flavor.</source>
          <target state="translated">표현 클래스가 URL 인 경우, 인쇄 서비스 자체는 클라이언트를 관여시키지 않고 URL 주소에서 직접 문서에 액세스하여 다운로드합니다. 서비스는 다른 환경에서 실행되는 네트워크 인쇄 서비스의 형태 일 수 있습니다. 즉, 클라이언트는 볼 수 있지만 프린터는 볼 수없는 제한된 URL로 문서를 인쇄하기 위해 URL 인쇄 데이터 특징을 사용해서는 안됩니다. 이는 또한 클라이언트와 독립적으로 액세스 할 수있는 URL에서 사용할 수없는 로컬 파일에 저장된 문서를 인쇄하기 위해 URL 인쇄 데이터 특징을 사용해서는 안됩니다. 예를 들어, HTTP 서버 또는 FTP 서버에서 제공하지 않는 파일입니다. 이러한 문서를 인쇄하려면 클라이언트가 URL 또는 파일에서 입력 스트림을 열고 입력 스트림 데이터 플레이버를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c50fdf0c297e395312b19932d6d698d6fe9410ab" translate="yes" xml:space="preserve">
          <source>When the returned &lt;code&gt;VarHandle&lt;/code&gt; is invoked, the array reference and array index are checked. A &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown if the array reference is &lt;code&gt;null&lt;/code&gt; and an &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; will be thrown if the index is negative or if it is greater than or equal to the length of the array.</source>
          <target state="translated">반환 된 &lt;code&gt;VarHandle&lt;/code&gt; 이 호출되면 배열 참조와 배열 인덱스가 확인됩니다. &lt;code&gt;NullPointerException&lt;/code&gt; 가 배열 참조 경우 발생한다 &lt;code&gt;null&lt;/code&gt; 하고 &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; 지수가 음수 인 경우 발생한다하거나 배열의 길이와 동일하거나보다 큰 경우.</target>
        </trans-unit>
        <trans-unit id="f2890f46cc50adad6b16a722b172030e24df5540" translate="yes" xml:space="preserve">
          <source>When the returned method handle is invoked, the array reference and array index are checked. A &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown if the array reference is &lt;code&gt;null&lt;/code&gt; and an &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; will be thrown if the index is negative or if it is greater than or equal to the length of the array.</source>
          <target state="translated">반환 된 메서드 핸들이 호출되면 배열 참조 및 배열 인덱스가 확인됩니다. &lt;code&gt;NullPointerException&lt;/code&gt; 가 배열 참조 경우 발생한다 &lt;code&gt;null&lt;/code&gt; 하고 &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; 지수가 음수 인 경우 발생한다하거나 배열의 길이와 동일하거나보다 큰 경우.</target>
        </trans-unit>
        <trans-unit id="65a8d19d4c40ff2e75d5423b676fb0c582abe879" translate="yes" xml:space="preserve">
          <source>When the selection is changed, &lt;code&gt;setValue&lt;/code&gt; is invoked, which generates a &lt;code&gt;PropertyChangeEvent&lt;/code&gt;.</source>
          <target state="translated">선택이 변경되면 &lt;code&gt;setValue&lt;/code&gt; 가 호출되어 &lt;code&gt;PropertyChangeEvent&lt;/code&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="750413507a9e50e7dd4ee48691a0e0e569f733c7" translate="yes" xml:space="preserve">
          <source>When the socket is created the &lt;a href=&quot;datagramsocket#setReuseAddress(boolean)&quot;&gt;&lt;code&gt;DatagramSocket.setReuseAddress(boolean)&lt;/code&gt;&lt;/a&gt; method is called to enable the SO_REUSEADDR socket option.</source>
          <target state="translated">소켓이 생성 되면 SO_REUSEADDR 소켓 옵션을 활성화하기 위해 &lt;a href=&quot;datagramsocket#setReuseAddress(boolean)&quot;&gt; &lt;code&gt;DatagramSocket.setReuseAddress(boolean)&lt;/code&gt; &lt;/a&gt; 메서드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c97f96f2fd46091c0f2026852faa74a91e5bd86f" translate="yes" xml:space="preserve">
          <source>When the socket is created the &lt;a href=&quot;datagramsocket#setReuseAddress-boolean-&quot;&gt;&lt;code&gt;DatagramSocket.setReuseAddress(boolean)&lt;/code&gt;&lt;/a&gt; method is called to enable the SO_REUSEADDR socket option.</source>
          <target state="translated">소켓이 작성 되면 SO_REUSEADDR 소켓 옵션을 사용하기 위해 &lt;a href=&quot;datagramsocket#setReuseAddress-boolean-&quot;&gt; &lt;code&gt;DatagramSocket.setReuseAddress(boolean)&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="23d0fb38ca6d6e11edcf3b7e63aa87f6a871583e" translate="yes" xml:space="preserve">
          <source>When the specified date-time arrives, the printer must remove the &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt; value of &lt;code&gt;JOB_HOLD_UNTIL_SPECIFIED&lt;/code&gt; from the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, if present. If there are no other job state reasons that keep the job in the &lt;code&gt;PENDING_HELD&lt;/code&gt; state, the printer must consider the job as a candidate for processing by moving the job to the PENDING state.</source>
          <target state="translated">지정된 날짜-시간이되면 프린터는 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성 (있는 경우) 에서 &lt;code&gt;JOB_HOLD_UNTIL_SPECIFIED&lt;/code&gt; 의 &lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt; 값을 제거해야합니다 . 작업을 &lt;code&gt;PENDING_HELD&lt;/code&gt; 상태로 유지하는 다른 작업 상태 이유가없는 경우 프린터는 작업을 PENDING 상태로 이동하여 작업을 처리 후보로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="5705af97d2330caf062737553687cb90dd63be9e" translate="yes" xml:space="preserve">
          <source>When the specified date-time arrives, the printer must remove the &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt; value of JOB_HOLD_UNTIL_SPECIFIED from the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, if present. If there are no other job state reasons that keep the job in the PENDING_HELD state, the printer must consider the job as a candidate for processing by moving the job to the PENDING state.</source>
          <target state="translated">지정된 날짜-시간이되면 프린터는 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성 (있는 경우) 에서 &lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt; 값 JOB_HOLD_UNTIL_SPECIFIED를 제거해야합니다 . 작업을 PENDING_HELD 상태로 유지하는 다른 작업 상태 이유가없는 경우 프린터는 작업을 PENDING 상태로 이동하여 처리 후보로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="88645d98095c743d1978459bbe537d54c96def54" translate="yes" xml:space="preserve">
          <source>When the specified provider is removed, all providers located at a position greater than where the specified provider was are shifted down one position (towards the head of the list of installed providers).</source>
          <target state="translated">지정된 제공자가 제거되면 지정된 제공자가 지정된 위치보다 큰 위치에있는 모든 제공자가 한 위치 아래 (설치된 제공자 목록의 머리쪽으로) 이동합니다.</target>
        </trans-unit>
        <trans-unit id="a42df38aa359f6593f2ef17a8352c58477850724" translate="yes" xml:space="preserve">
          <source>When the syntax is &quot;&lt;code&gt;glob&lt;/code&gt;&quot; then the &lt;code&gt;String&lt;/code&gt; representation of the path is matched using a limited pattern language that resembles regular expressions but with a simpler syntax. For example:</source>
          <target state="translated">구문이 &quot; &lt;code&gt;glob&lt;/code&gt; &quot; 인 경우 경로 의 &lt;code&gt;String&lt;/code&gt; 표현은 정규식과 유사하지만 구문이 더 간단한 제한된 패턴 언어를 사용하여 일치됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a34d7bcd42ea49862772510bb9b109c7b63aa486" translate="yes" xml:space="preserve">
          <source>When the syntax is &quot;&lt;code&gt;regex&lt;/code&gt;&quot; then the pattern component is a regular expression as defined by the &lt;a href=&quot;../../util/regex/pattern&quot;&gt;&lt;code&gt;Pattern&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">구문이 &quot; &lt;code&gt;regex&lt;/code&gt; &quot;인 경우 패턴 구성 요소는 &lt;a href=&quot;../../util/regex/pattern&quot;&gt; &lt;code&gt;Pattern&lt;/code&gt; &lt;/a&gt; 클래스에 의해 정의 된 정규식 입니다.</target>
        </trans-unit>
        <trans-unit id="846a62fdfe658618e67bb6666bfc83ef7036c188" translate="yes" xml:space="preserve">
          <source>When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, it returns the result of String concatenation, taking all function arguments and constants passed to the linkage method as inputs for concatenation. The target signature is given by &lt;code&gt;concatType&lt;/code&gt;, and does not include constants. For a target accepting:</source>
          <target state="translated">이 메서드에서 반환 된 &lt;code&gt;CallSite&lt;/code&gt; 의 대상 이 호출되면 연결을위한 입력으로 연결 메서드에 전달 된 모든 함수 인수와 상수를 사용하여 문자열 연결의 결과를 반환합니다. 대상 서명은 &lt;code&gt;concatType&lt;/code&gt; 으로 제공되며 상수를 포함하지 않습니다. 수락 대상 :</target>
        </trans-unit>
        <trans-unit id="d29230ce7aa0f83e52a9d0b8aae6ea61d3af4a88" translate="yes" xml:space="preserve">
          <source>When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, it returns the result of String concatenation, taking all function arguments passed to the linkage method as inputs for concatenation. The target signature is given by &lt;code&gt;concatType&lt;/code&gt;. For a target accepting:</source>
          <target state="translated">이 메서드에서 반환 된 &lt;code&gt;CallSite&lt;/code&gt; 의 대상 이 호출되면 연결 메서드에 전달 된 모든 함수 인수를 연결에 대한 입력으로 사용하여 문자열 연결의 결과를 반환합니다. 대상 서명은 &lt;code&gt;concatType&lt;/code&gt; 으로 제공됩니다 . 수락 대상 :</target>
        </trans-unit>
        <trans-unit id="d7d520f5e0468b072c681c7152b26b75810e8caf" translate="yes" xml:space="preserve">
          <source>When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, the resulting function objects are instances of a class which implements the interface named by the return type of &lt;code&gt;invokedType&lt;/code&gt;, declares a method with the name given by &lt;code&gt;invokedName&lt;/code&gt; and the signature given by &lt;code&gt;samMethodType&lt;/code&gt;. It may also override additional methods from &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">의 대상 때 &lt;code&gt;CallSite&lt;/code&gt; 이 메서드에서 반환이 호출, 결과 함수 객체의 반환 형식에 의해 명명 된 인터페이스를 구현하는 클래스의 인스턴스 &lt;code&gt;invokedType&lt;/code&gt; 는 ,에 의해 주어진 이름의 방법 선언 &lt;code&gt;invokedName&lt;/code&gt; 에 의해 주어진 서명 &lt;code&gt;samMethodType&lt;/code&gt; 을 . &lt;code&gt;Object&lt;/code&gt; 의 추가 메소드를 재정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="935f09a1ca1fda156388d4a2ee040efb3dfa7c02" translate="yes" xml:space="preserve">
          <source>When the target of the &lt;code&gt;CallSite&lt;/code&gt; returned from this method is invoked, the resulting function objects are instances of a class with the following properties:</source>
          <target state="translated">이 메소드에서 리턴 된 &lt;code&gt;CallSite&lt;/code&gt; 의 대상 이 호출되면 결과 함수 오브젝트는 다음 특성을 가진 클래스의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="6d07b79c3fe52992e2c96caa5963c279054fc29d" translate="yes" xml:space="preserve">
          <source>When the user changes the value of the scroll bar, the scroll bar receives an instance of &lt;code&gt;AdjustmentEvent&lt;/code&gt;. The scroll bar processes this event, passing it along to any registered listeners.</source>
          <target state="translated">사용자가 스크롤 막대의 값을 변경하면 스크롤 막대는 &lt;code&gt;AdjustmentEvent&lt;/code&gt; 인스턴스를받습니다 . 스크롤 막대는이 이벤트를 처리하여 등록 된 모든 리스너에게 전달합니다.</target>
        </trans-unit>
        <trans-unit id="16eee6e04be75731d2c23d0789dd273c70555ca5" translate="yes" xml:space="preserve">
          <source>When the user is resizing the &lt;code&gt;Component&lt;/code&gt;s the minimum size of the &lt;code&gt;Components&lt;/code&gt; is used to determine the maximum/minimum position the &lt;code&gt;Component&lt;/code&gt;s can be set to. If the minimum size of the two components is greater than the size of the split pane the divider will not allow you to resize it. To alter the minimum size of a &lt;code&gt;JComponent&lt;/code&gt;, see &lt;a href=&quot;jcomponent#setMinimumSize(java.awt.Dimension)&quot;&gt;&lt;code&gt;JComponent.setMinimumSize(java.awt.Dimension)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자가 리사이징 될 때 &lt;code&gt;Component&lt;/code&gt; 의 최소한의 크기 &lt;code&gt;Components&lt;/code&gt; 상기 최대 / 최소 위치를 결정하는 데 사용되는 &lt;code&gt;Component&lt;/code&gt; 들로 설정 될 수있다. 두 구성 요소의 최소 크기가 분할 창의 크기보다 크면 구분선에서 크기를 조정할 수 없습니다. &lt;code&gt;JComponent&lt;/code&gt; 의 최소 ​​크기를 변경하려면 &lt;a href=&quot;jcomponent#setMinimumSize(java.awt.Dimension)&quot;&gt; &lt;code&gt;JComponent.setMinimumSize(java.awt.Dimension)&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="955102ac80658721d1f432faef28beba4c5e0ef3" translate="yes" xml:space="preserve">
          <source>When the user resizes the split pane the new space is distributed between the two components based on the &lt;code&gt;resizeWeight&lt;/code&gt; property. A value of 0, the default, indicates the right/bottom component gets all the space, where as a value of 1 indicates the left/top component gets all the space.</source>
          <target state="translated">사용자가 분할 창의 크기를 조정하면 &lt;code&gt;resizeWeight&lt;/code&gt; 속성을 기반으로 두 구성 요소간에 새 공간이 배포 됩니다. 기본값 인 0은 오른쪽 / 아래쪽 구성 요소가 모든 공간을 차지함을 나타내며, 값 1은 왼쪽 / 위쪽 구성 요소가 모든 공간을 차지함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c90b9a5fd33f3cd980097a956b05ef5be63c5895" translate="yes" xml:space="preserve">
          <source>When the user terminates the drag operation, normally resulting in a successful Drop, both the &lt;code&gt;DragSource&lt;/code&gt; and &lt;code&gt;DropTarget&lt;/code&gt; receive notifications that include, and result in the type negotiation and transfer of, the information associated with the &lt;code&gt;DragSource&lt;/code&gt; via a &lt;code&gt;Transferable&lt;/code&gt; object.</source>
          <target state="translated">사용자가 드래그 작업을 종료하여 일반적으로 Drop이 성공하면 &lt;code&gt;DragSource&lt;/code&gt; 및 &lt;code&gt;DropTarget&lt;/code&gt; 모두 &lt;code&gt;Transferable&lt;/code&gt; 개체 를 통해 &lt;code&gt;DragSource&lt;/code&gt; 와 관련된 정보를 포함하고 그 결과 유형 협상 및 전송을 포함하는 알림을받습니다 .</target>
        </trans-unit>
        <trans-unit id="1b69617c3d426ae0b52b14cd7b31c80e8f2ff7cf" translate="yes" xml:space="preserve">
          <source>When the virtual machine's built-in class loader, known as the &quot;bootstrap class loader&quot;, unsuccessfully searches for a class, the entries in the &lt;a href=&quot;../../../../java.base/java/util/jar/jarfile&quot;&gt;&lt;code&gt;JAR file&lt;/code&gt;&lt;/a&gt; will be searched as well.</source>
          <target state="translated">가상 머신의 내장 클래스 로더 ( &quot;부트 스트랩 클래스 로더&quot;라고 함)가 클래스 검색에 실패하면 &lt;a href=&quot;../../../../java.base/java/util/jar/jarfile&quot;&gt; &lt;code&gt;JAR file&lt;/code&gt; &lt;/a&gt; 의 항목 도 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="3845d46c4ef86f663a835d134902a3051dd1ea04" translate="yes" xml:space="preserve">
          <source>When the virtual machine's built-in class loader, known as the &quot;bootstrap class loader&quot;, unsuccessfully searches for a class, the entries in the &lt;a href=&quot;../../util/jar/jarfile&quot;&gt;&lt;code&gt;JAR file&lt;/code&gt;&lt;/a&gt; will be searched as well.</source>
          <target state="translated">&quot;부트 스트랩 클래스 로더&quot;라고하는 가상 머신의 내장 클래스 로더가 클래스를 검색하지 못하면 &lt;a href=&quot;../../util/jar/jarfile&quot;&gt; &lt;code&gt;JAR file&lt;/code&gt; &lt;/a&gt; 의 항목 도 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="9f5936d0319917d0904a3bc84216aec8fd20dcb1" translate="yes" xml:space="preserve">
          <source>When the window is per-pixel translucent, the drawing sub-system respects the alpha value of each individual pixel. If a pixel gets painted with the alpha color component equal to zero, it becomes visually transparent. If the alpha of the pixel is equal to 1.0f, the pixel is fully opaque. Interim values of the alpha color component make the pixel semi-transparent. In this mode, the background of the window gets painted with the alpha value of the given background color. If the alpha value of the argument of this method is equal to &lt;code&gt;0&lt;/code&gt;, the background is not painted at all.</source>
          <target state="translated">창이 픽셀 당 반투명이면 그리기 하위 시스템은 각 개별 픽셀의 알파 값을 따릅니다. 픽셀이 0과 같은 알파 색상 구성 요소로 칠해지면 시각적으로 투명 해집니다. 픽셀의 알파가 1.0f와 같으면 픽셀은 완전히 불투명합니다. 알파 색상 구성 요소의 중간 값은 픽셀을 반투명하게 만듭니다. 이 모드에서 창의 배경은 주어진 배경색의 알파 값으로 칠해집니다. 이 메서드 인수의 알파 값이 &lt;code&gt;0&lt;/code&gt; 이면 배경이 전혀 칠해지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78301597bc29e04c67c4b5e8569630b44e2a80b1" translate="yes" xml:space="preserve">
          <source>When there are no more tokens, the last value found in the child-cache or returned by &lt;code&gt;childSpi&lt;/code&gt; is returned by this method. If during the traversal, two &lt;code&gt;&quot;/&quot;&lt;/code&gt; tokens occur consecutively, or the final token is &lt;code&gt;&quot;/&quot;&lt;/code&gt; (rather than a name), an appropriate &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">더 이상 토큰이 없으면 child-cache에서 찾거나 &lt;code&gt;childSpi&lt;/code&gt; 에 의해 리턴 된 마지막 값 이이 메소드에 의해 리턴됩니다. 순회 중에 두 개의 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 토큰이 연속적으로 발생하거나 최종 토큰이 &lt;code&gt;&quot;/&quot;&lt;/code&gt; (이름이 아닌)이면 적절한 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dd91b0658c6cf431015b14f6a00de46f9c97ac60" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of the input sequence then an empty leading substring is included at the beginning of the resulting array. A zero-width match at the beginning however never produces such empty leading substring.</source>
          <target state="translated">입력 시퀀스의 시작 부분에 양의 너비가 일치하면 결과 배열의 시작 부분에 빈 선행 부분 문자열이 포함됩니다. 그러나 처음에 너비가 0이면 일치하는 빈 선행 부분 문자열이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab6bcee9543d79d3bbe811e0f20b9a8c6356f175" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of the input sequence then an empty leading substring is included at the beginning of the stream. A zero-width match at the beginning however never produces such empty leading substring.</source>
          <target state="translated">입력 시퀀스의 시작 부분에 양의 너비가 일치하면 빈 시작 부분 문자열이 스트림의 시작 부분에 포함됩니다. 그러나 처음에 너비가 0이면 일치하는 빈 선행 부분 문자열이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="735c807118b30a042caeeea37d2a0653aefeb1e0" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of this string then an empty leading substring is included at the beginning of the resulting array. A zero-width match at the beginning however never produces such empty leading substring.</source>
          <target state="translated">이 문자열의 시작 부분에 양의 너비가 일치하면 결과 배열의 시작 부분에 빈 선행 부분 문자열이 포함됩니다. 그러나 처음에 너비가 0이면 일치하는 빈 선행 부분 문자열이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a4d1a71ed66693f31054772316c85b0392b49d2" translate="yes" xml:space="preserve">
          <source>When these are in place for a UDT, calling the methods &lt;code&gt;ResultSet.getObject&lt;/code&gt; or &lt;code&gt;CallableStatement.getObject&lt;/code&gt; on that UDT will automatically retrieve the custom mapping for it. Also, the &lt;code&gt;PreparedStatement.setObject&lt;/code&gt; method will automatically map the object back to its SQL type to store it in the data source.</source>
          <target state="translated">UDT에 대한 위치에있는 경우 해당 UDT에서 &lt;code&gt;ResultSet.getObject&lt;/code&gt; 또는 &lt;code&gt;CallableStatement.getObject&lt;/code&gt; 메서드를 호출하면 해당 UDT에 대한 사용자 지정 매핑이 자동으로 검색됩니다. 또한 &lt;code&gt;PreparedStatement.setObject&lt;/code&gt; 메소드는 자동으로 객체를 SQL 유형에 다시 매핑하여 데이터 소스에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="59b930f7ddff7332085ec26d6fac4974e8e12b10" translate="yes" xml:space="preserve">
          <source>When this code runs,</source>
          <target state="translated">이 코드가 실행되면</target>
        </trans-unit>
        <trans-unit id="cbcf2b7b42302b4ba4fae27e923d6a973f224d28" translate="yes" xml:space="preserve">
          <source>When this fails, the resolution will be retried with the specified prefix deleted from the implementation name, yielding the correct resolution:</source>
          <target state="translated">이것이 실패하면, 지정된 접두사가 구현 이름에서 삭제 된 상태에서 해결이 재 시도되어 올바른 해결이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="ff9da4b4449f564bcf08ecf5f687a2592cebde98" translate="yes" xml:space="preserve">
          <source>When this fails, the resolution will be retried with the specified prefix prepended to the method name, yielding the correct resolution:</source>
          <target state="translated">이것이 실패하면, 지정된 접두어가 메소드 이름 앞에 추가되어 해상도가 재 시도되어 올바른 해상도가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="75154f3aadedea422fd3c7633a9889ca79a529a3" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000,000.</source>
          <target state="translated">이 필드를 값 설정에 사용 하는 경우 값에 1,000,000을 곱한 &lt;a href=&quot;#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 설정과 동일한 방식으로 동작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="15ccb1c283c4e094f90353b08299e4e2a2ecb732" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000.</source>
          <target state="translated">이 필드를 값 설정에 사용하는 경우 &lt;a href=&quot;#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 를 1,000을 곱한 값 으로 설정하는 것과 동일한 방식으로 동작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="53f8544461b05bbe464ff7823a230bfc4bf04760" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000,000.</source>
          <target state="translated">이 필드를 값 설정에 사용하는 경우 &lt;a href=&quot;#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt; 를 1,000,000을 곱한 값 으로 설정하는 것과 동일한 방식으로 동작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f8f0fa54e907e8e2466eda8f3397fead3f7ec0b2" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000.</source>
          <target state="translated">이 필드를 값 설정에 사용하는 경우 &lt;a href=&quot;#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt; 를 1,000을 곱한 값 으로 설정하는 것과 동일한 방식으로 동작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eaab9ca0b04a7049f2a9f2eca0230f3f4e33a263" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000,000.</source>
          <target state="translated">이 필드를 사용하여 값을 설정하는 경우 1,000,000을 곱한 값으로 &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 를 설정하는 것과 같은 방식으로 작동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="db9acfde62bdc912d95eb549ddc180babc48a672" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000.</source>
          <target state="translated">이 필드를 사용하여 값을 설정하면 값 에 1,000을 곱한 &lt;a href=&quot;chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 설정과 같은 방식으로 작동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b434d16d4beadd3f769e9c367e4be1fa9657e587" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000,000.</source>
          <target state="translated">이 필드를 사용하여 값을 설정하면 1,000,000을 곱한 값으로 &lt;a href=&quot;chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt; 를 설정하는 것과 같은 방식으로 작동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4dce2d6953f5a46462f20dc8f01aaa03fa0ee37c" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should behave in the same way as setting &lt;a href=&quot;chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; with the value multiplied by 1,000.</source>
          <target state="translated">이 필드를 사용하여 값을 설정하면 값 에 1,000을 곱한 &lt;a href=&quot;chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt; 설정과 같은 방식으로 동작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f48a54b9eb38bdd2ccfe0a591106ec4e77d4089" translate="yes" xml:space="preserve">
          <source>When this field is used for setting a value, it should set as much precision as the object stores, using integer division to remove excess precision. For example, if the &lt;code&gt;TemporalAccessor&lt;/code&gt; stores time to millisecond precision, then the nano-of-second must be divided by 1,000,000 before replacing the milli-of-second.</source>
          <target state="translated">이 필드를 사용하여 값을 설정하는 경우 정수 나누기를 사용하여 초과 정밀도를 제거하여 오브젝트가 저장하는 정도의 정밀도를 설정해야합니다. 예를 들어, &lt;code&gt;TemporalAccessor&lt;/code&gt; 가 시간을 밀리 초 정밀도로 저장하는 경우, 밀리 초를 교체하기 전에 나노초를 1,000,000으로 나누어야합니다.</target>
        </trans-unit>
        <trans-unit id="e2e89c6cff8f954a3f0ea54f5e7b16399bcbf000" translate="yes" xml:space="preserve">
          <source>When this flag is specified then case-insensitive matching, when enabled by the &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;&lt;code&gt;CASE_INSENSITIVE&lt;/code&gt;&lt;/a&gt; flag, is done in a manner consistent with the Unicode Standard. By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched.</source>
          <target state="translated">이 플래그가 지정되면 &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt; &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; &lt;/a&gt; 플래그에 의해 활성화 될 때 대소 문자를 구분하지 않는 일치 가 유니 코드 표준과 일치하는 방식으로 수행됩니다. 기본적으로 대소 문자를 구분하지 않는 일치는 US-ASCII 문자 집합의 문자 만 일치한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7586fee8208377dc85e8eeb7ce578740e81e481a" translate="yes" xml:space="preserve">
          <source>When this flag is specified then case-insensitive matching, when enabled by the &lt;a href=&quot;pattern#CASE_INSENSITIVE&quot;&gt;&lt;code&gt;CASE_INSENSITIVE&lt;/code&gt;&lt;/a&gt; flag, is done in a manner consistent with the Unicode Standard. By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched.</source>
          <target state="translated">이 플래그가 지정되면 &lt;a href=&quot;pattern#CASE_INSENSITIVE&quot;&gt; &lt;code&gt;CASE_INSENSITIVE&lt;/code&gt; &lt;/a&gt; 플래그에 의해 사용 가능한 경우 대소 문자를 구분하지 않는 일치 가 유니 코드 표준과 일치하는 방식으로 수행됩니다. 기본적으로 대소 문자를 구분하지 않는 일치는 US-ASCII 문자 집합의 문자 만 일치한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="14b51aaf8931fe8814ff8bce6f0f7714b23eea9c" translate="yes" xml:space="preserve">
          <source>When this flag is specified then the (US-ASCII only)</source>
          <target state="translated">이 플래그가 지정되면 (US-ASCII에만 해당)</target>
        </trans-unit>
        <trans-unit id="a5a64aeef21bfe24b3dc25f14183010379e48ae2" translate="yes" xml:space="preserve">
          <source>When this flag is specified then the input string that specifies the pattern is treated as a sequence of literal characters. Metacharacters or escape sequences in the input sequence will be given no special meaning.</source>
          <target state="translated">이 플래그가 지정되면 패턴을 지정하는 입력 문자열이 일련의 리터럴 문자로 처리됩니다. 입력 시퀀스의 메타 문자 또는 이스케이프 시퀀스에는 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="21f1033522929794d630209592d380a1564d3a0e" translate="yes" xml:space="preserve">
          <source>When this flag is specified then two characters will be considered to match if, and only if, their full canonical decompositions match. The expression &lt;code&gt;&quot;a\u030A&quot;&lt;/code&gt;, for example, will match the string &lt;code&gt;&quot;\u00E5&quot;&lt;/code&gt; when this flag is specified. By default, matching does not take canonical equivalence into account.</source>
          <target state="translated">이 플래그가 지정되면 전체 정식 분해가 일치하는 경우에만 두 문자가 일치하는 것으로 간주됩니다. 예를 들어, &lt;code&gt;&quot;a\u030A&quot;&lt;/code&gt; 표현식 은이 플래그가 지정 될 때 문자열 &lt;code&gt;&quot;\u00E5&quot;&lt;/code&gt; 와 일치 합니다. 기본적으로 일치는 정식 동등성을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2eb07b710886c04bce981e5cfa33253d986b6149" translate="yes" xml:space="preserve">
          <source>When this method is called from a named module and the given loader is the class loader of the caller module, this is equivalent to calling:</source>
          <target state="translated">이 메서드가 명명 된 모듈에서 호출되고 지정된 로더가 호출자 모듈의 클래스 로더 인 경우 이는 다음을 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="97ec7609c528b9efd3de6f2bb7f5796b603e2fd8" translate="yes" xml:space="preserve">
          <source>When this method is called on a window with a value of &lt;code&gt;false&lt;/code&gt; the always-on-top state is set to normal. It may also cause an unspecified, platform-dependent change in the z-order of top-level windows, but other always-on-top windows will remain in top-most position. Calling this method with a value of &lt;code&gt;false&lt;/code&gt; on a window that has a normal state has no effect.</source>
          <target state="translated">이 메서드가 값이 &lt;code&gt;false&lt;/code&gt; 인 창에서 호출 되면 항상 맨 위 상태가 정상으로 설정됩니다. 또한 최상위 창의 z 순서에서 지정되지 않은 플랫폼에 따라 변경 될 수 있지만 다른 항상 위에있는 창은 최상위 위치에 유지됩니다. 정상 상태 인 창 에서 &lt;code&gt;false&lt;/code&gt; 값으로이 메서드를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="35fc6a39f3e8a32dd792f6a29a5416db989863ad" translate="yes" xml:space="preserve">
          <source>When this method is called on a window with a value of &lt;code&gt;true&lt;/code&gt;, and the window is visible and the platform supports always-on-top for this window, the window is immediately brought forward, &quot;sticking&quot; it in the top-most position. If the window isn`t currently visible, this method sets the always-on-top state to &lt;code&gt;true&lt;/code&gt; but does not bring the window forward. When the window is later shown, it will be always-on-top.</source>
          <target state="translated">이 메서드가 &lt;code&gt;true&lt;/code&gt; 값을 가진 창에서 호출되고 창이 표시되고 플랫폼이이 창에 대해 항상 맨 위를 지원하면 창은 즉시 앞으로 가져 와서 맨 위에 &quot;고정&quot;됩니다. 창이 현재 표시 되지 않는 경우이 메서드는 항상 맨 위 상태를 &lt;code&gt;true&lt;/code&gt; 로 설정 하지만 창을 앞으로 가져 오지 않습니다. 나중에 창이 표시되면 항상 맨 위에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="34681f8822dac6f93802ce310f175da3ecf86017" translate="yes" xml:space="preserve">
          <source>When this method is called, a &lt;code&gt;CachedRowSet&lt;/code&gt; implementation must ensure that all updates, inserts, and deletes to the current rowset instance are replaced by the previous values. In addition, the cursor should be reset to the first row and a &lt;code&gt;rowSetChanged&lt;/code&gt; event should be fired to notify all registered listeners.</source>
          <target state="translated">이 메서드가 호출 될 때 &lt;code&gt;CachedRowSet&lt;/code&gt; 구현은 현재 행 집합 인스턴스에 대한 모든 업데이트, 삽입 및 삭제가 이전 값으로 바뀌는 지 확인해야합니다. 또한 커서를 첫 번째 행으로 재설정하고 등록 된 모든 리스너에게 알리기 위해 &lt;code&gt;rowSetChanged&lt;/code&gt; 이벤트를 발생시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="c46ec6437cd48feaac1a48bb7981ed49d818cc15" translate="yes" xml:space="preserve">
          <source>When this method is first called, it creates a single new pseudorandom-number generator, exactly as if by the expression</source>
          <target state="translated">이 메소드를 처음 호출하면 마치 표현식에서와 같이 단일 의사 난수 생성기를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8017fa479dbb420d64cc0450b94e2122cd6d705f" translate="yes" xml:space="preserve">
          <source>When this method is observed via the Core Reflection API, it will appear as a single native method, taking an object array and returning an object. If this native method is invoked directly via &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;, via JNI, or indirectly via &lt;a href=&quot;methodhandles.lookup#unreflect(java.lang.reflect.Method)&quot;&gt;&lt;code&gt;Lookup.unreflect&lt;/code&gt;&lt;/a&gt;, it will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">이 메서드가 Core Reflection API를 통해 관찰되면 단일 네이티브 메서드로 표시되어 개체 배열을 가져와 개체를 반환합니다. 이 네이티브 메서드가 &lt;a href=&quot;../reflect/method#invoke(java.lang.Object,java.lang.Object...)&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt; 를 통해 직접 , JNI를 통해 또는 &lt;a href=&quot;methodhandles.lookup#unreflect(java.lang.reflect.Method)&quot;&gt; &lt;code&gt;Lookup.unreflect&lt;/code&gt; &lt;/a&gt; 를 통해 간접적으로 호출 되면 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="52757c7befe8d92c9dd6861f446c19ec7ae3c908" translate="yes" xml:space="preserve">
          <source>When this method is observed via the Core Reflection API, it will appear as a single native method, taking an object array and returning an object. If this native method is invoked directly via &lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt;&lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt;&lt;/a&gt;, via JNI, or indirectly via &lt;a href=&quot;methodhandles.lookup#unreflect-java.lang.reflect.Method-&quot;&gt;&lt;code&gt;Lookup.unreflect&lt;/code&gt;&lt;/a&gt;, it will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">이 메소드가 Core Reflection API를 통해 관찰되면 단일 네이티브 메소드로 표시되어 객체 배열을 가져와 객체를 반환합니다. 이 원시 메소드가 &lt;a href=&quot;../reflect/method#invoke-java.lang.Object-java.lang.Object...-&quot;&gt; &lt;code&gt;java.lang.reflect.Method.invoke&lt;/code&gt; &lt;/a&gt; 를 통해 직접 , JNI를 통해 또는 &lt;a href=&quot;methodhandles.lookup#unreflect-java.lang.reflect.Method-&quot;&gt; &lt;code&gt;Lookup.unreflect&lt;/code&gt; &lt;/a&gt; 를 통해 간접적으로 호출 되면 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="a38dc9de2e7e26b0458b9e11ee50544cbc7608fa" translate="yes" xml:space="preserve">
          <source>When this method returns both the input and the output will have been closed. Any pending send operations will fail with &lt;code&gt;IOException&lt;/code&gt;. Subsequent invocations of &lt;code&gt;abort&lt;/code&gt; will have no effect.</source>
          <target state="translated">이 메서드가 입력과 출력을 모두 반환하면 닫힙니다. 보류중인 모든 전송 작업은 &lt;code&gt;IOException&lt;/code&gt; 과 함께 실패 합니다. 이후의 &lt;code&gt;abort&lt;/code&gt; 호출은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3ee3ff5f0b0cb85ef35aeb00902b551ab3ba4149" translate="yes" xml:space="preserve">
          <source>When this method returns true, then it is possible that more input would have changed the result of the last search.</source>
          <target state="translated">이 메소드가 true를 리턴하면 더 많은 입력이 마지막 검색 결과를 변경했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6509e5735d2c1c6ef7c6f2ecc98960052393fc92" translate="yes" xml:space="preserve">
          <source>When this object is passed to a &lt;code&gt;SecureRandom.getInstance()&lt;/code&gt; call, it is the requested minimum capability. When it's returned from &lt;code&gt;SecureRandom.getParameters()&lt;/code&gt;, it is the effective capability.</source>
          <target state="translated">이 객체가 &lt;code&gt;SecureRandom.getInstance()&lt;/code&gt; 호출에 전달 되면 요청 된 최소 기능입니다. &lt;code&gt;SecureRandom.getParameters()&lt;/code&gt; 에서 반환되면 효과적인 기능입니다.</target>
        </trans-unit>
        <trans-unit id="1b6f8486c17688cf0a3d019c7be76ba42109c755" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;../channels/channel#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">이 옵션이 있으면 구현은 &lt;a href=&quot;../channels/channel#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드로 닫을 때 파일을 삭제하려고 &lt;em&gt;최선을 다합니다&lt;/em&gt; . 경우 &lt;code&gt;close&lt;/code&gt; 방법은 다음 호출되지 않는 &lt;em&gt;최선의 노력을&lt;/em&gt; 시도 할 때 Java 가상 머신의 종료 파일을 삭제한다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3d23117d12579aaf94e4afd1d23df8d2a8c9c22" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;../channels/channel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">이 옵션이 존재하면 구현은 &lt;a href=&quot;../channels/channel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드로 닫을 때 파일을 삭제하려고 &lt;em&gt;최선을 다합니다&lt;/em&gt; . 경우 &lt;code&gt;close&lt;/code&gt; 방법은 다음 호출되지 않는 &lt;em&gt;최선의 노력을&lt;/em&gt; 시도 할 때 Java 가상 머신의 종료 파일을 삭제한다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="154a44d02d610434ad7eb55b13886c24f76c0303" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;asynchronouschannel#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">이 옵션이 있으면 구현은 &lt;a href=&quot;asynchronouschannel#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드로 닫을 때 파일을 삭제하려고 &lt;em&gt;최선을 다합니다&lt;/em&gt; . 경우 &lt;code&gt;close&lt;/code&gt; 방법은 다음 호출되지 않는 &lt;em&gt;최선의 노력을&lt;/em&gt; 시도 할 때 Java 가상 머신의 종료 파일을 삭제한다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f56b2fb23d344e1a50af4c3e2e123c61d288eb20" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the &lt;a href=&quot;spi/abstractinterruptiblechannel#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">이 옵션이 있으면 구현은 &lt;a href=&quot;spi/abstractinterruptiblechannel#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드로 닫을 때 파일을 삭제하려고 &lt;em&gt;최선을 다합니다&lt;/em&gt; . 경우 &lt;code&gt;close&lt;/code&gt; 방법은 다음 호출되지 않는 &lt;em&gt;최선의 노력을&lt;/em&gt; 시도 할 때 Java 가상 머신의 종료 파일을 삭제한다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b452042a8719f181a9d60ae51034b9bcd166e197" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the the &lt;a href=&quot;asynchronouschannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">이 옵션이 존재하면, 구현은 &lt;a href=&quot;asynchronouschannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드에 의해 닫힐 때 파일을 삭제하려고 &lt;em&gt;최선을 다합니다&lt;/em&gt; . 경우 &lt;code&gt;close&lt;/code&gt; 방법은 다음 호출되지 않는 &lt;em&gt;최선의 노력을&lt;/em&gt; 시도 할 때 Java 가상 머신의 종료 파일을 삭제한다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f88517540cae38f29035447f8bcd48cdb8f163b" translate="yes" xml:space="preserve">
          <source>When this option is present then the implementation makes a &lt;em&gt;best effort&lt;/em&gt; attempt to delete the file when closed by the the &lt;a href=&quot;spi/abstractinterruptiblechannel#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method. If the &lt;code&gt;close&lt;/code&gt; method is not invoked then a &lt;em&gt;best effort&lt;/em&gt; attempt is made to delete the file when the Java virtual machine terminates.</source>
          <target state="translated">이 옵션이 존재하면, 구현은 &lt;a href=&quot;spi/abstractinterruptiblechannel#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드에 의해 닫힐 때 파일을 삭제하려고 &lt;em&gt;최선을 다합니다&lt;/em&gt; . 경우 &lt;code&gt;close&lt;/code&gt; 방법은 다음 호출되지 않는 &lt;em&gt;최선의 노력을&lt;/em&gt; 시도 할 때 Java 가상 머신의 종료 파일을 삭제한다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7cc18013b4812cde5f7d9912f2b87d319240ca6" translate="yes" xml:space="preserve">
          <source>When this property changes, a property change event with name &quot;dropLocation&quot; is fired by the component.</source>
          <target state="translated">이 속성이 변경되면 이름이 &quot;dropLocation&quot;인 속성 변경 이벤트가 구성 요소에 의해 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="038f87151a058e2199fb9c59c3147f43fabc5ee1" translate="yes" xml:space="preserve">
          <source>When this stage completes normally, the given function is invoked with this stage's result as the argument, returning another CompletionStage. When that stage completes normally, the CompletionStage returned by this method is completed with the same value.</source>
          <target state="translated">이 단계가 정상적으로 완료되면 주어진 함수가이 단계의 결과를 인수로 사용하여 호출되어 다른 CompletionStage를 반환합니다. 해당 단계가 정상적으로 완료되면이 메서드에서 반환 된 CompletionStage는 동일한 값으로 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="939cadcf27e2f0c5c29ad269b174f1448284da61" translate="yes" xml:space="preserve">
          <source>When this stage is complete, the given action is invoked with the result (or &lt;code&gt;null&lt;/code&gt; if none) and the exception (or &lt;code&gt;null&lt;/code&gt; if none) of this stage as arguments. The returned stage is completed when the action returns.</source>
          <target state="translated">이 단계가 완료되면 주어진 조치가 결과 (또는 &lt;code&gt;null&lt;/code&gt; 경우 null ) 및 이 단계 의 예외 (또는 &lt;code&gt;null&lt;/code&gt; 경우 null )를 인수로 사용하여 호출됩니다. 반환 된 단계는 작업이 반환되면 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="aaf41e965e28c5483c92f84aed2e73228dbc1a97" translate="yes" xml:space="preserve">
          <source>When this stage is complete, the given action is invoked with the result (or &lt;code&gt;null&lt;/code&gt; if none) and the exception (or &lt;code&gt;null&lt;/code&gt; if none) of this stage as arguments. The returned stage is completed when the action returns. If the supplied action itself encounters an exception, then the returned stage exceptionally completes with this exception unless this stage also completed exceptionally.</source>
          <target state="translated">이 단계가 완료되면 주어진 조치가 인수로이 단계 의 결과 (또는 &lt;code&gt;null&lt;/code&gt; 경우 널 ) 및 예외 ( &lt;code&gt;null&lt;/code&gt; 경우 널 )와 함께 호출됩니다 . 조치가 리턴되면 리턴 된 스테이지가 완료됩니다. 제공된 조치 자체에 예외가 발생하면이 단계도 예외적으로 완료되지 않으면 리턴 된 단계는 예외적으로 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="3f6f82cd6d0f4507ceec2cd68bde83c6bb558834" translate="yes" xml:space="preserve">
          <source>When this stage is complete, the given function is invoked with the result (or &lt;code&gt;null&lt;/code&gt; if none) and the exception (or &lt;code&gt;null&lt;/code&gt; if none) of this stage as arguments, and the function's result is used to complete the returned stage.</source>
          <target state="translated">이 단계가 완료되면 지정된 함수가이 단계의 결과 (또는 &lt;code&gt;null&lt;/code&gt; 경우 &lt;code&gt;null&lt;/code&gt; )와이 단계 의 예외 (또는 없는 경우 널 )를 인수로 호출하고 함수의 결과는 리턴 된 단계를 완료하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bac49680cb60a5ee049452f6e78185889fe92438" translate="yes" xml:space="preserve">
          <source>When this stream reaches end of stream, further invocations of this method will return an empty byte array.</source>
          <target state="translated">이 스트림이 스트림 끝에 도달하면이 메서드를 추가로 호출하면 빈 바이트 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="48eb95265e7d021d7c0bcfe7d5877c9bf2e00f35" translate="yes" xml:space="preserve">
          <source>When to implement</source>
          <target state="translated">구현시기</target>
        </trans-unit>
        <trans-unit id="b19e6fec33654d65225b5a683c7ddc3223d7ead2" translate="yes" xml:space="preserve">
          <source>When to use this interface</source>
          <target state="translated">이 인터페이스를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="2987413b1ccabfe41476e5c2416ebf03f5549889" translate="yes" xml:space="preserve">
          <source>When traversing a graph, an object may be encountered that does not support the Serializable interface. In this case the NotSerializableException will be thrown and will identify the class of the non-serializable object.</source>
          <target state="translated">그래프를 순회 할 때 직렬화 가능 인터페이스를 지원하지 않는 오브젝트가 발생할 수 있습니다. 이 경우 NotSerializableException이 발생하고 직렬화 할 수없는 객체의 클래스를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="72491fa06ce4e80db58d269ec31cc9c29821a7b3" translate="yes" xml:space="preserve">
          <source>When two composite names are compared, the case of the characters is significant.</source>
          <target state="translated">두 개의 복합 이름을 비교할 때 문자의 대소 문자가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d39ea45a6268a67c061975b6eb4abdceccee5c88" translate="yes" xml:space="preserve">
          <source>When two or more interfaces of a proxy class contain a method with the same name and parameter signature, the order of the proxy class's interfaces becomes significant. When such a</source>
          <target state="translated">프록시 클래스의 둘 이상의 인터페이스에 동일한 이름 및 매개 변수 서명이있는 메소드가 포함되어 있으면 프록시 클래스의 인터페이스 순서가 중요해집니다. 그런 때</target>
        </trans-unit>
        <trans-unit id="824dd2ec1443a6d10bed31844958381a75362daa" translate="yes" xml:space="preserve">
          <source>When two or more proxy interfaces contain a method with the same name and parameter signature, the order of the proxy class's interfaces becomes significant. When such a</source>
          <target state="translated">두 개 이상의 프록시 인터페이스에 동일한 이름과 매개 변수 서명이있는 메서드가 포함되어 있으면 프록시 클래스의 인터페이스 순서가 중요해집니다. 그런 때</target>
        </trans-unit>
        <trans-unit id="f1f676950e16294bc9c468cad050677459c84e82" translate="yes" xml:space="preserve">
          <source>When two or more threads attempt to &lt;a href=&quot;#complete(T)&quot;&gt;&lt;code&gt;complete&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#completeExceptionally(java.lang.Throwable)&quot;&gt;&lt;code&gt;completeExceptionally&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#cancel(boolean)&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; a CompletableFuture, only one of them succeeds.</source>
          <target state="translated">두 개 이상의 스레드 가 CompletableFuture 를 &lt;a href=&quot;#complete(T)&quot;&gt; &lt;code&gt;complete&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#completeExceptionally(java.lang.Throwable)&quot;&gt; &lt;code&gt;completeExceptionally&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#cancel(boolean)&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt; 하려고 하면 그중 하나만 성공합니다.</target>
        </trans-unit>
        <trans-unit id="e2cbb5b6ffa96f013fd73efb6c2acd02f012d948" translate="yes" xml:space="preserve">
          <source>When two or more threads attempt to &lt;a href=&quot;completablefuture#complete-T-&quot;&gt;&lt;code&gt;complete&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;completablefuture#completeExceptionally-java.lang.Throwable-&quot;&gt;&lt;code&gt;completeExceptionally&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;completablefuture#cancel-boolean-&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; a CompletableFuture, only one of them succeeds.</source>
          <target state="translated">둘 이상의 스레드 가 CompletableFuture 를 &lt;a href=&quot;completablefuture#complete-T-&quot;&gt; &lt;code&gt;complete&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;completablefuture#completeExceptionally-java.lang.Throwable-&quot;&gt; &lt;code&gt;completeExceptionally&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;completablefuture#cancel-boolean-&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt; 하려고 시도 하면 그 중 하나만 성공합니다.</target>
        </trans-unit>
        <trans-unit id="58e55e5b4a52749f3a8f688b451a56c8f51e84a5" translate="yes" xml:space="preserve">
          <source>When used in &lt;a href=&quot;securerandom#getInstance(java.lang.String,java.security.SecureRandomParameters)&quot;&gt;&lt;code&gt;SecureRandom.getInstance(String, SecureRandomParameters)&lt;/code&gt;&lt;/a&gt; or one of the other similar &lt;code&gt;getInstance&lt;/code&gt; calls that take a &lt;code&gt;SecureRandomParameters&lt;/code&gt; parameter, it means the requested instantiate parameters the newly created &lt;code&gt;SecureRandom&lt;/code&gt; object must minimally support. When used as the return value of the &lt;a href=&quot;securerandom#getParameters()&quot;&gt;&lt;code&gt;SecureRandom.getParameters()&lt;/code&gt;&lt;/a&gt; method, it means the effective instantiate parameters of the &lt;code&gt;SecureRandom&lt;/code&gt; object.</source>
          <target state="translated">사용할 경우 &lt;a href=&quot;securerandom#getInstance(java.lang.String,java.security.SecureRandomParameters)&quot;&gt; &lt;code&gt;SecureRandom.getInstance(String, SecureRandomParameters)&lt;/code&gt; &lt;/a&gt; 또는 다른 유사한 하나 &lt;code&gt;getInstance&lt;/code&gt; 테이크 호출 &lt;code&gt;SecureRandomParameters&lt;/code&gt; 의 매개 변수를, 그것은 새로 만든 인스턴스화 매개 변수 요청 의미 &lt;code&gt;SecureRandom&lt;/code&gt; 객체가 최소한 지원해야합니다. &lt;a href=&quot;securerandom#getParameters()&quot;&gt; &lt;code&gt;SecureRandom.getParameters()&lt;/code&gt; &lt;/a&gt; 메서드 의 반환 값으로 사용되는 경우 &lt;code&gt;SecureRandom&lt;/code&gt; 개체 의 효과적인 인스턴스화 매개 변수를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="43ffb4ecf968163232f09f73384f19b3a01bf3e9" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt;, the above class produces the following output for various format strings.</source>
          <target state="translated">&lt;a href=&quot;formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 위의 클래스는 다양한 형식 문자열에 대해 다음 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7e3a4f8ce8f2ce779cc7d5b71b65b0b477e564ce" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the &lt;a href=&quot;formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt;, the above class produces the following output for various format strings. &lt;code&gt;Formatter fmt = new Formatter();
   StockName sn = new StockName(&quot;HUGE&quot;, &quot;Huge Fruit, Inc.&quot;,
                                &quot;Fruit Titanesque, Inc.&quot;);
   fmt.format(&quot;%s&quot;, sn);                   //   -&amp;gt; &quot;Huge Fruit, Inc.&quot;
   fmt.format(&quot;%s&quot;, sn.toString());        //   -&amp;gt; &quot;HUGE - Huge Fruit, Inc.&quot;
   fmt.format(&quot;%#s&quot;, sn);                  //   -&amp;gt; &quot;HUGE&quot;
   fmt.format(&quot;%-10.8s&quot;, sn);              //   -&amp;gt; &quot;HUGE      &quot;
   fmt.format(&quot;%.12s&quot;, sn);                //   -&amp;gt; &quot;Huge Fruit,*&quot;
   fmt.format(Locale.FRANCE, &quot;%25s&quot;, sn);  //   -&amp;gt; &quot;   Fruit Titanesque, Inc.&quot;
 &lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 위 클래스는 다양한 형식 문자열에 대해 다음과 같은 출력을 생성합니다. &lt;code&gt;Formatter fmt = new Formatter(); StockName sn = new StockName(&quot;HUGE&quot;, &quot;Huge Fruit, Inc.&quot;, &quot;Fruit Titanesque, Inc.&quot;); fmt.format(&quot;%s&quot;, sn); // -&amp;gt; &quot;Huge Fruit, Inc.&quot; fmt.format(&quot;%s&quot;, sn.toString()); // -&amp;gt; &quot;HUGE - Huge Fruit, Inc.&quot; fmt.format(&quot;%#s&quot;, sn); // -&amp;gt; &quot;HUGE&quot; fmt.format(&quot;%-10.8s&quot;, sn); // -&amp;gt; &quot;HUGE &quot; fmt.format(&quot;%.12s&quot;, sn); // -&amp;gt; &quot;Huge Fruit,*&quot; fmt.format(Locale.FRANCE, &quot;%25s&quot;, sn); // -&amp;gt; &quot; Fruit Titanesque, Inc.&quot; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35a55ec2987f39f2327b6b1dee7f6dda3600a7d1" translate="yes" xml:space="preserve">
          <source>When used in the context of annotation processing, an accurate model of the element being represented must be returned. As this is a language model, the source code provides the fiducial (reference) representation of the construct in question rather than a representation in an executable output like a class file. Executable output may serve as the basis for creating a modeling element. However, the process of translating source code to executable output may not permit recovering some aspects of the source code representation. For example, annotations with &lt;a href=&quot;../../../../../java.base/java/lang/annotation/retentionpolicy#SOURCE&quot;&gt;source&lt;/a&gt;&lt;a href=&quot;../../../../../java.base/java/lang/annotation/retention&quot;&gt;retention&lt;/a&gt; cannot be recovered from class files and class files might not be able to provide source position information. Names of parameters may not be recoverable from class files. The &lt;a href=&quot;modifier&quot;&gt;modifiers&lt;/a&gt; on an element created from a class file may differ in some cases from an element for the same declaration created from a source file including:</source>
          <target state="translated">주석 처리의 맥락에서 사용되는 경우 표현되는 요소의 정확한 모델이 반환되어야합니다. 이것은 언어 모델이기 때문에 소스 코드는 클래스 파일과 같은 실행 가능한 출력의 표현이 아닌 문제의 구조에 대한 기준 (참조) 표현을 제공합니다. 실행 가능한 출력은 모델링 요소를 생성하기위한 기반이 될 수 있습니다. 그러나 소스 코드를 실행 가능한 출력으로 변환하는 프로세스는 소스 코드 표현의 일부 측면을 복구하는 것을 허용하지 않을 수 있습니다. 예를 들어, &lt;a href=&quot;../../../../../java.base/java/lang/annotation/retentionpolicy#SOURCE&quot;&gt;소스 &lt;/a&gt;&lt;a href=&quot;../../../../../java.base/java/lang/annotation/retention&quot;&gt;보존이&lt;/a&gt; 있는 어노테이션 은 클래스 파일에서 복구 할 수 없으며 클래스 파일은 소스 위치 정보를 제공하지 못할 수 있습니다. 매개 변수 이름은 클래스 파일에서 복구 할 수 없습니다. &lt;a href=&quot;modifier&quot;&gt;수정&lt;/a&gt; 클래스 파일에서 생성 된 요소는 경우에 따라 다음을 포함하여 소스 파일에서 생성 된 동일한 선언에 대한 요소와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ece0b7fb1ed791cbe7da72a2d53b96e1e02fbd42" translate="yes" xml:space="preserve">
          <source>When used in the context of annotation processing, an accurate model of the element being represented must be returned. As this is a language model, the source code provides the fiducial (reference) representation of the construct in question rather than a representation in an executable output like a class file. Executable output may serve as the basis for creating a modeling element. However, the process of translating source code to executable output may not permit recovering some aspects of the source code representation. For example, annotations with &lt;a href=&quot;../../../../java/lang/annotation/retentionpolicy#SOURCE&quot;&gt;source&lt;/a&gt;&lt;a href=&quot;../../../../java/lang/annotation/retention&quot;&gt;retention&lt;/a&gt; cannot be recovered from class files and class files might not be able to provide source position information. Names of parameters may not be recoverable from class files. The &lt;a href=&quot;modifier&quot;&gt;modifiers&lt;/a&gt; on an element may differ in some cases including:</source>
          <target state="translated">주석 처리의 맥락에서 사용될 때, 표현되는 요소의 정확한 모델이 반환되어야합니다. 이것이 언어 모델이기 때문에 소스 코드는 클래스 파일과 같은 실행 가능한 출력의 표현이 아니라 해당 구문의 기준 (기준) 표현을 제공합니다. 실행 가능한 출력은 모델링 요소를 생성하기위한 기초로 사용될 수 있습니다. 그러나 소스 코드를 실행 가능한 출력으로 변환하는 프로세스는 소스 코드 표현의 일부 측면을 복구하지 못할 수 있습니다. 예를 들어, &lt;a href=&quot;../../../../java/lang/annotation/retentionpolicy#SOURCE&quot;&gt;소스 &lt;/a&gt;&lt;a href=&quot;../../../../java/lang/annotation/retention&quot;&gt;보유가&lt;/a&gt; 있는 주석은 클래스 파일에서 복구 할 수 없으며 클래스 파일이 소스 위치 정보를 제공하지 못할 수 있습니다. 클래스 파일에서 매개 변수 이름을 복구 할 수 없습니다. &lt;a href=&quot;modifier&quot;&gt;수정&lt;/a&gt; 요소에 따라 다음과 같은 경우가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ecb08ff72bf2beff0f22f91d00d7f8a358093b0" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems it must correspond to an integral number of days and is normally an integral number of years.</source>
          <target state="translated">다른 달력 시스템과 함께 사용하는 경우 정수일에 해당해야하며 일반적으로 정수 년입니다.</target>
        </trans-unit>
        <trans-unit id="f21fcfe8b96da09eeaeaa464fe8fd54f0f415d2c" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems it must correspond to an integral number of days or months roughly equal to a year defined by the passage of the Earth around the Sun.</source>
          <target state="translated">다른 달력 시스템과 함께 사용하는 경우 태양 주위의 지구 통과에 의해 정의 된 연도와 대략 같은 일수 또는 월수에 해당해야합니다.</target>
        </trans-unit>
        <trans-unit id="a27413589719b5a8253a0b8d9af0f9739bd28a5f" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems it must correspond to an integral number of days.</source>
          <target state="translated">다른 달력 시스템과 함께 사용하는 경우 정수일에 해당해야합니다.</target>
        </trans-unit>
        <trans-unit id="9efada4e2737579f4bfde83c300d21f0a7943686" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems it must correspond to the day defined by the rising and setting of the Sun on Earth. It is not required that days begin at midnight - when converting between calendar systems, the date should be equivalent at midday.</source>
          <target state="translated">다른 달력 시스템과 함께 사용하는 경우 지구상의 태양의 상승 및 설정에 의해 정의 된 날짜와 일치해야합니다. 달력 시스템간에 변환 할 때 날짜는 자정에 시작하지 않아도됩니다. 날짜는 정오와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="62385eeb0c56551d6fa61230b23e3cea9e372c16" translate="yes" xml:space="preserve">
          <source>When used with other calendar systems there are no restrictions on the unit.</source>
          <target state="translated">다른 달력 시스템과 함께 사용하면 장치에 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="62abbe6041a1324368c7391f51baabfb09713986" translate="yes" xml:space="preserve">
          <source>When used with the GSSContext interface's wrap and getMIC methods, an instance of this class is used to indicate the desired Quality-of-Protection (QOP) and to request if confidentiality services are to be applied to caller supplied data (wrap only). To request default QOP, the value of 0 should be used for QOP.</source>
          <target state="translated">GSSContext 인터페이스의 wrap 및 getMIC 메소드와 함께 사용될 때,이 클래스의 인스턴스는 원하는 QOP (Quality-of-Protection)를 표시하고 기밀성 서비스가 호출자 제공 데이터에 적용 될지 여부를 요청하는 데 사용됩니다 (랩만 해당). 기본 QOP를 요청하려면 QOP에 0 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="313c2c16bb6b15d1f21bba9cb9b9b5bc5566a742" translate="yes" xml:space="preserve">
          <source>When used with the unwrap and verifyMIC methods of the GSSContext interface, an instance of this class will be used to indicate the applied QOP and confidentiality services over the supplied message. In the case of verifyMIC, the confidentiality state will always be &lt;code&gt;false&lt;/code&gt;. Upon return from these methods, this object will also contain any supplementary status values applicable to the processed token. The supplementary status values can indicate old tokens, out of sequence tokens, gap tokens or duplicate tokens.</source>
          <target state="translated">GSSContext 인터페이스의 unwrap 및 verifyMIC 메서드와 함께 사용되는 경우이 클래스의 인스턴스는 제공된 메시지를 통해 적용된 QOP 및 기밀성 서비스를 나타내는 데 사용됩니다. verifyMIC의 경우 기밀성 상태는 항상 &lt;code&gt;false&lt;/code&gt; 입니다. 이러한 메서드에서 반환되면이 개체에는 처리 된 토큰에 적용 할 수있는 추가 상태 값도 포함됩니다. 보충 상태 값은 오래된 토큰, 순서를 벗어난 토큰, 갭 토큰 또는 중복 토큰을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e6a51ecf8fcb17dbda43fef7e1c274e8aff30af" translate="yes" xml:space="preserve">
          <source>When used, this method changes the parsing to be lenient from this point onwards. The change will remain in force until the end of the formatter that is eventually constructed or until &lt;code&gt;parseStrict&lt;/code&gt; is called.</source>
          <target state="translated">이 방법을 사용하면이 시점부터 구문 분석이 관 대해집니다. 변경은 결국 생성 된 포맷터가 끝날 때까지 또는 &lt;code&gt;parseStrict&lt;/code&gt; 가 호출 될 때까지 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="ff556f1f879598b7bb76a699a0aec5ddb4224db2" translate="yes" xml:space="preserve">
          <source>When used, this method changes the parsing to be strict from this point onwards. As strict is the default, this is normally only needed after calling &lt;a href=&quot;#parseLenient()&quot;&gt;&lt;code&gt;parseLenient()&lt;/code&gt;&lt;/a&gt;. The change will remain in force until the end of the formatter that is eventually constructed or until &lt;code&gt;parseLenient&lt;/code&gt; is called.</source>
          <target state="translated">이 메서드를 사용하면이 시점부터 구문 분석이 엄격하게 변경됩니다. 엄격이 기본값이므로 일반적으로 &lt;a href=&quot;#parseLenient()&quot;&gt; &lt;code&gt;parseLenient()&lt;/code&gt; &lt;/a&gt; 호출 한 후에 만 ​​필요합니다 . 최종적으로 구성되는 포맷터가 끝날 때까지 또는 &lt;code&gt;parseLenient&lt;/code&gt; 가 호출 될 때까지 변경 사항 이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5af032fc78d26434042d41d26faa4d468835b7bf" translate="yes" xml:space="preserve">
          <source>When used, this method changes the parsing to be strict from this point onwards. As strict is the default, this is normally only needed after calling &lt;a href=&quot;datetimeformatterbuilder#parseLenient--&quot;&gt;&lt;code&gt;parseLenient()&lt;/code&gt;&lt;/a&gt;. The change will remain in force until the end of the formatter that is eventually constructed or until &lt;code&gt;parseLenient&lt;/code&gt; is called.</source>
          <target state="translated">이 방법을 사용하면이 시점부터 구문 분석이 엄격하게 변경됩니다. 엄격이 기본값이므로 일반적으로 &lt;a href=&quot;datetimeformatterbuilder#parseLenient--&quot;&gt; &lt;code&gt;parseLenient()&lt;/code&gt; &lt;/a&gt; 호출 한 후에 만 ​​필요합니다 . 변경은 최종적으로 생성 된 포맷터가 끝날 때까지 또는 &lt;code&gt;parseLenient&lt;/code&gt; 가 호출 될 때까지 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="3bea6a91a61ac47b8bd9736fff1365a319fd7ad0" translate="yes" xml:space="preserve">
          <source>When using a capacity-restricted deque, it is generally preferable to call &lt;a href=&quot;#offer(E)&quot;&gt;&lt;code&gt;offer&lt;/code&gt;&lt;/a&gt; separately on each element.</source>
          <target state="translated">용량이 제한된 deque를 사용하는 경우 일반적으로 각 요소에 대해 별도로 &lt;a href=&quot;#offer(E)&quot;&gt; &lt;code&gt;offer&lt;/code&gt; &lt;/a&gt; 를 호출 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="da316a4cc51c1899088ef95b5f213463772f58cf" translate="yes" xml:space="preserve">
          <source>When using a loader's &lt;a href=&quot;serviceloader#stream()&quot;&gt;&lt;code&gt;stream()&lt;/code&gt;&lt;/a&gt; method then the elements are of type &lt;code&gt;Provider&lt;/code&gt;. This allows processing to select or filter on the provider class without instantiating the provider.</source>
          <target state="translated">로더의 &lt;a href=&quot;serviceloader#stream()&quot;&gt; &lt;code&gt;stream()&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 때 요소는 &lt;code&gt;Provider&lt;/code&gt; 유형 입니다. 이를 통해 처리는 공급자를 인스턴스화하지 않고도 공급자 클래스를 선택하거나 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31ca175d1f09c132ed4a2c9c0157e1e350eb6ede" translate="yes" xml:space="preserve">
          <source>When using the IIOP transport, the client and server can specify what ORB to use with the attribute &lt;code&gt;java.naming.corba.orb&lt;/code&gt;. Connection to the ORB happens at &lt;a href=&quot;rmiconnectorserver#start--&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt; time for the connector server, and at &lt;a href=&quot;rmiconnector#connect-java.util.Map-&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; time for the connector client. If the &lt;code&gt;java.naming.corba.orb&lt;/code&gt; attribute is contained in the environment Map, then its value (an &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt;&lt;code&gt;ORB&lt;/code&gt;&lt;/a&gt;), is used to connect the IIOP Stubs. Otherwise, a new org.omg.CORBA.ORB is created by calling &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt;&lt;code&gt;org.omg.CORBA.ORB.init((String[])null,(Properties)null)&lt;/code&gt;&lt;/a&gt;. A later RMI connector client or server in the same JVM can reuse this ORB, or it can create another one in the same way.</source>
          <target state="translated">IIOP 전송을 사용할 때 클라이언트와 서버는 속성 &lt;code&gt;java.naming.corba.orb&lt;/code&gt; 와 함께 사용할 ORB를 지정할 수 있습니다 . ORB 에 대한 연결은 커넥터 서버의 &lt;a href=&quot;rmiconnectorserver#start--&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt; 시간과 커넥터 클라이언트의 &lt;a href=&quot;rmiconnector#connect-java.util.Map-&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 시간에 발생합니다. 경우] &lt;code&gt;java.naming.corba.orb&lt;/code&gt; 를의 특성이 환경지도, 그 값 (AN에 포함 &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt; &lt;code&gt;ORB&lt;/code&gt; &lt;/a&gt; )는 IIOP 스텁을 연결하는 데 사용된다. 그렇지 않으면 &lt;a href=&quot;/openjdk~8_web/org/omg/corba/orb&quot;&gt; &lt;code&gt;org.omg.CORBA.ORB.init((String[])null,(Properties)null)&lt;/code&gt; &lt;/a&gt; 을 호출하여 새 org.omg.CORBA.ORB가 작성됩니다 . 동일한 JVM의 이후 RMI 커넥터 클라이언트 또는 서버는이 ORB를 재사용하거나 동일한 방식으로 다른 ORB를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1094d843de7943a57b50e6ec3d12297784b464f6" translate="yes" xml:space="preserve">
          <source>When using the beanName as a serialized object name we convert the given beanName to a resource pathname and add a trailing &quot;.ser&quot; suffix. We then try to load a serialized object from that resource.</source>
          <target state="translated">beanName을 직렬화 된 객체 이름으로 사용하는 경우 제공된 beanName을 자원 경로 이름으로 변환하고 후미 &quot;.ser&quot;접미사를 추가합니다. 그런 다음 해당 리소스에서 직렬화 된 개체를로드하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a40a619f30648218521f9a9f35ae6461ea88f8ec" translate="yes" xml:space="preserve">
          <source>When using the default JRMP transport, RMI socket factories can be specified using the attributes &lt;code&gt;jmx.remote.rmi.client.socket.factory&lt;/code&gt; and &lt;code&gt;jmx.remote.rmi.server.socket.factory&lt;/code&gt; in the &lt;code&gt;environment&lt;/code&gt; given to the &lt;code&gt;RMIConnectorServer&lt;/code&gt; constructor. The values of these attributes must be of type &lt;a href=&quot;../../../../../java.rmi/java/rmi/server/rmiclientsocketfactory&quot;&gt;&lt;code&gt;RMIClientSocketFactory&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../../../java.rmi/java/rmi/server/rmiserversocketfactory&quot;&gt;&lt;code&gt;RMIServerSocketFactory&lt;/code&gt;&lt;/a&gt;, respectively. These factories are used when creating the RMI objects associated with the connector.</source>
          <target state="translated">기본 JRMP 전송을 사용하는 경우 &lt;code&gt;RMIConnectorServer&lt;/code&gt; 생성자에 지정된 &lt;code&gt;environment&lt;/code&gt; 에서 &lt;code&gt;jmx.remote.rmi.client.socket.factory&lt;/code&gt; 및 &lt;code&gt;jmx.remote.rmi.server.socket.factory&lt;/code&gt; 속성을 사용하여 RMI 소켓 팩토리를 지정할 수 있습니다 . 이러한 속성의 값은 각각 &lt;a href=&quot;../../../../../java.rmi/java/rmi/server/rmiclientsocketfactory&quot;&gt; &lt;code&gt;RMIClientSocketFactory&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../../../java.rmi/java/rmi/server/rmiserversocketfactory&quot;&gt; &lt;code&gt;RMIServerSocketFactory&lt;/code&gt; &lt;/a&gt; 유형이어야합니다 . 이러한 팩토리는 커넥터와 관련된 RMI 개체를 만들 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b289c10690d3b720cf943c114f2a703d731c855" translate="yes" xml:space="preserve">
          <source>When using the default JRMP transport, RMI socket factories can be specified using the attributes &lt;code&gt;jmx.remote.rmi.client.socket.factory&lt;/code&gt; and &lt;code&gt;jmx.remote.rmi.server.socket.factory&lt;/code&gt; in the &lt;code&gt;environment&lt;/code&gt; given to the &lt;code&gt;RMIConnectorServer&lt;/code&gt; constructor. The values of these attributes must be of type &lt;a href=&quot;/openjdk~8_web/java/rmi/server/rmiclientsocketfactory&quot;&gt;&lt;code&gt;RMIClientSocketFactory&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;/openjdk~8_web/java/rmi/server/rmiserversocketfactory&quot;&gt;&lt;code&gt;RMIServerSocketFactory&lt;/code&gt;&lt;/a&gt;, respectively. These factories are used when creating the RMI objects associated with the connector.</source>
          <target state="translated">기본 JRMP 전송을 사용하는 경우 &lt;code&gt;RMIConnectorServer&lt;/code&gt; 생성자에 지정된 &lt;code&gt;environment&lt;/code&gt; 에서 &lt;code&gt;jmx.remote.rmi.client.socket.factory&lt;/code&gt; 및 &lt;code&gt;jmx.remote.rmi.server.socket.factory&lt;/code&gt; 속성을 사용하여 RMI 소켓 팩토리를 지정할 수 있습니다 . 이러한 속성의 값은 각각 &lt;a href=&quot;/openjdk~8_web/java/rmi/server/rmiclientsocketfactory&quot;&gt; &lt;code&gt;RMIClientSocketFactory&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;/openjdk~8_web/java/rmi/server/rmiserversocketfactory&quot;&gt; &lt;code&gt;RMIServerSocketFactory&lt;/code&gt; &lt;/a&gt; 유형이어야합니다 . 이 팩토리는 커넥터와 연관된 RMI 오브젝트를 작성할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e657ee77256cf44030f873d13206c74a10610ec" translate="yes" xml:space="preserve">
          <source>When using the service loader's &lt;code&gt;iterator&lt;/code&gt;, the &lt;a href=&quot;iterator#hasNext()&quot;&gt;&lt;code&gt;hasNext&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iterator#next()&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; methods will fail with &lt;a href=&quot;serviceconfigurationerror&quot;&gt;&lt;code&gt;ServiceConfigurationError&lt;/code&gt;&lt;/a&gt; if an error occurs locating, loading or instantiating a service provider. When processing the service loader's stream then &lt;code&gt;ServiceConfigurationError&lt;/code&gt; may be thrown by any method that causes a service provider to be located or loaded.</source>
          <target state="translated">서비스 로더의 &lt;code&gt;iterator&lt;/code&gt; 를 사용할 때 서비스 제공자를 찾거나로드하거나 인스턴스화하는 중에 오류가 발생 하면 &lt;a href=&quot;iterator#hasNext()&quot;&gt; &lt;code&gt;hasNext&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;iterator#next()&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;serviceconfigurationerror&quot;&gt; &lt;code&gt;ServiceConfigurationError&lt;/code&gt; &lt;/a&gt; 와 함께 실패 합니다. 서비스 로더의 스트림을 처리 할 때 서비스 공급자를 찾거나로드하는 모든 메서드에 의해 &lt;code&gt;ServiceConfigurationError&lt;/code&gt; 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba566ef2656d9a242d602964e496b4d893948bab" translate="yes" xml:space="preserve">
          <source>When using this constructor, the Namespace URI is set to &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt;&lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt;&lt;/a&gt; and the prefix is set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 생성자를 사용할 때 네임 스페이스 URI는 &lt;a href=&quot;../xmlconstants#NULL_NS_URI&quot;&gt; &lt;code&gt;XMLConstants.NULL_NS_URI&lt;/code&gt; &lt;/a&gt; 로 설정되고 접두사는 &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="96c5642595e980fed49cb21924a5425817039bc3" translate="yes" xml:space="preserve">
          <source>When using this constructor, the prefix is set to &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 생성자를 사용할 때 접두사는 &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e87d4e305eeee8d02bfe9d7476f259cac952cdb2" translate="yes" xml:space="preserve">
          <source>When viewed as a character sequence, the length of a character buffer is simply the number of characters between the position (inclusive) and the limit (exclusive); that is, it is equivalent to &lt;code&gt;remaining()&lt;/code&gt;.</source>
          <target state="translated">문자 순서로 볼 때 문자 버퍼의 길이는 단순히 위치 (포함)와 한계 (제외) 사이의 문자 수입니다. 즉, &lt;code&gt;remaining()&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b74b06615a3effa44bf4fa9888e60a5a1492ac50" translate="yes" xml:space="preserve">
          <source>When viewed as a member of a third type &lt;code&gt;C&lt;/code&gt;, however, the method in &lt;code&gt;A&lt;/code&gt; does override the one in &lt;code&gt;B&lt;/code&gt;:</source>
          <target state="translated">세번째 형태의 부재로 간주 할 때 &lt;code&gt;C&lt;/code&gt; 그러나에있어서 &lt;code&gt;A&lt;/code&gt; 는 에서 무시하지 하나 &lt;code&gt;B&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="70641d46fc36740d8882e1912ac1db22e717a0cd" translate="yes" xml:space="preserve">
          <source>When waiting upon a &lt;code&gt;Condition&lt;/code&gt;, a &quot;&lt;em&gt;spurious wakeup&lt;/em&gt;&quot; is permitted to occur, in general, as a concession to the underlying platform semantics. This has little practical impact on most application programs as a &lt;code&gt;Condition&lt;/code&gt; should always be waited upon in a loop, testing the state predicate that is being waited for. An implementation is free to remove the possibility of spurious wakeups but it is recommended that applications programmers always assume that they can occur and so always wait in a loop.</source>
          <target state="translated">&lt;code&gt;Condition&lt;/code&gt; 기다릴 때 일반적으로 기본 플랫폼 의미에 대한 양보로 &quot; &lt;em&gt;스퓨리어스 웨이크 업&lt;/em&gt; &quot;이 발생할 수 있습니다. &lt;code&gt;Condition&lt;/code&gt; 은 항상 루프에서 대기하고 대기중인 상태 술어를 테스트해야 하므로 대부분의 응용 프로그램에는 거의 영향을 미치지 않습니다 . 구현은 가짜 웨이크 업의 가능성을 자유롭게 제거 할 수 있지만 응용 프로그램 프로그래머는 항상 발생할 수 있다고 가정하여 항상 루프에서 대기하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4246b2cc19c9676bfe631da16932f916fd42e34e" translate="yes" xml:space="preserve">
          <source>When warnings/errors/fatal errors are found by the validator, the parser must handle them as if those errors were found by the parser itself. In other words, if the user-specified &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; is set, it must receive those errors, and if not, they must be treated according to the implementation specific default error handling rules.</source>
          <target state="translated">유효성 검사기에서 경고 / 오류 / 치명적 오류를 발견하면 파서가 해당 오류를 파서 자체에서 찾은 것처럼 처리해야합니다. 즉, 사용자 지정 &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt; 가 설정되면 해당 오류를 수신해야하며 그렇지 않은 경우 구현 특정 기본 오류 처리 규칙에 따라 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b65ea9216658615a74fbadc89129a9320a6d2b4" translate="yes" xml:space="preserve">
          <source>When writing a multi-threaded application using Swing, there are two constraints to keep in mind: (refer to &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt; Concurrency in Swing &lt;/a&gt; for more details):</source>
          <target state="translated">Swing을 사용하여 멀티 스레드 애플리케이션을 작성할 때 염두에 두어야 할 두 가지 제약이 있습니다. ( 자세한 내용 &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/concurrency/index.html&quot;&gt;은 Swing의 동시성&lt;/a&gt; 참조) :</target>
        </trans-unit>
        <trans-unit id="50097f566388737a84366cf10ac13d1ccd775d2d" translate="yes" xml:space="preserve">
          <source>When writing an image, its metadata may be set by defining or modifying an &lt;code&gt;IIOMetadata&lt;/code&gt; object. Such an object may be obtained from an &lt;code&gt;ImageWriter&lt;/code&gt; or &lt;code&gt;ImageTranscoder&lt;/code&gt; (from the &lt;code&gt;javax.imageio&lt;/code&gt; package). Once such an object has been obtained, its contents may be set of modified via a &lt;code&gt;Document&lt;/code&gt; consisting of &lt;code&gt;IIOMetadataNode&lt;/code&gt;s. The document format may optionally be described using an &lt;code&gt;IIOMetadataFormat&lt;/code&gt; object.</source>
          <target state="translated">이미지를 쓸 때 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체를 정의하거나 수정하여 메타 데이터를 설정할 수 있습니다 . 이러한 객체는 &lt;code&gt;ImageWriter&lt;/code&gt; 또는 &lt;code&gt;ImageTranscoder&lt;/code&gt; ( &lt;code&gt;javax.imageio&lt;/code&gt; 패키지) 에서 얻을 수 있습니다 . 이러한 객체가 획득되면, &lt;code&gt;IIOMetadataNode&lt;/code&gt; 로 구성된 &lt;code&gt;Document&lt;/code&gt; 를 통해 그 내용을 수정할 수 있습니다 . &lt;code&gt;IIOMetadataFormat&lt;/code&gt; 객체를 사용하여 문서 형식을 선택적으로 설명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44b4a60f0d785ceae4f2f44785b50fadd22e0a67" translate="yes" xml:space="preserve">
          <source>When writing to a &lt;code&gt;LSOutput&lt;/code&gt;, the encoding is found by looking at the encoding information that is reachable through the &lt;code&gt;LSOutput&lt;/code&gt; and the item to be written (or its owner document) in this order:</source>
          <target state="translated">A를 쓸 때 &lt;code&gt;LSOutput&lt;/code&gt; , 인코딩은 통해 도달 할 수있는 인코딩 정보를보고 발견 &lt;code&gt;LSOutput&lt;/code&gt; 이 순서로 작성하고 항목 (또는 소유자 문서) :</target>
        </trans-unit>
        <trans-unit id="d2afab89366cad1e703d500543bdeff2a26cf52f" translate="yes" xml:space="preserve">
          <source>When writing to a HTTP URI, a HTTP PUT is performed. When writing to other types of URIs, the mechanism for writing the data to the URI is implementation dependent.</source>
          <target state="translated">HTTP URI에 쓸 때 HTTP PUT가 수행됩니다. 다른 유형의 URI에 쓸 때 URI에 데이터를 쓰는 메커니즘은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="da3859e404597e0949c5fd1f7d9550737c714ec5" translate="yes" xml:space="preserve">
          <source>When writing, an &lt;a href=&quot;../../metadata/iiometadata&quot;&gt;&lt;code&gt;IIOMetadata&lt;/code&gt;&lt;/a&gt; object for use by one of the &lt;code&gt;write()&lt;/code&gt; methods of &lt;a href=&quot;../../imagewriter&quot;&gt;&lt;code&gt;ImageWriter&lt;/code&gt;&lt;/a&gt; may be created from a &lt;code&gt;TIFFDirectory&lt;/code&gt; by &lt;a href=&quot;#getAsMetadata()&quot;&gt;&lt;code&gt;getAsMetadata()&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;TIFFDirectory&lt;/code&gt; itself may be created by construction or from the &lt;code&gt;IIOMetadata&lt;/code&gt; object returned by &lt;a href=&quot;../../imagewriter#getDefaultImageMetadata(javax.imageio.ImageTypeSpecifier,javax.imageio.ImageWriteParam)&quot;&gt;&lt;code&gt;ImageWriter.getDefaultImageMetadata()&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;TIFFField&lt;/code&gt;s in the directory may be set using the mutator methods provided in this class.</source>
          <target state="translated">, 작성할 때 &lt;a href=&quot;../../metadata/iiometadata&quot;&gt; &lt;code&gt;IIOMetadata&lt;/code&gt; &lt;/a&gt; 중 하나에 의한 사용을 위해 객체를 &lt;code&gt;write()&lt;/code&gt; 방법 &lt;a href=&quot;../../imagewriter&quot;&gt; &lt;code&gt;ImageWriter&lt;/code&gt; &lt;/a&gt; A로부터 생성 될 수있다 &lt;code&gt;TIFFDirectory&lt;/code&gt; 의해 &lt;a href=&quot;#getAsMetadata()&quot;&gt; &lt;code&gt;getAsMetadata()&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;TIFFDirectory&lt;/code&gt; 자체 구성하거나로부터 생성 될 수 &lt;code&gt;IIOMetadata&lt;/code&gt; 의해 리턴 된 객체 &lt;a href=&quot;../../imagewriter#getDefaultImageMetadata(javax.imageio.ImageTypeSpecifier,javax.imageio.ImageWriteParam)&quot;&gt; &lt;code&gt;ImageWriter.getDefaultImageMetadata()&lt;/code&gt; &lt;/a&gt; . 디렉토리 의 &lt;code&gt;TIFFField&lt;/code&gt; 는이 클래스에서 제공하는 mutator 메소드를 사용하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eea2b78361ef1f62a351050fb4d8e084b0419681" translate="yes" xml:space="preserve">
          <source>When writing, the destination type maybe used to determine the color type of the image. The &lt;code&gt;SampleModel&lt;/code&gt; information will be ignored, and may be &lt;code&gt;null&lt;/code&gt;. For example, a 4-banded image could represent either CMYK or RGBA data. If a destination type is set, its &lt;code&gt;ColorModel&lt;/code&gt; will override any &lt;code&gt;ColorModel&lt;/code&gt; on the image itself. This is crucial when &lt;code&gt;setSourceBands&lt;/code&gt; is used since the image's &lt;code&gt;ColorModel&lt;/code&gt; will refer to the entire image rather than to the subset of bands being written.</source>
          <target state="translated">기록 할 때 대상 유형이 이미지의 색상 유형을 결정하는 데 사용될 수 있습니다. &lt;code&gt;SampleModel&lt;/code&gt; 정보는 무시되고, 할 수있다 &lt;code&gt;null&lt;/code&gt; . 예를 들어, 4 밴드 이미지는 CMYK 또는 RGBA 데이터를 나타낼 수 있습니다. 대상 유형이 설정되면 해당 &lt;code&gt;ColorModel&lt;/code&gt; 은 이미지 자체의 모든 &lt;code&gt;ColorModel&lt;/code&gt; 을 재정의 합니다. 이는 이미지의 &lt;code&gt;ColorModel&lt;/code&gt; 이 작성되는 밴드의 하위 집합이 아닌 전체 이미지를 참조 하므로 &lt;code&gt;setSourceBands&lt;/code&gt; 를 사용할 때 중요 합니다 .</target>
        </trans-unit>
        <trans-unit id="9a6b169cf5cbb999580ca1588fd37eab8e71b189" translate="yes" xml:space="preserve">
          <source>When you create an initial context (&lt;code&gt;InitialLdapContext&lt;/code&gt;), you can specify a list of request controls. These controls will be used as the request controls for any implicit LDAP &quot;bind&quot; operation performed by the context or contexts derived from the context. These are called &lt;em&gt;connection request controls&lt;/em&gt;. Use &lt;code&gt;getConnectControls()&lt;/code&gt; to get a context's connection request controls.</source>
          <target state="translated">초기 컨텍스트 ( &lt;code&gt;InitialLdapContext&lt;/code&gt; ) 를 작성할 때 요청 제어 목록을 지정할 수 있습니다. 이러한 제어는 컨텍스트 또는 컨텍스트에서 파생 된 컨텍스트에 의해 수행 된 내재 된 LDAP &quot;바인드&quot;조작에 대한 요청 제어로 사용됩니다. 이것을 &lt;em&gt;연결 요청 컨트롤&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . &lt;code&gt;getConnectControls()&lt;/code&gt; 를 사용 하여 컨텍스트의 연결 요청 제어를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="7a55210ed8a9bbd91ed99904496d79d9e437e1c1" translate="yes" xml:space="preserve">
          <source>When you request this property, &lt;code&gt;LabelView&lt;/code&gt; re-syncs its state with the properties of the &lt;code&gt;Element&lt;/code&gt;'s &lt;code&gt;AttributeSet&lt;/code&gt;. If &lt;code&gt;Element&lt;/code&gt;'s &lt;code&gt;AttributeSet&lt;/code&gt; does not have this property set, it will revert to false.</source>
          <target state="translated">이 속성을 요청하면 &lt;code&gt;LabelView&lt;/code&gt; 는 해당 상태를 &lt;code&gt;Element&lt;/code&gt; 의 &lt;code&gt;AttributeSet&lt;/code&gt; 속성 과 다시 동기화합니다 . 경우 &lt;code&gt;Element&lt;/code&gt; 의 &lt;code&gt;AttributeSet&lt;/code&gt; 이 속성이 설정되지 않은, false에 되돌려집니다.</target>
        </trans-unit>
        <trans-unit id="76c291d7ec2e2a61da9c355ee091458c7391b573" translate="yes" xml:space="preserve">
          <source>When you want the &lt;code&gt;SwingWorker&lt;/code&gt; to block on the</source>
          <target state="translated">&lt;code&gt;SwingWorker&lt;/code&gt; 를 차단 하려는 경우</target>
        </trans-unit>
        <trans-unit id="221e0f97f37cb411d57af917bcf79190807898c6" translate="yes" xml:space="preserve">
          <source>When your program needs a locale-specific object, it loads the &lt;code&gt;ResourceBundle&lt;/code&gt; class using the &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale)&quot;&gt;&lt;code&gt;getBundle&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">프로그램에 로케일 별 객체가 필요한 경우 &lt;a href=&quot;#getBundle(java.lang.String,java.util.Locale)&quot;&gt; &lt;code&gt;getBundle&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;ResourceBundle&lt;/code&gt; 클래스를 로드합니다 .</target>
        </trans-unit>
        <trans-unit id="f5d6850ccbdf18f11fe78451acaa45891ec324a4" translate="yes" xml:space="preserve">
          <source>When your program needs a locale-specific object, it loads the &lt;code&gt;ResourceBundle&lt;/code&gt; class using the &lt;a href=&quot;resourcebundle#getBundle-java.lang.String-java.util.Locale-&quot;&gt;&lt;code&gt;getBundle&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">프로그램에 로케일 특정 오브젝트가 필요한 경우 &lt;a href=&quot;resourcebundle#getBundle-java.lang.String-java.util.Locale-&quot;&gt; &lt;code&gt;getBundle&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;code&gt;ResourceBundle&lt;/code&gt; 클래스를 로드합니다 .</target>
        </trans-unit>
        <trans-unit id="294687126fefbc03d977b1180723b4fd8063c95a" translate="yes" xml:space="preserve">
          <source>Whenever a permission is added to a heterogeneous PermissionCollection such as Permissions, and the PermissionCollection doesn't yet contain a PermissionCollection of the specified permission's type, the PermissionCollection should call the &lt;code&gt;newPermissionCollection&lt;/code&gt; method on the permission's class to see if it requires a special PermissionCollection. If &lt;code&gt;newPermissionCollection&lt;/code&gt; returns null, the PermissionCollection is free to store the permission in any type of PermissionCollection it desires (one using a Hashtable, one using a Vector, etc.). For example, the Permissions object uses a default PermissionCollection implementation that stores the permission objects in a Hashtable.</source>
          <target state="translated">권한과 같은 이종 PermissionCollection에 권한이 추가되고 PermissionCollection에 지정된 권한 유형의 PermissionCollection이 아직 포함되어 있지 않은 경우 PermissionCollection은 권한 클래스 에서 &lt;code&gt;newPermissionCollection&lt;/code&gt; 메서드를 호출하여 특수한 PermissionCollection이 필요한지 확인해야합니다. 경우 &lt;code&gt;newPermissionCollection&lt;/code&gt; 널 (null)을 반환 PermissionCollection의은 (해시 테이블, 벡터를 사용하여 하나 등을 사용하여 하나)은 욕망의 PermissionCollection 모든 유형의 권한을 저장하는 무료입니다. 예를 들어 Permissions 객체는 권한 객체를 Hashtable에 저장하는 기본 PermissionCollection 구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="657dbd1f56168fcdb6c057d84ffab8877f436bb8" translate="yes" xml:space="preserve">
          <source>Whenever an operation occurs involving a source sequence (such as appending or inserting from a source sequence), this class synchronizes only on the string buffer performing the operation, not on the source. Note that while &lt;code&gt;StringBuffer&lt;/code&gt; is designed to be safe to use concurrently from multiple threads, if the constructor or the &lt;code&gt;append&lt;/code&gt; or &lt;code&gt;insert&lt;/code&gt; operation is passed a source sequence that is shared across threads, the calling code must ensure that the operation has a consistent and unchanging view of the source sequence for the duration of the operation. This could be satisfied by the caller holding a lock during the operation's call, by using an immutable source sequence, or by not sharing the source sequence across threads.</source>
          <target state="translated">소스 시퀀스를 추가하거나 삽입하는 등 소스 시퀀스와 관련된 작업이 발생할 때마다이 클래스는 소스가 아닌 작업을 수행하는 문자열 버퍼에서만 동기화합니다. &lt;code&gt;StringBuffer&lt;/code&gt; 는 여러 스레드에서 동시에 사용하기에 안전하도록 설계 되었지만 생성자 또는 &lt;code&gt;append&lt;/code&gt; 또는 &lt;code&gt;insert&lt;/code&gt; 작업에 스레드간에 공유되는 소스 시퀀스가 ​​전달되면 호출 코드는 작업이 일관되고 변경되지 않은보기를 갖도록해야합니다. 작업 기간 동안 소스 시퀀스의 작업 호출 중에 잠금을 유지 한 호출자가 불변의 소스 시퀀스를 사용하거나 스레드간에 소스 시퀀스를 공유하지 않으면이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="431790292384e64efc177cdca9b3ed328240fae3" translate="yes" xml:space="preserve">
          <source>Whenever it is invoked on the same Permission object more than once during an execution of a Java application, the &lt;code&gt;hashCode&lt;/code&gt; method must consistently return the same integer. This integer need not remain consistent from one execution of an application to another execution of the same application.</source>
          <target state="translated">Java 애플리케이션을 실행하는 동안 동일한 Permission 오브젝트에서 두 번 이상 호출 될 때마다 &lt;code&gt;hashCode&lt;/code&gt; 메소드는 동일한 정수를 일관되게 리턴해야합니다. 이 정수는 응용 프로그램의 한 실행에서 동일한 응용 프로그램의 다른 실행까지 일관성을 유지하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="588f7fe1bed2c7e664ebaf61ee198d0177166e9e" translate="yes" xml:space="preserve">
          <source>Whenever it is invoked on the same object more than once during an execution of a Java application, the &lt;code&gt;hashCode&lt;/code&gt; method must consistently return the same integer, provided no information used in &lt;code&gt;equals&lt;/code&gt; comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</source>
          <target state="translated">Java 어플리케이션의 실행 중에 같은 객체에서 호출 될 때마다 &lt;code&gt;hashCode&lt;/code&gt; 방법은 지속적으로 같은 정수를 반환해야합니다에 사용 된 정보가 제공되지 &lt;code&gt;equals&lt;/code&gt; 객체가 수정에 비교. 이 정수는 응용 프로그램의 한 실행에서 동일한 응용 프로그램의 다른 실행까지 일관성을 유지하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="ffc62db80b67ec0b4098632184a3dc10efde0cdb" translate="yes" xml:space="preserve">
          <source>Whenever it succeeds, it calls the previously instantiated resource bundle's &lt;a href=&quot;#setParent(java.util.ResourceBundle)&quot;&gt;&lt;code&gt;setParent&lt;/code&gt;&lt;/a&gt; method with the new resource bundle. This continues until the list of names is exhausted or the current bundle already has a non-null parent.</source>
          <target state="translated">성공할 때마다 이전에 인스턴스화 된 리소스 번들의 &lt;a href=&quot;#setParent(java.util.ResourceBundle)&quot;&gt; &lt;code&gt;setParent&lt;/code&gt; &lt;/a&gt; 메서드를 새 리소스 번들과 함께 호출합니다 . 이것은 이름 목록이 소진되거나 현재 번들에 이미 널이 아닌 상위가있을 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="e5ded5fcd7a735ce98c847740a18c44d83d66cc2" translate="yes" xml:space="preserve">
          <source>Whenever it succeeds, it calls the previously instantiated resource bundle's &lt;a href=&quot;resourcebundle#setParent-java.util.ResourceBundle-&quot;&gt;&lt;code&gt;setParent&lt;/code&gt;&lt;/a&gt; method with the new resource bundle. This continues until the list of names is exhausted or the current bundle already has a non-null parent.</source>
          <target state="translated">성공할 때마다 이전에 인스턴스화 된 자원 번들의 &lt;a href=&quot;resourcebundle#setParent-java.util.ResourceBundle-&quot;&gt; &lt;code&gt;setParent&lt;/code&gt; &lt;/a&gt; 메소드를 새 자원 번들과 함께 호출합니다 . 이름 목록이 소진되거나 현재 번들에 널이 아닌 상위가 이미있을 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="f6905fb07fa47d960a6cc1c5c35a7ad900455a52" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;foo&lt;/code&gt; becomes a wrapper for the actual native method with the appended prefix &quot;wrapped_&quot;. Note that &quot;wrapped_&quot; would be a poor choice of prefix since it might conceivably form the name of an existing method thus something like &quot;$$$MyAgentWrapped$$$_&quot; would be better but would make these examples less readable.</source>
          <target state="translated">여기서 &lt;code&gt;foo&lt;/code&gt; 는 접두사가 &quot;wrapped_&quot;인 실제 원시 메소드의 랩퍼가됩니다. &quot;wrapped_&quot;는 기존 메소드의 이름을 형성 할 수 있으므로 &quot;$$$ MyAgentWrapped $$$ _&quot;와 같은 것이 더 좋지만이 예제를 읽기 어렵게하기 때문에 접두어를 선택하는 것이 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fff88ed5ff71cb64ca036661748f73a8e3a0800" translate="yes" xml:space="preserve">
          <source>Where a file is registered with a watch service by means of a symbolic link then it is implementation specific if the watch continues to depend on the existence of the symbolic link after it is registered.</source>
          <target state="translated">파일이 심볼릭 링크를 통해 감시 서비스에 등록 된 경우, 파일이 등록 된 후 심볼릭 링크의 존재 여부에 따라 계속 시계가 의존하는지 여부는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d790f6a28291e56f379a271ae7232a655fb1d865" translate="yes" xml:space="preserve">
          <source>Where a membership key is not source-specific and the underlying operation system supports source filtering, then the &lt;a href=&quot;#block(java.net.InetAddress)&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unblock(java.net.InetAddress)&quot;&gt;&lt;code&gt;unblock&lt;/code&gt;&lt;/a&gt; methods can be used to block or unblock multicast datagrams from particular source addresses.</source>
          <target state="translated">멤버십 키가 소스에 한정되지 않고 기본 운영 체제가 소스 필터링을 지원하는 경우 &lt;a href=&quot;#block(java.net.InetAddress)&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unblock(java.net.InetAddress)&quot;&gt; &lt;code&gt;unblock&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 특정 소스 주소에서 멀티 캐스트 데이터 그램을 차단하거나 차단 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4eef4e93d3c18e96b9b78253a20017e48bb542d" translate="yes" xml:space="preserve">
          <source>Where a membership key is not source-specific and the underlying operation system supports source filtering, then the &lt;a href=&quot;membershipkey#block-java.net.InetAddress-&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;membershipkey#unblock-java.net.InetAddress-&quot;&gt;&lt;code&gt;unblock&lt;/code&gt;&lt;/a&gt; methods can be used to block or unblock multicast datagrams from particular source addresses.</source>
          <target state="translated">멤버쉽 키가 소스별로 다르고 기본 운영 시스템이 소스 필터링을 지원하는 경우 &lt;a href=&quot;membershipkey#block-java.net.InetAddress-&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;membershipkey#unblock-java.net.InetAddress-&quot;&gt; &lt;code&gt;unblock&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 특정 소스 주소에서 멀티 캐스트 데이터 그램을 차단하거나 차단 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef0ae8bbc1659706ac95235ca1ce689fe57f64b3" translate="yes" xml:space="preserve">
          <source>Where an I/O operation completes immediately, and the initiating thread is one of the pooled threads in the group then the completion handler may be invoked directly by the initiating thread. To avoid stack overflow, an implementation may impose a limit as to the number of activations on the thread stack. Some I/O operations may prohibit invoking the completion handler directly by the initiating thread (see &lt;a href=&quot;asynchronousserversocketchannel#accept(A,java.nio.channels.CompletionHandler)&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">I / O 작업이 즉시 완료되고 시작 스레드가 그룹의 풀링 된 스레드 중 하나 인 경우 완료 핸들러는 시작 스레드에 의해 직접 호출 될 수 있습니다. 스택 오버플로를 방지하기 위해 구현시 스레드 스택의 활성화 수에 제한을 부과 할 수 있습니다. 일부 I / O 작업은 시작 스레드가 직접 완료 핸들러를 호출하는 것을 금지 할 수 있습니다 ( &lt;a href=&quot;asynchronousserversocketchannel#accept(A,java.nio.channels.CompletionHandler)&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8898ed0b51f593284e7f77a4f867cd2fc2e666cb" translate="yes" xml:space="preserve">
          <source>Where an I/O operation completes immediately, and the initiating thread is one of the pooled threads in the group then the completion handler may be invoked directly by the initiating thread. To avoid stack overflow, an implementation may impose a limit as to the number of activations on the thread stack. Some I/O operations may prohibit invoking the completion handler directly by the initiating thread (see &lt;a href=&quot;asynchronousserversocketchannel#accept-A-java.nio.channels.CompletionHandler-&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">I / O 조작이 즉시 완료되고 시작 스레드가 그룹의 풀링 된 스레드 중 하나 인 경우 완료 스레드는 시작 스레드에 의해 직접 호출 될 수 있습니다. 스택 오버플로를 피하기 위해 구현시 스레드 스택의 활성화 수에 제한이있을 수 있습니다. 일부 I / O 조작은 시작 스레드가 완료 핸들러를 직접 호출하지 못하게 할 수 있습니다 ( &lt;a href=&quot;asynchronousserversocketchannel#accept-A-java.nio.channels.CompletionHandler-&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="66ce7e87d0492095ddc6703b1b7f0c7420f96474" translate="yes" xml:space="preserve">
          <source>Where an implementation does not support any notion of group then this method always throws &lt;a href=&quot;userprincipalnotfoundexception&quot;&gt;&lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt;&lt;/a&gt;. Where the namespace for user accounts and groups is the same, then this method is identical to invoking &lt;a href=&quot;#lookupPrincipalByName(java.lang.String)&quot;&gt;&lt;code&gt;lookupPrincipalByName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구현이 그룹 개념을 지원하지 않는 경우이 메서드는 항상 &lt;a href=&quot;userprincipalnotfoundexception&quot;&gt; &lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt; 을&lt;/a&gt; throw 합니다. 사용자 계정 및 그룹의 네임 스페이스가 동일한 경우이 메서드는 &lt;a href=&quot;#lookupPrincipalByName(java.lang.String)&quot;&gt; &lt;code&gt;lookupPrincipalByName&lt;/code&gt; &lt;/a&gt; 을 호출하는 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f2bcdaf392a0bc8b6a2ade4e800476f90476c33e" translate="yes" xml:space="preserve">
          <source>Where an implementation does not support any notion of group then this method always throws &lt;a href=&quot;userprincipalnotfoundexception&quot;&gt;&lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt;&lt;/a&gt;. Where the namespace for user accounts and groups is the same, then this method is identical to invoking &lt;a href=&quot;userprincipallookupservice#lookupPrincipalByName-java.lang.String-&quot;&gt;&lt;code&gt;lookupPrincipalByName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구현이 그룹의 개념을 지원하지 않는 경우,이 메소드는 항상 &lt;a href=&quot;userprincipalnotfoundexception&quot;&gt; &lt;code&gt;UserPrincipalNotFoundException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다. 사용자 계정 및 그룹의 네임 스페이스가 동일한 경우이 메소드는 &lt;a href=&quot;userprincipallookupservice#lookupPrincipalByName-java.lang.String-&quot;&gt; &lt;code&gt;lookupPrincipalByName&lt;/code&gt; &lt;/a&gt; 호출과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="cb723c111014ba92d8f87833b389ec9ea6719988" translate="yes" xml:space="preserve">
          <source>Where an implementation provides a means to start agents from the command-line interface, an agent is started by adding the following option to the command-line:</source>
          <target state="translated">구현이 명령 줄 인터페이스에서 에이전트를 시작하는 수단을 제공하는 경우 에이전트는 명령 줄에 다음 옵션을 추가하여 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c9f90c3240707b3d864205080111e67313bf0eee" translate="yes" xml:space="preserve">
          <source>Where an implementation supports an ACL model that differs from the NFSv4 defined ACL model then setting the initial ACL when creating the file must translate the ACL to the model supported by the file system. Methods that create a file should reject (by throwing &lt;a href=&quot;../../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;) any attempt to create a file that would be less secure as a result of the translation.</source>
          <target state="translated">구현이 NFSv4 정의 ACL 모델과 다른 ACL 모델을 지원하는 경우 파일을 작성할 때 초기 ACL을 설정하면 ACL을 파일 시스템이 지원하는 모델로 변환해야합니다. 파일을 작성하는 메소드 는 변환의 결과로 덜 안전한 파일을 작성하려는 시도를 &lt;a href=&quot;../../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 을 발생&lt;/a&gt; 시켜 거부해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8b05be389f68d5924db16624428d14d236ca56aa" translate="yes" xml:space="preserve">
          <source>Where desired, &lt;a href=&quot;processbuilder#redirect-input&quot;&gt; process I/O can also be redirected&lt;/a&gt; using methods of the &lt;a href=&quot;processbuilder&quot;&gt;&lt;code&gt;ProcessBuilder&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">원하는 경우 &lt;a href=&quot;processbuilder&quot;&gt; &lt;code&gt;ProcessBuilder&lt;/code&gt; &lt;/a&gt; 클래스의 메서드를 사용하여 &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;프로세스 I / O를 리디렉션 할 수도 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3907849eb829645989d02022a9256583b35ccf13" translate="yes" xml:space="preserve">
          <source>Where desired, &lt;a href=&quot;processbuilder#redirect-input&quot;&gt; subprocess I/O can also be redirected&lt;/a&gt; using methods of the &lt;a href=&quot;processbuilder&quot;&gt;&lt;code&gt;ProcessBuilder&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">원하는 경우 &lt;a href=&quot;processbuilder&quot;&gt; &lt;code&gt;ProcessBuilder&lt;/code&gt; &lt;/a&gt; 클래스의 메서드를 사용하여 &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;하위 프로세스 I / O를 리디렉션 할 수도 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d8cf0baa75731ca6a5102a9d1799ad35f096def7" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the &lt;a href=&quot;../files#getAttribute(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; method may be used to read the attribute value. The attribute value is returned as a byte array (byte[]). The &lt;a href=&quot;../files#setAttribute(java.nio.file.Path,java.lang.String,java.lang.Object,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; method may be used to write the value of a user-defined attribute from a buffer (as if by invoking the &lt;a href=&quot;#write(java.lang.String,java.nio.ByteBuffer)&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method), or byte array (byte[]).</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우 &lt;a href=&quot;../files#getAttribute(java.nio.file.Path,java.lang.String,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 속성 값을 읽을 수 있습니다. 속성 값은 바이트 배열 (byte [])로 반환됩니다. &lt;a href=&quot;../files#setAttribute(java.nio.file.Path,java.lang.String,java.lang.Object,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt; 방법 (것처럼 호출하여 버퍼로부터의 사용자 정의 속성의 값을 기록하는데 이용 될 수있다 &lt;a href=&quot;#write(java.lang.String,java.nio.ByteBuffer)&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 방법), 또는 바이트 배열 (byte []).</target>
        </trans-unit>
        <trans-unit id="0fbeca4a7ecd10802c77529dde8b082e44d0dd19" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the &lt;a href=&quot;../files#getAttribute-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;getAttribute&lt;/code&gt;&lt;/a&gt; method may be used to read the attribute value. The attribute value is returned as a byte array (byte[]). The &lt;a href=&quot;../files#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;setAttribute&lt;/code&gt;&lt;/a&gt; method may be used to write the value of a user-defined attribute from a buffer (as if by invoking the &lt;a href=&quot;userdefinedfileattributeview#write-java.lang.String-java.nio.ByteBuffer-&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; method), or byte array (byte[]).</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우 &lt;a href=&quot;../files#getAttribute-java.nio.file.Path-java.lang.String-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;getAttribute&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 속성 값을 읽을 수 있습니다. 속성 값은 바이트 배열 (byte [])로 반환됩니다. &lt;a href=&quot;../files#setAttribute-java.nio.file.Path-java.lang.String-java.lang.Object-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;setAttribute&lt;/code&gt; &lt;/a&gt; 방법 (것처럼 호출하여 버퍼로부터의 사용자 정의 속성의 값을 기록하는데 이용 될 수있다 &lt;a href=&quot;userdefinedfileattributeview#write-java.lang.String-java.nio.ByteBuffer-&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 방법), 또는 바이트 배열 (byte []).</target>
        </trans-unit>
        <trans-unit id="ebb78ae3ef6ed103a9eb1696cdee777cab788dee" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by &lt;a href=&quot;basicfileattributeview&quot;&gt;&lt;code&gt;BasicFileAttributeView&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fileownerattributeview&quot;&gt;&lt;code&gt;FileOwnerAttributeView&lt;/code&gt;&lt;/a&gt;, and in addition, the following attributes are supported:</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우이 속성보기에서 지원되는 속성은 &lt;a href=&quot;basicfileattributeview&quot;&gt; &lt;code&gt;BasicFileAttributeView&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fileownerattributeview&quot;&gt; &lt;code&gt;FileOwnerAttributeView&lt;/code&gt; 에&lt;/a&gt; 의해 정의 된대로 다음 속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4e8ebe996cadf7a3b2a8cb30caf8f69a0b7ddda3" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by &lt;code&gt;
 BasicFileAttributeView&lt;/code&gt;, and in addition, the following attributes are supported:</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우이 속성보기에서 지원하는 속성은 &lt;code&gt; BasicFileAttributeView&lt;/code&gt; 에 정의 된대로 이며 추가로 다음 속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="277ea500a19bef26e680e53fb1654aac09fa83bc" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as defined by &lt;code&gt;BasicFileAttributeView&lt;/code&gt;, and in addition, the following attributes are supported:</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우이 속성보기에서 지원되는 속성은 &lt;code&gt;BasicFileAttributeView&lt;/code&gt; 에 의해 정의 된대로 다음 속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cf674cc8cdf6492af75c97ec90cc9a040aea0c29" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view are as follows:</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우이 속성보기에서 지원되는 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d820fbab2fe6e4127e50646c4e71b92a8792a22" translate="yes" xml:space="preserve">
          <source>Where dynamic access to file attributes is required, the attributes supported by this attribute view have the following names and types:</source>
          <target state="translated">파일 속성에 대한 동적 액세스가 필요한 경우이 속성보기에서 지원되는 속성의 이름 및 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a3a8b24e5fea76a61408fffd2a003c38a23b39a" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">&lt;code&gt;0L&lt;/code&gt; 이 반환 되는 경우와 I / O 예외를 구분해야 하거나 같은 파일의 여러 속성이 동시에 필요한 경우 &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43d91b56e88fa1a42f8c6d2adc7c084514e56e79" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">&lt;code&gt;0L&lt;/code&gt; 이 리턴 되는 경우와 동일한 I / O 예외를 구별해야 하거나 동일한 파일의 여러 속성이 동시에 필요한 경우 &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7de0392e6d47b4862228ebe6d2a818b846d1aedb" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory then the file attributes can be read with the &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isDirectory()&quot;&gt;&lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">I / O 예외를 파일이 디렉토리가 아닌 경우와 &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt; 경우 readAttributes 메서드 및 &lt;a href=&quot;attribute/basicfileattributes#isDirectory()&quot;&gt; &lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt; &lt;/a&gt; 메서드로 테스트 된 파일 유형으로 파일 속성을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="005cb3d94ffb0d26668ec1404f37b73b1ba29dc4" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory then the file attributes can be read with the &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isDirectory--&quot;&gt;&lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파일이 디렉토리가 아닌 경우와 I / O 예외를 구별해야하는 경우, 파일 속성은 &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt; 메소드 로 읽고 파일 유형은 &lt;a href=&quot;attribute/basicfileattributes#isDirectory--&quot;&gt; &lt;code&gt;BasicFileAttributes.isDirectory()&lt;/code&gt; &lt;/a&gt; 메소드로 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="007567199ff26eceed4a5f4b5e1dc57ccb4d5705" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">파일이 디렉토리가 아닌 경우와 I / O 예외를 구분해야하거나 동일한 파일의 여러 속성이 동시에 필요한 경우 &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bbbcba21c28c4d8c2c4924803def9e4ddb35ba8" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a directory, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">파일이 디렉토리가 아닌 경우 또는 동일한 파일의 여러 속성이 동시에 필요한 경우와 I / O 예외를 구별해야하는 경우 &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b9eef79be9b70ff82dc87b633ac874427f7ef1" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a normal file, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">파일이 일반 파일이 아닌 경우와 I / O 예외를 구분해야하거나 동일한 파일의 여러 속성이 동시에 필요한 경우 &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="298b25c773a1934ae542e41dcabec7d24973199b" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a normal file, or where several attributes of the same file are required at the same time, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">파일이 일반 파일이 아닌 경우 또는 동일한 파일의 여러 속성이 동시에 필요한 경우와 I / O 예외를 구별해야하는 경우 &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21258737e247b6c14994cdb209414cffbf2cb58c" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a regular file then the file attributes can be read with the &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isRegularFile()&quot;&gt;&lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">I / O 예외를 파일이 일반 파일이 아닌 경우와 &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt; 경우 readAttributes 메서드 및 &lt;a href=&quot;attribute/basicfileattributes#isRegularFile()&quot;&gt; &lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt; &lt;/a&gt; 메서드로 테스트 된 파일 유형으로 파일 속성을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02f695b12ef8bb76e6aea55a25eeab17ff1669ac" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a regular file then the file attributes can be read with the &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isRegularFile--&quot;&gt;&lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파일이 일반 파일이 아닌 경우와 I / O 예외를 구별해야하는 경우 &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt; 메소드로 파일 속성을 읽고 &lt;a href=&quot;attribute/basicfileattributes#isRegularFile--&quot;&gt; &lt;code&gt;BasicFileAttributes.isRegularFile()&lt;/code&gt; &lt;/a&gt; 메소드로 파일 유형을 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b73ecca6efa6b0c0122ee193aadbfbbac0725868" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a symbolic link then the file attributes can be read with the &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink()&quot;&gt;&lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">I / O 예외를 파일이 심볼릭 링크가 아닌 경우와 &lt;a href=&quot;#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt; 경우 readAttributes 메서드 및 &lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink()&quot;&gt; &lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt; &lt;/a&gt; 메서드로 테스트 된 파일 유형으로 파일 속성을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b99909cf143f334a41da20c3faff5347727a01c" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case that the file is not a symbolic link then the file attributes can be read with the &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method and the file type tested with the &lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink--&quot;&gt;&lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파일이 기호 링크가 아닌 경우와 I / O 예외를 구별해야하는 경우, 파일 속성은 &lt;a href=&quot;files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; &lt;/a&gt; 메소드 로 읽고 파일 유형은 &lt;a href=&quot;attribute/basicfileattributes#isSymbolicLink--&quot;&gt; &lt;code&gt;BasicFileAttributes.isSymbolicLink()&lt;/code&gt; &lt;/a&gt; 메소드로 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a3da2048af042507ba49cb66f0ec70eb628b60c" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case where &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, or where the time of last access or the creation time are required, then the &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used. If however only the time of last modification is required, then the &lt;a href=&quot;../nio/file/files#getLastModifiedTime(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;Files.getLastModifiedTime&lt;/code&gt;&lt;/a&gt; method may be used instead.</source>
          <target state="translated">&lt;code&gt;0L&lt;/code&gt; 이 반환 되는 경우와 I / O 예외를 구분해야하는 경우 또는 동일한 파일의 여러 속성이 동시에 필요한 경우 또는 마지막 액세스 시간 또는 생성 시간이 필요한 경우 &lt;a href=&quot;../nio/file/files#readAttributes(java.nio.file.Path,java.lang.Class,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다. 그러나 마지막 수정 시간 만 필요한 경우 대신 &lt;a href=&quot;../nio/file/files#getLastModifiedTime(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;Files.getLastModifiedTime&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acaa3530ad31cc461c41f4ed0c962b27b0124c2a" translate="yes" xml:space="preserve">
          <source>Where it is required to distinguish an I/O exception from the case where &lt;code&gt;0L&lt;/code&gt; is returned, or where several attributes of the same file are required at the same time, or where the time of last access or the creation time are required, then the &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;Files.readAttributes&lt;/code&gt;&lt;/a&gt; method may be used.</source>
          <target state="translated">&lt;code&gt;0L&lt;/code&gt; 이 리턴되거나 동일한 파일의 여러 속성이 동시에 필요하거나 마지막 액세스 시간 또는 작성 시간이 필요한 경우와 I / O 예외를 구별해야하는 경우 &lt;a href=&quot;../nio/file/files#readAttributes-java.nio.file.Path-java.lang.Class-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;Files.readAttributes&lt;/code&gt; &lt;/a&gt; 메소드가 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15c805f474acebca2530400cb8d6a021d50edd5e" translate="yes" xml:space="preserve">
          <source>Where possible, a newly constructed &lt;code&gt;DatagramSocket&lt;/code&gt; has the &lt;a href=&quot;socketoptions#SO_BROADCAST&quot;&gt;&lt;code&gt;SO_BROADCAST&lt;/code&gt;&lt;/a&gt; socket option enabled so as to allow the transmission of broadcast datagrams. In order to receive broadcast packets a DatagramSocket should be bound to the wildcard address. In some implementations, broadcast packets may also be received when a DatagramSocket is bound to a more specific address.</source>
          <target state="translated">가능한 경우 새로 구성된 &lt;code&gt;DatagramSocket&lt;/code&gt; 에는 브로드 캐스트 데이터 그램의 전송을 허용하기 위해 &lt;a href=&quot;socketoptions#SO_BROADCAST&quot;&gt; &lt;code&gt;SO_BROADCAST&lt;/code&gt; &lt;/a&gt; 소켓 옵션이 활성화되어 있습니다. 브로드 캐스트 패킷을 수신하려면 DatagramSocket을 와일드 카드 주소에 바인딩해야합니다. 일부 구현들에서, 브로드 캐스트 패킷들은 또한 DatagramSocket이보다 특정한 주소에 바인딩 될 때 수신 될 수있다.</target>
        </trans-unit>
        <trans-unit id="ae2251eb2bdde2077099e46a23fa2296253a4452" translate="yes" xml:space="preserve">
          <source>Where possible, applications should use &lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;LocalDateTime&lt;/code&gt; to better model the domain. For example, a birthday should be stored in a code &lt;code&gt;LocalDate&lt;/code&gt;. Bear in mind that any use of a &lt;a href=&quot;zoneid&quot;&gt;time-zone&lt;/a&gt;, such as 'Europe/Paris', adds considerable complexity to a calculation. Many applications can be written only using &lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt; and &lt;code&gt;Instant&lt;/code&gt;, with the time-zone added at the user interface (UI) layer.</source>
          <target state="translated">가능한 경우 응용 프로그램은 &lt;code&gt;LocalDate&lt;/code&gt; , &lt;code&gt;LocalTime&lt;/code&gt; 및 &lt;code&gt;LocalDateTime&lt;/code&gt; 을 사용 하여 도메인을 더 잘 모델링해야합니다. 예를 들어 생일은 코드 &lt;code&gt;LocalDate&lt;/code&gt; 에 저장해야합니다 . 곰은 마음에 어떤 사용하는 &lt;a href=&quot;zoneid&quot;&gt;시간대&lt;/a&gt; 등 '유럽 / 파리'등은 계산에 상당한 복잡성을 추가합니다. 많은 응용 프로그램은 사용자 인터페이스 (UI) 레이어에 시간대가 추가 된 &lt;code&gt;LocalDate&lt;/code&gt; , &lt;code&gt;LocalTime&lt;/code&gt; 및 &lt;code&gt;Instant&lt;/code&gt; 만 사용하여 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91b2e2e10f69ab09824cf8a20764fb8ed9c2bb88" translate="yes" xml:space="preserve">
          <source>Where several modules are defined to the same class loader, and where more than one module contains a resource with the given name, then the ordering is not specified and may be very unpredictable. When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt;&lt;code&gt;getResource(String)&lt;/code&gt;&lt;/a&gt; method. This should ensure that the first element returned by the Enumeration's &lt;code&gt;nextElement&lt;/code&gt; method is the same resource that the &lt;code&gt;getResource(String)&lt;/code&gt; method would return.</source>
          <target state="translated">여러 모듈이 동일한 클래스 로더에 정의되고 둘 이상의 모듈에 주어진 이름의 리소스가 포함 된 경우 순서가 지정되지 않고 예측할 수 없을 수 있습니다. 이 메서드를 재정의 할 때 구현시 모든 위임이 &lt;a href=&quot;#getResource(java.lang.String)&quot;&gt; &lt;code&gt;getResource(String)&lt;/code&gt; &lt;/a&gt; 메서드 와 일치하는지 확인하는 것이 좋습니다 . 이렇게하면 Enumeration의 &lt;code&gt;nextElement&lt;/code&gt; 메서드에 의해 반환 된 첫 번째 요소 가 &lt;code&gt;getResource(String)&lt;/code&gt; 메서드가 반환 하는 것과 동일한 리소스가 됩니다.</target>
        </trans-unit>
        <trans-unit id="30feb1a1deb63d86d797b59fc10ebf6c8ef8b081" translate="yes" xml:space="preserve">
          <source>Where several modules are defined to the same class loader, and where more than one module contains a resource with the given name, then the ordering that modules are searched is not specified and may be very unpredictable. When overriding this method it is recommended that an implementation ensures that any delegation is consistent with the &lt;a href=&quot;#getResources(java.lang.String)&quot;&gt;&lt;code&gt;getResources(String)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">여러 모듈이 동일한 클래스 로더에 정의되고 두 개 이상의 모듈에 주어진 이름의 리소스가 포함 된 경우 모듈 검색 순서가 지정되지 않고 예측할 수 없을 수 있습니다. 이 메서드를 재정의 할 때 구현시 모든 위임이 &lt;a href=&quot;#getResources(java.lang.String)&quot;&gt; &lt;code&gt;getResources(String)&lt;/code&gt; &lt;/a&gt; 메서드 와 일치하는지 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="87e0bb7fc901d05afac4326d164f35bed3f81996" translate="yes" xml:space="preserve">
          <source>Where symbolic links are supported, but the underlying &lt;a href=&quot;filestore&quot;&gt;&lt;code&gt;FileStore&lt;/code&gt;&lt;/a&gt; does not support symbolic links, then this may fail with an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;. Additionally, some operating systems may require that the Java virtual machine be started with implementation specific privileges to create symbolic links, in which case this method may throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">기호 링크가 지원되지만 기본 &lt;a href=&quot;filestore&quot;&gt; &lt;code&gt;FileStore&lt;/code&gt; &lt;/a&gt; 가 기호 링크를 지원하지 않는 경우 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt; 과 함께 실패 할 수 있습니다 . 또한 일부 운영 체제에서는 기호 링크를 작성하기 위해 구현 별 권한으로 Java 가상 머신을 시작해야 할 수 있습니다 . 이 경우이 메소드는 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aff3ccdb832b941a77362ca0a3153b1ed7d1a9da" translate="yes" xml:space="preserve">
          <source>Where syntactically malformed entries are encountered, the entry is ignored and the remainder of entries in file are processed. For instances where duplicate country code entries exist, the behavior of the Currency information for that &lt;code&gt;Currency&lt;/code&gt; is undefined and the remainder of entries in file are processed.</source>
          <target state="translated">구문이 잘못된 항목이 발견되면 해당 항목이 무시되고 파일의 나머지 항목이 처리됩니다. 중복 된 국가 코드 항목이 존재하는 인스턴스의 경우, 그의 통화 정보의 동작 &lt;code&gt;Currency&lt;/code&gt; 정의하고 파일에있는 항목의 나머지 부분이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="645bad2c04254cc2a6d121dc714e9825c14fd591" translate="yes" xml:space="preserve">
          <source>Where the &lt;a href=&quot;../../util/concurrent/future#cancel(boolean)&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; method is invoked with the &lt;code&gt;
 mayInterruptIfRunning&lt;/code&gt; parameter set to &lt;code&gt;true&lt;/code&gt; then the I/O operation may be interrupted by closing the channel. In that case all threads waiting on the result of the I/O operation throw &lt;code&gt;CancellationException&lt;/code&gt; and any other I/O operations outstanding on the channel complete with the exception &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">(가) 어디 &lt;a href=&quot;../../util/concurrent/future#cancel(boolean)&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt; 방법은 호출된다 &lt;code&gt; mayInterruptIfRunning&lt;/code&gt; 의 에 파라미터 세트 &lt;code&gt;true&lt;/code&gt; 다음 I / O 작업이 채널을 닫아 중단 될 수 있습니다. 이 경우 I / O 작업의 결과를 기다리는 모든 스레드는 &lt;code&gt;CancellationException&lt;/code&gt; 을 throw 하고 채널에서 처리되지 않은 다른 I / O 작업은 &lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt; 예외로 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0bfb8c567532e837621aeea501dc3f1ddcd12e2" translate="yes" xml:space="preserve">
          <source>Where the &lt;a href=&quot;../../util/concurrent/future#cancel-boolean-&quot;&gt;&lt;code&gt;cancel&lt;/code&gt;&lt;/a&gt; method is invoked with the &lt;code&gt;mayInterruptIfRunning&lt;/code&gt; parameter set to &lt;code&gt;true&lt;/code&gt; then the I/O operation may be interrupted by closing the channel. In that case all threads waiting on the result of the I/O operation throw &lt;code&gt;CancellationException&lt;/code&gt; and any other I/O operations outstanding on the channel complete with the exception &lt;a href=&quot;asynchronouscloseexception&quot;&gt;&lt;code&gt;AsynchronousCloseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">(가) 어디 &lt;a href=&quot;../../util/concurrent/future#cancel-boolean-&quot;&gt; &lt;code&gt;cancel&lt;/code&gt; &lt;/a&gt; 방법은 호출된다 &lt;code&gt;mayInterruptIfRunning&lt;/code&gt; 의 에 파라미터 세트 &lt;code&gt;true&lt;/code&gt; 다음 I / O 작업이 채널을 닫아 중단 될 수 있습니다. 이 경우 I / O 조작의 결과로 대기중인 모든 스레드는 &lt;code&gt;CancellationException&lt;/code&gt; 및 채널에서 처리중인 다른 I / O 조작이 &lt;a href=&quot;asynchronouscloseexception&quot;&gt; &lt;code&gt;AsynchronousCloseException&lt;/code&gt; &lt;/a&gt; 예외로 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6c5daf70ef6f15c107a25281f6a04621e811b36" translate="yes" xml:space="preserve">
          <source>Where the &lt;code&gt;cancel&lt;/code&gt; method is invoked to cancel read or write operations then it is recommended that all buffers used in the I/O operations be discarded or care taken to ensure that the buffers are not accessed while the channel remains open.</source>
          <target state="translated">읽기 또는 쓰기 조작을 취소하기 위해 &lt;code&gt;cancel&lt;/code&gt; 메소드가 호출되는 경우, I / O 조작에 사용 된 모든 버퍼는 버려지거나 채널이 열려있는 동안 버퍼에 액세스하지 않도록주의하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9d8305902030508a453b89974c5e0784154948cf" translate="yes" xml:space="preserve">
          <source>Where the &lt;code&gt;modified_package_name&lt;/code&gt; is the package name of this object with &lt;code&gt;'/'&lt;/code&gt; substituted for &lt;code&gt;'.'&lt;/code&gt; (&lt;code&gt;'\u002e'&lt;/code&gt;).</source>
          <target state="translated">여기서 &lt;code&gt;modified_package_name&lt;/code&gt; 은 &lt;code&gt;'/'&lt;/code&gt; 가 &lt;code&gt;'.'&lt;/code&gt; 로 대체 된 이 객체의 패키지 이름입니다 . ( &lt;code&gt;'\u002e'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="20aa13f386a65b9aa665ab0dd65397813225275a" translate="yes" xml:space="preserve">
          <source>Where the channel is &lt;a href=&quot;#bind(java.net.SocketAddress)&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널이 인터넷 프로토콜 소켓 주소에 &lt;a href=&quot;#bind(java.net.SocketAddress)&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt; 경우이 메서드의 반환 값은 &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="4b1d4e9876a115d289cc3d3d89044c6ff716cd4b" translate="yes" xml:space="preserve">
          <source>Where the channel is &lt;a href=&quot;networkchannel#bind(java.net.SocketAddress)&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널이 인터넷 프로토콜 소켓 주소에 &lt;a href=&quot;networkchannel#bind(java.net.SocketAddress)&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt; 경우이 메서드의 반환 값은 &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="5776a8c2e2eb012135f9b2f791b325011a696da1" translate="yes" xml:space="preserve">
          <source>Where the channel is &lt;a href=&quot;networkchannel#bind-java.net.SocketAddress-&quot;&gt;&lt;code&gt;bound&lt;/code&gt;&lt;/a&gt; to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널이 인터넷 프로토콜 소켓 주소에 &lt;a href=&quot;networkchannel#bind-java.net.SocketAddress-&quot;&gt; &lt;code&gt;bound&lt;/code&gt; &lt;/a&gt; 경우이 메소드의 리턴 값은 &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="2b5a252c98def07c02e37f2ec2055c98d16f0a55" translate="yes" xml:space="preserve">
          <source>Where the channel is bound and connected to an Internet Protocol socket address then the return value from this method is of type &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt;&lt;code&gt;InetSocketAddress&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">채널이 바인드되어 인터넷 프로토콜 소켓 주소에 연결된 경우이 메소드의 리턴 값은 &lt;a href=&quot;../../net/inetsocketaddress&quot;&gt; &lt;code&gt;InetSocketAddress&lt;/code&gt; &lt;/a&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="f3d56641ee7619e7defb7d614564f85e1460565f" translate="yes" xml:space="preserve">
          <source>Where the directory is opened successfully, then the entries in the directory, and their &lt;em&gt;descendants&lt;/em&gt; are visited. When all entries have been visited, or an I/O error occurs during iteration of the directory, then the directory is closed and the visitor's &lt;a href=&quot;filevisitor#postVisitDirectory(T,java.io.IOException)&quot;&gt;&lt;code&gt;postVisitDirectory&lt;/code&gt;&lt;/a&gt; method is invoked. The file tree walk then continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">디렉토리가 성공적으로 열리면 디렉토리의 항목과 해당 &lt;em&gt;하위&lt;/em&gt; 항목을 방문합니다. 모든 항목을 방문했거나 디렉토리 반복 중에 I / O 오류가 발생하면 디렉토리가 닫히고 방문자의 &lt;a href=&quot;filevisitor#postVisitDirectory(T,java.io.IOException)&quot;&gt; &lt;code&gt;postVisitDirectory&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. 그런 다음 파일 트리 워크는 기본적으로 디렉토리 의 다음 &lt;em&gt;형제&lt;/em&gt; 에서 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddadcdbdf7fecb97856976200f59b9dff77b97ca" translate="yes" xml:space="preserve">
          <source>Where the directory is opened successfully, then the entries in the directory, and their &lt;em&gt;descendants&lt;/em&gt; are visited. When all entries have been visited, or an I/O error occurs during iteration of the directory, then the directory is closed and the visitor's &lt;a href=&quot;filevisitor#postVisitDirectory-T-java.io.IOException-&quot;&gt;&lt;code&gt;postVisitDirectory&lt;/code&gt;&lt;/a&gt; method is invoked. The file tree walk then continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">디렉토리가 성공적으로 열리면 디렉토리의 항목 및 해당 &lt;em&gt;하위 항목&lt;/em&gt; 이 방문됩니다. 모든 항목을 방문했거나 디렉토리를 반복하는 동안 I / O 오류가 발생하면 디렉토리가 닫히고 방문자의 &lt;a href=&quot;filevisitor#postVisitDirectory-T-java.io.IOException-&quot;&gt; &lt;code&gt;postVisitDirectory&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. 그런 다음 기본적으로 파일 트리 워크 는 디렉토리 의 다음 &lt;em&gt;형제&lt;/em&gt; 에서 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="f20fbb77d5a28e0705439af43dcf961b9abb6e04" translate="yes" xml:space="preserve">
          <source>Where the file is a directory, and the directory could not be opened, then the &lt;code&gt;visitFileFailed&lt;/code&gt; method is invoked with the I/O exception, after which, the file tree walk continues, by default, at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">파일이 디렉토리이고 디렉토리를 열 수없는 경우 &lt;code&gt;visitFileFailed&lt;/code&gt; 메소드는 I / O 예외와 함께 호출되며, 그 후에 는 디렉토리 의 다음 &lt;em&gt;형제&lt;/em&gt; 에서 기본적으로 파일 트리 워크가 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="813178800981aaf7228102a5aacbe600959c9826" translate="yes" xml:space="preserve">
          <source>Where the file system supports Access Control Lists, and it uses an ACL model that differs from the NFSv4 defined ACL model, then this method must translate the ACL to the model supported by the file system. This method should reject (by throwing &lt;a href=&quot;../../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;) any attempt to write an ACL that would appear to make the file more secure than would be the case if the ACL were updated. Where an implementation does not support a mapping of &lt;a href=&quot;aclentrytype#AUDIT&quot;&gt;&lt;code&gt;AclEntryType.AUDIT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;aclentrytype#ALARM&quot;&gt;&lt;code&gt;AclEntryType.ALARM&lt;/code&gt;&lt;/a&gt; entries, then this method ignores these entries when writing the ACL.</source>
          <target state="translated">파일 시스템이 액세스 제어 목록을 지원하고 NFSv4 정의 ACL 모델과 다른 ACL 모델을 사용하는 경우이 방법은 ACL을 파일 시스템이 지원하는 모델로 변환해야합니다. 이 메소드는 ACL이 업데이트 된 경우보다 파일을 더 안전하게 만드는 것으로 보이는 ACL을 작성하려는 시도를 &lt;a href=&quot;../../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 을 발생&lt;/a&gt; 시켜 거부해야합니다 . 구현이 &lt;a href=&quot;aclentrytype#AUDIT&quot;&gt; &lt;code&gt;AclEntryType.AUDIT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;aclentrytype#ALARM&quot;&gt; &lt;code&gt;AclEntryType.ALARM&lt;/code&gt; &lt;/a&gt; 항목 의 맵핑을 지원하지 않는 경우이 메소드는 ACL을 작성할 때 이러한 항목을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="1bf3aa721e02b8abb961e05d45c9ccdfa7286d66" translate="yes" xml:space="preserve">
          <source>Where the filter terminates due to an uncaught error or runtime exception then it is propagated to the &lt;a href=&quot;../../util/iterator#hasNext()&quot;&gt;&lt;code&gt;hasNext&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../util/iterator#next()&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method. Where an &lt;code&gt;
 IOException&lt;/code&gt; is thrown, it results in the &lt;code&gt;hasNext&lt;/code&gt; or &lt;code&gt;
 next&lt;/code&gt; method throwing a &lt;a href=&quot;directoryiteratorexception&quot;&gt;&lt;code&gt;DirectoryIteratorException&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;IOException&lt;/code&gt; as the cause.</source>
          <target state="translated">포착되지 않은 오류 또는 런타임 예외로 인해 필터가 종료되는 경우 &lt;a href=&quot;../../util/iterator#hasNext()&quot;&gt; &lt;code&gt;hasNext&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../util/iterator#next()&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 메소드로 전파됩니다 . 경우 &lt;code&gt; IOException&lt;/code&gt; 이가 발생합니다, 그것은 결과 &lt;code&gt;hasNext&lt;/code&gt; 또는 &lt;code&gt; next&lt;/code&gt; 던지는 방법 &lt;a href=&quot;directoryiteratorexception&quot;&gt; &lt;code&gt;DirectoryIteratorException&lt;/code&gt; 을&lt;/a&gt; 과 &lt;code&gt;IOException&lt;/code&gt; 이 원인으로.</target>
        </trans-unit>
        <trans-unit id="8251e33247a11466c53d88af669cedf9a7c9b244" translate="yes" xml:space="preserve">
          <source>Where the filter terminates due to an uncaught error or runtime exception then it is propagated to the &lt;a href=&quot;../../util/iterator#hasNext--&quot;&gt;&lt;code&gt;hasNext&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../util/iterator#next--&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; method. Where an &lt;code&gt;IOException&lt;/code&gt; is thrown, it results in the &lt;code&gt;hasNext&lt;/code&gt; or &lt;code&gt;next&lt;/code&gt; method throwing a &lt;a href=&quot;directoryiteratorexception&quot;&gt;&lt;code&gt;DirectoryIteratorException&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;IOException&lt;/code&gt; as the cause.</source>
          <target state="translated">포착되지 않은 오류 또는 런타임 예외로 인해 필터가 종료되는 경우 &lt;a href=&quot;../../util/iterator#hasNext--&quot;&gt; &lt;code&gt;hasNext&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../util/iterator#next--&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 메소드로 전파됩니다 . 경우 &lt;code&gt;IOException&lt;/code&gt; 이가 발생합니다, 그것은 결과 &lt;code&gt;hasNext&lt;/code&gt; 또는 &lt;code&gt;next&lt;/code&gt; 던지는 방법 &lt;a href=&quot;directoryiteratorexception&quot;&gt; &lt;code&gt;DirectoryIteratorException&lt;/code&gt; 을&lt;/a&gt; 과 &lt;code&gt;IOException&lt;/code&gt; 이 원인으로.</target>
        </trans-unit>
        <trans-unit id="6af0ee5404f0be6ffe44935c032e92267f7c81e1" translate="yes" xml:space="preserve">
          <source>Where the impact lies, however, is in constructing and showing a Swing application. Calls to an application's &lt;code&gt;main&lt;/code&gt; method, or methods in &lt;code&gt;Applet&lt;/code&gt;, are not invoked on the event dispatching thread. As such, care must be taken to transfer control to the event dispatching thread when constructing and showing an application or applet. The preferred way to transfer control and begin working with Swing is to use &lt;code&gt;invokeLater&lt;/code&gt;. The &lt;code&gt;invokeLater&lt;/code&gt; method schedules a &lt;code&gt;Runnable&lt;/code&gt; to be processed on the event dispatching thread. The following two examples work equally well for transferring control and starting up a Swing application:</source>
          <target state="translated">그러나 영향이있는 곳은 Swing 애플리케이션을 구축하고 보여주는 것입니다. 애플리케이션의 &lt;code&gt;main&lt;/code&gt; 메소드 또는 &lt;code&gt;Applet&lt;/code&gt; 의 메소드 에 대한 호출은 이벤트 디스패치 스레드에서 호출되지 않습니다. 따라서 응용 프로그램이나 애플릿을 구성하고 표시 할 때 제어를 이벤트 디스패치 스레드로 전송하는 데주의를 기울여야합니다. 제어를 전송하고 Swing 작업을 시작하는 가장 좋은 방법은 &lt;code&gt;invokeLater&lt;/code&gt; 를 사용하는 것 입니다. &lt;code&gt;invokeLater&lt;/code&gt; 에 있어서 일정 &lt;code&gt;Runnable&lt;/code&gt; 이벤트 디스 패칭 스레드에 처리한다. 다음 두 가지 예제는 제어권을 전송하고 Swing 애플리케이션을 시작하는 데 동일하게 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c51f5961597e3abbd7cbd8e36154eb7f8ad2d5be" translate="yes" xml:space="preserve">
          <source>Where the nodes to be removed are read-only descendants of an &lt;code&gt;EntityReference&lt;/code&gt;, the &lt;code&gt;EntityReference&lt;/code&gt; must be removed instead of the read-only nodes. If any &lt;code&gt;EntityReference&lt;/code&gt; to be removed has descendants that are not &lt;code&gt;EntityReference&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt;, or &lt;code&gt;CDATASection&lt;/code&gt; nodes, the &lt;code&gt;replaceWholeText&lt;/code&gt; method must fail before performing any modification of the document, raising a &lt;code&gt;DOMException&lt;/code&gt; with the code &lt;code&gt;NO_MODIFICATION_ALLOWED_ERR&lt;/code&gt;.</source>
          <target state="translated">노드가 읽기 전용의 후손 제거 할 경우 &lt;code&gt;EntityReference&lt;/code&gt; 의 &lt;code&gt;EntityReference&lt;/code&gt; 대신 읽기 전용 노드를 제거해야합니다. 제거 할 &lt;code&gt;EntityReference&lt;/code&gt; 에 &lt;code&gt;EntityReference&lt;/code&gt; , &lt;code&gt;Text&lt;/code&gt; 또는 &lt;code&gt;CDATASection&lt;/code&gt; 노드 가 아닌 하위 항목이있는 경우 문서 수정을 수행하기 전에 &lt;code&gt;replaceWholeText&lt;/code&gt; 메서드가 실패해야 하며 코드 &lt;code&gt;NO_MODIFICATION_ALLOWED_ERR&lt;/code&gt; 과 함께 &lt;code&gt;DOMException&lt;/code&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="e9e95719d37b90a01bb50bb0f34cef6a4524dc4a" translate="yes" xml:space="preserve">
          <source>Where the tabs are placed.</source>
          <target state="translated">탭이있는 위치.</target>
        </trans-unit>
        <trans-unit id="312f35b21c5541d25fef137d0c9ff3c37934f56a" translate="yes" xml:space="preserve">
          <source>Where there is insufficient space to store the attribute, or the attribute name or value exceed an implementation specific maximum size then an &lt;code&gt;IOException&lt;/code&gt; is thrown.</source>
          <target state="translated">속성을 저장할 공간이 충분하지 않거나 속성 이름 또는 값이 구현 특정 최대 크기를 초과하면 &lt;code&gt;IOException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="78177395926d156536f0c1ac9740391b9dc6422e" translate="yes" xml:space="preserve">
          <source>Where this method returns &lt;code&gt;true&lt;/code&gt;, then the associated thread pool has also &lt;a href=&quot;../../util/concurrent/executorservice#isTerminated()&quot;&gt;&lt;code&gt;terminated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 관련 스레드 풀도 &lt;a href=&quot;../../util/concurrent/executorservice#isTerminated()&quot;&gt; &lt;code&gt;terminated&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e3596c9771db04fbff45896ebd877c1d02f0912e" translate="yes" xml:space="preserve">
          <source>Where this method returns &lt;code&gt;true&lt;/code&gt;, then the associated thread pool has also &lt;a href=&quot;../../util/concurrent/executorservice#isTerminated--&quot;&gt;&lt;code&gt;terminated&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 &lt;code&gt;true&lt;/code&gt; 를 돌려주는 경우 , 관련의 thread pool도 &lt;a href=&quot;../../util/concurrent/executorservice#isTerminated--&quot;&gt; &lt;code&gt;terminated&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca7c18078eeeb8440182461deea920927988a9b5" translate="yes" xml:space="preserve">
          <source>Where two scroll bars meet, the row header meets the column header, or a scroll bar meets one of the headers, both components stop short of the corner, leaving a rectangular space which is, by default, empty. These spaces can potentially exist in any number of the four corners. In the previous diagram, the top right space is present and identified by the label &quot;corner component&quot;.</source>
          <target state="translated">두 개의 스크롤 막대가 만나는 곳에서 행 머리글이 열 머리글과 만나거나 스크롤 막대가 머리글 중 하나와 만나면 두 구성 요소가 모두 모서리에서 멈추고 기본적으로 빈 사각형 공간이 남습니다. 이러한 공간은 잠재적으로 네 모서리에 존재할 수 있습니다. 이전 다이어그램에서 오른쪽 상단 공간은 &quot;코너 구성 요소&quot;라는 레이블로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="f85fba4d6258a50067fbdc6fb4924687e3519a29" translate="yes" xml:space="preserve">
          <source>Where value limitations are given, any value outside of that set is reserved for future use; the value will be treated as the default.</source>
          <target state="translated">값 제한이 제공되는 경우 해당 세트를 벗어난 모든 값은 향후 사용을 위해 예약됩니다. 값은 기본값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b93b49aca4151b6c139adc0aa283a778340da4f0" translate="yes" xml:space="preserve">
          <source>Where, in this case, the method handle is bound to the VarHandle instance.</source>
          <target state="translated">이 경우 메서드 핸들은 VarHandle 인스턴스에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="70c9d617c105e0ab6aed38dbb10fa98dbb5056d6" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;code&gt;PrintService&lt;/code&gt; connected to a physical printer can be reused, a &lt;code&gt;StreamPrintService&lt;/code&gt; connected to a stream cannot. The underlying &lt;code&gt;StreamPrintService&lt;/code&gt; may be disposed by the print system with the &lt;a href=&quot;streamprintservice#dispose()&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; method before returning from the &lt;a href=&quot;docprintjob#print(javax.print.Doc,javax.print.attribute.PrintRequestAttributeSet)&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;DocPrintJob&lt;/code&gt; so that the print system knows this printer is no longer usable. This is equivalent to a physical printer going offline - permanently. Applications may supply a &lt;code&gt;null&lt;/code&gt; print stream to create a queryable service. It is not valid to create a &lt;code&gt;PrintJob&lt;/code&gt; for such a stream. Implementations which allocate resources on construction should examine the stream and may wish to only allocate resources if the stream is &lt;code&gt;non-null&lt;/code&gt;.</source>
          <target state="translated">반면 &lt;code&gt;PrintService&lt;/code&gt; 의 물리적 접속 프린터가 재사용 될 수있다하는 &lt;code&gt;StreamPrintService&lt;/code&gt; 에는이 스트림에 접속 불가능. 기본 &lt;code&gt;StreamPrintService&lt;/code&gt; 는 &lt;code&gt;DocPrintJob&lt;/code&gt; 의 &lt;a href=&quot;docprintjob#print(javax.print.Doc,javax.print.attribute.PrintRequestAttributeSet)&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환하기 전에 &lt;a href=&quot;streamprintservice#dispose()&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 인쇄 시스템에 의해 삭제되어 인쇄 시스템 이이 프린터를 더 이상 사용할 수 없음을 알 수 있습니다. 이는 물리적 프린터가 영구적으로 오프라인 상태가되는 것과 같습니다. 응용 프로그램은 쿼리 가능한 서비스를 만들기 위해 &lt;code&gt;null&lt;/code&gt; 인쇄 스트림을 제공 할 수 있습니다. &lt;code&gt;PrintJob&lt;/code&gt; 을 만드는 것은 유효하지 않습니다.그런 스트림을 위해. 구성에 리소스를 할당하는 구현은 스트림을 검사해야하며 스트림이 &lt;code&gt;non-null&lt;/code&gt; 이 아닌 경우에만 리소스를 할당하려고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b6a9723c6d2f9343f85c6d8af60801d7b7682ec" translate="yes" xml:space="preserve">
          <source>Whereas a &lt;code&gt;PrintService&lt;/code&gt; connected to a physical printer can be reused, a &lt;code&gt;StreamPrintService&lt;/code&gt; connected to a stream cannot. The underlying &lt;code&gt;StreamPrintService&lt;/code&gt; may be disposed by the print system with the &lt;a href=&quot;streamprintservice#dispose--&quot;&gt;&lt;code&gt;dispose&lt;/code&gt;&lt;/a&gt; method before returning from the &lt;a href=&quot;docprintjob#print-javax.print.Doc-javax.print.attribute.PrintRequestAttributeSet-&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;DocPrintJob&lt;/code&gt; so that the print system knows this printer is no longer usable. This is equivalent to a physical printer going offline - permanently. Applications may supply a null print stream to create a queryable service. It is not valid to create a PrintJob for such a stream. Implementations which allocate resources on construction should examine the stream and may wish to only allocate resources if the stream is non-null.</source>
          <target state="translated">실제 프린터에 연결된 &lt;code&gt;PrintService&lt;/code&gt; 를 재사용 할 수있는 반면 스트림에 연결된 &lt;code&gt;StreamPrintService&lt;/code&gt; 는 재사용 할 수 없습니다. 기본 &lt;code&gt;StreamPrintService&lt;/code&gt; 는 인쇄 시스템이이 프린터를 더 이상 사용할 수 없음을 알 수 있도록 &lt;code&gt;DocPrintJob&lt;/code&gt; 의 &lt;a href=&quot;docprintjob#print-javax.print.Doc-javax.print.attribute.PrintRequestAttributeSet-&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 메소드 에서 돌아 오기 전에 &lt;a href=&quot;streamprintservice#dispose--&quot;&gt; &lt;code&gt;dispose&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 인쇄 시스템에 의해 처리 될 수 있습니다 . 이것은 실제 프린터가 오프라인 상태가되는 것과 같습니다. 응용 프로그램은 쿼리 가능한 서비스를 만들기 위해 null 인쇄 스트림을 제공 할 수 있습니다. 이러한 스트림에 대해 PrintJob을 작성하는 것은 유효하지 않습니다. 구성시 자원을 할당하는 구현은 스트림을 검사해야하며 스트림이 널이 아닌 경우에만 자원을 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68dfcf4573839943af330771499a40761c894968" translate="yes" xml:space="preserve">
          <source>Whereas these are not (reason in parentheses):</source>
          <target state="translated">이것들이 아닌 반면 (괄호 안의 이유) :</target>
        </trans-unit>
        <trans-unit id="034389c570341c477b986ed7aab5d2ac27118931" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;waitForIdle&lt;/code&gt; is automatically called</source>
          <target state="translated">&lt;code&gt;waitForIdle&lt;/code&gt; 이 자동으로 호출 되는지 여부</target>
        </trans-unit>
        <trans-unit id="0787c7934fdfd663c379d9463c168a4a31331bbd" translate="yes" xml:space="preserve">
          <source>Whether C++-style comments are to be recognized and skipped.</source>
          <target state="translated">C ++ 스타일 주석을 인식하고 건너 뛸지 여부</target>
        </trans-unit>
        <trans-unit id="e0848da24388d28c1afb73d61f7a7588fee7e498" translate="yes" xml:space="preserve">
          <source>Whether C-style comments are to be recognized and skipped.</source>
          <target state="translated">C 스타일 주석을 인식하고 건너 뛸지 여부</target>
        </trans-unit>
        <trans-unit id="3ce96c4b92120512de6ee705be9cc10faccd0e37" translate="yes" xml:space="preserve">
          <source>Whether a &lt;a href=&quot;tifftag&quot;&gt;&lt;code&gt;TIFFTag&lt;/code&gt;&lt;/a&gt; with tag number equal to &lt;code&gt;tagNumber&lt;/code&gt; is present in this &lt;code&gt;TIFFDirectory&lt;/code&gt;.</source>
          <target state="translated">되든지 관계없이 &lt;a href=&quot;tifftag&quot;&gt; &lt;code&gt;TIFFTag&lt;/code&gt; &lt;/a&gt; 태그 번호와 같 &lt;code&gt;tagNumber&lt;/code&gt; 이에 존재 &lt;code&gt;TIFFDirectory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="368fda18947ddfae823fba3ad12c0006e725b91a" translate="yes" xml:space="preserve">
          <source>Whether a byte buffer is direct or non-direct may be determined by invoking its &lt;a href=&quot;#isDirect()&quot;&gt;&lt;code&gt;isDirect&lt;/code&gt;&lt;/a&gt; method. This method is provided so that explicit buffer management can be done in performance-critical code.</source>
          <target state="translated">바이트 버퍼가 직접 또는 비 직접인지 여부는 &lt;a href=&quot;#isDirect()&quot;&gt; &lt;code&gt;isDirect&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여 결정할 수 있습니다 . 이 방법은 성능이 중요한 코드에서 명시 적 버퍼 관리를 수행 할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="51a1385dc9a39d4da44928c4400ff21a87209713" translate="yes" xml:space="preserve">
          <source>Whether a byte buffer is direct or non-direct may be determined by invoking its &lt;a href=&quot;bytebuffer#isDirect--&quot;&gt;&lt;code&gt;isDirect&lt;/code&gt;&lt;/a&gt; method. This method is provided so that explicit buffer management can be done in performance-critical code.</source>
          <target state="translated">바이트 버퍼가 직접인지 아닌지 여부는 &lt;a href=&quot;bytebuffer#isDirect--&quot;&gt; &lt;code&gt;isDirect&lt;/code&gt; &lt;/a&gt; 를 호출하여 확인할 수 있습니다. 메소드 . 이 방법은 성능에 중요한 코드에서 명시 적 버퍼 관리를 수행 할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="76ac3d7ca9570e219636389efe4d99114c39fbb9" translate="yes" xml:space="preserve">
          <source>Whether a lock is exclusive or shared may be determined by invoking its &lt;a href=&quot;#isShared()&quot;&gt;&lt;code&gt;isShared&lt;/code&gt;&lt;/a&gt; method. Some platforms do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.</source>
          <target state="translated">잠금이 독점인지 공유인지는 &lt;a href=&quot;#isShared()&quot;&gt; &lt;code&gt;isShared&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 판별 할 수 있습니다 . 일부 플랫폼은 공유 잠금을 지원하지 않습니다.이 경우 공유 잠금 요청이 배타적 잠금 요청으로 자동 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="059d74aa74a1f70698c412f2b1b1fb68c363877d" translate="yes" xml:space="preserve">
          <source>Whether a lock is exclusive or shared may be determined by invoking its &lt;a href=&quot;filelock#isShared--&quot;&gt;&lt;code&gt;isShared&lt;/code&gt;&lt;/a&gt; method. Some platforms do not support shared locks, in which case a request for a shared lock is automatically converted into a request for an exclusive lock.</source>
          <target state="translated">잠금이 배타적인지 공유인지는 &lt;a href=&quot;filelock#isShared--&quot;&gt; &lt;code&gt;isShared&lt;/code&gt; &lt;/a&gt; 를 호출하여 확인할 수 있습니다. 메소드 . 일부 플랫폼은 공유 잠금을 지원하지 않습니다.이 경우 공유 잠금 요청은 독점 잠금 요청으로 자동 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6533c544c3a0529e57beea5f901c658d036545" translate="yes" xml:space="preserve">
          <source>Whether a particular component is or is not defined in an instance depends upon the type of the URI being represented. An absolute URI has a scheme component. An opaque URI has a scheme, a scheme-specific part, and possibly a fragment, but has no other components. A hierarchical URI always has a path (though it may be empty) and a scheme-specific-part (which at least contains the path), and may have any of the other components. If the authority component is present and is server-based then the host component will be defined and the user-information and port components may be defined.</source>
          <target state="translated">특정 컴포넌트가 인스턴스에 정의되어 있는지 여부는 표시되는 URI의 유형에 따라 다릅니다. 절대 URI에는 체계 구성 요소가 있습니다. 불투명 한 URI에는 체계, 체계 별 부분 및 조각이 있지만 다른 구성 요소는 없습니다. 계층 적 URI는 항상 경로 (비어있을 수 있음)와 구성표 특정 부분 (적어도 경로를 포함)을 가지며 다른 구성 요소를 가질 수 있습니다. 권한 구성 요소가 존재하고 서버 기반 인 경우 호스트 구성 요소가 정의되고 사용자 정보 및 포트 구성 요소가 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7b45add21d97d6f92bb3c58b9dd4adb30ed79cd" translate="yes" xml:space="preserve">
          <source>Whether a thread is a daemon thread</source>
          <target state="translated">스레드가 데몬 스레드인지 여부</target>
        </trans-unit>
        <trans-unit id="d404f71e4894750c15b6981c1f6ed118e11a813d" translate="yes" xml:space="preserve">
          <source>Whether a virtual machine has a console is dependent upon the underlying platform and also upon the manner in which the virtual machine is invoked. If the virtual machine is started from an interactive command line without redirecting the standard input and output streams then its console will exist and will typically be connected to the keyboard and display from which the virtual machine was launched. If the virtual machine is started automatically, for example by a background job scheduler, then it will typically not have a console.</source>
          <target state="translated">가상 머신에 콘솔이 있는지 여부는 기본 플랫폼 및 가상 머신이 호출되는 방식에 따라 다릅니다. 표준 입력 및 출력 스트림을 경로 재지 정하지 않고 대화식 명령 행에서 가상 머신을 시작하면 해당 콘솔이 존재하며 일반적으로 가상 머신이 시작된 키보드 및 디스플레이에 연결됩니다. 백그라운드 작업 스케줄러와 같은 가상 머신이 자동으로 시작되면 일반적으로 콘솔이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b2f8d65d541d32da6ac4db35fde558abe5bba9b" translate="yes" xml:space="preserve">
          <source>Whether aliases are case sensitive is implementation dependent. In order to avoid problems, it is recommended not to use aliases in a KeyStore that only differ in case.</source>
          <target state="translated">별칭이 대소 문자를 구분하는지 여부는 구현에 따라 다릅니다. 문제점을 피하기 위해 경우에 따라 다른 키 저장소에서 별명을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e459ddcf8add7fb4f45be0659b059f816d4f3a8a" translate="yes" xml:space="preserve">
          <source>Whether keystores are persistent, and the mechanisms used by the keystore if it is persistent, are not specified here. This allows use of a variety of techniques for protecting sensitive (e.g., private or secret) keys. Smart cards or other integrated cryptographic engines (SafeKeyper) are one option, and simpler mechanisms such as files may also be used (in a variety of formats).</source>
          <target state="translated">키 저장소가 지속적인지 여부와 키 저장소가 지속적이면 키 저장소가 사용하는 메커니즘은 여기에 지정되어 있지 않습니다. 이를 통해 민감한 (예 : 개인 또는 비밀) 키를 보호하기위한 다양한 기술을 사용할 수 있습니다. 스마트 카드 또는 기타 통합 암호화 엔진 (SafeKeyper)은 하나의 옵션이며 파일과 같은 간단한 메커니즘을 다양한 형식으로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="839575dd0da2dbc62283eccad2a293850044e605" translate="yes" xml:space="preserve">
          <source>Whether line terminators are to be returned as tokens or treated as white space that merely separates tokens.</source>
          <target state="translated">행 종결자가 토큰으로 리턴되는지 또는 단순히 토큰을 분리하는 공백으로 처리되는지 여부</target>
        </trans-unit>
        <trans-unit id="64009d2c9b3c4d0e007e474d4b10457e969ea24e" translate="yes" xml:space="preserve">
          <source>Whether new values can be written to the attribute.</source>
          <target state="translated">새 값을 속성에 쓸 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="b03220d01de6d75c311d805bed01816711949222" translate="yes" xml:space="preserve">
          <source>Whether or not a channel is registered with one or more selectors may be determined by invoking the &lt;a href=&quot;#isRegistered()&quot;&gt;&lt;code&gt;isRegistered&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">채널이 하나 이상의 선택 자로 등록되었는지 여부는 &lt;a href=&quot;#isRegistered()&quot;&gt; &lt;code&gt;isRegistered&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed0c61cf2fb7a55d68d476b3cbe4799a77c242a1" translate="yes" xml:space="preserve">
          <source>Whether or not a channel is registered with one or more selectors may be determined by invoking the &lt;a href=&quot;selectablechannel#isRegistered--&quot;&gt;&lt;code&gt;isRegistered&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">채널이 하나 이상의 선택기에 등록되어 있는지 여부는 &lt;a href=&quot;selectablechannel#isRegistered--&quot;&gt; &lt;code&gt;isRegistered&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d4e0c74b1ca2cffb49ee764de91039c786dd2b9" translate="yes" xml:space="preserve">
          <source>Whether or not a file is available or may be created depends upon the underlying platform. Some platforms, in particular, allow a file to be opened for writing by only one &lt;code&gt;FileWriter&lt;/code&gt; (or other file-writing object) at a time. In such situations the constructors in this class will fail if the file involved is already open.</source>
          <target state="translated">파일의 사용 가능 여부는 기본 플랫폼에 따라 다릅니다. 특히 일부 플랫폼에서는 한 번에 하나의 &lt;code&gt;FileWriter&lt;/code&gt; (또는 다른 파일 쓰기 객체) 만 쓰기 위해 파일을 열 수 있습니다 . 이러한 상황에서 관련된 파일이 이미 열려 있으면이 클래스의 생성자가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ea35fdbb197a6d4bef3ff403fa57d76ec3b52a58" translate="yes" xml:space="preserve">
          <source>Whether or not a lock actually prevents another program from accessing the content of the locked region is system-dependent and therefore unspecified. The native file-locking facilities of some systems are merely</source>
          <target state="translated">잠금이 실제로 다른 프로그램이 잠긴 영역의 내용에 액세스하지 못하게하는지 여부는 시스템에 따라 다르므로 지정되지 않습니다. 일부 시스템의 기본 파일 잠금 기능은</target>
        </trans-unit>
        <trans-unit id="5484541c29643b9a5f36af7eafe3c332aef64933" translate="yes" xml:space="preserve">
          <source>Whether or not a read-write lock will improve performance over the use of a mutual exclusion lock depends on the frequency that the data is read compared to being modified, the duration of the read and write operations, and the contention for the data - that is, the number of threads that will try to read or write the data at the same time. For example, a collection that is initially populated with data and thereafter infrequently modified, while being frequently searched (such as a directory of some kind) is an ideal candidate for the use of a read-write lock. However, if updates become frequent then the data spends most of its time being exclusively locked and there is little, if any increase in concurrency. Further, if the read operations are too short the overhead of the read-write lock implementation (which is inherently more complex than a mutual exclusion lock) can dominate the execution cost, particularly as many read-write lock implementations still serialize all threads through a small section of code. Ultimately, only profiling and measurement will establish whether the use of a read-write lock is suitable for your application.</source>
          <target state="translated">읽기 / 쓰기 잠금이 상호 배제 잠금을 사용하여 성능을 향상 시킬지 여부는 데이터를 수정하는 것과 비교 한 빈도, 읽기 및 쓰기 작업 기간 및 데이터 경합에 따라 다릅니다. 데이터를 동시에 읽거나 쓰려고하는 스레드 수입니다. 예를 들어, 처음에 데이터로 채워지고 그 후에 자주 검색되는 동안 (일부 디렉토리와 같은) 컬렉션은 읽기-쓰기 잠금을 사용하기에 이상적인 후보입니다. 그러나 업데이트가 자주 발생하면 대부분의 시간을 독점적으로 잠그는 데 소요되며 동시성 증가가 거의 발생하지 않습니다. 더욱이,읽기 작업이 너무 짧은 경우 읽기-쓰기 잠금 구현의 오버 헤드 (상호 배제 잠금보다 본질적으로 더 복잡함), 특히 많은 읽기-쓰기 잠금 구현이 여전히 작은 섹션을 통해 모든 스레드를 직렬화함에 따라 실행 비용을 지배 할 수 있습니다. 코드 궁극적으로 프로파일 링 및 측정만으로 읽기-쓰기 잠금 사용이 애플리케이션에 적합한 지 여부를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ab8f019130320385026e5dab14b4180991ab8cbe" translate="yes" xml:space="preserve">
          <source>Whether or not a selection operation blocks to wait for one or more channels to become ready, and if so for how long, is the only essential difference between the three selection methods.</source>
          <target state="translated">선택 조작이 하나 이상의 채널이 준비 될 때까지 대기하는지 여부와 시간이 얼마나 걸리는지는 세 가지 선택 방법 간의 유일한 필수 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="41ee46a746e75b2c44835c6bb604f840669e2531" translate="yes" xml:space="preserve">
          <source>Whether or not a thread writing bytes to a pipe will block until another thread reads those bytes, or some previously-written bytes, from the pipe is system-dependent and therefore unspecified. Many pipe implementations will buffer up to a certain number of bytes between the sink and source channels, but such buffering should not be assumed.</source>
          <target state="translated">파이프에 바이트를 쓰는 스레드가 다른 스레드가 파이프에서 해당 바이트 또는 일부 이전에 쓴 바이트를 읽을 때까지 차단되는지 여부는 시스템에 따라 다르므로 지정되지 않습니다. 많은 파이프 구현은 싱크와 소스 채널 사이의 특정 바이트 수까지 버퍼링하지만 이러한 버퍼링을 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f1753321a954e7b513350ab852758250afb77bcc" translate="yes" xml:space="preserve">
          <source>Whether or not the border has rounded corners.</source>
          <target state="translated">테두리에 둥근 모서리가 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="fefaa51af10ff6b34610a73fe360a147bd71b1e4" translate="yes" xml:space="preserve">
          <source>Whether or not the drawing buffer has been recently restored from a lost state.</source>
          <target state="translated">드로잉 버퍼가 최근 손실 된 상태에서 복원되었는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="4d74f9e48a7c981d657e06b3f4e62aa762abfdf7" translate="yes" xml:space="preserve">
          <source>Whether or not the drawing buffer was lost since the last call to &lt;code&gt;getDrawGraphics&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getDrawGraphics&lt;/code&gt; 에 대한 마지막 호출 이후 드로잉 버퍼가 손실되었는지 여부 .</target>
        </trans-unit>
        <trans-unit id="b46af6682380966e3f1a4318992d86f116b4966b" translate="yes" xml:space="preserve">
          <source>Whether or not the drawing buffer was restored since the last call to &lt;code&gt;getDrawGraphics&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getDrawGraphics&lt;/code&gt; 에 대한 마지막 호출 이후 드로잉 버퍼가 복원되었는지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="dfcdb3967632f01437df753633766fd60adb3757" translate="yes" xml:space="preserve">
          <source>Whether or not the lead anchor notification is enabled.</source>
          <target state="translated">리드 앵커 알림 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b67aae029276f7596e2d6a2c6bdefef7f78062c8" translate="yes" xml:space="preserve">
          <source>Whether or not the returned key is trusted and the mechanisms used to determine that is implementation-specific.</source>
          <target state="translated">반환 된 키가 신뢰할 수 있는지 여부와이를 결정하는 데 사용되는 메커니즘이 구현별로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="882147ddaf8db0c13715bcfc2446b83df5e1174d" translate="yes" xml:space="preserve">
          <source>Whether or not the root component of this path starts with the root component of the given path is file system specific. If this path does not have a root component and the given path has a root component then this path does not start with the given path.</source>
          <target state="translated">이 경로의 루트 구성 요소가 주어진 경로의 루트 구성 요소로 시작하는지의 여부는 파일 시스템에 따라 다릅니다. 이 경로에 루트 구성 요소가없고 지정된 경로에 루트 구성 요소가 있으면이 경로는 지정된 경로로 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5561b885c61970439f8e8ab1f7452ebbd54f6012" translate="yes" xml:space="preserve">
          <source>Whether or not the views are continuously redisplayed while resizing.</source>
          <target state="translated">크기를 조정하는 동안 뷰가 계속 다시 표시되는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8d8dadabe9f784b22272f65c7af34baa4ecf3fe7" translate="yes" xml:space="preserve">
          <source>Whether or not this is equal to the argument.</source>
          <target state="translated">이것이 인수와 같은지의 여부.</target>
        </trans-unit>
        <trans-unit id="2c8782dc43c139a892cf9eca05fb5d76826e3adf" translate="yes" xml:space="preserve">
          <source>Whether or not two path are equal depends on the file system implementation. In some cases the paths are compared without regard to case, and others are case sensitive. This method does not access the file system and the file is not required to exist. Where required, the &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method may be used to check if two paths locate the same file.</source>
          <target state="translated">두 경로가 같은지 여부는 파일 시스템 구현에 따라 다릅니다. 어떤 경우에는 경로가 대소 문자를 구분하지 않고 비교되고 다른 경로는 대소 문자를 구분합니다. 이 방법은 파일 시스템에 액세스하지 않으며 파일이 존재하지 않아도됩니다. 필요한 경우 &lt;a href=&quot;files#isSameFile(java.nio.file.Path,java.nio.file.Path)&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 두 경로가 동일한 파일을 찾는 지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8370dbb2c98105665a87fe7a4451e4d08277efed" translate="yes" xml:space="preserve">
          <source>Whether or not two path are equal depends on the file system implementation. In some cases the paths are compared without regard to case, and others are case sensitive. This method does not access the file system and the file is not required to exist. Where required, the &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt;&lt;code&gt;isSameFile&lt;/code&gt;&lt;/a&gt; method may be used to check if two paths locate the same file.</source>
          <target state="translated">두 경로가 같은지 여부는 파일 시스템 구현에 따라 다릅니다. 어떤 경우에는 경로가 대소 문자와 상관없이 비교되고 다른 경우는 대소 문자를 구분합니다. 이 방법은 파일 시스템에 액세스하지 않으며 파일이 필요하지 않습니다. 필요한 경우 &lt;a href=&quot;files#isSameFile-java.nio.file.Path-java.nio.file.Path-&quot;&gt; &lt;code&gt;isSameFile&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 두 경로가 동일한 파일을 찾는 지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8284d3a1a8d812ad6669b46283821c095c0da402" translate="yes" xml:space="preserve">
          <source>Whether the characters of identifiers are converted to lowercase.</source>
          <target state="translated">식별자의 문자가 소문자로 변환되는지 여부</target>
        </trans-unit>
        <trans-unit id="8cb35ed334e6abf3cc5d46cfafbdff505f970f2b" translate="yes" xml:space="preserve">
          <source>Whether the checks for Java language access control can be suppressed (and thus, whether access can be enabled) depends on whether the reflected object corresponds to a member in an exported or open package (see &lt;a href=&quot;#setAccessible(boolean)&quot;&gt;&lt;code&gt;setAccessible(boolean)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Java 언어 액세스 제어에 대한 검사를 억제 할 수 있는지 (따라서 액세스를 사용할 수 있는지 여부)는 반영된 객체가 내 보낸 패키지 또는 열린 패키지의 멤버에 해당하는지 여부에 따라 다릅니다 ( &lt;a href=&quot;#setAccessible(boolean)&quot;&gt; &lt;code&gt;setAccessible(boolean)&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="abed7ebf656d855109885e2ad219cda0e430ff8f" translate="yes" xml:space="preserve">
          <source>Whether the directory is traversable or not.</source>
          <target state="translated">디렉토리를 순회 할 수 있는지 여부.</target>
        </trans-unit>
        <trans-unit id="9f7b655899be35706a060ba063ac17985c822863" translate="yes" xml:space="preserve">
          <source>Whether the directory is traversable or not. This might be useful, for example, if you want a directory to represent a compound document and don't want the user to descend into it.</source>
          <target state="translated">디렉토리를 순회 할 수 있는지 여부. 예를 들어 디렉토리가 복합 문서를 나타내도록하고 사용자가 그 문서로 내려 가지 않도록하려는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72bdf44965cf1882a7b82e577ba831bb4aa3aad8" translate="yes" xml:space="preserve">
          <source>Whether the effect of sheet collation is achieved by placing copies of a document in multiple output bins or in the same output bin with implementation defined document separation is implementation dependent. Also whether it is achieved by making multiple passes over the job or by using an output sorter is implementation dependent.</source>
          <target state="translated">문서 사본을 여러 출력 용지함에 배치하거나 구현 정의 문서 분리가있는 동일한 출력 용지함에 배치하여 시트 데이터 정렬의 효과를 달성하는지 여부는 구현에 따라 다릅니다. 또한 작업을 여러 번 통과하거나 출력 분류기를 사용하여 달성하는지 여부는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="80415a2402a1eeb4d1614afdc0790cc2cd751eb2" translate="yes" xml:space="preserve">
          <source>Whether the field type is integral.</source>
          <target state="translated">필드 유형이 필수인지 여부.</target>
        </trans-unit>
        <trans-unit id="0d0d9b917bd4457293707b233fdfaf38f800ca2f" translate="yes" xml:space="preserve">
          <source>Whether the given file is accepted by this filter.</source>
          <target state="translated">주어진 파일이이 필터에 의해 허용되는지 여부.</target>
        </trans-unit>
        <trans-unit id="0b221a5fcef637ecf18d19b895618107e0ec7d34" translate="yes" xml:space="preserve">
          <source>Whether the progress bar is horizontal or vertical.</source>
          <target state="translated">진행률 표시 줄이 수평인지 수직인지 여부.</target>
        </trans-unit>
        <trans-unit id="a6d6a865c13d64eec6f0217eba676663f0999299" translate="yes" xml:space="preserve">
          <source>Whether the progress bar is horizontal or vertical. The default is &lt;code&gt;HORIZONTAL&lt;/code&gt;.</source>
          <target state="translated">진행률 표시 줄이 수평인지 수직인지 여부. 기본값은 &lt;code&gt;HORIZONTAL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d07e8763f02114da7e0c71037a504961880c1abb" translate="yes" xml:space="preserve">
          <source>Whether the slider is horizontal or vertical The default is horizontal.</source>
          <target state="translated">슬라이더가 수평인지 수직인지 여부 기본값은 수평입니다.</target>
        </trans-unit>
        <trans-unit id="b500b42f712219c24a8bd54914f1fa1b4e445284" translate="yes" xml:space="preserve">
          <source>Whether the value of the attribute can be read.</source>
          <target state="translated">속성 값을 읽을 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="d7db98311d27050f8bbb866412a5ea00983c801f" translate="yes" xml:space="preserve">
          <source>Whether to display a border around the progress bar.</source>
          <target state="translated">진행률 표시 줄 주위에 테두리를 표시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="0d7eb02de3d8787df6eadd74e0b934899bf8467f" translate="yes" xml:space="preserve">
          <source>Whether to display a border around the progress bar. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">진행률 표시 줄 주위에 테두리를 표시할지 여부입니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7bb449420de50b1f70b9cf8aa6735bcb426d5e7f" translate="yes" xml:space="preserve">
          <source>Whether to display a string of text on the progress bar.</source>
          <target state="translated">진행률 표시 줄에 텍스트 문자열을 표시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="6ce38cd557d077996b81c259fa55fc8d873bb920" translate="yes" xml:space="preserve">
          <source>Whether to display a string of text on the progress bar. The default is &lt;code&gt;false&lt;/code&gt;. Setting this to &lt;code&gt;true&lt;/code&gt; causes a textual display of the progress to be rendered on the progress bar. If the &lt;code&gt;progressString&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the percentage of completion is displayed on the progress bar. Otherwise, the &lt;code&gt;progressString&lt;/code&gt; is rendered on the progress bar.</source>
          <target state="translated">진행률 표시 줄에 텍스트 문자열을 표시할지 여부입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 이 값을 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 진행률 표시 줄에 진행률의 텍스트 표시가 렌더링됩니다. 경우 &lt;code&gt;progressString&lt;/code&gt; 이가 있다 &lt;code&gt;null&lt;/code&gt; , 완료의 비율은 진행 표시 줄에 표시됩니다. 그렇지 않으면 &lt;code&gt;progressString&lt;/code&gt; 이 진행률 표시 줄에 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="49449561f235eb64ebabd8dfba321eb0bf01fd39" translate="yes" xml:space="preserve">
          <source>Whether to read fields of unrecognized tags</source>
          <target state="translated">인식 할 수없는 태그 필드를 읽을 지 여부</target>
        </trans-unit>
        <trans-unit id="2f2f17106f12b2db4361609c9dfa05eb46f32c85" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;CompositeView&lt;/code&gt; does not impose a layout policy on its child &lt;code&gt;View&lt;/code&gt;s, it does allow for inseting the child &lt;code&gt;View&lt;/code&gt;s it will contain. The insets can be set by either &lt;a href=&quot;#setInsets(short,short,short,short)&quot;&gt;&lt;code&gt;setInsets(short, short, short, short)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#setParagraphInsets(javax.swing.text.AttributeSet)&quot;&gt;&lt;code&gt;setParagraphInsets(javax.swing.text.AttributeSet)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">동안 &lt;code&gt;CompositeView&lt;/code&gt; 자식에 레이아웃 정책을 부과하지 않는 &lt;code&gt;View&lt;/code&gt; 의, 그것은 아이 inseting 허용 않는 &lt;code&gt;View&lt;/code&gt; 가 포함됩니다들. 인세 &lt;a href=&quot;#setInsets(short,short,short,short)&quot;&gt; &lt;code&gt;setInsets(short, short, short, short)&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#setParagraphInsets(javax.swing.text.AttributeSet)&quot;&gt; &lt;code&gt;setParagraphInsets(javax.swing.text.AttributeSet)&lt;/code&gt; &lt;/a&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c42976582ea88cec97c24e4c0d10841777ac466" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;Deque&lt;/code&gt; implementations are not strictly required to prohibit the insertion of null elements, they are strongly encouraged to do so. Users of any &lt;code&gt;Deque&lt;/code&gt; implementations that do allow null elements are strongly encouraged</source>
          <target state="translated">하지만 &lt;code&gt;Deque&lt;/code&gt; 와 구현이 엄격하게는 null 요소의 삽입을 금지 할 필요가 없습니다, 그들은 강력하게 그렇게하는 것이 좋습니다. null 요소를 허용 하는 &lt;code&gt;Deque&lt;/code&gt; 구현 사용자 는 강력히 권장됩니다</target>
        </trans-unit>
        <trans-unit id="3d6ef8f821513dcce4a530375fb519e3029c0687" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;TreePath&lt;/code&gt; is serializable, a &lt;code&gt;
 NotSerializableException&lt;/code&gt; is thrown if any elements of the path are not serializable.</source>
          <target state="translated">&lt;code&gt;TreePath&lt;/code&gt; 는 직렬화 가능 하지만 경로의 요소가 직렬화 가능하지 않으면 &lt;code&gt; NotSerializableException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="51c173ac8703a05aa36fea05d64c73f4930ea483" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;dropWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd08eb3b81d66f20546d1029c826ea0fbe16bd34" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;dropWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58a60decffcb60cd8818f4e94cb70dfd3ab19008" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;dropWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 지정 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a29b609ce06935cf71396d9bc3de52f946081d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;dropWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;dropWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;dropWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;dropWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8bebbe990bf762b2089ef58b873ffcb3559acbd" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 정렬 제약 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다.상황의 의미가 허용하는 경우 병렬 파이프 라인에서. 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;limit()&lt;/code&gt; 을 사용하여 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fae011e82778ef6bc326d638878e4e4eb7c86dc3" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다.상황의 의미가 허용하는 경우 병렬 파이프 라인에서. 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;limit()&lt;/code&gt; 을 사용하여 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52357540a609522f143b04a6d7f5344f0cb8965b" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 정렬 제약 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다.상황의 의미가 허용하는 경우 병렬 파이프 라인에서. 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;limit()&lt;/code&gt; 을 사용하여 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5292e16f7d0f56673e81e44acea4610d6162687f" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 제약 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다.상황의 의미가 허용하는 경우 병렬 파이프 라인에서. 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;limit()&lt;/code&gt; 을 사용하여 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c116ddf414b394a7666553a5a6b566a1451776ab" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;doublestream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 순서 제약 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다상황의 의미가 허용되는 경우 병렬 파이프 라인에서. 만남의 순서에 일관성이 필요합니다, 당신은 가난한 성능이나 메모리 사용률이 발생하는 경우 &lt;code&gt;limit()&lt;/code&gt; 에 순차 실행 전환 병렬 파이프 라인에서 &lt;a href=&quot;doublestream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt; 성능을 향상시킬 수있다.</target>
        </trans-unit>
        <trans-unit id="07ed1f5d7e24e0c78296347da906a9d60feefd38" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;intstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 제한 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 상황의 의미가 허용되는 경우 병렬 파이프 라인에서 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;code&gt;limit()&lt;/code&gt; 에 순차 실행 전환 병렬 파이프 라인에서 &lt;a href=&quot;intstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt; 성능을 향상시킬 수있다.</target>
        </trans-unit>
        <trans-unit id="50f1dd72f901eaef160af7e84d23600d1ebf7971" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;longstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 제한 조건을 제거하면 속도가 크게 향상 될 수 있습니다 &lt;code&gt;limit()&lt;/code&gt; 상황의 의미가 허용되는 경우 병렬 파이프 라인에서. 만남의 순서에 일관성이 필요합니다, 당신은 가난한 성능이나 메모리 사용률이 발생하는 경우 &lt;code&gt;limit()&lt;/code&gt; 에 순차 실행 전환 병렬 파이프 라인에서 &lt;a href=&quot;longstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt; 성능을 향상시킬 수있다.</target>
        </trans-unit>
        <trans-unit id="e7b022b1174615a655ebcf28b81dbf48a9f1556b" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;limit()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;maxSize&lt;/code&gt;, since &lt;code&gt;limit(n)&lt;/code&gt; is constrained to return not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;limit()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential--&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;limit()&lt;/code&gt; 연속 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;maxSize&lt;/code&gt; 를 하기 때문에, &lt;code&gt;limit(n)&lt;/code&gt; 아니라 어떤 돌아 제약을 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만, &lt;em&gt;처음 n은&lt;/em&gt; 만남 순서의 요소. 순서가없는 스트림 소스 (예 : &lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 순서 제약 조건을 제거하면 &lt;code&gt;limit()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다상황의 의미가 허용되는 경우 병렬 파이프 라인에서. 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;limit()&lt;/code&gt; 을 사용하여 성능 또는 메모리 사용률이 저하 된 경우 &lt;a href=&quot;basestream#sequential--&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차적 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b87dc7fad8d14aab16d4ddc4f41ded925891b0e" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">반면 &lt;code&gt;skip()&lt;/code&gt; 순차 스트림 파이프 라인 저렴한 작업이 일반적이며, 이는 특히 큰 값 순서화 병렬 파이프 라인에서 매우 비쌀 수 &lt;code&gt;n&lt;/code&gt; 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 임의의 건너 구속 &lt;em&gt;N 개의&lt;/em&gt; 요소하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능 저하 또는 메모리 사용률이 &lt;code&gt;skip()&lt;/code&gt; 병렬 파이프 라인에서 skip () 을 사용하는 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd851600c5d344782f73398b78b6e28503994a09" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">반면 &lt;code&gt;skip()&lt;/code&gt; 순차 스트림 파이프 라인 저렴한 작업이 일반적이며, 이는 특히 큰 값 순서화 병렬 파이프 라인에서 매우 비쌀 수 &lt;code&gt;n&lt;/code&gt; 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 임의의 건너 구속 &lt;em&gt;N 개의&lt;/em&gt; 요소하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 지정 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능 저하 또는 메모리 사용률이 &lt;code&gt;skip()&lt;/code&gt; 병렬 파이프 라인에서 skip () 을 사용하는 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a33a9aba4905d83925c9ee06f4fa960c35c02c78" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">반면 &lt;code&gt;skip()&lt;/code&gt; 순차 스트림 파이프 라인 저렴한 작업이 일반적이며, 이는 특히 큰 값 순서화 병렬 파이프 라인에서 매우 비쌀 수 &lt;code&gt;n&lt;/code&gt; 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 임의의 건너 구속 &lt;em&gt;N 개의&lt;/em&gt; 요소하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 지정 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능 저하 또는 메모리 사용률이 &lt;code&gt;skip()&lt;/code&gt; 병렬 파이프 라인에서 skip () 을 사용하는 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b0b2ed9d6a481a9b272dda6c65ea3e9ae7c5297" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">반면 &lt;code&gt;skip()&lt;/code&gt; 순차 스트림 파이프 라인 저렴한 작업이 일반적이며, 이는 특히 큰 값 순서화 병렬 파이프 라인에서 매우 비쌀 수 &lt;code&gt;n&lt;/code&gt; 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 임의의 건너 구속 &lt;em&gt;N 개의&lt;/em&gt; 요소하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 지정 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능 저하 또는 메모리 사용률이 &lt;code&gt;skip()&lt;/code&gt; 병렬 파이프 라인에서 skip () 을 사용하는 경우 &lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74d731aa21902009fd224b6c3c7d21287ffacde8" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;doublestream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">반면 &lt;code&gt;skip()&lt;/code&gt; 순차 스트림 파이프 라인 저렴한 작업이 일반적이며, 이는 특히 큰 값 순서화 병렬 파이프 라인에서 매우 비쌀 수 &lt;code&gt;n&lt;/code&gt; 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 어떤 이동하도록 구속되는 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예로서 사용하여 &lt;a href=&quot;doublestream#generate-java.util.function.DoubleSupplier-&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt; ) 또는 함께 오더링 제약 제거 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 의 경우 상당한 성능 향상을 기대할 수있다 &lt;code&gt;skip()&lt;/code&gt; 상황의 의미가 허용되는 경우 병렬 파이프 라인에서 . 발생 순서와의 일관성이 필요하고 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;code&gt;skip()&lt;/code&gt; 하여 순차 실행 전환 병렬 파이프 라인으로 &lt;a href=&quot;doublestream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt; 성능을 향상시킬 수있다.</target>
        </trans-unit>
        <trans-unit id="8b6aed4201bbc532174a6b1ac759cb47bf878a52" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;intstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;skip()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;n&lt;/code&gt; 있기 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 어떤 이동하도록 구속되는 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;intstream#generate-java.util.function.IntSupplier-&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 제한 조건을 제거하면 상황의 의미가 허용되는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;code&gt;skip()&lt;/code&gt; 하여 순차 실행 전환 병렬 파이프 라인으로 &lt;a href=&quot;intstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt; 성능을 향상시킬 수있다.</target>
        </trans-unit>
        <trans-unit id="08e49b292a5f6675c12e6e8084622cb9a1123c41" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;longstream#sequential--&quot;&gt;&lt;code&gt;sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;skip()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업이 일반적으로, 그것은 특히 큰 값, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다 &lt;code&gt;n&lt;/code&gt; 있기 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 그냥하지 건너 뛰도록 제한된다&lt;em&gt; n 개의&lt;/em&gt; 요소를하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;longstream#generate-java.util.function.LongSupplier-&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 제한 조건을 제거하면 상황의 의미가 허용되는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;code&gt;skip()&lt;/code&gt; 하여 순차 실행 전환 병렬 파이프 라인으로 &lt;a href=&quot;longstream#sequential--&quot;&gt; &lt;code&gt;sequential()&lt;/code&gt; &lt;/a&gt; 성능을 향상시킬 수있다.</target>
        </trans-unit>
        <trans-unit id="e1b922a638d8b7b0bf464d0b07da3f9937acce8a" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;skip()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, especially for large values of &lt;code&gt;n&lt;/code&gt;, since &lt;code&gt;skip(n)&lt;/code&gt; is constrained to skip not just any &lt;em&gt;n&lt;/em&gt; elements, but the &lt;em&gt;first n&lt;/em&gt; elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered--&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;skip()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential--&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">반면 &lt;code&gt;skip()&lt;/code&gt; 순차 스트림 파이프 라인 저렴한 작업이 일반적이며, 이는 특히 큰 값 순서화 병렬 파이프 라인에서 매우 비쌀 수 &lt;code&gt;n&lt;/code&gt; 때문에, &lt;code&gt;skip(n)&lt;/code&gt; 아닌 어떤 이동하도록 구속되는 &lt;em&gt;n 개의&lt;/em&gt; 요소를하지만 &lt;em&gt;제 n은&lt;/em&gt; 만남 순서의 요소. 정렬되지 않은 스트림 소스 (예 : &lt;a href=&quot;stream#generate-java.util.function.Supplier-&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered--&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 사용하여 정렬 제한 조건을 제거하면 상황의 의미가 허용되는 경우 병렬 파이프 라인에서 &lt;code&gt;skip()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요하고 성능이 저하되거나 메모리 사용률이 낮은 경우 &lt;code&gt;skip()&lt;/code&gt; 병렬 파이프 라인의 skip () 에서 &lt;a href=&quot;basestream#sequential--&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 사용하여 순차적 실행으로 전환 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f11e1ce2eaeeb9a61aafb14bbaaa04b134c253c4" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt;&lt;code&gt;generate(DoubleSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;takeWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.DoubleSupplier)&quot;&gt; &lt;code&gt;generate(DoubleSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 지정 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="536720f4d6e048e3bfc2daf23b8be0d5f28b62ff" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt;&lt;code&gt;generate(IntSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;takeWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.IntSupplier)&quot;&gt; &lt;code&gt;generate(IntSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 지정 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="996949649b893c1211f1e5529c0828c15fa967ef" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt;&lt;code&gt;generate(LongSupplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;takeWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.LongSupplier)&quot;&gt; &lt;code&gt;generate(LongSupplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e8939e26489616f38385fb9a8f6b0914d6faecc" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;takeWhile()&lt;/code&gt; is generally a cheap operation on sequential stream pipelines, it can be quite expensive on ordered parallel pipelines, since the operation is constrained to return not just any valid prefix, but the longest prefix of elements in the encounter order. Using an unordered stream source (such as &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt;&lt;code&gt;generate(Supplier)&lt;/code&gt;&lt;/a&gt;) or removing the ordering constraint with &lt;a href=&quot;basestream#unordered()&quot;&gt;&lt;code&gt;BaseStream.unordered()&lt;/code&gt;&lt;/a&gt; may result in significant speedups of &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, if the semantics of your situation permit. If consistency with encounter order is required, and you are experiencing poor performance or memory utilization with &lt;code&gt;takeWhile()&lt;/code&gt; in parallel pipelines, switching to sequential execution with &lt;a href=&quot;basestream#sequential()&quot;&gt;&lt;code&gt;BaseStream.sequential()&lt;/code&gt;&lt;/a&gt; may improve performance.</source>
          <target state="translated">하지만 &lt;code&gt;takeWhile()&lt;/code&gt; 순차적 스트림 파이프 라인에 싼 작업은 일반적으로 작업이 유효한 접두사,하지만 만남 순서에있는 요소의 가장 긴 접두사 단지를 반환하도록 제한되어 있기 때문에, 그것은, 주문 병렬 파이프 라인에 매우 비쌀 수 있습니다. 순서가 지정되지 않은 스트림 소스 (예 : &lt;a href=&quot;#generate(java.util.function.Supplier)&quot;&gt; &lt;code&gt;generate(Supplier)&lt;/code&gt; &lt;/a&gt; )를 사용하거나 &lt;a href=&quot;basestream#unordered()&quot;&gt; &lt;code&gt;BaseStream.unordered()&lt;/code&gt; &lt;/a&gt; 순서 제약 조건을 제거하면 상황의 의미가 허용하는 경우 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 속도가 크게 향상 될 수 있습니다 . 발생 순서와의 일관성이 필요 하고 병렬 파이프 라인에서 &lt;code&gt;takeWhile()&lt;/code&gt; 을 사용하여 성능이나 메모리 사용률이 저하되는 경우 다음을 사용 하여 순차 실행으로 전환합니다.&lt;a href=&quot;basestream#sequential()&quot;&gt; &lt;code&gt;BaseStream.sequential()&lt;/code&gt; &lt;/a&gt; 는 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f44ebb750484feed7acd90b248717e6c6a220783" translate="yes" xml:space="preserve">
          <source>While DefaultMutableTreeNode implements the MutableTreeNode interface and will allow you to add in any implementation of MutableTreeNode not all of the methods in DefaultMutableTreeNode will be applicable to all MutableTreeNodes implementations. Especially with some of the enumerations that are provided, using some of these methods assumes the DefaultMutableTreeNode contains only DefaultMutableNode instances. All of the TreeNode/MutableTreeNode methods will behave as defined no matter what implementations are added.</source>
          <target state="translated">DefaultMutableTreeNode가 MutableTreeNode 인터페이스를 구현하고 MutableTreeNode의 모든 구현에 추가 할 수 있도록 허용하지만 DefaultMutableTreeNode의 모든 메소드가 모든 MutableTreeNodes 구현에 적용되는 것은 아닙니다. 특히 제공되는 일부 열거의 경우 이러한 메서드 중 일부를 사용하면 DefaultMutableTreeNode에 DefaultMutableNode 인스턴스 만 포함되어 있다고 가정합니다. 모든 TreeNode / MutableTreeNode 메서드는 추가 된 구현에 관계없이 정의 된대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4167a99521bae55a855564642cb10cb92285c449" translate="yes" xml:space="preserve">
          <source>While JAXP supports validation as a feature of an XML parser, represented by either a &lt;a href=&quot;../parsers/saxparser&quot;&gt;&lt;code&gt;SAXParser&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../parsers/documentbuilder&quot;&gt;&lt;code&gt;DocumentBuilder&lt;/code&gt;&lt;/a&gt; instance, the &lt;code&gt;Validation&lt;/code&gt; API is preferred.</source>
          <target state="translated">JAXP는 &lt;a href=&quot;../parsers/saxparser&quot;&gt; &lt;code&gt;SAXParser&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../parsers/documentbuilder&quot;&gt; &lt;code&gt;DocumentBuilder&lt;/code&gt; &lt;/a&gt; 인스턴스로 표시되는 XML 파서의 기능으로 유효성 검사를 지원하지만 &lt;code&gt;Validation&lt;/code&gt; API가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="a21ea13fd41327eba1978d9dc59ed4e742694b36" translate="yes" xml:space="preserve">
          <source>While XPath expressions select nodes in the XML document, the XPath API allows the selected nodes to be coalesced into one of the following data types:</source>
          <target state="translated">XPath 표현식은 XML 문서에서 노드를 선택하지만 XPath API를 사용하면 선택한 노드를 다음 데이터 유형 중 하나로 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1c1d5877bbdead7eaf0421be72e2ef20db6441f" translate="yes" xml:space="preserve">
          <source>While a &lt;code id=&quot;ELEM_VS_TYPE&quot;&gt;TypeElement&lt;/code&gt; represents a class or interface</source>
          <target state="translated">&lt;code id=&quot;ELEM_VS_TYPE&quot;&gt;TypeElement&lt;/code&gt; 가 클래스 또는 인터페이스를 나타내는 동안</target>
        </trans-unit>
        <trans-unit id="9231d9bdcc9f4e1959e5ee9d3a56a9d2a170bb99" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;CachedRowSet&lt;/code&gt; object is disconnected, it can be much leaner than a &lt;code&gt;ResultSet&lt;/code&gt; object with the same data. As a result, it can be especially suitable for sending data to a thin client such as a PDA, where it would be inappropriate to use a JDBC driver due to resource limitations or security considerations. Thus, a &lt;code&gt;CachedRowSet&lt;/code&gt; object provides a means to &quot;get rows in&quot; without the need to implement the full JDBC API.</source>
          <target state="translated">&lt;code&gt;CachedRowSet&lt;/code&gt; 객체가 연결이 끊어진 동안 동일한 데이터를 가진 &lt;code&gt;ResultSet&lt;/code&gt; 객체 보다 훨씬 더 가늘어 질 수 있습니다 . 따라서 리소스 제한이나 보안 고려 사항으로 인해 JDBC 드라이버를 사용하는 것이 부적절 할 수있는 PDA와 같은 씬 클라이언트로 데이터를 보내는 데 특히 적합 할 수 있습니다. 따라서 &lt;code&gt;CachedRowSet&lt;/code&gt; 객체는 전체 JDBC API를 구현할 필요없이 &quot;행을 가져 오는&quot;수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="30e4f165db1002fe6fbf12ff195d30f7e4cff77b" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;Chronology&lt;/code&gt; object typically uses &lt;code&gt;ChronoField&lt;/code&gt; and is based on an era, year-of-era, month-of-year, day-of-month model of a date, this is not required. A &lt;code&gt;Chronology&lt;/code&gt; instance may represent a totally different kind of calendar system, such as the Mayan.</source>
          <target state="translated">잠시 &lt;code&gt;Chronology&lt;/code&gt; 객체는 일반적으로 사용 &lt;code&gt;ChronoField&lt;/code&gt; 을 시대와 기반으로, 올해의 시대, 달의 년, 날짜의 하루의 달 모델이 필요하지 않습니다. &lt;code&gt;Chronology&lt;/code&gt; 인스턴스는 마야로 캘린더 시스템의 완전히 다른 종류를 나타낼 수있다.</target>
        </trans-unit>
        <trans-unit id="9784eeccfaf1f4a4f0da131846253a9ef6b0027f" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;TypeElement&lt;/code&gt; represents a class or interface</source>
          <target state="translated">&lt;code&gt;TypeElement&lt;/code&gt; 가 클래스 또는 인터페이스를 나타내는 동안</target>
        </trans-unit>
        <trans-unit id="b1518d4c45f16c46674f0f206ccd4613201a8ad4" translate="yes" xml:space="preserve">
          <source>While all three of the &lt;code&gt;prototypeCellValue&lt;/code&gt;, &lt;code&gt;fixedCellHeight&lt;/code&gt;, and &lt;code&gt;fixedCellWidth&lt;/code&gt; properties may be modified by this method, &lt;code&gt;PropertyChangeEvent&lt;/code&gt; notifications are only sent when the &lt;code&gt;prototypeCellValue&lt;/code&gt; property changes.</source>
          <target state="translated">세 가지 &lt;code&gt;prototypeCellValue&lt;/code&gt; , &lt;code&gt;fixedCellHeight&lt;/code&gt; 및 &lt;code&gt;fixedCellWidth&lt;/code&gt; 속성은 모두이 메서드로 수정할 수 있지만 &lt;code&gt;PropertyChangeEvent&lt;/code&gt; 알림은 &lt;code&gt;prototypeCellValue&lt;/code&gt; 속성이 변경 될 때만 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b017d1c42ec1554655bf855dc44af27a7a96ca5" translate="yes" xml:space="preserve">
          <source>While applications write to the &lt;code&gt;LoginContext&lt;/code&gt; API, authentication technology providers implement the &lt;code&gt;LoginModule&lt;/code&gt; interface. A &lt;code&gt;Configuration&lt;/code&gt; specifies the LoginModule(s) to be used with a particular login application. Therefore different LoginModules can be plugged in under the application without requiring any modifications to the application itself.</source>
          <target state="translated">응용 프로그램이 &lt;code&gt;LoginContext&lt;/code&gt; API에 쓰는 동안 인증 기술 공급자는 &lt;code&gt;LoginModule&lt;/code&gt; 인터페이스를 . &lt;code&gt;Configuration&lt;/code&gt; 특정한 로그인 응용에 사용되는 LoginModule를 지정한다. 따라서 응용 프로그램 자체를 수정하지 않고도 응용 프로그램에서 다른 LoginModule을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2406ab2abac29e951c9626f9ef877429a290fa9c" translate="yes" xml:space="preserve">
          <source>While building the MBeanInfo, this method calls the customization hooks that make it possible for subclasses to supply their custom descriptions, parameter names, etc...</source>
          <target state="translated">MBeanInfo를 빌드하는 동안이 메소드는 서브 클래스가 사용자 정의 설명, 매개 변수 이름 등을 제공 할 수있게하는 사용자 정의 후크를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="73b5f4ac2141a2818394c1e963ca8d4434b78746" translate="yes" xml:space="preserve">
          <source>While callers may invoke &lt;code&gt;login&lt;/code&gt; directly, the provider may also invoke &lt;code&gt;login&lt;/code&gt; on behalf of callers if it determines that a login must be performed prior to certain operations.</source>
          <target state="translated">발신자가 &lt;code&gt;login&lt;/code&gt; 직접 호출 할 수도 있지만 공급자는 호출 할 수도 있습니다. &lt;code&gt;login&lt;/code&gt; 특정 조작 전에 로그인을 수행해야한다고 결정한 경우 발신자를 대신하여 로그인 을 있습니다.</target>
        </trans-unit>
        <trans-unit id="498a5c4d7f0598c6bbc42679f4696f06bbc47c30" translate="yes" xml:space="preserve">
          <source>While for case 2, it defines 4 URI Entries:</source>
          <target state="translated">사례 2의 경우 4 개의 URI 항목을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="868ad264cb55aef3c8dd9f1593aca303b1f31c60" translate="yes" xml:space="preserve">
          <source>While iterating through the &lt;code&gt;Set&lt;/code&gt;, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown if a security manager is installed and the caller does not have a &lt;a href=&quot;privatecredentialpermission&quot;&gt;&lt;code&gt;PrivateCredentialPermission&lt;/code&gt;&lt;/a&gt; to access a particular Credential. The &lt;code&gt;Iterator&lt;/code&gt; is nevertheless advanced to the next element in the &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">관통 반복하면서 &lt;code&gt;Set&lt;/code&gt; 하는 &lt;code&gt;SecurityException&lt;/code&gt; 가이 보안 관리자가 설치되어있는 경우 발생합니다 호출자가없는 &lt;a href=&quot;privatecredentialpermission&quot;&gt; &lt;code&gt;PrivateCredentialPermission&lt;/code&gt; 의&lt;/a&gt; 액세스 특정 자격 증명을합니다. &lt;code&gt;Iterator&lt;/code&gt; 에서 다음 요소로 그럼에도 불구하고 진보 된 &lt;code&gt;Set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6354a2a3180a9378c7eb02538eb193186e5effba" translate="yes" xml:space="preserve">
          <source>While iterating through the &lt;code&gt;Set&lt;/code&gt;, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown if the caller does not have permission to access a particular Credential. The &lt;code&gt;Iterator&lt;/code&gt; is nevertheless advanced to next element in the &lt;code&gt;Set&lt;/code&gt;.</source>
          <target state="translated">관통 반복하면서 &lt;code&gt;Set&lt;/code&gt; 하는 &lt;code&gt;SecurityException&lt;/code&gt; 가이 호출자 액세스 특정 자격 증명에 권한이없는 경우 발생합니다. &lt;code&gt;Iterator&lt;/code&gt; 그럼에도 불구하고 다음의 요소에 처리를 진행시킵니다 &lt;code&gt;Set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fa2ee2232311c188a194a08d7481eaf402f451e" translate="yes" xml:space="preserve">
          <source>While parsing an input source, errors are reported to the application through the error handler (&lt;code&gt;LSParser.domConfig&lt;/code&gt;'s &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt;&quot; parameter). This specification does in no way try to define all possible errors that can occur while parsing XML, or any other markup, but some common error cases are defined. The types (&lt;code&gt;DOMError.type&lt;/code&gt;) of errors and warnings defined by this specification are:</source>
          <target state="translated">입력 소스를 구문 분석하는 동안 오류 핸들러 ( &lt;code&gt;LSParser.domConfig&lt;/code&gt; 의 &quot; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt; &quot;매개 변수)를 통해 애플리케이션에 오류가보고됩니다 . 이 사양은 XML 또는 기타 마크 업을 구문 분석하는 동안 발생할 수있는 모든 가능한 오류를 정의하려고하지 않지만 몇 가지 일반적인 오류 사례가 정의되어 있습니다. 이 사양에 정의 된 오류 및 경고 유형 ( &lt;code&gt;DOMError.type&lt;/code&gt; )은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86165e5f29fc9b9137f2a5569a7128b787a2ddbb" translate="yes" xml:space="preserve">
          <source>While serializing a document, the parameter &quot;discard-default-content&quot; controls whether or not non-specified data is serialized.</source>
          <target state="translated">문서를 직렬화하는 동안 &quot;discard-default-content&quot;매개 변수는 지정되지 않은 데이터가 직렬화되는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="cf4536abd5f3f04b1e2ed476be040c60ab02acb7" translate="yes" xml:space="preserve">
          <source>While serializing, errors and warnings are reported to the application through the error handler (&lt;code&gt;LSSerializer.domConfig&lt;/code&gt;'s &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt;&quot; parameter). This specification does in no way try to define all possible errors and warnings that can occur while serializing a DOM node, but some common error and warning cases are defined. The types ( &lt;code&gt;DOMError.type&lt;/code&gt;) of errors and warnings defined by this specification are:</source>
          <target state="translated">직렬화하는 동안 오류 및 경고는 오류 처리기 ( &lt;code&gt;LSSerializer.domConfig&lt;/code&gt; 의 &quot; &lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-error-handler&quot;&gt;error-handler&lt;/a&gt; &quot;매개 변수)를 통해 응용 프로그램에보고됩니다 . 이 사양은 DOM 노드를 직렬화하는 동안 발생할 수있는 모든 가능한 오류 및 경고를 정의하려고하지 않지만 몇 가지 일반적인 오류 및 경고 사례가 정의되어 있습니다. 이 사양에 정의 된 오류 및 경고 유형 ( &lt;code&gt;DOMError.type&lt;/code&gt; )은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c239e1b59a3047897d29f5e117079370e9edd962" translate="yes" xml:space="preserve">
          <source>While tables for abbreviated streams are often obtained by first reading another abbreviated stream containing only the tables, in some applications the tables are fixed ahead of time. This class allows the tables to be specified directly from client code. If no tables are specified either in the stream or in a &lt;code&gt;JPEGImageReadParam&lt;/code&gt;, then the stream is presumed to use the &quot;standard&quot; visually lossless tables. See &lt;a href=&quot;jpegqtable&quot;&gt;&lt;code&gt;JPEGQTable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;jpeghuffmantable&quot;&gt;&lt;code&gt;JPEGHuffmanTable&lt;/code&gt;&lt;/a&gt; for more information on the default tables.</source>
          <target state="translated">축약 된 스트림에 대한 테이블은 종종 테이블 만 포함하는 다른 축약 된 스트림을 먼저 읽음으로써 얻을 수 있지만 일부 응용 프로그램에서는 테이블이 미리 고정되어 있습니다. 이 클래스는 클라이언트 코드에서 직접 테이블을 지정할 수 있습니다. 스트림 또는 &lt;code&gt;JPEGImageReadParam&lt;/code&gt; 에 테이블이 지정되어 있지 않은 경우 , 스트림은 &quot;표준&quot;시각적 무손실 테이블을 사용하는 것으로 간주됩니다. 참조 &lt;a href=&quot;jpegqtable&quot;&gt; &lt;code&gt;JPEGQTable&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;jpeghuffmantable&quot;&gt; &lt;code&gt;JPEGHuffmanTable&lt;/code&gt; &lt;/a&gt;기본 테이블에 대한 자세한 내용 JPEGHuffmanTable 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1b216501bc1079107fcb46b023f11ebfbbaf13fc" translate="yes" xml:space="preserve">
          <source>While tables for abbreviated streams are often specified by first writing an abbreviated stream containing only the tables, in some applications the tables are fixed ahead of time. This class allows the tables to be specified directly from client code.</source>
          <target state="translated">축약 된 스트림에 대한 테이블은 종종 테이블 만 포함 된 축약 된 스트림을 먼저 작성하여 지정되지만 일부 응용 프로그램에서는 테이블이 미리 고정되어 있습니다. 이 클래스는 클라이언트 코드에서 직접 테이블을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f55e7baa234a92f09d11651aeeb34c78f17b723e" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;Collection&lt;/code&gt; interface adds no stipulations to the general contract for the &lt;code&gt;Object.equals&lt;/code&gt;, programmers who implement the &lt;code&gt;Collection&lt;/code&gt; interface &quot;directly&quot; (in other words, create a class that is a &lt;code&gt;Collection&lt;/code&gt; but is not a &lt;code&gt;Set&lt;/code&gt; or a &lt;code&gt;List&lt;/code&gt;) must exercise care if they choose to override the &lt;code&gt;Object.equals&lt;/code&gt;. It is not necessary to do so, and the simplest course of action is to rely on &lt;code&gt;Object&lt;/code&gt;'s implementation, but the implementor may wish to implement a &quot;value comparison&quot; in place of the default &quot;reference comparison.&quot; (The &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; interfaces mandate such value comparisons.)</source>
          <target state="translated">그동안 &lt;code&gt;Collection&lt;/code&gt; 인터페이스가의 일반 규약에 조항을 추가하지 &lt;code&gt;Object.equals&lt;/code&gt; , 프로그래머는 누가 구현하는 &lt;code&gt;Collection&lt;/code&gt; (A 클래스 인 클래스 생성, 즉 인터페이스 &quot;직접&quot; &lt;code&gt;Collection&lt;/code&gt; 하지만없는 &lt;code&gt;Set&lt;/code&gt; 또는 &lt;code&gt;List&lt;/code&gt; 주의를 기울여야해야합니다) 그들이 &lt;code&gt;Object.equals&lt;/code&gt; 를 재정의하기로 선택한 경우 . 그렇게 할 필요는 없으며 가장 간단한 조치는 &lt;code&gt;Object&lt;/code&gt; 구현 에 의존하는 것이지만 구현자는 기본 &quot;참조 비교&quot;대신 &quot;값 비교&quot;를 구현할 수 있습니다. ( &lt;code&gt;List&lt;/code&gt; 과 &lt;code&gt;Set&lt;/code&gt; 인터페이스는 이러한 값 비교를 요구합니다.)</target>
        </trans-unit>
        <trans-unit id="d9b34ed17b895b7570e58dbe128c1061764f2836" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;JOptionPane&lt;/code&gt; class may appear complex because of the large number of methods, almost all uses of this class are one-line calls to one of the static &lt;code&gt;showXxxDialog&lt;/code&gt; methods shown below:</source>
          <target state="translated">&lt;code&gt;JOptionPane&lt;/code&gt; 클래스는 많은 수의 메서드로 인해 복잡해 보일 수 있지만 이 클래스의 거의 모든 용도는 아래 표시된 정적 &lt;code&gt;showXxxDialog&lt;/code&gt; 메서드 중 하나에 대한 한 줄 호출입니다 .</target>
        </trans-unit>
        <trans-unit id="f05e95138eee0f8263aaeecdb23d34bbf507f801" translate="yes" xml:space="preserve">
          <source>While the child view is being accessed a read lock is acquired on the associated document so that the model is stable while being accessed.</source>
          <target state="translated">하위 뷰에 액세스하는 동안 연결된 문서에 대한 읽기 잠금이 획득되어 모델이 액세스되는 동안 안정적입니다.</target>
        </trans-unit>
        <trans-unit id="18005f1749c0380a1dd553fb852a3af3b6131165" translate="yes" xml:space="preserve">
          <source>While the drag and drop implementation calls &lt;code&gt;canImport&lt;/code&gt; to determine the suitability of a transfer before calling this method, the implementation of paste does not. As such, it cannot be assumed that the transfer is acceptable upon a call to this method for paste. It is recommended that &lt;code&gt;canImport&lt;/code&gt; be explicitly called to cover this case.</source>
          <target state="translated">끌어서 놓기 구현에서는 &lt;code&gt;canImport&lt;/code&gt; 를 호출하여이 메서드를 호출하기 전에 전송의 적합성을 결정하지만 붙여 넣기 구현에서는 그렇지 않습니다. 따라서 붙여 넣기를 위해이 메서드를 호출하면 전송이 허용된다고 가정 할 수 없습니다. 이 경우를 처리하기 위해 &lt;code&gt;canImport&lt;/code&gt; 를 명시 적으로 호출하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4efe8fc428299599c701c1333f6be7122c0cee74" translate="yes" xml:space="preserve">
          <source>While the hook is being called, the new &lt;code&gt;ConstantCallSite&lt;/code&gt; object is in a partially constructed state. In this state, a call to &lt;code&gt;getTarget&lt;/code&gt;, or any other attempt to use the target, will result in an &lt;code&gt;IllegalStateException&lt;/code&gt;. It is legal at all times to obtain the call site's type using the &lt;code&gt;type&lt;/code&gt; method.</source>
          <target state="translated">후크가 호출되는 동안 새 &lt;code&gt;ConstantCallSite&lt;/code&gt; 오브젝트는 부분적으로 구성된 상태입니다. 이 상태에서 &lt;code&gt;getTarget&lt;/code&gt; 에 대한 호출 또는 다른 대상을 사용하려고하면 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생 합니다 . &lt;code&gt;type&lt;/code&gt; 메소드를 사용하여 콜 사이트의 유형을 얻는 것이 항상 합법적 입니다.</target>
        </trans-unit>
        <trans-unit id="e64de2c787d87b6255db69fb316860954d89cac4" translate="yes" xml:space="preserve">
          <source>While the scoping mechanism for &lt;code&gt;synchronized&lt;/code&gt; methods and statements makes it much easier to program with monitor locks, and helps avoid many common programming errors involving locks, there are occasions where you need to work with locks in a more flexible way. For example, some algorithms for traversing concurrently accessed data structures require the use of &quot;hand-over-hand&quot; or &quot;chain locking&quot;: you acquire the lock of node A, then node B, then release A and acquire C, then release B and acquire D and so on. Implementations of the &lt;code&gt;Lock&lt;/code&gt; interface enable the use of such techniques by allowing a lock to be acquired and released in different scopes, and allowing multiple locks to be acquired and released in any order.</source>
          <target state="translated">&lt;code&gt;synchronized&lt;/code&gt; 메소드 및 명령문 의 범위 지정 메커니즘 으로 모니터 잠금을 사용하여 프로그래밍하는 것이 훨씬 쉬워지고 잠금과 관련된 많은 일반적인 프로그래밍 오류를 피할 수 있지만보다 유연한 방식으로 잠금으로 작업해야하는 경우가 있습니다. 예를 들어, 동시에 액세스되는 데이터 구조를 순회하기위한 일부 알고리즘에는 &quot;Hand-over-hand&quot;또는 &quot;chain locking&quot;을 사용해야합니다. 노드 A, 노드 B의 잠금을 획득 한 다음 A를 해제하고 C를 획득 한 다음 B를 해제하십시오. D 등을 얻습니다. &lt;code&gt;Lock&lt;/code&gt; 구현 인터페이스의 이 다른 범위에서 획득 및 해제 될 수있게하고, 임의의 순서로 다수의 잠금이 획득 및 해제 될 수있게함으로써 이러한 기술의 사용을 가능하게한다.</target>
        </trans-unit>
        <trans-unit id="e4da0d73a5a72455f5512b34b17d391abf383ff0" translate="yes" xml:space="preserve">
          <source>While the specification of this method in the &lt;a href=&quot;writer#write(java.lang.String,int,int)&quot;&gt;superclass&lt;/a&gt; recommends that an &lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt;&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;&lt;/a&gt; be thrown if &lt;code&gt;len&lt;/code&gt; is negative or &lt;code&gt;off + len&lt;/code&gt; is negative, the implementation in this class does not throw such an exception in these cases but instead simply writes no characters.</source>
          <target state="translated">&lt;a href=&quot;writer#write(java.lang.String,int,int)&quot;&gt;수퍼 클래스&lt;/a&gt; 에서이 메서드의 사양은 &lt;code&gt;len&lt;/code&gt; 이 음수이거나 &lt;code&gt;off + len&lt;/code&gt; 이 음수 이면 &lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt; &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; &lt;/a&gt; 이 throw되도록 권장하지만 이 클래스의 구현은 이러한 경우에 이러한 예외를 throw하지 않고 대신 단순히 문자를 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2fa594a26798c1bce1231654fe91cf1056a98394" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;append(char)&lt;/code&gt;, &lt;code&gt;
 append(CharSequence)&lt;/code&gt;, &lt;code&gt;append(CharSequence, int, int)&lt;/code&gt;, &lt;code&gt;flush()&lt;/code&gt;, &lt;code&gt;write(int)&lt;/code&gt;, &lt;code&gt;write(char[])&lt;/code&gt;, and &lt;code&gt;write(char[], int, int)&lt;/code&gt; methods do nothing. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">스트림이 열려있는 동안 &lt;code&gt;append(char)&lt;/code&gt; , &lt;code&gt; append(CharSequence)&lt;/code&gt; , &lt;code&gt;append(CharSequence, int, int)&lt;/code&gt; , &lt;code&gt;flush()&lt;/code&gt; , &lt;code&gt;write(int)&lt;/code&gt; , &lt;code&gt;write(char[])&lt;/code&gt; 및 &lt;code&gt;write(char[], int, int)&lt;/code&gt; 메서드는 아무것도하지 않습니다. 스트림이 닫힌 후 이러한 메서드는 모두 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="9f27c207d45817eb6f9a257c7c530eb9bfcf4665" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;available()&lt;/code&gt;, &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read(byte[])&lt;/code&gt;, &lt;code&gt;read(byte[], int, int)&lt;/code&gt;, &lt;code&gt;readAllBytes()&lt;/code&gt;, &lt;code&gt;readNBytes(byte[], int, int)&lt;/code&gt;, &lt;code&gt;readNBytes(int)&lt;/code&gt;, &lt;code&gt;skip(long)&lt;/code&gt;, and &lt;code&gt;transferTo()&lt;/code&gt; methods all behave as if end of stream has been reached. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">스트림이 열려있는 동안 &lt;code&gt;available()&lt;/code&gt; , &lt;code&gt;read()&lt;/code&gt; , &lt;code&gt;read(byte[])&lt;/code&gt; , &lt;code&gt;read(byte[], int, int)&lt;/code&gt; , &lt;code&gt;readAllBytes()&lt;/code&gt; , &lt;code&gt;readNBytes(byte[], int, int)&lt;/code&gt; , &lt;code&gt;readNBytes(int)&lt;/code&gt; , &lt;code&gt;skip(long)&lt;/code&gt; 및 &lt;code&gt;transferTo()&lt;/code&gt; 메서드는 모두 스트림의 끝에 도달 한 것처럼 동작합니다. 스트림이 닫힌 후 이러한 메서드는 모두 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="354a3e678c0afc6d9c995cad19836af2c60e94bf" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;read(char[])&lt;/code&gt;, &lt;code&gt;read(char[], int, int)&lt;/code&gt;, &lt;code&gt;read(Charbuffer)&lt;/code&gt;, &lt;code&gt;
 ready()&lt;/code&gt;, &lt;code&gt;skip(long)&lt;/code&gt;, and &lt;code&gt;transferTo()&lt;/code&gt; methods all behave as if end of stream has been reached. After the stream has been closed, these methods all throw &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">스트림이 열려있는 동안 &lt;code&gt;read()&lt;/code&gt; , &lt;code&gt;read(char[])&lt;/code&gt; , &lt;code&gt;read(char[], int, int)&lt;/code&gt; , &lt;code&gt;read(Charbuffer)&lt;/code&gt; , &lt;code&gt; ready()&lt;/code&gt; , &lt;code&gt;skip(long)&lt;/code&gt; 및 &lt;code&gt;transferTo()&lt;/code&gt; 메서드는 모두 작동합니다. 마치 스트림의 끝에 도달 한 것처럼. 스트림이 닫힌 후 이러한 메서드는 모두 &lt;code&gt;IOException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="38e5439eae991a55c97ddfd38870798ef229cbcd" translate="yes" xml:space="preserve">
          <source>While the stream is open, the &lt;code&gt;write(int)&lt;/code&gt;, &lt;code&gt;
 write(byte[])&lt;/code&gt;, and &lt;code&gt;write(byte[], int, int)&lt;/code&gt; methods do nothing. After the stream has been closed, these methods all throw &lt;code&gt;
 IOException&lt;/code&gt;.</source>
          <target state="translated">스트림이 열려있는 동안 &lt;code&gt;write(int)&lt;/code&gt; , &lt;code&gt; write(byte[])&lt;/code&gt; 및 &lt;code&gt;write(byte[], int, int)&lt;/code&gt; 메서드는 아무 작업도 수행하지 않습니다. 스트림이 닫힌 후 이러한 메서드는 모두 &lt;code&gt; IOException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="dc1904d24dfdb2dc325b56134c9dce9b4ddaba55" translate="yes" xml:space="preserve">
          <source>While the unit of time of the return value is milliseconds, the granularity of the value depends on the underlying file system and may be larger. For example, some file systems use time stamps in units of seconds.</source>
          <target state="translated">반환 값의 시간 단위는 밀리 초이지만 값의 단위는 기본 파일 시스템에 따라 다르며 더 클 수 있습니다. 예를 들어, 일부 파일 시스템은 초 단위로 타임 스탬프를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="71a236fbeded33e61e30714b2af91dd5dfd1beff" translate="yes" xml:space="preserve">
          <source>While this class has been part of swing for a while now, it is public as of 1.4.</source>
          <target state="translated">이 클래스는 한동안 스윙의 일부 였지만 1.4에서 공개되었습니다.</target>
        </trans-unit>
        <trans-unit id="6ebba50ef7f7692c7039eeb694af9a571417cf59" translate="yes" xml:space="preserve">
          <source>While this class inherits from &lt;a href=&quot;threadpoolexecutor&quot;&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/a&gt;, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using &lt;code&gt;corePoolSize&lt;/code&gt; threads and an unbounded queue, adjustments to &lt;code&gt;maximumPoolSize&lt;/code&gt; have no useful effect. Additionally, it is almost never a good idea to set &lt;code&gt;corePoolSize&lt;/code&gt; to zero or use &lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt; because this may leave the pool without threads to handle tasks once they become eligible to run.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;threadpoolexecutor&quot;&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; &lt;/a&gt; 로부터 상속 받지만 상속 된 튜닝 방법 중 일부는 유용하지 않습니다. 특히 &lt;code&gt;corePoolSize&lt;/code&gt; 스레드와 무제한 큐를 사용하여 고정 크기 풀 역할을하므로 &lt;code&gt;maximumPoolSize&lt;/code&gt; 를 조정 해도 아무런 효과가 없습니다. 또한 &lt;code&gt;corePoolSize&lt;/code&gt; 를 0 으로 설정 하거나 &lt;code&gt;allowCoreThreadTimeOut&lt;/code&gt; 을 사용 하는 것은 좋은 아이디어가 아닙니다. 스레드가없는 풀에서 작업을 실행할 수있게되면 작업을 처리 할 수 ​​있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="37f43590d9884fbad9cdec8f02f0705df36bced7" translate="yes" xml:space="preserve">
          <source>While this interface method is declared to throw &lt;code&gt;
 Exception&lt;/code&gt;, implementers are &lt;em&gt;strongly&lt;/em&gt; encouraged to declare concrete implementations of the &lt;code&gt;close&lt;/code&gt; method to throw more specific exceptions, or to throw no exception at all if the close operation cannot fail.</source>
          <target state="translated">이 인터페이스 메서드가 &lt;code&gt; Exception&lt;/code&gt; 을 throw하도록 선언되었지만 구현자는 보다 구체적인 예외를 throw하거나 닫기 작업이 실패 할 수없는 경우 예외를 전혀 throw하지 않도록 &lt;code&gt;close&lt;/code&gt; 메서드 의 구체적인 구현을 선언 &lt;em&gt;하는&lt;/em&gt; 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="1c294c7b4d4f86f3493751e198f59f458ef4183c" translate="yes" xml:space="preserve">
          <source>While this interface method is declared to throw &lt;code&gt;Exception&lt;/code&gt;, implementers are &lt;em&gt;strongly&lt;/em&gt; encouraged to declare concrete implementations of the &lt;code&gt;close&lt;/code&gt; method to throw more specific exceptions, or to throw no exception at all if the close operation cannot fail.</source>
          <target state="translated">이 인터페이스 메소드가 &lt;code&gt;Exception&lt;/code&gt; 을 발생 시키도록 선언되어 있지만 , 구현자는 &lt;code&gt;close&lt;/code&gt; 의 구체적인 구현을 선언 할 것을 &lt;em&gt;강력히&lt;/em&gt; 권장합니다. 더 구체적인 예외를 던져, 또는 가까운 작업이 실패 할 수없는 경우 전혀 예외를 던지지하는 방법.</target>
        </trans-unit>
        <trans-unit id="5aafec2ecc872a5e693872afd5344f871ab06e7e" translate="yes" xml:space="preserve">
          <source>While this is a public method, this is typically only useful for subclassers of &lt;code&gt;JFormattedTextField&lt;/code&gt;. &lt;code&gt;JFormattedTextField&lt;/code&gt; will invoke this method at the appropriate times when the value changes, or its internal state changes.</source>
          <target state="translated">이것은 공용 메서드이지만 일반적으로 &lt;code&gt;JFormattedTextField&lt;/code&gt; 의 서브 클래 서에게만 유용합니다 . &lt;code&gt;JFormattedTextField&lt;/code&gt; 는 값이 변경되거나 내부 상태가 변경 될 때 적절한 시간에이 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="79111a912067f71a2c429865902e2e2dfdb6357a" translate="yes" xml:space="preserve">
          <source>While this is a public method, this is typically only useful for subclassers of &lt;code&gt;JFormattedTextField&lt;/code&gt;. &lt;code&gt;JFormattedTextField&lt;/code&gt; will invoke this method at the appropriate times when the value changes, or its internal state changes. You will only need to invoke this yourself if you are subclassing &lt;code&gt;JFormattedTextField&lt;/code&gt; and installing/uninstalling &lt;code&gt;AbstractFormatter&lt;/code&gt; at a different time than &lt;code&gt;JFormattedTextField&lt;/code&gt; does.</source>
          <target state="translated">이것은 공용 메서드이지만 일반적으로 &lt;code&gt;JFormattedTextField&lt;/code&gt; 의 서브 클래 서에게만 유용합니다 . &lt;code&gt;JFormattedTextField&lt;/code&gt; 는 값이 변경되거나 내부 상태가 변경 될 때 적절한 시간에이 메소드를 호출합니다. 당신은 당신이 서브 클래스 화하는 경우이 직접 호출해야합니다 &lt;code&gt;JFormattedTextField&lt;/code&gt; 제거 / 및 설치 &lt;code&gt;AbstractFormatter&lt;/code&gt; 보다 다른 시간 &lt;code&gt;JFormattedTextField&lt;/code&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8962e33fe4ae692b6f0669c0b0060997d23406a" translate="yes" xml:space="preserve">
          <source>While this may seem a more roundabout way to perform an aggregation compared to simply mutating a running total in a loop, reduction operations parallelize more gracefully, without needing additional synchronization and with greatly reduced risk of data races.</source>
          <target state="translated">이는 루프에서 누계를 단순히 변경하는 것보다 집계를 수행하는 데있어 가장 간단한 방법으로 보일 수 있지만 추가 동기화가 필요하지 않고 데이터 경쟁의 위험이 크게 줄어드는 대신 축소 작업이보다 정교하게 병렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="a47a2652b0c502dd1c763501db1290a29367490b" translate="yes" xml:space="preserve">
          <source>While this method is public, it should only be invoked by the &lt;code&gt;UIManager&lt;/code&gt; when the look and feel is set as the current look and feel and after &lt;code&gt;initialize&lt;/code&gt; has been invoked.</source>
          <target state="translated">이 메서드는 공용이지만 &lt;code&gt;UIManager&lt;/code&gt; 이 현재 룩앤필로 설정되고 &lt;code&gt;initialize&lt;/code&gt; 가 호출 된 후 UIManager에 의해서만 호출되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c581298e75ef5bf15df9b06bf2c664ea73c5c346" translate="yes" xml:space="preserve">
          <source>While writing an object via writeUnshared does not in itself guarantee a unique reference to the object when it is deserialized, it allows a single object to be defined multiple times in a stream, so that multiple calls to readUnshared by the receiver will not conflict. Note that the rules described above only apply to the base-level object written with writeUnshared, and not to any transitively referenced sub-objects in the object graph to be serialized.</source>
          <target state="translated">writeUnshared를 통해 객체를 작성한다고해서 역 직렬화 될 때 객체에 대한 고유 한 참조가 보장되는 것은 아니지만 단일 객체를 스트림에서 여러 번 정의 할 수 있으므로 수신자가 readUnshared를 여러 번 호출해도 충돌하지 않습니다. 위에서 설명한 규칙은 writeUnshared로 작성된 기본 레벨 오브젝트에만 적용되며 직렬화 할 오브젝트 그래프의 전 이적으로 참조 된 하위 오브젝트에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5da2d68669a03b947051233558b6ce56e6780f0a" translate="yes" xml:space="preserve">
          <source>White_Space</source>
          <target state="translated">White_Space</target>
        </trans-unit>
        <trans-unit id="325016380fb9842b99430cbb0b7cb06becabcdfe" translate="yes" xml:space="preserve">
          <source>Whitespace is allowed on either side of ',', ';', '=', and '+'. Such whitespace is accepted but not generated by this code, and is ignored when comparing names.</source>
          <target state="translated">',', ';', '='및 '+'의 양쪽에 공백이 허용됩니다. 이러한 공백은 허용되지만이 코드에서 생성되지 않으며 이름을 비교할 때 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3ef5e18e6403c342fcf6ad4db4c278abb2cb9d38" translate="yes" xml:space="preserve">
          <source>Whitespace is not significant in the above regular expressions.</source>
          <target state="translated">위 정규 표현식에서 공백은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d620fb7a85a0616f4a4e6e9dda029e04472a323" translate="yes" xml:space="preserve">
          <source>Wide Area Information Server (WAIS) protocol.</source>
          <target state="translated">WAIS (Wide Area Information Server) 프로토콜.</target>
        </trans-unit>
        <trans-unit id="4088f5317f57ea6f119849410abea3f8143240d0" translate="yes" xml:space="preserve">
          <source>Widget for user to</source>
          <target state="translated">사용자를위한 위젯</target>
        </trans-unit>
        <trans-unit id="a58ddf50c5ea5c03802da919dd5953bbf82ebd74" translate="yes" xml:space="preserve">
          <source>Width</source>
          <target state="translated">Width</target>
        </trans-unit>
        <trans-unit id="969d00f2cb9efe3539d44d8c60c74f5ad9d4d231" translate="yes" xml:space="preserve">
          <source>Width in pixels of the region of image data that this SampleModel describes.</source>
          <target state="translated">이 SampleModel이 설명하는 이미지 데이터 영역의 너비 (픽셀)입니다.</target>
        </trans-unit>
        <trans-unit id="ad438ebb7fecc02d85771ba7a5e164704291d2aa" translate="yes" xml:space="preserve">
          <source>Width margin between each column</source>
          <target state="translated">각 열 사이의 너비 여백</target>
        </trans-unit>
        <trans-unit id="50794f4688ae96bdb4341321c3ffa61a405c19eb" translate="yes" xml:space="preserve">
          <source>Width of the back buffers</source>
          <target state="translated">백 버퍼의 너비</target>
        </trans-unit>
        <trans-unit id="9c249f6d47c523ac145af2ace67f2b7577b5b942" translate="yes" xml:space="preserve">
          <source>Width or height of the divider based on orientation &lt;code&gt;BasicSplitPaneUI&lt;/code&gt; adds two to this.</source>
          <target state="translated">방향에 따른 구분선의 너비 또는 높이 &lt;code&gt;BasicSplitPaneUI&lt;/code&gt; 는 여기에 2 개를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d5208bbe059aa1046c3f08361ea1e178ca24d291" translate="yes" xml:space="preserve">
          <source>WildcardType</source>
          <target state="translated">WildcardType</target>
        </trans-unit>
        <trans-unit id="66c44a9ca081e2d89075ec9d49d2689c74584a8a" translate="yes" xml:space="preserve">
          <source>WildcardType represents a wildcard type expression, such as &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;? extends Number&lt;/code&gt;, or &lt;code&gt;? super Integer&lt;/code&gt;.</source>
          <target state="translated">와일드 카드 유형은 &lt;code&gt;?&lt;/code&gt; 와 같은 와일드 카드 유형 표현식을 나타냅니다 . , &lt;code&gt;? extends Number&lt;/code&gt; 또는 &lt;code&gt;? super Integer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce867c4c796e6dbe1d3e38766feb789822009ee1" translate="yes" xml:space="preserve">
          <source>WildcardType.getExtendsBound()</source>
          <target state="translated">WildcardType.getExtendsBound()</target>
        </trans-unit>
        <trans-unit id="330bde92db69c2198109194787e6c21b7478f2c0" translate="yes" xml:space="preserve">
          <source>WildcardType.getLowerBounds()</source>
          <target state="translated">WildcardType.getLowerBounds()</target>
        </trans-unit>
        <trans-unit id="f81da7284909bf43711682454467244f68db18a0" translate="yes" xml:space="preserve">
          <source>WildcardType.getSuperBound()</source>
          <target state="translated">WildcardType.getSuperBound()</target>
        </trans-unit>
        <trans-unit id="97172c5abf520854245e039ae23bd4e64bc5422f" translate="yes" xml:space="preserve">
          <source>WildcardType.getUpperBounds()</source>
          <target state="translated">WildcardType.getUpperBounds()</target>
        </trans-unit>
        <trans-unit id="521d06dd779ba79ee4cea678dbe14d70dbe38387" translate="yes" xml:space="preserve">
          <source>Will be &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;java.awt.Image&lt;/code&gt; is not visible, the &lt;code&gt;java.desktop&lt;/code&gt; module is not loaded, or the &lt;code&gt;java.desktop&lt;/code&gt; module is not in the run-time image.</source>
          <target state="translated">수 있을까요 &lt;code&gt;null&lt;/code&gt; 의 경우 &lt;code&gt;java.awt.Image&lt;/code&gt; 의가 표시되지는 &lt;code&gt;java.desktop&lt;/code&gt; 의 모듈이 장착되지 않았거나 &lt;code&gt;java.desktop&lt;/code&gt; 의 모듈은 런타임 이미지에 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d33509e2ec308e6546857b8da6aba57cee35ab90" translate="yes" xml:space="preserve">
          <source>Will be called to see whether or not this cookie should be accepted.</source>
          <target state="translated">이 쿠키의 수락 여부를 확인하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="37fa7a262702fe582d3a1dccfa6ad0f9944b59d4" translate="yes" xml:space="preserve">
          <source>Will check the role according to its corresponding role definition provided in relation's relation type</source>
          <target state="translated">관계의 관계 유형에 제공된 해당 역할 정의에 따라 역할을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6ccf06bf2935ecc384eb6df2769fb29a28f7bd2b" translate="yes" xml:space="preserve">
          <source>Will not always find a match (or the correct match) if some part of the parse is ambiguous. For example, if the pattern &quot;{1},{2}&quot; is used with the string arguments {&quot;a,b&quot;, &quot;c&quot;}, it will format as &quot;a,b,c&quot;. When the result is parsed, it will return {&quot;a&quot;, &quot;b,c&quot;}.</source>
          <target state="translated">구문 분석의 일부가 모호한 경우 항상 일치하는 항목을 찾을 수 없습니다. 예를 들어, 패턴 &quot;{1}, {2}&quot;를 문자열 인수 { &quot;a, b&quot;, &quot;c&quot;}와 함께 사용하면 &quot;a, b, c&quot;로 형식화됩니다. 결과가 구문 분석되면 { &quot;a&quot;, &quot;b, c&quot;}가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c58deb92d1c5c729de051dba7b43a35ac3101b21" translate="yes" xml:space="preserve">
          <source>Will not see uncommitted data (make &quot;dirty&quot; reads).</source>
          <target state="translated">커밋되지 않은 데이터를 볼 수 없습니다 ( &quot;더티 읽기&quot;).</target>
        </trans-unit>
        <trans-unit id="d669a272be58163914a204bccea56c09fa69e531" translate="yes" xml:space="preserve">
          <source>Will send a notification (RelationNotification with type RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the relation is a MBean or not).</source>
          <target state="translated">알림을 보냅니다 (관계가 MBean인지 여부에 따라 RELATION_BASIC_UPDATE 또는 RELATION_MBEAN_UPDATE 유형의 관계 알림).</target>
        </trans-unit>
        <trans-unit id="c456f440fcf296338c58bf917ef98c5c5d7bac84" translate="yes" xml:space="preserve">
          <source>Will send one notification (RelationNotification with type RELATION_BASIC_UPDATE or RELATION_MBEAN_UPDATE, depending if the relation is a MBean or not) per updated role.</source>
          <target state="translated">업데이트 된 역할마다 하나의 알림 (관계가 MBean인지 여부에 따라 RELATION_BASIC_UPDATE 또는 RELATION_MBEAN_UPDATE 유형의 관계 알림)을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="af60309eed9f0f92d76603dc55ac020d8599207d" translate="yes" xml:space="preserve">
          <source>Will start editing for node if there is a &lt;code&gt;cellEditor&lt;/code&gt; and &lt;code&gt;shouldSelectCell&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cellEditor&lt;/code&gt; 가 있고 &lt;code&gt;shouldSelectCell&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 노드 편집을 시작 합니다 .</target>
        </trans-unit>
        <trans-unit id="c95d75c28c35065fc1c57b0e876887193f122021" translate="yes" xml:space="preserve">
          <source>WinListener</source>
          <target state="translated">WinListener</target>
        </trans-unit>
        <trans-unit id="41dfc0a6c92707948578891c51d98c6443be63cc" translate="yes" xml:space="preserve">
          <source>Window</source>
          <target state="translated">Window</target>
        </trans-unit>
        <trans-unit id="5084a061070a3f1aa4d1ecab3a00df323a3b610e" translate="yes" xml:space="preserve">
          <source>Window events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;</source>
          <target state="translated">창 이벤트는 &lt;code&gt;enableEvents&lt;/code&gt; 를 통해 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="652b21379200b4ccc460b4492fe0d5374614171a" translate="yes" xml:space="preserve">
          <source>Window focus events are enabled via &lt;code&gt;enableEvents&lt;/code&gt;</source>
          <target state="translated">창 초점 이벤트는 &lt;code&gt;enableEvents&lt;/code&gt; 를 통해 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="8ac26c71e069b6eaa7e969b40aec9f9b5620310d" translate="yes" xml:space="preserve">
          <source>Window.AccessibleAWTWindow</source>
          <target state="translated">Window.AccessibleAWTWindow</target>
        </trans-unit>
        <trans-unit id="507611730a02b402edd6e7ba76a6fcebba9f788e" translate="yes" xml:space="preserve">
          <source>Window.Type</source>
          <target state="translated">Window.Type</target>
        </trans-unit>
        <trans-unit id="5dca9b99152803aee06162ae5e180ed80d355a7c" translate="yes" xml:space="preserve">
          <source>WindowAdapter</source>
          <target state="translated">WindowAdapter</target>
        </trans-unit>
        <trans-unit id="d30877c43152fe36a3fd859538a40a5cdaf9bfe2" translate="yes" xml:space="preserve">
          <source>WindowConstants</source>
          <target state="translated">WindowConstants</target>
        </trans-unit>
        <trans-unit id="506bdfc6c0c9e73aacc009ccc59240f421dee55e" translate="yes" xml:space="preserve">
          <source>WindowEvent</source>
          <target state="translated">WindowEvent</target>
        </trans-unit>
        <trans-unit id="389aeec541bb01caf058a1c61a1a55c203773d3c" translate="yes" xml:space="preserve">
          <source>WindowFocusListener</source>
          <target state="translated">WindowFocusListener</target>
        </trans-unit>
        <trans-unit id="d1e4bbe2f756a9e07443c61cb2a25527b3f01627" translate="yes" xml:space="preserve">
          <source>WindowListener</source>
          <target state="translated">WindowListener</target>
        </trans-unit>
        <trans-unit id="36d800c05ccdf96a77f664405b24b1d515a7dcaa" translate="yes" xml:space="preserve">
          <source>WindowStateListener</source>
          <target state="translated">WindowStateListener</target>
        </trans-unit>
        <trans-unit id="a4ec586bd67aec6c5c53fd30fb990d116b2bc3ae" translate="yes" xml:space="preserve">
          <source>Windows are capable of generating the following WindowEvents: WindowOpened, WindowClosed, WindowGainedFocus, WindowLostFocus.</source>
          <target state="translated">Windows는 WindowOpened, WindowClosed, WindowGainedFocus, WindowLostFocus와 같은 WindowEvents를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e736d7e9cd07fdd5619eb22e9d6ea04daf0e51ae" translate="yes" xml:space="preserve">
          <source>Windows cannot overlap the full-screen window. All other application windows will always appear beneath the full-screen window in the Z-order.</source>
          <target state="translated">Windows는 전체 화면 창과 겹칠 수 없습니다. 다른 모든 응용 프로그램 창은 항상 Z 순서로 전체 화면 창 아래에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="593ac35fa2bd24a666d120e3789447fbf9c25e2a" translate="yes" xml:space="preserve">
          <source>WindowsNT/x86/4.0/lib/stat.dll</source>
          <target state="translated">WindowsNT/x86/4.0/lib/stat.dll</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="de916a95a394d60b5970c72c8e49b95595c376f5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SEPARATE_DOCUMENTS_UNCOLLATED_COPIES&lt;/code&gt; and &lt;code&gt;SEPARATE_DOCUMENTS_COLLATED_COPIES&lt;/code&gt;, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled separately.</source>
          <target state="translated">&lt;code&gt;SEPARATE_DOCUMENTS_UNCOLLATED_COPIES&lt;/code&gt; 및 &lt;code&gt;SEPARATE_DOCUMENTS_COLLATED_COPIES&lt;/code&gt; 를 사용하면 문서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 별도로 스테이플됩니다.</target>
        </trans-unit>
        <trans-unit id="ce065a2774362ea1c0b4b2a9c6d578002c87fa95" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SINGLE_DOCUMENT&lt;/code&gt;, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document with no regard to new sheets.</source>
          <target state="translated">&lt;code&gt;SINGLE_DOCUMENT&lt;/code&gt; 를 사용하면 문서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 새 시트에 관계없이 단일 문서로 함께 스테이플 링됩니다.</target>
        </trans-unit>
        <trans-unit id="000a0d000df5c6984649ddbd1ee6d53891ba7395" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SINGLE_DOCUMENT_NEW_SHEET&lt;/code&gt;, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document, but document &lt;code&gt;b&lt;/code&gt; starts on a new sheet.</source>
          <target state="translated">&lt;code&gt;SINGLE_DOCUMENT_NEW_SHEET&lt;/code&gt; 를 사용하면 문서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 단일 문서로 함께 스테이플 링되지만 문서 &lt;code&gt;b&lt;/code&gt; 는 새 시트에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="702bb02b91946be2e7d1e7c71af340e7112b4fc2" translate="yes" xml:space="preserve">
          <source>With SEPARATE_DOCUMENTS_UNCOLLATED_COPIES and SEPARATE_DOCUMENTS_COLLATED_COPIES, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled separately.</source>
          <target state="translated">SEPARATE_DOCUMENTS_UNCOLLATED_COPIES 및 SEPARATE_DOCUMENTS_COLLATED_COPIES를 사용하면 문서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 별도로 스테이플됩니다.</target>
        </trans-unit>
        <trans-unit id="c6940d372bef23c372a894b2611764845d087573" translate="yes" xml:space="preserve">
          <source>With SINGLE_DOCUMENT, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document with no regard to new sheets.</source>
          <target state="translated">SINGLE_DOCUMENT를 사용하면 문서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 새 시트에 관계없이 단일 문서로 스테이플됩니다.</target>
        </trans-unit>
        <trans-unit id="6aea5edd4595a1343229324f4788e3637ab7593b" translate="yes" xml:space="preserve">
          <source>With SINGLE_DOCUMENT_NEW_SHEET, documents &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are stapled together as a single document, but document &lt;code&gt;b&lt;/code&gt; starts on a new sheet.</source>
          <target state="translated">SINGLE_DOCUMENT_NEW_SHEET을 사용하면 문서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 단일 문서로 스테이플되지만 문서 &lt;code&gt;b&lt;/code&gt; 는 새 시트에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="7a7f0a9b6a27b5ea272b2faa2111b50312da5684" translate="yes" xml:space="preserve">
          <source>With Version 0 cookies, values should not contain white space, brackets, parentheses, equals signs, commas, double quotes, slashes, question marks, at signs, colons, and semicolons. Empty values may not behave the same way on all browsers.</source>
          <target state="translated">버전 0 쿠키의 경우 값에는 공백, 대괄호, 괄호, 등호, 쉼표, 큰 따옴표, 슬래시, 물음표, 부호, 콜론 및 세미콜론이 포함되지 않아야합니다. 빈 값은 모든 브라우저에서 동일한 방식으로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf66f17ae2780078f9fea48695737926c268f057" translate="yes" xml:space="preserve">
          <source>With a PermissionCollection, you can:</source>
          <target state="translated">PermissionCollection을 사용하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddf292b706b0ea961ebe157c83d2d5ff0fdfda77" translate="yes" xml:space="preserve">
          <source>With a reference to the &lt;code&gt;&amp;lt;widget&amp;gt;&lt;/code&gt; element, a relative XPath expression can be written to select the &lt;code&gt;&amp;lt;manufacturer&amp;gt;&lt;/code&gt; child element:</source>
          <target state="translated">&lt;code&gt;&amp;lt;widget&amp;gt;&lt;/code&gt; 요소에 대한 참조를 사용 하여 &lt;code&gt;&amp;lt;manufacturer&amp;gt;&lt;/code&gt; 하위 요소 를 선택하기 위해 상대 XPath 표현식을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7921a6a2bd87af6e70cb7478096f1f706c0eed48" translate="yes" xml:space="preserve">
          <source>With attribute type synonyms, a directory can assign multiple names to the same attribute. For example, &quot;cn&quot; and &quot;commonName&quot; might both refer to the same attribute. Asking for &quot;cn&quot; might return the &quot;commonName&quot; attribute.</source>
          <target state="translated">속성 유형 동의어를 사용하면 디렉토리는 동일한 속성에 여러 이름을 지정할 수 있습니다. 예를 들어 &quot;cn&quot;과 &quot;commonName&quot;은 모두 동일한 속성을 참조 할 수 있습니다. &quot;cn&quot;을 요청하면 &quot;commonName&quot;속성이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="342174bb35309e577ba49df9b6a0136aab3a5327" translate="yes" xml:space="preserve">
          <source>With both intervals and &lt;code&gt;Spring&lt;/code&gt;s we can define &quot;-&quot; and &lt;em&gt;min&lt;/em&gt; in terms of negation:</source>
          <target state="translated">간격과 &lt;code&gt;Spring&lt;/code&gt; 모두 부정의 관점에서 &quot;-&quot;와 &lt;em&gt;min&lt;/em&gt; 을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b146947ce59686776207df75fa9d667325f9863" translate="yes" xml:space="preserve">
          <source>With most look and feels, the user can drag out a tool bar into a separate window (unless the &lt;code&gt;floatable&lt;/code&gt; property is set to &lt;code&gt;false&lt;/code&gt;). For drag-out to work correctly, it is recommended that you add &lt;code&gt;JToolBar&lt;/code&gt; instances to one of the four &quot;sides&quot; of a container whose layout manager is a &lt;code&gt;BorderLayout&lt;/code&gt;, and do not add children to any of the other four &quot;sides&quot;.</source>
          <target state="translated">대부분의 룩앤필에서 사용자는 도구 모음을 별도의 창으로 드래그 할 수 있습니다 ( &lt;code&gt;floatable&lt;/code&gt; 속성이 &lt;code&gt;false&lt;/code&gt; 로 설정 되지 않은 경우 ). 드래그 아웃이 제대로 작동하려면 레이아웃 관리자가 &lt;code&gt;BorderLayout&lt;/code&gt; 인 컨테이너의 네 &quot;측면&quot;중 하나에 &lt;code&gt;JToolBar&lt;/code&gt; 인스턴스를 추가하고 다른 네 &quot;측면&quot;에 자식을 추가하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0aee19fea36c937253e601d256a319bb86142c5d" translate="yes" xml:space="preserve">
          <source>With some complex reduction operations, for example a &lt;code&gt;collect()&lt;/code&gt; that produces a &lt;code&gt;Map&lt;/code&gt;, such as:</source>
          <target state="translated">복잡한 축소 작업 &lt;code&gt;collect()&lt;/code&gt; 예 : 다음과 같이 &lt;code&gt;Map&lt;/code&gt; 을 생성하는 collect () 등)</target>
        </trans-unit>
        <trans-unit id="5e5f811ed587d929e889b7d29ba9d4370ee0e985" translate="yes" xml:space="preserve">
          <source>With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled.</source>
          <target state="translated">위 코드를 사용하면 로그 수준 FINER가 비활성화 된 경우에도 상태가 불필요하게 수집됩니다. 아래와 같이 공급 업체 승인 버전을 사용하면 로그 수준 FINER가 활성화 된 경우에만 상태가 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="dc2156a4e2b3c1c33c618ec6f586c7ea7f4199d8" translate="yes" xml:space="preserve">
          <source>With the exception of re-imaging an entire document for multiple collated copies, the increasing page index order means that when page N is requested if a client needs to calculate page break position, it may safely discard any state related to pages &amp;lt; N, and make current that for page N. &quot;State&quot; usually is just the calculated position in the document that corresponds to the start of the page.</source>
          <target state="translated">한 부씩 인쇄 된 여러 복사본에 대해 전체 문서를 다시 이미지화하는 것을 제외하고 페이지 색인 순서가 증가한다는 것은 클라이언트가 페이지 나누기 위치를 계산해야하는 경우 페이지 N이 요청 될 때 &amp;lt;N 페이지와 관련된 모든 상태를 안전하게 버릴 수 있음을 의미합니다. 페이지 N에 대해 현재 상태로 만듭니다. &quot;상태&quot;는 일반적으로 페이지의 시작에 해당하는 문서에서 계산 된 위치입니다.</target>
        </trans-unit>
        <trans-unit id="2024497e2bf2f02b354dda9dd14a083e17ac2ff2" translate="yes" xml:space="preserve">
          <source>With the exception of selected printer, the PrinterJob state is not updated to reflect the user's changes. For the selections to affect a printer job, the attributes must be specified in the call to the &lt;code&gt;print(PrintRequestAttributeSet)&lt;/code&gt; method. If using the Pageable interface, clients which intend to use media selected by the user must create a PageFormat derived from the user's selections. If the user cancels the dialog, the attributes will not reflect any changes made by the user.</source>
          <target state="translated">선택한 프린터를 제외하고는 PrinterJob 상태가 사용자의 변경 사항을 반영하도록 업데이트되지 않습니다. 선택 사항이 프린터 작업에 영향을 미치려면 &lt;code&gt;print(PrintRequestAttributeSet)&lt;/code&gt; 메서드 에 대한 호출에서 속성을 지정해야합니다 . Pageable 인터페이스를 사용하는 경우 사용자가 선택한 미디어를 사용하려는 클라이언트는 사용자의 선택에서 파생 된 PageFormat을 만들어야합니다. 사용자가 대화 상자를 취소하면 속성은 사용자가 변경 한 사항을 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e344a6ab10b8325512c520c0690b8d3e445352c1" translate="yes" xml:space="preserve">
          <source>With the following HTML content:</source>
          <target state="translated">With the following HTML content:</target>
        </trans-unit>
        <trans-unit id="618b01eeb003ee4b1ffdf3f6106417f6de534070" translate="yes" xml:space="preserve">
          <source>With the information retrieved from the methods &lt;code&gt;getStatus&lt;/code&gt; and &lt;code&gt;getConflictValue&lt;/code&gt;, the application may make a determination as to which value should be persisted in the data source. The application then calls the &lt;code&gt;SyncResolver&lt;/code&gt; method &lt;code&gt;setResolvedValue&lt;/code&gt;, which sets the value to be persisted in the &lt;code&gt;RowSet&lt;/code&gt; object and also in the data source.</source>
          <target state="translated">With the information retrieved from the methods &lt;code&gt;getStatus&lt;/code&gt; and &lt;code&gt;getConflictValue&lt;/code&gt; , the application may make a determination as to which value should be persisted in the data source. The application then calls the &lt;code&gt;SyncResolver&lt;/code&gt; method &lt;code&gt;setResolvedValue&lt;/code&gt; , which sets the value to be persisted in the &lt;code&gt;RowSet&lt;/code&gt; object and also in the data source.</target>
        </trans-unit>
        <trans-unit id="e8ff6037d8867d2b3d47892d80515cedec13ebae" translate="yes" xml:space="preserve">
          <source>With this increased flexibility comes additional responsibility. The absence of block-structured locking removes the automatic release of locks that occurs with &lt;code&gt;synchronized&lt;/code&gt; methods and statements. In most cases, the following idiom should be used:</source>
          <target state="translated">이러한 유연성으로 인해 추가 책임이 따릅니다. 블록 구조 잠금이 없으면 &lt;code&gt;synchronized&lt;/code&gt; 메소드 및 명령문에서 발생하는 자동 잠금 해제가 제거됩니다 . 대부분의 경우 다음 관용구를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3c389bbd15c03f9dd881098991d518ed6f3894d" translate="yes" xml:space="preserve">
          <source>Within a</source>
          <target state="translated">이내에</target>
        </trans-unit>
        <trans-unit id="eaa46bf4774a02d445fea7fa33dbb744f6506eaa" translate="yes" xml:space="preserve">
          <source>Within a &lt;code&gt;Document&lt;/code&gt;, &lt;code&gt;DocumentFragment&lt;/code&gt;, or &lt;code&gt;Entity&lt;/code&gt; being serialized, &lt;code&gt;Nodes&lt;/code&gt; are processed as follows</source>
          <target state="translated">Within a &lt;code&gt;Document&lt;/code&gt; , &lt;code&gt;DocumentFragment&lt;/code&gt; , or &lt;code&gt;Entity&lt;/code&gt; being serialized, &lt;code&gt;Nodes&lt;/code&gt; are processed as follows</target>
        </trans-unit>
        <trans-unit id="0d2a1649d264fff3b41ff1e86e92590c9426695c" translate="yes" xml:space="preserve">
          <source>Within a bracket expression the &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt; characters match themselves. The (&lt;code&gt;-&lt;/code&gt;) character matches itself if it is the first character within the brackets, or the first character after the &lt;code&gt;!&lt;/code&gt; if negating.</source>
          <target state="translated">브라켓 표현식 내에서 &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; 및 &lt;code&gt;\&lt;/code&gt; 문자가 일치합니다. ( &lt;code&gt;-&lt;/code&gt; ) 문자는 대괄호 안의 첫 번째 문자이거나 &lt;code&gt;!&lt;/code&gt; 다음의 첫 번째 문자 인 경우 자체와 일치합니다 . 부정하면.</target>
        </trans-unit>
        <trans-unit id="83d916c5bbfc33ee16ea209e9686d45596a9c2ac" translate="yes" xml:space="preserve">
          <source>Within each &lt;code&gt;ClassLoader&lt;/code&gt; instance all classes from the same java package have the same Package object. The static methods allow a package to be found by name or the set of all packages known to the current class loader to be found.</source>
          <target state="translated">각 &lt;code&gt;ClassLoader&lt;/code&gt; 내 인스턴스 에서 동일한 Java 패키지의 모든 클래스는 동일한 Package 객체를 갖습니다. 정적 메소드를 사용하면 이름으로 패키지를 찾거나 현재 클래스 로더에 알려진 모든 패키지 세트를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0668371fa9b725d274f510f8d695c661c8f6c217" translate="yes" xml:space="preserve">
          <source>Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same VM signature (return type, name, parameter types). M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if:</source>
          <target state="translated">Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same VM signature (return type, name, parameter types). M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if:</target>
        </trans-unit>
        <trans-unit id="ed5391ea4c2aede0070693a361a2994f5e4a6a05" translate="yes" xml:space="preserve">
          <source>Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same signature and return type. M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if:</source>
          <target state="translated">Within each such subset only the most specific methods are selected. Let method M be a method from a set of methods with same signature and return type. M is most specific if there is no such method N != M from the same set, such that N is more specific than M. N is more specific than M if:</target>
        </trans-unit>
        <trans-unit id="8f444b6815c4d0578f6ec1b24cacc82f1de3a985" translate="yes" xml:space="preserve">
          <source>Within markup, but outside of attributes, any occurrence of a character that cannot be represented in the output character encoding is reported as a &lt;code&gt;DOMError&lt;/code&gt; fatal error. An example would be serializing the element &amp;lt;LaCa&amp;ntilde;ada/&amp;gt; with &lt;code&gt;encoding=&quot;us-ascii&quot;&lt;/code&gt;. This will result with a generation of a &lt;code&gt;DOMError&lt;/code&gt; &quot;wf-invalid-character-in-node-name&quot; (as proposed in &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-well-formed&quot;&gt;well-formed&lt;/a&gt;&quot;).</source>
          <target state="translated">Within markup, but outside of attributes, any occurrence of a character that cannot be represented in the output character encoding is reported as a &lt;code&gt;DOMError&lt;/code&gt; fatal error. An example would be serializing the element &amp;lt;LaCa&amp;ntilde;ada/&amp;gt; with &lt;code&gt;encoding=&quot;us-ascii&quot;&lt;/code&gt; . This will result with a generation of a &lt;code&gt;DOMError&lt;/code&gt; &quot;wf-invalid-character-in-node-name&quot; (as proposed in &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-well-formed&quot;&gt;well-formed&lt;/a&gt;&quot;).</target>
        </trans-unit>
        <trans-unit id="e65be46b0d82a65208f681b65c6b6af3ea153929" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;activate&lt;/code&gt; method, a controller obtains initial values by querying the &lt;code&gt;IIOMetadata&lt;/code&gt; object's settings, either using the XML DOM tree or a plug-in specific interface, modifies values by whatever means, then modifies the &lt;code&gt;IIOMetadata&lt;/code&gt; object's settings, using either the &lt;code&gt;setFromTree&lt;/code&gt; or &lt;code&gt;mergeTree&lt;/code&gt; methods, or a plug-in specific interface. In general, applications may expect that when the &lt;code&gt;activate&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;IIOMetadata&lt;/code&gt; object is ready for use in a write operation.</source>
          <target state="translated">&lt;code&gt;activate&lt;/code&gt; 메소드 내에서 컨트롤러는 XML DOM 트리 또는 플러그인 특정 인터페이스를 사용하여 &lt;code&gt;IIOMetadata&lt;/code&gt; 오브젝트의 설정 을 조회하여 초기 값을 가져오고 어떤 방법 으로든 값을 수정 한 다음 &lt;code&gt;setFromTree&lt;/code&gt; 또는 &lt;code&gt;mergeTree&lt;/code&gt; 를 사용하여 &lt;code&gt;IIOMetadata&lt;/code&gt; 오브젝트의 설정 을 수정합니다. 메소드 또는 플러그인 특정 인터페이스. 일반적으로 애플리케이션은 &lt;code&gt;activate&lt;/code&gt; 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 &lt;code&gt;IIOMetadata&lt;/code&gt; 오브젝트가 쓰기 조작에 사용할 준비 가 된 것으로 예상 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83029e44e09a5ba0623249885430579f4267be4f" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;activate&lt;/code&gt; method, a controller obtains initial values by querying the &lt;code&gt;IIOParam&lt;/code&gt; object's &lt;code&gt;get&lt;/code&gt; methods, modifies values by whatever means, then invokes the &lt;code&gt;IIOParam&lt;/code&gt; object's &lt;code&gt;set&lt;/code&gt; methods to modify the appropriate settings. Normally, these &lt;code&gt;set&lt;/code&gt; methods will be invoked all at once at a final commit in order that a cancel operation not disturb existing values. In general, applications may expect that when the &lt;code&gt;activate&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;IIOParam&lt;/code&gt; object is ready for use in a read or write operation.</source>
          <target state="translated">&lt;code&gt;activate&lt;/code&gt; 메소드 내에서 제어기는 &lt;code&gt;IIOParam&lt;/code&gt; 오브젝트의 &lt;code&gt;get&lt;/code&gt; 메소드 를 조회하여 초기 값을 확보 하고 어떤 방법 으로든 값을 수정 한 다음 &lt;code&gt;IIOParam&lt;/code&gt; 오브젝트의 &lt;code&gt;set&lt;/code&gt; 메소드를 호출 하여 적절한 설정을 수정합니다. 일반적으로 이러한 &lt;code&gt;set&lt;/code&gt; 메소드는 최종 커밋시 한 번에 모두 호출되어 취소 작업이 기존 값을 방해하지 않습니다. 일반적으로 애플리케이션은 &lt;code&gt;activate&lt;/code&gt; 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 &lt;code&gt;IIOParam&lt;/code&gt; 오브젝트가 읽기 또는 쓰기 조작에 사용할 준비 가 된 것으로 예상 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76c301b37038720275724c001f96646390680990" translate="yes" xml:space="preserve">
          <source>Within the character data of a document (outside of markup), any characters that cannot be represented directly are replaced with character references. Occurrences of '&amp;lt;' and '&amp;amp;' are replaced by the predefined entities &amp;amp;lt; and &amp;amp;amp;. The other predefined entities (&amp;amp;gt;, &amp;amp;apos;, and &amp;amp;quot;) might not be used, except where needed (e.g. using &amp;amp;gt; in cases such as ']]&amp;gt;'). Any characters that cannot be represented directly in the output character encoding are serialized as numeric character references (and since character encoding standards commonly use hexadecimal representations of characters, using the hexadecimal representation when serializing character references is encouraged).</source>
          <target state="translated">Within the character data of a document (outside of markup), any characters that cannot be represented directly are replaced with character references. Occurrences of '&amp;lt;' and '&amp;amp;' are replaced by the predefined entities &amp;amp;lt; and &amp;amp;amp;. The other predefined entities (&amp;amp;gt;, &amp;amp;apos;, and &amp;amp;quot;) might not be used, except where needed (e.g. using &amp;amp;gt; in cases such as ']]&amp;gt;'). Any characters that cannot be represented directly in the output character encoding are serialized as numeric character references (and since character encoding standards commonly use hexadecimal representations of characters, using the hexadecimal representation when serializing character references is encouraged).</target>
        </trans-unit>
        <trans-unit id="1759a0ebe8a5e5c04ff2fdb42ee3e41043aa418f" translate="yes" xml:space="preserve">
          <source>Without anchoring bounds, the boundaries of this matcher's region will not match anchors such as ^ and $.</source>
          <target state="translated">앵커 경계가 없으면이 매처 영역의 경계는 ^ 및 $와 같은 앵커와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d683f7eface7d10e82e3f102080ec5410bd6835c" translate="yes" xml:space="preserve">
          <source>Without this warning, an applet may pop up windows without the user knowing that they belong to an applet. Since users may make security-sensitive decisions based on whether or not the window belongs to an applet (entering a username and password into a dialog box, for example), disabling this warning banner may allow applets to trick the user into entering such information.</source>
          <target state="translated">Without this warning, an applet may pop up windows without the user knowing that they belong to an applet. Since users may make security-sensitive decisions based on whether or not the window belongs to an applet (entering a username and password into a dialog box, for example), disabling this warning banner may allow applets to trick the user into entering such information.</target>
        </trans-unit>
        <trans-unit id="6fd52a68c735f034b00232a476c8c2e710db36a9" translate="yes" xml:space="preserve">
          <source>Word boundary analysis is used by search and replace functions, as well as within text editing applications that allow the user to select words with a double click. Word selection provides correct interpretation of punctuation marks within and following words. Characters that are not part of a word, such as symbols or punctuation marks, have word-breaks on both sides.</source>
          <target state="translated">단어 경계 분석은 검색 및 바꾸기 기능과 사용자가 더블 클릭으로 단어를 선택할 수있는 텍스트 편집 응용 프로그램에서 사용됩니다. 단어 선택은 단어 내 및 뒤에 나오는 문장 부호를 올바르게 해석합니다. 기호 또는 문장 부호와 같이 단어에 포함되지 않은 문자는 양쪽에 단어 구분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="99edd8c8e615e373739d2cdd38a8942b8a573113" translate="yes" xml:space="preserve">
          <source>Worker</source>
          <target state="translated">Worker</target>
        </trans-unit>
        <trans-unit id="6e99a8e4272c2db9e95f06a1f314a0f285a61837" translate="yes" xml:space="preserve">
          <source>Would result in the string '123-____'. If &lt;code&gt;setPlaceholder(&quot;555-1212&quot;)&lt;/code&gt; was invoked '123-1212' would result. The placeholder String is only used on the initial format, on subsequent formats only the placeholder character will be used.</source>
          <target state="translated">Would result in the string '123-____'. If &lt;code&gt;setPlaceholder(&quot;555-1212&quot;)&lt;/code&gt; was invoked '123-1212' would result. The placeholder String is only used on the initial format, on subsequent formats only the placeholder character will be used.</target>
        </trans-unit>
        <trans-unit id="642d596b44e19ab47c9e267aa3cf4a6030e0380b" translate="yes" xml:space="preserve">
          <source>Wrap a key.</source>
          <target state="translated">열쇠를 감싼다.</target>
        </trans-unit>
        <trans-unit id="3bcf468a4c3b40978bdee293e80fc65249f9482b" translate="yes" xml:space="preserve">
          <source>Wrap an existing exception in a SAXParseException.</source>
          <target state="translated">Wrap an existing exception in a SAXParseException.</target>
        </trans-unit>
        <trans-unit id="b0b650cb303bad45cc633704145a571455dd7664" translate="yes" xml:space="preserve">
          <source>Wrap an existing exception in a TransformerConfigurationException.</source>
          <target state="translated">Wrap an existing exception in a TransformerConfigurationException.</target>
        </trans-unit>
        <trans-unit id="9b39d6715671bdb2580af79800238414d13f1fd7" translate="yes" xml:space="preserve">
          <source>Wrap an existing exception in a TransformerException.</source>
          <target state="translated">Wrap an existing exception in a TransformerException.</target>
        </trans-unit>
        <trans-unit id="0c3ecd9442f9e1b1059ee6690619be457c11839a" translate="yes" xml:space="preserve">
          <source>Wrapped value (&lt;code&gt;Integer.valueOf(5)&lt;/code&gt;, &lt;code&gt;Boolean.FALSE&lt;/code&gt;, etc)</source>
          <target state="translated">랩핑 된 값 ( &lt;code&gt;Integer.valueOf(5)&lt;/code&gt; , &lt;code&gt;Boolean.FALSE&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="adbbb2fc6c4f8e1a93cb3431a12402bc3b7237ec" translate="yes" xml:space="preserve">
          <source>WrappedPlainView</source>
          <target state="translated">WrappedPlainView</target>
        </trans-unit>
        <trans-unit id="a9ebad9ce612c251b607a54c6d2d4842c89b63b2" translate="yes" xml:space="preserve">
          <source>Wrapper</source>
          <target state="translated">Wrapper</target>
        </trans-unit>
        <trans-unit id="2dbad62d494925b0cc5a9b12acb2cba9f5175ae5" translate="yes" xml:space="preserve">
          <source>Wrapper for primitive graphics calls.</source>
          <target state="translated">Wrapper for primitive graphics calls.</target>
        </trans-unit>
        <trans-unit id="92704fc2036355b575a4c4fbf65bd7b09813a44e" translate="yes" xml:space="preserve">
          <source>Wrapping the attribute value into an Annotation object guarantees that adjacent text runs don't get merged even if the attribute values are equal, and indicates to text containers that the attribute should be discarded if the underlying text is modified.</source>
          <target state="translated">속성 값을 Annotation 객체로 래핑하면 속성 값이 같더라도 인접한 텍스트 실행이 병합되지 않으며 기본 텍스트가 수정되면 속성을 버려야한다는 텍스트 컨테이너를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cca5fcd7b5b7c14fbea5ee4fc3296a93d35e1da8" translate="yes" xml:space="preserve">
          <source>Wraps a byte array into a buffer.</source>
          <target state="translated">바이트 배열을 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="3e43b98c51021b6537868fda39974c26611122c5" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the client.</source>
          <target state="translated">Wraps a byte array to be sent to the client.</target>
        </trans-unit>
        <trans-unit id="64cfb840ede8be7ea7901c7dfd0a6e52d56476fa" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the client. This method can be called only after the authentication exchange has completed (i.e., when &lt;code&gt;isComplete()&lt;/code&gt; returns true) and only if the authentication exchange has negotiated integrity and/or privacy as the quality of protection; otherwise, a &lt;code&gt;SaslException&lt;/code&gt; is thrown.</source>
          <target state="translated">클라이언트에 보낼 바이트 배열을 래핑합니다. 이 메소드는 인증 교환이 완료된 후 (즉, &lt;code&gt;isComplete()&lt;/code&gt; 가 true를 리턴 할 때 ) 인증 교환이 무결성 및 / 또는 프라이버시를 보호 품질로 협상 한 경우 에만 호출 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;SaslException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b1be73d2494fd5ecf63ee8bc9278f31e2926d14e" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the server.</source>
          <target state="translated">Wraps a byte array to be sent to the server.</target>
        </trans-unit>
        <trans-unit id="c58ede29ff7ee729e1131d3a1d2647f530332ea4" translate="yes" xml:space="preserve">
          <source>Wraps a byte array to be sent to the server. This method can be called only after the authentication exchange has completed (i.e., when &lt;code&gt;isComplete()&lt;/code&gt; returns true) and only if the authentication exchange has negotiated integrity and/or privacy as the quality of protection; otherwise, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">서버로 보낼 바이트 배열을 래핑합니다. 이 메소드는 인증 교환이 완료된 후 (즉, &lt;code&gt;isComplete()&lt;/code&gt; 가 true를 리턴 할 때 ) 인증 교환이 무결성 및 / 또는 프라이버시를 보호 품질로 협상 한 경우 에만 호출 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="67b1374ef549a7e954a05b9ec7009fb8bc41734f" translate="yes" xml:space="preserve">
          <source>Wraps a char array into a buffer.</source>
          <target state="translated">char 배열을 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="f7b95771a9ecdaf8c4f0c45b0a3050463bc0fb11" translate="yes" xml:space="preserve">
          <source>Wraps a character sequence into a buffer.</source>
          <target state="translated">문자 순서를 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="9cf8f103948e6b6d2a2e2dcbd8e83ddda5dcdf8e" translate="yes" xml:space="preserve">
          <source>Wraps a double array into a buffer.</source>
          <target state="translated">더블 배열을 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="7c38a95681b8bf75718f777dc7681e478936ebe7" translate="yes" xml:space="preserve">
          <source>Wraps a float array into a buffer.</source>
          <target state="translated">float 배열을 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="e875d8d4d7f1a26ef5338640a04b767dbb14b0fd" translate="yes" xml:space="preserve">
          <source>Wraps a long array into a buffer.</source>
          <target state="translated">긴 배열을 버퍼에 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="7a45b9eefe39a4cdc4f096f2050c4639eeae92e4" translate="yes" xml:space="preserve">
          <source>Wraps a short array into a buffer.</source>
          <target state="translated">짧은 배열을 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="35438f1499f1a894d95345e3941ad2b29de6319a" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; if the MBeanInfo passed in parameter is null.</source>
          <target state="translated">Wraps an &lt;a href=&quot;../../../../java.base/java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; if the MBeanInfo passed in parameter is null.</target>
        </trans-unit>
        <trans-unit id="c1d32f710973f4fd61bdd696efd70daf69bd5b7d" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt; if the ModelMBean is currently registered in the MBeanServer.</source>
          <target state="translated">Wraps an &lt;a href=&quot;../../../../java.base/java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; &lt;/a&gt; if the ModelMBean is currently registered in the MBeanServer.</target>
        </trans-unit>
        <trans-unit id="526e84458ea6e6f011221fcab33932da84f5ba1d" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; if the MBeanInfo passed in parameter is null.</source>
          <target state="translated">매개 변수로 전달 된 MBeanInfo가 null 인 경우 &lt;a href=&quot;../../../java/lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을&lt;/a&gt; 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="5b976fffcdb3184f30e314babf43e006ea0f5ad5" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt;&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/a&gt; if the ModelMBean is currently registered in the MBeanServer.</source>
          <target state="translated">ModelMBean이 현재 MBeanServer에 등록되어있는 경우 &lt;a href=&quot;../../../java/lang/illegalstateexception&quot;&gt; &lt;code&gt;IllegalStateException&lt;/code&gt; 을&lt;/a&gt; 랩합니다 .</target>
        </trans-unit>
        <trans-unit id="0edf81e480b4a49c11c2dbafe5b84b7869d1aa13" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; with an unchecked exception.</source>
          <target state="translated">확인되지 않은 예외 로 &lt;a href=&quot;ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt; 을 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="6afb0fee856f2866c314288124d5fc7949a1696a" translate="yes" xml:space="preserve">
          <source>Wraps an int array into a buffer.</source>
          <target state="translated">int 배열을 버퍼에 랩합니다.</target>
        </trans-unit>
        <trans-unit id="f46c77a2dce440c1be651d2cef94b153c69cfdb1" translate="yes" xml:space="preserve">
          <source>Wraps an output stream for encoding byte data using the &lt;a href=&quot;base64&quot;&gt;&lt;code&gt;Base64&lt;/code&gt;&lt;/a&gt; encoding scheme.</source>
          <target state="translated">&lt;a href=&quot;base64&quot;&gt; &lt;code&gt;Base64&lt;/code&gt; &lt;/a&gt; 인코딩 체계를 사용하여 바이트 데이터를 인코딩하기위한 출력 스트림을 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="12b5eee30743d96f3a2465542a9df99878df7b23" translate="yes" xml:space="preserve">
          <source>Wraps exceptions thrown by the preRegister(), preDeregister() methods of the &lt;code&gt;MBeanRegistration&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;MBeanRegistration&lt;/code&gt; 인터페이스 의 preRegister (), preDeregister () 메소드에 의해 발생한 예외를 랩 합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
