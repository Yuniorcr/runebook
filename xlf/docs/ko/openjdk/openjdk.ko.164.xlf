<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="f4fab39cd8224c3b1514a8f32e67ab83b0c8eab2" translate="yes" xml:space="preserve">
          <source>The management interface for a memory pool.</source>
          <target state="translated">메모리 풀의 관리 인터페이스</target>
        </trans-unit>
        <trans-unit id="7a14f43b2f6f8cac13a2fed4f0e0a1d632571b59" translate="yes" xml:space="preserve">
          <source>The management interface for a memory pool. A memory pool represents the memory resource managed by the Java virtual machine and is managed by one or more &lt;a href=&quot;memorymanagermxbean&quot;&gt;&lt;code&gt;memory managers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 풀의 관리 인터페이스 메모리 풀은 Java 가상 머신이 관리하는 메모리 자원을 나타내며 하나 이상의 &lt;a href=&quot;memorymanagermxbean&quot;&gt; &lt;code&gt;memory managers&lt;/code&gt; &lt;/a&gt; 가 관리 합니다 .</target>
        </trans-unit>
        <trans-unit id="5b17a1c4f6bda60b169887ec3464b73178c40c53" translate="yes" xml:space="preserve">
          <source>The management interface for the &lt;a href=&quot;../../../../java.logging/java/util/logging/package-summary&quot;&gt;logging&lt;/a&gt; facility.</source>
          <target state="translated">The management interface for the &lt;a href=&quot;../../../../java.logging/java/util/logging/package-summary&quot;&gt;logging&lt;/a&gt; facility.</target>
        </trans-unit>
        <trans-unit id="45ce2f8d545e61efecccb099b6f99b2e77692328" translate="yes" xml:space="preserve">
          <source>The management interface for the &lt;a href=&quot;../../util/logging/package-summary&quot;&gt;logging&lt;/a&gt; facility.</source>
          <target state="translated">&lt;a href=&quot;../../util/logging/package-summary&quot;&gt;로깅&lt;/a&gt; 기능을 위한 관리 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="e5da84562122ccb1a4b9947a79eb4868f2181d64" translate="yes" xml:space="preserve">
          <source>The management interface for the class loading system of the Java virtual machine.</source>
          <target state="translated">Java 가상 머신의 클래스로드 시스템의 관리 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8a6fb7cb11948cb467a53e0c5155033baa489d24" translate="yes" xml:space="preserve">
          <source>The management interface for the compilation system of the Java virtual machine.</source>
          <target state="translated">Java 가상 머신의 컴파일 시스템의 관리 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="28e4b42aecf0c56a50db52a87728efbf52162f13" translate="yes" xml:space="preserve">
          <source>The management interface for the garbage collection of the Java virtual machine.</source>
          <target state="translated">Java 가상 머신의 가비지 콜렉션을위한 관리 인터페이스.</target>
        </trans-unit>
        <trans-unit id="cd92e36a53dffe8143090f88af9bf00d44b66033" translate="yes" xml:space="preserve">
          <source>The management interface for the garbage collection of the Java virtual machine. Garbage collection is the process that the Java virtual machine uses to find and reclaim unreachable objects to free up memory space. A garbage collector is one type of &lt;a href=&quot;memorymanagermxbean&quot;&gt;&lt;code&gt;memory manager&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Java 가상 머신의 가비지 콜렉션을위한 관리 인터페이스. 가비지 콜렉션은 JVM (Java Virtual Machine)이 도달 할 수없는 오브젝트를 찾아서 회수하여 메모리 공간을 확보하는 데 사용하는 프로세스입니다. 가비지 수집기는 &lt;a href=&quot;memorymanagermxbean&quot;&gt; &lt;code&gt;memory manager&lt;/code&gt; &lt;/a&gt; 유형 중 하나 입니다.</target>
        </trans-unit>
        <trans-unit id="0440ae4e2f0264de76917a1f8baa0480d3a12abc" translate="yes" xml:space="preserve">
          <source>The management interface for the logging facility.</source>
          <target state="translated">로깅 기능을위한 관리 인터페이스.</target>
        </trans-unit>
        <trans-unit id="93c3b79d3c66ce577a9864a254628b4a822e847f" translate="yes" xml:space="preserve">
          <source>The management interface for the logging facility. &lt;a href=&quot;../../../../java.management/java/lang/management/platformloggingmxbean&quot;&gt;&lt;code&gt;java.lang.management.PlatformLoggingMXBean&lt;/code&gt;&lt;/a&gt; is the management interface for logging facility registered in the &lt;a href=&quot;../../../../java.management/java/lang/management/managementfactory#getPlatformMBeanServer()&quot;&gt;&lt;code&gt;platform MBeanServer&lt;/code&gt;&lt;/a&gt;. It is recommended to use the &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; obtained via the &lt;a href=&quot;../../../../java.management/java/lang/management/managementfactory#getPlatformMXBean(java.lang.Class)&quot;&gt;&lt;code&gt;ManagementFactory.getPlatformMXBean(PlatformLoggingMXBean.class)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">The management interface for the logging facility. &lt;a href=&quot;../../../../java.management/java/lang/management/platformloggingmxbean&quot;&gt; &lt;code&gt;java.lang.management.PlatformLoggingMXBean&lt;/code&gt; &lt;/a&gt; is the management interface for logging facility registered in the &lt;a href=&quot;../../../../java.management/java/lang/management/managementfactory#getPlatformMBeanServer()&quot;&gt; &lt;code&gt;platform MBeanServer&lt;/code&gt; &lt;/a&gt;. It is recommended to use the &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; obtained via the &lt;a href=&quot;../../../../java.management/java/lang/management/managementfactory#getPlatformMXBean(java.lang.Class)&quot;&gt; &lt;code&gt;ManagementFactory.getPlatformMXBean(PlatformLoggingMXBean.class)&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="3ef314b5f9f21eb1016958cad7f6ed16998f4dbf" translate="yes" xml:space="preserve">
          <source>The management interface for the logging facility. It is recommended to use the &lt;a href=&quot;../../lang/management/platformloggingmxbean&quot;&gt;&lt;code&gt;PlatformLoggingMXBean&lt;/code&gt;&lt;/a&gt; management interface that implements all attributes defined in this &lt;code&gt;LoggingMXBean&lt;/code&gt;. The &lt;a href=&quot;../../lang/management/managementfactory#getPlatformMXBean-java.lang.Class-&quot;&gt;&lt;code&gt;ManagementFactory.getPlatformMXBean&lt;/code&gt;&lt;/a&gt; method can be used to obtain the &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; object representing the management interface for logging.</source>
          <target state="translated">로깅 기능을위한 관리 인터페이스. 이 &lt;code&gt;LoggingMXBean&lt;/code&gt; 에 정의 된 모든 속성을 구현 하는 &lt;a href=&quot;../../lang/management/platformloggingmxbean&quot;&gt; &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; &lt;/a&gt; 관리 인터페이스 를 사용하는 것이 좋습니다 . &lt;a href=&quot;../../lang/management/managementfactory#getPlatformMXBean-java.lang.Class-&quot;&gt; &lt;code&gt;ManagementFactory.getPlatformMXBean&lt;/code&gt; &lt;/a&gt; 방법은 취득 할 수 &lt;code&gt;PlatformLoggingMXBean&lt;/code&gt; 로깅을위한 관리 인터페이스를 나타내는 개체.</target>
        </trans-unit>
        <trans-unit id="10c44d718b1a21753bf3b069730f590be918c45f" translate="yes" xml:space="preserve">
          <source>The management interface for the memory system of the Java virtual machine.</source>
          <target state="translated">Java 가상 머신의 메모리 시스템의 관리 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="847ac3d0883ec1a323c757fc548b0fd4d2e2c36d" translate="yes" xml:space="preserve">
          <source>The management interface for the operating system on which the Java virtual machine is running.</source>
          <target state="translated">JVM (Java Virtual Machine)이 실행중인 운영 체제의 관리 인터페이스</target>
        </trans-unit>
        <trans-unit id="6eb52bce02ed0ce174dbff28ae7ecc47698722a7" translate="yes" xml:space="preserve">
          <source>The management interface for the runtime system of the Java virtual machine.</source>
          <target state="translated">JVM (Java Virtual Machine)의 런타임 시스템에 대한 관리 인터페이스</target>
        </trans-unit>
        <trans-unit id="8e39ca7a7b013a02644c7fe0d0da87295154d935" translate="yes" xml:space="preserve">
          <source>The management interface for the thread system of the Java virtual machine.</source>
          <target state="translated">JVM (Java Virtual Machine)의 스레드 시스템에 대한 관리 인터페이스</target>
        </trans-unit>
        <trans-unit id="0f89f384aef1c053634fba77e812dec13d803a9b" translate="yes" xml:space="preserve">
          <source>The management interface of this Standard MBean (or MXBean).</source>
          <target state="translated">이 Standard MBean (또는 MXBean)의 관리 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="9a8a459cca47f20b145ecf310bebc20942a80db0" translate="yes" xml:space="preserve">
          <source>The management interfaces are also registered with the platform &lt;a href=&quot;../../../javax/management/mbeanserver&quot;&gt;&lt;code&gt;MBeanServer&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../../../javax/management/objectname&quot;&gt;&lt;code&gt;ObjectName&lt;/code&gt;&lt;/a&gt; that uniquely identifies the management interface within the &lt;code&gt;MBeanServer&lt;/code&gt; takes the form:</source>
          <target state="translated">관리 인터페이스는 플랫폼 &lt;a href=&quot;../../../javax/management/mbeanserver&quot;&gt; &lt;code&gt;MBeanServer&lt;/code&gt; &lt;/a&gt; 에도 등록됩니다 . &lt;a href=&quot;../../../javax/management/objectname&quot;&gt; &lt;code&gt;ObjectName&lt;/code&gt; &lt;/a&gt; 고유 내에서 관리 인터페이스를 식별 &lt;code&gt;MBeanServer&lt;/code&gt; 형식을 취합니다 :</target>
        </trans-unit>
        <trans-unit id="351e7dc77ed2411113c4e0ace52b31f98531806d" translate="yes" xml:space="preserve">
          <source>The management of a signer's private keys is an important and sensitive issue that should be handled by subclasses as appropriate to their intended use.</source>
          <target state="translated">서명자의 개인 키 관리는 중요하고 민감한 문제로 의도 된 용도에 맞게 서브 클래스에서 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e3ee70b5049efe06c2a7d7c78dad8ec1c86cb19" translate="yes" xml:space="preserve">
          <source>The manifest of the agent JAR file must contain the attribute &lt;code&gt;
 Premain-Class&lt;/code&gt; in its main manifest. The value of this attribute is the name of the</source>
          <target state="translated">The manifest of the agent JAR file must contain the attribute &lt;code&gt; Premain-Class&lt;/code&gt; in its main manifest. The value of this attribute is the name of the</target>
        </trans-unit>
        <trans-unit id="d605640695e5655c5683f5e380c0d4a62c4c111b" translate="yes" xml:space="preserve">
          <source>The manifest of the agent JAR must contain the attribute &lt;code&gt;
   Agent-Class&lt;/code&gt; in its main manfiest. The value of this attribute is the name of the</source>
          <target state="translated">The manifest of the agent JAR must contain the attribute &lt;code&gt; Agent-Class&lt;/code&gt; in its main manfiest. The value of this attribute is the name of the</target>
        </trans-unit>
        <trans-unit id="0971fe683af5a5e2e54b47c769fab0246a3b75de" translate="yes" xml:space="preserve">
          <source>The manual feed input tray in the printer.</source>
          <target state="translated">프린터의 수동 급지 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="9d81f1be91cb53728efc46880aacfe384ada117f" translate="yes" xml:space="preserve">
          <source>The map is unmodifiable.</source>
          <target state="translated">지도를 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="148614dffcd2a1483f4669ef60a289f4891d5d8f" translate="yes" xml:space="preserve">
          <source>The map returned by this method will have one entry for each charset for which support is available in the current Java virtual machine. If two or more supported charsets have the same canonical name then the resulting map will contain just one of them; which one it will contain is not specified.</source>
          <target state="translated">이 메소드가 리턴 한 맵에는 현재 Java 가상 머신에서 지원되는 각 문자 세트마다 하나의 항목이 있습니다. 둘 이상의 지원되는 문자 집합이 동일한 정식 이름을 가진 경우 결과 맵에는 그 중 하나만 포함됩니다. 어떤 것이 포함 될지 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="cc3989e3137f8abc67f81771ff3d11582e2763d1" translate="yes" xml:space="preserve">
          <source>The map will not contain a mapping for the specified key once the call returns.</source>
          <target state="translated">호출이 반환되면 맵에 지정된 키에 대한 매핑이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d6d635a3361ab121278dfa747bf9a62761f81a7" translate="yes" xml:space="preserve">
          <source>The mapped Java type, &lt;em&gt;opendata(&lt;/em&gt;&lt;code&gt;
        List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;em&gt;)&lt;/em&gt;, is &lt;code&gt;String[]&lt;/code&gt;.</source>
          <target state="translated">The mapped Java type, &lt;em&gt;opendata(&lt;/em&gt; &lt;code&gt; List&amp;lt;String&amp;gt;&lt;/code&gt; &lt;em&gt;)&lt;/em&gt;, is &lt;code&gt;String[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5efef9ce16d66b6a65a451ff2af5a09326eda0bc" translate="yes" xml:space="preserve">
          <source>The mapped Java type, &lt;em&gt;opendata(&lt;/em&gt;&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;em&gt;)&lt;/em&gt;, is &lt;code&gt;String[]&lt;/code&gt;.</source>
          <target state="translated">맵핑 된 Java 유형 인 &lt;em&gt;opendata ( &lt;/em&gt; &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; &lt;em&gt;)&lt;/em&gt; 는 &lt;code&gt;String[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fd167e9165a3f6429397c891dd64da4bb93b1858" translate="yes" xml:space="preserve">
          <source>The mapped byte buffer</source>
          <target state="translated">매핑 된 바이트 버퍼</target>
        </trans-unit>
        <trans-unit id="5bc578c802f074a2b47893ebad7e6008cc29a3b3" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;ConfigurationInfo&lt;/code&gt; is &lt;code&gt;CompositeData&lt;/code&gt; with attributes as specified in the &lt;a href=&quot;configurationinfo#from(javax.management.openmbean.CompositeData)&quot;&gt;&lt;code&gt;ConfigurationInfo.from&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">의 매핑 유형 &lt;code&gt;ConfigurationInfo&lt;/code&gt; 는 이다 &lt;code&gt;CompositeData&lt;/code&gt; 에 지정된대로 속성을 &lt;a href=&quot;configurationinfo#from(javax.management.openmbean.CompositeData)&quot;&gt; &lt;code&gt;ConfigurationInfo.from&lt;/code&gt; 의&lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="eec85321356219422ccc94da919c9955fb20ab7d" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;EventTypeInfo&lt;/code&gt; is &lt;code&gt;CompositeData&lt;/code&gt; with attributes as specified in the &lt;a href=&quot;eventtypeinfo#from(javax.management.openmbean.CompositeData)&quot;&gt;&lt;code&gt;EventTypeInfo.from&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">의 매핑 유형 &lt;code&gt;EventTypeInfo&lt;/code&gt; 는 이다 &lt;code&gt;CompositeData&lt;/code&gt; 에 지정된대로 속성을 &lt;a href=&quot;eventtypeinfo#from(javax.management.openmbean.CompositeData)&quot;&gt; &lt;code&gt;EventTypeInfo.from&lt;/code&gt; 의&lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="b2312b24991b37933ebe862c787f3ef5bd90a444" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; is &lt;code&gt;String[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 의 매핑 된 유형 은 &lt;code&gt;String[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b54d5b016c52978ccbd2bdfb38bb414673876d40" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;Map&amp;lt;String,String&amp;gt;&lt;/code&gt; is &lt;a href=&quot;../../../javax/management/openmbean/tabulardata&quot;&gt;&lt;code&gt;TabularData&lt;/code&gt;&lt;/a&gt; with two items in each row as follows:</source>
          <target state="translated">&lt;code&gt;Map&amp;lt;String,String&amp;gt;&lt;/code&gt; 의 매핑 된 유형은 다음과 같이 각 행에 두 개의 항목 이있는 &lt;a href=&quot;../../../javax/management/openmbean/tabulardata&quot;&gt; &lt;code&gt;TabularData&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8e952ed904175c8930ea48403051b5d05c5545c6" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;MemoryType&lt;/code&gt; is &lt;code&gt;String&lt;/code&gt; and the value is the name of the &lt;code&gt;MemoryType&lt;/code&gt;.</source>
          <target state="translated">맵핑 된 &lt;code&gt;MemoryType&lt;/code&gt; 유형 은 &lt;code&gt;String&lt;/code&gt; 이고 값은 &lt;code&gt;MemoryType&lt;/code&gt; 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="9e1ac76286a906fe472a7e36c4b7b1ffadc6a203" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;MemoryUsage&lt;/code&gt; is &lt;code&gt;CompositeData&lt;/code&gt; with attributes as specified in &lt;a href=&quot;memoryusage#from(javax.management.openmbean.CompositeData)&quot;&gt;&lt;code&gt;MemoryUsage&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The mapped type of &lt;code&gt;MemoryUsage&lt;/code&gt; is &lt;code&gt;CompositeData&lt;/code&gt; with attributes as specified in &lt;a href=&quot;memoryusage#from(javax.management.openmbean.CompositeData)&quot;&gt; &lt;code&gt;MemoryUsage&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="fbaf85954f7772b1959d714dcd3394a5212a77f6" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;MemoryUsage&lt;/code&gt; is &lt;code&gt;CompositeData&lt;/code&gt; with attributes as specified in &lt;a href=&quot;memoryusage#from-javax.management.openmbean.CompositeData-&quot;&gt;&lt;code&gt;MemoryUsage&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 매핑 유형 &lt;code&gt;MemoryUsage&lt;/code&gt; 의가 있다 &lt;code&gt;CompositeData&lt;/code&gt; 에를 로 지정된 속성을 가지는 &lt;a href=&quot;memoryusage#from-javax.management.openmbean.CompositeData-&quot;&gt; &lt;code&gt;MemoryUsage&lt;/code&gt; 의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6cf8ae0181c2603669715b7b8d47d729964fcbb5" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;RecordingInfo&lt;/code&gt; is &lt;code&gt;CompositeData&lt;/code&gt; with attributes as specified in the &lt;a href=&quot;recordinginfo#from(javax.management.openmbean.CompositeData)&quot;&gt;&lt;code&gt;RecordingInfo.from&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">의 매핑 유형 &lt;code&gt;RecordingInfo&lt;/code&gt; 는 이다 &lt;code&gt;CompositeData&lt;/code&gt; 에 지정된대로 속성을 &lt;a href=&quot;recordinginfo#from(javax.management.openmbean.CompositeData)&quot;&gt; &lt;code&gt;RecordingInfo.from&lt;/code&gt; 의&lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="27168ca3751e58f41f1b0b7691cf1f63add33d5f" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;ThreadInfo&lt;/code&gt; is &lt;code&gt;CompositeData&lt;/code&gt; with attributes as specified in the &lt;a href=&quot;threadinfo#from(javax.management.openmbean.CompositeData)&quot;&gt;&lt;code&gt;ThreadInfo.from&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">The mapped type of &lt;code&gt;ThreadInfo&lt;/code&gt; is &lt;code&gt;CompositeData&lt;/code&gt; with attributes as specified in the &lt;a href=&quot;threadinfo#from(javax.management.openmbean.CompositeData)&quot;&gt; &lt;code&gt;ThreadInfo.from&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="61f3a8b7b0aafedaf94c7afc27dfb44c20f6f872" translate="yes" xml:space="preserve">
          <source>The mapped type of &lt;code&gt;ThreadInfo&lt;/code&gt; is &lt;code&gt;CompositeData&lt;/code&gt; with attributes as specified in the &lt;a href=&quot;threadinfo#from-javax.management.openmbean.CompositeData-&quot;&gt;&lt;code&gt;ThreadInfo.from&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">의 매핑 유형 &lt;code&gt;ThreadInfo&lt;/code&gt; 에가 있다 &lt;code&gt;CompositeData&lt;/code&gt; 에을 에 지정된대로 속성을 &lt;a href=&quot;threadinfo#from-javax.management.openmbean.CompositeData-&quot;&gt; &lt;code&gt;ThreadInfo.from&lt;/code&gt; 의&lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="3c087cdbe45fea6b6b9ec0f6437a67475b253bf7" translate="yes" xml:space="preserve">
          <source>The mapping from a local date-time to an offset is not straightforward. There are three cases:</source>
          <target state="translated">로컬 날짜-시간에서 오프셋으로의 매핑은 간단하지 않습니다. 세 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="12e8672b358b7324e88869fe3994e4595f187b3a" translate="yes" xml:space="preserve">
          <source>The mapping from an instant to an offset is simple, there is only one valid offset for each instant. This method returns that offset.</source>
          <target state="translated">인스턴트에서 오프셋으로의 매핑은 간단하며 각 인스턴트에 대해 하나의 유효한 오프셋 만 있습니다. 이 메소드는 해당 오프셋을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="efa8f760fe15a8611f03234f6225c472bbad9757" translate="yes" xml:space="preserve">
          <source>The mapping function is executed using the client's &lt;a href=&quot;httpclient#executor()&quot;&gt;executor&lt;/a&gt;, and can therefore be used to map any response body type, including blocking &lt;a href=&quot;../../../../java.base/java/io/inputstream&quot;&gt;&lt;code&gt;InputStream&lt;/code&gt;&lt;/a&gt;, as shown in the following example which uses a well-known JSON parser to convert an &lt;code&gt;InputStream&lt;/code&gt; into any annotated Java type.</source>
          <target state="translated">The mapping function is executed using the client's &lt;a href=&quot;httpclient#executor()&quot;&gt;executor&lt;/a&gt;, and can therefore be used to map any response body type, including blocking &lt;a href=&quot;../../../../java.base/java/io/inputstream&quot;&gt; &lt;code&gt;InputStream&lt;/code&gt; &lt;/a&gt;, as shown in the following example which uses a well-known JSON parser to convert an &lt;code&gt;InputStream&lt;/code&gt; into any annotated Java type.</target>
        </trans-unit>
        <trans-unit id="a0da09c5baf6c433f0daaa54f1f38ab8df0341d5" translate="yes" xml:space="preserve">
          <source>The mapping function is executed using the client's &lt;a href=&quot;httpclient#executor()&quot;&gt;executor&lt;/a&gt;, and can therefore be used to map any response body type, including blocking &lt;a href=&quot;../../../../java.base/java/io/inputstream&quot;&gt;&lt;code&gt;InputStream&lt;/code&gt;&lt;/a&gt;. However, performing any blocking operation in the mapper function runs the risk of blocking the executor's thread for an unknown amount of time (at least until the blocking operation finishes), which may end up starving the executor of available threads. Therefore, in the case where mapping to the desired type might block (e.g. by reading on the &lt;code&gt;InputStream&lt;/code&gt;), then mapping to a &lt;a href=&quot;../../../../java.base/java/util/function/supplier&quot;&gt;&lt;code&gt;Supplier&lt;/code&gt;&lt;/a&gt; of the desired type and deferring the blocking operation until &lt;a href=&quot;../../../../java.base/java/util/function/supplier#get()&quot;&gt;&lt;code&gt;Supplier::get&lt;/code&gt;&lt;/a&gt; is invoked by the caller's thread should be preferred, as shown in the following example which uses a well-known JSON parser to convert an &lt;code&gt;InputStream&lt;/code&gt; into any annotated Java type.</source>
          <target state="translated">매핑 함수는 클라이언트의 &lt;a href=&quot;httpclient#executor()&quot;&gt;executor를&lt;/a&gt; 사용하여 실행 되므로 &lt;a href=&quot;../../../../java.base/java/io/inputstream&quot;&gt; &lt;code&gt;InputStream&lt;/code&gt; &lt;/a&gt; 차단을 포함하여 모든 응답 본문 유형을 매핑하는 데 사용할 수 있습니다 . 그러나 매퍼 함수에서 차단 작업을 수행하면 알 수없는 시간 (적어도 차단 작업이 완료 될 때까지) 동안 실행기의 스레드를 차단할 위험이 있으며, 이로 인해 사용 가능한 스레드의 실행기가 굶어 죽을 수 있습니다. 따라서 원하는 유형에 대한 매핑이 차단 될 수있는 경우 (예 : &lt;code&gt;InputStream&lt;/code&gt; 에서 읽기 ) 원하는 유형 의 &lt;a href=&quot;../../../../java.base/java/util/function/supplier&quot;&gt; &lt;code&gt;Supplier&lt;/code&gt; &lt;/a&gt; 에 매핑하고 &lt;a href=&quot;../../../../java.base/java/util/function/supplier#get()&quot;&gt; &lt;code&gt;Supplier::get&lt;/code&gt; &lt;/a&gt; 까지 차단 작업을 연기합니다.잘 알려진 JSON 구문 분석기를 사용하여 &lt;code&gt;InputStream&lt;/code&gt; 을 주석이 달린 Java 유형으로 변환하는 다음 예제와 같이 호출자의 스레드가 호출하는 것이 선호되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ef4cb909339e0195cefa4b8944e1ab977800051" translate="yes" xml:space="preserve">
          <source>The mapping function must not modify this map during computation.</source>
          <target state="translated">매핑 함수는 계산 중에이 맵을 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="213db0c7af81269192b73e1d66cfb3a1ecd68846" translate="yes" xml:space="preserve">
          <source>The mapping function should not modify this map during computation.</source>
          <target state="translated">The mapping function should not modify this map during computation.</target>
        </trans-unit>
        <trans-unit id="f57b59469df7401fda6a0c7302c57fa6c971a325" translate="yes" xml:space="preserve">
          <source>The mapping in the Java programming language for the SQL &lt;code&gt;CLOB&lt;/code&gt; type.</source>
          <target state="translated">SQL &lt;code&gt;CLOB&lt;/code&gt; 유형 에 대한 Java 프로그래밍 언어의 매핑입니다 .</target>
        </trans-unit>
        <trans-unit id="602eb684f00ec50b36cf464526819f977542dd71" translate="yes" xml:space="preserve">
          <source>The mapping in the Java programming language for the SQL &lt;code&gt;CLOB&lt;/code&gt; type. An SQL &lt;code&gt;CLOB&lt;/code&gt; is a built-in type that stores a Character Large Object as a column value in a row of a database table. By default drivers implement a &lt;code&gt;Clob&lt;/code&gt; object using an SQL &lt;code&gt;locator(CLOB)&lt;/code&gt;, which means that a &lt;code&gt;Clob&lt;/code&gt; object contains a logical pointer to the SQL &lt;code&gt;CLOB&lt;/code&gt; data rather than the data itself. A &lt;code&gt;Clob&lt;/code&gt; object is valid for the duration of the transaction in which it was created.</source>
          <target state="translated">SQL &lt;code&gt;CLOB&lt;/code&gt; 유형 에 대한 Java 프로그래밍 언어의 매핑입니다 . SQL &lt;code&gt;CLOB&lt;/code&gt; 는 데이터베이스 테이블의 행에 큰 문자 개체를 열 값으로 저장하는 기본 제공 유형입니다. 기본적으로 드라이버 는 SQL &lt;code&gt;locator(CLOB)&lt;/code&gt; 사용하여 &lt;code&gt;Clob&lt;/code&gt; 객체를 구현합니다. 즉, &lt;code&gt;Clob&lt;/code&gt; 객체에는 데이터 자체가 아닌 SQL &lt;code&gt;CLOB&lt;/code&gt; 데이터에 대한 논리적 포인터가 포함 됩니다. &lt;code&gt;Clob&lt;/code&gt; 객체는 그것이 생성 된 트랜잭션 (transaction)의 기간 중에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="f7e262f8d0324c26413eb8c1ab5f37439d2ba06d" translate="yes" xml:space="preserve">
          <source>The mapping in the Java programming language for the SQL &lt;code&gt;NCLOB&lt;/code&gt; type.</source>
          <target state="translated">SQL &lt;code&gt;NCLOB&lt;/code&gt; 유형 에 대한 Java 프로그래밍 언어의 매핑입니다 .</target>
        </trans-unit>
        <trans-unit id="e6b81cfe25452ed4746be6ee376319b2833e7ce3" translate="yes" xml:space="preserve">
          <source>The mapping in the Java programming language for the SQL &lt;code&gt;NCLOB&lt;/code&gt; type. An SQL &lt;code&gt;NCLOB&lt;/code&gt; is a built-in type that stores a Character Large Object using the National Character Set as a column value in a row of a database table.</source>
          <target state="translated">SQL &lt;code&gt;NCLOB&lt;/code&gt; 유형 에 대한 Java 프로그래밍 언어의 매핑입니다 . SQL &lt;code&gt;NCLOB&lt;/code&gt; 는 데이터베이스 테이블의 행에서 국가 별 문자 세트를 컬럼 값으로 사용하여 문자 대형 오브젝트를 저장하는 내장 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a571d2bfd21eab9df5c46eaa9052b6dcad735a3e" translate="yes" xml:space="preserve">
          <source>The mapping in the Java programming language for the SQL type &lt;code&gt;ARRAY&lt;/code&gt;.</source>
          <target state="translated">The mapping in the Java programming language for the SQL type &lt;code&gt;ARRAY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52f0139dde804c78136c63591218cc96ffa35433" translate="yes" xml:space="preserve">
          <source>The mapping in the Java programming language for the SQL type &lt;code&gt;ARRAY&lt;/code&gt;. By default, an &lt;code&gt;Array&lt;/code&gt; value is a transaction-duration reference to an SQL &lt;code&gt;ARRAY&lt;/code&gt; value. By default, an &lt;code&gt;Array&lt;/code&gt; object is implemented using an SQL LOCATOR(array) internally, which means that an &lt;code&gt;Array&lt;/code&gt; object contains a logical pointer to the data in the SQL &lt;code&gt;ARRAY&lt;/code&gt; value rather than containing the &lt;code&gt;ARRAY&lt;/code&gt; value's data.</source>
          <target state="translated">The mapping in the Java programming language for the SQL type &lt;code&gt;ARRAY&lt;/code&gt; . By default, an &lt;code&gt;Array&lt;/code&gt; value is a transaction-duration reference to an SQL &lt;code&gt;ARRAY&lt;/code&gt; value. By default, an &lt;code&gt;Array&lt;/code&gt; object is implemented using an SQL LOCATOR(array) internally, which means that an &lt;code&gt;Array&lt;/code&gt; object contains a logical pointer to the data in the SQL &lt;code&gt;ARRAY&lt;/code&gt; value rather than containing the &lt;code&gt;ARRAY&lt;/code&gt; value's data.</target>
        </trans-unit>
        <trans-unit id="04436d9ae26c83110d5516cdd1d08ae63970fe91" translate="yes" xml:space="preserve">
          <source>The mapping in the Java programming language of an SQL &lt;code&gt;REF&lt;/code&gt; value, which is a reference to an SQL structured type value in the database.</source>
          <target state="translated">The mapping in the Java programming language of an SQL &lt;code&gt;REF&lt;/code&gt; value, which is a reference to an SQL structured type value in the database.</target>
        </trans-unit>
        <trans-unit id="da7f373a020c4b2a772bb84d65fd06df14d3ba1a" translate="yes" xml:space="preserve">
          <source>The mapping in the Java&amp;trade; programming language for the SQL &lt;code&gt;CLOB&lt;/code&gt; type.</source>
          <target state="translated">The mapping in the Java&amp;trade; programming language for the SQL &lt;code&gt;CLOB&lt;/code&gt; type.</target>
        </trans-unit>
        <trans-unit id="6975cb32bff899229ce9f4e10e17293c269e7cf3" translate="yes" xml:space="preserve">
          <source>The mapping in the Java&amp;trade; programming language for the SQL &lt;code&gt;CLOB&lt;/code&gt; type. An SQL &lt;code&gt;CLOB&lt;/code&gt; is a built-in type that stores a Character Large Object as a column value in a row of a database table. By default drivers implement a &lt;code&gt;Clob&lt;/code&gt; object using an SQL &lt;code&gt;locator(CLOB)&lt;/code&gt;, which means that a &lt;code&gt;Clob&lt;/code&gt; object contains a logical pointer to the SQL &lt;code&gt;CLOB&lt;/code&gt; data rather than the data itself. A &lt;code&gt;Clob&lt;/code&gt; object is valid for the duration of the transaction in which it was created.</source>
          <target state="translated">The mapping in the Java&amp;trade; programming language for the SQL &lt;code&gt;CLOB&lt;/code&gt; type. An SQL &lt;code&gt;CLOB&lt;/code&gt; is a built-in type that stores a Character Large Object as a column value in a row of a database table. By default drivers implement a &lt;code&gt;Clob&lt;/code&gt; object using an SQL &lt;code&gt;locator(CLOB)&lt;/code&gt; , which means that a &lt;code&gt;Clob&lt;/code&gt; object contains a logical pointer to the SQL &lt;code&gt;CLOB&lt;/code&gt; data rather than the data itself. A &lt;code&gt;Clob&lt;/code&gt; object is valid for the duration of the transaction in which it was created.</target>
        </trans-unit>
        <trans-unit id="a55434df05c4f86901f5b64057a68cfa88f0577d" translate="yes" xml:space="preserve">
          <source>The mapping in the Java&amp;trade; programming language for the SQL &lt;code&gt;NCLOB&lt;/code&gt; type.</source>
          <target state="translated">The mapping in the Java&amp;trade; programming language for the SQL &lt;code&gt;NCLOB&lt;/code&gt; type.</target>
        </trans-unit>
        <trans-unit id="7b63425c41c17fe4291c19c2b6017e208a65e5b0" translate="yes" xml:space="preserve">
          <source>The mapping in the Java&amp;trade; programming language for the SQL &lt;code&gt;NCLOB&lt;/code&gt; type. An SQL &lt;code&gt;NCLOB&lt;/code&gt; is a built-in type that stores a Character Large Object using the National Character Set as a column value in a row of a database table.</source>
          <target state="translated">The mapping in the Java&amp;trade; programming language for the SQL &lt;code&gt;NCLOB&lt;/code&gt; type. An SQL &lt;code&gt;NCLOB&lt;/code&gt; is a built-in type that stores a Character Large Object using the National Character Set as a column value in a row of a database table.</target>
        </trans-unit>
        <trans-unit id="255c64e2047c17ae5184bedb71a28f00f28b7429" translate="yes" xml:space="preserve">
          <source>The mapping in the JavaTM programming language for the SQL XML type.</source>
          <target state="translated">The mapping in the JavaTM programming language for the SQL XML type.</target>
        </trans-unit>
        <trans-unit id="3e6756cd08dbba5b84d5d8e2892c437d35af2b09" translate="yes" xml:space="preserve">
          <source>The mapping in the JavaTM programming language for the SQL XML type. XML is a built-in type that stores an XML value as a column value in a row of a database table. By default drivers implement an SQLXML object as a logical pointer to the XML data rather than the data itself. An SQLXML object is valid for the duration of the transaction in which it was created.</source>
          <target state="translated">The mapping in the JavaTM programming language for the SQL XML type. XML is a built-in type that stores an XML value as a column value in a row of a database table. By default drivers implement an SQLXML object as a logical pointer to the XML data rather than the data itself. An SQLXML object is valid for the duration of the transaction in which it was created.</target>
        </trans-unit>
        <trans-unit id="e1c4016a1547ff269142e86df6754b622f9096c2" translate="yes" xml:space="preserve">
          <source>The mapping is as follows:</source>
          <target state="translated">The mapping is as follows:</target>
        </trans-unit>
        <trans-unit id="070cdcd14f1b28d83ab8a6aeee5919d756ab62c0" translate="yes" xml:space="preserve">
          <source>The masks are also used to specify to which types of events an AWTEventListener should listen. The masks are bitwise-ORed together and passed to Toolkit.addAWTEventListener.</source>
          <target state="translated">The masks are also used to specify to which types of events an AWTEventListener should listen. The masks are bitwise-ORed together and passed to Toolkit.addAWTEventListener.</target>
        </trans-unit>
        <trans-unit id="d94cfa1b774fa8e3080e7fb76e5c183d18614b0c" translate="yes" xml:space="preserve">
          <source>The master list of all listeners registered by other classes.</source>
          <target state="translated">다른 클래스에 의해 등록 된 모든 리스너의 마스터 목록입니다.</target>
        </trans-unit>
        <trans-unit id="bd3430496cad125fbd6b4a89448dfd4066183dd3" translate="yes" xml:space="preserve">
          <source>The master list of all listeners registered by other classes. This can only be publicly modified by calling the add or remove listener methods in this class.</source>
          <target state="translated">다른 클래스에 의해 등록 된 모든 리스너의 마스터 목록입니다. 이 클래스에서 리스너 추가 또는 제거 메소드를 호출하여 공개적으로 만 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44258d85a346a4c9b6eb26fc12ad6d8021de13a" translate="yes" xml:space="preserve">
          <source>The match flags specified when this pattern was compiled</source>
          <target state="translated">이 패턴이 컴파일 될 때 지정된 일치 플래그</target>
        </trans-unit>
        <trans-unit id="b6161dc0d1d482e470d3b40c8580a8c7a9b72e62" translate="yes" xml:space="preserve">
          <source>The matchAllNames flag is &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">matchAllNames 플래그는 기본적으로 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="83a79f7443cf79cc4fa21a88607c23e056fb21d4" translate="yes" xml:space="preserve">
          <source>The matching element or &lt;code&gt;null&lt;/code&gt; if there is none.</source>
          <target state="translated">The matching element or &lt;code&gt;null&lt;/code&gt; if there is none.</target>
        </trans-unit>
        <trans-unit id="1cbc75262fd1ef2b8dadd8accd1736228c68ecd9" translate="yes" xml:space="preserve">
          <source>The matching elements.</source>
          <target state="translated">일치하는 요소.</target>
        </trans-unit>
        <trans-unit id="bca93fe90b1b894db1cfc72931b5ea41fde9342c" translate="yes" xml:space="preserve">
          <source>The matching of &lt;a href=&quot;path#getRoot()&quot;&gt;&lt;code&gt;root&lt;/code&gt;&lt;/a&gt; components is highly implementation-dependent and is not specified.</source>
          <target state="translated">The matching of &lt;a href=&quot;path#getRoot()&quot;&gt; &lt;code&gt;root&lt;/code&gt; &lt;/a&gt; components is highly implementation-dependent and is not specified.</target>
        </trans-unit>
        <trans-unit id="9bde4024a82b87c160e08374c35154b8fc469748" translate="yes" xml:space="preserve">
          <source>The matching of &lt;a href=&quot;path#getRoot--&quot;&gt;&lt;code&gt;root&lt;/code&gt;&lt;/a&gt; components is highly implementation-dependent and is not specified.</source>
          <target state="translated">&lt;a href=&quot;path#getRoot--&quot;&gt; &lt;code&gt;root&lt;/code&gt; &lt;/a&gt; 구성 요소 의 일치는 구현에 따라 다르며 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="bf6178e4c5f6199ffdea85dc0025cfc04da4e3b8" translate="yes" xml:space="preserve">
          <source>The matrix associated with this band combine operation.</source>
          <target state="translated">The matrix associated with this band combine operation.</target>
        </trans-unit>
        <trans-unit id="f72eb688190acfe479f553b3a38062f652d5b181" translate="yes" xml:space="preserve">
          <source>The matrix representing the returned transform is:</source>
          <target state="translated">The matrix representing the returned transform is:</target>
        </trans-unit>
        <trans-unit id="3d6e9efeee5e8c75c854f1ccf14ca0392463338e" translate="yes" xml:space="preserve">
          <source>The matrix representing this transform becomes:</source>
          <target state="translated">The matrix representing this transform becomes:</target>
        </trans-unit>
        <trans-unit id="c1fa5aaa90da896f57abcdb817d4038ebd7a2b72" translate="yes" xml:space="preserve">
          <source>The maximize button text property.</source>
          <target state="translated">The maximize button text property.</target>
        </trans-unit>
        <trans-unit id="20326d370501a0af41665f4c9a5ca80891b61f78" translate="yes" xml:space="preserve">
          <source>The maximize button.</source>
          <target state="translated">The maximize button.</target>
        </trans-unit>
        <trans-unit id="dafe5c013a4d23dd7d97352d183fb7befdc1ae98" translate="yes" xml:space="preserve">
          <source>The maximize icon.</source>
          <target state="translated">The maximize icon.</target>
        </trans-unit>
        <trans-unit id="fed4268f693a6541532c56cc66c5cf2f9c565e69" translate="yes" xml:space="preserve">
          <source>The maximum allowed length of the domain name in this implementation is &lt;code&gt;Integer.MAX_VALUE/4&lt;/code&gt;</source>
          <target state="translated">The maximum allowed length of the domain name in this implementation is &lt;code&gt;Integer.MAX_VALUE/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4304755a2aafc9e7c8b0e05b8ff5b0b036a8a9a3" translate="yes" xml:space="preserve">
          <source>The maximum amount by which the left side of this glyph can grow.</source>
          <target state="translated">The maximum amount by which the left side of this glyph can grow.</target>
        </trans-unit>
        <trans-unit id="0c31d2a2db4cd524c3f8ca2915ec9d8ee723482b" translate="yes" xml:space="preserve">
          <source>The maximum amount by which the left side of this glyph can shrink (a positive number).</source>
          <target state="translated">The maximum amount by which the left side of this glyph can shrink (a positive number).</target>
        </trans-unit>
        <trans-unit id="8fe564f1a9e6b8c8a78cadb8e8049f985c60ce98" translate="yes" xml:space="preserve">
          <source>The maximum amount by which the right side of this glyph can grow.</source>
          <target state="translated">The maximum amount by which the right side of this glyph can grow.</target>
        </trans-unit>
        <trans-unit id="5267028f1e50e91bfa8aed05f8762e1d741b42fc" translate="yes" xml:space="preserve">
          <source>The maximum amount by which the right side of this glyph can shrink (a positive number).</source>
          <target state="translated">The maximum amount by which the right side of this glyph can shrink (a positive number).</target>
        </trans-unit>
        <trans-unit id="caaaddcac02d29b7e0729b8b5a3f5eaa939992e8" translate="yes" xml:space="preserve">
          <source>The maximum normalized component value.</source>
          <target state="translated">The maximum normalized component value.</target>
        </trans-unit>
        <trans-unit id="da03290405b7c1d565b96a7f711d623661662ec8" translate="yes" xml:space="preserve">
          <source>The maximum number of arguments is limited by the maximum dimension of a Java array as defined by</source>
          <target state="translated">최대 인수 수는 다음에 의해 정의 된 Java 배열의 최대 차원에 의해 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="ca2a7698e53e08ca40902d31c125a0421b565e34" translate="yes" xml:space="preserve">
          <source>The maximum number of bytes that will be produced per character of input</source>
          <target state="translated">입력 문자 당 생성되는 최대 바이트 수</target>
        </trans-unit>
        <trans-unit id="7e9aed519157935d36669fabf1cedde3311fc915" translate="yes" xml:space="preserve">
          <source>The maximum number of characters that will be produced per byte of input</source>
          <target state="translated">입력 바이트 당 생성되는 최대 문자 수</target>
        </trans-unit>
        <trans-unit id="91152b63e685cd48eb7d0248d3371320972bb796" translate="yes" xml:space="preserve">
          <source>The maximum number of entries that will be returned.</source>
          <target state="translated">리턴 될 최대 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="93aede5def5caeba565f92f79b9343892253bbbf" translate="yes" xml:space="preserve">
          <source>The maximum number of inbound streams</source>
          <target state="translated">최대 인바운드 스트림 수</target>
        </trans-unit>
        <trans-unit id="5b00c15ede0bb5cd986a95da4286e0f38caac37d" translate="yes" xml:space="preserve">
          <source>The maximum number of method handles in the chain.</source>
          <target state="translated">체인의 최대 메서드 핸들 수입니다.</target>
        </trans-unit>
        <trans-unit id="a866b66e70e23668eadac882ece07b5ebb50cd08" translate="yes" xml:space="preserve">
          <source>The maximum number of method handles in the chain. Defaults to 8. You can override it in a subclass if you need to change the value.</source>
          <target state="translated">체인의 최대 메서드 핸들 수입니다. 기본값은 8입니다. 값을 변경해야하는 경우 하위 클래스에서 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83dfad991209eb6d5355a6911b7f865dcd550c22" translate="yes" xml:space="preserve">
          <source>The maximum number of outbound streams</source>
          <target state="translated">최대 아웃 바운드 스트림 수</target>
        </trans-unit>
        <trans-unit id="79be7d1b45b94d650237ca9ef607fb0644e6d715" translate="yes" xml:space="preserve">
          <source>The maximum number of progressive passes to read from the source.</source>
          <target state="translated">The maximum number of progressive passes to read from the source.</target>
        </trans-unit>
        <trans-unit id="c789ee02ecf9b1e05f4f980e654a03a1c6c8656a" translate="yes" xml:space="preserve">
          <source>The maximum number of progressive passes to read from the source. By default, the value is set to &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, which indicates that passes up to and including the last available pass should be decoded.</source>
          <target state="translated">소스에서 읽을 최대 진행 패스 수입니다. 기본적으로 값은 &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; 로 설정되며 , 사용 가능한 마지막 패스까지의 패스를 디코딩해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0478f40fe1f37871e583557d8be429e250c42fb2" translate="yes" xml:space="preserve">
          <source>The maximum number of sort keys is enforced by &lt;code&gt;toggleSortOrder&lt;/code&gt;. You can specify more sort keys by invoking &lt;code&gt;setSortKeys&lt;/code&gt; directly and they will all be honored. However if &lt;code&gt;toggleSortOrder&lt;/code&gt; is subsequently invoked the maximum number of sort keys will be enforced. The default value is 3.</source>
          <target state="translated">The maximum number of sort keys is enforced by &lt;code&gt;toggleSortOrder&lt;/code&gt; . You can specify more sort keys by invoking &lt;code&gt;setSortKeys&lt;/code&gt; directly and they will all be honored. However if &lt;code&gt;toggleSortOrder&lt;/code&gt; is subsequently invoked the maximum number of sort keys will be enforced. The default value is 3.</target>
        </trans-unit>
        <trans-unit id="48102fd1a679cbd334e138b724fc20ac9a9bae09" translate="yes" xml:space="preserve">
          <source>The maximum number of streams requested by the local endpoint during association initialization</source>
          <target state="translated">연관 초기화 중 로컬 엔드 포인트에서 요청한 최대 스트림 수</target>
        </trans-unit>
        <trans-unit id="7e608d73eeb8d2a37694e89f88f31da6ae045dbb" translate="yes" xml:space="preserve">
          <source>The maximum number of streams requested by the local endpoint during association initialization.</source>
          <target state="translated">연결 초기화 중에 로컬 끝점에서 요청한 최대 스트림 수입니다.</target>
        </trans-unit>
        <trans-unit id="fbbdc1258f7173253696d9e64d4c4a658afd6ade" translate="yes" xml:space="preserve">
          <source>The maximum priority that a thread can have.</source>
          <target state="translated">스레드가 가질 수있는 최대 우선 순위.</target>
        </trans-unit>
        <trans-unit id="a36a818c4f9c33f17fb433826771d2ce806e0080" translate="yes" xml:space="preserve">
          <source>The maximum queue length for incoming connection indications (a request to connect) is set to &lt;code&gt;50&lt;/code&gt;. If a connection indication arrives when the queue is full, the connection is refused.</source>
          <target state="translated">들어오는 연결 표시 (연결 요청)의 최대 큐 길이는 &lt;code&gt;50&lt;/code&gt; 으로 설정되어 있습니다. 큐가 가득 찼을 때 연결 표시가 도착하면 연결이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="6cc426f28f7320449dfe90a3a16a1a1b1f8164e7" translate="yes" xml:space="preserve">
          <source>The maximum queue length for incoming connection indications (a request to connect) is set to the &lt;code&gt;backlog&lt;/code&gt; parameter. If a connection indication arrives when the queue is full, the connection is refused.</source>
          <target state="translated">들어오는 연결 표시 (연결 요청)의 최대 큐 길이는 &lt;code&gt;backlog&lt;/code&gt; 매개 변수로 설정됩니다 . 큐가 가득 찼을 때 연결 표시가 도착하면 연결이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="4e76f165176d7e28c6b59c285a7ee8af5a71fc72" translate="yes" xml:space="preserve">
          <source>The maximum radix available for conversion to and from strings.</source>
          <target state="translated">문자열로 /에서 변환 할 수있는 최대 기수입니다.</target>
        </trans-unit>
        <trans-unit id="8c6409d2fd9d317951cab0b13d3c92c453ac5d7d" translate="yes" xml:space="preserve">
          <source>The maximum radix available for conversion to and from strings. The constant value of this field is the largest value permitted for the radix argument in radix-conversion methods such as the &lt;code&gt;digit&lt;/code&gt; method, the &lt;code&gt;forDigit&lt;/code&gt; method, and the &lt;code&gt;toString&lt;/code&gt; method of class &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">문자열로 /에서 변환 할 수있는 최대 기수입니다. 이 필드의 상수 값은 &lt;code&gt;digit&lt;/code&gt; 메소드, &lt;code&gt;forDigit&lt;/code&gt; 메소드 및 &lt;code&gt;Integer&lt;/code&gt; 클래스 의 &lt;code&gt;toString&lt;/code&gt; 메소드 와 같은 기수 변환 메소드에서 기수 인수에 허용되는 최대 값 입니다.</target>
        </trans-unit>
        <trans-unit id="f3a3a07104e7ef00f419dbb752b94c72537382fa" translate="yes" xml:space="preserve">
          <source>The maximum read ahead allowed after a call to the &lt;code&gt;mark&lt;/code&gt; method before subsequent calls to the &lt;code&gt;reset&lt;/code&gt; method fail.</source>
          <target state="translated">The maximum read ahead allowed after a call to the &lt;code&gt;mark&lt;/code&gt; method before subsequent calls to the &lt;code&gt;reset&lt;/code&gt; method fail.</target>
        </trans-unit>
        <trans-unit id="686e085cad769598f4690d3665f22a215c1c0ea4" translate="yes" xml:space="preserve">
          <source>The maximum read ahead allowed after a call to the &lt;code&gt;mark&lt;/code&gt; method before subsequent calls to the &lt;code&gt;reset&lt;/code&gt; method fail. Whenever the difference between &lt;code&gt;pos&lt;/code&gt; and &lt;code&gt;markpos&lt;/code&gt; exceeds &lt;code&gt;marklimit&lt;/code&gt;, then the mark may be dropped by setting &lt;code&gt;markpos&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">후속 &lt;code&gt;reset&lt;/code&gt; 메소드 호출이 실패 하기 전에 &lt;code&gt;mark&lt;/code&gt; 메소드 호출 후 허용되는 최대 미리 읽기 입니다. &lt;code&gt;pos&lt;/code&gt; 와 &lt;code&gt;markpos&lt;/code&gt; 의 차이 가 &lt;code&gt;marklimit&lt;/code&gt; 를 초과 할 때마다 &lt;code&gt;markpos&lt;/code&gt; 를 &lt;code&gt;-1&lt;/code&gt; 로 설정하여 마크를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cde12ff04949c15a881f89fbe0182caa7125e32d" translate="yes" xml:space="preserve">
          <source>The maximum size allowed.</source>
          <target state="translated">The maximum size allowed.</target>
        </trans-unit>
        <trans-unit id="ef1976d2f2dd62e42dde8526a7697fca9d5af5a1" translate="yes" xml:space="preserve">
          <source>The maximum size allowed. For a component &lt;code&gt;comp&lt;/code&gt;, this should be equal to either &lt;code&gt;comp.getMaximumSize().width&lt;/code&gt; or &lt;code&gt;comp.getMaximumSize().height&lt;/code&gt;.</source>
          <target state="translated">The maximum size allowed. For a component &lt;code&gt;comp&lt;/code&gt; , this should be equal to either &lt;code&gt;comp.getMaximumSize().width&lt;/code&gt; or &lt;code&gt;comp.getMaximumSize().height&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fc218541d1e04f65cfa7e7c0d95141ef5e61d7f" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;Instant&lt;/code&gt;, '1000000000-12-31T23:59:59.999999999Z'.</source>
          <target state="translated">The maximum supported &lt;code&gt;Instant&lt;/code&gt; , '1000000000-12-31T23:59:59.999999999Z'.</target>
        </trans-unit>
        <trans-unit id="04ce11fe3c27aa7aa9f2ef249ac2e65e1dc4e4ea" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;Instant&lt;/code&gt;, '1000000000-12-31T23:59:59.999999999Z'. This could be used by an application as a &quot;far future&quot; instant.</source>
          <target state="translated">지원되는 최대 &lt;code&gt;Instant&lt;/code&gt; , '1000000000-12-31T23 : 59 : 59.999999999Z'. 응용 프로그램에서 &quot;먼 미래&quot;순간으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8bdb11e05ddef7808311da08422e5ca0efacaf6" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;LocalDate&lt;/code&gt;, '+999999999-12-31'.</source>
          <target state="translated">The maximum supported &lt;code&gt;LocalDate&lt;/code&gt; , '+999999999-12-31'.</target>
        </trans-unit>
        <trans-unit id="e0429cd3a2343e86a77ff7f695d6193f6a24e2a6" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;LocalDate&lt;/code&gt;, '+999999999-12-31'. This could be used by an application as a &quot;far future&quot; date.</source>
          <target state="translated">지원되는 최대 &lt;code&gt;LocalDate&lt;/code&gt; , '+ 999999999-12-31'. 응용 프로그램에서 &quot;먼 미래&quot;날짜로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2eff0863fd6d4cbc5acf0b15a2d8ccc04810718" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;LocalDateTime&lt;/code&gt;, '+999999999-12-31T23:59:59.999999999'.</source>
          <target state="translated">The maximum supported &lt;code&gt;LocalDateTime&lt;/code&gt; , '+999999999-12-31T23:59:59.999999999'.</target>
        </trans-unit>
        <trans-unit id="744d761c58cd3ade37321eaf06b55bc7687217a1" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;LocalDateTime&lt;/code&gt;, '+999999999-12-31T23:59:59.999999999'. This is the local date-time just before midnight at the end of the maximum date. This combines &lt;a href=&quot;localdate#MAX&quot;&gt;&lt;code&gt;LocalDate.MAX&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;localtime#MAX&quot;&gt;&lt;code&gt;LocalTime.MAX&lt;/code&gt;&lt;/a&gt;. This could be used by an application as a &quot;far future&quot; date-time.</source>
          <target state="translated">지원되는 최대 &lt;code&gt;LocalDateTime&lt;/code&gt; , '+ 999999999-12-31T23 : 59 : 59.999999999'. 최대 날짜가 끝나는 자정 직전의 현지 날짜-시간입니다. &lt;a href=&quot;localdate#MAX&quot;&gt; &lt;code&gt;LocalDate.MAX&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;localtime#MAX&quot;&gt; &lt;code&gt;LocalTime.MAX&lt;/code&gt; 를&lt;/a&gt; 결합 합니다. 응용 프로그램에서 &quot;먼 미래&quot;날짜-시간으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="708651e23cf9a3e7e3f159ce07c8fa26f5953b8b" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;LocalTime&lt;/code&gt;, '23:59:59.999999999'.</source>
          <target state="translated">The maximum supported &lt;code&gt;LocalTime&lt;/code&gt; , '23:59:59.999999999'.</target>
        </trans-unit>
        <trans-unit id="a192d7e44fca6c6034ef03db938f5c28d8840499" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;LocalTime&lt;/code&gt;, '23:59:59.999999999'. This is the time just before midnight at the end of the day.</source>
          <target state="translated">지원되는 최대 &lt;code&gt;LocalTime&lt;/code&gt; , '23 : 59 : 59.999999999 ' 이것은 하루가 끝나는 자정 직전의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="8d5d0536c7f2d7b197a4d1276e3d35e8f6c3d2ce" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;OffsetDateTime&lt;/code&gt;, '+999999999-12-31T23:59:59.999999999-18:00'.</source>
          <target state="translated">The maximum supported &lt;code&gt;OffsetDateTime&lt;/code&gt; , '+999999999-12-31T23:59:59.999999999-18:00'.</target>
        </trans-unit>
        <trans-unit id="251ab3d26132087a17d987a3306ea536b764e3b4" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;OffsetDateTime&lt;/code&gt;, '+999999999-12-31T23:59:59.999999999-18:00'. This is the local date-time just before midnight at the end of the maximum date in the minimum offset (larger negative offsets are later on the time-line). This combines &lt;a href=&quot;localdatetime#MAX&quot;&gt;&lt;code&gt;LocalDateTime.MAX&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneoffset#MIN&quot;&gt;&lt;code&gt;ZoneOffset.MIN&lt;/code&gt;&lt;/a&gt;. This could be used by an application as a &quot;far future&quot; date-time.</source>
          <target state="translated">지원되는 최대 &lt;code&gt;OffsetDateTime&lt;/code&gt; , '+ 999999999-12-31T23 : 59 : 59.999999999-18 : 00'. 최소 오프셋의 최대 날짜 끝에서 자정 직전의 현지 날짜-시간입니다 (큰 음의 오프셋은 나중에 타임 라인에 표시됨). &lt;a href=&quot;localdatetime#MAX&quot;&gt; &lt;code&gt;LocalDateTime.MAX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;zoneoffset#MIN&quot;&gt; &lt;code&gt;ZoneOffset.MIN&lt;/code&gt; 을&lt;/a&gt; 결합 합니다. 응용 프로그램에서 &quot;먼 미래&quot;날짜-시간으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6888150958c5e1391109e70e7d9b5a79b259d824" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;OffsetTime&lt;/code&gt;, '23:59:59.999999999-18:00'.</source>
          <target state="translated">The maximum supported &lt;code&gt;OffsetTime&lt;/code&gt; , '23:59:59.999999999-18:00'.</target>
        </trans-unit>
        <trans-unit id="b48f7359abf2b721e4ffc36d002f51c3e787a1e9" translate="yes" xml:space="preserve">
          <source>The maximum supported &lt;code&gt;OffsetTime&lt;/code&gt;, '23:59:59.999999999-18:00'. This is the time just before midnight at the end of the day in the minimum offset (larger negative offsets are later on the time-line). This combines &lt;a href=&quot;localtime#MAX&quot;&gt;&lt;code&gt;LocalTime.MAX&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneoffset#MIN&quot;&gt;&lt;code&gt;ZoneOffset.MIN&lt;/code&gt;&lt;/a&gt;. This could be used by an application as a &quot;far future&quot; date.</source>
          <target state="translated">지원되는 최대 &lt;code&gt;OffsetTime&lt;/code&gt; , '23 : 59 : 59.999999999-18 : 00 ' 최소 오프셋에서 하루가 끝나는 자정 직전의 시간입니다 (큰 음수 오프셋은 나중에 타임 라인에 표시됨). &lt;a href=&quot;localtime#MAX&quot;&gt; &lt;code&gt;LocalTime.MAX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;zoneoffset#MIN&quot;&gt; &lt;code&gt;ZoneOffset.MIN&lt;/code&gt; 을&lt;/a&gt; 결합 합니다. 응용 프로그램에서 &quot;먼 미래&quot;날짜로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db55fe69812e7a35add31fe3f898cbec3f75e877" translate="yes" xml:space="preserve">
          <source>The maximum supported range is from +18:00 to -18:00 inclusive.</source>
          <target state="translated">지원되는 최대 범위는 +18 : 00 ~ -18 : 00입니다.</target>
        </trans-unit>
        <trans-unit id="c0a2c5b8a90ac648ea5c3d32022df7abb7a348b9" translate="yes" xml:space="preserve">
          <source>The maximum supported year, '+999,999,999'.</source>
          <target state="translated">지원되는 최대 연도는 '+999,999,999'입니다.</target>
        </trans-unit>
        <trans-unit id="6076022801aa2a830903e2357ca4ec9a03cb7cb0" translate="yes" xml:space="preserve">
          <source>The maximum value for reserved AWT event IDs.</source>
          <target state="translated">The maximum value for reserved AWT event IDs.</target>
        </trans-unit>
        <trans-unit id="d3911eb56181b40f7a9d04f8fc8a8a683e53707f" translate="yes" xml:space="preserve">
          <source>The maximum value for reserved AWT event IDs. Programs defining their own event IDs should use IDs greater than this value.</source>
          <target state="translated">The maximum value for reserved AWT event IDs. Programs defining their own event IDs should use IDs greater than this value.</target>
        </trans-unit>
        <trans-unit id="edefbb253da2c09881430a08425fc9be7f90b625" translate="yes" xml:space="preserve">
          <source>The maximum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt; Unicode code point&lt;/a&gt;, constant &lt;code&gt;U+10FFFF&lt;/code&gt;.</source>
          <target state="translated">a의 최대 값 &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;유니 코드 코드 포인트&lt;/a&gt; , 상수 &lt;code&gt;U+10FFFF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3a7910bd6efd0e6ebb4dcf27163b29a601e65d6" translate="yes" xml:space="preserve">
          <source>The maximum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt; Unicode high-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDBFF'&lt;/code&gt;.</source>
          <target state="translated">The maximum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt; Unicode high-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDBFF'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9cb824afcd96246aeae16307929222db177a085" translate="yes" xml:space="preserve">
          <source>The maximum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt; Unicode high-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDBFF'&lt;/code&gt;. A high-surrogate is also known as a</source>
          <target state="translated">(A)의 최대 값 &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt;유니 높은 대리 코드 단위&lt;/a&gt; 가 UTF-16 인코딩 상수 &lt;code&gt;'\uDBFF'&lt;/code&gt; . 높은 대리모는</target>
        </trans-unit>
        <trans-unit id="025d23141e8f218e9bdbe40f592e9e91b77c268e" translate="yes" xml:space="preserve">
          <source>The maximum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt; Unicode low-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDFFF'&lt;/code&gt;.</source>
          <target state="translated">The maximum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt; Unicode low-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDFFF'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b33263a788749bdc77ddfac4323c224cdfbe9ba3" translate="yes" xml:space="preserve">
          <source>The maximum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt; Unicode low-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDFFF'&lt;/code&gt;. A low-surrogate is also known as a</source>
          <target state="translated">(A)의 최대 값 &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt;유니 저 대리 코드 단위&lt;/a&gt; 가 UTF-16 인코딩 상수 &lt;code&gt;'\uDFFF'&lt;/code&gt; . 낮은 대리모는</target>
        </trans-unit>
        <trans-unit id="c045d68d1fa274a1e06a8666451440c9dec070cf" translate="yes" xml:space="preserve">
          <source>The maximum value of a &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt; Unicode code point&lt;/a&gt;, constant &lt;code&gt;U+10FFFF&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;유니 코드 코드 포인트&lt;/a&gt; 의 최대 값 , 상수 &lt;code&gt;U+10FFFF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21c3d07ff4ff8c16d8d7f9de237255eeb4fb6fb3" translate="yes" xml:space="preserve">
          <source>The maximum value of a &lt;a href=&quot;https://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt; Unicode high-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDBFF'&lt;/code&gt;.</source>
          <target state="translated">UTF-16 인코딩 의 &lt;a href=&quot;https://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt;유니 코드 상위 대리 코드 단위&lt;/a&gt; 의 최대 값 , 상수 &lt;code&gt;'\uDBFF'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e0c3a570128ba8ead20bbfde7fc4cb87a88a026" translate="yes" xml:space="preserve">
          <source>The maximum value of a &lt;a href=&quot;https://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt; Unicode high-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDBFF'&lt;/code&gt;. A high-surrogate is also known as a</source>
          <target state="translated">UTF-16 인코딩 의 &lt;a href=&quot;https://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt;유니 코드 상위 대리 코드 단위&lt;/a&gt; 의 최대 값 , 상수 &lt;code&gt;'\uDBFF'&lt;/code&gt; . 대리모는 다음과 같이 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d73220b385d1dd8fc0e31c41c52d89e132bfb6c" translate="yes" xml:space="preserve">
          <source>The maximum value of a &lt;a href=&quot;https://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt; Unicode low-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDFFF'&lt;/code&gt;.</source>
          <target state="translated">UTF-16 인코딩 의 &lt;a href=&quot;https://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt;유니 코드 하위 대리 코드 단위&lt;/a&gt; 의 최대 값 , 상수 &lt;code&gt;'\uDFFF'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="276865d2354411e3b518ae41c11b7c2f66480ee9" translate="yes" xml:space="preserve">
          <source>The maximum value of a &lt;a href=&quot;https://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt; Unicode low-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDFFF'&lt;/code&gt;. A low-surrogate is also known as a</source>
          <target state="translated">UTF-16 인코딩 의 &lt;a href=&quot;https://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt;유니 코드 하위 대리 코드 단위&lt;/a&gt; 의 최대 값 , 상수 &lt;code&gt;'\uDFFF'&lt;/code&gt; . 낮은 대리자는</target>
        </trans-unit>
        <trans-unit id="286d3939ee86174adc9c52569b3a684b11bce46b" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode surrogate code unit in the UTF-16 encoding, constant &lt;code&gt;'\uDFFF'&lt;/code&gt;.</source>
          <target state="translated">UTF-16 인코딩에서 상수 &lt;code&gt;'\uDFFF'&lt;/code&gt; 의 유니 코드 대리 코드 단위의 최대 값입니다 .</target>
        </trans-unit>
        <trans-unit id="42573092dce64961f85c6b925d6d388e3545023c" translate="yes" xml:space="preserve">
          <source>The maximum value of the scrollbar is maximum - extent.</source>
          <target state="translated">The maximum value of the scrollbar is maximum - extent.</target>
        </trans-unit>
        <trans-unit id="edc77352916d997bb34783351d83105819113640" translate="yes" xml:space="preserve">
          <source>The maximum value of this object.</source>
          <target state="translated">The maximum value of this object.</target>
        </trans-unit>
        <trans-unit id="859c0a3084b1dd53ea5eaf4aff7fa3428c74b0d2" translate="yes" xml:space="preserve">
          <source>The maximum width of the column.</source>
          <target state="translated">The maximum width of the column.</target>
        </trans-unit>
        <trans-unit id="ed42f003ef90603b5afd30f83e3433a1cdb3cd3e" translate="yes" xml:space="preserve">
          <source>The meaning of the term</source>
          <target state="translated">The meaning of the term</target>
        </trans-unit>
        <trans-unit id="1f4e7db5483a3dd3186cbf249393ad7015cc5aae" translate="yes" xml:space="preserve">
          <source>The means by which a file type detector determines the file type is highly implementation specific. A simple implementation might examine the &lt;em&gt;file extension&lt;/em&gt; (a convention used in some platforms) and map it to a file type. In other cases, the file type may be stored as a file &lt;a href=&quot;../attribute/package-summary&quot;&gt; attribute&lt;/a&gt; or the bytes in a file may be examined to guess its file type.</source>
          <target state="translated">파일 유형 탐지기가 파일 유형을 결정하는 수단은 구현에 따라 다릅니다. 간단한 구현은 &lt;em&gt;파일 확장자&lt;/em&gt; (일부 플랫폼에서 사용되는 규칙)를 검사하여 파일 형식에 매핑 할 수 있습니다. 다른 경우, 파일 유형이 파일 &lt;a href=&quot;../attribute/package-summary&quot;&gt;속성&lt;/a&gt; 으로 저장 되거나 파일 의 바이트가 파일 유형을 추측하기 위해 검사 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4770c800d3e35c0011221e1a554258227b54744" translate="yes" xml:space="preserve">
          <source>The means by which this method determines the file type is highly implementation specific. It may simply examine the file name, it may use a file &lt;a href=&quot;../attribute/package-summary&quot;&gt;attribute&lt;/a&gt;, or it may examines bytes in the file.</source>
          <target state="translated">이 방법으로 파일 형식을 결정하는 방법은 구현에 따라 다릅니다. 단순히 파일 이름을 검사하거나 파일 &lt;a href=&quot;../attribute/package-summary&quot;&gt;속성을&lt;/a&gt; 사용하거나 파일의 바이트를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab45809aa21711bcf5f58537fef1609f4b9533bd" translate="yes" xml:space="preserve">
          <source>The mechanism described here does not apply when the IIOP Remote objects (Stubs or Servers) are created and connected to an ORB manually before being passed to the RMIConnector and RMIConnectorServer.</source>
          <target state="translated">여기에 설명 된 메커니즘은 IIMI 원격 오브젝트 (스텁 또는 서버)가 RMIConnector 및 RMIConnectorServer에 전달되기 전에 ORB에 수동으로 작성되고 연결될 때 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="067d9eb74b05faea94f2c082c19d7e9ed59e0ad6" translate="yes" xml:space="preserve">
          <source>The mechanism for distributing the delta amongst the available columns is provided in a private method in the &lt;code&gt;JTable&lt;/code&gt; class:</source>
          <target state="translated">The mechanism for distributing the delta amongst the available columns is provided in a private method in the &lt;code&gt;JTable&lt;/code&gt; class:</target>
        </trans-unit>
        <trans-unit id="31a160d09d90d413fb94d75322e249dff174488a" translate="yes" xml:space="preserve">
          <source>The mechanism name and DRBG algorithm name are determined by the &lt;a href=&quot;security#getProperty(java.lang.String)&quot;&gt;security property&lt;/a&gt;&lt;code&gt;securerandom.drbg.config&lt;/code&gt;. The default choice is Hash_DRBG with SHA-256.</source>
          <target state="translated">The mechanism name and DRBG algorithm name are determined by the &lt;a href=&quot;security#getProperty(java.lang.String)&quot;&gt;security property&lt;/a&gt; &lt;code&gt;securerandom.drbg.config&lt;/code&gt; . The default choice is Hash_DRBG with SHA-256.</target>
        </trans-unit>
        <trans-unit id="75b2b887cd766344d43dde743abd52969399d0c6" translate="yes" xml:space="preserve">
          <source>The media type, media subtype, and parameter names are converted to lowercase.</source>
          <target state="translated">미디어 유형, 미디어 하위 유형 및 매개 변수 이름은 소문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="81485a662e4b18e73d7e50de595c401a66405a84" translate="yes" xml:space="preserve">
          <source>The media type, media subtype, and parameters are retained, but all comments and whitespace characters are discarded.</source>
          <target state="translated">미디어 유형, 미디어 하위 유형 및 매개 변수는 유지되지만 모든 주석 및 공백 문자는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e5ad857f39773029b21c495f43d83ff907a4db59" translate="yes" xml:space="preserve">
          <source>The medium at the &lt;code&gt;index&lt;/code&gt;th position in the &lt;code&gt;MediaList&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if that is not a valid index.</source>
          <target state="translated">&lt;code&gt;MediaList&lt;/code&gt; 의 &lt;code&gt;index&lt;/code&gt; 번째 위치에있는 매체 또는 유효한 인덱스가 아닌 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fa3363aae7619540e1a0d5268b085d34e5d87f7c" translate="yes" xml:space="preserve">
          <source>The member is &lt;code&gt;protected&lt;/code&gt;&lt;code&gt;static&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt; is &lt;code&gt;public&lt;/code&gt; in a package that the module containing &lt;code&gt;D&lt;/code&gt; exports to at least the module containing &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt; is a subclass of &lt;code&gt;D&lt;/code&gt;.</source>
          <target state="translated">The member is &lt;code&gt;protected&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; , &lt;code&gt;D&lt;/code&gt; is &lt;code&gt;public&lt;/code&gt; in a package that the module containing &lt;code&gt;D&lt;/code&gt; exports to at least the module containing &lt;code&gt;C&lt;/code&gt; , and &lt;code&gt;C&lt;/code&gt; is a subclass of &lt;code&gt;D&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b89410dcffaf7a872471541f99f6678180a6a8a8" translate="yes" xml:space="preserve">
          <source>The member is &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; is &lt;code&gt;public&lt;/code&gt; in a package that the module containing &lt;code&gt;D&lt;/code&gt;&lt;a href=&quot;../module#isExported(java.lang.String,java.lang.Module)&quot;&gt;&lt;code&gt;exports&lt;/code&gt;&lt;/a&gt; to at least the module containing &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">The member is &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; is &lt;code&gt;public&lt;/code&gt; in a package that the module containing &lt;code&gt;D&lt;/code&gt; &lt;a href=&quot;../module#isExported(java.lang.String,java.lang.Module)&quot;&gt; &lt;code&gt;exports&lt;/code&gt; &lt;/a&gt; to at least the module containing &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f97e6177805adf7afc68c7962dee0fa667febf49" translate="yes" xml:space="preserve">
          <source>The membership key</source>
          <target state="translated">멤버쉽 키</target>
        </trans-unit>
        <trans-unit id="0e5fa7adb21c0e325c51267052603c4f999c8037" translate="yes" xml:space="preserve">
          <source>The memory effects for accesses and updates of atomics generally follow the rules for volatiles, as stated in &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4&quot;&gt; The Java Language Specification (17.4 Memory Model)&lt;/a&gt;:</source>
          <target state="translated">원자의 액세스 및 업데이트에 대한 메모리 효과는 일반적으로 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4&quot;&gt;Java 언어 사양 (17.4 메모리 모델)에&lt;/a&gt; 명시된대로 휘발성에 대한 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="63ed54f77a4f5d562e787e9632c7dcd61349acbb" translate="yes" xml:space="preserve">
          <source>The memory segment this address belongs to, or &lt;code&gt;null&lt;/code&gt; if no such segment exists.</source>
          <target state="translated">이 주소가 속한 메모리 세그먼트 또는 해당 세그먼트가 &lt;code&gt;null&lt;/code&gt; 경우 null 입니다.</target>
        </trans-unit>
        <trans-unit id="aab7acbfa43834ab7dc033f83c5c606d75b26760" translate="yes" xml:space="preserve">
          <source>The memory system of the Java virtual machine manages the following kinds of memory:</source>
          <target state="translated">Java 가상 머신의 메모리 시스템은 다음과 같은 종류의 메모리를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="27790702c54d1d404915dd82c93b620fa3c28c6a" translate="yes" xml:space="preserve">
          <source>The memory usage can be monitored in three ways:</source>
          <target state="translated">메모리 사용량은 세 가지 방법으로 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d607f7f1ba30cb36c630b3c22647d62e99ce92fd" translate="yes" xml:space="preserve">
          <source>The memory usage monitoring mechanism is intended for load-balancing or workload distribution use. For example, an application would stop receiving any new workload when its memory usage exceeds a certain threshold. It is not intended for an application to detect and recover from a low memory condition.</source>
          <target state="translated">메모리 사용량 모니터링 메커니즘은로드 밸런싱 또는 워크로드 분배 사용을위한 것입니다. 예를 들어, 메모리 사용량이 특정 임계 값을 초과하면 애플리케이션이 새 워크로드 수신을 중지합니다. 응용 프로그램이 메모리 부족 상태를 감지하고 복구하기위한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="093780ce78707d757dc19b614256bc2e6651b1d0" translate="yes" xml:space="preserve">
          <source>The memory usage of the memory pool when the notification was constructed.</source>
          <target state="translated">알림이 구성 될 때 메모리 풀의 메모리 사용량.</target>
        </trans-unit>
        <trans-unit id="f920b80ca0223cf0e98906f5968692215bf83a73" translate="yes" xml:space="preserve">
          <source>The memory usage of the system can be monitored using &lt;a href=&quot;#Polling&quot;&gt;polling&lt;/a&gt; or &lt;a href=&quot;#ThresholdNotification&quot;&gt;threshold notification&lt;/a&gt; mechanisms.</source>
          <target state="translated">&lt;a href=&quot;#Polling&quot;&gt;폴링&lt;/a&gt; 또는 &lt;a href=&quot;#ThresholdNotification&quot;&gt;임계 값 알림&lt;/a&gt; 메커니즘을 사용하여 시스템의 메모리 사용량을 모니터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e5edb0774127d7a66acbb52bd0020f5a0df1d4e" translate="yes" xml:space="preserve">
          <source>The mention of URL in the documentation for this class refers to a URL string as defined by RFC 1738 and its related RFCs. It is any string that conforms to the syntax described therein, and may not always have corresponding support in the java.net.URL class or Web browsers.</source>
          <target state="translated">이 클래스의 문서에서 URL에 대한 언급은 RFC 1738 및 관련 RFC에 의해 정의 된 URL 문자열을 나타냅니다. 문자열은 여기에 설명 된 구문을 준수하며 java.net.URL 클래스 또는 웹 브라우저에서 항상 해당 지원을하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1759cdc52cf9269c6c862c60009301e96c6fba53" translate="yes" xml:space="preserve">
          <source>The menu bar.</source>
          <target state="translated">The menu bar.</target>
        </trans-unit>
        <trans-unit id="ff5d2fb3290b2743475828942fec01b928964169" translate="yes" xml:space="preserve">
          <source>The message consists of not more than &lt;code&gt;125&lt;/code&gt; bytes from the buffer's position to its limit. Upon normal completion of a &lt;code&gt;CompletableFuture&lt;/code&gt; returned from this method the buffer will have no remaining bytes. The buffer must not be accessed until after that.</source>
          <target state="translated">The message consists of not more than &lt;code&gt;125&lt;/code&gt; bytes from the buffer's position to its limit. Upon normal completion of a &lt;code&gt;CompletableFuture&lt;/code&gt; returned from this method the buffer will have no remaining bytes. The buffer must not be accessed until after that.</target>
        </trans-unit>
        <trans-unit id="3019b6df3d7638a94395e6881f48979a9dad4a64" translate="yes" xml:space="preserve">
          <source>The message digest associated with this stream.</source>
          <target state="translated">이 스트림에 관련한 메세지 다이제스트</target>
        </trans-unit>
        <trans-unit id="272751c88e094dd94ddc0eaa4f3a055cdbd2d93b" translate="yes" xml:space="preserve">
          <source>The message is transferred from the byte buffer as if by a regular &lt;a href=&quot;../../../../../java.base/java/nio/channels/writablebytechannel#write(java.nio.ByteBuffer)&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; operation.</source>
          <target state="translated">메시지는 일반 &lt;a href=&quot;../../../../../java.base/java/nio/channels/writablebytechannel#write(java.nio.ByteBuffer)&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; 작업 처럼 바이트 버퍼에서 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="70409d0fa2f61f14b8e11191ac964557890078df" translate="yes" xml:space="preserve">
          <source>The message string is first localized to a format string using the record's ResourceBundle. (If there is no ResourceBundle, or if the message key is not found, then the key is used as the format string.) The format String uses java.text style formatting.</source>
          <target state="translated">메시지 문자열은 먼저 레코드의 ResourceBundle을 사용하여 형식 문자열로 지역화됩니다. (ResourceBundle이 없거나 메시지 키를 찾지 못하면 키가 형식 문자열로 사용됩니다.) 형식 문자열은 java.text 스타일 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1bd240084381979a10006bdb738cc8c1d94c319c" translate="yes" xml:space="preserve">
          <source>The message string of this notification object.</source>
          <target state="translated">이 통지 오브젝트의 메세지 캐릭터 라인</target>
        </trans-unit>
        <trans-unit id="701f16b46c2ce7a14276110cb7af4785b9c2047c" translate="yes" xml:space="preserve">
          <source>The message type determines which icon will be displayed in the caption of the message, and a possible system sound a message may generate upon showing.</source>
          <target state="translated">The message type determines which icon will be displayed in the caption of the message, and a possible system sound a message may generate upon showing.</target>
        </trans-unit>
        <trans-unit id="b54d9c568e6be1f20ad4f6aa93ae581e62015ccb" translate="yes" xml:space="preserve">
          <source>The messages's status byte</source>
          <target state="translated">메시지의 상태 바이트</target>
        </trans-unit>
        <trans-unit id="a72cf44ed0b2379b5bd18fbbfcf576f977b2239c" translate="yes" xml:space="preserve">
          <source>The meta modifier.</source>
          <target state="translated">The meta modifier.</target>
        </trans-unit>
        <trans-unit id="9366f95e074485ed30640a0891257c1b701a3d6e" translate="yes" xml:space="preserve">
          <source>The meta modifier. An indicator that the meta key was held down during the event.</source>
          <target state="translated">The meta modifier. An indicator that the meta key was held down during the event.</target>
        </trans-unit>
        <trans-unit id="a0e34f930595246eb4ac871034e3d19c8c2aa069" translate="yes" xml:space="preserve">
          <source>The meta-data describing the make up of the WebRowSet is described in XML as detailed below. Note both columns are described between the &lt;code&gt;column-definition&lt;/code&gt; tags.</source>
          <target state="translated">The meta-data describing the make up of the WebRowSet is described in XML as detailed below. Note both columns are described between the &lt;code&gt;column-definition&lt;/code&gt; tags.</target>
        </trans-unit>
        <trans-unit id="8d68f77bdf14b55708f4d157fe026ae1c1203526" translate="yes" xml:space="preserve">
          <source>The metadata, including JDBC properties and Synchronization SPI properties, are maintained for future use. It is important that properties such as the &lt;code&gt;command&lt;/code&gt; property be relevant to the originating data source from which this &lt;code&gt;CachedRowSet&lt;/code&gt; object was originally established.</source>
          <target state="translated">The metadata, including JDBC properties and Synchronization SPI properties, are maintained for future use. It is important that properties such as the &lt;code&gt;command&lt;/code&gt; property be relevant to the originating data source from which this &lt;code&gt;CachedRowSet&lt;/code&gt; object was originally established.</target>
        </trans-unit>
        <trans-unit id="5900ffc1a8cc8517558f23fdade036b528a82fc8" translate="yes" xml:space="preserve">
          <source>The metal look and feel implementation of &lt;code&gt;TreeUI&lt;/code&gt;.</source>
          <target state="translated">The metal look and feel implementation of &lt;code&gt;TreeUI&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be84738a01f2fa95124f69a96842b9e168315acd" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;#divide(java.math.BigDecimal,int,java.math.RoundingMode)&quot;&gt;&lt;code&gt;divide(BigDecimal, int, RoundingMode)&lt;/code&gt;&lt;/a&gt; should be used in preference to this legacy method.</source>
          <target state="translated">The method &lt;a href=&quot;#divide(java.math.BigDecimal,int,java.math.RoundingMode)&quot;&gt; &lt;code&gt;divide(BigDecimal, int, RoundingMode)&lt;/code&gt; &lt;/a&gt; should be used in preference to this legacy method.</target>
        </trans-unit>
        <trans-unit id="fb5fe665c934cde2294e893fc3d1feab13203fea" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;#divide(java.math.BigDecimal,java.math.RoundingMode)&quot;&gt;&lt;code&gt;divide(BigDecimal, RoundingMode)&lt;/code&gt;&lt;/a&gt; should be used in preference to this legacy method.</source>
          <target state="translated">The method &lt;a href=&quot;#divide(java.math.BigDecimal,java.math.RoundingMode)&quot;&gt; &lt;code&gt;divide(BigDecimal, RoundingMode)&lt;/code&gt; &lt;/a&gt; should be used in preference to this legacy method.</target>
        </trans-unit>
        <trans-unit id="499c73378695ae873e56bb393dd46618f2de7514" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;#forLanguageTag(java.lang.String)&quot;&gt;&lt;code&gt;forLanguageTag(java.lang.String)&lt;/code&gt;&lt;/a&gt; creates a &lt;code&gt;Locale&lt;/code&gt; object for a well-formed BCP 47 language tag.</source>
          <target state="translated">The method &lt;a href=&quot;#forLanguageTag(java.lang.String)&quot;&gt; &lt;code&gt;forLanguageTag(java.lang.String)&lt;/code&gt; &lt;/a&gt; creates a &lt;code&gt;Locale&lt;/code&gt; object for a well-formed BCP 47 language tag.</target>
        </trans-unit>
        <trans-unit id="9d7a73950a6855c798644b49adc279997126bbed" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;#isDigit(int)&quot;&gt;&lt;code&gt;isDigit(codePoint)&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned.</source>
          <target state="translated">The method &lt;a href=&quot;#isDigit(int)&quot;&gt; &lt;code&gt;isDigit(codePoint)&lt;/code&gt; &lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned.</target>
        </trans-unit>
        <trans-unit id="b60f3cb9831db36f9ceca2a61e181635cf5b7b39" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;#setScale(int,java.math.RoundingMode)&quot;&gt;&lt;code&gt;setScale(int, RoundingMode)&lt;/code&gt;&lt;/a&gt; should be used in preference to this legacy method.</source>
          <target state="translated">The method &lt;a href=&quot;#setScale(int,java.math.RoundingMode)&quot;&gt; &lt;code&gt;setScale(int, RoundingMode)&lt;/code&gt; &lt;/a&gt; should be used in preference to this legacy method.</target>
        </trans-unit>
        <trans-unit id="107e4589942e2891e9ffdd66028ef7c4561dc66d" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../chrono/chronology#from(java.time.temporal.TemporalAccessor)&quot;&gt;&lt;code&gt;Chronology.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;Chronology::from&lt;/code&gt;. That method is equivalent to this query, except that it throws an exception if a chronology cannot be obtained.</source>
          <target state="translated">The method &lt;a href=&quot;../chrono/chronology#from(java.time.temporal.TemporalAccessor)&quot;&gt; &lt;code&gt;Chronology.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;Chronology::from&lt;/code&gt; . That method is equivalent to this query, except that it throws an exception if a chronology cannot be obtained.</target>
        </trans-unit>
        <trans-unit id="d2920b888cd3183590608cb7f05eefbb9147b9fa" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../chrono/chronology#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;Chronology.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;Chronology::from&lt;/code&gt;. That method is equivalent to this query, except that it throws an exception if a chronology cannot be obtained.</source>
          <target state="translated">방법 &lt;a href=&quot;../chrono/chronology#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;Chronology.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; A와 사용될 수 &lt;code&gt;TemporalQuery&lt;/code&gt; 방법 참조 통해 &lt;code&gt;Chronology::from&lt;/code&gt; . 이 방법은 연대기를 얻을 수없는 경우 예외가 발생한다는 점을 제외하고는이 쿼리와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2968320949ff8e3f076ab7282eb5f4f10c500e16" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../zoneid#from(java.time.temporal.TemporalAccessor)&quot;&gt;&lt;code&gt;ZoneId.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;ZoneId::from&lt;/code&gt;. That method is equivalent to this query, except that it throws an exception if a zone cannot be obtained.</source>
          <target state="translated">The method &lt;a href=&quot;../zoneid#from(java.time.temporal.TemporalAccessor)&quot;&gt; &lt;code&gt;ZoneId.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;ZoneId::from&lt;/code&gt; . That method is equivalent to this query, except that it throws an exception if a zone cannot be obtained.</target>
        </trans-unit>
        <trans-unit id="0fadbd5dc81bbd2e66fe9ce72197e29cd159b1e9" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../zoneid#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;ZoneId.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;ZoneId::from&lt;/code&gt;. That method is equivalent to this query, except that it throws an exception if a zone cannot be obtained.</source>
          <target state="translated">방법 &lt;a href=&quot;../zoneid#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;ZoneId.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; A와 사용될 수 &lt;code&gt;TemporalQuery&lt;/code&gt; 방법 참조 통해 &lt;code&gt;ZoneId::from&lt;/code&gt; . 해당 메소드는 영역을 확보 할 수없는 경우 예외를 처리한다는 점을 제외하고이 조회와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8417bab054d7bf1a2e1834915a9ee9f2fada3522" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../zoneoffset#from(java.time.temporal.TemporalAccessor)&quot;&gt;&lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;LocalDate::from&lt;/code&gt;. This query and &lt;code&gt;LocalDate::from&lt;/code&gt; will return the same result if the temporal object contains a date. If the temporal object does not contain a date, then the method reference will throw an exception, whereas this query will return null.</source>
          <target state="translated">The method &lt;a href=&quot;../zoneoffset#from(java.time.temporal.TemporalAccessor)&quot;&gt; &lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;LocalDate::from&lt;/code&gt; . This query and &lt;code&gt;LocalDate::from&lt;/code&gt; will return the same result if the temporal object contains a date. If the temporal object does not contain a date, then the method reference will throw an exception, whereas this query will return null.</target>
        </trans-unit>
        <trans-unit id="7910c769189f0da72816dcd1ec8967ad31ddc5fe" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../zoneoffset#from(java.time.temporal.TemporalAccessor)&quot;&gt;&lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;LocalTime::from&lt;/code&gt;. This query and &lt;code&gt;LocalTime::from&lt;/code&gt; will return the same result if the temporal object contains a time. If the temporal object does not contain a time, then the method reference will throw an exception, whereas this query will return null.</source>
          <target state="translated">The method &lt;a href=&quot;../zoneoffset#from(java.time.temporal.TemporalAccessor)&quot;&gt; &lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;LocalTime::from&lt;/code&gt; . This query and &lt;code&gt;LocalTime::from&lt;/code&gt; will return the same result if the temporal object contains a time. If the temporal object does not contain a time, then the method reference will throw an exception, whereas this query will return null.</target>
        </trans-unit>
        <trans-unit id="7437ff2a2270580f52fdbcaad5f2d8c807f5894a" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../zoneoffset#from(java.time.temporal.TemporalAccessor)&quot;&gt;&lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;ZoneOffset::from&lt;/code&gt;. This query and &lt;code&gt;ZoneOffset::from&lt;/code&gt; will return the same result if the temporal object contains an offset. If the temporal object does not contain an offset, then the method reference will throw an exception, whereas this query will return null.</source>
          <target state="translated">The method &lt;a href=&quot;../zoneoffset#from(java.time.temporal.TemporalAccessor)&quot;&gt; &lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;ZoneOffset::from&lt;/code&gt; . This query and &lt;code&gt;ZoneOffset::from&lt;/code&gt; will return the same result if the temporal object contains an offset. If the temporal object does not contain an offset, then the method reference will throw an exception, whereas this query will return null.</target>
        </trans-unit>
        <trans-unit id="99349278854aaea800ab628dbf65223df309ab09" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../zoneoffset#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;LocalDate::from&lt;/code&gt;. This query and &lt;code&gt;LocalDate::from&lt;/code&gt; will return the same result if the temporal object contains a date. If the temporal object does not contain a date, then the method reference will throw an exception, whereas this query will return null.</source>
          <target state="translated">메서드 &lt;a href=&quot;../zoneoffset#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 는 메서드 참조 &lt;code&gt;LocalDate::from&lt;/code&gt; 통해 &lt;code&gt;TemporalQuery&lt;/code&gt; 로 사용할 수 있습니다 . 이 쿼리와 &lt;code&gt;LocalDate::from&lt;/code&gt; 은 임시 개체에 날짜가 포함 된 경우 동일한 결과를 반환합니다. 시간 객체에 날짜가 포함되어 있지 않으면 메서드 참조에서 예외가 발생하지만이 쿼리는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6936a4796665371bcc6fe68524a9d8cf7935a697" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../zoneoffset#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;LocalTime::from&lt;/code&gt;. This query and &lt;code&gt;LocalTime::from&lt;/code&gt; will return the same result if the temporal object contains a time. If the temporal object does not contain a time, then the method reference will throw an exception, whereas this query will return null.</source>
          <target state="translated">메서드 &lt;a href=&quot;../zoneoffset#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; 는 메서드 참조 &lt;code&gt;LocalTime::from&lt;/code&gt; 통해 &lt;code&gt;TemporalQuery&lt;/code&gt; 로 사용할 수 있습니다 . 이 쿼리와 &lt;code&gt;LocalTime::from&lt;/code&gt; 은 시간 객체에 시간이 포함 된 경우 동일한 결과를 반환합니다. 시간 객체에 시간이 포함되어 있지 않으면 메서드 참조에서 예외가 발생하지만이 쿼리는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="017484d9fd6cdf516726d1ddbd8dc6b63c039d60" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../zoneoffset#from-java.time.temporal.TemporalAccessor-&quot;&gt;&lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt;&lt;/a&gt; can be used as a &lt;code&gt;TemporalQuery&lt;/code&gt; via a method reference, &lt;code&gt;ZoneOffset::from&lt;/code&gt;. This query and &lt;code&gt;ZoneOffset::from&lt;/code&gt; will return the same result if the temporal object contains an offset. If the temporal object does not contain an offset, then the method reference will throw an exception, whereas this query will return null.</source>
          <target state="translated">방법 &lt;a href=&quot;../zoneoffset#from-java.time.temporal.TemporalAccessor-&quot;&gt; &lt;code&gt;ZoneOffset.from(TemporalAccessor)&lt;/code&gt; &lt;/a&gt; A와 사용될 수 &lt;code&gt;TemporalQuery&lt;/code&gt; 방법 참조 통해 &lt;code&gt;ZoneOffset::from&lt;/code&gt; . 이 쿼리와 &lt;code&gt;ZoneOffset::from&lt;/code&gt; 은 임시 객체에 오프셋이 포함 된 경우 동일한 결과를 반환합니다. temporal 객체에 오프셋이 없으면 메서드 참조에서 예외가 발생하지만이 쿼리는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="acbe203a39f1e4dfd332d8350eb660e8d8a90fb4" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;character#isDigit-int-&quot;&gt;&lt;code&gt;isDigit(codePoint)&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned.</source>
          <target state="translated">메소드 &lt;a href=&quot;character#isDigit-int-&quot;&gt; &lt;code&gt;isDigit(codePoint)&lt;/code&gt; &lt;/a&gt; 인 &lt;code&gt;true&lt;/code&gt; 지정된 기수 미만 문자와 문자 (또는 단일 문자의 분해)의 유니 소수점 숫자 값. 이 경우 10 진수 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2581bfa41d0a1a93c4108b866c01432ab81d9ff9" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;locale#forLanguageTag-java.lang.String-&quot;&gt;&lt;code&gt;forLanguageTag(java.lang.String)&lt;/code&gt;&lt;/a&gt; creates a &lt;code&gt;Locale&lt;/code&gt; object for a well-formed BCP 47 language tag.</source>
          <target state="translated">&lt;a href=&quot;locale#forLanguageTag-java.lang.String-&quot;&gt; &lt;code&gt;forLanguageTag(java.lang.String)&lt;/code&gt; &lt;/a&gt; 의 메소드는 올바르게 구성된 BCP 47 언어 태그에 대한 &lt;code&gt;Locale&lt;/code&gt; 오브젝트를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="9b361785e205ed88604c5be102b0eacbc9006ee0" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;system#gc()&quot;&gt;&lt;code&gt;System.gc()&lt;/code&gt;&lt;/a&gt; is the conventional and convenient means of invoking this method.</source>
          <target state="translated">The method &lt;a href=&quot;system#gc()&quot;&gt; &lt;code&gt;System.gc()&lt;/code&gt; &lt;/a&gt; is the conventional and convenient means of invoking this method.</target>
        </trans-unit>
        <trans-unit id="8a7df96b80827737fe37d1466bc469409efb4f5f" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;system#gc--&quot;&gt;&lt;code&gt;System.gc()&lt;/code&gt;&lt;/a&gt; is the conventional and convenient means of invoking this method.</source>
          <target state="translated">&lt;a href=&quot;system#gc--&quot;&gt; &lt;code&gt;System.gc()&lt;/code&gt; &lt;/a&gt; 메소드 는이 메소드를 호출하는 기존의 편리한 수단입니다.</target>
        </trans-unit>
        <trans-unit id="c510bc364df35c448c1d77cdcdbcb5a68cff0b77" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;system#load(java.lang.String)&quot;&gt;&lt;code&gt;System.load(String)&lt;/code&gt;&lt;/a&gt; is the conventional and convenient means of invoking this method.</source>
          <target state="translated">The method &lt;a href=&quot;system#load(java.lang.String)&quot;&gt; &lt;code&gt;System.load(String)&lt;/code&gt; &lt;/a&gt; is the conventional and convenient means of invoking this method.</target>
        </trans-unit>
        <trans-unit id="d67ec53b39aba953770ea5d557a9a19d55511e10" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;system#load-java.lang.String-&quot;&gt;&lt;code&gt;System.load(String)&lt;/code&gt;&lt;/a&gt; is the conventional and convenient means of invoking this method.</source>
          <target state="translated">&lt;a href=&quot;system#load-java.lang.String-&quot;&gt; &lt;code&gt;System.load(String)&lt;/code&gt; &lt;/a&gt; 메소드 는이 메소드를 호출하는 기존의 편리한 수단입니다.</target>
        </trans-unit>
        <trans-unit id="072391e6b57b7fc8b5b4323a60a85fb6ee2592df" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;system#loadLibrary(java.lang.String)&quot;&gt;&lt;code&gt;System.loadLibrary(String)&lt;/code&gt;&lt;/a&gt; is the conventional and convenient means of invoking this method. If native methods are to be used in the implementation of a class, a standard strategy is to put the native code in a library file (call it &lt;code&gt;LibFile&lt;/code&gt;) and then to put a static initializer:</source>
          <target state="translated">The method &lt;a href=&quot;system#loadLibrary(java.lang.String)&quot;&gt; &lt;code&gt;System.loadLibrary(String)&lt;/code&gt; &lt;/a&gt; is the conventional and convenient means of invoking this method. If native methods are to be used in the implementation of a class, a standard strategy is to put the native code in a library file (call it &lt;code&gt;LibFile&lt;/code&gt; ) and then to put a static initializer:</target>
        </trans-unit>
        <trans-unit id="70d78eaa0709f4675ae6dbbcc4cd52c5b6f29b8d" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;system#loadLibrary-java.lang.String-&quot;&gt;&lt;code&gt;System.loadLibrary(String)&lt;/code&gt;&lt;/a&gt; is the conventional and convenient means of invoking this method. If native methods are to be used in the implementation of a class, a standard strategy is to put the native code in a library file (call it &lt;code&gt;LibFile&lt;/code&gt;) and then to put a static initializer:</source>
          <target state="translated">&lt;a href=&quot;system#loadLibrary-java.lang.String-&quot;&gt; &lt;code&gt;System.loadLibrary(String)&lt;/code&gt; &lt;/a&gt; 메소드 는이 메소드를 호출하는 기존의 편리한 수단입니다. 네이티브 메소드가 클래스의 구현에 사용되는 경우 표준 전략은 네이티브 코드를 라이브러리 파일 에 넣고 ( &lt;code&gt;LibFile&lt;/code&gt; 이라고 함 ) 정적 초기화 프로그램을 배치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="943c6a2954f608cf1aa25a52e8e7564f9b86f14f" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;system#runFinalization()&quot;&gt;&lt;code&gt;System.runFinalization()&lt;/code&gt;&lt;/a&gt; is the conventional and convenient means of invoking this method.</source>
          <target state="translated">The method &lt;a href=&quot;system#runFinalization()&quot;&gt; &lt;code&gt;System.runFinalization()&lt;/code&gt; &lt;/a&gt; is the conventional and convenient means of invoking this method.</target>
        </trans-unit>
        <trans-unit id="5effd9dbcb49e11e99f1d710b3ca201a6b6a9939" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;system#runFinalization--&quot;&gt;&lt;code&gt;System.runFinalization()&lt;/code&gt;&lt;/a&gt; is the conventional and convenient means of invoking this method.</source>
          <target state="translated">&lt;a href=&quot;system#runFinalization--&quot;&gt; &lt;code&gt;System.runFinalization()&lt;/code&gt; &lt;/a&gt; 메소드 는이 메소드를 호출하는 기존의 편리한 수단입니다.</target>
        </trans-unit>
        <trans-unit id="b0a8b68af3f04771fc8e7e14e5e1f96e743317be" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;LdapContext.getResponseControls()&lt;/code&gt; is used to retrieve the response controls generated by LDAP operations executed as the result of invoking a &lt;code&gt;Context&lt;/code&gt;/&lt;code&gt;DirContext&lt;/code&gt; operation. The result is all of the responses controls generated by the underlying LDAP operations, including any implicit reconnection. To get only the reconnection response controls, use &lt;code&gt;reconnect()&lt;/code&gt; followed by &lt;code&gt;getResponseControls()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LdapContext.getResponseControls()&lt;/code&gt; 메소드 는 &lt;code&gt;Context&lt;/code&gt; / &lt;code&gt;DirContext&lt;/code&gt; 오퍼레이션 호출 결과로 실행 된 LDAP 오퍼레이션에 의해 생성 된 응답 제어를 검색하는 데 사용됩니다 . 결과는 암시 적 재 연결을 포함하여 기본 LDAP 조작에 의해 생성 된 모든 응답 제어입니다. 재 연결 응답 제어 만 얻으려면 &lt;code&gt;reconnect()&lt;/code&gt; 다음에 &lt;code&gt;getResponseControls()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38efe8e37d65c58afa7204d2c1ff16cacc51ef82" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;ModuleMXBean.getProduct()&lt;/code&gt; defines an attribute called &lt;code&gt;Product&lt;/code&gt;. The Open Type for this attribute is &lt;code&gt;SimpleType.OBJECTNAME&lt;/code&gt;, and the corresponding &lt;code&gt;ObjectName&lt;/code&gt; value will be the name under which the referenced &lt;code&gt;ProductMXBean&lt;/code&gt; is registered in the MBean Server.</source>
          <target state="translated">&lt;code&gt;ModuleMXBean.getProduct()&lt;/code&gt; 메소드 는 &lt;code&gt;Product&lt;/code&gt; 라는 속성을 정의합니다 . 이 속성의 공개 유형은 &lt;code&gt;SimpleType.OBJECTNAME&lt;/code&gt; 이며 해당 &lt;code&gt;ObjectName&lt;/code&gt; 값은 참조 된 &lt;code&gt;ProductMXBean&lt;/code&gt; 이 MBean 서버에 등록 된 이름이됩니다 .</target>
        </trans-unit>
        <trans-unit id="b38a138bc8d2f8b05cf16a6e99bf3172cecefd42" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;acceptChanges&lt;/code&gt; will throw this exception after the writer has finished checking for conflicts and has found one or more conflicts. An application may catch a &lt;code&gt;SyncProviderException&lt;/code&gt; object and call its &lt;code&gt;getSyncResolver&lt;/code&gt; method to get its &lt;code&gt;SyncResolver&lt;/code&gt; object. See the code fragment in the interface comment for &lt;a href=&quot;syncresolver&quot;&gt;&lt;code&gt;SyncResolver&lt;/code&gt;&lt;/a&gt; for an example. This &lt;code&gt;SyncResolver&lt;/code&gt; object will mirror the &lt;code&gt;RowSet&lt;/code&gt; object that generated the exception, except that it will contain only the values from the data source that are in conflict. All other values in the &lt;code&gt;SyncResolver&lt;/code&gt; object will be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">The method &lt;code&gt;acceptChanges&lt;/code&gt; will throw this exception after the writer has finished checking for conflicts and has found one or more conflicts. An application may catch a &lt;code&gt;SyncProviderException&lt;/code&gt; object and call its &lt;code&gt;getSyncResolver&lt;/code&gt; method to get its &lt;code&gt;SyncResolver&lt;/code&gt; object. See the code fragment in the interface comment for &lt;a href=&quot;syncresolver&quot;&gt; &lt;code&gt;SyncResolver&lt;/code&gt; &lt;/a&gt; for an example. This &lt;code&gt;SyncResolver&lt;/code&gt; object will mirror the &lt;code&gt;RowSet&lt;/code&gt; object that generated the exception, except that it will contain only the values from the data source that are in conflict. All other values in the &lt;code&gt;SyncResolver&lt;/code&gt; object will be &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0a8992dddeafc6e212c01d0a03a038c45a92273" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;clone&lt;/code&gt; for class &lt;code&gt;Object&lt;/code&gt; performs a specific cloning operation. First, if the class of this object does not implement the interface &lt;code&gt;Cloneable&lt;/code&gt;, then a &lt;code&gt;CloneNotSupportedException&lt;/code&gt; is thrown. Note that all arrays are considered to implement the interface &lt;code&gt;Cloneable&lt;/code&gt; and that the return type of the &lt;code&gt;clone&lt;/code&gt; method of an array type &lt;code&gt;T[]&lt;/code&gt; is &lt;code&gt;T[]&lt;/code&gt; where T is any reference or primitive type. Otherwise, this method creates a new instance of the class of this object and initializes all its fields with exactly the contents of the corresponding fields of this object, as if by assignment; the contents of the fields are not themselves cloned. Thus, this method performs a &quot;shallow copy&quot; of this object, not a &quot;deep copy&quot; operation.</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 클래스 의 메서드 &lt;code&gt;clone&lt;/code&gt; 은 특정 복제 작업을 수행합니다. 이 객체의 클래스가 인터페이스를 구현하지 않는 경우, 최초로 &lt;code&gt;Cloneable&lt;/code&gt; , 다음 &lt;code&gt;CloneNotSupportedException&lt;/code&gt; 발생합니다. 모든 배열은 &lt;code&gt;Cloneable&lt;/code&gt; 인터페이스를 구현하는 것으로 간주되며 배열 유형 &lt;code&gt;T[]&lt;/code&gt; 의 &lt;code&gt;clone&lt;/code&gt; 메소드의 리턴 유형 은 &lt;code&gt;T[]&lt;/code&gt; 여기서 T는 참조 또는 기본 유형입니다. 그렇지 않은 경우,이 메소드는이 객체의 클래스의 새 인스턴스를 작성하고 할당에 의한 것처럼이 객체의 해당 필드의 내용으로 정확하게 모든 필드를 초기화합니다. 필드의 내용 자체는 복제되지 않습니다. 따라서이 방법은 &quot;깊은 복사&quot;작업이 아니라이 개체의 &quot;얕은 복사&quot;를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d7f8cbf555e81b515ebed5fd01a023f91544a6b4" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;getLastChangedTime&lt;/code&gt; defines an attribute of type &lt;code&gt;long&lt;/code&gt; called &lt;code&gt;LastChangedTime&lt;/code&gt;. This is a read-only attribute, since there is no method &lt;code&gt;setLastChangedTime&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getLastChangedTime&lt;/code&gt; 메소드 는 &lt;code&gt;LastChangedTime&lt;/code&gt; 이라는 &lt;code&gt;long&lt;/code&gt; 유형의 속성을 정의합니다 . &lt;code&gt;setLastChangedTime&lt;/code&gt; 메소드가 없기 때문에 읽기 전용 속성 입니다.</target>
        </trans-unit>
        <trans-unit id="3f5effcf811fba7ae5495c3eae2cda66d7e773a2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;getRowIdLifetime&lt;/code&gt; in the interface &lt;code&gt;DatabaseMetaData&lt;/code&gt;, can be used to determine if a &lt;code&gt;RowId&lt;/code&gt; object remains valid for the duration of the transaction in which the &lt;code&gt;RowId&lt;/code&gt; was created, the duration of the session in which the &lt;code&gt;RowId&lt;/code&gt; was created, or, effectively, for as long as its identified row is not deleted. In addition to specifying the duration of its valid lifetime outside its originating data source, &lt;code&gt;getRowIdLifetime&lt;/code&gt; specifies the duration of a &lt;code&gt;ROWID&lt;/code&gt; value's valid lifetime within its originating data source. In this, it differs from a large object, because there is no limit on the valid lifetime of a large object within its originating data source.</source>
          <target state="translated">The method &lt;code&gt;getRowIdLifetime&lt;/code&gt; in the interface &lt;code&gt;DatabaseMetaData&lt;/code&gt; , can be used to determine if a &lt;code&gt;RowId&lt;/code&gt; object remains valid for the duration of the transaction in which the &lt;code&gt;RowId&lt;/code&gt; was created, the duration of the session in which the &lt;code&gt;RowId&lt;/code&gt; was created, or, effectively, for as long as its identified row is not deleted. In addition to specifying the duration of its valid lifetime outside its originating data source, &lt;code&gt;getRowIdLifetime&lt;/code&gt; specifies the duration of a &lt;code&gt;ROWID&lt;/code&gt; value's valid lifetime within its originating data source. In this, it differs from a large object, because there is no limit on the valid lifetime of a large object within its originating data source.</target>
        </trans-unit>
        <trans-unit id="c3c5b184cc21ee7d95602d090b1e08067e68c2a2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;isDigit&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; of the character and the Unicode decimal digit value of the character (or its single-character decomposition) is less than the specified radix. In this case the decimal digit value is returned.</source>
          <target state="translated">메소드 &lt;code&gt;isDigit&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 지정된 기수 미만 문자와 문자 (또는 단일 문자의 분해)의 유니 소수점 숫자 값. 이 경우 10 진수 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="535bd995faa93342a266284ae4a21196cdfdbc7f" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextBoolean&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by:</source>
          <target state="translated">&lt;code&gt;nextBoolean&lt;/code&gt; 메소드 는 다음 과 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="39aec606639296b0b09aa7ce76c7792db0c9e8d1" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextBytes&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by:</source>
          <target state="translated">&lt;code&gt;nextBytes&lt;/code&gt; 메소드 는 다음 과 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="aa5e2878d870d8e6bb6b3436cc61343f5dff5aef" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextDouble&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by:</source>
          <target state="translated">&lt;code&gt;nextDouble&lt;/code&gt; 메소드 는 다음 과 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="b61e5112029d8cee888287c3757ccf1df1bbebf8" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextFloat&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by:</source>
          <target state="translated">&lt;code&gt;nextFloat&lt;/code&gt; 메소드 는 다음 과 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="52e435482b4a6bf7b9cc5a218513f721c3170375" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextGaussian&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by a threadsafe version of the following:</source>
          <target state="translated">&lt;code&gt;nextGaussian&lt;/code&gt; 메소드 는 다음의 스레드 안전 버전에서와 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="5153d25dbf172da98da0741daa09a59b0ad63eea" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextInt&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by:</source>
          <target state="translated">&lt;code&gt;nextInt&lt;/code&gt; 메소드 는 다음 과 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="8497b578fc5004656d89b7e6983aaffbdc2fbd06" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextLong&lt;/code&gt; is implemented by class &lt;code&gt;Random&lt;/code&gt; as if by:</source>
          <target state="translated">&lt;code&gt;nextLong&lt;/code&gt; 메소드 는 다음 과 같이 &lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="f5762f86bf570324ec0ea338b6232689e3da5ef3" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;nextPage&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; as long as the current page is not the last page of rows and &lt;code&gt;false&lt;/code&gt; when there are no more pages. It can therefore be used in a &lt;code&gt;while&lt;/code&gt; loop to retrieve all of the pages, as is demonstrated in the following lines of code.</source>
          <target state="translated">The method &lt;code&gt;nextPage&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; as long as the current page is not the last page of rows and &lt;code&gt;false&lt;/code&gt; when there are no more pages. It can therefore be used in a &lt;code&gt;while&lt;/code&gt; loop to retrieve all of the pages, as is demonstrated in the following lines of code.</target>
        </trans-unit>
        <trans-unit id="c67214681cb12eb1b4e0da6760e30a88882e1833" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;readObject&lt;/code&gt; is used to read an object from the stream. Java's safe casting should be used to get the desired type. In Java, strings and arrays are objects and are treated as objects during serialization. When read they need to be cast to the expected type.</source>
          <target state="translated">&lt;code&gt;readObject&lt;/code&gt; 메소드 는 스트림에서 객체를 읽는 데 사용됩니다. 원하는 유형을 얻으려면 Java의 안전한 캐스팅을 사용해야합니다. Java에서 문자열 및 배열은 객체이며 직렬화 중에 객체로 처리됩니다. 읽을 때 예상되는 유형으로 캐스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="bc3619ccbd3961713ea835abfe41261f8ad0eba7" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;readSQL&lt;/code&gt; then assigns the data to appropriate fields or elements (of this or other objects). Specifically, it must call the appropriate</source>
          <target state="translated">The method &lt;code&gt;readSQL&lt;/code&gt; then assigns the data to appropriate fields or elements (of this or other objects). Specifically, it must call the appropriate</target>
        </trans-unit>
        <trans-unit id="4459bd46bf4834bc8d1f2a66533eab615320b4ee" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;reset&lt;/code&gt; for class &lt;code&gt;InflaterInputStream&lt;/code&gt; does nothing except throw an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InflaterInputStream&lt;/code&gt; 클래스의 &lt;code&gt;reset&lt;/code&gt; 메소드 는 &lt;code&gt;IOException&lt;/code&gt; 을 던지는 것 외에는 아무것도하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="13e620608483b508819a8c26cd124d1d4afc2a94" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;reset&lt;/code&gt; for class &lt;code&gt;InputStream&lt;/code&gt; does nothing except throw an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InputStream&lt;/code&gt; 클래스의 &lt;code&gt;reset&lt;/code&gt; 메소드 는 &lt;code&gt;IOException&lt;/code&gt; 을 던지는 것 외에는 아무것도하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d0d3bcb4b06a0837cd3dc72144af017482e0c6d5" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;reset&lt;/code&gt; for class &lt;code&gt;PushbackInputStream&lt;/code&gt; does nothing except throw an &lt;code&gt;IOException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PushbackInputStream&lt;/code&gt; 클래스의 &lt;code&gt;reset&lt;/code&gt; 메소드 는 &lt;code&gt;IOException&lt;/code&gt; 을 던지는 것 외에는 아무것도하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f69dcbba5a7b1c0b5dad3540d98ac2d5ae36da0b" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;save&lt;/code&gt; defines an operation called &lt;code&gt;save&lt;/code&gt;. It is not an attribute, since its name does not begin with &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, or &lt;code&gt;is&lt;/code&gt;.</source>
          <target state="translated">방법은 &lt;code&gt;save&lt;/code&gt; 을 정의라는 작업을 &lt;code&gt;save&lt;/code&gt; . 이름이 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;is&lt;/code&gt; 로 시작하지 않으므로 속성이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="4c15f937ab0a49ac7eff467ab6a11aa54f889c23" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;setEchoChar&lt;/code&gt; and &lt;code&gt;getEchoChar&lt;/code&gt; are not provided directly to avoid a new implementation of a pluggable look-and-feel inadvertently exposing password characters. To provide password-like services a separate class &lt;code&gt;JPasswordField&lt;/code&gt; extends &lt;code&gt;JTextField&lt;/code&gt; to provide this service with an independently pluggable look-and-feel.</source>
          <target state="translated">The method &lt;code&gt;setEchoChar&lt;/code&gt; and &lt;code&gt;getEchoChar&lt;/code&gt; are not provided directly to avoid a new implementation of a pluggable look-and-feel inadvertently exposing password characters. To provide password-like services a separate class &lt;code&gt;JPasswordField&lt;/code&gt; extends &lt;code&gt;JTextField&lt;/code&gt; to provide this service with an independently pluggable look-and-feel.</target>
        </trans-unit>
        <trans-unit id="f7a612b5280e2e2c4c2ddcb3ab89ad9acbe42cd1" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;wasNull&lt;/code&gt; is used to determine whether the the last value read was SQL &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">The method &lt;code&gt;wasNull&lt;/code&gt; is used to determine whether the the last value read was SQL &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3ca789241e6d14c3ac15e790f37b9b79ea366c7" translate="yes" xml:space="preserve">
          <source>The method MAY be final.</source>
          <target state="translated">방법은 최종적 일 수있다.</target>
        </trans-unit>
        <trans-unit id="af8fe63e17d04ea68ffd008d010e54db7de4fd6e" translate="yes" xml:space="preserve">
          <source>The method MUST NOT be static except for the application client.</source>
          <target state="translated">이 방법은 응용 프로그램 클라이언트를 제외하고 정적이어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1fe676d9fffea60e7a8f68402d907c0a2c03baa3" translate="yes" xml:space="preserve">
          <source>The method MUST NOT be static.</source>
          <target state="translated">이 방법은 정적이어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="caac4ec314c6a1971b464984c3166dc42073086b" translate="yes" xml:space="preserve">
          <source>The method MUST NOT have any parameters except in the case of interceptors in which case it takes an InvocationContext object as defined by the Interceptors specification.</source>
          <target state="translated">이 메소드는 인터셉터의 경우를 제외하고는 매개 변수를 가져서는 안됩니다.이 경우 인터셉터 스펙에 정의 된대로 InvocationContext 오브젝트를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="89d4ef93ff558b93a6f2123bc37190ee451c78dd" translate="yes" xml:space="preserve">
          <source>The method Object.toString(), Object.hashCode(), or Object.equals(Object), when invoked on a proxy using this invocation handler, is forwarded to the MBean server as a method on the proxied MBean only if it appears in one of the proxy's interfaces. For a proxy created with &lt;a href=&quot;jmx#newMBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)&quot;&gt;&lt;code&gt;JMX.newMBeanProxy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;jmx#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)&quot;&gt;&lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt;&lt;/a&gt;, this means that the method must appear in the Standard MBean or MXBean interface. Otherwise these methods have the following behavior:</source>
          <target state="translated">The method Object.toString(), Object.hashCode(), or Object.equals(Object), when invoked on a proxy using this invocation handler, is forwarded to the MBean server as a method on the proxied MBean only if it appears in one of the proxy's interfaces. For a proxy created with &lt;a href=&quot;jmx#newMBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)&quot;&gt; &lt;code&gt;JMX.newMBeanProxy&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;jmx#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)&quot;&gt; &lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt; &lt;/a&gt;, this means that the method must appear in the Standard MBean or MXBean interface. Otherwise these methods have the following behavior:</target>
        </trans-unit>
        <trans-unit id="5bd74d8dca79474f68b7ace3eb464b4b46924655" translate="yes" xml:space="preserve">
          <source>The method Object.toString(), Object.hashCode(), or Object.equals(Object), when invoked on a proxy using this invocation handler, is forwarded to the MBean server as a method on the proxied MBean only if it appears in one of the proxy's interfaces. For a proxy created with &lt;a href=&quot;jmx#newMBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt;&lt;code&gt;JMX.newMBeanProxy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt;&lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt;&lt;/a&gt;, this means that the method must appear in the Standard MBean or MXBean interface. Otherwise these methods have the following behavior:</source>
          <target state="translated">이 호출 핸들러를 사용하여 프록시에서 호출 될 때 Object.toString (), Object.hashCode () 또는 Object.equals (Object) 메소드는 프록시 MBean에 메소드로 표시되는 경우에만 MBean 서버에 메소드로 전달됩니다. 프록시 인터페이스 중 하나입니다. &lt;a href=&quot;jmx#newMBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt; &lt;code&gt;JMX.newMBeanProxy&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt; &lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt; 로&lt;/a&gt; 작성된 프록시의 경우 이는 메소드가 표준 MBean 또는 MXBean 인터페이스에 나타나야 함을 의미합니다. 그렇지 않으면이 메소드는 다음과 같은 동작을합니다.</target>
        </trans-unit>
        <trans-unit id="bf837832e7854579616fcc0c7961e2c0f8eb7c68" translate="yes" xml:space="preserve">
          <source>The method also makes sure that the key passed in is the same as the one this exemption mechanism used in initializing and generating phases.</source>
          <target state="translated">이 방법은 또한 전달 된 키가 단계를 초기화하고 생성 할 때이 면제 메커니즘과 동일한 키인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a2ebce3cfc3d67e5a06b1146951b4c5544283d64" translate="yes" xml:space="preserve">
          <source>The method area is logically part of the heap but a Java virtual machine implementation may choose not to either garbage collect or compact it. Similar to the heap, the method area may be of a fixed size or may be expanded and shrunk. The memory for the method area does not need to be contiguous.</source>
          <target state="translated">메소드 영역은 논리적으로 힙의 일부이지만 Java 가상 머신 구현은이를 가비지 수집하거나 압축하지 않도록 선택할 수 있습니다. 힙과 유사하게, 방법 영역은 고정 된 크기이거나 확장 및 축소 될 수있다. 메소드 영역의 메모리는 연속적 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d2f787f787f66e4c7fe7596b60f067bd719396f2" translate="yes" xml:space="preserve">
          <source>The method attempts to parse text starting at the index given by &lt;code&gt;pos&lt;/code&gt;. If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed date is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of the character where the error occurred, and null is returned.</source>
          <target state="translated">이 메소드는 &lt;code&gt;pos&lt;/code&gt; 가 제공 한 색인에서 시작하여 텍스트를 구문 분석하려고 시도합니다 . 구문 분석에 성공하면 &lt;code&gt;pos&lt;/code&gt; 색인은 마지막으로 사용한 문자 이후에 색인으로 업데이트되고 (구문 분석이 반드시 문자열 끝까지 모든 문자를 사용할 필요는 없음) 구문 분석 된 날짜가 리턴됩니다. 업데이트 된 &lt;code&gt;pos&lt;/code&gt; 를 사용하여이 메소드에 대한 다음 호출의 시작점을 표시 할 수 있습니다. 에러가 발생하면, 다음의 인덱스 &lt;code&gt;pos&lt;/code&gt; 가 변경되지의 에러 인덱스 &lt;code&gt;pos&lt;/code&gt; 오류가 발생한 문자의 인덱스로 설정되고, null이 리턴된다.</target>
        </trans-unit>
        <trans-unit id="e9294a95741242e43f78e7e3460c9763244cb68c" translate="yes" xml:space="preserve">
          <source>The method attempts to parse text starting at the index given by &lt;code&gt;pos&lt;/code&gt;. If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of the character where the error occurred, and &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">이 메서드는 &lt;code&gt;pos&lt;/code&gt; 로 지정된 인덱스에서 시작하는 텍스트 구문 분석을 시도합니다 . 구문 분석이 성공하면 &lt;code&gt;pos&lt;/code&gt; 의 인덱스가 마지막으로 사용 된 문자 이후의 인덱스로 업데이트되고 (파싱시 문자열 끝까지 모든 문자를 사용할 필요는 없음) 구문 분석 된 숫자가 반환됩니다. 업데이트 된 &lt;code&gt;pos&lt;/code&gt; 는이 메서드에 대한 다음 호출의 시작점을 나타내는 데 사용할 수 있습니다. 에러가 발생하면, 다음의 인덱스 &lt;code&gt;pos&lt;/code&gt; 가 변경되지의 에러 인덱스 &lt;code&gt;pos&lt;/code&gt; 오류가 발생한 문자의 인덱스로 설정되고, &lt;code&gt;null&lt;/code&gt; 반환된다.</target>
        </trans-unit>
        <trans-unit id="bdc63bdbe6175542e0c05d24ad602abe98b3317a" translate="yes" xml:space="preserve">
          <source>The method attempts to parse text starting at the index given by &lt;code&gt;pos&lt;/code&gt;. If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed number is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of the character where the error occurred, and null is returned.</source>
          <target state="translated">이 메소드는 &lt;code&gt;pos&lt;/code&gt; 가 제공 한 색인에서 시작하여 텍스트를 구문 분석하려고 시도합니다 . 구문 분석에 성공하면 &lt;code&gt;pos&lt;/code&gt; 색인은 마지막으로 사용한 문자 다음에 색인으로 업데이트되고 (구문 분석에서 반드시 문자열 끝까지 모든 문자를 사용할 필요는 없음) 구문 분석 된 숫자가 리턴됩니다. 업데이트 된 &lt;code&gt;pos&lt;/code&gt; 를 사용하여이 메소드에 대한 다음 호출의 시작점을 표시 할 수 있습니다. 에러가 발생하면, 다음의 인덱스 &lt;code&gt;pos&lt;/code&gt; 가 변경되지의 에러 인덱스 &lt;code&gt;pos&lt;/code&gt; 오류가 발생한 문자의 인덱스로 설정되고, null이 리턴된다.</target>
        </trans-unit>
        <trans-unit id="755b2d6e0868e85486b4720a3bf6fb663c77e645" translate="yes" xml:space="preserve">
          <source>The method attempts to parse text starting at the index given by &lt;code&gt;pos&lt;/code&gt;. If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed object array is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of the character where the error occurred, and null is returned.</source>
          <target state="translated">이 메소드는 &lt;code&gt;pos&lt;/code&gt; 가 제공 한 색인에서 시작하여 텍스트를 구문 분석하려고 시도합니다 . 해석이 완료하면 (자), 인덱스 &lt;code&gt;pos&lt;/code&gt; (해석에서는 캐릭터 라인의 끝까지의 모든 문자를 사용하지 않습니다) 사용 된 마지막 문자의 뒤의 인덱스에 갱신되어 해석 된 객체 배열이 반환됩니다. 업데이트 된 &lt;code&gt;pos&lt;/code&gt; 를 사용하여이 메소드에 대한 다음 호출의 시작점을 표시 할 수 있습니다. 에러가 발생하면, 다음의 인덱스 &lt;code&gt;pos&lt;/code&gt; 가 변경되지의 에러 인덱스 &lt;code&gt;pos&lt;/code&gt; 오류가 발생한 문자의 인덱스로 설정되고, null이 리턴된다.</target>
        </trans-unit>
        <trans-unit id="728edd8d0c7fa7fe83058e87c898460ae69879c1" translate="yes" xml:space="preserve">
          <source>The method attempts to parse text starting at the index given by &lt;code&gt;pos&lt;/code&gt;. If parsing succeeds, then the index of &lt;code&gt;pos&lt;/code&gt; is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed object is returned. The updated &lt;code&gt;pos&lt;/code&gt; can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of &lt;code&gt;pos&lt;/code&gt; is not changed, the error index of &lt;code&gt;pos&lt;/code&gt; is set to the index of the character where the error occurred, and null is returned.</source>
          <target state="translated">이 메소드는 &lt;code&gt;pos&lt;/code&gt; 가 제공 한 색인에서 시작하여 텍스트를 구문 분석하려고 시도합니다 . 해석이 완료하면 (자), 인덱스 &lt;code&gt;pos&lt;/code&gt; (해석에서는 캐릭터 라인의 끝까지의 모든 문자를 사용하지 않습니다) 사용 된 마지막 문자의 뒤의 인덱스에 갱신되어 해석 된 객체가 돌려 주어집니다. 업데이트 된 &lt;code&gt;pos&lt;/code&gt; 를 사용하여이 메소드에 대한 다음 호출의 시작점을 표시 할 수 있습니다. 에러가 발생하면, 다음의 인덱스 &lt;code&gt;pos&lt;/code&gt; 가 변경되지의 에러 인덱스 &lt;code&gt;pos&lt;/code&gt; 오류가 발생한 문자의 인덱스로 설정되고, null이 리턴된다.</target>
        </trans-unit>
        <trans-unit id="bf4b711f1cdaf392a710511f3f4f04d14590ac67" translate="yes" xml:space="preserve">
          <source>The method changes the geometry-related data. Therefore, the native windowing system may ignore such requests, or it may modify the requested data, so that the &lt;code&gt;JPopupMenu&lt;/code&gt; object is placed and sized in a way that corresponds closely to the desktop settings.</source>
          <target state="translated">The method changes the geometry-related data. Therefore, the native windowing system may ignore such requests, or it may modify the requested data, so that the &lt;code&gt;JPopupMenu&lt;/code&gt; object is placed and sized in a way that corresponds closely to the desktop settings.</target>
        </trans-unit>
        <trans-unit id="96b82a41b3cc128f7bd730255f76a7a83cf6343b" translate="yes" xml:space="preserve">
          <source>The method changes the geometry-related data. Therefore, the native windowing system may ignore such requests, or it may modify the requested data, so that the &lt;code&gt;Window&lt;/code&gt; object is placed and sized in a way that corresponds closely to the desktop settings.</source>
          <target state="translated">The method changes the geometry-related data. Therefore, the native windowing system may ignore such requests, or it may modify the requested data, so that the &lt;code&gt;Window&lt;/code&gt; object is placed and sized in a way that corresponds closely to the desktop settings.</target>
        </trans-unit>
        <trans-unit id="d9a2756aa6193355e7784a53a8731be0aabbdbef" translate="yes" xml:space="preserve">
          <source>The method defined on a non-interceptor class MUST HAVE the following signature:</source>
          <target state="translated">인터셉터가 아닌 클래스에 정의 된 메소드에는 다음 서명이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b7fc31a8c1bb691e0963a145eeb54ea63fdff422" translate="yes" xml:space="preserve">
          <source>The method defined on an interceptor class MUST HAVE one of the following signatures:</source>
          <target state="translated">인터셉터 클래스에 정의 된 메소드에는 다음 서명 중 하나가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d288dedc0be71bcd9f7b6d49e3e7dce97a926418" translate="yes" xml:space="preserve">
          <source>The method does not take steps to guard against the &lt;code&gt;CharSequence&lt;/code&gt; being mutated while parsing.</source>
          <target state="translated">The method does not take steps to guard against the &lt;code&gt;CharSequence&lt;/code&gt; being mutated while parsing.</target>
        </trans-unit>
        <trans-unit id="874cf916c1f10aad774a741a754ad2423996c2b7" translate="yes" xml:space="preserve">
          <source>The method does not treat a backslash character, &lt;code&gt;\&lt;/code&gt;, before a non-valid escape character as an error; the backslash is silently dropped. For example, in a Java string the sequence &lt;code&gt;&quot;\z&quot;&lt;/code&gt; would cause a compile time error. In contrast, this method silently drops the backslash. Therefore, this method treats the two character sequence &lt;code&gt;&quot;\b&quot;&lt;/code&gt; as equivalent to the single character &lt;code&gt;'b'&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 유효하지 않은 이스케이프 문자 앞에 백 슬래시 문자 &lt;code&gt;\&lt;/code&gt; 를 오류로 처리하지 않습니다 . 백 슬래시가 자동으로 삭제됩니다. 예를 들어, Java 문자열에서 &lt;code&gt;&quot;\z&quot;&lt;/code&gt; 시퀀스 는 컴파일 시간 오류를 발생시킵니다. 반대로이 방법은 백 슬래시를 자동으로 삭제합니다. 따라서이 방법은 두 문자 시퀀스 &lt;code&gt;&quot;\b&quot;&lt;/code&gt; 를 단일 문자 &lt;code&gt;'b'&lt;/code&gt; 와 동등한 것으로 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="dff2253dcf2dbdbeb818932622f47c017d711d4d" translate="yes" xml:space="preserve">
          <source>The method does override or implement a method declared in a supertype.</source>
          <target state="translated">이 메소드는 수퍼 타입에 선언 된 메소드를 대체하거나 구현합니다.</target>
        </trans-unit>
        <trans-unit id="de0aebf01d17f688e180aa1f2d8c519be06ac3b0" translate="yes" xml:space="preserve">
          <source>The method does the following (implementations are free to optimized but must do equivalent processing):</source>
          <target state="translated">The method does the following (implementations are free to optimized but must do equivalent processing):</target>
        </trans-unit>
        <trans-unit id="d874850a3069b1faecbf73c1fdbee24f36633207" translate="yes" xml:space="preserve">
          <source>The method handle conversion cannot be made if any one of the required pairwise conversions cannot be made.</source>
          <target state="translated">필요한 페어 와이즈 변환 중 하나를 수행 할 수없는 경우 메소드 핸들 변환을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6801c974c56cb2c89e9773e9f5501edc995c2ac" translate="yes" xml:space="preserve">
          <source>The method handle may throw an &lt;em&gt;undeclared exception&lt;/em&gt;, which means any checked exception (or other checked throwable) not declared by the requested type's single abstract method. If this happens, the throwable will be wrapped in an instance of &lt;a href=&quot;../reflect/undeclaredthrowableexception&quot;&gt;&lt;code&gt;UndeclaredThrowableException&lt;/code&gt;&lt;/a&gt; and thrown in that wrapped form.</source>
          <target state="translated">메소드 핸들은 &lt;em&gt;선언되지 않은 예외를&lt;/em&gt; 던질 수 있는데, 이는 요청 된 유형의 단일 추상 메소드에 의해 선언 &lt;em&gt;되지 않은&lt;/em&gt; 모든 체크 된 예외 (또는 다른 체크 된 &lt;em&gt;예외&lt;/em&gt; )를 의미합니다. 이런 일이 발생하면 Throwable은 &lt;a href=&quot;../reflect/undeclaredthrowableexception&quot;&gt; &lt;code&gt;UndeclaredThrowableException&lt;/code&gt; &lt;/a&gt; 의 인스턴스에 랩핑되고 랩핑 된 폼에 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="041d039fea09ec912b2f7c0f54da21a3bfd1e44b" translate="yes" xml:space="preserve">
          <source>The method has a signature that is override-equivalent to that of any public method declared in &lt;a href=&quot;object&quot;&gt;Object&lt;/a&gt;.</source>
          <target state="translated">이 메소드에는 &lt;a href=&quot;object&quot;&gt;Object에&lt;/a&gt; 선언 된 모든 공개 메소드의 서명과 대체되는 서명이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ed8c6b5045fb72aff03047fce5ebbbafb8db76e" translate="yes" xml:space="preserve">
          <source>The method has no effect and is only left present to avoid introducing a binary incompatibility.</source>
          <target state="translated">이 메서드는 효과가 없으며 바이너리 비 호환성을 피하기 위해 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="82a435b42c8b73e724dcb824f7df83b575fd19be" translate="yes" xml:space="preserve">
          <source>The method invocation will occur in the specified thread. Method invocation can occur only if the specified thread has been suspended by an event which occurred in that thread. Method invocation is not supported when the target VM has been suspended through &lt;a href=&quot;virtualmachine#suspend()&quot;&gt;&lt;code&gt;VirtualMachine.suspend()&lt;/code&gt;&lt;/a&gt; or when the specified thread is suspended through &lt;a href=&quot;threadreference#suspend()&quot;&gt;&lt;code&gt;ThreadReference.suspend()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메서드 호출은 지정된 스레드에서 발생합니다. 메소드 호출은 지정된 스레드가 해당 스레드에서 발생한 이벤트에 의해 일시 중단 된 경우에만 발생할 수 있습니다. 대상 VM이 &lt;a href=&quot;virtualmachine#suspend()&quot;&gt; &lt;code&gt;VirtualMachine.suspend()&lt;/code&gt; &lt;/a&gt; 통해 일시 중단 되었거나 지정된 스레드가 &lt;a href=&quot;threadreference#suspend()&quot;&gt; &lt;code&gt;ThreadReference.suspend()&lt;/code&gt; &lt;/a&gt; 통해 일시 중단 된 경우 메서드 호출이 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="00121123a40bd3cc2c602ed162840173d63b2881" translate="yes" xml:space="preserve">
          <source>The method is called at end of dragging to place the frame in either its original place or in its floating frame.</source>
          <target state="translated">이 메서드는 드래그가 끝날 때 호출되어 프레임을 원래 위치 또는 부동 프레임에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="de35ac2212c0c9582b0146f8df1ba4a720f89ca9" translate="yes" xml:space="preserve">
          <source>The method is only called when the input method is active.</source>
          <target state="translated">이 메서드는 입력 메서드가 활성화 된 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9baa3ede543d5035f46bcd56e3c0863a6c562fb3" translate="yes" xml:space="preserve">
          <source>The method is only called when the input method is inactive.</source>
          <target state="translated">이 메서드는 입력 메서드가 비활성화 된 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cf9754a32ab897b521e9159a73620d72117cb589" translate="yes" xml:space="preserve">
          <source>The method is only called when the input method is inactive. A newly instantiated input method is assumed to be inactive.</source>
          <target state="translated">이 메서드는 입력 메서드가 비활성화 된 경우에만 호출됩니다. 새로 인스턴스화 된 입력 방법은 비활성 상태로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad284914c9aa89e7c3697bae4da03ceba60b4f8" translate="yes" xml:space="preserve">
          <source>The method is only called when the input method is inactive. No method of this interface is called on this instance after dispose.</source>
          <target state="translated">이 메서드는 입력 메서드가 비활성화 된 경우에만 호출됩니다. 처리 후이 인스턴스에서이 인터페이스의 메서드가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8988a6bf12069b0fac6f427bbfce01c5e069e820" translate="yes" xml:space="preserve">
          <source>The method is overridden to take into account caret width.</source>
          <target state="translated">이 메서드는 캐럿 너비를 고려하여 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="623ed9d67cf1fb8a617d106f69d4d42cdce1cab5" translate="yes" xml:space="preserve">
          <source>The method is used to drag &lt;code&gt;DragWindow&lt;/code&gt; during the &lt;code&gt;JToolBar&lt;/code&gt; is being dragged.</source>
          <target state="translated">이 메서드는 &lt;code&gt;JToolBar&lt;/code&gt; 가 드래그 &lt;code&gt;DragWindow&lt;/code&gt; 동안 DragWindow 를 드래그하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7616838d561dfc62e3dd4e5cdb730d2042aaf10e" translate="yes" xml:space="preserve">
          <source>The method makes a best effort attempt to close all opened files, by catching &lt;a href=&quot;../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;s internally. Unchecked exceptions and errors are not caught. Calling close on an already closed loader has no effect.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 을&lt;/a&gt; 내부적 으로 포착하여 열려있는 모든 파일을 닫으려고 최선을 다합니다 . 확인되지 않은 예외 및 오류는 포착되지 않습니다. 이미 닫힌 로더에서 닫기를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="22e6c0f3aab290294b829964017cfbc93840e56c" translate="yes" xml:space="preserve">
          <source>The method may have no visual effect if the Java platform implementation and/or the native system do not support changing the mouse cursor shape.</source>
          <target state="translated">Java 플랫폼 구현 및 / 또는 기본 시스템이 마우스 커서 모양 변경을 지원하지 않는 경우이 메서드는 시각적 효과가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1d97588045b8fdfb47b76675e28ef92cc975e90" translate="yes" xml:space="preserve">
          <source>The method may only be called by the startElement event of the &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; that the application sets to the &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드는 응용 프로그램이 &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; 로&lt;/a&gt; 설정 하는 &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt; 의 startElement 이벤트에 의해서만 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64b19b0029680ec5059b9a2babc8eac7a26ae79d" translate="yes" xml:space="preserve">
          <source>The method may only be called by the startElement event or the endElement event of the &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; that the application sets to the &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드는 응용 프로그램이 &lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; 로&lt;/a&gt; 설정 하는 &lt;a href=&quot;../../../org/xml/sax/contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt; 의 startElement 이벤트 또는 endElement 이벤트에 의해서만 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01f8d9463e6eb038e7275bbee56c959165f19559" translate="yes" xml:space="preserve">
          <source>The method must have the same effect as calling the &lt;code&gt;setBindings&lt;/code&gt; method of &lt;code&gt;ScriptContext&lt;/code&gt; with the corresponding value of &lt;code&gt;scope&lt;/code&gt; on the default &lt;code&gt;ScriptContext&lt;/code&gt; of the &lt;code&gt;ScriptEngine&lt;/code&gt;.</source>
          <target state="translated">이 방법은 호출과 같은 효과가 있어야 &lt;code&gt;setBindings&lt;/code&gt; 의 방법 &lt;code&gt;ScriptContext&lt;/code&gt; 의 대응하는 값 &lt;code&gt;scope&lt;/code&gt; 의 기본에 &lt;code&gt;ScriptContext&lt;/code&gt; 의 &lt;code&gt;ScriptEngine&lt;/code&gt; 를 검색 .</target>
        </trans-unit>
        <trans-unit id="b61a4c76b41fb31fb418cddaaa8ae04229303a5b" translate="yes" xml:space="preserve">
          <source>The method names &quot;get&quot; and &quot;set&quot; defined in the &lt;a href=&quot;../../../java.base/java/util/list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface may also be applied to array instances, mapping to the static methods of the same name in the &lt;code&gt;Array&lt;/code&gt; class.</source>
          <target state="translated">&lt;a href=&quot;../../../java.base/java/util/list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스에 정의 된 메서드 이름 &quot;get&quot;및 &quot;set&quot; 은 &lt;code&gt;Array&lt;/code&gt; 클래스 에있는 동일한 이름의 정적 메서드에 매핑되는 배열 인스턴스에도 적용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15a01b8573f438dbb644e46e679a12309fb238bb" translate="yes" xml:space="preserve">
          <source>The method names &quot;get&quot; and &quot;set&quot; defined in the &lt;a href=&quot;../util/list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; interface may also be applied to array instances, mapping to the static methods of the same name in the &lt;code&gt;Array&lt;/code&gt; class.</source>
          <target state="translated">&lt;a href=&quot;../util/list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 인터페이스에 정의 된 메소드 이름 &quot;get&quot;및 &quot;set&quot; 도 Array 인스턴스에 적용되어 &lt;code&gt;Array&lt;/code&gt; 클래스 에서 동일한 이름의 정적 메소드에 맵핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="31ea5c5f1f94c274b3d01eb1641bbe42804b8496" translate="yes" xml:space="preserve">
          <source>The method on which PostConstruct is applied MAY be public, protected, package private or private.</source>
          <target state="translated">PostConstruct가 적용되는 방법은 public, protected, package private 또는 private 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9d54155e020311194231f7107f4623669daac2c" translate="yes" xml:space="preserve">
          <source>The method on which PreDestroy is applied MAY be public, protected, package private or private.</source>
          <target state="translated">PreDestroy가 적용되는 방법은 public, protected, package private 또는 private 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a301ae939450f1e25dc09421c4085bcfd77c3e36" translate="yes" xml:space="preserve">
          <source>The method retrieves the source and destination band setting arrays from param using the &lt;code&gt;getSourceBands&lt;/code&gt; and &lt;code&gt;getDestinationBands&lt;/code&gt; methods (or considers them to be &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;param&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;). If the source band setting array is &lt;code&gt;null&lt;/code&gt;, it is considered to be equal to the array &lt;code&gt;{ 0, 1, ..., numSrcBands - 1 }&lt;/code&gt;, and similarly for the destination band setting array.</source>
          <target state="translated">이 메서드는 &lt;code&gt;getSourceBands&lt;/code&gt; 및 &lt;code&gt;getDestinationBands&lt;/code&gt; 메서드를 사용하여 param에서 소스 및 대상 밴드 설정 배열을 검색합니다 (또는 &lt;code&gt;param&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우 &lt;code&gt;null&lt;/code&gt; 로 간주 ). 소스 밴드 설정 배열이 &lt;code&gt;null&lt;/code&gt; 이면 배열 &lt;code&gt;{ 0, 1, ..., numSrcBands - 1 }&lt;/code&gt; 와 동일한 것으로 간주되며 대상 밴드 설정 배열도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="ca55322435324027e26d48fb8b856f2cd4798e10" translate="yes" xml:space="preserve">
          <source>The method retrieves the source and destination band setting arrays from param using the &lt;code&gt;getSourceBands&lt;/code&gt; and &lt;code&gt;getDestinationBands&lt;/code&gt;methods (or considers them to be &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;param&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;). If the source band setting array is &lt;code&gt;null&lt;/code&gt;, it is considered to be equal to the array &lt;code&gt;{ 0, 1, ..., numSrcBands - 1 }&lt;/code&gt;, and similarly for the destination band setting array.</source>
          <target state="translated">이 메소드는 &lt;code&gt;getSourceBands&lt;/code&gt; 및 &lt;code&gt;getDestinationBands&lt;/code&gt; 메소드를 사용하여 param에서 소스 및 대상 밴드 설정 배열을 검색합니다 (또는 &lt;code&gt;param&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우 &lt;code&gt;null&lt;/code&gt; 간주 ). 소스 대역 설정 배열이 &lt;code&gt;null&lt;/code&gt; 인 경우, 배열 &lt;code&gt;{ 0, 1, ..., numSrcBands - 1 }&lt;/code&gt; 와 같고 대상 대역 설정 배열 과 동일하게 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="eedb75f6270c3f56b8d300605906d86bfe0698fe" translate="yes" xml:space="preserve">
          <source>The method returns &lt;code&gt;false&lt;/code&gt; if the background color of the window is not &lt;code&gt;null&lt;/code&gt; and the alpha component of the color is less than &lt;code&gt;1.0f&lt;/code&gt;. The method returns &lt;code&gt;true&lt;/code&gt; otherwise.</source>
          <target state="translated">이 메서드는 창의 배경색이 &lt;code&gt;null&lt;/code&gt; 이 아니고 색상의 알파 구성 요소가 &lt;code&gt;1.0f&lt;/code&gt; 미만이면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 이 메서드는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="ec049c98e4152761fc23d3a62699d89db08b276a" translate="yes" xml:space="preserve">
          <source>The method returns &lt;code&gt;null&lt;/code&gt; for territories that don't have a currency, such as Antarctica.</source>
          <target state="translated">이 방법은 남극 대륙과 같이 통화가없는 영토에 대해서는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ceab077d59c6d554d1d17fd8d17c58c9283f7971" translate="yes" xml:space="preserve">
          <source>The method returns &lt;code&gt;null&lt;/code&gt; if no further fallback search is desired.</source>
          <target state="translated">추가 폴백 검색이 필요하지 않은 경우이 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0c99f16cb456d9d761214c183263d3daa238152b" translate="yes" xml:space="preserve">
          <source>The method returns an estimate of the number of nanoseconds remaining to wait given the supplied &lt;code&gt;nanosTimeout&lt;/code&gt; value upon return, or a value less than or equal to zero if it timed out. This value can be used to determine whether and how long to re-wait in cases where the wait returns but an awaited condition still does not hold. Typical uses of this method take the following form:</source>
          <target state="translated">이 메소드는 반환 시 제공된 &lt;code&gt;nanosTimeout&lt;/code&gt; 값 또는 시간이 초과 된 경우 0보다 작거나 같은 값을 제공 할 때까지 대기하기 위해 남아있는 나노초 수의 추정치를 반환합니다 . 이 값은 대기가 리턴되지만 대기 상태가 여전히 유지되지 않는 경우 대기 대기 시간 및 대기 시간을 판별하는 데 사용할 수 있습니다. 이 방법의 일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22807dd693843414d3166f9d76a4f0ab3b4b4bd9" translate="yes" xml:space="preserve">
          <source>The method returns the sum of the number of bytes that have been pushed back and the value returned by &lt;a href=&quot;filterinputstream#available()&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드는 푸시 백 된 바이트 수와 &lt;a href=&quot;filterinputstream#available()&quot;&gt; &lt;code&gt;available&lt;/code&gt; 에&lt;/a&gt; 의해 반환 된 값의 합계를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="769dd36c2f309466661aec7a75b851fd30f66882" translate="yes" xml:space="preserve">
          <source>The method returns the sum of the number of bytes that have been pushed back and the value returned by &lt;a href=&quot;filterinputstream#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 푸시 된 바이트 수와 &lt;a href=&quot;filterinputstream#available--&quot;&gt; &lt;code&gt;available&lt;/code&gt; 에서&lt;/a&gt; 리턴 한 값의 합계를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="cdb7f255588809397e808115b9458f128071df43" translate="yes" xml:space="preserve">
          <source>The method searches through the system-type entries, including &lt;code&gt;system,
 rewriteSystem, systemSuffix, delegateSystem&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; entries in the current catalog in order to find a match.</source>
          <target state="translated">이 메소드 는 일치하는 항목을 찾기 위해 현재 카탈로그에서 &lt;code&gt;system, rewriteSystem, systemSuffix, delegateSystem&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 항목을 포함한 시스템 유형 항목을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="a2afd8bb1d0a6da6c75a9bebebf50a25ebca3c5c" translate="yes" xml:space="preserve">
          <source>The method searches through the uri-type entries, including &lt;code&gt;uri,
 rewriteURI, uriSuffix, delegateURI&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt; entries in the current catalog in order to find a match.</source>
          <target state="translated">이 메소드 는 일치하는 항목을 찾기 위해 현재 카탈로그의 &lt;code&gt;uri, rewriteURI, uriSuffix, delegateURI&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 항목을 포함한 uri 유형 항목을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="216d790277e9b6cd604727689d5fc6d453f43302" translate="yes" xml:space="preserve">
          <source>The method should throw an exception if it is unable to process the error, or if it wishes execution to terminate immediately. The processor will not necessarily honor this request.</source>
          <target state="translated">메서드는 오류를 처리 할 수 ​​없거나 실행이 즉시 종료되기를 원하는 경우 예외를 throw해야합니다. 프로세서는이 요청을 반드시 준수하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe250e939b7e7db52403a1ef648db2140b1af77b" translate="yes" xml:space="preserve">
          <source>The method signature is of the form &lt;code&gt;(CT1 ct1, ..., CTn ctn)T&lt;/code&gt;.</source>
          <target state="translated">메서드 서명은 &lt;code&gt;(CT1 ct1, ..., CTn ctn)T&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aa6f42c80d224cda0b2c792cf80e5a6075e4aad7" translate="yes" xml:space="preserve">
          <source>The method signature is of the form &lt;code&gt;(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T&lt;/code&gt;.</source>
          <target state="translated">메서드 시그니처는 &lt;code&gt;(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)T&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a36d7c4d09bc50d171503ce472f931372ba7ea8d" translate="yes" xml:space="preserve">
          <source>The method signature is of the form &lt;code&gt;(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean&lt;/code&gt;.</source>
          <target state="translated">메서드 서명은 &lt;code&gt;(CT1 ct1, ..., CTn ctn, T expectedValue, T newValue)boolean&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7899a3c45aee2a63be58f43fb7507deaf14b7d4d" translate="yes" xml:space="preserve">
          <source>The method signature is of the form &lt;code&gt;(CT1 ct1, ..., CTn ctn, T mask)T&lt;/code&gt;.</source>
          <target state="translated">메서드 시그니처는 &lt;code&gt;(CT1 ct1, ..., CTn ctn, T mask)T&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="39f1f090ab5791c96af8aef06404b250428d15f5" translate="yes" xml:space="preserve">
          <source>The method signature is of the form &lt;code&gt;(CT1 ct1, ..., CTn ctn, T newValue)T&lt;/code&gt;.</source>
          <target state="translated">메서드 서명은 &lt;code&gt;(CT1 ct1, ..., CTn ctn, T newValue)T&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b6f5c80e4e9cd2bac2c511593356bcb08dd77cd9" translate="yes" xml:space="preserve">
          <source>The method signature is of the form &lt;code&gt;(CT1 ct1, ..., CTn ctn, T newValue)void&lt;/code&gt;</source>
          <target state="translated">메서드 시그니처는 &lt;code&gt;(CT1 ct1, ..., CTn ctn, T newValue)void&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df0cfa1862f205e9a02308b8b61263f11b297c2b" translate="yes" xml:space="preserve">
          <source>The method signature is of the form &lt;code&gt;(CT1 ct1, ..., CTn ctn, T newValue)void&lt;/code&gt;.</source>
          <target state="translated">메서드 서명은 &lt;code&gt;(CT1 ct1, ..., CTn ctn, T newValue)void&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5802882f01d2ae9f4aa2d6373c5cdb1490dd819f" translate="yes" xml:space="preserve">
          <source>The method signature is of the form &lt;code&gt;(CT1 ct1, ..., CTn ctn, T value)T&lt;/code&gt;.</source>
          <target state="translated">메서드 시그니처는 &lt;code&gt;(CT1 ct1, ..., CTn ctn, T value)T&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a5895c513c19101d431f066651cadee4994a6cd" translate="yes" xml:space="preserve">
          <source>The method that should be used to read an indexed property value. May return null if the property isn't indexed or is write-only.</source>
          <target state="translated">인덱싱 된 속성 값을 읽는 데 사용해야하는 방법입니다. 속성이 색인화되지 않았거나 쓰기 전용 인 경우 null을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b08ff4ef56a4f901d8176c3c9d3e4ffa7c0f0db" translate="yes" xml:space="preserve">
          <source>The method that should be used to read the property value. May return null if the property can't be read.</source>
          <target state="translated">속성 값을 읽는 데 사용해야하는 방법입니다. 속성을 읽을 수없는 경우 null을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27d046710b3e478e214106309178510fcd767174" translate="yes" xml:space="preserve">
          <source>The method that should be used to write an indexed property value. May return null if the property isn't indexed or is read-only.</source>
          <target state="translated">인덱싱 된 속성 값을 쓰는 데 사용해야하는 방법입니다. 속성이 색인화되지 않았거나 읽기 전용 인 경우 null을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="908a1d912ea96d1085e886bbb7a0220276726cc9" translate="yes" xml:space="preserve">
          <source>The method that should be used to write the property value. May return null if the property can't be written.</source>
          <target state="translated">속성 값을 작성하는 데 사용해야하는 방법입니다. 속성을 쓸 수 없으면 null을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f2a6855e5dad9257b6848b559469ffc4f5de113" translate="yes" xml:space="preserve">
          <source>The method then tests that both arrays are equal in length, and that neither array contains a value larger than the largest available band index.</source>
          <target state="translated">그런 다음이 방법은 두 배열의 길이가 같고 어느 배열도 사용 가능한 최대 밴드 인덱스보다 큰 값을 포함하지 않는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="930c767b1d1ebf85cf795f6f392c161b88a6b486" translate="yes" xml:space="preserve">
          <source>The method throws &lt;code&gt;IllegalStateException&lt;/code&gt; if the clipboard is currently unavailable. For example, on some platforms, the system clipboard is unavailable while it is accessed by another application.</source>
          <target state="translated">이 메서드는 클립 보드를 현재 사용할 수없는 경우 &lt;code&gt;IllegalStateException&lt;/code&gt; 을 발생시킵니다. 예를 들어 일부 플랫폼에서는 다른 응용 프로그램에서 액세스하는 동안 시스템 클립 보드를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9895b7a9795b5dbff6546ef043e299781d0fe80d" translate="yes" xml:space="preserve">
          <source>The method to use when painting outside the gradient bounds.</source>
          <target state="translated">그라디언트 경계 외부에 페인팅 할 때 사용하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7763d77a0367fd9e2f4e536ad7b65a7521b0a81c" translate="yes" xml:space="preserve">
          <source>The method type has a &lt;a href=&quot;../constant/methodtypedesc&quot;&gt;&lt;code&gt;nominal descriptor&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;#describeConstable()&quot;&gt;&lt;code&gt;MethodType::describeConstable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메서드 유형에는 &lt;a href=&quot;#describeConstable()&quot;&gt; &lt;code&gt;MethodType::describeConstable&lt;/code&gt; &lt;/a&gt; 의해 반환 된 &lt;a href=&quot;../constant/methodtypedesc&quot;&gt; &lt;code&gt;nominal descriptor&lt;/code&gt; &lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="144fdf820cdab5fd0df5fc91dad88ef53b4d6791" translate="yes" xml:space="preserve">
          <source>The method type has no &lt;a href=&quot;../constant/methodtypedesc&quot;&gt;&lt;code&gt;nominal descriptor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#describeConstable()&quot;&gt;&lt;code&gt;MethodType::describeConstable&lt;/code&gt;&lt;/a&gt; returns an empty optional.</source>
          <target state="translated">이 방법의 유형은 더이없는 &lt;a href=&quot;../constant/methodtypedesc&quot;&gt; &lt;code&gt;nominal descriptor&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;#describeConstable()&quot;&gt; &lt;code&gt;MethodType::describeConstable&lt;/code&gt; &lt;/a&gt; 빈 옵션을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec0804b3da18a61f222951f395dd58dd51623934" translate="yes" xml:space="preserve">
          <source>The method used to access the array of listeners at the event source or null if it doesn't exist.</source>
          <target state="translated">이벤트 소스에서 리스너의 배열에 액세스하는 데 사용되는 메소드이거나 존재하지 않는 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="d1b1e281970d0ec8d5c6cbefb1e926c1a0c3863c" translate="yes" xml:space="preserve">
          <source>The method used to register a listener at the event source.</source>
          <target state="translated">이벤트 소스에서 리스너를 등록하는 데 사용되는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="3cfa4fe325cf93f02d82653b486a7ae683ea287e" translate="yes" xml:space="preserve">
          <source>The method used to remove a listener at the event source.</source>
          <target state="translated">이벤트 소스에서 리스너를 제거하는 데 사용되는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="e4e4789aa1a9f309523b4d903049df53c986ffbe" translate="yes" xml:space="preserve">
          <source>The method which will return early is referred to as the called method. The called method is the current method (as defined by the Frames section in the Java Virtual Machine Specification) for the specified thread at the time this method is called.</source>
          <target state="translated">일찍 반환 될 메서드를 호출 된 메서드라고합니다. 호출 된 메소드는이 메소드가 호출 될 때 지정된 스레드에 대한 현재 메소드 (Java Virtual Machine 사양의 프레임 섹션에 정의 됨)입니다.</target>
        </trans-unit>
        <trans-unit id="2a56f0a297591ec761ffc4464906f2896e34b7f6" translate="yes" xml:space="preserve">
          <source>The method writeObject is used to write an object to the stream. Any object, including Strings and arrays, is written with writeObject. Multiple objects or primitives can be written to the stream. The objects must be read back from the corresponding ObjectInputstream with the same types and in the same order as they were written.</source>
          <target state="translated">writeObject 메소드는 객체를 스트림에 쓰는 데 사용됩니다. 문자열과 배열을 포함한 모든 객체는 writeObject로 작성됩니다. 여러 객체 또는 프리미티브를 스트림에 쓸 수 있습니다. 해당 ObjectInputstream에서 작성된 것과 동일한 유형 및 순서로 오브젝트를 다시 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="41363265c8a4bd05d3a45429d86429e66f37d3cc" translate="yes" xml:space="preserve">
          <source>The methods &lt;a href=&quot;#getInstant()&quot;&gt;&lt;code&gt;getInstant()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#getDateTimeBefore()&quot;&gt;&lt;code&gt;getDateTimeBefore()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#getDateTimeAfter()&quot;&gt;&lt;code&gt;getDateTimeAfter()&lt;/code&gt;&lt;/a&gt; all represent the same instant.</source>
          <target state="translated">&lt;a href=&quot;#getInstant()&quot;&gt; &lt;code&gt;getInstant()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#getDateTimeBefore()&quot;&gt; &lt;code&gt;getDateTimeBefore()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#getDateTimeAfter()&quot;&gt; &lt;code&gt;getDateTimeAfter()&lt;/code&gt; &lt;/a&gt; 메서드 는 모두 동일한 순간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1d2f32a4b9ffbf5e3d66a95c06be2ec95ffc9ed9" translate="yes" xml:space="preserve">
          <source>The methods &lt;a href=&quot;zoneoffsettransition#getInstant--&quot;&gt;&lt;code&gt;getInstant()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;zoneoffsettransition#getDateTimeBefore--&quot;&gt;&lt;code&gt;getDateTimeBefore()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneoffsettransition#getDateTimeAfter--&quot;&gt;&lt;code&gt;getDateTimeAfter()&lt;/code&gt;&lt;/a&gt; all represent the same instant.</source>
          <target state="translated">&lt;a href=&quot;zoneoffsettransition#getInstant--&quot;&gt; &lt;code&gt;getInstant()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;zoneoffsettransition#getDateTimeBefore--&quot;&gt; &lt;code&gt;getDateTimeBefore()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;zoneoffsettransition#getDateTimeAfter--&quot;&gt; &lt;code&gt;getDateTimeAfter()&lt;/code&gt; &lt;/a&gt; 메소드 는 모두 동일한 순간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2fa8e3c1943bf599da02611ada531a6bffa15fa8" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;getCacheSize&lt;/code&gt; and &lt;code&gt;setCacheSize&lt;/code&gt; define a read-write attribute of type &lt;code&gt;int&lt;/code&gt; called &lt;code&gt;CacheSize&lt;/code&gt; (with an initial capital, unlike the JavaBeans convention).</source>
          <target state="translated">&lt;code&gt;getCacheSize&lt;/code&gt; 및 &lt;code&gt;setCacheSize&lt;/code&gt; 메소드 는 JavaBeans 규칙과 달리 초기 대문자를 사용하여 &lt;code&gt;CacheSize&lt;/code&gt; 라는 &lt;code&gt;int&lt;/code&gt; 유형의 읽기-쓰기 속성을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f68f66a9cc678fa78140ffed606a6d1a687876f8" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;invokeExact&lt;/code&gt; and &lt;code&gt;invoke&lt;/code&gt; are declared to throw &lt;a href=&quot;../throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt;, which is to say that there is no static restriction on what a method handle can throw. Since the JVM does not distinguish between checked and unchecked exceptions (other than by their class, of course), there is no particular effect on bytecode shape from ascribing checked exceptions to method handle invocations. But in Java source code, methods which perform method handle calls must either explicitly throw &lt;code&gt;Throwable&lt;/code&gt;, or else must catch all throwables locally, rethrowing only those which are legal in the context, and wrapping ones which are illegal.</source>
          <target state="translated">&lt;code&gt;invokeExact&lt;/code&gt; 및 &lt;code&gt;invoke&lt;/code&gt; 메소드 는 &lt;a href=&quot;../throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; 을 던지도록 선언됩니다 . 즉, 메소드 핸들이 던질 수있는 대상에 대한 정적 제한이 없습니다. JVM은 물론 체크되지 않은 예외와 체크되지 않은 예외를 구분하지 않기 때문에 (확인 된 예외를 확인하는 것부터 메소드 핸들 호출에 이르기까지) 바이트 코드 형태에 특별한 영향은 없습니다. 그러나 Java 소스 코드에서 메소드 핸들 호출을 수행하는 메소드는 명시 적으로 &lt;code&gt;Throwable&lt;/code&gt; 을 발생 시키거나 그렇지 않은 경우 모든 Throwable을 로컬에서 포착하여 컨텍스트에서 올바른 항목 만 다시 던져서 잘못된 항목을 랩해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf14ebb965e886d2951ba293b030b2b06853b999" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;setAsciiStream&lt;/code&gt;, &lt;code&gt;setBinaryStream&lt;/code&gt;, &lt;code&gt;setCharacterStream&lt;/code&gt;, and &lt;code&gt;setUnicodeStream&lt;/code&gt; (which is deprecated, so applications should use &lt;code&gt;getCharacterStream&lt;/code&gt; instead) take three parameters, so for them, the element in the array returned by &lt;code&gt;getParams&lt;/code&gt; is also an array. What is different about these setter methods is that in addition to the information provided by parameters, the array contains one of the &lt;code&gt;BaseRowSet&lt;/code&gt; constants indicating the type of stream being set.</source>
          <target state="translated">이 방법 &lt;code&gt;setAsciiStream&lt;/code&gt; , &lt;code&gt;setBinaryStream&lt;/code&gt; 과 , &lt;code&gt;setCharacterStream&lt;/code&gt; 및 &lt;code&gt;setUnicodeStream&lt;/code&gt; (프로그램 사용해야하므로, 사용되지 &lt;code&gt;getCharacterStream&lt;/code&gt; 를이 세 매개 변수를 대신)이 있으므로 그들에게로 반환 된 배열의 요소 &lt;code&gt;getParams&lt;/code&gt; 또한 배열된다. 이러한 setter 메서드에서 다른 점은 매개 변수에서 제공하는 정보 외에도 배열 에 설정되는 스트림의 유형을 나타내는 &lt;code&gt;BaseRowSet&lt;/code&gt; 상수 중 하나가 포함되어 있다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="f23e34ba9de16e07759fdba49f95969f12bcc468" translate="yes" xml:space="preserve">
          <source>The methods and constants which specify options in this interface are for implementation only. If you're not subclassing SocketImpl or DatagramSocketImpl, &lt;b&gt;you won't use these directly.&lt;/b&gt; There are type-safe methods to get/set each of these options in Socket, ServerSocket, DatagramSocket and MulticastSocket.</source>
          <target state="translated">이 인터페이스에서 옵션을 지정하는 메소드 및 상수는 구현 전용입니다. SocketImpl 또는 DatagramSocketImpl을 서브 클래 싱 &lt;b&gt;하지 않으면 직접 사용하지 않습니다. &lt;/b&gt;Socket, ServerSocket, DatagramSocket 및 MulticastSocket에는 이러한 각 옵션을 가져오고 설정하는 형식 안전 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f4717636bd6cd82ae1347e0ad010ab81ed6937b" translate="yes" xml:space="preserve">
          <source>The methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the &lt;a href=&quot;#loadClass(java.lang.String)&quot;&gt;&lt;code&gt;loadClass&lt;/code&gt;&lt;/a&gt; method of the class loader that originally created the class.</source>
          <target state="translated">클래스 로더에 의해 생성 된 객체의 메서드와 생성자는 다른 클래스를 참조 할 수 있습니다. 참조 된 클래스를 판별하기 위해 Java 가상 머신은 원래 클래스를 생성 한 클래스 로더 의 &lt;a href=&quot;#loadClass(java.lang.String)&quot;&gt; &lt;code&gt;loadClass&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a1c8839f76f0c1cc8a34ad4ed7dc5ee39ef85f5c" translate="yes" xml:space="preserve">
          <source>The methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the &lt;a href=&quot;classloader#loadClass-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;loadClass&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method of the class loader that originally created the class.</source>
          <target state="translated">클래스 로더에 의해 생성 된 객체의 메소드와 생성자는 다른 클래스를 참조 할 수 있습니다. 참조 된 클래스를 판별하기 위해 JVM (Java Virtual Machine)은 원래 클래스를 작성한 클래스 로더 의 &lt;a href=&quot;classloader#loadClass-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;loadClass&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="39c7b8f07a9efbfd307fba62e3dde13e6f8f3ece" translate="yes" xml:space="preserve">
          <source>The methods and data of class &lt;code&gt;Character&lt;/code&gt; are defined by the information in the</source>
          <target state="translated">&lt;code&gt;Character&lt;/code&gt; 클래스의 메소드와 데이터 는 다음의 정보로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e092e659a922c45ad545ffba4e9a01d03812d39f" translate="yes" xml:space="preserve">
          <source>The methods for rendering are:</source>
          <target state="translated">렌더링 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="105b50c3378baf8b8ae12b87ea824df029be9611" translate="yes" xml:space="preserve">
          <source>The methods in an implementation of this interface may only accept &lt;code&gt;DocTree&lt;/code&gt; nodes that have been created by the same implementation.</source>
          <target state="translated">이 인터페이스 구현의 메서드 는 동일한 구현에 의해 생성 된 &lt;code&gt;DocTree&lt;/code&gt; 노드 만 허용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f07d1193469161b64e1d588a574c3d2c16bf0681" translate="yes" xml:space="preserve">
          <source>The methods in the &lt;code&gt;Joinable&lt;/code&gt; interface allow a &lt;code&gt;RowSet&lt;/code&gt; object to set a match column, retrieve a match column, or unset a match column, which is the column upon which an SQL &lt;code&gt;JOIN&lt;/code&gt; can be based. An instance of a class that implements these methods can be added to a &lt;code&gt;JoinRowSet&lt;/code&gt; object to allow an SQL &lt;code&gt;JOIN&lt;/code&gt; relationship to be established.</source>
          <target state="translated">&lt;code&gt;Joinable&lt;/code&gt; 인터페이스 의 메서드를 사용하면 &lt;code&gt;RowSet&lt;/code&gt; 개체가 일치 열을 설정하거나 일치 열을 검색하거나 SQL &lt;code&gt;JOIN&lt;/code&gt; 의 기반이 될 수있는 열인 일치 열을 설정 해제 할 수 있습니다. 이러한 메서드를 구현하는 클래스의 인스턴스를 &lt;code&gt;JoinRowSet&lt;/code&gt; 개체에 추가 하여 SQL &lt;code&gt;JOIN&lt;/code&gt; 관계를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f2b4113e05c3868eafe1fc665c48c2e34550e14" translate="yes" xml:space="preserve">
          <source>The methods in this class all throw a &lt;code&gt;NullPointerException&lt;/code&gt;, if the specified array reference is null, except where noted.</source>
          <target state="translated">지정된 배열 참조가 null 인 경우, 이 클래스의 메소드는 모두 &lt;code&gt;NullPointerException&lt;/code&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="f9b1c1ad7998b39c0048260abd8cc2313f1bb8c1" translate="yes" xml:space="preserve">
          <source>The methods in this class are used by the service provider to construct the bits to send to the LDAP server. Applications typically only deal with the classes that implement this interface, supplying them with any information required for a particular extended operation request. It would then pass such a class as an argument to the &lt;code&gt;LdapContext.extendedOperation()&lt;/code&gt; method for performing the LDAPv3 extended operation.</source>
          <target state="translated">이 클래스의 메소드는 서비스 제공자가 LDAP 서버로 보낼 비트를 구성하는 데 사용됩니다. 응용 프로그램은 일반적으로이 확장 인터페이스를 구현하는 클래스 만 처리하여 특정 확장 작업 요청에 필요한 정보를 제공합니다. 그런 다음 LDAPv3 확장 작업을 수행하기 위해 이러한 클래스를 &lt;code&gt;LdapContext.extendedOperation()&lt;/code&gt; 메서드에 인수로 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="bf8f7e029ac8a3874d50034ad3f38bf2b8cd6257" translate="yes" xml:space="preserve">
          <source>The methods in this class can be used by the application to get low level information about the extended operation response. However, typically, the application will be using methods specific to the class that implements this interface. Such a class should have decoded the BER buffer in the response and should provide methods that allow the user to access that data in the response in a type-safe and friendly manner.</source>
          <target state="translated">이 클래스의 메소드는 애플리케이션이 확장 조작 응답에 대한 저수준 정보를 얻기 위해 사용할 수 있습니다. 그러나 일반적으로 응용 프로그램은이 인터페이스를 구현하는 클래스에 특정한 메서드를 사용합니다. 이러한 클래스는 응답에서 BER 버퍼를 디코딩해야하며 사용자가 형식 안전하고 친숙한 방식으로 응답에서 해당 데이터에 액세스 할 수있는 메소드를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e44b2a0e16d7c476c1e2b813535b71f1d47ccc33" translate="yes" xml:space="preserve">
          <source>The methods in this class may be invoked concurrently by multiple threads in a single JVM without the need for external synchronization, and the results will be equivalent to some serial execution. If this class is used concurrently</source>
          <target state="translated">이 클래스의 메소드는 외부 동기화없이 단일 JVM에서 여러 스레드에 의해 동시에 호출 될 수 있으며 결과는 일부 직렬 실행과 같습니다. 이 클래스를 동시에 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="8c949cf9af8fb443cda22ad746c877480ab2743a" translate="yes" xml:space="preserve">
          <source>The methods in this interface are invoked internally when an application calls the method &lt;code&gt;RowSet.execute&lt;/code&gt;; an application programmer would not use them directly.</source>
          <target state="translated">이 인터페이스의 메서드는 응용 프로그램이 &lt;code&gt;RowSet.execute&lt;/code&gt; 메서드를 호출 할 때 내부적으로 호출됩니다 . 응용 프로그램 프로그래머는 직접 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9bea883b737df934e6a48c16c675c6e0826af4d" translate="yes" xml:space="preserve">
          <source>The methods in this interface can be used by an applet to obtain information about its environment.</source>
          <target state="translated">이 인터페이스의 메소드는 환경에 대한 정보를 얻기 위해 애플릿에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="256f0bfec8af2d80099c39667ba98e0fa83558c6" translate="yes" xml:space="preserve">
          <source>The methods in this interface support identification of objects by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2254.txt&quot;&gt;RFC 2254&lt;/a&gt; search filters.</source>
          <target state="translated">이 인터페이스의 메소드는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2254.txt&quot;&gt;RFC 2254&lt;/a&gt; 검색 필터에 의한 오브젝트 식별을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="296d9467efc7a5261cbfc84c5066d00f65578010" translate="yes" xml:space="preserve">
          <source>The methods in this interface support identification of objects by &lt;a href=&quot;https://www.ietf.org/rfc/rfc2254.txt&quot;&gt;RFC 2254&lt;/a&gt; search filters.</source>
          <target state="translated">이 인터페이스의 메서드는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2254.txt&quot;&gt;RFC 2254&lt;/a&gt; 검색 필터에 의한 개체 식별을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="1f232e016bcfec5180a282093404d0a4a6882d22" translate="yes" xml:space="preserve">
          <source>The methods of all classes in &lt;code&gt;java.util.concurrent&lt;/code&gt; and its subpackages extend these guarantees to higher-level synchronization. In particular:</source>
          <target state="translated">&lt;code&gt;java.util.concurrent&lt;/code&gt; 및 그 서브 패키지 에있는 모든 클래스의 메소드는 이러한 보증을 상위 레벨 동기화로 확장합니다. 특히:</target>
        </trans-unit>
        <trans-unit id="43349f5d728c467be905a586d671bac922ccc74b" translate="yes" xml:space="preserve">
          <source>The methods of class &lt;code&gt;Class&lt;/code&gt; expose many characteristics of a class or interface. Most characteristics are derived from the &lt;code&gt;class&lt;/code&gt; file that the class loader passed to the Java Virtual Machine or from the &lt;code&gt;class&lt;/code&gt; file passed to &lt;code&gt;Lookup::defineClass&lt;/code&gt; or &lt;code&gt;Lookup::defineHiddenClass&lt;/code&gt;. A few characteristics are determined by the class loading environment at run time, such as the module returned by &lt;a href=&quot;#getModule()&quot;&gt;&lt;code&gt;getModule()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Class&lt;/code&gt; 클래스 의 메서드 는 클래스 또는 인터페이스의 많은 특성을 노출합니다. 대부분의 특성은에서 파생 된 &lt;code&gt;class&lt;/code&gt; Java 가상 머신에 또는에서 전달 된 클래스 로더 해당 파일 &lt;code&gt;class&lt;/code&gt; 파일에 전달 &lt;code&gt;Lookup::defineClass&lt;/code&gt; 또는 &lt;code&gt;Lookup::defineHiddenClass&lt;/code&gt; . &lt;a href=&quot;#getModule()&quot;&gt; &lt;code&gt;getModule()&lt;/code&gt; &lt;/a&gt; 반환하는 모듈과 같은 몇 가지 특성은 런타임에 클래스 로딩 환경에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4fbf7ceda94e2ce9605129678bea18869076707d" translate="yes" xml:space="preserve">
          <source>The methods of class &lt;code&gt;Class&lt;/code&gt; expose many characteristics of a class or interface. Most characteristics are derived from the &lt;code&gt;class&lt;/code&gt; file that the class loader passed to the Java Virtual Machine. A few characteristics are determined by the class loading environment at run time, such as the module returned by &lt;a href=&quot;#getModule()&quot;&gt;&lt;code&gt;getModule()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Class&lt;/code&gt; 클래스 의 메서드 는 클래스 또는 인터페이스의 많은 특성을 노출합니다. 대부분의 특성은 클래스 로더가 Java Virtual Machine에 전달한 &lt;code&gt;class&lt;/code&gt; 파일 에서 파생됩니다 . &lt;a href=&quot;#getModule()&quot;&gt; &lt;code&gt;getModule()&lt;/code&gt; &lt;/a&gt; 반환하는 모듈과 같은 몇 가지 특성은 런타임에 클래스 로딩 환경에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c06c4b5c1c725337a3cff2da0da44820e6ab4d3" translate="yes" xml:space="preserve">
          <source>The methods of the &lt;code&gt;Graphics2D&lt;/code&gt; interface that use the outline &lt;code&gt;Shape&lt;/code&gt; returned by a &lt;code&gt;Stroke&lt;/code&gt; object include &lt;code&gt;draw&lt;/code&gt; and any other methods that are implemented in terms of that method, such as &lt;code&gt;drawLine&lt;/code&gt;, &lt;code&gt;drawRect&lt;/code&gt;, &lt;code&gt;drawRoundRect&lt;/code&gt;, &lt;code&gt;drawOval&lt;/code&gt;, &lt;code&gt;drawArc&lt;/code&gt;, &lt;code&gt;drawPolyline&lt;/code&gt;, and &lt;code&gt;drawPolygon&lt;/code&gt;.</source>
          <target state="translated">의 방법 &lt;code&gt;Graphics2D&lt;/code&gt; 윤곽 사용 계면 &lt;code&gt;Shape&lt;/code&gt; a로 복귀 &lt;code&gt;Stroke&lt;/code&gt; 오브젝트에는 &lt;code&gt;draw&lt;/code&gt; 과 같은 그 방법의 관점에서 구현되는 임의의 다른 방법 &lt;code&gt;drawLine&lt;/code&gt; , &lt;code&gt;drawRect&lt;/code&gt; , &lt;code&gt;drawRoundRect&lt;/code&gt; , &lt;code&gt;drawOval&lt;/code&gt; , &lt;code&gt;drawArc&lt;/code&gt; , &lt;code&gt;drawPolyline&lt;/code&gt; 및 &lt;code&gt;drawPolygon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba939efdaf2f5d46e723b15a2f6d210988c9dc6d" translate="yes" xml:space="preserve">
          <source>The methods of this class ( that accept a String header name ), and the &lt;code&gt;Map&lt;/code&gt; returned by the &lt;a href=&quot;#map()&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; method, operate without regard to case when retrieving the header value(s).</source>
          <target state="translated">이 클래스의 메서드 (String 헤더 이름을 허용 함) 및 &lt;a href=&quot;#map()&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 메서드에서 반환 한 &lt;code&gt;Map&lt;/code&gt; 은 헤더 값을 검색 할 때 대소 문자에 관계없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ac66d0aaaacddda7c8628c76f8814b7513844fdf" translate="yes" xml:space="preserve">
          <source>The methods of this class all throw a &lt;code&gt;NullPointerException&lt;/code&gt; if the collections or class objects provided to them are null.</source>
          <target state="translated">제공된 컬렉션 또는 클래스 객체가 null 인 경우이 클래스의 메서드는 모두 &lt;code&gt;NullPointerException&lt;/code&gt; 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b15b6e874e547e9e8ec5c26b9a529230eaf2be38" translate="yes" xml:space="preserve">
          <source>The methods previous() and next() are used for iteration. They return DONE if they would move outside the range from getBeginIndex() to getEndIndex() -1, signaling that the iterator has reached the end of the sequence. DONE is also returned by other methods to indicate that the current index is outside this range.</source>
          <target state="translated">previous () 및 next () 메소드가 반복에 사용됩니다. getBeginIndex ()에서 getEndIndex () -1 범위 밖으로 이동하면 반복자가 시퀀스의 끝에 도달했음을 알리는 DONE을 리턴합니다. 현재 색인이이 범위 밖에 있음을 나타 내기 위해 다른 메소드에 의해 DONE도 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d8a896db782172f2505139879d73b1a7c70dffac" translate="yes" xml:space="preserve">
          <source>The methods related to observing mutations to the document are:</source>
          <target state="translated">문서에 대한 돌연변이 관찰과 관련된 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dcf7ce0d82f3dbedc197b205333a23ce9baeeeb9" translate="yes" xml:space="preserve">
          <source>The methods that accept an &lt;code&gt;int&lt;/code&gt; value support all Unicode characters, including supplementary characters. For example, &lt;code&gt;Character.isLetter(0x2F81A)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; because the code point value represents a letter (a CJK ideograph).</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 값 을 허용하는 메소드는 보충 문자를 포함한 모든 유니 코드 문자를 지원합니다. 예를 들어 코드 포인트 값이 문자 (CJK 표의 문자)를 나타 내기 때문에 &lt;code&gt;Character.isLetter(0x2F81A)&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="0e9f59343b1741d2ad18d4f64373c4897b94448c" translate="yes" xml:space="preserve">
          <source>The methods that create processes may not work well for special processes on certain native platforms, such as native windowing processes, daemon processes, Win16/DOS processes on Microsoft Windows, or shell scripts.</source>
          <target state="translated">프로세스를 작성하는 메소드는 고유 윈도우 프로세스, 디먼 프로세스, Microsoft Windows의 Win16 / DOS 프로세스 또는 쉘 스크립트와 같은 특정 고유 플랫폼의 특수 프로세스에 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71e3777c8c977b532490037689faa12fb9e2e35" translate="yes" xml:space="preserve">
          <source>The methods that only accept a &lt;code&gt;char&lt;/code&gt; value cannot support supplementary characters. They treat &lt;code&gt;char&lt;/code&gt; values from the surrogate ranges as undefined characters. For example, &lt;code&gt;Character.isLetter('\uD840')&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, even though this specific value if followed by any low-surrogate value in a string would represent a letter.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 값만 허용하는 메소드는 보충 문자를 지원할 수 없습니다. 대리 범위의 &lt;code&gt;char&lt;/code&gt; 값을 정의되지 않은 문자로 취급 합니다. 예를 들어, &lt;code&gt;Character.isLetter('\uD840')&lt;/code&gt; 은 문자열에 낮은 대리 값이 오는 경우이 특정 값이 문자를 나타내더라도 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cce05671072ffa768c3e060a4fed0ba60bfcf876" translate="yes" xml:space="preserve">
          <source>The micro-of-day.</source>
          <target state="translated">미세한 날.</target>
        </trans-unit>
        <trans-unit id="012bea3abbd9eec2b60f0cb944c493f58a31a682" translate="yes" xml:space="preserve">
          <source>The micro-of-second.</source>
          <target state="translated">초 단위입니다.</target>
        </trans-unit>
        <trans-unit id="eb2247eaaba02959af49dbd11b3740337dcf42ce" translate="yes" xml:space="preserve">
          <source>The middle input tray in the printer.</source>
          <target state="translated">프린터의 중간 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="32c153e5d584c8cab991115e3522d22d789d047f" translate="yes" xml:space="preserve">
          <source>The milli-of-day.</source>
          <target state="translated">밀리 일.</target>
        </trans-unit>
        <trans-unit id="3b415ac04f1b330955bf35e2afa52b9cb732bd02" translate="yes" xml:space="preserve">
          <source>The milli-of-second.</source>
          <target state="translated">밀리 초</target>
        </trans-unit>
        <trans-unit id="2f6279f49fbee882c0c522be365eba539b886cf5" translate="yes" xml:space="preserve">
          <source>The millis property will be initialized to the current time.</source>
          <target state="translated">millis 속성은 현재 시간으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="7da091c278c4791ecff04eb76ed5827fe4694307" translate="yes" xml:space="preserve">
          <source>The millisecond precision of this &lt;code&gt;XMLGregorianCalendar&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;XMLGregorianCalendar&lt;/code&gt; 의 밀리 초 정밀도입니다 .</target>
        </trans-unit>
        <trans-unit id="6777e9b07e5f7f3af56c4b55dd6d8aed2307bf58" translate="yes" xml:space="preserve">
          <source>The milliseconds to add to UTC to get local time.</source>
          <target state="translated">현지 시간을 얻기 위해 UTC에 추가 할 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="c1888dd3fc2c61164d0f647a31d752f705f37737" translate="yes" xml:space="preserve">
          <source>The minimal number of days in the first week. For example, the ISO-8601 standard counts the first week as needing at least 4 days.</source>
          <target state="translated">첫 주에 최소 일수. 예를 들어, ISO-8601 표준은 첫 주에 최소 4 일이 필요하다고 간주합니다.</target>
        </trans-unit>
        <trans-unit id="b77330297991048617c8dd5d0f00a4b93db8dccb" translate="yes" xml:space="preserve">
          <source>The minimize button text property.</source>
          <target state="translated">최소화 버튼 텍스트 속성입니다.</target>
        </trans-unit>
        <trans-unit id="9802a60df3633c50edae56d461e6ac93844127b9" translate="yes" xml:space="preserve">
          <source>The minimize icon.</source>
          <target state="translated">최소화 아이콘.</target>
        </trans-unit>
        <trans-unit id="a23319c3216e82c5bdfb981d32b492582aa4945e" translate="yes" xml:space="preserve">
          <source>The minimum and maximum number of integer digits are interpreted together:</source>
          <target state="translated">정수의 최소 및 최대 수는 함께 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="35a27b93dda62a013e257da00e049d12ea692fd9" translate="yes" xml:space="preserve">
          <source>The minimum and maximum set methods &quot;correct&quot; the other three properties to accommodate their new value argument. For example setting the model's minimum may change its maximum, value, and extent properties (in that order), to maintain the constraints specified above.</source>
          <target state="translated">최소 및 최대 설정 메서드는 새 값 인수를 수용하기 위해 다른 세 가지 속성을 &quot;수정&quot;합니다. 예를 들어 모델의 최소값을 설정하면 위에 지정된 제약 조건을 유지하기 위해 최대 값, 값 및 범위 속성 (순서대로)이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98f3f783b71e0a20dc1a4555bf0378c8c24abe0d" translate="yes" xml:space="preserve">
          <source>The minimum height of a grid layout is the largest minimum height of all of the components in the container times the number of rows, plus the vertical padding times the number of rows minus one, plus the top and bottom insets of the target container.</source>
          <target state="translated">그리드 레이아웃의 최소 높이는 컨테이너에있는 모든 구성 요소의 가장 큰 최소 높이에 행 수를 곱한 값에 세로 패딩을 곱한 행에 1을 뺀 값에 대상 컨테이너의 상단 및 하단 삽입을 더한 값입니다.</target>
        </trans-unit>
        <trans-unit id="e92f52da3040099a15ede70db9920c3577d612c6" translate="yes" xml:space="preserve">
          <source>The minimum index of a progressive pass to read from the source.</source>
          <target state="translated">소스에서 읽을 점진적 패스의 최소 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="4e8a0a7939184991efd16774d48fcc9a4d9dfcd2" translate="yes" xml:space="preserve">
          <source>The minimum index of a progressive pass to read from the source. By default, the value is set to 0, which indicates that passes starting with the first available pass should be decoded.</source>
          <target state="translated">소스에서 읽을 점진적 패스의 최소 인덱스입니다. 기본적으로이 값은 0으로 설정되며 사용 가능한 첫 번째 패스로 시작하는 패스를 디코딩해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bd51c61096347bad094857c5e008f796178fd8ef" translate="yes" xml:space="preserve">
          <source>The minimum normalized component value.</source>
          <target state="translated">정규화 된 최소 구성 요소 값입니다.</target>
        </trans-unit>
        <trans-unit id="b08e3d0656c9b7803ad29c8b58ae2ace6e4bd253" translate="yes" xml:space="preserve">
          <source>The minimum priority that a thread can have.</source>
          <target state="translated">스레드가 가질 수있는 최소 우선 순위.</target>
        </trans-unit>
        <trans-unit id="cbb5d37dc4d790a9dba2a103cd7fc2ea1af9db2f" translate="yes" xml:space="preserve">
          <source>The minimum radix available for conversion to and from strings.</source>
          <target state="translated">문자열로 /에서 변환 할 수있는 최소 기수입니다.</target>
        </trans-unit>
        <trans-unit id="3077331e7366d18fa715ceb7d901dde04546de29" translate="yes" xml:space="preserve">
          <source>The minimum radix available for conversion to and from strings. The constant value of this field is the smallest value permitted for the radix argument in radix-conversion methods such as the &lt;code&gt;digit&lt;/code&gt; method, the &lt;code&gt;forDigit&lt;/code&gt; method, and the &lt;code&gt;toString&lt;/code&gt; method of class &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">문자열로 /에서 변환 할 수있는 최소 기수입니다. 이 필드의 정수 값은 작은 값이 예로서 기수 변환 메소드 인수 허용이다 &lt;code&gt;digit&lt;/code&gt; 에있어서, 상기 &lt;code&gt;forDigit&lt;/code&gt; 에 있어서, 상기 &lt;code&gt;toString&lt;/code&gt; 클래스의 메소드 &lt;code&gt;Integer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e50f636aa7c810c30c501b99665a939e31839e52" translate="yes" xml:space="preserve">
          <source>The minimum set of methods for layout are:</source>
          <target state="translated">레이아웃에 대한 최소 방법 세트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="205371b94b244af14f6cabf4a44e3cfe8c73e76b" translate="yes" xml:space="preserve">
          <source>The minimum size is the size of the display area plus insets plus the button.</source>
          <target state="translated">최소 크기는 표시 영역의 크기에 삽입과 버튼을 더한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3690b25e2f39160f0f56e905bf68cd8b7e64d3b0" translate="yes" xml:space="preserve">
          <source>The minimum size of a &lt;code&gt;ScrollPane&lt;/code&gt; is the size of the insets plus minimum size of the viewport, plus the scrollpane's viewportBorder insets, plus the minimum size of the visible headers, plus the minimum size of the scrollbars whose displayPolicy isn't NEVER.</source>
          <target state="translated">&lt;code&gt;ScrollPane&lt;/code&gt; 의 최소 ​​크기 는 삽입 크기와 뷰포트의 최소 크기, 스크롤 창의 viewportBorder 삽입, 표시 헤더의 최소 크기, displayPolicy가 NEVER가 아닌 스크롤바의 최소 크기를 더한 것입니다.</target>
        </trans-unit>
        <trans-unit id="57a603d748c9a77c02bf11aba17ef85929085643" translate="yes" xml:space="preserve">
          <source>The minimum size required.</source>
          <target state="translated">필요한 최소 크기입니다.</target>
        </trans-unit>
        <trans-unit id="e2c15b19cbed67ea24b210fb8b543082e37a8941" translate="yes" xml:space="preserve">
          <source>The minimum size required. For a component &lt;code&gt;comp&lt;/code&gt;, this should be equal to either &lt;code&gt;comp.getMinimumSize().width&lt;/code&gt; or &lt;code&gt;comp.getMinimumSize().height&lt;/code&gt;.</source>
          <target state="translated">필요한 최소 크기입니다. &lt;code&gt;comp&lt;/code&gt; 구성 요소의 경우 &lt;code&gt;comp.getMinimumSize().width&lt;/code&gt; 또는 &lt;code&gt;comp.getMinimumSize().height&lt;/code&gt; 중 하나와 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="30de3afa3a18bc7fdf3d3a0b78834fa743a12f3e" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;Instant&lt;/code&gt;, '-1000000000-01-01T00:00Z'.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;Instant&lt;/code&gt; , '-1000000000-01-01T00 : 00Z'.</target>
        </trans-unit>
        <trans-unit id="1079249c31ebba26f6b94e4287d0c29dd8ca364c" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;Instant&lt;/code&gt;, '-1000000000-01-01T00:00Z'. This could be used by an application as a &quot;far past&quot; instant.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;Instant&lt;/code&gt; , '-1000000000-01-01T00 : 00Z'. 응용 프로그램에서 &quot;원거리&quot;순간으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76cfe8db5ea1a8d25819f30c0b8f625bd66ea211" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;LocalDate&lt;/code&gt;, '-999999999-01-01'.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;LocalDate&lt;/code&gt; , '-999999999-01-01'.</target>
        </trans-unit>
        <trans-unit id="5f720ed7cf76100435b3548f72b4aa7a8f78154b" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;LocalDate&lt;/code&gt;, '-999999999-01-01'. This could be used by an application as a &quot;far past&quot; date.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;LocalDate&lt;/code&gt; '-999999999-01-01' 응용 프로그램에서 &quot;과거&quot;날짜로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5a840bd5defdc3c55712bb650b591d7989521bf" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;LocalDateTime&lt;/code&gt;, '-999999999-01-01T00:00:00'.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;LocalDateTime&lt;/code&gt; , '-999999999-01-01T00 : 00 : 00'.</target>
        </trans-unit>
        <trans-unit id="edda553e59b5b183f028875cb568ae44225c29be" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;LocalDateTime&lt;/code&gt;, '-999999999-01-01T00:00:00'. This is the local date-time of midnight at the start of the minimum date. This combines &lt;a href=&quot;localdate#MIN&quot;&gt;&lt;code&gt;LocalDate.MIN&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;localtime#MIN&quot;&gt;&lt;code&gt;LocalTime.MIN&lt;/code&gt;&lt;/a&gt;. This could be used by an application as a &quot;far past&quot; date-time.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;LocalDateTime&lt;/code&gt; , '-999999999-01-01T00 : 00 : 00'. 최소 날짜 시작시 자정의 현지 날짜-시간입니다. &lt;a href=&quot;localdate#MIN&quot;&gt; &lt;code&gt;LocalDate.MIN&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;localtime#MIN&quot;&gt; &lt;code&gt;LocalTime.MIN&lt;/code&gt; 을&lt;/a&gt; 결합 합니다. 응용 프로그램에서 &quot;원거리&quot;날짜-시간으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d7781416650441b8c40b7cf42692976437f71d2" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;LocalTime&lt;/code&gt;, '00:00'.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;LocalTime&lt;/code&gt; , '00 : 00 '.</target>
        </trans-unit>
        <trans-unit id="6de8290bca9f960ba54ce582e866ef778c1c4612" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;LocalTime&lt;/code&gt;, '00:00'. This is the time of midnight at the start of the day.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;LocalTime&lt;/code&gt; '00 : 00 ' 이것은 하루가 시작되는 자정의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="9da8564e7571682085369a996e22e81a2e598909" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;OffsetDateTime&lt;/code&gt;, '-999999999-01-01T00:00:00+18:00'.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;OffsetDateTime&lt;/code&gt; , '-999999999-01-01T00 : 00 : 00 + 18 : 00'.</target>
        </trans-unit>
        <trans-unit id="b3ce16d870d460569b094ad8fc0c1bff37370482" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;OffsetDateTime&lt;/code&gt;, '-999999999-01-01T00:00:00+18:00'. This is the local date-time of midnight at the start of the minimum date in the maximum offset (larger offsets are earlier on the time-line). This combines &lt;a href=&quot;localdatetime#MIN&quot;&gt;&lt;code&gt;LocalDateTime.MIN&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneoffset#MAX&quot;&gt;&lt;code&gt;ZoneOffset.MAX&lt;/code&gt;&lt;/a&gt;. This could be used by an application as a &quot;far past&quot; date-time.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;OffsetDateTime&lt;/code&gt; , '-999999999-01-01T00 : 00 : 00 + 18 : 00'. 최대 오프셋에서 최소 날짜 시작시 자정의 로컬 날짜-시간입니다 (큰 오프셋은 타임 라인에서 더 빠름). &lt;a href=&quot;localdatetime#MIN&quot;&gt; &lt;code&gt;LocalDateTime.MIN&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;zoneoffset#MAX&quot;&gt; &lt;code&gt;ZoneOffset.MAX&lt;/code&gt; 를&lt;/a&gt; 결합 합니다. 응용 프로그램에서 &quot;원거리&quot;날짜-시간으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d5458561eebbfe1a9323f79b1d38494586759f5" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;OffsetTime&lt;/code&gt;, '00:00:00+18:00'.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;OffsetTime&lt;/code&gt; , '00 : 00 : 00 + 18 : 00 '.</target>
        </trans-unit>
        <trans-unit id="ffec1f8e75141092e1bede08d9de5db86a65aee4" translate="yes" xml:space="preserve">
          <source>The minimum supported &lt;code&gt;OffsetTime&lt;/code&gt;, '00:00:00+18:00'. This is the time of midnight at the start of the day in the maximum offset (larger offsets are earlier on the time-line). This combines &lt;a href=&quot;localtime#MIN&quot;&gt;&lt;code&gt;LocalTime.MIN&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zoneoffset#MAX&quot;&gt;&lt;code&gt;ZoneOffset.MAX&lt;/code&gt;&lt;/a&gt;. This could be used by an application as a &quot;far past&quot; date.</source>
          <target state="translated">지원되는 최소 &lt;code&gt;OffsetTime&lt;/code&gt; , '00 : 00 : 00 + 18 : 00 ' 최대 오프셋에서 하루 시작시 자정의 시간입니다 (큰 오프셋은 타임 라인에서 더 빠름). &lt;a href=&quot;localtime#MIN&quot;&gt; &lt;code&gt;LocalTime.MIN&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;zoneoffset#MAX&quot;&gt; &lt;code&gt;ZoneOffset.MAX&lt;/code&gt; 를&lt;/a&gt; 결합 합니다. 응용 프로그램에서 &quot;과거&quot;날짜로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ceea9174f0075d07f9e4c2621111a5f2e242d4a" translate="yes" xml:space="preserve">
          <source>The minimum supported year, '-999,999,999'.</source>
          <target state="translated">지원되는 최소 연도 인 '-999,999,999'입니다.</target>
        </trans-unit>
        <trans-unit id="04b4fe66babc8e1e2a91d1f915c13f553008f5e4" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt; Unicode code point&lt;/a&gt;, constant &lt;code&gt;U+0000&lt;/code&gt;.</source>
          <target state="translated">a의 최소 값 &lt;a href=&quot;http://www.unicode.org/glossary/#code_point&quot;&gt;유니 코드 코드 포인트&lt;/a&gt; , 상수 &lt;code&gt;U+0000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c02d9afb81fad41f1b558fbf31a98f1c4c9ce720" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt; Unicode high-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uD800'&lt;/code&gt;.</source>
          <target state="translated">UTF-16 인코딩 의 &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt;유니 코드 상위 대리 코드 단위&lt;/a&gt; 의 최소값 , 상수 &lt;code&gt;'\uD800'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb8698589d666395f680bde3fffc23eb4f65729" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt; Unicode high-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uD800'&lt;/code&gt;. A high-surrogate is also known as a</source>
          <target state="translated">a의 최소값 &lt;a href=&quot;http://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt;유니 높은 대리 코드 단위&lt;/a&gt; 가 UTF-16 인코딩 상수 &lt;code&gt;'\uD800'&lt;/code&gt; . 높은 대리모는</target>
        </trans-unit>
        <trans-unit id="2d6cf70e24b8b0b8e2bc020ec9be76f98b9683d8" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt; Unicode low-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDC00'&lt;/code&gt;.</source>
          <target state="translated">UTF-16 인코딩 의 &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt;유니 코드 하위 대리 코드 단위&lt;/a&gt; 의 최소값 , 상수 &lt;code&gt;'\uDC00'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9341aef5dc8c567df1ec3d8097f6edae0ce1571d" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt; Unicode low-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDC00'&lt;/code&gt;. A low-surrogate is also known as a</source>
          <target state="translated">UTF-16 인코딩에서 상수 &lt;code&gt;'\uDC00'&lt;/code&gt; 의 &lt;a href=&quot;http://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt;유니 코드 &lt;/a&gt;저서 로 게이트 코드 단위 의 최소값 입니다. 낮은 대리모는</target>
        </trans-unit>
        <trans-unit id="b8ea878708f2a3189c4f60757a5b8113d3717cbd" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;http://www.unicode.org/glossary/#supplementary_code_point&quot;&gt; Unicode supplementary code point&lt;/a&gt;, constant &lt;code&gt;U+10000&lt;/code&gt;.</source>
          <target state="translated">a의 최소 값 &lt;a href=&quot;http://www.unicode.org/glossary/#supplementary_code_point&quot;&gt;유니 코드 보조 코드 포인트&lt;/a&gt; , 상수 &lt;code&gt;U+10000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e926cbbe64c62d106272c2b7ca43a189702f6c32" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt; Unicode code point&lt;/a&gt;, constant &lt;code&gt;U+0000&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.unicode.org/glossary/#code_point&quot;&gt;유니 코드 코드 포인트&lt;/a&gt; 의 최소값 , 상수 &lt;code&gt;U+0000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faa4ac91c4459179683baf22adb4b31650bfe550" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;https://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt; Unicode high-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uD800'&lt;/code&gt;.</source>
          <target state="translated">UTF-16 인코딩 의 &lt;a href=&quot;https://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt;유니 코드 상위 대리 코드 단위&lt;/a&gt; 의 최소값 , 상수 &lt;code&gt;'\uD800'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57dc386afdd8d6614a256ab3cbbedcf695b61f1f" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;https://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt; Unicode high-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uD800'&lt;/code&gt;. A high-surrogate is also known as a</source>
          <target state="translated">UTF-16 인코딩 의 &lt;a href=&quot;https://www.unicode.org/glossary/#high_surrogate_code_unit&quot;&gt;유니 코드 상위 대리 코드 단위&lt;/a&gt; 의 최소값 , 상수 &lt;code&gt;'\uD800'&lt;/code&gt; . 대리모는 다음과 같이 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e950fa9b761488294271924176dae3b26addaa4" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;https://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt; Unicode low-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDC00'&lt;/code&gt;.</source>
          <target state="translated">UTF-16 인코딩 의 &lt;a href=&quot;https://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt;유니 코드 하위 대리 코드 단위&lt;/a&gt; 의 최소값 , 상수 &lt;code&gt;'\uDC00'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07fdfe3a8af50a24bf8c5c1fd38b79373f07e4d9" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;https://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt; Unicode low-surrogate code unit&lt;/a&gt; in the UTF-16 encoding, constant &lt;code&gt;'\uDC00'&lt;/code&gt;. A low-surrogate is also known as a</source>
          <target state="translated">UTF-16 인코딩 의 &lt;a href=&quot;https://www.unicode.org/glossary/#low_surrogate_code_unit&quot;&gt;유니 코드 하위 대리 코드 단위&lt;/a&gt; 의 최소값 , 상수 &lt;code&gt;'\uDC00'&lt;/code&gt; . 낮은 대리자는</target>
        </trans-unit>
        <trans-unit id="7552b5dd74a599165c972dac02dde4630ada40cc" translate="yes" xml:space="preserve">
          <source>The minimum value of a &lt;a href=&quot;https://www.unicode.org/glossary/#supplementary_code_point&quot;&gt; Unicode supplementary code point&lt;/a&gt;, constant &lt;code&gt;U+10000&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.unicode.org/glossary/#supplementary_code_point&quot;&gt;유니 코드 보충 코드 포인트&lt;/a&gt; 의 최소값 , 상수 &lt;code&gt;U+10000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bbc35eee66637501d6257be2b6fdd1c93811164" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode surrogate code unit in the UTF-16 encoding, constant &lt;code&gt;'\uD800'&lt;/code&gt;.</source>
          <target state="translated">UTF-16 인코딩에서 상수 &lt;code&gt;'\uD800'&lt;/code&gt; 의 유니 코드 대리 코드 단위의 최소값 입니다.</target>
        </trans-unit>
        <trans-unit id="5fbe997ada48eff766f7cf7e14e58cec23e70059" translate="yes" xml:space="preserve">
          <source>The minimum value of this object.</source>
          <target state="translated">이 개체의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="95f09a7d9f34d60654550e620dc2ba2c912bf17e" translate="yes" xml:space="preserve">
          <source>The minimum width of a grid layout is the largest minimum width of all of the components in the container times the number of columns, plus the horizontal padding times the number of columns minus one, plus the left and right insets of the target container.</source>
          <target state="translated">그리드 레이아웃의 최소 너비는 컨테이너에있는 모든 구성 요소의 가장 큰 최소 너비에 열 수를 곱한 값에 가로 패딩을 곱한 열 수에서 1을 뺀 값에 대상 컨테이너의 왼쪽 및 오른쪽 삽입을 더한 값입니다.</target>
        </trans-unit>
        <trans-unit id="49fc53a3cdb40d046e3fb5b2728e5af5816b14a9" translate="yes" xml:space="preserve">
          <source>The minimum width of a pane.</source>
          <target state="translated">창의 최소 너비입니다.</target>
        </trans-unit>
        <trans-unit id="f827476283eaf54acaaba5a3b5e6f2d519b9e79c" translate="yes" xml:space="preserve">
          <source>The minimum width of the column.</source>
          <target state="translated">열의 최소 너비입니다.</target>
        </trans-unit>
        <trans-unit id="378c9bb2706a28db8c6368858d19c8a9e15f59df" translate="yes" xml:space="preserve">
          <source>The mininum height of &lt;code&gt;JOptionPane&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JOptionPane&lt;/code&gt; 의 최소 ​​높이입니다 .</target>
        </trans-unit>
        <trans-unit id="a2d014de681dac8e9fa71ad11906b8b9b7ea7a1f" translate="yes" xml:space="preserve">
          <source>The mininum width of &lt;code&gt;JOptionPane&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JOptionPane&lt;/code&gt; 의 최소 ​​너비입니다 .</target>
        </trans-unit>
        <trans-unit id="b71bf0a754c300b6fe868e1fa102af6d640d333b" translate="yes" xml:space="preserve">
          <source>The minor version of the profile.</source>
          <target state="translated">프로필의 부 버전입니다.</target>
        </trans-unit>
        <trans-unit id="b66d25a3bcecafeb8650a51f2ee9c9377ad08d80" translate="yes" xml:space="preserve">
          <source>The minute of hour of this &lt;code&gt;XMLGregorianCalendar&lt;/code&gt;, from 0 to 59.</source>
          <target state="translated">이 &lt;code&gt;XMLGregorianCalendar&lt;/code&gt; 의 분 ( 0부터 59까지)입니다.</target>
        </trans-unit>
        <trans-unit id="667a30120007f381c89db949ed47ebe336fec88a" translate="yes" xml:space="preserve">
          <source>The minute-of-day.</source>
          <target state="translated">분.</target>
        </trans-unit>
        <trans-unit id="bdf3bd78cbbce8ca5c3b8eb81726aefb24544a82" translate="yes" xml:space="preserve">
          <source>The minute-of-hour.</source>
          <target state="translated">시간입니다.</target>
        </trans-unit>
        <trans-unit id="f1d189b35d246e7c047f6472422d44013d4dce72" translate="yes" xml:space="preserve">
          <source>The mirror for a type in the target VM.</source>
          <target state="translated">대상 VM의 유형에 대한 미러입니다.</target>
        </trans-unit>
        <trans-unit id="ae31e21e238c93f98e856c4c163385b9ad10e387" translate="yes" xml:space="preserve">
          <source>The mirror for a type in the target VM. This interface is the root of a type hierarchy encompassing primitive types and reference types.</source>
          <target state="translated">대상 VM의 유형에 대한 미러입니다. 이 인터페이스는 기본 유형 및 참조 유형을 포함하는 유형 계층의 루트입니다.</target>
        </trans-unit>
        <trans-unit id="ae8793069a72742b82c721802e621b8679b0b8aa" translate="yes" xml:space="preserve">
          <source>The mirror for a value in the target VM.</source>
          <target state="translated">대상 VM의 값에 대한 미러입니다.</target>
        </trans-unit>
        <trans-unit id="cbad74b72ed9943373d11041163dd19a3f42b0b3" translate="yes" xml:space="preserve">
          <source>The mirror for a value in the target VM. This interface is the root of a value hierarchy encompassing primitive values and object values.</source>
          <target state="translated">대상 VM의 값에 대한 미러입니다. 이 인터페이스는 기본 값과 객체 값을 포함하는 값 계층 구조의 루트입니다.</target>
        </trans-unit>
        <trans-unit id="d1e01e9578c34a1b819c6910e06d54349322daab" translate="yes" xml:space="preserve">
          <source>The mnemonic keycode used for the approve button when a directory is selected and the current selection mode is FILES_ONLY.</source>
          <target state="translated">디렉토리가 선택되고 현재 선택 모드가 FILES_ONLY 일 때 승인 버튼에 사용되는 니모닉 키 코드입니다.</target>
        </trans-unit>
        <trans-unit id="6f280eaac6e54be7e34e3642f6ff855dccab09c2" translate="yes" xml:space="preserve">
          <source>The mode argument determines how the progression parameters are chosen, and must be either &lt;code&gt;MODE_DISABLED&lt;/code&gt;, &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;, or &lt;code&gt;MODE_DEFAULT&lt;/code&gt;. Otherwise an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">mode 인수는 진행 매개 변수 선택 방법을 결정하며 &lt;code&gt;MODE_DISABLED&lt;/code&gt; , &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 또는 &lt;code&gt;MODE_DEFAULT&lt;/code&gt; 중 하나 여야합니다 . 그렇지 않으면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b820834a96857a5b241fe95cf3e9cca22165efa9" translate="yes" xml:space="preserve">
          <source>The mode controlling compression settings, which must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values.</source>
          <target state="translated">4 개의 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정되어야하는 압축 설정을 제어하는 ​​모드 입니다.</target>
        </trans-unit>
        <trans-unit id="7f15fced94f4787a730192e708c8082a30aebb9f" translate="yes" xml:space="preserve">
          <source>The mode controlling compression settings, which must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values. The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.</source>
          <target state="translated">압축 설정을 제어하는 ​​모드는 네 가지 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정되어야 합니다. 기본값은 &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2a8ab8dfa11b67a073fb291acb9e8e1dda7b1630" translate="yes" xml:space="preserve">
          <source>The mode controlling progressive encoding, which must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values, except &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MODE_EXPLICIT&lt;/code&gt; 를 제외한 4 개의 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정해야하는 점진적 인코딩을 제어하는 ​​모드 입니다.</target>
        </trans-unit>
        <trans-unit id="3de7dfb6d10df1074cd5714724b32c3da19cb20a" translate="yes" xml:space="preserve">
          <source>The mode controlling progressive encoding, which must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values, except &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;. The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.</source>
          <target state="translated">점진적 인코딩을 제어하는 ​​모드 . &lt;code&gt;MODE_EXPLICIT&lt;/code&gt; 를 제외한 네 가지 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정해야 합니다 . 기본값은 &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0b4bf954229dabff064f394cda1a8fd6dbc2ddb7" translate="yes" xml:space="preserve">
          <source>The mode controlling tiling settings, which Must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values.</source>
          <target state="translated">타일링 설정을 제어하는 ​​모드로, 4 개의 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f25060df8ca2f2296a1ced1bd3e2a4bdeb249eca" translate="yes" xml:space="preserve">
          <source>The mode controlling tiling settings, which Must be set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values. The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.</source>
          <target state="translated">타일링 설정을 제어하는 ​​모드로, 네 가지 &lt;code&gt;MODE_*&lt;/code&gt; 값 중 하나로 설정해야 합니다. 기본값은 &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0539cba70c1c9cdcb4a862061eadbc32b891f327" translate="yes" xml:space="preserve">
          <source>The mode specifying the level of detail of module documentation.</source>
          <target state="translated">모듈 문서의 세부 수준을 지정하는 모드입니다.</target>
        </trans-unit>
        <trans-unit id="6fe32b2240e57a17879128135f9a453935908963" translate="yes" xml:space="preserve">
          <source>The model change type returned by getType() will be one of:</source>
          <target state="translated">getType ()에서 반환하는 모델 변경 유형은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="2616079c079dc951763eebae3bec223e413339d2" translate="yes" xml:space="preserve">
          <source>The model doesn't support indexed random access to sequence elements. Only three sequence values are accessible at a time: current, next and previous.</source>
          <target state="translated">모델은 시퀀스 요소에 대한 색인화 된 임의 액세스를 지원하지 않습니다. 한 번에 세 가지 시퀀스 값 (현재, 다음 및 이전) 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="168faef5c82b48acd963b7c9af4201a890453b16" translate="yes" xml:space="preserve">
          <source>The model is defined by the &lt;a href=&quot;document&quot;&gt;&lt;code&gt;Document&lt;/code&gt;&lt;/a&gt; interface. This is intended to provide a flexible text storage mechanism that tracks change during edits and can be extended to more sophisticated models. The model interfaces are meant to capture the capabilities of expression given by SGML, a system used to express a wide variety of content. Each modification to the document causes notification of the details of the change to be sent to all observers in the form of a &lt;a href=&quot;../event/documentevent&quot;&gt;&lt;code&gt;DocumentEvent&lt;/code&gt;&lt;/a&gt; which allows the views to stay up to date with the model. This event is sent to observers that have implemented the &lt;a href=&quot;../event/documentlistener&quot;&gt;&lt;code&gt;DocumentListener&lt;/code&gt;&lt;/a&gt; interface and registered interest with the model being observed.</source>
          <target state="translated">모델은 &lt;a href=&quot;document&quot;&gt; &lt;code&gt;Document&lt;/code&gt; &lt;/a&gt; 인터페이스에 의해 정의됩니다 . 이는 편집 중 변경 사항을 추적하고보다 정교한 모델로 확장 할 수있는 유연한 텍스트 저장 메커니즘을 제공하기위한 것입니다. 모델 인터페이스는 다양한 콘텐츠를 표현하는 데 사용되는 시스템 인 SGML이 제공하는 표현 능력을 캡처하기위한 것입니다. 문서를 수정할 때마다 변경 사항의 세부 사항에 대한 알림이 &lt;a href=&quot;../event/documentevent&quot;&gt; &lt;code&gt;DocumentEvent&lt;/code&gt; &lt;/a&gt; 형식으로 모든 관찰자에게 전송되어 뷰가 모델에 대한 최신 상태를 유지할 수 있습니다. 이 이벤트는 &lt;a href=&quot;../event/documentlistener&quot;&gt; &lt;code&gt;DocumentListener&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하고 관찰중인 모델에 관심을 등록한 관찰자에게 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="8330843d459736e066acd92b3f008756fa5c7567" translate="yes" xml:space="preserve">
          <source>The model that defines the tree displayed by this object.</source>
          <target state="translated">이 개체가 표시하는 트리를 정의하는 모델입니다.</target>
        </trans-unit>
        <trans-unit id="5570617ef85dae7ecc2d0d0bb54d74a489ee7647" translate="yes" xml:space="preserve">
          <source>The model that represents the scrollbar's minimum, maximum, extent (aka &quot;visibleAmount&quot;) and current value.</source>
          <target state="translated">스크롤바의 최소, 최대, 범위 ( &quot;visibleAmount&quot;라고도 함) 및 현재 값을 나타내는 모델입니다.</target>
        </trans-unit>
        <trans-unit id="75a1b07f9515385c3a661861496a6b145b77de8a" translate="yes" xml:space="preserve">
          <source>The model used by &lt;code&gt;JTree&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JTree&lt;/code&gt; 에서 사용하는 모델 입니다.</target>
        </trans-unit>
        <trans-unit id="3aa2540304cd41e4a19279ee3b3fa91e13a6535a" translate="yes" xml:space="preserve">
          <source>The modeling of HTML is provided by the class &lt;code&gt;HTMLDocument&lt;/code&gt;. Its documentation describes the details of how the HTML is modeled. The editing support leverages heavily off of the text package.</source>
          <target state="translated">HTML 모델링은 &lt;code&gt;HTMLDocument&lt;/code&gt; 클래스에서 제공합니다 . 문서는 HTML이 어떻게 모델링되는지에 대한 세부 사항을 설명합니다. 편집 지원은 텍스트 패키지를 많이 활용합니다.</target>
        </trans-unit>
        <trans-unit id="244c6099e5c9d507a776de051659ea7a5f6ced2a" translate="yes" xml:space="preserve">
          <source>The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds. Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and alterations to the length of the notional second. As of 2012, discussions are underway to change the definition of UTC again, with the potential to remove leap seconds or introduce other changes.</source>
          <target state="translated">현대 UTC 타임 스케일은 1972 년에 도입되어 전체 윤초 개념을 소개합니다. 1958 년에서 1972 년 사이에 UTC의 정의는 복잡했으며, 초 이하의 작은 도약과 명목 초의 길이로 변경되었습니다. 2012 년 현재, 윤초를 제거하거나 다른 변경 사항을 도입 할 가능성이있는 UTC 정의를 다시 변경하기위한 논의가 진행 중입니다.</target>
        </trans-unit>
        <trans-unit id="c9c8d93b57522e87b93d7fcd2ed2c2ba506c62e6" translate="yes" xml:space="preserve">
          <source>The modes are interpreted as follows:</source>
          <target state="translated">모드는 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="3cd9eb9b1298371443e0745698a19893708a9dc0" translate="yes" xml:space="preserve">
          <source>The modes are:</source>
          <target state="translated">모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3cc6805c08b8481a43ee22b87218eba5bf5978e2" translate="yes" xml:space="preserve">
          <source>The modification code. It is one of: DirContext.ADD_ATTRIBUTE DirContext.REPLACE_ATTRIBUTE DirContext.REMOVE_ATTRIBUTE</source>
          <target state="translated">수정 코드 DirContext.ADD_ATTRIBUTE DirContext.REPLACE_ATTRIBUTE DirContext.REMOVE_ATTRIBUTE 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="3b8710293df9488348bad7d24782355247e162f4" translate="yes" xml:space="preserve">
          <source>The modification time and deflation hint attributes are not available, for the JAR manifest file and its containing directory.</source>
          <target state="translated">JAR Manifest 파일 및 포함 디렉토리에 수정 시간 및 수축 힌트 속성을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae5392e591961cef35e6113a0d61745bb18d5cf2" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;abstract&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;abstract&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63ec4993c4772cec3247257c7af88444f99bd5d4" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;default&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;default&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b79ffc26fe09a60c57670ba9443868f3e378227" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;final&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;final&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4caecde01acdabdee3af4deddef05c9345eee88d" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;native&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;native&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12c8f5e7da855ef8de3892013c1a60aa6b53d514" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;non-sealed&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;non-sealed&lt;/code&gt; 수정 자</target>
        </trans-unit>
        <trans-unit id="5d84914d32c0b59de560ef406f5fd476bb609a72" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;private&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;private&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca2a774915ce47a0621b004260cfcdf34bae0b19" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;protected&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;protected&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d5d79646fb8f27e87d578f47719e85be208200f" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;public&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;public&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95432ecf9bb75e301f3b7c042a107066741dbe1a" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;sealed&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sealed&lt;/code&gt; 수정 자</target>
        </trans-unit>
        <trans-unit id="ca0e06d76cb207037ed375002dc516a6bbcfd082" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;static&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;static&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="843644ccb0d5da6c49b878e18a5c3bf04e5a41bd" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;strictfp&lt;/code&gt;</source>
          <target state="translated">한정자 &lt;code&gt;strictfp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e064fce2e476a78dbc9a1b50a393aead551b075c" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;synchronized&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;synchronized&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f0463dc16506480712ec2a64c8d394dc5a179d0" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;transient&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;transient&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8adc7b2e81a65197a52783e56e73bede59c438b8" translate="yes" xml:space="preserve">
          <source>The modifier &lt;code&gt;volatile&lt;/code&gt;</source>
          <target state="translated">수정 자 &lt;code&gt;volatile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91a4f7af68a90ed955a6d478ede71ae9a892a9db" translate="yes" xml:space="preserve">
          <source>The modifier encodings are defined in</source>
          <target state="translated">수정 자 인코딩은</target>
        </trans-unit>
        <trans-unit id="53c43243f455d925c46f284aad81cc7fec157428" translate="yes" xml:space="preserve">
          <source>The modifier encodings are defined in &lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;, table 4.1.</source>
          <target state="translated">수정 자 인코딩은 &lt;em&gt;Java 가상 머신 스펙&lt;/em&gt; , 표 4.1에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bcadef03c059150a239257f11fa3e5c8f597c42" translate="yes" xml:space="preserve">
          <source>The modifier encodings are defined in section &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.1&quot;&gt;4.1&lt;/a&gt; of</source>
          <target state="translated">수정 자 인코딩은 섹션 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.1&quot;&gt;4.1&lt;/a&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea943ef7605756df7d4c1d9a2ba6aa05951d0cb1" translate="yes" xml:space="preserve">
          <source>The modifier flags for this parameter.</source>
          <target state="translated">이 매개 변수에 대한 수정 자 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="d9015ba8f3732b054992024e20f5e48c6d7fa0d5" translate="yes" xml:space="preserve">
          <source>The modifier names are returned in an order consistent with the suggested modifier orderings given in sections 8.1.1, 8.3.1, 8.4.3, 8.8.3, and 9.1.1 of</source>
          <target state="translated">수정 자 이름은 8.1.1, 8.3.1, 8.4.3, 8.8.3 및 9.1.1의 섹션 8.1.1에 제시된 제안 된 수정 자 순서와 일치하는 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c051f323123e2496ae8ef9f68dd6f61e20d85875" translate="yes" xml:space="preserve">
          <source>The modifiers are placed in canonical order as specified by &quot;The Java Language Specification&quot;. This is &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt; first, and then other modifiers in the following order: &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;final&lt;/code&gt;, &lt;code&gt;transient&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;.</source>
          <target state="translated">수정자는 &quot;The Java Language Specification&quot;에 지정된대로 정식 순서로 배치됩니다. 이것은 &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; 또는 &lt;code&gt;private&lt;/code&gt; 이며, 다음 순서로 &lt;code&gt;static&lt;/code&gt; , &lt;code&gt;final&lt;/code&gt; , &lt;code&gt;transient&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; 순서로 다른 수정 자입니다 .</target>
        </trans-unit>
        <trans-unit id="d9638f5a7a035d2e6544d680de5d3ab0daed7b22" translate="yes" xml:space="preserve">
          <source>The modifiers consist of any combination of:</source>
          <target state="translated">수정자는 다음의 조합으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6ff5d7370fd2f43b716be59ccc281e0ddf9dbf8a" translate="yes" xml:space="preserve">
          <source>The module declaration of the &lt;em&gt;consumer module&lt;/em&gt; that calls one of the &lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; factory methods to obtain a resource bundle from service providers must specify the following directive:</source>
          <target state="translated">&lt;code&gt;ResourceBundle.getBundle&lt;/code&gt; 팩토리 메소드 중 하나를 호출 하여 서비스 제공자로부터 자원 번들을 가져 오는 &lt;em&gt;소비자 모듈&lt;/em&gt; 의 모듈 선언은 다음 지시문을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd27a759db5930b6965b70e80e45ffbd273976e9" translate="yes" xml:space="preserve">
          <source>The module declaration of this provider module specifies the following directive:</source>
          <target state="translated">이 공급자 모듈의 모듈 선언은 다음 지시문을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f826091184fabed6c053393d124b02eeb394e90b" translate="yes" xml:space="preserve">
          <source>The module descriptor</source>
          <target state="translated">모듈 설명자</target>
        </trans-unit>
        <trans-unit id="9ffb9f109518cb257ecb641ae9e31b19f384e7d8" translate="yes" xml:space="preserve">
          <source>The module descriptor for this module</source>
          <target state="translated">이 모듈의 모듈 설명자</target>
        </trans-unit>
        <trans-unit id="d5697a7d44cd8d7587068252683fa19c81cde1d8" translate="yes" xml:space="preserve">
          <source>The module descriptor is read from the buffer starting at index &lt;code&gt;p&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is the buffer's &lt;a href=&quot;../../nio/buffer#position()&quot;&gt;&lt;code&gt;position&lt;/code&gt;&lt;/a&gt; when this method is invoked. Upon return the buffer's position will be equal to &lt;code&gt;p + n&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the number of bytes read from the buffer.</source>
          <target state="translated">모듈 설명자는 인덱스 &lt;code&gt;p&lt;/code&gt; 에서 시작하는 버퍼에서 읽습니다 . 여기서 &lt;code&gt;p&lt;/code&gt; 는 이 메서드가 호출 될 때 버퍼의 &lt;a href=&quot;../../nio/buffer#position()&quot;&gt; &lt;code&gt;position&lt;/code&gt; &lt;/a&gt; 입니다. 반환시 버퍼의 위치는 &lt;code&gt;p + n&lt;/code&gt; 과 같을 것입니다. 여기서 &lt;code&gt;n&lt;/code&gt; 은 버퍼에서 읽은 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="23823c03b5b1082b2e61b6362541194e29396b6d" translate="yes" xml:space="preserve">
          <source>The module finder locates modules by searching each directory, exploded module, or packaged module in array index order. It finds the first occurrence of a module with a given name and ignores other modules of that name that appear later in the sequence.</source>
          <target state="translated">모듈 파인더는 각 디렉토리, 확장 된 모듈 또는 패키지 된 모듈을 배열 인덱스 순서로 검색하여 모듈을 찾습니다. 주어진 이름을 가진 모듈의 첫 번째 발생을 찾고 순서에서 나중에 나타나는 해당 이름의 다른 모듈을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="fd6e4f3b8e674aeca9b51d358b7f13e83c064b81" translate="yes" xml:space="preserve">
          <source>The module finder returned by this method supports modules packaged as JAR files. A JAR file with a &lt;code&gt;
 module-info.class&lt;/code&gt; in its top-level directory, or in a versioned entry in a &lt;a href=&quot;../../util/jar/jarfile#isMultiRelease()&quot;&gt;multi-release&lt;/a&gt; JAR file, is a modular JAR file and thus defines an &lt;em&gt;explicit&lt;/em&gt; module. A JAR file that does not have a &lt;code&gt;module-info.class&lt;/code&gt; in its top-level directory defines an &lt;em&gt;automatic module&lt;/em&gt;, as follows:</source>
          <target state="translated">이 메소드에서 반환 된 모듈 찾기는 JAR 파일로 패키지 된 모듈을 지원합니다. 기호가있는 JAR 파일 &lt;code&gt; module-info.class&lt;/code&gt; 최상위 디렉토리는, 또는에서 버전 항목에 &lt;a href=&quot;../../util/jar/jarfile#isMultiRelease()&quot;&gt;멀티 릴리스&lt;/a&gt; JAR 파일, 모듈 JAR 파일이며, 따라서 정의 &lt;em&gt;명시 적으로&lt;/em&gt; 모듈을. 최상위 디렉토리에 &lt;code&gt;module-info.class&lt;/code&gt; 가없는 JAR 파일 은 다음과 같이 &lt;em&gt;자동 모듈을&lt;/em&gt; 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="1a9f6d24753f85c58f990e727273d60e2e67d1e6" translate="yes" xml:space="preserve">
          <source>The module layer that contains this module</source>
          <target state="translated">이 모듈을 포함하는 모듈 계층</target>
        </trans-unit>
        <trans-unit id="1635800c659f8343bb6f76cf0577b6d8050a774a" translate="yes" xml:space="preserve">
          <source>The module name</source>
          <target state="translated">모듈 이름</target>
        </trans-unit>
        <trans-unit id="53e0fa608612b58a9a810e4063bf16f58069901a" translate="yes" xml:space="preserve">
          <source>The module name of the initial/main module</source>
          <target state="translated">초기 / 주 모듈의 모듈 이름</target>
        </trans-unit>
        <trans-unit id="ac5d37ad4e53b906df01aa542b63a047cb5d7bde" translate="yes" xml:space="preserve">
          <source>The module names, package names, and class names that are parameters specified to the builder methods are the module names, package names, and qualified names of classes (in named packages) as defined in the</source>
          <target state="translated">빌더 메소드에 지정된 매개 변수 인 모듈 이름, 패키지 이름 및 클래스 이름은 모듈 이름, 패키지 이름 및 클래스의 규정 된 이름 (명명 된 패키지에 있음)입니다.</target>
        </trans-unit>
        <trans-unit id="fa45d7a186ad1d94566a5a5b06f2471c8f81eba2" translate="yes" xml:space="preserve">
          <source>The module prompts for a username and password and then verifies the password against the password stored in a directory service configured under JNDI.</source>
          <target state="translated">모듈은 사용자 이름과 암호를 입력하라는 메시지를 표시 한 다음 JNDI에서 구성된 디렉토리 서비스에 저장된 암호와 비교하여 암호를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="11c2904d770fbc92f2522b07410930baefe40138" translate="yes" xml:space="preserve">
          <source>The module was implicitly declared.</source>
          <target state="translated">모듈이 암시 적으로 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="3f251bc3c55d3066fc0f31b71e99d61fef714079" translate="yes" xml:space="preserve">
          <source>The module was not explicitly or implicitly declared.</source>
          <target state="translated">모듈이 명시 적으로 또는 암시 적으로 선언되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="d3991d1b517dfde1e54a603f22fa164b96b0ed22" translate="yes" xml:space="preserve">
          <source>The module will require &quot;&lt;code&gt;java.base&lt;/code&gt;&quot; even if the dependence has not been declared (the exception is when building a module named &quot;&lt;code&gt;java.base&lt;/code&gt;&quot; as it cannot require itself). The dependence on &quot;&lt;code&gt;java.base&lt;/code&gt;&quot; will have the &lt;a href=&quot;moduledescriptor.requires.modifier#MANDATED&quot;&gt;&lt;code&gt;MANDATED&lt;/code&gt;&lt;/a&gt; modifier if the dependence was not declared.</source>
          <target state="translated">모듈은 &quot;필요 &lt;code&gt;java.base&lt;/code&gt; 의존도가 선언되지 않은 경우에도&quot;를 ( &quot;라는 이름의 모듈을 빌드 할 때 예외입니다 &lt;code&gt;java.base&lt;/code&gt; 그 자체를 필요로하지 수를&quot;). 종속성이 선언되지 않은 경우 &quot; &lt;code&gt;java.base&lt;/code&gt; &quot; 에 대한 종속성 에는 &lt;a href=&quot;moduledescriptor.requires.modifier#MANDATED&quot;&gt; &lt;code&gt;MANDATED&lt;/code&gt; &lt;/a&gt; 수정자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="854f140d77f63016d257e0527ca134810276d2c2" translate="yes" xml:space="preserve">
          <source>The module with the given name or an empty &lt;code&gt;Optional&lt;/code&gt; if there isn't a module with this name in this layer or any parent layer</source>
          <target state="translated">주어진 이름을 가진 모듈 또는이 레이어 또는 상위 레이어에이 이름을 가진 모듈이없는 경우 빈 &lt;code&gt;Optional&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62ab14799d4062196ce892d3b8d807e65d9fde90" translate="yes" xml:space="preserve">
          <source>The modulus value.</source>
          <target state="translated">모듈러스 값.</target>
        </trans-unit>
        <trans-unit id="3d08c37a4170b4dda9e34877ca839b2a5af939cc" translate="yes" xml:space="preserve">
          <source>The month of this &lt;code&gt;XMLGregorianCalendar&lt;/code&gt;, from 1 to 12.</source>
          <target state="translated">이 &lt;code&gt;XMLGregorianCalendar&lt;/code&gt; 의 월이며 1부터 12까지입니다.</target>
        </trans-unit>
        <trans-unit id="52e5f16469f41afd7f7f1a42b853a6034f970843" translate="yes" xml:space="preserve">
          <source>The month-of-year, such as March.</source>
          <target state="translated">3 월과 같은 달입니다.</target>
        </trans-unit>
        <trans-unit id="ad63462cba81985606db9ca1b76cff069f0f97bd" translate="yes" xml:space="preserve">
          <source>The months unit is not automatically normalized with the years unit. This means that a period of &quot;15 months&quot; is different to a period of &quot;1 year and 3 months&quot;.</source>
          <target state="translated">개월 단위는 년 단위로 자동 정규화되지 않습니다. 이것은 &quot;15 개월&quot;의 기간이 &quot;1 년 3 개월&quot;의 기간과 다르다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1808c8e9420488523fe90cca9d9f6edf6d79fa22" translate="yes" xml:space="preserve">
          <source>The most common example when the 'mixing-cutout' shape is needed is a glass pane component. The &lt;a href=&quot;../../javax/swing/jrootpane#setGlassPane(java.awt.Component)&quot;&gt;&lt;code&gt;JRootPane.setGlassPane(java.awt.Component)&lt;/code&gt;&lt;/a&gt; method automatically sets the</source>
          <target state="translated">'mixing-cutout'모양이 필요한 가장 일반적인 예는 유리창 구성 요소입니다. &lt;a href=&quot;../../javax/swing/jrootpane#setGlassPane(java.awt.Component)&quot;&gt; &lt;code&gt;JRootPane.setGlassPane(java.awt.Component)&lt;/code&gt; &lt;/a&gt; 방법을 자동 설정하는</target>
        </trans-unit>
        <trans-unit id="4513060ec32ffaef9ffecbdcf9d778476ec0f897" translate="yes" xml:space="preserve">
          <source>The most common implementations are method references, such as &lt;code&gt;LocalDate::from&lt;/code&gt; and &lt;code&gt;ZoneId::from&lt;/code&gt;. Additional common queries are provided as static methods in &lt;a href=&quot;temporalqueries&quot;&gt;&lt;code&gt;TemporalQueries&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가장 일반적인 구현은 다음과 같은 메소드 참조입니다. &lt;code&gt;LocalDate::from&lt;/code&gt; 및 &lt;code&gt;ZoneId::from&lt;/code&gt; 과 입니다 . 추가 일반 쿼리는 &lt;a href=&quot;temporalqueries&quot;&gt; &lt;code&gt;TemporalQueries&lt;/code&gt; &lt;/a&gt; 에서 정적 메소드로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="7e2c1befd40582f5a4726afbca33854db8dbfdc7" translate="yes" xml:space="preserve">
          <source>The most common implementations are method references, such as &lt;code&gt;LocalDate::from&lt;/code&gt; and &lt;code&gt;ZoneId::from&lt;/code&gt;. Additional common queries are provided to return:</source>
          <target state="translated">가장 일반적인 구현은 &lt;code&gt;LocalDate::from&lt;/code&gt; 및 &lt;code&gt;ZoneId::from&lt;/code&gt; 과 같은 메소드 참조 입니다 . 다음을 리턴하기 위해 추가 공통 조회가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3d41a4cbf15b731db6bda6714c5e00e992b9f579" translate="yes" xml:space="preserve">
          <source>The most common query implementations are method references, such as &lt;code&gt;LocalDate::from&lt;/code&gt; and &lt;code&gt;ZoneId::from&lt;/code&gt;. Additional implementations are provided as static methods on &lt;a href=&quot;temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가장 일반적인 쿼리 구현은 &lt;code&gt;LocalDate::from&lt;/code&gt; 과 같은 메서드 참조 입니다. 및 &lt;code&gt;ZoneId::from&lt;/code&gt; 과 입니다 . 추가 구현은 &lt;a href=&quot;temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; 에&lt;/a&gt; 정적 메소드로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c13dd68f0c8f57bb59ccd6903b4447f288e54694" translate="yes" xml:space="preserve">
          <source>The most commonly used units are defined in &lt;a href=&quot;chronofield&quot;&gt;&lt;code&gt;ChronoField&lt;/code&gt;&lt;/a&gt;. Further fields are supplied in &lt;a href=&quot;isofields&quot;&gt;&lt;code&gt;IsoFields&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weekfields&quot;&gt;&lt;code&gt;WeekFields&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;julianfields&quot;&gt;&lt;code&gt;JulianFields&lt;/code&gt;&lt;/a&gt;. Fields can also be written by application code by implementing this interface.</source>
          <target state="translated">가장 일반적으로 사용되는 단위는 &lt;a href=&quot;chronofield&quot;&gt; &lt;code&gt;ChronoField&lt;/code&gt; 에&lt;/a&gt; 정의되어 있습니다 . 추가 필드는 &lt;a href=&quot;isofields&quot;&gt; &lt;code&gt;IsoFields&lt;/code&gt; &lt;/a&gt; 에서 제공됩니다 .&lt;a href=&quot;weekfields&quot;&gt; &lt;code&gt;WeekFields&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;julianfields&quot;&gt; &lt;code&gt;JulianFields&lt;/code&gt; 에 제공&lt;/a&gt; 됩니다. 이 인터페이스를 구현하여 응용 프로그램 코드로 필드를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="af7dd9ea927fa70049276104e84510298e783b39" translate="yes" xml:space="preserve">
          <source>The most commonly used units are defined in &lt;a href=&quot;chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt;. Further units are supplied in &lt;a href=&quot;isofields&quot;&gt;&lt;code&gt;IsoFields&lt;/code&gt;&lt;/a&gt;. Units can also be written by application code by implementing this interface.</source>
          <target state="translated">가장 일반적으로 사용되는 단위는 &lt;a href=&quot;chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; 에&lt;/a&gt; 정의되어 있습니다. . 추가 단위는 &lt;a href=&quot;isofields&quot;&gt; &lt;code&gt;IsoFields&lt;/code&gt; &lt;/a&gt; 에 제공됩니다 . 이 인터페이스를 구현하여 응용 프로그램 코드로 단위를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="68bb9a4cb9aa2b82b423053d80b910869345efe3" translate="yes" xml:space="preserve">
          <source>The most condensed predefined width.</source>
          <target state="translated">가장 압축 된 미리 정의 된 너비입니다.</target>
        </trans-unit>
        <trans-unit id="40695de746ccbc2352bf8577be8e1cbb2b497820" translate="yes" xml:space="preserve">
          <source>The most extended predefined width.</source>
          <target state="translated">가장 확장 된 미리 정의 된 너비입니다.</target>
        </trans-unit>
        <trans-unit id="336862f66e49b850485d5a43840dcf02567602aa" translate="yes" xml:space="preserve">
          <source>The most significant 64 bits of this UUID's 128 bit value</source>
          <target state="translated">이 UUID 128 비트 값의 최상위 64 비트</target>
        </trans-unit>
        <trans-unit id="1b3a7b82d4c1e3494e08d3f8dcc14fcea3e3c83d" translate="yes" xml:space="preserve">
          <source>The mouse has entered a component.</source>
          <target state="translated">마우스가 구성 요소에 들어갔습니다.</target>
        </trans-unit>
        <trans-unit id="4300ff492f6761e54037896847250d58d9f7ca9a" translate="yes" xml:space="preserve">
          <source>The mouse has exited a component.</source>
          <target state="translated">마우스가 구성 요소를 종료했습니다.</target>
        </trans-unit>
        <trans-unit id="88d3dea421ee35681eb08ba780924b05a6ceba05" translate="yes" xml:space="preserve">
          <source>The mouse has moved with no button pressed.</source>
          <target state="translated">버튼을 누르지 않고 마우스가 움직였습니다.</target>
        </trans-unit>
        <trans-unit id="ba08b5f18ed9ec07f7eba8ec350b383be83d9827" translate="yes" xml:space="preserve">
          <source>The move button text property.</source>
          <target state="translated">이동 버튼 텍스트 속성입니다.</target>
        </trans-unit>
        <trans-unit id="4ed52e635196ac91fbf685930c6ca399d0d5eae6" translate="yes" xml:space="preserve">
          <source>The move cursor type.</source>
          <target state="translated">이동 커서 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e5b6b0ee327c4dda6a29cf8a360a7d3afa18127d" translate="yes" xml:space="preserve">
          <source>The move is performed as an atomic file system operation and all other options are ignored. If the target file exists then it is implementation specific if the existing file is replaced or this method fails by throwing an &lt;a href=&quot;../../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;. If the move cannot be performed as an atomic file system operation then &lt;a href=&quot;atomicmovenotsupportedexception&quot;&gt;&lt;code&gt;AtomicMoveNotSupportedException&lt;/code&gt;&lt;/a&gt; is thrown. This can arise, for example, when the target location is on a different &lt;code&gt;FileStore&lt;/code&gt; and would require that the file be copied, or target location is associated with a different provider to this object.</source>
          <target state="translated">이동은 원자 파일 시스템 조작으로 수행되며 다른 모든 옵션은 무시됩니다. 대상 파일이 존재하는 경우 기존 파일이 교체되거나 &lt;a href=&quot;../../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 을&lt;/a&gt; 발생시켜이 메소드가 실패하면 구현 고유의 것입니다 . 원자 파일 시스템 조작으로 이동을 수행 할 수없는 경우 &lt;a href=&quot;atomicmovenotsupportedexception&quot;&gt; &lt;code&gt;AtomicMoveNotSupportedException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 예를 들어, 대상 위치가 다른 &lt;code&gt;FileStore&lt;/code&gt; 에 있고 파일을 복사해야하거나 대상 위치가이 오브젝트에 대한 다른 제공자와 연관되어 있어야하는 경우가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf8d2bee39940d0f0e5b63f3da1a2f2575577f74" translate="yes" xml:space="preserve">
          <source>The msg string is localized using the named resource bundle. If the resource bundle name is null, or an empty String or invalid then the msg string is not localized.</source>
          <target state="translated">msg 문자열은 이름 지정된 자원 번들을 사용하여 현지화됩니다. 자원 번들 이름이 널이거나 비어있는 문자열이거나 유효하지 않은 경우 msg 문자열이 현지화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87e3caa9fe0fe65747b93ccf7d2958ad47e8ab5b" translate="yes" xml:space="preserve">
          <source>The multicast &lt;code&gt;NetworkInterface&lt;/code&gt; currently set. A placeholder NetworkInterface is returned when there is no interface set; it has a single InetAddress to represent any local address.</source>
          <target state="translated">현재 설정된 멀티 캐스트 &lt;code&gt;NetworkInterface&lt;/code&gt; 입니다. 인터페이스가 설정되지 않은 경우 자리 표시 자 NetworkInterface가 반환됩니다. 로컬 주소를 나타내는 단일 InetAddress가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f37cfad4e06252721b39abc7c9955ec39b17924d" translate="yes" xml:space="preserve">
          <source>The multicast datagram socket class is useful for sending and receiving IP multicast packets.</source>
          <target state="translated">멀티 캐스트 데이터 그램 소켓 클래스는 IP 멀티 캐스트 패킷을 보내고받는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0c63c91d04a939fcd587cbc1f9e978924f9d2ad7" translate="yes" xml:space="preserve">
          <source>The multicast datagram socket class is useful for sending and receiving IP multicast packets. A MulticastSocket is a (UDP) DatagramSocket, with additional capabilities for joining &quot;groups&quot; of other multicast hosts on the internet.</source>
          <target state="translated">멀티 캐스트 데이터 그램 소켓 클래스는 IP 멀티 캐스트 패킷을 보내고받는 데 유용합니다. MulticastSocket은 인터넷에서 다른 멀티 캐스트 호스트의 &quot;그룹&quot;에 참여하기위한 추가 기능이있는 (UDP) DatagramSocket입니다.</target>
        </trans-unit>
        <trans-unit id="679be2f4ae9c2488715346a40d11f01c153c9386" translate="yes" xml:space="preserve">
          <source>The multicast implementation is intended to map directly to the native multicasting facility. Consequently, the following items should be considered when developing an application that receives IP multicast datagrams:</source>
          <target state="translated">멀티 캐스트 구현은 기본 멀티 캐스팅 기능에 직접 매핑하기위한 것입니다. 따라서 IP 멀티 캐스트 데이터 그램을 수신하는 응용 프로그램을 개발할 때는 다음 사항을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d9f399a6a76b061b084d9b4a009e3d8e36254d4" translate="yes" xml:space="preserve">
          <source>The multiple input documents are combined into a single output document. Finishing operations (&lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt;), are performed on this single output document. The &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute tells how many copies of this single output document to produce. The &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; values &lt;code&gt;SINGLE_DOCUMENT&lt;/code&gt; and &lt;code&gt;SINGLE_DOCUMENT_NEW_SHEET&lt;/code&gt; specify two variations of this possibility.</source>
          <target state="translated">여러 입력 문서가 하나의 출력 문서로 결합됩니다. 마무리 작업 ( &lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt; )은이 단일 출력 문서에서 수행됩니다. &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 속성이 단일 출력 문서의 여러 복사본을 생성하는 방법에 대해 설명합니다. &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 값 &lt;code&gt;SINGLE_DOCUMENT&lt;/code&gt; 와 &lt;code&gt;SINGLE_DOCUMENT_NEW_SHEET&lt;/code&gt; 은 이러한 가능성의 두 변형을 지정.</target>
        </trans-unit>
        <trans-unit id="ce7b19820280a66b240e2ab7bb11f5dc03d3553e" translate="yes" xml:space="preserve">
          <source>The multiple input documents are combined into a single output document. Finishing operations (&lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt;), are performed on this single output document. The &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute tells how many copies of this single output document to produce. The MultipleDocumentHandling values SINGLE_DOCUMENT and SINGLE_DOCUMENT_NEW_SHEET specify two variations of this possibility.</source>
          <target state="translated">여러 입력 문서가 단일 출력 문서로 결합됩니다. 마무리 작업 ( &lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt; )은이 단일 출력 문서에서 수행됩니다. &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 속성이 단일 출력 문서의 여러 복사본을 생성하는 방법에 대해 설명합니다. MultipleDocumentHandling 값 SINGLE_DOCUMENT 및 SINGLE_DOCUMENT_NEW_SHEET은이 가능성의 두 가지 변형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ebc205570873174d635db810e1ed9b34c248d113" translate="yes" xml:space="preserve">
          <source>The multiple input documents remain separate output documents. Finishing operations (&lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt;), are performed on each output document separately. The &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute tells how many copies of each separate output document to produce. The &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; values &lt;code&gt;SEPARATE_DOCUMENTS_UNCOLLATED_COPIES&lt;/code&gt; and &lt;code&gt;SEPARATE_DOCUMENTS_COLLATED_COPIES&lt;/code&gt; specify two variations of this possibility.</source>
          <target state="translated">여러 입력 문서는 별도의 출력 문서로 유지됩니다. 마무리 작업 ( &lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt; )은 각 출력 문서에서 개별적으로 수행됩니다. &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 속성은 각각 별도의 출력 문서의 여러 복사본을 생성하는 방법에 대해 설명합니다. &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; 의이 값 &lt;code&gt;SEPARATE_DOCUMENTS_UNCOLLATED_COPIES&lt;/code&gt; 및 &lt;code&gt;SEPARATE_DOCUMENTS_COLLATED_COPIES&lt;/code&gt; 은 이러한 가능성의 두 변형을 지정.</target>
        </trans-unit>
        <trans-unit id="028e483478001df55d9b96778a1edffa0bfb1289" translate="yes" xml:space="preserve">
          <source>The multiple input documents remain separate output documents. Finishing operations (&lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt;), are performed on each output document separately. The &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute tells how many copies of each separate output document to produce. The MultipleDocumentHandling values SEPARATE_DOCUMENTS_UNCOLLATED_COPIES and SEPARATE_DOCUMENTS_COLLATED_COPIES specify two variations of this possibility.</source>
          <target state="translated">여러 입력 문서는 별도의 출력 문서로 유지됩니다. 마무리 작업 ( &lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt; )은 각 출력 문서에서 개별적으로 수행됩니다. &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 속성은 각각 별도의 출력 문서의 여러 복사본을 생성하는 방법에 대해 설명합니다. MultipleDocumentHandling 값 SEPARATE_DOCUMENTS_UNCOLLATED_COPIES 및 SEPARATE_DOCUMENTS_COLLATED_COPIES는이 가능성의 두 가지 변형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d1a9befa918fd9fc042bb67e1599e6636d96288a" translate="yes" xml:space="preserve">
          <source>The mutable reduction operation is called &lt;a href=&quot;stream#collect(java.util.stream.Collector)&quot;&gt;&lt;code&gt;collect()&lt;/code&gt;&lt;/a&gt;, as it collects together the desired results into a result container such as a &lt;code&gt;Collection&lt;/code&gt;. A &lt;code&gt;collect&lt;/code&gt; operation requires three functions: a supplier function to construct new instances of the result container, an accumulator function to incorporate an input element into a result container, and a combining function to merge the contents of one result container into another. The form of this is very similar to the general form of ordinary reduction:</source>
          <target state="translated">변경 가능한 축소 작업은 &lt;a href=&quot;stream#collect(java.util.stream.Collector)&quot;&gt; &lt;code&gt;collect()&lt;/code&gt; &lt;/a&gt; 라고 합니다. 원하는 결과를 &lt;code&gt;Collection&lt;/code&gt; 과 같은 결과 컨테이너로 모으기 때문 입니다. &lt;code&gt;collect&lt;/code&gt; 동작은 세 가지 기능을 필요 공급 기능을 다른 것으로 한 결과, 용기의 내용을 병합 한 결과 컨테이너 결과 용기에 입력 요소를 포함하는 누적 기 함수 및 합성 함수의 새로운 인스턴스를 생성하기. 이 형식은 일반적인 축소 형식과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="fc368dbc299b8ec9a50b33ed2e8162f1e9e9148a" translate="yes" xml:space="preserve">
          <source>The mutable reduction operation is called &lt;a href=&quot;stream#collect-java.util.stream.Collector-&quot;&gt;&lt;code&gt;collect()&lt;/code&gt;&lt;/a&gt;, as it collects together the desired results into a result container such as a &lt;code&gt;Collection&lt;/code&gt;. A &lt;code&gt;collect&lt;/code&gt; operation requires three functions: a supplier function to construct new instances of the result container, an accumulator function to incorporate an input element into a result container, and a combining function to merge the contents of one result container into another. The form of this is very similar to the general form of ordinary reduction:</source>
          <target state="translated">변경 가능한 축소 연산은 원하는 결과를 &lt;code&gt;Collection&lt;/code&gt; 과 같은 결과 컨테이너로 수집하기 때문에 &lt;a href=&quot;stream#collect-java.util.stream.Collector-&quot;&gt; &lt;code&gt;collect()&lt;/code&gt; &lt;/a&gt; 라고 합니다 . &lt;code&gt;collect&lt;/code&gt; 동작은 세 가지 기능을 필요 공급 기능을 다른 것으로 한 결과, 용기의 내용을 병합 한 결과 컨테이너 결과 용기에 입력 요소를 포함하는 누적 기 함수 및 합성 함수의 새로운 인스턴스를 생성하기. 이것의 형태는 일반적인 형태의 일반 축소와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="6bf363cc62a0d3c9d944fdceea262606a0bad8a4" translate="yes" xml:space="preserve">
          <source>The mutable source provides a late-binding and fail-fast Spliterator.</source>
          <target state="translated">변경 가능한 소스는 후기 바인딩 및 페일 빠른 스플리터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d66e6381fee28dcc7d4fb931e8ee888e87c11040" translate="yes" xml:space="preserve">
          <source>The mutable source provides a late-binding and non-fail-fast Spliterator.</source>
          <target state="translated">변경 가능한 소스는 후기 바인딩 및 실패하지 않은 스플리터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2f78fc2805fc5d07a59044553456ac5cd7dd26fa" translate="yes" xml:space="preserve">
          <source>The mutable source provides a non-late-binding and non-fail-fast Spliterator.</source>
          <target state="translated">가변 소스는 비 지연 바인딩 및 비 고속 스플리터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dbe168307666cea493e681f1f4347bdcea853c7c" translate="yes" xml:space="preserve">
          <source>The mutable source provides a non-late-binding but fail-fast Spliterator.</source>
          <target state="translated">변경 가능한 소스는 바인딩이 아닌 비 고속 스플리터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="76d403f1093a19ad1c9bb2d7114141c8b8dfd068" translate="yes" xml:space="preserve">
          <source>The n-th date which appears in the stream is equal to &lt;code&gt;this.plus(step.multipliedBy(n))&lt;/code&gt; (but the result of step multiplication never overflows). For example, if this date is &lt;code&gt;2015-01-31&lt;/code&gt;, the end date is &lt;code&gt;2015-05-01&lt;/code&gt; and the step is 1 month, then the stream contains &lt;code&gt;2015-01-31&lt;/code&gt;, &lt;code&gt;2015-02-28&lt;/code&gt;, &lt;code&gt;2015-03-31&lt;/code&gt;, and &lt;code&gt;2015-04-30&lt;/code&gt;.</source>
          <target state="translated">스트림에 나타나는 n 번째 날짜는 &lt;code&gt;this.plus(step.multipliedBy(n))&lt;/code&gt; (하지만 단계 곱셈의 결과는 절대 오버플로되지 않음). 예를 &lt;code&gt;2015-01-31&lt;/code&gt; 날짜가 2015-01-31 이고 종료 날짜가 &lt;code&gt;2015-05-01&lt;/code&gt; 이고 단계가 1 개월이면 스트림에 &lt;code&gt;2015-01-31&lt;/code&gt; , &lt;code&gt;2015-02-28&lt;/code&gt; , &lt;code&gt;2015-03-31&lt;/code&gt; 이 포함됩니다. , 및 &lt;code&gt;2015-04-30&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31d3c0f6b4d01646a48dc2eec0b9c8fb5b9267a6" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;gc&lt;/code&gt; stands for &quot;garbage collector&quot;. The Java Virtual Machine performs this recycling process automatically as needed, in a separate thread, even if the &lt;code&gt;gc&lt;/code&gt; method is not invoked explicitly.</source>
          <target state="translated">&lt;code&gt;gc&lt;/code&gt; 라는 이름 은 &quot;가비지 수집기&quot;를 의미합니다. Java Virtual Machine은 &lt;code&gt;gc&lt;/code&gt; 메소드가 명시 적으로 호출되지 않은 경우에도 별도의 스레드에서 필요에 따라이 재활용 프로세스를 자동으로 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="e7bae1d90225c65e4241b4140c7e704c983e32a7" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;gc&lt;/code&gt; stands for &quot;garbage collector&quot;. The virtual machine performs this recycling process automatically as needed, in a separate thread, even if the &lt;code&gt;gc&lt;/code&gt; method is not invoked explicitly.</source>
          <target state="translated">&lt;code&gt;gc&lt;/code&gt; 라는 이름 은 &quot;가비지 수집기&quot;를 의미합니다. 가상 머신은 &lt;code&gt;gc&lt;/code&gt; 메소드가 명시 적으로 호출되지 않더라도 필요한 경우 별도의 스레드에서이 재활용 프로세스를 자동으로 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="298b704b9fa08b7d1afe8582882b8210ab89b9c6" translate="yes" xml:space="preserve">
          <source>The name and type the specified CompositeData must contain</source>
          <target state="translated">지정된 CompositeData에 포함되어야하는 이름 및 유형</target>
        </trans-unit>
        <trans-unit id="544bf051094ed67f6eb578a4628c2bb2628ed3d9" translate="yes" xml:space="preserve">
          <source>The name as a list of RDNs which are instances of the class &lt;a href=&quot;rdn&quot;&gt;&lt;code&gt;Rdn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rdn&quot;&gt; &lt;code&gt;Rdn&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스 인 RDN리스트로서의 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="c8650bd011ea0967d50e07bf395dc45c6981be8f" translate="yes" xml:space="preserve">
          <source>The name assigned to a tag with an unknown tag number.</source>
          <target state="translated">태그 번호를 알 수없는 태그에 할당 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="22c0e5d40dd79969cd82e72465bb3fbde9230b74" translate="yes" xml:space="preserve">
          <source>The name assigned to a tag with an unknown tag number. Such a tag may be created for example when reading an IFD and a tag number is encountered which is not in any of the &lt;code&gt;TIFFTagSet&lt;/code&gt;s known to the reader.</source>
          <target state="translated">태그 번호를 알 수없는 태그에 할당 된 이름입니다. 이러한 태그는 예를 들어 IFD를 읽을 때 생성 될 수 있고 리더에게 알려진 &lt;code&gt;TIFFTagSet&lt;/code&gt; 에 없는 태그 번호가 발견 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86b0cc1239625455eae930e65603610fafed91c8" translate="yes" xml:space="preserve">
          <source>The name at the &lt;code&gt;index&lt;/code&gt;th position in the &lt;code&gt;NameList&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if there is no name for the specified index or if the index is out of range.</source>
          <target state="translated">상기 이름 &lt;code&gt;index&lt;/code&gt; 의 위치 일 &lt;code&gt;NameList&lt;/code&gt; , 또는 &lt;code&gt;null&lt;/code&gt; 인덱스가 범위를 벗어나 지정된 인덱스 또는 경우에 이름이없는 경우.</target>
        </trans-unit>
        <trans-unit id="e51d7878cc5e7e5574ad6e0538af772791366fe4" translate="yes" xml:space="preserve">
          <source>The name can be formed in the following ways:</source>
          <target state="translated">이름은 다음과 같은 방법으로 형성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="504eb3737ea1138b3f84bac07b01bdfb6961254c" translate="yes" xml:space="preserve">
          <source>The name constraints are returned as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 3280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;trustanchor#TrustAnchor-java.security.cert.X509Certificate-byte:A-&quot;&gt;&lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 반환됩니다. 이 바이트 배열에는 RFC 3280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식이 포함됩니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;trustanchor#TrustAnchor-java.security.cert.X509Certificate-byte:A-&quot;&gt; &lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt; &lt;/a&gt; 문서에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="211caa8f49b864cd1bbad3bd9135f34a8bd884f4" translate="yes" xml:space="preserve">
          <source>The name constraints are returned as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 3280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;x509certselector#setNameConstraints-byte:A-&quot;&gt;&lt;code&gt;setNameConstraints(byte [] bytes)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 반환됩니다. 이 바이트 배열에는 RFC 3280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식이 포함됩니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509certselector#setNameConstraints-byte:A-&quot;&gt; &lt;code&gt;setNameConstraints(byte [] bytes)&lt;/code&gt; &lt;/a&gt; 문서에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7035b9680ba2a5219acc362a95cb6bab9307b7a" translate="yes" xml:space="preserve">
          <source>The name constraints are returned as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 5280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;#%3Cinit%3E(java.security.cert.X509Certificate,byte%5B%5D)&quot;&gt;&lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 반환됩니다. 이 바이트 배열에는 RFC 5280 및 X.509에 정의 된 NameConstraints 구조에 표시되는 이름 제약 조건의 DER 인코딩 형식이 포함되어 있습니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#%3Cinit%3E(java.security.cert.X509Certificate,byte%5B%5D)&quot;&gt; &lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt; &lt;/a&gt; 에 대한 설명서에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="10ed19e6f99056d708df9e48318e76d1d9185711" translate="yes" xml:space="preserve">
          <source>The name constraints are returned as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 5280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;#setNameConstraints(byte%5B%5D)&quot;&gt;&lt;code&gt;setNameConstraints(byte [] bytes)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 반환됩니다. 이 바이트 배열에는 RFC 5280 및 X.509에 정의 된 NameConstraints 구조에 표시되는 이름 제약 조건의 DER 인코딩 형식이 포함되어 있습니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#setNameConstraints(byte%5B%5D)&quot;&gt; &lt;code&gt;setNameConstraints(byte [] bytes)&lt;/code&gt; &lt;/a&gt; 에 대한 설명서에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="89d3f5a0a3d4ea6ce2bb9307cf0651027e621ab6" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 3280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;trustanchor#TrustAnchor-java.security.cert.X509Certificate-byte:A-&quot;&gt;&lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열에는 RFC 3280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식이 포함됩니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;trustanchor#TrustAnchor-java.security.cert.X509Certificate-byte:A-&quot;&gt; &lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt; &lt;/a&gt; 문서에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b28b918d68df290fd1b094f19e837f8390d6a4e" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array contains the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 5280 and X.509. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;#%3Cinit%3E(java.security.cert.X509Certificate,byte%5B%5D)&quot;&gt;&lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열에는 RFC 5280 및 X.509에 정의 된 NameConstraints 구조에 표시되는 이름 제약 조건의 DER 인코딩 형식이 포함되어 있습니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#%3Cinit%3E(java.security.cert.X509Certificate,byte%5B%5D)&quot;&gt; &lt;code&gt;TrustAnchor(X509Certificate trustedCert, byte[] nameConstraints) &lt;/code&gt; &lt;/a&gt; 에 대한 설명서에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="524b24674014cc8494bd832aa5a756b964afc8ea" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array should contain the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc5280&quot;&gt;RFC 5280&lt;/a&gt; and X.509. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열은 &lt;a href=&quot;http://tools.ietf.org/html/rfc5280&quot;&gt;RFC 5280&lt;/a&gt; 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약 조건의 DER 인코딩 형식을 포함해야합니다 . 이 구조의 ASN.1 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd71c93b574504f37799ee1431d64b7c869dace9" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array should contain the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280&quot;&gt;RFC 3280&lt;/a&gt; and X.509. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280&quot;&gt;RFC 3280&lt;/a&gt; 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식을 포함해야합니다 . 이 구조의 ASN.1 정의는 아래와 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9da8a923fd342992d3b685a87125e7c68161db4" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array should contain the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot;&gt;RFC 5280&lt;/a&gt; and X.509. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름 제약은 바이트 배열로 지정됩니다. 이 바이트 배열은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot;&gt;RFC 5280&lt;/a&gt; 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약 조건의 DER 인코딩 형식을 포함해야합니다 . 이 구조의 ASN.1 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e99975d51bf3d1c8399965f8cf3b760f5a960107" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array should contain the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 3280 and X.509. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열은 RFC 3280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약의 DER 인코딩 형식을 포함해야합니다. 이 구조의 ASN.1 정의는 아래와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9e2a9452b3186e3009eca8a0d6a29d10082e447" translate="yes" xml:space="preserve">
          <source>The name constraints are specified as a byte array. This byte array should contain the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 5280 and X.509. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름 제약 조건은 바이트 배열로 지정됩니다. 이 바이트 배열은 RFC 5280 및 X.509에 정의 된 NameConstraints 구조에 나타나는 것처럼 이름 제약 조건의 DER 인코딩 형식을 포함해야합니다. 이 구조의 ASN.1 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2a86ce9761888022d92a9c1c1d8d272ebe5b60b" translate="yes" xml:space="preserve">
          <source>The name constraints have been violated.</source>
          <target state="translated">이름 제약 조건이 위반되었습니다.</target>
        </trans-unit>
        <trans-unit id="fb5609cf8ee988ed37ea8ec6d46d1aac96bcf30c" translate="yes" xml:space="preserve">
          <source>The name for a &lt;code&gt;SyncProvider&lt;/code&gt; implementation is its fully qualified class name.</source>
          <target state="translated">&lt;code&gt;SyncProvider&lt;/code&gt; 구현 의 이름 은 완전한 클래스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="61219587bf820289ff27cf1e6a6218813200b244" translate="yes" xml:space="preserve">
          <source>The name for a BasicPermission is the name of the given permission (for example, &quot;exit&quot;, &quot;setFactory&quot;, &quot;print.queueJob&quot;, etc). The naming convention follows the hierarchical property naming convention. An asterisk may appear by itself, or if immediately preceded by a &quot;.&quot; may appear at the end of the name, to signify a wildcard match. For example, &quot;*&quot; and &quot;java.*&quot; signify a wildcard match, while &quot;*java&quot;, &quot;a*b&quot;, and &quot;java*&quot; do not.</source>
          <target state="translated">BasicPermission의 이름은 주어진 권한의 이름입니다 (예 : &quot;exit&quot;, &quot;setFactory&quot;, &quot;print.queueJob&quot;등). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 별표가 단독으로 표시되거나 바로 앞에 &quot;.&quot;가 표시 될 수 있습니다. 와일드 카드 일치를 나타 내기 위해 이름 끝에 표시 될 수 있습니다. 예를 들어, &quot;*&quot;및 &quot;java. *&quot;는 와일드 카드 일치를 나타내며 &quot;* java&quot;, &quot;a * b&quot;및 &quot;java *&quot;는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db9c2273c564987e782fbfec8a9e4358476a9138" translate="yes" xml:space="preserve">
          <source>The name given to the default logical style attached to paragraphs.</source>
          <target state="translated">단락에 첨부 된 기본 논리 스타일에 지정된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="266e8cd855ff7a938d3adfd87b104087c04d25c9" translate="yes" xml:space="preserve">
          <source>The name in the &lt;code&gt;Map&lt;/code&gt; is the event name and the setting name separated by &lt;code&gt;&quot;#&quot;&lt;/code&gt; (for example, &lt;code&gt;&quot;jdk.VMInfo#period&quot;&lt;/code&gt;). The value is a textual representation of the settings value (for example, &lt;code&gt;&quot;60 s&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 의 이름은 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 로 구분 된 이벤트 이름 및 설정 이름입니다 (예 : &lt;code&gt;&quot;jdk.VMInfo#period&quot;&lt;/code&gt; ). 값은 설정 값의 텍스트 표현입니다 (예 : &lt;code&gt;&quot;60 s&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="82ff8cd92cff0415e94e8baa63e9f434898b77cd" translate="yes" xml:space="preserve">
          <source>The name in the binding is to be resolved relative to the event source &lt;code&gt;getEventContext()&lt;/code&gt;. The object returned by &lt;code&gt;Binding.getObject()&lt;/code&gt; may be null if such information is unavailable.</source>
          <target state="translated">바인딩의 이름은 이벤트 소스 &lt;code&gt;getEventContext()&lt;/code&gt; 됩니다. 이러한 정보를 사용할 수없는 경우 &lt;code&gt;Binding.getObject()&lt;/code&gt; 반환 한 객체 가 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc5a2efbe42dd82d80c8a01dba24d15cfd7bf55" translate="yes" xml:space="preserve">
          <source>The name is a &lt;code&gt;String&lt;/code&gt; that corresponds to the name of one of the static &lt;code&gt;SystemColor&lt;/code&gt; fields in the &lt;code&gt;
 SystemColor&lt;/code&gt; class. A name-color pair is created for every such &lt;code&gt;SystemColor&lt;/code&gt; field.</source>
          <target state="translated">이름은 &lt;code&gt; SystemColor&lt;/code&gt; 클래스 의 정적 &lt;code&gt;SystemColor&lt;/code&gt; 필드 중 하나의 이름에 해당 하는 &lt;code&gt;String&lt;/code&gt; 입니다 . 이러한 모든 &lt;code&gt;SystemColor&lt;/code&gt; 필드에 대해 이름-색상 쌍이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9f47c549f8f573a54eea31230a13704fa78151b" translate="yes" xml:space="preserve">
          <source>The name is a URL, or a name to be resolved relative to the initial context, or if the first character of the name is &quot;.&quot;, the name is relative to the context in which the link is bound.</source>
          <target state="translated">이름은 URL이거나 초기 컨텍스트를 기준으로 확인할 이름이거나 이름의 첫 문자가 &quot;.&quot;인 경우 이름은 링크가 바인딩 된 컨텍스트와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="61679979254cb486e82d74694afb2ea52ea52989" translate="yes" xml:space="preserve">
          <source>The name is finally normalized using normalization form KD, as described in the Unicode Standard and UAX #15</source>
          <target state="translated">이름은 유니 코드 표준 및 UAX # 15에 설명 된대로 정규화 양식 KD를 사용하여 최종적으로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="b349c489e66c9815159d8237cb45765e03ef77a1" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure appears in the documentation for &lt;a href=&quot;#setIssuerNames(java.util.Collection)&quot;&gt;&lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열은 X.501에 정의 된대로 단일 DER 인코딩 고유 이름을 포함해야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#setIssuerNames(java.util.Collection)&quot;&gt; &lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt; &lt;/a&gt; 설명서에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b968c3e471f5cb8bcebdf43477ac33f88899fb6" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure appears in the documentation for &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt;&lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열에는 X.501에 정의 된대로 단일 DER 인코딩 식별 이름이 포함되어야합니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509crlselector#setIssuerNames-java.util.Collection-&quot;&gt; &lt;code&gt;setIssuerNames(Collection names)&lt;/code&gt; &lt;/a&gt; 문서에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d62c30e2e16759f0de7f148ea8688978e4f0848c" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain the DER encoded name, as it would appear in the GeneralName structure defined in RFC 3280 and X.509. The ASN.1 definition of this structure appears in the documentation for &lt;a href=&quot;x509certselector#addSubjectAlternativeName-int-byte:A-&quot;&gt;&lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열에는 RFC 3280 및 X.509에 정의 된 GeneralName 구조에 나타나는 DER 인코딩 이름이 포함되어야합니다. 이 구조의 ASN.1 정의는 &lt;a href=&quot;x509certselector#addSubjectAlternativeName-int-byte:A-&quot;&gt; &lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="33c854a97c7935726ec4f0b93f3dec6e0b700626" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain the DER encoded name, as it would appear in the GeneralName structure defined in RFC 3280 and X.509. The encoded byte array should only contain the encoded value of the name, and should not include the tag associated with the name in the GeneralName structure. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열에는 RFC 3280 및 X.509에 정의 된 GeneralName 구조에 나타나는 DER 인코딩 이름이 포함되어야합니다. 인코딩 된 바이트 배열은 이름의 인코딩 된 값만 포함해야하며 GeneralName 구조에서 이름과 연관된 태그를 포함하지 않아야합니다. 이 구조의 ASN.1 정의는 아래와 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a10bc1a5f5762d2806cabd36dd335f7b09913a3" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain the DER encoded name, as it would appear in the GeneralName structure defined in RFC 5280 and X.509. The ASN.1 definition of this structure appears in the documentation for &lt;a href=&quot;#addSubjectAlternativeName(int,byte%5B%5D)&quot;&gt;&lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열에는 RFC 5280 및 X.509에 정의 된 GeneralName 구조에 나타나는 것처럼 DER로 인코딩 된 이름이 포함되어야합니다. 이 구조의 ASN.1 정의는 &lt;a href=&quot;#addSubjectAlternativeName(int,byte%5B%5D)&quot;&gt; &lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 에 대한 설명서에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75d5f67ff4edcf9b1ce9b4351faaa0aba31a87d7" translate="yes" xml:space="preserve">
          <source>The name is provided as a byte array. This byte array should contain the DER encoded name, as it would appear in the GeneralName structure defined in RFC 5280 and X.509. The encoded byte array should only contain the encoded value of the name, and should not include the tag associated with the name in the GeneralName structure. The ASN.1 definition of this structure appears below.</source>
          <target state="translated">이름은 바이트 배열로 제공됩니다. 이 바이트 배열에는 RFC 5280 및 X.509에 정의 된 GeneralName 구조에 나타나는 것처럼 DER로 인코딩 된 이름이 포함되어야합니다. 인코딩 된 바이트 배열은 이름의 인코딩 된 값만 포함해야하며 GeneralName 구조의 이름과 관련된 태그를 포함해서는 안됩니다. 이 구조의 ASN.1 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b4157e3b20b0d08a63e804105869ab9b80b570f" translate="yes" xml:space="preserve">
          <source>The name is provided in string format. &lt;a href=&quot;http://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt;, DNS, and URI names use the well-established string formats for those types (subject to the restrictions included in RFC 3280). IPv4 address names are supplied using dotted quad notation. OID address names are represented as a series of nonnegative integers separated by periods. And directory names (distinguished names) are supplied in RFC 2253 format. No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the &lt;a href=&quot;x509certselector#addSubjectAlternativeName-int-byte:A-&quot;&gt;&lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름은 문자열 형식으로 제공됩니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt; , DNS 및 URI 이름은 해당 유형에 대해 잘 설정된 문자열 형식을 사용합니다 (RFC 3280에 포함 된 제한 사항에 따라). IPv4 주소 이름은 점 쿼드 쿼드 표기법을 사용하여 제공됩니다. OID 주소 이름은 마침표로 구분 된 일련의 음이 아닌 정수로 표시됩니다. 그리고 디렉토리 이름 (고유 이름)은 RFC 2253 형식으로 제공됩니다. otherNames, X.400 이름, EDI 당사자 이름, IPv6 주소 이름 또는 다른 유형의 이름에는 표준 문자열 형식이 정의되어 있지 않습니다. &lt;a href=&quot;x509certselector#addSubjectAlternativeName-int-byte:A-&quot;&gt; &lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e0b384b9f6ffae73c057fe6ed3c6f704e7e1ee9" translate="yes" xml:space="preserve">
          <source>The name is provided in string format. &lt;a href=&quot;http://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt;, DNS, and URI names use the well-established string formats for those types (subject to the restrictions included in RFC 5280). IPv4 address names are supplied using dotted quad notation. OID address names are represented as a series of nonnegative integers separated by periods. And directory names (distinguished names) are supplied in RFC 2253 format. No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the &lt;a href=&quot;#addSubjectAlternativeName(int,byte%5B%5D)&quot;&gt;&lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름은 문자열 형식으로 제공됩니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt; , DNS 및 URI 이름은 이러한 유형에 대해 잘 설정된 문자열 형식을 사용합니다 (RFC 5280에 포함 된 제한 사항이 적용됨). IPv4 주소 이름은 점으로 된 쿼드 표기법을 사용하여 제공됩니다. OID 주소 이름은 마침표로 구분 된 일련의 음이 아닌 정수로 표시됩니다. 그리고 디렉터리 이름 (고유 이름)은 RFC 2253 형식으로 제공됩니다. otherNames, X.400 이름, EDI 당사자 이름, IPv6 주소 이름 또는 기타 유형의 이름에 대해서는 표준 문자열 형식이 정의되어 있지 않습니다. &lt;a href=&quot;#addSubjectAlternativeName(int,byte%5B%5D)&quot;&gt; &lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2d00b61b074cad56183a19ceb332126727471201" translate="yes" xml:space="preserve">
          <source>The name is provided in string format. &lt;a href=&quot;https://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt;, DNS, and URI names use the well-established string formats for those types (subject to the restrictions included in RFC 5280). IPv4 address names are supplied using dotted quad notation. OID address names are represented as a series of nonnegative integers separated by periods. And directory names (distinguished names) are supplied in RFC 2253 format. No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the &lt;a href=&quot;#addSubjectAlternativeName(int,byte%5B%5D)&quot;&gt;&lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름은 문자열 형식으로 제공됩니다. &lt;a href=&quot;https://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt; , DNS 및 URI 이름은 이러한 유형에 대해 잘 설정된 문자열 형식을 사용합니다 (RFC 5280에 포함 된 제한 사항이 적용됨). IPv4 주소 이름은 점으로 된 쿼드 표기법을 사용하여 제공됩니다. OID 주소 이름은 마침표로 구분 된 일련의 음이 아닌 정수로 표시됩니다. 그리고 디렉터리 이름 (고유 이름)은 RFC 2253 형식으로 제공됩니다. otherNames, X.400 이름, EDI 당사자 이름, IPv6 주소 이름 또는 기타 유형의 이름에 대해서는 표준 문자열 형식이 정의되어 있지 않습니다. &lt;a href=&quot;#addSubjectAlternativeName(int,byte%5B%5D)&quot;&gt; &lt;code&gt;addSubjectAlternativeName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="07a1eed59f77ed056220265851c4bb840c68eb88" translate="yes" xml:space="preserve">
          <source>The name is provided in string format. RFC 822, DNS, and URI names use the well-established string formats for those types (subject to the restrictions included in RFC 3280). IPv4 address names are supplied using dotted quad notation. OID address names are represented as a series of nonnegative integers separated by periods. And directory names (distinguished names) are supplied in RFC 2253 format. No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the &lt;a href=&quot;x509certselector#addPathToName-int-byte:A-&quot;&gt;&lt;code&gt;addPathToName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름은 문자열 형식으로 제공됩니다. RFC 822, DNS 및 URI 이름은 RFC 3280에 포함 된 제한 사항에 따라 해당 유형에 대해 잘 설정된 문자열 형식을 사용합니다. IPv4 주소 이름은 점 쿼드 쿼드 표기법을 사용하여 제공됩니다. OID 주소 이름은 마침표로 구분 된 일련의 음이 아닌 정수로 표시됩니다. 그리고 디렉토리 이름 (고유 이름)은 RFC 2253 형식으로 제공됩니다. otherNames, X.400 이름, EDI 당사자 이름, IPv6 주소 이름 또는 다른 유형의 이름에는 표준 문자열 형식이 정의되어 있지 않습니다. &lt;a href=&quot;x509certselector#addPathToName-int-byte:A-&quot;&gt; &lt;code&gt;addPathToName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6019cd3e2b1f21c1ba8c7668ed41fe65ddab9695" translate="yes" xml:space="preserve">
          <source>The name is provided in string format. RFC 822, DNS, and URI names use the well-established string formats for those types (subject to the restrictions included in RFC 5280). IPv4 address names are supplied using dotted quad notation. OID address names are represented as a series of nonnegative integers separated by periods. And directory names (distinguished names) are supplied in RFC 2253 format. No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the &lt;a href=&quot;#addPathToName(int,byte%5B%5D)&quot;&gt;&lt;code&gt;addPathToName(int type, byte [] name)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름은 문자열 형식으로 제공됩니다. RFC 822, DNS 및 URI 이름은 이러한 유형에 대해 잘 확립 된 문자열 형식을 사용합니다 (RFC 5280에 포함 된 제한 사항이 적용됨). IPv4 주소 이름은 점으로 구분 된 쿼드 표기법을 사용하여 제공됩니다. OID 주소 이름은 마침표로 구분 된 일련의 음이 아닌 정수로 표시됩니다. 그리고 디렉터리 이름 (고유 이름)은 RFC 2253 형식으로 제공됩니다. otherNames, X.400 이름, EDI 당사자 이름, IPv6 주소 이름 또는 기타 유형의 이름에 대해서는 표준 문자열 형식이 정의되어 있지 않습니다. &lt;a href=&quot;#addPathToName(int,byte%5B%5D)&quot;&gt; &lt;code&gt;addPathToName(int type, byte [] name)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="062b23aadb7d34d7c8b4e9c121e5a95a465b4012" translate="yes" xml:space="preserve">
          <source>The name is the name of the property (&quot;java.home&quot;, &quot;os.name&quot;, etc). The naming convention follows the hierarchical property naming convention. Also, an asterisk may appear at the end of the name, following a &quot;.&quot;, or by itself, to signify a wildcard match. For example: &quot;java.*&quot; and &quot;*&quot; signify a wildcard match, while &quot;*java&quot; and &quot;a*b&quot; do not.</source>
          <target state="translated">이름은 속성의 이름입니다 ( &quot;java.home&quot;, &quot;os.name&quot;등). 명명 규칙은 계층 적 속성 명명 규칙을 따릅니다. 또한 별표는 이름 끝에 &quot;.&quot;뒤에 또는 와일드 카드 일치를 나타 내기 위해 나타날 수 있습니다. 예를 들어, &quot;java. *&quot;및 &quot;*&quot;는 와일드 카드 일치를 나타내며 &quot;* java&quot;및 &quot;a * b&quot;는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5739ea579054ab19a148abf7bf72c35ee5d92488" translate="yes" xml:space="preserve">
          <source>The name must be a valid Java identifier (for example, &lt;code&gt;&quot;maxThroughput&quot;&lt;/code&gt;). See 3.8 Java Language Specification for more information.</source>
          <target state="translated">이름은 유효한 Java 식별자 (예 : &lt;code&gt;&quot;maxThroughput&quot;&lt;/code&gt; ) 여야 합니다. 자세한 내용은 3.8 Java 언어 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53ca24ddb66b7f4c546487a257cc2792abfc1758" translate="yes" xml:space="preserve">
          <source>The name must be a valid identifiers in the Java language (for example, &lt;code&gt;&quot;com.example.MyEvent&quot;&lt;/code&gt; for an event class or &lt;code&gt;&quot;message&quot;&lt;/code&gt; for an event field).</source>
          <target state="translated">이름은 Java 언어의 유효한 식별자 여야합니다 (예 : 이벤트 클래스의 경우 &lt;code&gt;&quot;com.example.MyEvent&quot;&lt;/code&gt; , 이벤트 필드의 경우 &lt;code&gt;&quot;message&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bfa54156ec30f9bc348736a478f8a06c98b8284b" translate="yes" xml:space="preserve">
          <source>The name must conform to RFC 2965. That means it can contain only ASCII alphanumeric characters and cannot contain commas, semicolons, or white space or begin with a $ character. The cookie's name cannot be changed after creation.</source>
          <target state="translated">이름은 RFC 2965를 준수해야합니다. 즉, ASCII 영숫자 문자 만 포함 할 수 있으며 쉼표, 세미콜론 또는 공백을 포함하거나 $ 문자로 시작할 수 없습니다. 쿠키 이름은 생성 후 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="996c6de93ebccc7b84117ecaee62f38d7311a913" translate="yes" xml:space="preserve">
          <source>The name of DTD; i.e., the name immediately following the &lt;code&gt;DOCTYPE&lt;/code&gt; keyword.</source>
          <target state="translated">DTD의 이름. 즉, &lt;code&gt;DOCTYPE&lt;/code&gt; 키워드 바로 뒤에 오는 이름 .</target>
        </trans-unit>
        <trans-unit id="a0b966f42feea9c33f3253f299c07faeb601d6d2" translate="yes" xml:space="preserve">
          <source>The name of a generic type does not include any reference to its formal type parameters. For example, the fully qualified name of the interface &lt;code&gt;java.util.Set&amp;lt;E&amp;gt;&lt;/code&gt; is &quot;&lt;code&gt;java.util.Set&lt;/code&gt;&quot;. Nested types use &quot;&lt;code&gt;.&lt;/code&gt;&quot; as a separator, as in &quot;&lt;code&gt;java.util.Map.Entry&lt;/code&gt;&quot;.</source>
          <target state="translated">제네릭 형식의 이름에는 형식 형식 매개 변수에 대한 참조가 포함되어 있지 않습니다. 예를 들어, 인터페이스 &lt;code&gt;java.util.Set&amp;lt;E&amp;gt;&lt;/code&gt; 의 완전한 이름 은 &quot; &lt;code&gt;java.util.Set&lt;/code&gt; &quot;입니다. 중첩 유형 은 &quot; &lt;code&gt;java.util.Map.Entry&lt;/code&gt; &quot; 에서와 같이 &quot; &lt;code&gt;.&lt;/code&gt; &quot;을 분리 자로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="586a3e128f97fabfbfbfd557a68c800759fa8523" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the bound server name for an unbound server.</source>
          <target state="translated">바인딩되지 않은 서버의 바인딩 된 서버 이름을 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f50fffd870d393ff1d83992d3375d9ebcd02098f" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the bound server name for an unbound server. A server is created as an unbound server by setting the &lt;code&gt;serverName&lt;/code&gt; argument in &lt;a href=&quot;#createSaslServer(java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)&quot;&gt;&lt;code&gt;createSaslServer(java.lang.String, java.lang.String, java.lang.String, java.util.Map&amp;lt;java.lang.String, ?&amp;gt;, javax.security.auth.callback.CallbackHandler)&lt;/code&gt;&lt;/a&gt; as null. The property contains the bound host name after the authentication exchange has completed. It is only available on the server side.</source>
          <target state="translated">바인딩되지 않은 서버의 바인딩 된 서버 이름을 지정하는 속성의 이름입니다. 서버는 &lt;a href=&quot;#createSaslServer(java.lang.String,java.lang.String,java.lang.String,java.util.Map,javax.security.auth.callback.CallbackHandler)&quot;&gt; &lt;code&gt;createSaslServer(java.lang.String, java.lang.String, java.lang.String, java.util.Map&amp;lt;java.lang.String, ?&amp;gt;, javax.security.auth.callback.CallbackHandler)&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;serverName&lt;/code&gt; 인수를 설정하여 언 바운드 서버로 생성됩니다. .security.auth.callback.CallbackHandler) 를 null로 지정합니다. 속성에는 인증 교환이 완료된 후 바인딩 된 호스트 이름이 포함됩니다. 서버 측에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dc7a8ad79c2d57c4b3606f2370da251a94ec44b" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the bound server name for an unbound server. A server is created as an unbound server by setting the &lt;code&gt;serverName&lt;/code&gt; argument in &lt;a href=&quot;sasl#createSaslServer-java.lang.String-java.lang.String-java.lang.String-java.util.Map-javax.security.auth.callback.CallbackHandler-&quot;&gt;&lt;code&gt;createSaslServer(java.lang.String, java.lang.String, java.lang.String, java.util.Map&amp;lt;java.lang.String, ?&amp;gt;, javax.security.auth.callback.CallbackHandler)&lt;/code&gt;&lt;/a&gt; as null. The property contains the bound host name after the authentication exchange has completed. It is only available on the server side.</source>
          <target state="translated">바인딩되지 않은 서버에 대한 바인딩 된 서버 이름을 지정하는 속성의 이름입니다. 서버는 &lt;a href=&quot;sasl#createSaslServer-java.lang.String-java.lang.String-java.lang.String-java.util.Map-javax.security.auth.callback.CallbackHandler-&quot;&gt; &lt;code&gt;createSaslServer(java.lang.String, java.lang.String, java.lang.String, java.util.Map&amp;lt;java.lang.String, ?&amp;gt;, javax.security.auth.callback.CallbackHandler)&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;serverName&lt;/code&gt; 인수를 설정하여 언 바운드 서버로 작성됩니다. .security.auth.callback.CallbackHandler) 를 null로 반환합니다 . 인증 교환이 완료된 후 속성에 바인딩 된 호스트 이름이 포함됩니다. 서버 측에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b55f9b70a02e260dfa3c61e0194b4235bd08a1d" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the cipher strength to use.</source>
          <target state="translated">사용할 암호 강도를 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="31543f2d17616a509f1542da77a0190a933ae420" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the cipher strength to use. The property contains a comma-separated, ordered list of cipher strength values that the client or server is willing to support. A strength value is one of</source>
          <target state="translated">사용할 암호 강도를 지정하는 특성의 이름입니다. 이 속성에는 클라이언트 또는 서버가 지원할 쉼표로 구분 된 순서의 암호 수준 값 목록이 포함됩니다. 강도 값은</target>
        </trans-unit>
        <trans-unit id="a910b5b12f169a8c9e6299db186743853fa9fd06" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the credentials to use.</source>
          <target state="translated">사용할 자격 증명을 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="55e2920c36428c57f886e32853d1f39a8e1f86e0" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the credentials to use. The property contains a mechanism-specific Java credential object. Mechanism implementations may examine the value of this property to determine whether it is a class that they support. The property may be used to supply credentials to a mechanism that supports delegated authentication.</source>
          <target state="translated">사용할 자격 증명을 지정하는 속성의 이름입니다. 이 특성에는 메커니즘 별 Java 신임 오브젝트가 포함되어 있습니다. 메커니즘 구현에서는이 속성의 값을 검사하여 해당 속성이 지원하는 클래스인지 확인할 수 있습니다. 이 속성은 위임 된 인증을 지원하는 메커니즘에 자격 증명을 제공하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2501b67874585ca960fda8402bd14c813cfae62" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the maximum size of the raw send buffer in bytes of &lt;code&gt;SaslClient&lt;/code&gt;/&lt;code&gt;SaslServer&lt;/code&gt;.</source>
          <target state="translated">원시 전송 버퍼의 최대 크기 (바이트)를 &lt;code&gt;SaslClient&lt;/code&gt; / &lt;code&gt;SaslServer&lt;/code&gt; 로 지정하는 속성의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="56b920153e04b83edb9986c955cfd7fb277a67ff" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the maximum size of the raw send buffer in bytes of &lt;code&gt;SaslClient&lt;/code&gt;/&lt;code&gt;SaslServer&lt;/code&gt;. The property contains the string representation of an integer. The value of this property is negotiated between the client and server during the authentication exchange.</source>
          <target state="translated">원시 전송 버퍼의 최대 크기를 &lt;code&gt;SaslClient&lt;/code&gt; / &lt;code&gt;SaslServer&lt;/code&gt; 의 바이트 단위로 지정하는 특성의 이름입니다 . 이 속성에는 정수의 문자열 표현이 포함됩니다. 이 속성의 값은 인증 교환 중에 클라이언트와 서버간에 협상됩니다.</target>
        </trans-unit>
        <trans-unit id="50ebc98595175a09096a08393ea23c009230db69" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the maximum size of the receive buffer in bytes of &lt;code&gt;SaslClient&lt;/code&gt;/&lt;code&gt;SaslServer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SaslClient&lt;/code&gt; / &lt;code&gt;SaslServer&lt;/code&gt; 의 바이트 단위로 수신 버퍼의 최대 크기를 지정하는 속성의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="5e65556f8d43cf173606f56669dc9e1376a6357a" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the maximum size of the receive buffer in bytes of &lt;code&gt;SaslClient&lt;/code&gt;/&lt;code&gt;SaslServer&lt;/code&gt;. The property contains the string representation of an integer.</source>
          <target state="translated">수신 버퍼의 최대 크기를 &lt;code&gt;SaslClient&lt;/code&gt; / &lt;code&gt;SaslServer&lt;/code&gt; 의 바이트 단위로 지정하는 특성의 이름입니다 . 이 속성에는 정수의 문자열 표현이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1a5b3e7cc0cb1dea4bf1a55bf0bf2a3076634087" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the quality-of-protection to use.</source>
          <target state="translated">사용할 보호 품질을 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7c2208ad557360dbabcdcb1796613d7ab45b49c2" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies the quality-of-protection to use. The property contains a comma-separated, ordered list of quality-of-protection values that the client or server is willing to support. A qop value is one of</source>
          <target state="translated">사용할 보호 수준을 지정하는 속성의 이름입니다. 이 속성에는 클라이언트 또는 서버가 지원할 쉼표로 구분 된 순서대로 보호 품질 값 목록이 포함됩니다. qop 값은</target>
        </trans-unit>
        <trans-unit id="cd8f19eb65ae48b796032fae90788d4c582fd1e0" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to active (non-dictionary) attacks are not permitted.</source>
          <target state="translated">활성 (사전이 아닌) 공격에 취약한 메커니즘이 허용되지 않는지 여부를 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b8d78b06c714a7846430cd85289564a8ba25548a" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to active (non-dictionary) attacks are not permitted. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms susceptible to active attacks are not permitted; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are permitted. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">활성 (사전이 아닌) 공격에 취약한 메커니즘이 허용되지 않는지 여부를 지정하는 속성의 이름입니다. 활성 공격에 취약한 메커니즘이 허용되지 않으면 이 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 허용되는 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ef96d0876dd10348f8c1f12dd21e6f2560d1563" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to passive dictionary attacks are not permitted.</source>
          <target state="translated">수동 사전 공격에 취약한 메커니즘이 허용되지 않는지 여부를 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7ccacffcd7e795c6f2158de9fc95195180770467" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to passive dictionary attacks are not permitted. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms susceptible to dictionary attacks are not permitted; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are permitted. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">수동 사전 공격에 취약한 메커니즘이 허용되지 않는지 여부를 지정하는 특성의 이름입니다. 사전 공격에 취약한 메커니즘이 허용되지 않으면 이 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 허용되는 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="abaa82f841676a61897a58942179bb4b525225bf" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to simple plain passive attacks (e.g., &quot;PLAIN&quot;) are not permitted.</source>
          <target state="translated">단순 일반 수동 공격 (예 : &quot;PLAIN&quot;)에 취약한 메커니즘이 허용되지 않는지 여부를 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6b6e642921edcbb0aeb070dc85a3fae28c660e0e" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms susceptible to simple plain passive attacks (e.g., &quot;PLAIN&quot;) are not permitted. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if such mechanisms are not permitted; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are permitted. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">단순한 일반 수동 공격에 취약한 메커니즘 (예 : &quot;PLAIN&quot;)이 허용되지 않는지 여부를 지정하는 속성의 이름입니다. 이러한 메커니즘이 허용되지 않으면 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 허용되는 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c2be230b027b47e8ceacad313b7a595b8ba10cde" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that accept anonymous login are not permitted.</source>
          <target state="translated">익명 로그인을 허용하는 메커니즘이 허용되지 않는지 여부를 지정하는 특성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f4fcba71a86df30c02372fc37f3f03794d3958d1" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that accept anonymous login are not permitted. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms that accept anonymous login are not permitted; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are permitted. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">익명 로그인을 허용하는 메커니즘이 허용되지 않는지 여부를 지정하는 특성의 이름입니다. 익명 로그인을 허용하는 메커니즘이 허용되지 않으면 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 허용되는 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="011a1d9f0a1619c5f4de3beca91ad9ce6660674c" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that implement forward secrecy between sessions are required.</source>
          <target state="translated">세션간에 순방향 보안을 구현하는 메커니즘이 필요한지 여부를 지정하는 특성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="06776ce760218a8bb3c69a553b99504e2368a22b" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that implement forward secrecy between sessions are required. Forward secrecy means that breaking into one session will not automatically provide information for breaking into future sessions. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms that implement forward secrecy between sessions are required; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are not required. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">세션 사이에 포워드 보안을 구현하는 메커니즘이 필요한지 여부를 지정하는 특성의 이름입니다. 순방향 비밀은 한 세션으로 침입해도 향후 세션으로 침입하기위한 정보를 자동으로 제공하지 않음을 의미합니다. 세션간에 순방향 비밀을 구현하는 메커니즘이 필요한 경우이 속성에는 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 필요하지 않은 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1ab394d56b4345203ccd73fb6be21a6d4fbda32a" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that pass client credentials are required.</source>
          <target state="translated">클라이언트 자격 증명을 전달하는 메커니즘이 필요한지 여부를 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0ce55bb11912a17b35cd30b5ec6b2d3629fbdf83" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether mechanisms that pass client credentials are required. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if mechanisms that pass client credentials are required; &lt;code&gt;&quot;false&quot;&lt;/code&gt; if such mechanisms are not required. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">클라이언트 자격 증명을 전달하는 메커니즘이 필요한지 여부를 지정하는 속성의 이름입니다. 클라이언트 자격 증명을 전달하는 메커니즘이 필요한 경우 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그러한 메커니즘이 필요하지 않은 경우 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="576ff001ae8f0589bede75beb4f725c2066586f4" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether the server must authenticate to the client.</source>
          <target state="translated">서버가 클라이언트에 인증해야하는지 여부를 지정하는 특성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="11148564aae0a7b5ceb776e3ad9122d4f8cc5031" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether the server must authenticate to the client. The property contains &lt;code&gt;&quot;true&quot;&lt;/code&gt; if the server must authenticate the to client; &lt;code&gt;&quot;false&quot;&lt;/code&gt; otherwise. The default is &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">서버가 클라이언트를 인증해야하는지 여부를 지정하는 특성의 이름입니다. 서버가 클라이언트를 인증해야하는 경우 속성에 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 가 포함 됩니다. 그렇지 않으면 &lt;code&gt;&quot;false&quot;&lt;/code&gt; . 기본값은 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="832866552eccab3a6d070c63001ca0fadd95eee1" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether to reuse previously authenticated session information.</source>
          <target state="translated">이전에 인증 된 세션 정보를 재사용할지 여부를 지정하는 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f8afde55a67986c5517be4ac59b9842900fb0c1e" translate="yes" xml:space="preserve">
          <source>The name of a property that specifies whether to reuse previously authenticated session information. The property contains &quot;true&quot; if the mechanism implementation may attempt to reuse previously authenticated session information; it contains &quot;false&quot; if the implementation must not reuse previously authenticated session information. A setting of &quot;true&quot; serves only as a hint: it does not necessarily entail actual reuse because reuse might not be possible due to a number of reasons, including, but not limited to, lack of mechanism support for reuse, expiration of reusable information, and the peer's refusal to support reuse. The property's default value is &quot;false&quot;. The value of this constant is &quot;javax.security.sasl.reuse&quot;. Note that all other parameters and properties required to create a SASL client/server instance must be provided regardless of whether this property has been supplied. That is, you cannot supply any less information in anticipation of reuse. Mechanism implementations that support reuse might allow customization of its implementation, for factors such as cache size, timeouts, and criteria for reusability. Such customizations are implementation-dependent.</source>
          <target state="translated">이전에 인증 된 세션 정보를 재사용할지 여부를 지정하는 특성의 이름입니다. 메커니즘 구현이 이전에 인증 된 세션 정보를 재사용하려고 시도 할 수있는 경우 특성에 &quot;true&quot;가 포함됩니다. 구현에서 이전에 인증 된 세션 정보를 재사용하지 않아야하는 경우 &quot;false&quot;를 포함합니다. &quot;true&quot;로 설정하면 힌트로만 사용됩니다. 재사용에 대한 메커니즘 지원 부족, 재사용 가능한 정보의 만료 등 여러 가지 이유로 재사용이 불가능할 수 있기 때문에 실제 재사용이 반드시 필요한 것은 아닙니다. , 동료의 재사용 지원 거부. 속성의 기본값은 &quot;false&quot;입니다. 이 상수의 값은 &quot;javax.security.sasl.reuse&quot;입니다.SASL 클라이언트 / 서버 인스턴스를 작성하는 데 필요한 다른 모든 매개 변수 및 특성은이 특성의 제공 여부에 관계없이 제공되어야합니다. 즉, 재사용을 예상 할 때 더 적은 정보를 제공 할 수 없습니다. 재사용을 지원하는 메커니즘 구현은 캐시 크기, 제한 시간 및 재사용 성 기준과 같은 요소에 대해 구현을 사용자 정의 할 수 있습니다. 이러한 사용자 지정은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="883225677e8f8e5b399c448f823a43abbfc061ea" translate="yes" xml:space="preserve">
          <source>The name of a resource is a '&lt;code&gt;/&lt;/code&gt;'-separated path name that identifies the resource.</source>
          <target state="translated">자원의 이름은 자원 을 식별 하는 ' &lt;code&gt;/&lt;/code&gt; '로 구분 된 경로 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a515910aa70c3ebcc7ce4ca607dd0dd4f6d0da22" translate="yes" xml:space="preserve">
          <source>The name of a resource is a &lt;code&gt;/&lt;/code&gt;-separated path name that identifies the resource.</source>
          <target state="translated">자원의 이름은 자원 을 식별 하는 &lt;code&gt;/&lt;/code&gt; 로 구분 된 경로 이름입니다.</target>
        </trans-unit>
        <trans-unit id="319adc5d83fce6f79c34d9545b7888dbf5045286" translate="yes" xml:space="preserve">
          <source>The name of a run-time parameter.</source>
          <target state="translated">런타임 매개 변수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ef4cac5600d37eabcbd751e94b89085faefd95e6" translate="yes" xml:space="preserve">
          <source>The name of a run-time parameter. See the name attribute definition in HTML 4.0.</source>
          <target state="translated">런타임 매개 변수의 이름입니다. HTML 4.0의 이름 속성 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b3ecc612b49df85d98b697f4e1750b6def88652" translate="yes" xml:space="preserve">
          <source>The name of a runtime permission required to successfully invoke the &lt;a href=&quot;#getLookup()&quot;&gt;&lt;code&gt;getLookup()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#getLookup()&quot;&gt; &lt;code&gt;getLookup()&lt;/code&gt; &lt;/a&gt; 메서드 를 성공적으로 호출하는 데 필요한 런타임 권한의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="6c6bde9766a09b2f3be7c967965b9ca843d70a67" translate="yes" xml:space="preserve">
          <source>The name of a type declared for the associated element or attribute, or &lt;code&gt;null&lt;/code&gt; if unknown.</source>
          <target state="translated">연관된 요소 또는 속성에 대해 선언 된 유형의 이름 또는 알 수없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="62982d29904d31c3a0cbb4a261e01b9f577843f4" translate="yes" xml:space="preserve">
          <source>The name of each record component must be distinct from the names of all other record components.</source>
          <target state="translated">각 레코드 구성 요소의 이름은 다른 모든 레코드 구성 요소의 이름과 구별되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fe25ce1fcf2cee52aa157f625ee02fa6e4aef934" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#defaultValue&quot;&gt;&lt;code&gt;
 defaultValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#defaultValue&quot;&gt; &lt;code&gt; defaultValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="02a87ad296b6a16e86ed792fcd23b2d436a8aa38" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#defaultValue&quot;&gt;&lt;code&gt;defaultValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#defaultValue&quot;&gt; &lt;code&gt;defaultValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="fb29c322db8f3271ac67d4a85fa88b1e19ea74b5" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#immutableInfo&quot;&gt;&lt;code&gt;
 immutableInfo&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#immutableInfo&quot;&gt; &lt;code&gt; immutableInfo&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="21a7183405f994f4abb54ab06bb8d0ca6abd1b33" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#immutableInfo&quot;&gt;&lt;code&gt;immutableInfo&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#immutableInfo&quot;&gt; &lt;code&gt;immutableInfo&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="28b747c7a3c7144aafa0ddadca50daced5ec5e60" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#interfaceClassName&quot;&gt;&lt;code&gt;
 interfaceClassName&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#interfaceClassName&quot;&gt; &lt;code&gt; interfaceClassName&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="4cae14c94ea437e28b95eb63b65b9dc19f3b9961" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#interfaceClassName&quot;&gt;&lt;code&gt;interfaceClassName&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#interfaceClassName&quot;&gt; &lt;code&gt;interfaceClassName&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="07f75e785cf9779fd44ac44a3329126cabda2bbe" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#legalValues&quot;&gt;&lt;code&gt;
 legalValues&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#legalValues&quot;&gt; &lt;code&gt; legalValues&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="9fe458bf94e08c2715db3ba7353f7b20a329fde6" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#legalValues&quot;&gt;&lt;code&gt;legalValues&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#legalValues&quot;&gt; &lt;code&gt;legalValues&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="95ff2b82f6409c0303045938f829f414f57885eb" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#maxValue&quot;&gt;&lt;code&gt;
 maxValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#maxValue&quot;&gt; &lt;code&gt; maxValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="7f056bc651ef11844698474a4860bfd2b3c8422c" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#maxValue&quot;&gt;&lt;code&gt;maxValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#maxValue&quot;&gt; &lt;code&gt;maxValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="20b8df24d89b15e474968793eeae1e9cf0905d5a" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#minValue&quot;&gt;&lt;code&gt;
 minValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#minValue&quot;&gt; &lt;code&gt; minValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="b5458eeba59dcfbb2d86cb008e54ef4459974966" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#minValue&quot;&gt;&lt;code&gt;minValue&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#minValue&quot;&gt; &lt;code&gt;minValue&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="3c360c1088b36522f6e8ac159e1dc3bfafdadb44" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#mxbean&quot;&gt;&lt;code&gt;
 mxbean&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#mxbean&quot;&gt; &lt;code&gt; mxbean&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="3d12e5d2c43700fffd1f2acdcc9bfb6314cfa143" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#mxbean&quot;&gt;&lt;code&gt;mxbean&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#mxbean&quot;&gt; &lt;code&gt;mxbean&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="b2306786e35b8dc8113a90bb0b9bfcaebbbb4111" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#openType&quot;&gt;&lt;code&gt;
 openType&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#openType&quot;&gt; &lt;code&gt; openType&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="c0f4d31dececcf3cbe425b7676d150fa31bfc39e" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#openType&quot;&gt;&lt;code&gt;openType&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#openType&quot;&gt; &lt;code&gt;openType&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="ce2f69899ea3f7db305ee78fde5c0731069c8dcd" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#originalType&quot;&gt;&lt;code&gt;
 originalType&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#originalType&quot;&gt; &lt;code&gt; originalType&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="019614432873d92a45cf0bd7b968f9482692078a" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;descriptor#originalType&quot;&gt;&lt;code&gt;originalType&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">&lt;a href=&quot;descriptor#originalType&quot;&gt; &lt;code&gt;originalType&lt;/code&gt; &lt;/a&gt; 필드 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="48744229149f107d48a57a9a32fe47303158d512" translate="yes" xml:space="preserve">
          <source>The name of the Cryptography Package Provider is designated also by the Signature parameter to the constructor and the &lt;code&gt;verify&lt;/code&gt; method. If the provider is not specified, the default provider is used. Each installation can be configured to use a particular provider as default.</source>
          <target state="translated">암호화 패키지 제공자의 이름은 Signature 매개 변수에 의해 생성자와 &lt;code&gt;verify&lt;/code&gt; 메소드 에도 지정됩니다 . 공급자를 지정하지 않으면 기본 공급자가 사용됩니다. 각 설치는 특정 공급자를 기본값으로 사용하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3374bc67db57b47fa67041ab369a402111b546bf" translate="yes" xml:space="preserve">
          <source>The name of the MBean within the MBean server to which methods are forwarded.</source>
          <target state="translated">메소드가 전달되는 MBean 서버 내의 MBean 이름.</target>
        </trans-unit>
        <trans-unit id="e603cbb804d9eb28de3e80c8071713281c1279aa" translate="yes" xml:space="preserve">
          <source>The name of the action for the key.</source>
          <target state="translated">키에 대한 작업의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="67bf46d27bfc385d4d53f17c9da30fc6ca21ea63" translate="yes" xml:space="preserve">
          <source>The name of the applet.</source>
          <target state="translated">애플릿의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a1c26c8039abfb710d40fd7960a8ffe4de3637fc" translate="yes" xml:space="preserve">
          <source>The name of the applet. See the name attribute definition in HTML 4.0. This attribute is deprecated in HTML 4.0.</source>
          <target state="translated">애플릿의 이름입니다. HTML 4.0의 이름 속성 정의를 참조하십시오. 이 속성은 HTML 4.0에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8664e99ba0ec714f65189ef121b50d48bf752bb" translate="yes" xml:space="preserve">
          <source>The name of the associated notation.</source>
          <target state="translated">연관된 표기법의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="097c841c5ffaa4f483a66be7178ea3a98d83fcc8" translate="yes" xml:space="preserve">
          <source>The name of the built-in system class loader is &lt;code&gt;&quot;app&quot;&lt;/code&gt;. The system property &quot;&lt;code&gt;java.class.path&lt;/code&gt;&quot; is read during early initialization of the VM to determine the class path. An empty value of &quot;&lt;code&gt;java.class.path&lt;/code&gt;&quot; property is interpreted differently depending on whether the initial module (the module containing the main class) is named or unnamed: If named, the built-in system class loader will have no class path and will search for classes and resources using the application module path; otherwise, if unnamed, it will set the class path to the current working directory.</source>
          <target state="translated">내장 시스템 클래스 로더의 이름은 &lt;code&gt;&quot;app&quot;&lt;/code&gt; 입니다. 클래스 경로를 판별하기 위해 VM의 초기 초기화 중에 시스템 특성 &quot; &lt;code&gt;java.class.path&lt;/code&gt; &quot;를 읽습니다. &quot; &lt;code&gt;java.class.path&lt;/code&gt; &quot;속성 의 빈 값은 초기 모듈 (메인 클래스를 포함하는 모듈)의 이름이 지정되었는지 여부에 따라 다르게 해석됩니다. 이름이 지정되면 내장 시스템 클래스 로더에 클래스 경로가 없으며 응용 프로그램 모듈 경로를 사용하여 클래스와 리소스를 검색합니다. 그렇지 않으면 이름이 지정되지 않은 경우 클래스 경로를 현재 작업 디렉토리로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="59571c11a8a61f5087536ca331e870fbc1bf9620" translate="yes" xml:space="preserve">
          <source>The name of the builtin platform class loader is &lt;code&gt;&quot;platform&quot;&lt;/code&gt;.</source>
          <target state="translated">내장 플랫폼 클래스 로더의 이름은 &lt;code&gt;&quot;platform&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a80646cd5cb31601fc4aac5527e3c066f071889e" translate="yes" xml:space="preserve">
          <source>The name of the class implementing &lt;code&gt;IIOMetadataFormat&lt;/code&gt; and representing the native metadata format, initialized to &lt;code&gt;null&lt;/code&gt; and set via the constructor.</source>
          <target state="translated">&lt;code&gt;IIOMetadataFormat&lt;/code&gt; 을 구현 하고 기본 메타 데이터 형식을 나타내는 클래스 이름 으로, &lt;code&gt;null&lt;/code&gt; 로 초기화되고 생성자를 통해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="87c36c4524553c04fdf7d1a5553c3ac41e742c7f" translate="yes" xml:space="preserve">
          <source>The name of the code generator</source>
          <target state="translated">코드 생성기의 이름</target>
        </trans-unit>
        <trans-unit id="14628be31dd329e555df1f6bfb10c67eaffa4605" translate="yes" xml:space="preserve">
          <source>The name of the country appropriate to the given locale.</source>
          <target state="translated">주어진 로케일에 적합한 국가 이름.</target>
        </trans-unit>
        <trans-unit id="4acb982db435eb2721de142ef807bacda4ac4425" translate="yes" xml:space="preserve">
          <source>The name of the country appropriate to the locale.</source>
          <target state="translated">로케일에 적합한 국가 이름.</target>
        </trans-unit>
        <trans-unit id="78358406b490b90c985dd9db549b2619ef569e50" translate="yes" xml:space="preserve">
          <source>The name of the default event set is used to calculate its &lt;a href=&quot;beaninfo#getDefaultEventIndex()&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;beaninfo#getEventSetDescriptors()&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; of event sets defined in the annotated class.</source>
          <target state="translated">기본 이벤트 세트의 이름은 어노테이션이있는 클래스에 정의 된 이벤트 세트 의 &lt;a href=&quot;beaninfo#getEventSetDescriptors()&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;beaninfo#getDefaultEventIndex()&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; 을 계산하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="04ac24816aef6488806c42c595d2915ed924cca8" translate="yes" xml:space="preserve">
          <source>The name of the default event set is used to calculate its &lt;a href=&quot;beaninfo#getDefaultEventIndex()&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;beaninfo#getEventSetDescriptors()&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; of event sets defined in the annotated class. If the name is not set or the annotated class does not define an event set with the specified name, the default event set index will be calculated automatically by the &lt;a href=&quot;introspector&quot;&gt;&lt;code&gt;Introspector&lt;/code&gt;&lt;/a&gt; depending on its state.</source>
          <target state="translated">기본 이벤트 세트의 이름은 어노테이션이있는 클래스에 정의 된 이벤트 세트 의 &lt;a href=&quot;beaninfo#getEventSetDescriptors()&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;beaninfo#getDefaultEventIndex()&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; 을 계산하는 데 사용됩니다 . 이름이 설정되지 않았거나 주석이 추가 된 클래스가 지정된 이름으로 이벤트 세트를 정의하지 않는 경우 기본 이벤트 세트 인덱스는 상태에 따라 &lt;a href=&quot;introspector&quot;&gt; &lt;code&gt;Introspector&lt;/code&gt; 에서&lt;/a&gt; 자동으로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ce6ce57d1833563bb66734286a352e834e326ed" translate="yes" xml:space="preserve">
          <source>The name of the default property is used to calculate its &lt;a href=&quot;beaninfo#getDefaultPropertyIndex()&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;beaninfo#getPropertyDescriptors()&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; of properties defined in the annotated class.</source>
          <target state="translated">기본 속성의 이름은 계산하는 데 사용되는 &lt;a href=&quot;beaninfo#getDefaultPropertyIndex()&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;beaninfo#getPropertyDescriptors()&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 주석 클래스에 정의 된 속성.</target>
        </trans-unit>
        <trans-unit id="086957e2f5e5ccd35b93f7fa6892198bfd1505fe" translate="yes" xml:space="preserve">
          <source>The name of the default property is used to calculate its &lt;a href=&quot;beaninfo#getDefaultPropertyIndex()&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;beaninfo#getPropertyDescriptors()&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; of properties defined in the annotated class. If the name is not set or the annotated class does not define a property with the specified name, the default property index will be calculated automatically by the &lt;a href=&quot;introspector&quot;&gt;&lt;code&gt;Introspector&lt;/code&gt;&lt;/a&gt; depending on its state.</source>
          <target state="translated">기본 속성의 이름은 계산하는 데 사용되는 &lt;a href=&quot;beaninfo#getDefaultPropertyIndex()&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;beaninfo#getPropertyDescriptors()&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 주석 클래스에 정의 된 속성. 이름이 설정되지 않았거나 주석이 달린 클래스가 지정된 이름을 가진 속성을 정의하지 않는 경우 기본 속성 인덱스는 상태에 따라 &lt;a href=&quot;introspector&quot;&gt; &lt;code&gt;Introspector&lt;/code&gt; 에서&lt;/a&gt; 자동으로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="5bb84751719d943c1bdfe595f0b620fdf05a9b4b" translate="yes" xml:space="preserve">
          <source>The name of the display language appropriate to the given locale.</source>
          <target state="translated">지정된 로케일에 적합한 표시 언어의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="60b08c752ba73a8a294eb2dc32a69396a5bd0e3a" translate="yes" xml:space="preserve">
          <source>The name of the display language.</source>
          <target state="translated">표시 언어의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0cef399fec1ed02c817bd26adc657c6bf0cd05e8" translate="yes" xml:space="preserve">
          <source>The name of the display variant code appropriate to the given locale.</source>
          <target state="translated">지정된 로케일에 적합한 디스플레이 변형 코드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c6f8f604377a983983396835745055e795e7955c" translate="yes" xml:space="preserve">
          <source>The name of the display variant code appropriate to the locale.</source>
          <target state="translated">로케일에 적합한 디스플레이 변형 코드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="24528e36b7470855aa32b59a5449546f41560454" translate="yes" xml:space="preserve">
          <source>The name of the element</source>
          <target state="translated">요소의 이름</target>
        </trans-unit>
        <trans-unit id="a95d25eec2ed4333c2f6d38fca0cb5eeb8fd06b9" translate="yes" xml:space="preserve">
          <source>The name of the element (for backwards compatibility).</source>
          <target state="translated">요소의 이름 (이전 버전과의 호환성을 위해).</target>
        </trans-unit>
        <trans-unit id="fc747a0011536738e1fa0490d7d958b96f02eb2a" translate="yes" xml:space="preserve">
          <source>The name of the element.</source>
          <target state="translated">요소의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6b3f6644531a48b6304ed514d2bea39651f0ab46" translate="yes" xml:space="preserve">
          <source>The name of the element. If &lt;code&gt;Node.localName&lt;/code&gt; is different from &lt;code&gt;null&lt;/code&gt;, this attribute is a qualified name. For example, in:</source>
          <target state="translated">요소의 이름입니다. 경우 &lt;code&gt;Node.localName&lt;/code&gt; 가 다른 &lt;code&gt;null&lt;/code&gt; ,이 속성은 수식 명입니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="120a36a79f97ac5cca7e6072a7f24815aa4e4e51" translate="yes" xml:space="preserve">
          <source>The name of the engine implementation.</source>
          <target state="translated">엔진 구현의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f75476630adc7537ab0942d349040825c278cc3c" translate="yes" xml:space="preserve">
          <source>The name of the entity</source>
          <target state="translated">실체의 이름</target>
        </trans-unit>
        <trans-unit id="97d6f3b8c4207b3258c6fdf35439ec4e64a6b33f" translate="yes" xml:space="preserve">
          <source>The name of the entity.</source>
          <target state="translated">엔터티의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="47e223e8c5fe87dc2f017ef2eabcb21daf87ceb2" translate="yes" xml:space="preserve">
          <source>The name of the event (case-insensitive).</source>
          <target state="translated">이벤트 이름 (대소 문자 구분).</target>
        </trans-unit>
        <trans-unit id="e7cc9e48bd592ef36c17b71fc57758920bbb168c" translate="yes" xml:space="preserve">
          <source>The name of the event (case-insensitive). The name must be an XML name.</source>
          <target state="translated">이벤트 이름 (대소 문자 구분 안함). 이름은 XML 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d3af95a63e43cd17e9a6cea712564b8e6527a909" translate="yes" xml:space="preserve">
          <source>The name of the feature.</source>
          <target state="translated">기능의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9e5fd5b90df7480a7c2fc85c88ad6342ff889328" translate="yes" xml:space="preserve">
          <source>The name of the feature. It is recommended that subclasses call &lt;a href=&quot;#getName()&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt; rather than reading this field, and that they not change it.</source>
          <target state="translated">기능의 이름입니다. 서브 클래스는 이 필드를 읽는 대신 &lt;a href=&quot;#getName()&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt; 호출 하고 변경하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="95a2547de9061a70c8901a9a9ae8316a19182943" translate="yes" xml:space="preserve">
          <source>The name of the feature. It is recommended that subclasses call &lt;a href=&quot;mbeanfeatureinfo#getName--&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt; rather than reading this field, and that they not change it.</source>
          <target state="translated">기능의 이름입니다. 서브 클래스는 이 필드를 읽지 않고 &lt;a href=&quot;mbeanfeatureinfo#getName--&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt; 호출 하고 변경하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="94428221f570bbc866fd9fb07f0332af0c0604fc" translate="yes" xml:space="preserve">
          <source>The name of the file or directory denoted by this abstract pathname, or the empty string if this pathname's name sequence is empty</source>
          <target state="translated">이 추상 경로명이 나타내는 파일 또는 디렉토리의 이름, 또는이 경로명의 이름 순서가 비어있는 경우는 빈 캐릭터 라인</target>
        </trans-unit>
        <trans-unit id="264313247d929c3123a9e7fe3982f9c4d6734ea2" translate="yes" xml:space="preserve">
          <source>The name of the file.</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="358d802fea6719e80e2748acb46d55d47944cf81" translate="yes" xml:space="preserve">
          <source>The name of the file. Normally this would be simply &lt;code&gt;f.getName()&lt;/code&gt;.</source>
          <target state="translated">파일의 이름입니다. 일반적으로 이것은 단순히 &lt;code&gt;f.getName()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2863f6ebe2f2814981517623a864e07602aa260c" translate="yes" xml:space="preserve">
          <source>The name of the garbage collector used to perform the collection.</source>
          <target state="translated">수집을 수행하는 데 사용되는 가비지 수집기의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="01c9c4139ce4fa623ad1d25aaa2f563884a126a5" translate="yes" xml:space="preserve">
          <source>The name of the getter method in the annotated class, which returns the corresponding Swing container, if it is not recommended to add subcomponents to the annotated class directly.</source>
          <target state="translated">어노테이션이있는 클래스에 직접 하위 컴포넌트를 추가하는 것이 권장되지 않는 경우 해당하는 Swing 컨테이너를 리턴하는 어노테이션이있는 클래스의 getter 메소드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6184eca693cfe52fc5392fc61940fe51c58be9b4" translate="yes" xml:space="preserve">
          <source>The name of the indexed attribute, or null if the index is out of range.</source>
          <target state="translated">색인화 된 속성의 이름 또는 색인이 범위를 벗어난 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="78e529e47375c2632b7b035e64454552347f35c2" translate="yes" xml:space="preserve">
          <source>The name of the keystore's JCE provider.</source>
          <target state="translated">키 스토어의 JCE 프로 바이더의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="710b3a74bf068fa8de9ebf8e26c80f7f253ab602" translate="yes" xml:space="preserve">
          <source>The name of the locale appropriate to display.</source>
          <target state="translated">표시 할 로케일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="dc4668583967ec894c4fc99eff383fa78666fc18" translate="yes" xml:space="preserve">
          <source>The name of the log level of the specified logger; or an empty string if the log level of the specified logger is &lt;code&gt;null&lt;/code&gt;. If the specified logger does not exist, &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 로거의 로그 레벨 이름입니다. 또는 지정된 로거의 로그 레벨은 빈 문자열 인 경우 &lt;code&gt;null&lt;/code&gt; . 지정된 로거가 없으면 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="eb2d73104061df95f17818382bae8dff8ab298b0" translate="yes" xml:space="preserve">
          <source>The name of the m-let registered.</source>
          <target state="translated">등록 된 m-let의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="093ff0ae78d61a47dcf7ef6063cf858716b59de9" translate="yes" xml:space="preserve">
          <source>The name of the memory pool.</source>
          <target state="translated">메모리 풀의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c7ad1c87eb9dcdbd25ae935d16c25ad0f224ed52" translate="yes" xml:space="preserve">
          <source>The name of the method is denoted by the &quot;method&quot; attribute.</source>
          <target state="translated">메소드의 이름은 &quot;method&quot;속성으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a672ec3f5d7f1814d41e28cb442fc9ba334b3bdc" translate="yes" xml:space="preserve">
          <source>The name of the monitor MBean registered.</source>
          <target state="translated">등록 된 모니터 MBean의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c291f6decb6f8d5426876dff90ab34f56da868c4" translate="yes" xml:space="preserve">
          <source>The name of the native metadata format for this object, initialized to &lt;code&gt;null&lt;/code&gt; and set via the constructor.</source>
          <target state="translated">이 객체의 고유 메타 데이터 형식의 이름으로, &lt;code&gt;null&lt;/code&gt; 로 초기화되고 생성자를 통해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ac5280a7663692ad6dd0a6b4111143acc66a2b08" translate="yes" xml:space="preserve">
          <source>The name of the package is derived from the &lt;a href=&quot;class#getName()&quot;&gt;binary names&lt;/a&gt; of the classes. Since classes in a named module must be in a named package, the derived name is never empty.</source>
          <target state="translated">패키지 &lt;a href=&quot;class#getName()&quot;&gt;이름&lt;/a&gt; 은 클래스 의 이진 이름 에서 파생됩니다 . 명명 된 모듈의 클래스는 명명 된 패키지에 있어야하므로 파생 된 이름은 비어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b13ee813ed632277885f5a6dd137f0cfb5e8df51" translate="yes" xml:space="preserve">
          <source>The name of the package is either &lt;code&gt;&quot;&quot;&lt;/code&gt; (for classes in an unnamed package) or derived from the &lt;a href=&quot;class#getName()&quot;&gt;binary names&lt;/a&gt; of the classes (for classes in a named package).</source>
          <target state="translated">패키지 이름은 &lt;code&gt;&quot;&quot;&lt;/code&gt; (이름이 지정되지 않은 패키지에있는 클래스의 경우)이거나 클래스 의 &lt;a href=&quot;class#getName()&quot;&gt;이진 이름 (이름&lt;/a&gt; 이 지정된 패키지에있는 클래스의 경우) 에서 파생됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4a64f909c1c428320f52ac482a8515417ecb899" translate="yes" xml:space="preserve">
          <source>The name of the parameter</source>
          <target state="translated">매개 변수의 이름</target>
        </trans-unit>
        <trans-unit id="ec919114b57c6c6f0bddee6582f54e56c541ab2a" translate="yes" xml:space="preserve">
          <source>The name of the parameter, either provided by the class file or synthesized if the class file does not provide a name.</source>
          <target state="translated">클래스 파일에서 제공하거나 클래스 파일이 이름을 제공하지 않으면 합성되는 매개 변수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="45a1439ae42ba4c8c5dd49280d770ad86f3c6a9b" translate="yes" xml:space="preserve">
          <source>The name of the principal that should be used. The principal can be a simple username such as &quot;&lt;code&gt;testuser&lt;/code&gt;&quot; or a service name such as &quot;&lt;code&gt;host/testhost.eng.sun.com&lt;/code&gt;&quot;. You can use the &lt;code&gt;principal&lt;/code&gt; option to set the principal when there are credentials for multiple principals in the &lt;code&gt;keyTab&lt;/code&gt; or when you want a specific ticket cache only. The principal can also be set using the system property &lt;code&gt;sun.security.krb5.principal&lt;/code&gt;. In addition, if this system property is defined, then it will be used. If this property is not set, then the principal name from the configuration will be used. The principal name can be set to &quot;*&quot; when &lt;code&gt;isInitiator&lt;/code&gt; is false. In this case, the acceptor is not bound to a single principal. It can act as any principal an initiator requests if keys for that principal can be found. When &lt;code&gt;isInitiator&lt;/code&gt; is true, the principal name cannot be set to &quot;*&quot;.</source>
          <target state="translated">사용해야하는 주체의 이름입니다. 주체는 &quot; &lt;code&gt;testuser&lt;/code&gt; &quot; 와 같은 간단한 사용자 이름 또는 &quot; &lt;code&gt;host/testhost.eng.sun.com&lt;/code&gt; &quot; 과 같은 서비스 이름 일 수 있습니다. 당신이 사용할 수있는 &lt;code&gt;principal&lt;/code&gt; 거기에 여러 교장 자격 증명 주요 설정 옵션을 &lt;code&gt;keyTab&lt;/code&gt; 당신은 단지 특정 티켓 캐시를 할 때 또는. 주체는 시스템 등록 정보 &lt;code&gt;sun.security.krb5.principal&lt;/code&gt; 을 사용하여 설정할 수도 있습니다 . 또한이 시스템 속성이 정의 된 경우이 속성이 사용됩니다. 이 속성이 설정되지 않은 경우 구성의 주체 이름이 사용됩니다. &lt;code&gt;isInitiator&lt;/code&gt; 인 경우 프린시 펄 이름을 &quot;*&quot;로 설정할 수 있습니다.거짓입니다. 이 경우 수락자는 단일 주체에 바인딩되지 않습니다. 해당 주체에 대한 키를 찾을 수있는 경우 이니시에이터가 요청하는 주체로 작동 할 수 있습니다. 때 &lt;code&gt;isInitiator&lt;/code&gt; 는 사실, 주요 이름은 &quot;*&quot;로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="76dbce8fae53c29781d96a2d788eef7df5a5de9f" translate="yes" xml:space="preserve">
          <source>The name of the processing instruction that is sent if the result tree disables output escaping.</source>
          <target state="translated">결과 트리가 출력 이스케이프를 비활성화하는 경우 전송되는 처리 명령의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="16abcde6d38a72eae8ef0428bcfea1f17bf5c47a" translate="yes" xml:space="preserve">
          <source>The name of the processing instruction that is sent if the result tree enables output escaping at some point after having received a PI_DISABLE_OUTPUT_ESCAPING processing instruction.</source>
          <target state="translated">PI_DISABLE_OUTPUT_ESCAPING 처리 명령을 수신 한 후 결과 트리가 출력 이스케이프를 활성화하는 경우 전송되는 처리 명령의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="116d7b1741b1750b3a187fa6439cac63813b08f8" translate="yes" xml:space="preserve">
          <source>The name of the property at this ordinal position. The empty string if no property exists at this position.</source>
          <target state="translated">이 서수 위치에있는 속성의 이름입니다. 이 위치에 속성이 없으면 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ac3506b2a41d26429a561490d65dccec37908ee6" translate="yes" xml:space="preserve">
          <source>The name of the property.</source>
          <target state="translated">속성의 이름</target>
        </trans-unit>
        <trans-unit id="887faaf33b50c35d7b160d10047016054616f44d" translate="yes" xml:space="preserve">
          <source>The name of the provider is supplied on the command line, which will add the provider to the system properties. For example:</source>
          <target state="translated">공급자의 이름은 명령 줄에 제공되어 공급자를 시스템 속성에 추가합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="0fde951d6d267c7761faf39ef1278ab5b4594efa" translate="yes" xml:space="preserve">
          <source>The name of the resolved object, relative to &lt;code&gt;altNameCtx&lt;/code&gt;. It is a composite name. If null, then no name is specified.</source>
          <target state="translated">&lt;code&gt;altNameCtx&lt;/code&gt; 에 상대적인 해결 된 객체의 이름입니다 . 합성 이름입니다. null의 경우는 이름이 지정되지 않는다</target>
        </trans-unit>
        <trans-unit id="cd1bd73ac27aa215798a1528ac7cb6d12a80bc26" translate="yes" xml:space="preserve">
          <source>The name of the resource that the reference points to. It can link to any compatible resource using the global JNDI names.</source>
          <target state="translated">참조가 가리키는 자원의 이름입니다. 글로벌 JNDI 이름을 사용하여 호환 가능한 모든 자원에 링크 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e3b3c20b96280dc122ea9b30ac0fcd7a5b82dcf" translate="yes" xml:space="preserve">
          <source>The name of the runtime permission for creating instances of this class.</source>
          <target state="translated">이 클래스의 인스턴스를 만들기위한 런타임 권한의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="aaf04e53e4a1152396ec28d1bfb5edacd69aa3f2" translate="yes" xml:space="preserve">
          <source>The name of the runtime permission for creating instances of this class. Granting this permission to a language runtime allows it to export its linkers for automatic loading into other language runtimes.</source>
          <target state="translated">이 클래스의 인스턴스를 만들기위한 런타임 권한의 이름입니다. 언어 런타임에이 권한을 부여하면 다른 언어 런타임으로 자동로드하기 위해 링커를 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea9beb0c3bba4aa9b71ab429f16da92aee27b15" translate="yes" xml:space="preserve">
          <source>The name of the stub class to load is determined by concatenating the binary name of the root class with the suffix &lt;code&gt;_Stub&lt;/code&gt;.</source>
          <target state="translated">로드 할 스텁 클래스의 이름은 루트 클래스의 이진 이름을 접미사 &lt;code&gt;_Stub&lt;/code&gt; 과 연결하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1292f65aa82f44923949346d4e1e691d616e2a33" translate="yes" xml:space="preserve">
          <source>The name of the supported language.</source>
          <target state="translated">지원되는 언어의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d92c69c213f3feae00524d25525f42e579d3cf48" translate="yes" xml:space="preserve">
          <source>The name of the tag, if any, associated with this kind of node.</source>
          <target state="translated">이러한 종류의 노드와 연결된 태그의 이름입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="ea3ee1b66718d70c98586654a55a17d890a101c8" translate="yes" xml:space="preserve">
          <source>The name of the timer MBean registered.</source>
          <target state="translated">등록 된 타이머 MBean의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c5f41cf5312635b9b71243059c7c01b830a817b2" translate="yes" xml:space="preserve">
          <source>The name of the transport service</source>
          <target state="translated">운송 서비스의 이름</target>
        </trans-unit>
        <trans-unit id="ac8d30e1489df051168dc38caa12a3e3879c648b" translate="yes" xml:space="preserve">
          <source>The name of the unsupported charset</source>
          <target state="translated">지원되지 않는 문자 집합의 이름</target>
        </trans-unit>
        <trans-unit id="2ea3029204b8563c2686223e0b30344df216cad0" translate="yes" xml:space="preserve">
          <source>The name of the vendor for this data type</source>
          <target state="translated">이 데이터 유형의 공급 업체 이름</target>
        </trans-unit>
        <trans-unit id="b104e9a9f317ddcff8d221e2af9f9bbcb518f76a" translate="yes" xml:space="preserve">
          <source>The name of the vendor for this data type which is java.sql for JDBCType.</source>
          <target state="translated">이 데이터 유형의 공급 업체 이름은 JDBCType의 경우 java.sql입니다.</target>
        </trans-unit>
        <trans-unit id="126564f90a129c4441e4a2c75da79a1d030e99b6" translate="yes" xml:space="preserve">
          <source>The name of the vendor who defined the SPI class and a brief description of the class are available via the &lt;code&gt;getVendorName&lt;/code&gt;, &lt;code&gt;getDescription&lt;/code&gt;, and &lt;code&gt;getVersion&lt;/code&gt; methods. These methods may be internationalized to provide locale-specific output. These methods are intended mainly to provide short, human-readable information that might be used to organize a pop-up menu or other list.</source>
          <target state="translated">SPI 클래스를 정의한 공급 업체 이름 및 클래스에 대한 간단한 설명은 &lt;code&gt;getVendorName&lt;/code&gt; , &lt;code&gt;getDescription&lt;/code&gt; 및 &lt;code&gt;getVersion&lt;/code&gt; 메소드 를 통해 사용할 수 있습니다 . 로케일 별 출력을 제공하기 위해 이러한 메소드를 국제화 할 수 있습니다. 이러한 방법은 주로 팝업 메뉴 또는 기타 목록을 구성하는 데 사용될 수있는 사람이 읽을 수있는 짧은 정보를 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="962ba302c34f721b90ce31af44446e3c52ade33c" translate="yes" xml:space="preserve">
          <source>The name of the vendor who defined the SPI class and a brief description of the class are available via the &lt;code&gt;getVendorName&lt;/code&gt;, &lt;code&gt;getDescription&lt;/code&gt;, and &lt;code&gt;getVersion&lt;/code&gt; methods. These methods may be internationalized to provide locale-specific output. These methods are intended mainly to provide short, human-writable information that might be used to organize a pop-up menu or other list.</source>
          <target state="translated">SPI 클래스를 정의한 공급 업체 이름 및 클래스에 대한 간단한 설명은 &lt;code&gt;getVendorName&lt;/code&gt; , &lt;code&gt;getDescription&lt;/code&gt; 및 &lt;code&gt;getVersion&lt;/code&gt; 메소드 를 통해 사용할 수 있습니다 . 로케일 별 출력을 제공하기 위해 이러한 메소드를 국제화 할 수 있습니다. 이러한 방법은 주로 팝업 메뉴 또는 기타 목록을 구성하는 데 사용할 수있는 사람이 쓸 수있는 짧은 정보를 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f00712a679d46359245fd53d36dcdc263f5f38cd" translate="yes" xml:space="preserve">
          <source>The name of this &lt;code&gt;SQLType&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;SQLType&lt;/code&gt; 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="8dd4993f396f86b98140b04a30ad081da0cc6b41" translate="yes" xml:space="preserve">
          <source>The name of this buffer pool.</source>
          <target state="translated">이 버퍼 풀의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8c533fca0bdf1847378d972e6408702bbaa3f035" translate="yes" xml:space="preserve">
          <source>The name of this class is taken from the terms used in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC 2278&lt;/i&gt;&lt;/a&gt;. In that document a</source>
          <target state="translated">이 클래스의 이름은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC 2278에&lt;/i&gt;&lt;/a&gt; 사용 된 용어에서 가져 왔습니다 . 그 문서에서</target>
        </trans-unit>
        <trans-unit id="bf3f5034f6d0761ce1f9b15ff92f37e5f38a40d4" translate="yes" xml:space="preserve">
          <source>The name of this class is taken from the terms used in &lt;a href=&quot;https://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC 2278&lt;/i&gt;&lt;/a&gt;. In that document a</source>
          <target state="translated">이 클래스의 이름은 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2278.txt&quot;&gt;&lt;i&gt;RFC 2278&lt;/i&gt;&lt;/a&gt; 에서 사용되는 용어에서 따 왔습니다 . 그 문서에서</target>
        </trans-unit>
        <trans-unit id="a78d89e8c4c181d92cab5b241c2e56cfa0c8eb49" translate="yes" xml:space="preserve">
          <source>The name of this node, depending on its type; see the table above.</source>
          <target state="translated">유형에 따라이 노드의 이름입니다. 위의 표를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57b40764274f1fc002df7c8b7ebff9fcc7d9b22c" translate="yes" xml:space="preserve">
          <source>The name of this provider</source>
          <target state="translated">이 제공자의 이름</target>
        </trans-unit>
        <trans-unit id="9724d1f38cc8445c96c102f929e30366b8968038" translate="yes" xml:space="preserve">
          <source>The name only contains alphanumeric characters or the character &quot;_&quot;</source>
          <target state="translated">이름에는 영숫자 또는 문자 &quot;_&quot;만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6879a68caf1d6a7ab9d9a4a53cc53b346d66fe6f" translate="yes" xml:space="preserve">
          <source>The name parameter in the &lt;code&gt;addNamingListener()&lt;/code&gt; methods is referred to as the &lt;em&gt;target&lt;/em&gt;. The target, along with the scope, identify the object(s) that the listener is interested in. It is possible to register interest in a target that does not exist, but there might be limitations in the extent to which this can be supported by the service provider and underlying protocol/service.</source>
          <target state="translated">&lt;code&gt;addNamingListener()&lt;/code&gt; 메소드 의 이름 매개 변수를 &lt;em&gt;target&lt;/em&gt; 이라고합니다 . 대상은 범위와 함께 리스너가 관심있는 오브젝트를 식별합니다. 존재하지 않는 대상에 관심을 등록 할 수는 있지만 대상이 지원할 수있는 범위에는 제한이있을 수 있습니다. 서비스 제공자 및 기본 프로토콜 / 서비스.</target>
        </trans-unit>
        <trans-unit id="860c4f0c945e8ceccccb8c32dcd64ba5a09ada9e" translate="yes" xml:space="preserve">
          <source>The name separator</source>
          <target state="translated">이름 구분자</target>
        </trans-unit>
        <trans-unit id="4513ba4813163f865c14e4ebc4f20c422d73d263" translate="yes" xml:space="preserve">
          <source>The name separator is used to separate names in a path string. An implementation may support multiple name separators in which case this method returns an implementation specific &lt;em&gt;default&lt;/em&gt; name separator. This separator is used when creating path strings by invoking the &lt;a href=&quot;path#toString()&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름 구분 기호는 경로 문자열에서 이름을 구분하는 데 사용됩니다. 구현은 여러 이름 구분 기호를 지원할 수 있으며이 경우이 메서드는 구현 특정 &lt;em&gt;기본&lt;/em&gt; 이름 구분 기호를 반환합니다 . 이 구분 기호는 &lt;a href=&quot;path#toString()&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 경로 문자열을 만들 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="35fd956615f3183b2a27cf861192a4328ba79011" translate="yes" xml:space="preserve">
          <source>The name separator is used to separate names in a path string. An implementation may support multiple name separators in which case this method returns an implementation specific &lt;em&gt;default&lt;/em&gt; name separator. This separator is used when creating path strings by invoking the &lt;a href=&quot;path#toString--&quot;&gt;&lt;code&gt;toString()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이름 구분 기호는 경로 문자열에서 이름을 구분하는 데 사용됩니다. 구현시 여러 이름 구분 기호를 지원할 수 있으며이 경우이 메서드는 구현 별 &lt;em&gt;기본&lt;/em&gt; 이름 구분 기호를 반환합니다 . 이 구분 기호는 &lt;a href=&quot;path#toString--&quot;&gt; &lt;code&gt;toString()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 경로 문자열을 작성할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5428a05faaeaed33e2f9ec7686064395200f6cf6" translate="yes" xml:space="preserve">
          <source>The name under which the MBean is to be registered.</source>
          <target state="translated">MBean을 등록 할 이름입니다.</target>
        </trans-unit>
        <trans-unit id="52573a98988fd98ad0050a1dc9a6c1143b22efbf" translate="yes" xml:space="preserve">
          <source>The name under which the MBean is to be registered. This value must not be null. If the &lt;code&gt;name&lt;/code&gt; parameter is not null, it will usually but not necessarily be the returned value.</source>
          <target state="translated">MBean을 등록 할 이름입니다. 이 값은 null이 아니어야합니다. &lt;code&gt;name&lt;/code&gt; 매개 변수가 null이 아닌 경우 일반적으로 반환되는 값일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4ea4ead5eaedd88911039ea1b43c07d7392cc64" translate="yes" xml:space="preserve">
          <source>The named ClassLoader. If &lt;var&gt;l&lt;/var&gt; is the actual ClassLoader with that name, and &lt;var&gt;r&lt;/var&gt; is the returned value, then either:</source>
          <target state="translated">명명 된 ClassLoader 경우 &lt;var&gt;l&lt;/var&gt; 그 이름을 가진 실제 클래스 로더이고, &lt;var&gt;r&lt;/var&gt; 은 다음 중 반환 된 값입니다 :</target>
        </trans-unit>
        <trans-unit id="5c1d5b92b4e57a45a5307ad7f0334127b6e48d33" translate="yes" xml:space="preserve">
          <source>The named character construct, &lt;code&gt;\N{&lt;/code&gt;</source>
          <target state="translated">명명 된 문자 구조 &lt;code&gt;\N{&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd3a4268a61dca16f11df59322f0d23569e1bd03" translate="yes" xml:space="preserve">
          <source>The named child node.</source>
          <target state="translated">명명 된 자식 노드</target>
        </trans-unit>
        <trans-unit id="3f8a750c331f2492d2d7adbdb43f580acc695902" translate="yes" xml:space="preserve">
          <source>The named class must exist and must implement the &lt;a href=&quot;../parser&quot;&gt;&lt;code&gt;Parser&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">명명 된 클래스가 존재해야하며 &lt;a href=&quot;../parser&quot;&gt; &lt;code&gt;Parser&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5845346cc0cc0f0d59912000c5fce352fb493340" translate="yes" xml:space="preserve">
          <source>The names in &lt;code&gt;newBd&lt;/code&gt; and &lt;code&gt;oldBd&lt;/code&gt; are to be resolved relative to the event source &lt;code&gt;source&lt;/code&gt;. For an &lt;code&gt;OBJECT_ADDED&lt;/code&gt; event type, &lt;code&gt;newBd&lt;/code&gt; must not be null. For an &lt;code&gt;OBJECT_REMOVED&lt;/code&gt; event type, &lt;code&gt;oldBd&lt;/code&gt; must not be null. For an &lt;code&gt;OBJECT_CHANGED&lt;/code&gt; event type, &lt;code&gt;newBd&lt;/code&gt; and &lt;code&gt;oldBd&lt;/code&gt; must not be null. For an &lt;code&gt;OBJECT_RENAMED&lt;/code&gt; event type, one of &lt;code&gt;newBd&lt;/code&gt; or &lt;code&gt;oldBd&lt;/code&gt; may be null if the new or old binding is outside of the scope for which the listener has registered.</source>
          <target state="translated">&lt;code&gt;newBd&lt;/code&gt; 및 &lt;code&gt;oldBd&lt;/code&gt; 의 이름 은 이벤트 소스 &lt;code&gt;source&lt;/code&gt; 기준으로 분석 됩니다. 를 들어 &lt;code&gt;OBJECT_ADDED&lt;/code&gt; 이벤트 유형, &lt;code&gt;newBd&lt;/code&gt; 는 널 (null)이 아니어야합니다. 를 들어 &lt;code&gt;OBJECT_REMOVED&lt;/code&gt; 이벤트 유형, &lt;code&gt;oldBd&lt;/code&gt; 는 널 (null)이 아니어야합니다. 를 들어 &lt;code&gt;OBJECT_CHANGED&lt;/code&gt; 이벤트 유형, &lt;code&gt;newBd&lt;/code&gt; 및 &lt;code&gt;oldBd&lt;/code&gt; 은 널 (null)이 아니어야합니다. 들어 &lt;code&gt;OBJECT_RENAMED&lt;/code&gt; 이벤트 타입 중 하나 &lt;code&gt;newBd&lt;/code&gt; 또는 &lt;code&gt;oldBd&lt;/code&gt; 는 (가) 또는 새로운 결합 이전 리스너가 등록되어있는 범위를 벗어나면 널이 될 수있다.</target>
        </trans-unit>
        <trans-unit id="28e648943eed3d5bc718d5018d02e901c65f23c3" translate="yes" xml:space="preserve">
          <source>The names must be unique: the SAX parser shall not include the same attribute twice. Attributes without values (those declared #IMPLIED without a value specified in the start tag) will be omitted from the list.</source>
          <target state="translated">이름은 고유해야합니다. SAX 파서는 동일한 속성을 두 번 포함하지 않아야합니다. 값이없는 속성 (시작 태그에 값이 지정되지 않고 #IMPLIED로 선언 된 속성)은 목록에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="f0a8616907b43c47c1c091877850ead64500f009" translate="yes" xml:space="preserve">
          <source>The names of the available metadata formats may be queried using the &lt;code&gt;getMetadataFormatNames&lt;/code&gt; method.</source>
          <target state="translated">사용 가능한 메타 데이터 형식의 이름은 &lt;code&gt;getMetadataFormatNames&lt;/code&gt; 메소드를 사용하여 조회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac3d983bd141120202d1d7f059bd758bd4ec98ba" translate="yes" xml:space="preserve">
          <source>The names specified in the assistive_technologies property are used to query each service provider implementation. If the requested name matches the &lt;a href=&quot;../../javax/accessibility/accessibilityprovider#getName()&quot;&gt;name&lt;/a&gt; of the service provider, the &lt;a href=&quot;../../javax/accessibility/accessibilityprovider#activate()&quot;&gt;&lt;code&gt;AccessibilityProvider.activate()&lt;/code&gt;&lt;/a&gt; method will be invoked to activate the matching service provider.</source>
          <target state="translated">assistive_technologies 특성에 지정된 이름은 각 서비스 제공자 구현을 조회하는 데 사용됩니다. 요청 된 이름이 일치하는 경우 &lt;a href=&quot;../../javax/accessibility/accessibilityprovider#getName()&quot;&gt;이름&lt;/a&gt; 서비스 제공자의를의 &lt;a href=&quot;../../javax/accessibility/accessibilityprovider#activate()&quot;&gt; &lt;code&gt;AccessibilityProvider.activate()&lt;/code&gt; &lt;/a&gt; 메서드는 일치하는 서비스 제공을 활성화하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="029f6a8be9fb510a5f766210b1e61cc783a3f358" translate="yes" xml:space="preserve">
          <source>The names used for bindings in a &lt;code&gt;Registry&lt;/code&gt; are pure strings, not parsed. A service which stores its remote reference in a &lt;code&gt;Registry&lt;/code&gt; may wish to use a package name as a prefix in the name binding to reduce the likelihood of name collisions in the registry.</source>
          <target state="translated">&lt;code&gt;Registry&lt;/code&gt; 에서 바인딩에 사용되는 이름 은 구문 분석되지 않은 순수한 문자열입니다. &lt;code&gt;Registry&lt;/code&gt; 원격 참조를 저장하는 서비스는 레지스트리 에서 이름 충돌 가능성을 줄이기 위해 이름 바인딩의 접두사로 패키지 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcd6ee214aa3b9f4650a6b8ae8b104453e32f318" translate="yes" xml:space="preserve">
          <source>The namespace URI at the &lt;code&gt;index&lt;/code&gt;th position in the &lt;code&gt;NameList&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if there is no name for the specified index or if the index is out of range.</source>
          <target state="translated">상기 네임 스페이스 URI &lt;code&gt;index&lt;/code&gt; 에 위치 일 &lt;code&gt;NameList&lt;/code&gt; , 또는 &lt;code&gt;null&lt;/code&gt; 는, 인덱스가 범위를 벗어 지정된 인덱스 또는 경우에 이름이없는 경우.</target>
        </trans-unit>
        <trans-unit id="ad968aef2ce359adabcf4b06887f7b010100b12f" translate="yes" xml:space="preserve">
          <source>The namespace URI of this node, or &lt;code&gt;null&lt;/code&gt; if it is unspecified (see ).</source>
          <target state="translated">이 노드의 네임 스페이스 URI 또는 지정되지 않은 경우 &lt;code&gt;null&lt;/code&gt; 입니다 (참조).</target>
        </trans-unit>
        <trans-unit id="15319931b49f78d34365b7fe637c46e690880dd9" translate="yes" xml:space="preserve">
          <source>The namespace declaration URI as a constant.</source>
          <target state="translated">상수로서의 네임 스페이스 선언 URI입니다.</target>
        </trans-unit>
        <trans-unit id="228b61ea658e02a099b69880335433a98bae30ec" translate="yes" xml:space="preserve">
          <source>The namespace declaration URI as a constant. The value is &lt;code&gt;http://www.w3.org/xmlns/2000/&lt;/code&gt;, as defined in a backwards-incompatible erratum to the &quot;Namespaces in XML&quot; recommendation. Because that erratum postdated SAX2, SAX2 defaults to the original recommendation, and does not normally use this URI.</source>
          <target state="translated">상수로서의 네임 스페이스 선언 URI입니다. 값은 &lt;code&gt;http://www.w3.org/xmlns/2000/&lt;/code&gt; 입니다. &quot;XML의 네임 스페이스&quot;권장 사항에 대해 이전 버전과 호환되지 않는 정오표에 정의되어 있습니다. 이 정오표는 SAX2 이후에 게시되었으므로 SAX2는 기본 권장 사항을 기본으로하며 일반적으로이 URI를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="894c9ad401c48e80324e2a77b581833e9593381e" translate="yes" xml:space="preserve">
          <source>The namespace of the type declared for the associated element or attribute or &lt;code&gt;null&lt;/code&gt; if the element does not have declaration or if no namespace information is available.</source>
          <target state="translated">연관된 요소 또는 속성에 대해 선언 된 유형의 네임 스페이스 또는 요소에 선언이 없거나 사용 가능한 네임 스페이스 정보가없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1535997202a921696d8786fcff8bc91e08cf6dc6" translate="yes" xml:space="preserve">
          <source>The namespace prefix of this node, or &lt;code&gt;null&lt;/code&gt; if it is unspecified.</source>
          <target state="translated">이 노드의 네임 스페이스 접두사 또는 지정되지 않은 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bdb974fd4cde04fb21c7dccde9027bcf31610fc0" translate="yes" xml:space="preserve">
          <source>The namespace prefix of this node, or &lt;code&gt;null&lt;/code&gt; if it is unspecified. When it is defined to be &lt;code&gt;null&lt;/code&gt;, setting it has no effect, including if the node is read-only.</source>
          <target state="translated">이 노드의 네임 스페이스 접두사 또는 지정되지 않은 경우 &lt;code&gt;null&lt;/code&gt; 입니다. &lt;code&gt;null&lt;/code&gt; 로 정의 된 경우 노드가 읽기 전용인지 여부를 포함하여 설정해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="252ba1c56374166baaa96e269996326d63427fdf" translate="yes" xml:space="preserve">
          <source>The nano-of-day.</source>
          <target state="translated">오늘의 나노.</target>
        </trans-unit>
        <trans-unit id="5eab94f056909b0481546e3eec3879a8647f2fdf" translate="yes" xml:space="preserve">
          <source>The nano-of-second.</source>
          <target state="translated">나노초.</target>
        </trans-unit>
        <trans-unit id="2bb5963aab34db2c750039ae2c23921252e470b4" translate="yes" xml:space="preserve">
          <source>The nanosecond field is set to zero.</source>
          <target state="translated">나노초 필드는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1f1f9f634c617722a2cc7a183fbeaa32e432ed0a" translate="yes" xml:space="preserve">
          <source>The nanosecond in second field is set to zero.</source>
          <target state="translated">두 번째 필드의 나노초는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="76fd7e21a457011d726338242241f8903c347ee8" translate="yes" xml:space="preserve">
          <source>The nanosecond-of-second value measures the total number of nanoseconds from the second returned by &lt;a href=&quot;#getEpochSecond()&quot;&gt;&lt;code&gt;getEpochSecond()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">나노초 값은 &lt;a href=&quot;#getEpochSecond()&quot;&gt; &lt;code&gt;getEpochSecond()&lt;/code&gt; &lt;/a&gt; 반환 된 초로부터 총 나노초 수를 측정합니다 .</target>
        </trans-unit>
        <trans-unit id="83d052126d41940b2289154ad002f598ff00e77e" translate="yes" xml:space="preserve">
          <source>The nanosecond-of-second value measures the total number of nanoseconds from the second returned by &lt;code&gt;getEpochSecond&lt;/code&gt;.</source>
          <target state="translated">나노초 값은 &lt;code&gt;getEpochSecond&lt;/code&gt; 가 리턴 한 초부터 총 나노초 수를 측정합니다 .</target>
        </trans-unit>
        <trans-unit id="8d9af2aeac2c5039b9c64536435d8f3fb400bacf" translate="yes" xml:space="preserve">
          <source>The native byte order of the hardware upon which this Java virtual machine is running</source>
          <target state="translated">이 Java 가상 머신이 실행되고있는 하드웨어의 원시 바이트 순서</target>
        </trans-unit>
        <trans-unit id="97bded427ee67f08fd9eb95689f83724ec8164db" translate="yes" xml:space="preserve">
          <source>The native character encoding of the Java programming language is UTF-16. A charset in the Java platform therefore defines a mapping between sequences of sixteen-bit UTF-16 code units (that is, sequences of chars) and sequences of bytes.</source>
          <target state="translated">Java 프로그래밍 언어의 기본 문자 인코딩은 UTF-16입니다. 따라서 Java 플랫폼의 문자 세트는 16 비트 UTF-16 코드 단위 시퀀스 (즉, 문자 시퀀스)와 바이트 시퀀스 간의 맵핑을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1219b90b3713ea6ffa550dbe0af918ae384ffcc9" translate="yes" xml:space="preserve">
          <source>The native platform print dialog should be used.</source>
          <target state="translated">기본 플랫폼 인쇄 대화 상자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="83686ff5a26a6fe617fa1acbc83be8300b5c6546" translate="yes" xml:space="preserve">
          <source>The native process ID is an identification number that the operating system assigns to the process. The range for process id values is dependent on the operating system. For example, an embedded system might use a 16-bit value. Status information about a process is retrieved from the native system and may change asynchronously; processes may be created or terminate spontaneously. The time between when a process terminates and the process id is reused for a new process is unpredictable. Race conditions can exist between checking the status of a process and acting upon it. When using ProcessHandles avoid assumptions about the liveness or identity of the underlying process.</source>
          <target state="translated">원시 프로세스 ID는 운영 체제가 프로세스에 할당하는 식별 번호입니다. 프로세스 ID 값의 범위는 운영 체제에 따라 다릅니다. 예를 들어, 임베디드 시스템은 16 비트 값을 사용할 수 있습니다. 프로세스에 대한 상태 정보는 기본 시스템에서 검색되며 비동기 적으로 변경 될 수 있습니다. 프로세스는 자발적으로 생성되거나 종료 될 수 있습니다. 프로세스가 종료되고 프로세스 ID가 새 프로세스에 재사용되는 사이의 시간은 예측할 수 없습니다. 프로세스의 상태를 확인하고 조치를 취하는 사이에 경쟁 조건이 존재할 수 있습니다. ProcessHandles를 사용할 때 기본 프로세스의 활성 또는 ID에 대한 가정을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="e72b8d07ae2a52493e69fa910beb1a9da83caf12" translate="yes" xml:space="preserve">
          <source>The natural ordering for a class &lt;code&gt;C&lt;/code&gt; is said to be</source>
          <target state="translated">클래스 &lt;code&gt;C&lt;/code&gt; 의 자연스러운 순서 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e26b92bd376c727cc9ae6d911fde6e70b291f7e3" translate="yes" xml:space="preserve">
          <source>The natural width/height of the component or component group, in pixels.</source>
          <target state="translated">구성 요소 또는 구성 요소 그룹의 기본 너비 / 높이 (픽셀 단위)입니다.</target>
        </trans-unit>
        <trans-unit id="b84120c20a6bdf6d7f5ae3856a89d9473555ad90" translate="yes" xml:space="preserve">
          <source>The negotiated SSL session</source>
          <target state="translated">협상 된 SSL 세션</target>
        </trans-unit>
        <trans-unit id="9de1c83fb5bc0b107cb559ca22ebf44b869de4c2" translate="yes" xml:space="preserve">
          <source>The nest host of &lt;code&gt;C&lt;/code&gt; is determined to be &lt;code&gt;H&lt;/code&gt;, the nest host of the lookup class.</source>
          <target state="translated">둥지 호스트 &lt;code&gt;C&lt;/code&gt; 는 것으로 판단 &lt;code&gt;H&lt;/code&gt; 룩업 클래스의 둥지 호스트.</target>
        </trans-unit>
        <trans-unit id="234a9e648b6468143062def34d6ca8f9dc630930" translate="yes" xml:space="preserve">
          <source>The net result of these issues is that if the &lt;code&gt;Math.sin()&lt;/code&gt; and &lt;code&gt;Math.cos()&lt;/code&gt; methods are used to directly generate the values for the matrix modifications during these radian-based rotation operations then the resulting transform is never strictly classifiable as a quadrant rotation even for a simple case like &lt;code&gt;rotate(Math.PI/2.0)&lt;/code&gt;, due to minor variations in the matrix caused by the non-0.0 values obtained for the sine and cosine. If these transforms are not classified as quadrant rotations then subsequent code which attempts to optimize further operations based upon the type of the transform will be relegated to its most general implementation.</source>
          <target state="translated">이러한 문제의 최종 결과는 &lt;code&gt;Math.sin()&lt;/code&gt; 및 &lt;code&gt;Math.cos()&lt;/code&gt; 메서드를 사용하여 이러한 라디안 기반 회전 작업 중에 행렬 수정 값을 직접 생성하는 경우 결과 변환을 절대로 엄격하게 분류 할 수 없습니다. 사인 및 코사인에 대해 얻은 0.0이 아닌 값으로 인한 행렬의 사소한 변화로 인해 &lt;code&gt;rotate(Math.PI/2.0)&lt;/code&gt; 와 같은 간단한 경우에도 사분면 회전 . 이러한 변환이 사분면 회전으로 분류되지 않으면 변환 유형에 따라 추가 작업을 최적화하려는 후속 코드가 가장 일반적인 구현으로 강등됩니다.</target>
        </trans-unit>
        <trans-unit id="f6f46588995ed496d4911f8ff1d273d4a2dd3241" translate="yes" xml:space="preserve">
          <source>The network class loader subclass must define the methods &lt;a href=&quot;#findClass(java.lang.String)&quot;&gt;&lt;code&gt;findClass&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;loadClassData&lt;/code&gt; to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method &lt;a href=&quot;#defineClass(byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/a&gt; to create a class instance. A sample implementation is:</source>
          <target state="translated">네트워크 클래스 로더 서브 클래스는 네트워크에서 클래스 를로드하기 위해 &lt;a href=&quot;#findClass(java.lang.String)&quot;&gt; &lt;code&gt;findClass&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;loadClassData&lt;/code&gt; 메소드를 정의해야합니다 . 클래스를 구성하는 바이트를 다운로드 한 후에는 &lt;a href=&quot;#defineClass(byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;defineClass&lt;/code&gt; &lt;/a&gt; 메서드 를 사용하여 클래스 인스턴스를 만들어야합니다. 샘플 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="29d0ba30c08b06286e5f241683ca2b4246f089a6" translate="yes" xml:space="preserve">
          <source>The network class loader subclass must define the methods &lt;a href=&quot;classloader#findClass-java.lang.String-&quot;&gt;&lt;code&gt;&lt;code&gt;findClass&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;loadClassData&lt;/code&gt; to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method &lt;a href=&quot;classloader#defineClass-byte:A-int-int-&quot;&gt;&lt;code&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; to create a class instance. A sample implementation is:</source>
          <target state="translated">네트워크 클래스 로더 서브 클래스는 &lt;a href=&quot;classloader#findClass-java.lang.String-&quot;&gt; &lt;code&gt;&lt;code&gt;findClass&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;loadClassData&lt;/code&gt; 메소드를 정의하여 네트워크에서 클래스 를로드해야합니다. 클래스를 구성하는 바이트를 다운로드 한 후에는 메소드를 사용해야합니다.&lt;a href=&quot;classloader#defineClass-byte:A-int-int-&quot;&gt; &lt;code&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/code&gt; &lt;/a&gt;를 사용하여 클래스 인스턴스를 작성합니다. 샘플 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60bdca0ec3065d96f7c4fa13ff060a6ac497223a" translate="yes" xml:space="preserve">
          <source>The network interface for Internet Protocol (IP) multicast datagrams</source>
          <target state="translated">인터넷 프로토콜 (IP) 멀티 캐스트 데이터 그램을위한 네트워크 인터페이스</target>
        </trans-unit>
        <trans-unit id="67864d43181467d0e750e9cf2430f7984db2145a" translate="yes" xml:space="preserve">
          <source>The network interface for Internet Protocol (IP) multicast datagrams.</source>
          <target state="translated">인터넷 프로토콜 (IP) 멀티 캐스트 데이터 그램을위한 네트워크 인터페이스.</target>
        </trans-unit>
        <trans-unit id="77e297f05cd6c24b81ee98871c2f562cc1712cbf" translate="yes" xml:space="preserve">
          <source>The network interface may not be uniquely identified by the InetAddress returned.</source>
          <target state="translated">네트워크 인터페이스는 반환 된 InetAddress로 고유하게 식별되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62bdfbdb68bbddab14a9ba442a221c26cc2c40f8" translate="yes" xml:space="preserve">
          <source>The network interface may not be uniquely identified by the InetAddress returned. Use &lt;a href=&quot;#getNetworkInterface()&quot;&gt;&lt;code&gt;getNetworkInterface()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">네트워크 인터페이스는 반환 된 InetAddress로 고유하게 식별되지 않을 수 있습니다. 대신 &lt;a href=&quot;#getNetworkInterface()&quot;&gt; &lt;code&gt;getNetworkInterface()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1580356f22e412c53443664b7e31925aaa4d1af" translate="yes" xml:space="preserve">
          <source>The network software may discard bytes that are buffered by the socket. Bytes that aren't discarded by the network software can be read using &lt;a href=&quot;../io/inputstream#read()&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">네트워크 소프트웨어는 소켓에 의해 버퍼링 된 바이트를 삭제할 수 있습니다. 네트워크 소프트웨어에 의해 삭제되지 않은 바이트는 read를 사용하여 &lt;a href=&quot;../io/inputstream#read()&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6fe308b0ca1ecd4664a44845bd1ebbb9f779e7d" translate="yes" xml:space="preserve">
          <source>The network software may discard bytes that are buffered by the socket. Bytes that aren't discarded by the network software can be read using &lt;a href=&quot;../io/inputstream#read--&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">네트워크 소프트웨어는 소켓에 의해 버퍼링 된 바이트를 버릴 수 있습니다. 네트워크 소프트웨어에서 버리지 않은 바이트는 read를 사용하여 &lt;a href=&quot;../io/inputstream#read--&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55670e5d5dd2d95a1600413eeec6cbda76a343d6" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;bigdecimal#divide-java.math.BigDecimal-int-java.math.RoundingMode-&quot;&gt;&lt;code&gt;divide(BigDecimal, int, RoundingMode)&lt;/code&gt;&lt;/a&gt; method should be used in preference to this legacy method.</source>
          <target state="translated">이 레거시 방법보다 새로운 &lt;a href=&quot;bigdecimal#divide-java.math.BigDecimal-int-java.math.RoundingMode-&quot;&gt; &lt;code&gt;divide(BigDecimal, int, RoundingMode)&lt;/code&gt; &lt;/a&gt; 방법을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac784c4d64146b5dcf94b8e436a19a6c04e1010d" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;bigdecimal#divide-java.math.BigDecimal-java.math.RoundingMode-&quot;&gt;&lt;code&gt;divide(BigDecimal, RoundingMode)&lt;/code&gt;&lt;/a&gt; method should be used in preference to this legacy method.</source>
          <target state="translated">이 레거시 방법보다 새로운 &lt;a href=&quot;bigdecimal#divide-java.math.BigDecimal-java.math.RoundingMode-&quot;&gt; &lt;code&gt;divide(BigDecimal, RoundingMode)&lt;/code&gt; &lt;/a&gt; 방법을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2735dd48d8041cfacd708718becc725a951d4601" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;bigdecimal#setScale-int-java.math.RoundingMode-&quot;&gt;&lt;code&gt;setScale(int, RoundingMode)&lt;/code&gt;&lt;/a&gt; method should be used in preference to this legacy method.</source>
          <target state="translated">이 레거시 메소드보다 새로운 &lt;a href=&quot;bigdecimal#setScale-int-java.math.RoundingMode-&quot;&gt; &lt;code&gt;setScale(int, RoundingMode)&lt;/code&gt; &lt;/a&gt; 메소드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="78cebb1e774e1e4b22b69b8b3afb2ebe16d107f0" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--show-*&lt;/code&gt; options provide a more detailed replacement for the older options &lt;code&gt;-public&lt;/code&gt;, &lt;code&gt;-protected&lt;/code&gt;, &lt;code&gt;-package&lt;/code&gt;, &lt;code&gt;-private&lt;/code&gt;. Alternatively, the older options can continue to be used as shorter forms for combinations of the new options, as described below:</source>
          <target state="translated">새로운 &lt;code&gt;--show-*&lt;/code&gt; 옵션은 이전 옵션 인 &lt;code&gt;-public&lt;/code&gt; , &lt;code&gt;-protected&lt;/code&gt; , &lt;code&gt;-package&lt;/code&gt; , &lt;code&gt;-private&lt;/code&gt; 에 대한보다 자세한 대체를 제공합니다 . 또는 아래에 설명 된대로 이전 옵션을 새 옵션 조합에 대해 더 짧은 형식으로 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ac33af37763a895fb45c8674bcd9b2f4195f026" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;CDATASection&lt;/code&gt; object.</source>
          <target state="translated">새로운 &lt;code&gt;CDATASection&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="21ab9f29997ac044ac786c27f5f4247505485231" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;Comment&lt;/code&gt; object.</source>
          <target state="translated">새로운 &lt;code&gt;Comment&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="3de7e88be2994a0198fc6b96016f6a661e41553f" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;EntityReference&lt;/code&gt; object.</source>
          <target state="translated">새 &lt;code&gt;EntityReference&lt;/code&gt; 개체입니다.</target>
        </trans-unit>
        <trans-unit id="2ea1019c83ded3f69e80d30416950390eadbdebc" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;ProcessingInstruction&lt;/code&gt; object.</source>
          <target state="translated">새로운 &lt;code&gt;ProcessingInstruction&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="ba45d206f6ce10fd626fa94b5424cc97accbd485" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;Rectangle&lt;/code&gt; has &lt;code&gt;(x - h, y - v)&lt;/code&gt; as its upper-left corner, width of &lt;code&gt;(width + 2h)&lt;/code&gt;, and a height of &lt;code&gt;(height + 2v)&lt;/code&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;Rectangle&lt;/code&gt; 은 &lt;code&gt;(x - h, y - v)&lt;/code&gt; 왼쪽 상단 모서리, 너비 &lt;code&gt;(width + 2h)&lt;/code&gt; 및 높이 &lt;code&gt;(height + 2v)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b974fb076134f8a2b5e9c5d2e506d6b6d140c6b6" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;SerialArray&lt;/code&gt; object contains the same elements as the &lt;code&gt;Array&lt;/code&gt; object from which it is built, except when the base type is the SQL type &lt;code&gt;BLOB&lt;/code&gt;, &lt;code&gt;CLOB&lt;/code&gt;, &lt;code&gt;DATALINK&lt;/code&gt; or &lt;code&gt;JAVA_OBJECT&lt;/code&gt;. In this case, each element in the new &lt;code&gt;SerialArray&lt;/code&gt; object is the appropriate serialized form, that is, a &lt;code&gt;SerialBlob&lt;/code&gt;, &lt;code&gt;SerialClob&lt;/code&gt;, &lt;code&gt;SerialDatalink&lt;/code&gt;, or &lt;code&gt;SerialJavaObject&lt;/code&gt; object.</source>
          <target state="translated">새 &lt;code&gt;SerialArray&lt;/code&gt; 객체 는 기본 유형이 SQL 유형 &lt;code&gt;BLOB&lt;/code&gt; , &lt;code&gt;CLOB&lt;/code&gt; , &lt;code&gt;DATALINK&lt;/code&gt; 또는 &lt;code&gt;JAVA_OBJECT&lt;/code&gt; 인 경우를 제외하고는 해당 객체가 빌드 된 &lt;code&gt;Array&lt;/code&gt; 객체 와 동일한 요소를 포함합니다 . 이 경우 새 &lt;code&gt;SerialArray&lt;/code&gt; 객체 의 각 요소는 직렬화 된 적절한 형식, 즉 &lt;code&gt;SerialBlob&lt;/code&gt; , &lt;code&gt;SerialClob&lt;/code&gt; , &lt;code&gt;SerialDatalink&lt;/code&gt; 또는 &lt;code&gt;SerialJavaObject&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="80e0ce8f3d894008a7021d81d24aa60554c9d440" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;SerialArray&lt;/code&gt; object contains the same elements as the &lt;code&gt;Array&lt;/code&gt; object from which it is built, except when the base type is the SQL type &lt;code&gt;STRUCT&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;BLOB&lt;/code&gt;, &lt;code&gt;CLOB&lt;/code&gt;, &lt;code&gt;DATALINK&lt;/code&gt; or &lt;code&gt;JAVA_OBJECT&lt;/code&gt;. In this case, each element in the new &lt;code&gt;SerialArray&lt;/code&gt; object is the appropriate serialized form, that is, a &lt;code&gt;SerialStruct&lt;/code&gt;, &lt;code&gt;SerialArray&lt;/code&gt;, &lt;code&gt;SerialBlob&lt;/code&gt;, &lt;code&gt;SerialClob&lt;/code&gt;, &lt;code&gt;SerialDatalink&lt;/code&gt;, or &lt;code&gt;SerialJavaObject&lt;/code&gt; object.</source>
          <target state="translated">새 &lt;code&gt;SerialArray&lt;/code&gt; 객체 는 기본 유형이 SQL 유형 &lt;code&gt;STRUCT&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;BLOB&lt;/code&gt; , &lt;code&gt;CLOB&lt;/code&gt; , &lt;code&gt;DATALINK&lt;/code&gt; 또는 &lt;code&gt;JAVA_OBJECT&lt;/code&gt; 인 경우를 제외하고는 해당 객체가 빌드 된 &lt;code&gt;Array&lt;/code&gt; 객체 와 동일한 요소를 포함합니다 . 이 경우 새 &lt;code&gt;SerialArray&lt;/code&gt; 객체 의 각 요소는 직렬화 된 적절한 형식, 즉 &lt;code&gt;SerialStruct&lt;/code&gt; , &lt;code&gt;SerialArray&lt;/code&gt; , &lt;code&gt;SerialBlob&lt;/code&gt; , &lt;code&gt;SerialClob&lt;/code&gt; , &lt;code&gt;SerialDatalink&lt;/code&gt; 또는 &lt;code&gt;SerialJavaObject&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="06abd2075e2ed1721af0f48e630558bf700d5acf" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;SerialBlob&lt;/code&gt; object is initialized with the data from the &lt;code&gt;Blob&lt;/code&gt; object; therefore, the &lt;code&gt;Blob&lt;/code&gt; object should have previously brought the SQL &lt;code&gt;BLOB&lt;/code&gt; value's data over to the client from the database. Otherwise, the new &lt;code&gt;SerialBlob&lt;/code&gt; object will contain no data.</source>
          <target state="translated">새 &lt;code&gt;SerialBlob&lt;/code&gt; 개체는 &lt;code&gt;Blob&lt;/code&gt; 개체 의 데이터로 초기화됩니다 . 따라서 &lt;code&gt;Blob&lt;/code&gt; 개체는 이전에 SQL &lt;code&gt;BLOB&lt;/code&gt; 값의 데이터를 데이터베이스에서 클라이언트로 가져 왔어 야 합니다. 그렇지 않으면 새 &lt;code&gt;SerialBlob&lt;/code&gt; 개체에 데이터가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a900d5f2ddce08647425d98d24a6bddafdbf9ba0" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;SerialBlob&lt;/code&gt; object is initialized with the data from the &lt;code&gt;byte&lt;/code&gt; array, thus allowing disconnected &lt;code&gt;RowSet&lt;/code&gt; objects to establish serialized &lt;code&gt;Blob&lt;/code&gt; objects without touching the data source.</source>
          <target state="translated">새 &lt;code&gt;SerialBlob&lt;/code&gt; 개체는 &lt;code&gt;byte&lt;/code&gt; 배열 의 데이터로 초기화 되므로 연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체가 데이터 소스를 건드리지 않고도 직렬화 된 &lt;code&gt;Blob&lt;/code&gt; 개체 를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78aaae994b4dabb3fc80be4b84511dee256896b1" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;SerialClob&lt;/code&gt; object is initialized with the data from the &lt;code&gt;Clob&lt;/code&gt; object; therefore, the &lt;code&gt;Clob&lt;/code&gt; object should have previously brought the SQL &lt;code&gt;CLOB&lt;/code&gt; value's data over to the client from the database. Otherwise, the new &lt;code&gt;SerialClob&lt;/code&gt; object object will contain no data.</source>
          <target state="translated">새 &lt;code&gt;SerialClob&lt;/code&gt; 개체는 &lt;code&gt;Clob&lt;/code&gt; 개체 의 데이터로 초기화됩니다 . 따라서 &lt;code&gt;Clob&lt;/code&gt; 개체는 이전에 SQL &lt;code&gt;CLOB&lt;/code&gt; 값의 데이터를 데이터베이스에서 클라이언트로 가져 왔어 야 합니다. 그렇지 않으면 새 &lt;code&gt;SerialClob&lt;/code&gt; 개체 개체에 데이터가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17353bad20748ceb3bfb756b24c2c22df6c4c460" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;SerialClob&lt;/code&gt; object is initialized with the data from the &lt;code&gt;char&lt;/code&gt; array, thus allowing disconnected &lt;code&gt;RowSet&lt;/code&gt; objects to establish a serialized &lt;code&gt;Clob&lt;/code&gt; object without touching the data source.</source>
          <target state="translated">새 &lt;code&gt;SerialClob&lt;/code&gt; 개체는 &lt;code&gt;char&lt;/code&gt; 배열 의 데이터로 초기화 되므로 연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체가 데이터 소스를 건드리지 않고도 직렬화 된 &lt;code&gt;Clob&lt;/code&gt; 개체를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd289b7da3f8d0a5f7fe07055b8416ed256428d0" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;Text&lt;/code&gt; object.</source>
          <target state="translated">새로운 &lt;code&gt;Text&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="5d361a6c28b3a7b924134f4c2310c4356b571de7" translate="yes" xml:space="preserve">
          <source>The new Raster may additionally be translated to a different coordinate system for the plane than that used by the current Raster. The childMinX and childMinY parameters give the new (x, y) coordinate of the upper-left pixel of the returned Raster; the coordinate (childMinX, childMinY) in the new Raster will map to the same pixel as the coordinate (parentX, parentY) in the current Raster.</source>
          <target state="translated">새로운 Raster는 현재 Raster에서 사용하는 것과는 다른 평면 좌표계로 추가로 변환 될 수 있습니다. childMinX 및 childMinY 매개 변수는 반환 된 Raster의 왼쪽 위 픽셀의 새 (x, y) 좌표를 제공합니다. 새 Raster의 좌표 (childMinX, childMinY)는 현재 Raster의 좌표 (parentX, parentY)와 동일한 픽셀에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="82b647f77da8fc51c747ee0f20a9855467762c05" translate="yes" xml:space="preserve">
          <source>The new Raster may be defined to contain only a subset of the bands of the current Raster, possibly reordered, by means of the bandList parameter. If bandList is null, it is taken to include all of the bands of the current Raster in their current order.</source>
          <target state="translated">새로운 Raster는 bandList 매개 변수를 사용하여 현재 Raster 밴드의 하위 집합 만 포함하도록 정의 할 수 있습니다. bandList가 null이면 현재 Raster의 모든 밴드를 현재 순서대로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7265ccc5d623c310cc3ac47a66fc5eed1ffa49bf" translate="yes" xml:space="preserve">
          <source>The new URI</source>
          <target state="translated">새로운 URI</target>
        </trans-unit>
        <trans-unit id="5f405da8bbae6be9b41dfa9b6d7bbc89199565ba" translate="yes" xml:space="preserve">
          <source>The new WritableRaster may additionally be translated to a different coordinate system for the plane than that used by the current WritableRaster. The childMinX and childMinY parameters give the new (x, y) coordinate of the upper-left pixel of the returned WritableRaster; the coordinate (childMinX, childMinY) in the new WritableRaster will map to the same pixel as the coordinate (parentX, parentY) in the current WritableRaster.</source>
          <target state="translated">새로운 WritableRaster는 현재 WritableRaster에서 사용하는 것과는 다른 평면 좌표계로 추가로 변환 될 수 있습니다. childMinX 및 childMinY 매개 변수는 반환 된 WritableRaster의 왼쪽 위 픽셀의 새 (x, y) 좌표를 제공합니다. 새 WritableRaster의 좌표 (childMinX, childMinY)는 현재 WritableRaster의 좌표 (parentX, parentY)와 동일한 픽셀에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="ab5c193afbcca8cc582eca9bc77cb959c8b4bf3a" translate="yes" xml:space="preserve">
          <source>The new WritableRaster may be defined to contain only a subset of the bands of the current WritableRaster, possibly reordered, by means of the bandList parameter. If bandList is null, it is taken to include all of the bands of the current WritableRaster in their current order.</source>
          <target state="translated">새로운 WritableRaster는 bandList 매개 변수를 사용하여 현재 WritableRaster의 밴드의 부분 집합 만 포함하도록 정의 될 수 있습니다. bandList가 null이면 현재 WritableRaster의 모든 밴드를 현재 순서대로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a2b375f7ec337d0b7321744b498b77bbbb43dc04" translate="yes" xml:space="preserve">
          <source>The new binding: information about the object after the change.</source>
          <target state="translated">새로운 바인딩 : 변경 후 객체에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="811ee44cf7e2eeb64087a000511e1308ea7b319a" translate="yes" xml:space="preserve">
          <source>The new buffer</source>
          <target state="translated">새로운 버퍼</target>
        </trans-unit>
        <trans-unit id="a9f750a1ec47c53e6933e7367f0dd037a6159afe" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;bytebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 바이트 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;bytebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="90e1aff286e96d964a4b0f5b68af2f26432a8471" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 바이트 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량과 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; &lt;/a&gt; 입니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b87cda267359dfa7e6d3c0f1f70075ab22125777" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;bytebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 바이트 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;bytebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="8379c53880b85933ce4a6ea8375b41465251bdc7" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given byte array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 바이트 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; &lt;/a&gt; 입니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="3a25bef4c13a14c4415962bc64f251e299155ad6" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given char array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;charbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 문자 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;charbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="c2482ceaa24382ea21ac8d5f908044a26e325543" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given char array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 char 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량 및 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="0d2674995ec7db927894a48c261ddea8d595a398" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given char array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;charbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 문자 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;charbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="735303f9844fa882ca8acee8fe46085bd77a959b" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given char array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 char 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="35306637861eed16af88b4e2dfb5c1e37c341a44" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given double array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;doublebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 이중 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;doublebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="eb0dbfe7f7fa1cea1555c6a9994e13ed4e5283a8" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given double array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 이중 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량 및 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="8dceaea7882e5d50ea82b5e02eaccd6768f24042" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given double array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;doublebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 이중 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;doublebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="48e7d25898b00d2244ede003e69d1683b40c8061" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given double array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 이중 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="a4320fd76f9f4ca139f58312ae6d89d82b8751b8" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given float array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;floatbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 float 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;floatbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="23ca7ac0ad6d66ac718f1ac4f45677a5be8afe92" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given float array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 float 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량 및 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="1e7911665bb7451ce6034993a67b89354cf0e0fe" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given float array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;floatbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 float 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;floatbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="aaee794f7a79d58138226cea2eb7241025e96893" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given float array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 float 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="3fd84a12e6c22a3ee3939f3f6a961f726d7f5c1a" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given int array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;intbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 int 배열은 지정된 int 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;intbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="542acab240cf7a91a0f009397f9d5e391547359c" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given int array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 int 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량 및 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="c8228e64f023a9d3a8c7700654a22211275f6638" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given int array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;intbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 int 배열은 지정된 int 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;intbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="7a5777903d7dc4a8dd6a7b994da71372ebd61285" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given int array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 int 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b259e53add3a5528efdfbd8e55c0de407403a961" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given long array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;longbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 긴 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;longbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="c025cebd020483c761ea0b9d2e34843256ba8160" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given long array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 긴 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량 및 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="78548868dc1648694724e198deaa1f84f096b4c8" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given long array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;longbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 긴 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;longbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="05e5d377bee49b4b9cb9eb2b7777b988471bf1d3" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given long array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 긴 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="d08a08b839ac302da9552db1b3bb522b1eeb1ba6" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given short array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, and its mark will be undefined. Its &lt;a href=&quot;shortbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&amp;gt;&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 짧은 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새 버퍼의 용량과 한계는 &lt;code&gt;array.length&lt;/code&gt; 이고 위치는 0이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;shortbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열 될 것이며, 그 &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&amp;gt;&lt;/code&gt; &lt;/a&gt; 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="938f79a566e736887d022dd209c93277878b1d06" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given short array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity and limit will be &lt;code&gt;array.length&lt;/code&gt;, its position will be zero, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 짧은 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량 및 제한은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 0, 마크는 정의되지 않고 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b7616ef26b29d3dbc28547aecc940e0b07b48cc8" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given short array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, and its mark will be undefined. Its &lt;a href=&quot;shortbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새로운 버퍼는 주어진 짧은 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대도 마찬가지입니다. 새로운 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; 이며 마크는 정의되지 않습니다. 그 &lt;a href=&quot;shortbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="e50668684daefc59dbea18aaaf601a06240c643e" translate="yes" xml:space="preserve">
          <source>The new buffer will be backed by the given short array; that is, modifications to the buffer will cause the array to be modified and vice versa. The new buffer's capacity will be &lt;code&gt;array.length&lt;/code&gt;, its position will be &lt;code&gt;offset&lt;/code&gt;, its limit will be &lt;code&gt;offset + length&lt;/code&gt;, its mark will be undefined, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. Its &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; will be the given array, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼는 주어진 짧은 배열에 의해 지원됩니다. 즉, 버퍼를 수정하면 배열이 수정되고 그 반대의 경우도 마찬가지입니다. 새 버퍼의 용량은 &lt;code&gt;array.length&lt;/code&gt; , 위치는 &lt;code&gt;offset&lt;/code&gt; , 한계는 &lt;code&gt;offset + length&lt;/code&gt; , 마크는 정의되지 않으며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 지정된 배열되고, 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="c14e82168abd4ac4df9c13b98e0a4c8e7cfc8643" translate="yes" xml:space="preserve">
          <source>The new buffer will share this buffer's content; that is, if the content of this buffer is mutable then modifications to one buffer will cause the other to be modified. The new buffer's capacity will be that of this buffer, its position will be &lt;code&gt;position()&lt;/code&gt; + &lt;code&gt;start&lt;/code&gt;, and its limit will be &lt;code&gt;position()&lt;/code&gt; + &lt;code&gt;end&lt;/code&gt;. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼는이 버퍼의 내용을 공유합니다. 즉,이 버퍼의 내용이 변경 가능한 경우 한 버퍼를 수정하면 다른 버퍼가 수정됩니다. 새로운 버퍼의 용량은이 버퍼의 용량이되고, 위치는 &lt;code&gt;position()&lt;/code&gt; + &lt;code&gt;start&lt;/code&gt; 이며, 한계는 &lt;code&gt;position()&lt;/code&gt; + &lt;code&gt;end&lt;/code&gt; 입니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="dc2c8b2d7d20a9e7009df83e54bdc37e78f70e0d" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position and mark values will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 용량, 한계, 위치 및 표시 값은이 버퍼의 값과 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="e41c4ae231a59cfcca0e03cc7c39edbc8d2edb92" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새 버퍼의 용량, 한계, 위치 및 표시 값은이 버퍼의 값과 동일하며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="49eb244b64c8d9a9ba9cd656fc24f8323f3eb0f6" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 용량, 한계, 위치 및 표시 값은이 버퍼의 값과 동일하며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; &lt;/a&gt; 입니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이고,이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="7d665df25b33f41e16e1676893f85747fee6206b" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer.</source>
          <target state="translated">새로운 버퍼의 용량, 한계, 위치 및 마크 값은이 버퍼와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1441a0ea6ee677b09ef764abcace356aff8ffb6a" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, and mark values will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 용량, 한계, 위치 및 마크 값은이 버퍼와 동일합니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="6550570fb9555c58e1cb0e5def73509b39966896" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, mark values, and byte order will be identical to those of this buffer.</source>
          <target state="translated">새 버퍼의 용량, 한계, 위치, 표시 값 및 바이트 순서는이 버퍼의 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f79d65af633493eb7a8e1c8f5a8b5b414b175153" translate="yes" xml:space="preserve">
          <source>The new buffer's capacity, limit, position, mark values, and byte order will be identical to those of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 용량, 한계, 위치, 표시 값 및 바이트 순서는이 버퍼의 것과 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="5d0859533f4f7eba199c12f64f9c924ec68a5ed4" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be &lt;code&gt;length&lt;/code&gt;, its mark will be undefined, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0, 용량 및 한계는 &lt;code&gt;length&lt;/code&gt; , 마크는 정의되지 않고 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; &lt;/a&gt; 입니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이고,이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="fd8fd4d38b4a711de6697a218a5e29d85c42d5ae" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be &lt;code&gt;length&lt;/code&gt;, its mark will be undefined, and its byte order will be identical to that of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0, 용량 및 한계는 &lt;code&gt;length&lt;/code&gt; , 표시는 정의되지 않으며 바이트 순서는이 버퍼의 순서와 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이고,이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="d1a160e2273e22d7f46b108919d8b91c72e2e605" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be &lt;code&gt;length&lt;/code&gt;, its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는 &lt;code&gt;length&lt;/code&gt; 가되며 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이고,이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="a13d0be56226b191c2b44377cfe1a92626a44776" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by eight, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 8로 나눈 값이되고 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="c02f03f90159f93e336df782d499064fb01da7f6" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by eight, its mark will be undefined, and its byte order will be that of the byte buffer at the moment the view is created. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 8로 나눈 값이며, 마크는 정의되지 않으며, 바이트 순서는 뷰가 표시되는 순간의 바이트 버퍼의 순서가됩니다. 만들어진. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="90552048b6aa0101e52962a0d5b974862e391b43" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by four, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 4로 나눈 값이며 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="04d53bc931f3031cff24d274e2153cb0f909b287" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by four, its mark will be undefined, and its byte order will be that of the byte buffer at the moment the view is created. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 4로 나눈 값이고, 마크는 정의되지 않으며, 바이트 순서는 뷰가 표시되는 순간의 바이트 버퍼의 순서가됩니다. 만들어진. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="cfc7272e6b5899b3b2bcbd70bb498a4197e3a159" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by two, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 2로 나눈 값이며 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="a414db15894243d7fc9b87769d0b51664c13216d" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer divided by two, its mark will be undefined, and its byte order will be that of the byte buffer at the moment the view is created. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 바이트 수를 2로 나눈 값이고, 마크는 정의되지 않으며, 해당 바이트 순서는 뷰가 표시되는 순간의 바이트 버퍼의 순서가됩니다. 만들어진. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="b52b5dc3e863470f025e539f6bf77a5f3e4be8d9" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer or fewer subject to alignment, its mark will be undefined, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0, 용량 및 한계는이 버퍼에 남아있는 바이트 수 또는 정렬 대상이 될 수있는 바이트 수이며, 마크는 정의되지 않으며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; 이&lt;/a&gt; 됩니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이고,이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="9a09a10dc3d2fc25e63569ae94bfd86cd530afbc" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 바이트 수가되고 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="111bd5660eac942fbcac5519244714b2247bf80a" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of bytes remaining in this buffer, its mark will be undefined, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 바이트 수이며 마크는 정의되지 않으며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; 이&lt;/a&gt; 됩니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이고,이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="fba588f426f87edc19c14d7f0682ef96259b59dd" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of chars remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 문자 수이며 표시는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="62b85884a696b76732cec9a21385d540addc262a" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of chars remaining in this buffer, its mark will be undefined, and its byte order will be identical to that of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 문자의 수이며 마크는 정의되지 않으며 바이트 순서는이 버퍼의 순서와 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="f0973afd84caee05155e2681a55128180674a18a" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of doubles remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 그 용량과 한계는이 버퍼에 남은 두 배의 수이며, 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="f30e4a528cab353438c8c19e5c1f5da6f13e94ec" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of doubles remaining in this buffer, its mark will be undefined, and its byte order will be identical to that of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 더블의 수이며, 마크는 정의되지 않으며 바이트 순서는이 버퍼의 순서와 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="ea906443b3c3866a2da17662e0837ea4ceea532d" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of elements remaining in this buffer, its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 요소의 수이며 표시는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="8222a6605391ceeccd212b79d0de137bdee941ea" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of floats remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새로운 버퍼의 위치는 0이되고, 그 용량과 한계는이 버퍼에 남아있는 플로트의 수이며, 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="6e18af5ed60c263adba26d819e39f8be09733dac" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of floats remaining in this buffer, its mark will be undefined, and its byte order will be identical to that of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 부동 소수점 수이며, 마크는 정의되지 않으며 바이트 순서는이 버퍼의 순서와 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="409703dd3fa5e15595f45b7bfa97d23dfc879f75" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of ints remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 정수의 개수가되고 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="f2b37217a2a5560896450794e316ea9ef8cba8b8" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of ints remaining in this buffer, its mark will be undefined, and its byte order will be identical to that of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 정수의 수이며 마크는 정의되지 않으며 바이트 순서는이 버퍼의 바이트 순서와 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="184e102258e542a41b9bc5bd5712cf1b45f7ba82" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of longs remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 길이의 수이며 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="319703467b5cb1d899cc5f3b715fa5fcab517e87" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of longs remaining in this buffer, its mark will be undefined, and its byte order will be identical to that of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 long의 수이며 표시는 정의되지 않으며 바이트 순서는이 버퍼의 순서와 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="db4d05da05e11921709f2c45d3cc55f4a61dcdd8" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of shorts remaining in this buffer, and its mark will be undefined. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고, 용량과 한계는이 버퍼에 남아있는 쇼트 수이며, 마크는 정의되지 않습니다. 새 버퍼는이 버퍼가 직접 인 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="ca4a2b6104fd9c9d8887d29f3acd6594660e9a9a" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its capacity and its limit will be the number of shorts remaining in this buffer, its mark will be undefined, and its byte order will be identical to that of this buffer. The new buffer will be direct if, and only if, this buffer is direct, and it will be read-only if, and only if, this buffer is read-only.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 용량과 한계는이 버퍼에 남아있는 쇼트의 수이며 마크는 정의되지 않으며 바이트 순서는이 버퍼의 바이트 순서와 동일합니다. 새 버퍼는이 버퍼가 직접적 일 경우에만 직접적이며이 버퍼가 읽기 전용 인 경우에만 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="e873cc2a43337dc6d0f48726bcbfe54afbbbb3dd" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;bytebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;bytebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;bytebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="0bc120342e8b1870b356b3688bd19e6b6d771658" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;charbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;charbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;charbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="4499f8809b64cea17e4ae935e38e57b0f0d75938" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;doublebuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;doublebuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;doublebuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="98fcf6ac3b1e8e48717c044627e4568fcf5fbd06" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;floatbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;floatbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;floatbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b824b2632dba5cfa58058d0964f1ea0de5c6b90e" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;intbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;intbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;intbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="0f405c739bacda631028ecb69ab8e7e2935ea317" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;longbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;longbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;longbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="ab6d02b7d7ce9994222ab6506d8bcc54c8589506" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. It will have a &lt;a href=&quot;shortbuffer#array--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. 그것은 것이다 &lt;a href=&quot;shortbuffer#array--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;shortbuffer#arrayOffset--&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b9f0b692e41b510f435757041e930b3ca3d5e9be" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, and each of its elements will be initialized to zero. Whether or not it has a &lt;a href=&quot;bytebuffer#hasArray--&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; is unspecified.</source>
          <target state="translated">새 버퍼의 위치는 0이되고 한계는 용량이되고 표시는 정의되지 않으며 각 요소는 0으로 초기화됩니다. &lt;a href=&quot;bytebuffer#hasArray--&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 이 있는지 여부 는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbc7cae7c2403b598dadadcb3b2ec2f7f72370c3" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, each of its elements will be initialized to zero, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. It will have a &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0, 한계는 용량, 마크는 정의되지 않고 각 요소는 0으로 초기화되며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; 이&lt;/a&gt; 됩니다. 그것은 것이다 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="7290acf9ff7e32a5e68089310685aad7a3175da4" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, each of its elements will be initialized to zero, and its byte order will be &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;. Whether or not it has a &lt;a href=&quot;#hasArray()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt; is unspecified.</source>
          <target state="translated">새 버퍼의 위치는 0, 한계는 용량, 마크는 정의되지 않고 각 요소는 0으로 초기화되며 바이트 순서는 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; 이&lt;/a&gt; 됩니다. &lt;a href=&quot;#hasArray()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 가 있는지 여부 는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e20908b4684455a9d46aa45c5928acb89154e418" translate="yes" xml:space="preserve">
          <source>The new buffer's position will be zero, its limit will be its capacity, its mark will be undefined, each of its elements will be initialized to zero, and its byte order will be the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. It will have a &lt;a href=&quot;#array()&quot;&gt;&lt;code&gt;backing array&lt;/code&gt;&lt;/a&gt;, and its &lt;a href=&quot;#arrayOffset()&quot;&gt;&lt;code&gt;array offset&lt;/code&gt;&lt;/a&gt; will be zero.</source>
          <target state="translated">새 버퍼의 위치는 0, 한계는 용량, 마크는 정의되지 않고 각 요소는 0으로 초기화되며 바이트 순서는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 가됩니다. 그것은 것이다 &lt;a href=&quot;#array()&quot;&gt; &lt;code&gt;backing array&lt;/code&gt; &lt;/a&gt; 및 그 &lt;a href=&quot;#arrayOffset()&quot;&gt; &lt;code&gt;array offset&lt;/code&gt; &lt;/a&gt; 제로가 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b1662b58ac08c19eb90fcbe51af1d61f93d2d097" translate="yes" xml:space="preserve">
          <source>The new byte buffer</source>
          <target state="translated">새로운 바이트 버퍼</target>
        </trans-unit>
        <trans-unit id="a45f4c65b0bb36650376b631e6594f501b8c823a" translate="yes" xml:space="preserve">
          <source>The new channel</source>
          <target state="translated">새로운 채널</target>
        </trans-unit>
        <trans-unit id="39988f7bd48bce3640ae9255ae58edd4d492d701" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;../file/spi/filesystemprovider#newFileChannel(java.nio.file.Path,java.util.Set,java.nio.file.attribute.FileAttribute...)&quot;&gt;&lt;code&gt;newFileChannel&lt;/code&gt;&lt;/a&gt; method on the provider that created the &lt;code&gt;Path&lt;/code&gt;.</source>
          <target state="translated">새 채널은 &lt;code&gt;Path&lt;/code&gt; 를 만든 공급자 에서 &lt;a href=&quot;../file/spi/filesystemprovider#newFileChannel(java.nio.file.Path,java.util.Set,java.nio.file.attribute.FileAttribute...)&quot;&gt; &lt;code&gt;newFileChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a0c64b8684bdcf86946498ab7c59c1c46403fb26" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;../file/spi/filesystemprovider#newFileChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt;&lt;code&gt;newFileChannel&lt;/code&gt;&lt;/a&gt; method on the provider that created the &lt;code&gt;Path&lt;/code&gt;.</source>
          <target state="translated">새 채널은 &lt;code&gt;Path&lt;/code&gt; 를 작성한 제공자 에서 &lt;a href=&quot;../file/spi/filesystemprovider#newFileChannel-java.nio.file.Path-java.util.Set-java.nio.file.attribute.FileAttribute...-&quot;&gt; &lt;code&gt;newFileChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3f0ccd9145e43381e62fd1685d01e3719c2f360" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousServerSocketChannel(java.nio.channels.AsynchronousChannelGroup)&quot;&gt;&lt;code&gt;openAsynchronousServerSocketChannel&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; object that created the given group. If the group parameter is &lt;code&gt;null&lt;/code&gt; then the resulting channel is created by the system-wide default provider, and bound to the &lt;em&gt;default group&lt;/em&gt;.</source>
          <target state="translated">새 채널은 지정된 그룹을 만든 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 개체 에서 &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousServerSocketChannel(java.nio.channels.AsynchronousChannelGroup)&quot;&gt; &lt;code&gt;openAsynchronousServerSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 만듭니다. 그룹 매개 변수가 &lt;code&gt;null&lt;/code&gt; 이면 결과 채널은 시스템 전체 기본 공급자에 의해 생성되고 &lt;em&gt;기본 그룹에&lt;/em&gt; 바인딩됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30644cb35aeeea5e1c72b112f048cacccf59280e" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousServerSocketChannel-java.nio.channels.AsynchronousChannelGroup-&quot;&gt;&lt;code&gt;openAsynchronousServerSocketChannel&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; object that created the given group. If the group parameter is &lt;code&gt;null&lt;/code&gt; then the resulting channel is created by the system-wide default provider, and bound to the &lt;em&gt;default group&lt;/em&gt;.</source>
          <target state="translated">지정된 그룹을 만든 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 객체 에서 &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousServerSocketChannel-java.nio.channels.AsynchronousChannelGroup-&quot;&gt; &lt;code&gt;openAsynchronousServerSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 새 채널을 만듭니다. group 매개 변수가 &lt;code&gt;null&lt;/code&gt; 이면 결과 채널이 시스템 전체 기본 공급자에 의해 만들어지고 &lt;em&gt;기본 그룹에&lt;/em&gt; 바인딩됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="562dfacb39e3312f09e9cc2dfa08d51de3d858cf" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousSocketChannel(java.nio.channels.AsynchronousChannelGroup)&quot;&gt;&lt;code&gt;openAsynchronousSocketChannel&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; that created the group. If the group parameter is &lt;code&gt;null&lt;/code&gt; then the resulting channel is created by the system-wide default provider, and bound to the &lt;em&gt;default group&lt;/em&gt;.</source>
          <target state="translated">새 채널은 그룹을 만든 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousSocketChannel(java.nio.channels.AsynchronousChannelGroup)&quot;&gt; &lt;code&gt;openAsynchronousSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 . 그룹 매개 변수가 &lt;code&gt;null&lt;/code&gt; 이면 결과 채널은 시스템 전체 기본 공급자에 의해 생성되고 &lt;em&gt;기본 그룹에&lt;/em&gt; 바인딩됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2fa05ef1e428bfbeed57a213a4e34a9d9876bffe" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousSocketChannel-java.nio.channels.AsynchronousChannelGroup-&quot;&gt;&lt;code&gt;openAsynchronousSocketChannel&lt;/code&gt;&lt;/a&gt; method on the &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt;&lt;code&gt;AsynchronousChannelProvider&lt;/code&gt;&lt;/a&gt; that created the group. If the group parameter is &lt;code&gt;null&lt;/code&gt; then the resulting channel is created by the system-wide default provider, and bound to the &lt;em&gt;default group&lt;/em&gt;.</source>
          <target state="translated">새 채널은 그룹을 만든 &lt;a href=&quot;spi/asynchronouschannelprovider&quot;&gt; &lt;code&gt;AsynchronousChannelProvider&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;spi/asynchronouschannelprovider#openAsynchronousSocketChannel-java.nio.channels.AsynchronousChannelGroup-&quot;&gt; &lt;code&gt;openAsynchronousSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 만듭니다. group 매개 변수가 &lt;code&gt;null&lt;/code&gt; 이면 결과 채널이 시스템 전체 기본 공급자에 의해 만들어지고 &lt;em&gt;기본 그룹에&lt;/em&gt; 바인딩됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d32ddddfcc557792e2a3982412cb757082a83260" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openDatagramChannel()&quot;&gt;&lt;code&gt;openDatagramChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object. The channel will not be connected.</source>
          <target state="translated">새 채널은 시스템 전체 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체 의 &lt;a href=&quot;spi/selectorprovider#openDatagramChannel()&quot;&gt; &lt;code&gt;openDatagramChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 . 채널이 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="154c7f6ed3d5cc86652d699d9e0e59a008d31144" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openDatagramChannel(java.net.ProtocolFamily)&quot;&gt;&lt;code&gt;openDatagramChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object. The channel will not be connected.</source>
          <target state="translated">새 채널은 시스템 전체 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체 의 &lt;a href=&quot;spi/selectorprovider#openDatagramChannel(java.net.ProtocolFamily)&quot;&gt; &lt;code&gt;openDatagramChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 . 채널이 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a7232600a19d5c749f1ed775c91b5c69237ecde" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openDatagramChannel--&quot;&gt;&lt;code&gt;openDatagramChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object. The channel will not be connected.</source>
          <target state="translated">새로운 채널은 시스템 전체의 디폴트 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openDatagramChannel--&quot;&gt; &lt;code&gt;openDatagramChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것으로 작성됩니다 . 채널이 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c3805a8ad4425a07e7b9601f1dc5f49f6555fb05" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openDatagramChannel-java.net.ProtocolFamily-&quot;&gt;&lt;code&gt;openDatagramChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object. The channel will not be connected.</source>
          <target state="translated">새로운 채널은 시스템 전체의 디폴트 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openDatagramChannel-java.net.ProtocolFamily-&quot;&gt; &lt;code&gt;openDatagramChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것으로 작성됩니다 . 채널이 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="959d7a0fafc989b56eed04d747893067826ef149" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openServerSocketChannel()&quot;&gt;&lt;code&gt;openServerSocketChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새 채널은 시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체 의 &lt;a href=&quot;spi/selectorprovider#openServerSocketChannel()&quot;&gt; &lt;code&gt;openServerSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1ea70f40215283abdf01fc3d884a51c682ee7f37" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openServerSocketChannel(java.net.ProtocolFamily)&quot;&gt;&lt;code&gt;openServerSocketChannel(ProtocolFamily)&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새 채널은 시스템 전체 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체 의 &lt;a href=&quot;spi/selectorprovider#openServerSocketChannel(java.net.ProtocolFamily)&quot;&gt; &lt;code&gt;openServerSocketChannel(ProtocolFamily)&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="640a2a8aa11bc64a4a6a49aefd39e43c327cdc4d" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openServerSocketChannel--&quot;&gt;&lt;code&gt;openServerSocketChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새로운 채널은 시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openServerSocketChannel--&quot;&gt; &lt;code&gt;openServerSocketChannel&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5a091dfe7abb19d6eed31b9d441901fe7edd403a" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openSocketChannel()&quot;&gt;&lt;code&gt;openSocketChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새 채널은 시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체 의 &lt;a href=&quot;spi/selectorprovider#openSocketChannel()&quot;&gt; &lt;code&gt;openSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f5efe1c452cc61f00d538b00398c6e9c85c0ef0" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openSocketChannel(java.net.ProtocolFamily)&quot;&gt;&lt;code&gt;openSocketChannel(ProtocolFamily)&lt;/code&gt;&lt;/a&gt; method of the system-wide default. &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새 채널은 시스템 전체 기본값 의 &lt;a href=&quot;spi/selectorprovider#openSocketChannel(java.net.ProtocolFamily)&quot;&gt; &lt;code&gt;openSocketChannel(ProtocolFamily)&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 . &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체입니다.</target>
        </trans-unit>
        <trans-unit id="b3c960cf1b6fdeb74926d0f06d9ebb63c6b2bfe2" translate="yes" xml:space="preserve">
          <source>The new channel is created by invoking the &lt;a href=&quot;spi/selectorprovider#openSocketChannel--&quot;&gt;&lt;code&gt;openSocketChannel&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새 채널은 시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openSocketChannel--&quot;&gt; &lt;code&gt;openSocketChannel&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="2a4e608f96db52ee969f0bd80aab227b4407654a" translate="yes" xml:space="preserve">
          <source>The new channel is unbound and unconnected.</source>
          <target state="translated">새 채널은 바인딩 해제되고 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15c4e6dd6305ec4f180be38da828431f52c91192" translate="yes" xml:space="preserve">
          <source>The new channel is unbound.</source>
          <target state="translated">새 채널이 바인딩 해제되었습니다.</target>
        </trans-unit>
        <trans-unit id="ea1cbf1d75b44adb6e4a5286b15544eb44d26552" translate="yes" xml:space="preserve">
          <source>The new channel's socket is initially unbound; it must be bound to a specific address via one of its socket's &lt;a href=&quot;#bind(java.net.SocketAddress)&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; methods before associations can be accepted.</source>
          <target state="translated">새 채널의 소켓은 처음에 바인딩 해제됩니다. 연결이 허용되기 전에 소켓의 &lt;a href=&quot;#bind(java.net.SocketAddress)&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 통해 특정 주소에 바인드되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ef5640ed0e3dd57e5904174d8dcc4cbd65edeff0" translate="yes" xml:space="preserve">
          <source>The new channel's socket is initially unbound; it must be bound to a specific address via one of its socket's &lt;a href=&quot;../../net/serversocket#bind(java.net.SocketAddress)&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; methods before connections can be accepted.</source>
          <target state="translated">새 채널의 소켓은 처음에 바인딩 해제됩니다. 연결이 허용되기 전에 소켓의 &lt;a href=&quot;../../net/serversocket#bind(java.net.SocketAddress)&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 통해 특정 주소에 바인드되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4166a9ca9c991a66f299641f2e32e0fece1a98ba" translate="yes" xml:space="preserve">
          <source>The new channel's socket is initially unbound; it must be bound to a specific address via one of its socket's &lt;a href=&quot;../../net/serversocket#bind-java.net.SocketAddress-&quot;&gt;&lt;code&gt;bind&lt;/code&gt;&lt;/a&gt; methods before connections can be accepted.</source>
          <target state="translated">새로운 채널의 소켓은 초기에 언 바운드입니다. 연결을 수락하기 전에 소켓의 &lt;a href=&quot;../../net/serversocket#bind-java.net.SocketAddress-&quot;&gt; &lt;code&gt;bind&lt;/code&gt; &lt;/a&gt; 메소드 중 하나를 통해 특정 주소에 바인드되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="405a847e27c80c831a52b3ca25e1aee97b0b63cd" translate="yes" xml:space="preserve">
          <source>The new char buffer</source>
          <target state="translated">새로운 문자 버퍼</target>
        </trans-unit>
        <trans-unit id="a3bfde5271747a153dbc45be6dd7b2fa8d92c106" translate="yes" xml:space="preserve">
          <source>The new character buffer</source>
          <target state="translated">새로운 캐릭터 버퍼</target>
        </trans-unit>
        <trans-unit id="105e02b325849c87768426ba794cd482fa2cf5d4" translate="yes" xml:space="preserve">
          <source>The new context has the same environment properties and connection request controls as this context. See the class description for details. Implementations might also allow this context and the new context to share the same network connection or other resources if doing so does not impede the independence of either context.</source>
          <target state="translated">새 컨텍스트에는이 컨텍스트와 동일한 환경 특성 및 연결 요청 제어가 있습니다. 자세한 내용은 수업 설명을 참조하십시오. 구현시이 컨텍스트와 새 컨텍스트가 동일한 네트워크 연결 또는 다른 리소스를 공유 할 수 있으므로 컨텍스트의 독립성을 방해하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32225c2b2a4cd61beeafae6360573239239143d8" translate="yes" xml:space="preserve">
          <source>The new directory stream, once created, is not dependent upon the directory stream used to create it. Closing this directory stream has no effect upon newly created directory stream.</source>
          <target state="translated">일단 작성된 새 디렉토리 스트림은이를 작성하는 데 사용 된 디렉토리 스트림에 종속되지 않습니다. 이 디렉토리 스트림을 닫아도 새로 작성된 디렉토리 스트림에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1472dd980957833880e469fd869da118a620a1d" translate="yes" xml:space="preserve">
          <source>The new double buffer</source>
          <target state="translated">새로운 더블 버퍼</target>
        </trans-unit>
        <trans-unit id="2f0532ed60ab4132dd9d65f7412ae3fdaace63d3" translate="yes" xml:space="preserve">
          <source>The new float buffer</source>
          <target state="translated">새로운 플로트 버퍼</target>
        </trans-unit>
        <trans-unit id="f60894a3ea95a69c84bc4b87c767e21d9aecdcf4" translate="yes" xml:space="preserve">
          <source>The new glass pane's visibility is changed to match that of the current glass pane. An implication of this is that care must be taken when you want to replace the glass pane and make it visible. Either of the following will work:</source>
          <target state="translated">새 유리창의 가시성이 현재 유리창의 가시성과 일치하도록 변경됩니다. 이것의 의미는 유리창을 교체하고 보이게 할 때주의를 기울여야한다는 것입니다. 다음 중 하나가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="40fa9d09acdee10a0a3b36ab9ea3d84678cccd77" translate="yes" xml:space="preserve">
          <source>The new graphics context has an additional clipping rectangle, in addition to whatever (translated) clipping rectangle it inherited from the original graphics context. The origin of the new clipping rectangle is at (&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;), and its size is specified by the &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; arguments.</source>
          <target state="translated">새 그래픽 컨텍스트에는 원래 그래픽 컨텍스트에서 상속 된 (변환 된) 클리핑 사각형 외에 추가 클리핑 사각형이 있습니다. 새 클리핑 사각형의 원점은 ( &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; )이고 크기는 &lt;code&gt;width&lt;/code&gt; 및 &lt;code&gt;height&lt;/code&gt; 인수로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1aad4607b7a4ff89c5cae016542628ea7e5e8cda" translate="yes" xml:space="preserve">
          <source>The new graphics context is translated by (</source>
          <target state="translated">새 그래픽 컨텍스트는 (</target>
        </trans-unit>
        <trans-unit id="351ce29e1a236701155b75e9b6605d4772412233" translate="yes" xml:space="preserve">
          <source>The new handlers are not implemented by the SAX2 &lt;code&gt;org.xml.sax.helpers.DefaultHandler&lt;/code&gt; or &lt;code&gt;org.xml.sax.helpers.XMLFilterImpl&lt;/code&gt; classes. You can subclass these if you need such behavior, or use the helper classes found here.</source>
          <target state="translated">새 핸들러는 SAX2 &lt;code&gt;org.xml.sax.helpers.DefaultHandler&lt;/code&gt; 또는 &lt;code&gt;org.xml.sax.helpers.XMLFilterImpl&lt;/code&gt; 클래스에 의해 구현되지 않습니다 . 이러한 동작이 필요한 경우 하위 클래스를 만들거나 여기에있는 도우미 클래스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c7a2f2dd2b2712931e42cff9b291f698ae12a0" translate="yes" xml:space="preserve">
          <source>The new input source, or null to require the default behaviour.</source>
          <target state="translated">새 입력 소스 또는 기본 동작이 필요한 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="1f6194d825d6dc0688d142cdf98fae1e64221945" translate="yes" xml:space="preserve">
          <source>The new int buffer</source>
          <target state="translated">새로운 int 버퍼</target>
        </trans-unit>
        <trans-unit id="16916b8d2254968908c21ac68fdf72fdd3794032" translate="yes" xml:space="preserve">
          <source>The new iterator</source>
          <target state="translated">새로운 반복자</target>
        </trans-unit>
        <trans-unit id="779eee0d9cf7a611f52c9afc435db4ffc9a7b2aa" translate="yes" xml:space="preserve">
          <source>The new long buffer</source>
          <target state="translated">새로운 긴 버퍼</target>
        </trans-unit>
        <trans-unit id="a049a6df3cdeeeac083a1b0492d8837e20ab7728" translate="yes" xml:space="preserve">
          <source>The new method handle, when invoked, will perform the following steps:</source>
          <target state="translated">새 메소드 핸들은 호출 될 때 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="92e50b8ce0fbbc5d3ddc700f726a1f61541bb746" translate="yes" xml:space="preserve">
          <source>The new node, of the same type as this node.</source>
          <target state="translated">이 노드와 동일한 유형의 새 노드입니다.</target>
        </trans-unit>
        <trans-unit id="aad32c6be4c40289765349dc77371198d0722960" translate="yes" xml:space="preserve">
          <source>The new node, or &lt;code&gt;null&lt;/code&gt; if the current node has no children in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새 노드, 또는 현재 노드에 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리적 뷰에 자식이없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fa7f18ee056860588a84eb3540948e7621523f1" translate="yes" xml:space="preserve">
          <source>The new node, or &lt;code&gt;null&lt;/code&gt; if the current node has no next node in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새 노드, 또는 현재 노드에 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리적보기 에 다음 노드가없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08bee0f0cc7eaeddd7d01886f4661fa98348f038" translate="yes" xml:space="preserve">
          <source>The new node, or &lt;code&gt;null&lt;/code&gt; if the current node has no next sibling. in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새 노드 또는 현재 노드에 다음 형제가없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다. 에서 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리적보기.</target>
        </trans-unit>
        <trans-unit id="53979055d6a4dbf049878044d8f40a2525ff6d07" translate="yes" xml:space="preserve">
          <source>The new node, or &lt;code&gt;null&lt;/code&gt; if the current node has no previous node in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새 노드, 또는 현재 노드에 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리보기 에 이전 노드가없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="66d1991db11199cc0a752370830eb32dd53f1760" translate="yes" xml:space="preserve">
          <source>The new node, or &lt;code&gt;null&lt;/code&gt; if the current node has no previous sibling. in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새 노드 또는 현재 노드에 이전 형제가없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다. 에서 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리적보기.</target>
        </trans-unit>
        <trans-unit id="cc9bb88661ee58f520f7596174f8b9dbd4b0c604" translate="yes" xml:space="preserve">
          <source>The new node, or &lt;code&gt;null&lt;/code&gt; if the current node has no visible children in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새 노드 또는 현재 노드에 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리적 뷰 에 보이는 자식이없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c7edac962c9fdf5e1ed3e30ef75f9b85854bb6c3" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 2-argument constructor DeflaterOutputStream(out, false).</source>
          <target state="translated">새 출력 스트림 인스턴스는 2 개의 인수 생성자 DeflaterOutputStream (out, false)을 호출하여 것처럼 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="17e00405c9d859e5ea535348ea74cc91e9987eea" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 2-argument constructor GZIPOutputStream(out, false).</source>
          <target state="translated">새 출력 스트림 인스턴스는 2 인수 생성자 GZIPOutputStream (out, false)을 호출하여 것처럼 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="eba31038050930f93163a540e115ac8b731c66f1" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 3-argument constructor DeflaterOutputStream(out, def, false).</source>
          <target state="translated">새로운 출력 스트림 인스턴스는 3- 인수 생성자 DeflaterOutputStream (out, def, false)을 호출하는 것처럼 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d9335ad9c012ce1f2b92b1f6698fcccb2cb17791" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 3-argument constructor GZIPOutputStream(out, size, false).</source>
          <target state="translated">새로운 출력 스트림 인스턴스는 3- 인수 생성자 GZIPOutputStream (out, size, false)을 호출하는 것처럼 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f12bbb4d87ec052fcf9300036f1e190a6c68064b" translate="yes" xml:space="preserve">
          <source>The new output stream instance is created as if by invoking the 4-argument constructor DeflaterOutputStream(out, def, size, false).</source>
          <target state="translated">새로운 출력 스트림 인스턴스는 4 개의 인수 생성자 DeflaterOutputStream (out, def, size, false)을 호출하는 것처럼 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="51f264957ea16725861ee0b7f2549925bad1a95b" translate="yes" xml:space="preserve">
          <source>The new parent node, or &lt;code&gt;null&lt;/code&gt; if the current node has no parent in the &lt;code&gt;TreeWalker&lt;/code&gt;'s logical view.</source>
          <target state="translated">새로운 부모 노드, 또는 현재 노드에 &lt;code&gt;TreeWalker&lt;/code&gt; 의 논리 뷰에 부모가없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d884f874f7014685b458a4af3391ba4d45f11053" translate="yes" xml:space="preserve">
          <source>The new pipe</source>
          <target state="translated">새로운 파이프</target>
        </trans-unit>
        <trans-unit id="81743a0e516c888ca495a3379f63119c30a076d1" translate="yes" xml:space="preserve">
          <source>The new pipe is created by invoking the &lt;a href=&quot;spi/selectorprovider#openPipe()&quot;&gt;&lt;code&gt;openPipe&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새 파이프는 시스템 전체 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체 의 &lt;a href=&quot;spi/selectorprovider#openPipe()&quot;&gt; &lt;code&gt;openPipe&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c83e22c89152847eb837b14970d1ac61dec5b58" translate="yes" xml:space="preserve">
          <source>The new pipe is created by invoking the &lt;a href=&quot;spi/selectorprovider#openPipe--&quot;&gt;&lt;code&gt;openPipe&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openPipe--&quot;&gt; &lt;code&gt;openPipe&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 새 파이프를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d288ab1052db5bba3bc77fb644b627d9caad3669" translate="yes" xml:space="preserve">
          <source>The new previous lookup class is chosen as follows:</source>
          <target state="translated">새로운 이전 조회 클래스는 다음과 같이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="ea7fad088fe017180a3cb702a40bcf125e3ccdc4" translate="yes" xml:space="preserve">
          <source>The new process will invoke the command and arguments given by &lt;a href=&quot;#command()&quot;&gt;&lt;code&gt;command()&lt;/code&gt;&lt;/a&gt;, in a working directory as given by &lt;a href=&quot;#directory()&quot;&gt;&lt;code&gt;directory()&lt;/code&gt;&lt;/a&gt;, with a process environment as given by &lt;a href=&quot;#environment()&quot;&gt;&lt;code&gt;environment()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새로운 프로세스는 &lt;a href=&quot;#environment()&quot;&gt; &lt;code&gt;environment()&lt;/code&gt; &lt;/a&gt; 의해 주어진 프로세스 환경과 함께 &lt;a href=&quot;#directory()&quot;&gt; &lt;code&gt;directory()&lt;/code&gt; &lt;/a&gt; 의해 주어진 작업 디렉토리에서 &lt;a href=&quot;#command()&quot;&gt; &lt;code&gt;command()&lt;/code&gt; &lt;/a&gt; 의해 주어진 명령과 인수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e219b1425b7017143bc6b763f1e3479269fe8f77" translate="yes" xml:space="preserve">
          <source>The new process will invoke the command and arguments given by &lt;a href=&quot;processbuilder#command--&quot;&gt;&lt;code&gt;command()&lt;/code&gt;&lt;/a&gt;, in a working directory as given by &lt;a href=&quot;processbuilder#directory--&quot;&gt;&lt;code&gt;directory()&lt;/code&gt;&lt;/a&gt;, with a process environment as given by &lt;a href=&quot;processbuilder#environment--&quot;&gt;&lt;code&gt;environment()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새 프로세스는 &lt;a href=&quot;processbuilder#environment--&quot;&gt; &lt;code&gt;environment()&lt;/code&gt; &lt;/a&gt; 의해 주어진 프로세스 환경과 함께 &lt;a href=&quot;processbuilder#directory--&quot;&gt; &lt;code&gt;directory()&lt;/code&gt; &lt;/a&gt; 의해 주어진 작업 디렉토리에서 &lt;a href=&quot;processbuilder#command--&quot;&gt; &lt;code&gt;command()&lt;/code&gt; &lt;/a&gt; 의해 주어진 명령과 인수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="95ac9042239c405df39132ca4d6a54dd4895fee9" translate="yes" xml:space="preserve">
          <source>The new selector</source>
          <target state="translated">새로운 선택기</target>
        </trans-unit>
        <trans-unit id="0afd52fcd7a3f4bc42d8190464378d5622d0a3f2" translate="yes" xml:space="preserve">
          <source>The new selector is created by invoking the &lt;a href=&quot;spi/selectorprovider#openSelector()&quot;&gt;&lt;code&gt;openSelector&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새 선택기는 시스템 전체의 기본 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 개체 의 &lt;a href=&quot;spi/selectorprovider#openSelector()&quot;&gt; &lt;code&gt;openSelector&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d90a5fbf3072fbdd10fb888cd77c2fecc69894d" translate="yes" xml:space="preserve">
          <source>The new selector is created by invoking the &lt;a href=&quot;spi/selectorprovider#openSelector--&quot;&gt;&lt;code&gt;openSelector&lt;/code&gt;&lt;/a&gt; method of the system-wide default &lt;a href=&quot;spi/selectorprovider&quot;&gt;&lt;code&gt;SelectorProvider&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새로운 선택기는 시스템 전체의 디폴트 &lt;a href=&quot;spi/selectorprovider&quot;&gt; &lt;code&gt;SelectorProvider&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;spi/selectorprovider#openSelector--&quot;&gt; &lt;code&gt;openSelector&lt;/code&gt; &lt;/a&gt; 메소드를 호출함으로써 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="51a2e917f552d1b6e1f23856874476d3b036cddf" translate="yes" xml:space="preserve">
          <source>The new short buffer</source>
          <target state="translated">새로운 짧은 버퍼</target>
        </trans-unit>
        <trans-unit id="cdfb6de24569ebdf6e37ac2a01c85f6c9999b45a" translate="yes" xml:space="preserve">
          <source>The new string.</source>
          <target state="translated">새로운 문자열.</target>
        </trans-unit>
        <trans-unit id="256bfd55d3498eaaeab282ef6a86ba7b61007791" translate="yes" xml:space="preserve">
          <source>The new value for the preference, or &lt;code&gt;null&lt;/code&gt; if the preference was removed.</source>
          <target state="translated">환경 설정의 새 값 . 환경 설정이 제거 된 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca7055dc46762027e9a170faf3c4bd0af39a754d" translate="yes" xml:space="preserve">
          <source>The new value for the property, expressed as an Object. May be null if multiple properties have changed.</source>
          <target state="translated">속성의 새로운 값으로, Object로 표현됩니다. 여러 속성이 변경된 경우 null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fed342089a94d554987b9df830e98f728b84e13" translate="yes" xml:space="preserve">
          <source>The new, read-only byte buffer</source>
          <target state="translated">새로운 읽기 전용 바이트 버퍼</target>
        </trans-unit>
        <trans-unit id="051bb43b66b4c67456aad2b704f6aa6b0ddd97f5" translate="yes" xml:space="preserve">
          <source>The new, read-only char buffer</source>
          <target state="translated">새로운 읽기 전용 문자 버퍼</target>
        </trans-unit>
        <trans-unit id="5f53d1fe5257c7586da9f701a660008b6cdc42d4" translate="yes" xml:space="preserve">
          <source>The new, read-only double buffer</source>
          <target state="translated">새로운 읽기 전용 이중 버퍼</target>
        </trans-unit>
        <trans-unit id="ab388d6a1900bbf211a8682234f0d28e544b3f90" translate="yes" xml:space="preserve">
          <source>The new, read-only float buffer</source>
          <target state="translated">새로운 읽기 전용 플로트 버퍼</target>
        </trans-unit>
        <trans-unit id="f25346b335ad55392706741def759dd809ecac74" translate="yes" xml:space="preserve">
          <source>The new, read-only int buffer</source>
          <target state="translated">새로운 읽기 전용 int 버퍼</target>
        </trans-unit>
        <trans-unit id="38c3e68c7e1d834b8bc5df3c59964660afd47865" translate="yes" xml:space="preserve">
          <source>The new, read-only long buffer</source>
          <target state="translated">새로운 읽기 전용 롱 버퍼</target>
        </trans-unit>
        <trans-unit id="9632c9f4a41cbd94b91ee4867c7f6daa96d1578b" translate="yes" xml:space="preserve">
          <source>The new, read-only short buffer</source>
          <target state="translated">새로운 읽기 전용 짧은 버퍼</target>
        </trans-unit>
        <trans-unit id="c2c6f911faa099e683e433008f099f0a9b73bf5d" translate="yes" xml:space="preserve">
          <source>The newline (line feed) character (&lt;code&gt;'\u000A'&lt;/code&gt;)</source>
          <target state="translated">줄 바꿈 (줄 바꿈) 문자 ( &lt;code&gt;'\u000A'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c7384c3bb09727310bc462bab676b4596e47e94b" translate="yes" xml:space="preserve">
          <source>The newly constructed Sets check whether this &lt;code&gt;Subject&lt;/code&gt; has been set read-only before permitting subsequent modifications. The newly created Sets also prevent illegal modifications by ensuring that callers have sufficient permissions.</source>
          <target state="translated">새로 구성된 세트 는 후속 수정을 허용하기 전에이 &lt;code&gt;Subject&lt;/code&gt; 읽기 전용으로 설정되어 있는지 확인합니다 . 새로 생성 된 세트는 또한 발신자가 충분한 권한을 갖도록하여 불법적 인 수정을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="950cb6be1344fde9aef742cb8b54558cb32694c0" translate="yes" xml:space="preserve">
          <source>The newly constructed Sets check whether this &lt;code&gt;Subject&lt;/code&gt; has been set read-only before permitting subsequent modifications. The newly created Sets also prevent illegal modifications by ensuring that callers have sufficient permissions. These Sets also prohibit null elements, and attempts to add or query a null element will result in a &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">새로 구성된 세트 는 후속 수정을 허용하기 전에이 &lt;code&gt;Subject&lt;/code&gt; 읽기 전용으로 설정 되었는지 확인합니다 . 새로 생성 된 세트는 또한 호출자가 충분한 권한을 갖도록하여 불법적 인 수정을 방지합니다. 이러한 집합은 또한 null 요소를 금지하고 null 요소를 추가하거나 쿼리하려고하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f25a3de7da474f19021bd8b53da04f971e190cc7" translate="yes" xml:space="preserve">
          <source>The newly created &lt;code&gt;Event&lt;/code&gt;</source>
          <target state="translated">새로 생성 된 &lt;code&gt;Event&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28a3bbb5f8626699a4150b134c9da099d4f7b9f6" translate="yes" xml:space="preserve">
          <source>The newly created &lt;code&gt;LSParser&lt;/code&gt; object. This &lt;code&gt;LSParser&lt;/code&gt; is either synchronous or asynchronous depending on the value of the &lt;code&gt;mode&lt;/code&gt; argument.</source>
          <target state="translated">새로 생성 된 &lt;code&gt;LSParser&lt;/code&gt; 개체입니다. 이 &lt;code&gt;LSParser&lt;/code&gt; 는 &lt;code&gt;mode&lt;/code&gt; 인수 의 값에 따라 동기식 또는 비동기식 입니다.</target>
        </trans-unit>
        <trans-unit id="2e6864f451552ad1214b39d65e1af98daa80917f" translate="yes" xml:space="preserve">
          <source>The newly created &lt;code&gt;LSSerializer&lt;/code&gt; object.</source>
          <target state="translated">새로 생성 된 &lt;code&gt;LSSerializer&lt;/code&gt; 개체입니다.</target>
        </trans-unit>
        <trans-unit id="7e9c38638d5b2ca62e0875ef6d8d3c0e6198cf85" translate="yes" xml:space="preserve">
          <source>The newly created &lt;code&gt;NodeIterator&lt;/code&gt;.</source>
          <target state="translated">새로 생성 된 &lt;code&gt;NodeIterator&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="63f62a75ff2d1bcae67829ab95de721785ef5e31" translate="yes" xml:space="preserve">
          <source>The newly created &lt;code&gt;TreeWalker&lt;/code&gt;.</source>
          <target state="translated">새로 생성 된 &lt;code&gt;TreeWalker&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e5e31a1cc1c74f54f3cd20d6282840c7661b160" translate="yes" xml:space="preserve">
          <source>The newly created cell.</source>
          <target state="translated">새로 생성 된 셀입니다.</target>
        </trans-unit>
        <trans-unit id="71152fc3c9b4330d477e4b2a69f4edcb28719575" translate="yes" xml:space="preserve">
          <source>The newly created class or interface &lt;code&gt;C&lt;/code&gt; serves as the &lt;a href=&quot;#lookupClass()&quot;&gt;lookup class&lt;/a&gt; of the &lt;code&gt;Lookup&lt;/code&gt; object returned by this method. &lt;code&gt;C&lt;/code&gt; is &lt;em&gt;hidden&lt;/em&gt; in the sense that no other class or interface can refer to &lt;code&gt;C&lt;/code&gt; via a constant pool entry. That is, a hidden class or interface cannot be named as a supertype, a field type, a method parameter type, or a method return type by any other class. This is because a hidden class or interface does not have a binary name, so there is no internal form available to record in any class's constant pool. A hidden class or interface is not discoverable by &lt;a href=&quot;../class#forName(java.lang.String,boolean,java.lang.ClassLoader)&quot;&gt;&lt;code&gt;Class.forName(String, boolean, ClassLoader)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../classloader#loadClass(java.lang.String,boolean)&quot;&gt;&lt;code&gt;ClassLoader.loadClass(String, boolean)&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#findClass(java.lang.String)&quot;&gt;&lt;code&gt;findClass(String)&lt;/code&gt;&lt;/a&gt;, and is not &lt;a href=&quot;../../../../java.instrument/java/lang/instrument/instrumentation#isModifiableClass(java.lang.Class)&quot;&gt;modifiable&lt;/a&gt; by Java agents or tool agents using the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jvmti.html&quot;&gt; JVM Tool Interface&lt;/a&gt;.</source>
          <target state="translated">새로 생성 된 클래스 또는 인터페이스 &lt;code&gt;C&lt;/code&gt; 는 역할 &lt;a href=&quot;#lookupClass()&quot;&gt;룩업 클래스&lt;/a&gt; 의 &lt;code&gt;Lookup&lt;/code&gt; 이러한 방법에 의해 리턴 된 객체. &lt;code&gt;C&lt;/code&gt; 는 다른 클래스 나 인터페이스 가 상수 풀 항목을 통해 &lt;code&gt;C&lt;/code&gt; 를 참조 할 수 없다는 의미에서 &lt;em&gt;숨겨져&lt;/em&gt; 있습니다 . 즉, 숨겨진 클래스 또는 인터페이스는 다른 클래스에 의해 상위 유형, 필드 유형, 메소드 매개 변수 유형 또는 메소드 리턴 유형으로 명명 될 수 없습니다. 이는 숨겨진 클래스 또는 인터페이스에 이진 이름이 없기 때문에 클래스의 상수 풀에 기록 할 수있는 내부 형식이 없기 때문입니다. 숨겨진 클래스 또는 인터페이스는 &lt;a href=&quot;../class#forName(java.lang.String,boolean,java.lang.ClassLoader)&quot;&gt; &lt;code&gt;Class.forName(String, boolean, ClassLoader)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../classloader#loadClass(java.lang.String,boolean)&quot;&gt; &lt;code&gt;ClassLoader.loadClass(String, boolean)&lt;/code&gt; &lt;/a&gt;또는 &lt;a href=&quot;#findClass(java.lang.String)&quot;&gt; &lt;code&gt;findClass(String)&lt;/code&gt; &lt;/a&gt; 이며 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jvmti.html&quot;&gt;JVM 도구 인터페이스를&lt;/a&gt; 사용하는 Java 에이전트 또는 도구 에이전트에서 &lt;a href=&quot;../../../../java.instrument/java/lang/instrument/instrumentation#isModifiableClass(java.lang.Class)&quot;&gt;수정할 수&lt;/a&gt; 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a2a279a75cbfd1b2bc63caf566b30d4919609850" translate="yes" xml:space="preserve">
          <source>The newly created input object.</source>
          <target state="translated">새로 생성 된 입력 개체입니다.</target>
        </trans-unit>
        <trans-unit id="9ad3c1c06f2258bb8b0549b75e0edff7de06d15f" translate="yes" xml:space="preserve">
          <source>The newly created layer</source>
          <target state="translated">새로 생성 된 레이어</target>
        </trans-unit>
        <trans-unit id="fbcab23ed277974083f961513c6300581cc3dddd" translate="yes" xml:space="preserve">
          <source>The newly created output object.</source>
          <target state="translated">새로 생성 된 출력 개체입니다.</target>
        </trans-unit>
        <trans-unit id="3ecdb2179dd90bd6fc6af860dcdb167b3e9dd7a7" translate="yes" xml:space="preserve">
          <source>The newly created permission object replaces the UnresolvedPermission, which is removed.</source>
          <target state="translated">새로 만든 권한 개체가 제거 된 UnresolvedPermission을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="c7b105995f24b1e2b648556c2293bbc4eb17ca2e" translate="yes" xml:space="preserve">
          <source>The newly created recording is in the &lt;a href=&quot;recordingstate#NEW&quot;&gt;&lt;code&gt;RecordingState.NEW&lt;/code&gt;&lt;/a&gt; state. To start the recording, invoke the &lt;a href=&quot;#start()&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">새로 생성 된 녹음은 &lt;a href=&quot;recordingstate#NEW&quot;&gt; &lt;code&gt;RecordingState.NEW&lt;/code&gt; &lt;/a&gt; 상태입니다. 기록을 시작하려면 start &lt;a href=&quot;#start()&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a66ffa820d5afabe54a1e4db548f48c6c7d28245" translate="yes" xml:space="preserve">
          <source>The newly created row.</source>
          <target state="translated">새로 생성 된 행입니다.</target>
        </trans-unit>
        <trans-unit id="b0535665b03585361bf66e8fd5718be81ec47c1d" translate="yes" xml:space="preserve">
          <source>The newly created thread is initially marked as being a daemon thread if and only if the thread creating it is currently marked as a daemon thread. The method &lt;a href=&quot;#setDaemon(boolean)&quot;&gt;setDaemon&lt;/a&gt; may be used to change whether or not a thread is a daemon.</source>
          <target state="translated">새로 생성 된 스레드는이를 생성하는 스레드가 현재 데몬 스레드로 표시된 경우에만 처음에는 데몬 스레드로 표시됩니다. &lt;a href=&quot;#setDaemon(boolean)&quot;&gt;setDaemon&lt;/a&gt; 메소드를 사용하여 스레드가 데몬인지 여부를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="526425b0b2a6b0567b0294d2b4111ab89f47f622" translate="yes" xml:space="preserve">
          <source>The newly created thread is initially marked as being a daemon thread if and only if the thread creating it is currently marked as a daemon thread. The method &lt;a href=&quot;thread#setDaemon-boolean-&quot;&gt;setDaemon&lt;/a&gt; may be used to change whether or not a thread is a daemon.</source>
          <target state="translated">새로 작성된 스레드는 스레드를 작성하는 스레드가 현재 디먼 스레드로 표시되는 경우에만 데몬 스레드로 표시됩니다. &lt;a href=&quot;thread#setDaemon-boolean-&quot;&gt;setDaemon&lt;/a&gt; 메소드 는 스레드가 데몬인지 여부를 변경하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f1012a0ca0d70327fd286d7c29cb6bd15b1c082" translate="yes" xml:space="preserve">
          <source>The newly defined &lt;code&gt;Package&lt;/code&gt; object</source>
          <target state="translated">새롭게 정의 된 &lt;code&gt;Package&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="e8a1d4d9b98ec9cdee82b685b8101093972dd311" translate="yes" xml:space="preserve">
          <source>The newly instantiated object.</source>
          <target state="translated">새로 인스턴스화 된 객체입니다.</target>
        </trans-unit>
        <trans-unit id="92ff2dd99580714af4fdb9c066e81faf90f4c0bf" translate="yes" xml:space="preserve">
          <source>The next &lt;a href=&quot;event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; in an &lt;a href=&quot;eventset&quot;&gt;&lt;code&gt;EventSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;eventset&quot;&gt; &lt;code&gt;EventSet&lt;/code&gt; &lt;/a&gt; 의 다음 &lt;a href=&quot;event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="30faf9343c317b3c3d65da86c3ef8e7eeaeeebe8" translate="yes" xml:space="preserve">
          <source>The next &lt;code&gt;Node&lt;/code&gt; in the set being iterated over, or &lt;code&gt;null&lt;/code&gt; if there are no more members in that set.</source>
          <target state="translated">반복되는 집합 의 다음 &lt;code&gt;Node&lt;/code&gt; 또는 해당 집합에 더 이상 구성원이 없으면 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0cfba659f68108a8eba88e4b742d7a0c443076d6" translate="yes" xml:space="preserve">
          <source>The next attribute in the list</source>
          <target state="translated">목록의 다음 속성</target>
        </trans-unit>
        <trans-unit id="7c190fdba16a43189c716408411071b0d121dcd8" translate="yes" xml:space="preserve">
          <source>The next code fragment shows populating a &lt;code&gt;CachedRowSet&lt;/code&gt; object using the method &lt;code&gt;execute&lt;/code&gt;, which may or may not take a &lt;code&gt;Connection&lt;/code&gt; object as a parameter. This code passes &lt;code&gt;execute&lt;/code&gt; the &lt;code&gt;Connection&lt;/code&gt; object</source>
          <target state="translated">다음 코드 조각은 &lt;code&gt;execute&lt;/code&gt; 메서드를 사용하여 &lt;code&gt;CachedRowSet&lt;/code&gt; 개체를 채우는 것을 보여줍니다. 이 메서드 는 &lt;code&gt;Connection&lt;/code&gt; 개체를 매개 변수로 사용 하거나 사용하지 않을 수 있습니다 . 이 코드는 통과 &lt;code&gt;execute&lt;/code&gt; &lt;code&gt;Connection&lt;/code&gt; 객체를</target>
        </trans-unit>
        <trans-unit id="003d3922eea2d3f53c0b82cbc99650ac135666f8" translate="yes" xml:space="preserve">
          <source>The next content model (in a ',', '|' or '&amp;amp;' expression).</source>
          <target state="translated">다음 콘텐츠 모델 ( ',', '|'또는 '&amp;amp;'표현식).</target>
        </trans-unit>
        <trans-unit id="4226522b6020d9eb89363bd243677866f295b1c0" translate="yes" xml:space="preserve">
          <source>The next event.</source>
          <target state="translated">다음 이벤트.</target>
        </trans-unit>
        <trans-unit id="62b2f558f8d0a98b00fed91f851c07fa625e66bd" translate="yes" xml:space="preserve">
          <source>The next event. This field is set when putting events into a linked list. This has been replaced by EventQueue.</source>
          <target state="translated">다음 이벤트. 이 필드는 이벤트를 연결 목록에 넣을 때 설정됩니다. 이것은 EventQueue로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="bc8222d0239dcfe9d56e39f9cbd0bf5bc8aa8ac0" translate="yes" xml:space="preserve">
          <source>The next example demonstrates moving to the insert row, building a new row on the insert row, inserting it into the rowset, and then calling the method &lt;code&gt;acceptChanges&lt;/code&gt; to add the new row to the underlying data source. Note that as with the getter methods, the updater methods may take either a column index or a column name to designate the column being acted upon.</source>
          <target state="translated">다음 예제에서는 삽입 행으로 이동하고, 삽입 행에 새 행을 만들고, 행 집합에 삽입 한 다음, &lt;code&gt;acceptChanges&lt;/code&gt; 메서드를 호출 하여 새 행을 기본 데이터 원본에 추가하는 방법 을 보여줍니다. getter 메서드와 마찬가지로 업데이트 프로그램 메서드는 열 인덱스 또는 열 이름을 사용하여 작업중인 열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9a97853b991192fa16b78639ad825e96e507ee6" translate="yes" xml:space="preserve">
          <source>The next example is useful in situations where you wish to process data as it is ready on the</source>
          <target state="translated">다음 예제는 데이터가 준비된대로 처리하려는 상황에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6875bb5b5c807acc8e5c2fa49dd331b238e4ca8a" translate="yes" xml:space="preserve">
          <source>The next group of &lt;code&gt;JTree&lt;/code&gt; methods use &quot;visible&quot; to mean &quot;viewable&quot; (under an expanded parent):</source>
          <target state="translated">다음 &lt;code&gt;JTree&lt;/code&gt; 메소드 그룹은 &quot;표시&quot;를 사용하여 &quot;보기 가능&quot;(확장 된 상위 아래)을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6b1ca923fcbee792afab001c0bf4d34e084c719f" translate="yes" xml:space="preserve">
          <source>The next simplest use of &lt;code&gt;EventHandler&lt;/code&gt; is to extract a property value from the first argument of the method in the listener interface (typically an event object) and use it to set the value of a property in the target object. In the following example we create an &lt;code&gt;ActionListener&lt;/code&gt; that sets the &lt;code&gt;nextFocusableComponent&lt;/code&gt; property of the target (myButton) object to the value of the &quot;source&quot; property of the event.</source>
          <target state="translated">&lt;code&gt;EventHandler&lt;/code&gt; 의 다음으로 가장 간단한 용도 는 리스너 인터페이스에서 메소드의 첫 번째 인수 (일반적으로 이벤트 오브젝트)에서 특성 값을 추출하고이를 사용하여 대상 오브젝트에서 특성 값을 설정하는 것입니다. 다음 예제 에서는 대상 (myButton) 객체 의 &lt;code&gt;nextFocusableComponent&lt;/code&gt; 속성을 이벤트의 &quot;source&quot;속성 값으로 설정 하는 &lt;code&gt;ActionListener&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3823007117061ff42c1e7a6b40c6d8a19f34ccd0" translate="yes" xml:space="preserve">
          <source>The next time paint is invoked on the viewport, if the clip region is smaller than the viewport size a timer is kicked off to repaint the whole region.</source>
          <target state="translated">다음에 뷰포트에서 페인트를 호출 할 때 클립 영역이 뷰포트 크기보다 작 으면 타이머가 시작되어 전체 영역을 다시 페인트합니다.</target>
        </trans-unit>
        <trans-unit id="f9a2faf9fb3b9f8ae2040c7c4e5d190ce7ecc0af" translate="yes" xml:space="preserve">
          <source>The next type of ID are offset-style IDs with some form of prefix, such as 'GMT+2' or 'UTC+01:00'. The recognised prefixes are 'UTC', 'GMT' and 'UT'. The offset is the suffix and will be normalized during creation. These IDs can be normalized to a &lt;code&gt;ZoneOffset&lt;/code&gt; using &lt;code&gt;normalized()&lt;/code&gt;.</source>
          <target state="translated">다음 유형의 ID는 'GMT + 2'또는 'UTC + 01 : 00'과 같은 접두사 형식의 오프셋 스타일 ID입니다. 인식되는 접두사는 'UTC', 'GMT'및 'UT'입니다. 오프셋은 접미사이며 작성 중에 정규화됩니다. 이 ID는 &lt;code&gt;normalized()&lt;/code&gt; 사용하여 &lt;code&gt;ZoneOffset&lt;/code&gt; 으로 정규화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86e912d40d864957a142854d170c406757cb0414" translate="yes" xml:space="preserve">
          <source>The node added.</source>
          <target state="translated">노드가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e44f1d28b1ed0c6128cf75964dda2af57cb4bc43" translate="yes" xml:space="preserve">
          <source>The node at the &lt;code&gt;index&lt;/code&gt;th position in the &lt;code&gt;NodeList&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if that is not a valid index.</source>
          <target state="translated">상기 노드 &lt;code&gt;index&lt;/code&gt; 번째 위치에서 상기 &lt;code&gt;NodeList&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 인덱스가 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="8f08767eb41800bbfbde9bbe5607f86187a21279" translate="yes" xml:space="preserve">
          <source>The node at the &lt;code&gt;index&lt;/code&gt;th position in the map, or &lt;code&gt;null&lt;/code&gt; if that is not a valid index.</source>
          <target state="translated">맵에서 &lt;code&gt;index&lt;/code&gt; 번째 위치 의 노드 또는 유효한 색인이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="25dcefb2a69d40c85715032a38d4c765b6ad7ec0" translate="yes" xml:space="preserve">
          <source>The node at which the &lt;code&gt;TreeWalker&lt;/code&gt; is currently positioned.</source>
          <target state="translated">&lt;code&gt;TreeWalker&lt;/code&gt; 가 현재 위치 하는 노드 입니다.</target>
        </trans-unit>
        <trans-unit id="25c2494a9062b0a4fec44eb9e5d8f2a5f7bf6cf4" translate="yes" xml:space="preserve">
          <source>The node being inserted.</source>
          <target state="translated">삽입되는 노드입니다.</target>
        </trans-unit>
        <trans-unit id="eefd68869134b5c6003f67d668b41f50e9088f4b" translate="yes" xml:space="preserve">
          <source>The node contains the reference node.</source>
          <target state="translated">노드에는 참조 노드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="926d4c6c5c9641e6784d6df9d9121f96b518e1d8" translate="yes" xml:space="preserve">
          <source>The node contains the reference node. A node which contains is always preceding, too.</source>
          <target state="translated">노드에는 참조 노드가 포함됩니다. 포함하는 노드도 항상 선행합니다.</target>
        </trans-unit>
        <trans-unit id="72cdab6fabcb4973b8730812adba18d5fc92d324" translate="yes" xml:space="preserve">
          <source>The node follows the reference node.</source>
          <target state="translated">노드는 참조 노드를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="5a40a86d7ba4c3fbae277f67eaa1edd72c64dac0" translate="yes" xml:space="preserve">
          <source>The node immediately following this node.</source>
          <target state="translated">이 노드 바로 다음 노드입니다.</target>
        </trans-unit>
        <trans-unit id="70e1299d21c7e340ff3f7d3d35f755d09b6b0a68" translate="yes" xml:space="preserve">
          <source>The node immediately following this node. If there is no such node, this returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 노드 바로 다음 노드입니다. 그러한 노드가 없으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="688be01f5e712790a2f07c91bccb3e81dc55084a" translate="yes" xml:space="preserve">
          <source>The node immediately preceding this node.</source>
          <target state="translated">The node immediately preceding this node.</target>
        </trans-unit>
        <trans-unit id="489a2f7876809d76036f44c18b0a6878267c599e" translate="yes" xml:space="preserve">
          <source>The node immediately preceding this node. If there is no such node, this returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">The node immediately preceding this node. If there is no such node, this returns &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d88a4ea137aa25d2bcdb9f0d29337d00d2719f5" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;CDATASection&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;CDATASection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3992c5decf9ee81e9249173454da0089170acc0c" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;Comment&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;Comment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cfa4ce440134eec7d17e729483d88d0752609d0" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;Document&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;Document&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1253bf6ce5e8d87245eb71c8e7995f7e9d2713a" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;DocumentFragment&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;DocumentFragment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="104e203c7a3beb38e0173d43a12cd8263e1662ab" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;DocumentType&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;DocumentType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c43db55ccab03c274adc3665d5d207f1c987613b" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;Namespace&lt;/code&gt;.</source>
          <target state="translated">노드는 &lt;code&gt;Namespace&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="70799baaed087daa78146fe3d2c82c5e97d198f8" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;Notation&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;Notation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6959c6bb576b424cf20edc90de27e85139e0b7d6" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;ProcessingInstruction&lt;/code&gt;.</source>
          <target state="translated">The node is a &lt;code&gt;ProcessingInstruction&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82181fc9a25ccdbbaa459ae8ffabba3c6b011e07" translate="yes" xml:space="preserve">
          <source>The node is a &lt;code&gt;Text&lt;/code&gt; node.</source>
          <target state="translated">The node is a &lt;code&gt;Text&lt;/code&gt; node.</target>
        </trans-unit>
        <trans-unit id="a4f1fdcd6851b1862447156d36f1a8064edcbdef" translate="yes" xml:space="preserve">
          <source>The node is adopted, using &lt;code&gt;Document.adoptNode()&lt;/code&gt;.</source>
          <target state="translated">The node is adopted, using &lt;code&gt;Document.adoptNode()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="652436729df0bb208fdc046aefbfa457dcae47c3" translate="yes" xml:space="preserve">
          <source>The node is an &lt;code&gt;Attr&lt;/code&gt;.</source>
          <target state="translated">The node is an &lt;code&gt;Attr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e118daebecbe6e623fcaf62887ad574669481e6b" translate="yes" xml:space="preserve">
          <source>The node is an &lt;code&gt;Element&lt;/code&gt;.</source>
          <target state="translated">The node is an &lt;code&gt;Element&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d8a8c8365746d5f22ab7e728d5b9e9461515cb7" translate="yes" xml:space="preserve">
          <source>The node is an &lt;code&gt;Entity&lt;/code&gt;.</source>
          <target state="translated">The node is an &lt;code&gt;Entity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c777aafc5adf73466ca4dc068f72c31fa299122" translate="yes" xml:space="preserve">
          <source>The node is an &lt;code&gt;EntityReference&lt;/code&gt;.</source>
          <target state="translated">The node is an &lt;code&gt;EntityReference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31d528f4cb617d25ed6bf587586d2e01a3d6d2b4" translate="yes" xml:space="preserve">
          <source>The node is cloned, using &lt;code&gt;Node.cloneNode()&lt;/code&gt;.</source>
          <target state="translated">The node is cloned, using &lt;code&gt;Node.cloneNode()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b94cbc6b4a584d6bdaedb2ccd9ce9afc37897036" translate="yes" xml:space="preserve">
          <source>The node is contained by the reference node.</source>
          <target state="translated">The node is contained by the reference node.</target>
        </trans-unit>
        <trans-unit id="d6ece946ea02ee3d159660f34819134d355f68bc" translate="yes" xml:space="preserve">
          <source>The node is contained by the reference node. A node which is contained is always following, too.</source>
          <target state="translated">The node is contained by the reference node. A node which is contained is always following, too.</target>
        </trans-unit>
        <trans-unit id="e47a628abe4bcb510d76413db50a34ada4a36683" translate="yes" xml:space="preserve">
          <source>The node is deleted.</source>
          <target state="translated">The node is deleted.</target>
        </trans-unit>
        <trans-unit id="83672ddfbdbb04e6267923061fcdb494f10ed227" translate="yes" xml:space="preserve">
          <source>The node is imported, using &lt;code&gt;Document.importNode()&lt;/code&gt;.</source>
          <target state="translated">The node is imported, using &lt;code&gt;Document.importNode()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be958ab1a3a5b153c7e4bd485baa0f017b8a0164" translate="yes" xml:space="preserve">
          <source>The node is renamed, using &lt;code&gt;Document.renameNode()&lt;/code&gt;.</source>
          <target state="translated">The node is renamed, using &lt;code&gt;Document.renameNode()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04e411af71a3a83badf3b4023e66910b22ac252a" translate="yes" xml:space="preserve">
          <source>The node removed from this map if a node with such a local name and namespace URI exists.</source>
          <target state="translated">The node removed from this map if a node with such a local name and namespace URI exists.</target>
        </trans-unit>
        <trans-unit id="b661946dd93bda0e46530c86097ef476c83f10f5" translate="yes" xml:space="preserve">
          <source>The node removed from this map if a node with such a name exists.</source>
          <target state="translated">The node removed from this map if a node with such a name exists.</target>
        </trans-unit>
        <trans-unit id="e4ac372935e647fb4df00b130e6084b54ef6b1be" translate="yes" xml:space="preserve">
          <source>The node removed.</source>
          <target state="translated">The node removed.</target>
        </trans-unit>
        <trans-unit id="4bc33794277995ad7b77021ec5435f72d849a19b" translate="yes" xml:space="preserve">
          <source>The node replaced.</source>
          <target state="translated">The node replaced.</target>
        </trans-unit>
        <trans-unit id="007df73ce0d9720fbd1e06f547bec4ea1ba835a2" translate="yes" xml:space="preserve">
          <source>The node that associates this style sheet with the document.</source>
          <target state="translated">이 스타일 시트를 문서와 연관시키는 노드입니다.</target>
        </trans-unit>
        <trans-unit id="4cf53e554b4a5482b427fcf2998c91fe0e55cb8a" translate="yes" xml:space="preserve">
          <source>The node that associates this style sheet with the document. For HTML, this may be the corresponding &lt;code&gt;LINK&lt;/code&gt; or &lt;code&gt;STYLE&lt;/code&gt; element. For XML, it may be the linking processing instruction. For style sheets that are included by other style sheets, the value of this attribute is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 스타일 시트를 문서와 연관시키는 노드입니다. HTML의 경우 해당하는 &lt;code&gt;LINK&lt;/code&gt; 또는 &lt;code&gt;STYLE&lt;/code&gt; 요소 일 수 있습니다. XML의 경우 연결 처리 명령 일 수 있습니다. 다른 스타일 시트에 포함 된 스타일 시트의 경우이 속성 값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7572680b2b80e8ffbe2e43845817ff3163683c09" translate="yes" xml:space="preserve">
          <source>The node that is the location for the event.</source>
          <target state="translated">The node that is the location for the event.</target>
        </trans-unit>
        <trans-unit id="e6c54c2549b66a4b21ce4b74222cef22b07b4422" translate="yes" xml:space="preserve">
          <source>The node that is to be transformed.</source>
          <target state="translated">The node that is to be transformed.</target>
        </trans-unit>
        <trans-unit id="2244b9f1c988f6ab45e1adc3aeaad05d28dd975b" translate="yes" xml:space="preserve">
          <source>The node that was added or removed.</source>
          <target state="translated">추가 또는 제거 된 노드입니다.</target>
        </trans-unit>
        <trans-unit id="ed73ee97c8cd24a6296d058a31d1ef9c51cf1abe" translate="yes" xml:space="preserve">
          <source>The node this locator is pointing to, or &lt;code&gt;null&lt;/code&gt; if no node is available.</source>
          <target state="translated">The node this locator is pointing to, or &lt;code&gt;null&lt;/code&gt; if no node is available.</target>
        </trans-unit>
        <trans-unit id="6d6f08034b2207c569504846755de13d16de0411" translate="yes" xml:space="preserve">
          <source>The node to which the transformation will be appended.</source>
          <target state="translated">The node to which the transformation will be appended.</target>
        </trans-unit>
        <trans-unit id="4c914679c177f8361a70044b7d9e5fed26293161" translate="yes" xml:space="preserve">
          <source>The node value associated with this UUID.</source>
          <target state="translated">이 UUID와 연관된 노드 값입니다.</target>
        </trans-unit>
        <trans-unit id="5bbeb5b168502d18da4f1fe9867711841ff15466" translate="yes" xml:space="preserve">
          <source>The node value is only meaningful in a time-based UUID, which has version type 1. If this UUID is not a time-based UUID then this method throws UnsupportedOperationException.</source>
          <target state="translated">노드 값은 버전 유형이 1 인 시간 기반 UUID에서만 의미가 있습니다.이 UUID가 시간 기반 UUID가 아닌 경우이 메소드는 UnsupportedOperationException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b2c083ad90bd1defea28a63436df660a7fd1208e" translate="yes" xml:space="preserve">
          <source>The node value of this &lt;code&gt;UUID&lt;/code&gt;</source>
          <target state="translated">이 &lt;code&gt;UUID&lt;/code&gt; 의 노드 치</target>
        </trans-unit>
        <trans-unit id="9083087196b5f8357ba2ae34b61b87d8cf605eab" translate="yes" xml:space="preserve">
          <source>The nominal form of an instance of a constable type is obtained via &lt;a href=&quot;#describeConstable()&quot;&gt;&lt;code&gt;describeConstable()&lt;/code&gt;&lt;/a&gt;. A &lt;a href=&quot;constable&quot;&gt;Constable&lt;/a&gt; need not be able to (or may choose not to) describe all its instances in the form of a &lt;a href=&quot;constantdesc&quot;&gt;&lt;code&gt;ConstantDesc&lt;/code&gt;&lt;/a&gt;; this method returns an &lt;a href=&quot;../../util/optional&quot;&gt;&lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt; that can be empty to indicate that a nominal descriptor could not be created for an instance. (For example, &lt;a href=&quot;../invoke/methodhandle&quot;&gt;&lt;code&gt;MethodHandle&lt;/code&gt;&lt;/a&gt; will produce nominal descriptors for direct method handles, but not necessarily those produced by method handle combinators.)</source>
          <target state="translated">constable 유형 인스턴스의 명목 형식은 &lt;a href=&quot;#describeConstable()&quot;&gt; &lt;code&gt;describeConstable()&lt;/code&gt; &lt;/a&gt; 통해 얻습니다 . &lt;a href=&quot;constable&quot;&gt;경호&lt;/a&gt; 필요로 할 수 (또는하지 않도록 선택할 수 있음)의 형태로 모든 인스턴스를 설명하지 &lt;a href=&quot;constantdesc&quot;&gt; &lt;code&gt;ConstantDesc&lt;/code&gt; &lt;/a&gt; ; 이 메서드는 인스턴스에 대한 명목 설명자를 만들 수 없음을 나타 내기 위해 비어있을 수있는 &lt;a href=&quot;../../util/optional&quot;&gt; &lt;code&gt;Optional&lt;/code&gt; &lt;/a&gt; 을 반환 합니다. (예를 들어, &lt;a href=&quot;../invoke/methodhandle&quot;&gt; &lt;code&gt;MethodHandle&lt;/code&gt; &lt;/a&gt; 은 직접 메서드 핸들에 대한 명목 설명자를 생성하지만 반드시 메서드 핸들 결합 자에 의해 생성되는 것은 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="116e08dc3c5462998592161ec4267b36074a602d" translate="yes" xml:space="preserve">
          <source>The non-&lt;code&gt;void&lt;/code&gt; result from a step function call is used to update the corresponding value in the sequence &lt;code&gt;(v...)&lt;/code&gt; of loop variables. The updated value is immediately visible to all subsequent function calls.</source>
          <target state="translated">The non- &lt;code&gt;void&lt;/code&gt; result from a step function call is used to update the corresponding value in the sequence &lt;code&gt;(v...)&lt;/code&gt; of loop variables. The updated value is immediately visible to all subsequent function calls.</target>
        </trans-unit>
        <trans-unit id="b799d392c13f57a4244dc8cc1be985c89795fd60" translate="yes" xml:space="preserve">
          <source>The non-baseline tags included in this class are:</source>
          <target state="translated">The non-baseline tags included in this class are:</target>
        </trans-unit>
        <trans-unit id="dbb6f21cdd21b51f043b1d7e9cd850253fc91842" translate="yes" xml:space="preserve">
          <source>The non-baseline values of baseline tags included in this class are</source>
          <target state="translated">The non-baseline values of baseline tags included in this class are</target>
        </trans-unit>
        <trans-unit id="abbf56635d9b1770e8f377f88d7eb5625296e6d7" translate="yes" xml:space="preserve">
          <source>The non-negative number of components in this LDAP name.</source>
          <target state="translated">이 LDAP 이름에서 음수가 아닌 수의 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="0ec6632ce3dac4952c6d1e6de9a5a4ac96bd4964" translate="yes" xml:space="preserve">
          <source>The non-negative number of type/value pairs in this Rdn.</source>
          <target state="translated">이 Rdn에서 음수가 아닌 유형 / 값 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="04c40e79aa1d2b145632c16a6ba96e3ddd6f6561" translate="yes" xml:space="preserve">
          <source>The non-null &lt;code&gt;EventContext&lt;/code&gt; that fired this event.</source>
          <target state="translated">이 이벤트를 발생시킨 null 이외의 &lt;code&gt;EventContext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9835e454d9aa1da3cda1a5d111588c0dd9c03234" translate="yes" xml:space="preserve">
          <source>The non-null Attribute ID of the sort key.</source>
          <target state="translated">정렬 키의 널이 아닌 속성 ID.</target>
        </trans-unit>
        <trans-unit id="72f787f2a198f8fedf6cb84c6fe0b5e362381096" translate="yes" xml:space="preserve">
          <source>The non-null RDN at index posn.</source>
          <target state="translated">인덱스 위치에서 널이 아닌 RDN입니다.</target>
        </trans-unit>
        <trans-unit id="e27f3c4b638ce7540d85488b7dcdab9e1e5afc40" translate="yes" xml:space="preserve">
          <source>The non-null Reference of this object.</source>
          <target state="translated">이 객체의 null 이외의 Reference</target>
        </trans-unit>
        <trans-unit id="3a820348b05a92e3255fb97f0c53e3ffddc88be6" translate="yes" xml:space="preserve">
          <source>The non-null address type of this address.</source>
          <target state="translated">이 주소의 널이 아닌 주소 유형.</target>
        </trans-unit>
        <trans-unit id="981d279effb28301c8fb24760d756c4ff54dba76" translate="yes" xml:space="preserve">
          <source>The non-null array of X.509 public-key certificates.</source>
          <target state="translated">Null이 아닌 X.509 공개 키 인증서 배열입니다.</target>
        </trans-unit>
        <trans-unit id="1b2a6e4ec9d45a99cb8a8a065afc3d03e2188058" translate="yes" xml:space="preserve">
          <source>The non-null array of signature bytes.</source>
          <target state="translated">Null이 아닌 서명 바이트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="d2201b95b88b6f901440dc4bbfb1317bf8e7ee42" translate="yes" xml:space="preserve">
          <source>The non-null attribute to use for the modification.</source>
          <target state="translated">수정에 사용할 널이 아닌 속성입니다.</target>
        </trans-unit>
        <trans-unit id="c9313ebf57ec9424f831b52f67bbfc348328c4ee" translate="yes" xml:space="preserve">
          <source>The non-null attribute type.</source>
          <target state="translated">널이 아닌 속성 유형.</target>
        </trans-unit>
        <trans-unit id="e8b69252e6ee01638d108902e5793b76660660f5" translate="yes" xml:space="preserve">
          <source>The non-null attribute value.</source>
          <target state="translated">널이 아닌 속성 값.</target>
        </trans-unit>
        <trans-unit id="2715e88a065e5152070b841d877e00fdf01a9b7e" translate="yes" xml:space="preserve">
          <source>The non-null attributes containing the type/value mappings of this Rdn.</source>
          <target state="translated">이 Rdn의 형태 / 치의 매핑을 포함한 null 이외의 속성</target>
        </trans-unit>
        <trans-unit id="e7d5ad9946b78e64d8017c4154edc754f5fde616" translate="yes" xml:space="preserve">
          <source>The non-null attributes in this search result. Can be empty.</source>
          <target state="translated">이 검색 결과의 널이 아닌 속성입니다. 비워 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e85cdf81db9eeec068d8d09a8ef2fb4c407fd0" translate="yes" xml:space="preserve">
          <source>The non-null buffer containing this address's contents.</source>
          <target state="translated">이 주소의 내용을 포함한 null 이외의 버퍼</target>
        </trans-unit>
        <trans-unit id="3d9f08aa3696853e49ea210dd84b71a816664327" translate="yes" xml:space="preserve">
          <source>The non-null cached initial context.</source>
          <target state="translated">널이 아닌 캐시 된 초기 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="ff3c6126fdf1cc140a98a5cb1cbb91b07b9dae34" translate="yes" xml:space="preserve">
          <source>The non-null component at index posn.</source>
          <target state="translated">인덱스 위치에서 널이 아닌 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="a0cd8693286f7ab03bf8dfc7ae7e3825ff062d8e" translate="yes" xml:space="preserve">
          <source>The non-null context at which to continue the method.</source>
          <target state="translated">메소드를 계속할 널이 아닌 컨텍스트.</target>
        </trans-unit>
        <trans-unit id="d451c4f1e3abd2fc769f4b6cdd808b41cafdf4b1" translate="yes" xml:space="preserve">
          <source>The non-null context that fired this event.</source>
          <target state="translated">이 이벤트를 발생시킨 null 이외의 컨텍스트</target>
        </trans-unit>
        <trans-unit id="6ccd0c9d630cefab9c9188537f5d448330d7fbd1" translate="yes" xml:space="preserve">
          <source>The non-null fully-qualified class name of the object. (e.g. &quot;java.lang.String&quot;)</source>
          <target state="translated">객체의 null이 아닌 정규화 된 클래스 이름입니다. (예 : &quot;java.lang.String&quot;)</target>
        </trans-unit>
        <trans-unit id="55a9d1f6cd92ef1fb0cc4c11ee02219bb6a9c640" translate="yes" xml:space="preserve">
          <source>The non-null name of this binding.</source>
          <target state="translated">이 바인딩의 null 이외의 이름</target>
        </trans-unit>
        <trans-unit id="379e7340b01855217e56feddfd0c3f522ce31421" translate="yes" xml:space="preserve">
          <source>The non-null name of this link.</source>
          <target state="translated">이 링크의 null 이외의 이름</target>
        </trans-unit>
        <trans-unit id="42b9a5b2a8d6c68424fd72083172c212655d9589" translate="yes" xml:space="preserve">
          <source>The non-null object identifier string representing the LDAP &lt;code&gt;ExtendedRequest.requestName&lt;/code&gt; component.</source>
          <target state="translated">LDAP &lt;code&gt;ExtendedRequest.requestName&lt;/code&gt; 구성 요소를 나타내는 널이 아닌 오브젝트 ID 문자열 .</target>
        </trans-unit>
        <trans-unit id="2cb882abf23a7aa368fb5faa23b533a76c55bbc5" translate="yes" xml:space="preserve">
          <source>The non-null object identifier string.</source>
          <target state="translated">널이 아닌 오브젝트 ID 문자열.</target>
        </trans-unit>
        <trans-unit id="b295dc0fd888ea6d48259db4af3e90633d18ef36" translate="yes" xml:space="preserve">
          <source>The non-null object representing &lt;code&gt;obj&lt;/code&gt;'s state for binding. It could be the object (&lt;code&gt;obj&lt;/code&gt;) itself.</source>
          <target state="translated">바인딩의 &lt;code&gt;obj&lt;/code&gt; 상태를 나타내는 null 이외의 객체 객체 ( &lt;code&gt;obj&lt;/code&gt; ) 자체 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f69773c16095a881d10252c9218f6c6e3c34b88" translate="yes" xml:space="preserve">
          <source>The non-null string containing the string representation of this exception.</source>
          <target state="translated">이 예외의 캐릭터 라인 표현을 포함한 null 이외의 캐릭터 라인</target>
        </trans-unit>
        <trans-unit id="44e96a35fa5e2445cf72315bf35956f839cecc36" translate="yes" xml:space="preserve">
          <source>The non-null string containing the string representation.</source>
          <target state="translated">문자열 표현을 포함하는 널이 아닌 문자열.</target>
        </trans-unit>
        <trans-unit id="14770ada04aa52b33da43484d775da2d31012e32" translate="yes" xml:space="preserve">
          <source>The non-null string name of the signature algorithm.</source>
          <target state="translated">서명 알고리즘의 널이 아닌 문자열 이름입니다.</target>
        </trans-unit>
        <trans-unit id="25555b5a8e89ed1aa36bc9391297251618d88661" translate="yes" xml:space="preserve">
          <source>The non-null string of the message digest algorithm name.</source>
          <target state="translated">메시지 다이제스트 알고리즘 이름의 널이 아닌 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b5944a034b359b83174f56a2a7f96839e7b38494" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this address.</source>
          <target state="translated">이 주소의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="c14b6c44d0bf24b5cea45b3da8630bae20b53ad4" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this attribute.</source>
          <target state="translated">이 속성의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="e489b76b389ad519e5854a5f41ece2a22837acbc" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this binding.</source>
          <target state="translated">이 바인딩의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="5bd52f1e3944566dde82d6b472de7f01b46708e3" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this exception.</source>
          <target state="translated">이 예외의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="42db8fc25d73e560ebf5468300a8bc2116164162" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this link exception.</source>
          <target state="translated">이 링크 예외의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="514dc42a6376eec82b1d1ca24105735005dbb207" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this modification item.</source>
          <target state="translated">이 수정 아이템의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="c944d1dbf9885fa579e084db281b25ba8d8a9512" translate="yes" xml:space="preserve">
          <source>The non-null string representation of this reference.</source>
          <target state="translated">이 참조의 null 이외의 캐릭터 라인 표현</target>
        </trans-unit>
        <trans-unit id="f67fe15778905975a7fa5a2327a8581b53a9f83e" translate="yes" xml:space="preserve">
          <source>The non-null unsolicited notification that caused this event to be fired.</source>
          <target state="translated">이 이벤트를 발생시키는 널이 아닌 원치 않는 알림입니다.</target>
        </trans-unit>
        <trans-unit id="d47f97097499b7920b445b44552f3b93fe502268" translate="yes" xml:space="preserve">
          <source>The nonnegative number of addresses in this reference.</source>
          <target state="translated">이 참조에서 음수가 아닌 주소 수입니다.</target>
        </trans-unit>
        <trans-unit id="763b0638d66b2e279fdcda534bfb0307f9e14a5c" translate="yes" xml:space="preserve">
          <source>The nonnegative number of attributes in this attribute set.</source>
          <target state="translated">이 속성 세트의 음수가 아닌 속성 수입니다.</target>
        </trans-unit>
        <trans-unit id="27a92262272f2e066164e4797757c92e88b495a7" translate="yes" xml:space="preserve">
          <source>The nonnegative number of components in this composite name.</source>
          <target state="translated">이 컴퍼 짓 이름의 음수가 아닌 수의 컴포넌트.</target>
        </trans-unit>
        <trans-unit id="2ae208f4c4b22b7904207d628361c77d6ba61f42" translate="yes" xml:space="preserve">
          <source>The nonnegative number of components in this compound name.</source>
          <target state="translated">이 화합물 명의 음수가 아닌 수의 성분.</target>
        </trans-unit>
        <trans-unit id="933031459aff054e43a842b4fd2dd5ed57b4a079" translate="yes" xml:space="preserve">
          <source>The nonnegative number of values in this attribute.</source>
          <target state="translated">이 속성의 음수가 아닌 값 수입니다.</target>
        </trans-unit>
        <trans-unit id="f552faffb0355ddf1b05a015bb7baf11154da3d5" translate="yes" xml:space="preserve">
          <source>The normal argument conversion rules for &lt;code&gt;MethodHandle.invoke&lt;/code&gt; apply to all stacked arguments. For example, if a pushed value is a primitive type, it may be converted to a reference by boxing conversion. If the bootstrap method is a variable arity method (its modifier bit &lt;code&gt;0x0080&lt;/code&gt; is set), then some or all of the arguments specified here may be collected into a trailing array parameter. (This is not a special rule, but rather a useful consequence of the interaction between &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; constants, the modifier bit for variable arity methods, and the &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt;&lt;code&gt;asVarargsCollector&lt;/code&gt;&lt;/a&gt; transformation.)</source>
          <target state="translated">&lt;code&gt;MethodHandle.invoke&lt;/code&gt; 의 일반 인수 변환 규칙은 모든 누적 인수에 적용됩니다. 예를 들어, 푸시 된 값이 기본 유형 인 경우 복싱 변환을 통해 참조로 변환 될 수 있습니다. 부트 스트랩 방법이 가변 arity 방법 인 경우 (수정 자 비트 &lt;code&gt;0x0080&lt;/code&gt; 이 설정 됨) 여기에 지정된 인수 중 일부 또는 전부가 후행 배열 매개 변수로 수집 될 수 있습니다. (이것은 특별한 규칙이 아니라 &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; 상수, 변수 arity 메소드의 수정 자 비트 및 &lt;a href=&quot;methodhandle#asVarargsCollector-java.lang.Class-&quot;&gt; &lt;code&gt;asVarargsCollector&lt;/code&gt; &lt;/a&gt; 변환 간의 상호 작용으로 인한 유용한 결과입니다 .)</target>
        </trans-unit>
        <trans-unit id="92e831571304f766e53b7678f2c8bc953d39e95a" translate="yes" xml:space="preserve">
          <source>The normal use of the &quot;privileged&quot; feature is as follows. If you don't need to return a value from within the &quot;privileged&quot; block, do the following:</source>
          <target state="translated">&quot;권한있는&quot;기능의 일반적인 사용법은 다음과 같습니다. &quot;privileged&quot;블록 내에서 값을 반환 할 필요가 없으면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1713b6c492038d81b6717f471a6bc21770c3edef" translate="yes" xml:space="preserve">
          <source>The normalization checks if the rules of this &lt;code&gt;ZoneId&lt;/code&gt; have a fixed offset. If they do, then the &lt;code&gt;ZoneOffset&lt;/code&gt; equal to that offset is returned. Otherwise &lt;code&gt;this&lt;/code&gt; is returned.</source>
          <target state="translated">정규화는이 &lt;code&gt;ZoneId&lt;/code&gt; 의 규칙에 고정 오프셋 이 있는지 확인합니다 . 그렇게 하면 해당 오프셋과 같은 &lt;code&gt;ZoneOffset&lt;/code&gt; 이 반환됩니다. 그렇지 않으면 &lt;code&gt;this&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e2cd0ae79d9cf181d6f2f03a35a1f43855bdc7fd" translate="yes" xml:space="preserve">
          <source>The normalized String</source>
          <target state="translated">정규화 된 문자열</target>
        </trans-unit>
        <trans-unit id="1b1f85af4c6b9e902075539bd21a4b792674f3bd" translate="yes" xml:space="preserve">
          <source>The normative value constraint stated relative to month field's value is in &lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D&lt;/a&gt;.</source>
          <target state="translated">The normative value constraint stated relative to month field's value is in &lt;a href=&quot;http://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2030261f3c87151457bf4c1a86a431b91a19ae8a" translate="yes" xml:space="preserve">
          <source>The normative value constraint stated relative to month field's value is in &lt;a href=&quot;https://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D&lt;/a&gt;.</source>
          <target state="translated">월 필드의 값과 관련된 표준 값 제약은 &lt;a href=&quot;https://www.w3.org/TR/xmlschema-2/#isoformats&quot;&gt;W3C XML Schema 1.0 Part 2, Appendix D에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="4221fe7c43b2be1f1fe74901de3af60a78573671" translate="yes" xml:space="preserve">
          <source>The north layout constraint (top of container).</source>
          <target state="translated">The north layout constraint (top of container).</target>
        </trans-unit>
        <trans-unit id="c780ad14e7504360c8fafa2a94843c0740f74099" translate="yes" xml:space="preserve">
          <source>The north-east-resize cursor type.</source>
          <target state="translated">The north-east-resize cursor type.</target>
        </trans-unit>
        <trans-unit id="239d8e4a2f499ca8854b5485f8b1ea607325532b" translate="yes" xml:space="preserve">
          <source>The north-resize cursor type.</source>
          <target state="translated">The north-resize cursor type.</target>
        </trans-unit>
        <trans-unit id="2977eceb5994e17fa1f7c0dfe7bf3a323d5dcca6" translate="yes" xml:space="preserve">
          <source>The north-west-resize cursor type.</source>
          <target state="translated">The north-west-resize cursor type.</target>
        </trans-unit>
        <trans-unit id="22d006471ccb7e48bf28b33ef811fdaa4f31ba30" translate="yes" xml:space="preserve">
          <source>The notation name.</source>
          <target state="translated">The notation name.</target>
        </trans-unit>
        <trans-unit id="46f4f42f6b54d68a6627b5ec7f9323ab37bbc2ac" translate="yes" xml:space="preserve">
          <source>The notation's public identifier, or null if none was given.</source>
          <target state="translated">The notation's public identifier, or null if none was given.</target>
        </trans-unit>
        <trans-unit id="c0a171fe5edbbdcd09395d7988a9b4e98a3f2976" translate="yes" xml:space="preserve">
          <source>The notation's system identifier, or null if none was given.</source>
          <target state="translated">The notation's system identifier, or null if none was given.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
