<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="3b3629e1c7a434db3fa94e4624595c63c91c3763" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">다른 스레드가 잠금을 보유한 경우 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하게되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="bc3fb57c41848bc377b297ddabc5e3ff9216fa1a" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">다른 스레드가 잠금을 보유한 경우 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="9a8c566c06708381b95a076b6d0a7ff9c3dd5f9a" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one.</source>
          <target state="translated">다른 스레드가 잠금을 보유한 경우 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 잠금이 확보 될 때까지 휴면 상태가되어 잠금 보유 계수가 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d853278a5b45d2ebee3420faecb6ce65095ece12" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the write lock has been acquired, at which time the write lock hold count is set to one.</source>
          <target state="translated">잠금이 다른 스레드에 의해 유지되면 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 쓰기 잠금이 확보 될 때까지 휴면 상태가되며,이 때 쓰기 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="918d784e15001f2097233989116a220695ba3605" translate="yes" xml:space="preserve">
          <source>If the lock is held by another thread then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">다른 thread에 의해 락이 보관 유지되고있는 경우,이 메소드는 값을 &lt;code&gt;false&lt;/code&gt; 로 즉시 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="85233bd93c41bf81d5bd16d44009dd4101f01d92" translate="yes" xml:space="preserve">
          <source>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">잠금을 사용할 수없는 경우 현재 스레드는 스레드 스케줄링을 위해 비활성화되며 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="2fcde55af63c37dc1d170326de90648dbad927ec" translate="yes" xml:space="preserve">
          <source>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired.</source>
          <target state="translated">잠금을 사용할 수없는 경우 현재 스레드는 스레드 스케줄링 목적으로 사용 불가능하게되고 잠금을 획득 할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="98452bdc04ba24a75162b80592faf24a66256700" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp then, atomically, if the stamp represents holding a lock, releases it and returns an observation stamp.</source>
          <target state="translated">잠금 상태가 주어진 스탬프와 일치하면 원자 적으로 스탬프가 잠금을 유지하고 있음을 나타내면 잠금을 해제하고 관찰 스탬프를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9531444c267d5feba915ddbb6e8e98d082819147" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp then, atomically, if the stamp represents holding a lock, releases it and returns an observation stamp. Or, if an optimistic read, returns it if validated. This method returns zero in all other cases, and so may be useful as a form of &quot;tryUnlock&quot;.</source>
          <target state="translated">잠금 상태가 주어진 스탬프와 일치하면 원자 적으로 스탬프가 잠금을 유지하고 있음을 나타내면 잠금을 해제하고 관찰 스탬프를 반환합니다. 또는 낙관적 읽기 인 경우 유효성이 확인되면 반환합니다. 이 메서드는 다른 모든 경우에 0을 반환하므로 &quot;tryUnlock&quot;형식으로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a09e194cce7b274be7295eeba5f7cce4ea171773" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp then, if the stamp represents holding a lock, releases it and returns an observation stamp. Or, if an optimistic read, returns it if validated. This method returns zero in all other cases, and so may be useful as a form of &quot;tryUnlock&quot;.</source>
          <target state="translated">잠금 상태가 주어진 스탬프와 일치하면 스탬프가 잠금 유지를 나타내는 경우 잠금을 해제하고 관찰 스탬프를 반환합니다. 또는 낙관적 읽기 인 경우 유효성이 검증 된 경우이를 읽습니다. 이 메소드는 다른 모든 경우에 0을 리턴하므로 &quot;tryUnlock&quot;의 양식으로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c02dbead9b54aba8193788d721d9f35fe265e8ac" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, atomically performs one of the following actions.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 다음 작업 중 하나를 원자 적으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c68f8e544ee0dc6483d80e98a4e234377462da50" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, atomically performs one of the following actions. If the stamp represents holding a write lock, releases it and obtains a read lock. Or, if a read lock, returns it. Or, if an optimistic read, acquires a read lock and returns a read stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 다음 작업 중 하나를 원자 적으로 수행합니다. 스탬프가 쓰기 잠금을 유지하고 있음을 나타내면이를 해제하고 읽기 잠금을 얻습니다. 또는 읽기 잠금 인 경우 반환합니다. 또는 낙관적 읽기 인 경우 읽기 잠금을 획득하고 즉시 사용 가능한 경우에만 읽기 스탬프를 반환합니다. 이 메서드는 다른 모든 경우에 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4406ed634a16a7a2fc6a312ac7fcd3088591c18" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, atomically performs one of the following actions. If the stamp represents holding a write lock, returns it. Or, if a read lock, if the write lock is available, releases the read lock and returns a write stamp. Or, if an optimistic read, returns a write stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 다음 작업 중 하나를 원자 적으로 수행합니다. 스탬프가 쓰기 잠금을 유지하고 있음을 나타내면 반환합니다. 또는 읽기 잠금이있는 경우 쓰기 잠금을 사용할 수있는 경우 읽기 잠금을 해제하고 쓰기 스탬프를 반환합니다. 또는 낙관적 읽기 인 경우 즉시 사용 가능한 경우에만 쓰기 스탬프를 반환합니다. 이 메서드는 다른 모든 경우에 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eefa68914d354c4eea9a7f9d2e87edb5b5d3616c" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, performs one of the following actions. If the stamp represents holding a write lock, releases it and obtains a read lock. Or, if a read lock, returns it. Or, if an optimistic read, acquires a read lock and returns a read stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 다음 조치 중 하나를 수행하십시오. 스탬프가 쓰기 잠금 보유를 나타내는 경우 해제하여 읽기 잠금을 얻습니다. 또는 읽기 잠금 인 경우이를 리턴합니다. 또는 낙관적 읽기 인 경우 읽기 잠금을 획득하고 즉시 사용 가능한 경우에만 읽기 스탬프를 반환합니다. 이 방법은 다른 모든 경우에 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3fe6cd5b7f1314dfe53912057e75419a458d6c46" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, performs one of the following actions. If the stamp represents holding a write lock, returns it. Or, if a read lock, if the write lock is available, releases the read lock and returns a write stamp. Or, if an optimistic read, returns a write stamp only if immediately available. This method returns zero in all other cases.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 다음 조치 중 하나를 수행하십시오. 스탬프가 쓰기 잠금 유지를 나타내는 경우 반환합니다. 또는 읽기 잠금 인 경우 쓰기 잠금이 사용 가능한 경우 읽기 잠금을 해제하고 쓰기 스탬프를 반환합니다. 또는 낙관적 읽기 인 경우 즉시 사용 가능한 경우에만 쓰기 스탬프를 반환합니다. 이 방법은 다른 모든 경우에 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="14a53c83eff403dc5c623bd9e147872ed3ff94fc" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the corresponding mode of the lock.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 해당 잠금 모드를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="3114f1897355cfbc96b7a2b2a9909376a9675347" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the exclusive lock.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 독점 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="4a3ebac76180e9eaa8e069fe7a9c0cce392315b8" translate="yes" xml:space="preserve">
          <source>If the lock state matches the given stamp, releases the non-exclusive lock.</source>
          <target state="translated">잠금 상태가 지정된 스탬프와 일치하면 비 독점 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="e004c7523986b5ecc4e1749a86febcd1a6784511" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the CONFIG message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 CONFIG 메시지 레벨에 대해 사용 가능한 경우 지정된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2480ae012f96dc55272b45f972094f52d29f7772" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the CONFIG message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 CONFIG 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f74f4184b1114d21694c20083bffeca6773ddbdc" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINE message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINE 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ef129fafed8fea9b1b19398062aeaf0403caccda" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINE message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINE 메시지 레벨에 대해 사용 가능한 경우, 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5c488b5e8261b0b9f6a94d2c335e06b774d3e4c2" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINER message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINER 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="400e0c53967d73d6073541aa2955ecfaedacc619" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINER message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINER 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c08c72ddfcb02350456ab868e8db332930e255e4" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINEST message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINEST 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="776e22483061c922dbf981169c45b199faadcb6b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the FINEST message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 FINEST 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0c3de4bfb7369cf5faf7dd1122bdabc955fddf2e" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the INFO message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 INFO 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b7c2334c2c90239d4c59ec8c7a0e4b1e0b78f35b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the INFO message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 INFO 메시지 레벨에 대해 사용 가능한 경우, 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ab7e0ed2e38d83c57cfc908b346ba953ba01ea6e" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the SEVERE message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 SEVERE 메시지 레벨에 대해 사용 가능한 경우, 주어진 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8e167659c676fd6a76d1a8ff361acf900cf2dee4" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the SEVERE message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 SEVERE 메시지 레벨에 대해 사용 가능한 경우, 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="700de6b174ae4293a822d7062908049e15243b9c" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the WARNING message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 WARNING 메시지 레벨에 대해 사용 가능한 경우 제공된 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8548b61ec8126b5ee81ca57df60b3e51531c5a8a" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the WARNING message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 WARNING 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지가 구성되고 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5a707ce3f0ebdced7855946db27b8b7e46bf0539" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message &lt;code&gt;level&lt;/code&gt; then a corresponding &lt;code&gt;LogRecord&lt;/code&gt; is created and forwarded to all the registered output &lt;code&gt;Handler&lt;/code&gt; objects.</source>
          <target state="translated">로거가 현재 주어진 메시지 &lt;code&gt;level&lt;/code&gt; 대해 활성화 된 경우 해당 &lt;code&gt;LogRecord&lt;/code&gt; 가 생성되어 등록 된 모든 출력 &lt;code&gt;Handler&lt;/code&gt; 전달됩니다. 객체로 .</target>
        </trans-unit>
        <trans-unit id="b378f215976c2e18ee9b57b56cfaa682e43ca7e1" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message &lt;code&gt;level&lt;/code&gt; then the given arguments are stored in a &lt;code&gt;LogRecord&lt;/code&gt; which is forwarded to all registered output handlers.</source>
          <target state="translated">로거가 현재 지정된 메시지 &lt;code&gt;level&lt;/code&gt; 대해 활성화되어있는 경우 지정된 인수는 등록 된 모든 출력 핸들러로 전달 되는 &lt;code&gt;LogRecord&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="2998fe288d20db38f6f02724d9a3e1e03f44693c" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then a corresponding LogRecord is created and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 해당 LogRecord가 작성되어 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5672874e662c52b70bec899dedf5a6f7d4107f79" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 제공된 인수는 LogRecord에 저장되며 등록 된 모든 출력 핸들러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0a20e1ab3ef4c4dda5575d5b6fbf96f00af911a8" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers. The LogRecord's message is set to &quot;THROW&quot;.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 제공된 인수는 LogRecord에 저장되며 등록 된 모든 출력 핸들러로 전달됩니다. LogRecord의 메시지가 &quot;THROW&quot;로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="325dfec7a72934c84f66843540d89c8f3769035b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the given message is forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우, 주어진 메시지는 등록 된 모든 출력 핸들러 오브젝트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="09b15fa7220dfe741c8baffb5087e302fb89c908" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지를 구성하고 등록 된 모든 출력 핸들러 오브젝트로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c33be9e7edb44141d7868af8327eb0567ce6ec4f" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function. The message and the given &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; are then stored in a &lt;a href=&quot;logrecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; which is forwarded to all registered output handlers.</source>
          <target state="translated">로거가 현재 주어진 메시지 수준에 대해 활성화되어있는 경우 제공된 공급자 기능을 호출하여 메시지가 구성됩니다. 그러면 메시지와 주어진 &lt;a href=&quot;../../../../java.base/java/lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;logrecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; 에&lt;/a&gt; 저장됩니다. 등록 된 모든 출력 핸들러로 전달 .</target>
        </trans-unit>
        <trans-unit id="72eff8884364ee54a875323cb549fca604cb4b7b" translate="yes" xml:space="preserve">
          <source>If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function. The message and the given &lt;a href=&quot;../../lang/throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; are then stored in a &lt;a href=&quot;logrecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; which is forwarded to all registered output handlers.</source>
          <target state="translated">로거가 현재 지정된 메시지 레벨에 대해 사용 가능한 경우 제공된 공급 업체 기능을 호출하여 메시지를 구성합니다. 그런 다음 메시지와 지정된 &lt;a href=&quot;../../lang/throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;logrecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; 에&lt;/a&gt; 저장되며 등록 된 모든 출력 핸들러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bb1c400f82a20624d25957d22a9309735bd25ad8" translate="yes" xml:space="preserve">
          <source>If the looked-up method has a &lt;a href=&quot;methodhandle#maxarity&quot;&gt;very large arity&lt;/a&gt;, the method handle creation may fail with an &lt;code&gt;IllegalArgumentException&lt;/code&gt;, due to the method handle type having &lt;a href=&quot;methodhandle#maxarity&quot;&gt;too many parameters.&lt;/a&gt;</source>
          <target state="translated">조회 메서드의 &lt;a href=&quot;methodhandle#maxarity&quot;&gt;arity&lt;/a&gt; 가 매우 큰 경우 메서드 핸들 유형에 &lt;a href=&quot;methodhandle#maxarity&quot;&gt;매개 변수&lt;/a&gt; 가 너무 많아서 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 과 함께 메서드 핸들 생성이 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df68511496b32d8949f42994423a12d97c5a37a3" translate="yes" xml:space="preserve">
          <source>If the looked-up method has a &lt;a href=&quot;methodhandle#maxarity&quot;&gt;very large arity&lt;/a&gt;, the method handle creation may fail, due to the method handle type having too many parameters.</source>
          <target state="translated">조회 된 메소드의 특성이 &lt;a href=&quot;methodhandle#maxarity&quot;&gt;매우 큰&lt;/a&gt; 경우 메소드 핸들 유형에 매개 변수가 너무 많아 메소드 핸들 작성에 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5a1d5c49aae5cb26d9965efa2b543eb65306a01" translate="yes" xml:space="preserve">
          <source>If the magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the magnitude will not be the zero character.</source>
          <target state="translated">크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면, 크기 표현의 첫 번째 문자는 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e2b282ebf7062ed0ca134866fb50f5fe7dd48ced" translate="yes" xml:space="preserve">
          <source>If the main task must later await termination, it may re-register and then execute a similar loop:</source>
          <target state="translated">주 작업이 나중에 종료를 기다려야하는 경우 다시 등록한 후 비슷한 루프를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="531cc08b857c4e56e257070320ab4f3d2accadae" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys may have duplicates, use &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">맵핑 된 키 (에 따른 중복 된 경우 &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;IllegalStateException&lt;/code&gt; 이는 콜렉션 동작이 수행 될 때 발생된다. 매핑 된 키에 중복이있을 수있는 경우 &lt;a href=&quot;#toConcurrentMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="088f14da8d2c154179e131d3ed238aa448ab02fb" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys might have duplicates, use &lt;a href=&quot;#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">맵핑 된 키 (에 따른 중복 된 경우 &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;IllegalStateException&lt;/code&gt; 이는 콜렉션 동작이 수행 될 때 발생된다. 매핑 된 키에 중복이있을 수있는 경우 대신 &lt;a href=&quot;#toMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a291cf6a416b3035d499691d19d66c91e9db3e1a" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys might have duplicates, use &lt;a href=&quot;#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;toUnmodifiableMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; to handle merging of the values.</source>
          <target state="translated">맵핑 된 키 (에 따른 중복 된 경우 &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;IllegalStateException&lt;/code&gt; 이는 콜렉션 동작이 수행 될 때 발생된다. 매핑 된 키에 중복이있을 수있는 경우 &lt;a href=&quot;#toUnmodifiableMap(java.util.function.Function,java.util.function.Function,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;toUnmodifiableMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 을 사용하여 값 병합을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b1373a2f67fea002749155a531d7ee46df51febf" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.</source>
          <target state="translated">매핑 된 키에 중복 &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 포함 된 경우 ( Object.equals (Object) 에 따라 ) ) 값 매핑 함수는 각 동일한 요소에 적용되고 결과는 제공된 병합 함수를 사용하여 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="d6ebb09d651c50d7a498fdb18d45eddf7b8ceeeb" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;ConcurrentMap&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">매핑 된 키에 중복 &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 포함 된 경우 ( Object.equals (Object) 에 따라 ) 값 매핑 함수는 각 동일한 요소에 적용되고 결과는 제공된 병합 함수를 사용하여 병합됩니다. &lt;code&gt;ConcurrentMap&lt;/code&gt; 제공된 공급 기능에 의해 생성된다.</target>
        </trans-unit>
        <trans-unit id="2e75e6f9c272bcc58cd0a4bb014e176c452d721a" translate="yes" xml:space="preserve">
          <source>If the mapped keys contain duplicates (according to &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;Map&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">매핑 된 키에 중복 &lt;a href=&quot;../../lang/object#equals(java.lang.Object)&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 포함 된 경우 ( Object.equals (Object) 에 따라 ) 값 매핑 함수는 각 동일한 요소에 적용되고 결과는 제공된 병합 함수를 사용하여 병합됩니다. &lt;code&gt;Map&lt;/code&gt; 제공된 공급 업체의 기능에 의해 생성된다.</target>
        </trans-unit>
        <trans-unit id="91601953e386bbcbf0a6b2f49eca2d05544c99f8" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys may have duplicates, use &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">맵핑 된 키 (따른 중복 포함 된 경우 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;IllegalStateException&lt;/code&gt; 이는 콜렉션 동작이 수행 될 때 발생된다. 매핑 된 키가 중복 된 경우 &lt;a href=&quot;collectors#toConcurrentMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;toConcurrentMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="42bc70fbf81ca2e8ef91fd72811c9886f9c29e43" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown when the collection operation is performed. If the mapped keys may have duplicates, use &lt;a href=&quot;collectors#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">맵핑 된 키 (따른 중복 포함 된 경우 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;IllegalStateException&lt;/code&gt; 이는 콜렉션 동작이 수행 될 때 발생된다. 매핑 된 키에 중복이있는 경우 대신 &lt;a href=&quot;collectors#toMap-java.util.function.Function-java.util.function.Function-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;toMap(Function, Function, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ebd1a935a059b20128bc5042763d4c45de22fb0b" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.</source>
          <target state="translated">맵핑 된 키에 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 에 따라 중복이 포함 된 경우 값 맵핑 기능이 각 동일한 요소에 적용되고 제공된 병합 기능을 사용하여 결과가 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="0ab1f12a020b33fa5cdaa6c8e92a327756ecc141" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;ConcurrentMap&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">맵핑 된 키에 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 에 따라 중복이 포함 된 경우 값 맵핑 기능이 각 동일한 요소에 적용되고 제공된 병합 기능을 사용하여 결과가 병합됩니다. &lt;code&gt;ConcurrentMap&lt;/code&gt; 제공된 공급 기능에 의해 생성된다.</target>
        </trans-unit>
        <trans-unit id="5d55abd598d0098b46d878c1a82407a1edf09085" translate="yes" xml:space="preserve">
          <source>If the mapped keys contains duplicates (according to &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt;&lt;code&gt;Object.equals(Object)&lt;/code&gt;&lt;/a&gt;), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The &lt;code&gt;Map&lt;/code&gt; is created by a provided supplier function.</source>
          <target state="translated">맵핑 된 키에 &lt;a href=&quot;../../lang/object#equals-java.lang.Object-&quot;&gt; &lt;code&gt;Object.equals(Object)&lt;/code&gt; &lt;/a&gt; 에 따라 중복이 포함 된 경우 값 맵핑 기능이 각 동일한 요소에 적용되고 제공된 병합 기능을 사용하여 결과가 병합됩니다. &lt;code&gt;Map&lt;/code&gt; 제공된 공급 업체의 기능에 의해 생성된다.</target>
        </trans-unit>
        <trans-unit id="6776bff4be9d5889c77b053d4d78e203a02dda2b" translate="yes" xml:space="preserve">
          <source>If the mapping function returns &lt;code&gt;null&lt;/code&gt;, no mapping is recorded. If the mapping function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:</source>
          <target state="translated">매핑 함수가 &lt;code&gt;null&lt;/code&gt; 을 반환하면 매핑이 기록되지 않습니다. 매핑 함수 자체가 (확인되지 ​​않은) 예외를 throw하면 예외가 다시 throw되고 매핑이 기록되지 않습니다. 가장 일반적인 사용법은 다음과 같이 초기 매핑 된 값 또는 메모 된 결과로 제공되는 새 개체를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb025d3bf5eb9ce361d77c9eec5cc70908428bf7" translate="yes" xml:space="preserve">
          <source>If the mapping function returns a &lt;code&gt;null&lt;/code&gt; result then this method returns an empty &lt;code&gt;Optional&lt;/code&gt;.</source>
          <target state="translated">매핑 함수가 &lt;code&gt;null&lt;/code&gt; 결과를 반환하면이 메서드는 빈 &lt;code&gt;Optional&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="12d75596707c6333177ca57803e56fd8714ec021" translate="yes" xml:space="preserve">
          <source>If the match succeeds then more information can be obtained via the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; methods, and subsequent invocations of the &lt;a href=&quot;#find()&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt; method will start at the first character not matched by this match.</source>
          <target state="translated">일치가 성공하면 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 메서드 를 통해 더 많은 정보를 얻을 수 있으며 &lt;a href=&quot;#find()&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt; 메서드 의 후속 호출은 이 일치와 일치하지 않는 첫 번째 문자에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="38fcc3a9324656c7f62d52adcd0bcdf26f23941f" translate="yes" xml:space="preserve">
          <source>If the match succeeds then more information can be obtained via the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; methods, and subsequent invocations of the &lt;a href=&quot;matcher#find--&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt; method will start at the first character not matched by this match.</source>
          <target state="translated">일치가 성공하면 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 메소드 를 통해 추가 정보를 얻을 수 있으며 &lt;a href=&quot;matcher#find--&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt; 메소드 의 후속 호출은 이 일치와 일치하지 않는 첫 번째 문자에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e45d30a935b4cf0dbcaf8698457f96e2ee71e0db" translate="yes" xml:space="preserve">
          <source>If the match succeeds then more information can be obtained via the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;group&lt;/code&gt; methods.</source>
          <target state="translated">일치하는 경우 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 메소드 를 통해 추가 정보를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4646f11996bf69cea5464367c1335e753c401c2e" translate="yes" xml:space="preserve">
          <source>If the match was successful but the group specified failed to match any part of the input sequence, then &lt;code&gt;null&lt;/code&gt; is returned. Note that some groups, for example &lt;code&gt;(a*)&lt;/code&gt;, match the empty string. This method will return the empty string when such a group successfully matches the empty string in the input.</source>
          <target state="translated">일치는했지만 지정된 그룹이 입력 순서의 일부와 일치하지 않으면 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다. 예를 들어 &lt;code&gt;(a*)&lt;/code&gt; 와 같은 일부 그룹 은 빈 문자열과 일치합니다. 이 메소드는 해당 그룹이 입력의 빈 문자열과 성공적으로 일치하면 빈 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7978619400e787b4fa09d19e22379298e6ddd77a" translate="yes" xml:space="preserve">
          <source>If the matcher is to be used for further matching operations after the terminal stream operation completes then it should be first reset.</source>
          <target state="translated">터미널 스트림 작업이 완료된 후 추가 매칭 작업에 matcher를 사용하려면 먼저 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e27c63987af47673a3557d130f21afb577235397" translate="yes" xml:space="preserve">
          <source>If the maximum number of integer digits is greater than their minimum number and greater than 1, it forces the exponent to be a multiple of the maximum number of integer digits, and the minimum number of integer digits to be interpreted as 1. The most common use of this is to generate &lt;em&gt;engineering notation&lt;/em&gt;, in which the exponent is a multiple of three, e.g., &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt;. Using this pattern, the number 12345 formats to &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt;, and 123456 formats to &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt;.</source>
          <target state="translated">최대 정수 자릿수가 최소 자릿수보다 크고 1보다 큰 경우 지수는 최대 정수 자릿수의 배수가되고 최소 정수 자릿수가 1로 해석됩니다. 이것의 사용은 &lt;em&gt;공학 표기법&lt;/em&gt; 을 생성 하는 것인데, 지수는 &lt;code&gt;&quot;##0.#####E0&quot;&lt;/code&gt; 과 같이 3의 배수입니다 . 이 패턴을 사용하면 숫자 12345는 &lt;code&gt;&quot;12.345E3&quot;&lt;/code&gt; 으로 , 123456은 &lt;code&gt;&quot;123.456E3&quot;&lt;/code&gt; 으로 포맷됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc02abf9ff2a8cfb39d93ed0d23fa96b285931bc" translate="yes" xml:space="preserve">
          <source>If the maximum packet size is too small to hold a minimal record, an implementation may attempt to generate as minimal records as possible. However, this may cause a generated packet to be larger than the maximum packet size.</source>
          <target state="translated">최대 패킷 크기가 너무 작아 최소 레코드를 보유 할 수없는 경우 구현시 가능한 한 최소 레코드를 생성하려고 할 수 있습니다. 그러나 이로 인해 생성 된 패킷이 최대 패킷 크기보다 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b7136459975c689cb618446a7775563184c4f97" translate="yes" xml:space="preserve">
          <source>If the maximum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it.</source>
          <target state="translated">최대 크기가 &lt;code&gt;null&lt;/code&gt; 이 아닌 값 으로 설정되어 있으면 반환합니다.</target>
        </trans-unit>
        <trans-unit id="86b3b7a5e5f22c1bf8fae091e74834fd7dca174e" translate="yes" xml:space="preserve">
          <source>If the maximum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it. If the UI delegate's &lt;code&gt;getMaximumSize&lt;/code&gt; method returns a non-&lt;code&gt;null&lt;/code&gt; value then return that; otherwise defer to the component's layout manager.</source>
          <target state="translated">최대 크기가 &lt;code&gt;null&lt;/code&gt; 이 아닌 값 으로 설정되어 있으면 반환합니다. UI 델리게이트의 &lt;code&gt;getMaximumSize&lt;/code&gt; 메서드가 &lt;code&gt;null&lt;/code&gt; 이 아닌 값을 반환하면 해당 값을 반환합니다. 그렇지 않으면 구성 요소의 레이아웃 관리자를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="a8ec7f18e844715a365255a5c9ce58a9ea8cde37" translate="yes" xml:space="preserve">
          <source>If the maximum value is different from the previous maximum, all change listeners are notified.</source>
          <target state="translated">최대 값이 이전 최대 값과 다른 경우 모든 변경 리스너에게 알림이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="838dcf4d5b32bbaaf6507ff34ec3b9a39315ea1c" translate="yes" xml:space="preserve">
          <source>If the mechanism has an initial response, the library invokes &lt;code&gt;evaluateChallenge()&lt;/code&gt; with an empty challenge and to get initial response. Protocols such as IMAP4, which do not include an initial response with their first authentication command to the server, initiates the authentication without first calling &lt;code&gt;hasInitialResponse()&lt;/code&gt; or &lt;code&gt;evaluateChallenge()&lt;/code&gt;. When the server responds to the command, it sends an initial challenge. For a SASL mechanism in which the client sends data first, the server should have issued a challenge with no data. This will then result in a call (on the client) to &lt;code&gt;evaluateChallenge()&lt;/code&gt; with an empty challenge.</source>
          <target state="translated">메커니즘에 초기 응답이있는 경우 라이브러리는 비어있는 시도로 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 를 호출 하고 초기 응답을받습니다. 서버에 대한 첫 번째 인증 명령으로 초기 응답을 포함하지 않는 IMAP4와 같은 프로토콜은 &lt;code&gt;hasInitialResponse()&lt;/code&gt; 또는 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 를 먼저 호출하지 않고 인증을 시작합니다 . 서버가 명령에 응답하면 초기 챌린지를 보냅니다. 클라이언트가 데이터를 먼저 보내는 SASL 메커니즘의 경우 서버는 데이터없이 챌린지를 발행해야합니다. 그러면 빈 챌린지 로 &lt;code&gt;evaluateChallenge()&lt;/code&gt; 를 평가 하기 위해 ( 클라이언트에서) 호출이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4583d5e7e45e0fa2e945cb9ac4db80337ed6eff8" translate="yes" xml:space="preserve">
          <source>If the membership key represents a membership to receive all datagrams then the membership is dropped and the channel will no longer receive any datagrams sent to the group. If the membership key is source-specific then the channel will no longer receive datagrams sent to the group from that source address.</source>
          <target state="translated">멤버쉽 키가 모든 데이터 그램을 수신하는 멤버쉽을 나타내는 경우 멤버쉽이 삭제되고 채널은 더 이상 그룹으로 전송 된 데이터 그램을 수신하지 않습니다. 멤버쉽 키가 소스에 특정한 경우 채널은 더 이상 해당 소스 주소에서 그룹으로 전송 된 데이터 그램을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6001952d56f121e245b493dc6d0d725d39114278" translate="yes" xml:space="preserve">
          <source>If the metadata does contain tables, the tables given in a &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; are ignored. Furthermore, once a set of tables has been written, only tables in the metadata can override them for subsequent writes, whether to the same stream or a different one. In order to specify new tables using this class, the &lt;a href=&quot;../../imagewriter#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; method of the writer must be called.</source>
          <target state="translated">메타 데이터에 테이블이 포함되어 있으면 &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; 에 지정된 테이블 이 무시됩니다. 또한 테이블 집합이 작성되면 메타 데이터의 테이블 만 동일한 스트림 또는 다른 스트림에 대한 후속 쓰기를 위해이를 재정의 할 수 있습니다. 이 클래스를 사용하여 새 테이블을 지정 하려면 writer 의 &lt;a href=&quot;../../imagewriter#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메서드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="578b6c8818072cd3e8eeb57e000ffbfdfb02eb42" translate="yes" xml:space="preserve">
          <source>If the metadata does contain tables, the tables given in a &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; are ignored. Furthermore, once a set of tables has been written, only tables in the metadata can override them for subsequent writes, whether to the same stream or a different one. In order to specify new tables using this class, the &lt;a href=&quot;../../imagewriter#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; method of the writer must be called.</source>
          <target state="translated">메타 데이터에 테이블이 포함되어 있으면 &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; 에 제공된 테이블 이 무시됩니다. 또한 일단 테이블 세트가 작성된 후에는 동일한 스트림이든 다른 스트림이든간에 메타 데이터의 테이블 만 후속 쓰기를 위해이를 대체 할 수 있습니다. 이 클래스를 사용하여 새 테이블을 지정 하려면 기록기 의 &lt;a href=&quot;../../imagewriter#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad0276650305bd3de8e01175bff74048c2dfe026" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;mark&lt;/code&gt; has not been called since the stream was created, or the number of bytes read from the stream since &lt;code&gt;mark&lt;/code&gt; was last called is larger than the argument to &lt;code&gt;mark&lt;/code&gt; at that last call, then an &lt;code&gt;IOException&lt;/code&gt; might be thrown.</source>
          <target state="translated">스트림이 작성된 후 메소드 &lt;code&gt;mark&lt;/code&gt; 가 호출되지 않았거나 &lt;code&gt;mark&lt;/code&gt; 가 마지막으로 호출 된 이후 스트림에서 읽은 바이트 수가 해당 마지막 호출에서 &lt;code&gt;mark&lt;/code&gt; 하기위한 인수보다 큰 경우 &lt;code&gt;IOException&lt;/code&gt; 이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd81035982e12d53ca7e2f58a6ad2d674721fd8" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, then:</source>
          <target state="translated">&lt;code&gt;markSupported&lt;/code&gt; 메소드 가 &lt;code&gt;false&lt;/code&gt; 를 돌려주는 경우 :</target>
        </trans-unit>
        <trans-unit id="864c00c6cb70175672417e9637771a48ccc4d334" translate="yes" xml:space="preserve">
          <source>If the method &lt;code&gt;markSupported&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, then:</source>
          <target state="translated">이 방법은 경우 &lt;code&gt;markSupported&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , 다음 :</target>
        </trans-unit>
        <trans-unit id="257969b0bfbf03841c2811e4e4900ba062f566de" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../../java.base/java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception does not prevent other listeners from being invoked. However, if the method call of a filter or of &lt;code&gt;Executor.execute&lt;/code&gt; or of &lt;code&gt;handleNotification&lt;/code&gt; (when no &lt;code&gt;Excecutor&lt;/code&gt; is specified) throws an &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then that &lt;code&gt;Error&lt;/code&gt; is propagated to the caller of &lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필터 또는 리스너의 메서드 호출이 &lt;a href=&quot;../../../java.base/java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; 을&lt;/a&gt; throw하는 경우 해당 예외는 다른 리스너가 호출되는 것을 방지하지 않습니다. 그러나 필터, &lt;code&gt;Executor.execute&lt;/code&gt; 또는 &lt;code&gt;handleNotification&lt;/code&gt; ( &lt;code&gt;Excecutor&lt;/code&gt; 가 지정 되지 않은 경우)의 메서드 호출이 &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; 를&lt;/a&gt; 던지면 해당 &lt;code&gt;Error&lt;/code&gt; 가 &lt;a href=&quot;#sendNotification(javax.management.Notification)&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; &lt;/a&gt; 호출자에게 전파됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a268179b4de151a916f950d2bb56b82b6124706" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../../java.base/java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception should not prevent other listeners from being invoked. However, if the method call throws an &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then it is recommended that processing of the notification stop at that point, and if it is possible to propagate the &lt;code&gt;Error&lt;/code&gt; to the sender of the notification, this should be done.</source>
          <target state="translated">필터 또는 리스너의 메서드 호출이 &lt;a href=&quot;../../../java.base/java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 을 발생시키는 경우 해당 예외는 다른 리스너가 호출되는 것을 방지하지 않아야합니다. 그러나 메서드 호출이 &lt;a href=&quot;../../../java.base/java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; 를&lt;/a&gt; 던지면 해당 지점에서 알림 처리를 중지하는 것이 좋으며 알림 발신자에게 &lt;code&gt;Error&lt;/code&gt; 를 전파 할 수있는 경우이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="eaea82c9a23067ef7f772f7e498b434c683c927b" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception does not prevent other listeners from being invoked. However, if the method call of a filter or of &lt;code&gt;Executor.execute&lt;/code&gt; or of &lt;code&gt;handleNotification&lt;/code&gt; (when no &lt;code&gt;Excecutor&lt;/code&gt; is specified) throws an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then that &lt;code&gt;Error&lt;/code&gt; is propagated to the caller of &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt;&lt;code&gt;sendNotification&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필터 또는 리스너의 메소드 호출에서 &lt;a href=&quot;../../java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 이 발생하면 해당 예외로 인해 다른 리스너가 호출되지 않습니다. 또는 필터의 메소드 호출 그러나 &lt;code&gt;Executor.execute&lt;/code&gt; 또는 &lt;code&gt;handleNotification&lt;/code&gt; (어떤 경우 &lt;code&gt;Excecutor&lt;/code&gt; 가 지정되지 않은)이 발생 &lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; , 그 &lt;code&gt;Error&lt;/code&gt; 호출자에게 전달된다 &lt;a href=&quot;notificationbroadcastersupport#sendNotification-javax.management.Notification-&quot;&gt; &lt;code&gt;sendNotification&lt;/code&gt; 에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="267719667d5da83b9f20baec6b480b3574e95dc7" translate="yes" xml:space="preserve">
          <source>If the method call of a filter or listener throws an &lt;a href=&quot;../../java/lang/exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, then that exception should not prevent other listeners from being invoked. However, if the method call throws an &lt;a href=&quot;../../java/lang/error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;, then it is recommended that processing of the notification stop at that point, and if it is possible to propagate the &lt;code&gt;Error&lt;/code&gt; to the sender of the notification, this should be done.</source>
          <target state="translated">필터 또는 리스너의 메소드 호출에서 &lt;a href=&quot;../../java/lang/exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 이 발생하면 해당 예외로 인해 다른 리스너가 호출되지 않아야합니다. 그러나 메소드 호출에서 &lt;a href=&quot;../../java/lang/error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 발생하면 해당 시점에서 알림 처리를 중지하고 &lt;code&gt;Error&lt;/code&gt; 를 알림 발신자 에게 전파 할 수있는 경우이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f5c827066a55f3bfdaa44e5351bcaf2001cab9a" translate="yes" xml:space="preserve">
          <source>If the method completes normally, the value it returns is returned to the caller of invoke; if the value has a primitive type, it is first appropriately wrapped in an object. However, if the value has the type of an array of a primitive type, the elements of the array are</source>
          <target state="translated">메소드가 정상적으로 완료되면 리턴하는 값이 호출자에게 리턴됩니다. 값에 프리미티브 유형이있는 경우 먼저 오브젝트에 적절하게 랩핑됩니다. 그러나 값에 기본 유형의 배열 유형이있는 경우 배열의 요소는</target>
        </trans-unit>
        <trans-unit id="b17c4dd6d3aeaac2e8381aefcb1bb96824a4c8a8" translate="yes" xml:space="preserve">
          <source>If the method given to &lt;a href=&quot;../../../../java.base/java/lang/reflect/invocationhandler#invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt; is the method &lt;code&gt;boolean equals(Object)&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return true if and only if the argument is a &lt;code&gt;Proxy&lt;/code&gt; whose &lt;code&gt;InvocationHandler&lt;/code&gt; is also a &lt;code&gt;
   CompositeDataInvocationHandler&lt;/code&gt; and whose backing &lt;code&gt;
   CompositeData&lt;/code&gt; is equal (not necessarily identical) to this object's. If the method given to &lt;code&gt;invoke&lt;/code&gt; is the method &lt;code&gt;int hashCode()&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return a value that is consistent with this definition of &lt;code&gt;
   equals&lt;/code&gt;: if two objects are equal according to &lt;code&gt;equals&lt;/code&gt;, then they will have the same &lt;code&gt;hashCode&lt;/code&gt;.</source>
          <target state="translated">주어진 방법 않으면 &lt;a href=&quot;../../../../java.base/java/lang/reflect/invocationhandler#invoke(java.lang.Object,java.lang.reflect.Method,java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; &lt;/a&gt; 메소드이다 &lt;code&gt;boolean equals(Object)&lt;/code&gt; 로부터 상속 된 &lt;code&gt;Object&lt;/code&gt; , 다음과 같은 경우 true를 반환 할 것이다 인수는 경우에만 &lt;code&gt;Proxy&lt;/code&gt; 누구 &lt;code&gt;InvocationHandler&lt;/code&gt; 도이다 &lt;code&gt; CompositeDataInvocationHandler&lt;/code&gt; 및 그 백업 &lt;code&gt; CompositeData&lt;/code&gt; 동일한 (동일한 필요는 없다)된다에 이 개체의. &lt;code&gt;invoke&lt;/code&gt; 에 주어진 메서드 가 &lt;code&gt;Object&lt;/code&gt; 에서 상속 된 &lt;code&gt;int hashCode()&lt;/code&gt; 메서드 인 경우이 &lt;code&gt; equals&lt;/code&gt; 정의와 일치하는 값을 반환합니다 . 두 개체가 같음에 따라 &lt;code&gt;equals&lt;/code&gt; , 그러면 동일한 &lt;code&gt;hashCode&lt;/code&gt; 를 갖게됩니다 .</target>
        </trans-unit>
        <trans-unit id="16a48723a8d9e2801b89e415c711042c7335165b" translate="yes" xml:space="preserve">
          <source>If the method given to &lt;a href=&quot;compositedatainvocationhandler#invoke-java.lang.Object-java.lang.reflect.Method-java.lang.Object:A-&quot;&gt;&lt;code&gt;invoke&lt;/code&gt;&lt;/a&gt; is the method &lt;code&gt;boolean equals(Object)&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return true if and only if the argument is a &lt;code&gt;Proxy&lt;/code&gt; whose &lt;code&gt;InvocationHandler&lt;/code&gt; is also a &lt;code&gt;CompositeDataInvocationHandler&lt;/code&gt; and whose backing &lt;code&gt;CompositeData&lt;/code&gt; is equal (not necessarily identical) to this object's. If the method given to &lt;code&gt;invoke&lt;/code&gt; is the method &lt;code&gt;int hashCode()&lt;/code&gt; inherited from &lt;code&gt;Object&lt;/code&gt;, then it will return a value that is consistent with this definition of &lt;code&gt;equals&lt;/code&gt;: if two objects are equal according to &lt;code&gt;equals&lt;/code&gt;, then they will have the same &lt;code&gt;hashCode&lt;/code&gt;.</source>
          <target state="translated">주어진 방법 않으면 &lt;a href=&quot;compositedatainvocationhandler#invoke-java.lang.Object-java.lang.reflect.Method-java.lang.Object:A-&quot;&gt; &lt;code&gt;invoke&lt;/code&gt; &lt;/a&gt; 메소드이다 &lt;code&gt;boolean equals(Object)&lt;/code&gt; 로부터 상속 된 &lt;code&gt;Object&lt;/code&gt; , 다음과 같은 경우 true를 반환 할 것이다 인수는 경우에만 &lt;code&gt;Proxy&lt;/code&gt; 누구 &lt;code&gt;InvocationHandler&lt;/code&gt; 도이다 &lt;code&gt;CompositeDataInvocationHandler&lt;/code&gt; 및 그 백업 &lt;code&gt;CompositeData&lt;/code&gt; 동일한 (동일한 필요는 없다)된다에 이 객체. 주어진 경우에있어서 &lt;code&gt;invoke&lt;/code&gt; 메소드이다 &lt;code&gt;int hashCode()&lt;/code&gt; 로부터 상속 된 &lt;code&gt;Object&lt;/code&gt; , 그것은의 정의와 일치하는 값을 반환 &lt;code&gt;equals&lt;/code&gt; 두 개체에있어서 동일한 경우 &lt;code&gt;equals&lt;/code&gt; 그러면 동일한 &lt;code&gt;hashCode&lt;/code&gt; 를 갖게됩니다 .</target>
        </trans-unit>
        <trans-unit id="89482ab6ffc986fc87454df58fb0e43c7e1caddc" translate="yes" xml:space="preserve">
          <source>If the method is native or abstract, an empty list is returned.</source>
          <target state="translated">메서드가 기본 또는 추상이면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0c8dd855a596d9b3681ae2a62cc0d2f6c52ee22d" translate="yes" xml:space="preserve">
          <source>If the method shows the window then the window is also made focused under the following conditions:</source>
          <target state="translated">메소드가 창을 표시하면 다음 조건에서도 창에 초점이 맞춰집니다.</target>
        </trans-unit>
        <trans-unit id="2b6f07a7fdaf466e246e416a6d8be9d141006087" translate="yes" xml:space="preserve">
          <source>If the method throws an unchecked exception it is ignored except in the case of EJBs where the EJB can handle exceptions.</source>
          <target state="translated">메소드가 확인되지 않은 예외를 발생시키는 경우 EJB가 예외를 처리 할 수있는 EJB의 경우를 제외하고는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="dd7f5b04deb2b9061789f4f81f1da0be43e66b30" translate="yes" xml:space="preserve">
          <source>If the method throws an unchecked exception the class MUST NOT be put into service except in the case of EJBs where the EJB can handle exceptions and even recover from them.</source>
          <target state="translated">메소드가 검사되지 않은 예외를 발생시키는 경우 EJB가 예외를 처리하고 예외로부터 복구 할 수있는 EJB의 경우를 제외하고는 클래스를 서비스에 포함해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="71fad1ecc8a08eac94d160de9bd1bcb1628402e9" translate="yes" xml:space="preserve">
          <source>If the methods that return configuration information about the annotation processor return &lt;code&gt;null&lt;/code&gt;, return other invalid input, or throw an exception, the tool infrastructure must treat this as an error condition.</source>
          <target state="translated">어노테이션 프로세서에 대한 구성 정보를 리턴하는 메소드가 &lt;code&gt;null&lt;/code&gt; 을 리턴하거나 다른 유효하지 않은 입력을 리턴하거나 예외를 발생시키는 경우 도구 인프라는이를 오류 조건으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d9250ed3bc9c6d4ff0b925cf3b480e2220dbd67" translate="yes" xml:space="preserve">
          <source>If the mimeType is &quot;application/x-java-serialized-object; class=&amp;lt;representation class&amp;gt;&quot;, the result is the same as calling &lt;code&gt;new DataFlavor(Class.forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">mimeType이 &quot;application / x-java-serialized-object; class = &amp;lt;representation class&amp;gt;&quot;인 경우 결과는 &lt;code&gt;new DataFlavor(Class.forName(&amp;lt;representation class&amp;gt;)&lt;/code&gt; 호출과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="645cb7d243c1be249a152ed3e295457a416dfa10" translate="yes" xml:space="preserve">
          <source>If the minimum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it.</source>
          <target state="translated">최소 크기가 &lt;code&gt;null&lt;/code&gt; 이 아닌 값 으로 설정되어 있으면 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8876db76229cee3d170e10fbb666ffa91c4f625e" translate="yes" xml:space="preserve">
          <source>If the minimum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value just returns it. If the UI delegate's &lt;code&gt;getMinimumSize&lt;/code&gt; method returns a non-&lt;code&gt;null&lt;/code&gt; value then return that; otherwise defer to the component's layout manager.</source>
          <target state="translated">최소 크기가 &lt;code&gt;null&lt;/code&gt; 이 아닌 값 으로 설정되어 있으면 반환합니다. UI 델리게이트의 &lt;code&gt;getMinimumSize&lt;/code&gt; 메서드가 &lt;code&gt;null&lt;/code&gt; 이 아닌 값을 반환하면 해당 값을 반환합니다. 그렇지 않으면 구성 요소의 레이아웃 관리자를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="34725787b80a4ac3e39668b42bbcaa23889b0833" translate="yes" xml:space="preserve">
          <source>If the minimum value is different from the previous minimum, all change listeners are notified.</source>
          <target state="translated">최소값이 이전 최소값과 다른 경우 모든 변경 리스너에게 알림이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="691404a8b3e5b3eda8e1acec57c701c9733bf667" translate="yes" xml:space="preserve">
          <source>If the model isn't empty, the width is the preferred size's width, typically the width of the widest list element. The height is the height of the cell with index 0 multiplied by the &lt;code&gt;visibleRowCount&lt;/code&gt;, plus the list's vertical insets.</source>
          <target state="translated">모델이 비어 있지 않은 경우 너비는 기본 크기의 너비이며 일반적으로 가장 넓은 목록 요소의 너비입니다. 높이는 index 0에 &lt;code&gt;visibleRowCount&lt;/code&gt; 를 곱한 셀의 높이와 목록의 수직 인세 트입니다.</target>
        </trans-unit>
        <trans-unit id="0b88a0b55b2b80ffaa036b69fe4a0d5c5dc0f38c" translate="yes" xml:space="preserve">
          <source>If the module name consists of one identifier, then this method returns that identifier, which is deemed to be module's fully qualified name despite not being in qualified form. If the module name consists of more than one identifier, then this method returns the entire name.</source>
          <target state="translated">모듈 이름이 하나의 식별자로 구성된 경우이 메서드는 해당 식별자를 반환합니다.이 식별자는 정규화 된 형식이 아니더라도 모듈의 정규화 된 이름으로 간주됩니다. 모듈 이름이 둘 이상의 식별자로 구성된 경우이 메서드는 전체 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f7fafdcfebc35bea4dd094bd5605e29e57f9bd44" translate="yes" xml:space="preserve">
          <source>If the module name consists of one identifier, then this method returns that identifier. If the module name consists of more than one identifier, then this method returns the rightmost such identifier, which is deemed to be the module's simple name.</source>
          <target state="translated">모듈 이름이 하나의 식별자로 구성된 경우이 메서드는 해당 식별자를 반환합니다. 모듈 이름이 둘 이상의 식별자로 구성되어 있으면이 메서드는 모듈의 단순 이름으로 간주되는 가장 오른쪽에있는 식별자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1d5473331af759f2d8229027168bed280516c881" translate="yes" xml:space="preserve">
          <source>If the module reader can determine that the name locates a directory then the resulting URI will end with a slash ('/').</source>
          <target state="translated">모듈 판독기가 이름이 디렉토리를 찾는 것을 확인할 수있는 경우 결과 URI는 슬래시 ( '/')로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="504335c7ed6dbcdfc8abf3c7edbaa85154a6e4d7" translate="yes" xml:space="preserve">
          <source>If the mouse is pressed above the &quot;thumb&quot; component then reduce the scrollbars value by one page (&quot;page up&quot;), otherwise increase it by one page.</source>
          <target state="translated">&quot;thumb&quot;구성 요소 위에서 마우스를 누르면 스크롤 막대 값을 한 페이지 줄이고 ( &quot;page up&quot;) 그렇지 않으면 한 페이지 늘립니다.</target>
        </trans-unit>
        <trans-unit id="ba4fc2c0db235b256084eb10160b50a98ca67f0a" translate="yes" xml:space="preserve">
          <source>If the mouse is pressed above the &quot;thumb&quot; component then reduce the scrollbars value by one page (&quot;page up&quot;), otherwise increase it by one page. If there is no thumb then page up if the mouse is in the upper half of the track.</source>
          <target state="translated">&quot;thumb&quot;구성 요소 위에서 마우스를 누르면 스크롤 막대 값을 한 페이지 줄이고 ( &quot;page up&quot;) 그렇지 않으면 한 페이지 늘립니다. 엄지가 없으면 마우스가 트랙의 위쪽 절반에 있으면 페이지 위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d66f64c9f7d27c9865a5a830293bbaacc7ca8be1" translate="yes" xml:space="preserve">
          <source>If the name matches the regular expression &lt;code&gt;
         &quot;-(\\d+(\\.|$))&quot;&lt;/code&gt; then the module name will be derived from the subsequence preceding the hyphen of the first occurrence. The subsequence after the hyphen is parsed as a &lt;a href=&quot;moduledescriptor.version&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; and ignored if it cannot be parsed as a &lt;code&gt;Version&lt;/code&gt;.</source>
          <target state="translated">If the name matches the regular expression &lt;code&gt; &quot;-(\\d+(\\.|$))&quot;&lt;/code&gt; then the module name will be derived from the subsequence preceding the hyphen of the first occurrence. The subsequence after the hyphen is parsed as a &lt;a href=&quot;moduledescriptor.version&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; and ignored if it cannot be parsed as a &lt;code&gt;Version&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c345ae50909ad753edc18ff3d914c0995558637" translate="yes" xml:space="preserve">
          <source>If the named Logger already exists and does not yet have a localization resource bundle then the given resource bundle name is used. If the named Logger already exists and has a different resource bundle name then an IllegalArgumentException is thrown.</source>
          <target state="translated">이름 지정된 로거가 이미 존재하고 아직 현지화 자원 번들이없는 경우 제공된 자원 번들 이름이 사용됩니다. 이름이 지정된 Logger가 이미 존재하고 다른 자원 번들 이름이 있으면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="68506597c2f99be04b0f47ace8cfa88608b7a8be" translate="yes" xml:space="preserve">
          <source>If the named class is not a top-level class, this invocation will have no effect on the actual assertion status of any class.</source>
          <target state="translated">명명 된 클래스가 최상위 클래스가 아닌 경우이 호출은 클래스의 실제 어설 션 상태에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="482df42008c5e582c9e2d80de4a8c2c7a964f035" translate="yes" xml:space="preserve">
          <source>If the named file does not exist, is a directory rather than a regular file, or for some other reason cannot be opened for reading then a &lt;code&gt;FileNotFoundException&lt;/code&gt; is thrown.</source>
          <target state="translated">명명 된 파일이 존재하지 않거나 일반 파일이 아닌 디렉토리이거나 다른 이유로 읽을 수없는 경우 &lt;code&gt;FileNotFoundException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="95905c4bd2793861fb30aaa68b18d361d2c40205" translate="yes" xml:space="preserve">
          <source>If the named object is not a DirContext, search only the object. If the named object is a DirContext, search the subtree rooted at the named object, including the named object itself.</source>
          <target state="translated">명명 된 개체가 DirContext가 아닌 경우 개체 만 검색하십시오. 명명 된 객체가 DirContext 인 경우, 명명 된 객체 자체를 포함하여 명명 된 객체를 기반으로하는 하위 트리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="c355566b5306844a932460e0a37f46753cb3dc74" translate="yes" xml:space="preserve">
          <source>If the namespace-prefixes feature (see above) is &lt;var&gt;false&lt;/var&gt;, access by qualified name may not be available; if the &lt;code&gt;http://xml.org/sax/features/namespaces&lt;/code&gt; feature is &lt;var&gt;false&lt;/var&gt;, access by Namespace-qualified names may not be available.</source>
          <target state="translated">If the namespace-prefixes feature (see above) is &lt;var&gt;false&lt;/var&gt; , access by qualified name may not be available; if the &lt;code&gt;http://xml.org/sax/features/namespaces&lt;/code&gt; feature is &lt;var&gt;false&lt;/var&gt; , access by Namespace-qualified names may not be available.</target>
        </trans-unit>
        <trans-unit id="a797ab321ba29b078906111b6a9d36444e539b67" translate="yes" xml:space="preserve">
          <source>If the nano-of-second is zero or not available then the format is complete.</source>
          <target state="translated">나노초가 0이거나 사용할 수없는 경우 포맷이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b5bb80313d91ea06fa6a854209eaa7ff1477dde" translate="yes" xml:space="preserve">
          <source>If the natural result is a node set when &lt;code&gt;ANY_TYPE&lt;/code&gt; was requested, then &lt;code&gt;UNORDERED_NODE_ITERATOR_TYPE&lt;/code&gt; is always the resulting type. Any other representation of a node set must be explicitly requested.</source>
          <target state="translated">&lt;code&gt;ANY_TYPE&lt;/code&gt; 이 요청 되었을 때 자연 결과가 노드 집합 이면 &lt;code&gt;UNORDERED_NODE_ITERATOR_TYPE&lt;/code&gt; 은 항상 결과 유형입니다. 노드 집합의 다른 표현은 명시 적으로 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="0fa9630681cd403ee0de2e898abe3034087ed2d1" translate="yes" xml:space="preserve">
          <source>If the nest host of the lookup class of this &lt;code&gt;Lookup&lt;/code&gt; has previously been determined, then let &lt;code&gt;H&lt;/code&gt; be the nest host of the lookup class. Otherwise, the nest host of the lookup class is determined using the algorithm in JVMS &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-5.html#jls-5.4.4&quot;&gt;5.4.4&lt;/a&gt;, yielding &lt;code&gt;H&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Lookup&lt;/code&gt; 의 조회 클래스의 중첩 호스트 가 이전에 결정된 경우 &lt;code&gt;H&lt;/code&gt; 를 조회 클래스의 중첩 호스트 로 둡니다 . 그렇지 않으면, 조회 클래스의 둥지 호스트 JVMS의 알고리즘을 이용하여 결정된다 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-5.html#jls-5.4.4&quot;&gt;5.4.4&lt;/a&gt; 수득 &lt;code&gt;H&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="5582ab669009a8a27be652376823390e57a44c93" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;Node&lt;/code&gt; replaces an existing node the replaced &lt;code&gt;Node&lt;/code&gt; is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">If the new &lt;code&gt;Node&lt;/code&gt; replaces an existing node the replaced &lt;code&gt;Node&lt;/code&gt; is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned.</target>
        </trans-unit>
        <trans-unit id="2bc796f960d0884f7fa3798155b8968a45c48d83" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;TransferHandler&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this method removes the drop target.</source>
          <target state="translated">If the new &lt;code&gt;TransferHandler&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; , this method removes the drop target.</target>
        </trans-unit>
        <trans-unit id="1dda90377648f98704c19dc7bb65377bbe60c5ed" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;TransferHandler&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, this method also installs a &lt;b&gt;new&lt;/b&gt;&lt;code&gt;DropTarget&lt;/code&gt; on the component to activate drop handling through the &lt;code&gt;TransferHandler&lt;/code&gt; and activate any built-in support (such as calculating and displaying potential drop locations). If you do not wish for this component to respond in any way to drops, you can disable drop support entirely either by removing the drop target (&lt;code&gt;setDropTarget(null)&lt;/code&gt;) or by de-activating it (&lt;code&gt;getDropTaget().setActive(false)&lt;/code&gt;).</source>
          <target state="translated">If the new &lt;code&gt;TransferHandler&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; , this method also installs a &lt;b&gt;new&lt;/b&gt; &lt;code&gt;DropTarget&lt;/code&gt; on the component to activate drop handling through the &lt;code&gt;TransferHandler&lt;/code&gt; and activate any built-in support (such as calculating and displaying potential drop locations). If you do not wish for this component to respond in any way to drops, you can disable drop support entirely either by removing the drop target ( &lt;code&gt;setDropTarget(null)&lt;/code&gt; ) or by de-activating it ( &lt;code&gt;getDropTaget().setActive(false)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0388ea5e05300452be6a29d74452f310aa91ce94" translate="yes" xml:space="preserve">
          <source>If the new extent value is different from the previous extent value, all change listeners are notified.</source>
          <target state="translated">If the new extent value is different from the previous extent value, all change listeners are notified.</target>
        </trans-unit>
        <trans-unit id="18bffcd626a18ef77083ada33a312e98a304ff4c" translate="yes" xml:space="preserve">
          <source>If the new level is null, it means that this node should inherit its level from its nearest ancestor with a specific (non-null) level value.</source>
          <target state="translated">새 레벨이 널인 경우,이 노드는 특정 (널이 아닌) 레벨 값으로 가장 가까운 조상으로부터 레벨을 상속해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e9cd03b46165de5658cfad6de7730a3839030abf" translate="yes" xml:space="preserve">
          <source>If the new lookup class differs from the old one then &lt;code&gt;UNCONDITIONAL&lt;/code&gt; is lost.</source>
          <target state="translated">If the new lookup class differs from the old one then &lt;code&gt;UNCONDITIONAL&lt;/code&gt; is lost.</target>
        </trans-unit>
        <trans-unit id="bc536a2662e091e215ec8f641a7473d3709fe706" translate="yes" xml:space="preserve">
          <source>If the new lookup class differs from the old one, protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.)</source>
          <target state="translated">새 조회 클래스가 이전 클래스와 다르면 상속을 통해 보호 된 멤버에 액세스 할 수 없습니다. (패키지 공유로 인해 보호 된 구성원이 계속 액세스 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="3e53f9b359a105bac148750d2761e52e1cd4e8b5" translate="yes" xml:space="preserve">
          <source>If the new lookup class is in a different module from the old lookup class, the new previous lookup class is the old lookup class.</source>
          <target state="translated">새 조회 클래스가 이전 조회 클래스와 다른 모듈에있는 경우 새 이전 조회 클래스는 이전 조회 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b6ba8835bff009366d798076903baa59224c126e" translate="yes" xml:space="preserve">
          <source>If the new lookup class is in a different module from the old one, i.e. &lt;a href=&quot;#MODULE&quot;&gt;&lt;code&gt;MODULE&lt;/code&gt;&lt;/a&gt; access is lost.</source>
          <target state="translated">새 조회 클래스가 이전 모듈과 다른 모듈에있는 경우 즉, &lt;a href=&quot;#MODULE&quot;&gt; &lt;code&gt;MODULE&lt;/code&gt; &lt;/a&gt; 액세스가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="a377cca7fdb7bec2b3b01bf2e347da0c2ef86e72" translate="yes" xml:space="preserve">
          <source>If the new lookup class is in a different package than the old one, protected and default (package) members will not be accessible, i.e. &lt;a href=&quot;#PROTECTED&quot;&gt;&lt;code&gt;PROTECTED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#PACKAGE&quot;&gt;&lt;code&gt;PACKAGE&lt;/code&gt;&lt;/a&gt; access are lost.</source>
          <target state="translated">새 조회 클래스가 이전 패키지와 다른 패키지에있는 경우 보호 및 기본 (패키지) 멤버에 액세스 할 수 없습니다. 즉, &lt;a href=&quot;#PROTECTED&quot;&gt; &lt;code&gt;PROTECTED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#PACKAGE&quot;&gt; &lt;code&gt;PACKAGE&lt;/code&gt; &lt;/a&gt; 액세스가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="60f2db2d23a3b70ce0836cac49cb47c5b9f6353f" translate="yes" xml:space="preserve">
          <source>If the new lookup class is in a different package than the old one, protected and default (package) members will not be accessible.</source>
          <target state="translated">새 조회 클래스가 이전 조회 클래스와 다른 패키지에 있으면 보호 및 기본 (패키지) 멤버에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="68dca4027c2017d1c1cfe6cad29219610bdc524e" translate="yes" xml:space="preserve">
          <source>If the new lookup class is in the same module as the old lookup class, the new previous lookup class is the old previous lookup class.</source>
          <target state="translated">새 조회 클래스가 이전 조회 클래스와 동일한 모듈에있는 경우 새 이전 조회 클래스는 이전 이전 조회 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="4ea2f0333a7bf60c58a21448f2c80569656a34b7" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not &lt;a href=&quot;#accessClass(java.lang.Class)&quot;&gt;accessible&lt;/a&gt; to this lookup, then no members, not even public members, will be accessible i.e. all access modes are lost.</source>
          <target state="translated">이 조회에 새 조회 클래스에 &lt;a href=&quot;#accessClass(java.lang.Class)&quot;&gt;액세스 할 수&lt;/a&gt; 없는 경우 공개 멤버를 비롯한 멤버에 액세스 할 수 없습니다. 즉 모든 액세스 모드가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="ca96aa918a0139c5241a9be60ea7a47fde358969" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not accessible to the old lookup class, then no members, not even public members, will be accessible. (In all other cases, public members will continue to be accessible.)</source>
          <target state="translated">이전 조회 클래스에서 새 조회 클래스에 액세스 할 수 없으면 공개 멤버가 아닌 멤버는 액세스 할 수 없습니다. (다른 모든 경우에도 공개 멤버는 계속 액세스 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="70a1ed61c4e5681283e25d035abcda938a4809a1" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not within the same package member as the old one, private members will not be accessible, and protected members will not be accessible by virtue of inheritance, i.e. &lt;a href=&quot;#PRIVATE&quot;&gt;&lt;code&gt;PRIVATE&lt;/code&gt;&lt;/a&gt; access is lost. (Protected members may continue to be accessible because of package sharing.)</source>
          <target state="translated">새 조회 클래스가 이전 클래스와 동일한 패키지 멤버 내에 있지 않으면 private 멤버에 액세스 할 수 없으며 보호 된 멤버는 상속으로 인해 액세스 할 수 없습니다 . 즉, &lt;a href=&quot;#PRIVATE&quot;&gt; &lt;code&gt;PRIVATE&lt;/code&gt; &lt;/a&gt; 액세스가 손실됩니다. (보호 된 구성원은 패키지 공유로 인해 계속 액세스 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="46f23def278f0153e203621371a62fdba4471bd7" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not within the same package member as the old one, private members will not be accessible, and protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.)</source>
          <target state="translated">If the new lookup class is not within the same package member as the old one, private members will not be accessible, and protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.)</target>
        </trans-unit>
        <trans-unit id="1a7e98a2066ab4c0cf93405953a8d0cbcca7cb64" translate="yes" xml:space="preserve">
          <source>If the new lookup class is not within the same package member as the old one, private members will not be accessible.</source>
          <target state="translated">새 조회 클래스가 이전 클래스와 동일한 패키지 멤버 내에 있지 않으면 개인 멤버는 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="603c087e553c404966d23a0567bdcc13996bea64" translate="yes" xml:space="preserve">
          <source>If the new lookup class, the old lookup class and the previous lookup class are all in different modules i.e. teleporting to a third module, all access modes are lost.</source>
          <target state="translated">새 조회 클래스, 이전 조회 클래스 및 이전 조회 클래스가 모두 다른 모듈에있는 경우, 즉 세 번째 모듈로 텔레포트하면 모든 액세스 모드가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="fe55e352ffb78a39a10dfbfe04744d52fb7c8ef9" translate="yes" xml:space="preserve">
          <source>If the new lookup object has &lt;a href=&quot;#UNCONDITIONAL&quot;&gt;&lt;code&gt;UNCONDITIONAL&lt;/code&gt;&lt;/a&gt; bit, the new previous lookup class is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">새 조회 개체에 &lt;a href=&quot;#UNCONDITIONAL&quot;&gt; &lt;code&gt;UNCONDITIONAL&lt;/code&gt; &lt;/a&gt; 비트가있는 경우 새 이전 조회 클래스는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cacfac52fe886f7cd2e9a3abcbc070941615f373" translate="yes" xml:space="preserve">
          <source>If the new maximum value is different from the previous maximum value, all change listeners are notified.</source>
          <target state="translated">If the new maximum value is different from the previous maximum value, all change listeners are notified.</target>
        </trans-unit>
        <trans-unit id="86bb426f7dca2fb9a6984cb3ba264576f8178a89" translate="yes" xml:space="preserve">
          <source>If the new minimum value is different from the previous minimum value, all change listeners are notified.</source>
          <target state="translated">If the new minimum value is different from the previous minimum value, all change listeners are notified.</target>
        </trans-unit>
        <trans-unit id="5c61d4985d9e12a6258d359254a6ef98f882749e" translate="yes" xml:space="preserve">
          <source>If the new value is different from the previous value, all change listeners are notified.</source>
          <target state="translated">If the new value is different from the previous value, all change listeners are notified.</target>
        </trans-unit>
        <trans-unit id="dd3bd21f414045efb5b6e0572af661119b6ef82c" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigDecimal&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/bigdecimal#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigDecimal&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/bigdecimal#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt; constructor.</target>
        </trans-unit>
        <trans-unit id="070950b6983687a52f5c8a4982aa2eebcfd77d61" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigDecimal&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/bigdecimal#BigDecimal-java.lang.String-&quot;&gt;&lt;code&gt;BigDecimal(String)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Decimal-regex&quot;&gt;&lt;i&gt;Decimal&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 모든 그룹 구분 기호를 제거하고 ASCII가 아닌 숫자를 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 ASCII 숫자로 매핑 하고 결과 문자열을 &lt;a href=&quot;../math/bigdecimal#BigDecimal-java.lang.String-&quot;&gt; &lt;code&gt;BigDecimal(String)&lt;/code&gt; &lt;/a&gt; 전달하는 것처럼 토큰이 &lt;code&gt;BigDecimal&lt;/code&gt; 값으로 변환됩니다. (문자열) 생성자.</target>
        </trans-unit>
        <trans-unit id="efd903809d871bfd2261f9bb7c6f8847849f99dc" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;double&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/double#parseDouble(java.lang.String)&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/double#parseDouble(java.lang.String)&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;double&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/double#parseDouble(java.lang.String)&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; &lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/double#parseDouble(java.lang.String)&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; &lt;/a&gt; as appropriate.</target>
        </trans-unit>
        <trans-unit id="e2b55b595ce54b4c7a0ff65ce30ecb0da6b4383c" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;double&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt;&lt;code&gt;Double.parseDouble&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII가 아닌 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;double&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음수 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 추가하고 결과 문자열을 &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; 로&lt;/a&gt; 전달하십시오 . 토큰이 지역화 된 NaN 또는 무한대 문자열과 일치하면 &quot;Nan&quot;또는 &quot;Infinity&quot;가 &lt;a href=&quot;../lang/double#parseDouble-java.lang.String-&quot;&gt; &lt;code&gt;Double.parseDouble&lt;/code&gt; &lt;/a&gt; 에 적절하게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="3eb97346bea3b5a1c66d1ff73d9a7571c94316bf" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;float&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/float#parseFloat(java.lang.String)&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/float#parseFloat(java.lang.String)&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;float&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/float#parseFloat(java.lang.String)&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; &lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/float#parseFloat(java.lang.String)&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; &lt;/a&gt; as appropriate.</target>
        </trans-unit>
        <trans-unit id="6a79c16b442949a70d19c9e0f0f3c3e6d85edf9f" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;float&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt;. If the token matches the localized NaN or infinity strings, then either &quot;Nan&quot; or &quot;Infinity&quot; is passed to &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt;&lt;code&gt;Float.parseFloat&lt;/code&gt;&lt;/a&gt; as appropriate.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Float-regex&quot;&gt;&lt;i&gt;Float&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII 이외의 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;float&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음의 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 앞에두고 결과 문자열을 &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; 로&lt;/a&gt; 전달합니다 . 토큰이 지역화 된 NaN 또는 무한대 문자열과 일치하면 &quot;Nan&quot;또는 &quot;Infinity&quot;가 &lt;a href=&quot;../lang/float#parseFloat-java.lang.String-&quot;&gt; &lt;code&gt;Float.parseFloat&lt;/code&gt; &lt;/a&gt; 에 적절하게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d2ff6a2387c543b478a622ed06f1bb7df0d7421" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigInteger&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/biginteger#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;BigInteger(String, int)&lt;/code&gt;&lt;/a&gt; constructor with the specified radix.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigInteger&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/biginteger#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;BigInteger(String, int)&lt;/code&gt; &lt;/a&gt; constructor with the specified radix.</target>
        </trans-unit>
        <trans-unit id="1a4727cf6304247402307e6eaca3eff6d0258644" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;BigInteger&lt;/code&gt; value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, and passing the resulting string to the &lt;a href=&quot;../math/biginteger#BigInteger-java.lang.String-&quot;&gt;&lt;code&gt;BigInteger(String, int)&lt;/code&gt;&lt;/a&gt; constructor with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 모든 그룹 구분 기호를 제거하고 ASCII가 아닌 숫자를 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 ASCII 숫자로 맵핑 하고 결과 문자열을 &lt;a href=&quot;../math/biginteger#BigInteger-java.lang.String-&quot;&gt; &lt;code&gt;BigInteger(String, int)&lt;/code&gt; &lt;/a&gt; 전달하는 것처럼 토큰이 &lt;code&gt;BigInteger&lt;/code&gt; 값으로 변환됩니다. 기수가 지정된 (String, int) 생성자</target>
        </trans-unit>
        <trans-unit id="fac93df718c735e73535bc4d3d4b9324ef4c5caf" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;byte&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/byte#parseByte(java.lang.String,int)&quot;&gt;&lt;code&gt;Byte.parseByte&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;byte&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/byte#parseByte(java.lang.String,int)&quot;&gt; &lt;code&gt;Byte.parseByte&lt;/code&gt; &lt;/a&gt; with the specified radix.</target>
        </trans-unit>
        <trans-unit id="12b289473a0cfbe9016bed30eea7221cdd374181" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;byte&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/byte#parseByte-java.lang.String-int-&quot;&gt;&lt;code&gt;Byte.parseByte&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;정수&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII가 아닌 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;byte&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음수 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 앞에 두고 지정된 기수 를 사용하여 결과 문자열을 &lt;a href=&quot;../lang/byte#parseByte-java.lang.String-int-&quot;&gt; &lt;code&gt;Byte.parseByte&lt;/code&gt; 에&lt;/a&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="3589f798ea949bb8459c5766611ecd61d78cc6ed" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;long&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/long#parseLong(java.lang.String,int)&quot;&gt;&lt;code&gt;Long.parseLong&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;long&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/long#parseLong(java.lang.String,int)&quot;&gt; &lt;code&gt;Long.parseLong&lt;/code&gt; &lt;/a&gt; with the specified radix.</target>
        </trans-unit>
        <trans-unit id="b349deb1d290eaa1752d8feff84d8af8caefc093" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;long&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/long#parseLong-java.lang.String-int-&quot;&gt;&lt;code&gt;Long.parseLong&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;정수&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII 이외의 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;long&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음의 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 앞에 두고 지정된 기수 를 사용하여 결과 문자열을 &lt;a href=&quot;../lang/long#parseLong-java.lang.String-int-&quot;&gt; &lt;code&gt;Long.parseLong&lt;/code&gt; 에&lt;/a&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="b68e5822216b2d7fa77ca18249aad6224e4ec92a" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;short&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/short#parseShort(java.lang.String,int)&quot;&gt;&lt;code&gt;Short.parseShort&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;short&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/short#parseShort(java.lang.String,int)&quot;&gt; &lt;code&gt;Short.parseShort&lt;/code&gt; &lt;/a&gt; with the specified radix.</target>
        </trans-unit>
        <trans-unit id="cde2372e3435e6554a5b5741f761096f7eea5fcf" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into a &lt;code&gt;short&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/short#parseShort-java.lang.String-int-&quot;&gt;&lt;code&gt;Short.parseShort&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;정수&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII 이외의 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;short&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음의 접 두부와 접미 부가있는 경우 음수 부호 (-)를 앞에 두고 지정된 기수 를 사용하여 결과 문자열을 &lt;a href=&quot;../lang/short#parseShort-java.lang.String-int-&quot;&gt; &lt;code&gt;Short.parseShort&lt;/code&gt; 에&lt;/a&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="d5aa82aacf2b2fd955865f9e55427bb7ea1a38f3" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into an &lt;code&gt;int&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/integer#parseInt(java.lang.String,int)&quot;&gt;&lt;code&gt;Integer.parseInt&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into an &lt;code&gt;int&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit(char,int)&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/integer#parseInt(java.lang.String,int)&quot;&gt; &lt;code&gt;Integer.parseInt&lt;/code&gt; &lt;/a&gt; with the specified radix.</target>
        </trans-unit>
        <trans-unit id="e2e6b9af16a7a0f10ca898c5788d2527ee4c8561" translate="yes" xml:space="preserve">
          <source>If the next token matches the &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;Integer&lt;/i&gt;&lt;/a&gt; regular expression defined above then the token is converted into an &lt;code&gt;int&lt;/code&gt; value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt;&lt;code&gt;Character.digit&lt;/code&gt;&lt;/a&gt;, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to &lt;a href=&quot;../lang/integer#parseInt-java.lang.String-int-&quot;&gt;&lt;code&gt;Integer.parseInt&lt;/code&gt;&lt;/a&gt; with the specified radix.</source>
          <target state="translated">다음 토큰이 위에 정의 된 &lt;a href=&quot;#Integer-regex&quot;&gt;&lt;i&gt;정수&lt;/i&gt;&lt;/a&gt; 정규식 과 일치하면 토큰은 모든 로케일 특정 접두어, 그룹 구분 기호 및 로케일 특정 접미 부를 제거한 다음 ASCII 이외의 숫자를 ASCII 숫자로 &lt;a href=&quot;../lang/character#digit-char-int-&quot;&gt; &lt;code&gt;Character.digit&lt;/code&gt; &lt;/a&gt; 를 통해 맵핑하는 것처럼 &lt;code&gt;int&lt;/code&gt; 값으로 변환됩니다. 로케일 특정 음수 접 두부 및 접미 부가있는 경우 음수 부호 (-)를 앞에 두고 지정된 기수 를 사용하여 결과 문자열을 &lt;a href=&quot;../lang/integer#parseInt-java.lang.String-int-&quot;&gt; &lt;code&gt;Integer.parseInt&lt;/code&gt; 에&lt;/a&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="f51b9968b885ef1885dbe34821dc425278cfb9c3" translate="yes" xml:space="preserve">
          <source>If the node being visited has more than one child, the result will be determined by calling &lt;code&gt;scan&lt;/code&gt; each child in turn, and then combining the result of each scan after the first with the cumulative result so far, as determined by the &lt;a href=&quot;#reduce(R,R)&quot;&gt;&lt;code&gt;reduce(R, R)&lt;/code&gt;&lt;/a&gt; method. Each child may be either a simple node of a list of nodes. The default behavior of the &lt;code&gt;reduce&lt;/code&gt; method is such that the result of the visitXYZ method will be the result of the last child scanned.</source>
          <target state="translated">노드가 호출 이상의 어린이보다 결과가 결정된다있다 방문한 경우 &lt;code&gt;scan&lt;/code&gt; 에 의해 결정되는 바와 같이, 지금까지의 누적 된 결과와 제 후의 각 검사의 결과를 조합 한 후, 다시 어린이 및 &lt;a href=&quot;#reduce(R,R)&quot;&gt; &lt;code&gt;reduce(R, R)&lt;/code&gt; &lt;/a&gt; 방법. 각 자식은 노드 목록의 단순 노드 일 수 있습니다. &lt;code&gt;reduce&lt;/code&gt; 메서드 의 기본 동작은 visitXYZ 메서드의 결과가 마지막으로 스캔 된 자식의 결과가되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9c52658cbffb38373b711425c29a4d9b7f3c889c" translate="yes" xml:space="preserve">
          <source>If the node being visited has no children, the result will be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">방문중인 노드에 자식이 없으면 결과는 &lt;code&gt;null&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="77bd3efb080ea23321f595eec5e2b18f84442b5f" translate="yes" xml:space="preserve">
          <source>If the node being visited has one child, the result will be the result of calling &lt;code&gt;scan&lt;/code&gt; on that child. The child may be a simple node or itself a list of nodes.</source>
          <target state="translated">방문중인 노드에 자식이 하나있는 경우 결과는 해당 자식 에 대해 &lt;code&gt;scan&lt;/code&gt; 을 호출 한 결과입니다 . 자식은 단순 노드이거나 그 자체가 노드 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50647ef6cfa173ffb331678172077c93b906dc08" translate="yes" xml:space="preserve">
          <source>If the number is followed by a colon, it is regarded as an hour, unless an hour has already been recognized, in which case it is regarded as a minute.</source>
          <target state="translated">숫자 뒤에 콜론이 오는 경우, 시간이 이미 인식되지 않은 경우 1 시간으로 간주되며,이 경우 1 분으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2185b02dab1b8be5d039095147b6a86e141a45f4" translate="yes" xml:space="preserve">
          <source>If the number is followed by a slash, it is regarded as a month (it is decreased by 1 to produce a number in the range &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;11&lt;/code&gt;), unless a month has already been recognized, in which case it is regarded as a day of the month.</source>
          <target state="translated">숫자 뒤에 슬래시가 있으면 , 한 달이 이미 인식되지 않은 한, 한 달로 간주됩니다 ( &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;11&lt;/code&gt; 사이 의 숫자를 생성하기 위해 1 씩 감소됨 ). 이달의.</target>
        </trans-unit>
        <trans-unit id="24c204655d0c4e49fdb27ee92ac3fcb02b0bfac3" translate="yes" xml:space="preserve">
          <source>If the number is followed by whitespace, a comma, a hyphen, or end of string, then if an hour has been recognized but not a minute, it is regarded as a minute; otherwise, if a minute has been recognized but not a second, it is regarded as a second; otherwise, it is regarded as a day of the month.</source>
          <target state="translated">숫자 다음에 공백, 쉼표, 하이픈 또는 문자열 끝이 오는 경우 시간이 인식되었지만 1 분이 아닌 경우 1 분으로 간주됩니다. 그렇지 않으면 1 분이 인식되었지만 1 초가 인식되지 않으면 1 초로 간주됩니다. 그렇지 않으면 월의 일로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6291ad948edcd3847ce9e2ff7d5cea133a2c5935" translate="yes" xml:space="preserve">
          <source>If the number of arguments in the specified constructor is non-zero and the class of &lt;code&gt;oldInstance&lt;/code&gt; explicitly declares an &quot;equals&quot; method this method returns the value of &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt;.</source>
          <target state="translated">If the number of arguments in the specified constructor is non-zero and the class of &lt;code&gt;oldInstance&lt;/code&gt; explicitly declares an &quot;equals&quot; method this method returns the value of &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28b1d7370c2a1b58a891d34fad7ee082b38756d3" translate="yes" xml:space="preserve">
          <source>If the number of arguments in the specified constructor is non-zero and the class of &lt;code&gt;oldInstance&lt;/code&gt; explicitly declares an &quot;equals&quot; method this method returns the value of &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt;. Otherwise, this method uses the superclass's definition which returns true if the classes of the two instances are equal.</source>
          <target state="translated">지정된 생성자의 인수 수가 0이 &lt;code&gt;oldInstance&lt;/code&gt; 클래스가 명시 적으로 &quot;equals&quot;메소드를 선언하면이 메소드는 &lt;code&gt;oldInstance.equals(newInstance)&lt;/code&gt; 의 값을 리턴합니다 . 그렇지 않은 경우,이 메소드는 슈퍼 클래스 정의를 사용하여 두 인스턴스의 클래스가 동일한 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c24fe213e64505f30b52e8476bd73dee9a4a91ca" translate="yes" xml:space="preserve">
          <source>If the number of bands is more than one, the SampleModel will be a SinglePixelPackedSampleModel, with each band having bitsPerBand bits. In either case, the requirements on dataType and bitsPerBand imposed by the corresponding SampleModel must be met.</source>
          <target state="translated">If the number of bands is more than one, the SampleModel will be a SinglePixelPackedSampleModel, with each band having bitsPerBand bits. In either case, the requirements on dataType and bitsPerBand imposed by the corresponding SampleModel must be met.</target>
        </trans-unit>
        <trans-unit id="d4af9d2d4726a8f3ade67f849e06bc1d1ab1564a" translate="yes" xml:space="preserve">
          <source>If the number of formal parameters required by the underlying constructor is 0, the supplied &lt;code&gt;initargs&lt;/code&gt; array may be of length 0 or null.</source>
          <target state="translated">기본 생성자가 요구하는 형식 매개 변수의 수가 0 인 경우 제공된 &lt;code&gt;initargs&lt;/code&gt; 배열의 길이는 0이거나 널일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a45750d8cf5475f9813ae9cb718f088a466add3" translate="yes" xml:space="preserve">
          <source>If the number of formal parameters required by the underlying method is 0, the supplied &lt;code&gt;args&lt;/code&gt; array may be of length 0 or null.</source>
          <target state="translated">기본이되는 메소드에 필요한 형식 매개 변수의 수가 0 인 경우, 제공된 &lt;code&gt;args&lt;/code&gt; 배열의 길이는 0이거나 널일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6aa952eaa67d2b3ae4ac72907b831466314c9b3" translate="yes" xml:space="preserve">
          <source>If the number of pattern letters is 4 or more, &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown when constructing a &lt;code&gt;
     SimpleDateFormat&lt;/code&gt; or &lt;a href=&quot;#applyPattern(java.lang.String)&quot;&gt;applying a pattern&lt;/a&gt;.</source>
          <target state="translated">If the number of pattern letters is 4 or more, &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; is thrown when constructing a &lt;code&gt; SimpleDateFormat&lt;/code&gt; or &lt;a href=&quot;#applyPattern(java.lang.String)&quot;&gt;applying a pattern&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="aecea4a5924a64f71d7845e41d1c3b018c067a01" translate="yes" xml:space="preserve">
          <source>If the number of pattern letters is 4 or more, &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; is thrown when constructing a &lt;code&gt;SimpleDateFormat&lt;/code&gt; or &lt;a href=&quot;simpledateformat#applyPattern-java.lang.String-&quot;&gt;applying a pattern&lt;/a&gt;.</source>
          <target state="translated">패턴 문자 수가 4 개 이상인 경우 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 을 구성 하거나 &lt;a href=&quot;simpledateformat#applyPattern-java.lang.String-&quot;&gt;패턴을 적용&lt;/a&gt; 할 때 &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; &lt;/a&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="40ebc6195d83e88d053f6b7f4d083dcca34d15e6" translate="yes" xml:space="preserve">
          <source>If the number of readers is now zero then the lock is made available for write lock attempts.</source>
          <target state="translated">판독기 수가 이제 0이면 쓰기 잠금 시도에 잠금을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57761664428c22b67f54914f3d10f06ea9626ec9" translate="yes" xml:space="preserve">
          <source>If the number of readers is now zero then the lock is made available for write lock attempts. If the current thread does not hold this lock then &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt;&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;&lt;/a&gt; is thrown.</source>
          <target state="translated">If the number of readers is now zero then the lock is made available for write lock attempts. If the current thread does not hold this lock then &lt;a href=&quot;../../../lang/illegalmonitorstateexception&quot;&gt; &lt;code&gt;IllegalMonitorStateException&lt;/code&gt; &lt;/a&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="9539dfa1e1c4ed8a395e2b48d8e6f0bcbf6c71d0" translate="yes" xml:space="preserve">
          <source>If the object does not have a requested attribute, that nonexistent attribute will be ignored. Those requested attributes that the object does have will be returned.</source>
          <target state="translated">객체에 요청 된 속성이 없으면 존재하지 않는 속성은 무시됩니다. 객체가 요청한 속성이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ba188f9b3d08b409858ffc14dad0538d6c066ad5" translate="yes" xml:space="preserve">
          <source>If the object does not have an attribute specified, the directory will ignore the nonexistent attribute and return those requested attributes that the object does have.</source>
          <target state="translated">객체에 속성이 지정되어 있지 않으면 디렉토리는 존재하지 않는 속성을 무시하고 해당 객체에 요청 된 속성을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1d2b3a1e7cd5b23b39d1f5133dc5c01a091b5bb9" translate="yes" xml:space="preserve">
          <source>If the object does not have the attribute specified, the directory will ignore the nonexistent attribute and return the requested attributes that the object does have.</source>
          <target state="translated">오브젝트에 속성이 지정되지 않은 경우 디렉토리는 존재하지 않는 속성을 무시하고 오브젝트에있는 요청 된 속성을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f7640b018347f47539ec443ff012615b370426e4" translate="yes" xml:space="preserve">
          <source>If the object has a &lt;code&gt;getPropertyChangeListeners&lt;/code&gt; method then the array returned could be a mixture of &lt;code&gt;PropertyChangeListener&lt;/code&gt; and &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; objects.</source>
          <target state="translated">객체에 &lt;code&gt;getPropertyChangeListeners&lt;/code&gt; 메소드 가있는 경우 리턴 된 배열은 &lt;code&gt;PropertyChangeListener&lt;/code&gt; 및 &lt;code&gt;PropertyChangeListenerProxy&lt;/code&gt; 객체 의 혼합 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3efaaa6db916f5e8dd0c50701e6e2af84aea78e5" translate="yes" xml:space="preserve">
          <source>If the object has a &lt;code&gt;getVetoableChangeListeners&lt;/code&gt; method then the array returned could be a mixture of &lt;code&gt;VetoableChangeListener&lt;/code&gt; and &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; objects.</source>
          <target state="translated">객체에 &lt;code&gt;getVetoableChangeListeners&lt;/code&gt; 메소드 가있는 경우 반환 된 배열은 &lt;code&gt;VetoableChangeListener&lt;/code&gt; 및 &lt;code&gt;VetoableChangeListenerProxy&lt;/code&gt; 객체 의 혼합 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0000bd104b2da8f8fad009e5ad16ebe1912acd0" translate="yes" xml:space="preserve">
          <source>If the object has a custom mapping (is of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;), the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write it to the SQL data stream. If, on the other hand, the object is of a class implementing &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;, &lt;code&gt;NClob&lt;/code&gt;, &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a value of the corresponding SQL type.</source>
          <target state="translated">If the object has a custom mapping (is of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt; ), the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write it to the SQL data stream. If, on the other hand, the object is of a class implementing &lt;code&gt;Ref&lt;/code&gt; , &lt;code&gt;Blob&lt;/code&gt; , &lt;code&gt;Clob&lt;/code&gt; , &lt;code&gt;NClob&lt;/code&gt; , &lt;code&gt;Struct&lt;/code&gt; , &lt;code&gt;java.net.URL&lt;/code&gt; , or &lt;code&gt;Array&lt;/code&gt; , the driver should pass it to the database as a value of the corresponding SQL type.</target>
        </trans-unit>
        <trans-unit id="c633f6da7ab2fee69bd882fac3b3abc472fa5a8a" translate="yes" xml:space="preserve">
          <source>If the object is a &lt;code&gt;DirContext&lt;/code&gt;, any existing attributes associated with the name are replaced with those of the object. Otherwise, any existing attributes associated with the name remain unchanged.</source>
          <target state="translated">객체가 &lt;code&gt;DirContext&lt;/code&gt; 인 경우, 이름과 연관된 기존 속성 이 객체 의 속성으로 대체됩니다. 그렇지 않으면 이름과 연관된 기존 속성은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80b22f0afff8183f235d7fd8ee96b05798cb0cf3" translate="yes" xml:space="preserve">
          <source>If the object is of a class implementing &lt;code&gt;SQLData&lt;/code&gt;, the rowset should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write the object to an &lt;code&gt;SQLOutput&lt;/code&gt; data stream. If, on the other hand, the object is of a class implementing &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;, &lt;code&gt;NClob&lt;/code&gt;, &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a value of the corresponding SQL type.</source>
          <target state="translated">If the object is of a class implementing &lt;code&gt;SQLData&lt;/code&gt; , the rowset should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write the object to an &lt;code&gt;SQLOutput&lt;/code&gt; data stream. If, on the other hand, the object is of a class implementing &lt;code&gt;Ref&lt;/code&gt; , &lt;code&gt;Blob&lt;/code&gt; , &lt;code&gt;Clob&lt;/code&gt; , &lt;code&gt;NClob&lt;/code&gt; , &lt;code&gt;Struct&lt;/code&gt; , &lt;code&gt;java.net.URL&lt;/code&gt; , or &lt;code&gt;Array&lt;/code&gt; , the driver should pass it to the database as a value of the corresponding SQL type.</target>
        </trans-unit>
        <trans-unit id="4f5b3142d8650d58dfbe46a9e556320ac2bd2e7d" translate="yes" xml:space="preserve">
          <source>If the offset is not available then the format is complete.</source>
          <target state="translated">오프셋을 사용할 수 없으면 포맷이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="2519e323e000b11bce96906bcfd196efd2dc89f9" translate="yes" xml:space="preserve">
          <source>If the offset is not available to format or parse then the format is complete.</source>
          <target state="translated">오프셋을 포맷하거나 파싱 할 수없는 경우 포맷이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="83f30839a17edd7cfbb33b3121aaa65bc609378b" translate="yes" xml:space="preserve">
          <source>If the old configuration defined a level for a logger, and the resulting configuration doesn't, then this change will not be propagated to existing loggers, if any. To completely replace a configuration - the caller should therefore call &lt;a href=&quot;#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; to empty the current configuration, before calling &lt;code&gt;updateConfiguration&lt;/code&gt;.</source>
          <target state="translated">If the old configuration defined a level for a logger, and the resulting configuration doesn't, then this change will not be propagated to existing loggers, if any. To completely replace a configuration - the caller should therefore call &lt;a href=&quot;#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; to empty the current configuration, before calling &lt;code&gt;updateConfiguration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50ff0a2d4c9016d9ad590b91ba476d4fd341c512" translate="yes" xml:space="preserve">
          <source>If the old configuration defined some handlers for a logger, and the resulting configuration doesn't, if that logger exists, its handlers will be removed and closed.</source>
          <target state="translated">If the old configuration defined some handlers for a logger, and the resulting configuration doesn't, if that logger exists, its handlers will be removed and closed.</target>
        </trans-unit>
        <trans-unit id="6272ea50e04f5a7acc04b3b46505bc6dc3d28d4e" translate="yes" xml:space="preserve">
          <source>If the old lookup class is in a &lt;a href=&quot;../module#isNamed()&quot;&gt;&lt;code&gt;named&lt;/code&gt;&lt;/a&gt; module, and the new lookup class is in a different module &lt;code&gt;M&lt;/code&gt;, then no members, not even public members in &lt;code&gt;M&lt;/code&gt;'s exported packages, will be accessible. The exception to this is when this lookup is &lt;a href=&quot;methodhandles#publicLookup()&quot;&gt;&lt;code&gt;publicLookup&lt;/code&gt;&lt;/a&gt;, in which case &lt;code&gt;PUBLIC&lt;/code&gt; access is not lost.</source>
          <target state="translated">If the old lookup class is in a &lt;a href=&quot;../module#isNamed()&quot;&gt; &lt;code&gt;named&lt;/code&gt; &lt;/a&gt; module, and the new lookup class is in a different module &lt;code&gt;M&lt;/code&gt; , then no members, not even public members in &lt;code&gt;M&lt;/code&gt; 's exported packages, will be accessible. The exception to this is when this lookup is &lt;a href=&quot;methodhandles#publicLookup()&quot;&gt; &lt;code&gt;publicLookup&lt;/code&gt; &lt;/a&gt;, in which case &lt;code&gt;PUBLIC&lt;/code&gt; access is not lost.</target>
        </trans-unit>
        <trans-unit id="befd5d850eccad70e74cebb655eecf125efcc787" translate="yes" xml:space="preserve">
          <source>If the old lookup class is in an unnamed module, and the new lookup class is a different module then &lt;a href=&quot;#MODULE&quot;&gt;&lt;code&gt;MODULE&lt;/code&gt;&lt;/a&gt; access is lost.</source>
          <target state="translated">If the old lookup class is in an unnamed module, and the new lookup class is a different module then &lt;a href=&quot;#MODULE&quot;&gt; &lt;code&gt;MODULE&lt;/code&gt; &lt;/a&gt; access is lost.</target>
        </trans-unit>
        <trans-unit id="4c280c860cb9f7effbb5d1573c9db972ff6dade1" translate="yes" xml:space="preserve">
          <source>If the opaque representation of a key (see &lt;a href=&quot;../key&quot;&gt;&lt;code&gt;Key&lt;/code&gt;&lt;/a&gt;) can be transformed (see &lt;a href=&quot;../keyfactory&quot;&gt;&lt;code&gt;KeyFactory&lt;/code&gt;&lt;/a&gt;) into this key specification (or a subclass of it), &lt;code&gt;getFormat&lt;/code&gt; called on the opaque key returns the same value as the &lt;code&gt;getFormat&lt;/code&gt; method of this key specification.</source>
          <target state="translated">키 (볼의 불투명 표현하면 &lt;a href=&quot;../key&quot;&gt; &lt;code&gt;Key&lt;/code&gt; &lt;/a&gt; ) (참조 변형 될 수 &lt;a href=&quot;../keyfactory&quot;&gt; &lt;code&gt;KeyFactory&lt;/code&gt; 에가&lt;/a&gt; 이 키 지정 (또는 서브 클래스)으로) &lt;code&gt;getFormat&lt;/code&gt; 는 AS 동일한 값 불투명 키 복귀 호출 &lt;code&gt;getFormat&lt;/code&gt; 이 키 지정 방법.</target>
        </trans-unit>
        <trans-unit id="26d2d84804d4a76528e348ab91515fb0509d099f" translate="yes" xml:space="preserve">
          <source>If the operating system does not support the creation of processes, an &lt;a href=&quot;unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">If the operating system does not support the creation of processes, an &lt;a href=&quot;unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; &lt;/a&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="7608927d8184c584cd9d11cef0e073e1bb7bf926" translate="yes" xml:space="preserve">
          <source>If the operation is a &lt;code&gt;draw(Shape)&lt;/code&gt; operation, then the &lt;a href=&quot;stroke#createStrokedShape(java.awt.Shape)&quot;&gt;&lt;code&gt;createStrokedShape&lt;/code&gt;&lt;/a&gt; method on the current &lt;a href=&quot;stroke&quot;&gt;&lt;code&gt;Stroke&lt;/code&gt;&lt;/a&gt; attribute in the &lt;code&gt;Graphics2D&lt;/code&gt; context is used to construct a new &lt;code&gt;Shape&lt;/code&gt; object that contains the outline of the specified &lt;code&gt;Shape&lt;/code&gt;.</source>
          <target state="translated">If the operation is a &lt;code&gt;draw(Shape)&lt;/code&gt; operation, then the &lt;a href=&quot;stroke#createStrokedShape(java.awt.Shape)&quot;&gt; &lt;code&gt;createStrokedShape&lt;/code&gt; &lt;/a&gt; method on the current &lt;a href=&quot;stroke&quot;&gt; &lt;code&gt;Stroke&lt;/code&gt; &lt;/a&gt; attribute in the &lt;code&gt;Graphics2D&lt;/code&gt; context is used to construct a new &lt;code&gt;Shape&lt;/code&gt; object that contains the outline of the specified &lt;code&gt;Shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3a6f1065b50c79f203f06252e6050cc498ea0ba" translate="yes" xml:space="preserve">
          <source>If the original type and new type are equal, returns &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">원래의 타입과 새로운 타입이 같은 경우는 &lt;code&gt;this&lt;/code&gt; 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="15d571df526b560a24fbbc6f542b12d585fc4182" translate="yes" xml:space="preserve">
          <source>If the original type and new type are equal, returns target.</source>
          <target state="translated">원래 형식과 새 형식이 같으면 target을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d132531fc669e517a82a3d82919ac097d06f2259" translate="yes" xml:space="preserve">
          <source>If the other &lt;code&gt;StringJoiner&lt;/code&gt; is using a different delimiter, then elements from the other &lt;code&gt;StringJoiner&lt;/code&gt; are concatenated with that delimiter and the result is appended to this &lt;code&gt;StringJoiner&lt;/code&gt; as a single element.</source>
          <target state="translated">다른 경우 &lt;code&gt;StringJoiner&lt;/code&gt; 가 다른 구분자를 사용하고 다른 쪽의 요소 &lt;code&gt;StringJoiner&lt;/code&gt; 은 그 분리와 연결되며, 그 결과이 추가된다 &lt;code&gt;StringJoiner&lt;/code&gt; 단일 요소로.</target>
        </trans-unit>
        <trans-unit id="613b81a7888d7292adb45fa99af137ae84272f3b" translate="yes" xml:space="preserve">
          <source>If the output is an &lt;code&gt;ImageOutputStream&lt;/code&gt;, the existing contents of the output prior to the current seek position are flushed, and need not be readable or writable. If the format requires that &lt;code&gt;endWriteSequence&lt;/code&gt; be able to rewind to patch up the header information, such as for a sequence of images in a single TIFF file, then the metadata written by this method must remain in a writable portion of the stream. Other formats may flush the stream after this method and after each image.</source>
          <target state="translated">출력이 &lt;code&gt;ImageOutputStream&lt;/code&gt; 인 경우, 현재 탐색 위치 이전의 기존 출력 내용이 플러시되므로 읽을 수 있거나 쓸 수 없습니다. 형식에서 &lt;code&gt;endWriteSequence&lt;/code&gt; 가 단일 TIFF 파일의 이미지 시퀀스와 같이 헤더 정보를 패치하기 위해 되감기를 필요로하는 경우이 방법으로 작성된 메타 데이터는 스트림의 쓰기 가능한 부분에 남아 있어야합니다. 이 방법 이후와 각 이미지 후에 다른 형식으로 스트림을 플러시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08f1019969adaf9147a2917277718270a6117c0e" translate="yes" xml:space="preserve">
          <source>If the overall view is represented by many pieces (which is the best situation if one want to be able to change the view and write the least amount of new code), it would be impractical to have a huge number of &lt;code&gt;DocumentListener&lt;/code&gt;s. If each view listened to the model, only a few would actually be interested in the changes broadcasted at any given time. Since the model has no knowledge of views, it has no way to filter the broadcast of change information. The view hierarchy itself is instead responsible for propagating the change information. At any level in the view hierarchy, that view knows enough about its children to best distribute the change information further. Changes are therefore broadcasted starting from the root of the view hierarchy. The methods for doing this are:</source>
          <target state="translated">If the overall view is represented by many pieces (which is the best situation if one want to be able to change the view and write the least amount of new code), it would be impractical to have a huge number of &lt;code&gt;DocumentListener&lt;/code&gt; s. If each view listened to the model, only a few would actually be interested in the changes broadcasted at any given time. Since the model has no knowledge of views, it has no way to filter the broadcast of change information. The view hierarchy itself is instead responsible for propagating the change information. At any level in the view hierarchy, that view knows enough about its children to best distribute the change information further. Changes are therefore broadcasted starting from the root of the view hierarchy. The methods for doing this are:</target>
        </trans-unit>
        <trans-unit id="78a74da7cebb7ba0feae1474dc321fbaaddcde66" translate="yes" xml:space="preserve">
          <source>If the owner document of the &lt;code&gt;DOMStructure&lt;/code&gt; is different than the target document of an &lt;code&gt;XMLSignature&lt;/code&gt;, the &lt;a href=&quot;../dsig/xmlsignature#sign(javax.xml.crypto.dsig.XMLSignContext)&quot;&gt;&lt;code&gt;XMLSignature.sign(XMLSignContext)&lt;/code&gt;&lt;/a&gt; method imports the node into the target document before generating the signature.</source>
          <target state="translated">If the owner document of the &lt;code&gt;DOMStructure&lt;/code&gt; is different than the target document of an &lt;code&gt;XMLSignature&lt;/code&gt; , the &lt;a href=&quot;../dsig/xmlsignature#sign(javax.xml.crypto.dsig.XMLSignContext)&quot;&gt; &lt;code&gt;XMLSignature.sign(XMLSignContext)&lt;/code&gt; &lt;/a&gt; method imports the node into the target document before generating the signature.</target>
        </trans-unit>
        <trans-unit id="fa93ae60cb7452d1a5da6932448d22165c4af9a2" translate="yes" xml:space="preserve">
          <source>If the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt;&quot; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;EntityReference&lt;/code&gt; nodes are serialized as an entity reference of the form &quot; &lt;code&gt;&amp;amp;entityName;&lt;/code&gt;&quot; in the output. Child nodes (the expansion) of the entity reference are ignored. If the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt;&quot; is set to &lt;code&gt;false&lt;/code&gt;, only the children of the entity reference are serialized. &lt;code&gt;EntityReference&lt;/code&gt; nodes with no children (no corresponding &lt;code&gt;Entity&lt;/code&gt; node or the corresponding &lt;code&gt;Entity&lt;/code&gt; nodes have no children) are always serialized.</source>
          <target state="translated">If the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt;&quot; is set to &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;EntityReference&lt;/code&gt; nodes are serialized as an entity reference of the form &quot; &lt;code&gt;&amp;amp;entityName;&lt;/code&gt; &quot; in the output. Child nodes (the expansion) of the entity reference are ignored. If the parameter &quot;&lt;a href=&quot;https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#parameter-entities&quot;&gt;entities&lt;/a&gt;&quot; is set to &lt;code&gt;false&lt;/code&gt; , only the children of the entity reference are serialized. &lt;code&gt;EntityReference&lt;/code&gt; nodes with no children (no corresponding &lt;code&gt;Entity&lt;/code&gt; node or the corresponding &lt;code&gt;Entity&lt;/code&gt; nodes have no children) are always serialized.</target>
        </trans-unit>
        <trans-unit id="bb3ac957b69da27cb19dfba9a08e05602d603ed4" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;isId&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this method declares the specified attribute to be a user-determined ID attribute .</source>
          <target state="translated">If the parameter &lt;code&gt;isId&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; , this method declares the specified attribute to be a user-determined ID attribute .</target>
        </trans-unit>
        <trans-unit id="41c4967bfb211978283a04544f0d61d21594df4d" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;isId&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this method declares the specified attribute to be a user-determined ID attribute . This affects the value of &lt;code&gt;Attr.isId&lt;/code&gt; and the behavior of &lt;code&gt;Document.getElementById&lt;/code&gt;, but does not change any schema that may be in use, in particular this does not affect the &lt;code&gt;Attr.schemaTypeInfo&lt;/code&gt; of the specified &lt;code&gt;Attr&lt;/code&gt; node. Use the value &lt;code&gt;false&lt;/code&gt; for the parameter &lt;code&gt;isId&lt;/code&gt; to undeclare an attribute for being a user-determined ID attribute.</source>
          <target state="translated">If the parameter &lt;code&gt;isId&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; , this method declares the specified attribute to be a user-determined ID attribute . This affects the value of &lt;code&gt;Attr.isId&lt;/code&gt; and the behavior of &lt;code&gt;Document.getElementById&lt;/code&gt; , but does not change any schema that may be in use, in particular this does not affect the &lt;code&gt;Attr.schemaTypeInfo&lt;/code&gt; of the specified &lt;code&gt;Attr&lt;/code&gt; node. Use the value &lt;code&gt;false&lt;/code&gt; for the parameter &lt;code&gt;isId&lt;/code&gt; to undeclare an attribute for being a user-determined ID attribute.</target>
        </trans-unit>
        <trans-unit id="170b05155c2fff91755b761f2183540c80aa9948" translate="yes" xml:space="preserve">
          <source>If the parameter does not have a user-defined or &lt;code&gt;REF&lt;/code&gt; type, the given &lt;code&gt;typeName&lt;/code&gt; parameter is ignored.</source>
          <target state="translated">If the parameter does not have a user-defined or &lt;code&gt;REF&lt;/code&gt; type, the given &lt;code&gt;typeName&lt;/code&gt; parameter is ignored.</target>
        </trans-unit>
        <trans-unit id="18c245a7f9ecfcc3d829455a0e0abe420832d2a6" translate="yes" xml:space="preserve">
          <source>If the parameter is negative or beyond the length of the document, the caret is placed at the beginning or at the end, respectively.</source>
          <target state="translated">If the parameter is negative or beyond the length of the document, the caret is placed at the beginning or at the end, respectively.</target>
        </trans-unit>
        <trans-unit id="8249c3394f9981a5c6710331cd767e75fd4509a3" translate="yes" xml:space="preserve">
          <source>If the parameters exist in XML form, the &lt;a href=&quot;#init(javax.xml.crypto.XMLStructure,javax.xml.crypto.XMLCryptoContext)&quot;&gt;&lt;code&gt;init(XMLStructure, XMLCryptoContext)&lt;/code&gt;&lt;/a&gt; method should be used to initialize the &lt;code&gt;TransformService&lt;/code&gt;.</source>
          <target state="translated">If the parameters exist in XML form, the &lt;a href=&quot;#init(javax.xml.crypto.XMLStructure,javax.xml.crypto.XMLCryptoContext)&quot;&gt; &lt;code&gt;init(XMLStructure, XMLCryptoContext)&lt;/code&gt; &lt;/a&gt; method should be used to initialize the &lt;code&gt;TransformService&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a23d99be271523bb82052d907e3db3f2dbe428c3" translate="yes" xml:space="preserve">
          <source>If the parent is specified as &lt;code&gt;null&lt;/code&gt; (for the bootstrap class loader) then there is no guarantee that all platform classes are visible.</source>
          <target state="translated">If the parent is specified as &lt;code&gt;null&lt;/code&gt; (for the bootstrap class loader) then there is no guarantee that all platform classes are visible.</target>
        </trans-unit>
        <trans-unit id="a54204b2e99d7d060bb6235389e37beb7f049e32" translate="yes" xml:space="preserve">
          <source>If the parse completes without reading the entire length of the text, or a problem occurs during parsing or merging, then an exception is thrown.</source>
          <target state="translated">텍스트의 전체 길이를 읽지 않고 구문 분석이 완료되거나 구문 분석 또는 병합 중에 문제가 발생하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="966672a90f95f435f932b758ca1be0521185c7b2" translate="yes" xml:space="preserve">
          <source>If the parsed set of schemas includes error(s) as specified in the section 5.1 of the XML Schema spec, then the error must be reported to the &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the parsed set of schemas includes error(s) as specified in the section 5.1 of the XML Schema spec, then the error must be reported to the &lt;a href=&quot;../../../org/xml/sax/errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1ec9adbbdbd63160216787347e59341d3fd1989d" translate="yes" xml:space="preserve">
          <source>If the parser has not read a declaration for the attribute, or if the parser does not report attribute types, then it must return the value &quot;CDATA&quot; as stated in the XML 1.0 Recommendation (clause 3.3.3, &quot;Attribute-Value Normalization&quot;).</source>
          <target state="translated">If the parser has not read a declaration for the attribute, or if the parser does not report attribute types, then it must return the value &quot;CDATA&quot; as stated in the XML 1.0 Recommendation (clause 3.3.3, &quot;Attribute-Value Normalization&quot;).</target>
        </trans-unit>
        <trans-unit id="951efcf89e37dc37c87ce691e02e23742bc9d33e" translate="yes" xml:space="preserve">
          <source>If the parser has not read a declaration for the attribute, or if the parser does not report attribute types, then it must return the value &quot;CDATA&quot; as stated in the XML 1.0 Recommentation (clause 3.3.3, &quot;Attribute-Value Normalization&quot;).</source>
          <target state="translated">If the parser has not read a declaration for the attribute, or if the parser does not report attribute types, then it must return the value &quot;CDATA&quot; as stated in the XML 1.0 Recommentation (clause 3.3.3, &quot;Attribute-Value Normalization&quot;).</target>
        </trans-unit>
        <trans-unit id="ee0a795fb5ae860545c1f74e1564f3e8fc66414d" translate="yes" xml:space="preserve">
          <source>If the parser or application needs to include information about a specific location in an XML document, it should use the &lt;a href=&quot;saxparseexception&quot;&gt;&lt;code&gt;SAXParseException&lt;/code&gt;&lt;/a&gt; subclass.</source>
          <target state="translated">If the parser or application needs to include information about a specific location in an XML document, it should use the &lt;a href=&quot;saxparseexception&quot;&gt; &lt;code&gt;SAXParseException&lt;/code&gt; &lt;/a&gt; subclass.</target>
        </trans-unit>
        <trans-unit id="27392b4b5ae25c2878c249c3152c3d3160b5375b" translate="yes" xml:space="preserve">
          <source>If the partialReturn property on the txt parameter is false, the data returned in the Segment will be the entire length requested and may or may not be a copy depending upon how the data was stored. If the partialReturn property is true, only the amount of text that can be returned without creating a copy is returned. Using partial returns will give better performance for situations where large parts of the document are being scanned. The following is an example of using the partial return to access the entire document:</source>
          <target state="translated">If the partialReturn property on the txt parameter is false, the data returned in the Segment will be the entire length requested and may or may not be a copy depending upon how the data was stored. If the partialReturn property is true, only the amount of text that can be returned without creating a copy is returned. Using partial returns will give better performance for situations where large parts of the document are being scanned. The following is an example of using the partial return to access the entire document:</target>
        </trans-unit>
        <trans-unit id="310a520f747ac0f430b2cb202c7289354ce38544" translate="yes" xml:space="preserve">
          <source>If the passed in operation is a &lt;a href=&quot;namespaceoperation&quot;&gt;&lt;code&gt;NamespaceOperation&lt;/code&gt;&lt;/a&gt;, or a &lt;a href=&quot;namedoperation&quot;&gt;&lt;code&gt;NamedOperation&lt;/code&gt;&lt;/a&gt; wrapping a &lt;a href=&quot;namespaceoperation&quot;&gt;&lt;code&gt;NamespaceOperation&lt;/code&gt;&lt;/a&gt;, then it returns the first (if any) &lt;a href=&quot;standardnamespace&quot;&gt;&lt;code&gt;StandardNamespace&lt;/code&gt;&lt;/a&gt; in its namespace list.</source>
          <target state="translated">(가) 작동 전달 경우입니다 &lt;a href=&quot;namespaceoperation&quot;&gt; &lt;code&gt;NamespaceOperation&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;namedoperation&quot;&gt; &lt;code&gt;NamedOperation&lt;/code&gt; &lt;/a&gt; 랩핑 &lt;a href=&quot;namespaceoperation&quot;&gt; &lt;code&gt;NamespaceOperation&lt;/code&gt; 은&lt;/a&gt; , 다음 (있는 경우) 첫 번째 반환 &lt;a href=&quot;standardnamespace&quot;&gt; &lt;code&gt;StandardNamespace&lt;/code&gt; 를&lt;/a&gt; 네임 스페이스 목록에.</target>
        </trans-unit>
        <trans-unit id="a7bd44336d4b3666a0011d9d7cbae158269a6fd5" translate="yes" xml:space="preserve">
          <source>If the passed in operation is a &lt;a href=&quot;namespaceoperation&quot;&gt;&lt;code&gt;NamespaceOperation&lt;/code&gt;&lt;/a&gt;, or a &lt;a href=&quot;namedoperation&quot;&gt;&lt;code&gt;NamedOperation&lt;/code&gt;&lt;/a&gt; wrapping a &lt;a href=&quot;namespaceoperation&quot;&gt;&lt;code&gt;NamespaceOperation&lt;/code&gt;&lt;/a&gt;, then it returns the first (if any) &lt;a href=&quot;standardnamespace&quot;&gt;&lt;code&gt;StandardNamespace&lt;/code&gt;&lt;/a&gt; in its namespace list. If the passed operation is not a namespace operation (optionally wrapped in a named operation), or if it doesn't have any standard namespaces in it, returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">(가) 작동 전달 경우입니다 &lt;a href=&quot;namespaceoperation&quot;&gt; &lt;code&gt;NamespaceOperation&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;namedoperation&quot;&gt; &lt;code&gt;NamedOperation&lt;/code&gt; &lt;/a&gt; 랩핑 &lt;a href=&quot;namespaceoperation&quot;&gt; &lt;code&gt;NamespaceOperation&lt;/code&gt; 은&lt;/a&gt; , 다음 (있는 경우) 첫 번째 반환 &lt;a href=&quot;standardnamespace&quot;&gt; &lt;code&gt;StandardNamespace&lt;/code&gt; 를&lt;/a&gt; 네임 스페이스 목록에. 전달 된 작업이 네임 스페이스 작업이 아니거나 (선택적으로 명명 된 작업에 래핑 됨) 표준 네임 스페이스가없는 경우 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="79d69da696a97838674e241d7ea5d2d8014fb0e5" translate="yes" xml:space="preserve">
          <source>If the passed operation is a named operation, returns its &lt;a href=&quot;#getBaseOperation()&quot;&gt;&lt;code&gt;getBaseOperation()&lt;/code&gt;&lt;/a&gt;, otherwise returns the operation as is.</source>
          <target state="translated">전달 된 작업이 명명 된 작업이면 &lt;a href=&quot;#getBaseOperation()&quot;&gt; &lt;code&gt;getBaseOperation()&lt;/code&gt; &lt;/a&gt; 반환하고, 그렇지 않으면 작업을있는 그대로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d934bcf86fcc533735822d99eeae5629daf70231" translate="yes" xml:space="preserve">
          <source>If the passed operation is a named operation, returns its &lt;a href=&quot;#getName()&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt;, otherwise returns null.</source>
          <target state="translated">전달 된 작업이 명명 된 작업이면 &lt;a href=&quot;#getName()&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt; 반환하고 그렇지 않으면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="955cd55c42b1c749bf0d0200c01dd32b47c3552c" translate="yes" xml:space="preserve">
          <source>If the passed operation is a named operation, returns its &lt;a href=&quot;#getName()&quot;&gt;&lt;code&gt;getName()&lt;/code&gt;&lt;/a&gt;, otherwise returns null. Note that a named operation object can never have a null name, therefore returning null is indicative that the passed operation is not, in fact, a named operation.</source>
          <target state="translated">전달 된 작업이 명명 된 작업이면 &lt;a href=&quot;#getName()&quot;&gt; &lt;code&gt;getName()&lt;/code&gt; &lt;/a&gt; 반환하고 그렇지 않으면 null을 반환합니다. 명명 된 작업 개체는 null 이름을 가질 수 없으므로 null을 반환하면 전달 된 작업이 실제로 명명 된 작업이 아님을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b6f8e527f319773c3b4cecd9c9f7becb955367cb" translate="yes" xml:space="preserve">
          <source>If the passed operation is a namespace operation, returns its &lt;a href=&quot;#getBaseOperation()&quot;&gt;&lt;code&gt;getBaseOperation()&lt;/code&gt;&lt;/a&gt;, otherwise returns the operation as is.</source>
          <target state="translated">전달 된 작업이 네임 스페이스 작업이면 &lt;a href=&quot;#getBaseOperation()&quot;&gt; &lt;code&gt;getBaseOperation()&lt;/code&gt; &lt;/a&gt; 반환하고, 그렇지 않으면 작업을있는 그대로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1c652576684afac677e6258e3c80046a8f1e595" translate="yes" xml:space="preserve">
          <source>If the passed operation is a namespace operation, returns its &lt;a href=&quot;#getNamespaces()&quot;&gt;&lt;code&gt;getNamespaces()&lt;/code&gt;&lt;/a&gt;, otherwise returns an empty array.</source>
          <target state="translated">전달 된 작업이 네임 스페이스 작업이면 &lt;a href=&quot;#getNamespaces()&quot;&gt; &lt;code&gt;getNamespaces()&lt;/code&gt; &lt;/a&gt; 를 반환하고 그렇지 않으면 빈 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5ed75a33bb4145623122f20c780e9bac95e43865" translate="yes" xml:space="preserve">
          <source>If the path is relative, and if its first segment contains a colon character (&lt;code&gt;':'&lt;/code&gt;), then a &lt;code&gt;&quot;.&quot;&lt;/code&gt; segment is prepended. This prevents a relative URI with a path such as &lt;code&gt;&quot;a:b/c/d&quot;&lt;/code&gt; from later being re-parsed as an opaque URI with a scheme of &lt;code&gt;&quot;a&quot;&lt;/code&gt; and a scheme-specific part of &lt;code&gt;&quot;b/c/d&quot;&lt;/code&gt;. &lt;b&gt;&lt;i&gt;(Deviation from RFC 2396)&lt;/i&gt;&lt;/b&gt;</source>
          <target state="translated">경로가 상대 경로이고 첫 번째 세그먼트에 콜론 문자 ( &lt;code&gt;':'&lt;/code&gt; ) 가 포함 된 경우 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 세그먼트가 앞에 붙습니다. 이렇게하면 &lt;code&gt;&quot;a:b/c/d&quot;&lt;/code&gt; 와 같은 경로가있는 상대 URI가 나중에 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 체계와 &lt;code&gt;&quot;b/c/d&quot;&lt;/code&gt; 체계가있는 불투명 URI로 다시 구문 분석되지 않습니다. . &lt;b&gt;&lt;i&gt;(RFC 2396에서 벗어남)&lt;/i&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bd2e4303923c73137d6318c7fb1a6ecc2cd9b62d" translate="yes" xml:space="preserve">
          <source>If the pattern contains &quot;/&quot;, the non-empty prefix up to the &quot;/&quot; is the module name; if the module name matches the module name of the class then the remaining pattern is matched with the class name. If there is no &quot;/&quot;, the module name is not compared.</source>
          <target state="translated">If the pattern contains &quot;/&quot;, the non-empty prefix up to the &quot;/&quot; is the module name; if the module name matches the module name of the class then the remaining pattern is matched with the class name. If there is no &quot;/&quot;, the module name is not compared.</target>
        </trans-unit>
        <trans-unit id="47d65275395c58dc9640d193b6ab38182a27d80c" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &quot;*&quot;, it matches any class with the pattern as a prefix.</source>
          <target state="translated">If the pattern ends with &quot;*&quot;, it matches any class with the pattern as a prefix.</target>
        </trans-unit>
        <trans-unit id="2b99798368562eadf341b3140c731a962ac17514" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &quot;.*&quot; it matches any class in the package.</source>
          <target state="translated">If the pattern ends with &quot;.*&quot; it matches any class in the package.</target>
        </trans-unit>
        <trans-unit id="64908fcc581dd6ae74cbec11495eb53bd054a169" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &quot;.**&quot; it matches any class in the package and all subpackages.</source>
          <target state="translated">If the pattern ends with &quot;.**&quot; it matches any class in the package and all subpackages.</target>
        </trans-unit>
        <trans-unit id="d4631732bf01387295ef2c9727234cf63af52f66" translate="yes" xml:space="preserve">
          <source>If the pattern is equal to the class name, it matches.</source>
          <target state="translated">If the pattern is equal to the class name, it matches.</target>
        </trans-unit>
        <trans-unit id="72a8f0cca7462c028e15e68df7691503088ae3a6" translate="yes" xml:space="preserve">
          <source>If the pattern letter is 'v' the output provides the zone name ignoring daylight savings time. If the count of letters is one, then the short name is output. If the count of letters is four, then the full name is output. Two, three and five or more letters throw &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">If the pattern letter is 'v' the output provides the zone name ignoring daylight savings time. If the count of letters is one, then the short name is output. If the count of letters is four, then the full name is output. Two, three and five or more letters throw &lt;code&gt;IllegalArgumentException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2047fa1b9e42f9c7566436cd904af026a1d6b5e2" translate="yes" xml:space="preserve">
          <source>If the pattern starts with &quot;!&quot;, the class is rejected if the remaining pattern is matched; otherwise the class is allowed if the pattern matches.</source>
          <target state="translated">If the pattern starts with &quot;!&quot;, the class is rejected if the remaining pattern is matched; otherwise the class is allowed if the pattern matches.</target>
        </trans-unit>
        <trans-unit id="87a4c8fb790be59120806baf097d003e2948d992" translate="yes" xml:space="preserve">
          <source>If the pending count is nonzero, (atomically) decrements it.</source>
          <target state="translated">보류 카운트가 0이 아닌 경우 (원자 적으로) 감소합니다.</target>
        </trans-unit>
        <trans-unit id="8ad7048ac80247a957da8eeed8a41a5f37a54c39" translate="yes" xml:space="preserve">
          <source>If the pending count is nonzero, decrements the count; otherwise invokes &lt;a href=&quot;#onCompletion(java.util.concurrent.CountedCompleter)&quot;&gt;&lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt;&lt;/a&gt; and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.</source>
          <target state="translated">If the pending count is nonzero, decrements the count; otherwise invokes &lt;a href=&quot;#onCompletion(java.util.concurrent.CountedCompleter)&quot;&gt; &lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt; &lt;/a&gt; and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.</target>
        </trans-unit>
        <trans-unit id="e572cb5e5dee791d5b39d6f57ac77915682e21a1" translate="yes" xml:space="preserve">
          <source>If the pending count is nonzero, decrements the count; otherwise invokes &lt;a href=&quot;countedcompleter#onCompletion-java.util.concurrent.CountedCompleter-&quot;&gt;&lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt;&lt;/a&gt; and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.</source>
          <target state="translated">보류 카운트가 0이 아닌 경우 카운트를 감소시킵니다. 그렇지 않으면 &lt;a href=&quot;countedcompleter#onCompletion-java.util.concurrent.CountedCompleter-&quot;&gt; &lt;code&gt;onCompletion(CountedCompleter)&lt;/code&gt; &lt;/a&gt; 호출 한 다음이 작업의 완료자를 작성하려고 시도합니다 (있는 경우). 그렇지 않으면 이 작업을 완료된 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="bc17ec5f581dec30fa586e110a04b1eaf5b5b327" translate="yes" xml:space="preserve">
          <source>If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</source>
          <target state="translated">허가가있는 경우 허가가 소비되고 즉시 전화가 반환됩니다. 그렇지 않으면 현재 스레드는 스레드 스케줄링 목적으로 비활성화되고 다음 4 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="d4223a7d1829a5930922236b794117f0ecfa3ef5" translate="yes" xml:space="preserve">
          <source>If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">허가가있는 경우 허가가 소비되고 즉시 전화가 반환됩니다. 그렇지 않으면 현재 스레드는 스레드 예약 목적으로 비활성화되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="1c7072c32b05b6fd0de10d7da5998d3dbfa5ec38" translate="yes" xml:space="preserve">
          <source>If the permits are acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">허가가 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4cea382e9b6e94d448d8b5b7931ce98c85d158e1" translate="yes" xml:space="preserve">
          <source>If the persist field of the attribute's descriptor is not null then Persistence policy from the attribute descriptor is used to guide storing the attribute in a persistent store.</source>
          <target state="translated">속성 설명 자의 지속 필드가 널이 아닌 경우 속성 설명 자의 지속성 정책이 속성을 영구 저장소에 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f4b331cf13e540556f5aca90f86b4e8ad5c60f9" translate="yes" xml:space="preserve">
          <source>If the plug-in does not handle image metadata, null should be returned.</source>
          <target state="translated">플러그인이 이미지 메타 데이터를 처리하지 않으면 널이 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="aab4c0c381c1b7fcd5929e45b451378e4a93f9be" translate="yes" xml:space="preserve">
          <source>If the plug-in does not handle metadata, null should be returned.</source>
          <target state="translated">플러그인이 메타 데이터를 처리하지 않으면 널이 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="06277a1c71d67301bd303d6a030fc9040d866b9c" translate="yes" xml:space="preserve">
          <source>If the point is colinear with the line segment, but not between the end points, then the value will be -1 if the point lies &quot;beyond &lt;code&gt;(x1,y1)&lt;/code&gt;&quot; or 1 if the point lies &quot;beyond &lt;code&gt;(x2,y2)&lt;/code&gt;&quot;.</source>
          <target state="translated">If the point is colinear with the line segment, but not between the end points, then the value will be -1 if the point lies &quot;beyond &lt;code&gt;(x1,y1)&lt;/code&gt; &quot; or 1 if the point lies &quot;beyond &lt;code&gt;(x2,y2)&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="566f0e2c0058f212146ef4067827ea84b517258f" translate="yes" xml:space="preserve">
          <source>If the pool currently has more than corePoolSize threads, excess threads will be terminated if they have been idle for more than the keepAliveTime (see &lt;a href=&quot;#getKeepAliveTime(java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt;&lt;/a&gt;). This provides a means of reducing resource consumption when the pool is not being actively used. If the pool becomes more active later, new threads will be constructed. This parameter can also be changed dynamically using method &lt;a href=&quot;#setKeepAliveTime(long,java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;setKeepAliveTime(long,
 TimeUnit)&lt;/code&gt;&lt;/a&gt;. Using a value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt;&lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt;&lt;/a&gt; effectively disables idle threads from ever terminating prior to shut down. By default, the keep-alive policy applies only when there are more than corePoolSize threads, but method &lt;a href=&quot;#allowCoreThreadTimeOut(boolean)&quot;&gt;&lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt;&lt;/a&gt; can be used to apply this time-out policy to core threads as well, so long as the keepAliveTime value is non-zero.</source>
          <target state="translated">If the pool currently has more than corePoolSize threads, excess threads will be terminated if they have been idle for more than the keepAliveTime (see &lt;a href=&quot;#getKeepAliveTime(java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt; &lt;/a&gt;). This provides a means of reducing resource consumption when the pool is not being actively used. If the pool becomes more active later, new threads will be constructed. This parameter can also be changed dynamically using method &lt;a href=&quot;#setKeepAliveTime(long,java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;setKeepAliveTime(long, TimeUnit)&lt;/code&gt; &lt;/a&gt;. Using a value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; &lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt; &lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt; &lt;/a&gt; effectively disables idle threads from ever terminating prior to shut down. By default, the keep-alive policy applies only when there are more than corePoolSize threads, but method &lt;a href=&quot;#allowCoreThreadTimeOut(boolean)&quot;&gt; &lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt; &lt;/a&gt; can be used to apply this time-out policy to core threads as well, so long as the keepAliveTime value is non-zero.</target>
        </trans-unit>
        <trans-unit id="5bf226ccbe41713d478e11aab7ab361a597353a7" translate="yes" xml:space="preserve">
          <source>If the pool currently has more than corePoolSize threads, excess threads will be terminated if they have been idle for more than the keepAliveTime (see &lt;a href=&quot;threadpoolexecutor#getKeepAliveTime-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt;&lt;/a&gt;). This provides a means of reducing resource consumption when the pool is not being actively used. If the pool becomes more active later, new threads will be constructed. This parameter can also be changed dynamically using method &lt;a href=&quot;threadpoolexecutor#setKeepAliveTime-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;setKeepAliveTime(long,
 TimeUnit)&lt;/code&gt;&lt;/a&gt;. Using a value of &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;&lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt;&lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt;&lt;/a&gt; effectively disables idle threads from ever terminating prior to shut down. By default, the keep-alive policy applies only when there are more than corePoolSize threads. But method &lt;a href=&quot;threadpoolexecutor#allowCoreThreadTimeOut-boolean-&quot;&gt;&lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt;&lt;/a&gt; can be used to apply this time-out policy to core threads as well, so long as the keepAliveTime value is non-zero.</source>
          <target state="translated">풀에 현재 corePoolSize 스레드보다 많은 스레드가 있으면 keepAliveTime 이상 동안 유휴 상태 인 경우 초과 스레드가 종료됩니다 ( &lt;a href=&quot;threadpoolexecutor#getKeepAliveTime-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;getKeepAliveTime(TimeUnit)&lt;/code&gt; &lt;/a&gt; 참조 ). 이는 풀을 적극적으로 사용하지 않을 때 리소스 소비를 줄이는 수단을 제공합니다. 풀이 나중에 더 활성화되면 새 스레드가 구성됩니다. 이 매개 변수는 &lt;a href=&quot;threadpoolexecutor#setKeepAliveTime-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;setKeepAliveTime(long, TimeUnit)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 동적으로 변경할 수도 있습니다 . &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 값을 사용하면 &lt;a href=&quot;timeunit#NANOSECONDS&quot;&gt; &lt;code&gt;TimeUnit.NANOSECONDS&lt;/code&gt; 는&lt;/a&gt; 종료 전에 유휴 스레드가 종료되지 않도록 효과적으로 비활성화합니다. 기본적으로 연결 유지 정책은 corePoolSize 스레드보다 많은 경우에만 적용됩니다. 그러나 &lt;a href=&quot;threadpoolexecutor#allowCoreThreadTimeOut-boolean-&quot;&gt; &lt;code&gt;allowCoreThreadTimeOut(boolean)&lt;/code&gt; &lt;/a&gt; 메소드 keepAliveTime 값이 0이 아닌 한이 시간 제한 정책을 코어 스레드에도 적용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a3ff33f4d5e297ea7ec3916317d36251a2ccb95" translate="yes" xml:space="preserve">
          <source>If the prefix is &quot;GMT&quot;, &quot;UTC&quot;, or &quot;UT&quot; a &lt;code&gt;ZoneId&lt;/code&gt; with the prefix and the non-zero offset is returned. If the prefix is empty &lt;code&gt;&quot;&quot;&lt;/code&gt; the &lt;code&gt;ZoneOffset&lt;/code&gt; is returned.</source>
          <target state="translated">접두사가 &quot;GMT&quot;, &quot;UTC&quot;또는 &quot;UT&quot; 이면 접두사가 있고 0이 아닌 오프셋이 있는 &lt;code&gt;ZoneId&lt;/code&gt; 가 반환됩니다. 접두사가 비어 있으면 &lt;code&gt;&quot;&quot;&lt;/code&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a88d71fc9f54022eac4890ef06a233fa0844cac0" translate="yes" xml:space="preserve">
          <source>If the prefix is &lt;code&gt;null&lt;/code&gt;, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. Use &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt;&lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt;&lt;/a&gt; to explicitly indicate that no prefix is present or the prefix is not relevant.</source>
          <target state="translated">If the prefix is &lt;code&gt;null&lt;/code&gt; , an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. Use &lt;a href=&quot;../xmlconstants#DEFAULT_NS_PREFIX&quot;&gt; &lt;code&gt;XMLConstants.DEFAULT_NS_PREFIX&lt;/code&gt; &lt;/a&gt; to explicitly indicate that no prefix is present or the prefix is not relevant.</target>
        </trans-unit>
        <trans-unit id="2958ef27e71136debb4afdbdf265b117d00e567e" translate="yes" xml:space="preserve">
          <source>If the present length of the file as returned by the &lt;code&gt;length&lt;/code&gt; method is greater than the &lt;code&gt;newLength&lt;/code&gt; argument then the file will be truncated. In this case, if the file offset as returned by the &lt;code&gt;getFilePointer&lt;/code&gt; method is greater than &lt;code&gt;newLength&lt;/code&gt; then after this method returns the offset will be equal to &lt;code&gt;newLength&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; 메소드가 리턴 한 파일의 현재 길이가 &lt;code&gt;newLength&lt;/code&gt; 인수 보다 크면 파일이 잘립니다. 이 경우, &lt;code&gt;getFilePointer&lt;/code&gt; 메소드에 의해 리턴 된 파일 오프셋 이 &lt;code&gt;newLength&lt;/code&gt; 보다 큰 경우 , 이 메소드가 리턴 된 후 오프셋은 &lt;code&gt;newLength&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9cef2b80409c01c0c853b230c56f0ff2824529e5" translate="yes" xml:space="preserve">
          <source>If the present length of the file as returned by the &lt;code&gt;length&lt;/code&gt; method is smaller than the &lt;code&gt;newLength&lt;/code&gt; argument then the file will be extended. In this case, the contents of the extended portion of the file are not defined.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; 메소드에 의해 리턴 된 파일의 현재 길이가 &lt;code&gt;newLength&lt;/code&gt; 인수 보다 작 으면 파일이 확장됩니다. 이 경우 파일의 확장 부분 내용이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="087d7d53cb32d81d4bb2e8d37c5e0f4bd813cb56" translate="yes" xml:space="preserve">
          <source>If the previous step fails to find a protocol handler, the constructor reads the value of the system property:</source>
          <target state="translated">If the previous step fails to find a protocol handler, the constructor reads the value of the system property:</target>
        </trans-unit>
        <trans-unit id="c6c92eb74a9e692df342c2385a09b40d4ef27afc" translate="yes" xml:space="preserve">
          <source>If the previous step fails to find a protocol handler, then the constructor tries to load a built-in protocol handler. If this class does not exist, or if the class exists but it is not a subclass of &lt;code&gt;URLStreamHandler&lt;/code&gt;, then a &lt;code&gt;MalformedURLException&lt;/code&gt; is thrown.</source>
          <target state="translated">If the previous step fails to find a protocol handler, then the constructor tries to load a built-in protocol handler. If this class does not exist, or if the class exists but it is not a subclass of &lt;code&gt;URLStreamHandler&lt;/code&gt; , then a &lt;code&gt;MalformedURLException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="dec7b0fc3a3fa3565bc2b4d09d4d15db4b1e4a93" translate="yes" xml:space="preserve">
          <source>If the previous step fails to find a protocol handler, then the constructor tries to load from a system default package.</source>
          <target state="translated">이전 단계에서 프로토콜 핸들러를 찾지 못하면 생성자가 시스템 기본 패키지에서로드를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6585f9f7ecc69964ba3abd119ebdf439ff37f98d" translate="yes" xml:space="preserve">
          <source>If the previous step has found no resource bundle, proceed to Step 6. If a bundle has been found that is a base bundle (a bundle for &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;), and the candidate locale list only contained &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt;, return the bundle to the caller. If a bundle has been found that is a base bundle, but the candidate locale list contained locales other than Locale(&quot;&quot;), put the bundle on hold and proceed to Step 6. If a bundle has been found that is not a base bundle, proceed to Step 7.</source>
          <target state="translated">이전 단계에서 자원 번들을 찾지 못한 경우 6 단계로 진행하십시오. 기본 번들 ( &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt; 의 번들) 인 번들이 발견 되고 후보 로케일 목록에 &lt;code&gt;Locale(&quot;&quot;)&lt;/code&gt; 만 포함 된 경우 , 번들을 호출자에게 리턴하십시오. 기본 번들 인 번들이 발견되었지만 후보 로케일 목록에 Locale ( &quot;&quot;) 이외의 다른 로케일이 포함 된 경우 번들을 보류하고 6 단계로 진행하십시오. 기본 번들이 아닌 번들이 발견 된 경우 7 단계로 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="ea2595038e3728d521540b9e147c81e0fa793394" translate="yes" xml:space="preserve">
          <source>If the principal system property or key is already provided, the value of &quot;javax.security.auth.login.name&quot; in the shared state is ignored.</source>
          <target state="translated">주 시스템 속성 또는 키가 이미 제공된 경우 공유 상태의 &quot;javax.security.auth.login.name&quot;값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6778bed4bae7f4aceabe96f43a91b258db12e0c7" translate="yes" xml:space="preserve">
          <source>If the print data is a stream, or a print job requests data as a stream, then &lt;code&gt;SimpleDoc&lt;/code&gt; does not monitor if the service properly closes the stream after data transfer completion or job termination. Clients may prefer to use provide their own implementation of doc that adds a listener to monitor job completion and to validate that resources such as streams are freed (ie closed).</source>
          <target state="translated">인쇄 데이터가 스트림이거나 인쇄 작업이 데이터를 스트림으로 요청하면 &lt;code&gt;SimpleDoc&lt;/code&gt; 은 데이터 전송 완료 또는 작업 종료 후 서비스가 스트림을 올바르게 닫는 지 여부를 모니터링하지 않습니다. 클라이언트는 작업 완료를 모니터하고 스트림과 같은 자원이 해제 (즉, 닫힘)되었는지 확인하기 위해 리스너를 추가하는 고유 한 doc 구현을 사용하는 것을 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bebb66852f6964b9bd2e3cea1ce8a7ef48446b3a" translate="yes" xml:space="preserve">
          <source>If the process has already terminated then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If the process has not terminated and the timeout value is less than, or equal to, zero, then this method returns immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">If the process has already terminated then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt; . If the process has not terminated and the timeout value is less than, or equal to, zero, then this method returns immediately with the value &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6c209a5eafb6c3fed5697bfbb41d0d1e8b8dc27" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt;&lt;code&gt;SupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation.</source>
          <target state="translated">If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt; &lt;code&gt;SupportedAnnotationTypes&lt;/code&gt; &lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation.</target>
        </trans-unit>
        <trans-unit id="88bf35bed53cf1a7b9c25c4c647bfc4d663ad0d2" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt;&lt;code&gt;SupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned.</source>
          <target state="translated">프로세서 클래스에 &lt;a href=&quot;supportedannotationtypes&quot;&gt; &lt;code&gt;SupportedAnnotationTypes&lt;/code&gt; &lt;/a&gt; 로 주석이 달린 경우 주석과 동일한 문자열 세트로 수정할 수없는 세트를 리턴하십시오. 클래스에 주석이없는 경우 빈 세트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f41793fe3304ceb1d00d62771a4aa39cb3d71ae7" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt;&lt;code&gt;SupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned. If the &lt;a href=&quot;processingenvironment#getSourceVersion()&quot;&gt;&lt;code&gt;source
 version&lt;/code&gt;&lt;/a&gt; does not support modules, in other words if it is less than or equal to &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_8&quot;&gt;&lt;code&gt;RELEASE_8&lt;/code&gt;&lt;/a&gt;, then any leading &lt;a href=&quot;processor#getSupportedAnnotationTypes()&quot;&gt;&lt;code&gt;module prefixes&lt;/code&gt;&lt;/a&gt; are stripped from the names.</source>
          <target state="translated">If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt; &lt;code&gt;SupportedAnnotationTypes&lt;/code&gt; &lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned. If the &lt;a href=&quot;processingenvironment#getSourceVersion()&quot;&gt; &lt;code&gt;source version&lt;/code&gt; &lt;/a&gt; does not support modules, in other words if it is less than or equal to &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_8&quot;&gt; &lt;code&gt;RELEASE_8&lt;/code&gt; &lt;/a&gt;, then any leading &lt;a href=&quot;processor#getSupportedAnnotationTypes()&quot;&gt; &lt;code&gt;module prefixes&lt;/code&gt; &lt;/a&gt; are stripped from the names.</target>
        </trans-unit>
        <trans-unit id="7d2a0bffaf2c47cc7d7f992548c87fe48e574cab" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedannotationtypes&quot;&gt;&lt;code&gt;SupportedAnnotationTypes&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned. If the &lt;a href=&quot;processingenvironment#getSourceVersion()&quot;&gt;source version&lt;/a&gt; does not support modules, in other words if it is less than or equal to &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_8&quot;&gt;&lt;code&gt;RELEASE_8&lt;/code&gt;&lt;/a&gt;, then any leading &lt;a href=&quot;processor#getSupportedAnnotationTypes()&quot;&gt;module prefixes&lt;/a&gt; are stripped from the names.</source>
          <target state="translated">프로세서 클래스가 &lt;a href=&quot;supportedannotationtypes&quot;&gt; &lt;code&gt;SupportedAnnotationTypes&lt;/code&gt; &lt;/a&gt; 로 주석이 달린 경우 주석과 동일한 문자열 세트로 수정 불가능한 세트를 리턴하십시오. 클래스에 주석을 달지 않으면 빈 집합이 반환됩니다. &lt;a href=&quot;processingenvironment#getSourceVersion()&quot;&gt;소스 버전&lt;/a&gt; 이 모듈을 지원하지 않는 경우, 즉 &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_8&quot;&gt; &lt;code&gt;RELEASE_8&lt;/code&gt; &lt;/a&gt; 이하 이면 모든 선행 &lt;a href=&quot;processor#getSupportedAnnotationTypes()&quot;&gt;모듈 접두사&lt;/a&gt; 가 이름에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d3f67fa776d861f7bdbdce342363185f87f166e6" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedoptions&quot;&gt;&lt;code&gt;SupportedOptions&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation.</source>
          <target state="translated">If the processor class is annotated with &lt;a href=&quot;supportedoptions&quot;&gt; &lt;code&gt;SupportedOptions&lt;/code&gt; &lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation.</target>
        </trans-unit>
        <trans-unit id="09f9046e5ee10b9263ce6a07905ea1779eccbaa9" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedoptions&quot;&gt;&lt;code&gt;SupportedOptions&lt;/code&gt;&lt;/a&gt;, return an unmodifiable set with the same set of strings as the annotation. If the class is not so annotated, an empty set is returned.</source>
          <target state="translated">프로세서 클래스에 &lt;a href=&quot;supportedoptions&quot;&gt; &lt;code&gt;SupportedOptions&lt;/code&gt; &lt;/a&gt; 로 주석이 달린 경우 주석과 동일한 문자열 세트로 수정할 수없는 세트를 리턴하십시오. 클래스에 주석이없는 경우 빈 세트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b36cf0c2beb0dbdd953aff6325943dc74920fe4e" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedsourceversion&quot;&gt;&lt;code&gt;SupportedSourceVersion&lt;/code&gt;&lt;/a&gt;, return the source version in the annotation.</source>
          <target state="translated">If the processor class is annotated with &lt;a href=&quot;supportedsourceversion&quot;&gt; &lt;code&gt;SupportedSourceVersion&lt;/code&gt; &lt;/a&gt;, return the source version in the annotation.</target>
        </trans-unit>
        <trans-unit id="7003e770420135c1df12e09d555ca6780cff43c6" translate="yes" xml:space="preserve">
          <source>If the processor class is annotated with &lt;a href=&quot;supportedsourceversion&quot;&gt;&lt;code&gt;SupportedSourceVersion&lt;/code&gt;&lt;/a&gt;, return the source version in the annotation. If the class is not so annotated, &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_6&quot;&gt;&lt;code&gt;SourceVersion.RELEASE_6&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">프로세서 클래스에 &lt;a href=&quot;supportedsourceversion&quot;&gt; &lt;code&gt;SupportedSourceVersion&lt;/code&gt; &lt;/a&gt; 으로 주석이 달린 경우 주석 에서 소스 버전을 리턴하십시오. 클래스에 주석이없는 경우 &lt;a href=&quot;../../lang/model/sourceversion#RELEASE_6&quot;&gt; &lt;code&gt;SourceVersion.RELEASE_6&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="83fa47aeaeb40c5cd4a73d7078ea6a57dab4dfda" translate="yes" xml:space="preserve">
          <source>If the profile has specified the corresponding TRC as linear (gamma = 1.0) or as a simple gamma value, this method throws an exception. In this case, the &lt;a href=&quot;#getGamma(int)&quot;&gt;&lt;code&gt;getGamma(int)&lt;/code&gt;&lt;/a&gt; method should be used to get the gamma value.</source>
          <target state="translated">프로파일이 해당 TRC를 선형 (감마 = 1.0) 또는 단순 감마 값으로 지정한 경우이 메서드는 예외를 throw합니다. 이 경우 &lt;a href=&quot;#getGamma(int)&quot;&gt; &lt;code&gt;getGamma(int)&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 감마 값을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="31cac7c5487d20649f40e4f99c36175d92d8d730" translate="yes" xml:space="preserve">
          <source>If the profile represents the TRC for the corresponding component as a table rather than a single gamma value, an exception is thrown. In this case the actual table can be obtained through the &lt;a href=&quot;#getTRC(int)&quot;&gt;&lt;code&gt;getTRC(int)&lt;/code&gt;&lt;/a&gt; method. When using a gamma value, the linear component (R, G, or B) is computed as follows:</source>
          <target state="translated">If the profile represents the TRC for the corresponding component as a table rather than a single gamma value, an exception is thrown. In this case the actual table can be obtained through the &lt;a href=&quot;#getTRC(int)&quot;&gt; &lt;code&gt;getTRC(int)&lt;/code&gt; &lt;/a&gt; method. When using a gamma value, the linear component (R, G, or B) is computed as follows:</target>
        </trans-unit>
        <trans-unit id="2a28ee9e20388a55d35f948cd48fff9c84de8808" translate="yes" xml:space="preserve">
          <source>If the program doesn't explicitly hide or dispose the window while processing this event, the window close operation is canceled.</source>
          <target state="translated">If the program doesn't explicitly hide or dispose the window while processing this event, the window close operation is canceled.</target>
        </trans-unit>
        <trans-unit id="b31e3a1fd2087ce273c8b857c1c713db2fbc7119" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch AuthenticationException explicitly before attempting to catch NamingException. After catching AuthenticationException, the program could reattempt the authentication by updating the resolved context's environment properties with the appropriate appropriate credentials.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 AuthenticationException을 명시 적으로 포착해야합니다. AuthenticationException을 발견 한 후, 프로그램은 분석 된 컨텍스트의 환경 특성을 적절한 적절한 신임 정보로 업데이트하여 인증을 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c285b45955c2c11ff3e733840c81852c7f62aeb" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch AuthenticationException explicitly before attempting to catch NamingException. After catching AuthenticationException, the program could reattempt the authentication by updating the resolved context's environment properties with the appropriate credentials.</source>
          <target state="translated">If the program wants to handle this exception in particular, it should catch AuthenticationException explicitly before attempting to catch NamingException. After catching AuthenticationException, the program could reattempt the authentication by updating the resolved context's environment properties with the appropriate credentials.</target>
        </trans-unit>
        <trans-unit id="6f2dc297aa51d5849276a390a4e74ee5aecc6575" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch AuthenticationNotSupportedException explicitly before attempting to catch NamingException. After catching &lt;code&gt;AuthenticationNotSupportedException&lt;/code&gt;, the program could reattempt the authentication using a different authentication flavor by updating the resolved context's environment properties accordingly.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 AuthenticationNotSupportedException을 명시 적으로 포착해야합니다. &lt;code&gt;AuthenticationNotSupportedException&lt;/code&gt; 을 포착 한 후 , 프로그램은 이에 따라 해결 된 컨텍스트의 환경 특성을 업데이트하여 다른 인증 플레이버를 사용하여 인증을 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aa89d5f48713a94a294fbe63d3a7465ee70153d" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch CannotProceedException explicitly before attempting to catch NamingException.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 CannotProceedException을 명시 적으로 포착해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8620b756848fd740f3151a464311aed319d8483" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch ContextNotEmptyException explicitly before attempting to catch NamingException. For example, after catching ContextNotEmptyException, the program might try to remove the contents of the context before reattempting the destroy.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 ContextNotEmptyException을 명시 적으로 포착해야합니다. 예를 들어, ContextNotEmptyException을 발견 한 후 프로그램은 삭제를 재 시도하기 전에 컨텍스트의 컨텐츠를 제거하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="895af51843785805eb993f6b245e3c37e050b292" translate="yes" xml:space="preserve">
          <source>If the program wants to handle this exception in particular, it should catch NamingSecurityException explicitly before attempting to catch NamingException. A program might want to do this, for example, if it wants to treat security-related exceptions specially from other sorts of naming exception.</source>
          <target state="translated">프로그램이 특히이 예외를 처리하려면 NamingException을 포착하기 전에 NamingSecurityException을 명시 적으로 포착해야합니다. 예를 들어, 다른 종류의 명명 예외에서 보안 관련 예외를 처리하려는 경우 프로그램이이를 수행하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb41eee27e4dcb52452672c25f0afd9d73a6363a" translate="yes" xml:space="preserve">
          <source>If the properties for this image are not yet known, this method returns &lt;code&gt;null&lt;/code&gt;, and the &lt;code&gt;ImageObserver&lt;/code&gt; object is notified later.</source>
          <target state="translated">If the properties for this image are not yet known, this method returns &lt;code&gt;null&lt;/code&gt; , and the &lt;code&gt;ImageObserver&lt;/code&gt; object is notified later.</target>
        </trans-unit>
        <trans-unit id="c6f5f7560de8700736d8932ba9b65417b272c5ae" translate="yes" xml:space="preserve">
          <source>If the property editor class has a public constructor that takes an Object argument then it will be invoked using the bean parameter as the argument. Otherwise, the default constructor will be invoked.</source>
          <target state="translated">특성 편집기 클래스에 Object 인수를 사용하는 공용 생성자가 있으면 Bean 매개 변수를 인수로 사용하여 호출됩니다. 그렇지 않으면 기본 생성자가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9e0db0c19ce124c9165b021df450a93e7c1b610d" translate="yes" xml:space="preserve">
          <source>If the property value begins with the ASCII character &lt;code&gt;0&lt;/code&gt; followed by another character, it is parsed as an octal integer exactly as by the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 8.</source>
          <target state="translated">If the property value begins with the ASCII character &lt;code&gt;0&lt;/code&gt; followed by another character, it is parsed as an octal integer exactly as by the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; with radix 8.</target>
        </trans-unit>
        <trans-unit id="b2f66e3274b70113dec5b6e974df0367593c3c3b" translate="yes" xml:space="preserve">
          <source>If the property value begins with the ASCII character &lt;code&gt;0&lt;/code&gt; followed by another character, it is parsed as an octal integer exactly as by the method &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 8.</source>
          <target state="translated">특성 값이 ASCII 문자 &lt;code&gt;0&lt;/code&gt; 으로 시작하고 그 뒤에 다른 문자가 오는 경우 기수 8을 사용 하는 &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일하게 8 진 정수로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="d846b960ac8982dfe609a8cc87db59aceb1d4596" translate="yes" xml:space="preserve">
          <source>If the property value begins with the ASCII character &lt;code&gt;0&lt;/code&gt; followed by another character, it is parsed as an octal integer exactly as by the method &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 8.</source>
          <target state="translated">특성 값이 ASCII 문자 &lt;code&gt;0&lt;/code&gt; 으로 시작하고 그 뒤에 다른 문자가 오는 경우 기수 8을 사용 하는 &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 동일하게 8 진 정수로 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="f31812e2389a3fbd5e06ae57741d1eba9e8ae01c" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as by the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt; , not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as by the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; with radix 16.</target>
        </trans-unit>
        <trans-unit id="0c2a7d82245ca935ebfab36515f8332c15126b95" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as by the method &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">등록 정보 값이 두 개의 ASCII 문자 &lt;code&gt;0x&lt;/code&gt; 또는 ASCII 문자 &lt;code&gt;#&lt;/code&gt; 로 시작하고 그 뒤에 빼기 부호가 없으면 나머지 값은 &lt;a href=&quot;integer#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 같은 16 진 정수로 구문 분석됩니다. 기수 16.</target>
        </trans-unit>
        <trans-unit id="3e08b19ba4e6b5c03dd249dfcc97aa3c284ebfc6" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as for the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt; , not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as for the method &lt;a href=&quot;#valueOf(java.lang.String,int)&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; with radix 16.</target>
        </trans-unit>
        <trans-unit id="b9750c4a61406d17de53527d1fc84ece847954d5" translate="yes" xml:space="preserve">
          <source>If the property value begins with the two ASCII characters &lt;code&gt;0x&lt;/code&gt; or the ASCII character &lt;code&gt;#&lt;/code&gt;, not followed by a minus sign, then the rest of it is parsed as a hexadecimal integer exactly as for the method &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt;&lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt;&lt;/a&gt; with radix 16.</source>
          <target state="translated">특성 값이 두 개의 ASCII 문자 &lt;code&gt;0x&lt;/code&gt; 또는 ASCII 문자 &lt;code&gt;#&lt;/code&gt; 로 시작하고 그 뒤에 빼기 부호가 없으면 나머지 값은 &lt;a href=&quot;long#valueOf-java.lang.String-int-&quot;&gt; &lt;code&gt;valueOf(java.lang.String, int)&lt;/code&gt; &lt;/a&gt; 메소드 와 정확히 같은 16 진 정수로 구문 분석됩니다. 기수 16.</target>
        </trans-unit>
        <trans-unit id="9341abc5c400faccf17a3a07de7fac11536f5e5a" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tag values.</source>
          <target state="translated">If the property value must be one of a set of known tagged values, then this method should return an array of the tag values.</target>
        </trans-unit>
        <trans-unit id="6bfe54e945e0b7d817f4c40688004d1c3e18c1e7" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tag values. This can be used to represent (for example) enum values. If a PropertyEditor supports tags, then it should support the use of setAsText with a tag value as a way of setting the value.</source>
          <target state="translated">속성 값이 알려진 태그 값 집합 중 하나 여야하는 경우이 메서드는 태그 값의 배열을 반환해야합니다. 열거 형 값을 나타내는 데 사용할 수 있습니다 (예 :). PropertyEditor가 태그를 지원하는 경우 값을 설정하는 방법으로 태그 값과 함께 setAsText 사용을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="6cd73dc02e49fa592dbe8e15dd72558ce6881cfe" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tags.</source>
          <target state="translated">If the property value must be one of a set of known tagged values, then this method should return an array of the tags.</target>
        </trans-unit>
        <trans-unit id="ef546a8769cb06ecdb14394d21b131483d0cbdbf" translate="yes" xml:space="preserve">
          <source>If the property value must be one of a set of known tagged values, then this method should return an array of the tags. This can be used to represent (for example) enum values. If a PropertyEditor supports tags, then it should support the use of setAsText with a tag value as a way of setting the value and the use of getAsText to identify the current value.</source>
          <target state="translated">속성 값이 알려진 태그 값 집합 중 하나 여야하는 경우이 메서드는 태그 배열을 반환해야합니다. 열거 형 값을 나타내는 데 사용할 수 있습니다 (예 :). PropertyEditor가 태그를 지원하는 경우 값을 설정하고 getAsText를 사용하여 현재 값을 식별하는 방법으로 태그 값과 함께 setAsText 사용을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d4476facb38f8ef6d3eac0b77402edf9355a984" translate="yes" xml:space="preserve">
          <source>If the protected key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a certificate chain certifying the corresponding public key.</source>
          <target state="translated">보호 된 키가 &lt;code&gt;java.security.PrivateKey&lt;/code&gt; 유형 인 경우 해당 공개 키를 인증하는 인증 체인이 동반되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8efe5ceae64e694176e05313f25266d8f3110e7f" translate="yes" xml:space="preserve">
          <source>If the protected key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a certificate chain certifying the corresponding public key. If the underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt; must be encoded as an &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.</source>
          <target state="translated">보호 된 키가 &lt;code&gt;java.security.PrivateKey&lt;/code&gt; 유형 인 경우 해당 공개 키를 인증하는 인증 체인이 동반되어야합니다. 기본 스토어 구현 형의 경우 &lt;code&gt;jks&lt;/code&gt; , &lt;code&gt;key&lt;/code&gt; 로서 부호화해야 &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; 는 PKCS # 8 표준에서 정의 된 바와 같다.</target>
        </trans-unit>
        <trans-unit id="1e8fade5fe2a933f005d764f4f99cdb58a44ddd5" translate="yes" xml:space="preserve">
          <source>If the protocol is &quot;file&quot; and there is an authority component, then permission to connect to and accept connections from that authority may be granted. If the protocol is &quot;file&quot; and the path specifies a file, then permission to read that file is granted. If protocol is &quot;file&quot; and the path is a directory, permission is granted to read all files and (recursively) all files and subdirectories contained in that directory.</source>
          <target state="translated">프로토콜이 &quot;파일&quot;이고 권한 구성 요소가있는 경우 해당 권한에 대한 연결 및 연결 권한이 부여 될 수 있습니다. 프로토콜이 &quot;file&quot;이고 경로가 파일을 지정하면 해당 파일을 읽을 수있는 권한이 부여됩니다. 프로토콜이 &quot;file&quot;이고 경로가 디렉토리 인 경우 해당 디렉토리에 포함 된 모든 파일과 모든 파일 및 하위 디렉토리를 읽을 수있는 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="bb5e9c9f7d7d328c23292e6a5e585815516946f8" translate="yes" xml:space="preserve">
          <source>If the protocol is not &quot;file&quot;, then permission to connect to and accept connections from the URL's host is granted.</source>
          <target state="translated">프로토콜이 &quot;파일&quot;이 아닌 경우 URL 호스트에 연결하고 연결을 수락 할 수있는 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="40b1f09001ad2f74e8788b23bbde2accb73745d9" translate="yes" xml:space="preserve">
          <source>If the protocol of this URL is &quot;jar&quot;, then the permission granted is based on the permission that is required by the URL of the Jar file.</source>
          <target state="translated">이 URL의 프로토콜이 &quot;jar&quot;인 경우 부여 된 권한은 Jar 파일의 URL에 필요한 권한을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="2f6b4c1a7017bece1784e1294dd82a4357362b10" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these devices do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;#getMidiDeviceInfo()&quot;&gt;&lt;code&gt;getMidiDeviceInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects.</source>
          <target state="translated">If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these devices do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;#getMidiDeviceInfo()&quot;&gt; &lt;code&gt;getMidiDeviceInfo()&lt;/code&gt; &lt;/a&gt; to contain all available &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects.</target>
        </trans-unit>
        <trans-unit id="f7aff0ef21850924145fd8d1eef710a0152583e2" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these devices do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;midisystem#getMidiDeviceInfo--&quot;&gt;&lt;code&gt;getMidiDeviceInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;MidiDevice.Info&lt;/code&gt; objects.</source>
          <target state="translated">공급자 클래스가 지정되고 설치된 공급자에서 성공적으로 검색 할 수있는 경우 공급자에서 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 개체 목록 이 검색됩니다. 그렇지 않은 경우 또는 이러한 장치가 후속 일치 항목을 제공하지 않으면 사용 가능한 모든 &lt;code&gt;MidiDevice.Info&lt;/code&gt; 객체 를 포함하도록 &lt;a href=&quot;midisystem#getMidiDeviceInfo--&quot;&gt; &lt;code&gt;getMidiDeviceInfo()&lt;/code&gt; &lt;/a&gt; 에서 목록을 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="4f695eb9c45a7476a06cdea16f6e7dbf1118f942" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these mixers do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;#getMixerInfo()&quot;&gt;&lt;code&gt;getMixerInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;Mixer.Info&lt;/code&gt; objects.</source>
          <target state="translated">If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these mixers do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;#getMixerInfo()&quot;&gt; &lt;code&gt;getMixerInfo()&lt;/code&gt; &lt;/a&gt; to contain all available &lt;code&gt;Mixer.Info&lt;/code&gt; objects.</target>
        </trans-unit>
        <trans-unit id="0e695a51fa3964ae1c7613ee0169a232ee920a9d" translate="yes" xml:space="preserve">
          <source>If the provider class is specified, and it can be successfully retrieved from the installed providers, the list of &lt;code&gt;Mixer.Info&lt;/code&gt; objects is retrieved from the provider. Otherwise, or when these mixers do not provide a subsequent match, the list is retrieved from &lt;a href=&quot;audiosystem#getMixerInfo--&quot;&gt;&lt;code&gt;getMixerInfo()&lt;/code&gt;&lt;/a&gt; to contain all available &lt;code&gt;Mixer.Info&lt;/code&gt; objects.</source>
          <target state="translated">공급자 클래스가 지정되고 설치된 공급자에서 성공적으로 검색 할 수있는 경우 Provider에서 &lt;code&gt;Mixer.Info&lt;/code&gt; 객체 목록 이 검색됩니다. 그렇지 않은 경우 또는 이러한 믹서가 후속 일치 항목을 제공하지 않으면 사용 가능한 모든 &lt;code&gt;Mixer.Info&lt;/code&gt; 오브젝트 를 포함하기 위해 &lt;a href=&quot;audiosystem#getMixerInfo--&quot;&gt; &lt;code&gt;getMixerInfo()&lt;/code&gt; &lt;/a&gt; 에서 목록이 검색 됩니다.</target>
        </trans-unit>
        <trans-unit id="60186988e7792b549f33f598eb6796ff82e377be" translate="yes" xml:space="preserve">
          <source>If the provider implementation is dynamic, then the flag gives the option of preventing the returned rules from being cached in &lt;a href=&quot;../zoneid&quot;&gt;&lt;code&gt;ZoneId&lt;/code&gt;&lt;/a&gt;. When the flag is true, the provider is permitted to return null, where null will prevent the rules from being cached in &lt;code&gt;ZoneId&lt;/code&gt;. When the flag is false, the provider must return non-null rules.</source>
          <target state="translated">제공자 구현이 동적 인 경우 플래그는 리턴 된 규칙이 &lt;a href=&quot;../zoneid&quot;&gt; &lt;code&gt;ZoneId&lt;/code&gt; &lt;/a&gt; 에 캐시되지 않도록하는 옵션을 제공합니다 . 플래그가 true 인 경우 공급자는 null을 반환 할 수 있습니다. 여기서 null은 규칙이 &lt;code&gt;ZoneId&lt;/code&gt; 에 캐시되지 않도록합니다 . 플래그가 false이면 제공자는 널이 아닌 규칙을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="e445a3443a37b81ff119acc67b2ad73cb5fb6432" translate="yes" xml:space="preserve">
          <source>If the provider implementation is not dynamic, then the result of the method must be the non-null set of rules selected by the ID.</source>
          <target state="translated">제공자 구현이 동적이 아닌 경우 메소드의 결과는 ID에 의해 선택된 널이 아닌 규칙 세트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="17253c90de92aa58bc36b4a773f197b6ca04e1e5" translate="yes" xml:space="preserve">
          <source>If the provider package list exists and is not empty, then for each element &lt;code&gt;&lt;em&gt;pkg&lt;/em&gt;&lt;/code&gt; of the list, the factory will attempt to load the class</source>
          <target state="translated">공급자 패키지 목록이 존재하고 비어 있지 않은 경우 목록의 각 요소 &lt;code&gt;&lt;em&gt;pkg&lt;/em&gt;&lt;/code&gt; 에 대해 팩토리는 클래스를로드하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="622b60c7279314ec79406efe2e9c7dcfd8abc786" translate="yes" xml:space="preserve">
          <source>If the proxy could not be created, a &lt;a href=&quot;../stubnotfoundexception&quot;&gt;&lt;code&gt;StubNotFoundException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">If the proxy could not be created, a &lt;a href=&quot;../stubnotfoundexception&quot;&gt; &lt;code&gt;StubNotFoundException&lt;/code&gt; &lt;/a&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="d01e7ab79ccc797c94edb821e2001a4b21858cc0" translate="yes" xml:space="preserve">
          <source>If the queue fits in the specified array with room to spare (i.e., the array has more elements than the queue), the element in the array immediately following the end of the collection is set to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">큐에 여유 공간이있는 지정된 배열에 큐가 적합하면 (즉, 배열에 큐보다 많은 요소가있는 경우) 콜렉션의 끝 바로 뒤에있는 배열의 요소는 &lt;code&gt;null&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a336b114f09759ab0e34346b42e3f6b6437e8fc" translate="yes" xml:space="preserve">
          <source>If the radix is less than &lt;a href=&quot;../lang/character#MIN_RADIX&quot;&gt;&lt;code&gt;Character.MIN_RADIX&lt;/code&gt;&lt;/a&gt; or greater than &lt;a href=&quot;../lang/character#MAX_RADIX&quot;&gt;&lt;code&gt;Character.MAX_RADIX&lt;/code&gt;&lt;/a&gt;, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">If the radix is less than &lt;a href=&quot;../lang/character#MIN_RADIX&quot;&gt; &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; &lt;/a&gt; or greater than &lt;a href=&quot;../lang/character#MAX_RADIX&quot;&gt; &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; &lt;/a&gt;, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="99b3e8d45f37070b6c7a53d21e9f356902e9580a" translate="yes" xml:space="preserve">
          <source>If the radix is less than &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; or greater than &lt;code&gt;Character.MAX_RADIX&lt;/code&gt;, then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">기수가 &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; 보다 작은 지, &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; 보다 큰 경우 는 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 Throw됩니다.</target>
        </trans-unit>
        <trans-unit id="a648ff4273d99de4e1bc95f12a1486f421ca4054" translate="yes" xml:space="preserve">
          <source>If the radix is not in the range &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; or if the character is not a valid digit in the specified radix, &lt;code&gt;-1&lt;/code&gt; is returned. A character is a valid digit if at least one of the following is true:</source>
          <target state="translated">기수가 &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; 범위 에 있지 않거나 문자가 지정된 기수의 유효한 숫자가 아닌 경우 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다. 다음 중 하나 이상에 해당하면 문자는 유효한 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="d4a1e7fa070e5bd8bde88ce903f985156a6f1b0d" translate="yes" xml:space="preserve">
          <source>If the radix is not in the range &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; or if the value of &lt;code&gt;ch&lt;/code&gt; is not a valid digit in the specified radix, &lt;code&gt;-1&lt;/code&gt; is returned. A character is a valid digit if at least one of the following is true:</source>
          <target state="translated">기수가 &lt;code&gt;MIN_RADIX&lt;/code&gt; &amp;le; &lt;code&gt;radix&lt;/code&gt; &amp;le; &lt;code&gt;MAX_RADIX&lt;/code&gt; 범위 에 있지 않거나 &lt;code&gt;ch&lt;/code&gt; 값이 지정된 기수의 유효한 숫자가 아닌 경우 &lt;code&gt;-1&lt;/code&gt; 이 리턴됩니다. 다음 중 하나 이상에 해당하면 문자는 유효한 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="671d0d109c8316ebaf1f99c9e9a6b5ad599bcdb9" translate="yes" xml:space="preserve">
          <source>If the radix is smaller than &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; or larger than &lt;code&gt;Character.MAX_RADIX&lt;/code&gt;, then the radix &lt;code&gt;10&lt;/code&gt; is used instead.</source>
          <target state="translated">기수 미만이면 &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; 보다 이상 &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; 후 기수 &lt;code&gt;10&lt;/code&gt; 대신 사용된다.</target>
        </trans-unit>
        <trans-unit id="88c548789120cc039a2be678f91a294c4a57446d" translate="yes" xml:space="preserve">
          <source>If the read lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">읽기 잠금이 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f1de0197561ab1c42739d318716c6da06cb232ac" translate="yes" xml:space="preserve">
          <source>If the reader does not support thumbnails, (&lt;code&gt;readerSupportsThumbnails&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;), an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown regardless of whether an input source has been set or whether the indices are in bounds.</source>
          <target state="translated">리더가 썸네일을 지원하지 않으면 ( &lt;code&gt;readerSupportsThumbnails&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 반환 함 ) 입력 소스가 설정되었는지 또는 인덱스가 범위 내에 있는지에 관계없이 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb2451c0113cb8c1e0775121dff8874d947bd15f" translate="yes" xml:space="preserve">
          <source>If the reader does not support thumbnails, (&lt;code&gt;readerSupportsThumbnails&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;), an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be thrown.</source>
          <target state="translated">리더가 썸네일을 지원하지 않으면 ( &lt;code&gt;readerSupportsThumbnails&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 반환 ) &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79b35d0dc9d2895dea0c8a3b110254c91b6bdc53" translate="yes" xml:space="preserve">
          <source>If the receiver is laying its &lt;code&gt;View&lt;/code&gt;s along the &lt;code&gt;Y_AXIS&lt;/code&gt;, this will return the value from invoking the same method on the &lt;code&gt;View&lt;/code&gt; responsible for rendering &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;bias&lt;/code&gt;. Otherwise this will return false.</source>
          <target state="translated">If the receiver is laying its &lt;code&gt;View&lt;/code&gt; s along the &lt;code&gt;Y_AXIS&lt;/code&gt; , this will return the value from invoking the same method on the &lt;code&gt;View&lt;/code&gt; responsible for rendering &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;bias&lt;/code&gt; . Otherwise this will return false.</target>
        </trans-unit>
        <trans-unit id="00cde4cc70dae1cb495d031cb9acb67bc8abef24" translate="yes" xml:space="preserve">
          <source>If the recognized year number is less than 100, it is interpreted as an abbreviated year relative to a century of which dates are within 80 years before and 19 years after the time when the Date class is initialized. After adjusting the year number, 1900 is subtracted from it. For example, if the current year is 1999 then years in the range 19 to 99 are assumed to mean 1919 to 1999, while years from 0 to 18 are assumed to mean 2000 to 2018. Note that this is slightly different from the interpretation of years less than 100 that is used in &lt;a href=&quot;../text/simpledateformat&quot;&gt;&lt;code&gt;SimpleDateFormat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인식 된 연도 수가 100보다 작은 경우 Date 클래스가 초기화 된 시간의 80 년 전과 19 년 후 날짜가 세기를 기준으로 약식 연도로 해석됩니다. 연도 번호를 조정 한 후 1900을 뺍니다. 예를 들어, 현재 연도가 1999 인 경우 19-99 범위의 연도는 1919-1999를 의미하고 0-18은 연도는 2000-2018을 의미한다고 가정합니다. 이는 연도 해석과 약간 다릅니다. 적은 100보다 그에서 사용 &lt;a href=&quot;../text/simpledateformat&quot;&gt; &lt;code&gt;SimpleDateFormat&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="010a039d9be90452e6c238ffa1c527f615bc99fe" translate="yes" xml:space="preserve">
          <source>If the recorded values contain infinities of one sign and an intermediate sum overflows to an infinity of the opposite sign, the sum may be NaN.</source>
          <target state="translated">If the recorded values contain infinities of one sign and an intermediate sum overflows to an infinity of the opposite sign, the sum may be NaN.</target>
        </trans-unit>
        <trans-unit id="fcacf666045f97e91725b22bc1de0a3b50a4cbe3" translate="yes" xml:space="preserve">
          <source>If the recorded values contain infinities of opposite sign, the sum will be NaN.</source>
          <target state="translated">If the recorded values contain infinities of opposite sign, the sum will be NaN.</target>
        </trans-unit>
        <trans-unit id="75c49e5b2d7ecad5d026c07a5fdde433fcf5271a" translate="yes" xml:space="preserve">
          <source>If the recorded values contain one or more infinities, the sum will be infinite or NaN.</source>
          <target state="translated">If the recorded values contain one or more infinities, the sum will be infinite or NaN.</target>
        </trans-unit>
        <trans-unit id="3499044671723182fe3ed32287d4d0e02001dbb2" translate="yes" xml:space="preserve">
          <source>If the recording is already closed, invoking this method has no effect.</source>
          <target state="translated">녹음이 이미 닫혀 있으면이 메서드를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="57ad84aa4b7a2b33d920b4d445e6eaeb418fc1cc" translate="yes" xml:space="preserve">
          <source>If the region is such that this width is zero, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">영역이이 폭이 0이되면 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5c3b8b1f31e8b1eb0578d0596a852433e7405f3a" translate="yes" xml:space="preserve">
          <source>If the relation is represented by an MBean (created by the user and added as a relation in the Relation Service), returns the ObjectName of the MBean.</source>
          <target state="translated">관계가 MBean으로 표시되면 (사용자가 작성하고 관계 서비스에서 관계로 추가 된 경우) MBean의 ObjectName을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a4fea0cc0a062ac6f4b44054eaf08ec5f2eead20" translate="yes" xml:space="preserve">
          <source>If the relationship between nested types is expressed directly through the &lt;code&gt;NestHost&lt;/code&gt; and &lt;code&gt;NestMembers&lt;/code&gt; attributes (see the Java Virtual Machine Specification, sections 4.7.28 and 4.7.29), then the associated &lt;code&gt;Lookup&lt;/code&gt; object provides direct access to the lookup class and all of its nestmates (see &lt;a href=&quot;../class#getNestHost()&quot;&gt;&lt;code&gt;Class.getNestHost&lt;/code&gt;&lt;/a&gt;). Otherwise, access between nested classes is obtained by the Java compiler creating a wrapper method to access a private method of another class in the same nest. For example, a nested class &lt;code&gt;C.D&lt;/code&gt; can access private members within other related classes such as &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;C.D.E&lt;/code&gt;, or &lt;code&gt;C.B&lt;/code&gt;, but the Java compiler may need to generate wrapper methods in those related classes. In such cases, a &lt;code&gt;Lookup&lt;/code&gt; object on &lt;code&gt;C.E&lt;/code&gt; would be unable to access those private members. A workaround for this limitation is the &lt;a href=&quot;#in(java.lang.Class)&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; method, which can transform a lookup on &lt;code&gt;C.E&lt;/code&gt; into one on any of those other classes, without special elevation of privilege.</source>
          <target state="translated">If the relationship between nested types is expressed directly through the &lt;code&gt;NestHost&lt;/code&gt; and &lt;code&gt;NestMembers&lt;/code&gt; attributes (see the Java Virtual Machine Specification, sections 4.7.28 and 4.7.29), then the associated &lt;code&gt;Lookup&lt;/code&gt; object provides direct access to the lookup class and all of its nestmates (see &lt;a href=&quot;../class#getNestHost()&quot;&gt; &lt;code&gt;Class.getNestHost&lt;/code&gt; &lt;/a&gt;). Otherwise, access between nested classes is obtained by the Java compiler creating a wrapper method to access a private method of another class in the same nest. For example, a nested class &lt;code&gt;C.D&lt;/code&gt; can access private members within other related classes such as &lt;code&gt;C&lt;/code&gt; , &lt;code&gt;C.D.E&lt;/code&gt; , or &lt;code&gt;C.B&lt;/code&gt; , but the Java compiler may need to generate wrapper methods in those related classes. In such cases, a &lt;code&gt;Lookup&lt;/code&gt; object on &lt;code&gt;C.E&lt;/code&gt; would be unable to access those private members. A workaround for this limitation is the &lt;a href=&quot;#in(java.lang.Class)&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; &lt;/a&gt; method, which can transform a lookup on &lt;code&gt;C.E&lt;/code&gt; into one on any of those other classes, without special elevation of privilege.</target>
        </trans-unit>
        <trans-unit id="47d94839dfe119ae8b427b70bc88efb6e6b48192" translate="yes" xml:space="preserve">
          <source>If the relationship between nested types is expressed directly through the &lt;code&gt;NestHost&lt;/code&gt; and &lt;code&gt;NestMembers&lt;/code&gt; attributes (see the Java Virtual Machine Specification, sections &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.7.28&quot;&gt;4.7.28&lt;/a&gt; and &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.7.29&quot;&gt;4.7.29&lt;/a&gt;), then the associated &lt;code&gt;Lookup&lt;/code&gt; object provides direct access to the lookup class and all of its nestmates (see &lt;a href=&quot;../class#getNestHost()&quot;&gt;&lt;code&gt;Class.getNestHost&lt;/code&gt;&lt;/a&gt;). Otherwise, access between nested classes is obtained by the Java compiler creating a wrapper method to access a private method of another class in the same nest. For example, a nested class &lt;code&gt;C.D&lt;/code&gt; can access private members within other related classes such as &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;C.D.E&lt;/code&gt;, or &lt;code&gt;C.B&lt;/code&gt;, but the Java compiler may need to generate wrapper methods in those related classes. In such cases, a &lt;code&gt;Lookup&lt;/code&gt; object on &lt;code&gt;C.E&lt;/code&gt; would be unable to access those private members. A workaround for this limitation is the &lt;a href=&quot;#in(java.lang.Class)&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; method, which can transform a lookup on &lt;code&gt;C.E&lt;/code&gt; into one on any of those other classes, without special elevation of privilege.</source>
          <target state="translated">중첩 된 유형 간의 관계가 &lt;code&gt;NestHost&lt;/code&gt; 및 &lt;code&gt;NestMembers&lt;/code&gt; 속성을 통해 직접 표현되는 경우 (Java Virtual Machine Specification, 섹션 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.7.28&quot;&gt;4.7.28&lt;/a&gt; 및 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.7.29&quot;&gt;4.7.29 참조&lt;/a&gt; ) 연결된 &lt;code&gt;Lookup&lt;/code&gt; 객체는 조회 클래스 및 모든 중첩에 대한 직접 액세스를 제공합니다. ( &lt;a href=&quot;../class#getNestHost()&quot;&gt; &lt;code&gt;Class.getNestHost&lt;/code&gt; &lt;/a&gt; 참조 ). 그렇지 않으면 중첩 된 클래스 간의 액세스는 동일한 중첩에있는 다른 클래스의 개인 메서드에 액세스하기위한 래퍼 메서드를 생성하는 Java 컴파일러에 의해 획득됩니다. 예를 들어 중첩 된 클래스 &lt;code&gt;C.D&lt;/code&gt; 는 &lt;code&gt;C&lt;/code&gt; , &lt;code&gt;C.D.E&lt;/code&gt; 또는 &lt;code&gt;C.B&lt;/code&gt; 와 같은 다른 관련 클래스 내의 전용 멤버에 액세스 할 수 있습니다.그러나 Java 컴파일러는 이러한 관련 클래스에서 래퍼 메서드를 생성해야 할 수 있습니다. 이러한 경우 &lt;code&gt;C.E&lt;/code&gt; 의 &lt;code&gt;Lookup&lt;/code&gt; 개체는 해당 개인 구성원에 액세스 할 수 없습니다. 이 제한에 대한 해결 방법은 &lt;a href=&quot;#in(java.lang.Class)&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; &lt;/a&gt; 메서드입니다.이 메서드 는 특별한 권한 상승없이 &lt;code&gt;C.E&lt;/code&gt; 에 대한 조회를 다른 클래스 중 하나로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16b1911621b01dde472303d885688d4202ac98fc" translate="yes" xml:space="preserve">
          <source>If the remapping function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed (or remains absent if initially absent). If the remapping function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">If the remapping function returns &lt;code&gt;null&lt;/code&gt; , the mapping is removed (or remains absent if initially absent). If the remapping function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</target>
        </trans-unit>
        <trans-unit id="eed62fa294d3e85832e433cc3d47b46c67241064" translate="yes" xml:space="preserve">
          <source>If the remapping function returns &lt;code&gt;null&lt;/code&gt;, the mapping is removed. If the remapping function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</source>
          <target state="translated">If the remapping function returns &lt;code&gt;null&lt;/code&gt; , the mapping is removed. If the remapping function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.</target>
        </trans-unit>
        <trans-unit id="6c90ca0b52fc5c89008817da193bca78cfc36ed6" translate="yes" xml:space="preserve">
          <source>If the remote MBean Server is 1.2</source>
          <target state="translated">리모트 MBean 서버가 1.2 인 경우</target>
        </trans-unit>
        <trans-unit id="03cc18ab3cabbd8e48236da939259f3b987d3f83" translate="yes" xml:space="preserve">
          <source>If the remote destination to which the socket is connected does not exist, or is otherwise unreachable, and if an ICMP destination unreachable packet has been received for that address, then a subsequent call to send or receive may throw a PortUnreachableException. Note, there is no guarantee that the exception will be thrown.</source>
          <target state="translated">소켓이 연결된 원격 대상이 존재하지 않거나 도달 할 수없는 경우 해당 주소에 대해 ICMP 대상 도달 불가능 패킷이 수신 된 경우, 후속 송신 또는 수신 호출에서 PortUnreachableException이 발생할 수 있습니다. 예외가 발생한다고 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="57098f4ee262627cd7b01db63d1f7f1265d43afa" translate="yes" xml:space="preserve">
          <source>If the requested attribute is not in the list, this is a no-op.</source>
          <target state="translated">If the requested attribute is not in the list, this is a no-op.</target>
        </trans-unit>
        <trans-unit id="018a97b62ca2a70069aed6a1c61c5a920e8d9cac" translate="yes" xml:space="preserve">
          <source>If the requested opacity value is less than &lt;code&gt;1.0f&lt;/code&gt;, and any of the above conditions are not met, the window opacity will not change, and the &lt;code&gt;IllegalComponentStateException&lt;/code&gt; will be thrown.</source>
          <target state="translated">If the requested opacity value is less than &lt;code&gt;1.0f&lt;/code&gt; , and any of the above conditions are not met, the window opacity will not change, and the &lt;code&gt;IllegalComponentStateException&lt;/code&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="1d89a1cc49adab461bf1f01dc66545d017f8bacb" translate="yes" xml:space="preserve">
          <source>If the requested option is binary, it can be set using this method by a java.lang.Boolean:</source>
          <target state="translated">요청 된 옵션이 이진 인 경우 java.lang.Boolean에서이 메소드를 사용하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38ce1c03b79a7b89afd15d63c7ba902df5495593" translate="yes" xml:space="preserve">
          <source>If the requested permission is allowed, this method returns quietly. If denied, a SecurityException is raised.</source>
          <target state="translated">요청 된 권한이 허용되면이 메소드는 자동으로 리턴합니다. 거부되면 SecurityException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f2e93c0c542e53839669b61ae87dd1ffe992a629" translate="yes" xml:space="preserve">
          <source>If the requested shape is not &lt;code&gt;null&lt;/code&gt;, and any of the above conditions are not met, the shape of this window will not change, and either the &lt;code&gt;UnsupportedOperationException&lt;/code&gt; or &lt;code&gt;
 IllegalComponentStateException&lt;/code&gt; will be thrown.</source>
          <target state="translated">If the requested shape is not &lt;code&gt;null&lt;/code&gt; , and any of the above conditions are not met, the shape of this window will not change, and either the &lt;code&gt;UnsupportedOperationException&lt;/code&gt; or &lt;code&gt; IllegalComponentStateException&lt;/code&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="4c37b9290b4ade460cdf802abd93f12770f8d7f0" translate="yes" xml:space="preserve">
          <source>If the required access and argument checks succeed and the instantiation will proceed, the constructor's declaring class is initialized if it has not already been initialized.</source>
          <target state="translated">필요한 액세스 및 인수 확인이 성공하고 인스턴스화가 진행되면 생성자의 선언 클래스가 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="0f30dad69df088eb0e8a01273d14f832b9a0aeff" translate="yes" xml:space="preserve">
          <source>If the required properties have not been set, an exception is thrown. If this method is successful, the current contents of the rowset are discarded and the rowset's metadata is also (re)set. If there are outstanding updates, they are ignored.</source>
          <target state="translated">If the required properties have not been set, an exception is thrown. If this method is successful, the current contents of the rowset are discarded and the rowset's metadata is also (re)set. If there are outstanding updates, they are ignored.</target>
        </trans-unit>
        <trans-unit id="1eeec4d99736a2aab560f80ec43309d2f90d3ed3" translate="yes" xml:space="preserve">
          <source>If the resolver argument is null, the URIResolver value will be cleared and the transformer will no longer have a resolver.</source>
          <target state="translated">If the resolver argument is null, the URIResolver value will be cleared and the transformer will no longer have a resolver.</target>
        </trans-unit>
        <trans-unit id="fa7d4a7621c617404117d28c394ccda5b256dfa2" translate="yes" xml:space="preserve">
          <source>If the resource manager did not commit the transaction and the paramether onePhase is set to true, the resource manager may throw one of the XA_RB* exceptions. Upon return, the resource manager has rolled back the branch's work and has released all held resources.</source>
          <target state="translated">If the resource manager did not commit the transaction and the paramether onePhase is set to true, the resource manager may throw one of the XA_RB* exceptions. Upon return, the resource manager has rolled back the branch's work and has released all held resources.</target>
        </trans-unit>
        <trans-unit id="03e08a40eb5811e25250f7c549a9fd7b28757670" translate="yes" xml:space="preserve">
          <source>If the resource name ends with &quot;&lt;code&gt;.class&lt;/code&gt;&quot; then it is not encapsulated.</source>
          <target state="translated">If the resource name ends with &quot; &lt;code&gt;.class&lt;/code&gt; &quot; then it is not encapsulated.</target>
        </trans-unit>
        <trans-unit id="62e2c41caf4aaf142a44a8c6c165f53c1d68b4be" translate="yes" xml:space="preserve">
          <source>If the result of this method is used to access the event source, for example, to look up the object or get its attributes, then it needs to be locked because implementations of &lt;code&gt;Context&lt;/code&gt; are not guaranteed to be thread-safe (and &lt;code&gt;EventContext&lt;/code&gt; is a subinterface of &lt;code&gt;Context&lt;/code&gt;). See the &lt;a href=&quot;package-summary#THREADING&quot;&gt;package description&lt;/a&gt; for more information on threading issues.</source>
          <target state="translated">이 메소드의 결과가 예를 들어 오브젝트를 찾거나 속성을 얻는 등의 이벤트 소스에 액세스하는 데 사용되는 경우 &lt;code&gt;Context&lt;/code&gt; 구현은 스레드로부터 안전하지 않기 때문에 잠겨 야 합니다 (그리고 &lt;code&gt;EventContext&lt;/code&gt; 는 &lt;code&gt;Context&lt;/code&gt; 의 하위 인터페이스 ). 스레딩 문제에 대한 자세한 내용은 &lt;a href=&quot;package-summary#THREADING&quot;&gt;패키지 설명&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da3549687bea03167816a9b17ffaee344e82b496" translate="yes" xml:space="preserve">
          <source>If the resulting &lt;code&gt;OffsetDateTime&lt;/code&gt; is invalid, an exception is thrown. The time and offset do not affect the calculation and will be the same in the result.</source>
          <target state="translated">결과 &lt;code&gt;OffsetDateTime&lt;/code&gt; 이 유효하지 않으면 예외가 발생합니다. 시간과 오프셋은 계산에 영향을 미치지 않으며 결과에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="35a287431d52af9ee48c2d5a75b9272669222ecb" translate="yes" xml:space="preserve">
          <source>If the resulting &lt;code&gt;Rectangle&lt;/code&gt; would have a dimension too large to be expressed as an &lt;code&gt;int&lt;/code&gt;, the result will have a dimension of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; along that dimension.</source>
          <target state="translated">If the resulting &lt;code&gt;Rectangle&lt;/code&gt; would have a dimension too large to be expressed as an &lt;code&gt;int&lt;/code&gt; , the result will have a dimension of &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; along that dimension.</target>
        </trans-unit>
        <trans-unit id="1d921983024b3a73fd6c36177cb6aac0894e7d34" translate="yes" xml:space="preserve">
          <source>If the resulting configuration defines a level for a logger and if the resulting level is different than the level specified in the the old configuration, or not specified in the old configuration, then if the logger exists or if children for that logger exist, the level for that logger will be updated, and the change propagated to any existing logger children. This may cause the logger to be created, if necessary.</source>
          <target state="translated">If the resulting configuration defines a level for a logger and if the resulting level is different than the level specified in the the old configuration, or not specified in the old configuration, then if the logger exists or if children for that logger exist, the level for that logger will be updated, and the change propagated to any existing logger children. This may cause the logger to be created, if necessary.</target>
        </trans-unit>
        <trans-unit id="587aeb87194f308dfa93440ba8ff79e1c3891aa4" translate="yes" xml:space="preserve">
          <source>If the resulting configuration defines a list of handlers for a logger, and if the resulting list is different than the list specified in the old configuration for that logger (that could be empty), then if the logger exists or its children exist, the handlers associated with that logger are closed and removed and the new handlers will be created per the resulting configuration and added to that logger, creating that logger if necessary.</source>
          <target state="translated">If the resulting configuration defines a list of handlers for a logger, and if the resulting list is different than the list specified in the old configuration for that logger (that could be empty), then if the logger exists or its children exist, the handlers associated with that logger are closed and removed and the new handlers will be created per the resulting configuration and added to that logger, creating that logger if necessary.</target>
        </trans-unit>
        <trans-unit id="8a3d11d3b73e216be8517618d151d35e100edd64" translate="yes" xml:space="preserve">
          <source>If the resulting date is invalid, an exception is thrown.</source>
          <target state="translated">결과 날짜가 유효하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6ca351660a2dc03d4cb71b7bc124559d23a4db29" translate="yes" xml:space="preserve">
          <source>If the resulting date-time is invalid, an exception is thrown.</source>
          <target state="translated">결과 날짜-시간이 유효하지 않은 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="44ca6bebbc9287dfb9c1097c7e056b162daf7bcb" translate="yes" xml:space="preserve">
          <source>If the resulting date-time is invalid, an exception is thrown. The time does not affect the calculation and will be the same in the result.</source>
          <target state="translated">결과 날짜-시간이 유효하지 않은 경우 예외가 발생합니다. 시간은 계산에 영향을 미치지 않으며 결과에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4f6dc2bf2873abab7867f3b616c93e4b15b446fa" translate="yes" xml:space="preserve">
          <source>If the return type &lt;em&gt;T0&lt;/em&gt; is void and &lt;em&gt;T1&lt;/em&gt; a primitive, a zero value is introduced.</source>
          <target state="translated">리턴 유형 &lt;em&gt;T0&lt;/em&gt; 이 void이고 &lt;em&gt;T1&lt;/em&gt; 이 기본이면 0 값이 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="f822d109dcf5c55256ad0bbca3b4f4180ce12367" translate="yes" xml:space="preserve">
          <source>If the return type &lt;em&gt;T0&lt;/em&gt; is void and &lt;em&gt;T1&lt;/em&gt; a reference, a null value is introduced.</source>
          <target state="translated">리턴 유형 &lt;em&gt;T0&lt;/em&gt; 이 void이고 &lt;em&gt;T1&lt;/em&gt; 이 참조이면 널값이 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="22bfe5b1532d3b1937f6f097fa6b7e18ec35a472" translate="yes" xml:space="preserve">
          <source>If the return type &lt;em&gt;T1&lt;/em&gt; is marked as void, any returned value is discarded</source>
          <target state="translated">반환 유형 &lt;em&gt;T1&lt;/em&gt; 이 void로 표시되면 반환 된 값이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="d8afd9f745cfb7d28652f05e0fd4637227b676db" translate="yes" xml:space="preserve">
          <source>If the return type is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type arguments used in the source code.</source>
          <target state="translated">반환 형식이 매개 변수가있는 형식 인 경우 반환 된 &lt;code&gt;Type&lt;/code&gt; 개체는 소스 코드에 사용 된 실제 형식 인수를 정확하게 반영해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a413e6168d2b6897adbb71ca65aa2bb806445d1" translate="yes" xml:space="preserve">
          <source>If the return type is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type parameters used in the source code.</source>
          <target state="translated">리턴 유형이 매개 변수화 된 유형 인 경우 리턴 된 &lt;code&gt;Type&lt;/code&gt; 오브젝트는 소스 코드에 사용 된 실제 유형 매개 변수를 정확하게 반영해야합니다.</target>
        </trans-unit>
        <trans-unit id="c790d87847b61c0198be1f5880f62ee8cbf59f42" translate="yes" xml:space="preserve">
          <source>If the return type is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">리턴 유형이 유형 변수 또는 매개 변수화 된 유형 인 경우 작성됩니다. 그렇지 않으면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="29af74f5a09429dcfd9193c144c392b2c8199600" translate="yes" xml:space="preserve">
          <source>If the return type of any of the methods is a primitive type or void, then all of the methods must have that same return type.</source>
          <target state="translated">메소드의 리턴 유형이 기본 유형이거나 void 인 경우 모든 메소드는 동일한 리턴 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="a5a546d9693c1042591033e7eb00ca2f2a455047" translate="yes" xml:space="preserve">
          <source>If the return value is &lt;code&gt;non-null&lt;/code&gt;, all attributes in the returned set are unsupported with this &lt;code&gt;DocFlavor&lt;/code&gt;. The returned set does not distinguish attribute categories that are unsupported from unsupported attribute values.</source>
          <target state="translated">If the return value is &lt;code&gt;non-null&lt;/code&gt; , all attributes in the returned set are unsupported with this &lt;code&gt;DocFlavor&lt;/code&gt; . The returned set does not distinguish attribute categories that are unsupported from unsupported attribute values.</target>
        </trans-unit>
        <trans-unit id="17d771c49fde9fd06df899fa732fea09b1398c4a" translate="yes" xml:space="preserve">
          <source>If the return value is non-null, all attributes in the returned set are unsupported with this DocFlavor. The returned set does not distinguish attribute categories that are unsupported from unsupported attribute values.</source>
          <target state="translated">리턴 값이 널이 아닌 경우, 리턴 된 세트의 모든 속성이이 DocFlavor에서 지원되지 않습니다. 리턴 된 세트는 지원되지 않는 속성 값과 지원되지 않는 속성 카테고리를 구별하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5779215ae457d29d8170805afb88e18c9cd73378" translate="yes" xml:space="preserve">
          <source>If the returned VarHandle is operated on, the declaring class will be initialized, if it has not already been initialized.</source>
          <target state="translated">If the returned VarHandle is operated on, the declaring class will be initialized, if it has not already been initialized.</target>
        </trans-unit>
        <trans-unit id="eccb50eb8fca6c917cb62a8ea7ba110f808e9efb" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked with a &lt;code&gt;null&lt;/code&gt; array reference, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</source>
          <target state="translated">If the returned method handle is invoked with a &lt;code&gt;null&lt;/code&gt; array reference, a &lt;code&gt;NullPointerException&lt;/code&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="a121ca0e7664dd7a93409420197145f4f87f1e39" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked with a negative array size, a &lt;code&gt;NegativeArraySizeException&lt;/code&gt; will be thrown.</source>
          <target state="translated">If the returned method handle is invoked with a negative array size, a &lt;code&gt;NegativeArraySizeException&lt;/code&gt; will be thrown.</target>
        </trans-unit>
        <trans-unit id="d67afcae574c0dadec33d0948d30e110523b788e" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked, the constructor's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">리턴 된 메소드 핸들이 호출되면 생성자의 클래스가 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="bba8a24f154f8c33c7318be4afad7cbac85009fd" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked, the field's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">리턴 된 메소드 핸들이 호출되면 필드의 클래스가 아직 초기화되지 않은 경우 필드 클래스가 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="51fb639a4d11801aea7b926f5d54285fffc4a0fb" translate="yes" xml:space="preserve">
          <source>If the returned method handle is invoked, the method's class will be initialized, if it has not already been initialized.</source>
          <target state="translated">리턴 된 메소드 핸들이 호출되면 메소드의 클래스가 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="062c7a8a96f0cd16df82fd6a3d7ef90b21f0c525" translate="yes" xml:space="preserve">
          <source>If the returned node did not exist prior to this call, this node and any ancestors that were created by this call are not guaranteed to become permanent until the &lt;code&gt;flush&lt;/code&gt; method is called on the returned node (or one of its ancestors or descendants).</source>
          <target state="translated">이 호출 이전에 리턴 된 노드가 존재하지 않으면이 노드와이 호출로 작성된 상위 노드는 리턴 된 노드 (또는 상위 또는 하위 항목 중 하나) 에서 &lt;code&gt;flush&lt;/code&gt; 메소드가 호출 될 때까지 영구적으로 보장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="31845fc89c4f6a02a974ef2eb4b2ee1fabe487a0" translate="yes" xml:space="preserve">
          <source>If the returned object represents a &lt;a href=&quot;javafileobject.kind#SOURCE&quot;&gt;source&lt;/a&gt; or &lt;a href=&quot;javafileobject.kind#CLASS&quot;&gt;class&lt;/a&gt; file, it must be an instance of &lt;a href=&quot;javafileobject&quot;&gt;&lt;code&gt;JavaFileObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 오브젝트가 &lt;a href=&quot;javafileobject.kind#SOURCE&quot;&gt;소스&lt;/a&gt; 또는 &lt;a href=&quot;javafileobject.kind#CLASS&quot;&gt;클래스&lt;/a&gt; 파일을 나타내는 경우 &lt;a href=&quot;javafileobject&quot;&gt; &lt;code&gt;JavaFileObject&lt;/code&gt; &lt;/a&gt; 의 인스턴스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="730234ede727312ada9b756fde5db3279ce11863" translate="yes" xml:space="preserve">
          <source>If the root node isn't visible, it is generally a good to make this value true. Otherwise, the tree looks exactly like a list, and users may not know that the &quot;list entries&quot; are actually tree nodes.</source>
          <target state="translated">If the root node isn't visible, it is generally a good to make this value true. Otherwise, the tree looks exactly like a list, and users may not know that the &quot;list entries&quot; are actually tree nodes.</target>
        </trans-unit>
        <trans-unit id="5ec11db983f71de1343f50235b7b5724bd516b85" translate="yes" xml:space="preserve">
          <source>If the row number is positive, the cursor moves to the given row number with respect to the beginning of the result set. The first row is row 1, the second is row 2, and so on.</source>
          <target state="translated">If the row number is positive, the cursor moves to the given row number with respect to the beginning of the result set. The first row is row 1, the second is row 2, and so on.</target>
        </trans-unit>
        <trans-unit id="dca61f9ccb26f5859e93cf51aef9999003d9187e" translate="yes" xml:space="preserve">
          <source>If the row number specified is zero, the cursor is moved to before the first row.</source>
          <target state="translated">If the row number specified is zero, the cursor is moved to before the first row.</target>
        </trans-unit>
        <trans-unit id="6e65e674c2c9738a67b46cbdff85eddf6bd7d6d6" translate="yes" xml:space="preserve">
          <source>If the rule defines a week where the cutover might occur, then this method returns the day-of-week that the month-day will be adjusted to. If the day is positive then the adjustment is later. If the day is negative then the adjustment is earlier.</source>
          <target state="translated">규칙이 컷 오버가 발생할 수있는 주를 정의하면이 방법은 월이 조정될 요일을 반환합니다. 일이 양수이면 나중에 조정됩니다. 일이 음수이면 조정이 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ab9f1126ac23de664120eeb0433d59deaee2f7bd" translate="yes" xml:space="preserve">
          <source>If the rule defines a week where the transition might occur, then the day defines either the start of the end of the transition week.</source>
          <target state="translated">규칙에서 전환이 발생할 수있는 주를 정의하면 해당 요일은 전환 주 끝의 시작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="89f95b53b5119c06e7c28d0a4953b38d65679d33" translate="yes" xml:space="preserve">
          <source>If the rule defines a week where the transition might occur, then the month if the month of either the earliest or latest possible date of the cutover.</source>
          <target state="translated">규칙에서 전환이 발생할 수있는 주를 정의하는 경우 컷 오버의 가장 빠른 날짜 또는 가장 최근 달인 월입니다.</target>
        </trans-unit>
        <trans-unit id="c5876d137cd994c7ad4a664d7beaa1b898954c4d" translate="yes" xml:space="preserve">
          <source>If the rule defines an exact date then the day is the month of that date.</source>
          <target state="translated">규칙이 정확한 날짜를 정의하면 그 날짜는 해당 날짜의 월입니다.</target>
        </trans-unit>
        <trans-unit id="7a405331c7ddef3021a3335c00454f67145186ff" translate="yes" xml:space="preserve">
          <source>If the rule defines an exact date then the month is the month of that date.</source>
          <target state="translated">규칙이 정확한 날짜를 정의하면 해당 월이 해당 날짜의 월입니다.</target>
        </trans-unit>
        <trans-unit id="5034d0b228d4988928265c1d8ac1f628685a4b7f" translate="yes" xml:space="preserve">
          <source>If the rule defines an exact date then this returns null.</source>
          <target state="translated">규칙이 정확한 날짜를 정의하면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="188251de9eebdf9999e55d3130ae4d68d97ee026" translate="yes" xml:space="preserve">
          <source>If the same &lt;code&gt;Action&lt;/code&gt; is used with menus and buttons you'll typically specify both a &lt;code&gt;SMALL_ICON&lt;/code&gt; and a &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt;. The menu will use the &lt;code&gt;SMALL_ICON&lt;/code&gt; and the button the &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt;.</source>
          <target state="translated">같은 경우 &lt;code&gt;Action&lt;/code&gt; 메뉴와 버튼을 사용하면 일반적으로 모두 지정해야 &lt;code&gt;SMALL_ICON&lt;/code&gt; 과 &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt; 를 . 메뉴는 사용 &lt;code&gt;SMALL_ICON&lt;/code&gt; 과 버튼 &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="77685adc8a0c8449f2dc16b0f092c4e3cf760fa3" translate="yes" xml:space="preserve">
          <source>If the same &lt;code&gt;Action&lt;/code&gt; is used with menus and buttons you'll typically specify both a &lt;code&gt;SMALL_ICON&lt;/code&gt; and a &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt;. The menu will use the &lt;code&gt;SMALL_ICON&lt;/code&gt; and the button will use the &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt;.</source>
          <target state="translated">같은 경우 &lt;code&gt;Action&lt;/code&gt; 메뉴와 버튼을 사용하면 일반적으로 모두 지정해야 &lt;code&gt;SMALL_ICON&lt;/code&gt; 과 &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt; 를 . 메뉴는 &lt;code&gt;SMALL_ICON&lt;/code&gt; 을 사용하고 버튼은 &lt;code&gt;LARGE_ICON_KEY&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="2f0e91ac8cea622cd628a97cacbf583516eb1203" translate="yes" xml:space="preserve">
          <source>If the same MXBean were registered under two different &lt;code&gt;ObjectName&lt;/code&gt;s, a reference to that MXBean from another MXBean would be ambiguous. Therefore, if an MXBean object is already registered in an MBean Server and an attempt is made to register it in the same MBean Server under another name, the result is an &lt;a href=&quot;instancealreadyexistsexception&quot;&gt;&lt;code&gt;InstanceAlreadyExistsException&lt;/code&gt;&lt;/a&gt;. Registering the same MBean object under more than one name is discouraged in general, notably because it does not work well for MBeans that are &lt;a href=&quot;notificationbroadcaster&quot;&gt;&lt;code&gt;NotificationBroadcaster&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">동일한 MXBean이 두 개의 다른 &lt;code&gt;ObjectName&lt;/code&gt; 아래에 등록 된 경우 다른 MXBean에서 해당 MXBean에 대한 참조가 모호합니다. 따라서 MXBean 객체가 이미 MBean 서버에 등록되어 있고 다른 이름으로 동일한 MBean 서버에 등록하려고하면 결과는 &lt;a href=&quot;instancealreadyexistsexception&quot;&gt; &lt;code&gt;InstanceAlreadyExistsException&lt;/code&gt; &lt;/a&gt; 입니다. 하나 이상의 이름으로 동일한 MBean 객체를 등록하는 것은 일반적으로 권장되지 않습니다. 특히 &lt;a href=&quot;notificationbroadcaster&quot;&gt; &lt;code&gt;NotificationBroadcaster&lt;/code&gt; 인&lt;/a&gt; MBean에서는 제대로 작동하지 않기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="50eb773388c08998af191260a43e85de5e2d0eab" translate="yes" xml:space="preserve">
          <source>If the same listener is added more than once, it is considered as many times as it was added. It is often useful to add the same listener with different filters or handback objects.</source>
          <target state="translated">동일한 리스너가 두 번 이상 추가되면 추가 된 횟수만큼 간주됩니다. 필터 나 핸드백 객체가 다른 동일한 리스너를 추가하는 것이 유용한 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="7408f6bcba8070d6e3a1c46a3adc49506ab7c38a" translate="yes" xml:space="preserve">
          <source>If the same listener is added multiple times, only one instance is removed.</source>
          <target state="translated">동일한 리스너가 여러 번 추가되면 하나의 인스턴스 만 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a530990bfaa8ba340ab7814bcb938600df0674e3" translate="yes" xml:space="preserve">
          <source>If the same listener was added more than once, it will be notified one less time after being removed. If &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, or was never added, no exception is thrown and no action is taken.</source>
          <target state="translated">동일한 리스너가 두 번 이상 추가 된 경우 제거 된 후 한 번 덜 알림을받습니다. 경우 &lt;code&gt;listener&lt;/code&gt; 있다 &lt;code&gt;null&lt;/code&gt; , 또는 추가되지 않았다, 예외는 throw되지 않고, 아무것도 처리는 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a2f1faa361a4f239eecfaa4480ce58bb66c8e63" translate="yes" xml:space="preserve">
          <source>If the scale is greater than or equal to zero and the adjusted exponent is greater than or equal to &lt;code&gt;-6&lt;/code&gt;, the number will be converted to a character form without using exponential notation. In this case, if the scale is zero then no decimal point is added and if the scale is positive a decimal point will be inserted with the scale specifying the number of characters to the right of the decimal point. &lt;code&gt;'0'&lt;/code&gt; characters are added to the left of the converted unscaled value as necessary. If no character precedes the decimal point after this insertion then a conventional &lt;code&gt;'0'&lt;/code&gt; character is prefixed.</source>
          <target state="translated">스케일이 0보다 크거나 조정 된 지수가 &lt;code&gt;-6&lt;/code&gt; 보다 크거나 같은 경우 , 지수 표기법을 사용하지 않고 숫자가 문자 형식으로 변환됩니다. 이 경우 스케일이 0이면 소수점이 추가되지 않고 스케일이 양수이면 소수점 오른쪽에 문자 수를 지정하는 스케일과 함께 소수점이 삽입됩니다. 필요에 따라 변환 된 스케일링되지 않은 값의 왼쪽에 &lt;code&gt;'0'&lt;/code&gt; 문자가 추가됩니다. 이 삽입 후 소수점 앞에 문자가 없으면 일반적인 &lt;code&gt;'0'&lt;/code&gt; 문자가 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="b6699480c9af01ef59363f0886670fc80f9f3dd6" translate="yes" xml:space="preserve">
          <source>If the scheme component is defined in the given spec and does not match the scheme of the context, then the new URL is created as an absolute URL based on the spec alone. Otherwise the scheme component is inherited from the context URL.</source>
          <target state="translated">스킴 구성 요소가 지정된 스펙에 정의되어 있고 컨텍스트의 스킴과 일치하지 않으면 스펙 만 기반으로 새 URL이 절대 URL로 작성됩니다. 그렇지 않으면 스킴 구성 요소가 컨텍스트 URL에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="0f6fbda65188dadd280d2d62127e7bf188917970" translate="yes" xml:space="preserve">
          <source>If the screens configuration does not allow the window to be moved from one screen to another, then the window is only placed at the location determined according to the above conditions and its &lt;code&gt;GraphicsConfiguration&lt;/code&gt; is not changed.</source>
          <target state="translated">화면 구성에서 창을 한 화면에서 다른 화면으로 이동할 수없는 경우 창은 위의 조건에 따라 결정된 위치에만 배치되고 &lt;code&gt;GraphicsConfiguration&lt;/code&gt; 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9dcb8547b15783f8929c319cccddbb69b3b6cf00" translate="yes" xml:space="preserve">
          <source>If the scrollbar display policy is defined as &quot;never&quot;, then the scrollpane can still be programmatically scrolled using the setScrollPosition() method and the scrollpane will move and clip the child's contents appropriately. This policy is useful if the program needs to create and manage its own adjustable controls.</source>
          <target state="translated">스크롤바 표시 정책이 &quot;never&quot;로 정의되어있는 경우 setScrollPosition () 메서드를 사용하여 스크롤 창을 프로그래밍 방식으로 계속 스크롤 할 수 있으며 스크롤 창은 자식의 콘텐츠를 적절하게 이동하고 클립합니다. 이 정책은 프로그램이 자체 조정 가능한 컨트롤을 만들고 관리해야하는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="481d140f57a30b2cc9e64db972e10c648c8a2a3b" translate="yes" xml:space="preserve">
          <source>If the scrollpane has a non-&lt;code&gt;null&lt;/code&gt;&lt;code&gt;viewportBorder&lt;/code&gt;, then space is allocated for that.</source>
          <target state="translated">scrollpane에 &lt;code&gt;null&lt;/code&gt; 이 아닌 &lt;code&gt;viewportBorder&lt;/code&gt; 가 있으면 공간이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="6ccd5d8778f5d88a5474e8c59978eccee5689a2e" translate="yes" xml:space="preserve">
          <source>If the second argument is 1.0, then the result is the same as the first argument.</source>
          <target state="translated">두 번째 인수가 1.0이면 결과는 첫 번째 인수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8344687c76c61e184619d725d0545c562c31518" translate="yes" xml:space="preserve">
          <source>If the second argument is NaN, then the result is NaN.</source>
          <target state="translated">두 번째 인수가 NaN이면 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="728f5c52b29916aebc4c06ac0928425a83bcd984" translate="yes" xml:space="preserve">
          <source>If the second argument is an &lt;code&gt;InputStream&lt;/code&gt; then the stream must contain number of bytes specified by scaleOrLength. If the second argument is a &lt;code&gt;Reader&lt;/code&gt; then the reader must contain the number of characters specified by scaleOrLength. If these conditions are not true the driver will generate a &lt;code&gt;SQLException&lt;/code&gt; when the statement is executed.</source>
          <target state="translated">두 번째 인수가 &lt;code&gt;InputStream&lt;/code&gt; 이면 스트림에는 scaleOrLength로 지정된 바이트 수가 포함되어야합니다. 두 번째 인수가 &lt;code&gt;Reader&lt;/code&gt; 인 경우 판독기는 scaleOrLength로 지정된 문자 수를 포함해야합니다. 이러한 조건이 참이 아닌 경우 드라이버는 명령문이 실행될 때 &lt;code&gt;SQLException&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="5e66ea14e901f2694aafe98690642d15fedd9f3e" translate="yes" xml:space="preserve">
          <source>If the second argument is an &lt;code&gt;InputStream&lt;/code&gt; then the stream must contain the number of bytes specified by scaleOrLength. If the second argument is a &lt;code&gt;Reader&lt;/code&gt; then the reader must contain the number of characters specified by scaleOrLength. If these conditions are not true the driver will generate a &lt;code&gt;SQLException&lt;/code&gt; when the statement is executed.</source>
          <target state="translated">두 번째 인수가 &lt;code&gt;InputStream&lt;/code&gt; 이면 스트림에는 scaleOrLength로 지정된 바이트 수가 포함되어야합니다. 두 번째 인수가 &lt;code&gt;Reader&lt;/code&gt; 인 경우 판독기는 scaleOrLength로 지정된 문자 수를 포함해야합니다. 이러한 조건이 참이 아닌 경우 드라이버는 명령문이 실행될 때 &lt;code&gt;SQLException&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="83af07e72de969c0ada685452a5155bf504024e7" translate="yes" xml:space="preserve">
          <source>If the second argument is positive or negative zero, then the result is 1.0.</source>
          <target state="translated">두 번째 인수가 양수 또는 음수 0이면 결과는 1.0입니다.</target>
        </trans-unit>
        <trans-unit id="9b941ca67a1b9bc33a6bb0d7bf06f63dc95c2df8" translate="yes" xml:space="preserve">
          <source>If the second-of-minute is not available then jump to the next space.</source>
          <target state="translated">초를 사용할 수 없으면 다음 공간으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="6ea372174aa5c23af0c1777c675872adacfad266" translate="yes" xml:space="preserve">
          <source>If the second-of-minute is not available then the format is complete.</source>
          <target state="translated">초를 사용할 수 없으면 형식이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0ca0c8f14e74d6e3c35517091b31f9d9d7a6b0c" translate="yes" xml:space="preserve">
          <source>If the seconds field carries more digits than milli-second order, those will be simply discarded (or in other words, rounded to zero.) For example, for any &lt;code&gt;Date&lt;/code&gt; value &lt;code&gt;x&lt;/code&gt;,</source>
          <target state="translated">초 필드가 밀리 초 순서보다 많은 자릿수를 전달하는 경우 해당 숫자는 단순히 버려집니다 (즉, 0으로 반올림됩니다.). 예를 들어, &lt;code&gt;Date&lt;/code&gt; 값 &lt;code&gt;x&lt;/code&gt; 의 경우 ,</target>
        </trans-unit>
        <trans-unit id="6762d0d3f73a120d76591aa7109ff493352a5101" translate="yes" xml:space="preserve">
          <source>If the seconds field carries more digits than milli-second order, those will be simply discarded (or in other words, rounded to zero.) For example, for any Calendar value &lt;code&gt;x&lt;/code&gt;,</source>
          <target state="translated">초 필드가 밀리 초 순서보다 많은 숫자를 전달하는 경우 해당 숫자는 단순히 버려집니다 (즉, 0으로 반올림됩니다.). 예를 들어, 달력 값 &lt;code&gt;x&lt;/code&gt; 의 경우 ,</target>
        </trans-unit>
        <trans-unit id="5653b3f59b63219b61535639dd8eec29f7dad782" translate="yes" xml:space="preserve">
          <source>If the security property is set to the fully qualified name of a &lt;code&gt;CallbackHandler&lt;/code&gt; implementation class, then a &lt;code&gt;LoginContext&lt;/code&gt; will load the specified &lt;code&gt;CallbackHandler&lt;/code&gt; and pass it to the underlying LoginModules. The &lt;code&gt;LoginContext&lt;/code&gt; only loads the default handler if it was not provided one.</source>
          <target state="translated">보안 특성이 &lt;code&gt;CallbackHandler&lt;/code&gt; 구현 클래스 의 완전한 이름으로 설정 되면 &lt;code&gt;LoginContext&lt;/code&gt; 는 지정된 &lt;code&gt;CallbackHandler&lt;/code&gt; 를로드 하여 기본 LoginModules에 전달합니다. &lt;code&gt;LoginContext&lt;/code&gt; 만 하나를 제공하지 않은 경우 기본 핸들러를로드합니다.</target>
        </trans-unit>
        <trans-unit id="d64a3fa99372fe6ed29fb93b51136151680efc81" translate="yes" xml:space="preserve">
          <source>If the selection includes the leftmost (topmost) position, the selection is extended to the left (top) of &lt;code&gt;bounds&lt;/code&gt;. If the selection includes the rightmost (bottommost) position, the selection is extended to the right (bottom) of the bounds. The height (width on vertical lines) of the selection is always extended to &lt;code&gt;bounds&lt;/code&gt;.</source>
          <target state="translated">선택 항목에 가장 왼쪽 (맨 위) 위치가 포함 된 경우 선택 항목은 &lt;code&gt;bounds&lt;/code&gt; 의 왼쪽 (맨 위)으로 확장됩니다 . 선택 항목에 맨 오른쪽 (맨 아래) 위치가 포함 된 경우 선택 영역이 경계의 오른쪽 (맨 아래)으로 확장됩니다. 선택 항목의 높이 (수직선 너비)는 항상 &lt;code&gt;bounds&lt;/code&gt; 로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c6ce13905c3b53f290f1fe802b6aed3d33f0e9f" translate="yes" xml:space="preserve">
          <source>If the selection mode is &lt;code&gt;CONTIGUOUS_TREE_SELECTION&lt;/code&gt;, and adding the new paths would make the selection discontiguous. Then two things can result: if the TreePaths in &lt;code&gt;paths&lt;/code&gt; are contiguous, then the selection becomes these TreePaths, otherwise the TreePaths aren't contiguous and the selection becomes the first TreePath in &lt;code&gt;paths&lt;/code&gt;.</source>
          <target state="translated">선택 모드가 &lt;code&gt;CONTIGUOUS_TREE_SELECTION&lt;/code&gt; 이고 새 경로를 추가하면 선택이 불 연속적으로됩니다. 그러면 두 가지 결과가 발생할 수 있습니다. &lt;code&gt;paths&lt;/code&gt; 의 TreePath 가 연속적이면 선택 항목이 이러한 TreePath가되고 그렇지 않으면 TreePath가 연속적이지 않고 선택 항목이 &lt;code&gt;paths&lt;/code&gt; 의 첫 번째 TreePath가됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e2c6505b616998dc824a56fb69330d1ffe1a66c" translate="yes" xml:space="preserve">
          <source>If the selection mode is &lt;code&gt;SINGLE_TREE_SELECTION&lt;/code&gt; and more than one TreePath is selected, the selection is reset to contain the first path currently selected.</source>
          <target state="translated">선택 모드가 &lt;code&gt;SINGLE_TREE_SELECTION&lt;/code&gt; 이고 둘 이상의 TreePath를 선택한 경우 현재 선택한 첫 번째 경로를 포함하도록 선택 항목이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a9329c3f6f88e34510974b909e266bf49fd3da54" translate="yes" xml:space="preserve">
          <source>If the selection range includes the first logical character, the selection is extended to the portion of &lt;code&gt;bounds&lt;/code&gt; before the start of this &lt;code&gt;TextLayout&lt;/code&gt;. If the range includes the last logical character, the selection is extended to the portion of &lt;code&gt;bounds&lt;/code&gt; after the end of this &lt;code&gt;TextLayout&lt;/code&gt;. The height (width on vertical lines) of the selection is always extended to &lt;code&gt;bounds&lt;/code&gt;.</source>
          <target state="translated">선택 범위에 첫 번째 논리 문자가 포함 된 경우 선택 영역은 이 &lt;code&gt;TextLayout&lt;/code&gt; 시작 전 &lt;code&gt;bounds&lt;/code&gt; 부분까지 확장됩니다 . 범위에 마지막 논리 문자가 포함 된 경우 선택 &lt;code&gt;bounds&lt;/code&gt; 은이 &lt;code&gt;TextLayout&lt;/code&gt; 끝 이후 의 경계 부분까지 확장됩니다 . 선택 항목의 높이 (수직선 너비)는 항상 &lt;code&gt;bounds&lt;/code&gt; 로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6707140df46f6eb04938367483bc2c365bdb2e5" translate="yes" xml:space="preserve">
          <source>If the selector has already been closed then this method returns immediately. Otherwise it marks the selector as closed and then invokes the &lt;a href=&quot;#implCloseSelector()&quot;&gt;&lt;code&gt;implCloseSelector&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">선택기가 이미 닫힌 경우이 메서드는 즉시 반환됩니다. 그렇지 않으면 선택기를 닫힌 것으로 표시 한 다음 닫기 작업을 완료하기 위해 &lt;a href=&quot;#implCloseSelector()&quot;&gt; &lt;code&gt;implCloseSelector&lt;/code&gt; &lt;/a&gt; 메서드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="08dd4228bba4510d42bc79e395b01540dece6a1f" translate="yes" xml:space="preserve">
          <source>If the selector has already been closed then this method returns immediately. Otherwise it marks the selector as closed and then invokes the &lt;a href=&quot;abstractselector#implCloseSelector--&quot;&gt;&lt;code&gt;implCloseSelector&lt;/code&gt;&lt;/a&gt; method in order to complete the close operation.</source>
          <target state="translated">선택기가 이미 닫혀 있으면이 메서드는 즉시 반환됩니다. 그렇지 않으면 선택기를 닫은 것으로 표시 한 다음 닫기 작업을 완료하기 위해 &lt;a href=&quot;abstractselector#implCloseSelector--&quot;&gt; &lt;code&gt;implCloseSelector&lt;/code&gt; &lt;/a&gt; 메서드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c7ad935cdc55d4a107502fb1347aaf4da85ef291" translate="yes" xml:space="preserve">
          <source>If the selector itself is closed then the channel will be deregistered, and the key representing its registration will be invalidated, without further delay.</source>
          <target state="translated">선택기 자체가 닫히면 채널이 등록 취소되고 등록을 나타내는 키가 추가 지연없이 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="527b7c6f507b87aa21ddf93053b13e95205bb2c8" translate="yes" xml:space="preserve">
          <source>If the sequence is mutated while the stream is being read, the result is undefined.</source>
          <target state="translated">스트림을 읽는 동안 시퀀스가 ​​변경되면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68365060e1fd3c2daf69dad059677cfed6352297" translate="yes" xml:space="preserve">
          <source>If the sequence of characters is already available as a character array, using this constructor is faster than converting the &lt;code&gt;char&lt;/code&gt; array to string and using the &lt;code&gt;BigDecimal(String)&lt;/code&gt; constructor.</source>
          <target state="translated">문자 시퀀스가 ​​이미 문자 배열로 사용 가능한 경우이 생성자를 사용하는 것이 &lt;code&gt;char&lt;/code&gt; 배열을 문자열 로 변환 하고 &lt;code&gt;BigDecimal(String)&lt;/code&gt; 생성자를 사용하는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="44599ce71e2e538b01fd695f05e20f34c21d8951" translate="yes" xml:space="preserve">
          <source>If the sequence of characters is already available within a character array, using this constructor is faster than converting the &lt;code&gt;char&lt;/code&gt; array to string and using the &lt;code&gt;BigDecimal(String)&lt;/code&gt; constructor.</source>
          <target state="translated">문자 배열 내에서 문자 시퀀스를 이미 사용할 수있는 경우이 생성자를 사용하는 것이 &lt;code&gt;char&lt;/code&gt; 배열을 문자열 로 변환 하고 &lt;code&gt;BigDecimal(String)&lt;/code&gt; 생성자를 사용하는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="905718a38e6e40a4a44a638dd8e38175f57a597e" translate="yes" xml:space="preserve">
          <source>If the service provider declares a provider method, then the service loader invokes that method to obtain an instance of the service provider. A provider method is a public static method named &quot;provider&quot; with no formal parameters and a return type that is assignable to the service's interface or class.</source>
          <target state="translated">서비스 공급자가 공급자 메서드를 선언하면 서비스 로더는 해당 메서드를 호출하여 서비스 공급자의 인스턴스를 얻습니다. 공급자 메서드는 서비스의 인터페이스 또는 클래스에 할당 할 수있는 반환 형식과 형식 매개 변수가없는 &quot;provider&quot;라는 이름의 공용 정적 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="3b23056cdaee0c387d69777057adce2233310c89" translate="yes" xml:space="preserve">
          <source>If the service provider does not declare a provider method, then the service provider is instantiated directly, via its provider constructor. A provider constructor is a public constructor with no formal parameters.</source>
          <target state="translated">서비스 공급자가 공급자 메서드를 선언하지 않으면 서비스 공급자는 공급자 생성자를 통해 직접 인스턴스화됩니다. 공급자 생성자는 형식 매개 변수가없는 공용 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="96cc80cb5c49589843f4c152dbe187b0d7672c14" translate="yes" xml:space="preserve">
          <source>If the set contains &lt;code&gt;null&lt;/code&gt; or elements that are not of type &lt;code&gt;PosixFilePermission&lt;/code&gt; then these elements are ignored.</source>
          <target state="translated">집합에 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;PosixFilePermission&lt;/code&gt; 유형이 아닌 요소가 포함 된 경우 이러한 요소는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bdd7ddd5abc6f06de4935b22a2b32f438818b4c2" translate="yes" xml:space="preserve">
          <source>If the set is modified after the iterator is created, in any way except by invoking the iterator's own &lt;a href=&quot;../../util/iterator#remove()&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; method, then a &lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt;&lt;code&gt;ConcurrentModificationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">반복자가 생성 된 후 집합이 수정되면 반복기의 자체 &lt;a href=&quot;../../util/iterator#remove()&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하는 것을 제외하고 는 &lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6a2fc5c10d29d945ad7e76e24ac30350f31297ef" translate="yes" xml:space="preserve">
          <source>If the set is modified after the iterator is created, in any way except by invoking the iterator's own &lt;a href=&quot;../../util/iterator#remove--&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; method, then a &lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt;&lt;code&gt;ConcurrentModificationException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">반복자의 고유 한 &lt;a href=&quot;../../util/iterator#remove--&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 것을 제외하고, 반복자가 작성된 후에 세트가 수정 되면 &lt;a href=&quot;../../util/concurrentmodificationexception&quot;&gt; &lt;code&gt;ConcurrentModificationException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f6638fbdc996aa0e831fc1abcabd26d13939d37e" translate="yes" xml:space="preserve">
          <source>If the setting control represents a boolean condition and four recordings are running at the same time with the following values &lt;code&gt;&quot;true&quot;&lt;/code&gt;, &lt;code&gt;&quot;false&quot;&lt;/code&gt;, &lt;code&gt;&quot;false&quot;&lt;/code&gt;, and &lt;code&gt;&quot;incorrect&quot;&lt;/code&gt;, this method returns &lt;code&gt;&quot;true&quot;&lt;/code&gt;, because all recordings get at least all the requested data.</source>
          <target state="translated">설정 컨트롤이 부울 조건을 나타내며 &lt;code&gt;&quot;true&quot;&lt;/code&gt; , &lt;code&gt;&quot;false&quot;&lt;/code&gt; , &lt;code&gt;&quot;false&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;incorrect&quot;&lt;/code&gt; 값을 사용하여 4 개의 레코딩이 동시에 실행되는 경우 모든 레코딩 이 다음 위치에 있으므로이 메서드는 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 를 반환합니다 . 최소한 모든 요청 된 데이터.</target>
        </trans-unit>
        <trans-unit id="f213e623005cb03ce8a996eda62ae9d104d49741" translate="yes" xml:space="preserve">
          <source>If the setting control represents a set of names and two recordings are running at the same time with the setting values &lt;code&gt;&quot;Smith, Jones&quot;&lt;/code&gt; and &lt;code&gt;&quot;Jones,
 Williams&quot;&lt;/code&gt; the returned value is &lt;code&gt;&quot;Smith, Jones, Williams&quot;&lt;/code&gt; because all names would be accepted.</source>
          <target state="translated">설정 컨트롤이 이름 집합을 나타내고 두 개의 녹음이 &lt;code&gt;&quot;Smith, Jones&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;Jones, Williams&quot;&lt;/code&gt; 설정 값으로 동시에 실행되는 경우 모든 이름이 허용되므로 반환 된 값은 &lt;code&gt;&quot;Smith, Jones, Williams&quot;&lt;/code&gt; 입니다. .</target>
        </trans-unit>
        <trans-unit id="abc7e4a8c7928920f09d0830931380727e4c575d" translate="yes" xml:space="preserve">
          <source>If the setting lacks a content type, the content type for the type that is associated with this setting is returned, or &lt;code&gt;null&lt;/code&gt; if not available.</source>
          <target state="translated">설정에 콘텐츠 형식이없는 경우이 설정과 연결된 형식의 콘텐츠 형식이 반환되거나 사용할 수 &lt;code&gt;null&lt;/code&gt; 경우 null 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="3303157e26b918aa41092329e21abb66fb1b45ac" translate="yes" xml:space="preserve">
          <source>If the setting lacks a description, the description for the type that is associated with this setting is returned, or &lt;code&gt;null&lt;/code&gt; if doesn't exist.</source>
          <target state="translated">설정에 설명이없는 경우이 설정과 연결된 유형에 대한 설명이 반환되거나 &lt;code&gt;null&lt;/code&gt; 경우 null 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="1fe14664f5baaf914d6c2209b660139b1bf58f90" translate="yes" xml:space="preserve">
          <source>If the setting lacks a label, the label for the type that is associated with this setting is returned, or &lt;code&gt;null&lt;/code&gt; if doesn't exist</source>
          <target state="translated">설정에 레이블이없는 경우이 설정과 연결된 유형의 레이블이 반환되거나 &lt;code&gt;null&lt;/code&gt; 경우 null 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="41dd85f3f179642b62aec20efd62519a0e7d8ea5" translate="yes" xml:space="preserve">
          <source>If the setting value is not valid for this setting, this method does not throw an exception. Instead, the value is ignored.</source>
          <target state="translated">이 설정에 대해 설정 값이 유효하지 않은 경우이 메서드는 예외를 throw하지 않습니다. 대신 값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d6f544e9f4637d730c544f2df049efe3bc2241c9" translate="yes" xml:space="preserve">
          <source>If the signs of arguments are unknown and a positive modulus is needed it can be computed as &lt;code&gt;(floorMod(x, y) + abs(y)) % abs(y)&lt;/code&gt;.</source>
          <target state="translated">인수의 부호를 알 수없고 양의 계수가 필요한 경우 &lt;code&gt;(floorMod(x, y) + abs(y)) % abs(y)&lt;/code&gt; 로 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d63f4df1fec01d153e077a0cd492720daea9604" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are different, the quotient is negative and &lt;code&gt;floorDiv&lt;/code&gt; returns the integer less than or equal to the quotient and the &lt;code&gt;/&lt;/code&gt; operator returns the integer closest to zero.</source>
          <target state="translated">인수의 부호가 다른 경우 몫은 음수이고 &lt;code&gt;floorDiv&lt;/code&gt; 는 몫 보다 작거나 같은 정수를 반환하고 &lt;code&gt;/&lt;/code&gt; 연산자는 0에 가장 가까운 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b3eddbc3f191c883b4734fcd232862a579d8785" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are different, the results differ from the &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">인수의 부호가 다른 경우 결과는 &lt;code&gt;%&lt;/code&gt; 연산자 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="8893f46ae7c980fbb6e68ff03e7cfa2f4485e10e" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are the same, the results of &lt;code&gt;floorDiv&lt;/code&gt; and the &lt;code&gt;/&lt;/code&gt; operator are the same.</source>
          <target state="translated">인수의 부호가 동일하면 &lt;code&gt;floorDiv&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 연산자 의 결과가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e7d5446141374acaa0bf3d68df3adaaf0963a7c6" translate="yes" xml:space="preserve">
          <source>If the signs of the arguments are the same, the results of &lt;code&gt;floorMod&lt;/code&gt; and the &lt;code&gt;%&lt;/code&gt; operator are the same.</source>
          <target state="translated">인수의 부호가 동일하면 &lt;code&gt;floorMod&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 연산자 의 결과가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7c0c3191c882ae94e067ec4dbb9ae1efa5c18a6b" translate="yes" xml:space="preserve">
          <source>If the size of the map (the number of key-value mappings) sufficiently exceeds the expected maximum size, the number of buckets is increased. Increasing the number of buckets (&quot;rehashing&quot;) may be fairly expensive, so it pays to create identity hash maps with a sufficiently large expected maximum size. On the other hand, iteration over collection views requires time proportional to the number of buckets in the hash table, so it pays not to set the expected maximum size too high if you are especially concerned with iteration performance or memory usage.</source>
          <target state="translated">맵 크기 (키-값 매핑 수)가 예상 최대 크기를 충분히 초과하면 버킷 수가 늘어납니다. 버킷 수를 늘리면 ( &quot;리 해싱&quot;) 비용이 상당히 많이들 수 있으므로 예상되는 최대 크기가 충분히 큰 ID 해시 맵을 만드는 데 비용이 듭니다. 반면 컬렉션 뷰에 대한 반복에는 해시 테이블의 버킷 수에 비례 한 시간이 필요하므로 반복 성능이나 메모리 사용과 관련하여 예상되는 최대 크기를 너무 높게 설정하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="49af0f5d2c34bab8d6d7bf3a55a636eed438a349" translate="yes" xml:space="preserve">
          <source>If the smaller index is outside the list's range of cells, this method returns &lt;code&gt;null&lt;/code&gt;. If the smaller index is valid, but the larger index is outside the list's range, the bounds of just the first index is returned. Otherwise, the bounds of the valid range is returned.</source>
          <target state="translated">더 작은 인덱스가 목록의 셀 범위 밖에 있으면이 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 더 작은 인덱스가 유효하지만 더 큰 인덱스가 목록의 범위를 벗어난 경우 첫 번째 인덱스의 경계 만 반환됩니다. 그렇지 않으면 유효한 범위의 경계가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b48f7eb14ba4fe0ba8d12278087b9bd58de5fe30" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인딩 된 경우이 메서드는 계속해서 반환합니다. &lt;code&gt;true&lt;/code&gt; 소켓이 닫힌 후에도 true 합니다 .</target>
        </trans-unit>
        <trans-unit id="c08afa2dd83781248a8b6598b34ddd6bd609cd7b" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the address of the endpoint after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인딩 된 경우 경우이 메서드는 소켓이 닫힌 후에도 끝점의 주소를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ef9dc97922014b6a635ad3f24d3c2f309797f78" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local address after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인딩 된 경우 경우이 메서드는 소켓이 닫힌 후에도 계속해서 로컬 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="795364986502a26fa06bf27ac780aeadecd43628" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local port number after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인딩 된 경우 경우이 메서드는 소켓이 닫힌 후에도 계속해서 로컬 포트 ​​번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="22d427b6f3e432eb55922847295296fb762a16b8" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the port number after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인딩 된 경우 경우이 메서드는 소켓이 닫힌 후에도 포트 번호를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b4b4f804a6b1c8756d6a9edd0658d83fbd67c5c" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;#close()&quot;&gt;closed&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt;닫히기&lt;/a&gt; 전에 바인딩 된 경우이 메서드는 소켓이 닫힌 후에도 계속 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="0ca2d090f17022dd5e73b01197f1d6848c079ffd" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓을 닫은 후에도 계속 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="59679157176f257978bbe9def3e0740bb5fb205a" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;serversocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the address of the endpoint after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;serversocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓이 닫힌 후 엔드 포인트의 주소를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0e21984f9cc07335c38e61e8524fe85a27b1d410" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;serversocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local address after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;serversocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓이 닫힌 후 로컬 주소를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="763b9cd171c3cff366fd68dad3b49caafc1fe527" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;serversocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the port number after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;serversocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓이 닫힌 후 포트 번호를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cd6141b5241054244025e22ff3d73a0248d5fc8c" translate="yes" xml:space="preserve">
          <source>If the socket was bound prior to being &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the local port number after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 바인드 된 경우, 이 메소드는 소켓이 닫힌 후에도 로컬 포트 ​​번호를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6e9dae5be20db8da3e58f51cd7b51d1fb85b6fbf" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 되었다면 이 메서드는 계속해서 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다. 소켓이 닫힌 후에도 .</target>
        </trans-unit>
        <trans-unit id="917ebef9402f85a9edd81896ca3483affe543bd7" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected address after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 되었다면 이 메서드는 소켓이 닫힌 후에도 연결된 주소를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1204ee019c4cde4f66441dc7934326b11df3ec43" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected port number after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 되었다면 이 메서드는 소켓이 닫힌 후에도 연결된 포트 번호를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fc8e1670126679859d5c660bcdcb0e5c4dce29e" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return &lt;code&gt;true&lt;/code&gt; after the socket is closed.</source>
          <target state="translated">소켓이 &lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결된 경우 소켓이 닫힌 후에도이 메소드는 계속 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="eded3cce47a4f9690c31a1eee5141c639e63658a" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected address after the socket is closed.</source>
          <target state="translated">소켓을 &lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 한 경우이 방법은 소켓을 닫은 후에도 연결된 주소를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3d182eb3854cd39ce3f790ae76cf8abf4ec7f3e" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;datagramsocket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected port number after the socket is closed.</source>
          <target state="translated">소켓을 &lt;a href=&quot;datagramsocket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 한 경우이 방법은 소켓을 닫은 후에도 연결된 포트 번호를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac6a556c1933db902b091802b19407a613fc41d9" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected address after the socket is closed.</source>
          <target state="translated">소켓을 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 한 경우이 방법은 소켓을 닫은 후에도 연결된 주소를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abfab3eeb26c13c0835e0da8c32c95bf0e46c4ed" translate="yes" xml:space="preserve">
          <source>If the socket was connected prior to being &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt;, then this method will continue to return the connected port number after the socket is closed.</source>
          <target state="translated">소켓을 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 전에 연결 한 경우이 방법은 소켓을 닫은 후에도 연결된 포트 번호를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca2d424b7fdfc2a79a2dfc6c0453d110b7859bc0" translate="yes" xml:space="preserve">
          <source>If the source is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard input of a subprocess can be written to using the output stream returned by &lt;a href=&quot;process#getOutputStream()&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt;. If the source is set to any other value, then &lt;a href=&quot;process#getOutputStream()&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">소스가 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값)이면 &lt;a href=&quot;process#getOutputStream()&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt; 반환 된 출력 스트림을 사용하여 하위 프로세스의 표준 입력을 쓸 수 있습니다 . 소스가 다른 값으로 설정된 경우 &lt;a href=&quot;process#getOutputStream()&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-input&quot;&gt;null 출력 스트림을&lt;/a&gt; 반환 합니다. .</target>
        </trans-unit>
        <trans-unit id="c74e08fa061f46bcfc74bd1ceb1c899db939f1d9" translate="yes" xml:space="preserve">
          <source>If the source is &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt;&lt;code&gt;Redirect.PIPE&lt;/code&gt;&lt;/a&gt; (the initial value), then the standard input of a subprocess can be written to using the output stream returned by &lt;a href=&quot;process#getOutputStream--&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt;. If the source is set to any other value, then &lt;a href=&quot;process#getOutputStream--&quot;&gt;&lt;code&gt;Process.getOutputStream()&lt;/code&gt;&lt;/a&gt; will return a &lt;a href=&quot;#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">소스가 &lt;a href=&quot;processbuilder.redirect#PIPE&quot;&gt; &lt;code&gt;Redirect.PIPE&lt;/code&gt; &lt;/a&gt; (초기 값) 인 경우 &lt;a href=&quot;process#getOutputStream--&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt; 리턴 한 출력 스트림을 사용하여 서브 프로세스의 표준 입력을 쓸 수 있습니다 . 소스가 다른 값으로 설정되면 &lt;a href=&quot;process#getOutputStream--&quot;&gt; &lt;code&gt;Process.getOutputStream()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#redirect-input&quot;&gt;null 출력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="f6c84516f9aebb90d613c9f7eb26a5e9fd1dca09" translate="yes" xml:space="preserve">
          <source>If the source is a BufferedImage with premultiplied alpha, the color components are divided by the alpha component before color conversion. If the destination is a BufferedImage with premultiplied alpha, the color components are multiplied by the alpha component after conversion. Rasters are treated as having no alpha channel, i.e. all bands are color bands.</source>
          <target state="translated">소스가 알파가 미리 곱해진 BufferedImage 인 경우 색상 구성 요소는 색상 변환 전에 알파 구성 요소로 나뉩니다. 대상이 알파가 미리 곱해진 BufferedImage 인 경우 변환 후 색상 구성 요소에 알파 구성 요소가 곱해집니다. 래스터는 알파 채널이없는 것으로 처리됩니다. 즉, 모든 밴드는 색상 밴드입니다.</target>
        </trans-unit>
        <trans-unit id="1c6d739298af4f4dfdbeb07ff847cfc9d3c6a7a7" translate="yes" xml:space="preserve">
          <source>If the source of the PropertyChangeEvent &lt;code&gt;e&lt;/code&gt; equals the optionPane and is one of the ICON_PROPERTY, MESSAGE_PROPERTY, OPTIONS_PROPERTY or INITIAL_VALUE_PROPERTY, validateComponent is invoked.</source>
          <target state="translated">PropertyChangeEvent &lt;code&gt;e&lt;/code&gt; 의 소스가 optionPane과 같고 ICON_PROPERTY, MESSAGE_PROPERTY, OPTIONS_PROPERTY 또는 INITIAL_VALUE_PROPERTY 중 하나이면 validateComponent가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="661f6402b0c9208e67543bc3982626f5f2502c0a" translate="yes" xml:space="preserve">
          <source>If the source of the notification is a reference to an MBean object, the MBean server will replace it by that MBean's ObjectName. Otherwise the source is unchanged.</source>
          <target state="translated">통지의 소스가 MBean 객체에의 참조 인 경우, MBean 서버는 그것을 MBean의 ObjectName로 교체합니다. 그렇지 않으면 소스가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc0afb74deac5658d35d1df20daa373ddaf8091c" translate="yes" xml:space="preserve">
          <source>If the spec's path component begins with a slash character &quot;/&quot; then the path is treated as absolute and the spec path replaces the context path.</source>
          <target state="translated">스펙의 경로 구성 요소가 슬래시 문자 &quot;/&quot;로 시작하면 경로는 절대 경로로 취급되고 스펙 경로는 컨텍스트 경로를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="9a4f4b68138d4550ce0ad6e021c29ead94a8e3ad" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;DataFlavor&lt;/code&gt; is previously unknown to the data transfer subsystem and the data transfer subsystem is unable to translate this &lt;code&gt;DataFlavor&lt;/code&gt; to any existing native, then invoking this method will establish a mapping in both directions between the specified &lt;code&gt;DataFlavor&lt;/code&gt; and an encoded version of its MIME type as its native.</source>
          <target state="translated">지정된 &lt;code&gt;DataFlavor&lt;/code&gt; 가 이전에 데이터 전송 하위 시스템에 알려지지 않았고 데이터 전송 하위 시스템이이 &lt;code&gt;DataFlavor&lt;/code&gt; 를 기존 네이티브 로 변환 할 수없는 경우이 메서드를 호출하면 지정된 &lt;code&gt;DataFlavor&lt;/code&gt; 와 해당 MIME의 인코딩 된 버전 간에 양방향 매핑이 설정됩니다. 네이티브로 입력합니다.</target>
        </trans-unit>
        <trans-unit id="ec28138e6077c419b066b58918bda314e27771f9" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;locale&lt;/code&gt; contains &quot;cu&quot; and/or &quot;rg&quot; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;, the instance returned from this method reflects the values specified with those extensions. If both &quot;cu&quot; and &quot;rg&quot; are specified, the currency from the &quot;cu&quot; extension supersedes the implicit one from the &quot;rg&quot; extension.</source>
          <target state="translated">지정된 &lt;code&gt;locale&lt;/code&gt; 에 &quot;cu&quot;및 / 또는 &quot;rg&quot; &lt;a href=&quot;locale#def_locale_extension&quot;&gt;유니 코드 확장&lt;/a&gt; 이 포함 된 경우이 메서드에서 반환 된 인스턴스는 해당 확장으로 지정된 값을 반영합니다. &quot;cu&quot;와 &quot;rg&quot;가 모두 지정되면 &quot;cu&quot;확장의 통화가 &quot;rg&quot;확장의 암시 적 통화를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="e385849f938ca3e361afb2eab43ee21415cbd43e" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;locale&lt;/code&gt; contains &quot;rg&quot; (region override) &lt;a href=&quot;locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, the symbol returned from this method reflects the value specified with that extension.</source>
          <target state="translated">지정된 &lt;code&gt;locale&lt;/code&gt; 에 &quot;rg&quot;(지역 재정의) &lt;a href=&quot;locale#def_locale_extension&quot;&gt;유니 코드 확장&lt;/a&gt; 이 포함 된 경우이 메서드에서 반환 된 기호는 해당 확장으로 지정된 값을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="257aba8bf323b9c1c989b22a9946ac7416be5538" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;name&lt;/code&gt; begins with &quot;&lt;code&gt;java.&lt;/code&gt;&quot;, it can only be defined by the &lt;a href=&quot;#getPlatformClassLoader()&quot;&gt;platform class loader&lt;/a&gt; or its ancestors; otherwise &lt;code&gt;SecurityException&lt;/code&gt; will be thrown. If &lt;code&gt;name&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it must be equal to the &lt;a href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of the class specified by the byte array &lt;code&gt;b&lt;/code&gt;, otherwise a &lt;a href=&quot;noclassdeffounderror&quot;&gt;&lt;code&gt;NoClassDefFoundError&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">지정된 &lt;code&gt;name&lt;/code&gt; 이 &quot; &lt;code&gt;java.&lt;/code&gt; &quot;로 시작 하는 경우 &lt;a href=&quot;#getPlatformClassLoader()&quot;&gt;플랫폼 클래스 로더&lt;/a&gt; 또는 해당 조상에 의해서만 정의 될 수 있습니다 . 그렇지 않으면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다. 경우 &lt;code&gt;name&lt;/code&gt; 없는 &lt;code&gt;null&lt;/code&gt; , 상기 동일해야 &lt;a href=&quot;#binary-name&quot;&gt;진 이름&lt;/a&gt; 바이트 배열에 의해 특정 클래스 &lt;code&gt;b&lt;/code&gt; 달리, &lt;a href=&quot;noclassdeffounderror&quot;&gt; &lt;code&gt;NoClassDefFoundError&lt;/code&gt; &lt;/a&gt; 발생한다.</target>
        </trans-unit>
        <trans-unit id="97c03df7f79f779f19dbd94c565abdfcc104d7ca" translate="yes" xml:space="preserve">
          <source>If the specified IP address is bound to multiple network interfaces it is not defined which network interface is returned.</source>
          <target state="translated">지정된 IP 주소가 여러 네트워크 인터페이스에 바인딩 된 경우 어떤 네트워크 인터페이스가 반환되는지 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96c68f935629df479cecc1daf2323805432c7c1f" translate="yes" xml:space="preserve">
          <source>If the specified amount is a &lt;code&gt;ChronoPeriod&lt;/code&gt; then it must have the same chronology as this period. Implementations may choose to accept or reject other &lt;code&gt;TemporalAmount&lt;/code&gt; implementations.</source>
          <target state="translated">지정된 금액이 &lt;code&gt;ChronoPeriod&lt;/code&gt; 인 경우이 기간과 동일한 연대기를 가져야합니다. 구현시 다른 &lt;code&gt;TemporalAmount&lt;/code&gt; 구현 을 수락하거나 거부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09cff20bf42b9ad1e7365bfddfe3a021913c702f" translate="yes" xml:space="preserve">
          <source>If the specified calendar doesn't support week dates, the &lt;a href=&quot;#build()&quot;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/a&gt; method will throw an &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 달력이 주 날짜를 지원하지 않는 경우 &lt;a href=&quot;#build()&quot;&gt; &lt;code&gt;build&lt;/code&gt; &lt;/a&gt; 메서드는 &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="aeb138890341e49f448dcdb19a0436d6eccb12fa" translate="yes" xml:space="preserve">
          <source>If the specified calendar doesn't support week dates, the &lt;a href=&quot;calendar.builder#build--&quot;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/a&gt; method will throw an &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 달력이 주 날짜를 지원하지 않는 경우, &lt;a href=&quot;calendar.builder#build--&quot;&gt; &lt;code&gt;build&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;a href=&quot;../lang/illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="21d5a2365b7e2ef9cdf719d377a83491e9b996d8" translate="yes" xml:space="preserve">
          <source>If the specified comment is &lt;code&gt;null&lt;/code&gt; then no comment will be stored in the document.</source>
          <target state="translated">지정된 주석이 &lt;code&gt;null&lt;/code&gt; 이면 주석이 문서에 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c00aef2c14db555263f047e1c32a11c40196454" translate="yes" xml:space="preserve">
          <source>If the specified comparator is &lt;code&gt;null&lt;/code&gt; then all elements in this list must implement the &lt;a href=&quot;../../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt; interface and the elements' &lt;a href=&quot;../../lang/comparable&quot;&gt;natural ordering&lt;/a&gt; should be used.</source>
          <target state="translated">지정된 비교자가 &lt;code&gt;null&lt;/code&gt; 인 경우, 이 목록의 모든 요소는 &lt;a href=&quot;../../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현해야 하며 요소의 &lt;a href=&quot;../../lang/comparable&quot;&gt;자연 순서를&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="aefe2d484ac87a9f75945af0a56cb6b62891cb32" translate="yes" xml:space="preserve">
          <source>If the specified comparator is &lt;code&gt;null&lt;/code&gt; then all elements in this list must implement the &lt;a href=&quot;../lang/comparable&quot;&gt;&lt;code&gt;Comparable&lt;/code&gt;&lt;/a&gt; interface and the elements' &lt;a href=&quot;../lang/comparable&quot;&gt;natural ordering&lt;/a&gt; should be used.</source>
          <target state="translated">지정된 비교자가 &lt;code&gt;null&lt;/code&gt; 인 경우, 이 목록의 모든 요소는 &lt;a href=&quot;../lang/comparable&quot;&gt; &lt;code&gt;Comparable&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현해야 하며 요소의 &lt;a href=&quot;../lang/comparable&quot;&gt;자연 순서를&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a543a9a4c58a21fee89ee30e3c66f4521a79acb" translate="yes" xml:space="preserve">
          <source>If the specified component is already a child of this then we don't bother doing anything - stacking order doesn't matter for cell renderer components (CellRendererPane doesn't paint anyway).</source>
          <target state="translated">지정된 구성 요소가 이미 이것의 자식이면 아무 작업도 수행하지 않습니다. 스택 순서는 셀 렌더러 구성 요소에 대해 중요하지 않습니다 (CellRendererPane은 어쨌든 페인트하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="1142a4e571e7e45e0126c1fa376f4b7549ff134a" translate="yes" xml:space="preserve">
          <source>If the specified date-time has already passed, the job must be a candidate for processing immediately. Thus, one way to make the job immediately become a candidate for processing is to specify a &lt;code&gt;JobHoldUntil&lt;/code&gt; attribute constructed like this (denoting a date-time of January 1, 1970, 00:00:00 GMT):</source>
          <target state="translated">지정된 날짜-시간이 이미 지난 경우 작업은 즉시 처리 할 후보 여야합니다. 따라서 작업을 즉시 처리 후보로 만드는 한 가지 방법은 다음 과 같이 구성된 &lt;code&gt;JobHoldUntil&lt;/code&gt; 속성 을 지정하는 것입니다 (1970 년 1 월 1 일, 00:00:00 GMT를 나타냄).</target>
        </trans-unit>
        <trans-unit id="e90b9efbdd73e57fac8cf7dcbd6a9324c80a3a89" translate="yes" xml:space="preserve">
          <source>If the specified date-time has already passed, the job must be a candidate for processing immediately. Thus, one way to make the job immediately become a candidate for processing is to specify a JobHoldUntil attribute constructed like this (denoting a date-time of January 1, 1970, 00:00:00 GMT):</source>
          <target state="translated">지정된 날짜-시간이 이미 지난 경우 작업은 즉시 처리 할 수 ​​있어야합니다. 따라서 작업을 즉시 처리 후보로 만드는 한 가지 방법은 다음과 같이 구성된 JobHoldUntil 속성을 지정하는 것입니다 (1970 년 1 월 1 일 00:00:00 GMT 표시).</target>
        </trans-unit>
        <trans-unit id="7cc62287dac9dd3318ff0227906bfc56c107c2f1" translate="yes" xml:space="preserve">
          <source>If the specified driver is not found in the list of registered drivers, then no action is taken. If the driver was found, it will be removed from the list of registered drivers.</source>
          <target state="translated">지정된 드라이버가 등록 된 드라이버 목록에 없으면 아무 조치도 취하지 않습니다. 드라이버가 발견되면 등록 된 드라이버 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9579f0c52418214efdc0671f46a3ff5e4527ea42" translate="yes" xml:space="preserve">
          <source>If the specified field is present, this method returns a non-null non-negative &lt;a href=&quot;../../../../java.base/java/lang/number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; object that represents its value. If it is not present, return null. For YEARS, MONTHS, DAYS, HOURS, and MINUTES, this method returns a &lt;a href=&quot;../../../../java.base/java/math/biginteger&quot;&gt;&lt;code&gt;BigInteger&lt;/code&gt;&lt;/a&gt; object. For SECONDS, this method returns a &lt;a href=&quot;../../../../java.base/java/math/bigdecimal&quot;&gt;&lt;code&gt;BigDecimal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 필드가있는 경우이 메서드는 해당 값을 나타내는 Null이 아닌 음수가 아닌 &lt;a href=&quot;../../../../java.base/java/lang/number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; 개체를 반환 합니다. 존재하지 않으면 null을 반환합니다. YEARS, MONTHS, DAYS, HOURS 및 MINUTES의 경우이 메서드는 &lt;a href=&quot;../../../../java.base/java/math/biginteger&quot;&gt; &lt;code&gt;BigInteger&lt;/code&gt; &lt;/a&gt; 개체를 반환 합니다. SECONDS의 경우이 메서드는 &lt;a href=&quot;../../../../java.base/java/math/bigdecimal&quot;&gt; &lt;code&gt;BigDecimal&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ab27614aa1a1e159b8f3228af15f24fff13239ec" translate="yes" xml:space="preserve">
          <source>If the specified file is a directory, the file manager of the current platform is launched to open it.</source>
          <target state="translated">지정된 파일이 디렉토리이면 현재 플랫폼의 파일 관리자가 실행되어 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="6ddc595a62cbea355de55b31675b042692a29bee" translate="yes" xml:space="preserve">
          <source>If the specified host is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as &lt;a href=&quot;inetaddress#getByName(java.lang.String)&quot;&gt;&lt;code&gt;InetAddress.getByName&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(null)&lt;/code&gt;. In other words, it is equivalent to specifying an address of the loopback interface.</source>
          <target state="translated">지정된 호스트가 &lt;code&gt;null&lt;/code&gt; 인 경우 주소를 &lt;a href=&quot;inetaddress#getByName(java.lang.String)&quot;&gt; &lt;code&gt;InetAddress.getByName&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(null)&lt;/code&gt; 으로 지정하는 것과 동일 합니다. 즉, 루프백 인터페이스의 주소를 지정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2496623a004f15dd4819ee54aa8493f7e338eba3" translate="yes" xml:space="preserve">
          <source>If the specified host is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as &lt;a href=&quot;inetaddress#getByName-java.lang.String-&quot;&gt;&lt;code&gt;InetAddress.getByName&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(null)&lt;/code&gt;. In other words, it is equivalent to specifying an address of the loopback interface.</source>
          <target state="translated">지정된 호스트가 &lt;code&gt;null&lt;/code&gt; 의 경우, 주소를 &lt;a href=&quot;inetaddress#getByName-java.lang.String-&quot;&gt; &lt;code&gt;InetAddress.getByName&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(null)&lt;/code&gt; 로 지정하는 것과 같습니다 . 즉, 루프백 인터페이스의 주소를 지정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c33d8531f7d2499b880c450b0b37d9ef3fa77c82" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a (non-null) value, associates it with the given value.</source>
          <target state="translated">지정된 키가 (null이 아닌) 값과 아직 연결되지 않은 경우 지정된 값과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="900d04445ca5a80f48077470ed1101681577ef82" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a (non-null) value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if &lt;code&gt;null&lt;/code&gt;. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.</source>
          <target state="translated">지정된 키가 (널이 아닌) 값과 아직 연결되지 않은 경우 지정된 값과 연결합니다. 그렇지 않으면, 값을 제공된 다시 매핑 함수의 결과로 바꾸거나 if &lt;code&gt;null&lt;/code&gt; 을 제거합니다 . 전체 메소드 호출은 원자 적으로 수행됩니다. 다른 스레드가이 맵에서 시도한 일부 업데이트 작업은 계산이 진행되는 동안 차단 될 수 있으므로 계산이 짧고 단순해야하며이 맵의 다른 매핑을 업데이트하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="327e72df9ef84db72836c87a15ef8d4fb475f995" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value (or is mapped to &lt;code&gt;null&lt;/code&gt;) associates it with the given value and returns &lt;code&gt;null&lt;/code&gt;, else returns the current value.</source>
          <target state="translated">지정된 키가 값과 아직 연결되어 있지 않거나 &lt;code&gt;null&lt;/code&gt; 에 매핑 된 경우 해당 키를 지정된 값과 연결하고 &lt;code&gt;null&lt;/code&gt; 을 반환하면 현재 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7b0beef1230b8f936ac0be883b146508d29a805b" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value (or is mapped to &lt;code&gt;null&lt;/code&gt;), attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">지정된 키가 값에 아직 연결되어 있지 않은 경우 (또는 &lt;code&gt;null&lt;/code&gt; 에 매핑 된 경우) 지정된 매핑 함수를 사용하여 값을 계산하려고 시도하고 &lt;code&gt;null&lt;/code&gt; 이 아닌 한이 맵에 입력합니다 .</target>
        </trans-unit>
        <trans-unit id="59de12c4feb8699041392433808d90a4be2dd1b8" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value.</source>
          <target state="translated">지정된 키가 아직 값과 연결되어 있지 않거나 null과 연결되어있는 경우 해당 키를 지정된 null이 아닌 값과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="50fe8f5b029680a754d045deccf54d554f1ecb50" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function, or removes if the result is &lt;code&gt;null&lt;/code&gt;. This method may be of use when combining multiple mapped values for a key. For example, to either create or append a &lt;code&gt;String msg&lt;/code&gt; to a value mapping:</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않았거나 널과 연관되어 있으면 제공된 널이 아닌 값과 연관시킵니다. 그렇지 않으면 관련 값을 지정된 다시 매핑 기능의 결과로 바꾸거나 결과가 다음과 같은 경우 제거합니다. &lt;code&gt;null&lt;/code&gt; 인 . 이 방법은 키에 대해 여러 개의 매핑 된 값을 결합 할 때 사용할 수 있습니다. 예를 들어, &lt;code&gt;String msg&lt;/code&gt; 를 작성하거나 값 맵핑에 추가 하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ec2236aaf5d6e4455671d55125f8980e4fa9768d" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given value.</source>
          <target state="translated">지정된 키가 아직 값과 연결되지 않았거나 null과 연결되어 있으면 지정된 값과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="07aab8862177972b392beb8f0bf5c9cd52e38ac3" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value or is associated with null, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if the result is null. This method may be of use when combining multiple mapped values for a key.</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않았거나 널과 연관되어 있으면 주어진 값과 연관시킵니다. 그렇지 않으면 값을 지정된 다시 매핑 함수의 결과로 바꾸거나 결과가 null 인 경우 제거합니다. 이 방법은 키에 대해 여러 개의 매핑 된 값을 결합 할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4925c79cda2f9aaf0050cbbfb1bd9cb1cde5984" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associate it with the given value. This is equivalent to</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않은 경우 지정된 값과 연관 시키십시오. 이것은</target>
        </trans-unit>
        <trans-unit id="d4876e55c0474ed2aee75208b622ba1f147600e9" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associates it with the given value.</source>
          <target state="translated">지정된 키가 아직 값과 연결되지 않은 경우 지정된 값과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="df5a13cc298f2e36b4088599af2bf52a36c46112" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if &lt;code&gt;null&lt;/code&gt;. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically.</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않은 경우 지정된 값과 연관시킵니다. 그렇지 않으면, 값을 제공된 다시 매핑 함수의 결과로 바꾸거나 if &lt;code&gt;null&lt;/code&gt; 을 제거합니다 . 이 기능은 원자 적으로 한 번만 적용되는 것은 &lt;em&gt;아닙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e0e2aa4c62a637c17a37f4738b005d30fd80554c" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, associates it with the given value. This is equivalent to, for this &lt;code&gt;map&lt;/code&gt;:</source>
          <target state="translated">지정된 키가 아직 값과 연결되지 않은 경우 지정된 값과 연결합니다. 이 &lt;code&gt;map&lt;/code&gt; 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6107b4d5266bf408264e8a734eb446c3449b2b14" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">지정된 키가 아직 값과 연결되지 않은 경우 지정된 매핑 함수를 사용하여 값을 계산하고 &lt;code&gt;null&lt;/code&gt; 이 아닌 한이 맵에 입력합니다 .</target>
        </trans-unit>
        <trans-unit id="551c906c1bb44aa217c725bb3e6835b67419ea34" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;. The entire method invocation is performed atomically, so the function is applied at most once per key. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않은 경우 제공된 맵핑 함수를 사용하여 값을 계산하려고 시도하고 &lt;code&gt;null&lt;/code&gt; 이 아닌 한이 맵에 입력합니다 . 전체 메소드 호출은 원자 적으로 수행되므로 함수는 키당 최대 한 번 적용됩니다. 다른 스레드가이 맵에서 시도한 일부 업데이트 작업은 계산이 진행되는 동안 차단 될 수 있으므로 계산이 짧고 단순해야하며이 맵의 다른 매핑을 업데이트하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a7ba2104811a8cc71437ff79090a01cae2c82bf2" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;. The entire method invocation is performed atomically. The supplied function is invoked exactly once per invocation of this method if the key is absent, else not at all. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple.</source>
          <target state="translated">지정된 키가 아직 값과 연결되지 않은 경우 지정된 매핑 함수를 사용하여 해당 값을 계산하고 &lt;code&gt;null&lt;/code&gt; 이 아닌 한이 맵에 입력합니다 . 전체 메소드 호출은 원자 적으로 수행됩니다. 제공된 함수는 키가 없으면이 메서드를 호출 할 때마다 정확히 한 번 호출됩니다. 그렇지 않으면 전혀 호출되지 않습니다. 다른 스레드가이 맵에서 시도한 일부 업데이트 작업은 계산이 진행되는 동안 차단 될 수 있으므로 계산이 짧고 간단해야합니다.</target>
        </trans-unit>
        <trans-unit id="199aa69d5cf4c4d157c5d05ec7094035a1890fc8" translate="yes" xml:space="preserve">
          <source>If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless &lt;code&gt;null&lt;/code&gt;. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically only if the value is not present.</source>
          <target state="translated">지정된 키가 아직 값과 연관되지 않은 경우 제공된 맵핑 함수를 사용하여 값을 계산하려고 시도하고 &lt;code&gt;null&lt;/code&gt; 이 아닌 한이 맵에 입력합니다 . 함수가된다 &lt;em&gt;NOT&lt;/em&gt; 한번 원자 적 가치가 존재하지 않는 경우에만 적용 보장.</target>
        </trans-unit>
        <trans-unit id="ac522be26b00567361a746d74b58f7524d15d7ee" translate="yes" xml:space="preserve">
          <source>If the specified language tag contains any ill-formed subtags, the first such subtag and all following subtags are ignored. Compare to &lt;a href=&quot;locale.builder#setLanguageTag(java.lang.String)&quot;&gt;&lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt;&lt;/a&gt; which throws an exception in this case.</source>
          <target state="translated">지정된 언어 태그에 형식이 잘못된 하위 태그가 포함 된 경우 이러한 첫 번째 하위 태그와 모든 후속 하위 태그는 무시됩니다. 이 경우 예외를 발생시키는 &lt;a href=&quot;locale.builder#setLanguageTag(java.lang.String)&quot;&gt; &lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt; &lt;/a&gt; 와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="74ec46a56735923288ea9182f5be9a7235b7c574" translate="yes" xml:space="preserve">
          <source>If the specified language tag contains any ill-formed subtags, the first such subtag and all following subtags are ignored. Compare to &lt;a href=&quot;locale.builder#setLanguageTag-java.lang.String-&quot;&gt;&lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt;&lt;/a&gt; which throws an exception in this case.</source>
          <target state="translated">지정된 언어 태그에 잘못된 형식의 하위 태그가 포함 된 경우 첫 번째 하위 태그와 다음 하위 태그는 모두 무시됩니다. 이 경우 예외를 발생시키는 &lt;a href=&quot;locale.builder#setLanguageTag-java.lang.String-&quot;&gt; &lt;code&gt;Locale.Builder.setLanguageTag(java.lang.String)&lt;/code&gt; &lt;/a&gt; 와 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="495384335ab36e262e909f5285ee42e18f9010ef" translate="yes" xml:space="preserve">
          <source>If the specified list is small or implements the &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; interface, this implementation exchanges the first element into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element. If necessary, the process is repeated on the second and successive elements, until the rotation is complete. If the specified list is large and doesn't implement the &lt;code&gt;RandomAccess&lt;/code&gt; interface, this implementation breaks the list into two sublist views around index &lt;code&gt;-distance mod size&lt;/code&gt;. Then the &lt;a href=&quot;#reverse(java.util.List)&quot;&gt;&lt;code&gt;reverse(List)&lt;/code&gt;&lt;/a&gt; method is invoked on each sublist view, and finally it is invoked on the entire list. For a more complete description of both algorithms, see Section 2.3 of Jon Bentley's</source>
          <target state="translated">지정된 목록이 작거나 &lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 경우이 구현은 첫 번째 요소를 이동해야하는 위치로 교환 한 다음 대체 된 요소가 첫 번째 요소로 교체 될 때까지 이동해야하는 위치로 대체 된 요소를 반복적으로 교환합니다. 필요한 경우 회전이 완료 될 때까지 두 번째 및 연속 요소에서 프로세스가 반복됩니다. 지정된 목록이 크고 &lt;code&gt;RandomAccess&lt;/code&gt; 인터페이스를 구현하지 않는 경우이 구현은 목록을 index- &lt;code&gt;-distance mod size&lt;/code&gt; 주위의 두 개의 하위 목록보기로 나눕니다 . 그런 다음 &lt;a href=&quot;#reverse(java.util.List)&quot;&gt; &lt;code&gt;reverse(List)&lt;/code&gt; &lt;/a&gt;메서드는 각 하위 목록보기에서 호출되고 마지막으로 전체 목록에서 호출됩니다. 두 알고리즘에 대한 자세한 설명은 Jon Bentley의 섹션 2.3을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="29e16cfca3f81f7f2c484ea21572aa935aba3557" translate="yes" xml:space="preserve">
          <source>If the specified list is small or implements the &lt;a href=&quot;randomaccess&quot;&gt;&lt;code&gt;RandomAccess&lt;/code&gt;&lt;/a&gt; interface, this implementation exchanges the first element into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element. If necessary, the process is repeated on the second and successive elements, until the rotation is complete. If the specified list is large and doesn't implement the &lt;code&gt;RandomAccess&lt;/code&gt; interface, this implementation breaks the list into two sublist views around index &lt;code&gt;-distance mod size&lt;/code&gt;. Then the &lt;a href=&quot;collections#reverse-java.util.List-&quot;&gt;&lt;code&gt;reverse(List)&lt;/code&gt;&lt;/a&gt; method is invoked on each sublist view, and finally it is invoked on the entire list. For a more complete description of both algorithms, see Section 2.3 of Jon Bentley's</source>
          <target state="translated">지정된리스트가 작거나 &lt;a href=&quot;randomaccess&quot;&gt; &lt;code&gt;RandomAccess&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 경우 ,이 구현은 첫 번째 요소를 이동해야하는 위치로 교환 한 다음, 대체 된 요소를 이동 된 요소가 첫 번째 요소로 교체 될 때까지 이동해야하는 위치로 반복적으로 교환합니다. 필요한 경우 회전이 완료 될 때까지 두 번째 및 연속 요소에서 프로세스가 반복됩니다. 지정된리스트가 크고 &lt;code&gt;RandomAccess&lt;/code&gt; 인터페이스를 구현하지 않는 경우 ,이 구현은리스트를 index- &lt;code&gt;-distance mod size&lt;/code&gt; 주위의 두 개의 서브 리스트보기로 나눕니다 . 그런 다음 &lt;a href=&quot;collections#reverse-java.util.List-&quot;&gt; &lt;code&gt;reverse(List)&lt;/code&gt; &lt;/a&gt;메소드는 각 서브리스트보기에서 호출되고 마지막으로 전체 목록에서 호출됩니다. 두 알고리즘에 대한 자세한 설명은 Jon Bentley 's 2.3 단원을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a34d2ff62cb9dee92bc87d570b5cda8f97027ea5" translate="yes" xml:space="preserve">
          <source>If the specified local address is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as the AnyLocal address (see &lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt;&lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt;&lt;/a&gt;&lt;code&gt;()&lt;/code&gt;).</source>
          <target state="translated">지정된 로컬 주소가 &lt;code&gt;null&lt;/code&gt; 이면 주소를 AnyLocal 주소로 지정하는 것과 동일합니다 ( &lt;a href=&quot;inetaddress#isAnyLocalAddress()&quot;&gt; &lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt; &lt;/a&gt; &lt;code&gt;()&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e207478f4c307f8daec04a1eb43edfa1b56c4337" translate="yes" xml:space="preserve">
          <source>If the specified local address is &lt;code&gt;null&lt;/code&gt; it is the equivalent of specifying the address as the AnyLocal address (see &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt;&lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt;&lt;/a&gt;&lt;code&gt;()&lt;/code&gt;).</source>
          <target state="translated">지정된 로컬 주소가 &lt;code&gt;null&lt;/code&gt; 인 경우 주소를 AnyLocal 주소로 지정하는 것과 같습니다 ( &lt;a href=&quot;inetaddress#isAnyLocalAddress--&quot;&gt; &lt;code&gt;InetAddress.isAnyLocalAddress&lt;/code&gt; &lt;/a&gt; &lt;code&gt;()&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e20d600ab6dd5dfc2718408c731259b979d97003" translate="yes" xml:space="preserve">
          <source>If the specified locale contains &quot;ca&quot; (calendar), &quot;rg&quot; (region override), and/or &quot;tz&quot; (timezone) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode extensions&lt;/a&gt;, the calendar, the country and/or the time zone for formatting are overridden. If both &quot;ca&quot; and &quot;rg&quot; are specified, the calendar from the &quot;ca&quot; extension supersedes the implicit one from the &quot;rg&quot; extension.</source>
          <target state="translated">지정된 로케일에 &quot;ca&quot;(캘린더), &quot;rg&quot;(지역 재정의) 및 / 또는 &quot;tz&quot;(시간대) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;유니 코드 확장&lt;/a&gt; 이 포함 된 경우 달력, 국가 및 / 또는 서식 지정을위한 표준 시간대가 재정의됩니다. &quot;ca&quot;와 &quot;rg&quot;가 모두 지정되면 &quot;ca&quot;확장의 달력이 &quot;rg&quot;확장의 암시 적 달력을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="880a5d6295e66934e1af3a345f9a64565c2063d5" translate="yes" xml:space="preserve">
          <source>If the specified locale contains the &quot;&lt;code&gt;cf&lt;/code&gt;&quot; ( &lt;a href=&quot;https://www.unicode.org/reports/tr35/tr35.html#UnicodeCurrencyFormatIdentifier&quot;&gt; currency format style&lt;/a&gt;) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;, the returned currency format uses the style if it is available. Otherwise, the style uses the default &quot;&lt;code&gt;standard&lt;/code&gt;&quot; currency format. For example, if the style designates &quot;&lt;code&gt;account&lt;/code&gt;&quot;, negative currency amounts use a pair of parentheses in some locales.</source>
          <target state="translated">지정된 로케일에 &quot; &lt;code&gt;cf&lt;/code&gt; &quot;( &lt;a href=&quot;https://www.unicode.org/reports/tr35/tr35.html#UnicodeCurrencyFormatIdentifier&quot;&gt;통화 형식 스타일&lt;/a&gt; ) &lt;a href=&quot;../util/locale#def_locale_extension&quot;&gt;유니 코드 확장&lt;/a&gt; 이 포함 된 경우 반환 된 통화 형식은 사용 가능한 경우 스타일을 사용합니다. 그렇지 않으면 스타일은 기본 &quot; &lt;code&gt;standard&lt;/code&gt; &quot;통화 형식을 사용합니다. 예를 들어 스타일이 &quot; &lt;code&gt;account&lt;/code&gt; &quot;를 지정하는 경우 음수 통화 금액은 일부 로케일에서 한 쌍의 괄호를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3bb4277707fb1b363f377904ef8a00ae80162edc" translate="yes" xml:space="preserve">
          <source>If the specified name is already in the list of enabled attribute names, this method has no effect.</source>
          <target state="translated">지정된 이름이 이미 사용 가능한 속성 이름 목록에 있으면이 방법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5fdd0b3e89e1f58df16acb73daa9598c19a8c783" translate="yes" xml:space="preserve">
          <source>If the specified name is not in the list of enabled attribute names, this method has no effect.</source>
          <target state="translated">지정된 이름이 사용 가능한 속성 이름 목록에 없으면이 방법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="06d84325d01c60c6779f1c995e33cf0b305c715d" translate="yes" xml:space="preserve">
          <source>If the specified native is not a properly encoded native and the mappings for this native have not been altered with &lt;code&gt;setFlavorsForNative&lt;/code&gt;, then the contents of the &lt;code&gt;List&lt;/code&gt; is platform dependent, but &lt;code&gt;null&lt;/code&gt; cannot be returned.</source>
          <target state="translated">지정된 네이티브가 적절하게 인코딩 된 네이티브가 &lt;code&gt;setFlavorsForNative&lt;/code&gt; 네이티브에 대한 매핑이 setFlavorsForNative 로 변경되지 않은 경우 &lt;code&gt;List&lt;/code&gt; 의 콘텐츠 는 플랫폼에 따라 다르지만 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25d850bc5c8154fd5a609c44324b0fd903372382" translate="yes" xml:space="preserve">
          <source>If the specified native is previously unknown to the data transfer subsystem, and that native has been properly encoded, then invoking this method will establish a mapping in both directions between the specified native and a &lt;code&gt;DataFlavor&lt;/code&gt; whose MIME type is a decoded version of the native.</source>
          <target state="translated">지정된 네이티브가 이전에 데이터 전송 하위 시스템에 알려지지 않았고 해당 네이티브가 적절하게 인코딩 된 경우이 메서드를 호출하면 지정된 네이티브와 MIME 유형이 네이티브의 디코딩 된 버전 인 &lt;code&gt;DataFlavor&lt;/code&gt; 간의 양방향 매핑이 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="92b923f20f66bacef4d2ff1b575298d2082a6d3b" translate="yes" xml:space="preserve">
          <source>If the specified object is an instance of &lt;code&gt;Throwable&lt;/code&gt;, it becomes the</source>
          <target state="translated">지정된 객체가 &lt;code&gt;Throwable&lt;/code&gt; 의 인스턴스 인 경우는</target>
        </trans-unit>
        <trans-unit id="f07c1a027ba244740b1e94181579aafe6b9799f7" translate="yes" xml:space="preserve">
          <source>If the specified prefix is already in the list of enabled notification types, this method has no effect.</source>
          <target state="translated">지정된 접두사가 이미 사용 가능한 알림 유형 목록에있는 경우이 방법은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35c19bfb0ddf95e53e5300c7d5d437ccd663d657" translate="yes" xml:space="preserve">
          <source>If the specified prefix is not in the list of enabled notification types, this method has no effect.</source>
          <target state="translated">지정된 접두사가 사용 가능한 알림 유형 목록에없는 경우이 방법은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f43c50810daae04d0ace6639274dabc1168944f9" translate="yes" xml:space="preserve">
          <source>If the specified property is not defined for a particular file format, this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">지정된 속성이 특정 파일 형식에 대해 정의되어 있지 않으면이 메서드는 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0dde80edd4786d58af9002dd456373854e678d38" translate="yes" xml:space="preserve">
          <source>If the specified property is not found or cannot be parsed as an integer then the &lt;code&gt;Color&lt;/code&gt; specified by the second argument is returned instead.</source>
          <target state="translated">지정된 속성을 찾을 수 없거나 정수로 구문 분석 할 수없는 경우 두 번째 인수로 지정된 &lt;code&gt;Color&lt;/code&gt; 가 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bdabf1d6b2382f70866806891245d3b01a4f4527" translate="yes" xml:space="preserve">
          <source>If the specified property is not found or could not be parsed as an integer then &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 속성을 찾을 수 없거나 정수로 구문 분석 할 수없는 경우 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d802140ffd78fd804cf7b1fd2b7295c7e5afc88" translate="yes" xml:space="preserve">
          <source>If the specified property is not found or could not be parsed as an integer then the integer value &lt;code&gt;v&lt;/code&gt; is used instead, and is converted to a &lt;code&gt;Color&lt;/code&gt; object.</source>
          <target state="translated">지정된 속성을 찾을 수 없거나 정수로 구문 분석 할 수없는 경우 정수 값 &lt;code&gt;v&lt;/code&gt; 가 대신 사용되며 &lt;code&gt;Color&lt;/code&gt; 개체 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4834c64d62740309c88f771524fdcb223e3fc7b" translate="yes" xml:space="preserve">
          <source>If the specified range of text does not fit into a &lt;code&gt;DOMString&lt;/code&gt;.</source>
          <target state="translated">지정된 텍스트 범위가 &lt;code&gt;DOMString&lt;/code&gt; 에 맞지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="caa74ec04f197f8793bb6217e9a34e0badeccd71" translate="yes" xml:space="preserve">
          <source>If the specified system ID is a relative URI reference (see section 5 in [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;]), the DOM implementation will attempt to resolve the relative URI with the &lt;code&gt;baseURI&lt;/code&gt; as the base, if that fails, the behavior is implementation dependent.</source>
          <target state="translated">지정된 시스템 ID가 상대 URI 참조 ([ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]의 섹션 5 참조 ) 인 경우 DOM 구현은 &lt;code&gt;baseURI&lt;/code&gt; 를 기준으로하는 상대 URI를 확인하려고 시도 합니다. 실패하면 동작은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ccebe2f1442b09ad81733fcfdb75c424f50597a4" translate="yes" xml:space="preserve">
          <source>If the specified system ID is a relative URI reference (see section 5 in [&lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;]), the DOM implementation will attempt to resolve the relative URI with the &lt;code&gt;baseURI&lt;/code&gt; as the base, if that fails, the behavior is implementation dependent.</source>
          <target state="translated">지정된 시스템 ID가 상대 URI 참조 ([ &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]의 섹션 5 참조 ) 인 경우 DOM 구현은 &lt;code&gt;baseURI&lt;/code&gt; 를 기준으로하는 상대 URI를 확인하려고 시도 합니다. 실패하면 동작은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1954d35e1a8126307e2b4392ca7004d2cfa54884" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then &lt;a href=&quot;timeoutexception&quot;&gt;&lt;code&gt;TimeoutException&lt;/code&gt;&lt;/a&gt; is thrown. If the time is less than or equal to zero, the method will not wait at all.</source>
          <target state="translated">지정된 대기 시간이 경과하면 &lt;a href=&quot;timeoutexception&quot;&gt; &lt;code&gt;TimeoutException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 시간이 0보다 작거나 같은 경우이 방법은 전혀 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="310c63f9de70d34cca02c16171cb0b3c368911f0" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then the value &lt;code&gt;false&lt;/code&gt; is returned. If the time is less than or equal to zero, the method will not wait at all.</source>
          <target state="translated">지정된 대기 시간이 경과하면 &lt;code&gt;false&lt;/code&gt; 값 이 리턴됩니다. 시간이 0보다 작거나 같은 경우이 방법은 전혀 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bdd6bad6b7c4c04adc8addbdd6baac39622961b" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then the value &lt;code&gt;false&lt;/code&gt; is returned. If the time is less than or equal to zero, the method will not wait at all. Any permits that were to be assigned to this thread, are instead assigned to other threads trying to acquire permits, as if the permits had been made available by a call to &lt;a href=&quot;#release()&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 대기 시간이 경과하면 &lt;code&gt;false&lt;/code&gt; 값 이 반환됩니다. 시간이 0보다 작거나 같으면 메서드는 전혀 기다리지 않습니다. 이 스레드에 할당 될 모든 허가는 마치 &lt;a href=&quot;#release()&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출로 허가를 사용할 수있는 것처럼 허가를 얻으려는 다른 스레드에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="229ff9ac1c41d305f35a7c0608935889e0aaec6b" translate="yes" xml:space="preserve">
          <source>If the specified waiting time elapses then the value &lt;code&gt;false&lt;/code&gt; is returned. If the time is less than or equal to zero, the method will not wait at all. Any permits that were to be assigned to this thread, are instead assigned to other threads trying to acquire permits, as if the permits had been made available by a call to &lt;a href=&quot;semaphore#release--&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 대기 시간이 경과하면 &lt;code&gt;false&lt;/code&gt; 값 이 리턴됩니다. 시간이 0보다 작거나 같은 경우이 방법은 전혀 기다리지 않습니다. 이 스레드에 할당 된 모든 허가는 &lt;a href=&quot;semaphore#release--&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출에 의해 허용 된 것처럼 허가를 획득하려는 다른 스레드에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e9384353fa1c2365434f6e7663568dfb603f1c6" translate="yes" xml:space="preserve">
          <source>If the specified waiting time is zero or negative, the method does nothing. Otherwise, if the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</source>
          <target state="translated">지정된 대기 시간이 0이거나 음수이면 메서드는 아무 작업도 수행하지 않습니다. 그렇지 않으면 허가가 사용 가능하면 소비되고 호출이 즉시 반환됩니다. 그렇지 않으면 현재 스레드가 스레드 스케줄링 목적으로 비활성화되고 다음 네 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="6d2fa8250cbec1b974164fdd92ff3bc201feb96b" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect other than validating its argument.</source>
          <target state="translated">이 &lt;code&gt;Throwable&lt;/code&gt; 의 스택 추적이 &lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;쓰기 가능하지 않은&lt;/a&gt; 경우이 메서드를 호출해도 인수를 확인하는 것 외에 다른 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6d793547d8065207a7a2a3b64f74bfbae2f70956" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect.</source>
          <target state="translated">이 &lt;code&gt;Throwable&lt;/code&gt; 의 스택 추적이 &lt;a href=&quot;#%3Cinit%3E(java.lang.String,java.lang.Throwable,boolean,boolean)&quot;&gt;쓰기 가능하지 않은&lt;/a&gt; 경우이 메서드를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3dda73785392b01747ad72630377e93ff7ebd123" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect other than validating its argument.</source>
          <target state="translated">이 &lt;code&gt;Throwable&lt;/code&gt; 의 스택 트레이스가 &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;쓰기 가능하지 않은 경우&lt;/a&gt; ,이 메소드를 호출해도 인수의 유효성을 검사하는 것 외에 다른 효과는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f140d470f07fad292b66fc6ee306ae6d2a54ab2a" translate="yes" xml:space="preserve">
          <source>If the stack trace of this &lt;code&gt;Throwable&lt;/code&gt;&lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;is not writable&lt;/a&gt;, calling this method has no effect.</source>
          <target state="translated">이 &lt;code&gt;Throwable&lt;/code&gt; 의 스택 트레이스가 &lt;a href=&quot;throwable#Throwable-java.lang.String-java.lang.Throwable-boolean-boolean-&quot;&gt;쓰기 가능하지 않은 경우&lt;/a&gt; ,이 메소드를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a0c7fbb44b44d8e097852c8b27b45e37f7b8b9c" translate="yes" xml:space="preserve">
          <source>If the standard error of the process has been redirected using &lt;a href=&quot;processbuilder#redirectError(java.lang.ProcessBuilder.Redirect)&quot;&gt;&lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;processbuilder#redirectErrorStream(boolean)&quot;&gt;&lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder#redirectError(java.lang.ProcessBuilder.Redirect)&quot;&gt; &lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;processbuilder#redirectErrorStream(boolean)&quot;&gt; &lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt; &lt;/a&gt; 을 사용하여 프로세스의 표준 오류가 리디렉션 된 경우이 메서드는 &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="077ba9a63c85f3c79b6472adbd6bd273ed829948" translate="yes" xml:space="preserve">
          <source>If the standard error of the subprocess has been redirected using &lt;a href=&quot;processbuilder#redirectError-java.lang.ProcessBuilder.Redirect-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;processbuilder#redirectErrorStream-boolean-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder#redirectError-java.lang.ProcessBuilder.Redirect-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;processbuilder#redirectErrorStream-boolean-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectErrorStream&lt;/code&gt; &lt;/a&gt; 을 사용하여 하위 프로세스의 표준 오류를 리디렉션 한 경우이 메서드는 &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="68b1b68d307d6ca1fc6a760c2ae878282f015b92" translate="yes" xml:space="preserve">
          <source>If the standard input of the process has been redirected using &lt;a href=&quot;processbuilder#redirectInput(java.lang.ProcessBuilder.Redirect)&quot;&gt;&lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">프로세스의 표준 입력 이 &lt;a href=&quot;processbuilder#redirectInput(java.lang.ProcessBuilder.Redirect)&quot;&gt; &lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt; &lt;/a&gt; 을 사용하여 리디렉션 된 경우이 메서드는 &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;null 출력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="86430b03fbc71403519b5c3b7220021c3f6618a7" translate="yes" xml:space="preserve">
          <source>If the standard input of the subprocess has been redirected using &lt;a href=&quot;processbuilder#redirectInput-java.lang.ProcessBuilder.Redirect-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;null output stream&lt;/a&gt;.</source>
          <target state="translated">하위 프로세스의 표준 입력 이 &lt;a href=&quot;processbuilder#redirectInput-java.lang.ProcessBuilder.Redirect-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectInput&lt;/code&gt; &lt;/a&gt; 을 사용하여 경로 재 지정된 경우이 메소드는 &lt;a href=&quot;processbuilder#redirect-input&quot;&gt;널 출력 스트림을&lt;/a&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="3193a3f874d9883f06995425c57bb9f49f95c498" translate="yes" xml:space="preserve">
          <source>If the standard output of the process has been redirected using &lt;a href=&quot;processbuilder#redirectOutput(java.lang.ProcessBuilder.Redirect)&quot;&gt;&lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;processbuilder#redirectOutput(java.lang.ProcessBuilder.Redirect)&quot;&gt; &lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt; &lt;/a&gt; 을 사용하여 프로세스의 표준 출력이 리디렉션 된 경우이 메서드는 &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null 입력 스트림을&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="7075f6432f67c8c99f417e3aed9f9abd4674447d" translate="yes" xml:space="preserve">
          <source>If the standard output of the subprocess has been redirected using &lt;a href=&quot;processbuilder#redirectOutput-java.lang.ProcessBuilder.Redirect-&quot;&gt;&lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt;&lt;/a&gt; then this method will return a &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;null input stream&lt;/a&gt;.</source>
          <target state="translated">하위 프로세스의 표준 출력 이 &lt;a href=&quot;processbuilder#redirectOutput-java.lang.ProcessBuilder.Redirect-&quot;&gt; &lt;code&gt;ProcessBuilder.redirectOutput&lt;/code&gt; &lt;/a&gt; 을 사용하여 경로 재 지정된 경우이 메소드는 &lt;a href=&quot;processbuilder#redirect-output&quot;&gt;널 입력 스트림을&lt;/a&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="ef7d1e9b0031ea83269d5adfbd99e3c687130e6f" translate="yes" xml:space="preserve">
          <source>If the state of this check box is &lt;code&gt;true&lt;/code&gt; and the new group already has a check box selected, this check box's state is changed to &lt;code&gt;false&lt;/code&gt;. If the state of this check box is &lt;code&gt;true&lt;/code&gt; and the new group has no check box selected, this check box becomes the selected checkbox for the new group and its state is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 확인란의 상태가 &lt;code&gt;true&lt;/code&gt; 이고 새 그룹에 이미 확인란이 선택되어 있으면이 확인란의 상태가 &lt;code&gt;false&lt;/code&gt; 로 변경됩니다 . 이 확인란의 상태가 &lt;code&gt;true&lt;/code&gt; 이고 새 그룹에 선택된 확인란이없는 경우이 확인란은 새 그룹에 대해 선택된 확인란이되고 상태는 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d366f3eb6bf9e4d636eed0b8ad01a318338322f7" translate="yes" xml:space="preserve">
          <source>If the stream argument is &lt;code&gt;true&lt;/code&gt;, this creates a stream socket. If the stream argument is &lt;code&gt;false&lt;/code&gt;, it creates a datagram socket.</source>
          <target state="translated">stream 인수가 &lt;code&gt;true&lt;/code&gt; 인 경우 스트림 소켓이 작성됩니다. stream 인수가 &lt;code&gt;false&lt;/code&gt; 인 경우 데이터 그램 소켓을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="99da69fcd16c1de3a48462f6d509743df4ef63c3" translate="yes" xml:space="preserve">
          <source>If the stream is already closed, invoking this method has no effect.</source>
          <target state="translated">스트림이 이미 닫혀 있으면이 메서드를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3eb34c7e224c2415946e3db9d58aac4984e092ef" translate="yes" xml:space="preserve">
          <source>If the stream is already closed, the action will be performed immediately in the current thread.</source>
          <target state="translated">스트림이 이미 닫혀 있으면 작업이 현재 스레드에서 즉시 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="92109724254a6a952d63389232984fc4b39d101f" translate="yes" xml:space="preserve">
          <source>If the stream is parallel, and the &lt;code&gt;Collector&lt;/code&gt; is &lt;a href=&quot;collector.characteristics#CONCURRENT&quot;&gt;&lt;code&gt;concurrent&lt;/code&gt;&lt;/a&gt;, and either the stream is unordered or the collector is &lt;a href=&quot;collector.characteristics#UNORDERED&quot;&gt;&lt;code&gt;unordered&lt;/code&gt;&lt;/a&gt;, then a concurrent reduction will be performed (see &lt;a href=&quot;collector&quot;&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt; for details on concurrent reduction.)</source>
          <target state="translated">스트림이 병렬이고 &lt;code&gt;Collector&lt;/code&gt; 가 &lt;a href=&quot;collector.characteristics#CONCURRENT&quot;&gt; &lt;code&gt;concurrent&lt;/code&gt; &lt;/a&gt; 이고 스트림이 정렬되지 않거나 수집기가 &lt;a href=&quot;collector.characteristics#UNORDERED&quot;&gt; &lt;code&gt;unordered&lt;/code&gt; &lt;/a&gt; 경우 동시 축소가 수행됩니다 ( 동시 축소에 대한 자세한 내용 은 &lt;a href=&quot;collector&quot;&gt; &lt;code&gt;Collector&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f3975bae6f8df00f0d259552436dae709c82b9db" translate="yes" xml:space="preserve">
          <source>If the style sheet is a linked style sheet, the value of its attribute is its location.</source>
          <target state="translated">스타일 시트가 링크 된 스타일 시트 인 경우 속성 값은 해당 위치입니다.</target>
        </trans-unit>
        <trans-unit id="e8936505a02a28236a091f15ae37b5daf1c18699" translate="yes" xml:space="preserve">
          <source>If the style sheet is a linked style sheet, the value of its attribute is its location. For inline style sheets, the value of this attribute is &lt;code&gt;null&lt;/code&gt;. See the href attribute definition for the &lt;code&gt;LINK&lt;/code&gt; element in HTML 4.0, and the href pseudo-attribute for the XML style sheet processing instruction.</source>
          <target state="translated">스타일 시트가 링크 된 스타일 시트 인 경우 속성 값은 해당 위치입니다. 인라인 스타일 시트의 경우이 속성 값은 &lt;code&gt;null&lt;/code&gt; 입니다. HTML 4.0 의 &lt;code&gt;LINK&lt;/code&gt; 요소에 대한 href 속성 정의 와 XML 스타일 시트 처리 명령에 대한 href 의사 속성을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="649cf82f464f662aa965403c73cf99d556fea581" translate="yes" xml:space="preserve">
          <source>If the subprocess has already terminated then this method returns immediately with the value &lt;code&gt;true&lt;/code&gt;. If the process has not terminated and the timeout value is less than, or equal to, zero, then this method returns immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">서브 프로세스가 이미 종료 된 경우이 메소드는 &lt;code&gt;true&lt;/code&gt; 값으로 즉시 리턴 합니다 . 프로세스가 종료되지 않고 시간 종료 값이 0보다 작거나 같은 경우,이 메소드는 값을 &lt;code&gt;false&lt;/code&gt; 로 즉시 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="eadbeed59697fe559cad7872f812e28abf5d75a2" translate="yes" xml:space="preserve">
          <source>If the superclass is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type arguments used in the source code. The parameterized type representing the superclass is created if it had not been created before. See the declaration of &lt;a href=&quot;reflect/parameterizedtype&quot;&gt;&lt;code&gt;ParameterizedType&lt;/code&gt;&lt;/a&gt; for the semantics of the creation process for parameterized types. If this &lt;code&gt;Class&lt;/code&gt; object represents either the &lt;code&gt;Object&lt;/code&gt; class, an interface, a primitive type, or void, then null is returned. If this &lt;code&gt;Class&lt;/code&gt; object represents an array class then the &lt;code&gt;Class&lt;/code&gt; object representing the &lt;code&gt;Object&lt;/code&gt; class is returned.</source>
          <target state="translated">수퍼 클래스가 매개 변수화 된 유형 인 경우 반환 된 &lt;code&gt;Type&lt;/code&gt; 객체는 소스 코드에 사용 된 실제 유형 인수를 정확하게 반영해야합니다. 수퍼 클래스를 나타내는 매개 변수화 된 유형은 이전에 생성되지 않은 경우 생성됩니다. 매개 변수화 된 유형에 대한 생성 프로세스의 의미 는 &lt;a href=&quot;reflect/parameterizedtype&quot;&gt; &lt;code&gt;ParameterizedType&lt;/code&gt; &lt;/a&gt; 의 선언을 참조하십시오 . 이 &lt;code&gt;Class&lt;/code&gt; 객체가 &lt;code&gt;Object&lt;/code&gt; 클래스, 인터페이스, 기본 유형 또는 void를 나타내는 경우 null이 반환됩니다. 이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 클래스를 나타내는 경우 &lt;code&gt;Object&lt;/code&gt; 클래스를 나타내는 &lt;code&gt;Class&lt;/code&gt; 객체 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1b0a8ba1234c9978531ae814a7cbb1dae0a3c230" translate="yes" xml:space="preserve">
          <source>If the superclass is a parameterized type, the &lt;code&gt;Type&lt;/code&gt; object returned must accurately reflect the actual type parameters used in the source code. The parameterized type representing the superclass is created if it had not been created before. See the declaration of &lt;a href=&quot;reflect/parameterizedtype&quot;&gt;&lt;code&gt;ParameterizedType&lt;/code&gt;&lt;/a&gt; for the semantics of the creation process for parameterized types. If this &lt;code&gt;Class&lt;/code&gt; represents either the &lt;code&gt;Object&lt;/code&gt; class, an interface, a primitive type, or void, then null is returned. If this object represents an array class then the &lt;code&gt;Class&lt;/code&gt; object representing the &lt;code&gt;Object&lt;/code&gt; class is returned.</source>
          <target state="translated">수퍼 클래스가 매개 변수화 된 유형 인 경우, 리턴 된 &lt;code&gt;Type&lt;/code&gt; 오브젝트는 소스 코드에 사용 된 실제 유형 매개 변수를 정확하게 반영해야합니다. 슈퍼 클래스를 나타내는 매개 변수화 된 유형은 이전에 작성되지 않은 경우 작성됩니다. 매개 변수화 된 유형에 대한 작성 프로세스의 시맨틱에 대해서는 &lt;a href=&quot;reflect/parameterizedtype&quot;&gt; &lt;code&gt;ParameterizedType&lt;/code&gt; &lt;/a&gt; 선언을 참조하십시오 . 이 &lt;code&gt;Class&lt;/code&gt; 가 &lt;code&gt;Object&lt;/code&gt; 클래스, 인터페이스, 프리미티브 유형 또는 void를 나타내는 경우 널이 리턴됩니다. 이 객체가 배열 클래스를 나타내는 경우, &lt;code&gt;Object&lt;/code&gt; 클래스를 나타내는 &lt;code&gt;Class&lt;/code&gt; 객체 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="702061aae71a7b0bc29035519b62837f0bf9ee3d" translate="yes" xml:space="preserve">
          <source>If the supplied &lt;code&gt;ImageReadParam&lt;/code&gt; contains optional setting values not supported by this reader (</source>
          <target state="translated">제공된 &lt;code&gt;ImageReadParam&lt;/code&gt; 에이 리더에서 지원하지 않는 선택적 설정 값이 포함 된 경우 (</target>
        </trans-unit>
        <trans-unit id="a6062faf5608aab9b4601cbc2c84f0f96e088fa9" translate="yes" xml:space="preserve">
          <source>If the supplied &lt;code&gt;ImageWriteParam&lt;/code&gt; contains optional setting values not supported by this writer (</source>
          <target state="translated">제공된 &lt;code&gt;ImageWriteParam&lt;/code&gt; 에이 라이터에서 지원하지 않는 선택적 설정 값이 포함 된 경우 (</target>
        </trans-unit>
        <trans-unit id="e0ec08c9bcf3ded436efba803a4101d1da6386d3" translate="yes" xml:space="preserve">
          <source>If the supplied &lt;code&gt;ImageWriteParam&lt;/code&gt; contains optional setting values not understood by this writer or transcoder, they will be ignored.</source>
          <target state="translated">제공된 &lt;code&gt;ImageWriteParam&lt;/code&gt; 에이 기록 기나 트랜스 코더가 이해할 수없는 선택적 설정 값이 포함되어 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="83332eaf39cb8bfd82ea83337e6eefff71ef19fb" translate="yes" xml:space="preserve">
          <source>If the support for extended mouse buttons is &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;disabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to use only the following standard button masks: &lt;code&gt;InputEvent.BUTTON1_DOWN_MASK&lt;/code&gt;, &lt;code&gt;InputEvent.BUTTON2_DOWN_MASK&lt;/code&gt;, &lt;code&gt;InputEvent.BUTTON3_DOWN_MASK&lt;/code&gt;.</source>
          <target state="translated">확장 마우스 버튼에 대한 지원 이 Java에 의해 &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;disabled&lt;/code&gt; &lt;/a&gt; 된 경우 다음 표준 버튼 마스크 만 사용할 수 있습니다. &lt;code&gt;InputEvent.BUTTON1_DOWN_MASK&lt;/code&gt; , &lt;code&gt;InputEvent.BUTTON2_DOWN_MASK&lt;/code&gt; , &lt;code&gt;InputEvent.BUTTON3_DOWN_MASK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96b9d55f1b2271749505c66ce5e0fd46a6ed130f" translate="yes" xml:space="preserve">
          <source>If the support for extended mouse buttons is &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;enabled&lt;/code&gt;&lt;/a&gt; by Java then it is allowed to use the standard button masks and masks for existing extended mouse buttons, if the mouse has more then three buttons. In that way, it is allowed to use the button masks corresponding to the buttons in the range from 1 to &lt;a href=&quot;mouseinfo#getNumberOfButtons()&quot;&gt;&lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">확장 마우스 단추 지원이 &lt;a href=&quot;toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;enabled&lt;/code&gt; &lt;/a&gt; 이 Java에 의해 된 경우 마우스에 3 개 이상의 버튼이있는 경우 기존 확장 마우스 버튼에 대한 표준 버튼 마스크 및 마스크를 사용할 수 있습니다. 이렇게하면 1부터 &lt;a href=&quot;mouseinfo#getNumberOfButtons()&quot;&gt; &lt;code&gt;MouseInfo.getNumberOfButtons()&lt;/code&gt; &lt;/a&gt; 까지의 범위에서 버튼에 해당하는 버튼 마스크를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c7431ea9b95b75172bde5cfc89a8c0841e0ed59" translate="yes" xml:space="preserve">
          <source>If the system ID is a URL, it will be fully resolved.</source>
          <target state="translated">시스템 ID가 URL이면 완전히 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="7b5818c71edba95dbdcbbbe03f31b7344a7f8756" translate="yes" xml:space="preserve">
          <source>If the system ID is a relative URI reference (see section 5 in [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;]), the behavior is implementation dependent.</source>
          <target state="translated">시스템 ID가 상대 URI 참조 인 경우 ([&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt; IETF RFC 2396&lt;/a&gt; ]의 ) 인 경우 동작은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="331d34dbe48eb64c17b2f5bc6cd336e62af8577b" translate="yes" xml:space="preserve">
          <source>If the system ID is a relative URI reference (see section 5 in [&lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;]), the behavior is implementation dependent.</source>
          <target state="translated">시스템 ID가 상대 URI 참조 ([ &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]의 섹션 5 참조 ) 인 경우 동작은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="11c8152472d911028fe75c0272d12bdc08e6d5e4" translate="yes" xml:space="preserve">
          <source>If the system does not support environment variables, an empty map is returned.</source>
          <target state="translated">시스템이 환경 변수를 지원하지 않으면 빈 맵이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="06f52e1b071eac0948a9acca87880e3e4138c05f" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, it must be fully resolved (it may not be a relative URL).</source>
          <target state="translated">시스템 식별자가 URL 인 경우 완전히 확인되어야합니다 (상대 URL이 아닐 수도 있음).</target>
        </trans-unit>
        <trans-unit id="702582a6612c4020970698031381ca0b9cdc6250" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, it must be fully resolved by the application before it is passed to the parser.</source>
          <target state="translated">시스템 식별자가 URL 인 경우 파서로 전달되기 전에 응용 프로그램에서 완전히 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1141b9ff132e9f64996b3e44968c6f92596158e" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, it will have been resolved fully.</source>
          <target state="translated">시스템 식별자가 URL이면 완전히 확인 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="69c62c9017d4450e514b7c2160989710e82b3ed0" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, the SAX parser must resolve it fully before reporting it to the application.</source>
          <target state="translated">시스템 식별자가 URL 인 경우 SAX 구문 분석기는 응용 프로그램에보고하기 전에이를 완전히 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="84493bb7e50a00814aa34c277d5716aea3301f50" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, the parser must resolve it fully before passing it to the application.</source>
          <target state="translated">시스템 식별자가 URL 인 경우 파서는 응용 프로그램에 전달하기 전에이를 완전히 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="63e187f8aea2b4eaa14f670a85e3ec3f6d417906" translate="yes" xml:space="preserve">
          <source>If the system identifier is a URL, the parser must resolve it fully before passing it to the application. For example, a file name must always be provided as a &lt;em&gt;file:...&lt;/em&gt; URL, and other kinds of relative URI are also resolved against their bases.</source>
          <target state="translated">시스템 식별자가 URL 인 경우 파서는 응용 프로그램에 전달하기 전에이를 완전히 확인해야합니다. 예를 들어 파일 이름은 항상 파일로 제공되어야합니다 &lt;em&gt;....&lt;/em&gt; URL 하며 다른 종류의 상대 URI도 해당 기반에 대해 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="1d4775f63756839b1ddacbd6914b05abbe4f7038" translate="yes" xml:space="preserve">
          <source>If the system property &quot;&lt;code&gt;&lt;span id=&quot;java.system.class.loader&quot;&gt;java.system.class.loader&lt;/span&gt;&lt;/code&gt;&quot; is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type &lt;code&gt;ClassLoader&lt;/code&gt; which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader. During construction, the class loader should take great care to avoid calling &lt;code&gt;getSystemClassLoader()&lt;/code&gt;. If circular initialization of the system class loader is detected then an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 메소드가 처음 호출 될 때 시스템 특성 &quot; &lt;code&gt;&lt;span id=&quot;java.system.class.loader&quot;&gt;java.system.class.loader&lt;/span&gt;&lt;/code&gt; &quot;가 정의 된 경우 해당 특성의 값은 시스템 클래스 로더로 리턴 될 클래스 이름으로 간주됩니다. 클래스는 기본 시스템 클래스 로더를 사용하여로드 되며 위임 부모로 사용되는 &lt;code&gt;ClassLoader&lt;/code&gt; 유형의 단일 매개 변수를 사용하는 공용 생성자를 정의해야합니다 . 그런 다음 기본 시스템 클래스 로더를 매개 변수로 사용하여이 생성자를 사용하여 인스턴스가 작성됩니다. 결과 클래스 로더는 시스템 클래스 로더로 정의됩니다. 생성 중에 클래스 로더는 &lt;code&gt;getSystemClassLoader()&lt;/code&gt; 호출을 방지하기 위해 세심한주의를 기울여야합니다 . 시스템 클래스 로더의 순환 초기화가 감지되면 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="98fa5298bfbc9c3dc738e30b2cfbc794eda77505" translate="yes" xml:space="preserve">
          <source>If the system property &quot;&lt;code&gt;java.system.class.loader&lt;/code&gt;&quot; is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type &lt;code&gt;ClassLoader&lt;/code&gt; which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader.</source>
          <target state="translated">이 메소드가 처음 호출 될 때 시스템 특성 &quot; &lt;code&gt;java.system.class.loader&lt;/code&gt; &quot;가 정의 된 경우 해당 특성의 값은 시스템 클래스 로더로 리턴 될 클래스의 이름이됩니다. 클래스는 기본 시스템 클래스 로더를 사용하여로드 되며 위임 상위로 사용되는 &lt;code&gt;ClassLoader&lt;/code&gt; 유형의 단일 매개 변수를 사용하는 공용 생성자를 정의해야합니다 . 그런 다음 기본 시스템 클래스 로더를 매개 변수로 사용하여이 생성자를 사용하여 인스턴스가 작성됩니다. 결과 클래스 로더는 시스템 클래스 로더로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="72daeec5943fe704e6b6f79f778edda5bb93a7be" translate="yes" xml:space="preserve">
          <source>If the system property &quot;&lt;code&gt;java.system.class.loader&lt;/code&gt;&quot; is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type &lt;code&gt;ClassLoader&lt;/code&gt; which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader. During construction, the class loader should take great care to avoid calling &lt;code&gt;getSystemClassLoader()&lt;/code&gt;. If circular initialization of the system class loader is detected then an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 메소드가 처음 호출 될 때 시스템 특성 &quot; &lt;code&gt;java.system.class.loader&lt;/code&gt; &quot;가 정의 된 경우 해당 특성의 값은 시스템 클래스 로더로 리턴 될 클래스의 이름이됩니다. 클래스는 기본 시스템 클래스 로더를 사용하여로드 되며 위임 부모로 사용되는 &lt;code&gt;ClassLoader&lt;/code&gt; 유형의 단일 매개 변수를 사용하는 공용 생성자를 정의해야합니다 . 그런 다음 기본 시스템 클래스 로더를 매개 변수로 사용하여이 생성자를 사용하여 인스턴스가 작성됩니다. 결과 클래스 로더는 시스템 클래스 로더로 정의됩니다. 생성 중에 클래스 로더는 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생 하지 않도록주의해야합니다 . &lt;code&gt;getSystemClassLoader()&lt;/code&gt; . 시스템 클래스 로더의 순환 초기화가 감지되면</target>
        </trans-unit>
        <trans-unit id="b99d8bdd490b40a5b7b3869d55b18d0b463d68ae" translate="yes" xml:space="preserve">
          <source>If the system property &lt;a href=&quot;#DEFAULT_PROPERTY_NAME&quot;&gt;&lt;code&gt;DEFAULT_PROPERTY_NAME&lt;/code&gt;&lt;/a&gt; + &quot;:uri&quot; is present, where uri is the parameter to this method, then its value is read as a class name. The method will try to create a new instance of this class by using the class loader, and returns it if it is successfully created.</source>
          <target state="translated">시스템 속성 &lt;a href=&quot;#DEFAULT_PROPERTY_NAME&quot;&gt; &lt;code&gt;DEFAULT_PROPERTY_NAME&lt;/code&gt; &lt;/a&gt; + &quot;: uri&quot;가있는 경우, 여기서 uri는이 메서드에 대한 매개 변수이며 해당 값은 클래스 이름으로 읽습니다. 메서드는 클래스 로더를 사용하여이 클래스의 새 인스턴스를 만들려고 시도하고 성공적으로 만들어진 경우 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07bb24fbcfd01038cb271accdc3621d725d60279" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&quot;javax.xml.validation.SchemaFactory:&amp;lt;i&amp;gt;schemaLanguage&amp;lt;/i&amp;gt;&quot;&lt;/code&gt; is present (where</source>
          <target state="translated">시스템 속성 &lt;code&gt;&quot;javax.xml.validation.SchemaFactory:&amp;lt;i&amp;gt;schemaLanguage&amp;lt;/i&amp;gt;&quot;&lt;/code&gt; 가있는 경우 (여기서</target>
        </trans-unit>
        <trans-unit id="7f7a9a303f9cb45f840f5c2ab595c9253722c6a7" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;com.sun.net.httpserver.HttpServerProvider&quot;&gt;com.sun.net.httpserver.HttpServerProvider&lt;/span&gt;&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified unchecked error or exception is thrown.</source>
          <target state="translated">시스템 등록 정보 &lt;code&gt;&lt;span id=&quot;com.sun.net.httpserver.HttpServerProvider&quot;&gt;com.sun.net.httpserver.HttpServerProvider&lt;/span&gt;&lt;/code&gt; 가 정의 된 경우 이는 구체적인 공급자 클래스의 정규화 된 이름으로 간주됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 확인되지 않은 오류 또는 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="84e51147b8722cac897d95fae276f73bfae5bacd" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;java.nio.channels.spi.AsynchronousChannelProvider&quot;&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/span&gt;&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 특성 &lt;code&gt;&lt;span id=&quot;java.nio.channels.spi.AsynchronousChannelProvider&quot;&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/span&gt;&lt;/code&gt; 가 정의 된 경우 이는 구체적인 제공자 클래스의 완전한 이름으로 간주됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ef75bfa5083a390acda97a096494d6c039249d74" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;java.nio.channels.spi.SelectorProvider&quot;&gt;java.nio.channels.spi.SelectorProvider&lt;/span&gt;&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 특성 &lt;code&gt;&lt;span id=&quot;java.nio.channels.spi.SelectorProvider&quot;&gt;java.nio.channels.spi.SelectorProvider&lt;/span&gt;&lt;/code&gt; 가 정의 된 경우 이는 구체적인 제공자 클래스의 완전한 이름으로 간주됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7ae664d66a76b02b3110fa2464812b1011bc5ba9" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;java.rmi.server.RMIClassLoaderSpi&quot;&gt;java.rmi.server.RMIClassLoaderSpi&lt;/span&gt;&lt;/code&gt; is defined, then if its value equals the string &lt;code&gt;&quot;default&quot;&lt;/code&gt;, the provider instance will be the value returned by an invocation of the &lt;a href=&quot;#getDefaultProviderInstance()&quot;&gt;&lt;code&gt;getDefaultProviderInstance()&lt;/code&gt;&lt;/a&gt; method, and for any other value, if a class named with the value of the property can be loaded by the system class loader (see &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;&lt;/a&gt;) and that class is assignable to &lt;a href=&quot;rmiclassloaderspi&quot;&gt;&lt;code&gt;RMIClassLoaderSpi&lt;/code&gt;&lt;/a&gt; and has a public no-argument constructor, then that constructor will be invoked to create the provider instance. If the property is defined but any other of those conditions are not true, then an unspecified &lt;code&gt;Error&lt;/code&gt; will be thrown to code that attempts to use &lt;code&gt;RMIClassLoader&lt;/code&gt;, indicating the failure to obtain a provider instance.</source>
          <target state="translated">시스템 속성 &lt;code&gt;&lt;span id=&quot;java.rmi.server.RMIClassLoaderSpi&quot;&gt;java.rmi.server.RMIClassLoaderSpi&lt;/span&gt;&lt;/code&gt; 가 정의 된 경우 해당 값이 문자열 &lt;code&gt;&quot;default&quot;&lt;/code&gt; 와 같으면 공급자 인스턴스는 &lt;a href=&quot;#getDefaultProviderInstance()&quot;&gt; &lt;code&gt;getDefaultProviderInstance()&lt;/code&gt; &lt;/a&gt; 메서드 호출에 의해 반환 된 값이되고 다른 값의 경우 다음과 같은 경우 속성 값으로 명명 된 클래스는 시스템 클래스 로더 ( &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt; &lt;/a&gt; 참조)에 의해로드 될 수 있으며 해당 클래스는 &lt;a href=&quot;rmiclassloaderspi&quot;&gt; &lt;code&gt;RMIClassLoaderSpi&lt;/code&gt; 에&lt;/a&gt; 할당 할 수 있고 인수가없는 공용 생성자를 가지고 있습니다. 그러면 해당 생성자가 호출되어 공급자 인스턴스. 속성이 정의되었지만 다른 조건이 참이 아닌 경우 사용을 시도하는 코드에 지정되지 않은 &lt;code&gt;Error&lt;/code&gt; 가 발생합니다. &lt;code&gt;RMIClassLoader&lt;/code&gt; , 공급자 인스턴스를 가져 오지 못했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="49ac08bfd515249091e7394a6ee49c9a2fed5e70" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;java.rmi.server.randomIDs&quot;&gt;java.rmi.server.randomIDs&lt;/span&gt;&lt;/code&gt; is defined to equal the string &lt;code&gt;&quot;true&quot;&lt;/code&gt; (case insensitive), then the &lt;a href=&quot;#%3Cinit%3E()&quot;&gt;&lt;code&gt;ObjID()&lt;/code&gt;&lt;/a&gt; constructor will use a cryptographically strong random number generator to choose the object number of the returned &lt;code&gt;ObjID&lt;/code&gt;.</source>
          <target state="translated">시스템 속성 &lt;code&gt;&lt;span id=&quot;java.rmi.server.randomIDs&quot;&gt;java.rmi.server.randomIDs&lt;/span&gt;&lt;/code&gt; 가 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; (대소 문자 구분 안 함)와 같도록 정의 된 경우 &lt;a href=&quot;#%3Cinit%3E()&quot;&gt; &lt;code&gt;ObjID()&lt;/code&gt; &lt;/a&gt; 생성자는 암호화 된 강력한 난수 생성기를 사용하여 반환 된 &lt;code&gt;ObjID&lt;/code&gt; 의 개체 번호를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="16322c9765cf14a6f819de14a9ca0ba3b1b00413" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledCipherSuites&quot;&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/span&gt;&lt;/code&gt; is specified, the &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt;&lt;code&gt;createSocket(String,int)&lt;/code&gt;&lt;/a&gt; method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS cipher suites to enable.</source>
          <target state="translated">시스템 속성 &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledCipherSuites&quot;&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/span&gt;&lt;/code&gt; 가 지정된 경우 &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt; &lt;code&gt;createSocket(String,int)&lt;/code&gt; &lt;/a&gt; 메서드는 소켓을 반환하기 전에 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 시스템 속성의 값은 활성화 할 SSL / TLS 암호화 제품군의 쉼표로 구분 된 목록 인 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="596e2084ca2c577ef4c311446714119d3d18b3ee" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledCipherSuites-1&quot;&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/span&gt;&lt;/code&gt; is specified, this method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS cipher suites to enable.</source>
          <target state="translated">시스템 속성 &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledCipherSuites-1&quot;&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/span&gt;&lt;/code&gt; 가 지정된 경우이 메서드는 소켓을 반환하기 전에 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 시스템 속성의 값은 활성화 할 SSL / TLS 암호화 제품군의 쉼표로 구분 된 목록 인 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="85e125dd8fdc5133e26429f181bd79c7949497ac" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledProtocols&quot;&gt;javax.rmi.ssl.client.enabledProtocols&lt;/span&gt;&lt;/code&gt; is specified, the &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt;&lt;code&gt;createSocket(String,int)&lt;/code&gt;&lt;/a&gt; method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS protocol versions to enable.</source>
          <target state="translated">시스템 속성 &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledProtocols&quot;&gt;javax.rmi.ssl.client.enabledProtocols&lt;/span&gt;&lt;/code&gt; 가 지정된 경우 &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt; &lt;code&gt;createSocket(String,int)&lt;/code&gt; &lt;/a&gt; 메서드는 소켓을 반환하기 전에 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 시스템 속성의 값은 활성화 할 SSL / TLS 프로토콜 버전의 쉼표로 구분 된 목록 인 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="631a5d993700cbd8957a989d51b00a4545052b7d" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledProtocols-1&quot;&gt;javax.rmi.ssl.client.enabledProtocols&lt;/span&gt;&lt;/code&gt; is specified, this method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS protocol versions to enable.</source>
          <target state="translated">시스템 속성 &lt;code&gt;&lt;span id=&quot;javax.rmi.ssl.client.enabledProtocols-1&quot;&gt;javax.rmi.ssl.client.enabledProtocols&lt;/span&gt;&lt;/code&gt; 가 지정된 경우이 메서드는 소켓을 반환하기 전에 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 시스템 속성의 값은 활성화 할 SSL / TLS 프로토콜 버전의 쉼표로 구분 된 목록 인 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="eecf6f38d2140ba1e50010cc6e9645ed8e47e5a9" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;awt.dnd.drag.threshold&lt;/code&gt; is set to a positive integer, this method returns the value of the system property; otherwise if a pertinent desktop property is available and supported by the implementation of the Java platform, this method returns the value of that property; otherwise this method returns some default value. The pertinent desktop property can be queried using &lt;code&gt;java.awt.Toolkit.getDesktopProperty(&quot;DnD.gestureMotionThreshold&quot;)&lt;/code&gt;.</source>
          <target state="translated">시스템 속성 &lt;code&gt;awt.dnd.drag.threshold&lt;/code&gt; 가 양의 정수로 설정된 경우이 메서드는 시스템 속성의 값을 반환합니다. 그렇지 않으면 관련 데스크탑 속성이 사용 가능하고 Java 플랫폼 구현에서 지원되는 경우이 메서드는 해당 속성의 값을 반환합니다. 그렇지 않으면이 메서드는 일부 기본값을 반환합니다. 적절한 데스크톱 속성은 &lt;code&gt;java.awt.Toolkit.getDesktopProperty(&quot;DnD.gestureMotionThreshold&quot;)&lt;/code&gt; 를 사용하여 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="5504ea1f8b0b864e39c0da5d0938dff7d5fce0a6" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;awt.image.incrementaldraw&lt;/code&gt; is missing or has the value &lt;code&gt;true&lt;/code&gt;, the image is incrementally drawn. If the system property has any other value, then the image is not drawn until it has been completely loaded.</source>
          <target state="translated">시스템 속성 &lt;code&gt;awt.image.incrementaldraw&lt;/code&gt; 가 누락되었거나 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 이미지가 증분 적으로 그려집니다. 시스템 속성에 다른 값이 있으면 이미지가 완전히로드 될 때까지 그려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a82eebeff03c982f8a2c8e7b92fff81f4e06e38" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.nio.channels.spi.AsynchronousChannelProvider&lt;/code&gt; 가 정의되면 콘크리트 제공자 클래스의 완전한 이름으로 간주됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52c1afd219c316bf40da492c932d1f909b2e0fe8" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete provider class. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt; 가 정의되면 콘크리트 제공자 클래스의 완전한 이름으로 간주됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5093af58ccd31e98a4f37d4eff5d606412ea6ad9" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; is defined then it is taken to be a list of one or more fully-qualified names of concrete provider classes identified by the URI scheme &lt;code&gt;&quot;file&quot;&lt;/code&gt;. Where the property is a list of more than one name then the names are separated by a comma. Each class is loaded, using the system class loader, and instantiated by invoking a one argument constructor whose formal parameter type is &lt;code&gt;FileSystemProvider&lt;/code&gt;. The providers are loaded and instantiated in the order they are listed in the property. If this process fails or a provider's scheme is not equal to &lt;code&gt;&quot;file&quot;&lt;/code&gt; then an unspecified error is thrown. URI schemes are normally compared without regard to case but for the default provider, the scheme is required to be &lt;code&gt;&quot;file&quot;&lt;/code&gt;. The first provider class is instantiated by invoking it with a reference to the system-default provider. The second provider class is instantiated by invoking it with a reference to the first provider instance. The third provider class is instantiated by invoking it with a reference to the second instance, and so on. The last provider to be instantiated becomes the default provider; its &lt;code&gt;
 getFileSystem&lt;/code&gt; method is invoked with the URI &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; to get a reference to the default file system.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; 가 정의 된 경우 URI 스킴 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 로 식별되는 하나 이상의 완전한 제공자 클래스 이름 목록이 됩니다 . 속성이 둘 이상의 이름 목록 인 경우 이름은 쉼표로 구분됩니다. 각 클래스는 시스템 클래스 로더를 사용하여로드되고 형식 매개 변수 유형이 &lt;code&gt;FileSystemProvider&lt;/code&gt; 인 하나의 인수 생성자를 호출하여 인스턴스화됩니다 . 공급자는 속성에 나열된 순서대로로드되고 인스턴스화됩니다. 이 프로세스가 실패하거나 제공자의 계획이 다음과 같지 않은 경우 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 그러면 지정되지 않은 오류가 발생합니다. URI 체계는 일반적으로 대소 문자에 관계없이 비교되지만 기본 공급자의 경우 체계는 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 이어야 합니다 . 첫 번째 공급자 클래스는 시스템 기본 공급자에 대한 참조로 호출하여 인스턴스화됩니다. 두 번째 공급자 클래스는 첫 번째 공급자 인스턴스에 대한 참조를 사용하여 호출하여 인스턴스화됩니다. 세 번째 공급자 클래스는 두 번째 인스턴스에 대한 참조로 호출하여 인스턴스화됩니다. 인스턴스화 할 마지막 공급자가 기본 공급자가됩니다. 그 &lt;code&gt; getFileSystem&lt;/code&gt; 의 방법은 URI를 호출 &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; 기본 파일 시스템에 대한 참조를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3d062ab7060d9b3ee095375a8de4d829bd4225b" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; is defined then it is taken to be a list of one or more fully-qualified names of concrete provider classes identified by the URI scheme &lt;code&gt;&quot;file&quot;&lt;/code&gt;. Where the property is a list of more than one name then the names are separated by a comma. Each class is loaded, using the system class loader, and instantiated by invoking a one argument constructor whose formal parameter type is &lt;code&gt;FileSystemProvider&lt;/code&gt;. The providers are loaded and instantiated in the order they are listed in the property. If this process fails or a provider's scheme is not equal to &lt;code&gt;&quot;file&quot;&lt;/code&gt; then an unspecified error is thrown. URI schemes are normally compared without regard to case but for the default provider, the scheme is required to be &lt;code&gt;&quot;file&quot;&lt;/code&gt;. The first provider class is instantiated by invoking it with a reference to the system-default provider. The second provider class is instantiated by invoking it with a reference to the first provider instance. The third provider class is instantiated by invoking it with a reference to the second instance, and so on. The last provider to be instantiated becomes the default provider; its &lt;code&gt;getFileSystem&lt;/code&gt; method is invoked with the URI &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; to get a reference to the default file system.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.nio.file.spi.DefaultFileSystemProvider&lt;/code&gt; 인 가 정의 된 경우 URI 스킴 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 로 식별되는 구체적 제공자 클래스의 하나 이상의 완전한 이름 목록으로 간주 됩니다 . 특성이 둘 이상의 이름 목록 인 경우 이름은 쉼표로 구분됩니다. 각 클래스는 시스템 클래스 로더를 사용하여로드되며 형식 매개 변수 유형이 &lt;code&gt;FileSystemProvider&lt;/code&gt; 인 하나의 인수 생성자를 호출하여 인스턴스화됩니다 . 제공자는 속성에 나열된 순서대로로드 및 인스턴스화됩니다. 이 프로세스가 실패하거나 공급자의 체계가 같지 않은 경우 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 지정되지 않은 오류가 발생합니다. URI 스킴은 일반적으로 대소 문자와 상관없이 비교되지만 기본 제공자의 경우 스킴은 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 이어야 합니다 . 첫 번째 제공자 클래스는 시스템 기본 제공자에 대한 참조로 호출하여 인스턴스화됩니다. 두 번째 공급자 클래스는 첫 번째 공급자 인스턴스에 대한 참조로 호출하여 인스턴스화됩니다. 세 번째 공급자 클래스는 두 번째 인스턴스 등에 대한 참조로 호출하여 인스턴스화됩니다. 인스턴스화 할 마지막 공급자가 기본 공급자가됩니다. 그 &lt;code&gt;getFileSystem&lt;/code&gt; 의 방법은 URI를 호출 &lt;code&gt;&quot;file:///&quot;&lt;/code&gt; 기본 파일 시스템에 대한 참조를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46b65db3ac8212073211f72ace037edb568ab174" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.rmi.server.RMIClassLoaderSpi&lt;/code&gt; is defined, then if its value equals the string &lt;code&gt;&quot;default&quot;&lt;/code&gt;, the provider instance will be the value returned by an invocation of the &lt;a href=&quot;#getDefaultProviderInstance()&quot;&gt;&lt;code&gt;getDefaultProviderInstance()&lt;/code&gt;&lt;/a&gt; method, and for any other value, if a class named with the value of the property can be loaded by the system class loader (see &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt;&lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt;&lt;/a&gt;) and that class is assignable to &lt;a href=&quot;rmiclassloaderspi&quot;&gt;&lt;code&gt;RMIClassLoaderSpi&lt;/code&gt;&lt;/a&gt; and has a public no-argument constructor, then that constructor will be invoked to create the provider instance. If the property is defined but any other of those conditions are not true, then an unspecified &lt;code&gt;Error&lt;/code&gt; will be thrown to code that attempts to use &lt;code&gt;RMIClassLoader&lt;/code&gt;, indicating the failure to obtain a provider instance.</source>
          <target state="translated">시스템 속성 &lt;code&gt;java.rmi.server.RMIClassLoaderSpi&lt;/code&gt; 가 정의 된 경우 해당 값이 문자열 &lt;code&gt;&quot;default&quot;&lt;/code&gt; 와 같으면 공급자 인스턴스는 &lt;a href=&quot;#getDefaultProviderInstance()&quot;&gt; &lt;code&gt;getDefaultProviderInstance()&lt;/code&gt; &lt;/a&gt; 메서드 호출에 의해 반환 된 값이되고 다른 값의 경우 속성 값으로 명명 된 클래스는 시스템 클래스 로더 ( &lt;a href=&quot;../../../../java.base/java/lang/classloader#getSystemClassLoader()&quot;&gt; &lt;code&gt;ClassLoader.getSystemClassLoader()&lt;/code&gt; &lt;/a&gt; 참조)에 의해로드 될 수 있으며 해당 클래스는 &lt;a href=&quot;rmiclassloaderspi&quot;&gt; &lt;code&gt;RMIClassLoaderSpi&lt;/code&gt; 에&lt;/a&gt; 할당 할 수 있고 인수가없는 공용 생성자를 가지고 있습니다. 그러면 해당 생성자가 호출되어 공급자 인스턴스. 속성이 정의되었지만 다른 조건이 참이 아닌 경우 사용을 시도하는 코드에 지정되지 않은 &lt;code&gt;Error&lt;/code&gt; 가 발생합니다. &lt;code&gt;RMIClassLoader&lt;/code&gt; , 공급자 인스턴스를 가져 오지 못했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3f46166d5f46be810080dff80c8423bab7a1101a" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.rmi.server.randomIDs&lt;/code&gt; is defined to equal the string &lt;code&gt;&quot;true&quot;&lt;/code&gt; (case insensitive), then the &lt;a href=&quot;#%3Cinit%3E()&quot;&gt;&lt;code&gt;ObjID()&lt;/code&gt;&lt;/a&gt; constructor will use a cryptographically strong random number generator to choose the object number of the returned &lt;code&gt;ObjID&lt;/code&gt;.</source>
          <target state="translated">시스템 속성 &lt;code&gt;java.rmi.server.randomIDs&lt;/code&gt; 가 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; (대소 문자 구분 안 함)와 같도록 정의 된 경우 &lt;a href=&quot;#%3Cinit%3E()&quot;&gt; &lt;code&gt;ObjID()&lt;/code&gt; &lt;/a&gt; 생성자는 암호화 된 강력한 난수 생성기를 사용하여 반환 된 &lt;code&gt;ObjID&lt;/code&gt; 의 개체 번호를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="8d2fee9a69da418ea608c03885c80bf1ca4b886c" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.rmi.server.randomIDs&lt;/code&gt; is defined to equal the string &lt;code&gt;&quot;true&quot;&lt;/code&gt; (case insensitive), then this constructor will use a cryptographically strong random number generator to choose the object number of the returned &lt;code&gt;ObjID&lt;/code&gt;.</source>
          <target state="translated">시스템 속성 &lt;code&gt;java.rmi.server.randomIDs&lt;/code&gt; 가 문자열 &lt;code&gt;&quot;true&quot;&lt;/code&gt; (대소 문자 구분 안 함)와 같도록 정의 된 경우이 생성자는 암호화 된 강력한 난수 생성기를 사용하여 반환 된 &lt;code&gt;ObjID&lt;/code&gt; 의 개체 번호를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="dd24e048fc15e059868d56f4f568438df6b0caf5" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.util.jar.Pack200.Packer&lt;/code&gt; is defined, then the value is taken to be the fully-qualified name of a concrete implementation class, which must implement Packer. This class is loaded and instantiated. If this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 속성이 &lt;code&gt;java.util.jar.Pack200.Packer&lt;/code&gt; 가 정의 된 경우 값은 구체적인 구현 클래스의 완전한 이름으로 간주되며 Packer를 구현해야합니다. 이 클래스는로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="45a9607a9147c5f0b3360c97b95442bd171c997a" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.util.jar.Pack200.Unpacker&lt;/code&gt; is defined, then the value is taken to be the fully-qualified name of a concrete implementation class, which must implement Unpacker. The class is loaded and instantiated. If this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 프로퍼티 &lt;code&gt;java.util.jar.Pack200.Unpacker&lt;/code&gt; 인 경우 가 정의 된 경우 값은 Unpacker를 구현해야하는 구체적 구현 클래스의 완전한 이름이됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e75189cd7136093b1d6f408091c23d0de22eb446" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; is defined, then it is taken to be the fully-qualified name of a class implementing the &lt;code&gt;PreferencesFactory&lt;/code&gt; interface. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.</source>
          <target state="translated">시스템 특성 &lt;code&gt;java.util.prefs.PreferencesFactory&lt;/code&gt; 가 정의 된 경우 &lt;code&gt;PreferencesFactory&lt;/code&gt; 인터페이스를 구현하는 클래스의 완전한 이름으로 간주 됩니다. 클래스가로드되고 인스턴스화됩니다. 이 프로세스가 실패하면 지정되지 않은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a7e27f744d6efd52e983b8075a0c2febcea34f65" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.management.builder.initial&lt;/code&gt; is set, the platform &lt;code&gt;MBeanServer&lt;/code&gt; creation will be done by the specified &lt;a href=&quot;../../../javax/management/mbeanserverbuilder&quot;&gt;&lt;code&gt;MBeanServerBuilder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.management.builder.initial&lt;/code&gt; 이 설정되면, 플랫폼 &lt;code&gt;MBeanServer&lt;/code&gt; 작성은 지정된 &lt;a href=&quot;../../../javax/management/mbeanserverbuilder&quot;&gt; &lt;code&gt;MBeanServerBuilder&lt;/code&gt; 에&lt;/a&gt; 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d066e5cdc048829a2f626bea353ff4aba240c230" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; is specified, the &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt;&lt;code&gt;createSocket(String,int)&lt;/code&gt;&lt;/a&gt; method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS cipher suites to enable.</source>
          <target state="translated">시스템 속성 &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; 가 지정된 경우 &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt; &lt;code&gt;createSocket(String,int)&lt;/code&gt; &lt;/a&gt; 메서드는 소켓을 반환하기 전에 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 시스템 속성의 값은 활성화 할 SSL / TLS 암호화 제품군의 쉼표로 구분 된 목록 인 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="9cdd13fa82f3ac48193dd93680807e448f9971c6" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; is specified, this method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS cipher suites to enable.</source>
          <target state="translated">시스템 속성 &lt;code&gt;javax.rmi.ssl.client.enabledCipherSuites&lt;/code&gt; 가 지정된 경우이 메서드는 소켓을 반환하기 전에 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledCipherSuites(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledCipherSuites(String[])&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 시스템 속성의 값은 활성화 할 SSL / TLS 암호화 제품군의 쉼표로 구분 된 목록 인 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="e3beb140976a34dd92e43f005e5cdc896cbf0e59" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; is specified, the &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt;&lt;code&gt;createSocket(String,int)&lt;/code&gt;&lt;/a&gt; method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS protocol versions to enable.</source>
          <target state="translated">시스템 속성 &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; 가 지정된 경우 &lt;a href=&quot;#createSocket(java.lang.String,int)&quot;&gt; &lt;code&gt;createSocket(String,int)&lt;/code&gt; &lt;/a&gt; 메서드는 소켓을 반환하기 전에 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 시스템 속성의 값은 활성화 할 SSL / TLS 프로토콜 버전의 쉼표로 구분 된 목록 인 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="2c1710dbf416654c2b07f01e4c116984afd32006" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; is specified, this method will call &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt;&lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt;&lt;/a&gt; before returning the socket. The value of this system property is a string that is a comma-separated list of SSL/TLS protocol versions to enable.</source>
          <target state="translated">시스템 속성 &lt;code&gt;javax.rmi.ssl.client.enabledProtocols&lt;/code&gt; 가 지정된 경우이 메서드는 소켓을 반환하기 전에 &lt;a href=&quot;../../../../java.base/javax/net/ssl/sslsocket#setEnabledProtocols(java.lang.String%5B%5D)&quot;&gt; &lt;code&gt;SSLSocket.setEnabledProtocols(String[])&lt;/code&gt; &lt;/a&gt; 를 호출 합니다. 이 시스템 속성의 값은 활성화 할 SSL / TLS 프로토콜 버전의 쉼표로 구분 된 목록 인 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d37a20fcf5fe426fc5b5a1c3bcefbc944d6b8689" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the device that provides the default receiver. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 속성 &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; 가 정의되어 있거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 수신기를 제공하는 장치를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cde7239c70f83bff85e4440c46d6384691316ad" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the device that provides the default receiver. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;. If a suitable MIDI port is not available, the Receiver is retrieved from an installed synthesizer.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.midi.Receiver&lt;/code&gt; 가 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 수신자를 제공하는 장치를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 적합한 MIDI 포트를 사용할 수 없으면 설치된 신시사이저에서 수신기를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="91d3c314661dc26f163d797ffb58967de288f2ac" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Sequencer&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the default sequencer. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.midi.Sequencer&lt;/code&gt; 가 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 시퀀서를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00dcdd9d0bce1154db11492279afceeca3e08d7a" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Synthesizer&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the default synthesizer. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.midi.Synthesizer&lt;/code&gt; 가 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 신시사이저를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30df19d74bec068b077f43c95c9174eacf908696" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.midi.Transmitter&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to identify the device that provides the default transmitter. For details, refer to the &lt;a href=&quot;midisystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.midi.Transmitter&lt;/code&gt; 가 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 송신기를 제공하는 장치를 식별하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;midisystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2db720e9cdab4ebfc9f02a35fbd8f738bb2171b1" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to retrieve the default clip. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt; 이 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 클립을 검색하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="878cc5542428544d5bac13085b41e0430d054903" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to retrieve the default source data line. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; 이 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 소스 데이터 라인을 검색하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8d607cde38af381ba0dfdab64a53303e271b212" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; is defined or it is defined in the file &quot;sound.properties&quot;, it is used to retrieve the default target data line. For details, refer to the &lt;a href=&quot;audiosystem&quot;&gt;&lt;code&gt;class description&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시스템 특성 &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; 이 정의되었거나 &quot;sound.properties&quot;파일에 정의 된 경우 기본 대상 데이터 라인을 검색하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;audiosystem&quot;&gt; &lt;code&gt;class description&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d07239e369381a0fb6e04b89573dbf0f8758c57d" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;org.xml.sax.driver&lt;/code&gt; has a value, that is used as an XMLReader class name.</source>
          <target state="translated">시스템 속성 &lt;code&gt;org.xml.sax.driver&lt;/code&gt; 에 값이 있으면 XMLReader 클래스 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7eb7d836f2f43aa70bd878289c523ee9226c1901" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;suppressSwingDropSupport&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default) and the current drop target on this component is either &lt;code&gt;null&lt;/code&gt; or not a user-set drop target, this method will change the drop target as follows: If &lt;code&gt;newHandler&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; it will clear the drop target. If not &lt;code&gt;null&lt;/code&gt; it will install a new &lt;code&gt;DropTarget&lt;/code&gt;.</source>
          <target state="translated">시스템 속성 &lt;code&gt;suppressSwingDropSupport&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; (기본값)이고이 구성 요소의 현재 놓기 대상이 &lt;code&gt;null&lt;/code&gt; 이거나 사용자가 설정 한 놓기 대상이 아닌 경우이 메서드는 놓기 대상을 다음과 같이 변경합니다. &lt;code&gt;newHandler&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 삭제를 지 웁니다. 표적. 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 이 새로운 설치합니다 &lt;code&gt;DropTarget&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="d7708124db0ebabf9cd252ce976d692ad91505f5" translate="yes" xml:space="preserve">
          <source>If the system property &lt;code&gt;swing.defaultlaf&lt;/code&gt; is &lt;code&gt;non-null&lt;/code&gt;, use its value as the default look and feel class name.</source>
          <target state="translated">시스템 속성 &lt;code&gt;swing.defaultlaf&lt;/code&gt; 가 &lt;code&gt;non-null&lt;/code&gt; 이 아닌 경우 해당 값을 기본 룩앤필 클래스 이름으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8ff71830cbe5c28d3e3792ef57a69165cfffa083" translate="yes" xml:space="preserve">
          <source>If the system property is not set or the getInstance() call fails for any reason, the system defaults to an implementation specific default type and TerminalFactory.</source>
          <target state="translated">시스템 속성이 설정되지 않았거나 어떤 이유로 든 getInstance () 호출이 실패하면 시스템은 기본적으로 구현 특정 기본 유형과 TerminalFactory로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="de8593fcec2e6dbf96521d87b6c0f3273e22eb58" translate="yes" xml:space="preserve">
          <source>If the system property specified by &lt;a href=&quot;#DATATYPEFACTORY_PROPERTY&quot;&gt;&lt;code&gt;DATATYPEFACTORY_PROPERTY&lt;/code&gt;&lt;/a&gt;, &quot;&lt;code&gt;javax.xml.datatype.DatatypeFactory&lt;/code&gt;&quot;, exists, a class with the name of the property value is instantiated. Any Exception thrown during the instantiation process is wrapped as a &lt;a href=&quot;datatypeconfigurationexception&quot;&gt;&lt;code&gt;DatatypeConfigurationException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#DATATYPEFACTORY_PROPERTY&quot;&gt; &lt;code&gt;DATATYPEFACTORY_PROPERTY&lt;/code&gt; 로&lt;/a&gt; 지정된 시스템 속성 인 &quot; &lt;code&gt;javax.xml.datatype.DatatypeFactory&lt;/code&gt; &quot;가 존재하면 속성 값의 이름을 가진 클래스가 인스턴스화됩니다. 인스턴스화 프로세스 중에 발생한 모든 예외는 &lt;a href=&quot;datatypeconfigurationexception&quot;&gt; &lt;code&gt;DatatypeConfigurationException&lt;/code&gt; 으로&lt;/a&gt; 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="0de1cc0e4dda5fcc7e4aa252a0cbf64fbed0f628" translate="yes" xml:space="preserve">
          <source>If the target VM is disconnected during the invoke (for example, through &lt;a href=&quot;virtualmachine#dispose()&quot;&gt;&lt;code&gt;VirtualMachine.dispose()&lt;/code&gt;&lt;/a&gt;) the method invocation continues.</source>
          <target state="translated">호출 중에 대상 VM의 연결이 끊어지면 (예 : &lt;a href=&quot;virtualmachine#dispose()&quot;&gt; &lt;code&gt;VirtualMachine.dispose()&lt;/code&gt; &lt;/a&gt; 통해 ) 메서드 호출이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="8886f362ca8263086eee9b95c52f35ec0d45cf61" translate="yes" xml:space="preserve">
          <source>If the target VM terminates before the disconnection, this event will be preceded by a &lt;a href=&quot;vmdeathevent&quot;&gt;&lt;code&gt;VMDeathEvent&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결이 끊어지기 전에 대상 VM이 종료되면이 이벤트 앞에 &lt;a href=&quot;vmdeathevent&quot;&gt; &lt;code&gt;VMDeathEvent&lt;/code&gt; &lt;/a&gt; 가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6af05deaf58fe154a4b75ce321753672bae18f99" translate="yes" xml:space="preserve">
          <source>If the target file exists, then the target file is replaced if it is not a non-empty directory. If the target file exists and is a symbolic link, then the symbolic link itself, not the target of the link, is replaced.</source>
          <target state="translated">대상 파일이 존재하면 비어 있지 않은 디렉토리가 아닌 경우 대상 파일이 대체됩니다. 대상 파일이 존재하고 심볼릭 링크 인 경우 링크 대상이 아닌 심볼릭 링크 자체가 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="ac457e75b3f1b21e3f75382a66191d55b4a52e0f" translate="yes" xml:space="preserve">
          <source>If the target is _parent, then it deletes the parent element, which is a &amp;lt;FRAMESET&amp;gt; element, and inserts a new &amp;lt;FRAME&amp;gt; element, and sets its &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute to have a value equal to the destination URL and fire a &lt;code&gt;RemovedUpdate&lt;/code&gt; and &lt;code&gt;InsertUpdate&lt;/code&gt;.</source>
          <target state="translated">대상이 _parent 인 경우 &amp;lt;FRAMESET&amp;gt; 요소 인 상위 요소를 삭제하고 새 &amp;lt;FRAME&amp;gt; 요소를 삽입하고 &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; 속성을 대상 URL과 동일한 값으로 설정하고 실행합니다. &lt;code&gt;RemovedUpdate&lt;/code&gt; 및 &lt;code&gt;InsertUpdate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf1de5041cbc9489101a1efbb3aa93f8e3747f64" translate="yes" xml:space="preserve">
          <source>If the target is _top, this method does nothing. In the implementation of the view for a frame, namely the &lt;code&gt;FrameView&lt;/code&gt;, the processing of _top is handled. Given that _top implies replacing the entire document, it made sense to handle this outside of the document that it will replace.</source>
          <target state="translated">대상이 _top이면이 메서드는 아무 작업도 수행하지 않습니다. 프레임에 대한 뷰, 즉 &lt;code&gt;FrameView&lt;/code&gt; 구현 에서 _top 처리가 처리됩니다. _top이 전체 문서를 대체하는 것을 의미하므로 대체 할 문서 외부에서이를 처리하는 것이 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="05419b4ed8480b175c0a67be127a4f47601c6536" translate="yes" xml:space="preserve">
          <source>If the target is a named frame, then the element hierarchy is searched for an element with a name equal to the target, its &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; attribute is updated and a &lt;code&gt;ChangedUpdate&lt;/code&gt; event is fired.</source>
          <target state="translated">대상이 명명 된 프레임이면 요소 계층 구조에서 대상과 이름이 같은 요소를 검색하고 해당 &lt;code&gt;HTML.Attribute.SRC&lt;/code&gt; 속성이 업데이트되고 &lt;code&gt;ChangedUpdate&lt;/code&gt; 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3c180e88e82b133d4c219bf7bc995901410956a4" translate="yes" xml:space="preserve">
          <source>If the target method handle consumes no arguments besides than the result (if any) of the filter &lt;code&gt;coll&lt;/code&gt;, then &lt;code&gt;collectArguments(mh, 0, coll)&lt;/code&gt; is equivalent to &lt;code&gt;filterReturnValue(coll, mh)&lt;/code&gt;. If the filter method handle &lt;code&gt;coll&lt;/code&gt; consumes one argument and produces a non-void result, then &lt;code&gt;collectArguments(mh, N, coll)&lt;/code&gt; is equivalent to &lt;code&gt;filterArguments(mh, N, coll)&lt;/code&gt;. Other equivalences are possible but would require argument permutation.</source>
          <target state="translated">대상있어서 핸들 필터들 (있는 경우) 또한 결과보다 인수를 소모하지 않으면 &lt;code&gt;coll&lt;/code&gt; 후, &lt;code&gt;collectArguments(mh, 0, coll)&lt;/code&gt; 동등 &lt;code&gt;filterReturnValue(coll, mh)&lt;/code&gt; . 필터 메소드 핸들 &lt;code&gt;coll&lt;/code&gt; 이 하나의 인수를 사용하고 무효가 아닌 결과를 생성하는 경우 &lt;code&gt;collectArguments(mh, N, coll)&lt;/code&gt; 는 &lt;code&gt;filterArguments(mh, N, coll)&lt;/code&gt; . 다른 동등성도 가능하지만 인수 치환이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="458e499fec0b734951e6d53ad84671bd6e68d6c5" translate="yes" xml:space="preserve">
          <source>If the target method handle has variable arity, and the argument list is longer than that arity, the excess arguments, starting at the position of the trailing array argument, will be gathered (if possible, as if by &lt;code&gt;asType&lt;/code&gt; conversions) into an array of the appropriate type, and invocation will proceed on the shortened argument list. In this way, &lt;em&gt;jumbo argument lists&lt;/em&gt; which would spread into more than 254 slots can still be processed uniformly.</source>
          <target state="translated">대상 메서드 핸들에 가변 arity가 있고 인수 목록이 해당 arity보다 길면 후행 배열 인수의 위치에서 시작하는 초과 인수가 수집됩니다 (가능한 경우 &lt;code&gt;asType&lt;/code&gt; 변환에 의한 것처럼 ). 적절한 유형을 선택하면 단축 된 인수 목록에서 호출이 진행됩니다. 이러한 방식으로 254 개 이상의 슬롯으로 확산되는 &lt;em&gt;점보 인수 목록&lt;/em&gt; 은 여전히 ​​균일하게 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a6410dfb8cfd393874164170a840502005c25ad" translate="yes" xml:space="preserve">
          <source>If the target returns a value, the filter must accept that value as its only argument. If the target returns void, the filter must accept no arguments.</source>
          <target state="translated">대상이 값을 반환하면 필터는 해당 값을 유일한 인수로 허용해야합니다. 대상이 void를 반환하면 필터는 인수를 허용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="933efa6315f31837fd252efc9f236faa4bf2d497" translate="yes" xml:space="preserve">
          <source>If the target text component is specified as the source of the ActionEvent and there is a command string, the command string will be interpreted as an integer that should be one of the legal values for the &lt;code&gt;StyleConstants.Alignment&lt;/code&gt; attribute.</source>
          <target state="translated">대상 텍스트 구성 요소가 ActionEvent의 소스로 지정되고 명령 문자열이있는 경우 명령 문자열은 &lt;code&gt;StyleConstants.Alignment&lt;/code&gt; 속성 의 유효한 값 중 하나 여야하는 정수로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad7689e60ae1c9939383833d9772f90e200fa26d" translate="yes" xml:space="preserve">
          <source>If the target text component is specified as the source of the ActionEvent and there is a command string, the command string will be interpreted as the foreground color. It will be interpreted by called &lt;code&gt;Color.decode&lt;/code&gt;, and should therefore be legal input for that method.</source>
          <target state="translated">대상 텍스트 구성 요소가 ActionEvent의 소스로 지정되고 명령 문자열이있는 경우 명령 문자열은 전경색으로 해석됩니다. 이것은 &lt;code&gt;Color.decode&lt;/code&gt; 라는 이름으로 해석 되므로 해당 메서드에 대한 올바른 입력이어야합니다.</target>
        </trans-unit>
        <trans-unit id="60ff5ddff7c5d899dfe402e4472a1b9b2a332d25" translate="yes" xml:space="preserve">
          <source>If the temporal object does not contain a date, but does contain one or more &lt;code&gt;ChronoField&lt;/code&gt; date fields, then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown. In all other cases, the override chronology is added to the temporal, replacing any previous chronology, but without changing the date/time.</source>
          <target state="translated">임시 개체에 날짜가 포함되어 있지 않지만 &lt;code&gt;ChronoField&lt;/code&gt; 날짜 필드 가 하나 이상 포함 된 경우 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다. 다른 모든 경우에는 날짜 / 시간을 변경하지 않고 재정의 연대기를 시간에 추가하여 이전 연대기를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="dd85e14ed75c47c84beea3f122d891fc9308e690" translate="yes" xml:space="preserve">
          <source>If the temporal object does not contain an instant, but does contain an offset then an additional check is made. If the normalized override zone is an offset that differs from the offset of the temporal, then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown. In all other cases, the override zone is added to the temporal, replacing any previous zone, but without changing the date/time.</source>
          <target state="translated">임시 객체에 순간이 포함되어 있지 않지만 오프셋이 포함되어 있으면 추가 검사가 수행됩니다. 정규화 된 재정의 영역이 시간의 오프셋과 다른 오프셋 인 경우 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다. 다른 모든 경우에는 재정의 영역이 시간에 추가되어 이전 영역을 대체하지만 날짜 / 시간을 변경하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c09abaae8508d70028ba67cefa61277b54360a6" translate="yes" xml:space="preserve">
          <source>If the thread argument is a system thread (belongs to the thread group with a &lt;code&gt;null&lt;/code&gt; parent) then this method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; permission. If the thread argument is</source>
          <target state="translated">스레드 인수가 시스템 스레드 인 경우 ( 부모 가 &lt;code&gt;null&lt;/code&gt; 인 스레드 그룹에 속함 )이 메소드 는 &lt;code&gt;RuntimePermission(&quot;modifyThread&quot;)&lt;/code&gt; 와 함께 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다. 권한으로 . 스레드 인수가</target>
        </trans-unit>
        <trans-unit id="956a4caf473783d2c99b96d529421cc001582508" translate="yes" xml:space="preserve">
          <source>If the thread group argument is the system thread group ( has a &lt;code&gt;null&lt;/code&gt; parent) then this method calls &lt;code&gt;checkPermission&lt;/code&gt; with the &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; permission. If the thread group argument is</source>
          <target state="translated">스레드 그룹 인수가 시스템 스레드 그룹 인 경우 ( 부모 가 &lt;code&gt;null&lt;/code&gt; 인 경우)이 메소드 는 &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; 권한으로 &lt;code&gt;checkPermission&lt;/code&gt; 을 호출합니다 . 스레드 그룹 인수가</target>
        </trans-unit>
        <trans-unit id="2851f30724641ecca099288cb8621aaa00615fd6" translate="yes" xml:space="preserve">
          <source>If the thread is alive but suspended, it is resumed and is permitted to make progress in its execution.</source>
          <target state="translated">스레드가 활성 상태이지만 일시 중단 된 경우 스레드가 재개되고 실행 진행이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a8d129983d6e8dc28983c9eb2cd579ed898cf687" translate="yes" xml:space="preserve">
          <source>If the thread is alive, it is suspended and makes no further progress unless and until it is resumed.</source>
          <target state="translated">스레드가 활성 상태 인 경우 스레드가 일시 중단되고 다시 시작하지 않는 한 계속 진행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95f23b0ab1d9ecd54f0d7d1cfdcbc8a705f2c602" translate="yes" xml:space="preserve">
          <source>If the thread of the specified ID is not alive or does not exist, this method returns &lt;code&gt;-1&lt;/code&gt;. If CPU time measurement is disabled, this method returns &lt;code&gt;-1&lt;/code&gt;. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">지정된 ID의 스레드가 존재하지 않거나 존재하지 않으면이 메소드는 &lt;code&gt;-1&lt;/code&gt; 을 리턴합니다 . CPU 시간 측정이 비활성화 된 경우이 방법은 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다. . 스레드가 시작되어 아직 죽지 않은 경우 스레드가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="2f1597e2b1b784b5b3de28848e78b8e4d92ff74b" translate="yes" xml:space="preserve">
          <source>If the thread with the specified ID is not alive or does not exist, this method returns &lt;code&gt;-1&lt;/code&gt;. If thread memory allocation measurement is disabled, this method returns &lt;code&gt;-1&lt;/code&gt;. A thread is alive if it has been started and has not yet died.</source>
          <target state="translated">지정된 ID를 가진 스레드가 살아 있지 않거나 존재하지 않는 경우이 메서드는 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 . 스레드 메모리 할당 측정이 비활성화 된 경우이 메서드는 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 . 스레드가 시작되었지만 아직 죽지 않았다면 살아있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="97aef73764a8b235d11df488cc792228726de005" translate="yes" xml:space="preserve">
          <source>If the time '23:59:60' is received, then a simple conversion is applied, replacing the second-of-minute of 60 with 59. This query can be used on the parse result to determine if the leap-second adjustment was made. The query will return &lt;code&gt;true&lt;/code&gt; if it did adjust to remove the leap-second, and &lt;code&gt;false&lt;/code&gt; if not. Note that applying a leap-second smoothing mechanism, such as UTC-SLS, is the responsibility of the application, as follows:</source>
          <target state="translated">'23 : 59 : 60 '시간이 수신되면 간단한 변환이 적용되어 분의 초를 60으로 59로 바꿉니다.이 쿼리는 구문 분석 결과에 사용되어 윤초 조정이 만든. 쿼리는 윤초를 제거하도록 조정 한 경우 &lt;code&gt;true&lt;/code&gt; 를 반환하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다. UTC-SLS와 같은 윤초 평활 메커니즘을 적용하는 것은 다음과 같이 응용 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="6ae6878cfd3b1d0ceb5a94fe0301dc8e364dcc4f" translate="yes" xml:space="preserve">
          <source>If the timeout limit is set to 't' seconds, a session exceeds the timeout limit 't' seconds after its creation time. When the timeout limit is exceeded for a session, the &lt;code&gt;SSLSession&lt;/code&gt; object is invalidated and future connections cannot resume or rejoin the session. A check for sessions exceeding the timeout is made immediately whenever the timeout limit is changed for this &lt;code&gt;SSLSessionContext&lt;/code&gt;.</source>
          <target state="translated">시간 초과 한계가 't'초로 설정되면, 세션은 작성 시간 후 시간 초과 한계 't'초를 초과합니다. 세션에 대한 시간 종료 제한이 초과되면 &lt;code&gt;SSLSession&lt;/code&gt; 오브젝트가 무효화되고 이후 연결에서 세션을 재개하거나 다시 참여할 수 없습니다. 이 &lt;code&gt;SSLSessionContext&lt;/code&gt; 의 제한 시간이 변경 될 때마다 제한 시간을 초과하는 세션을 점검합니다 .</target>
        </trans-unit>
        <trans-unit id="ad1adddf8356c433278ef7cd10d12a5f2bd6c761" translate="yes" xml:space="preserve">
          <source>If the timeout limit is set to 't' seconds, a session exceeds the timeout limit 't' seconds after its creation time. When the timeout limit is exceeded for a session, the &lt;code&gt;SSLSession&lt;/code&gt; object is invalidated and future connections cannot resume or rejoin the session. A check for sessions exceeding the timeout limit is made immediately whenever the timeout limit is changed for this &lt;code&gt;SSLSessionContext&lt;/code&gt;.</source>
          <target state="translated">시간 초과 한계가 't'초로 설정되면, 세션은 작성 시간 후 시간 초과 한계 't'초를 초과합니다. 세션에 대한 시간 종료 한계가 초과되면 &lt;code&gt;SSLSession&lt;/code&gt; 오브젝트가 무효화되고 이후 연결에서 세션을 재개하거나 다시 참여할 수 없습니다. 이 &lt;code&gt;SSLSessionContext&lt;/code&gt; 에 대해 시간 종료 한계가 변경 될 때마다 시간 종료 한계를 초과하는 세션이 즉시 점검됩니다 .</target>
        </trans-unit>
        <trans-unit id="44775d676f01ccf28f57333e6fb89f1c12f0cfd6" translate="yes" xml:space="preserve">
          <source>If the timer notification to be inserted has a date that is before the current date, the method behaves as if the specified date were the current date and the notification is delivered immediately.</source>
          <target state="translated">삽입 할 타이머 알림에 현재 날짜 이전의 날짜가 있으면 지정된 날짜가 현재 날짜 인 것처럼 동작하며 알림이 즉시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8056b6ccedf3aca7fb9d63268e271ee88e090cd9" translate="yes" xml:space="preserve">
          <source>If the timer notification to be inserted has a date that is before the current date, the method behaves as if the specified date were the current date.</source>
          <target state="translated">삽입 할 타이머 알림에 현재 날짜 이전의 날짜가 있으면 지정된 날짜가 현재 날짜 인 것처럼 메서드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f7ed1fef67b3c31fe3734b8ae38aa892bb880b72" translate="yes" xml:space="preserve">
          <source>If the timer notification to be inserted has a date that is before the current date, the method behaves as if the specified date were the current date. The first notification is delivered immediately and the subsequent ones are spaced as specified by the period parameter.</source>
          <target state="translated">삽입 할 타이머 알림에 현재 날짜 이전의 날짜가 있으면 지정된 날짜가 현재 날짜 인 것처럼 메서드가 작동합니다. 첫 번째 알림은 즉시 전달되고 후속 알림은 period 매개 변수에 지정된 간격으로 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="38b2e2e16267baf4e1e54405bd70137ca888e8ed" translate="yes" xml:space="preserve">
          <source>If the timer's task execution thread terminates unexpectedly, for example, because its &lt;code&gt;stop&lt;/code&gt; method is invoked, any further attempt to schedule a task on the timer will result in an &lt;code&gt;IllegalStateException&lt;/code&gt;, as if the timer's &lt;code&gt;cancel&lt;/code&gt; method had been invoked.</source>
          <target state="translated">예를 들어, &lt;code&gt;stop&lt;/code&gt; 메소드가 호출 되어 타이머의 태스크 실행 스레드가 예기치 않게 종료되면 타이머에서 태스크 를 스케줄하려고 하면 타이머의 &lt;code&gt;cancel&lt;/code&gt; 메소드가 호출 된 것처럼 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac3591693d15d3e4209a0731ba617c073e32bb40" translate="yes" xml:space="preserve">
          <source>If the transformer throws an exception (which it doesn't catch), subsequent transformers will still be called and the load, redefine or retransform will still be attempted. Thus, throwing an exception has the same effect as returning &lt;code&gt;null&lt;/code&gt;. To prevent unexpected behavior when unchecked exceptions are generated in transformer code, a transformer can catch &lt;code&gt;Throwable&lt;/code&gt;. If the transformer believes the &lt;code&gt;classFileBuffer&lt;/code&gt; does not represent a validly formatted class file, it should throw an &lt;code&gt;IllegalClassFormatException&lt;/code&gt;; while this has the same effect as returning null. it facilitates the logging or debugging of format corruptions.</source>
          <target state="translated">변압기에 예외가 발생하더라도 (포착되지 않는) 후속 변압기가 계속 호출되고로드, 재정의 또는 재 변환이 계속 시도됩니다. 따라서 예외를 throw하면 &lt;code&gt;null&lt;/code&gt; 을 반환하는 것과 같은 효과가 있습니다. 확인되지 않은 예외가 변환기 코드에서 생성 될 때 예기치 않은 동작을 방지하기 위해 변환기는 &lt;code&gt;Throwable&lt;/code&gt; 을 포착 할 수 있습니다 . 변환기가 &lt;code&gt;classFileBuffer&lt;/code&gt; 가 올바른 형식의 클래스 파일을 나타내지 않는다고 생각 하면 &lt;code&gt;IllegalClassFormatException&lt;/code&gt; 을 발생 시켜야합니다. . null을 반환하는 것과 같은 효과가 있습니다. 형식 손상의 로깅 또는 디버깅을 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="b2202f39f213e519d8a6a914b9451df18b3b6cd6" translate="yes" xml:space="preserve">
          <source>If the traversal key has not been explicitly set for this Window, then this Window's parent's traversal key is returned. If the traversal key has not been explicitly set for any of this Window's ancestors, then the current KeyboardFocusManager's default traversal key is returned.</source>
          <target state="translated">순회 키가이 Window에 대해 명시 적으로 설정되지 않은 경우,이 Window의 부모 순회 키가 반환됩니다. 이 Window의 조상에 대해 순회 키가 명시 적으로 설정되지 않은 경우 현재 KeyboardFocusManager의 기본 순회 키가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="10849c037dd8bc1c2fc1c741b858e266697ece21" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements of type &lt;code&gt;T&lt;/code&gt; at an index &lt;code&gt;i&lt;/code&gt; within the respective arrays that is the prefix length, as if by:</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 다음과 같이 접두사 길이 인 각 배열 내의 인덱스 &lt;code&gt;i&lt;/code&gt; 에서 유형 &lt;code&gt;T&lt;/code&gt; 의 두 요소를 비교 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="b155792f2e510e17ec8d253fc3a0fb59ca79f8dd" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/boolean#compare(boolean,boolean)&quot;&gt;&lt;code&gt;Boolean.compare(boolean, boolean)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(boolean%5B%5D,boolean%5B%5D)&quot;&gt;&lt;code&gt;mismatch(boolean[], boolean[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/boolean#compare(boolean,boolean)&quot;&gt; &lt;code&gt;Boolean.compare(boolean, boolean)&lt;/code&gt; &lt;/a&gt; 에서처럼 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( &lt;a href=&quot;#mismatch(boolean%5B%5D,boolean%5B%5D)&quot;&gt; &lt;code&gt;mismatch(boolean[], boolean[])&lt;/code&gt; &lt;/a&gt; 일반적이고 적절한 접두사의 정의는 를 .)</target>
        </trans-unit>
        <trans-unit id="57243fdb8f978c78fb76c986d30f96d7bf6d4774" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/byte#compare(byte,byte)&quot;&gt;&lt;code&gt;Byte.compare(byte, byte)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(byte%5B%5D,byte%5B%5D)&quot;&gt;&lt;code&gt;mismatch(byte[], byte[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/byte#compare(byte,byte)&quot;&gt; &lt;code&gt;Byte.compare(byte, byte)&lt;/code&gt; &lt;/a&gt; 와 같이 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(byte%5B%5D,byte%5B%5D)&quot;&gt; &lt;code&gt;mismatch(byte[], byte[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="efbf4a94c94fc3222d7e00ab8ab0707b70f1d4e9" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/byte#compareUnsigned(byte,byte)&quot;&gt;&lt;code&gt;Byte.compareUnsigned(byte, byte)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(byte%5B%5D,byte%5B%5D)&quot;&gt;&lt;code&gt;mismatch(byte[], byte[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/byte#compareUnsigned(byte,byte)&quot;&gt; &lt;code&gt;Byte.compareUnsigned(byte, byte)&lt;/code&gt; &lt;/a&gt; 와 같이 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(byte%5B%5D,byte%5B%5D)&quot;&gt; &lt;code&gt;mismatch(byte[], byte[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="4e8abaf672daa90f27c4a28744cf3bffbed58f1b" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/character#compare(char,char)&quot;&gt;&lt;code&gt;Character.compare(char, char)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(char%5B%5D,char%5B%5D)&quot;&gt;&lt;code&gt;mismatch(char[], char[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 마치 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/character#compare(char,char)&quot;&gt; &lt;code&gt;Character.compare(char, char)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(char%5B%5D,char%5B%5D)&quot;&gt; &lt;code&gt;mismatch(char[], char[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a1fa6e3b313e74e85610c3d66b8ff693e012d72d" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/double#compare(double,double)&quot;&gt;&lt;code&gt;Double.compare(double, double)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(double%5B%5D,double%5B%5D)&quot;&gt;&lt;code&gt;mismatch(double[], double[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/double#compare(double,double)&quot;&gt; &lt;code&gt;Double.compare(double, double)&lt;/code&gt; &lt;/a&gt; 에서처럼 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(double%5B%5D,double%5B%5D)&quot;&gt; &lt;code&gt;mismatch(double[], double[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="1c4f63f453b8509aa4d20ab07035dc58ee1cb446" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/float#compare(float,float)&quot;&gt;&lt;code&gt;Float.compare(float, float)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(float%5B%5D,float%5B%5D)&quot;&gt;&lt;code&gt;mismatch(float[], float[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/float#compare(float,float)&quot;&gt; &lt;code&gt;Float.compare(float, float)&lt;/code&gt; &lt;/a&gt; 와 같이 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(float%5B%5D,float%5B%5D)&quot;&gt; &lt;code&gt;mismatch(float[], float[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="3a6dc406fb7fd94c09e0c48b3ba97eeaadc82d2f" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/integer#compare(int,int)&quot;&gt;&lt;code&gt;Integer.compare(int, int)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(int%5B%5D,int%5B%5D)&quot;&gt;&lt;code&gt;mismatch(int[], int[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/integer#compare(int,int)&quot;&gt; &lt;code&gt;Integer.compare(int, int)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(int%5B%5D,int%5B%5D)&quot;&gt; &lt;code&gt;mismatch(int[], int[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="f49296e451be67acc72ebac21d6d5d2ab335c399" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/integer#compareUnsigned(int,int)&quot;&gt;&lt;code&gt;Integer.compareUnsigned(int, int)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(int%5B%5D,int%5B%5D)&quot;&gt;&lt;code&gt;mismatch(int[], int[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/integer#compareUnsigned(int,int)&quot;&gt; &lt;code&gt;Integer.compareUnsigned(int, int)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(int%5B%5D,int%5B%5D)&quot;&gt; &lt;code&gt;mismatch(int[], int[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="b63db0f74eabd287280b9ce88e153dd64850efd0" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/long#compare(long,long)&quot;&gt;&lt;code&gt;Long.compare(long, long)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(long%5B%5D,long%5B%5D)&quot;&gt;&lt;code&gt;mismatch(long[], long[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/long#compare(long,long)&quot;&gt; &lt;code&gt;Long.compare(long, long)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(long%5B%5D,long%5B%5D)&quot;&gt; &lt;code&gt;mismatch(long[], long[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="1bcb7cd8bec0f1fcffe21770a5583ac7e1aa23a1" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/long#compareUnsigned(long,long)&quot;&gt;&lt;code&gt;Long.compareUnsigned(long, long)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(long%5B%5D,long%5B%5D)&quot;&gt;&lt;code&gt;mismatch(long[], long[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/long#compareUnsigned(long,long)&quot;&gt; &lt;code&gt;Long.compareUnsigned(long, long)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(long%5B%5D,long%5B%5D)&quot;&gt; &lt;code&gt;mismatch(long[], long[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="3d148b2dafd16e299cfcc608fd7bc9a2b486aed0" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/short#compare(short,short)&quot;&gt;&lt;code&gt;Short.compare(short, short)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(short%5B%5D,short%5B%5D)&quot;&gt;&lt;code&gt;mismatch(short[], short[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/short#compare(short,short)&quot;&gt; &lt;code&gt;Short.compare(short, short)&lt;/code&gt; &lt;/a&gt; 와 같이 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(short%5B%5D,short%5B%5D)&quot;&gt; &lt;code&gt;mismatch(short[], short[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="10bcf2ff1ce53653290b9af98721a6b69481041d" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/short#compareUnsigned(short,short)&quot;&gt;&lt;code&gt;Short.compareUnsigned(short, short)&lt;/code&gt;&lt;/a&gt;, at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(short%5B%5D,short%5B%5D)&quot;&gt;&lt;code&gt;mismatch(short[], short[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 &lt;a href=&quot;../lang/short#compareUnsigned(short,short)&quot;&gt; &lt;code&gt;Short.compareUnsigned(short, short)&lt;/code&gt; &lt;/a&gt; 와 같이 두 요소를 비교 한 결과입니다 . 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(short%5B%5D,short%5B%5D)&quot;&gt; &lt;code&gt;mismatch(short[], short[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="9b48c79397e666c5c9e58c00b0300c3f32625780" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the lexicographic comparison is the result of comparing with the specified comparator two elements at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See &lt;a href=&quot;#mismatch(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt;&lt;code&gt;mismatch(Object[], Object[])&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 인덱스에서 지정된 비교 자와 두 요소를 비교 한 결과입니다. 그렇지 않으면 한 어레이가 다른 어레이의 적절한 접두어이고 사전 식 비교는 두 어레이 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(java.lang.Object%5B%5D,java.lang.Object%5B%5D)&quot;&gt; &lt;code&gt;mismatch(Object[], Object[])&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="751f847fc7eff31ed05d5e61dc95a845161d2ad3" translate="yes" xml:space="preserve">
          <source>If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch.</source>
          <target state="translated">두 배열이 공통 접두사를 공유하는 경우 반환 된 색인은 공통 접두사의 길이이며 각 배열 내에서 해당 색인의 두 요소간에 불일치가 발생합니다. 한 배열이 다른 배열의 적절한 접두사 인 경우 반환 된 인덱스는 더 작은 배열의 길이이며 인덱스는 더 큰 배열에 대해서만 유효합니다. 그렇지 않으면 불일치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e2839946586ddeda4b1002deade56dce2c14f22" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements of type &lt;code&gt;T&lt;/code&gt; at a relative index &lt;code&gt;i&lt;/code&gt; within the respective arrays that is the prefix length, as if by:</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 다음과 같이 접두사 길이 인 각 배열 내 상대 색인 &lt;code&gt;i&lt;/code&gt; 에서 유형 &lt;code&gt;T&lt;/code&gt; 의 두 요소를 비교 한 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="f3f948cd0dc8d1832d6c7cda8991ab71dcb99b17" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/boolean#compare(boolean,boolean)&quot;&gt;&lt;code&gt;Boolean.compare(boolean, boolean)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(boolean%5B%5D,int,int,boolean%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(boolean[], int, int, boolean[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 색인에서 &lt;a href=&quot;../lang/boolean#compare(boolean,boolean)&quot;&gt; &lt;code&gt;Boolean.compare(boolean, boolean)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(boolean%5B%5D,int,int,boolean%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(boolean[], int, int, boolean[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="a6e94f75faa2282739b4f3b904d2d252589549dd" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/byte#compare(byte,byte)&quot;&gt;&lt;code&gt;Byte.compare(byte, byte)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(byte[], int, int, byte[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 인덱스에서 &lt;a href=&quot;../lang/byte#compare(byte,byte)&quot;&gt; &lt;code&gt;Byte.compare(byte, byte)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(byte[], int, int, byte[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="d99ad3f23655df7e4fbd277c7e8afb3093422df6" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/byte#compareUnsigned(byte,byte)&quot;&gt;&lt;code&gt;Byte.compareUnsigned(byte, byte)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(byte[], int, int, byte[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 인덱스에서 &lt;a href=&quot;../lang/byte#compareUnsigned(byte,byte)&quot;&gt; &lt;code&gt;Byte.compareUnsigned(byte, byte)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(byte%5B%5D,int,int,byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(byte[], int, int, byte[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="689546c82dfde445df7cb6060f65882dc0abca33" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/character#compare(char,char)&quot;&gt;&lt;code&gt;Character.compare(char, char)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(char%5B%5D,int,int,char%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(char[], int, int, char[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 색인에서 &lt;a href=&quot;../lang/character#compare(char,char)&quot;&gt; &lt;code&gt;Character.compare(char, char)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(char%5B%5D,int,int,char%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(char[], int, int, char[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="33f0cf3594f25f4cb36a42269d56adb60385fdc6" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/double#compare(double,double)&quot;&gt;&lt;code&gt;Double.compare(double, double)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(double%5B%5D,int,int,double%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(double[], int, int, double[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 색인에서 &lt;a href=&quot;../lang/double#compare(double,double)&quot;&gt; &lt;code&gt;Double.compare(double, double)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(double%5B%5D,int,int,double%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(double[], int, int, double[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="96dc20aff5dbee21053cf86a2f97932e6e113e17" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/float#compare(float,float)&quot;&gt;&lt;code&gt;Float.compare(float, float)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(float%5B%5D,int,int,float%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(float[], int, int, float[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 색인에서 &lt;a href=&quot;../lang/float#compare(float,float)&quot;&gt; &lt;code&gt;Float.compare(float, float)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(float%5B%5D,int,int,float%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(float[], int, int, float[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="efb772271b892ca76f0e7c60394b0c3288a55976" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/integer#compare(int,int)&quot;&gt;&lt;code&gt;Integer.compare(int, int)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(int[], int, int, int[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 인덱스에서 &lt;a href=&quot;../lang/integer#compare(int,int)&quot;&gt; &lt;code&gt;Integer.compare(int, int)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(int[], int, int, int[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="fc1abfae5f6bec827afbe78092dd5076cbb73043" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/integer#compareUnsigned(int,int)&quot;&gt;&lt;code&gt;Integer.compareUnsigned(int, int)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(int[], int, int, int[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 인덱스에서 &lt;a href=&quot;../lang/integer#compareUnsigned(int,int)&quot;&gt; &lt;code&gt;Integer.compareUnsigned(int, int)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(int%5B%5D,int,int,int%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(int[], int, int, int[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="3f390c1a0173f067f002963d99ec1e933697624f" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/long#compare(long,long)&quot;&gt;&lt;code&gt;Long.compare(long, long)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(long[], int, int, long[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에 걸쳐 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 색인에서 &lt;a href=&quot;../lang/long#compare(long,long)&quot;&gt; &lt;code&gt;Long.compare(long, long)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(long[], int, int, long[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="acdbd4d409077318826faeff1066f127d79d2e03" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/long#compareUnsigned(long,long)&quot;&gt;&lt;code&gt;Long.compareUnsigned(long, long)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(long[], int, int, long[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 길이 인 각 배열 내의 상대 인덱스에서 &lt;a href=&quot;../lang/long#compareUnsigned(long,long)&quot;&gt; &lt;code&gt;Long.compareUnsigned(long, long)&lt;/code&gt; &lt;/a&gt; 의해 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(long%5B%5D,int,int,long%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(long[], int, int, long[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="165852849eadb60efdc65ee7e29e23a132211a7c" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/short#compare(short,short)&quot;&gt;&lt;code&gt;Short.compare(short, short)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(short[], int, int, short[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 &lt;a href=&quot;../lang/short#compare(short,short)&quot;&gt; &lt;code&gt;Short.compare(short, short)&lt;/code&gt; &lt;/a&gt; 길이 인 각 배열 내의 상대 색인에서 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(short[], int, int, short[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="92a13ef6017334f61c5516d921592620158e34a6" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by &lt;a href=&quot;../lang/short#compareUnsigned(short,short)&quot;&gt;&lt;code&gt;Short.compareUnsigned(short, short)&lt;/code&gt;&lt;/a&gt;, at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(short[], int, int, short[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">지정된 범위에서 두 배열이 공통 접두사를 공유하는 경우 사전 식 비교는 마치 &lt;a href=&quot;../lang/short#compareUnsigned(short,short)&quot;&gt; &lt;code&gt;Short.compareUnsigned(short, short)&lt;/code&gt; &lt;/a&gt; 가 길이 인 각 배열 내의 상대 색인에서 두 요소를 비교 한 결과입니다. 접두사의. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(short%5B%5D,int,int,short%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(short[], int, int, short[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="0adc08ed767ba5fcac736354cc12489898dcbc7c" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing with the specified comparator two elements at a relative index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See &lt;a href=&quot;#mismatch(java.lang.Object%5B%5D,int,int,java.lang.Object%5B%5D,int,int)&quot;&gt;&lt;code&gt;mismatch(Object[], int, int, Object[], int, int)&lt;/code&gt;&lt;/a&gt; for the definition of a common and proper prefix.)</source>
          <target state="translated">두 배열이 지정된 범위에 걸쳐 공통 접두사를 공유하는 경우 사전 식 비교는 접두사 길이 인 각 배열 내의 상대 색인에서 지정된 비교 자와 두 요소를 비교 한 결과입니다. 그렇지 않으면 한 배열이 다른 배열의 적절한 접두어이고 사전 식 비교는 두 범위 길이를 비교 한 결과입니다. ( 일반적이고 적절한 접두사의 정의는 &lt;a href=&quot;#mismatch(java.lang.Object%5B%5D,int,int,java.lang.Object%5B%5D,int,int)&quot;&gt; &lt;code&gt;mismatch(Object[], int, int, Object[], int, int)&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="de179b6b61556777afe0f0139dc8277c77218327" translate="yes" xml:space="preserve">
          <source>If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch.</source>
          <target state="translated">지정된 범위에 걸쳐 두 배열이 공통 접두사를 공유하는 경우 반환 된 상대 색인은 공통 접두사의 길이이며 각 배열 내 해당 상대 색인의 두 요소간에 불일치가 발생합니다. 한 배열이 지정된 범위에서 다른 배열의 적절한 접두사 인 경우 반환 된 상대 인덱스는 더 작은 범위의 길이이며 상대 인덱스는 더 큰 범위의 배열에만 유효합니다. 그렇지 않으면 불일치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3ff68f92a851855ba68fbc7ed3f7e692a3962b65" translate="yes" xml:space="preserve">
          <source>If the two buffers share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two buffers at that index within the respective buffers. If one buffer is a proper prefix of the other then the returned index is the smaller of the remaining elements in each buffer, and it follows that the index is only valid for the buffer with the larger number of remaining elements. Otherwise, there is no mismatch.</source>
          <target state="translated">두 버퍼가 공통 접두사를 공유하는 경우 반환 된 인덱스는 공통 접두사의 길이이며 각 버퍼 내 해당 인덱스의 두 버퍼간에 불일치가 발생합니다. 한 버퍼가 다른 버퍼의 적절한 접두사 인 경우 반환 된 인덱스는 각 버퍼의 나머지 요소 중 더 작으며 나머지 요소 수가 많은 버퍼에 대해서만 인덱스가 유효합니다. 그렇지 않으면 불일치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="051c9daf6b939af50cb443665c610f27abeb1722" translate="yes" xml:space="preserve">
          <source>If the two interfaces are mixed (including serialization), Unicode range values are mapped to their counterparts where such mapping is possible, such as &lt;code&gt;NumericShaper.Range.ARABIC&lt;/code&gt; from/to &lt;code&gt;NumericShaper.ARABIC&lt;/code&gt;. If any unmappable range values are specified, such as &lt;code&gt;NumericShaper.Range.BALINESE&lt;/code&gt;, those ranges are ignored.</source>
          <target state="translated">두 인터페이스가 혼합 된 경우 (직렬화 포함) 유니 코드 범위 값은 &lt;code&gt;NumericShaper.Range.ARABIC&lt;/code&gt; from / to &lt;code&gt;NumericShaper.ARABIC&lt;/code&gt; 과 같이 이러한 매핑이 가능한 해당 대응 항목에 매핑됩니다 . 매핑 할 수없는 범위 값 (예 : &lt;code&gt;NumericShaper.Range.BALINESE&lt;/code&gt; ) 이 지정된 경우 해당 범위는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b2f14e6b9879b33cc948a3f23d891c8c9a5dfd45" translate="yes" xml:space="preserve">
          <source>If the two segments share a common prefix then the returned offset is the length of the common prefix and it follows that there is a mismatch between the two segments at that offset within the respective segments. If one segment is a proper prefix of the other then the returned offset is the smaller of the segment sizes, and it follows that the offset is only valid for the larger segment. Otherwise, there is no mismatch and &lt;code&gt;
 -1&lt;/code&gt; is returned.</source>
          <target state="translated">두 세그먼트가 공통 접두사를 공유하는 경우 반환 된 오프셋은 공통 접두사의 길이이며 각 세그먼트 내의 해당 오프셋에서 두 세그먼트간에 불일치가 발생합니다. 한 세그먼트가 다른 세그먼트의 적절한 접두사 인 경우 반환 된 오프셋은 세그먼트 크기보다 작으며 오프셋은 더 큰 세그먼트에만 유효합니다. 그렇지 않으면 불일치가없고 &lt;code&gt; -1&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cac1823b4d109a58d8c15953a4c53e9282211329" translate="yes" xml:space="preserve">
          <source>If the type is &lt;code&gt;null&lt;/code&gt;, a shared internal persistence delegate is returned that encodes &lt;code&gt;null&lt;/code&gt; value.</source>
          <target state="translated">유형 인 경우 &lt;code&gt;null&lt;/code&gt; , 공유 내부의 지속적인 위양은 인코딩 것을 반환 &lt;code&gt;null&lt;/code&gt; 값 됩니다.</target>
        </trans-unit>
        <trans-unit id="24624d93ce0bd52bd62b61c2d340c4e06907a0dd" translate="yes" xml:space="preserve">
          <source>If the type is a &lt;code&gt;enum&lt;/code&gt; declaration, a shared internal persistence delegate is returned that encodes constants of this enumeration by their names.</source>
          <target state="translated">형식이 &lt;code&gt;enum&lt;/code&gt; 선언 인 경우이 열거의 상수를 이름으로 인코딩하는 공유 내부 지속성 대리자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="17c7dfdd306d9dca345cd59fbb286fb56494c02b" translate="yes" xml:space="preserve">
          <source>If the type is a primitive type or the corresponding wrapper, a shared internal persistence delegate is returned that encodes values of the given type.</source>
          <target state="translated">유형이 기본 유형 또는 해당 랩퍼 인 경우, 주어진 유형의 값을 인코딩하는 공유 내부 지속성 대리자가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e83ddcadc497b3ac8c423eb1d1497d6d589d42af" translate="yes" xml:space="preserve">
          <source>If the type is a proxy, a shared internal persistence delegate is returned that encodes a proxy instance by using the &lt;a href=&quot;../../../java.base/java/lang/reflect/proxy#newProxyInstance(java.lang.ClassLoader,java.lang.Class%5B%5D,java.lang.reflect.InvocationHandler)&quot;&gt;&lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">유형이 프록시 인 경우 &lt;a href=&quot;../../../java.base/java/lang/reflect/proxy#newProxyInstance(java.lang.ClassLoader,java.lang.Class%5B%5D,java.lang.reflect.InvocationHandler)&quot;&gt; &lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt; &lt;/a&gt; 를 사용하여 프록시 인스턴스를 인코딩하는 공유 내부 지속성 위임이 리턴됩니다. ) 방법.</target>
        </trans-unit>
        <trans-unit id="7266e7d4fe52b4f4bd2947e2022cc33489854699" translate="yes" xml:space="preserve">
          <source>If the type is a proxy, a shared internal persistence delegate is returned that encodes a proxy instance by using the &lt;a href=&quot;../lang/reflect/proxy#newProxyInstance-java.lang.ClassLoader-java.lang.Class:A-java.lang.reflect.InvocationHandler-&quot;&gt;&lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">유형이 프록시 인 경우 &lt;a href=&quot;../lang/reflect/proxy#newProxyInstance-java.lang.ClassLoader-java.lang.Class:A-java.lang.reflect.InvocationHandler-&quot;&gt; &lt;code&gt;Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class&amp;lt;?&amp;gt;[], java.lang.reflect.InvocationHandler)&lt;/code&gt; &lt;/a&gt; 를 사용하여 프록시 인스턴스를 인코딩하는 공유 내부 지속성 위임이 리턴됩니다. ) 방법.</target>
        </trans-unit>
        <trans-unit id="7d57cd67c4f9b115595d9ab402c68b98705b5fc3" translate="yes" xml:space="preserve">
          <source>If the type is an &lt;code&gt;enum&lt;/code&gt; declaration, a shared internal persistence delegate is returned that encodes constants of this enumeration by their names.</source>
          <target state="translated">형식이 &lt;code&gt;enum&lt;/code&gt; 선언이면이 열거 형의 상수를 이름으로 인코딩하는 공유 내부 지속성 대리자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6d791c963ef8e6e2b0fde7ef89bca6d1754b00b4" translate="yes" xml:space="preserve">
          <source>If the type is an array, a shared internal persistence delegate is returned that encodes an array of the appropriate type and length, and each of its elements as if they are properties.</source>
          <target state="translated">유형이 배열 인 경우 적절한 유형 및 길이의 배열과 각 요소가 마치 속성 인 것처럼 인코딩하는 공유 내부 지속성 대리자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0b2e4d1a1790e1526fd1d7230bad3ff1e34601cd" translate="yes" xml:space="preserve">
          <source>If the type of an object is incompatible with the expected type of the parameter associated to the object.</source>
          <target state="translated">개체 유형이 개체에 연결된 매개 변수의 예상 유형과 호환되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="99f690abde7ac9507cafcabd4eb11b9f675436cc" translate="yes" xml:space="preserve">
          <source>If the type of the underlying field is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">기본 필드의 유형이 유형 변수 또는 매개 변수화 된 유형 인 경우 작성됩니다. 그렇지 않으면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="bba92f2510991dff47988d4605e2d098cf44722d" translate="yes" xml:space="preserve">
          <source>If the type of the underlying record component is a type variable or a parameterized type, it is created. Otherwise, it is resolved.</source>
          <target state="translated">기본 레코드 구성 요소의 유형이 유형 변수 또는 매개 변수화 된 유형이면 작성됩니다. 그렇지 않으면 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="595e9b134500ae042fb86dbdf0154307a723dc06" translate="yes" xml:space="preserve">
          <source>If the underlying class is an array class, then its &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; modifiers are the same as those of its component type. If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type or void, its &lt;code&gt;public&lt;/code&gt; modifier is always &lt;code&gt;true&lt;/code&gt;, and its &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; modifiers are always &lt;code&gt;false&lt;/code&gt;. If this &lt;code&gt;Class&lt;/code&gt; object represents an array class, a primitive type or void, then its &lt;code&gt;final&lt;/code&gt; modifier is always &lt;code&gt;true&lt;/code&gt; and its interface modifier is always &lt;code&gt;false&lt;/code&gt;. The values of its other modifiers are not determined by this specification.</source>
          <target state="translated">기본 클래스가 배열 클래스 인 경우 해당 &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;private&lt;/code&gt; 및 &lt;code&gt;protected&lt;/code&gt; 수정자는 해당 구성 요소 유형의 수정 자와 동일합니다. 이 &lt;code&gt;Class&lt;/code&gt; 객체가 기본 유형 또는 void를 나타내는 경우 해당 &lt;code&gt;public&lt;/code&gt; 수정자는 항상 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;protected&lt;/code&gt; 및 &lt;code&gt;private&lt;/code&gt; 수정자는 항상 &lt;code&gt;false&lt;/code&gt; 입니다. 이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 클래스, 기본 유형 또는 void를 나타내는 경우 &lt;code&gt;final&lt;/code&gt; 수정자는 항상 &lt;code&gt;true&lt;/code&gt; 이고 인터페이스 수정자는 항상 &lt;code&gt;false&lt;/code&gt; 입니다.. 다른 수정 자의 값은이 사양에 의해 결정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66b62dfc82fc14777b26e50687d5b79596a57206" translate="yes" xml:space="preserve">
          <source>If the underlying class is an array class, then its &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; modifiers are the same as those of its component type. If this &lt;code&gt;Class&lt;/code&gt; represents a primitive type or void, its &lt;code&gt;public&lt;/code&gt; modifier is always &lt;code&gt;true&lt;/code&gt;, and its &lt;code&gt;protected&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; modifiers are always &lt;code&gt;false&lt;/code&gt;. If this object represents an array class, a primitive type or void, then its &lt;code&gt;final&lt;/code&gt; modifier is always &lt;code&gt;true&lt;/code&gt; and its interface modifier is always &lt;code&gt;false&lt;/code&gt;. The values of its other modifiers are not determined by this specification.</source>
          <target state="translated">기본 클래스가 배열 클래스 인 경우 &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;private&lt;/code&gt; 및 &lt;code&gt;protected&lt;/code&gt; 수정자는 해당 구성 요소 유형과 동일합니다. 이 &lt;code&gt;Class&lt;/code&gt; 가 원시적 형 또는 void를 나타내는 경우, 그 &lt;code&gt;public&lt;/code&gt; 수식자는 항상 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; 및 &lt;code&gt;private&lt;/code&gt; 수식자는 항상 &lt;code&gt;false&lt;/code&gt; 입니다. 이 객체가 배열 클래스, 기본 유형 또는 void를 나타내는 경우, &lt;code&gt;final&lt;/code&gt; 수정자는 항상 &lt;code&gt;true&lt;/code&gt; 이고 인터페이스 수정자는 항상 &lt;code&gt;false&lt;/code&gt; 입니다. 다른 수정 자의 값은이 사양에 의해 결정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6635d2c90407f220bf7ecba5d59930986096dac" translate="yes" xml:space="preserve">
          <source>If the underlying field is a static field, the &lt;code&gt;obj&lt;/code&gt; argument is ignored; it may be null.</source>
          <target state="translated">기본 필드가 정적 필드 인 경우 &lt;code&gt;obj&lt;/code&gt; 인수는 무시됩니다. null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61e60b6593bad05aa260e774035853633abadd33" translate="yes" xml:space="preserve">
          <source>If the underlying field is final, the method throws an &lt;code&gt;IllegalAccessException&lt;/code&gt; unless &lt;code&gt;setAccessible(true)&lt;/code&gt; has succeeded for this &lt;code&gt;Field&lt;/code&gt; object and the field is non-static. Setting a final field in this way is meaningful only during deserialization or reconstruction of instances of classes with blank final fields, before they are made available for access by other parts of a program. Use in any other context may have unpredictable effects, including cases in which other parts of a program continue to use the original value of this field.</source>
          <target state="translated">기본이되는 필드가 final의 경우, 이 &lt;code&gt;Field&lt;/code&gt; 오브젝트에 대해 &lt;code&gt;setAccessible(true)&lt;/code&gt; 가 성공 해 필드가 static이 아닌 경우 , 메소드는 &lt;code&gt;IllegalAccessException&lt;/code&gt; 을 Throw합니다 . 이 방법으로 최종 필드를 설정하는 것은 프로그램의 다른 부분에서 액세스 할 수 있기 전에 빈 최종 필드가있는 클래스의 인스턴스를 역 직렬화 또는 재구성하는 동안에 만 의미가 있습니다. 다른 상황에서 사용하면 프로그램의 다른 부분이이 필드의 원래 값을 계속 사용하는 경우를 포함하여 예측할 수없는 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="269ef8898f71d5139fc6e4b1292850037573e45e" translate="yes" xml:space="preserve">
          <source>If the underlying field is final, this &lt;code&gt;Field&lt;/code&gt; object has &lt;em&gt;write&lt;/em&gt; access if and only if the following conditions are met:</source>
          <target state="translated">기본 필드가 최종 &lt;code&gt;Field&lt;/code&gt; 인 경우이 Field 개체는 다음 조건이 충족되는 경우에만 &lt;em&gt;쓰기&lt;/em&gt; 액세스 권한을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="f8ffdb31707c7c6f0d8ea54510f297f85f678ae3" translate="yes" xml:space="preserve">
          <source>If the underlying field is of a primitive type, an unwrapping conversion is attempted to convert the new value to a value of a primitive type. If this attempt fails, the method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">기본 필드가 기본 유형 인 경우 랩핑 해제 변환은 새 값을 기본 유형의 값으로 변환하려고 시도합니다. 이 시도가 실패하면, 메소드는 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 던집니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="35c398b7568f2f6829527a1ee4e8ad05ab589757" translate="yes" xml:space="preserve">
          <source>If the underlying field is static, the &lt;code&gt;obj&lt;/code&gt; argument is ignored; it may be null.</source>
          <target state="translated">기본이되는 필드가 정적 인 경우, &lt;code&gt;obj&lt;/code&gt; 인수는 무시됩니다. null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79473e9ad073a8c2b30d02714d81cdc8e02b2e5d" translate="yes" xml:space="preserve">
          <source>If the underlying field is static, the class that declared the field is initialized if it has not already been initialized.</source>
          <target state="translated">기본 필드가 정적 인 경우 필드를 선언 한 클래스는 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="884f8872373909a62519ac7ae071245b57ecb411" translate="yes" xml:space="preserve">
          <source>If the underlying method is &lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;caller sensitive&lt;/a&gt;, the direct method handle will have been &quot;bound&quot; to a particular caller class, the &lt;a href=&quot;methodhandles.lookup#lookupClass()&quot;&gt;lookup class&lt;/a&gt; of the lookup object used to create it. Cracking this method handle with a different lookup class will fail even if the underlying method is public (like &lt;code&gt;Class.forName&lt;/code&gt;).</source>
          <target state="translated">기본 메서드가 &lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;호출자에 민감한&lt;/a&gt; 경우 직접 메서드 핸들은 특정 호출자 클래스, 이를 생성하는 데 사용 된 조회 개체 의 &lt;a href=&quot;methodhandles.lookup#lookupClass()&quot;&gt;조회 클래스&lt;/a&gt; 에 &quot;바인딩&quot;됩니다 . 다른 조회 클래스로이 메서드 핸들을 크래킹하면 기본 메서드가 공용 (예 : &lt;code&gt;Class.forName&lt;/code&gt; ) 인 경우에도 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="5c2e8ba35ddb7d491a4530be7e2d58c63b91b804" translate="yes" xml:space="preserve">
          <source>If the underlying method is &lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;caller sensitive&lt;/a&gt;, the direct method handle will have been &quot;bound&quot; to a particular caller class, the &lt;a href=&quot;methodhandles.lookup#lookupClass--&quot;&gt;lookup class&lt;/a&gt; of the lookup object used to create it. Cracking this method handle with a different lookup class will fail even if the underlying method is public (like &lt;code&gt;Class.forName&lt;/code&gt;).</source>
          <target state="translated">기본 메소드가 &lt;a href=&quot;methodhandles.lookup#callsens&quot;&gt;호출자 구분&lt;/a&gt; 인 경우 직접 메소드 핸들은 특정 호출자 클래스, 이를 작성하는 데 사용되는 찾아보기 오브젝트 의 찾아 &lt;a href=&quot;methodhandles.lookup#lookupClass--&quot;&gt;보기 클래스&lt;/a&gt; 에 &quot;바인드&quot;됩니다 . 기본 메소드가 공용 인 경우에도 ( &lt;code&gt;Class.forName&lt;/code&gt; 과 같은 ) 다른 조회 클래스로이 메소드 핸들을 크래킹하면 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="315e1d5687f0be0717ab38a86bf5bdc38d92fd67" translate="yes" xml:space="preserve">
          <source>If the underlying method is an instance method, it is invoked using dynamic method lookup as documented in The Java Language Specification, Second Edition, section 15.12.4.4; in particular, overriding based on the runtime type of the target object will occur.</source>
          <target state="translated">기본 메소드가 인스턴스 메소드 인 경우 The Java Language Specification, Second Edition, 섹션 15.12.4.4에 설명 된대로 동적 메소드 조회를 사용하여 호출됩니다. 특히 대상 객체의 런타임 유형에 따라 재정의가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5b1ed6ee8640dbbd801323bd87c98b861047134d" translate="yes" xml:space="preserve">
          <source>If the underlying method is an instance method, it is invoked using dynamic method lookup as documented in The Java Language Specification, section 15.12.4.4; in particular, overriding based on the runtime type of the target object may occur.</source>
          <target state="translated">기본 메서드가 인스턴스 메서드 인 경우 Java 언어 사양, 섹션 15.12.4.4에 설명 된대로 동적 메서드 조회를 사용하여 호출됩니다. 특히 대상 개체의 런타임 유형에 따라 재정의가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38f2cdfc3191616e303143bb27c18fb2f6e69964" translate="yes" xml:space="preserve">
          <source>If the underlying method is an instance method, it is invoked using dynamic method lookup as documented in The Java Language Specification, section &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.12.4.4&quot;&gt;15.12.4.4&lt;/a&gt;; in particular, overriding based on the runtime type of the target object may occur.</source>
          <target state="translated">기본 메서드가 인스턴스 메서드 인 경우 Java 언어 사양, 섹션 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.12.4.4&quot;&gt;15.12.4.4에&lt;/a&gt; 설명 된대로 동적 메서드 조회를 사용하여 호출됩니다 . 특히 대상 개체의 런타임 유형에 따라 재정의가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fdc5865953923b940ef228e2839e6291e6d1529" translate="yes" xml:space="preserve">
          <source>If the underlying method is static, the class that declared the method is initialized if it has not already been initialized.</source>
          <target state="translated">기본 메소드가 정적 인 경우 메소드를 선언 한 클래스는 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="5417f1946175b0c601b43e5b5d82e2dfa1a39a1f" translate="yes" xml:space="preserve">
          <source>If the underlying method is static, then the specified &lt;code&gt;obj&lt;/code&gt; argument is ignored. It may be null.</source>
          <target state="translated">기본 메소드가 정적이면 지정된 &lt;code&gt;obj&lt;/code&gt; 인수가 무시됩니다. null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baee3bb7bafb1339b8300d582f80c05c628c3c7f" translate="yes" xml:space="preserve">
          <source>If the underlying model of the &lt;code&gt;RowSorter&lt;/code&gt; differs from that of this &lt;code&gt;JTable&lt;/code&gt; undefined behavior will result.</source>
          <target state="translated">&lt;code&gt;RowSorter&lt;/code&gt; 의 기본 모델 이이 &lt;code&gt;JTable&lt;/code&gt; 의 모델 과 다른 경우 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dae88d15741d2fff1d10727455001428453c69fc" translate="yes" xml:space="preserve">
          <source>If the underlying model structure changes (the &lt;code&gt;modelStructureChanged&lt;/code&gt; method is invoked) the following are reset to their default values: &lt;code&gt;Comparator&lt;/code&gt;s by column, current sort order, and whether each column is sortable. The default sort order is natural (the same as the model), and columns are sortable by default.</source>
          <target state="translated">기본 모델 구조가 변경되면 ( &lt;code&gt;modelStructureChanged&lt;/code&gt; 메서드가 호출 됨) 다음이 기본값으로 재설정됩니다. &lt;code&gt;Comparator&lt;/code&gt; s by column, current sort order, and whether each column is sortable. 기본 정렬 순서는 자연스럽고 (모델과 동일) 기본적으로 열을 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9883703230204600dade0bca3c6ef6ed2362790c" translate="yes" xml:space="preserve">
          <source>If the underlying model structure changes (the &lt;code&gt;modelStructureChanged&lt;/code&gt; method is invoked) the following are reset to their default values: &lt;code&gt;Comparator&lt;/code&gt;s by column, current sort order, and whether each column is sortable. To find the default &lt;code&gt;Comparator&lt;/code&gt;s, see the concrete implementation (for example, &lt;a href=&quot;table/tablerowsorter&quot;&gt;&lt;code&gt;TableRowSorter&lt;/code&gt;&lt;/a&gt;). The default sort order is unsorted (the same as the model), and columns are sortable by default.</source>
          <target state="translated">기본 모델 구조가 변경되면 ( &lt;code&gt;modelStructureChanged&lt;/code&gt; 메서드가 호출 됨) 다음이 기본값으로 재설정됩니다. &lt;code&gt;Comparator&lt;/code&gt; s by column, current sort order, and whether each column is sortable. 기본 &lt;code&gt;Comparator&lt;/code&gt; 를 찾으려면 구체적인 구현 (예 : &lt;a href=&quot;table/tablerowsorter&quot;&gt; &lt;code&gt;TableRowSorter&lt;/code&gt; &lt;/a&gt; ) 을 참조하십시오 . 기본 정렬 순서는 정렬되지 않으며 (모델과 동일) 기본적으로 열을 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9921e56a78b932a99ec7c118f676e37975b2d1c9" translate="yes" xml:space="preserve">
          <source>If the underlying platform has a &quot;native&quot; look and feel, and this is an implementation of it, return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">기본 플랫폼에 &quot;기본&quot;모양과 느낌이 있고 이것이 구현 된 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="afbbef7a28945de7e4c59f1f0a920532651223f3" translate="yes" xml:space="preserve">
          <source>If the underlying platform has a &quot;native&quot; look and feel, and this is an implementation of it, return &lt;code&gt;true&lt;/code&gt;. For example, when the underlying platform is Solaris running CDE a CDE/Motif look and feel implementation would return &lt;code&gt;
 true&lt;/code&gt;.</source>
          <target state="translated">기본 플랫폼에 &quot;기본&quot;모양과 느낌이 있고 이것이 구현 된 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 예를 들어, 기본 플랫폼이 CDE를 실행하는 Solaris 인 경우 CDE / Motif 룩앤필 구현은 &lt;code&gt; true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2221ca8e8e96c757d1acb4e9dea9f2b5398db497" translate="yes" xml:space="preserve">
          <source>If the unit is a &lt;a href=&quot;temporal/chronounit&quot;&gt;&lt;code&gt;ChronoUnit&lt;/code&gt;&lt;/a&gt; then the query is implemented here. The supported units are:</source>
          <target state="translated">단위가 &lt;a href=&quot;temporal/chronounit&quot;&gt; &lt;code&gt;ChronoUnit&lt;/code&gt; &lt;/a&gt; 이면 여기에서 쿼리가 구현됩니다. 지원되는 단위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd8d281301aa1d20e9a67171d9933765d4124562" translate="yes" xml:space="preserve">
          <source>If the unit is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the first argument.</source>
          <target state="translated">단위가 아닌 경우 &lt;code&gt;ChronoUnit&lt;/code&gt; ,이 방법의 결과를 호출하는 것에 의해 획득된다 &lt;code&gt;TemporalUnit.addTo(Temporal, long)&lt;/code&gt; 전달하는 &lt;code&gt;this&lt;/code&gt; 첫번째 인자로.</target>
        </trans-unit>
        <trans-unit id="6f71bc9db5b6219e1ae283e954d88ba321dd8591" translate="yes" xml:space="preserve">
          <source>If the unit is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the first argument and the converted input temporal as the second argument.</source>
          <target state="translated">단위가 아닌 경우 &lt;code&gt;ChronoUnit&lt;/code&gt; 호출함으로써 얻어지는,이 방법의 다음 결과 &lt;code&gt;TemporalUnit.between(Temporal, Temporal)&lt;/code&gt; 통과하는 &lt;code&gt;this&lt;/code&gt; 첫번째 인수와 두 번째 인수로 변환 된 입력 시간있다.</target>
        </trans-unit>
        <trans-unit id="66bc82b1dd235049a5511719d85e81950af05fd7" translate="yes" xml:space="preserve">
          <source>If the unit is not a &lt;code&gt;ChronoUnit&lt;/code&gt;, then the result of this method is obtained by invoking &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; passing &lt;code&gt;this&lt;/code&gt; as the argument. Whether the unit is supported is determined by the unit.</source>
          <target state="translated">단위가 아닌 경우 &lt;code&gt;ChronoUnit&lt;/code&gt; 이 메소드의 결과를 호출하는 것에 의해 얻어진다 &lt;code&gt;TemporalUnit.isSupportedBy(Temporal)&lt;/code&gt; 통과 &lt;code&gt;this&lt;/code&gt; 하여 인수로 . 장치가 지원되는지 여부는 장치에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="906c58bb1f6e7950ac3b30334d2bb84e89a6b83b" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The characters &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;) and &lt;code&gt;
 '1'&lt;/code&gt; (&lt;code&gt;'\u0031'&lt;/code&gt;) are used as binary digits.</source>
          <target state="translated">부호없는 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면 부호없는 크기 표현의 첫 번째 문자가 0 문자가 아닙니다. 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; ) 및 &lt;code&gt; '1'&lt;/code&gt; ( &lt;code&gt;'\u0031'&lt;/code&gt; )은 이진수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="20661569ddc05848e0dfeb41e06e5676e4ccca6a" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The characters &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;) and &lt;code&gt;'1'&lt;/code&gt; (&lt;code&gt;'\u0031'&lt;/code&gt;) are used as binary digits.</source>
          <target state="translated">부호없는 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면 부호없는 크기 표현의 첫 번째 문자는 0이 아닙니다. 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; ) 및 &lt;code&gt;'1'&lt;/code&gt; ( &lt;code&gt;'\u0031'&lt;/code&gt; )은 이진수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c10c42689b734462a910f9cd90fb2d17103287f1" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The following characters are used as hexadecimal digits:</source>
          <target state="translated">부호없는 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면 부호없는 크기 표현의 첫 번째 문자는 0이 아닙니다. 다음 문자는 16 진수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f07ca050a4a81c4b683387f3c53d9089c379035d" translate="yes" xml:space="preserve">
          <source>If the unsigned magnitude is zero, it is represented by a single zero character &lt;code&gt;'0'&lt;/code&gt; (&lt;code&gt;'\u0030'&lt;/code&gt;); otherwise, the first character of the representation of the unsigned magnitude will not be the zero character. The following characters are used as octal digits:</source>
          <target state="translated">부호없는 크기가 0이면 단일 0 문자 &lt;code&gt;'0'&lt;/code&gt; ( &lt;code&gt;'\u0030'&lt;/code&gt; )으로 표시됩니다. 그렇지 않으면 부호없는 크기 표현의 첫 번째 문자는 0이 아닙니다. 다음 문자는 8 진수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ffd8f31b308ededd50592fa98b7b8942dd2be329" translate="yes" xml:space="preserve">
          <source>If the user cancels the dialog, the returned attributes will not reflect any changes made by the user.</source>
          <target state="translated">사용자가 대화 상자를 취소하면 반환 된 속성은 사용자가 변경 한 사항을 반영하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb6714e942d1212dc9686ac25a627707c330ee39" translate="yes" xml:space="preserve">
          <source>If the user cancels the dialog, the returned attributes will not reflect any changes made by the user. A typical basic usage of this method may be :</source>
          <target state="translated">사용자가 대화 상자를 취소하면 반환 된 속성에 사용자가 변경 한 내용이 반영되지 않습니다. 이 방법의 일반적인 기본 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7208f9f9b8096f5bc1e213faa64052c112ef12fa" translate="yes" xml:space="preserve">
          <source>If the user cancels the file dialog, then the method returns an empty array.</source>
          <target state="translated">사용자가 파일 대화 상자를 취소하면 메서드는 빈 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="de0b9944a16bfd19e85e0670561c553ba7b1eeb4" translate="yes" xml:space="preserve">
          <source>If the user doesn't select a drop action, the set of &lt;code&gt;DnDConstants&lt;/code&gt; that represents the set of drop actions supported by the drag source is searched for &lt;code&gt;DnDConstants.ACTION_MOVE&lt;/code&gt;, then for &lt;code&gt;DnDConstants.ACTION_COPY&lt;/code&gt;, then for &lt;code&gt;DnDConstants.ACTION_LINK&lt;/code&gt; and the</source>
          <target state="translated">사용자가 드롭 액션을 선택하지 않는 경우, 세트 &lt;code&gt;DnDConstants&lt;/code&gt; 어떤 드래그 소스로 지원되고있는 일련의 드롭 액션을 나타내는를 검색합니다 &lt;code&gt;DnDConstants.ACTION_MOVE&lt;/code&gt; 다음에, &lt;code&gt;DnDConstants.ACTION_COPY&lt;/code&gt; , 다음에 대한 &lt;code&gt;DnDConstants.ACTION_LINK&lt;/code&gt; 가 와</target>
        </trans-unit>
        <trans-unit id="93c5fdab4572abcb9f84bc6e6f772f374b7d5ea5" translate="yes" xml:space="preserve">
          <source>If the user has previously selected an input method or keyboard layout for the requested locale from the user interface, then the most recently selected such input method or keyboard layout is reselected.</source>
          <target state="translated">사용자가 이전에 사용자 인터페이스에서 요청 된 로케일에 대한 입력 방법 또는 키보드 레이아웃을 선택한 경우 가장 최근에 선택한 해당 입력 방법 또는 키보드 레이아웃이 다시 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="0a3ff22bd71bfe0f9cb8dffa032e252c7a72a011" translate="yes" xml:space="preserve">
          <source>If the user provides an &lt;code&gt;RMIServerImpl&lt;/code&gt; rather than a &lt;code&gt;JMXServiceURL&lt;/code&gt;, then the generated &lt;code&gt;JMXServiceURL&lt;/code&gt; will have the local host name in its &lt;code&gt;&lt;em&gt;host&lt;/em&gt;&lt;/code&gt; part and no &lt;code&gt;&lt;em&gt;port&lt;/em&gt;&lt;/code&gt;.</source>
          <target state="translated">사용자 가 &lt;code&gt;JMXServiceURL&lt;/code&gt; 대신 &lt;code&gt;RMIServerImpl&lt;/code&gt; 을 제공하면 생성 된 &lt;code&gt;JMXServiceURL&lt;/code&gt; 의 &lt;code&gt;&lt;em&gt;host&lt;/em&gt;&lt;/code&gt; 부분 에 로컬 호스트 이름이 있고 &lt;code&gt;&lt;em&gt;port&lt;/em&gt;&lt;/code&gt; 없습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c751f889067dd8cb1ad34d217d14ea94b60a4ea0" translate="yes" xml:space="preserve">
          <source>If the user selects a drop action, the</source>
          <target state="translated">사용자가 놓기 동작을 선택하면</target>
        </trans-unit>
        <trans-unit id="790177d5a2da0339061b07b0e2796a63d5c7bba4" translate="yes" xml:space="preserve">
          <source>If the user wants to represent more complex relations, involving properties and/or methods, he has to provide his own class implementing the Relation interface. This can be achieved either by inheriting from RelationSupport class, or by implementing the interface (fully or delegation to a RelationSupport object member).</source>
          <target state="translated">사용자가 속성 및 / 또는 메서드와 관련된보다 복잡한 관계를 나타내려면 Relation 인터페이스를 구현하는 고유 한 클래스를 제공해야합니다. RelationSupport 클래스에서 상속하거나 인터페이스를 구현하거나 (RelationSupport 개체 멤버에게 완전 또는 위임) 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e426a67bb1131fd615e1eb1f3e1e7dddce68bf0" translate="yes" xml:space="preserve">
          <source>If the value at the anchor index is not selected, do the same thing in reverse selecting values in the old range and deselecting values in the new one.</source>
          <target state="translated">앵커 인덱스의 값이 선택되지 않은 경우 이전 범위의 값을 반대로 선택하고 새 범위의 값을 선택 취소하는 것과 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2d22c3736384d8f57852c160122995e97ee6f65b" translate="yes" xml:space="preserve">
          <source>If the value cannot be obtained then an exception will be thrown. If the value is negative an exception will be thrown. If the field does not have a fixed set of valid values then an exception will be thrown. If the field value in the date-time to be printed is invalid it cannot be printed and an exception will be thrown.</source>
          <target state="translated">값을 얻을 수 없으면 예외가 발생합니다. 값이 음수이면 예외가 발생합니다. 필드에 고정 된 유효한 값 세트가 없으면 예외가 발생합니다. 인쇄 할 날짜-시간의 필드 값이 유효하지 않으면 인쇄 할 수 없으며 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d99b539ed5fff0ea996e5c36ef46a4ab0d55246" translate="yes" xml:space="preserve">
          <source>If the value does not represent a valid &lt;a href=&quot;../java.base/java/lang/runtime.version&quot;&gt;Java SE Platform version number&lt;/a&gt;, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.</source>
          <target state="translated">값이 유효한 표현하지 않는 경우 &lt;a href=&quot;../java.base/java/lang/runtime.version&quot;&gt;자바 SE 플랫폼의 버전 번호&lt;/a&gt; , &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 슬로우됩니다.</target>
        </trans-unit>
        <trans-unit id="3ee0cd8b8e0f022dac140b1064202354f2993085" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value.</source>
          <target state="translated">지정된 키의 값이 존재하고 널이 아닌 경우 키와 현재 맵핑 된 값이 주어지면 새 맵핑을 계산하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ecdf413c04b1da892ae0fa943003fe90e373d5c1" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value.</source>
          <target state="translated">지정된 키의 값이있는 경우 키와 현재 매핑 된 값이 주어지면 새 매핑을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4b761882d9981acf5026d5923e5e847a58120eb7" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.</source>
          <target state="translated">지정된 키의 값이 있으면 키와 현재 매핑 된 값이 주어지면 새 매핑을 계산하려고 시도합니다. 전체 메소드 호출은 원자 적으로 수행됩니다. 다른 스레드가이 맵에서 시도한 일부 업데이트 작업은 계산이 진행되는 동안 차단 될 수 있으므로 계산이 짧고 단순해야하며이 맵의 다른 매핑을 업데이트하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ab9247f09f8a914d5d3a273cd57f46206435c082" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The entire method invocation is performed atomically. The supplied function is invoked exactly once per invocation of this method if the key is present, else not at all. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple.</source>
          <target state="translated">지정된 키의 값이있는 경우 키와 현재 매핑 된 값이 주어지면 새 매핑을 계산합니다. 전체 메소드 호출은 원자 적으로 수행됩니다. 제공된 함수는 키가있는 경우이 메서드를 호출 할 때마다 정확히 한 번 호출됩니다. 그렇지 않으면 전혀 호출되지 않습니다. 다른 스레드가이 맵에서 시도한 일부 업데이트 작업은 계산이 진행되는 동안 차단 될 수 있으므로 계산이 짧고 간단해야합니다.</target>
        </trans-unit>
        <trans-unit id="f3db5a9e74f7891f194526ea0f347239e63fa2ef" translate="yes" xml:space="preserve">
          <source>If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The function is &lt;em&gt;NOT&lt;/em&gt; guaranteed to be applied once atomically.</source>
          <target state="translated">지정된 키의 값이 있으면 키와 현재 매핑 된 값이 주어지면 새 매핑을 계산하려고 시도합니다. 기능이 &lt;em&gt;아닙니다&lt;/em&gt; 원자 적으로 한 번만 적용되는 .</target>
        </trans-unit>
        <trans-unit id="c5e8a168b387e1a676dd90915381d221d843a6ab" translate="yes" xml:space="preserve">
          <source>If the value in the designated column has a custom mapping, this method returns the name of the class that implements &lt;code&gt;SQLData&lt;/code&gt;. When the method &lt;code&gt;ResultSet.getObject&lt;/code&gt; is called to retrieve a value from the designated column, it will create an instance of this class or one of its subclasses.</source>
          <target state="translated">지정된 열의 값에 사용자 지정 매핑이있는 경우이 메서드는 &lt;code&gt;SQLData&lt;/code&gt; 를 구현하는 클래스의 이름을 반환합니다 . 지정된 열에서 값을 검색하기 위해 &lt;code&gt;ResultSet.getObject&lt;/code&gt; 메소드 가 호출 되면 이 클래스 또는 하위 클래스 중 하나의 인스턴스가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="76a62dcfb0cff96625fd935bd1e2f63de3a120f6" translate="yes" xml:space="preserve">
          <source>If the value is 0, this means to wait indefinitely.</source>
          <target state="translated">값이 0이면 무기한 대기한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="c7ba3202bd2d7e0d3d7e70603c207b47eb8a22d0" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;&quot;DEFLATED&quot;&lt;/code&gt; or the property is not set, the Zip file system provider will use data compression when writing entries to the Zip file system.</source>
          <target state="translated">값이 &lt;code&gt;&quot;DEFLATED&quot;&lt;/code&gt; 이거나 속성이 설정되지 않은 경우 Zip 파일 시스템 공급자는 항목을 Zip 파일 시스템에 쓸 때 데이터 압축을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c4915503ed46018ca7714a4810995361ec058bdf" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;&quot;STORED&quot;&lt;/code&gt;, the Zip file system provider will not compress entries when writing to the Zip file system.</source>
          <target state="translated">값이 &lt;code&gt;&quot;STORED&quot;&lt;/code&gt; 이면 Zip 파일 시스템 공급자는 Zip 파일 시스템에 쓸 때 항목을 압축하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1da17a5162837fd71057188c7c8f9d55cafe8683" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;&quot;runtime&quot;&lt;/code&gt;, the version entry will be determined by invoking &lt;a href=&quot;../java.base/java/lang/runtime.version#feature()&quot;&gt;Runtime.Version.feature()&lt;/a&gt;.</source>
          <target state="translated">값이 &lt;code&gt;&quot;runtime&quot;&lt;/code&gt; 이면 &lt;a href=&quot;../java.base/java/lang/runtime.version#feature()&quot;&gt;Runtime.Version.feature ()&lt;/a&gt; 를 호출하여 버전 항목이 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0de4492c54d50e85bf0da62b3577996044c41c74" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;non-null&lt;/code&gt;, it is returned. If the value of the default &lt;code&gt;&quot;AuditoryCues.actionMap&quot;&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; and the value of the default &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; is &lt;code&gt;non-null&lt;/code&gt;, an &lt;code&gt;ActionMapUIResource&lt;/code&gt; is created and populated. Population is done by iterating over each of the elements of the &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; array, and invoking &lt;code&gt;createAudioAction()&lt;/code&gt; to create an &lt;code&gt;
 Action&lt;/code&gt; for each element. The resulting &lt;code&gt;Action&lt;/code&gt; is placed in the &lt;code&gt;ActionMapUIResource&lt;/code&gt;, using the array element as the key. For example, if the &lt;code&gt;
 &quot;AuditoryCues.cueList&quot;&lt;/code&gt; array contains a single-element, &lt;code&gt;
 &quot;audioKey&quot;&lt;/code&gt;, the &lt;code&gt;ActionMapUIResource&lt;/code&gt; is created, then populated by way of &lt;code&gt;actionMap.put(cueList[0],
 createAudioAction(cueList[0]))&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;non-null&lt;/code&gt; 이 아닌 경우 반환됩니다. 기본 값 경우 &lt;code&gt;&quot;AuditoryCues.actionMap&quot;&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 과 기본 값 &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; 입니다 &lt;code&gt;non-null&lt;/code&gt; AN, &lt;code&gt;ActionMapUIResource&lt;/code&gt; 가 작성되고 채워집니다. 채우기는 &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; 배열 의 각 요소를 반복하고 &lt;code&gt;createAudioAction()&lt;/code&gt; 을 호출 하여 각 요소에 대한 &lt;code&gt; Action&lt;/code&gt; 을 생성하여 수행 됩니다. 결과 &lt;code&gt;Action&lt;/code&gt; 은 배열 요소를 키로 사용하여 &lt;code&gt;ActionMapUIResource&lt;/code&gt; 에 배치됩니다 . 예를 들어 경우 &lt;code&gt; &quot;AuditoryCues.cueList&quot;&lt;/code&gt; 배열은 단일 요소 &lt;code&gt; &quot;audioKey&quot;&lt;/code&gt; , &lt;code&gt;ActionMapUIResource&lt;/code&gt; 가 생성 된 다음 &lt;code&gt;actionMap.put(cueList[0], createAudioAction(cueList[0]))&lt;/code&gt; 을 통해 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="48f26593351b6f67f120030ffb29e742cf0e8005" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;null&lt;/code&gt; or the property is not set, then the JAR will be treated as an un-versioned JAR.</source>
          <target state="translated">값이 &lt;code&gt;null&lt;/code&gt; 이거나 속성이 설정되지 않은 경우 JAR은 버전이 지정되지 않은 JAR로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="13f1ab8d6bcff2c595a675585e42d96731f03925" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, the Zip file system provider creates a new Zip or JAR file if it does not exist.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 Zip 파일 시스템 공급자는 존재하지 않는 경우 새 Zip 또는 JAR 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f7b9c97637681e9e7a63c9db0dc64ec2ca509020" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, the Zip file system will support the &lt;a href=&quot;../java.base/java/nio/file/attribute/posixfileattributeview&quot;&gt;&lt;code&gt;PosixFileAttributeView&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 Zip 파일 시스템은 &lt;a href=&quot;../java.base/java/nio/file/attribute/posixfileattributeview&quot;&gt; &lt;code&gt;PosixFileAttributeView&lt;/code&gt; &lt;/a&gt; 를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="301076cf0d84829c80ed3ada45bc0a362fb8a4d9" translate="yes" xml:space="preserve">
          <source>If the value is NaN or infinite, the literal strings &quot;NaN&quot; or &quot;Infinity&quot;, respectively, will be output.</source>
          <target state="translated">값이 NaN 또는 무한이면 리터럴 문자열 &quot;NaN&quot;또는 &quot;Infinity&quot;가 각각 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="ab06ef8615a9271c661fe8e0122f8b8d95f1110e" translate="yes" xml:space="preserve">
          <source>If the value is NaN or positive infinity the literal strings &quot;NaN&quot; or &quot;Infinity&quot; respectively, will be output. If the value is negative infinity, then the output will be &quot;(Infinity)&quot; if the &lt;code&gt;'('&lt;/code&gt; flag is given otherwise the output will be &quot;-Infinity&quot;. These values are not localized.</source>
          <target state="translated">값이 NaN 또는 양의 무한대 인 경우 리터럴 문자열 &quot;NaN&quot;또는 &quot;Infinity&quot;가 각각 출력됩니다. 값이 음의 무한대이면 &lt;code&gt;'('&lt;/code&gt; 플래그가 제공 되면 출력은 &quot;(무한대)&quot;가되고 그렇지 않으면 출력은 &quot;-무한대&quot;가됩니다 .이 값은 현지화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0835f0832141e69a77792c43ed4cdb23fe77095b" translate="yes" xml:space="preserve">
          <source>If the value is a URN, the &lt;code&gt;href&lt;/code&gt; attribute is recognized as a &lt;code&gt;publicId&lt;/code&gt;, and used to search &lt;code&gt;public&lt;/code&gt; entries. If the value is a URI, it is taken as a &lt;code&gt;systemId&lt;/code&gt;, and used to search both &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;uri&lt;/code&gt; entries.</source>
          <target state="translated">값이 URN 인 경우 &lt;code&gt;href&lt;/code&gt; 속성은 &lt;code&gt;publicId&lt;/code&gt; 로 인식되고 &lt;code&gt;public&lt;/code&gt; 항목 을 검색하는 데 사용됩니다 . 값이 URI이면 &lt;code&gt;systemId&lt;/code&gt; 로 간주 되며 &lt;code&gt;system&lt;/code&gt; 및 &lt;code&gt;uri&lt;/code&gt; 항목을 모두 검색하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8386f5e063110a495ec4902ded50dbabab418fe" translate="yes" xml:space="preserve">
          <source>If the value is negative (or floating-point negative zero) and &lt;code&gt;'('&lt;/code&gt; flag is not given, then a &lt;code&gt;'-'&lt;/code&gt; (&lt;code&gt;'\u002d'&lt;/code&gt;) is prepended.</source>
          <target state="translated">값이 음수 (또는 부동 소수점 음수 0)이고 &lt;code&gt;'('&lt;/code&gt; 플래그가 제공되지 않은 경우 &lt;code&gt;'-'&lt;/code&gt; ( &lt;code&gt;'\u002d'&lt;/code&gt; )가 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="6f6d817a3f4c5b41b572c9b2e4daf5c4281d9fee" translate="yes" xml:space="preserve">
          <source>If the value is negative and the &lt;code&gt;'('&lt;/code&gt; flag is given, then a &lt;code&gt;'('&lt;/code&gt; (&lt;code&gt;'\u0028'&lt;/code&gt;) is prepended and a &lt;code&gt;')'&lt;/code&gt; (&lt;code&gt;'\u0029'&lt;/code&gt;) is appended.</source>
          <target state="translated">값이 음수이고 &lt;code&gt;'('&lt;/code&gt; 플래그가 제공되면 &lt;code&gt;'('&lt;/code&gt; ( &lt;code&gt;'\u0028'&lt;/code&gt; )이 앞에 붙고 &lt;code&gt;')'&lt;/code&gt; ( &lt;code&gt;'\u0029'&lt;/code&gt; )이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="79c5db2353984efc6cb7e1c18940f5eb527e5ef9" translate="yes" xml:space="preserve">
          <source>If the value is negative, then it represents the number of days back from the end of the month where &lt;code&gt;-1&lt;/code&gt; is the last day of the month. In this case, the day identified is the latest possible date that the transition can be.</source>
          <target state="translated">값이 음수 &lt;code&gt;-1&lt;/code&gt; 은 달 의 마지막 날인 달의 끝에서 되돌아온 일 수를 나타냅니다 . 이 경우 식별 된 날짜는 전환이 가능한 최신 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="f585bd91e3b9e65403bebed531867a10e356498c" translate="yes" xml:space="preserve">
          <source>If the value is not &lt;code&gt;&quot;STORED&quot;&lt;/code&gt; or &lt;code&gt;&quot;DEFLATED&quot;&lt;/code&gt;, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown when the Zip filesystem is created.</source>
          <target state="translated">값이되지 않는 경우 &lt;code&gt;&quot;STORED&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;DEFLATED&quot;&lt;/code&gt; , &lt;code&gt;IllegalArgumentException&lt;/code&gt; 가 [압축 파일 시스템을 만들 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a221fc4de816cd6c7effceee4131da4c33e0f4df" translate="yes" xml:space="preserve">
          <source>If the value is not of the proper type, the attribute will be ignored.</source>
          <target state="translated">값이 적절한 유형이 아니면 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a89c880bd0c92196eb9e203f110acd320c2580c9" translate="yes" xml:space="preserve">
          <source>If the value is positive, then it represents a normal day-of-month, and is the earliest possible date that the transition can be. The date may refer to 29th February which should be treated as 1st March in non-leap years.</source>
          <target state="translated">값이 양수이면 정상 일을 나타내며 전환이 가능한 가장 빠른 날짜입니다. 날짜는 2 월 29 일을 의미 할 수 있으며 이는 윤년이 아닌 경우 3 월 1 일로 처리되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3334ef34b1cd3c138c012c02960e8363c7beb397" translate="yes" xml:space="preserve">
          <source>If the value is set to &lt;code&gt;true&lt;/code&gt;, then:</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e02310a0ea5559eabc6294ef56491025a14c4eb6" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;DISPLAYED_MNEMONIC_INDEX_KEY&lt;/code&gt; is beyond the bounds of the text, it is ignored. When &lt;code&gt;setAction&lt;/code&gt; is called, if the value from the &lt;code&gt;Action&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the displayed mnemonic index is not updated. In any subsequent changes to &lt;code&gt;DISPLAYED_MNEMONIC_INDEX_KEY&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; is treated as -1.</source>
          <target state="translated">&lt;code&gt;DISPLAYED_MNEMONIC_INDEX_KEY&lt;/code&gt; 의 값이 텍스트의 범위를 벗어나면 무시됩니다. &lt;code&gt;setAction&lt;/code&gt; 이 호출 될 때 &lt;code&gt;Action&lt;/code&gt; 의 값 이 &lt;code&gt;null&lt;/code&gt; 이면 표시된 니모닉 인덱스가 업데이트되지 않습니다. &lt;code&gt;DISPLAYED_MNEMONIC_INDEX_KEY&lt;/code&gt; 에 대한 후속 변경 에서 &lt;code&gt;null&lt;/code&gt; 은 -1로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="22c60f3a7542e4a41034dd5216a61c3aba7c36d9" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;Border&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; A는 &lt;code&gt;Border&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eba252138c8090a37a788c71e19e8a3cb0276356" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;Color&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; A는 &lt;code&gt;Color&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="367d8e2f0ca28a2ea644636137ef64c997bec18b" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;Dimension&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; A는 &lt;code&gt;Dimension&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2be0d9b17a5e47e7e93a2913690292ed9a69b7ff" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;Font&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; A는 &lt;code&gt;Font&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c67916533b9dbb5dc83f598e1e6382427cd552f9" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is a &lt;code&gt;String&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; A는 &lt;code&gt;String&lt;/code&gt; 반환 그것은 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d2bfc7c723ba35a6fcf6c4b6137b4f780a0b3de" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is an &lt;code&gt;Icon&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; 입니다 &lt;code&gt;Icon&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab2d62c2054fc3fa0f8b523b4eab33e78eb557e0" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is an &lt;code&gt;Insets&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; 입니다 &lt;code&gt;Insets&lt;/code&gt; 반환, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0260b2e58bbf30b3665cb0865cc9a91961481c68" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is an &lt;code&gt;Integer&lt;/code&gt; return its integer value, otherwise return 0.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 주어진에 대한 &lt;code&gt;Locale&lt;/code&gt; 있는 &lt;code&gt;Integer&lt;/code&gt; , 그렇지 않으면 0을 반환, 그 정수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a6474e2edb69dbe8cb6a10bd386064bfd71534a0" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;Locale&lt;/code&gt; is boolean, return the boolean value, otherwise return false.</source>
          <target state="translated">주어진 &lt;code&gt;Locale&lt;/code&gt; 의 &lt;code&gt;key&lt;/code&gt; 값 이 부울이면 부울 값을 반환하고 그렇지 않으면 거짓을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b6d5bd5fca8a25f1dd49217534639ed2ffe7fe4" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Border&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; A는 &lt;code&gt;Border&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3be018e83c846fe1b30aea1f6bf6ccf6c10c541" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Color&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; A는 &lt;code&gt;Color&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c8b42e483eff7d7568eb7eb3163a2f5cbbf4c96" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Dimension&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; A는 &lt;code&gt;Dimension&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5785760f42f1977942d08aa328b366f8fc0db0e" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;Font&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; A는 &lt;code&gt;Font&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4141012d327f30dfb544d88d4209e96defccecb8" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is a &lt;code&gt;String&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; A는 &lt;code&gt;String&lt;/code&gt; 반환 그것은 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ba848583bb0ce0d7c9675fd82c19e9dbc0309d4" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is an &lt;code&gt;Icon&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 입니다 &lt;code&gt;Icon&lt;/code&gt; 반환이, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eba09aea4ed9d543ab5701573b6ee8091b5b8904" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is an &lt;code&gt;Insets&lt;/code&gt; return it, otherwise return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 입니다 &lt;code&gt;Insets&lt;/code&gt; 반환, 그렇지 않으면 반환 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5234ac47786667f30dde0ed0ff67d97ce01bff63" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is an &lt;code&gt;Integer&lt;/code&gt; return its integer value, otherwise return 0.</source>
          <target state="translated">의 값 경우 &lt;code&gt;key&lt;/code&gt; 입니다 &lt;code&gt;Integer&lt;/code&gt; 는 그 정수 값을 반환, 그렇지 않은 경우는 0을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="f45a7d95af981044e17417d792efc75f1ad87858" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;key&lt;/code&gt; is boolean, return the boolean value, otherwise return false.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 값 이 부울이면 부울 값을 반환하고 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="43c44811372338e5d89625fd7f4ec1fe65b36ee4" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;load&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then this method starts loading any images that are not yet being loaded.</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 값 이 &lt;code&gt;true&lt;/code&gt; 이면 이 메서드는 아직로드되지 않은 이미지로드를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f6fe9c920cf87a3961283663010d0cc7faf04891" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;LOAD&lt;/code&gt;, then the file dialog is finding a file to read, and the files shown are those in the current directory. If the value of &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;SAVE&lt;/code&gt;, the file dialog is finding a place to write a file.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 값 이 &lt;code&gt;LOAD&lt;/code&gt; 이면 파일 대화 상자가 읽을 파일을 찾고 표시된 파일은 현재 디렉토리에있는 파일입니다. &lt;code&gt;mode&lt;/code&gt; 값 이 &lt;code&gt;SAVE&lt;/code&gt; 이면 파일 대화 상자가 파일을 쓸 위치를 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a25b68c044cd0c1ec4edc8c60c29d6185e1c049" translate="yes" xml:space="preserve">
          <source>If the value of a field is not a String, then the toString() method will be called on it and the returned value, enclosed in parentheses, used as the value for the field in the returned array. If the value of a field is null, then the value of the field in the returned array will be empty. If the descriptor is empty, you will get an empty array.</source>
          <target state="translated">필드의 값이 문자열이 아니면 toString () 메소드가 호출되고 괄호로 묶인 리턴 값이 리턴 된 배열의 필드 값으로 사용됩니다. 필드 값이 null이면 반환 된 배열의 필드 값이 비어 있습니다. 디스크립터가 비어 있으면 빈 배열을 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="1efefa1818e57cc73d4ed09d390b1ca62795c0cf" translate="yes" xml:space="preserve">
          <source>If the value of a shorthand property can not be decomposed into its component longhand properties, as is the case for the &lt;code&gt;font&lt;/code&gt; property with a value of &quot;menu&quot;, querying for the values of the component longhand properties should return the empty string.</source>
          <target state="translated">값이 &quot;menu&quot;인 &lt;code&gt;font&lt;/code&gt; 속성 의 경우처럼 속기 속성의 값을 구성 요소 longhand 속성으로 분해 할 수없는 경우 구성 요소 longhand 속성 의 값을 쿼리하면 빈 문자열이 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3c88da9b0c956884891afc187b29ac9d1d3914af" translate="yes" xml:space="preserve">
          <source>If the value of that system property is not &lt;code&gt;null&lt;/code&gt;, it is interpreted as a list of packages separated by a vertical slash character '&lt;code&gt;|&lt;/code&gt;'. The constructor tries to load the class named:</source>
          <target state="translated">이 시스템 프로퍼티의 값이없는 경우 &lt;code&gt;null&lt;/code&gt; 패키지 목록은 수직 슬래시 문자 '로 구분으로,이 해석 &lt;code&gt;|&lt;/code&gt; '. 생성자는 다음과 같은 이름의 클래스를로드하려고합니다.</target>
        </trans-unit>
        <trans-unit id="189b2a483106b850cb5a3377c0425a501b7adcff" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;len&lt;/code&gt; parameter is negative then no characters are written. This is contrary to the specification of this method in the &lt;a href=&quot;writer#write-java.lang.String-int-int-&quot;&gt;superclass&lt;/a&gt;, which requires that an &lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt;&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;&lt;/a&gt; be thrown.</source>
          <target state="translated">&lt;code&gt;len&lt;/code&gt; 매개 변수 의 값 이 음수이면 문자가 기록되지 않습니다. 이것은 &lt;a href=&quot;writer#write-java.lang.String-int-int-&quot;&gt;수퍼 클래스&lt;/a&gt; 에서이 메소드의 스펙과 상반 되므로 &lt;a href=&quot;../lang/indexoutofboundsexception&quot;&gt; &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; &lt;/a&gt; 이 발생 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8a175ebc49437ed81722116dff77ef058a7b66c3" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;load&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, then this method starts loading any images that are not yet being loaded.</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 플래그 의 값 이 &lt;code&gt;true&lt;/code&gt; 이면 이 메서드는 아직로드되지 않은 이미지로드를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b153c1760d762182820a11651725f26d981a5d3a" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;preferredWidth&lt;/code&gt; property is less than the new minimum width, this method sets that property to the new minimum width.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 또는 &lt;code&gt;preferredWidth&lt;/code&gt; 속성 값이 새 최소 너비보다 작 으면이 메서드는 해당 속성을 새 최소 너비로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d3222faa7f28cca7505e3db00febf3a73dfdf614" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;preferredWidth&lt;/code&gt; property is more than the new maximum width, this method sets that property to the new maximum width.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 또는 &lt;code&gt;preferredWidth&lt;/code&gt; 속성 값이 새 최대 너비보다 크면이 메서드는 해당 속성을 새 최대 너비로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1faf4afd4927c3eff93f389c43a673f5145f1898" translate="yes" xml:space="preserve">
          <source>If the value of the default &lt;code&gt;&quot;AuditoryCues.actionMap&quot;&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; and the value of the default &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, an empty &lt;code&gt;ActionMapUIResource&lt;/code&gt; is created.</source>
          <target state="translated">기본 값 경우 &lt;code&gt;&quot;AuditoryCues.actionMap&quot;&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 과 기본 값 &lt;code&gt;&quot;AuditoryCues.cueList&quot;&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 빈, &lt;code&gt;ActionMapUIResource&lt;/code&gt; 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="677e23258402aae540c1aad5d995a866d4b392f9" translate="yes" xml:space="preserve">
          <source>If the value of the system property is set to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt; is converted to a &lt;a href=&quot;../nio/file/path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; object named &lt;code&gt;npath&lt;/code&gt; after &lt;a href=&quot;../nio/file/path#normalize()&quot;&gt;&lt;code&gt;normalization&lt;/code&gt;&lt;/a&gt;. No canonicalization is performed which means the underlying file system is not accessed. If an &lt;a href=&quot;../nio/file/invalidpathexception&quot;&gt;&lt;code&gt;InvalidPathException&lt;/code&gt;&lt;/a&gt; is thrown during the conversion, this &lt;code&gt;FilePermission&lt;/code&gt; will be labeled as invalid.</source>
          <target state="translated">시스템 속성의 값이 &lt;code&gt;false&lt;/code&gt; 로 설정 되면 &lt;code&gt;path&lt;/code&gt; 는 &lt;a href=&quot;../nio/file/path#normalize()&quot;&gt; &lt;code&gt;normalization&lt;/code&gt; &lt;/a&gt; 후 &lt;code&gt;npath&lt;/code&gt; 라는 이름 의 &lt;a href=&quot;../nio/file/path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 개체 로 변환됩니다 . 정규화가 수행되지 않으므로 기본 파일 시스템에 액세스 할 수 없습니다. 는 IF &lt;a href=&quot;../nio/file/invalidpathexception&quot;&gt; &lt;code&gt;InvalidPathException&lt;/code&gt; 가&lt;/a&gt; 변환하는 동안 발생합니다,이 &lt;code&gt;FilePermission&lt;/code&gt; 를 1 개씩 무효로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9d3cf19c572562cc39301cdc9457c2f8ef2d7a44" translate="yes" xml:space="preserve">
          <source>If the value of the system property is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt; is canonicalized and stored as a String object named &lt;code&gt;cpath&lt;/code&gt;. This means a relative path is converted to an absolute path, a Windows DOS-style 8.3 path is expanded to a long path, and a symbolic link is resolved to its target, etc.</source>
          <target state="translated">시스템 속성 값이 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 &lt;code&gt;path&lt;/code&gt; 가 정규화되고 &lt;code&gt;cpath&lt;/code&gt; 라는 문자열 개체로 저장됩니다 . 이것은 상대 경로가 절대 경로로 변환되고 Windows DOS 스타일 8.3 경로가 긴 경로로 확장되고 심볼릭 링크가 대상으로 확인된다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9bbd078cde15abb1e52c1f5b43c7ab7eadad9320" translate="yes" xml:space="preserve">
          <source>If the value of this attribute specifies a date-time that is in the future, the printer should add the &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt; value of &lt;code&gt;JOB_HOLD_UNTIL_SPECIFIED&lt;/code&gt; to the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, must move the job to the &lt;code&gt;PENDING_HELD&lt;/code&gt; state, and must not schedule the job for printing until the specified date-time arrives.</source>
          <target state="translated">이 속성 값이 미래의 날짜-시간을 지정하는 경우 프린터는 &lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt; 값 &lt;code&gt;JOB_HOLD_UNTIL_SPECIFIED&lt;/code&gt; 를 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성에 추가하고 작업을 &lt;code&gt;PENDING_HELD&lt;/code&gt; 상태 로 이동해야 하며 다음 날짜 까지 인쇄 작업을 예약하지 않아야합니다. 지정된 날짜-시간이 도착합니다.</target>
        </trans-unit>
        <trans-unit id="3351a4cf5b5a7a09cdd906eb6fad0d706861c179" translate="yes" xml:space="preserve">
          <source>If the value of this attribute specifies a date-time that is in the future, the printer should add the &lt;a href=&quot;jobstatereason&quot;&gt;&lt;code&gt;JobStateReason&lt;/code&gt;&lt;/a&gt; value of JOB_HOLD_UNTIL_SPECIFIED to the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute, must move the job to the PENDING_HELD state, and must not schedule the job for printing until the specified date-time arrives.</source>
          <target state="translated">이 속성 값이 미래의 날짜 시간을 지정하는 경우 프린터는 JOB_HOLD_UNTIL_SPECIFIED 의 &lt;a href=&quot;jobstatereason&quot;&gt; &lt;code&gt;JobStateReason&lt;/code&gt; &lt;/a&gt; 값을 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성에 추가하고 작업을 PENDING_HELD 상태로 이동해야하며 인쇄 작업을 예약하지 않아야합니다. 지정된 날짜-시간이 도착합니다.</target>
        </trans-unit>
        <trans-unit id="48a7960d847d0c7897f06eee9795f35f60cafa1b" translate="yes" xml:space="preserve">
          <source>If the value property of this instance is not already set, this method dynamically finds the method with the specified methodName on this target with these arguments and calls it.</source>
          <target state="translated">이 인스턴스의 값 속성이 아직 설정되지 않은 경우이 메서드는 이러한 인수를 사용하여이 대상에서 지정된 methodName을 가진 메서드를 동적으로 찾아 호출합니다.</target>
        </trans-unit>
        <trans-unit id="fa55bedef91ce7d9c1fec0b52fe91e9615e15668" translate="yes" xml:space="preserve">
          <source>If the value property of this instance is not already set, this method dynamically finds the method with the specified methodName on this target with these arguments and calls it. The result of the method invocation is first copied into the value property of this expression and then returned as the result of &lt;code&gt;getValue&lt;/code&gt;. If the value property was already set, either by a call to &lt;code&gt;setValue&lt;/code&gt; or a previous call to &lt;code&gt;getValue&lt;/code&gt; then the value property is returned without either looking up or calling the method.</source>
          <target state="translated">이 인스턴스의 value 속성이 아직 설정되지 않은 경우이 메서드는이 인수를 사용하여이 대상에서 지정된 methodName이있는 메서드를 동적으로 찾아 호출합니다. 메소드 호출의 결과는 &lt;code&gt;getValue&lt;/code&gt; 표현식의 value 특성에 복사 된 후 getValue 의 결과로 리턴됩니다 . &lt;code&gt;setValue&lt;/code&gt; 에 대한 호출 또는 &lt;code&gt;getValue&lt;/code&gt; 에 대한 이전 호출에 의해 값 특성이 이미 설정된 경우 값 특성은 메소드를 찾거나 호출하지 않고 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a6f8f305677180b918ee9ef198861d8afd741517" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a &lt;code&gt;Collection&lt;/code&gt; of names. Each name is a &lt;code&gt;String&lt;/code&gt; or a byte array representing a distinguished name (in RFC 2253 or ASN.1 DER encoded form, respectively). Note that the &lt;code&gt;Collection&lt;/code&gt; returned may contain duplicate names.</source>
          <target state="translated">반환 값이 &lt;code&gt;null&lt;/code&gt; 가 아닌 경우는 이름 의 &lt;code&gt;Collection&lt;/code&gt; 입니다. 각 이름은 고유 이름을 나타내는 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열입니다 (각각 RFC 2253 또는 ASN.1 DER로 인코딩 된 형식). 반환 된 &lt;code&gt;Collection&lt;/code&gt; 에 중복 된 이름이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d32dd70eeac4617e75643e7232c7906050d5b2bd" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a &lt;code&gt;Collection&lt;/code&gt; with one entry for each name to be included in the pathToNames criterion. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively). There can be multiple names of the same type. Note that the &lt;code&gt;Collection&lt;/code&gt; returned may contain duplicate names (same name and name type).</source>
          <target state="translated">리턴 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 , 이는 pathToNames 기준에 포함 할 각 이름에 대해 하나의 항목 이있는 &lt;code&gt;Collection&lt;/code&gt; 입니다. 각 항목은이다 &lt;code&gt;List&lt;/code&gt; 그 첫 번째 엔트리이다 &lt;code&gt;Integer&lt;/code&gt; (이름 타입, 0-8) 및 그 두 번째 항목 인 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열 (이름, 문자열 또는 ASN.1 DER 각각, 인코딩 형태). 같은 유형의 이름이 여러 개있을 수 있습니다. 반환 된 &lt;code&gt;Collection&lt;/code&gt; 은 중복 된 이름 (동일한 이름과 이름 유형)을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d26bd3763c8755d23c2f1916d343c204ac5aaffe" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a &lt;code&gt;Collection&lt;/code&gt; with one entry for each name to be included in the subject alternative name criterion. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively). There can be multiple names of the same type. Note that the &lt;code&gt;Collection&lt;/code&gt; returned may contain duplicate names (same name and name type).</source>
          <target state="translated">리턴 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우, 주제 대체 이름 기준에 포함 할 각 이름에 대해 하나의 항목 이있는 &lt;code&gt;Collection&lt;/code&gt; 입니다. 각 항목은이다 &lt;code&gt;List&lt;/code&gt; 그 첫 번째 엔트리이다 &lt;code&gt;Integer&lt;/code&gt; (이름 타입, 0-8) 및 그 두 번째 항목 인 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열 (이름, 문자열 또는 ASN.1 DER 각각, 인코딩 형태). 같은 유형의 이름이 여러 개있을 수 있습니다. 반환 된 &lt;code&gt;Collection&lt;/code&gt; 은 중복 된 이름 (동일한 이름과 이름 유형)을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="174489e8b5c4498b78d97a375b5ea6bab3a43a71" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;#setIssuer(byte%5B%5D)&quot;&gt;&lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 X.501에 정의 된대로 단일 DER 인코딩 고유 이름을 포함하는 바이트 배열입니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#setIssuer(byte%5B%5D)&quot;&gt; &lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt; &lt;/a&gt; 설명서에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="06d0b31d05f2e63feb86aed4d9a330fd81f56f90" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;#setSubject(byte%5B%5D)&quot;&gt;&lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 X.501에 정의 된대로 단일 DER 인코딩 고유 이름을 포함하는 바이트 배열입니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;#setSubject(byte%5B%5D)&quot;&gt; &lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt; &lt;/a&gt; 에 대한 문서에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2adc8f493111a0124aaa2df328143a9d50bda6b" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt;&lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우, X.501에 정의 된 단일 DER 인코딩 식별 이름을 포함하는 바이트 배열입니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509certselector#setIssuer-byte:A-&quot;&gt; &lt;code&gt;setIssuer(byte [] issuerDN)&lt;/code&gt; &lt;/a&gt; 문서에 제공되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5bfe0070c603a52728ff84ece5362c0b7ddae9b" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a byte array containing a single DER encoded distinguished name, as defined in X.501. The ASN.1 notation for this structure is supplied in the documentation for &lt;a href=&quot;x509certselector#setSubject-byte:A-&quot;&gt;&lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우, X.501에 정의 된 단일 DER 인코딩 식별 이름을 포함하는 바이트 배열입니다. 이 구조에 대한 ASN.1 표기법은 &lt;a href=&quot;x509certselector#setSubject-byte:A-&quot;&gt; &lt;code&gt;setSubject(byte [] subjectDN)&lt;/code&gt; &lt;/a&gt; 문서에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce45de7cc21b8ac51cf0ba8fa224985e1d61a9e9" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a distinguished name, in RFC 2253 format.</source>
          <target state="translated">반환 된 값이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우는 RFC 2253 형식의 식별 명입니다.</target>
        </trans-unit>
        <trans-unit id="5b8d5b4ce751bcbd27dc2db355066e723ecb44dc" translate="yes" xml:space="preserve">
          <source>If the value returned is not &lt;code&gt;null&lt;/code&gt;, it is a unmodifiable &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;X500Principal&lt;/code&gt;s.</source>
          <target state="translated">반환 된 값이 &lt;code&gt;null&lt;/code&gt; 가 아닌 경우, 수정 불가능한 &lt;code&gt;X500Principal&lt;/code&gt; &lt;code&gt;Collection&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="6566f72aa07086a575c5856c5262b23d64492e56" translate="yes" xml:space="preserve">
          <source>If the value specified to this method is greater than the maximum length for the property the driver may either truncate the value and generate a warning or generate a &lt;code&gt;SQLClientInfoException&lt;/code&gt;. If the driver generates a &lt;code&gt;SQLClientInfoException&lt;/code&gt;, the value specified was not set on the connection.</source>
          <target state="translated">이 메서드에 지정된 값이 속성의 최대 길이보다 큰 경우 드라이버는 값을 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 경고를 생성하거나 SQLClientInfoException을 생성 할 수 있습니다. 드라이버가 &lt;code&gt;SQLClientInfoException&lt;/code&gt; 을 생성하면 지정된 값이 연결에 설정되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="751e6d0216d0808c1e052a74a279b7c68e16f026" translate="yes" xml:space="preserve">
          <source>If the value supplied is less than the current &lt;code&gt;minimum&lt;/code&gt; or greater than the current &lt;code&gt;maximum - visibleAmount&lt;/code&gt;, then either &lt;code&gt;minimum&lt;/code&gt; or &lt;code&gt;maximum - visibleAmount&lt;/code&gt; is substituted, as appropriate.</source>
          <target state="translated">주어진 값 이하이면 현재보다 &lt;code&gt;minimum&lt;/code&gt; 전류보다 큰 또는 &lt;code&gt;maximum - visibleAmount&lt;/code&gt; , 다음 중 &lt;code&gt;minimum&lt;/code&gt; 또는 &lt;code&gt;maximum - visibleAmount&lt;/code&gt; 적절히 치환된다.</target>
        </trans-unit>
        <trans-unit id="12fe3656fcca79e989b3edac8aeb79cce5390758" translate="yes" xml:space="preserve">
          <source>If the value supplied is less than the current minimum or greater than the current maximum, then one of those values is substituted, as appropriate.</source>
          <target state="translated">제공된 값이 현재 최소값보다 작거나 현재 최대 값보다 큰 경우 해당 값 중 하나가 적절하게 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="0d365fd08bc1c9a61dd923fc4e345493754eacc1" translate="yes" xml:space="preserve">
          <source>If the values for all the longhand properties that compose a particular string are the initial values, then a string consisting of all the initial values should be returned (e.g. a &lt;code&gt;border-width&lt;/code&gt; value of &quot;medium&quot; should be returned as such, not as &quot;&quot;).</source>
          <target state="translated">특정 문자열을 구성하는 모든 longhand 속성의 값이 초기 값 인 경우 모든 초기 값으로 구성된 문자열이 반환되어야합니다 (예 : &lt;code&gt;border-width&lt;/code&gt; 값 &quot;medium&quot;은 &quot;가 아닌 그대로 반환되어야 함&quot;). &quot;).</target>
        </trans-unit>
        <trans-unit id="ab17023ef639bf29e49c32902183016851239f29" translate="yes" xml:space="preserve">
          <source>If the values of the width and height arguments are both &lt;code&gt;-1&lt;/code&gt;, this method prepares the image for rendering on the default screen; otherwise, this method prepares an image for rendering on the default screen at the specified width and height.</source>
          <target state="translated">너비 및 높이 인수의 값이 모두 &lt;code&gt;-1&lt;/code&gt; 이면이 메서드는 기본 화면에서 렌더링 할 이미지를 준비합니다. 그렇지 않으면이 메서드는 지정된 너비와 높이로 기본 화면에 렌더링 할 이미지를 준비합니다.</target>
        </trans-unit>
        <trans-unit id="062fc19b785fff8baef488c9df986bc3034c7cd8" translate="yes" xml:space="preserve">
          <source>If the values of the width and height arguments are both &lt;code&gt;-1&lt;/code&gt;, this method returns the construction status of a screen representation of the specified image in this toolkit. Otherwise, this method returns the construction status of a scaled representation of the image at the specified width and height.</source>
          <target state="translated">너비 및 높이 인수의 값이 모두 &lt;code&gt;-1&lt;/code&gt; 이면이 메서드는이 툴킷에서 지정된 이미지의 화면 표현 구성 상태를 반환합니다. 그렇지 않으면이 메서드는 지정된 너비와 높이에서 이미지의 크기가 조정 된 표현의 구성 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31962e30b961885e15e6a668db59bf31ea069bcf" translate="yes" xml:space="preserve">
          <source>If the variable type is &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; then atomic update access modes compare values using their bitwise representation (see &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt;&lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt;&lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt;&lt;/a&gt;, respectively).</source>
          <target state="translated">변수 유형이 &lt;code&gt;float&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 인 경우 원자 업데이트 액세스 모드는 비트 표현을 사용하여 값을 비교합니다 &lt;a href=&quot;../double#doubleToRawLongBits(double)&quot;&gt; &lt;code&gt;Double.doubleToRawLongBits(double)&lt;/code&gt; &lt;/a&gt; 각각 &lt;a href=&quot;../float#floatToRawIntBits(float)&quot;&gt; &lt;code&gt;Float.floatToRawIntBits(float)&lt;/code&gt; &lt;/a&gt; 및 Double.doubleToRawLongBits (double) 참조 ).</target>
        </trans-unit>
        <trans-unit id="f203f0949cc7b918d1e2d216ac08216e57175fa4" translate="yes" xml:space="preserve">
          <source>If the variable type is the non-integral &lt;code&gt;boolean&lt;/code&gt; type then a logical AND is performed instead of a bitwise AND.</source>
          <target state="translated">변수 유형이 정수가 아닌 &lt;code&gt;boolean&lt;/code&gt; 유형이면 비트 AND 대신 논리 AND가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="317918488b3cba82b42ec854abe818df328b4867" translate="yes" xml:space="preserve">
          <source>If the variable type is the non-integral &lt;code&gt;boolean&lt;/code&gt; type then a logical OR is performed instead of a bitwise OR.</source>
          <target state="translated">변수 유형이 정수가 아닌 &lt;code&gt;boolean&lt;/code&gt; 유형이면 비트 OR 대신 논리 OR이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8f69ebca5baf035e2d13b6c96c1a80a913bdc9ac" translate="yes" xml:space="preserve">
          <source>If the variable type is the non-integral &lt;code&gt;boolean&lt;/code&gt; type then a logical XOR is performed instead of a bitwise XOR.</source>
          <target state="translated">변수 유형이 정수가 아닌 &lt;code&gt;boolean&lt;/code&gt; 유형이면 비트 단위 XOR 대신 논리 XOR이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="49f80850c03dac4ccd69fe704a52eb909e453d10" translate="yes" xml:space="preserve">
          <source>If the view component of this layer implements &lt;a href=&quot;scrollable&quot;&gt;&lt;code&gt;Scrollable&lt;/code&gt;&lt;/a&gt;, this method delegates its implementation to the view component.</source>
          <target state="translated">이 레이어의 뷰 구성 요소가 &lt;a href=&quot;scrollable&quot;&gt; &lt;code&gt;Scrollable&lt;/code&gt; 을&lt;/a&gt; 구현하는 경우이 메서드는 해당 구현을 뷰 구성 요소에 위임합니다.</target>
        </trans-unit>
        <trans-unit id="e6056598d7fc6e1f9bab9fde45ff4e85d32b9431" translate="yes" xml:space="preserve">
          <source>If the view implements &lt;code&gt;Scrollable&lt;/code&gt; a combination of &lt;code&gt;getPreferredScrollableViewportSize&lt;/code&gt;, &lt;code&gt;getScrollableTracksViewportWidth&lt;/code&gt; and &lt;code&gt;getScrollableTracksViewportHeight&lt;/code&gt;is used, otherwise</source>
          <target state="translated">보기가 &lt;code&gt;Scrollable&lt;/code&gt; 을 구현 하는 경우 &lt;code&gt;getPreferredScrollableViewportSize&lt;/code&gt; , &lt;code&gt;getScrollableTracksViewportWidth&lt;/code&gt; 및 &lt;code&gt;getScrollableTracksViewportHeight&lt;/code&gt; 가 사용됩니다. 그렇지 않으면</target>
        </trans-unit>
        <trans-unit id="6e8e8c7689ef325d78e889713b9aed6e71529da2" translate="yes" xml:space="preserve">
          <source>If the view's size hasn't been explicitly set, return the preferred size, otherwise return the view's current size.</source>
          <target state="translated">보기의 크기가 명시 적으로 설정되지 않은 경우 선호하는 크기를 반환하고 그렇지 않으면보기의 현재 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15a76a9f42e8b551caa02ec901e3cd32d7b99d18" translate="yes" xml:space="preserve">
          <source>If the view's size hasn't been explicitly set, return the preferred size, otherwise return the view's current size. If there is no view, return 0,0.</source>
          <target state="translated">보기의 크기가 명시 적으로 설정되지 않은 경우 선호하는 크기를 반환하고 그렇지 않으면보기의 현재 크기를 반환합니다. 보기가 없으면 0,0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80fb55d57fa2a3783b757491a0aafb1381a47c58" translate="yes" xml:space="preserve">
          <source>If the viewport is obscured by an ancestor, stop and repaint the whole viewport.</source>
          <target state="translated">If the viewport is obscured by an ancestor, stop and repaint the whole viewport.</target>
        </trans-unit>
        <trans-unit id="ac85a1b5c14ea33446482faac76a04c937a42f22" translate="yes" xml:space="preserve">
          <source>If the visible amount supplied is less than &lt;code&gt;one&lt;/code&gt; or greater than the current &lt;code&gt;maximum - minimum&lt;/code&gt;, then either &lt;code&gt;one&lt;/code&gt; or &lt;code&gt;maximum - minimum&lt;/code&gt; is substituted, as appropriate.</source>
          <target state="translated">If the visible amount supplied is less than &lt;code&gt;one&lt;/code&gt; or greater than the current &lt;code&gt;maximum - minimum&lt;/code&gt; , then either &lt;code&gt;one&lt;/code&gt; or &lt;code&gt;maximum - minimum&lt;/code&gt; is substituted, as appropriate.</target>
        </trans-unit>
        <trans-unit id="c974944a24bc22bfa54c303b025a9e590bd03f10" translate="yes" xml:space="preserve">
          <source>If the visible row count is &amp;lt;= 0, the preferred height is dictated by the number of columns, which will be as many as can fit in the width of the &lt;code&gt;JList&lt;/code&gt; (width / max cell width), with at least one column. The preferred height then becomes the model size / number of columns * maximum cell height. Max cell height is either the fixed cell height, or is determined by iterating through all the cells to find the maximum height from the ListCellRenderer.</source>
          <target state="translated">If the visible row count is &amp;lt;= 0, the preferred height is dictated by the number of columns, which will be as many as can fit in the width of the &lt;code&gt;JList&lt;/code&gt; (width / max cell width), with at least one column. The preferred height then becomes the model size / number of columns * maximum cell height. Max cell height is either the fixed cell height, or is determined by iterating through all the cells to find the maximum height from the ListCellRenderer.</target>
        </trans-unit>
        <trans-unit id="5f5fba29ff007e49901e18f55046f0713af8526d" translate="yes" xml:space="preserve">
          <source>If the visible row count is greater than zero, the preferredHeight is the maximum cell height * adjustedRowCount. Where visibleRowCount is used to determine the number of columns. Because this lays out horizontally the number of rows is then determined from the column count. For example, lets say you have a model with 10 items and the visible row count is 8. The number of columns needed to display this is 2, but you no longer need 8 rows to display this, you only need 5, thus the adjustedRowCount is 5.</source>
          <target state="translated">If the visible row count is greater than zero, the preferredHeight is the maximum cell height * adjustedRowCount. Where visibleRowCount is used to determine the number of columns. Because this lays out horizontally the number of rows is then determined from the column count. For example, lets say you have a model with 10 items and the visible row count is 8. The number of columns needed to display this is 2, but you no longer need 8 rows to display this, you only need 5, thus the adjustedRowCount is 5.</target>
        </trans-unit>
        <trans-unit id="af8f2aafa2c4ff83395f11d4e625de90952dbebf" translate="yes" xml:space="preserve">
          <source>If the visible row count is greater than zero, the preferredHeight is the maximum cell height * visibleRowCount. If the visible row count is &amp;lt;= 0, the preferred height is either the current height of the list, or the maximum cell height, whichever is bigger. The preferred width is than the maximum cell width * number of columns needed. Where the number of columns needs is list.height / max cell height. Max cell height is either the fixed cell height, or is determined by iterating through all the cells to find the maximum height from the ListCellRenderer.</source>
          <target state="translated">If the visible row count is greater than zero, the preferredHeight is the maximum cell height * visibleRowCount. If the visible row count is &amp;lt;= 0, the preferred height is either the current height of the list, or the maximum cell height, whichever is bigger. The preferred width is than the maximum cell width * number of columns needed. Where the number of columns needs is list.height / max cell height. Max cell height is either the fixed cell height, or is determined by iterating through all the cells to find the maximum height from the ListCellRenderer.</target>
        </trans-unit>
        <trans-unit id="bde030a57b155127406abe290ea916c308394ff9" translate="yes" xml:space="preserve">
          <source>If the voice is not currently processing a MIDI note, it is considered inactive. A voice is inactive when it has been given no note-on commands, or when every note-on command received has been terminated by a corresponding note-off (or by an &quot;all notes off&quot; message). For example, this happens when a synthesizer capable of playing 16 simultaneous notes is told to play a four-note chord; only four voices are active in this case (assuming no earlier notes are still playing). Usually, a voice whose status is reported as active is producing audible sound, but this is not always true; it depends on the details of the instrument (that is, the synthesis algorithm) and how long the note has been going on. For example, a voice may be synthesizing the sound of a single hand-clap. Because this sound dies away so quickly, it may become inaudible before a note-off message is received. In such a situation, the voice is still considered active even though no sound is currently being produced.</source>
          <target state="translated">음성이 현재 MIDI 음표를 처리하지 않으면 비활성 상태로 간주됩니다. 음성 명령에 메모 명령이 없거나 수신 된 모든 메모 명령이 해당 메모에 의해 (또는 &quot;모든 메모 꺼짐&quot;메시지에 의해 종료 된 경우) 음성이 비활성화됩니다. 예를 들어, 16 개의 동시 음을 연주 할 수있는 신시사이저에 4 음 코드를 연주하도록 지시 할 때 발생합니다. 이 경우 4 개의 음색 만 활성화됩니다 (이전의 음표가 여전히 재생되지 않는다고 가정). 일반적으로 상태가 활성으로보고 된 음성은 소리를 내고 있지만 항상 그런 것은 아닙니다. 악기의 세부 사항 (즉, 합성 알고리즘)과 음이 얼마나 오래 지속되었는지에 따라 다릅니다. 예를 들어, 음성은 단일 핸드 박수 소리를 합성 할 수 있습니다. 이 소리가 너무 빨리 사라 지므로메모 메시지가 수신되기 전에들을 수 없습니다. 이러한 상황에서 소리가 현재 생성되지 않더라도 음성은 여전히 ​​활성 상태로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f1b51ec0e550c0c529f4869085fbe1c6f15be1a3" translate="yes" xml:space="preserve">
          <source>If the waiting thread wakes up without dispatching the event, the &lt;code&gt;isDispatched()&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt;, and the &lt;code&gt;while&lt;/code&gt; loop executes once more, thus, causing the awakened thread to revert to the waiting mode.</source>
          <target state="translated">If the waiting thread wakes up without dispatching the event, the &lt;code&gt;isDispatched()&lt;/code&gt; method returns &lt;code&gt;false&lt;/code&gt; , and the &lt;code&gt;while&lt;/code&gt; loop executes once more, thus, causing the awakened thread to revert to the waiting mode.</target>
        </trans-unit>
        <trans-unit id="eea99a16ca9472ba7577a6286f0c99175c71b6e9" translate="yes" xml:space="preserve">
          <source>If the window and/or its owner are not displayable yet, both of them are made displayable before calculating the preferred size. The Window is validated after its size is being calculated.</source>
          <target state="translated">If the window and/or its owner are not displayable yet, both of them are made displayable before calculating the preferred size. The Window is validated after its size is being calculated.</target>
        </trans-unit>
        <trans-unit id="99602aee7fccb8c26815c6abd3610a017f32754c" translate="yes" xml:space="preserve">
          <source>If the window is secure, then &lt;code&gt;getWarningString&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;. If the window is insecure, this method checks for the system property &lt;code&gt;awt.appletWarning&lt;/code&gt; and returns the string value of that property.</source>
          <target state="translated">If the window is secure, then &lt;code&gt;getWarningString&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt; . If the window is insecure, this method checks for the system property &lt;code&gt;awt.appletWarning&lt;/code&gt; and returns the string value of that property.</target>
        </trans-unit>
        <trans-unit id="5a7732dc7a32e7541fda0d87428f498a5f17066e" translate="yes" xml:space="preserve">
          <source>If the windowing system supports the &lt;a href=&quot;graphicsdevice.windowtranslucency#PERPIXEL_TRANSLUCENT&quot;&gt;&lt;code&gt;PERPIXEL_TRANSLUCENT&lt;/code&gt;&lt;/a&gt; translucency, the alpha component of the given background color may effect the mode of operation for this window: it indicates whether this window must be opaque (alpha equals &lt;code&gt;1.0f&lt;/code&gt;) or per-pixel translucent (alpha is less than &lt;code&gt;1.0f&lt;/code&gt;). If the given background color is &lt;code&gt;null&lt;/code&gt;, the window is considered completely opaque.</source>
          <target state="translated">If the windowing system supports the &lt;a href=&quot;graphicsdevice.windowtranslucency#PERPIXEL_TRANSLUCENT&quot;&gt; &lt;code&gt;PERPIXEL_TRANSLUCENT&lt;/code&gt; &lt;/a&gt; translucency, the alpha component of the given background color may effect the mode of operation for this window: it indicates whether this window must be opaque (alpha equals &lt;code&gt;1.0f&lt;/code&gt; ) or per-pixel translucent (alpha is less than &lt;code&gt;1.0f&lt;/code&gt; ). If the given background color is &lt;code&gt;null&lt;/code&gt; , the window is considered completely opaque.</target>
        </trans-unit>
        <trans-unit id="653f1f40cfb615ca17661dd80259d388f697bee1" translate="yes" xml:space="preserve">
          <source>If the write lock is acquired by the current thread then the lock hold count is set to one.</source>
          <target state="translated">현재 스레드가 쓰기 잠금을 획득하면 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0805140ae31a0f4050f9a4cfea06b4f470819eca" translate="yes" xml:space="preserve">
          <source>If the write lock is acquired then the value &lt;code&gt;true&lt;/code&gt; is returned and the write lock hold count is set to one.</source>
          <target state="translated">쓰기 잠금이 획득되면 &lt;code&gt;true&lt;/code&gt; 값 이 리턴되고 쓰기 잠금 유지 계수는 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a07048d034065274e4ede5c8a84bad27f47aabea" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:</source>
          <target state="translated">쓰기 잠금이 다른 스레드에 의해 유지되면 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하게되고 다음 세 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="74ef7c44b070eb1cc369e6589e8a1122f0468708" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:</source>
          <target state="translated">쓰기 잠금이 다른 스레드에 의해 유지되면 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하게되고 다음 두 가지 중 하나가 발생할 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="4fbef50e47f6976d0537a04edb35c78320ba5006" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the read lock has been acquired.</source>
          <target state="translated">쓰기 잠금이 다른 스레드에 의해 유지되면 현재 스레드는 스레드 스케줄링을 위해 사용 불가능하게되고 읽기 잠금이 획득 될 때까지 휴면 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="30ab94fb63654ae631cd1d744ae39fbebb43dde7" translate="yes" xml:space="preserve">
          <source>If the write lock is held by another thread then this method will return immediately with the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">다른 스레드가 쓰기 잠금을 보유한 경우이 메소드는 값 &lt;code&gt;false&lt;/code&gt; 와 함께 즉시 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7ef816b7e6153a6a58cc075b78ddfa153cbea13c" translate="yes" xml:space="preserve">
          <source>If the writer only offers a single, mandatory form of compression, it is not necessary to provide any named compression types. Named compression types should only be used where the user is able to make a meaningful choice between different schemes.</source>
          <target state="translated">기록기가 단일의 필수 압축 형식 만 제공하는 경우 명명 된 압축 유형을 제공 할 필요가 없습니다. 명명 된 압축 유형은 사용자가 다른 체계 중에서 의미있는 선택을 할 수있는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d7d2702baf6e372c2fd974b9ceb0e8765e0573d" translate="yes" xml:space="preserve">
          <source>If the years field is present, return its value as an &lt;code&gt;int&lt;/code&gt;, else return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">If the years field is present, return its value as an &lt;code&gt;int&lt;/code&gt; , else return &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb2436b74f4b1b03e972c41f1699a7b257b5b16" translate="yes" xml:space="preserve">
          <source>If the zone ID consists of a single letter, the zone ID is invalid and &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">영역 ID가 단일 문자로 구성된 경우 영역 ID가 유효하지 않고 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="06d35c94a78d00be0bce80775b09f94dc2815e57" translate="yes" xml:space="preserve">
          <source>If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a &lt;code&gt;ZoneId&lt;/code&gt; with the same ID and rules equivalent to &lt;code&gt;ZoneOffset.UTC&lt;/code&gt;.</source>
          <target state="translated">영역 ID가 'GMT', 'UTC'또는 'UT'인 경우 결과는 동일한 ID 및 규칙 이 &lt;code&gt;ZoneId&lt;/code&gt; 와 동일한 &lt;code&gt;ZoneOffset.UTC&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7be309d5b31d6d9fd94ee00c0bd12eacb646dab8" translate="yes" xml:space="preserve">
          <source>If the zone ID equals 'Z', the result is &lt;code&gt;ZoneOffset.UTC&lt;/code&gt;.</source>
          <target state="translated">영역 ID가 'Z'인 경우 결과는 &lt;code&gt;ZoneOffset.UTC&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="87e6092693d13cc8dfc7ff32db6b3e49ec91630a" translate="yes" xml:space="preserve">
          <source>If the zone ID is a &lt;a href=&quot;zoneoffset&quot;&gt;&lt;code&gt;ZoneOffset&lt;/code&gt;&lt;/a&gt;, then the result always has a time of midnight.</source>
          <target state="translated">영역 ID가 &lt;a href=&quot;zoneoffset&quot;&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; &lt;/a&gt; 이면 결과는 항상 자정 시간입니다.</target>
        </trans-unit>
        <trans-unit id="4b48da9c9e601217a4f5ae92f654428afda6e1aa" translate="yes" xml:space="preserve">
          <source>If the zone ID is not available or is a &lt;code&gt;ZoneOffset&lt;/code&gt; then the format is complete.</source>
          <target state="translated">영역 ID를 사용할 수 없거나 &lt;code&gt;ZoneOffset&lt;/code&gt; 인 경우 형식이 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb96bf777d809e7b3490ab730d9c70ee13ec5673" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with '+' or '-', the ID is parsed as a &lt;code&gt;ZoneOffset&lt;/code&gt; using &lt;a href=&quot;zoneoffset#of(java.lang.String)&quot;&gt;&lt;code&gt;ZoneOffset.of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If the zone ID starts with '+' or '-', the ID is parsed as a &lt;code&gt;ZoneOffset&lt;/code&gt; using &lt;a href=&quot;zoneoffset#of(java.lang.String)&quot;&gt; &lt;code&gt;ZoneOffset.of(String)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="87677aa24c82d7da48f53ccb0c5b3d24a805cbe9" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with '+' or '-', the ID is parsed as a &lt;code&gt;ZoneOffset&lt;/code&gt; using &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt;&lt;code&gt;ZoneOffset.of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">'-'영역 ID는 '+'또는 시작하는 경우,이 ID로서 해석된다 &lt;code&gt;ZoneOffset&lt;/code&gt; 하여 &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt; &lt;code&gt;ZoneOffset.of(String)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="602223c8f8d238b617198cc90ea4b499d3a80171" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-' then the ID is a prefixed offset-based ID. The ID is split in two, with a two or three letter prefix and a suffix starting with the sign. The suffix is parsed as a &lt;a href=&quot;zoneoffset#of(java.lang.String)&quot;&gt;&lt;code&gt;ZoneOffset&lt;/code&gt;&lt;/a&gt;. The result will be a &lt;code&gt;ZoneId&lt;/code&gt; with the specified UTC/GMT/UT prefix and the normalized offset ID as per &lt;a href=&quot;zoneoffset#getId()&quot;&gt;&lt;code&gt;ZoneOffset.getId()&lt;/code&gt;&lt;/a&gt;. The rules of the returned &lt;code&gt;ZoneId&lt;/code&gt; will be equivalent to the parsed &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-' then the ID is a prefixed offset-based ID. The ID is split in two, with a two or three letter prefix and a suffix starting with the sign. The suffix is parsed as a &lt;a href=&quot;zoneoffset#of(java.lang.String)&quot;&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; &lt;/a&gt;. The result will be a &lt;code&gt;ZoneId&lt;/code&gt; with the specified UTC/GMT/UT prefix and the normalized offset ID as per &lt;a href=&quot;zoneoffset#getId()&quot;&gt; &lt;code&gt;ZoneOffset.getId()&lt;/code&gt; &lt;/a&gt;. The rules of the returned &lt;code&gt;ZoneId&lt;/code&gt; will be equivalent to the parsed &lt;code&gt;ZoneOffset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1780773eff7ca92ecd4ba03a3e8ea655fd0b8589" translate="yes" xml:space="preserve">
          <source>If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-' then the ID is a prefixed offset-based ID. The ID is split in two, with a two or three letter prefix and a suffix starting with the sign. The suffix is parsed as a &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt;&lt;code&gt;ZoneOffset&lt;/code&gt;&lt;/a&gt;. The result will be a &lt;code&gt;ZoneId&lt;/code&gt; with the specified UTC/GMT/UT prefix and the normalized offset ID as per &lt;a href=&quot;zoneoffset#getId--&quot;&gt;&lt;code&gt;ZoneOffset.getId()&lt;/code&gt;&lt;/a&gt;. The rules of the returned &lt;code&gt;ZoneId&lt;/code&gt; will be equivalent to the parsed &lt;code&gt;ZoneOffset&lt;/code&gt;.</source>
          <target state="translated">영역 ID가 'UTC +', 'UTC-', 'GMT +', 'GMT-', 'UT +'또는 'UT-'로 시작하면 ID는 접두사 오프셋 기반 ID입니다. ID는 2 개 또는 3 개의 문자 접두사와 부호로 시작하는 접미사와 함께 2 개로 분할됩니다. 접미사는 &lt;a href=&quot;zoneoffset#of-java.lang.String-&quot;&gt; &lt;code&gt;ZoneOffset&lt;/code&gt; 으로&lt;/a&gt; 구문 분석됩니다 . 결과는 것이다 &lt;code&gt;ZoneId&lt;/code&gt; 따라 지정된 UTC / GMT / UT 프리픽스 및 정규화 옵셋 ID와 &lt;a href=&quot;zoneoffset#getId--&quot;&gt; &lt;code&gt;ZoneOffset.getId()&lt;/code&gt; &lt;/a&gt; . 반환 된 &lt;code&gt;ZoneId&lt;/code&gt; 의 규칙은 구문 분석 된 &lt;code&gt;ZoneOffset&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="41b8bc898e51c548630ae4313953f5a0179fbf8d" translate="yes" xml:space="preserve">
          <source>If the zone cannot be parsed then an exception is thrown unless the section of the formatter is optional.</source>
          <target state="translated">영역을 구문 분석 할 수없는 경우 포맷터 섹션이 선택 사항이 아닌 한 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="716de69875ef09bdf51d065ceec30a6b7a11919e" translate="yes" xml:space="preserve">
          <source>If the zone defines daylight savings into the future, then the list will normally be of size two and hold information about entering and exiting daylight savings. If the zone does not have daylight savings, or information about future changes is uncertain, then the list will be empty.</source>
          <target state="translated">영역이 일광 절약 시간을 미래로 정의하는 경우 일반적으로 목록의 크기는 2이며 일광 절약 입력 및 종료에 대한 정보를 보유합니다. 영역에 일광 절약 시간이 없거나 향후 변경에 대한 정보가 확실하지 않은 경우 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a223a21923ebbbeb7ae1d7b22472f2e489ded7a7" translate="yes" xml:space="preserve">
          <source>If there are any calendar fields whose values haven't been set in the selected field combination, &lt;code&gt;Calendar&lt;/code&gt; uses their default values. The default value of each field may vary by concrete calendar systems. For example, in &lt;code&gt;GregorianCalendar&lt;/code&gt;, the default of a field is the same as that of the start of the Epoch: i.e., &lt;code&gt;YEAR = 1970&lt;/code&gt;, &lt;code&gt;MONTH =
 JANUARY&lt;/code&gt;, &lt;code&gt;DAY_OF_MONTH = 1&lt;/code&gt;, etc.</source>
          <target state="translated">그 선택한 필드의 편성으로 값이 설정되어 있지 않은 달력 필드가있는 경우, &lt;code&gt;Calendar&lt;/code&gt; 기본 값을 사용합니다. 각 필드의 기본값은 구체적인 달력 시스템에 따라 달라질 수 있습니다. 예를 들어, &lt;code&gt;GregorianCalendar&lt;/code&gt; 에서 필드의 기본값은 Epoch의 시작과 동일합니다 (예 : &lt;code&gt;YEAR = 1970&lt;/code&gt; , &lt;code&gt;MONTH = JANUARY&lt;/code&gt; , &lt;code&gt;DAY_OF_MONTH = 1&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="2f3668df86278c8a1e88d94210aa98ee6165c605" translate="yes" xml:space="preserve">
          <source>If there are any previously existing preferences that conflict with the preference being set here, then the GSSManager should ignore this request.</source>
          <target state="translated">If there are any previously existing preferences that conflict with the preference being set here, then the GSSManager should ignore this request.</target>
        </trans-unit>
        <trans-unit id="74ff37baa980c0a61132f301ce21852b4bc130d4" translate="yes" xml:space="preserve">
          <source>If there are bytes following the module descriptor then it is implementation specific as to whether those bytes are read, ignored, or reported as an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt;. If this method fails with an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; or &lt;code&gt;
 IOException&lt;/code&gt; then it may do so after some, but not all, bytes have been read from the input stream. It is strongly recommended that the stream be promptly closed and discarded if an exception occurs.</source>
          <target state="translated">If there are bytes following the module descriptor then it is implementation specific as to whether those bytes are read, ignored, or reported as an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; . If this method fails with an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; or &lt;code&gt; IOException&lt;/code&gt; then it may do so after some, but not all, bytes have been read from the input stream. It is strongly recommended that the stream be promptly closed and discarded if an exception occurs.</target>
        </trans-unit>
        <trans-unit id="92b113a4ce2494a131747fc911a67441d1d05a57" translate="yes" xml:space="preserve">
          <source>If there are bytes following the module descriptor then it is implementation specific as to whether those bytes are read, ignored, or reported as an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt;. If this method fails with an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; then it may do so after some, but not all, bytes have been read.</source>
          <target state="translated">If there are bytes following the module descriptor then it is implementation specific as to whether those bytes are read, ignored, or reported as an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; . If this method fails with an &lt;code&gt;InvalidModuleDescriptorException&lt;/code&gt; then it may do so after some, but not all, bytes have been read.</target>
        </trans-unit>
        <trans-unit id="e1f64fb5716e07724c0a7d48c0a02647c58da231" translate="yes" xml:space="preserve">
          <source>If there are conflicts or overlaps between the information provided by different &lt;code&gt;BeanInfo&lt;/code&gt; objects, the current &lt;code&gt;BeanInfo&lt;/code&gt; object takes priority over the additional &lt;code&gt;BeanInfo&lt;/code&gt; objects. Array elements with higher indices take priority over the elements with lower indices.</source>
          <target state="translated">다른 &lt;code&gt;BeanInfo&lt;/code&gt; 객체가 제공하는 정보간에 충돌이 있거나 겹치는 경우 현재 &lt;code&gt;BeanInfo&lt;/code&gt; 객체가 추가 &lt;code&gt;BeanInfo&lt;/code&gt; 객체 보다 우선 합니다. 지수가 높은 배열 요소는 지수가 낮은 요소보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="530a00d062bd6f003dc671b04ddaa979158f274f" translate="yes" xml:space="preserve">
          <source>If there are different resources for different countries, you can make specializations: for example, &quot;MyResources_de_CH&quot; contains objects for the German language (de) in Switzerland (CH). If you want to only modify some of the resources in the specialization, you can do so.</source>
          <target state="translated">국가별로 다른 리소스가있는 경우 전문화를 수행 할 수 있습니다. 예를 들어 &quot;MyResources_de_CH&quot;에는 스위스 (CH)의 독일어 (de)에 대한 개체가 포함되어 있습니다. 전문화 과정에서 일부 리소스 만 수정하려는 경우 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43c5f52ef558689fc38e846808ccf12921cc7008" translate="yes" xml:space="preserve">
          <source>If there are mnemonic names to be associated with the legal data values for the tag, &lt;a href=&quot;#addValueName(int,java.lang.String)&quot;&gt;&lt;code&gt;addValueName()&lt;/code&gt;&lt;/a&gt; should be called on the new instance for each name. Mnemonic names apply only to tags which have integral data type.</source>
          <target state="translated">If there are mnemonic names to be associated with the legal data values for the tag, &lt;a href=&quot;#addValueName(int,java.lang.String)&quot;&gt; &lt;code&gt;addValueName()&lt;/code&gt; &lt;/a&gt; should be called on the new instance for each name. Mnemonic names apply only to tags which have integral data type.</target>
        </trans-unit>
        <trans-unit id="0a003779b8a649ef8cb40c3f51dd00ab52590b8c" translate="yes" xml:space="preserve">
          <source>If there are more arguments than format specifiers, the extra arguments are ignored.</source>
          <target state="translated">형식 지정자보다 많은 인수가 있으면 추가 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="af82728ab0f3eefda7b3d99ca5d34ea41f8be9f9" translate="yes" xml:space="preserve">
          <source>If there are more than one node in the actual result, the single node returned might not be the first in document order.</source>
          <target state="translated">실제 결과에 둘 이상의 노드가있는 경우 반환 된 단일 노드가 문서 순서에서 첫 번째 노드가 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3bf8d2720860eb61e319f9623619d679a6a03d2" translate="yes" xml:space="preserve">
          <source>If there are more than one node in the actual result, the single node returned will be the first in document order.</source>
          <target state="translated">실제 결과에 둘 이상의 노드가있는 경우 반환 된 단일 노드가 문서 순서에서 첫 번째 노드가됩니다.</target>
        </trans-unit>
        <trans-unit id="deb195b2b9fae2539cd1155fb241509f69b8a781" translate="yes" xml:space="preserve">
          <source>If there are multiple compression types but none has been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.</source>
          <target state="translated">여러 압축 유형이 있지만 설정되지 않은 경우 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="768dcb3e70295dbb108fd5dd725293766667ea22" translate="yes" xml:space="preserve">
          <source>If there are multiple runs of text, information about the runs can be accessed by indexing to get the start, limit, and level of a run. The level represents both the direction and the 'nesting level' of a directional run. Odd levels are right-to-left, while even levels are left-to-right. So for example level 0 represents left-to-right text, while level 1 represents right-to-left text, and level 2 represents left-to-right text embedded in a right-to-left run.</source>
          <target state="translated">여러 개의 텍스트 실행이있는 경우 인덱스를 통해 실행에 대한 정보에 액세스하여 실행의 시작, 한계 및 레벨을 얻을 수 있습니다. 레벨은 방향 달리기의 방향과 '중첩 레벨'을 모두 나타냅니다. 홀수 레벨은 오른쪽에서 왼쪽이며, 짝수 레벨은 왼쪽에서 오른쪽입니다. 예를 들어, 레벨 0은 왼쪽에서 오른쪽으로 텍스트를 나타내고, 레벨 1은 오른쪽에서 왼쪽으로 텍스트를 나타내며, 레벨 2는 오른쪽에서 왼쪽으로 실행에 포함 된 왼쪽에서 오른쪽으로 텍스트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="95fa2c7c9d03744e4ab294e05332429d827cf658" translate="yes" xml:space="preserve">
          <source>If there are multiple text directions present in the associated document, a flag indicating the caret bias will be rendered. This will occur only if the associated document is a subclass of AbstractDocument and there are multiple bidi levels present in the bidi element structure (i.e. the text has multiple directions associated with it).</source>
          <target state="translated">If there are multiple text directions present in the associated document, a flag indicating the caret bias will be rendered. This will occur only if the associated document is a subclass of AbstractDocument and there are multiple bidi levels present in the bidi element structure (i.e. the text has multiple directions associated with it).</target>
        </trans-unit>
        <trans-unit id="8a6ca385a1344a83e96b59363dfacd7ef2452f9f" translate="yes" xml:space="preserve">
          <source>If there are native methods in the call stack at the time of the exception, there are important restrictions to note about the returned catch location. In such cases, it is not possible to predict whether an exception will be handled by some native method on the call stack. Thus, it is possible that exceptions considered uncaught here will, in fact, be handled by a native method and not cause termination of the target VM. Furthermore, it cannot be assumed that the catch location returned here will ever be reached by the throwing thread. If there is a native frame between the current location and the catch location, the exception might be handled and cleared in that native method instead.</source>
          <target state="translated">예외 시점에 호출 스택에 네이티브 메서드가있는 경우 반환 된 catch 위치에 대해 유의해야 할 중요한 제한 사항이 있습니다. 이러한 경우 호출 스택의 일부 네이티브 메서드에서 예외를 처리할지 여부를 예측할 수 없습니다. 따라서 여기서 포착되지 않은 것으로 간주되는 예외는 실제로 네이티브 메서드에 의해 처리되고 대상 VM의 종료를 유발하지 않을 수 있습니다. 또한 여기에서 반환 된 캐치 위치는 던지는 스레드에 의해 도달 될 것이라고 가정 할 수 없습니다. 현재 위치와 catch 위치 사이에 네이티브 프레임이있는 경우 해당 네이티브 메서드에서 예외가 처리되고 지워질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91aa0c8a84bbac8b5804b3100754fe9bb7d1dcbe" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, and the socket has not been closed using &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/inputstream#available()&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">If there are no bytes buffered on the socket, and the socket has not been closed using &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;, then &lt;a href=&quot;../io/inputstream#available()&quot;&gt; &lt;code&gt;available&lt;/code&gt; &lt;/a&gt; will return &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3fd8782c948e6644afcfe2c7b88c23640ca646b" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, and the socket has not been closed using &lt;a href=&quot;socket#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;../io/inputstream#available--&quot;&gt;&lt;code&gt;available&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">소켓에 버퍼링 된 바이트가없고 &lt;a href=&quot;socket#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; 를&lt;/a&gt; 사용하여 소켓을 닫지 않은 경우 &lt;a href=&quot;../io/inputstream#available--&quot;&gt; &lt;code&gt;available&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="899f5685138aa94e92de9d02a27528d96a112601" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, or all buffered bytes have been consumed by &lt;a href=&quot;../io/inputstream#read()&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, then all subsequent calls to &lt;a href=&quot;../io/inputstream#read()&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; will throw an &lt;a href=&quot;../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If there are no bytes buffered on the socket, or all buffered bytes have been consumed by &lt;a href=&quot;../io/inputstream#read()&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;, then all subsequent calls to &lt;a href=&quot;../io/inputstream#read()&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; will throw an &lt;a href=&quot;../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="70808ff13ea15a635fe9933aa430b40622465ff0" translate="yes" xml:space="preserve">
          <source>If there are no bytes buffered on the socket, or all buffered bytes have been consumed by &lt;a href=&quot;../io/inputstream#read--&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt;, then all subsequent calls to &lt;a href=&quot;../io/inputstream#read--&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; will throw an &lt;a href=&quot;../io/ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소켓에 버퍼링 된 바이트가 없거나 모든 버퍼링 된 바이트가 &lt;a href=&quot;../io/inputstream#read--&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 에 의해 소비 된 경우 , 모든 후속 &lt;a href=&quot;../io/inputstream#read--&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; 호출 은 &lt;a href=&quot;../io/ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="d97fea5e3b07fef354727bb8ea01358071cedc12" translate="yes" xml:space="preserve">
          <source>If there are no fields in the descriptor, then an empty String is returned.</source>
          <target state="translated">디스크립터에 필드가 없으면 빈 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a5d1f0a062afbc6cda49f87f90c8e9a1acb2dd5c" translate="yes" xml:space="preserve">
          <source>If there are no fini functions, the loop return type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">If there are no fini functions, the loop return type is &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="452463b6bb8122e8d19b3e5165c3baa6dd891166" translate="yes" xml:space="preserve">
          <source>If there are no originating elements, none need to be passed. This information may be used in an incremental environment to determine the need to rerun processors or remove generated files. Non-incremental environments may ignore the originating element information.</source>
          <target state="translated">원래 요소가 없으면 전달할 필요가 없습니다. 이 정보는 증분 환경에서 프로세서를 다시 실행하거나 생성 된 파일을 제거해야 할 필요성을 판별하는 데 사용될 수 있습니다. 비 증분 환경은 원래 요소 정보를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d1b6e296a2b77ef070997fd74f624d1c0686a93" translate="yes" xml:space="preserve">
          <source>If there are no parameters, no formatter is used.</source>
          <target state="translated">매개 변수가 없으면 포맷터가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="256816c6b5677c8691bdb94b6765ccbc5f24a09f" translate="yes" xml:space="preserve">
          <source>If there are several such threads, the bootstrap method may be invoked in several threads concurrently. Therefore, bootstrap methods which access global application data must take the usual precautions against race conditions. In any case, every &lt;code&gt;invokedynamic&lt;/code&gt; instruction is either unlinked or linked to a unique &lt;code&gt;CallSite&lt;/code&gt; object.</source>
          <target state="translated">그러한 스레드가 여러 개인 경우 부트 스트랩 메소드가 여러 스레드에서 동시에 호출 될 수 있습니다. 따라서 전역 응용 프로그램 데이터에 액세스하는 부트 스트랩 방법은 경쟁 조건에 대해 일반적인 예방 조치를 취해야합니다. 어쨌든 모든 &lt;code&gt;invokedynamic&lt;/code&gt; 명령어는 연결이 해제되거나 고유 한 &lt;code&gt;CallSite&lt;/code&gt; 객체에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="19df7c3245481a0b870f8b690f97116f667d21a7" translate="yes" xml:space="preserve">
          <source>If there are specialization prefixes for all arguments, the arity prefix may be left out (as in &lt;a href=&quot;objintconsumer&quot;&gt;&lt;code&gt;ObjIntConsumer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">모든 인수에 특수 접두사가있는 경우, &lt;a href=&quot;objintconsumer&quot;&gt; &lt;code&gt;ObjIntConsumer&lt;/code&gt; &lt;/a&gt; 에서와 같이 arity 접 두부가 생략 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5496a27b9238a94964b622c624cac4a711b3706d" translate="yes" xml:space="preserve">
          <source>If there are two sets of quotes, a specific begin-quote must be matched by its corresponding end-quote.</source>
          <target state="translated">인용 부호가 두 개인 경우 특정 시작 인용 부호를 해당 종료 인용 부호와 일치시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="f6d2e2287b3f940a2108e0447a31bf2c4dae6c7e" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;linkageerror&quot;&gt;linkage error&lt;/a&gt; accessing the nest host, or if this class or interface is not enumerated as a member of the nest by the nest host, then it is considered to belong to its own nest and &lt;code&gt;this&lt;/code&gt; is returned as the host.</source>
          <target state="translated">If there is a &lt;a href=&quot;linkageerror&quot;&gt;linkage error&lt;/a&gt; accessing the nest host, or if this class or interface is not enumerated as a member of the nest by the nest host, then it is considered to belong to its own nest and &lt;code&gt;this&lt;/code&gt; is returned as the host.</target>
        </trans-unit>
        <trans-unit id="60fe5e1f14261b51420b2f4800ed45295f2b7b43" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Filter&lt;/code&gt;, its &lt;code&gt;isLoggable&lt;/code&gt; method is called to check if the given log record is loggable. If not we return. Otherwise the given record is copied into an internal circular buffer. Then the record's level property is compared with the &lt;code&gt;pushLevel&lt;/code&gt;. If the given level is greater than or equal to the &lt;code&gt;pushLevel&lt;/code&gt; then &lt;code&gt;push&lt;/code&gt; is called to write all buffered records to the target output &lt;code&gt;Handler&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Filter&lt;/code&gt; 가있는 경우, 주어진 로그 레코드가 로그 가능한지 확인하기 위해 &lt;code&gt;isLoggable&lt;/code&gt; 메소드가 호출됩니다. 그렇지 않으면 우리는 돌아온다. 그렇지 않으면 주어진 레코드가 내부 순환 버퍼에 복사됩니다. 그런 다음 레코드의 레벨 특성이 &lt;code&gt;pushLevel&lt;/code&gt; 과 비교됩니다 . 주어진 레벨이 이상인 경우 &lt;code&gt;pushLevel&lt;/code&gt; 다음 &lt;code&gt;push&lt;/code&gt; 목표 출력 버퍼 된 모든 레코드를 작성라고 &lt;code&gt;Handler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5dab46b4549ff2feda5be50fc66d249aaffc422" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;ParseException&lt;/code&gt; in converting the current value to a String, this will set the text to an empty String, and mark the &lt;code&gt;JFormattedTextField&lt;/code&gt; as being in an invalid state.</source>
          <target state="translated">If there is a &lt;code&gt;ParseException&lt;/code&gt; in converting the current value to a String, this will set the text to an empty String, and mark the &lt;code&gt;JFormattedTextField&lt;/code&gt; as being in an invalid state.</target>
        </trans-unit>
        <trans-unit id="8264923428e93189de3d9488f3d02a8d83fd11ec" translate="yes" xml:space="preserve">
          <source>If there is a character stream specified, the SAX parser will ignore any byte stream and will not attempt to open a URI connection to the system identifier.</source>
          <target state="translated">문자 스트림이 지정된 경우 SAX 파서는 바이트 스트림을 무시하고 시스템 식별자에 대한 URI 연결을 열려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41cf28f3b00327296b2da5a55e1ed9b510e74f92" translate="yes" xml:space="preserve">
          <source>If there is a charset definition specified as a parameter of the content type specification, it will be used when loading input streams using the associated &lt;code&gt;EditorKit&lt;/code&gt;. For example if the type is specified as &lt;code&gt;text/html; charset=EUC-JP&lt;/code&gt; the content will be loaded using the &lt;code&gt;EditorKit&lt;/code&gt; registered for &lt;code&gt;text/html&lt;/code&gt; and the Reader provided to the &lt;code&gt;EditorKit&lt;/code&gt; to load unicode into the document will use the &lt;code&gt;EUC-JP&lt;/code&gt; charset for translating to unicode. If the type is not recognized, the content will be loaded using the &lt;code&gt;EditorKit&lt;/code&gt; registered for plain text, &lt;code&gt;text/plain&lt;/code&gt;.</source>
          <target state="translated">If there is a charset definition specified as a parameter of the content type specification, it will be used when loading input streams using the associated &lt;code&gt;EditorKit&lt;/code&gt; . For example if the type is specified as &lt;code&gt;text/html; charset=EUC-JP&lt;/code&gt; the content will be loaded using the &lt;code&gt;EditorKit&lt;/code&gt; registered for &lt;code&gt;text/html&lt;/code&gt; and the Reader provided to the &lt;code&gt;EditorKit&lt;/code&gt; to load unicode into the document will use the &lt;code&gt;EUC-JP&lt;/code&gt; charset for translating to unicode. If the type is not recognized, the content will be loaded using the &lt;code&gt;EditorKit&lt;/code&gt; registered for plain text, &lt;code&gt;text/plain&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0a6d33db9099e5da02b63b1c08b711314ed1070" translate="yes" xml:space="preserve">
          <source>If there is a current output stream then the &lt;code&gt;Formatter&lt;/code&gt;'s tail string is written and the stream is flushed and closed. Then the output stream is replaced with the new output stream.</source>
          <target state="translated">현재 출력 스트림이 있으면 &lt;code&gt;Formatter&lt;/code&gt; 의 꼬리 문자열이 기록되고 스트림이 플러시되고 닫힙니다. 그런 다음 출력 스트림이 새 출력 스트림으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="360eb0e694f70b9c0d8a6d2539b8b95168589f9b" translate="yes" xml:space="preserve">
          <source>If there is a language tag which matches completely to a language range above, the language tag is returned.</source>
          <target state="translated">위의 언어 범위와 완전히 일치하는 언어 태그가 있으면 언어 태그가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe9d5f4f323a99adea908fdeaf0c559a2234dc4" translate="yes" xml:space="preserve">
          <source>If there is a positive entry that grants a principal a particular permission, and a negative entry that denies the principal the same permission, the result is as though the permission was never granted or denied.</source>
          <target state="translated">주체에게 특정 권한을 부여하는 긍정적 인 항목과 주체에게 동일한 권한을 거부하는 부정적 항목이 있으면 결과는 권한이 부여되거나 거부되지 않은 것처럼 나타납니다.</target>
        </trans-unit>
        <trans-unit id="b820edb0cd4651acfa98bad6a1adbcc5b12aee0a" translate="yes" xml:space="preserve">
          <source>If there is a public subclass representing the type of &lt;code&gt;XMLStructure&lt;/code&gt;, it is returned as an instance of that class (ex: a &lt;code&gt;SignatureProperties&lt;/code&gt; element would be returned as an instance of &lt;a href=&quot;signatureproperties&quot;&gt;&lt;code&gt;SignatureProperties&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">If there is a public subclass representing the type of &lt;code&gt;XMLStructure&lt;/code&gt; , it is returned as an instance of that class (ex: a &lt;code&gt;SignatureProperties&lt;/code&gt; element would be returned as an instance of &lt;a href=&quot;signatureproperties&quot;&gt; &lt;code&gt;SignatureProperties&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="9a0ac9d4b223e6ba398b5c03bdbdea908d2e6008" translate="yes" xml:space="preserve">
          <source>If there is a public subclass representing the type of &lt;code&gt;XMLStructure&lt;/code&gt;, it is returned as an instance of that class (ex: an &lt;code&gt;X509Data&lt;/code&gt; element would be returned as an instance of &lt;a href=&quot;x509data&quot;&gt;&lt;code&gt;X509Data&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">If there is a public subclass representing the type of &lt;code&gt;XMLStructure&lt;/code&gt; , it is returned as an instance of that class (ex: an &lt;code&gt;X509Data&lt;/code&gt; element would be returned as an instance of &lt;a href=&quot;x509data&quot;&gt; &lt;code&gt;X509Data&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="7d2642219ae6689a90935a889cec5cc47e6b73a4" translate="yes" xml:space="preserve">
          <source>If there is a security manager already installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;RuntimePermission(&quot;setSecurityManager&quot;)&lt;/code&gt; permission to ensure it's ok to replace the existing security manager. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 이미 설치되어있는 경우이 메소드는 먼저 기존 보안 관리자를 대체 할 수 있도록 &lt;code&gt;RuntimePermission(&quot;setSecurityManager&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출합니다 . 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34d939280196d74fc1d1d34c5817d26280f87f75" translate="yes" xml:space="preserve">
          <source>If there is a security manager already installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;RuntimePermission(&quot;createSecurityManager&quot;)&lt;/code&gt; permission to ensure the calling thread has permission to create a new security manager. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 이미 설치되어있는 경우이 메소드는 먼저 &lt;code&gt;RuntimePermission(&quot;createSecurityManager&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출하여 호출 스레드에 새 보안 관리자를 작성할 수있는 권한이 있는지 확인합니다. 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5672428ce2d0310db13a3f85f67e993338e8598a" translate="yes" xml:space="preserve">
          <source>If there is a security manager and &lt;code&gt;host&lt;/code&gt; is not null and &lt;code&gt;host.length() &lt;/code&gt; is not equal to zero, the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method is called with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed.</source>
          <target state="translated">보안 관리자가 있고 &lt;code&gt;host&lt;/code&gt; 가 널이 &lt;code&gt;host.length() &lt;/code&gt; 가 0이 아닌 경우, 보안 관리자의 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호스트 이름 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 조작이 허용되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="aa68b021538f0471826642ff3267e740630d422f" translate="yes" xml:space="preserve">
          <source>If there is a security manager and this lookup does not have &lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;full privilege access&lt;/a&gt;, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called to check &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가 있고이 조회에 &lt;a href=&quot;#hasFullPrivilegeAccess()&quot;&gt;전체 권한 액세스 권한&lt;/a&gt; 이없는 경우 먼저 해당 &lt;code&gt;checkPermission&lt;/code&gt; 메서드가 호출되어 &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt; 를 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="fd5ff852f368770ab762748f1c19d1dda73aa1db" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, it can forbid the lookup on various grounds (&lt;a href=&quot;methodhandles.lookup#secmgr&quot;&gt;see below&lt;/a&gt;). By contrast, the &lt;code&gt;ldc&lt;/code&gt; instruction on a &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; constant is not subject to security manager checks.</source>
          <target state="translated">보안 관리자가 설치되어 있으면 다양한 이유로 조회를 금지 할 수 있습니다 ( &lt;a href=&quot;methodhandles.lookup#secmgr&quot;&gt;아래 참조&lt;/a&gt; ). 반대로 &lt;code&gt;CONSTANT_MethodHandle&lt;/code&gt; 상수 의 &lt;code&gt;ldc&lt;/code&gt; 명령어 는 보안 관리자 검사를받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b156cc02a90506f8eb9b81ce87ad4e2f4f5e01f7" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, its &lt;code&gt;checkAccess&lt;/code&gt; method is called with &lt;code&gt;this&lt;/code&gt; as its argument. This may result in a &lt;code&gt;SecurityException&lt;/code&gt; being raised (in the current thread).</source>
          <target state="translated">설치 보안 매니저가 존재하는 경우, 그 &lt;code&gt;checkAccess&lt;/code&gt; 메소드가 호출되어 &lt;code&gt;this&lt;/code&gt; 인수로. 이로 인해 현재 스레드에서 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5128105dcb411eeec7bd98eb31dc6c9f32f36396" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with a &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; permission to ensure it's ok to enable subclassing.</source>
          <target state="translated">보안 관리자가 설치되어있는 경우이 메소드는 먼저 &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출하여 서브 클래 싱을 사용할 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="31761f6c70fa775cd9eb51012f53c8d7db6b5b68" translate="yes" xml:space="preserve">
          <source>If there is a security manager installed, this method first calls the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method with the &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; permission to ensure it's ok to enable subclassing.</source>
          <target state="translated">보안 관리자가 설치되어있는 경우,이 메소드는 먼저 &lt;code&gt;SerializablePermission(&quot;enableSubclassImplementation&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드를 호출하여 서브 클래 싱을 사용할 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d92f5c22aaa435017a22a7870a8799131bb3b4bf" translate="yes" xml:space="preserve">
          <source>If there is a security manager set then its &lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkRead(java.io.FileDescriptor)&quot;&gt;&lt;code&gt;checkRead&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkWrite(java.io.FileDescriptor)&quot;&gt;&lt;code&gt;checkWrite&lt;/code&gt;&lt;/a&gt; methods are invoked to check that the caller has permission to both read from and write to the file descriptor.</source>
          <target state="translated">보안 관리자가 설정되어 있으면 해당 &lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkRead(java.io.FileDescriptor)&quot;&gt; &lt;code&gt;checkRead&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkWrite(java.io.FileDescriptor)&quot;&gt; &lt;code&gt;checkWrite&lt;/code&gt; &lt;/a&gt; 메서드가 호출되어 호출자가 파일 설명자에 대한 읽기 및 쓰기 권한이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5e92b1005890b8e36b5a3e3ec1d22670527621dc" translate="yes" xml:space="preserve">
          <source>If there is a security manager set then its &lt;a href=&quot;../securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is invoked to check that the caller has been granted &lt;a href=&quot;../runtimepermission&quot;&gt;&lt;code&gt;RuntimePermission(&quot;accessSystemModules&quot;)&lt;/code&gt;&lt;/a&gt; to access the system modules.</source>
          <target state="translated">If there is a security manager set then its &lt;a href=&quot;../securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; method is invoked to check that the caller has been granted &lt;a href=&quot;../runtimepermission&quot;&gt; &lt;code&gt;RuntimePermission(&quot;accessSystemModules&quot;)&lt;/code&gt; &lt;/a&gt; to access the system modules.</target>
        </trans-unit>
        <trans-unit id="3db3bf435e3205478cee741a5d2c93114bf55e60" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, and this socket is &lt;a href=&quot;#isBound()&quot;&gt;bound&lt;/a&gt;, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an &lt;code&gt;InetAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned as the implementation address.</source>
          <target state="translated">보안 관리자가 설정되어 &lt;code&gt;checkConnect&lt;/code&gt; 소켓이 &lt;a href=&quot;#isBound()&quot;&gt;바인딩 된&lt;/a&gt; 경우 해당 checkConnect 메서드는 로컬 주소와 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 호출되어 작업이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소를 나타내는 &lt;code&gt;InetAddress&lt;/code&gt; 가 구현 주소로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b86d00a2babbd52f7023cffa0fd1499e014ec134" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, it is invoked to check &lt;code&gt;AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)&lt;/code&gt;. If that check fails with a &lt;code&gt;SecurityException&lt;/code&gt; then a warning banner is created.</source>
          <target state="translated">If there is a security manager set, it is invoked to check &lt;code&gt;AWTPermission(&quot;showWindowWithoutWarningBanner&quot;)&lt;/code&gt; . If that check fails with a &lt;code&gt;SecurityException&lt;/code&gt; then a warning banner is created.</target>
        </trans-unit>
        <trans-unit id="64d3f1b6faeb8fe10d38810363c8cc48f8921c9d" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;../../net/inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port of the channel's socket is returned.</source>
          <target state="translated">If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;../../net/inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; address and the local port of the channel's socket is returned.</target>
        </trans-unit>
        <trans-unit id="efeea28b8db5bdbdbe7665022456615ea9a2a02a" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;../../net/inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port of the channel's socket is returned.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;../../net/inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소와 채널 소켓의 로컬 포트를 나타내는 &lt;code&gt;SocketAddress&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="314e1e1967331821237d640541c5b0e1313b59bd" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which the socket is bound is returned.</source>
          <target state="translated">If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; address and the local port to which the socket is bound is returned.</target>
        </trans-unit>
        <trans-unit id="c7de07e801ccd99c1e04407e222cb2fc9764b11a" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which this socket is bound is returned.</source>
          <target state="translated">If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; address and the local port to which this socket is bound is returned.</target>
        </trans-unit>
        <trans-unit id="bd4504e52760544f5802fe95b384c420e8994a88" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which the socket is bound is returned.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소와 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소를 나타내는 &lt;code&gt;SocketAddress&lt;/code&gt; 와 소켓이 바인딩 된 로컬 포트가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e9d7c04bc4d0c36452207dc47930704ce6c96d6" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, a &lt;code&gt;SocketAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address and the local port to which this socket is bound is returned.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소를 나타내는 &lt;code&gt;SocketAddress&lt;/code&gt; 와이 소켓이 바인딩 된 로컬 포트가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d707ade497c4fb2f188d76f169d44a01ba531e6e" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an &lt;code&gt;InetAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned as the implementation address.</source>
          <target state="translated">If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an &lt;code&gt;InetAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; address is returned as the implementation address.</target>
        </trans-unit>
        <trans-unit id="d2186903b27dd0e412d3c41bc56df02edfa54b96" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an &lt;code&gt;InetAddress&lt;/code&gt; representing the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned as the implementation address.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소를 나타내는 &lt;code&gt;InetAddress&lt;/code&gt; 가 구현 주소로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b7859548d6fe21c1371c700ba9e5a16a116554b8" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned.</source>
          <target state="translated">If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, the &lt;a href=&quot;inetaddress#getLoopbackAddress()&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; address is returned.</target>
        </trans-unit>
        <trans-unit id="e5eea39d0bafa27479de1740d6a3bd033e70cc0a" translate="yes" xml:space="preserve">
          <source>If there is a security manager set, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, the &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt;&lt;code&gt;loopback&lt;/code&gt;&lt;/a&gt; address is returned.</source>
          <target state="translated">보안 관리자 세트가있는 경우 , 로컬 주소 및 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 &lt;a href=&quot;inetaddress#getLoopbackAddress--&quot;&gt; &lt;code&gt;loopback&lt;/code&gt; &lt;/a&gt; 주소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c4393236d40a93051b0ea6d79cd37ab06006e55e" translate="yes" xml:space="preserve">
          <source>If there is a security manager then its &lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkPermission(java.security.Permission)&quot;&gt;&lt;code&gt;checkPermission&lt;/code&gt;&lt;/a&gt; method is called to check &lt;code&gt;AWTPermission(&quot;accessEventQueue&quot;)&lt;/code&gt;.</source>
          <target state="translated">If there is a security manager then its &lt;a href=&quot;../../../java.base/java/lang/securitymanager#checkPermission(java.security.Permission)&quot;&gt; &lt;code&gt;checkPermission&lt;/code&gt; &lt;/a&gt; method is called to check &lt;code&gt;AWTPermission(&quot;accessEventQueue&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcd0ea8c723035f1f68d96d6ce02d00d5e694624" translate="yes" xml:space="preserve">
          <source>If there is a security manager then its &lt;code&gt;checkPermission&lt;/code&gt; method if first called with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to check that the caller is allowed to get access to the class loader.</source>
          <target state="translated">If there is a security manager then its &lt;code&gt;checkPermission&lt;/code&gt; method if first called with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to check that the caller is allowed to get access to the class loader.</target>
        </trans-unit>
        <trans-unit id="975b403d7a17640c61b22b1fe12733ab70ac0406" translate="yes" xml:space="preserve">
          <source>If there is a security manager then its &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to check that the caller is allowed to get access to the class loader.</source>
          <target state="translated">If there is a security manager then its &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission to check that the caller is allowed to get access to the class loader.</target>
        </trans-unit>
        <trans-unit id="70274ada9a62f6bd34849b3ea45696f8033443f7" translate="yes" xml:space="preserve">
          <source>If there is a security manager then the class loader created by this method will load classes and resources with privileges that are restricted by the calling context of this method.</source>
          <target state="translated">If there is a security manager then the class loader created by this method will load classes and resources with privileges that are restricted by the calling context of this method.</target>
        </trans-unit>
        <trans-unit id="f21f2cb00e18158e239acee5b75d0e9108e9c70d" translate="yes" xml:space="preserve">
          <source>If there is a security manager then the class loaders created by this method will load classes and resources with privileges that are restricted by the calling context of this method.</source>
          <target state="translated">If there is a security manager then the class loaders created by this method will load classes and resources with privileges that are restricted by the calling context of this method.</target>
        </trans-unit>
        <trans-unit id="501526fb9b9e2e222246e9cd9786ee96d321d66c" translate="yes" xml:space="preserve">
          <source>If there is a security manager, a packet cannot be received if the security manager's &lt;code&gt;checkAccept&lt;/code&gt; method does not allow it.</source>
          <target state="translated">보안 관리자가있는 경우 보안 관리자의 &lt;code&gt;checkAccept&lt;/code&gt; 메소드가 허용하지 않으면 패킷을 수신 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8d8ccd4fade79b52387ca219cceec58d9c7bfd0d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, an &lt;a href=&quot;inquireseccontextpermission&quot;&gt;&lt;code&gt;InquireSecContextPermission&lt;/code&gt;&lt;/a&gt; with the name &lt;code&gt;type.mech&lt;/code&gt; must be granted. Otherwise, this could result in a &lt;a href=&quot;../../../../../java.base/java/lang/securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보안 관리자가있는 경우 &lt;a href=&quot;inquireseccontextpermission&quot;&gt; &lt;code&gt;InquireSecContextPermission&lt;/code&gt; &lt;/a&gt; 라는 이름의 &lt;code&gt;type.mech&lt;/code&gt; 을 부여해야합니다. 그렇지 않으면 &lt;a href=&quot;../../../../../java.base/java/lang/securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfbfad4dd09ad7ea7b2126cee4029ecba6ab2815" translate="yes" xml:space="preserve">
          <source>If there is a security manager, and &lt;code&gt;host&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;host.length() &lt;/code&gt; is not equal to zero, the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method is called with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to determine if the operation is allowed.</source>
          <target state="translated">If there is a security manager, and &lt;code&gt;host&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;host.length() &lt;/code&gt; is not equal to zero, the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method is called with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to determine if the operation is allowed.</target>
        </trans-unit>
        <trans-unit id="9cc5fcc49e4c5f23df1182ea1b133caeed726d61" translate="yes" xml:space="preserve">
          <source>If there is a security manager, and the socket is not currently connected to a remote address, a packet cannot be received if the security manager's &lt;code&gt;checkAccept&lt;/code&gt; method does not allow it. Datagrams that are not permitted by the security manager are silently discarded.</source>
          <target state="translated">보안 관리자가 있고 소켓이 현재 원격 주소에 연결되어 있지 않은 경우 보안 관리자의 &lt;code&gt;checkAccept&lt;/code&gt; 메소드에서 허용하지 않으면 패킷을 수신 할 수 없습니다 . 보안 관리자가 허용하지 않는 데이터 그램은 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="78bc0f4a72c52e6defa54f26456df6b6bfdcd359" translate="yes" xml:space="preserve">
          <source>If there is a security manager, and the socket is not currently connected to a remote address, this method first performs some security checks. First, if &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; is true, this method calls the security manager's &lt;code&gt;checkMulticast&lt;/code&gt; method with &lt;code&gt;p.getAddress()&lt;/code&gt; as its argument. If the evaluation of that expression is false, this method instead calls the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method with arguments &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; and &lt;code&gt;p.getPort()&lt;/code&gt;. Each call to a security manager method could result in a SecurityException if the operation is not allowed.</source>
          <target state="translated">보안 관리자가 있고 소켓이 현재 원격 주소에 연결되어 있지 않은 경우이 방법은 먼저 일부 보안 검사를 수행합니다. 먼저 &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; 가 true 인 경우이 메소드는 &lt;code&gt;p.getAddress()&lt;/code&gt; 를 인수로 사용 하여 보안 관리자의 &lt;code&gt;checkMulticast&lt;/code&gt; 메소드를 호출합니다 . 해당 표현식의 평가가 false 인 경우이 메소드는 대신 &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; 및 &lt;code&gt;p.getPort()&lt;/code&gt; 인수로 보안 관리자의 &lt;code&gt;checkConnect&lt;/code&gt; 메소드를 호출합니다 . 조작이 허용되지 않으면 보안 관리자 메소드를 호출 할 때마다 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f2dc991bc054662c9aaf92a4f81920cc42b0299" translate="yes" xml:space="preserve">
          <source>If there is a security manager, and this thread is not the current thread, then the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; permission to see if it's ok to get the stack trace.</source>
          <target state="translated">보안 관리자가 &lt;code&gt;checkPermission&lt;/code&gt; 스레드가 현재 스레드가 아닌 경우 보안 관리자의 checkPermission 메소드가 &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; 권한으로 호출되어 스택 추적을 가져 오기에 적합한 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d1b98d766cc337fb9898419e46a662c7d8de062a" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkAccess(java.lang.ThreadGroup)&quot;&gt;&lt;code&gt;checkAccess&lt;/code&gt;&lt;/a&gt; method is invoked with the ThreadGroup as its argument.</source>
          <target state="translated">If there is a security manager, its &lt;a href=&quot;securitymanager#checkAccess(java.lang.ThreadGroup)&quot;&gt; &lt;code&gt;checkAccess&lt;/code&gt; &lt;/a&gt; method is invoked with the ThreadGroup as its argument.</target>
        </trans-unit>
        <trans-unit id="9414114a34df41ef68dcd065db4f4c005b486dbe" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkAccess-java.lang.ThreadGroup-&quot;&gt;&lt;code&gt;checkAccess&lt;/code&gt;&lt;/a&gt; method is invoked with the ThreadGroup as its argument.</source>
          <target state="translated">보안 관리자가있는 경우 해당 &lt;a href=&quot;securitymanager#checkAccess-java.lang.ThreadGroup-&quot;&gt; &lt;code&gt;checkAccess&lt;/code&gt; &lt;/a&gt; 메소드가 ThreadGroup을 인수로 사용하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7fd4592e446f7faba341b06f36e03f193c3eabf7" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkCreateClassLoader()&quot;&gt;&lt;code&gt;checkCreateClassLoader&lt;/code&gt;&lt;/a&gt; method is invoked. This may result in a security exception.</source>
          <target state="translated">If there is a security manager, its &lt;a href=&quot;securitymanager#checkCreateClassLoader()&quot;&gt; &lt;code&gt;checkCreateClassLoader&lt;/code&gt; &lt;/a&gt; method is invoked. This may result in a security exception.</target>
        </trans-unit>
        <trans-unit id="3533ff6ee33a3d65c462d1050b52aa5438f30879" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkCreateClassLoader--&quot;&gt;&lt;code&gt;&lt;code&gt;checkCreateClassLoader&lt;/code&gt;&lt;/code&gt;&lt;/a&gt; method is invoked. This may result in a security exception.</source>
          <target state="translated">보안 관리자가있는 경우 &lt;a href=&quot;securitymanager#checkCreateClassLoader--&quot;&gt; &lt;code&gt;&lt;code&gt;checkCreateClassLoader&lt;/code&gt;&lt;/code&gt; &lt;/a&gt; 메소드가 호출됩니다. 보안 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eab087ce5a6c8b2fb5dba3d7042957f448b206c1" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is called with the first component of each process builder's &lt;code&gt;command&lt;/code&gt; array as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가있는 경우 각 프로세스 빌더 &lt;code&gt;command&lt;/code&gt; 배열 의 첫 번째 구성 요소를 인수로 사용하여 &lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt; 메서드가 호출됩니다 . 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6dd5e5d0112178d816deaa79996ddbde5d42d22e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is called with the first component of this object's &lt;code&gt;command&lt;/code&gt; array as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">If there is a security manager, its &lt;a href=&quot;securitymanager#checkExec(java.lang.String)&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt; method is called with the first component of this object's &lt;code&gt;command&lt;/code&gt; array as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; being thrown.</target>
        </trans-unit>
        <trans-unit id="85a1e97c5d37987df52e3f2db8dd957eb6a2e0a1" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt;&lt;code&gt;checkExec&lt;/code&gt;&lt;/a&gt; method is called with the first component of this object's &lt;code&gt;command&lt;/code&gt; array as its argument. This may result in a &lt;a href=&quot;securityexception&quot;&gt;&lt;code&gt;SecurityException&lt;/code&gt;&lt;/a&gt; being thrown.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;a href=&quot;securitymanager#checkExec-java.lang.String-&quot;&gt; &lt;code&gt;checkExec&lt;/code&gt; &lt;/a&gt; 메소드가이 오브젝트 &lt;code&gt;command&lt;/code&gt; 배열 의 첫 번째 구성 요소를 인수로 사용하여 호출됩니다. 이로 인해 &lt;a href=&quot;securityexception&quot;&gt; &lt;code&gt;SecurityException&lt;/code&gt; &lt;/a&gt; 이 발생 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c30beb89be73a967106d6bb017cc3341325b7e4" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkAccess&lt;/code&gt; method is called with this thread as its argument. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가있는 경우이 스레드를 인수로 사용 하여 &lt;code&gt;checkAccess&lt;/code&gt; 메소드가 호출됩니다. 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="959b09fe0d2c452907b0520da6e28a90c4ae65f9" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkAccess&lt;/code&gt; method is called with this thread group as its argument. This may result in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">보안 관리자가있는 경우이 스레드 그룹을 인수로 사용 하여 &lt;code&gt;checkAccess&lt;/code&gt; 메소드가 호출됩니다. 이로 인해 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c17150f3dc1fd1d9a170113f445867d696c2b24" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called for each InetAddress. Only InetAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn't throw a SecurityException will be returned in the Enumeration. However, if the caller has the &lt;a href=&quot;netpermission&quot;&gt;&lt;code&gt;NetPermission&lt;/code&gt;&lt;/a&gt;(&quot;getNetworkInformation&quot;) permission, then all InetAddresses are returned.</source>
          <target state="translated">보안 관리자가있는 경우 각 InetAddress에 대해 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출됩니다. &lt;code&gt;checkConnect&lt;/code&gt; 가 SecurityException을 발생시키지 않는 InetAddresses 만 Enumeration에 반환됩니다. 그러나 호출자에게 &lt;a href=&quot;netpermission&quot;&gt; &lt;code&gt;NetPermission&lt;/code&gt; &lt;/a&gt; ( &quot;getNetworkInformation&quot;) 권한 이 있으면 모든 InetAddresses가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="58541a971b5c4b55ce89f0aa08744fea81192c9b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called for each InetAddress. Only InetAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn't throw a SecurityException will be returned in the Stream. However, if the caller has the &lt;a href=&quot;netpermission&quot;&gt;&lt;code&gt;NetPermission&lt;/code&gt;&lt;/a&gt;(&quot;getNetworkInformation&quot;) permission, then all InetAddresses are returned.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called for each InetAddress. Only InetAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn't throw a SecurityException will be returned in the Stream. However, if the caller has the &lt;a href=&quot;netpermission&quot;&gt; &lt;code&gt;NetPermission&lt;/code&gt; &lt;/a&gt;(&quot;getNetworkInformation&quot;) permission, then all InetAddresses are returned.</target>
        </trans-unit>
        <trans-unit id="16d27bea720609eee04166dfd76b88b456132798" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with &lt;code&gt;host.getHostAddress()&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; as its arguments. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 &lt;code&gt;host.getHostAddress()&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 를 인수로 사용하여 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43c71e671e00781339f5ba759f2bcd61a8b7a34b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the InetAddress for each InterfaceAddress. Only InterfaceAddresses where the &lt;code&gt;checkConnect&lt;/code&gt; doesn't throw a SecurityException will be returned in the List.</source>
          <target state="translated">보안 관리자가있는 경우 &lt;code&gt;checkConnect&lt;/code&gt; 메소드는 각 InterfaceAddress에 대해 InetAddress와 함께 호출됩니다. &lt;code&gt;checkConnect&lt;/code&gt; 가 SecurityException을 발생시키지 않는 인터페이스 주소 만 목록에 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="78af07133b038dacb150089b40e78b0ca1d3d753" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the host address and &lt;code&gt;port&lt;/code&gt; as its arguments. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우 호스트 주소와 &lt;code&gt;port&lt;/code&gt; 를 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출됩니다 . 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d2ddb66aff693ec81fe7a3cff9c33e416a967ed" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the host name as its argument to check the permission to resolve it. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkConnect&lt;/code&gt; 메소드는 호스트 이름을 인수로하여이를 해결하기위한 권한을 점검합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01ae3cd02649f51bc3641c7c81a3016b88a1579b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the local host name and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, an InetAddress representing the loopback address is returned.</source>
          <target state="translated">보안 관리자가있는 경우 로컬 호스트 이름과 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용 하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 루프백 주소를 나타내는 InetAddress가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4d128c55ea8e46338a04c172173181318ab739b7" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is called with the proxy host address and port number as its arguments. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우 프록시 호스트 주소 및 포트 번호를 인수로 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bca28a5046aedb2445dad871f1870c7cd86fe222" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is first called with the host address and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 먼저 호스트 주소와 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 호출되어 조작이 허용되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fd69bfacd3a48bd3c84ffe11c3502373bc1b717d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkConnect&lt;/code&gt; method is first called with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the operation is allowed. If the operation is not allowed, it will return the textual representation of the IP address.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkConnect&lt;/code&gt; 메소드가 먼저 호스트 이름과 &lt;code&gt;-1&lt;/code&gt; 을 인수로 사용하여 호출되어 조작이 허용되는지 확인합니다. 작업이 허용되지 않으면 IP 주소의 텍스트 표현이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="19b8451790374e638a897d576809e75ff26e4bdc" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkExit&lt;/code&gt; method is first called with 0 as its argument to ensure the exit is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkExit&lt;/code&gt; 메소드는 먼저 엑시트가 허용되도록 인수로 0을 사용하여 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ad778e38f7a8fa1a04c66c84bec80348990751b" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드가 &lt;code&gt;port&lt;/code&gt; 인수 와 함께 인수로 호출되어 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4275d6bc9ac0d95a70ff7bc44ead467a08203c23" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The &lt;code&gt;backlog&lt;/code&gt; argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogether. The value provided should be greater than &lt;code&gt;0&lt;/code&gt;. If it is less than or equal to &lt;code&gt;0&lt;/code&gt;, then an implementation specific default will be used.</source>
          <target state="translated">보안 관리자가있는 경우 &lt;code&gt;port&lt;/code&gt; 인수를 인수로 사용하여 &lt;code&gt;checkListen&lt;/code&gt; 메서드를 호출 하여 작업이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다. &lt;code&gt;backlog&lt;/code&gt; 인수는 소켓에 대기중인 연결 요청의 최대 수입니다. 정확한 의미는 구현에 따라 다릅니다. 특히, 구현은 최대 길이를 부과하거나 매개 변수를 모두 무시하도록 선택할 수 있습니다. 제공된 값은 &lt;code&gt;0&lt;/code&gt; 보다 커야 합니다. &lt;code&gt;0&lt;/code&gt; 보다 작거나 같으면 구현 특정 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="84eacac097d36c19fe75054afbaa3ba99bf8985e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The &lt;code&gt;backlog&lt;/code&gt; argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than &lt;code&gt;0&lt;/code&gt;. If it is less than or equal to &lt;code&gt;0&lt;/code&gt;, then an implementation specific default will be used.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드가 &lt;code&gt;port&lt;/code&gt; 인수 와 함께 인수로 호출되어 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다. &lt;code&gt;backlog&lt;/code&gt; 인수는 소켓에 대기중인 연결 요청의 최대 수입니다. 정확한 의미는 구현에 따라 다릅니다. 특히, 구현은 최대 길이를 부과하거나 매개 변수를 무시하도록 선택할 수 있습니다. 제공된 값은 &lt;code&gt;0&lt;/code&gt; 보다 커야 합니다. &lt;code&gt;0&lt;/code&gt; 보다 작거나 같은 경우, 구현 고유의 디폴트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7696a640bf74fb64021433fe004320c4e69fec7e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with 0 as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드는 조작이 허용되도록 인수로 0을 사용하여 먼저 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7d8bb6cd4c61d496d648276b50f92f3feba88b5" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드가 먼저 &lt;code&gt;port&lt;/code&gt; 인수 와 함께 인수로 호출되어 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2550b60768f930b8dee700df520c5f4176ce28d3" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with the SocketAddress port as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드는 조작이 허용되도록 인수로 SocketAddress 포트와 함께 먼저 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a229539b4a28c2f5ec8ded7c3825ecf64243199f" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkListen&lt;/code&gt; method is first called with the port from the socket address as its argument to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우, &lt;code&gt;checkListen&lt;/code&gt; 메소드가 먼저 소켓 주소의 포트를 인수로 호출하여 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a67ec5feda224ae64b8c4ed0abf118d7033d1c2" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called to check &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; and that must return normally.</source>
          <target state="translated">보안 관리자가있는 경우 해당 &lt;code&gt;checkPermission&lt;/code&gt; 메서드가 호출되어 &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; 를 확인 하고 정상적으로 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="526f451df552a77dd63ebe02272aee894aeec911" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called to check &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt;.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called to check &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1362fabcddab928d786a66dfafce71193c90bbd3" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)&lt;/code&gt; permission before the default locale is changed.</source>
          <target state="translated">보안 관리자가있는 경우 기본 로케일이 변경되기 전에 &lt;code&gt;checkPermission&lt;/code&gt; 메소드가 &lt;code&gt;PropertyPermission(&quot;user.language&quot;, &quot;write&quot;)&lt;/code&gt; 권한 으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a19d07ab57d6d32ab3bfc3854e57cbabaa6348e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">보안 관리자가 있으면 해당 &lt;code&gt;checkPermission&lt;/code&gt; 메소드가 &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; 권한으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2046cd2160f064fcca12b8ed464d009e531b209f" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with an &lt;code&gt;AWTPermission(&quot;watchMousePointer&quot;)&lt;/code&gt; permission before creating and returning a &lt;code&gt;PointerInfo&lt;/code&gt; object. This may result in a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with an &lt;code&gt;AWTPermission(&quot;watchMousePointer&quot;)&lt;/code&gt; permission before creating and returning a &lt;code&gt;PointerInfo&lt;/code&gt; object. This may result in a &lt;code&gt;SecurityException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="023c7b6fa6e64e85c534968cd82b886f189f68e0" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with the &lt;code&gt;AWTPermission(&quot;setAppletStub&quot;)&lt;/code&gt; permission if a stub has already been set.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with the &lt;code&gt;AWTPermission(&quot;setAppletStub&quot;)&lt;/code&gt; permission if a stub has already been set.</target>
        </trans-unit>
        <trans-unit id="a5901e8f5f3e827f7dec190acb7b2c680e3d8a12" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called to check &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt;.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called to check &lt;code&gt;RuntimePermission(&quot;defineClass&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba736daa95eab79c3e9ec30a15feed15b6f2153e" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is first called with a &lt;code&gt;ReflectPermission(&quot;suppressAccessChecks&quot;)&lt;/code&gt; permission.</target>
        </trans-unit>
        <trans-unit id="b73ff7cd0749e2fe69c0f2fcc0421edecf259b2d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;RuntimePermission(&quot;setFactory&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;RuntimePermission(&quot;setFactory&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e19a3d6b18c7f288973d4faca480e353d3119ae" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;java.util.logging.LoggingPermission(&quot;control&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;java.util.logging.LoggingPermission(&quot;control&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cb05ace85aa7a9edcb040bdd423405912174b9c" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called. This could result in a &lt;a href=&quot;../../../java.base/java/lang/securityexception&quot;&gt;SecurityException&lt;/a&gt;.</source>
          <target state="translated">If there is a security manager, its &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called. This could result in a &lt;a href=&quot;../../../java.base/java/lang/securityexception&quot;&gt;SecurityException&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b812e22f1f04741048de016813ab27b17900ad4d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called. This could result in a &lt;a href=&quot;../lang/securityexception&quot;&gt;SecurityException&lt;/a&gt;.</source>
          <target state="translated">보안 관리자가있는 &lt;code&gt;checkPropertiesAccess&lt;/code&gt; 메소드가 호출됩니다. 이로 인해 &lt;a href=&quot;../lang/securityexception&quot;&gt;SecurityException&lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61ad58a3688694c18343d625b7add7843909f0fc" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is called with the &lt;code&gt;name&lt;/code&gt; argument as its argument to see if read access to the file is allowed. If the mode allows writing, the security manager's &lt;code&gt;checkWrite&lt;/code&gt; method is also called with the &lt;code&gt;name&lt;/code&gt; argument as its argument to see if write access to the file is allowed.</source>
          <target state="translated">보안 관리자가있는 경우 파일에 대한 읽기 액세스가 허용되는지 확인하기 위해 &lt;code&gt;checkRead&lt;/code&gt; 메소드가 &lt;code&gt;name&lt;/code&gt; 인수 와 함께 인수로 호출됩니다 . 모드 가 쓰기를 허용하는 경우 파일에 대한 쓰기 액세스가 허용되는지 확인하기 위해 &lt;code&gt;name&lt;/code&gt; 인수를 인수로 사용 하여 보안 관리자의 &lt;code&gt;checkWrite&lt;/code&gt; 메소드도 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e8440e06fb5641cd0bbb2e4e19fe4021dbf3d258" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is called with the file descriptor &lt;code&gt;fdObj&lt;/code&gt; as its argument to see if it's ok to read the file descriptor. If read access is denied to the file descriptor a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">보안 관리자가있는 경우 파일 디스크립터 &lt;code&gt;fdObj&lt;/code&gt; 를 인수로 하여 &lt;code&gt;checkRead&lt;/code&gt; 메소드를 호출하여 파일 디스크립터 를 읽을 수 있는지 확인합니다. 파일 디스크립터에 대한 읽기 액세스가 거부되면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="07ece2acfb17b36150e2dd4f7e477c94e9f4a76d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its &lt;code&gt;checkRead&lt;/code&gt; method is called with the pathname of the &lt;code&gt;file&lt;/code&gt; argument as its argument to see if read access to the file is allowed. If the mode allows writing, the security manager's &lt;code&gt;checkWrite&lt;/code&gt; method is also called with the path argument to see if write access to the file is allowed.</source>
          <target state="translated">보안 관리자가있는 경우 &lt;code&gt;file&lt;/code&gt; 대한 읽기 액세스가 허용되는지 확인하기 위해 파일 인수 의 경로 이름을 인수로 사용하여 &lt;code&gt;checkRead&lt;/code&gt; 메소드가 호출됩니다 . 모드 가 쓰기를 허용하는 경우, 파일에 대한 쓰기 액세스가 허용되는지 확인하기 위해 보안 관리자의 &lt;code&gt;checkWrite&lt;/code&gt; 메소드가 path 인수와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="31b66585dd5ded5b4cf8149540abcf6d797f5618" translate="yes" xml:space="preserve">
          <source>If there is a security manager, its checkPermission method is called with a PropertyPermission(&quot;user.language&quot;, &quot;write&quot;) permission before the default locale is changed.</source>
          <target state="translated">보안 관리자가있는 경우 기본 로케일이 변경되기 전에 checkPermission 메소드가 PropertyPermission ( &quot;user.language&quot;, &quot;write&quot;) 권한으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8825d17638da814f3b0c11ec345292fdd5696887" translate="yes" xml:space="preserve">
          <source>If there is a security manager, the &lt;a href=&quot;../lang/securitymanager#checkSecurityAccess(java.lang.String)&quot;&gt;&lt;code&gt;SecurityManager.checkSecurityAccess(java.lang.String)&lt;/code&gt;&lt;/a&gt; method is called with the &lt;code&gt;&quot;insertProvider&quot;&lt;/code&gt; permission target name to see if it's ok to add a new provider. If this permission check is denied, &lt;code&gt;checkSecurityAccess&lt;/code&gt; is called again with the &lt;code&gt;&quot;insertProvider.&quot;+provider.getName()&lt;/code&gt; permission target name. If both checks are denied, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">If there is a security manager, the &lt;a href=&quot;../lang/securitymanager#checkSecurityAccess(java.lang.String)&quot;&gt; &lt;code&gt;SecurityManager.checkSecurityAccess(java.lang.String)&lt;/code&gt; &lt;/a&gt; method is called with the &lt;code&gt;&quot;insertProvider&quot;&lt;/code&gt; permission target name to see if it's ok to add a new provider. If this permission check is denied, &lt;code&gt;checkSecurityAccess&lt;/code&gt; is called again with the &lt;code&gt;&quot;insertProvider.&quot;+provider.getName()&lt;/code&gt; permission target name. If both checks are denied, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="bd97e3f8323cfe0de6530417bd6292cf0553996a" translate="yes" xml:space="preserve">
          <source>If there is a security manager, the &lt;a href=&quot;../lang/securitymanager#checkSecurityAccess-java.lang.String-&quot;&gt;&lt;code&gt;SecurityManager.checkSecurityAccess(java.lang.String)&lt;/code&gt;&lt;/a&gt; method is called with the &lt;code&gt;&quot;insertProvider&quot;&lt;/code&gt; permission target name to see if it's ok to add a new provider. If this permission check is denied, &lt;code&gt;checkSecurityAccess&lt;/code&gt; is called again with the &lt;code&gt;&quot;insertProvider.&quot;+provider.getName()&lt;/code&gt; permission target name. If both checks are denied, a &lt;code&gt;SecurityException&lt;/code&gt; is thrown.</source>
          <target state="translated">보안 관리자가있는 경우 &lt;code&gt;&quot;insertProvider&quot;&lt;/code&gt; 권한 대상 이름으로 &lt;a href=&quot;../lang/securitymanager#checkSecurityAccess-java.lang.String-&quot;&gt; &lt;code&gt;SecurityManager.checkSecurityAccess(java.lang.String)&lt;/code&gt; &lt;/a&gt; 메소드가 호출되어 새 제공자를 추가 할 수 있는지 확인합니다. 이 권한 검사가 거부되면 &lt;code&gt;&quot;insertProvider.&quot;+provider.getName()&lt;/code&gt; 권한 대상 이름으로 &lt;code&gt;checkSecurityAccess&lt;/code&gt; 가 다시 호출됩니다 . 두 검사가 모두 거부되면 &lt;code&gt;SecurityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9b31a15f0a361ace0e86d27297cb7544846a2131" translate="yes" xml:space="preserve">
          <source>If there is a security manager, then the security manager's &lt;code&gt;checkPermission&lt;/code&gt; method is called with a &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; permission as well as &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; permission to see if it is ok to get the stack trace of all threads.</source>
          <target state="translated">보안 관리자가있는 경우 모든 스레드의 스택 추적을 얻을 수 있는지 확인하기 위해 &lt;code&gt;RuntimePermission(&quot;modifyThreadGroup&quot;)&lt;/code&gt; 권한 뿐만 아니라 &lt;code&gt;RuntimePermission(&quot;getStackTrace&quot;)&lt;/code&gt; 권한으로 보안 관리자의 &lt;code&gt;checkPermission&lt;/code&gt; 메소드가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="372f832c98aee8a28f1bafce4413d10d1d87c33d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method calls its &lt;code&gt;checkListen&lt;/code&gt; method with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The &lt;code&gt;backlog&lt;/code&gt; argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogether. The value provided should be greater than &lt;code&gt;0&lt;/code&gt;. If it is less than or equal to &lt;code&gt;0&lt;/code&gt;, then an implementation specific default will be used.</source>
          <target state="translated">보안 관리자가있는 경우이 메서드 는 &lt;code&gt;port&lt;/code&gt; 인수를 인수로 사용하여 &lt;code&gt;checkListen&lt;/code&gt; 메서드를 호출 하여 작업이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다. &lt;code&gt;backlog&lt;/code&gt; 인수는 소켓에 대기중인 연결 요청의 최대 수입니다. 정확한 의미는 구현에 따라 다릅니다. 특히, 구현은 최대 길이를 부과하거나 매개 변수를 모두 무시하도록 선택할 수 있습니다. 제공된 값은 &lt;code&gt;0&lt;/code&gt; 보다 커야 합니다. &lt;code&gt;0&lt;/code&gt; 보다 작거나 같으면 구현 특정 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3774f41cca13a332ee025b0313241e9bb0d0309d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method calls its &lt;code&gt;checkListen&lt;/code&gt; method with the &lt;code&gt;port&lt;/code&gt; argument as its argument to ensure the operation is allowed. This could result in a SecurityException. The &lt;code&gt;backlog&lt;/code&gt; argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than &lt;code&gt;0&lt;/code&gt;. If it is less than or equal to &lt;code&gt;0&lt;/code&gt;, then an implementation specific default will be used.</source>
          <target state="translated">보안 관리자가있는 경우이 메소드 는 &lt;code&gt;port&lt;/code&gt; 인수를 인수로 사용하여 &lt;code&gt;checkListen&lt;/code&gt; 메소드를 호출 하여 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다. &lt;code&gt;backlog&lt;/code&gt; 인수는 소켓에 대기중인 연결 요청의 최대 수입니다. 정확한 의미는 구현에 따라 다릅니다. 특히, 구현은 최대 길이를 부과하거나 매개 변수를 무시하도록 선택할 수 있습니다. 제공된 값은 &lt;code&gt;0&lt;/code&gt; 보다 커야 합니다. &lt;code&gt;0&lt;/code&gt; 보다 작거나 같은 경우, 구현 고유의 디폴트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c49df9821bd54b67f07151d3efea906c51666fdf" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls its &lt;code&gt;checkConnect&lt;/code&gt; method with the hostname and &lt;code&gt;-1&lt;/code&gt; as its arguments to see if the calling code is allowed to know the hostname for this IP address, i.e., to connect to the host. If the operation is not allowed, it will return the textual representation of the IP address.</source>
          <target state="translated">보안 관리자가있는 경우이 메소드는 먼저 호스트 이름과 인수로 &lt;code&gt;-1&lt;/code&gt; 을 사용하여 &lt;code&gt;checkConnect&lt;/code&gt; 메소드를 호출하여 호출 코드가이 IP 주소의 호스트 이름을 알 수 있는지 (예 : 호스트에 연결) 여부를 확인합니다. 작업이 허용되지 않으면 IP 주소의 텍스트 표현이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="999933e43cb5d7cfb6601989d19930a2a9186ce5" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls its &lt;code&gt;checkMulticast&lt;/code&gt; method with the &lt;code&gt;mcastaddr&lt;/code&gt; argument as its argument.</source>
          <target state="translated">보안 관리자가있는 경우이 메소드는 먼저 &lt;code&gt;mcastaddr&lt;/code&gt; 인수를 인수로 사용하여 &lt;code&gt;checkMulticast&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1e8e454b01623ff9ba56024fdcbb8a6e018247b0" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls the security manager's &lt;code&gt;checkCreateClassLoader&lt;/code&gt; method to ensure creation of a class loader is allowed.</source>
          <target state="translated">보안 관리자가있는 경우이 메소드는 먼저 보안 관리자의 &lt;code&gt;checkCreateClassLoader&lt;/code&gt; 메소드를 호출하여 클래스 로더 작성이 허용되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="799f9e285d27c3aa5aa412489ee33ebf55b4583d" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls the security manager's &lt;code&gt;checkSetFactory&lt;/code&gt; method to ensure the operation is allowed. This could result in a &lt;code&gt;SecurityException&lt;/code&gt;.</source>
          <target state="translated">If there is a security manager, this method first calls the security manager's &lt;code&gt;checkSetFactory&lt;/code&gt; method to ensure the operation is allowed. This could result in a &lt;code&gt;SecurityException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="532913bfc0592ca00219b6f161a58e7676757794" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls the security manager's &lt;code&gt;checkSetFactory&lt;/code&gt; method to ensure the operation is allowed. This could result in a SecurityException.</source>
          <target state="translated">보안 관리자가있는 경우이 메소드는 먼저 보안 관리자의 &lt;code&gt;checkSetFactory&lt;/code&gt; 메소드를 호출 하여 조작이 허용되는지 확인합니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b85ee089e6901857f30792e22767b9407897d233" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first calls the security manager's &lt;code&gt;checkSetFactory&lt;/code&gt; method. This could result in a SecurityException.</source>
          <target state="translated">If there is a security manager, this method first calls the security manager's &lt;code&gt;checkSetFactory&lt;/code&gt; method. This could result in a SecurityException.</target>
        </trans-unit>
        <trans-unit id="d0319ca077ddde1bcf2e693ddcb559868dc66ee3" translate="yes" xml:space="preserve">
          <source>If there is a security manager, this method first performs some security checks. First, if &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; is true, this method calls the security manager's &lt;code&gt;checkMulticast&lt;/code&gt; method with &lt;code&gt;p.getAddress()&lt;/code&gt; and &lt;code&gt;ttl&lt;/code&gt; as its arguments. If the evaluation of that expression is false, this method instead calls the security manager's &lt;code&gt;checkConnect&lt;/code&gt; method with arguments &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; and &lt;code&gt;p.getPort()&lt;/code&gt;. Each call to a security manager method could result in a SecurityException if the operation is not allowed.</source>
          <target state="translated">보안 관리자가있는 경우이 방법은 먼저 일부 보안 검사를 수행합니다. 먼저 &lt;code&gt;p.getAddress().isMulticastAddress()&lt;/code&gt; 가 true 인 경우이 메소드는 &lt;code&gt;p.getAddress()&lt;/code&gt; 및 &lt;code&gt;ttl&lt;/code&gt; 을 인수로 사용 하여 보안 관리자의 &lt;code&gt;checkMulticast&lt;/code&gt; 메소드를 호출합니다 . 해당 표현식의 평가가 false 인 경우이 메소드는 대신 &lt;code&gt;p.getAddress().getHostAddress()&lt;/code&gt; 및 &lt;code&gt;p.getPort()&lt;/code&gt; 인수로 보안 관리자의 &lt;code&gt;checkConnect&lt;/code&gt; 메소드를 호출합니다 . 조작이 허용되지 않으면 보안 관리자 메소드를 호출 할 때마다 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63982b929f4b12662afdfb3691962ff7e8ce5aaa" translate="yes" xml:space="preserve">
          <source>If there is a security manger, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt;. The implementation of this method may also perform further security checks to verify that the calling context has permission to connect to all of the URLs in the codebase URL path.</source>
          <target state="translated">If there is a security manger, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt; . The implementation of this method may also perform further security checks to verify that the calling context has permission to connect to all of the URLs in the codebase URL path.</target>
        </trans-unit>
        <trans-unit id="bf4410fbd9dbb3855c2a0c2fc2a80606e063a5a3" translate="yes" xml:space="preserve">
          <source>If there is a security manger, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt;. The provider implementation of this method may also perform further security checks to verify that the calling context has permission to connect to all of the URLs in the codebase URL path.</source>
          <target state="translated">If there is a security manger, its &lt;code&gt;checkPermission&lt;/code&gt; method will be invoked with a &lt;code&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/code&gt; permission; this could result in a &lt;code&gt;SecurityException&lt;/code&gt; . The provider implementation of this method may also perform further security checks to verify that the calling context has permission to connect to all of the URLs in the codebase URL path.</target>
        </trans-unit>
        <trans-unit id="696cdd286fb1f9966bf04867ac93a074e1dded21" translate="yes" xml:space="preserve">
          <source>If there is a way to convert &lt;em&gt;opendata(J)&lt;/em&gt; back to &lt;em&gt;J&lt;/em&gt; then we say that &lt;em&gt;J&lt;/em&gt; is &lt;em&gt;reconstructible&lt;/em&gt;. All method parameters in an MXBean interface must be reconstructible, because when the MXBean framework is invoking a method it will need to convert those parameters from &lt;em&gt;opendata(J)&lt;/em&gt; to &lt;em&gt;J&lt;/em&gt;. In a proxy generated by &lt;a href=&quot;jmx#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)&quot;&gt;&lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt;&lt;/a&gt;, it is the return values of the methods in the MXBean interface that must be reconstructible.</source>
          <target state="translated">If there is a way to convert &lt;em&gt;opendata(J)&lt;/em&gt; back to &lt;em&gt;J&lt;/em&gt; then we say that &lt;em&gt;J&lt;/em&gt; is &lt;em&gt;reconstructible&lt;/em&gt;. All method parameters in an MXBean interface must be reconstructible, because when the MXBean framework is invoking a method it will need to convert those parameters from &lt;em&gt;opendata(J)&lt;/em&gt; to &lt;em&gt;J&lt;/em&gt;. In a proxy generated by &lt;a href=&quot;jmx#newMXBeanProxy(javax.management.MBeanServerConnection,javax.management.ObjectName,java.lang.Class)&quot;&gt; &lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt; &lt;/a&gt;, it is the return values of the methods in the MXBean interface that must be reconstructible.</target>
        </trans-unit>
        <trans-unit id="f00389ed8595939dc871f12e3fcfe41a5531ae8a" translate="yes" xml:space="preserve">
          <source>If there is a way to convert &lt;em&gt;opendata(J)&lt;/em&gt; back to &lt;em&gt;J&lt;/em&gt; then we say that &lt;em&gt;J&lt;/em&gt; is &lt;em&gt;reconstructible&lt;/em&gt;. All method parameters in an MXBean interface must be reconstructible, because when the MXBean framework is invoking a method it will need to convert those parameters from &lt;em&gt;opendata(J)&lt;/em&gt; to &lt;em&gt;J&lt;/em&gt;. In a proxy generated by &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt;&lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt;&lt;/a&gt;, it is the return values of the methods in the MXBean interface that must be reconstructible.</source>
          <target state="translated">&lt;em&gt;opendata (J)&lt;/em&gt; 를 &lt;em&gt;J&lt;/em&gt; 로 다시 변환하는 방법이 있다면 &lt;em&gt;J&lt;/em&gt; 는 &lt;em&gt;재구성 가능&lt;/em&gt; 하다고 말합니다 . MXBean 프레임 워크가 메소드를 호출 할 때 메소드를 &lt;em&gt;opendata (J)&lt;/em&gt; 에서 &lt;em&gt;J&lt;/em&gt; 로 변환해야하기 때문에 MXBean 인터페이스의 모든 메소드 매개 변수는 재구성 가능해야합니다 . &lt;a href=&quot;jmx#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-&quot;&gt; &lt;code&gt;JMX.newMXBeanProxy&lt;/code&gt; &lt;/a&gt; 에 의해 생성 된 프록시에서 , 그것은 재구성 가능해야하는 MXBean 인터페이스에있는 메소드의 리턴 값입니다.</target>
        </trans-unit>
        <trans-unit id="b80859daf00685681791770cf08af14640ed386a" translate="yes" xml:space="preserve">
          <source>If there is an embedded exception, and if the SAXException has no detail message of its own, this method will return the detail message from the embedded exception.</source>
          <target state="translated">If there is an embedded exception, and if the SAXException has no detail message of its own, this method will return the detail message from the embedded exception.</target>
        </trans-unit>
        <trans-unit id="d2e96a33766dec8129dace08a450401d0d9f28dc" translate="yes" xml:space="preserve">
          <source>If there is an error while loading or scaling an image, that image is considered to have finished loading. Use the &lt;code&gt;isErrorAny&lt;/code&gt; and &lt;code&gt;isErrorID&lt;/code&gt; methods to check for errors.</source>
          <target state="translated">If there is an error while loading or scaling an image, that image is considered to have finished loading. Use the &lt;code&gt;isErrorAny&lt;/code&gt; and &lt;code&gt;isErrorID&lt;/code&gt; methods to check for errors.</target>
        </trans-unit>
        <trans-unit id="a5644f977cf03bc3dcfd54d5e5282d96e0e8e7ab" translate="yes" xml:space="preserve">
          <source>If there is an error while loading or scaling an image, then that image is considered to have finished loading. Use the &lt;code&gt;isErrorAny&lt;/code&gt; and &lt;code&gt;isErrorID&lt;/code&gt; methods to check for errors.</source>
          <target state="translated">If there is an error while loading or scaling an image, then that image is considered to have finished loading. Use the &lt;code&gt;isErrorAny&lt;/code&gt; and &lt;code&gt;isErrorID&lt;/code&gt; methods to check for errors.</target>
        </trans-unit>
        <trans-unit id="dac5311ab03433886854f19241b442e660113c11" translate="yes" xml:space="preserve">
          <source>If there is an error while loading or scaling an image, then that image is considered to have finished loading. Use the &lt;code&gt;isErrorAny&lt;/code&gt; or &lt;code&gt;isErrorID&lt;/code&gt; methods to check for errors.</source>
          <target state="translated">If there is an error while loading or scaling an image, then that image is considered to have finished loading. Use the &lt;code&gt;isErrorAny&lt;/code&gt; or &lt;code&gt;isErrorID&lt;/code&gt; methods to check for errors.</target>
        </trans-unit>
        <trans-unit id="46881d0768f79ef8afcf68abaa71937fc7171ad1" translate="yes" xml:space="preserve">
          <source>If there is an error while loading or scaling an image, then that image is considered to have finished loading. Use the &lt;code&gt;statusID&lt;/code&gt;, &lt;code&gt;isErrorID&lt;/code&gt;, and &lt;code&gt;isErrorAny&lt;/code&gt; methods to check for errors.</source>
          <target state="translated">If there is an error while loading or scaling an image, then that image is considered to have finished loading. Use the &lt;code&gt;statusID&lt;/code&gt; , &lt;code&gt;isErrorID&lt;/code&gt; , and &lt;code&gt;isErrorAny&lt;/code&gt; methods to check for errors.</target>
        </trans-unit>
        <trans-unit id="b8ec246e3bef63fa40b6bd7a53890c4d682a9eac" translate="yes" xml:space="preserve">
          <source>If there is an existing owner different from the argument &lt;code&gt;owner&lt;/code&gt;, that owner is notified that it no longer holds ownership of the clipboard contents via an invocation of &lt;code&gt;ClipboardOwner.lostOwnership()&lt;/code&gt; on that owner. An implementation of &lt;code&gt;setContents()&lt;/code&gt; is free not to invoke &lt;code&gt;lostOwnership()&lt;/code&gt; directly from this method. For example, &lt;code&gt;lostOwnership()&lt;/code&gt; may be invoked later on a different thread. The same applies to &lt;code&gt;FlavorListener&lt;/code&gt;s registered on this clipboard.</source>
          <target state="translated">If there is an existing owner different from the argument &lt;code&gt;owner&lt;/code&gt; , that owner is notified that it no longer holds ownership of the clipboard contents via an invocation of &lt;code&gt;ClipboardOwner.lostOwnership()&lt;/code&gt; on that owner. An implementation of &lt;code&gt;setContents()&lt;/code&gt; is free not to invoke &lt;code&gt;lostOwnership()&lt;/code&gt; directly from this method. For example, &lt;code&gt;lostOwnership()&lt;/code&gt; may be invoked later on a different thread. The same applies to &lt;code&gt;FlavorListener&lt;/code&gt; s registered on this clipboard.</target>
        </trans-unit>
        <trans-unit id="9bde7f17c2deabb0575bd222ed2f85f576a5ede8" translate="yes" xml:space="preserve">
          <source>If there is any error (say, I/O error or format error) during the reading process of the KeyTab file, a saved result should be returned. If there is no saved result (say, this is the first time this method is called, or, all previous read attempts failed), an empty array should be returned. This can make sure the result is not drastically changed during the (probably slow) update of the keytab file.</source>
          <target state="translated">KeyTab 파일을 읽는 과정에서 오류 (예 : I / O 오류 또는 형식 오류)가 있으면 저장된 결과가 반환되어야합니다. 저장된 결과가없는 경우 (즉,이 메소드가 처음 호출되거나 모든 이전 읽기 시도가 실패한 경우) 빈 배열이 리턴되어야합니다. 이를 통해 키탭 파일을 업데이트하는 동안 (아마도 느린) 결과가 크게 변경되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20616256852615e42dbadb55ba5815746032d11a" translate="yes" xml:space="preserve">
          <source>If there is any error (say, I/O error or format error) during the reading process of the keytab file, a saved result should be returned. If there is no saved result (say, this is the first time this method is called, or, all previous read attempts failed), an empty array should be returned. This can make sure the result is not drastically changed during the (probably slow) update of the keytab file.</source>
          <target state="translated">If there is any error (say, I/O error or format error) during the reading process of the keytab file, a saved result should be returned. If there is no saved result (say, this is the first time this method is called, or, all previous read attempts failed), an empty array should be returned. This can make sure the result is not drastically changed during the (probably slow) update of the keytab file.</target>
        </trans-unit>
        <trans-unit id="e2521f70370beeb7a65247f5ecdb6409da533aa1" translate="yes" xml:space="preserve">
          <source>If there is any inherited context, then it has already been copied into the &lt;code&gt;URL&lt;/code&gt; argument.</source>
          <target state="translated">상속 된 컨텍스트가 있으면 이미 &lt;code&gt;URL&lt;/code&gt; 인수에 복사 된 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1538c9e56cc4a72171a55abc846e5acdad6ad5c5" translate="yes" xml:space="preserve">
          <source>If there is at least one getter and every getter has a convertible type, then &lt;em&gt;opentype(J)&lt;/em&gt; is a &lt;code&gt;
      CompositeType&lt;/code&gt; with one item for every getter. If the getter is</source>
          <target state="translated">If there is at least one getter and every getter has a convertible type, then &lt;em&gt;opentype(J)&lt;/em&gt; is a &lt;code&gt; CompositeType&lt;/code&gt; with one item for every getter. If the getter is</target>
        </trans-unit>
        <trans-unit id="ce492db546ed8f744751a5952cc84069d57cdf28" translate="yes" xml:space="preserve">
          <source>If there is at least one getter and every getter has a convertible type, then &lt;em&gt;opentype(J)&lt;/em&gt; is a &lt;code&gt;CompositeType&lt;/code&gt; with one item for every getter. If the getter is</source>
          <target state="translated">적어도 하나의 getter가 있고 모든 getter에 컨버터블 유형이있는 경우 &lt;em&gt;opentype (J)&lt;/em&gt; 는 모든 getter에 대해 하나의 항목 이있는 &lt;code&gt;CompositeType&lt;/code&gt; 입니다. 게터가</target>
        </trans-unit>
        <trans-unit id="f0a5ce38d1565c12f161531f62c2ed657aa770d3" translate="yes" xml:space="preserve">
          <source>If there is exactly one such interface, or if there is one such interface that is a subinterface of all the others, then the object is an MXBean. The interface in question is the &lt;em&gt;MXBean interface&lt;/em&gt;. In the example above, the MXBean interface is &lt;code&gt;MemoryPoolMXBean&lt;/code&gt;.</source>
          <target state="translated">그러한 인터페이스가 정확히 하나이거나 다른 인터페이스의 서브 인터페이스 인 인터페이스가 있으면 객체는 MXBean입니다. 문제의 인터페이스는 &lt;em&gt;MXBean 인터페이스&lt;/em&gt; 입니다. 위의 예에서 MXBean 인터페이스는 &lt;code&gt;MemoryPoolMXBean&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2719aa3eb5a7fffd1ca38e949931f67f1421af57" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;serviceURL&lt;/code&gt;, there must be a user-provided &lt;code&gt;RMIServerImpl&lt;/code&gt;. If the &lt;a href=&quot;rmiserverimpl#toStub--&quot;&gt;&lt;code&gt;toStub&lt;/code&gt;&lt;/a&gt; method on this object returns an instance of &lt;a href=&quot;/openjdk~8_web/javax/rmi/corba/stub&quot;&gt;&lt;code&gt;Stub&lt;/code&gt;&lt;/a&gt;, then the connector server will generate a &lt;code&gt;JMXServiceURL&lt;/code&gt; using the &lt;code&gt;iiop&lt;/code&gt; form above. Otherwise, it will generate a &lt;code&gt;JMXServiceURL&lt;/code&gt; using the &lt;code&gt;rmi&lt;/code&gt; form.</source>
          <target state="translated">&lt;code&gt;serviceURL&lt;/code&gt; 이 없으면 사용자 제공 &lt;code&gt;RMIServerImpl&lt;/code&gt; 이 있어야합니다 . 이 오브젝트 의 &lt;a href=&quot;rmiserverimpl#toStub--&quot;&gt; &lt;code&gt;toStub&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;/openjdk~8_web/javax/rmi/corba/stub&quot;&gt; &lt;code&gt;Stub&lt;/code&gt; &lt;/a&gt; 인스턴스를 리턴하면 , 커넥터 서버는 위 의 &lt;code&gt;iiop&lt;/code&gt; 양식을 사용하여 &lt;code&gt;JMXServiceURL&lt;/code&gt; 을 생성합니다 . 그렇지 않으면 &lt;code&gt;rmi&lt;/code&gt; 양식을 사용하여 &lt;code&gt;JMXServiceURL&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="8a2bf9ecdfc5d61123d9e4fc43dc1ffa56add6c1" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;serviceURL&lt;/code&gt;, there must be a user-provided &lt;code&gt;RMIServerImpl&lt;/code&gt;. The connector server will generate a &lt;code&gt;JMXServiceURL&lt;/code&gt; using the &lt;code&gt;rmi&lt;/code&gt; form.</source>
          <target state="translated">If there is no &lt;code&gt;serviceURL&lt;/code&gt; , there must be a user-provided &lt;code&gt;RMIServerImpl&lt;/code&gt; . The connector server will generate a &lt;code&gt;JMXServiceURL&lt;/code&gt; using the &lt;code&gt;rmi&lt;/code&gt; form.</target>
        </trans-unit>
        <trans-unit id="f8c7ed9aa34be8bbca1c409e4e9d8af9947fac39" translate="yes" xml:space="preserve">
          <source>If there is no association existing between this channel's socket and the intended receiver, identified by the address in the given messageInfo, then one will be automatically setup to the intended receiver. This is considered to be Implicit Association Setup. Upon successful association setup, an &lt;a href=&quot;associationchangenotification&quot;&gt;&lt;code&gt;association changed&lt;/code&gt;&lt;/a&gt; notification will be put to the SCTP stack with its &lt;code&gt;event&lt;/code&gt; parameter set to &lt;a href=&quot;associationchangenotification.assocchangeevent#COMM_UP&quot;&gt;&lt;code&gt;COMM_UP&lt;/code&gt;&lt;/a&gt; . This notification can be received by invoking &lt;a href=&quot;#receive(java.nio.ByteBuffer,T,com.sun.nio.sctp.NotificationHandler)&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 messageInfo의 주소로 식별되는이 채널의 소켓과 의도 한 수신자 사이에 존재하는 연관이없는 경우, 하나는 의도 된 수신자에 자동으로 설정됩니다. 이것은 암시 적 연관 설정으로 간주됩니다. 연결 설정이 성공하면 &lt;a href=&quot;associationchangenotification&quot;&gt; &lt;code&gt;association changed&lt;/code&gt; &lt;/a&gt; 알림이 &lt;code&gt;event&lt;/code&gt; 매개 변수가 &lt;a href=&quot;associationchangenotification.assocchangeevent#COMM_UP&quot;&gt; &lt;code&gt;COMM_UP&lt;/code&gt; 으로&lt;/a&gt; 설정된 SCTP 스택 에 저장 됩니다. 이 알림은 &lt;a href=&quot;#receive(java.nio.ByteBuffer,T,com.sun.nio.sctp.NotificationHandler)&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 를 호출하여 받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cc3dec11f4378075a31721786189ded4db361d5" translate="yes" xml:space="preserve">
          <source>If there is no current set of system properties, a set of system properties is first created and initialized in the same manner as for the &lt;code&gt;getProperties&lt;/code&gt; method.</source>
          <target state="translated">현재 시스템 특성 세트가없는 경우 &lt;code&gt;getProperties&lt;/code&gt; 메소드 와 동일한 방식으로 시스템 특성 세트가 먼저 작성되고 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="62385658f9c9d30f2326007c7be1947af3806233" translate="yes" xml:space="preserve">
          <source>If there is no display name for the locale then a suitable default must be returned.</source>
          <target state="translated">로케일의 표시 이름이 없으면 적절한 기본값을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="14d757aed623c13896747a1cb10d2fafe0c24ef5" translate="yes" xml:space="preserve">
          <source>If there is no entry for a particular principal, then the principal is considered to have a null (empty) permission set.</source>
          <target state="translated">특정 프린시 펄에 대한 항목이 없으면 프린시 펄에는 널 (빈) 권한 세트가있는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="83cc3943509d49fbbe54f8e7d0348cb9ef645fa2" translate="yes" xml:space="preserve">
          <source>If there is no entry in this Access Control List for the specified principal, an empty permission set is returned.</source>
          <target state="translated">이 액세스 제어 목록에 지정된 보안 주체에 대한 항목이 없으면 빈 권한 집합이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="97ef1aceb0bd9ccbc5a3e085bc385c17a96da05c" translate="yes" xml:space="preserve">
          <source>If there is no index position at which they differ, then the shorter string lexicographically precedes the longer string. In this case, &lt;code&gt;compareTo&lt;/code&gt; returns the difference of the lengths of the strings -- that is, the value:</source>
          <target state="translated">서로 다른 인덱스 위치가 없으면 짧은 문자열이 사전 식으로 긴 문자열보다 앞에옵니다. 이 경우 &lt;code&gt;compareTo&lt;/code&gt; 는 문자열 길이의 차이, 즉 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a5b86c82cbb33ba85e2cf972377173b04ef65d60" translate="yes" xml:space="preserve">
          <source>If there is no input method or keyboard layout available that supports the requested locale, the current input method or keyboard layout remains selected.</source>
          <target state="translated">If there is no input method or keyboard layout available that supports the requested locale, the current input method or keyboard layout remains selected.</target>
        </trans-unit>
        <trans-unit id="f38d945bc914e61ae40e4aad1f19fc041a605394" translate="yes" xml:space="preserve">
          <source>If there is no match, then either the first or last index is used, depending on whether the number (X) is too low or too high. If the limit array is not in ascending order, the results of formatting will be incorrect. ChoiceFormat also accepts &lt;code&gt;\u221E&lt;/code&gt; as equivalent to infinity(INF).</source>
          <target state="translated">일치하는 항목이 없으면 숫자 (X)가 너무 낮거나 높은지 여부에 따라 첫 번째 또는 마지막 색인이 사용됩니다. 한계 배열이 오름차순이 아닌 경우 서식 결과가 올바르지 않습니다. ChoiceFormat은 또한 무한대 (INF)와 동등한 &lt;code&gt;\u221E&lt;/code&gt; 를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="2648977b5bfdd7de94f30791f17e5163fa9fa3c2" translate="yes" xml:space="preserve">
          <source>If there is no parent reader set, any attempt to parse or to set or get a feature or property will fail.</source>
          <target state="translated">If there is no parent reader set, any attempt to parse or to set or get a feature or property will fail.</target>
        </trans-unit>
        <trans-unit id="f3d0e4d2da1282aaec455fc4732cff1c598c3d7c" translate="yes" xml:space="preserve">
          <source>If there is no property with the specified name, if the specified name is empty or &lt;code&gt;null&lt;/code&gt;, or if the property does not have the correct numeric format, then &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 이름의 속성이 없거나 지정된 이름이 비어 있거나 &lt;code&gt;null&lt;/code&gt; 이거나 속성에 올바른 숫자 형식이없는 경우 &lt;code&gt;null&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ebec043b114adf3a66c121103ae990378ebe9b9b" translate="yes" xml:space="preserve">
          <source>If there is no property with the specified name, or if the specified name is empty or null, then &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 이름의 속성이 없거나 지정된 이름이 비어 있거나 null 인 경우 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="217c4e72fc9b4dd43cf1ac4eaa272b71123427a9" translate="yes" xml:space="preserve">
          <source>If there is no such parameter list, the external parameter list is taken to be the empty sequence.</source>
          <target state="translated">If there is no such parameter list, the external parameter list is taken to be the empty sequence.</target>
        </trans-unit>
        <trans-unit id="62eecfe9a255148d750e0784a244f5d095566c9e" translate="yes" xml:space="preserve">
          <source>If there is one or more timer notifications before the time in the list of notifications, the notification is sent according to the &lt;code&gt;sendPastNotifications&lt;/code&gt; flag and then, updated according to its period and remaining number of occurrences. If the timer notification date remains earlier than the current date, this notification is just removed from the list of notifications.</source>
          <target state="translated">통지 목록에 시간 이전에 하나 이상의 타이머 통지가있는 경우, 통지는 &lt;code&gt;sendPastNotifications&lt;/code&gt; 플래그 에 따라 전송 된 후,주기 및 남은 발생 횟수에 따라 업데이트됩니다. 타이머 알림 날짜가 현재 날짜보다 빠른 경우이 알림은 알림 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b3edef51748fde1dc3cb9b0db38c74d836448067" translate="yes" xml:space="preserve">
          <source>If these fields have not been set, meaning that the &lt;code&gt;execute&lt;/code&gt; method has not executed successfully, no methods other than &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;close&lt;/code&gt; may be called on the rowset. All other public methods will throw an exception.</source>
          <target state="translated">If these fields have not been set, meaning that the &lt;code&gt;execute&lt;/code&gt; method has not executed successfully, no methods other than &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;close&lt;/code&gt; may be called on the rowset. All other public methods will throw an exception.</target>
        </trans-unit>
        <trans-unit id="da9dbbb1b206e8e0a44cdf5f294d39074c1d1013" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface that implements no interfaces, the method returns an array of length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 인터페이스를 구현하지 않는 클래스 또는 인터페이스를 나타내는 경우 메서드는 길이가 0 인 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bea1d12841642f06cd5c576dd8ad73a21f49fc5b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface whose declaration does not explicitly indicate any annotated superinterfaces, the return value is an array of length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 선언에 주석이 붙은 슈퍼 인터페이스를 명시 적으로 나타내지 않는 클래스 또는 인터페이스를 나타내는 경우, 반환 값은 길이가 0의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="6e8416f8b31967b12db27ca7304aeef5569fa6c8" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface with no accessible public fields, then this method returns an array of length 0.</source>
          <target state="translated">If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface with no accessible public fields, then this method returns an array of length 0.</target>
        </trans-unit>
        <trans-unit id="94f6da01be13858770dcd2fbeb1c8376bf8f27d5" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface with no declared fields, then this method returns an array of length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 선언 된 필드가없는 클래스 또는 인터페이스를 나타내는 경우이 메소드는 길이가 0 인 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c5e526ec67c2b068f6813c00e0742ddec3d6151e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface with no declared methods, then the returned array has length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 선언 된 메서드가없는 클래스 또는 인터페이스를 나타내는 경우 반환 된 배열의 길이는 0입니다.</target>
        </trans-unit>
        <trans-unit id="d4ce471ae16ab801b2259a590ff7a0fee5c25fdb" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface with no no accessible public fields, then this method returns an array of length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 액세스 가능한 공개 필드가없는 클래스 또는 인터페이스를 나타내는 경우 ,이 메소드는 길이가 0 인 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="89bb69095909bff1e8994753820a646783cdac75" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class or interface, not an array class, then:</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 클래스가 아닌 클래스 또는 인터페이스를 나타내는 경우 :</target>
        </trans-unit>
        <trans-unit id="c664406d0522e22c26f8aa4cf18c2f0c9efc994e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class, the return value is an array containing objects representing all interfaces directly implemented by the class. The order of the interface objects in the array corresponds to the order of the interface names in the &lt;code&gt;implements&lt;/code&gt; clause of the declaration of the class represented by this &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 클래스를 나타내는 경우 반환 값은 클래스에서 직접 구현 한 모든 인터페이스를 나타내는 객체를 포함하는 배열입니다. 배열에있는 인터페이스 객체의 순서는 이 &lt;code&gt;Class&lt;/code&gt; 객체가 나타내는 클래스 선언의 &lt;code&gt;implements&lt;/code&gt; 절에있는 인터페이스 이름의 순서와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="db27714da382f703a913c7a11179d75442553bce" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class, the return value is an array containing objects representing all interfaces directly implemented by the class. The order of the interface objects in the array corresponds to the order of the interface names in the &lt;code&gt;implements&lt;/code&gt; clause of the declaration of the class represented by this &lt;code&gt;Class&lt;/code&gt; object. For example, given the declaration:</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 클래스를 나타내는 경우 반환 값은 클래스에서 직접 구현 한 모든 인터페이스를 나타내는 객체를 포함하는 배열입니다. 배열에있는 인터페이스 객체의 순서는 이 &lt;code&gt;Class&lt;/code&gt; 객체가 나타내는 클래스 선언의 &lt;code&gt;implements&lt;/code&gt; 절에있는 인터페이스 이름의 순서와 일치 합니다. 예를 들어 다음과 같은 선언이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9c0f2616e4b918558184c0ef2f121a34cc9b89a" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class, the return value is an array containing objects representing the uses of interface types to specify interfaces implemented by the class. The order of the objects in the array corresponds to the order of the interface types used in the 'implements' clause of the declaration of this &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 클래스를 나타내는 경우 , 반환 값은 클래스에 의해 구현되는 인터페이스를 지정하기위한 인터페이스 타입의 사용을 나타내는 객체를 포함한 배열입니다. 배열 내의 객체의 순서는이 &lt;code&gt;Class&lt;/code&gt; 객체 의 선언의 'implementation'절에 사용되는 인터페이스 타입의 순서에 대응 합니다.</target>
        </trans-unit>
        <trans-unit id="972bf4d56f599ffc46c00671b73ed210f8ab96fd" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class, then this method returns the public fields of the class and of all its superclasses and superinterfaces.</source>
          <target state="translated">If this &lt;code&gt;Class&lt;/code&gt; object represents a class, then this method returns the public fields of the class and of all its superclasses and superinterfaces.</target>
        </trans-unit>
        <trans-unit id="8ea0225aadb3a9617c32673581f4007aea0f62a1" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a class, then this method returns the public fields of the class and of all its superclasses.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 클래스를 나타내는 경우 ,이 메소드는 클래스와 모든 슈퍼 클래스의 공개 필드를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="19efbdc41b97ce163692b9570014a1cf2d915716" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a local or anonymous class within a constructor, returns a &lt;a href=&quot;reflect/constructor&quot;&gt;&lt;code&gt;Constructor&lt;/code&gt;&lt;/a&gt; object representing the immediately enclosing constructor of the underlying class.</source>
          <target state="translated">If this &lt;code&gt;Class&lt;/code&gt; object represents a local or anonymous class within a constructor, returns a &lt;a href=&quot;reflect/constructor&quot;&gt; &lt;code&gt;Constructor&lt;/code&gt; &lt;/a&gt; object representing the immediately enclosing constructor of the underlying class.</target>
        </trans-unit>
        <trans-unit id="42af070ad6a4d3648b309df9a277dd2d8e338352" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a local or anonymous class within a constructor, returns a &lt;a href=&quot;reflect/constructor&quot;&gt;&lt;code&gt;Constructor&lt;/code&gt;&lt;/a&gt; object representing the immediately enclosing constructor of the underlying class. Returns &lt;code&gt;null&lt;/code&gt; otherwise. In particular, this method returns &lt;code&gt;null&lt;/code&gt; if the underlying class is a local or anonymous class immediately enclosed by a type declaration, instance initializer or static initializer.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 생성자 내에서 로컬 또는 익명 클래스를 나타내는 경우 기본 클래스의 즉시 둘러싸는 생성자를 나타내는 &lt;a href=&quot;reflect/constructor&quot;&gt; &lt;code&gt;Constructor&lt;/code&gt; &lt;/a&gt; 객체를 반환합니다 . 반환 값은 &lt;code&gt;null&lt;/code&gt; 이 없습니다. 특히, 기본이되는 클래스가 타입 선언, 인스턴스 이니셜 라이저 또는 정적 이니셜 라이저로 즉시 둘러싸인 로컬 또는 익명의 클래스 인 경우 ,이 메소드는 &lt;code&gt;null&lt;/code&gt; 를 돌려 줍니다 .</target>
        </trans-unit>
        <trans-unit id="97ef3bf0bcc99ac4678b3a68f5947eddd7c49a75" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a local or anonymous class within a method, returns a &lt;a href=&quot;reflect/method&quot;&gt;&lt;code&gt;Method&lt;/code&gt;&lt;/a&gt; object representing the immediately enclosing method of the underlying class.</source>
          <target state="translated">If this &lt;code&gt;Class&lt;/code&gt; object represents a local or anonymous class within a method, returns a &lt;a href=&quot;reflect/method&quot;&gt; &lt;code&gt;Method&lt;/code&gt; &lt;/a&gt; object representing the immediately enclosing method of the underlying class.</target>
        </trans-unit>
        <trans-unit id="4477ae736ceef4ce368b1839297468a2918b1155" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a local or anonymous class within a method, returns a &lt;a href=&quot;reflect/method&quot;&gt;&lt;code&gt;Method&lt;/code&gt;&lt;/a&gt; object representing the immediately enclosing method of the underlying class. Returns &lt;code&gt;null&lt;/code&gt; otherwise. In particular, this method returns &lt;code&gt;null&lt;/code&gt; if the underlying class is a local or anonymous class immediately enclosed by a type declaration, instance initializer or static initializer.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 메서드 내에서 로컬 또는 익명 클래스를 나타내는 경우 기본 클래스의 바로 묶는 메서드를 나타내는 &lt;a href=&quot;reflect/method&quot;&gt; &lt;code&gt;Method&lt;/code&gt; &lt;/a&gt; 객체를 반환합니다 . 반환 값은 &lt;code&gt;null&lt;/code&gt; 이 없습니다. 특히, 기본이되는 클래스가 타입 선언, 인스턴스 이니셜 라이저 또는 정적 이니셜 라이저로 즉시 둘러싸인 로컬 또는 익명의 클래스 인 경우 ,이 메소드는 &lt;code&gt;null&lt;/code&gt; 를 돌려 줍니다 .</target>
        </trans-unit>
        <trans-unit id="2a3ae28f0cc9994a8418c1f25794acf0dba7ddbd" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type or &lt;code&gt;void&lt;/code&gt;, then the result is a field descriptor string which is a one-letter code corresponding to a primitive type or &lt;code&gt;void&lt;/code&gt; (&lt;code&gt;&quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;&lt;/code&gt;) (JVMS &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.3.2&quot;&gt;4.3.2&lt;/a&gt;).</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 기본 유형 또는 &lt;code&gt;void&lt;/code&gt; 를 나타내는 경우 결과는 기본 유형 또는 &lt;code&gt;void&lt;/code&gt; ( &lt;code&gt;&quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;&lt;/code&gt; ) (JVMS &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.3.2&quot;&gt;4.3.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eddd017ac2fa648338a5adfef36719dffa6cd4a7" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type or &lt;code&gt;void&lt;/code&gt;, then the result is a string with the same spelling as the Java language keyword which corresponds to the primitive type or &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 기본 유형 또는 &lt;code&gt;void&lt;/code&gt; 를 나타내는 경우 결과는 기본 유형 또는 &lt;code&gt;void&lt;/code&gt; 에 해당하는 Java 언어 키워드와 동일한 철자를 가진 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="0ce8f59b51441dc3e0dfd4f500ca0b103d2aa378" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type or void, null is returned.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 기본 유형 또는 void를 나타내는 경우 null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e7e1076c9609cebd2628d37243affd492d58bbb2" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type or void, the method returns an array of length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 기본 유형 또는 void를 나타내는 경우 메서드는 길이가 0 인 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="79bd7175460e43940d330fea2bc43e369e031bbb" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type or void, then the returned array has length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 프리미티브 유형 또는 void를 나타내는 경우 반환 된 배열의 길이는 0입니다.</target>
        </trans-unit>
        <trans-unit id="3854e372a9cd1fcdc624d6d86e1f2d3b92f49c92" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type, an array type, or &lt;code&gt;void&lt;/code&gt;, then this method returns &lt;code&gt;this&lt;/code&gt;, indicating that the represented entity belongs to the nest consisting only of itself, and is the nest host.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 기본 유형, 배열 유형 또는 &lt;code&gt;void&lt;/code&gt; 를 나타내는 경우이 메서드는 &lt;code&gt;this&lt;/code&gt; 를 반환 하여 표현 된 엔티티가 자신으로 만 구성된 중첩에 속하고 중첩 호스트임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="acfe2652412126a5eafdde5443108fc5fd2020f2" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a primitive type, an array type, or &lt;code&gt;void&lt;/code&gt;, then this method returns a single-element array containing &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 기본 유형, 배열 유형 또는 &lt;code&gt;void&lt;/code&gt; 를 나타내는 경우이 메서드는 &lt;code&gt;this&lt;/code&gt; 를 포함하는 단일 요소 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f02c0ed1f5bae30d0291b5a6aaf11110bd96f07d" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type that has a class initialization method &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;, then the returned array does &lt;em&gt;not&lt;/em&gt; have a corresponding &lt;code&gt;Method&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 클래스 초기화 메소드 &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; 를 가지는 타입을 나타내는 경우 , 반환되는 배열에는 대응하는 &lt;code&gt;Method&lt;/code&gt; 객체 가 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b86687e1e312e67b7460fddd5aed10106e1e53" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type that has multiple declared methods with the same name and parameter types, but different return types, then the returned array has a &lt;code&gt;Method&lt;/code&gt; object for each such method.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 같은 이름과 파라미터 타입을 가지지 만, 리턴 타입이 다른 선언 된 메소드가 여러 개있는 타입을 나타내는 경우 , 반환 된 배열에는 그러한 각 &lt;code&gt;Method&lt;/code&gt; 대한 Method 오브젝트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a5139658d7d0116078759c8a142a520e5a7e171" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type that has multiple public methods with the same name and parameter types, but different return types, then the returned array has a &lt;code&gt;Method&lt;/code&gt; object for each such method.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가, 이름과 파라미터 타입은 같지만 리턴 타입이 다른 복수의 퍼블릭 메소드를 가지는 타입을 나타내는 경우 , 반환 된 배열에는 그러한 각 &lt;code&gt;Method&lt;/code&gt; 대한 Method 오브젝트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9710c2aebb0499fff54a4c1fab48952630f8353" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type whose declaration does not explicitly indicate an annotated superclass, then the return value is an &lt;code&gt;AnnotatedType&lt;/code&gt; object representing an element with no annotations.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 선언에 주석이 붙은 슈퍼 클래스를 명시 적으로 나타내지 않는 타입을 나타내는 경우 , 반환 값은 &lt;code&gt;AnnotatedType&lt;/code&gt; 이없는 요소를 나타내는 AnnotatedType 객체입니다.</target>
        </trans-unit>
        <trans-unit id="abacab4cf9b024f594f0b3f572123f051f06c2c5" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents a type with a class initialization method &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;, then the returned array does &lt;em&gt;not&lt;/em&gt; have a corresponding &lt;code&gt;Method&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 클래스 초기화 메소드 &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; 를 가지는 타입을 나타내는 경우 , 반환되는 배열에는 대응하는 &lt;code&gt;Method&lt;/code&gt; 객체 가 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="967e996b2092a0d523d490bc35ee89ac74138a79" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array class, then the result is a string consisting of one or more '&lt;code&gt;[&lt;/code&gt;' characters representing the depth of the array nesting, followed by the descriptor string of the element type.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 클래스를 나타내는 경우 결과는 배열 중첩의 깊이를 나타내는 하나 이상의 ' &lt;code&gt;[&lt;/code&gt; '문자와 요소 유형의 설명자 문자열로 구성된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="f14a8b922cdce1119585c5f1a0795f16cbd6be65" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array class, then the result is a string consisting of one or more '&lt;code&gt;[&lt;/code&gt;' characters representing the depth of the array nesting, followed by the element type as encoded using the following table:</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 클래스를 나타내는 경우 결과는 배열 중첩의 깊이를 나타내는 하나 이상의 ' &lt;code&gt;[&lt;/code&gt; '문자와 다음 표를 사용하여 인코딩 된 요소 유형으로 구성된 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="1bebb6eaefac5ae2ce6d923cc8da1eb725883029" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, a primitive type, or void, then the returned array has length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 형, 원시적 형, 또는 void를 나타내는 경우, 반환되는 배열의 길이는 0입니다.</target>
        </trans-unit>
        <trans-unit id="70b797601062908da356817410150aa204020fc1" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, a primitive type, or void, then this method returns an array of length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 형, 원시적 형, 또는 void를 나타내는 경우,이 메소드는 길이가 0 인 배열을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="20332c048f55b2154c66a445225edb4bdb3e274e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, the interfaces &lt;code&gt;Cloneable&lt;/code&gt; and &lt;code&gt;java.io.Serializable&lt;/code&gt; are returned in that order.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 형을 나타내는 경우는 &lt;code&gt;Cloneable&lt;/code&gt; 인터페이스 와 &lt;code&gt;java.io.Serializable&lt;/code&gt; 인터페이스 가 그 순서로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="348539037139d48e6387c9a62912e6564911c876" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, then the returned array has a &lt;code&gt;Method&lt;/code&gt; object for each of the public methods inherited by the array type from &lt;code&gt;Object&lt;/code&gt;. It does not contain a &lt;code&gt;Method&lt;/code&gt; object for &lt;code&gt;clone()&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 형을 나타내는 경우, 돌려 주어진 배열은 &lt;code&gt;Object&lt;/code&gt; 로부터 배열 형에 의해 상속 된 각 공개 메소드에 대한 &lt;code&gt;Method&lt;/code&gt; 오브젝트를가집니다 . &lt;code&gt;clone()&lt;/code&gt; 의 &lt;code&gt;Method&lt;/code&gt; 객체를 포함하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="29e81a940f259cfb7b07c0e245bb52be63c0dd30" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, then this method does not find the &lt;code&gt;clone()&lt;/code&gt; method.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 형을 나타내는 경우,이 메소드는 &lt;code&gt;clone()&lt;/code&gt; 메소드를 찾지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cb178a8f1871d07a34cdb3bb2de9a0c1fb20f2b9" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, then this method does not find the &lt;code&gt;length&lt;/code&gt; field of the array type.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 배열 형을 나타내는 경우,이 메소드는 배열 형 의 &lt;code&gt;length&lt;/code&gt; 필드를 찾지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4bd7f84a076a4583d7107678dfa8e8e6a579b02f" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, then this method finds any public method inherited by the array type from &lt;code&gt;Object&lt;/code&gt; except method &lt;code&gt;clone()&lt;/code&gt;.</source>
          <target state="translated">If this &lt;code&gt;Class&lt;/code&gt; object represents an array type, then this method finds any public method inherited by the array type from &lt;code&gt;Object&lt;/code&gt; except method &lt;code&gt;clone()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c4b35440106aa65e3bd6d1155d9e17869493181" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an interface then the returned array does not contain any implicitly declared methods from &lt;code&gt;Object&lt;/code&gt;. Therefore, if no methods are explicitly declared in this interface or any of its superinterfaces then the returned array has length 0. (Note that a &lt;code&gt;Class&lt;/code&gt; object which represents a class always has public methods, inherited from &lt;code&gt;Object&lt;/code&gt;.)</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 인터페이스를 나타내는 경우, 돌려 주어진 배열은 &lt;code&gt;Object&lt;/code&gt; 로부터 암묵적으로 선언 된 메소드를 포함하지 않습니다 . 따라서이 인터페이스 또는 해당 수퍼 인터페이스에 명시 적으로 선언 된 메소드가없는 경우 반환 된 배열의 길이는 0입니다. &lt;code&gt;Class&lt;/code&gt; 를 나타내는 Class 객체에는 항상 &lt;code&gt;Object&lt;/code&gt; 에서 상속 된 public 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="50a58368b3e27e2351421689396e8aedc8df4704" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an interface then this method does not find any implicitly declared method from &lt;code&gt;Object&lt;/code&gt;. Therefore, if no methods are explicitly declared in this interface or any of its superinterfaces, then this method does not find any method.</source>
          <target state="translated">If this &lt;code&gt;Class&lt;/code&gt; object represents an interface then this method does not find any implicitly declared method from &lt;code&gt;Object&lt;/code&gt; . Therefore, if no methods are explicitly declared in this interface or any of its superinterfaces, then this method does not find any method.</target>
        </trans-unit>
        <trans-unit id="45c9a0ebbda8feb26f5e010d8c8f598fe0c99748" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an interface, the array contains objects representing all interfaces directly extended by the interface. The order of the interface objects in the array corresponds to the order of the interface names in the &lt;code&gt;extends&lt;/code&gt; clause of the declaration of the interface represented by this &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 인터페이스를 나타내는 경우 배열에는 인터페이스에 의해 직접 확장 된 모든 인터페이스를 나타내는 객체가 포함됩니다. 배열에있는 인터페이스 객체의 순서는 이 &lt;code&gt;Class&lt;/code&gt; 객체가 나타내는 인터페이스 선언의 &lt;code&gt;extends&lt;/code&gt; 절에있는 인터페이스 이름의 순서와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="9d2d45c96fc82cd4f5045bb65c083bb3e36fa1de" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an interface, the return value is an array containing objects representing the uses of interface types to specify interfaces directly extended by the interface. The order of the objects in the array corresponds to the order of the interface types used in the 'extends' clause of the declaration of this &lt;code&gt;Class&lt;/code&gt; object.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 인터페이스를 나타내는 경우, 반환 값은 인터페이스에 의해 직접 확장 된 인터페이스를 지정하기위한 인터페이스 타입의 사용을 나타내는 객체를 포함한 배열입니다. 배열의 객체 순서는이 &lt;code&gt;Class&lt;/code&gt; 객체 선언의 'extends'절에 사용 된 인터페이스 유형의 순서와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="0f7aab31089775b3540a55de72ec8246707dca71" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents an interface, then this method returns the fields of the interface and of all its superinterfaces.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 인터페이스를 나타내는 경우,이 메소드는 인터페이스 및 모든 슈퍼 인터페이스의 필드를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="24fcfbcd558d192b46d9d8daf24bd3361c63931e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; object represents either the &lt;code&gt;Object&lt;/code&gt; class, an array type, a primitive type, or void, the return value is an array of length 0.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 객체가 &lt;code&gt;Object&lt;/code&gt; 클래스, 배열 유형, 기본 유형 또는 void를 나타내는 경우 반환 값은 길이가 0 인 배열입니다.</target>
        </trans-unit>
        <trans-unit id="74ef85a38a3ffe3f10aa47e5d033acb048da33fd" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Class&lt;/code&gt; represents either the &lt;code&gt;Object&lt;/code&gt; class, an interface type, an array type, a primitive type, or void, the return value is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Class&lt;/code&gt; 가 &lt;code&gt;Object&lt;/code&gt; 클래스, 인터페이스 유형, 배열 유형, 기본 유형 또는 void를 나타내는 경우, 리턴 값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b79ca71cca6aeb6a7facb903fa697dd31da36756" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Container&lt;/code&gt; is not valid, this method invokes the &lt;code&gt;validateTree&lt;/code&gt; method and marks this &lt;code&gt;Container&lt;/code&gt; as valid. Otherwise, no action is performed.</source>
          <target state="translated">If this &lt;code&gt;Container&lt;/code&gt; is not valid, this method invokes the &lt;code&gt;validateTree&lt;/code&gt; method and marks this &lt;code&gt;Container&lt;/code&gt; as valid. Otherwise, no action is performed.</target>
        </trans-unit>
        <trans-unit id="d61b3bb217a8c25d2209158ddd28a60999b5d264" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Deflater&lt;/code&gt; has been subclassed and the &lt;code&gt;end&lt;/code&gt; method has been overridden, the &lt;code&gt;end&lt;/code&gt; method will be called by the finalization when the deflater is unreachable. But the subclasses should not depend on this specific implementation; the finalization is not reliable and the &lt;code&gt;finalize&lt;/code&gt; method is deprecated to be removed.</source>
          <target state="translated">If this &lt;code&gt;Deflater&lt;/code&gt; has been subclassed and the &lt;code&gt;end&lt;/code&gt; method has been overridden, the &lt;code&gt;end&lt;/code&gt; method will be called by the finalization when the deflater is unreachable. But the subclasses should not depend on this specific implementation; the finalization is not reliable and the &lt;code&gt;finalize&lt;/code&gt; method is deprecated to be removed.</target>
        </trans-unit>
        <trans-unit id="6c005c11b66aec51de31e87c510532c6a448273e" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Field&lt;/code&gt; object is enforcing Java language access control, and the underlying field is inaccessible, the method throws an &lt;code&gt;IllegalAccessException&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Field&lt;/code&gt; 객체가 Java 언어 액세스 제어를 실시하고있어, 기본이되는 필드에 액세스 할 수없는 경우, 메소드는 &lt;code&gt;IllegalAccessException&lt;/code&gt; 을 Throw 합니다.</target>
        </trans-unit>
        <trans-unit id="bfff6651d72785da15b50a35bc44c7be29e967f4" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Field&lt;/code&gt; object is enforcing Java language access control, and the underlying field is inaccessible, the method throws an &lt;code&gt;IllegalAccessException&lt;/code&gt;. If the underlying field is static, the class that declared the field is initialized if it has not already been initialized.</source>
          <target state="translated">이 &lt;code&gt;Field&lt;/code&gt; 객체가 Java 언어 액세스 제어를 실시하고있어, 기본이되는 필드에 액세스 할 수없는 경우, 메소드는 &lt;code&gt;IllegalAccessException&lt;/code&gt; 을 Throw 합니다. 기본 필드가 정적 인 경우 필드를 선언 한 클래스는 아직 초기화되지 않은 경우 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="eb5b424e32b92ab7192512c0fc09ab99276ccc50" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Graphics2D&lt;/code&gt; context is drawing to a &lt;code&gt;Component&lt;/code&gt; on the display screen and the &lt;code&gt;Composite&lt;/code&gt; is a custom object rather than an instance of the &lt;code&gt;AlphaComposite&lt;/code&gt; class, and if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with an &lt;code&gt;AWTPermission(&quot;readDisplayPixels&quot;)&lt;/code&gt; permission.</source>
          <target state="translated">If this &lt;code&gt;Graphics2D&lt;/code&gt; context is drawing to a &lt;code&gt;Component&lt;/code&gt; on the display screen and the &lt;code&gt;Composite&lt;/code&gt; is a custom object rather than an instance of the &lt;code&gt;AlphaComposite&lt;/code&gt; class, and if there is a security manager, its &lt;code&gt;checkPermission&lt;/code&gt; method is called with an &lt;code&gt;AWTPermission(&quot;readDisplayPixels&quot;)&lt;/code&gt; permission.</target>
        </trans-unit>
        <trans-unit id="1dcd83e4433ffbc1ebbf7b8020d46089730ee740" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;HttpResponse&lt;/code&gt; was returned from an invocation of &lt;a href=&quot;#previousResponse()&quot;&gt;&lt;code&gt;previousResponse()&lt;/code&gt;&lt;/a&gt; then this method returns &lt;code&gt;null&lt;/code&gt;</source>
          <target state="translated">If this &lt;code&gt;HttpResponse&lt;/code&gt; was returned from an invocation of &lt;a href=&quot;#previousResponse()&quot;&gt; &lt;code&gt;previousResponse()&lt;/code&gt; &lt;/a&gt; then this method returns &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f7ccb08c5fb1d4a7665d31d16cc3af87c0f7a6b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Inflater&lt;/code&gt; has been subclassed and the &lt;code&gt;end&lt;/code&gt; method has been overridden, the &lt;code&gt;end&lt;/code&gt; method will be called by the finalization when the inflater is unreachable. But the subclasses should not depend on this specific implementation; the finalization is not reliable and the &lt;code&gt;finalize&lt;/code&gt; method is deprecated to be removed.</source>
          <target state="translated">If this &lt;code&gt;Inflater&lt;/code&gt; has been subclassed and the &lt;code&gt;end&lt;/code&gt; method has been overridden, the &lt;code&gt;end&lt;/code&gt; method will be called by the finalization when the inflater is unreachable. But the subclasses should not depend on this specific implementation; the finalization is not reliable and the &lt;code&gt;finalize&lt;/code&gt; method is deprecated to be removed.</target>
        </trans-unit>
        <trans-unit id="66c4254fec3d7e2e4edd4f26fd06d26cd6621cde" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Inflater&lt;/code&gt; has been subclassed and the &lt;code&gt;end&lt;/code&gt; method has been overridden, the &lt;code&gt;end&lt;/code&gt; method will be called when the inflater is unreachable.</source>
          <target state="translated">If this &lt;code&gt;Inflater&lt;/code&gt; has been subclassed and the &lt;code&gt;end&lt;/code&gt; method has been overridden, the &lt;code&gt;end&lt;/code&gt; method will be called when the inflater is unreachable.</target>
        </trans-unit>
        <trans-unit id="c26daa984a3e23882bcf4505853a0f173ed21163" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JInternalFrame&lt;/code&gt; is active, returns the child that has focus.</source>
          <target state="translated">If this &lt;code&gt;JInternalFrame&lt;/code&gt; is active, returns the child that has focus.</target>
        </trans-unit>
        <trans-unit id="bc9401f368e3758d3188ace75004f7819d77e1f2" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JInternalFrame&lt;/code&gt; is active, returns the child that has focus. Otherwise, returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">If this &lt;code&gt;JInternalFrame&lt;/code&gt; is active, returns the child that has focus. Otherwise, returns &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6828b57248dc55ee33f2d0f727d461ced903c7ae" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JTable&lt;/code&gt; is the &lt;code&gt;viewportView&lt;/code&gt; of an enclosing &lt;code&gt;JScrollPane&lt;/code&gt; (the usual situation), configure this &lt;code&gt;ScrollPane&lt;/code&gt; by, amongst other things, installing the table's &lt;code&gt;tableHeader&lt;/code&gt; as the &lt;code&gt;columnHeaderView&lt;/code&gt; of the scroll pane.</source>
          <target state="translated">If this &lt;code&gt;JTable&lt;/code&gt; is the &lt;code&gt;viewportView&lt;/code&gt; of an enclosing &lt;code&gt;JScrollPane&lt;/code&gt; (the usual situation), configure this &lt;code&gt;ScrollPane&lt;/code&gt; by, amongst other things, installing the table's &lt;code&gt;tableHeader&lt;/code&gt; as the &lt;code&gt;columnHeaderView&lt;/code&gt; of the scroll pane.</target>
        </trans-unit>
        <trans-unit id="95bc5377a471ae3598176805da8df7dc9f63dc18" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JTable&lt;/code&gt; is the &lt;code&gt;viewportView&lt;/code&gt; of an enclosing &lt;code&gt;JScrollPane&lt;/code&gt; (the usual situation), configure this &lt;code&gt;ScrollPane&lt;/code&gt; by, amongst other things, installing the table's &lt;code&gt;tableHeader&lt;/code&gt; as the &lt;code&gt;columnHeaderView&lt;/code&gt; of the scroll pane. When a &lt;code&gt;JTable&lt;/code&gt; is added to a &lt;code&gt;JScrollPane&lt;/code&gt; in the usual way, using &lt;code&gt;new JScrollPane(myTable)&lt;/code&gt;, &lt;code&gt;addNotify&lt;/code&gt; is called in the &lt;code&gt;JTable&lt;/code&gt; (when the table is added to the viewport). &lt;code&gt;JTable&lt;/code&gt;'s &lt;code&gt;addNotify&lt;/code&gt; method in turn calls this method, which is protected so that this default installation procedure can be overridden by a subclass.</source>
          <target state="translated">If this &lt;code&gt;JTable&lt;/code&gt; is the &lt;code&gt;viewportView&lt;/code&gt; of an enclosing &lt;code&gt;JScrollPane&lt;/code&gt; (the usual situation), configure this &lt;code&gt;ScrollPane&lt;/code&gt; by, amongst other things, installing the table's &lt;code&gt;tableHeader&lt;/code&gt; as the &lt;code&gt;columnHeaderView&lt;/code&gt; of the scroll pane. When a &lt;code&gt;JTable&lt;/code&gt; is added to a &lt;code&gt;JScrollPane&lt;/code&gt; in the usual way, using &lt;code&gt;new JScrollPane(myTable)&lt;/code&gt; , &lt;code&gt;addNotify&lt;/code&gt; is called in the &lt;code&gt;JTable&lt;/code&gt; (when the table is added to the viewport). &lt;code&gt;JTable&lt;/code&gt; 's &lt;code&gt;addNotify&lt;/code&gt; method in turn calls this method, which is protected so that this default installation procedure can be overridden by a subclass.</target>
        </trans-unit>
        <trans-unit id="971006a579f4cd386294bc03012306a545ec65dd" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JarFile&lt;/code&gt; is a multi-release jar file and is configured to be processed as such, then a search is performed to find and return a &lt;code&gt;JarEntry&lt;/code&gt; that is the latest versioned entry associated with the given entry name. The returned &lt;code&gt;JarEntry&lt;/code&gt; is the versioned entry corresponding to the given base entry name prefixed with the string &lt;code&gt;&quot;META-INF/versions/{n}/&quot;&lt;/code&gt;, for the largest value of &lt;code&gt;n&lt;/code&gt; for which an entry exists. If such a versioned entry does not exist, then the &lt;code&gt;JarEntry&lt;/code&gt; for the base entry is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned if no entries are found. The initial value for the version &lt;code&gt;n&lt;/code&gt; is the maximum version as returned by the method &lt;a href=&quot;#getVersion()&quot;&gt;&lt;code&gt;getVersion()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If this &lt;code&gt;JarFile&lt;/code&gt; is a multi-release jar file and is configured to be processed as such, then a search is performed to find and return a &lt;code&gt;JarEntry&lt;/code&gt; that is the latest versioned entry associated with the given entry name. The returned &lt;code&gt;JarEntry&lt;/code&gt; is the versioned entry corresponding to the given base entry name prefixed with the string &lt;code&gt;&quot;META-INF/versions/{n}/&quot;&lt;/code&gt; , for the largest value of &lt;code&gt;n&lt;/code&gt; for which an entry exists. If such a versioned entry does not exist, then the &lt;code&gt;JarEntry&lt;/code&gt; for the base entry is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned if no entries are found. The initial value for the version &lt;code&gt;n&lt;/code&gt; is the maximum version as returned by the method &lt;a href=&quot;#getVersion()&quot;&gt; &lt;code&gt;getVersion()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a42359b2547fcf0cced67f0b8abbfee7db30652b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JarFile&lt;/code&gt; is a multi-release jar file and is configured to be processed as such, then a search is performed to find and return a &lt;code&gt;ZipEntry&lt;/code&gt; that is the latest versioned entry associated with the given entry name. The returned &lt;code&gt;ZipEntry&lt;/code&gt; is the versioned entry corresponding to the given base entry name prefixed with the string &lt;code&gt;&quot;META-INF/versions/{n}/&quot;&lt;/code&gt;, for the largest value of &lt;code&gt;n&lt;/code&gt; for which an entry exists. If such a versioned entry does not exist, then the &lt;code&gt;ZipEntry&lt;/code&gt; for the base entry is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned if no entries are found. The initial value for the version &lt;code&gt;n&lt;/code&gt; is the maximum version as returned by the method &lt;a href=&quot;#getVersion()&quot;&gt;&lt;code&gt;getVersion()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If this &lt;code&gt;JarFile&lt;/code&gt; is a multi-release jar file and is configured to be processed as such, then a search is performed to find and return a &lt;code&gt;ZipEntry&lt;/code&gt; that is the latest versioned entry associated with the given entry name. The returned &lt;code&gt;ZipEntry&lt;/code&gt; is the versioned entry corresponding to the given base entry name prefixed with the string &lt;code&gt;&quot;META-INF/versions/{n}/&quot;&lt;/code&gt; , for the largest value of &lt;code&gt;n&lt;/code&gt; for which an entry exists. If such a versioned entry does not exist, then the &lt;code&gt;ZipEntry&lt;/code&gt; for the base entry is returned, otherwise &lt;code&gt;null&lt;/code&gt; is returned if no entries are found. The initial value for the version &lt;code&gt;n&lt;/code&gt; is the maximum version as returned by the method &lt;a href=&quot;#getVersion()&quot;&gt; &lt;code&gt;getVersion()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4544200625ea70ebc9bce4110deacb71c8b2c125" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JarFile&lt;/code&gt; is a multi-release jar file and is configured to be processed as such, then an entry in the stream is the latest versioned entry associated with the corresponding base entry name. The maximum version of the latest versioned entry is the version returned by &lt;a href=&quot;#getVersion()&quot;&gt;&lt;code&gt;getVersion()&lt;/code&gt;&lt;/a&gt;. The returned stream may include an entry that only exists as a versioned entry. If the jar file is not a multi-release jar file or the &lt;code&gt;JarFile&lt;/code&gt; is not configured for processing a multi-release jar file, this method returns the same stream that &lt;a href=&quot;#stream()&quot;&gt;&lt;code&gt;stream()&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">If this &lt;code&gt;JarFile&lt;/code&gt; is a multi-release jar file and is configured to be processed as such, then an entry in the stream is the latest versioned entry associated with the corresponding base entry name. The maximum version of the latest versioned entry is the version returned by &lt;a href=&quot;#getVersion()&quot;&gt; &lt;code&gt;getVersion()&lt;/code&gt; &lt;/a&gt;. The returned stream may include an entry that only exists as a versioned entry. If the jar file is not a multi-release jar file or the &lt;code&gt;JarFile&lt;/code&gt; is not configured for processing a multi-release jar file, this method returns the same stream that &lt;a href=&quot;#stream()&quot;&gt; &lt;code&gt;stream()&lt;/code&gt; &lt;/a&gt; returns.</target>
        </trans-unit>
        <trans-unit id="8fc33555c25f80831c0628ad15a0ccf77251dea3" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;JarFile&lt;/code&gt; is not a multi-release jar file or is not configured to be processed as such, then the version returned will be the same as that returned from &lt;a href=&quot;#baseVersion()&quot;&gt;&lt;code&gt;baseVersion()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">If this &lt;code&gt;JarFile&lt;/code&gt; is not a multi-release jar file or is not configured to be processed as such, then the version returned will be the same as that returned from &lt;a href=&quot;#baseVersion()&quot;&gt; &lt;code&gt;baseVersion()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8557e1e1be59bc05bf4e2df145cc3c316c6e80c0" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Locale&lt;/code&gt; has a language, country, or variant that does not satisfy the IETF BCP 47 language tag syntax requirements, this method handles these fields as described below:</source>
          <target state="translated">이 &lt;code&gt;Locale&lt;/code&gt; 에 IETF BCP 47 언어 태그 구문 요구 사항을 충족하지 않는 언어, 국가 또는 변형이있는 경우이 메소드는 아래 설명 된대로 이러한 필드를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f49a3fde11d5db0ed881977831e9e3ba3cc4fab5" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;PopupMenu&lt;/code&gt; is being used as a &lt;code&gt;Menu&lt;/code&gt; (i.e., it has a non-&lt;code&gt;Component&lt;/code&gt; parent), then you cannot call this method on the &lt;code&gt;PopupMenu&lt;/code&gt;.</source>
          <target state="translated">If this &lt;code&gt;PopupMenu&lt;/code&gt; is being used as a &lt;code&gt;Menu&lt;/code&gt; (i.e., it has a non- &lt;code&gt;Component&lt;/code&gt; parent), then you cannot call this method on the &lt;code&gt;PopupMenu&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7731e7aef77ad748710b57493f4b7ea47070b36" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Rectangle&lt;/code&gt; has any dimension less than zero, the rules for &lt;a href=&quot;#NonExistent&quot;&gt;non-existent&lt;/a&gt; rectangles apply. In that case, the new bounds of this &lt;code&gt;Rectangle&lt;/code&gt; will have a location equal to the coordinates of the specified &lt;code&gt;Point&lt;/code&gt; and width and height equal to zero.</source>
          <target state="translated">If this &lt;code&gt;Rectangle&lt;/code&gt; has any dimension less than zero, the rules for &lt;a href=&quot;#NonExistent&quot;&gt;non-existent&lt;/a&gt; rectangles apply. In that case, the new bounds of this &lt;code&gt;Rectangle&lt;/code&gt; will have a location equal to the coordinates of the specified &lt;code&gt;Point&lt;/code&gt; and width and height equal to zero.</target>
        </trans-unit>
        <trans-unit id="1b8dc137f02a58d56274933aac40eb866926b6a8" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Rectangle&lt;/code&gt; has any dimension less than zero, the rules for &lt;a href=&quot;#NonExistent&quot;&gt;non-existent&lt;/a&gt; rectangles apply. In that case, the new bounds of this &lt;code&gt;Rectangle&lt;/code&gt; will have a location equal to the specified coordinates and width and height equal to zero.</source>
          <target state="translated">If this &lt;code&gt;Rectangle&lt;/code&gt; has any dimension less than zero, the rules for &lt;a href=&quot;#NonExistent&quot;&gt;non-existent&lt;/a&gt; rectangles apply. In that case, the new bounds of this &lt;code&gt;Rectangle&lt;/code&gt; will have a location equal to the specified coordinates and width and height equal to zero.</target>
        </trans-unit>
        <trans-unit id="d37a0ebcc6085e0c5c10ef85dea41aa701353317" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;RowSet&lt;/code&gt; object does not maintain a continuous connection with its source of data, it may use a &lt;code&gt;Reader&lt;/code&gt; (a &lt;code&gt;RowSetReader&lt;/code&gt; object) to fill itself with data. In this case, a &lt;code&gt;Reader&lt;/code&gt; will have been registered with this &lt;code&gt;RowSet&lt;/code&gt; object, and the method &lt;code&gt;execute&lt;/code&gt; will call on the &lt;code&gt;Reader&lt;/code&gt;'s &lt;code&gt;readData&lt;/code&gt; method as part of its implementation.</source>
          <target state="translated">If this &lt;code&gt;RowSet&lt;/code&gt; object does not maintain a continuous connection with its source of data, it may use a &lt;code&gt;Reader&lt;/code&gt; (a &lt;code&gt;RowSetReader&lt;/code&gt; object) to fill itself with data. In this case, a &lt;code&gt;Reader&lt;/code&gt; will have been registered with this &lt;code&gt;RowSet&lt;/code&gt; object, and the method &lt;code&gt;execute&lt;/code&gt; will call on the &lt;code&gt;Reader&lt;/code&gt; 's &lt;code&gt;readData&lt;/code&gt; method as part of its implementation.</target>
        </trans-unit>
        <trans-unit id="ae1424f53f74471f85637ef0b51790d77bcaf639" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;SSLEngine&lt;/code&gt; has not yet started its initial handshake, this method will automatically start the handshake.</source>
          <target state="translated">이 &lt;code&gt;SSLEngine&lt;/code&gt; 가 초기 핸드 셰이크를 아직 시작하지 않은 경우이 메소드는 자동으로 핸드 셰이크를 시작합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
