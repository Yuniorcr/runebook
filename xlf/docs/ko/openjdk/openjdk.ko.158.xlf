<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="df4b870fb6b307f47ae3b882d0d392b6a0a27623" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;menuBar&lt;/code&gt; is positioned at the upper edge of the &lt;code&gt;layeredPane&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;menuBar&lt;/code&gt; 의 상부 에지에 위치 &lt;code&gt;layeredPane&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25cc63f27b499ac936092a81d7ae1cac847e5fe0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;messageType&lt;/code&gt; parameter is primarily used to supply a default icon from the look and feel.</source>
          <target state="translated">&lt;code&gt;messageType&lt;/code&gt; 매개 변수는 주로 모양과 느낌에서 기본 아이콘을 제공하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6af76e421d8e057e7b7d9ff20dd9e09a4d087b85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;metaData&lt;/code&gt; parameter can be used to limit the number of I/O operations that this method is required to perform. Passing &lt;code&gt;false&lt;/code&gt; for this parameter indicates that only updates to the file's content need be written to storage; passing &lt;code&gt;true&lt;/code&gt; indicates that updates to both the file's content and metadata must be written, which generally requires at least one more I/O operation. Whether this parameter actually has any effect is dependent upon the underlying operating system and is therefore unspecified.</source>
          <target state="translated">&lt;code&gt;metaData&lt;/code&gt; 파라미터는이 방법을 수행하기 위해 요구되는 I / O 동작들의 수를 제한 할 수있다. 이 매개 변수에 대해 &lt;code&gt;false&lt;/code&gt; 를 전달 하면 파일 내용에 대한 업데이트 만 저장소에 기록해야 함을 나타냅니다. &lt;code&gt;true&lt;/code&gt; 를 전달 하면 파일의 내용과 메타 데이터 모두에 대한 업데이트를 작성해야하며 이는 일반적으로 하나 이상의 I / O 작업이 필요합니다. 이 매개 변수가 실제로 영향을 미치는지 여부는 기본 운영 체제에 따라 다르므로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68681b14e33063683f77b0c98ad6ad810109a928" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;minimum&lt;/code&gt; and &lt;code&gt;maximum&lt;/code&gt; parameters can be &lt;code&gt;null&lt;/code&gt; to indicate that the range doesn't have an upper or lower bound. If &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;stepSize&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, or if both &lt;code&gt;minimum&lt;/code&gt; and &lt;code&gt;maximum&lt;/code&gt; are specified and &lt;code&gt;minimum &amp;gt; maximum&lt;/code&gt; then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. Similarly if &lt;code&gt;(minimum &amp;lt;= value &amp;lt;= maximum&lt;/code&gt;) is false, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.</source>
          <target state="translated">&lt;code&gt;minimum&lt;/code&gt; 및 &lt;code&gt;maximum&lt;/code&gt; 파라미터 일 수 &lt;code&gt;null&lt;/code&gt; 범위는 상부가 없거나 하한 것을 나타내는. 경우 &lt;code&gt;value&lt;/code&gt; 또는 &lt;code&gt;stepSize&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; , 또는 둘 경우 &lt;code&gt;minimum&lt;/code&gt; 및 &lt;code&gt;maximum&lt;/code&gt; 지정 및 &lt;code&gt;minimum &amp;gt; maximum&lt;/code&gt; 후 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 슬로우됩니다. 마찬가지로 &lt;code&gt;(minimum &amp;lt;= value &amp;lt;= maximum&lt;/code&gt; )이 false이면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="74be4dfd459c69d6c5eed0336db7d26406e6421b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;minimumCapacity&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;minimumCapacity&lt;/code&gt; 의 인수.</target>
        </trans-unit>
        <trans-unit id="890e9f6e189646766e2f576b109ba30702568602" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; argument specifies the access mode with which the file is to be opened. The permitted values and their meanings are as specified for the &lt;a href=&quot;#mode&quot;&gt;&lt;code&gt;RandomAccessFile(File,String)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 인수는 파일을 열 수하는있는 액세스 모드를 지정합니다. 허용되는 값과 의미는 &lt;a href=&quot;#mode&quot;&gt; &lt;code&gt;RandomAccessFile(File,String)&lt;/code&gt; &lt;/a&gt; 생성자에 지정된 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e641820f7d6466959040c65c77fa4bc72f70aff9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; parameter specifies how the region of the file is mapped and may be one of the following modes:</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 파일의 영역을 매핑되고 다음 모드 중 하나가 될 수있는 방법을 지정하는 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="8d634c96d7b7dc8c2283b2dc960c9bfb6ad5d16f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;modifiers&lt;/code&gt; parameter specifies &lt;em&gt;modifiers&lt;/em&gt; that qualify how the directory is registered. This release does not define any &lt;em&gt;standard&lt;/em&gt; modifiers. It may contain implementation specific modifiers.</source>
          <target state="translated">&lt;code&gt;modifiers&lt;/code&gt; 지정 매개 변수 &lt;em&gt;수정&lt;/em&gt; 디렉토리 등록 방법 자격. 이 릴리스는 &lt;em&gt;표준&lt;/em&gt; 수정자를 정의하지 않습니다 . 구현 특정 수정자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c71b33fd5b314e171d4df0723194294f0896265" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;msg&lt;/code&gt; string is localized using the given resource bundle. If the resource bundle is &lt;code&gt;null&lt;/code&gt;, then the &lt;code&gt;msg&lt;/code&gt; string is not localized.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; 문자열은 주어진 자원 번들을 사용하여 지역화됩니다. 자원 번들 인 경우 &lt;code&gt;null&lt;/code&gt; , 다음 &lt;code&gt;msg&lt;/code&gt; 문자열은 지역화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ad795f1c708af7880ff420b8fad93daa8b2155f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; parameter may be negative, even though the &lt;code&gt;skip&lt;/code&gt; method of the &lt;a href=&quot;reader&quot;&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt; superclass throws an exception in this case. If &lt;code&gt;n&lt;/code&gt; is negative, then this method does nothing and returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 파라미터는, 비록 음극 일 수있다 &lt;code&gt;skip&lt;/code&gt; 의 방법 &lt;a href=&quot;reader&quot;&gt; &lt;code&gt;Reader&lt;/code&gt; &lt;/a&gt; 수퍼이 경우 예외를 던진다. 경우 &lt;code&gt;n&lt;/code&gt; 은 음,이 메소드는 아무 것도 반환하지 않습니다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dff9aa267101b80032f4f16286856df7bec91f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;environment&lt;/code&gt; parameters are owned by the caller. The implementation will not modify these objects or keep references to them, although it may keep references to clones or copies.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;environment&lt;/code&gt; 변수는 호출 측이 소유합니다. 구현은 이러한 객체를 수정하거나 참조를 유지하지 않지만 복제본이나 복사본에 대한 참조를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30d43ffbfe8d9be7ac13f65149aa0271dd8dbc00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;nameCtx&lt;/code&gt; parameters may optionally be used to specify the name of the object being created. &lt;code&gt;name&lt;/code&gt; is the name of the object, relative to context &lt;code&gt;nameCtx&lt;/code&gt;. This information could be useful to the object factory or to the object implementation. If there are several possible contexts from which the object could be named -- as will often be the case -- it is up to the caller to select one. A good rule of thumb is to select the &quot;deepest&quot; context available. If &lt;code&gt;nameCtx&lt;/code&gt; is null, &lt;code&gt;name&lt;/code&gt; is relative to the default initial context. If no name is being specified, the &lt;code&gt;name&lt;/code&gt; parameter should be null.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;nameCtx&lt;/code&gt; 에의 파라미터를 선택적으로 생성되는 객체의 이름을 지정하는 데 사용될 수있다. &lt;code&gt;name&lt;/code&gt; 은 컨텍스트 &lt;code&gt;nameCtx&lt;/code&gt; 에 상대적인 객체 이름입니다 . 이 정보는 객체 팩토리 또는 객체 구현에 유용 할 수 있습니다. 경우에 따라 객체의 이름을 지정할 수있는 컨텍스트가 여러 개있는 경우 하나를 선택하는 것은 호출자에게 달려 있습니다. 경험상 &quot;가장 깊은&quot;컨텍스트를 선택하는 것이 좋습니다. 경우 &lt;code&gt;nameCtx&lt;/code&gt; 에이 널 (null)이며, &lt;code&gt;name&lt;/code&gt; 디폴트의 초기 컨텍스트에 상대적입니다. 이름을 지정하지 않으면 &lt;code&gt;name&lt;/code&gt; 매개 변수는 null이어야합니다.</target>
        </trans-unit>
        <trans-unit id="be1fd20ce63d2a2b2230f8b0a96a9b6d08008ebe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;nameCtx&lt;/code&gt; parameters may optionally be used to specify the name of the object being created. See the description of &quot;Name and Context Parameters&quot; in &lt;a href=&quot;objectfactory#getObjectInstance(java.lang.Object,javax.naming.Name,javax.naming.Context,java.util.Hashtable)&quot;&gt;&lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;nameCtx&lt;/code&gt; 에의 파라미터를 선택적으로 생성되는 객체의 이름을 지정하는 데 사용될 수있다. 자세한 내용은 &lt;a href=&quot;objectfactory#getObjectInstance(java.lang.Object,javax.naming.Name,javax.naming.Context,java.util.Hashtable)&quot;&gt; &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; &lt;/a&gt; 의 &quot;이름 및 컨텍스트 매개 변수&quot;에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c9872e72bac6d145cc0c98edc174c7beb6a1a6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;nameCtx&lt;/code&gt; parameters may optionally be used to specify the name of the object being created. See the description of &quot;Name and Context Parameters&quot; in &lt;a href=&quot;objectfactory#getObjectInstance(java.lang.Object,javax.naming.Name,javax.naming.Context,java.util.Hashtable)&quot;&gt;&lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt;&lt;/a&gt; for details. If a factory uses &lt;code&gt;nameCtx&lt;/code&gt; it should synchronize its use against concurrent access, since context implementations are not guaranteed to be thread-safe.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;nameCtx&lt;/code&gt; 에의 파라미터를 선택적으로 생성되는 객체의 이름을 지정하는 데 사용될 수있다. 자세한 내용은 &lt;a href=&quot;objectfactory#getObjectInstance(java.lang.Object,javax.naming.Name,javax.naming.Context,java.util.Hashtable)&quot;&gt; &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; &lt;/a&gt; 의 &quot;이름 및 컨텍스트 매개 변수&quot;에 대한 설명을 참조하십시오. 팩토리가 &lt;code&gt;nameCtx&lt;/code&gt; 를 사용하는 경우 컨텍스트 구현이 스레드로부터 안전하다고 보장되지 않으므로 동시 액세스에 대해 사용을 동기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="f70a327d5594e9f181a40f5c6ca0cd8e025505b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;nameCtx&lt;/code&gt; parameters may optionally be used to specify the name of the object being created. See the description of &quot;Name and Context Parameters&quot; in &lt;a href=&quot;objectfactory#getObjectInstance-java.lang.Object-javax.naming.Name-javax.naming.Context-java.util.Hashtable-&quot;&gt;&lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;nameCtx&lt;/code&gt; 에의 파라미터를 선택적으로 생성되는 객체의 이름을 지정하는 데 사용될 수있다. 자세한 내용은 &lt;a href=&quot;objectfactory#getObjectInstance-java.lang.Object-javax.naming.Name-javax.naming.Context-java.util.Hashtable-&quot;&gt; &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; &lt;/a&gt; 의 &quot;이름 및 컨텍스트 매개 변수&quot;에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d4c006afdb1b3d49e58c74bd4a0ffd732b023002" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;nameCtx&lt;/code&gt; parameters may optionally be used to specify the name of the object being created. See the description of &quot;Name and Context Parameters&quot; in &lt;a href=&quot;objectfactory#getObjectInstance-java.lang.Object-javax.naming.Name-javax.naming.Context-java.util.Hashtable-&quot;&gt;&lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt;&lt;/a&gt; for details. If a factory uses &lt;code&gt;nameCtx&lt;/code&gt; it should synchronize its use against concurrent access, since context implementations are not guaranteed to be thread-safe.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;nameCtx&lt;/code&gt; 에의 파라미터를 선택적으로 생성되는 객체의 이름을 지정하는 데 사용될 수있다. 자세한 내용은 &lt;a href=&quot;objectfactory#getObjectInstance-java.lang.Object-javax.naming.Name-javax.naming.Context-java.util.Hashtable-&quot;&gt; &lt;code&gt;ObjectFactory.getObjectInstance()&lt;/code&gt; &lt;/a&gt; 의 &quot;이름 및 컨텍스트 매개 변수&quot;에 대한 설명을 참조하십시오. 팩토리가 &lt;code&gt;nameCtx&lt;/code&gt; 를 사용하는 경우 컨텍스트 구현이 스레드 안전을 보장하지 않으므로 동시 액세스에 대해 사용을 동기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="e883ac2d08181956247cb122333240f05339fa61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; argument is case insensitive.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 인수는 경우를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75ed05c0b8a33486c051a951114b24540ff05d3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; matching is case insensitive, with any leading and trailing whitespace character removed.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 매칭을 제거 선행과 후행 공백 문자로, 사례를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b3818f758723f19e7f19461448d70ae40bd144a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;attrs&lt;/code&gt;, and &lt;code&gt;environment&lt;/code&gt; parameters are owned by the caller. The implementation will not modify these objects or keep references to them, although it may keep references to clones or copies.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; , &lt;code&gt;attrs&lt;/code&gt; 및 &lt;code&gt;environment&lt;/code&gt; 파라미터는 호출 측이 소유합니다. 구현은 이러한 객체를 수정하거나 참조를 유지하지 않지만 복제본이나 복사본에 대한 참조를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48161fbd495af11311a77e82a4acb8a1f70aaa4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;inAttrs&lt;/code&gt;, and &lt;code&gt;environment&lt;/code&gt; parameters are owned by the caller. The implementation will not modify these objects or keep references to them, although it may keep references to clones or copies. The object returned by this method is owned by the caller. The implementation will not subsequently modify it. It will contain either a new &lt;code&gt;Attributes&lt;/code&gt; object that is likewise owned by the caller, or a reference to the original &lt;code&gt;inAttrs&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; , &lt;code&gt;inAttrs&lt;/code&gt; , 및 &lt;code&gt;environment&lt;/code&gt; 파라미터는 호출 측이 소유합니다. 구현은 이러한 객체를 수정하거나 참조를 유지하지 않지만 복제본이나 복사본에 대한 참조를 유지할 수 있습니다. 이 메소드에 의해 리턴 된 오브젝트는 호출자가 소유합니다. 구현은 나중에 수정하지 않습니다. 호출자가 소유 한 새로운 &lt;code&gt;Attributes&lt;/code&gt; 객체 또는 원래 &lt;code&gt;inAttrs&lt;/code&gt; 매개 변수에 대한 참조를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="ef2e6b4b4d41262649d36998a45ab4a554e41dd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; parameter (if not &lt;code&gt;null&lt;/code&gt;) is a &lt;code&gt;Collection&lt;/code&gt; of &lt;code&gt;X500Principal&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 매개 변수 (없는 경우 &lt;code&gt;null&lt;/code&gt; )이있다 &lt;code&gt;Collection&lt;/code&gt; 의 &lt;code&gt;X500Principal&lt;/code&gt; 를 의.</target>
        </trans-unit>
        <trans-unit id="f5c100cec826504d35586ac2749c0d0f50484e21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; parameter (if not &lt;code&gt;null&lt;/code&gt;) is a &lt;code&gt;Collection&lt;/code&gt; of names. Each name is a &lt;code&gt;String&lt;/code&gt; or a byte array representing a distinguished name (in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; or ASN.1 DER encoded form, respectively). If &lt;code&gt;null&lt;/code&gt; is supplied as the value for this argument, no issuerNames check will be performed.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 매개 변수 (없는 경우 &lt;code&gt;null&lt;/code&gt; )이있다 &lt;code&gt;Collection&lt;/code&gt; 이름. 각 이름은 고유 이름을 나타내는 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열입니다 ( 각각 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; 또는 ASN.1 DER로 인코딩 된 형식). 이 인수의 값으로 &lt;code&gt;null&lt;/code&gt; 이 제공 되면 issuerNames 점검이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="158c9c58ed1b16c5fc715719b723134504c4d4a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; parameter (if not &lt;code&gt;null&lt;/code&gt;) is a &lt;code&gt;Collection&lt;/code&gt; of names. Each name is a &lt;code&gt;String&lt;/code&gt; or a byte array representing a distinguished name (in &lt;a href=&quot;https://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; or ASN.1 DER encoded form, respectively). If &lt;code&gt;null&lt;/code&gt; is supplied as the value for this argument, no issuerNames check will be performed.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 매개 변수 (없는 경우 &lt;code&gt;null&lt;/code&gt; )이있다 &lt;code&gt;Collection&lt;/code&gt; 이름. 각 이름은 고유 이름을 나타내는 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열입니다 ( 각각 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; 또는 ASN.1 DER 인코딩 형식). 이 인수의 값으로 &lt;code&gt;null&lt;/code&gt; 이 제공 되면 issuerNames 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10f8926ca6dbdca434f3cdffa8eda26510a88124" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; parameter (if not &lt;code&gt;null&lt;/code&gt;) is a &lt;code&gt;Collection&lt;/code&gt; with one entry for each name to be included in the pathToNames criterion. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively). There can be multiple names of the same type. If &lt;code&gt;null&lt;/code&gt; is supplied as the value for this argument, no pathToNames check will be performed.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 매개 변수 (없는 경우 &lt;code&gt;null&lt;/code&gt; )이있다 &lt;code&gt;Collection&lt;/code&gt; 각각의 이름에 대해 하나 개의 항목이 pathToNames 기준치에 포함 될 것입니다. 각 항목은이다 &lt;code&gt;List&lt;/code&gt; 그 첫 번째 엔트리이다 &lt;code&gt;Integer&lt;/code&gt; (이름 타입, 0-8) 및 그 두 번째 항목 인 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열 (이름, 문자열 또는 ASN.1 DER 각각, 인코딩 형태). 동일한 유형의 이름이 여러 개있을 수 있습니다. 이 인수의 값으로 &lt;code&gt;null&lt;/code&gt; 이 제공 되면 pathToNames 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7f614fb779c50df2c64620e5af3100fbb23fe19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; parameter (if not &lt;code&gt;null&lt;/code&gt;) is a &lt;code&gt;Collection&lt;/code&gt; with one entry for each name to be included in the subject alternative name criterion. Each entry is a &lt;code&gt;List&lt;/code&gt; whose first entry is an &lt;code&gt;Integer&lt;/code&gt; (the name type, 0-8) and whose second entry is a &lt;code&gt;String&lt;/code&gt; or a byte array (the name, in string or ASN.1 DER encoded form, respectively). There can be multiple names of the same type. If &lt;code&gt;null&lt;/code&gt; is supplied as the value for this argument, no subjectAlternativeNames check will be performed.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 매개 변수 (없는 경우 &lt;code&gt;null&lt;/code&gt; )이있다 &lt;code&gt;Collection&lt;/code&gt; 각각의 이름에 대해 하나 개의 항목이 주체 대체 이름 기준에 포함 될 것입니다. 각 항목은이다 &lt;code&gt;List&lt;/code&gt; 그 첫 번째 엔트리이다 &lt;code&gt;Integer&lt;/code&gt; (이름 타입, 0-8) 및 그 두 번째 항목 인 &lt;code&gt;String&lt;/code&gt; 또는 바이트 배열 (이름, 문자열 또는 ASN.1 DER 각각, 인코딩 형태). 동일한 유형의 이름이 여러 개있을 수 있습니다. 이 인수의 값으로 &lt;code&gt;null&lt;/code&gt; 이 제공 되면 subjectAlternativeNames 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86f6973623e34ae41d0cb380cd7a6687a04a283e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;network interface&lt;/code&gt; and &lt;code&gt;ttl&lt;/code&gt; parameters let the caller specify which network interface the test will go through and the maximum number of hops the packets should go through. A negative value for the &lt;code&gt;ttl&lt;/code&gt; will result in an IllegalArgumentException being thrown.</source>
          <target state="translated">&lt;code&gt;network interface&lt;/code&gt; 와 &lt;code&gt;ttl&lt;/code&gt; 매개 변수는 테스트를 통과하고 최대 홉의 수는 패킷이 통과해야 인터페이스 호출자가있는 네트워크를 지정할 수 있습니다. &lt;code&gt;ttl&lt;/code&gt; 의 값이 음수이면 IllegalArgumentException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b09e54aa5c847f44721e53e1758b993160bcd0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;newLength&lt;/code&gt; argument must be greater than or equal to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;newLength&lt;/code&gt; 인수보다 더 큰 일하거나 동일해야합니다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7231d4e3f44c3037aca933714c69e80b5eb9b9ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;newTypes&lt;/code&gt; list contains types &lt;code&gt;P..., M..., A...&lt;/code&gt;, with as many types in &lt;code&gt;P&lt;/code&gt; as indicated by &lt;code&gt;pos&lt;/code&gt;. The &lt;code&gt;M&lt;/code&gt; types are precisely those that the &lt;code&gt;M&lt;/code&gt; types in the target handle's parameter type list are supposed to match. The types in &lt;code&gt;A&lt;/code&gt; are additional types found after the matching sub-list.</source>
          <target state="translated">&lt;code&gt;newTypes&lt;/code&gt; 의 목록이 포함 된 타입 &lt;code&gt;P..., M..., A...&lt;/code&gt; , 많은 종류와 같이 &lt;code&gt;P&lt;/code&gt; 는 에 의해 나타낸 바와 같이, &lt;code&gt;pos&lt;/code&gt; . &lt;code&gt;M&lt;/code&gt; 의 종류는 정확하게 것들이다 &lt;code&gt;M&lt;/code&gt; 의 대상 핸들의 매개 변수 유형 목록에서 유형이 일치하도록되어있다. &lt;code&gt;A&lt;/code&gt; 의 유형 은 일치하는 하위 목록 뒤에있는 추가 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5caef121267476c77e7c49f344a99bf3c90e71f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;newtransform&lt;/code&gt; and &lt;code&gt;newCanonicalizationMethod&lt;/code&gt; methods of &lt;code&gt;XMLSignatureFactory&lt;/code&gt; MUST support &lt;code&gt;DOMStructure&lt;/code&gt; parameter types.</source>
          <target state="translated">&lt;code&gt;XMLSignatureFactory&lt;/code&gt; 의 &lt;code&gt;newtransform&lt;/code&gt; 및 &lt;code&gt;newCanonicalizationMethod&lt;/code&gt; 메소드는 &lt;code&gt;DOMStructure&lt;/code&gt; 매개 변수 유형을 지원해야 합니다.</target>
        </trans-unit>
        <trans-unit id="238e2ddc1de1cf5d38b16bf8a5ed7a88e495f8bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nodeName&lt;/code&gt; attribute that is inherited from &lt;code&gt;Node&lt;/code&gt; contains the name of the entity.</source>
          <target state="translated">&lt;code&gt;nodeName&lt;/code&gt; 에서 상속되는 속성 &lt;code&gt;Node&lt;/code&gt; 엔티티의 이름을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="cd6f3c9ed9744a178a240c4efe334b44144e9408" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;normalize&lt;/code&gt; method helps solve these problems by transforming text into the canonical composed and decomposed forms as shown in the first example above. In addition, you can have it perform compatibility decompositions so that you can treat compatibility characters the same as their equivalents. Finally, the &lt;code&gt;normalize&lt;/code&gt; method rearranges accents into the proper canonical order, so that you do not have to worry about accent rearrangement on your own.</source>
          <target state="translated">&lt;code&gt;normalize&lt;/code&gt; 방법으로 구성 및 상기 첫번째 예에 도시 된 바와 같이 형태를 분해 정식으로 텍스트를 변환하여 이러한 문제를 해결할 수. 또한 호환성 분해를 수행하여 호환성 문자를 동등 문자와 동일하게 취급 할 수 있습니다. 마지막으로 &lt;code&gt;normalize&lt;/code&gt; 방법은 악센트를 올바른 정식 순서로 재 배열하므로 사용자가 직접 악센트 재배 열에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f52e6638e3eca203f0c48df0632a417ad5518e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;notations&lt;/code&gt;&lt;code&gt;NamedNodeMaps&lt;/code&gt; are equal.</source>
          <target state="translated">&lt;code&gt;notations&lt;/code&gt; &lt;code&gt;NamedNodeMaps&lt;/code&gt; 는 동일하다.</target>
        </trans-unit>
        <trans-unit id="63cf4faf44647d95951cea7798d0b85f615c45ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ns&lt;/code&gt; parameter may be negative, even though the &lt;code&gt;skip&lt;/code&gt; method of the &lt;a href=&quot;reader&quot;&gt;&lt;code&gt;Reader&lt;/code&gt;&lt;/a&gt; superclass throws an exception in this case. Negative values of &lt;code&gt;ns&lt;/code&gt; cause the stream to skip backwards. Negative return values indicate a skip backwards. It is not possible to skip backwards past the beginning of the string.</source>
          <target state="translated">&lt;code&gt;ns&lt;/code&gt; 파라미터는, 비록 음극 일 수있다 &lt;code&gt;skip&lt;/code&gt; 의 방법 &lt;a href=&quot;reader&quot;&gt; &lt;code&gt;Reader&lt;/code&gt; &lt;/a&gt; 수퍼이 경우 예외를 던진다. &lt;code&gt;ns&lt;/code&gt; 의 음수 값은 스트림을 뒤로 건너 뜁니다. 음수 반환 값은 뒤로 건너 뛰기를 나타냅니다. 문자열의 시작을지나 뒤로 건너 뛸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e0fcc06e98814dd87a3c62b985949fba60bdb550" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; argument is the index of the first byte of the subarray, and the &lt;code&gt;count&lt;/code&gt; argument specifies the length of the subarray.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 인자는 배열의 첫 번째 바이트의 인덱스이고, 상기 &lt;code&gt;count&lt;/code&gt; 인수는 배열의 길이를 지정한다.</target>
        </trans-unit>
        <trans-unit id="baa0351e008899618db6b64da0e758694ddf41eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; argument is the index of the first character of the subarray. The &lt;code&gt;count&lt;/code&gt; argument specifies the length of the subarray. The contents of the subarray are copied; subsequent modification of the character array does not affect the returned string.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 인수는 배열의 첫 번째 문자의 인덱스입니다. &lt;code&gt;count&lt;/code&gt; 인수는 부분 배열의 길이를 지정합니다. 하위 배열의 내용이 복사됩니다. 후속 문자 배열 수정은 반환 된 문자열에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c01d1aa6c77241f92e51f28f20db5fb08e4c253" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; argument must be greater than or equal to &lt;code&gt;0&lt;/code&gt;, and less than or equal to the &lt;a href=&quot;charsequence#length()&quot;&gt;length&lt;/a&gt; of this sequence.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 인자보다 크거나 같아야 &lt;code&gt;0&lt;/code&gt; , 미만 또는 동일 &lt;a href=&quot;charsequence#length()&quot;&gt;길이의&lt;/a&gt; 이 시퀀스.</target>
        </trans-unit>
        <trans-unit id="7d930134c90bf6d49ed3db167b3ffa23d64e6b5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; argument must be greater than or equal to &lt;code&gt;0&lt;/code&gt;, and less than or equal to the &lt;a href=&quot;stringbuffer#length--&quot;&gt;length&lt;/a&gt; of this sequence.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 인자보다 크거나 같아야 &lt;code&gt;0&lt;/code&gt; , 미만 또는 동일 &lt;a href=&quot;stringbuffer#length--&quot;&gt;길이의&lt;/a&gt; 이 시퀀스.</target>
        </trans-unit>
        <trans-unit id="5649ec97e26cd383b62037dbe7726158b1b2a542" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; argument must be greater than or equal to &lt;code&gt;0&lt;/code&gt;, and less than or equal to the &lt;a href=&quot;stringbuilder#length--&quot;&gt;length&lt;/a&gt; of this sequence.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 인자보다 크거나 같아야 &lt;code&gt;0&lt;/code&gt; , 미만 또는 동일 &lt;a href=&quot;stringbuilder#length--&quot;&gt;길이의&lt;/a&gt; 이 시퀀스.</target>
        </trans-unit>
        <trans-unit id="2d5b4d40ecb1db6747499e6955bb54e7c954105e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;openAttributes&lt;/code&gt;, &lt;code&gt;openConstructors&lt;/code&gt;, &lt;code&gt;
 openOperations&lt;/code&gt; and &lt;code&gt;notifications&lt;/code&gt; array parameters are internally copied, so that subsequent changes to the arrays referenced by these parameters have no effect on this instance.</source>
          <target state="translated">&lt;code&gt;openAttributes&lt;/code&gt; , &lt;code&gt;openConstructors&lt;/code&gt; , &lt;code&gt; openOperations&lt;/code&gt; 및 &lt;code&gt;notifications&lt;/code&gt; 배열 매개 변수는 내부적으로 이러한 매개 변수에 의해 참조되는 그 후의 배열의 변경이이 인스턴스에 영향을 미치지 그래서, 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="4b47fbce935f5d028b77339d1ef9818c0b7586f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;openAttributes&lt;/code&gt;, &lt;code&gt;openConstructors&lt;/code&gt;, &lt;code&gt;openOperations&lt;/code&gt; and &lt;code&gt;notifications&lt;/code&gt; array parameters are internally copied, so that subsequent changes to the arrays referenced by these parameters have no effect on this instance.</source>
          <target state="translated">&lt;code&gt;openAttributes&lt;/code&gt; , &lt;code&gt;openConstructors&lt;/code&gt; , &lt;code&gt;openOperations&lt;/code&gt; 및 &lt;code&gt;notifications&lt;/code&gt; 배열 매개 변수는 내부적으로 이러한 매개 변수에 의해 참조되는 그 후의 배열의 변경이이 인스턴스에 영향을 미치지 그래서, 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="d6983d2110c5fe985de448c67aa2a3f5fba3481e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; array may be used to indicate how symbolic links are handled by the resulting file attribute view for the case that the file is a symbolic link. By default, symbolic links are followed. If the option &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt;&lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; is present then symbolic links are not followed. This option is ignored by implementations that do not support symbolic links.</source>
          <target state="translated">그만큼 &lt;code&gt;options&lt;/code&gt; 배열은 파일이 심볼릭 링크 인 경우의 결과 파일의 속성보기 처리하는 방법 기호 링크 표시하는 데 이용 될 수있다. 기본적으로 기호 링크가 수행됩니다. &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt; &lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; 옵션 이 있으면 기호 링크를 따르지 않습니다. 이 옵션은 심볼릭 링크를 지원하지 않는 구현에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e205a1262affb513a2bd877857ae965e9d442d7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is read. If the option &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt;&lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; is present then symbolic links are not followed.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 배열은 파일이 심볼릭 링크 인 경우에 대한 처리하는 방법 기호 링크 표시하는 데 이용 될 수있다. 기본적으로 기호 링크가 따르고 링크의 최종 대상 파일 속성이 읽 힙니다. &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt; &lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; 옵션 이 있으면 기호 링크를 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07b7edf8d716c1c078bf2b1c0f91fb4940940f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is set. If the option &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt;&lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; is present then symbolic links are not followed.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 배열은 파일이 심볼릭 링크 인 경우에 대한 처리하는 방법 기호 링크 표시하는 데 이용 될 수있다. 기본적으로 심볼릭 링크가 따르고 링크의 최종 대상의 파일 속성이 설정됩니다. &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt; &lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; 옵션 이 있으면 기호 링크를 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d06342b773fea6549bc89fc2462a7083b70f4fb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; array may be used to indicate how symbolic links are handled. By default, symbolic links are resolved to their final target. If the option &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt;&lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; is present then this method does not resolve symbolic links. Some implementations allow special names such as &quot;&lt;code&gt;..&lt;/code&gt;&quot; to refer to the parent directory. When deriving the &lt;em&gt;real path&lt;/em&gt;, and a &quot;&lt;code&gt;..&lt;/code&gt;&quot; (or equivalent) is preceded by a non-&quot;&lt;code&gt;..&lt;/code&gt;&quot; name then an implementation will typically cause both names to be removed. When not resolving symbolic links and the preceding name is a symbolic link then the names are only removed if it guaranteed that the resulting path will locate the same file as this path.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 배열을 처리하는 방법을 기호 링크 표시하는 데 이용 될 수있다. 기본적으로 심볼릭 링크는 최종 대상으로 확인됩니다. &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt; &lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; 옵션 이 존재하면이 메소드는 기호 링크를 해석하지 않습니다. 일부 구현에서는 &quot; &lt;code&gt;..&lt;/code&gt; &quot; 와 같은 특수 이름으로 상위 디렉토리를 참조 할 수 있습니다. 상기 유도 &lt;em&gt;실제 경로를&lt;/em&gt; , 그리고 &quot; &lt;code&gt;..&lt;/code&gt; &quot;(또는 동등한 항목) 앞에 &quot;&quot; &lt;code&gt;..&lt;/code&gt; &quot; 가 아닌 이름이 오는 경우 구현시 일반적으로 두 이름이 모두 제거됩니다. 심볼릭 링크를 해결하지 않고 이전 이름이 심볼릭 링크 인 경우 결과 경로가이 경로와 동일한 파일을 찾도록 보장 된 경우에만 이름이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f5a345ea481a9989b3e67c3fdfaa252ee2038c96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter determines how the file is opened. If no options are present then it is equivalent to opening the file with the &lt;a href=&quot;standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; option. In addition to the &lt;code&gt;
 READ&lt;/code&gt; option, an implementation may also support additional implementation specific options.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 매개 변수는 파일을 열 방법을 결정합니다. 옵션이 없으면 &lt;a href=&quot;standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 옵션으로 파일을 여는 것과 같습니다 . 받는 사람 또한 &lt;code&gt; READ&lt;/code&gt; 옵션, 구현은 추가적인 구현 고유의 옵션을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bc9bb7ec20a4fcc37fab92a84728a3be6a3d529" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter determines how the file is opened. If no options are present then it is equivalent to opening the file with the &lt;a href=&quot;standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; option. In addition to the &lt;code&gt;READ&lt;/code&gt; option, an implementation may also support additional implementation specific options.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 매개 변수는 파일을 열 방법을 결정합니다. 옵션이 없으면 &lt;a href=&quot;standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 옵션으로 파일을 여는 것과 같습니다 . 여기에 덧붙여 &lt;code&gt;READ&lt;/code&gt; 옵션, 구현은 추가적인 구현 고유의 옵션을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feb5d322a388c3217a1ff698a06ad00e166739fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter determines how the file is opened. The &lt;a href=&quot;../file/standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../file/standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options determine if the file should be opened for reading and/or writing. If neither option (or the &lt;a href=&quot;../file/standardopenoption#APPEND&quot;&gt;&lt;code&gt;APPEND&lt;/code&gt;&lt;/a&gt; option) is contained in the array then the file is opened for reading. By default reading or writing commences at the beginning of the file.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 매개 변수는 파일을 열 방법을 결정합니다. &lt;a href=&quot;../file/standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../file/standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 파일 읽기 및 / 또는 쓰기 위해 열 수 있습니다 경우 옵션을 결정합니다. 옵션 (또는 &lt;a href=&quot;../file/standardopenoption#APPEND&quot;&gt; &lt;code&gt;APPEND&lt;/code&gt; )이&lt;/a&gt; 없으면 옵션)이 배열에 포함되어 파일을 읽기 위해 열립니다. 기본적으로 읽기 또는 쓰기는 파일 시작 부분에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c735a8e347a9d0b0ecd22343769651f2ac14125f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter determines how the file is opened. The &lt;a href=&quot;../file/standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../file/standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options determines if the file should be opened for reading and/or writing. If neither option is contained in the array then an existing file is opened for reading.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 매개 변수는 파일을 열 방법을 결정합니다. &lt;a href=&quot;../file/standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../file/standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 파일 읽기 및 / 또는 쓰기 위해 열 수 있습니다 경우 옵션을 결정합니다. 배열에 옵션이 없으면 기존 파일을 열어 읽습니다.</target>
        </trans-unit>
        <trans-unit id="70441efdb55fa14107d32cb84dfbb03932007cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter determines how the file is opened. The &lt;a href=&quot;standardopenoption#READ&quot;&gt;&lt;code&gt;READ&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options determine if the file should be opened for reading and/or writing. If neither option (or the &lt;a href=&quot;standardopenoption#APPEND&quot;&gt;&lt;code&gt;APPEND&lt;/code&gt;&lt;/a&gt; option) is present then the file is opened for reading. By default reading or writing commence at the beginning of the file.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 매개 변수는 파일을 열 방법을 결정합니다. &lt;a href=&quot;standardopenoption#READ&quot;&gt; &lt;code&gt;READ&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 파일 읽기 및 / 또는 쓰기 위해 열 수 있습니다 경우 옵션을 결정합니다. 옵션 (또는 &lt;a href=&quot;standardopenoption#APPEND&quot;&gt; &lt;code&gt;APPEND&lt;/code&gt; )이&lt;/a&gt; 없으면 옵션)이 파일을 읽기 위해 열립니다. 기본적으로 파일의 시작 부분에서 읽기 또는 쓰기가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="adaafaa0c2c26b989f9f5f2e8716f29c6f11b35c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed. If the option &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt;&lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt;&lt;/a&gt; is present then symbolic links are not followed.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 매개 변수는 파일이 심볼릭 링크 인 경우에 대한 처리하는 방법 기호 링크 표시하는 데 이용 될 수있다. 기본적으로 기호 링크가 수행됩니다. &lt;a href=&quot;linkoption#NOFOLLOW_LINKS&quot;&gt; &lt;code&gt;NOFOLLOW_LINKS&lt;/code&gt; &lt;/a&gt; 옵션 인 경우 이 있으면 기호 링크를 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e88e22b5339b7c784d561d64428df97e00625dcf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter may include any of the following:</source>
          <target state="translated">그만큼 &lt;code&gt;options&lt;/code&gt; 매개 변수는 다음 중 하나를 포함 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="4b13774c0241962d758bb9e487f1b8e4b324b63e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter specifies how the file is created or opened. If no options are present then this method works as if the &lt;a href=&quot;standardopenoption#CREATE&quot;&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt;&lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing &lt;a href=&quot;#isRegularFile(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;regular-file&lt;/code&gt;&lt;/a&gt; to a size of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 파일을 만들거나 열 방법을 지정하는 매개 변수입니다. 옵션이 없으면이 메서드는 &lt;a href=&quot;standardopenoption#CREATE&quot;&gt; &lt;code&gt;CREATE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt; &lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 옵션이 있는 것처럼 작동합니다 . 즉, 쓰기 위해 파일을 열고, 존재하지 않는 경우 파일을 생성하거나, 기존 &lt;a href=&quot;#isRegularFile(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;regular-file&lt;/code&gt; &lt;/a&gt; 을 처음 에 &lt;code&gt;0&lt;/code&gt; 크기로 자릅니다 .</target>
        </trans-unit>
        <trans-unit id="9f9d8a105de341349c54bc6855f4dc3514259ce3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter specifies how the file is created or opened. If no options are present then this method works as if the &lt;a href=&quot;standardopenoption#CREATE&quot;&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt;&lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing &lt;a href=&quot;#isRegularFile(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;regular-file&lt;/code&gt;&lt;/a&gt; to a size of &lt;code&gt;0&lt;/code&gt;. The method ensures that the file is closed when all lines have been written (or an I/O error or other runtime exception is thrown). If an I/O error occurs then it may do so after the file has been created or truncated, or after some bytes have been written to the file.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 파일을 만들거나 열 방법을 지정하는 매개 변수입니다. 옵션이 없으면이 메서드는 &lt;a href=&quot;standardopenoption#CREATE&quot;&gt; &lt;code&gt;CREATE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt; &lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 옵션이 있는 것처럼 작동합니다 . 즉, 쓰기 위해 파일을 열고, 존재하지 않는 경우 파일을 생성하거나, 기존 &lt;a href=&quot;#isRegularFile(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;regular-file&lt;/code&gt; &lt;/a&gt; 을 처음 에 &lt;code&gt;0&lt;/code&gt; 크기로 자릅니다 . 이 메서드는 모든 행이 기록되었을 때 파일이 닫히도록합니다 (또는 I / O 오류 또는 기타 런타임 예외가 발생 함). I / O 오류가 발생하면 파일이 작성되거나 잘린 후 또는 파일에 일부 바이트가 기록 된 후에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c00a59ba94adcb6905e3dd085514e8e2f27d12a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter specifies how the the file is created or opened. If no options are present then this method works as if the &lt;a href=&quot;standardopenoption#CREATE&quot;&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt;&lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;standardopenoption#WRITE&quot;&gt;&lt;code&gt;WRITE&lt;/code&gt;&lt;/a&gt; options are present. In other words, it opens the file for writing, creating the file if it doesn't exist, or initially truncating an existing &lt;a href=&quot;files#isRegularFile-java.nio.file.Path-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;regular-file&lt;/code&gt;&lt;/a&gt; to a size of &lt;code&gt;0&lt;/code&gt;. The method ensures that the file is closed when all lines have been written (or an I/O error or other runtime exception is thrown). If an I/O error occurs then it may do so after the file has created or truncated, or after some bytes have been written to the file.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 하여 파일을 만들거나 열 방법을 지정하는 매개 변수입니다. 옵션이 없으면이 메소드는 &lt;a href=&quot;standardopenoption#CREATE&quot;&gt; &lt;code&gt;CREATE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;standardopenoption#TRUNCATE_EXISTING&quot;&gt; &lt;code&gt;TRUNCATE_EXISTING&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;standardopenoption#WRITE&quot;&gt; &lt;code&gt;WRITE&lt;/code&gt; &lt;/a&gt; 옵션이 있는 것처럼 작동합니다 . 즉, 파일을 작성하기 위해 파일을 열거 나 존재하지 않는 경우 파일을 만들거나 기존의 &lt;a href=&quot;files#isRegularFile-java.nio.file.Path-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;regular-file&lt;/code&gt; &lt;/a&gt; 처음에 자릅니다 을 &lt;code&gt;0&lt;/code&gt; 크기로 자릅니다 . 이 방법을 사용하면 모든 줄을 쓸 때 (또는 I / O 오류 또는 기타 런타임 예외가 발생했을 때) 파일이 닫힙니다. I / O 오류가 발생하면 파일이 작성되거나 잘린 후 또는 일부 바이트가 파일에 기록 된 후에 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19ea8dcb435d7496383db34913da36823ca371d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;orientation&lt;/code&gt; argument must take one of the two values &lt;code&gt;Scrollbar.HORIZONTAL&lt;/code&gt;, or &lt;code&gt;Scrollbar.VERTICAL&lt;/code&gt;, indicating a horizontal or vertical scroll bar, respectively.</source>
          <target state="translated">&lt;code&gt;orientation&lt;/code&gt; 인자는 두 개의 값 중 하나를 수행해야 &lt;code&gt;Scrollbar.HORIZONTAL&lt;/code&gt; 또는 &lt;code&gt;Scrollbar.VERTICAL&lt;/code&gt; 을 각각 수직 또는 수평 스크롤 바를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="d38cc57bdb401fa5458030b8203d68a47b6b87cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;outputMimeType&lt;/code&gt; parameter describes the document type that you want to create, whereas the &lt;code&gt;flavor&lt;/code&gt; parameter describes the format in which the input data will be provided by the application to the &lt;code&gt;StreamPrintService&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;outputMimeType&lt;/code&gt; 의 매개 변수는 반면, 만들려는 문서 유형을 설명 &lt;code&gt;flavor&lt;/code&gt; 파라미터는 상기 입력 데이터가 애플리케이션에 의해 제공 될 것이다 포맷 설명 &lt;code&gt;StreamPrintService&lt;/code&gt; 를이 .</target>
        </trans-unit>
        <trans-unit id="8257034935941be3f0b0a79bcb02da45c170ab8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ownerElement&lt;/code&gt; attribute is set to &lt;code&gt;null&lt;/code&gt; and the &lt;code&gt;specified&lt;/code&gt; flag is set to &lt;code&gt;true&lt;/code&gt; on the adopted &lt;code&gt;Attr&lt;/code&gt;. The descendants of the source &lt;code&gt;Attr&lt;/code&gt; are recursively adopted.</source>
          <target state="translated">&lt;code&gt;ownerElement&lt;/code&gt; 속성이 설정되어 &lt;code&gt;null&lt;/code&gt; 과 &lt;code&gt;specified&lt;/code&gt; 플래그가 설정되어 &lt;code&gt;true&lt;/code&gt; 채택에 &lt;code&gt;Attr&lt;/code&gt; . 소스 &lt;code&gt;Attr&lt;/code&gt; 의 자손 은 재귀 적으로 채택됩니다.</target>
        </trans-unit>
        <trans-unit id="db95ff142963f6cc3449f48fbd4ccbf6c3102b9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ownerElement&lt;/code&gt; attribute is set to &lt;code&gt;null&lt;/code&gt; and the &lt;code&gt;specified&lt;/code&gt; flag is set to &lt;code&gt;true&lt;/code&gt; on the generated &lt;code&gt;Attr&lt;/code&gt;. The descendants of the source &lt;code&gt;Attr&lt;/code&gt; are recursively imported and the resulting nodes reassembled to form the corresponding subtree. Note that the &lt;code&gt;deep&lt;/code&gt; parameter has no effect on &lt;code&gt;Attr&lt;/code&gt; nodes; they always carry their children with them when imported.</source>
          <target state="translated">&lt;code&gt;ownerElement&lt;/code&gt; 속성이 설정되어 &lt;code&gt;null&lt;/code&gt; 과 &lt;code&gt;specified&lt;/code&gt; 플래그가 설정되어 &lt;code&gt;true&lt;/code&gt; 생성에 &lt;code&gt;Attr&lt;/code&gt; . 소스 &lt;code&gt;Attr&lt;/code&gt; 의 하위 항목을 재귀 적으로 가져오고 결과 노드를 재 조립하여 해당 하위 트리를 형성합니다. 참고 것을 &lt;code&gt;deep&lt;/code&gt; 매개 변수에 아무런 영향이 없습니다 &lt;code&gt;Attr&lt;/code&gt; 노드; 그들은 수입 될 때 항상 그들의 아이들을 가지고갑니다.</target>
        </trans-unit>
        <trans-unit id="5c95aaf1fcdce3e672aff6748a9bdc1c5a92b1a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packageFinder&lt;/code&gt; parameter is for use when reading module descriptors from legacy module-artifact formats that do not record the set of packages in the descriptor itself.</source>
          <target state="translated">&lt;code&gt;packageFinder&lt;/code&gt; 의 기술자 자체 패키지 세트를 기록하지 않는 레거시 모듈 유물 형식의 모듈 설명을 읽을 때 매개 변수는 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1d6a3e2666b292d57c5aab696b343f540ec638d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; field now contains two elements, each of which is an array two elements long. The first element is the parameter number; the second is the value to be set. In this case, the first element of &lt;code&gt;params&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;5000&lt;/code&gt;, and the second element is &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;&quot;West&quot;&lt;/code&gt;. When an application calls the method &lt;code&gt;execute&lt;/code&gt;, it will in turn call on this &lt;code&gt;RowSet&lt;/code&gt; object's reader, which will in turn invoke its &lt;code&gt;readData&lt;/code&gt; method. As part of its implementation, &lt;code&gt;readData&lt;/code&gt; will get the values in &lt;code&gt;params&lt;/code&gt; and use them to set the command's placeholder parameters. The following code fragment gives an idea of how the reader does this, after obtaining the &lt;code&gt;Connection&lt;/code&gt; object &lt;code&gt;con&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;params&lt;/code&gt; 필드에는 두 개의 요소가 포함되며, 각 요소는 두 요소 길이의 배열입니다. 첫 번째 요소는 매개 변수 번호입니다. 두 번째는 설정할 값입니다. 이 경우 &lt;code&gt;params&lt;/code&gt; 의 첫 번째 요소 는 &lt;code&gt;1&lt;/code&gt; 입니다 . &lt;code&gt;5000&lt;/code&gt; 이고 두 번째 요소는 &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;&quot;West&quot;&lt;/code&gt; 입니다. 응용 프로그램이 메소드가 호출하면 &lt;code&gt;execute&lt;/code&gt; ,이에 차례 호출됩니다 &lt;code&gt;RowSet&lt;/code&gt; 객체의 리더, 년 된 invoke 켜 것이다 &lt;code&gt;readData&lt;/code&gt; 방법. 구현의 일부로 &lt;code&gt;readData&lt;/code&gt; 는 &lt;code&gt;params&lt;/code&gt; 이를 사용하여 명령의 자리 표시 자 매개 변수를 설정합니다. 다음 코드 조각은 &lt;code&gt;Connection&lt;/code&gt; 객체 &lt;code&gt;con&lt;/code&gt; 을 얻은 후 독자가이를 수행하는 방법에 대한 아이디어를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="edb61ce5d9acc2ab5ce76544d532094234d018a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parent&lt;/code&gt; argument determines two things: the frame on which the open dialog depends and the component whose position the look and feel should consider when placing the dialog. If the parent is a &lt;code&gt;Frame&lt;/code&gt; object (such as a &lt;code&gt;JFrame&lt;/code&gt;) then the dialog depends on the frame and the look and feel positions the dialog relative to the frame (for example, centered over the frame). If the parent is a component, then the dialog depends on the frame containing the component, and is positioned relative to the component (for example, centered over the component). If the parent is &lt;code&gt;null&lt;/code&gt;, then the dialog depends on no visible window, and it's placed in a look-and-feel-dependent position such as the center of the screen.</source>
          <target state="translated">&lt;code&gt;parent&lt;/code&gt; 열기 대화 상자가 의존하는 프레임 위치 모양과 느낌 대화 상자를 배치 할 때 고려해야 할 요소 : 인수는 두 가지를 결정한다. 부모가 &lt;code&gt;Frame&lt;/code&gt; 객체 (예 : &lt;code&gt;JFrame&lt;/code&gt; ) 인 경우 대화 상자는 프레임에 따라 달라지며 모양과 느낌은 프레임을 기준으로 대화 상자를 배치합니다 (예 : 프레임 중앙에 위치). 부모가 구성 요소 인 경우 대화 상자는 구성 요소를 포함하는 프레임에 따라 달라지며 구성 요소를 기준으로 배치됩니다 (예 : 구성 요소 중앙에 위치). 부모가 &lt;code&gt;null&lt;/code&gt; 이면 대화 상자는 보이지 않는 창에 의존하며 화면 중앙과 같은 모양과 느낌에 종속 된 위치에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="64a8995d9ac05171aede64481f740265b7613585" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parseURL&lt;/code&gt; method of &lt;code&gt;URLStreamHandler&lt;/code&gt; parses the string representation as if it were an &lt;code&gt;http&lt;/code&gt; specification. Most URL protocol families have a similar parsing. A stream protocol handler for a protocol that has a different syntax must override this routine.</source>
          <target state="translated">&lt;code&gt;URLStreamHandler&lt;/code&gt; 의 &lt;code&gt;parseURL&lt;/code&gt; 메소드 는 문자열 표현을 마치 &lt;code&gt;http&lt;/code&gt; 스펙을 http 스펙 인 . 대부분의 URL 프로토콜 패밀리는 유사한 구문 분석을 가지고 있습니다. 구문이 다른 프로토콜의 스트림 프로토콜 핸들러는이 루틴을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="2221038019d4be2cb2f88fab060218d2d5a02e57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; parameter is associated with a &lt;code&gt;FileSystem&lt;/code&gt; that supports the &lt;a href=&quot;attribute/posixfileattributeview&quot;&gt;&lt;code&gt;PosixFileAttributeView&lt;/code&gt;&lt;/a&gt;. This attribute view provides access to file attributes commonly associated with files on file systems used by operating systems that implement the Portable Operating System Interface (POSIX) family of standards.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 파라미터는와 연관된 &lt;code&gt;FileSystem&lt;/code&gt; 지지체 &lt;a href=&quot;attribute/posixfileattributeview&quot;&gt; &lt;code&gt;PosixFileAttributeView&lt;/code&gt; 를&lt;/a&gt; . 이 속성보기는 POSIX (Portable Operating System Interface) 표준 제품군을 구현하는 운영 체제에서 사용되는 파일 시스템의 파일과 일반적으로 관련된 파일 속성에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b249e9a3d9c0f37793a768ee4c126d9c0f3b49e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; parameter is associated with a file system that supports &lt;a href=&quot;attribute/fileownerattributeview&quot;&gt;&lt;code&gt;FileOwnerAttributeView&lt;/code&gt;&lt;/a&gt;. This file attribute view provides access to a file attribute that is the owner of the file.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 매개 변수가 지원하는 파일 시스템과 관련된 &lt;a href=&quot;attribute/fileownerattributeview&quot;&gt; &lt;code&gt;FileOwnerAttributeView&lt;/code&gt; 을&lt;/a&gt; . 이 파일 속성보기는 파일 소유자 인 파일 속성에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5493aef38945eeedee66c785a93a8e949626fc4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perms&lt;/code&gt; parameter is a &lt;code&gt;String&lt;/code&gt; representing the permissions. It has 9 characters that are interpreted as three sets of three. The first set refers to the owner's permissions; the next to the group permissions and the last to others. Within each set, the first character is &lt;code&gt;'r'&lt;/code&gt; to indicate permission to read, the second character is &lt;code&gt;'w'&lt;/code&gt; to indicate permission to write, and the third character is &lt;code&gt;'x'&lt;/code&gt; for execute permission. Where a permission is not set then the corresponding character is set to &lt;code&gt;'-'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perms&lt;/code&gt; 매개 변수는 있습니다 &lt;code&gt;String&lt;/code&gt; 권한을 나타내는. 3 개의 3 개 세트로 해석되는 9 개의 문자가 있습니다. 첫 번째 세트는 소유자의 권한을 나타냅니다. 그룹 권한 옆에 있고 다른 사람에게 마지막 권한. 각 세트 내에서 첫 번째 문자는 읽기 권한을 나타내는 &lt;code&gt;'r'&lt;/code&gt; 이고, 두 번째 문자는 쓰기 권한을 나타내는 &lt;code&gt;'w'&lt;/code&gt; 이며, 세 번째 문자는 실행 권한 &lt;code&gt;'x'&lt;/code&gt; 경우 'x' 입니다. 권한이 설정되지 않은 경우 해당 문자는 &lt;code&gt;'-'&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9d482d82a8c67b95f55d10ab3dda1aad0c96b7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;persistPolicy&lt;/code&gt; and &lt;code&gt;currencyTimeLimit&lt;/code&gt; fields are meaningless for constructors, but are not considered invalid.</source>
          <target state="translated">&lt;code&gt;persistPolicy&lt;/code&gt; 과 &lt;code&gt;currencyTimeLimit&lt;/code&gt; 에는 필드는 생성자에 대한 의미가 있지만, 유효하지 않은 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca92d75fa54a7f375119b1732a1defda2c5a065a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;popup&lt;/code&gt; can be set on one &lt;code&gt;TrayIcon&lt;/code&gt; only. Setting the same popup on multiple &lt;code&gt;TrayIcon&lt;/code&gt;s will cause an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.</source>
          <target state="translated">그만큼 &lt;code&gt;popup&lt;/code&gt; 하나를 설정할 수 있습니다 &lt;code&gt;TrayIcon&lt;/code&gt; 에 만. 여러 &lt;code&gt;TrayIcon&lt;/code&gt; 에 동일한 팝업을 설정하면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="822e7053ed501794bcb73e078de627432ea24760" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pos&lt;/code&gt; argument may range between zero and</source>
          <target state="translated">그만큼 &lt;code&gt;pos&lt;/code&gt; 인수 제로 사이의 범위 일 수있다</target>
        </trans-unit>
        <trans-unit id="0d4b8df143426535636c3d9fcf5d259dd494e8ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pos&lt;/code&gt; argument selects which parameters are to be bound. It may range between zero and</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 매개 변수는 인수 선택이 결합된다. 0과 0 사이의 범위 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a88d4013b421f51fd6a8b134cf58266c11d071d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pred&lt;/code&gt; handle describes the loop condition; and &lt;code&gt;body&lt;/code&gt;, its body. The loop resulting from this method will, in each iteration, first evaluate the predicate and then execute its body (if the predicate evaluates to &lt;code&gt;true&lt;/code&gt;). The loop will terminate once the predicate evaluates to &lt;code&gt;false&lt;/code&gt; (the body will not be executed in this case).</source>
          <target state="translated">그만큼 &lt;code&gt;pred&lt;/code&gt; 핸들 루프 조건을 나타내고; 그리고 &lt;code&gt;body&lt;/code&gt; , 그 몸. 이 메서드의 결과 루프는 각 반복에서 먼저 술어를 평가 한 다음 해당 본문을 실행합니다 (조건자가 &lt;code&gt;true&lt;/code&gt; 로 평가되는 경우 ). 술어가 &lt;code&gt;false&lt;/code&gt; 로 평가되면 루프가 종료됩니다 (이 경우 본문이 실행되지 않음).</target>
        </trans-unit>
        <trans-unit id="a86ac63e6484dc40818acb31efed1223ef30cbe4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pred&lt;/code&gt; handle describes the loop condition; and &lt;code&gt;body&lt;/code&gt;, its body. The loop resulting from this method will, in each iteration, first execute its body and then evaluate the predicate. The loop will terminate once the predicate evaluates to &lt;code&gt;false&lt;/code&gt; after an execution of the body.</source>
          <target state="translated">&lt;code&gt;pred&lt;/code&gt; 핸들 루프 조건을 나타내고; 그리고 &lt;code&gt;body&lt;/code&gt; , 그 몸. 이 메서드의 결과 루프는 각 반복에서 먼저 본문을 실행 한 다음 술어를 평가합니다. 루프는 본문 실행 후 술어가 &lt;code&gt;false&lt;/code&gt; 평가되면 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="83271b2397fc080adb45b6ed96f5fc2c799338f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pred&lt;/code&gt; handle must not be &lt;code&gt;null&lt;/code&gt;. It must have &lt;code&gt;boolean&lt;/code&gt; as its return type. Its parameter list (either empty or of the form &lt;code&gt;(V A*)&lt;/code&gt;) must be effectively identical to the internal parameter list.</source>
          <target state="translated">&lt;code&gt;pred&lt;/code&gt; 핸들이 아니어야합니다 &lt;code&gt;null&lt;/code&gt; . 반환 유형으로 &lt;code&gt;boolean&lt;/code&gt; 이 있어야합니다 . 매개 변수 목록 (비어 있거나 &lt;code&gt;(V A*)&lt;/code&gt; 형식 )은 내부 매개 변수 목록과 실질적으로 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="12d2f504fe0c18a15bb945c0612b6e3db966f980" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preferredSize&lt;/code&gt; is only computed once, subsequent calls to this method just return a cached size.</source>
          <target state="translated">&lt;code&gt;preferredSize&lt;/code&gt; 가이 한 번만 계산이 방법에 대한 후속 호출은 캐시 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3295278a86db378f96ef38915c5399dfa8f46eb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; argument must be at least three characters long. It is recommended that the prefix be a short, meaningful string such as &lt;code&gt;&quot;hjb&quot;&lt;/code&gt; or &lt;code&gt;&quot;mail&quot;&lt;/code&gt;. The &lt;code&gt;suffix&lt;/code&gt; argument may be &lt;code&gt;null&lt;/code&gt;, in which case the suffix &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; will be used.</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 인수는 길이 3 자 이상이어야합니다. 접두어는 &lt;code&gt;&quot;hjb&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;mail&quot;&lt;/code&gt; 과 같이 짧고 의미있는 문자열 인 것이 좋습니다 . &lt;code&gt;suffix&lt;/code&gt; 인수는있을 수 있습니다 &lt;code&gt;null&lt;/code&gt; 접미사가있는 경우에, &lt;code&gt;&quot;.tmp&quot;&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="925230b553f62600c7f8ab6d82a4beb6853e7805" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;premain&lt;/code&gt; method has one of two possible signatures. The JVM first attempts to invoke the following method on the agent class:</source>
          <target state="translated">&lt;code&gt;premain&lt;/code&gt; 방법은 두 가지 중 하나의 서명이있다. JVM은 먼저 에이전트 클래스에서 다음 메소드를 호출하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="472d7917be1b3a899af16c5d311e26bdd6f1aec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;process&lt;/code&gt; argument specifies the &lt;a href=&quot;../../../../java.base/java/lang/process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object for the taget VM. It may be specified as &lt;code&gt;null&lt;/code&gt;. If the target VM is launched by a &lt;a href=&quot;connect/launchingconnector&quot;&gt;&lt;code&gt;LaunchingConnector&lt;/code&gt;&lt;/a&gt; the &lt;code&gt;process&lt;/code&gt; argument should be specified, otherwise calling &lt;a href=&quot;virtualmachine#process()&quot;&gt;&lt;code&gt;VirtualMachine.process()&lt;/code&gt;&lt;/a&gt; on the created virtual machine will return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;process&lt;/code&gt; 인수는 지정 &lt;a href=&quot;../../../../java.base/java/lang/process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; taget VM에 대한 개체를. &lt;code&gt;null&lt;/code&gt; 로 지정 될 수 있습니다 . 대상 VM이 &lt;a href=&quot;connect/launchingconnector&quot;&gt; &lt;code&gt;LaunchingConnector&lt;/code&gt; 에&lt;/a&gt; 의해 시작 되는 경우 &lt;code&gt;process&lt;/code&gt; 인수를 지정해야합니다. 그렇지 않으면 생성 된 가상 머신에서 &lt;a href=&quot;virtualmachine#process()&quot;&gt; &lt;code&gt;VirtualMachine.process()&lt;/code&gt; &lt;/a&gt; 를 호출 하면 &lt;code&gt;null&lt;/code&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="0521fbe64ec7e5f9ef121124473e0d97a004ca5c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r.width&lt;/code&gt; or &lt;code&gt;r.height&lt;/code&gt; values will be automatically enlarged if either is less than the minimum size as specified by previous call to &lt;code&gt;setMinimumSize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r.width&lt;/code&gt; 또는 &lt;code&gt;r.height&lt;/code&gt; 에 이전 호출에 의해 지정된 하나 적은 최소 크기 이하인 경우 값이 자동으로 확대된다 &lt;code&gt;setMinimumSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5caea50061710cec044d7be43530e50e1eb551a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;radix&lt;/code&gt; argument is valid if it is greater than or equal to &lt;code&gt;MIN_RADIX&lt;/code&gt; and less than or equal to &lt;code&gt;MAX_RADIX&lt;/code&gt;. The &lt;code&gt;digit&lt;/code&gt; argument is valid if &lt;code&gt;0 &amp;lt;= digit &amp;lt; radix&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;radix&lt;/code&gt; 가보다 크거나 같으면 인수 유효 &lt;code&gt;MIN_RADIX&lt;/code&gt; 미만 또는 동등 &lt;code&gt;MAX_RADIX&lt;/code&gt; . &lt;code&gt;digit&lt;/code&gt; 인수 경우 유효 &lt;code&gt;0 &amp;lt;= digit &amp;lt; radix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b33942ad43fbe9d22cb9d95c4c4908fdaa08301" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;radix&lt;/code&gt; is either smaller than &lt;a href=&quot;character#MIN_RADIX&quot;&gt;&lt;code&gt;Character.MIN_RADIX&lt;/code&gt;&lt;/a&gt; or larger than &lt;a href=&quot;character#MAX_RADIX&quot;&gt;&lt;code&gt;Character.MAX_RADIX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;radix&lt;/code&gt; 하나보다 작은 &lt;a href=&quot;character#MIN_RADIX&quot;&gt; &lt;code&gt;Character.MIN_RADIX&lt;/code&gt; &lt;/a&gt; 보다 작거나 큰 &lt;a href=&quot;character#MAX_RADIX&quot;&gt; &lt;code&gt;Character.MAX_RADIX&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d785142e5ab58037a089cd9e5a386011f0b7e09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ranges&lt;/code&gt; to be given can take one of the following forms:</source>
          <target state="translated">제공되는 &lt;code&gt;ranges&lt;/code&gt; 는 다음 형식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1259bcaaf2e03d5637399a403f2eed4bcb0658f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read(b)&lt;/code&gt; method for class &lt;code&gt;InputStream&lt;/code&gt; has the same effect as:</source>
          <target state="translated">&lt;code&gt;InputStream&lt;/code&gt; 클래스 의 &lt;code&gt;read(b)&lt;/code&gt; 메소드 는 다음과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4604e99f767c72aaa96525bf29f68941bb283ab2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read(b)&lt;/code&gt; method has the same effect as:</source>
          <target state="translated">&lt;code&gt;read(b)&lt;/code&gt; 에있어서의 효과는 :</target>
        </trans-unit>
        <trans-unit id="85d1e68ced47f29a100869a09cd002ed4be72da4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read(b, off, len)&lt;/code&gt; method for class &lt;code&gt;InputStream&lt;/code&gt; simply calls the method &lt;code&gt;read()&lt;/code&gt; repeatedly. If the first such call results in an &lt;code&gt;IOException&lt;/code&gt;, that exception is returned from the call to the &lt;code&gt;read(b,&lt;/code&gt;&lt;code&gt;off,&lt;/code&gt;&lt;code&gt;len)&lt;/code&gt; method. If any subsequent call to &lt;code&gt;read()&lt;/code&gt; results in a &lt;code&gt;IOException&lt;/code&gt;, the exception is caught and treated as if it were end of file; the bytes read up to that point are stored into &lt;code&gt;b&lt;/code&gt; and the number of bytes read before the exception occurred is returned. The default implementation of this method blocks until the requested amount of input data &lt;code&gt;len&lt;/code&gt; has been read, end of file is detected, or an exception is thrown. Subclasses are encouraged to provide a more efficient implementation of this method.</source>
          <target state="translated">&lt;code&gt;InputStream&lt;/code&gt; 클래스 의 &lt;code&gt;read(b, off, len)&lt;/code&gt; 메서드는 단순히 &lt;code&gt;read()&lt;/code&gt; 메서드를 반복적으로 호출합니다 . 이러한 첫 번째 호출 결과 &lt;code&gt;IOException&lt;/code&gt; 이 발생하면 해당 예외는 &lt;code&gt;read(b,&lt;/code&gt; &lt;code&gt;off,&lt;/code&gt; &lt;code&gt;len)&lt;/code&gt; 메서드에 대한 호출에서 반환됩니다 . &lt;code&gt;read()&lt;/code&gt; 대한 후속 호출로 인해 &lt;code&gt;IOException&lt;/code&gt; 이 발생하면 예외가 포착되어 파일의 끝인 것처럼 처리됩니다. 그 지점까지 읽은 바이트는 &lt;code&gt;b&lt;/code&gt; 에 저장되고 예외가 발생하기 전에 읽은 바이트 수가 리턴됩니다. 이 메소드의 기본 구현은 요청 된 양의 입력 데이터 &lt;code&gt;len&lt;/code&gt; 까지 차단됩니다.읽었거나 파일 끝이 감지되었거나 예외가 발생했습니다. 이 메서드의보다 효율적인 구현을 제공하기 위해 하위 클래스가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="d053108594714cc2e678b8a8b8bcae476c059c88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read(b,&lt;/code&gt;&lt;code&gt;off,&lt;/code&gt;&lt;code&gt;len)&lt;/code&gt; method for class &lt;code&gt;InputStream&lt;/code&gt; simply calls the method &lt;code&gt;read()&lt;/code&gt; repeatedly. If the first such call results in an &lt;code&gt;IOException&lt;/code&gt;, that exception is returned from the call to the &lt;code&gt;read(b,&lt;/code&gt;&lt;code&gt;off,&lt;/code&gt;&lt;code&gt;len)&lt;/code&gt; method. If any subsequent call to &lt;code&gt;read()&lt;/code&gt; results in a &lt;code&gt;IOException&lt;/code&gt;, the exception is caught and treated as if it were end of file; the bytes read up to that point are stored into &lt;code&gt;b&lt;/code&gt; and the number of bytes read before the exception occurred is returned. The default implementation of this method blocks until the requested amount of input data &lt;code&gt;len&lt;/code&gt; has been read, end of file is detected, or an exception is thrown. Subclasses are encouraged to provide a more efficient implementation of this method.</source>
          <target state="translated">&lt;code&gt;InputStream&lt;/code&gt; 클래스 의 &lt;code&gt;read(b,&lt;/code&gt; &lt;code&gt;off,&lt;/code&gt; &lt;code&gt;len)&lt;/code&gt; 메소드는 단순히 &lt;code&gt;read()&lt;/code&gt; 메소드를 반복적으로 호출합니다 . 첫 번째 호출로 &lt;code&gt;IOException&lt;/code&gt; 이 발생하면 해당 예외는 호출에서 &lt;code&gt;read(b,&lt;/code&gt; &lt;code&gt;off,&lt;/code&gt; &lt;code&gt;len)&lt;/code&gt; 메소드 로 리턴됩니다 . &lt;code&gt;read()&lt;/code&gt; 대한 후속 호출로 인해 &lt;code&gt;IOException&lt;/code&gt; 이 발생하면 예외는 파일의 끝인 것처럼 잡히고 처리됩니다. 해당 시점까지 읽은 바이트 &lt;code&gt;b&lt;/code&gt; 에 예외가 발생하기 전에 읽은 바이트 수가 리턴됩니다. 이 메소드의 기본 구현은 요청 된 양의 입력 데이터가 &lt;code&gt;len&lt;/code&gt; 까지 차단됩니다.읽었거나 파일 끝이 감지되었거나 예외가 발생했습니다. 서브 클래스는이 메소드를보다 효율적으로 구현할 것을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="d73e15d99486a3edb623a542384b22544dac32ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;InputStream&lt;/code&gt; calls the &lt;code&gt;read&lt;/code&gt; method of three arguments with the arguments &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;b.length&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 방법 &lt;code&gt;InputStream&lt;/code&gt; 부르는 &lt;code&gt;read&lt;/code&gt; 인수와 세 개의 인수의 방법 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , 및 &lt;code&gt;b.length&lt;/code&gt; 를을 .</target>
        </trans-unit>
        <trans-unit id="7efed5a820d4dabed25b8a28bd1df6414d7e77e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;LineNumberInputStream&lt;/code&gt; calls the &lt;code&gt;read&lt;/code&gt; method of the underlying input stream. It checks for carriage returns and newline characters in the input, and modifies the current line number as appropriate. A carriage-return character or a carriage return followed by a newline character are both converted into a single newline character.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 의 방법 &lt;code&gt;LineNumberInputStream&lt;/code&gt; 가 부르는 &lt;code&gt;read&lt;/code&gt; 기본이되는 입력 스트림의 방법을. 입력에서 캐리지 리턴과 개행 문자를 확인하고 현재 행 번호를 적절하게 수정합니다. 캐리지 리턴 문자 또는 캐리지 리턴 다음에 개행 문자가 둘 다 단일 개행 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4d12f1e1c60d3ded7ff55ddd8ec9fa42dcbe1312" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;LineNumberInputStream&lt;/code&gt; repeatedly calls the &lt;code&gt;read&lt;/code&gt; method of zero arguments to fill in the byte array.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 방법 &lt;code&gt;LineNumberInputStream&lt;/code&gt; 가 반복 호출 &lt;code&gt;read&lt;/code&gt; 바이트 배열을 작성 제로 인수 방법.</target>
        </trans-unit>
        <trans-unit id="9c073aae985b3b46c91c5b9276bb615fd3d6afcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;SequenceInputStream&lt;/code&gt; tries to read the data from the current substream. If it fails to read any characters because the substream has reached the end of the stream, it calls the &lt;code&gt;close&lt;/code&gt; method of the current substream and begins reading from the next substream.</source>
          <target state="translated">&lt;code&gt;SequenceInputStream&lt;/code&gt; 의 &lt;code&gt;read&lt;/code&gt; 메소드 는 현재 서브 스트림에서 데이터를 읽으려고합니다. 서브 스트림이 스트림의 끝에 도달하여 문자를 읽지 못하면 현재 서브 스트림 의 &lt;code&gt;close&lt;/code&gt; 메소드를 호출 하고 다음 서브 스트림에서 읽기를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="266c4f3bc071054256173e68adbd4a6e7656ec4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;StringBufferInputStream&lt;/code&gt; cannot block. It copies the low eight bits from the characters in this input stream's buffer into the byte array argument.</source>
          <target state="translated">&lt;code&gt;StringBufferInputStream&lt;/code&gt; 의 &lt;code&gt;read&lt;/code&gt; 메소드는 차단할 수 없습니다. 이 입력 스트림 버퍼의 문자에서 하위 8 비트를 바이트 배열 인수로 복사합니다.</target>
        </trans-unit>
        <trans-unit id="e61745f20485b6632a27794087bfb013bec50ba7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of &lt;code&gt;StringBufferInputStream&lt;/code&gt; cannot block. It returns the low eight bits of the next character in this input stream's buffer.</source>
          <target state="translated">&lt;code&gt;StringBufferInputStream&lt;/code&gt; 의 &lt;code&gt;read&lt;/code&gt; 메소드는 차단할 수 없습니다. 이 입력 스트림의 버퍼에있는 다음 문자의 하위 8 비트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4aaed4854c67e469816ea074297444b594e5943c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of the &lt;code&gt;InputStream&lt;/code&gt; may throw the &lt;a href=&quot;../../../java.base/java/io/interruptedioexception&quot;&gt;&lt;code&gt;InterruptedIOException&lt;/code&gt;&lt;/a&gt; to signal the user canceled the input. The currently running snippet will be automatically &lt;a href=&quot;jshell#stop()&quot;&gt;&lt;code&gt;stopped&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;InputStream&lt;/code&gt; 의 &lt;code&gt;read&lt;/code&gt; 메서드 는 &lt;a href=&quot;../../../java.base/java/io/interruptedioexception&quot;&gt; &lt;code&gt;InterruptedIOException&lt;/code&gt; &lt;/a&gt; 을 발생시켜 사용자가 입력을 취소 했음을 알릴 수 있습니다 . 현재 실행중인 스 니펫은 자동으로 &lt;a href=&quot;jshell#stop()&quot;&gt; &lt;code&gt;stopped&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b68abbad5ba6fb28f94eaadf9085c6dda28742eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; method of the underlying stream returns &lt;code&gt;-1&lt;/code&gt;, indicating end-of-file, or</source>
          <target state="translated">기본 스트림 의 &lt;code&gt;read&lt;/code&gt; 메소드는 파일 끝을 나타내는 &lt;code&gt;-1&lt;/code&gt; 을 리턴 하거나</target>
        </trans-unit>
        <trans-unit id="3c7f1342e13b19c7f98cefc6efd106f8e231e650" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; methods of the resulting stream will throw an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; if invoked while the underlying channel is in non-blocking mode. The stream will not be buffered, and it will not support the &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/inputstream#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">결과 스트림 의 &lt;code&gt;read&lt;/code&gt; 메소드 는 기본 채널이 비 차단 모드에있는 동안 호출되면 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; 을&lt;/a&gt; 발생시킵니다. 스트림은 버퍼링되지 않으며 &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;../../io/inputstream#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메서드를. 스트림은 여러 동시 스레드에 의한 액세스에 안전합니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="6ff4f563e5b69d4b6268d50e4aa9d51aa5725103" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; methods of the resulting stream will throw an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; if invoked while the underlying channel is in non-blocking mode. The stream will not be buffered, and it will not support the &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; methods. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">기본 채널이 비 블로킹 모드에있는 동안 호출되면 결과 스트림 의 &lt;code&gt;read&lt;/code&gt; 메소드에서 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 스트림은 버퍼링되지 않으며 &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 메소드를 지원하지 않습니다 . 스트림은 여러 개의 동시 스레드가 안전하게 액세스 할 수 있습니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="3b7ea7159daa93e13abc58f5ee72d1aa9624ff2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; methods of the returned &lt;code&gt;InputStream&lt;/code&gt; will throw &lt;code&gt;IOException&lt;/code&gt; when reading bytes that cannot be decoded.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 반환 된 방법 &lt;code&gt;InputStream&lt;/code&gt; 발생합니다 &lt;code&gt;IOException&lt;/code&gt; 가 디코딩 할 수없는 바이트를 읽을 때.</target>
        </trans-unit>
        <trans-unit id="05a4ee599465096efb07afcd435e0618463168e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readData&lt;/code&gt; method adds rows to the caller. It can be implemented in a wide variety of ways and can even populate the caller with rows from a nonrelational data source. In general, a reader may invoke any of the rowset's methods, with one exception. Calling the method &lt;code&gt;execute&lt;/code&gt; will cause an &lt;code&gt;SQLException&lt;/code&gt; to be thrown because &lt;code&gt;execute&lt;/code&gt; may not be called recursively. Also, when a reader invokes &lt;code&gt;RowSet&lt;/code&gt; methods, no listeners are notified; that is, no &lt;code&gt;RowSetEvent&lt;/code&gt; objects are generated and no &lt;code&gt;RowSetListener&lt;/code&gt; methods are invoked. This is true because listeners are already being notified by the method &lt;code&gt;execute&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;readData&lt;/code&gt; 방법은 발신자에 행을 추가한다. 다양한 방법으로 구현할 수 있으며 비 관계형 데이터 소스의 행으로 호출자를 채울 수도 있습니다. 일반적으로 판독기는 한 가지 예외를 제외하고 행 집합의 모든 메서드를 호출 할 수 있습니다. 이 방법은 호출 &lt;code&gt;execute&lt;/code&gt; 의 원인이됩니다 &lt;code&gt;SQLException&lt;/code&gt; 때문에 슬로우 &lt;code&gt;execute&lt;/code&gt; 재귀 적으로 호출 할 수 없습니다. 또한 판독기가 &lt;code&gt;RowSet&lt;/code&gt; 메서드를 호출 할 때 리스너는 알림을받지 않습니다. 즉, &lt;code&gt;RowSetEvent&lt;/code&gt; 객체가 생성되지 않고 &lt;code&gt;RowSetListener&lt;/code&gt; 메서드가 호출 되지 않습니다 . 이는 리스너가 &lt;code&gt;execute&lt;/code&gt; 메소드에서 이미 알림을 받고 있기 때문에 사실 입니다.</target>
        </trans-unit>
        <trans-unit id="b52f6c80e4a3c11df2890b54a5a8b3b1218aeabd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to allow that many bytes to be read before the mark position gets invalidated.</source>
          <target state="translated">&lt;code&gt;readlimit&lt;/code&gt; 는의 인수는, 마크 위치가 무효가되기 전에 많은 바이트를 읽도록하려면이 입력 스트림을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="f523a2bdf73035ee44a575de3e5dff08d7683039" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readlimit&lt;/code&gt; arguments tells this input stream to allow that many bytes to be read before the mark position gets invalidated.</source>
          <target state="translated">&lt;code&gt;readlimit&lt;/code&gt; 는의 인수는, 마크 위치가 무효가되기 전에 많은 바이트를 읽도록하려면이 입력 스트림을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="26aa2e19c94981b7af3edb0fd924e85788e560ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready&lt;/code&gt; method of the underlying stream returns &lt;code&gt;false&lt;/code&gt;, indicating that further input requests would block.</source>
          <target state="translated">기본 스트림 의 &lt;code&gt;ready&lt;/code&gt; 메소드는 추가 입력 요청이 &lt;code&gt;false&lt;/code&gt; 을 나타내는 false를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="82057f4ffe730acc914f906991a8da694e9b715d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reducing()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, downstream of &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. To perform a simple map-reduce on a stream, use &lt;a href=&quot;stream#map(java.util.function.Function)&quot;&gt;&lt;code&gt;Stream.map(Function)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stream#reduce(T,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">그만큼 &lt;code&gt;reducing()&lt;/code&gt; 의 하류에 다중 레벨의 감소에 사용될 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 스트림에서 간단한 맵 축소를 수행하려면 대신 &lt;a href=&quot;stream#map(java.util.function.Function)&quot;&gt; &lt;code&gt;Stream.map(Function)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stream#reduce(T,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="165873d7f5551dc1377b152568842b2aacddf487" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reducing()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, downstream of &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. To perform a simple map-reduce on a stream, use &lt;a href=&quot;stream#map-java.util.function.Function-&quot;&gt;&lt;code&gt;Stream.map(Function)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stream#reduce-T-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;reducing()&lt;/code&gt; 의 하류에 다중 레벨의 감소에 사용될 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 스트림에서 간단한 맵 축소를 수행하려면 &lt;a href=&quot;stream#map-java.util.function.Function-&quot;&gt; &lt;code&gt;Stream.map(Function)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stream#reduce-T-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b8dd7b9000da8c4a38e9a5b07cb2af0e9bc54239" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reducing()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, downstream of &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. To perform a simple reduction on a stream, use &lt;a href=&quot;stream#reduce(T,java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt;&lt;/a&gt;} instead.</source>
          <target state="translated">&lt;code&gt;reducing()&lt;/code&gt; 의 하류에 다중 레벨의 감소에 사용될 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 스트림에서 단순 축소를 수행하려면 대신 &lt;a href=&quot;stream#reduce(T,java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt; &lt;/a&gt; }를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1031f383b6493cee2618b8a613faaaa7b50cece7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reducing()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, downstream of &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. To perform a simple reduction on a stream, use &lt;a href=&quot;stream#reduce(java.util.function.BinaryOperator)&quot;&gt;&lt;code&gt;Stream.reduce(BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;reducing()&lt;/code&gt; 의 하류에 다중 레벨의 감소에 사용될 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 스트림에서 단순 감소를 수행하려면 다음을 사용하십시오.&lt;a href=&quot;stream#reduce(java.util.function.BinaryOperator)&quot;&gt; &lt;code&gt;Stream.reduce(BinaryOperator)&lt;/code&gt; &lt;/a&gt;대신 Stream.reduce (BinaryOperator)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7e64fcbf48d32ed9f489fe7ed817a63867533729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reducing()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, downstream of &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. To perform a simple reduction on a stream, use &lt;a href=&quot;stream#reduce-T-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt;&lt;/a&gt;} instead.</source>
          <target state="translated">&lt;code&gt;reducing()&lt;/code&gt; 의 하류에 다중 레벨의 감소에 사용될 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 스트림에서 간단한 축소를 수행하려면 대신 &lt;a href=&quot;stream#reduce-T-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;Stream.reduce(Object, BinaryOperator)&lt;/code&gt; &lt;/a&gt; }를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="331f2b86728595fcc490eed59b6a8eb8cea11e3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reducing()&lt;/code&gt; collectors are most useful when used in a multi-level reduction, downstream of &lt;code&gt;groupingBy&lt;/code&gt; or &lt;code&gt;partitioningBy&lt;/code&gt;. To perform a simple reduction on a stream, use &lt;a href=&quot;stream#reduce-java.util.function.BinaryOperator-&quot;&gt;&lt;code&gt;Stream.reduce(BinaryOperator)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;reducing()&lt;/code&gt; 의 하류에 다중 레벨의 감소에 사용될 때 수집은 가장 유용 &lt;code&gt;groupingBy&lt;/code&gt; 또는 &lt;code&gt;partitioningBy&lt;/code&gt; . 스트림에서 간단한 축소를 수행하려면 &lt;a href=&quot;stream#reduce-java.util.function.BinaryOperator-&quot;&gt; &lt;code&gt;Stream.reduce(BinaryOperator)&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6e4a1cfb3d954ef8dc93a66017c84659865340e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refresh&lt;/code&gt; method causes the policy object to refresh/reload its data. This operation is implementation-dependent. For example, if the policy object stores its data in configuration files, calling &lt;code&gt;refresh&lt;/code&gt; will cause it to re-read the configuration policy files. If a refresh operation is not supported, this method does nothing. Note that refreshed policy may not have an effect on classes in a particular ProtectionDomain. This is dependent on the Policy provider's implementation of the &lt;code&gt;implies&lt;/code&gt; method and its PermissionCollection caching strategy.</source>
          <target state="translated">&lt;code&gt;refresh&lt;/code&gt; 방법은 정책 개체 / 새로 고침 데이터를 다시로드됩니다. 이 작업은 구현에 따라 다릅니다. 예를 들어, 정책 개체가 데이터를 구성 파일에 저장하는 경우 &lt;code&gt;refresh&lt;/code&gt; 를 호출 하면 구성 정책 파일을 다시 읽게됩니다. 새로 고침 작업이 지원되지 않으면이 방법은 아무 작업도 수행하지 않습니다. 새로 고친 정책은 특정 ProtectionDomain의 클래스에 영향을 미치지 않을 수 있습니다. 이는 정책 공급자의 &lt;code&gt;implies&lt;/code&gt; 메소드 구현 및 PermissionCollection 캐싱 전략에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="e2cb1c75917513fd66c67c74580c51f242c6ba51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refreshRow&lt;/code&gt; method provides a way for an application to explicitly tell the JDBC driver to refetch a row(s) from the database. An application may want to call &lt;code&gt;refreshRow&lt;/code&gt; when caching or prefetching is being done by the JDBC driver to fetch the latest value of a row from the database. The JDBC driver may actually refresh multiple rows at once if the fetch size is greater than one.</source>
          <target state="translated">&lt;code&gt;refreshRow&lt;/code&gt; 방법은 응용 프로그램이 명시 적으로 데이터베이스에서의 행의 재 취득을 위해 JDBC 드라이버를 알 수있는 방법을 제공합니다. 응용 프로그램에서 전화를 걸 수 있습니다. &lt;code&gt;refreshRow&lt;/code&gt; 데이터베이스에서 행의 최신 값을 가져 오기 위해 JDBC 드라이버가 캐싱 또는 프리 페치를 수행 할 때 refreshRow 있습니다. JDBC 드라이버는 페치 크기가 1보다 큰 경우 실제로 한 번에 여러 행을 새로 고칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b92536f2a5a0e1a3b6f9a0f2c5c546403063f5bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;registerMBean&lt;/code&gt; method is simpler for local use, but cannot be used remotely. The &lt;code&gt;createMBean&lt;/code&gt; method can be used remotely, but sometimes requires attention to class loading issues.</source>
          <target state="translated">&lt;code&gt;registerMBean&lt;/code&gt; 방법은 현지 사용을위한 간단하지만 원격으로 사용할 수 없습니다. &lt;code&gt;createMBean&lt;/code&gt; 방법은 원격으로 사용할 수 있지만, 클래스의로드의 문제에주의를 필요로 할 수있다.</target>
        </trans-unit>
        <trans-unit id="3bd964509b0c0b7b2aff54193499f79341906bf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;registerObject&lt;/code&gt; method is used to register an activation descriptor, &lt;code&gt;desc&lt;/code&gt;, and obtain an activation identifier for a activatable remote object.</source>
          <target state="translated">&lt;code&gt;registerObject&lt;/code&gt; 의 방법은, 기동 기술자를 등록하는 데 사용 &lt;code&gt;desc&lt;/code&gt; , 및 기동 가능한 원격 객체의 기동 식별자를 얻었다.</target>
        </trans-unit>
        <trans-unit id="0648dc19ee55d0e590d0f1e083a26887e631abbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;registerObject&lt;/code&gt; method is used to register an activation descriptor, &lt;code&gt;desc&lt;/code&gt;, and obtain an activation identifier for a activatable remote object. The &lt;code&gt;ActivationSystem&lt;/code&gt; creates an &lt;code&gt;ActivationID&lt;/code&gt; (a activation identifier) for the object specified by the descriptor, &lt;code&gt;desc&lt;/code&gt;, and records, in stable storage, the activation descriptor and its associated identifier for later use. When the &lt;code&gt;Activator&lt;/code&gt; receives an &lt;code&gt;activate&lt;/code&gt; request for a specific identifier, it looks up the activation descriptor (registered previously) for the specified identifier and uses that information to activate the object.</source>
          <target state="translated">&lt;code&gt;registerObject&lt;/code&gt; 에 있어서 기동 기술자 등록하는 데 사용되는 &lt;code&gt;desc&lt;/code&gt; , 및 기동 가능한 원격 객체의 기동 식별자를 얻었다. &lt;code&gt;ActivationSystem&lt;/code&gt; 를는 생성 &lt;code&gt;ActivationID&lt;/code&gt; , 기술자에 의해 지정된 개체 (기동 식별자) &lt;code&gt;desc&lt;/code&gt; 안정된 저장, 나중에 사용하기위한 기동 기술자 및 관련 식별자에, 그리고 기록. 때 &lt;code&gt;Activator&lt;/code&gt; 수신 &lt;code&gt;activate&lt;/code&gt; 특정 식별자에 대한 요청을, 상기 지정된 식별자 및 정보 객체를 활성화 할 것을 용도 기동 기술자 (미리 등록)를 보인다.</target>
        </trans-unit>
        <trans-unit id="d5b769a6261bcf9c925196e481e33f743eb9161c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replaceEditor&lt;/code&gt; method is called when the spinners editor is changed with &lt;code&gt;JSpinner.setEditor&lt;/code&gt;. If you've overriden this method, then you'll probably want to override &lt;code&gt;replaceEditor&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;replaceEditor&lt;/code&gt; 스피 나 에디터가로 변경 될 때 메소드가 불려 &lt;code&gt;JSpinner.setEditor&lt;/code&gt; . 이 메서드를 재정의했다면 &lt;code&gt;replaceEditor&lt;/code&gt; 를 재정의하고 싶을 것입니다. 도 .</target>
        </trans-unit>
        <trans-unit id="b2bff7fa0a0c8c4fa4c945d1cc03fe4bb97f5383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;required&lt;/code&gt; field is &lt;code&gt;true&lt;/code&gt; if a value must be supplied for this property during &lt;code&gt;Driver.connect&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;required&lt;/code&gt; 필드는 &lt;code&gt;true&lt;/code&gt; 값을 지정해야하는 경우, &lt;code&gt;Driver.connect&lt;/code&gt; 에 와 &lt;code&gt;false&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="dec43624de062d1e7493f56cb68ff2515b4d245d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; method of &lt;code&gt;LineNumberInputStream&lt;/code&gt; resets the line number to be the line number at the time the &lt;code&gt;mark&lt;/code&gt; method was called, and then calls the &lt;code&gt;reset&lt;/code&gt; method of the underlying input stream.</source>
          <target state="translated">&lt;code&gt;LineNumberInputStream&lt;/code&gt; 의 &lt;code&gt;reset&lt;/code&gt; 메소드는 &lt;code&gt;mark&lt;/code&gt; 메소드가 호출 될 때 행 번호가되도록 행 번호를 &lt;code&gt;reset&lt;/code&gt; 한 다음 기본 입력 스트림 의 reset 메소드 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="bcb2620e18cfc65d493f7d3aa17132a5ca731483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;root&lt;/code&gt; node of the &lt;code&gt;TreeWalker&lt;/code&gt;, as specified when it was created.</source>
          <target state="translated">그만큼 &lt;code&gt;root&lt;/code&gt; 의 노드 &lt;code&gt;TreeWalker&lt;/code&gt; 는 이 생성 된 경우로 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="ef077420b03ffbe4cf9c89bd8f72839c46602b82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; components should be floating-point values between zero and one (numbers in the range 0.0-1.0). The &lt;code&gt;h&lt;/code&gt; component can be any floating-point number. The floor of this number is subtracted from it to create a fraction between 0 and 1. This fractional number is then multiplied by 360 to produce the hue angle in the HSB color model.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 성분 (0.0 ~ 1.0의 범위의 수)는 0과 1 사이의 부동 소수점 값이어야한다. &lt;code&gt;h&lt;/code&gt; 구성 요소는 부동 소수점 숫자가 될 수 있습니다. 이 숫자의 하한값을 빼서 0과 1 사이의 분수를 만듭니다. 그런 다음이 분수에 360을 곱하여 HSB 색상 모델에서 색조 각도를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e6920483d1b5d5fdadee6caa3bd9747d28274c80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;saturation&lt;/code&gt; and &lt;code&gt;brightness&lt;/code&gt; components should be floating-point values between zero and one (numbers in the range 0.0-1.0). The &lt;code&gt;hue&lt;/code&gt; component can be any floating-point number. The floor of this number is subtracted from it to create a fraction between 0 and 1. This fractional number is then multiplied by 360 to produce the hue angle in the HSB color model.</source>
          <target state="translated">&lt;code&gt;saturation&lt;/code&gt; 및 &lt;code&gt;brightness&lt;/code&gt; 성분 (0.0 ~ 1.0의 범위의 수)는 0과 1 사이의 부동 소수점 값이어야한다. &lt;code&gt;hue&lt;/code&gt; 구성 요소는 부동 소수점 숫자가 될 수 있습니다. 이 숫자의 하한값을 빼서 0과 1 사이의 분수를 만듭니다. 그런 다음이 분수에 360을 곱하여 HSB 색상 모델에서 색조 각도를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9e487af727a443b2fc09683914bf955d5aed101d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;schedule&lt;/code&gt; methods create tasks with various delays and return a task object that can be used to cancel or check execution. The &lt;code&gt;scheduleAtFixedRate&lt;/code&gt; and &lt;code&gt;scheduleWithFixedDelay&lt;/code&gt; methods create and execute tasks that run periodically until cancelled.</source>
          <target state="translated">&lt;code&gt;schedule&lt;/code&gt; 메서드는 다양한 지연을 가지는 태스크를 생성하고 취소 체크 실행하는 데 사용할 수있는 작업 개체를 반환합니다. &lt;code&gt;scheduleAtFixedRate&lt;/code&gt; 및 &lt;code&gt;scheduleWithFixedDelay&lt;/code&gt; 방법은 생성하고 해제 할 때까지 주기적으로 실행 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="08c9e29dc36b0482fbc29013fb24d1e073d335c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scrollUnderway&lt;/code&gt; flag is used for components like &lt;code&gt;JList&lt;/code&gt;.</source>
          <target state="translated">그만큼 &lt;code&gt;scrollUnderway&lt;/code&gt; 의 플래그와 같은 구성 요소에 사용되는 &lt;code&gt;JList&lt;/code&gt; 의 .</target>
        </trans-unit>
        <trans-unit id="0d1c017ef96a248d10e61c88fe2cbb2851eb303e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scrollUnderway&lt;/code&gt; flag is used for components like &lt;code&gt;JList&lt;/code&gt;. When the downarrow key is pressed on a &lt;code&gt;JList&lt;/code&gt; and the selected cell is the last in the list, the &lt;code&gt;scrollpane&lt;/code&gt; autoscrolls. Here, the old selected cell needs repainting and so we need a flag to make the viewport do the optimized painting only when there is an explicit call to &lt;code&gt;setViewPosition(Point)&lt;/code&gt;. When &lt;code&gt;setBounds&lt;/code&gt; is called through other routes, the flag is off and the view repaints normally. Another approach would be to remove this from the &lt;code&gt;JViewport&lt;/code&gt; class and have the &lt;code&gt;JList&lt;/code&gt; manage this case by using &lt;code&gt;setBackingStoreEnabled&lt;/code&gt;. The default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scrollUnderway&lt;/code&gt; 의 플래그와 같은 구성 요소에 사용되는 &lt;code&gt;JList&lt;/code&gt; 를 . &lt;code&gt;JList&lt;/code&gt; 에서 아래쪽 화살표 키를 누르고 선택한 셀이 목록의 마지막 셀이면 &lt;code&gt;scrollpane&lt;/code&gt; 창이 자동 스크롤됩니다. 여기에서 이전에 선택한 셀은 다시 칠해야하므로 &lt;code&gt;setViewPosition(Point)&lt;/code&gt; 대한 명시 적 호출이있을 때만 뷰포트에서 최적화 된 페인팅을 수행하도록하는 플래그가 필요합니다 . &lt;code&gt;setBounds&lt;/code&gt; 가 다른 경로를 통해 호출 되면 플래그가 꺼지고 뷰가 정상적으로 다시 그려집니다. 또 다른 접근 방식은 &lt;code&gt;JViewport&lt;/code&gt; 클래스 에서 이것을 제거 하고 &lt;code&gt;JList&lt;/code&gt; 가 &lt;code&gt;setBackingStoreEnabled&lt;/code&gt; 를 사용 하여이 경우를 관리하도록하는 것 입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="275b9770ecb642dad5739bf9b860015b219e5bc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;seekForwardOnly&lt;/code&gt; parameter controls whether the value returned by &lt;code&gt;getMinIndex&lt;/code&gt; will be increased as each image (or thumbnail, or image metadata) is read. If &lt;code&gt;seekForwardOnly&lt;/code&gt; is true, then a call to &lt;code&gt;read(index)&lt;/code&gt; will throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; if &lt;code&gt;index &amp;lt; this.minIndex&lt;/code&gt;; otherwise, the value of &lt;code&gt;minIndex&lt;/code&gt; will be set to &lt;code&gt;index&lt;/code&gt;. If &lt;code&gt;seekForwardOnly&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the value of &lt;code&gt;minIndex&lt;/code&gt; will remain 0 regardless of any read operations.</source>
          <target state="translated">&lt;code&gt;seekForwardOnly&lt;/code&gt; 의해 리턴 된 값 여부 파라미터 조절기 &lt;code&gt;getMinIndex&lt;/code&gt; 각 화상 (또는 썸네일 이미지 또는 메타 데이터)으로 상승한다이 판독된다. 경우 &lt;code&gt;seekForwardOnly&lt;/code&gt; 는 사실에의 호출 &lt;code&gt;read(index)&lt;/code&gt; 발생합니다 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 경우 &lt;code&gt;index &amp;lt; this.minIndex&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;minIndex&lt;/code&gt; 값이 &lt;code&gt;index&lt;/code&gt; 로 설정됩니다 . 경우 &lt;code&gt;seekForwardOnly&lt;/code&gt; 가 인 &lt;code&gt;false&lt;/code&gt; 의 값 &lt;code&gt;minIndex&lt;/code&gt; 관계없이 읽기 작업의 0을 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d1482f0d46f1a2acb9dc1233fcf5f91d87996d1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sendClose&lt;/code&gt; method does not close this WebSocket's input. It merely closes this WebSocket's output by sending a Close message. To enforce closing the input, invoke the &lt;code&gt;abort&lt;/code&gt; method. Here is an example of an application that sends a Close message, and then starts a timer. Once no data has been received within the specified timeout, the timer goes off and the alarm aborts &lt;code&gt;WebSocket&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;sendClose&lt;/code&gt; 방법은이 웹 소켓의 입력 닫히지 않습니다. Close 메시지를 보내이 WebSocket의 출력을 닫을뿐입니다. 입력을 강제로 닫으려면 &lt;code&gt;abort&lt;/code&gt; 메서드를 호출합니다 . 다음은 닫기 메시지를 보낸 다음 타이머를 시작하는 응용 프로그램의 예입니다. 지정된 제한 시간 내에 데이터가 수신되지 않으면 타이머가 꺼지고 알람이 &lt;code&gt;WebSocket&lt;/code&gt; 을 중단합니다. .</target>
        </trans-unit>
        <trans-unit id="b372bf4225287956fe3cfd675126ff074ca47b28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setCharacterAttributes()&lt;/code&gt; method takes four arguments . The first and second arguments identify a region in the Document that is to be changed. The third argument specifies the new attributes (as an AttributeSet), and the fourth argument determines if the new attributes should be added to the existing attributes (a value of false) or if the character Element should replace its existing attributes with the new attributes (a value of true).</source>
          <target state="translated">&lt;code&gt;setCharacterAttributes()&lt;/code&gt; 메소드는 4 개 개의 인자를받습니다. 첫 번째 및 두 번째 인수는 변경할 문서의 영역을 식별합니다. 세 번째 인수는 새 속성 (AttributeSet으로)을 지정하고, 네 번째 인수는 새 속성을 기존 속성에 추가해야하는지 (false 값) 또는 문자 요소가 기존 속성을 새 속성 ( true 값).</target>
        </trans-unit>
        <trans-unit id="2b89c456d2b4bd25e583ec6cc1aa01d8496f3f6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setPaintMode&lt;/code&gt; method is implemented as a convenience method to set the default &lt;code&gt;Composite&lt;/code&gt;, equivalent to &lt;code&gt;setComposite(new AlphaComposite.SrcOver)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setPaintMode&lt;/code&gt; 의 방법은 기본 설정하기위한 편의 수단으로 구현되는 &lt;code&gt;Composite&lt;/code&gt; 등가, &lt;code&gt;setComposite(new AlphaComposite.SrcOver)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43b250cc63cb491b2b4915e37282c63d786eef72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setSize&lt;/code&gt; method should be prepared to be called a number of times (i.e. It may be called even if the size didn't change). The &lt;code&gt;setSize&lt;/code&gt; method is generally called to make sure the View layout is complete prior to trying to perform an operation on it that requires an up-to-date layout. A view's size should &lt;em&gt;always&lt;/em&gt; be set to a value within the minimum and maximum span specified by that view. Additionally, the view must always call the &lt;code&gt;preferenceChanged&lt;/code&gt; method on the parent if it has changed the values for the layout it would like, and expects the parent to honor. The parent View is not required to recognize a change until the &lt;code&gt;preferenceChanged&lt;/code&gt; has been sent. This allows parent View implementations to cache the child requirements if desired. The calling sequence looks something like the following:</source>
          <target state="translated">&lt;code&gt;setSize&lt;/code&gt; 방법은 여러 번 호출 할 수 있도록 준비해야한다 (사이즈가 변경되지 않는 경우에서도 호출 할 수 있습니다 즉). &lt;code&gt;setSize&lt;/code&gt; 방법은 일반적으로 확인보기 레이아웃 전에 최신의 레이아웃을 필요로하는 작업을 수행하려고 노력을 완료하기 위해 호출된다. 보기의 크기는 &lt;em&gt;항상&lt;/em&gt; 해당보기에서 지정한 최소 및 최대 범위 내의 값으로 설정 되어야 합니다. 또한보기는 원하는 레이아웃의 값을 변경하고 부모가 존중할 것으로 예상하는 경우 부모에서 항상 &lt;code&gt;preferenceChanged&lt;/code&gt; 메서드를 호출해야합니다 . parent View는 &lt;code&gt;preferenceChanged&lt;/code&gt; 까지 변경을 인식 할 필요가 없습니다.전송 된. 이를 통해 원하는 경우 상위 View 구현이 하위 요구 사항을 캐시 할 수 있습니다. 호출 시퀀스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="146eb04c811039b6ff998f453c63a8e8d4185f58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setValue(String)&lt;/code&gt;, &lt;code&gt;getValue()&lt;/code&gt; and &lt;code&gt;combine(Set&amp;lt;String&amp;gt;)&lt;/code&gt; methods are invoked when a setting value changes, which typically happens when a recording is started or stopped. The &lt;code&gt;combine(Set&amp;lt;String&amp;gt;)&lt;/code&gt; method is invoked to resolve what value to use when multiple recordings are running at the same time.</source>
          <target state="translated">&lt;code&gt;setValue(String)&lt;/code&gt; , &lt;code&gt;getValue()&lt;/code&gt; 과 &lt;code&gt;combine(Set&amp;lt;String&amp;gt;)&lt;/code&gt; 메소드가 호출 될 때 녹화를 시작 또는 중지 될 때 일반적으로 발생하는 설정 값 변경. (가) &lt;code&gt;combine(Set&amp;lt;String&amp;gt;)&lt;/code&gt; 다중 녹음을 동시에 실행하는 경우 방법은 어떤 값을 사용으로 해결하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="42f025b3d9979c63bfda933d9c9717fb99aa29ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setXORMode(Color xorcolor)&lt;/code&gt; method is implemented as a convenience method to set a special &lt;code&gt;Composite&lt;/code&gt; object that ignores the &lt;code&gt;Alpha&lt;/code&gt; components of source colors and sets the destination color to the value:</source>
          <target state="translated">&lt;code&gt;setXORMode(Color xorcolor)&lt;/code&gt; 방법은 특별한 설정하는 편리한 방법으로 구현 &lt;code&gt;Composite&lt;/code&gt; 무시 객체 &lt;code&gt;Alpha&lt;/code&gt; 소스 컬러 성분 값 및 목표 색을 설정 :</target>
        </trans-unit>
        <trans-unit id="e4d9578b126fe071444650921e8afdae2dde1b52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shape&lt;/code&gt; argument may have the following values:</source>
          <target state="translated">&lt;code&gt;shape&lt;/code&gt; 인수는 다음과 같은 값을 가질 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f788aeac802ff7904bf9412e16d01319cb050308" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sign&lt;/code&gt; method of &lt;code&gt;XMLSignature&lt;/code&gt;s produced by &lt;code&gt;XMLSignatureFactory&lt;/code&gt; MUST support &lt;code&gt;DOMSignContext&lt;/code&gt; types and the &lt;code&gt;validate&lt;/code&gt; method MUST support &lt;code&gt;DOMValidateContext&lt;/code&gt; types. This requirement also applies to the &lt;code&gt;validate&lt;/code&gt; method of &lt;code&gt;
 SignatureValue&lt;/code&gt; and the &lt;code&gt;validate&lt;/code&gt; method of &lt;code&gt;Reference&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;XMLSignature&lt;/code&gt; Factory에 의해 생성 된 &lt;code&gt;XMLSignatureFactory&lt;/code&gt; 의 &lt;code&gt;sign&lt;/code&gt; 메소드는 &lt;code&gt;DOMSignContext&lt;/code&gt; 유형을 지원해야 하며 &lt;code&gt;validate&lt;/code&gt; 메소드는 &lt;code&gt;DOMValidateContext&lt;/code&gt; 유형을 지원해야합니다 (MUST) . 이 요구 사항은 또한 적용 &lt;code&gt;validate&lt;/code&gt; 의 방법 &lt;code&gt; SignatureValue&lt;/code&gt; 를 하고 &lt;code&gt;validate&lt;/code&gt; 의 방법 &lt;code&gt;Reference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf825e34076ebaf2f0b03cf88441dbd2884319b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signature&lt;/code&gt; array parameter is internally copied, so that subsequent changes to the array referenced by &lt;code&gt;
 signature&lt;/code&gt; have no effect on this instance.</source>
          <target state="translated">The &lt;code&gt;signature&lt;/code&gt; array parameter is internally copied, so that subsequent changes to the array referenced by &lt;code&gt; signature&lt;/code&gt; have no effect on this instance.</target>
        </trans-unit>
        <trans-unit id="76ca7bc87a7a645eee5be869e5f2afee6e7546a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signature&lt;/code&gt; array parameter is internally copied, so that subsequent changes to the array referenced by &lt;code&gt;signature&lt;/code&gt; have no effect on this instance.</source>
          <target state="translated">&lt;code&gt;signature&lt;/code&gt; 배열 매개 변수는 내부적으로 참조되는 그 후의 배열의 변경 그래서, 복사 &lt;code&gt;signature&lt;/code&gt; 이 인스턴스에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ab62abd8dea24de7feab17efb96ab240af801b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt;, &lt;code&gt;isEmpty&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;iterator&lt;/code&gt;, and &lt;code&gt;listIterator&lt;/code&gt; operations run in constant time. The &lt;code&gt;add&lt;/code&gt; operation runs in</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; , &lt;code&gt;isEmpty&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;iterator&lt;/code&gt; 및 &lt;code&gt;listIterator&lt;/code&gt; 의의 일정한 시간에 실행 작업. &lt;code&gt;add&lt;/code&gt; 작업이 실행됩니다</target>
        </trans-unit>
        <trans-unit id="9a1118dd39358bc6d8e191accb546fe46ebdd2b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip&lt;/code&gt; method implementation of this class creates a byte array and then repeatedly reads into it until &lt;code&gt;n&lt;/code&gt; bytes have been read or the end of the stream has been reached. Subclasses are encouraged to provide a more efficient implementation of this method. For instance, the implementation may depend on the ability to seek.</source>
          <target state="translated">The &lt;code&gt;skip&lt;/code&gt; method implementation of this class creates a byte array and then repeatedly reads into it until &lt;code&gt;n&lt;/code&gt; bytes have been read or the end of the stream has been reached. Subclasses are encouraged to provide a more efficient implementation of this method. For instance, the implementation may depend on the ability to seek.</target>
        </trans-unit>
        <trans-unit id="a4a7eb3594e941fdb97e903210733646c272b12a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip&lt;/code&gt; method may, for a variety of reasons, end up skipping over some smaller number of bytes, possibly &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is negative, the method will try to skip backwards. In case the backing file does not support backward skip at its current position, an &lt;code&gt;IOException&lt;/code&gt; is thrown. The actual number of bytes skipped is returned. If it skips forwards, it returns a positive value. If it skips backwards, it returns a negative value.</source>
          <target state="translated">&lt;code&gt;skip&lt;/code&gt; 방법은 여러 가지 이유로,보다 적은 바이트 수 밖에 스킵 수 &lt;code&gt;0&lt;/code&gt; . 경우 &lt;code&gt;n&lt;/code&gt; 은 음, 방법은 뒤로 건너하려고합니다. 백업 파일이 현재 위치에서 뒤로 건너 뛰기를 지원하지 않는 경우 &lt;code&gt;IOException&lt;/code&gt; 이 발생합니다. 건너 뛴 실제 바이트 수가 반환됩니다. 앞으로 건너 뛰면 양수 값을 반환합니다. 뒤로 건너 뛰면 음수 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66c38c1c54f362c964143fb2033b1ddc5a7e0a28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip&lt;/code&gt; method of &lt;code&gt;LineNumberInputStream&lt;/code&gt; creates a byte array and then repeatedly reads into it until &lt;code&gt;n&lt;/code&gt; bytes have been read or the end of the stream has been reached.</source>
          <target state="translated">&lt;code&gt;LineNumberInputStream&lt;/code&gt; 의 &lt;code&gt;skip&lt;/code&gt; 메소드는 바이트 배열을 작성한 다음 &lt;code&gt;n&lt;/code&gt; 바이트를 읽거나 스트림의 끝에 도달 할 때까지 반복적으로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="6a923526e0376b2377270933dbe7190607b0ff31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip&lt;/code&gt; method of &lt;code&gt;PushbackInputStream&lt;/code&gt; first skips over the bytes in the pushback buffer, if any. It then calls the &lt;code&gt;skip&lt;/code&gt; method of the underlying input stream if more bytes need to be skipped. The actual number of bytes skipped is returned.</source>
          <target state="translated">&lt;code&gt;PushbackInputStream&lt;/code&gt; 의 &lt;code&gt;skip&lt;/code&gt; 메소드는 먼저 푸시 백 버퍼의 바이트를 건너 뜁니다 (있는 경우). 그런 다음 더 많은 바이트를 건너 뛸 필요가있는 경우 기본 입력 스트림 의 &lt;code&gt;skip&lt;/code&gt; 메소드 를 호출합니다 . 건너 뛴 실제 바이트 수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c16533536dab6e2f9b65c6a5002fc87433ad4e31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip&lt;/code&gt; method of this class creates a byte array and then repeatedly reads into it until &lt;code&gt;n&lt;/code&gt; bytes have been read or the end of the stream has been reached. Subclasses are encouraged to provide a more efficient implementation of this method. For instance, the implementation may depend on the ability to seek.</source>
          <target state="translated">이 클래스 의 &lt;code&gt;skip&lt;/code&gt; 메소드는 바이트 배열을 작성한 다음 &lt;code&gt;n&lt;/code&gt; 바이트를 읽거나 스트림의 끝에 도달 할 때까지 반복적으로 읽습니다 . 서브 클래스는이 메소드를보다 효율적으로 구현할 것을 권장합니다. 예를 들어, 구현은 탐색 능력에 의존 할 수있다.</target>
        </trans-unit>
        <trans-unit id="48bb13788e4dffd1bf5c784a19fc6b8edec85d28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; argument and &lt;code&gt;dest&lt;/code&gt; argument refer to arrays whose component types are different primitive types.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 인수 및 &lt;code&gt;dest&lt;/code&gt; 인수는 그 구성 요소 유형의 다른 원시적 형이다 배열을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ded185c55f988e1ab8aa4ba594d8425c8a39394" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; argument refers to an array with a primitive component type and the &lt;code&gt;dest&lt;/code&gt; argument refers to an array with a reference component type.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 인자는 프리미티브 컴포넌트 유형의 배열을 의미하고, &lt;code&gt;dest&lt;/code&gt; 인수는 기준 성분 유형 배열을 말한다.</target>
        </trans-unit>
        <trans-unit id="9b64842c9ed7d557d1d18f19836d86fd1cadc9b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; argument refers to an array with a reference component type and the &lt;code&gt;dest&lt;/code&gt; argument refers to an array with a primitive component type.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 인수는 기준 부품 형태로 배열를 참조하여 &lt;code&gt;dest&lt;/code&gt; 인자는 프리미티브 컴포넌트 유형의 배열을 말한다.</target>
        </trans-unit>
        <trans-unit id="17390f5ec2c7023bf41b502643c3390be1470837" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src&lt;/code&gt; argument refers to an object that is not an array.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 인수 배열이 아닌 오브젝트를 지칭한다.</target>
        </trans-unit>
        <trans-unit id="32cf5d4487a70ff5b3296fb66460f51ac7c6a160" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;srcPos&lt;/code&gt; argument is negative.</source>
          <target state="translated">&lt;code&gt;srcPos&lt;/code&gt; 인수는 부정적이다.</target>
        </trans-unit>
        <trans-unit id="be02728a3743350708b8b357f2bfb78e56f08541" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; handles must not be &lt;code&gt;null&lt;/code&gt;, and must both return the common type &lt;code&gt;int&lt;/code&gt;, referred to here as &lt;code&gt;I&lt;/code&gt; in parameter type lists.</source>
          <target state="translated">The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; handles must not be &lt;code&gt;null&lt;/code&gt; , and must both return the common type &lt;code&gt;int&lt;/code&gt; , referred to here as &lt;code&gt;I&lt;/code&gt; in parameter type lists.</target>
        </trans-unit>
        <trans-unit id="6dc25c0527566429af8136756050546b7203d021" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; parameters can be &lt;code&gt;null&lt;/code&gt; to indicate that the range doesn't have an upper or lower bound. If &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;calendarField&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, or if both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are specified and &lt;code&gt;minimum &amp;gt; maximum&lt;/code&gt; then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. Similarly if &lt;code&gt;(minimum &amp;lt;= value &amp;lt;= maximum)&lt;/code&gt; is false, an IllegalArgumentException is thrown.</source>
          <target state="translated">The &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; parameters can be &lt;code&gt;null&lt;/code&gt; to indicate that the range doesn't have an upper or lower bound. If &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;calendarField&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; , or if both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are specified and &lt;code&gt;minimum &amp;gt; maximum&lt;/code&gt; then an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown. Similarly if &lt;code&gt;(minimum &amp;lt;= value &amp;lt;= maximum)&lt;/code&gt; is false, an IllegalArgumentException is thrown.</target>
        </trans-unit>
        <trans-unit id="3c17d5d7d0e68ab4ec50eef0d86ee3e15e17df97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;startPipeline&lt;/code&gt; method performs the same checks on each ProcessBuilder as does the &lt;a href=&quot;#start()&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method. Each new process invokes the command and arguments given by the respective process builder's &lt;a href=&quot;#command()&quot;&gt;&lt;code&gt;command()&lt;/code&gt;&lt;/a&gt;, in a working directory as given by its &lt;a href=&quot;#directory()&quot;&gt;&lt;code&gt;directory()&lt;/code&gt;&lt;/a&gt;, with a process environment as given by its &lt;a href=&quot;#environment()&quot;&gt;&lt;code&gt;environment()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;startPipeline&lt;/code&gt; 의 마찬가지로 각 ProcessBuilder를 수행에있어서 동일한 검사를 &lt;a href=&quot;#start()&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 방법. 각각의 새 프로세스는 해당 &lt;a href=&quot;#environment()&quot;&gt; &lt;code&gt;environment()&lt;/code&gt; &lt;/a&gt; 의해 제공된 프로세스 환경과 함께 해당 &lt;a href=&quot;#directory()&quot;&gt; &lt;code&gt;directory()&lt;/code&gt; &lt;/a&gt; 의해 제공된 작업 디렉토리에서 각 프로세스 빌더의 &lt;a href=&quot;#command()&quot;&gt; &lt;code&gt;command()&lt;/code&gt; &lt;/a&gt; 의해 제공된 명령 및 인수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e4cc6c311e7eebc97573c7745efa0c1accd23d43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;startPipeline&lt;/code&gt; method performs the same checks on each ProcessBuilder as does the &lt;a href=&quot;#start()&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method. The new process will invoke the command and arguments given by &lt;a href=&quot;#command()&quot;&gt;&lt;code&gt;command()&lt;/code&gt;&lt;/a&gt;, in a working directory as given by &lt;a href=&quot;#directory()&quot;&gt;&lt;code&gt;directory()&lt;/code&gt;&lt;/a&gt;, with a process environment as given by &lt;a href=&quot;#environment()&quot;&gt;&lt;code&gt;environment()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The &lt;code&gt;startPipeline&lt;/code&gt; method performs the same checks on each ProcessBuilder as does the &lt;a href=&quot;#start()&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; method. The new process will invoke the command and arguments given by &lt;a href=&quot;#command()&quot;&gt; &lt;code&gt;command()&lt;/code&gt; &lt;/a&gt;, in a working directory as given by &lt;a href=&quot;#directory()&quot;&gt; &lt;code&gt;directory()&lt;/code&gt; &lt;/a&gt;, with a process environment as given by &lt;a href=&quot;#environment()&quot;&gt; &lt;code&gt;environment()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="076b65d1dcb2536b5b9253389218e30908409663" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stateChange&lt;/code&gt; of any &lt;code&gt;ItemEvent&lt;/code&gt; instance takes one of the following values:</source>
          <target state="translated">The &lt;code&gt;stateChange&lt;/code&gt; of any &lt;code&gt;ItemEvent&lt;/code&gt; instance takes one of the following values:</target>
        </trans-unit>
        <trans-unit id="4d7e3c187b7502624a8ff731ccc49ed33e5b1f80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;statusCode&lt;/code&gt; is an integer from the range &lt;code&gt;1000 &amp;lt;= code &amp;lt;= 4999&lt;/code&gt;. Status codes &lt;code&gt;1002&lt;/code&gt;, &lt;code&gt;1003&lt;/code&gt;, &lt;code&gt;1006&lt;/code&gt;, &lt;code&gt;1007&lt;/code&gt;, &lt;code&gt;1009&lt;/code&gt;, &lt;code&gt;1010&lt;/code&gt;, &lt;code&gt;1012&lt;/code&gt;, &lt;code&gt;1013&lt;/code&gt; and &lt;code&gt;1015&lt;/code&gt; are illegal. Behaviour in respect to other status codes is implementation-specific. A legal &lt;code&gt;reason&lt;/code&gt; is a string that has a UTF-8 representation not longer than &lt;code&gt;123&lt;/code&gt; bytes.</source>
          <target state="translated">The &lt;code&gt;statusCode&lt;/code&gt; is an integer from the range &lt;code&gt;1000 &amp;lt;= code &amp;lt;= 4999&lt;/code&gt; . Status codes &lt;code&gt;1002&lt;/code&gt; , &lt;code&gt;1003&lt;/code&gt; , &lt;code&gt;1006&lt;/code&gt; , &lt;code&gt;1007&lt;/code&gt; , &lt;code&gt;1009&lt;/code&gt; , &lt;code&gt;1010&lt;/code&gt; , &lt;code&gt;1012&lt;/code&gt; , &lt;code&gt;1013&lt;/code&gt; and &lt;code&gt;1015&lt;/code&gt; are illegal. Behaviour in respect to other status codes is implementation-specific. A legal &lt;code&gt;reason&lt;/code&gt; is a string that has a UTF-8 representation not longer than &lt;code&gt;123&lt;/code&gt; bytes.</target>
        </trans-unit>
        <trans-unit id="96a37830010cc84066474823aaa8925f3e262fd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stopPropagation&lt;/code&gt; method is used prevent further propagation of an event during event flow.</source>
          <target state="translated">The &lt;code&gt;stopPropagation&lt;/code&gt; method is used prevent further propagation of an event during event flow.</target>
        </trans-unit>
        <trans-unit id="87a32d228a0f8798ef1bced948af76af2274fc0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stopPropagation&lt;/code&gt; method is used prevent further propagation of an event during event flow. If this method is called by any &lt;code&gt;EventListener&lt;/code&gt; the event will cease propagating through the tree. The event will complete dispatch to all listeners on the current &lt;code&gt;EventTarget&lt;/code&gt; before event flow stops. This method may be used during any stage of event flow.</source>
          <target state="translated">The &lt;code&gt;stopPropagation&lt;/code&gt; method is used prevent further propagation of an event during event flow. If this method is called by any &lt;code&gt;EventListener&lt;/code&gt; the event will cease propagating through the tree. The event will complete dispatch to all listeners on the current &lt;code&gt;EventTarget&lt;/code&gt; before event flow stops. This method may be used during any stage of event flow.</target>
        </trans-unit>
        <trans-unit id="345b6d87d178ad048ca717372d6308e35699c398" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stream&lt;/code&gt; walks the file tree as elements are consumed. The &lt;code&gt;Stream&lt;/code&gt; returned is guaranteed to have at least one element, the starting file itself. For each file visited, the stream attempts to read its &lt;a href=&quot;attribute/basicfileattributes&quot;&gt;&lt;code&gt;BasicFileAttributes&lt;/code&gt;&lt;/a&gt;. If the file is a directory and can be opened successfully, entries in the directory, and their &lt;em&gt;descendants&lt;/em&gt; will follow the directory in the stream as they are encountered. When all entries have been visited, then the directory is closed. The file tree walk then continues at the next &lt;em&gt;sibling&lt;/em&gt; of the directory.</source>
          <target state="translated">&lt;code&gt;stream&lt;/code&gt; 요소가 소비의 파일 트리를 안내합니다. 리턴 된 &lt;code&gt;Stream&lt;/code&gt; 은 적어도 하나의 요소, 시작 파일 자체를 갖도록 보장됩니다. 방문한 각 파일에 대해 스트림은 &lt;a href=&quot;attribute/basicfileattributes&quot;&gt; &lt;code&gt;BasicFileAttributes&lt;/code&gt; &lt;/a&gt; 를 읽으려고 시도합니다 . 파일이 디렉토리이고 성공적으로 열 수있는 경우 디렉토리의 항목 및 해당 &lt;em&gt;하위&lt;/em&gt; 항목 은 스트림에서 디렉토리를 따라갑니다. 모든 항목을 방문하면 디렉토리가 닫힙니다. 그런 다음 파일 트리 워크는 다음 디렉토리의 &lt;em&gt;형제&lt;/em&gt; 에서 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="b3710d2b5eccac183494c98736ff55e0daad76d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; factory methods provide clocks based on the best available system clock This may use &lt;a href=&quot;../lang/system#currentTimeMillis()&quot;&gt;&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;&lt;/a&gt;, or a higher resolution clock if one is available.</source>
          <target state="translated">The &lt;code&gt;system&lt;/code&gt; factory methods provide clocks based on the best available system clock This may use &lt;a href=&quot;../lang/system#currentTimeMillis()&quot;&gt; &lt;code&gt;System.currentTimeMillis()&lt;/code&gt; &lt;/a&gt;, or a higher resolution clock if one is available.</target>
        </trans-unit>
        <trans-unit id="bbed603ba13286eef01f00c49ed0143e560232fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; factory methods provide clocks based on the best available system clock This may use &lt;a href=&quot;../lang/system#currentTimeMillis--&quot;&gt;&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;&lt;/a&gt;, or a higher resolution clock if one is available.</source>
          <target state="translated">&lt;code&gt;system&lt;/code&gt; 팩토리 메소드는이 사용할 수 있습니다 가능한 최상의 시스템 클럭을 기준으로 시계 제공 &lt;a href=&quot;../lang/system#currentTimeMillis--&quot;&gt; &lt;code&gt;System.currentTimeMillis()&lt;/code&gt; &lt;/a&gt; 사용 가능한 경우, 또는 더 높은 해상도 시계를.</target>
        </trans-unit>
        <trans-unit id="705416f1898f90c6d7101837ec2872b8de0927e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;systemId&lt;/code&gt; will be used literally, with no attempt to be made absolute to the &lt;code&gt;baseUri&lt;/code&gt;. The &lt;code&gt;baseUri&lt;/code&gt; and &lt;code&gt;namespace&lt;/code&gt; are not used in the search for a match in a catalog. However, a relative &lt;code&gt;systemId&lt;/code&gt; in an xml source may have been made absolute by the parser with the &lt;code&gt;baseURI&lt;/code&gt;, thus making it unable to find a &lt;code&gt;system&lt;/code&gt; entry. In such a case, a &lt;code&gt;systemSuffix&lt;/code&gt; entry is recommended over a &lt;code&gt;system&lt;/code&gt; entry.</source>
          <target state="translated">The &lt;code&gt;systemId&lt;/code&gt; will be used literally, with no attempt to be made absolute to the &lt;code&gt;baseUri&lt;/code&gt; . The &lt;code&gt;baseUri&lt;/code&gt; and &lt;code&gt;namespace&lt;/code&gt; are not used in the search for a match in a catalog. However, a relative &lt;code&gt;systemId&lt;/code&gt; in an xml source may have been made absolute by the parser with the &lt;code&gt;baseURI&lt;/code&gt; , thus making it unable to find a &lt;code&gt;system&lt;/code&gt; entry. In such a case, a &lt;code&gt;systemSuffix&lt;/code&gt; entry is recommended over a &lt;code&gt;system&lt;/code&gt; entry.</target>
        </trans-unit>
        <trans-unit id="5fa8fe0340ab2e43b8e4f2fccf1346d93701ab46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;systemId&lt;/code&gt; will be used literally, with no attempt to be made absolute to the &lt;code&gt;baseUri&lt;/code&gt;. The &lt;code&gt;baseUri&lt;/code&gt;, &lt;code&gt;namespaceUri&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; are not used in the search for a match in a catalog. However, a relative &lt;code&gt;systemId&lt;/code&gt; in a source may have been made absolute by the parser with the &lt;code&gt;baseURI&lt;/code&gt;, thus making it unable to find a &lt;code&gt;system&lt;/code&gt; entry. In such a case, a &lt;code&gt;systemSuffix&lt;/code&gt; entry is recommended over a &lt;code&gt;system&lt;/code&gt; entry.</source>
          <target state="translated">The &lt;code&gt;systemId&lt;/code&gt; will be used literally, with no attempt to be made absolute to the &lt;code&gt;baseUri&lt;/code&gt; . The &lt;code&gt;baseUri&lt;/code&gt; , &lt;code&gt;namespaceUri&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; are not used in the search for a match in a catalog. However, a relative &lt;code&gt;systemId&lt;/code&gt; in a source may have been made absolute by the parser with the &lt;code&gt;baseURI&lt;/code&gt; , thus making it unable to find a &lt;code&gt;system&lt;/code&gt; entry. In such a case, a &lt;code&gt;systemSuffix&lt;/code&gt; entry is recommended over a &lt;code&gt;system&lt;/code&gt; entry.</target>
        </trans-unit>
        <trans-unit id="102c04e139e85c06b332c1cf89cc171685c4335a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;cleanup&lt;/code&gt; handles must have the same corresponding argument and return types, except that the &lt;code&gt;cleanup&lt;/code&gt; handle may omit trailing arguments. Also, the &lt;code&gt;cleanup&lt;/code&gt; handle must have one or two extra leading parameters:</source>
          <target state="translated">The &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;cleanup&lt;/code&gt; handles must have the same corresponding argument and return types, except that the &lt;code&gt;cleanup&lt;/code&gt; handle may omit trailing arguments. Also, the &lt;code&gt;cleanup&lt;/code&gt; handle must have one or two extra leading parameters:</target>
        </trans-unit>
        <trans-unit id="fc9c79ee1df025d55ac0b05752be64291c34d35f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; and the &lt;code&gt;methodName&lt;/code&gt; values should not be &lt;code&gt;null&lt;/code&gt;. Otherwise an attempt to execute this &lt;code&gt;Expression&lt;/code&gt; will result in a &lt;code&gt;NullPointerException&lt;/code&gt;. If the &lt;code&gt;arguments&lt;/code&gt; value is &lt;code&gt;null&lt;/code&gt;, an empty array is used as the value of the &lt;code&gt;arguments&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 과 &lt;code&gt;methodName&lt;/code&gt; 로의 값이어야한다 &lt;code&gt;null&lt;/code&gt; . 그렇지 않으면이 &lt;code&gt;Expression&lt;/code&gt; 을 실행하려고 하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생 합니다. 경우] &lt;code&gt;arguments&lt;/code&gt; 값은 &lt;code&gt;null&lt;/code&gt; 빈 배열의 값으로서 사용되는 &lt;code&gt;arguments&lt;/code&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="67df39f98209ce29324f6940292995bb97c5d095" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; parameter is the target of the link. It may be an &lt;a href=&quot;path#isAbsolute()&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; or relative path and may not exist. When the target is a relative path then file system operations on the resulting link are relative to the path of the link.</source>
          <target state="translated">The &lt;code&gt;target&lt;/code&gt; parameter is the target of the link. It may be an &lt;a href=&quot;path#isAbsolute()&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; or relative path and may not exist. When the target is a relative path then file system operations on the resulting link are relative to the path of the link.</target>
        </trans-unit>
        <trans-unit id="643140ef281b03db8ff1987c73ac0c49fd06dd1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; parameter is the target of the link. It may be an &lt;a href=&quot;path#isAbsolute--&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; or relative path and may not exist. When the target is a relative path then file system operations on the resulting link are relative to the path of the link.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 파라미터는 링크의 대상이다. &lt;a href=&quot;path#isAbsolute--&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 또는 상대 경로 일 수 있으며 존재하지 않을 수 있습니다. 대상이 상대 경로 인 경우 결과 링크에서 파일 시스템 조작은 링크 경로에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="0009c69a4dc15a49dcbf1a0c8eae01039c7c4a96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thumbnails&lt;/code&gt; argument must either be &lt;code&gt;null&lt;/code&gt; or contain only &lt;code&gt;BufferedImage&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;thumbnails&lt;/code&gt; 인수는 하나 여야합니다 &lt;code&gt;null&lt;/code&gt; 또는에만 포함 &lt;code&gt;BufferedImage&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="7f203db2af4b065dabcc3805554e22404c4433c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeStamp&lt;/code&gt; of the notification is a time value (consistent with &lt;a href=&quot;../../../../java.base/java/lang/system#currentTimeMillis()&quot;&gt;&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;&lt;/a&gt;) indicating when the notification was constructed.</source>
          <target state="translated">The &lt;code&gt;timeStamp&lt;/code&gt; of the notification is a time value (consistent with &lt;a href=&quot;../../../../java.base/java/lang/system#currentTimeMillis()&quot;&gt; &lt;code&gt;System.currentTimeMillis()&lt;/code&gt; &lt;/a&gt;) indicating when the notification was constructed.</target>
        </trans-unit>
        <trans-unit id="a0e9ab517d625c7c2deaf59529ad7e0219c013fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeStamp&lt;/code&gt; of the notification is a time value (consistent with &lt;a href=&quot;../../../java/lang/system#currentTimeMillis--&quot;&gt;&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;&lt;/a&gt;) indicating when the notification was constructed.</source>
          <target state="translated">알림 의 &lt;code&gt;timeStamp&lt;/code&gt; 는 알림이 생성 된시기를 나타내는 시간 값 ( &lt;a href=&quot;../../../java/lang/system#currentTimeMillis--&quot;&gt; &lt;code&gt;System.currentTimeMillis()&lt;/code&gt; &lt;/a&gt; 일치 )입니다.</target>
        </trans-unit>
        <trans-unit id="b2dc1977f789016cfbe08995493b9abe10ad9cbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toString&lt;/code&gt; method for class &lt;code&gt;Object&lt;/code&gt; returns a string consisting of the name of the class of which the object is an instance, the at-sign character `&lt;code&gt;@&lt;/code&gt;', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 클래스 의 &lt;code&gt;toString&lt;/code&gt; 메소드 는 오브젝트가 인스턴스 인 클래스의 이름, at 기호 문자` &lt;code&gt;@&lt;/code&gt; '및 오브젝트의 해시 코드의 부호없는 16 진 표현으로 구성된 문자열을 리턴 합니다. 즉,이 메소드는 다음 값과 동일한 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f35e165aad5f7865197b005be9bb45266399d993" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;toString&lt;/code&gt; method may return two different values on two &lt;code&gt;StackTraceElement&lt;/code&gt; instances that are &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;equal&lt;/a&gt;, for example one created via the constructor, and one obtained from &lt;a href=&quot;throwable&quot;&gt;&lt;code&gt;Throwable&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stackwalker.stackframe&quot;&gt;&lt;code&gt;StackWalker.StackFrame&lt;/code&gt;&lt;/a&gt;, where an implementation may choose to omit some element in the returned string.</source>
          <target state="translated">The &lt;code&gt;toString&lt;/code&gt; method may return two different values on two &lt;code&gt;StackTraceElement&lt;/code&gt; instances that are &lt;a href=&quot;#equals(java.lang.Object)&quot;&gt;equal&lt;/a&gt;, for example one created via the constructor, and one obtained from &lt;a href=&quot;throwable&quot;&gt; &lt;code&gt;Throwable&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;stackwalker.stackframe&quot;&gt; &lt;code&gt;StackWalker.StackFrame&lt;/code&gt; &lt;/a&gt;, where an implementation may choose to omit some element in the returned string.</target>
        </trans-unit>
        <trans-unit id="c0a1342d2a95a488e60cf2e7575f74b70a1b15a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transform&lt;/code&gt; method of &lt;code&gt;Transform&lt;/code&gt; MUST support &lt;code&gt;DOMCryptoContext&lt;/code&gt; context parameter types.</source>
          <target state="translated">&lt;code&gt;Transform&lt;/code&gt; 의 &lt;code&gt;transform&lt;/code&gt; 메소드는 &lt;code&gt;DOMCryptoContext&lt;/code&gt; 컨텍스트 매개 변수 유형을 지원해야 합니다.</target>
        </trans-unit>
        <trans-unit id="bc716b32be2e2ea2d617e608d9ff17039ae30d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument should be a valid value for the byte that follows the status byte in the &lt;code&gt;MetaMessage&lt;/code&gt;. The &lt;code&gt;data&lt;/code&gt; argument should contain all the subsequent bytes of the &lt;code&gt;MetaMessage&lt;/code&gt;. In other words, the byte that specifies the type of &lt;code&gt;MetaMessage&lt;/code&gt; is not considered a data byte.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 인자는의 상태 바이트 다음 바이트의 유효 값이 &lt;code&gt;MetaMessage&lt;/code&gt; 의이 . &lt;code&gt;data&lt;/code&gt; 인수는 모든 후속 바이트를 포함해야 &lt;code&gt;MetaMessage&lt;/code&gt; 의를 . 즉, &lt;code&gt;MetaMessage&lt;/code&gt; 유형을 지정하는 바이트는 데이터 바이트로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06b9218c7159f9ade16823be04d6c173149333fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; of any &lt;code&gt;AdjustmentEvent&lt;/code&gt; instance takes one of the following values:</source>
          <target state="translated">The &lt;code&gt;type&lt;/code&gt; of any &lt;code&gt;AdjustmentEvent&lt;/code&gt; instance takes one of the following values:</target>
        </trans-unit>
        <trans-unit id="9d6e7d46137f25ad7f8964128a6f000618a91b9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; parameter indicates the relation between the two components. If the two components will be contained in the same parent and are showing similar logically related items, use &lt;code&gt;RELATED&lt;/code&gt;. If the two components will be contained in the same parent but show logically unrelated items use &lt;code&gt;UNRELATED&lt;/code&gt;. Some look and feels may not distinguish between the &lt;code&gt;RELATED&lt;/code&gt; and &lt;code&gt;UNRELATED&lt;/code&gt; types.</source>
          <target state="translated">The &lt;code&gt;type&lt;/code&gt; parameter indicates the relation between the two components. If the two components will be contained in the same parent and are showing similar logically related items, use &lt;code&gt;RELATED&lt;/code&gt; . If the two components will be contained in the same parent but show logically unrelated items use &lt;code&gt;UNRELATED&lt;/code&gt; . Some look and feels may not distinguish between the &lt;code&gt;RELATED&lt;/code&gt; and &lt;code&gt;UNRELATED&lt;/code&gt; types.</target>
        </trans-unit>
        <trans-unit id="fc25f1a4f79c0d9cb38f65494514c69d349c3f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; parameter is the type of the attributes required and this method returns an instance of that type if supported. All implementations support a basic set of file attributes and so invoking this method with a &lt;code&gt;type&lt;/code&gt; parameter of &lt;code&gt;
 BasicFileAttributes.class&lt;/code&gt; will not throw &lt;code&gt;
 UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;type&lt;/code&gt; parameter is the type of the attributes required and this method returns an instance of that type if supported. All implementations support a basic set of file attributes and so invoking this method with a &lt;code&gt;type&lt;/code&gt; parameter of &lt;code&gt; BasicFileAttributes.class&lt;/code&gt; will not throw &lt;code&gt; UnsupportedOperationException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="714e35a3944791dcc0a21aa2cfb1cc1a672a4844" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; parameter is the type of the attributes required and this method returns an instance of that type if supported. All implementations support a basic set of file attributes and so invoking this method with a &lt;code&gt;type&lt;/code&gt; parameter of &lt;code&gt;BasicFileAttributes.class&lt;/code&gt; will not throw &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 매개 변수는 필수 속성의 유형 및 지원하는 경우이 방법은 해당 유형의 인스턴스를 반환합니다. 모든 구현은 기본 파일 속성 세트를 지원하므로 &lt;code&gt;BasicFileAttributes.class&lt;/code&gt; &lt;code&gt;type&lt;/code&gt; 매개 변수 로이 메소드를 호출하면 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f1056213ec4dbb35ecbc5b5160831677aa11a47e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; parameter is typically a class, but it may be any type, such as an interface, a primitive type (like &lt;code&gt;int.class&lt;/code&gt;), or &lt;code&gt;void.class&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 파라미터는 일반적으로 클래스이지만, 이러한 인터페이스 (같은 원시 형 등 임의의 타입 일 수있다 &lt;code&gt;int.class&lt;/code&gt; 를 ) 또는 &lt;code&gt;void.class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d0f557c7ffa69e938b51901e39f9567f456bb67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeName&lt;/code&gt; here is determined by the &lt;a href=&quot;#type-names&quot;&gt; type name rules&lt;/a&gt; detailed below.</source>
          <target state="translated">여기서 &lt;code&gt;typeName&lt;/code&gt; 은 아래에 자세히 설명 된 &lt;a href=&quot;#type-names&quot;&gt;유형 이름 규칙&lt;/a&gt; 에 따라 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b34f44d7ea255df3fe2a501bc7503f396e8bcc57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uncaughtException&lt;/code&gt; method of &lt;code&gt;ThreadGroup&lt;/code&gt; does the following:</source>
          <target state="translated">&lt;code&gt;ThreadGroup&lt;/code&gt; 의 &lt;code&gt;uncaughtException&lt;/code&gt; 메소드 는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="284484383fbc17bd10f3ef3060ba77933b35645d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;underlinedIndex&lt;/code&gt; parameter points to a char value (Unicode code unit) in the given string. If the char value specified at the underlined index is in the high-surrogate range and the char value at the following index is in the low-surrogate range then the supplementary character corresponding to this surrogate pair is underlined.</source>
          <target state="translated">The &lt;code&gt;underlinedIndex&lt;/code&gt; parameter points to a char value (Unicode code unit) in the given string. If the char value specified at the underlined index is in the high-surrogate range and the char value at the following index is in the low-surrogate range then the supplementary character corresponding to this surrogate pair is underlined.</target>
        </trans-unit>
        <trans-unit id="8a305919fe389125db79560ea71e37822fe9f961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unmarshalKeyInfo&lt;/code&gt; method of &lt;code&gt;KeyInfoFactory&lt;/code&gt; MUST support &lt;code&gt;DOMStructure&lt;/code&gt; types. If the type is &lt;code&gt;DOMStructure&lt;/code&gt;, it SHOULD contain an &lt;code&gt;Element&lt;/code&gt; of type &lt;code&gt;KeyInfo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;KeyInfoFactory&lt;/code&gt; 의 &lt;code&gt;unmarshalKeyInfo&lt;/code&gt; 메소드는 &lt;code&gt;DOMStructure&lt;/code&gt; 유형을 지원해야 합니다. 유형이 &lt;code&gt;DOMStructure&lt;/code&gt; 인 경우 &lt;code&gt;KeyInfo&lt;/code&gt; 유형 의 &lt;code&gt;Element&lt;/code&gt; 를 포함해야합니다 (SHOULD) .</target>
        </trans-unit>
        <trans-unit id="64d95f34639981a626eae38c178805b9f2a259aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unmarshalXMLSignature&lt;/code&gt; method of &lt;code&gt;XMLSignatureFactory&lt;/code&gt; MUST support &lt;code&gt;DOMStructure&lt;/code&gt; types. If the type is &lt;code&gt;DOMStructure&lt;/code&gt;, it SHOULD contain an &lt;code&gt;Element&lt;/code&gt; of type &lt;code&gt;Signature&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;XMLSignatureFactory&lt;/code&gt; 의 &lt;code&gt;unmarshalXMLSignature&lt;/code&gt; 메소드는 &lt;code&gt;DOMStructure&lt;/code&gt; 유형을 지원해야 합니다. 유형이 &lt;code&gt;DOMStructure&lt;/code&gt; 인 경우 &lt;code&gt;Signature&lt;/code&gt; 유형 의 &lt;code&gt;Element&lt;/code&gt; 를 포함해야합니다 (SHOULD) .</target>
        </trans-unit>
        <trans-unit id="6fad801c53ac062a66adda45916aec072ec30d47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unmarshalXMLSignature&lt;/code&gt; method of &lt;code&gt;XMLSignatureFactory&lt;/code&gt; MUST support &lt;code&gt;DOMValidateContext&lt;/code&gt; types. If the type is &lt;code&gt;DOMValidateContext&lt;/code&gt;, it SHOULD contain an &lt;code&gt;Element&lt;/code&gt; of type Signature. Additionally, the &lt;code&gt;unmarshalXMLSignature&lt;/code&gt; method MAY populate the Id/Element mappings of the passed-in &lt;code&gt;DOMValidateContext&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;XMLSignatureFactory&lt;/code&gt; 의 &lt;code&gt;unmarshalXMLSignature&lt;/code&gt; 메소드는 &lt;code&gt;DOMValidateContext&lt;/code&gt; 유형을 지원해야 합니다. 유형이 &lt;code&gt;DOMValidateContext&lt;/code&gt; 이면 서명 유형 의 &lt;code&gt;Element&lt;/code&gt; 를 포함해야합니다 (SHOULD) . 또한 &lt;code&gt;unmarshalXMLSignature&lt;/code&gt; 메서드는 전달 된 &lt;code&gt;DOMValidateContext&lt;/code&gt; 의 Id / Element 매핑을 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4450253c95c412d34ca14474c433b55151989bf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt; calls this component's &lt;code&gt;paint&lt;/code&gt; method to redraw this component. This method is commonly overridden by subclasses which need to do additional work in response to a call to &lt;code&gt;repaint&lt;/code&gt;. Subclasses of Component that override this method should either call &lt;code&gt;super.update(g)&lt;/code&gt;, or call &lt;code&gt;paint(g)&lt;/code&gt; directly from their &lt;code&gt;update&lt;/code&gt; method.</source>
          <target state="translated">The &lt;code&gt;update&lt;/code&gt; method of &lt;code&gt;Component&lt;/code&gt; calls this component's &lt;code&gt;paint&lt;/code&gt; method to redraw this component. This method is commonly overridden by subclasses which need to do additional work in response to a call to &lt;code&gt;repaint&lt;/code&gt; . Subclasses of Component that override this method should either call &lt;code&gt;super.update(g)&lt;/code&gt; , or call &lt;code&gt;paint(g)&lt;/code&gt; directly from their &lt;code&gt;update&lt;/code&gt; method.</target>
        </trans-unit>
        <trans-unit id="ba8b125bbe0fb10254e8b4e3a983a07e8dccd3bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;uri&lt;/code&gt; parameter is an absolute, hierarchical URI, with a scheme equal (without regard to case) to the scheme supported by this provider. The exact form of the URI is highly provider dependent. The &lt;code&gt;env&lt;/code&gt; parameter is a map of provider specific properties to configure the file system.</source>
          <target state="translated">&lt;code&gt;uri&lt;/code&gt; 파라미터는이 제공자가 지원하는 방식으로 (경우에 관계없이)와 동일한 방식으로, 절대 계층 URI이다. URI의 정확한 형식은 공급자에 따라 크게 다릅니다. &lt;code&gt;env&lt;/code&gt; 매개 변수는 파일 시스템을 구성하는 제공자 특정 속성의 맵입니다.</target>
        </trans-unit>
        <trans-unit id="8d5265eccd53a8174604390135889708c5fc5e2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useOrdering&lt;/code&gt; argument controls the ordering of the results using the same rules as &lt;code&gt;getServiceProviders(Class, boolean)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;useOrdering&lt;/code&gt; 인수 컨트롤과 같은 규칙을 사용하여 결과의 순서 &lt;code&gt;getServiceProviders(Class, boolean)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56c69f9bf13711770382aef06023e97ae68a4935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; argument is the value that the method is to return. If the return type of the method is void, then value must be a &lt;a href=&quot;voidvalue&quot;&gt;&lt;code&gt;VoidValue&lt;/code&gt;&lt;/a&gt;. Object values must be assignment compatible with the method return type (This implies that the method return type must be loaded through the enclosing class's class loader). Primitive values must be either assignment compatible with the method return type or must be convertible to the variable type without loss of information. See JLS section 5.2 for more information on assignment compatibility.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 인수는 메서드가 반환하는 것입니다 값입니다. 메서드의 반환 유형이 void이면 값은 &lt;a href=&quot;voidvalue&quot;&gt; &lt;code&gt;VoidValue&lt;/code&gt; &lt;/a&gt; 여야합니다 . 객체 값은 메서드 반환 유형과 호환되는 할당이어야합니다 (이는 메서드 반환 유형이 둘러싸는 클래스의 클래스 로더를 통해로드되어야 함을 의미 함). 기본 값은 메서드 반환 유형과 호환되는 할당이거나 정보 손실없이 변수 유형으로 변환 할 수 있어야합니다. 할당 호환성에 대한 자세한 내용은 JLS 섹션 5.2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cf3c577a872e1c1751d1a92167097db6476c0ae8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method with a &lt;code&gt;key&lt;/code&gt; that is equal to the original &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 발신하여 검색 할 수있는 &lt;code&gt;get&lt;/code&gt; A의 방법 &lt;code&gt;key&lt;/code&gt; 일본어 같다 &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6dc1003235f78ae44b563cd9c64b625dec84264" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; field specifies the current value of the property, based on a combination of the information supplied to the method &lt;code&gt;getPropertyInfo&lt;/code&gt;, the Java environment, and the driver-supplied default values.</source>
          <target state="translated">The &lt;code&gt;value&lt;/code&gt; field specifies the current value of the property, based on a combination of the information supplied to the method &lt;code&gt;getPropertyInfo&lt;/code&gt; , the Java environment, and the driver-supplied default values.</target>
        </trans-unit>
        <trans-unit id="6bb04aabca923c27392cb6a07985f491ac538c08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; field specifies the current value of the property, based on a combination of the information supplied to the method &lt;code&gt;getPropertyInfo&lt;/code&gt;, the Java environment, and the driver-supplied default values. This field may be null if no value is known.</source>
          <target state="translated">The &lt;code&gt;value&lt;/code&gt; field specifies the current value of the property, based on a combination of the information supplied to the method &lt;code&gt;getPropertyInfo&lt;/code&gt; , the Java environment, and the driver-supplied default values. This field may be null if no value is known.</target>
        </trans-unit>
        <trans-unit id="a0dc0ca5643c577e2bc28f2c4d9f85f55ae2ae0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;view&lt;/code&gt; attribute identifies the &lt;code&gt;AbstractView&lt;/code&gt; from which the event was generated.</source>
          <target state="translated">The &lt;code&gt;view&lt;/code&gt; attribute identifies the &lt;code&gt;AbstractView&lt;/code&gt; from which the event was generated.</target>
        </trans-unit>
        <trans-unit id="35e9083dd12ca67db6c302fb48e049498f0e86ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; values are automatically enlarged if either is less than the minimum size as specified by previous call to &lt;code&gt;setMinimumSize&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; values are automatically enlarged if either is less than the minimum size as specified by previous call to &lt;code&gt;setMinimumSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e270b26fb5f4d86ce8e6fe4ab24f798852bc112c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; values are automatically enlarged if either is less than the minimum size as specified by previous call to &lt;code&gt;setMinimumSize&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; values are automatically enlarged if either is less than the minimum size as specified by previous call to &lt;code&gt;setMinimumSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb6cc5d83f6f060e6206ee4432cd2838d953df43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;unwrap()&lt;/code&gt; methods may execute concurrently of each other.</source>
          <target state="translated">&lt;code&gt;wrap()&lt;/code&gt; 및 &lt;code&gt;unwrap()&lt;/code&gt; 메소드는 서로 동시에 실행할 수있다.</target>
        </trans-unit>
        <trans-unit id="b6ac35afc51c676f6acfb59fbb66aebb7fd7dffe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;CipherOutputStream&lt;/code&gt; calls the &lt;code&gt;write&lt;/code&gt; method of three arguments with the three arguments &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;b.length&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 의 방법 &lt;code&gt;CipherOutputStream&lt;/code&gt; 를이 부르는 &lt;code&gt;write&lt;/code&gt; 세 개의 인수와 세 개의 인수의 방법 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , 및 &lt;code&gt;b.length&lt;/code&gt; 를을 .</target>
        </trans-unit>
        <trans-unit id="b444208efa76dded6db1c12df1b7df685049876c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt; calls its &lt;code&gt;write&lt;/code&gt; method of three arguments with the arguments &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, and &lt;code&gt;b.length&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 의 방법을 &lt;code&gt;FilterOutputStream&lt;/code&gt; 자사의 호출을 &lt;code&gt;write&lt;/code&gt; 인수와 세 개의 인수의 방법 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , 및 &lt;code&gt;b.length&lt;/code&gt; 를을 .</target>
        </trans-unit>
        <trans-unit id="4d273be569b8b30933a05fc498292c5402a93de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt; calls the &lt;code&gt;write&lt;/code&gt; method of its underlying output stream, that is, it performs &lt;code&gt;out.write(b)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 방법 &lt;code&gt;FilterOutputStream&lt;/code&gt; 부르는 &lt;code&gt;write&lt;/code&gt; 자사 기본 출력 스트림의 방법, 그것을 행하는 &lt;code&gt;out.write(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b52d117ddcb1aaf2483d386c55d430f15571498" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;FilterOutputStream&lt;/code&gt; calls the &lt;code&gt;write&lt;/code&gt; method of one argument on each &lt;code&gt;byte&lt;/code&gt; to output.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 방법 &lt;code&gt;FilterOutputStream&lt;/code&gt; 부르는 &lt;code&gt;write&lt;/code&gt; 각각에 하나 개의 인자에있어서의 &lt;code&gt;byte&lt;/code&gt; 를 출력한다.</target>
        </trans-unit>
        <trans-unit id="f6b5bd7ff632f357b485afe4736af5f2318b4eb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; method of &lt;code&gt;OutputStream&lt;/code&gt; calls the write method of one argument on each of the bytes to be written out. Subclasses are encouraged to override this method and provide a more efficient implementation.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 방법 &lt;code&gt;OutputStream&lt;/code&gt; 바이트마다 인수의 쓰기 방법을 기입합니다 호출합니다. 서브 클래스는이 메소드를 대체하고보다 효율적인 구현을 제공하도록 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="4052734952517729cae634a4334fbfe7bc56b79a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; methods of the resulting stream will throw an &lt;a href=&quot;illegalblockingmodeexception&quot;&gt;&lt;code&gt;IllegalBlockingModeException&lt;/code&gt;&lt;/a&gt; if invoked while the underlying channel is in non-blocking mode. The stream will not be buffered. The stream will be safe for access by multiple concurrent threads. Closing the stream will in turn cause the channel to be closed.</source>
          <target state="translated">기본 채널이 비 차단 모드에있는 동안 호출되면 결과 스트림 의 &lt;code&gt;write&lt;/code&gt; 메소드에서 &lt;a href=&quot;illegalblockingmodeexception&quot;&gt; &lt;code&gt;IllegalBlockingModeException&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 스트림은 버퍼링되지 않습니다. 스트림은 여러 개의 동시 스레드가 안전하게 액세스 할 수 있습니다. 스트림을 닫으면 채널이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7aeccac65dd62b076d4abb5d4c775615877d46ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;writeObject&lt;/code&gt; is a single entry point to the persistence and is used by a &lt;code&gt;Encoder&lt;/code&gt; in the traditional mode of delegation. Although this method is not final, it should not need to be subclassed under normal circumstances.</source>
          <target state="translated">&lt;code&gt;writeObject&lt;/code&gt; 지속성에 대한 단일 진입 점이며 의해 사용되는 &lt;code&gt;Encoder&lt;/code&gt; 대표의 전통적인 모드. 이 방법은 최종 방법은 아니지만 일반적인 상황에서 하위 클래스로 분류 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0937ca02336197261dddb7803acba46aa6ec7743" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;writeObject&lt;/code&gt; is a single entry point to the persistence and is used by an &lt;code&gt;Encoder&lt;/code&gt; in the traditional mode of delegation.</source>
          <target state="translated">The &lt;code&gt;writeObject&lt;/code&gt; is a single entry point to the persistence and is used by an &lt;code&gt;Encoder&lt;/code&gt; in the traditional mode of delegation.</target>
        </trans-unit>
        <trans-unit id="9c855374ef3af39f227ccdf574cfb54afb0d247f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;writeObject&lt;/code&gt; is a single entry point to the persistence and is used by an &lt;code&gt;Encoder&lt;/code&gt; in the traditional mode of delegation. Although this method is not final, it should not need to be subclassed under normal circumstances.</source>
          <target state="translated">The &lt;code&gt;writeObject&lt;/code&gt; is a single entry point to the persistence and is used by an &lt;code&gt;Encoder&lt;/code&gt; in the traditional mode of delegation. Although this method is not final, it should not need to be subclassed under normal circumstances.</target>
        </trans-unit>
        <trans-unit id="65972030b222838810b7ba8b656c7648e06077d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;writeUTF&lt;/code&gt; method of interface &lt;code&gt;DataOutput&lt;/code&gt; may be used to write data that is suitable for reading by this method.</source>
          <target state="translated">&lt;code&gt;DataOutput&lt;/code&gt; 인터페이스 의 &lt;code&gt;writeUTF&lt;/code&gt; 메소드를 사용하여이 메소드로 읽기에 적합한 데이터를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecdfdf55c3e6233c34db1e9797ae4ac06e60e0e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{ }&lt;/code&gt; characters are a group of subpatterns, where the group matches if any subpattern in the group matches. The &lt;code&gt;&quot;,&quot;&lt;/code&gt; character is used to separate the subpatterns. Groups cannot be nested.</source>
          <target state="translated">&lt;code&gt;{ }&lt;/code&gt; 문자는 그룹이있는 경우 일치 서브 패턴의 그룹이다 그룹 경기에서 어떤 서브 패턴. 은 &lt;code&gt;&quot;,&quot;&lt;/code&gt; 문자는 서브 패턴을 분리하는 데 사용됩니다. 그룹은 중첩 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4383cedf66c99d541142d23205794e9fbe074f11" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;action&lt;/em&gt;. For a permission you need, this is one of the actions in the list &lt;a href=&quot;#action-list&quot;&gt;below&lt;/a&gt;. For a permission you have, this is a comma-separated list of those actions, or &lt;code&gt;*&lt;/code&gt;, representing all actions.</source>
          <target state="translated">&lt;em&gt;행동&lt;/em&gt; . 필요한 권한의 경우 &lt;a href=&quot;#action-list&quot;&gt;아래&lt;/a&gt; 목록의 작업 중 하나입니다 . 권한이있는 경우이 목록은 쉼표로 구분 된 해당 작업 목록 또는 &lt;code&gt;*&lt;/code&gt; 이며 모든 작업을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a6904e89112c0b2f4cf76a3eaf77590286f5121f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;canonical key property list&lt;/em&gt; is the same string as described for &lt;a href=&quot;#getCanonicalKeyPropertyListString()&quot;&gt;&lt;code&gt;getCanonicalKeyPropertyListString()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The &lt;em&gt;canonical key property list&lt;/em&gt; is the same string as described for &lt;a href=&quot;#getCanonicalKeyPropertyListString()&quot;&gt; &lt;code&gt;getCanonicalKeyPropertyListString()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4203e1844ba2358b9cf99e65861fc5814fcbd135" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;canonical key property list&lt;/em&gt; is the same string as described for &lt;a href=&quot;objectname#getCanonicalKeyPropertyListString--&quot;&gt;&lt;code&gt;getCanonicalKeyPropertyListString()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;표준 키의 프로퍼티리스트&lt;/em&gt; 에 기술 된 것과 동일한 문자열 &lt;a href=&quot;objectname#getCanonicalKeyPropertyListString--&quot;&gt; &lt;code&gt;getCanonicalKeyPropertyListString()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0da932c873e0a87699cfc16c3ea52c0b2e0de4c0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;class name&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;클래스 이름&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b34ed1bdfeb4a02859cb87fc0dd3c70da93cc4ac" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;domain&lt;/em&gt; is a string of characters not including the character colon (&lt;code&gt;:&lt;/code&gt;). It is recommended that the domain should not contain the string &quot;&lt;code&gt;//&lt;/code&gt;&quot;, which is reserved for future use.</source>
          <target state="translated">&lt;em&gt;도메인은&lt;/em&gt; 문자 콜론을 포함하지 않는 문자열입니다 ( &lt;code&gt;:&lt;/code&gt; ). 도메인에는 &quot; &lt;code&gt;//&lt;/code&gt; &quot; 문자열이 포함되어서는 안되며 , 나중에 사용하기 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4031de43ef1c59b0c68ad4834eee900eefebe3c6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;head&lt;/em&gt; of this queue is the &lt;em&gt;least&lt;/em&gt; element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements -- ties are broken arbitrarily. The queue retrieval operations &lt;code&gt;poll&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;peek&lt;/code&gt;, and &lt;code&gt;element&lt;/code&gt; access the element at the head of the queue.</source>
          <target state="translated">이 큐 의 &lt;em&gt;헤드&lt;/em&gt; 는 지정된 순서와 관련 하여 &lt;em&gt;가장 작은&lt;/em&gt; 요소입니다. 여러 요소가 최소한의 가치로 묶여 있으면 머리는 그러한 요소 중 하나입니다. 넥타이는 임의로 끊어집니다. 큐 검색 조작 은 큐 헤드에서 &lt;code&gt;element&lt;/code&gt; &lt;code&gt;poll&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;peek&lt;/code&gt; 및 요소 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="132748ef7ce7edd118fa2aec50bbb6b7013d4a04" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;key properties&lt;/em&gt; are an unordered set of keys and associated values.</source>
          <target state="translated">&lt;em&gt;키 등록은&lt;/em&gt; 키와 관련된 값들의 순서화 된 집합이다.</target>
        </trans-unit>
        <trans-unit id="49b6c7b812bfb37bbfa829d277662d381281a9fd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mapped&lt;/em&gt; Java type, &lt;em&gt;opendata(J)&lt;/em&gt;, which is always the same for any given &lt;em&gt;opentype(J)&lt;/em&gt;. This is a Java class.</source>
          <target state="translated">&lt;em&gt;매핑 된&lt;/em&gt; Java 형, &lt;em&gt;opendata (J)&lt;/em&gt; 항상 주어진에 대해 동일, &lt;em&gt;오픈 타입 (J)&lt;/em&gt; . 이것은 Java 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="bbb454761775dc1a414464798499aeee43da2b26" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;member&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;멤버&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="074cbd71c6bb024356bb7396d0de2ecfe45082b5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; of the permission can also denote a list of one or more comma-separated operations. Spaces are allowed at the beginning and end of the &lt;em&gt;name&lt;/em&gt; and before and after commas.</source>
          <target state="translated">&lt;em&gt;이름&lt;/em&gt; 권한의는 하나 이상의 쉼표로 구분 된 작업 목록을 표시 할 수 있습니다. &lt;em&gt;이름&lt;/em&gt; 의 시작과 끝 과 쉼표 앞뒤에 공백이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9480872eca819a401a143d99801ef4a81e78cc7a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;object name&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;개체 이름&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b8bea707941f307636110813bd9843488dbd1cb0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;opens&lt;/em&gt; directive in a module declaration declares a package to be open to allow all types in the package, and all their members, not just public types and their public members to be reflected on by APIs that support private access or a way to bypass or suppress default Java language access control checks.</source>
          <target state="translated">The &lt;em&gt;opens&lt;/em&gt; directive in a module declaration declares a package to be open to allow all types in the package, and all their members, not just public types and their public members to be reflected on by APIs that support private access or a way to bypass or suppress default Java language access control checks.</target>
        </trans-unit>
        <trans-unit id="5ea4f18aba4c5af225e35673d4891fc5fa9e0a6b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;origin&lt;/em&gt; of an element or other language model item.</source>
          <target state="translated">The &lt;em&gt;origin&lt;/em&gt; of an element or other language model item.</target>
        </trans-unit>
        <trans-unit id="7bf772b2c89d559914753f218273f17b3f5fef8c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;origin&lt;/em&gt; of an element or other language model item. The origin of an element or item models how a construct in a program is declared in the source code, explicitly, implicitly, etc.</source>
          <target state="translated">The &lt;em&gt;origin&lt;/em&gt; of an element or other language model item. The origin of an element or item models how a construct in a program is declared in the source code, explicitly, implicitly, etc.</target>
        </trans-unit>
        <trans-unit id="f0e83e021e240eac4fd2981ea6d32868e52f81d8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname consists of the pathname's prefix, if any, and each name in the pathname's name sequence except for the last. If the name sequence is empty then the pathname does not name a parent directory.</source>
          <target state="translated">추상 경로명 의 &lt;em&gt;부모&lt;/em&gt; 는 경로명의 접두사 (있는 경우)와 마지막을 제외한 경로명의 이름 순서에있는 각 이름으로 구성됩니다. 이름 순서가 비어 있으면 경로 이름이 상위 디렉토리의 이름을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89fec665c0c46c36e97a962d8fe4d0387ff30f83" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname may be obtained by invoking the &lt;a href=&quot;#getParent()&quot;&gt;&lt;code&gt;getParent()&lt;/code&gt;&lt;/a&gt; method of this class and consists of the pathname's prefix and each name in the pathname's name sequence except for the last. Each directory's absolute pathname is an ancestor of any &lt;code&gt;File&lt;/code&gt; object with an absolute abstract pathname which begins with the directory's absolute pathname. For example, the directory denoted by the abstract pathname &lt;code&gt;&quot;/usr&quot;&lt;/code&gt; is an ancestor of the directory denoted by the pathname &lt;code&gt;&quot;/usr/local/bin&quot;&lt;/code&gt;.</source>
          <target state="translated">The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname may be obtained by invoking the &lt;a href=&quot;#getParent()&quot;&gt; &lt;code&gt;getParent()&lt;/code&gt; &lt;/a&gt; method of this class and consists of the pathname's prefix and each name in the pathname's name sequence except for the last. Each directory's absolute pathname is an ancestor of any &lt;code&gt;File&lt;/code&gt; object with an absolute abstract pathname which begins with the directory's absolute pathname. For example, the directory denoted by the abstract pathname &lt;code&gt;&quot;/usr&quot;&lt;/code&gt; is an ancestor of the directory denoted by the pathname &lt;code&gt;&quot;/usr/local/bin&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0528ba347878b821ba42755b3a17661463c339f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;parent&lt;/em&gt; of an abstract pathname may be obtained by invoking the &lt;a href=&quot;file#getParent--&quot;&gt;&lt;code&gt;getParent()&lt;/code&gt;&lt;/a&gt; method of this class and consists of the pathname's prefix and each name in the pathname's name sequence except for the last. Each directory's absolute pathname is an ancestor of any &lt;code&gt;File&lt;/code&gt; object with an absolute abstract pathname which begins with the directory's absolute pathname. For example, the directory denoted by the abstract pathname &lt;code&gt;&quot;/usr&quot;&lt;/code&gt; is an ancestor of the directory denoted by the pathname &lt;code&gt;&quot;/usr/local/bin&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;부모&lt;/em&gt; 추상 패스의이 호출함으로써 얻어 질 수있다 &lt;a href=&quot;file#getParent--&quot;&gt; &lt;code&gt;getParent()&lt;/code&gt; &lt;/a&gt; 이 클래스의 방법과 경로의 접두사와 마지막을 제외한 경로 이름 순서에서 각각 이름 구성된다. 각 디렉토리의 절대 경로 이름은 디렉토리의 절대 경로 이름으로 시작하는 절대 추상 경로 이름을 가진 &lt;code&gt;File&lt;/code&gt; 객체 의 조상입니다 . 예를 들어, 추상 경로 이름 &lt;code&gt;&quot;/usr&quot;&lt;/code&gt; 으로 표시된 디렉토리는 경로 이름 &lt;code&gt;&quot;/usr/local/bin&quot;&lt;/code&gt; 으로 표시된 디렉토리의 조상입니다 .</target>
        </trans-unit>
        <trans-unit id="3219f3facb21696d1ed20d4e54a6c99ee13262e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;pattern indication&lt;/em&gt; is:</source>
          <target state="translated">&lt;em&gt;패턴 표시&lt;/em&gt; 이다 :</target>
        </trans-unit>
        <trans-unit id="75b0986f1f4d3f972e20d5706e48596a413d0f0a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;specified&lt;/em&gt; flag for each attribute will always be true, unless it has been set to false in the copy constructor or using &lt;a href=&quot;#setSpecified(int,boolean)&quot;&gt;&lt;code&gt;setSpecified(int, boolean)&lt;/code&gt;&lt;/a&gt;. Similarly, the &lt;em&gt;declared&lt;/em&gt; flag for each attribute will always be false, except for defaulted attributes (&lt;em&gt;specified&lt;/em&gt; is false), non-CDATA attributes, or when it is set to true using &lt;a href=&quot;#setDeclared(int,boolean)&quot;&gt;&lt;code&gt;setDeclared(int, boolean)&lt;/code&gt;&lt;/a&gt;. If you change an attribute's type by hand, you may need to modify its &lt;em&gt;declared&lt;/em&gt; flag to match.</source>
          <target state="translated">The &lt;em&gt;specified&lt;/em&gt; flag for each attribute will always be true, unless it has been set to false in the copy constructor or using &lt;a href=&quot;#setSpecified(int,boolean)&quot;&gt; &lt;code&gt;setSpecified(int, boolean)&lt;/code&gt; &lt;/a&gt;. Similarly, the &lt;em&gt;declared&lt;/em&gt; flag for each attribute will always be false, except for defaulted attributes (&lt;em&gt;specified&lt;/em&gt; is false), non-CDATA attributes, or when it is set to true using &lt;a href=&quot;#setDeclared(int,boolean)&quot;&gt; &lt;code&gt;setDeclared(int, boolean)&lt;/code&gt; &lt;/a&gt;. If you change an attribute's type by hand, you may need to modify its &lt;em&gt;declared&lt;/em&gt; flag to match.</target>
        </trans-unit>
        <trans-unit id="e24706d6569ad24b7b450fbbe13dd7ea6ed5e827" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;time-to-live&lt;/em&gt; for Internet Protocol (IP) multicast datagrams</source>
          <target state="translated">&lt;em&gt;타임 - 투 - 라이브&lt;/em&gt; 인터넷 프로토콜 (IP) 멀티 캐스트 데이터 그램에 대한</target>
        </trans-unit>
        <trans-unit id="2a0f0d9a04c7aa959de016e80e8a27f487dc3d88" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;time-to-live&lt;/em&gt; for Internet Protocol (IP) multicast datagrams.</source>
          <target state="translated">&lt;em&gt;타임 - 투 - 라이브&lt;/em&gt; 인터넷 프로토콜 (IP) 멀티 캐스트 데이터 그램합니다.</target>
        </trans-unit>
        <trans-unit id="cb26ab7b8c8e6681c6af9faff6deeeb55d0a5d1f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;unchecked&lt;/em&gt; memory address instance modelling the &lt;code&gt;NULL&lt;/code&gt; address.</source>
          <target state="translated">&lt;em&gt;되지 않은&lt;/em&gt; 모델링 메모리 주소 인스턴스 &lt;code&gt;NULL&lt;/code&gt; 의 주소를.</target>
        </trans-unit>
        <trans-unit id="b26dfea9030c19a22d94c096ae163a764273dd4b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;unchecked&lt;/em&gt; memory address instance modelling the &lt;code&gt;NULL&lt;/code&gt; address. This address is &lt;em&gt;not&lt;/em&gt; backed by a memory segment and hence it cannot be dereferenced.</source>
          <target state="translated">&lt;em&gt;되지 않은&lt;/em&gt; 모델링 메모리 주소 인스턴스 &lt;code&gt;NULL&lt;/code&gt; 의 주소를. 이 주소는되어 &lt;em&gt;있지&lt;/em&gt; 메모리 세그먼트 뒷받침 따라서 이는 참조를 취소 할 수 없다.</target>
        </trans-unit>
        <trans-unit id="51b9adb8936cb123ed7c1dde2b592cfab77ae3c9" translate="yes" xml:space="preserve">
          <source>The &lt;u&gt;&lt;a href=&quot;defaultstyleddocument&quot;&gt;&lt;code&gt;DefaultStyledDocument&lt;/code&gt;&lt;/a&gt;&lt;/u&gt; class, used for styled text, contains another level of Elements. This extra level is needed so that each paragraph can contain different styles of text. In the two paragraphs shown in &lt;u&gt;Figure 6&lt;/u&gt;, the first paragraph contains two styles and the second paragraph contains three styles.</source>
          <target state="translated">&lt;u&gt;&lt;a href=&quot;defaultstyleddocument&quot;&gt; &lt;code&gt;DefaultStyledDocument&lt;/code&gt; 의&lt;/a&gt;&lt;/u&gt; 스타일이 텍스트에 사용되는 클래스는 요소의 또 다른 수준이 포함되어 있습니다. 이 추가 수준은 각 단락이 서로 다른 스타일의 텍스트를 포함 할 수 있도록하기 위해 필요합니다. &lt;u&gt;그림 6에&lt;/u&gt; 표시된 두 단락 에서 첫 번째 단락에는 두 가지 스타일이 포함되어 있고 두 번째 단락에는 세 가지 스타일이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d9acc7331c0bb62597d02bf29306884fcbc07df" translate="yes" xml:space="preserve">
          <source>The &lt;u&gt;&lt;a href=&quot;plaindocument&quot;&gt;&lt;code&gt;PlainDocument&lt;/code&gt;&lt;/a&gt;&lt;/u&gt; class defines an Element structure in which the root node has a child node for each line of text in the model. &lt;u&gt;Figure 1&lt;/u&gt; shows how two lines of text would be modeled by a PlainDocument</source>
          <target state="translated">&lt;u&gt;&lt;a href=&quot;plaindocument&quot;&gt; &lt;code&gt;PlainDocument&lt;/code&gt; 의&lt;/a&gt;&lt;/u&gt; 클래스는 루트 노드가 모델에서 텍스트의 각 라인에 대한 자식 노드가있는 Element의 구조를 정의합니다. &lt;u&gt;그림 1&lt;/u&gt; 은 PlainDocument로 두 줄의 텍스트를 모델링하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d69a19d85b8e44ea82b45f3ab6025bf32be35861" translate="yes" xml:space="preserve">
          <source>The &lt;u&gt;&lt;a href=&quot;styleddocument&quot;&gt;&lt;code&gt;StyledDocument&lt;/code&gt;&lt;/a&gt;&lt;/u&gt; class provides a method named &lt;code&gt;setCharacterAttributes()&lt;/code&gt;, which allows you to set the attributes on the character Elements in a given range:</source>
          <target state="translated">&lt;u&gt;&lt;a href=&quot;styleddocument&quot;&gt; &lt;code&gt;StyledDocument&lt;/code&gt; &lt;/a&gt;&lt;/u&gt; 클래스는 메소드 이름을 제공 &lt;code&gt;setCharacterAttributes()&lt;/code&gt; 는 주어진 범위의 문자 요소에 대한 속성을 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a5cbd78bbaec3014307f658d756d06fe19f45c6b" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;outer&lt;/var&gt; parameter is a pointer to the MBeanServer that should be passed to the &lt;a href=&quot;mbeanregistration&quot;&gt;&lt;code&gt;MBeanRegistration&lt;/code&gt;&lt;/a&gt; interface when registering MBeans inside the MBeanServer. If &lt;var&gt;outer&lt;/var&gt; is &lt;code&gt;null&lt;/code&gt;, then the MBeanServer implementation must use its own &lt;code&gt;this&lt;/code&gt; reference when invoking the &lt;a href=&quot;mbeanregistration&quot;&gt;&lt;code&gt;MBeanRegistration&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">&lt;var&gt;outer&lt;/var&gt; 파라미터는에게 건네지는 MBeanServer의 포인터 &lt;a href=&quot;mbeanregistration&quot;&gt; &lt;code&gt;MBeanRegistration&lt;/code&gt; &lt;/a&gt; MBeanServer에 MBean를 등록 할 때에 인터페이스. &lt;var&gt;outer&lt;/var&gt; 가 &lt;code&gt;null&lt;/code&gt; 의 경우 , MBeanServer 구현은 독자적인 것을 사용해야합니다 &lt;code&gt;this&lt;/code&gt; &lt;a href=&quot;mbeanregistration&quot;&gt; &lt;code&gt;MBeanRegistration&lt;/code&gt; &lt;/a&gt; 인터페이스를 호출 할 때 으로이 참조를 .</target>
        </trans-unit>
        <trans-unit id="f59eba20773f5628795f2594c47e23e68f64a277" translate="yes" xml:space="preserve">
          <source>The ACL Entries in each ACL observe the following rules:</source>
          <target state="translated">각 ACL의 ACL 항목은 다음 규칙을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="8bff27e96b6704d8f87499203e5a6ae8eb995398" translate="yes" xml:space="preserve">
          <source>The ACL entry represented by this class is based on the ACL model specified in &lt;a href=&quot;http://www.ietf.org/rfc/rfc3530.txt&quot;&gt;&lt;i&gt;RFC 3530: Network File System (NFS) version 4 Protocol&lt;/i&gt;&lt;/a&gt;. Each entry has four components as follows:</source>
          <target state="translated">이 클래스가 나타내는 ACL 항목은에 지정된 ACL 모델을 기반으로합니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc3530.txt&quot;&gt;&lt;i&gt; RFC 3530 : NFS (Network File System) 버전 4 프로토콜에&lt;/i&gt;&lt;/a&gt;. 각 항목에는 다음과 같은 네 가지 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca592302262da526d39a62951c512b3c1b6f0bf7" translate="yes" xml:space="preserve">
          <source>The ACL entry represented by this class is based on the ACL model specified in &lt;a href=&quot;https://www.ietf.org/rfc/rfc3530.txt&quot;&gt;&lt;i&gt;RFC 3530: Network File System (NFS) version 4 Protocol&lt;/i&gt;&lt;/a&gt;. Each entry has four components as follows:</source>
          <target state="translated">이 클래스가 나타내는 ACL 항목은 &lt;a href=&quot;https://www.ietf.org/rfc/rfc3530.txt&quot;&gt;&lt;i&gt;RFC 3530 : NFS (Network File System) 버전 4 프로토콜에&lt;/i&gt;&lt;/a&gt; 지정된 ACL 모델을 기반으로합니다 . 각 항목에는 다음과 같은 네 가지 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7935a2f1ee484e91861f127adcc137f1458cac88" translate="yes" xml:space="preserve">
          <source>The API allows a concrete &lt;a href=&quot;transformerfactory&quot;&gt;&lt;code&gt;TransformerFactory&lt;/code&gt;&lt;/a&gt; object to be created from the static function &lt;a href=&quot;transformerfactory#newInstance()&quot;&gt;&lt;code&gt;TransformerFactory.newInstance()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The API allows a concrete &lt;a href=&quot;transformerfactory&quot;&gt; &lt;code&gt;TransformerFactory&lt;/code&gt; &lt;/a&gt; object to be created from the static function &lt;a href=&quot;transformerfactory#newInstance()&quot;&gt; &lt;code&gt;TransformerFactory.newInstance()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="36548e1972814e3b9960a257ac0e7fefe094719d" translate="yes" xml:space="preserve">
          <source>The API has a relatively large surface area in terms of number of methods. This is made manageable through the use of consistent method prefixes.</source>
          <target state="translated">API는 메소드 수 측면에서 비교적 넓은 표면적을 가지고 있습니다. 일관된 메소드 접두사를 사용하여 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="dbd68d7bbcc6cfd76b2979294dc860ef940a8a77" translate="yes" xml:space="preserve">
          <source>The API has been designed to reject null early and to be clear about this behavior. A key exception is any method that takes an object and returns a boolean, for the purpose of checking or validating, will generally return false for null.</source>
          <target state="translated">API는 null을 일찍 거부하고이 동작에 대해 명확하게 설계되었습니다. 중요한 예외는 객체를 가져 와서 부울을 리턴하는 메소드이며, 점검 또는 유효성 검증을 위해 일반적으로 널 (null)에 대해 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5d2d1219bb89c1b00654a21e6d21d64a9c99c7dd" translate="yes" xml:space="preserve">
          <source>The API includes remote access, so a remote management program can interact with a running application for these purposes.</source>
          <target state="translated">API에는 원격 액세스가 포함되어 있으므로 원격 관리 프로그램은 이러한 목적으로 실행중인 응용 프로그램과 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ddb46698ab6320ca268f051f9fdff93cea456dc" translate="yes" xml:space="preserve">
          <source>The API is also designed for user extensibility, as there are many ways of calculating time. The &lt;a href=&quot;temporal/temporalfield&quot;&gt;field&lt;/a&gt; and &lt;a href=&quot;temporal/temporalunit&quot;&gt;unit&lt;/a&gt; API, accessed via &lt;a href=&quot;temporal/temporalaccessor&quot;&gt;&lt;code&gt;TemporalAccessor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/temporal&quot;&gt;&lt;code&gt;Temporal&lt;/code&gt;&lt;/a&gt; provide considerable flexibility to applications. In addition, the &lt;a href=&quot;temporal/temporalquery&quot;&gt;&lt;code&gt;TemporalQuery&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/temporaladjuster&quot;&gt;&lt;code&gt;TemporalAdjuster&lt;/code&gt;&lt;/a&gt; interfaces provide day-to-day power, allowing code to read close to business requirements:</source>
          <target state="translated">API는 시간을 계산하는 많은 방법이 있기 때문에 사용자 확장 성을 위해 설계되었습니다. &lt;a href=&quot;temporal/temporalaccessor&quot;&gt; &lt;code&gt;TemporalAccessor&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/temporal&quot;&gt; &lt;code&gt;Temporal&lt;/code&gt; 을&lt;/a&gt; 통해 액세스 되는 &lt;a href=&quot;temporal/temporalfield&quot;&gt;필드&lt;/a&gt; 및 &lt;a href=&quot;temporal/temporalunit&quot;&gt;단위&lt;/a&gt; API 는 애플리케이션에 상당한 유연성을 제공합니다. 또한 &lt;a href=&quot;temporal/temporalquery&quot;&gt; &lt;code&gt;TemporalQuery&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/temporaladjuster&quot;&gt; &lt;code&gt;TemporalAdjuster&lt;/code&gt; &lt;/a&gt; 인터페이스는 일상적인 성능을 제공하여 코드가 비즈니스 요구 사항에 근접하여 읽을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="9d4850815012acd78d63e490cb3a9ac9619de1e0" translate="yes" xml:space="preserve">
          <source>The API is defined by classes in the package &lt;code&gt;javax.smartcardio&lt;/code&gt;. They can be classified as follows:</source>
          <target state="translated">The API is defined by classes in the package &lt;code&gt;javax.smartcardio&lt;/code&gt; . They can be classified as follows:</target>
        </trans-unit>
        <trans-unit id="14204c857d829d56ea62ee7c57aa99da1a8c1fa8" translate="yes" xml:space="preserve">
          <source>The API is designed to be type-safe where reasonable in the main high-level API. Thus, there are separate classes for the distinct concepts of date, time and date-time, plus variants for offset and time-zone. This can seem like a lot of classes, but most applications can begin with just five date/time types.</source>
          <target state="translated">API는 주요 고급 API에서 합리적인 경우 형식이 안전하도록 설계되었습니다. 따라서 날짜, 시간 및 날짜-시간의 고유 한 개념에 대한 별도의 클래스와 오프셋 및 시간대에 대한 변형이 있습니다. 이것은 많은 수업처럼 보일 수 있지만 대부분의 응용 프로그램은 5 개의 날짜 / 시간 유형으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c946352687beebbc767bf6f2e149b6a14c7e762" translate="yes" xml:space="preserve">
          <source>The API leverages the JCA provider model (see &lt;a href=&quot;../../../../../java.base/java/security/provider&quot;&gt;&lt;code&gt;the Provider class&lt;/code&gt;&lt;/a&gt;) for registering and loading &lt;code&gt;XMLSignatureFactory&lt;/code&gt; and &lt;code&gt;KeyInfoFactory&lt;/code&gt; implementations.</source>
          <target state="translated">API는 &lt;code&gt;XMLSignatureFactory&lt;/code&gt; 및 &lt;code&gt;KeyInfoFactory&lt;/code&gt; 구현 을 등록하고로드하기 위해 JCA 제공자 모델 ( &lt;a href=&quot;../../../../../java.base/java/security/provider&quot;&gt; &lt;code&gt;the Provider class&lt;/code&gt; &lt;/a&gt; 참조 )을 활용합니다 .</target>
        </trans-unit>
        <trans-unit id="5ef3ef0b96f3f41f9bc604e1a12e6451e41174cc" translate="yes" xml:space="preserve">
          <source>The API provides a way for URIs referenced from within the stylesheet instructions or within the transformation to be resolved by the calling application. This can be done by creating a class that implements the &lt;a href=&quot;uriresolver&quot;&gt;&lt;code&gt;URIResolver&lt;/code&gt;&lt;/a&gt; interface, with its one method, &lt;a href=&quot;uriresolver#resolve(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;URIResolver.resolve(java.lang.String, java.lang.String)&lt;/code&gt;&lt;/a&gt;, and use this class to set the URI resolution for the transformation instructions or transformation with &lt;a href=&quot;transformerfactory#setURIResolver(javax.xml.transform.URIResolver)&quot;&gt;&lt;code&gt;TransformerFactory.setURIResolver(javax.xml.transform.URIResolver)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;transformer#setURIResolver(javax.xml.transform.URIResolver)&quot;&gt;&lt;code&gt;Transformer.setURIResolver(javax.xml.transform.URIResolver)&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;URIResolver.resolve&lt;/code&gt; method takes two String arguments, the URI found in the stylesheet instructions or built as part of the transformation process, and the base URI against which the first argument will be made absolute if the absolute URI is required. The returned &lt;a href=&quot;source&quot;&gt;&lt;code&gt;Source&lt;/code&gt;&lt;/a&gt; object must be usable by the transformer, as specified in its implemented features.</source>
          <target state="translated">The API provides a way for URIs referenced from within the stylesheet instructions or within the transformation to be resolved by the calling application. This can be done by creating a class that implements the &lt;a href=&quot;uriresolver&quot;&gt; &lt;code&gt;URIResolver&lt;/code&gt; &lt;/a&gt; interface, with its one method, &lt;a href=&quot;uriresolver#resolve(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;URIResolver.resolve(java.lang.String, java.lang.String)&lt;/code&gt; &lt;/a&gt;, and use this class to set the URI resolution for the transformation instructions or transformation with &lt;a href=&quot;transformerfactory#setURIResolver(javax.xml.transform.URIResolver)&quot;&gt; &lt;code&gt;TransformerFactory.setURIResolver(javax.xml.transform.URIResolver)&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;transformer#setURIResolver(javax.xml.transform.URIResolver)&quot;&gt; &lt;code&gt;Transformer.setURIResolver(javax.xml.transform.URIResolver)&lt;/code&gt; &lt;/a&gt;. The &lt;code&gt;URIResolver.resolve&lt;/code&gt; method takes two String arguments, the URI found in the stylesheet instructions or built as part of the transformation process, and the base URI against which the first argument will be made absolute if the absolute URI is required. The returned &lt;a href=&quot;source&quot;&gt; &lt;code&gt;Source&lt;/code&gt; &lt;/a&gt; object must be usable by the transformer, as specified in its implemented features.</target>
        </trans-unit>
        <trans-unit id="1d7455826253bffa39b78615725dcdd563f19a04" translate="yes" xml:space="preserve">
          <source>The API requires every print service to support certain attributes; other attributes are optional and the service can choose whether or not to support them. Each attribute has a set of values that it accepts. The API requires every print service to support certain values for certain attributes; other attribute values are optional and the service can choose whether or not to support them. These support requirements are recorded in the documentation for each attribute class.</source>
          <target state="translated">API는 모든 인쇄 서비스가 특정 속성을 지원하도록 요구합니다. 다른 속성은 선택 사항이며 서비스는 해당 속성을 지원할지 여부를 선택할 수 있습니다. 각 속성에는 허용되는 값 세트가 있습니다. API는 모든 인쇄 서비스가 특정 속성에 대한 특정 값을 지원하도록 요구합니다. 다른 속성 값은 선택 사항이며 서비스는이를 지원할지 여부를 선택할 수 있습니다. 이러한 지원 요구 사항은 각 속성 클래스에 대한 설명서에 기록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="98bf436512bc6abd974a2733430a3d5b5a388d6c" translate="yes" xml:space="preserve">
          <source>The APIs added in 1.7 map between the old and new language codes, maintaining the old codes internal to Locale (so that &lt;code&gt;getLanguage&lt;/code&gt; and &lt;code&gt;toString&lt;/code&gt; reflect the old code), but using the new codes in the BCP 47 language tag APIs (so that &lt;code&gt;toLanguageTag&lt;/code&gt; reflects the new one). This preserves the equivalence between Locales no matter which code or API is used to construct them. Java's default resource bundle lookup mechanism also implements this mapping, so that resources can be named using either convention, see &lt;a href=&quot;resourcebundle.control&quot;&gt;&lt;code&gt;ResourceBundle.Control&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1.7에 추가 된 API는 이전 언어 코드와 새 언어 코드를 매핑하여 로케일 내부의 기존 코드를 유지하지만 ( &lt;code&gt;getLanguage&lt;/code&gt; 및 &lt;code&gt;toString&lt;/code&gt; 은 이전 코드를 반영 함) BCP 47 언어 태그 API에서 새 코드를 사용합니다 ( &lt;code&gt;toLanguageTag&lt;/code&gt; 는 새로운 것). 이렇게하면 로케일간에 코드 또는 API를 사용하여 로케일 간의 동등성을 유지합니다. Java의 기본 자원 번들 조회 메커니즘은이 맵핑을 구현하므로 두 규칙 중 하나를 사용하여 자원의 이름을 지정할 수 있습니다 ( &lt;a href=&quot;resourcebundle.control&quot;&gt; &lt;code&gt;ResourceBundle.Control&lt;/code&gt; &lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="6023c5172deb2e42606e029f4d360e805d38b457" translate="yes" xml:space="preserve">
          <source>The APIs in this package are all deprecated without replacement.</source>
          <target state="translated">The APIs in this package are all deprecated without replacement.</target>
        </trans-unit>
        <trans-unit id="1e8aa36e1e31661c0e8ce5465a873be7b0631796" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition for this is:</source>
          <target state="translated">이에 대한 ASN.1 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="943be2a0bc4bf87f26928040bf4bf42222a1a4d3" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition is as follows:</source>
          <target state="translated">ASN.1 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33b3e4f975d64c40485d484aff9c8c6946bbcac2" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition of &lt;code&gt;GeneralNames&lt;/code&gt; is defined in &lt;a href=&quot;#getSubjectAlternativeNames()&quot;&gt;&lt;code&gt;getSubjectAlternativeNames&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The ASN.1 definition of &lt;code&gt;GeneralNames&lt;/code&gt; is defined in &lt;a href=&quot;#getSubjectAlternativeNames()&quot;&gt; &lt;code&gt;getSubjectAlternativeNames&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="47734034dda78f218c309ac08628f954c60425f3" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition of &lt;code&gt;GeneralNames&lt;/code&gt; is defined in &lt;a href=&quot;x509certificate#getSubjectAlternativeNames--&quot;&gt;&lt;code&gt;getSubjectAlternativeNames&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;GeneralNames&lt;/code&gt; 의 ASN.1 정의는 &lt;a href=&quot;x509certificate#getSubjectAlternativeNames--&quot;&gt; &lt;code&gt;getSubjectAlternativeNames&lt;/code&gt; 에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d4394df37dee40fdf32c164d9e7675520b84225" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition of &lt;code&gt;tbsCertList&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;tbsCertList&lt;/code&gt; 의 ASN.1 정의는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3b0786ad17cd85c2406e5dec048d22519850b47" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition of &lt;code&gt;tbsCertificate&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;tbsCertificate&lt;/code&gt; 의 ASN.1 정의는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef48af476f938c6dbaa3d39664736786a596b706" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition of the &lt;code&gt;IssuerAltName&lt;/code&gt; extension is:</source>
          <target state="translated">&lt;code&gt;IssuerAltName&lt;/code&gt; 확장 의 ASN.1 정의 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3bfe2daf1a8d1055520bbddc7ce3310410386b4" translate="yes" xml:space="preserve">
          <source>The ASN.1 definition of the &lt;code&gt;SubjectAltName&lt;/code&gt; extension is:</source>
          <target state="translated">&lt;code&gt;SubjectAltName&lt;/code&gt; 확장 의 ASN.1 정의 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef7fb5e463d8e7a85b7d17a9a4424f5c59dec8a2" translate="yes" xml:space="preserve">
          <source>The AWT Focus Subsystem</source>
          <target state="translated">The AWT Focus Subsystem</target>
        </trans-unit>
        <trans-unit id="c23a37e89e94656b7c67efc2143f08a7162a7dc6" translate="yes" xml:space="preserve">
          <source>The AWT Modality</source>
          <target state="translated">The AWT Modality</target>
        </trans-unit>
        <trans-unit id="b973428a4010a2e2c6902dfcdc73ebef4dc85d16" translate="yes" xml:space="preserve">
          <source>The AWT listener model lets applications attach event listeners to components in order to bind events to actions. Swing encourages the use of keymaps instead of listeners, but maintains compatibility with listeners by giving the listeners a chance to steal an event by consuming it.</source>
          <target state="translated">The AWT listener model lets applications attach event listeners to components in order to bind events to actions. Swing encourages the use of keymaps instead of listeners, but maintains compatibility with listeners by giving the listeners a chance to steal an event by consuming it.</target>
        </trans-unit>
        <trans-unit id="0669e573aa756da1edc3404f2ca12e839dcd44e2" translate="yes" xml:space="preserve">
          <source>The AccessControlContext of the thread that created the instance of URLClassLoader will be used when subsequently loading classes and resources.</source>
          <target state="translated">URLClassLoader의 인스턴스를 만든 스레드의 AccessControlContext는 이후에 클래스와 리소스를로드 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b36f05d0d881d326a4ca7052f41c11e7cb29b4d8" translate="yes" xml:space="preserve">
          <source>The AccessController class is used for access control operations and decisions.</source>
          <target state="translated">AccessController 클래스는 액세스 제어 조작 및 결정에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e44ca12442a1e7b0c2ea9c89fdb764999e8954ae" translate="yes" xml:space="preserve">
          <source>The AccessibleObject class is the base class for Field, Method and Constructor objects.</source>
          <target state="translated">AccessibleObject 클래스는 Field, Method 및 Constructor 객체의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="6a4566430ddc25f7244284392e568dac22b82186" translate="yes" xml:space="preserve">
          <source>The AccessibleObject class is the base class for Field, Method and Constructor objects. It provides the ability to flag a reflected object as suppressing default Java language access control checks when it is used. The access checks--for public, default (package) access, protected, and private members--are performed when Fields, Methods or Constructors are used to set or get fields, to invoke methods, or to create and initialize new instances of classes, respectively.</source>
          <target state="translated">AccessibleObject 클래스는 Field, Method 및 Constructor 객체의 기본 클래스입니다. 사용시 기본 Java 언어 액세스 제어 검사를 억제하여 반사 된 오브젝트에 플래그를 지정할 수 있습니다. 공개, 기본 (패키지) 액세스, 보호 및 개인 멤버에 대한 액세스 검사는 필드, 메소드 또는 생성자가 필드를 설정 또는 가져 오거나 메소드를 호출하거나 클래스의 새 인스턴스를 작성 및 초기화하는 데 사용되는 경우 수행됩니다. 각각.</target>
        </trans-unit>
        <trans-unit id="a68ea02747038a8e45417b19cd5c6838a7022a98" translate="yes" xml:space="preserve">
          <source>The AffineTransform parameter passed into and out of this class are cloned. The RenderingHints and Shape parameters are not necessarily cloneable and are therefore only reference copied. Altering RenderingHints or Shape instances that are in use by instances of RenderContext may have undesired side effects.</source>
          <target state="translated">The AffineTransform parameter passed into and out of this class are cloned. The RenderingHints and Shape parameters are not necessarily cloneable and are therefore only reference copied. Altering RenderingHints or Shape instances that are in use by instances of RenderContext may have undesired side effects.</target>
        </trans-unit>
        <trans-unit id="6784e3abc090fab94e5244fcbe90ade6d9424123" translate="yes" xml:space="preserve">
          <source>The AllPermission is a permission that implies all other permissions.</source>
          <target state="translated">AllPermission은 다른 모든 권한을 암시하는 권한입니다.</target>
        </trans-unit>
        <trans-unit id="160ae22b65044b8568a8445e371a31bf8aaf3856" translate="yes" xml:space="preserve">
          <source>The Alt key extended modifier constant.</source>
          <target state="translated">The Alt key extended modifier constant.</target>
        </trans-unit>
        <trans-unit id="c32b87d13e51010df9b131a2a159c6f08c4061cc" translate="yes" xml:space="preserve">
          <source>The Alt key modifier constant.</source>
          <target state="translated">The Alt key modifier constant.</target>
        </trans-unit>
        <trans-unit id="67ebaec467a6e9959ba36c0e74821764b3f28d0e" translate="yes" xml:space="preserve">
          <source>The AltGraph key extended modifier constant.</source>
          <target state="translated">The AltGraph key extended modifier constant.</target>
        </trans-unit>
        <trans-unit id="af96a3451e70135ea5a5f5dfb4bc7b7416b43b8e" translate="yes" xml:space="preserve">
          <source>The AltGraph key modifier constant.</source>
          <target state="translated">The AltGraph key modifier constant.</target>
        </trans-unit>
        <trans-unit id="6868186048f362d856c90c60963c84a42086381e" translate="yes" xml:space="preserve">
          <source>The Applet API is deprecated, no replacement.</source>
          <target state="translated">The Applet API is deprecated, no replacement.</target>
        </trans-unit>
        <trans-unit id="952898db7755e8938613fa579a9e9fc86b6e5a52" translate="yes" xml:space="preserve">
          <source>The Applet API is deprecated.</source>
          <target state="translated">The Applet API is deprecated.</target>
        </trans-unit>
        <trans-unit id="8dd33816bcdb119edd3850a36cdb8640a02f66c5" translate="yes" xml:space="preserve">
          <source>The Applet API is deprecated. See the &lt;a href=&quot;../../java/applet/package-summary&quot;&gt; java.applet package documentation&lt;/a&gt; for further information.</source>
          <target state="translated">The Applet API is deprecated. See the &lt;a href=&quot;../../java/applet/package-summary&quot;&gt; java.applet package documentation&lt;/a&gt; for further information.</target>
        </trans-unit>
        <trans-unit id="3fde7dcfee0eaa7810b2d3e4119c1b3003baeb65" translate="yes" xml:space="preserve">
          <source>The Applet API is deprecated. See the &lt;a href=&quot;../applet/package-summary&quot;&gt; java.applet package documentation&lt;/a&gt; for further information.</source>
          <target state="translated">The Applet API is deprecated. See the &lt;a href=&quot;../applet/package-summary&quot;&gt; java.applet package documentation&lt;/a&gt; for further information.</target>
        </trans-unit>
        <trans-unit id="074b0f1a024ad247a895c2f41c9dab31804bb1f1" translate="yes" xml:space="preserve">
          <source>The Arabic range with the Arabic-Indic digits.</source>
          <target state="translated">The Arabic range with the Arabic-Indic digits.</target>
        </trans-unit>
        <trans-unit id="5f0a7cc180f7ec121449f8ad22a0f254f01aed33" translate="yes" xml:space="preserve">
          <source>The Arabic range with the Eastern Arabic-Indic digits.</source>
          <target state="translated">The Arabic range with the Eastern Arabic-Indic digits.</target>
        </trans-unit>
        <trans-unit id="9b559b3d068940514b3b2c10adaad5cfb38dfc1e" translate="yes" xml:space="preserve">
          <source>The Area class will attempt to return the tightest bounding box possible for the Shape. The bounding box will not be padded to include the control points of curves in the outline of the Shape, but should tightly fit the actual geometry of the outline itself.</source>
          <target state="translated">The Area class will attempt to return the tightest bounding box possible for the Shape. The bounding box will not be padded to include the control points of curves in the outline of the Shape, but should tightly fit the actual geometry of the outline itself.</target>
        </trans-unit>
        <trans-unit id="9477ca8f0c7cd6500bd0479d8977d02cdcbaf631" translate="yes" xml:space="preserve">
          <source>The Area class will attempt to return the tightest bounding box possible for the Shape. The bounding box will not be padded to include the control points of curves in the outline of the Shape, but should tightly fit the actual geometry of the outline itself. Since the returned object represents the bounding box with integers, the bounding box can only be as tight as the nearest integer coordinates that encompass the geometry of the Shape.</source>
          <target state="translated">The Area class will attempt to return the tightest bounding box possible for the Shape. The bounding box will not be padded to include the control points of curves in the outline of the Shape, but should tightly fit the actual geometry of the outline itself. Since the returned object represents the bounding box with integers, the bounding box can only be as tight as the nearest integer coordinates that encompass the geometry of the Shape.</target>
        </trans-unit>
        <trans-unit id="e40e5d487b331e1f7f4c2477322a84662ea1dcde" translate="yes" xml:space="preserve">
          <source>The Art of Computer Programming</source>
          <target state="translated">컴퓨터 프로그래밍의 기술</target>
        </trans-unit>
        <trans-unit id="3e916cc17dff2d73e810c4085e8846b18e562a3e" translate="yes" xml:space="preserve">
          <source>The Art of Computer Programming,</source>
          <target state="translated">컴퓨터 프로그래밍 기술,</target>
        </trans-unit>
        <trans-unit id="d69bacd54b669ff7d878e60414c2d1f8611ca3a2" translate="yes" xml:space="preserve">
          <source>The Art of Computer Programming, Volume 2</source>
          <target state="translated">컴퓨터 프로그래밍 기술, 2 권</target>
        </trans-unit>
        <trans-unit id="545bef1b9e1299301bb2907b1e213bfe088b7b67" translate="yes" xml:space="preserve">
          <source>The Attribute with attrID that was previous in this attribute set; null if no such attribute existed.</source>
          <target state="translated">이 속성 세트에서 이전에 attrID를 가진 속성. 그러한 속성이 존재하지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="86989bf0d4a1d404f5eef67b394b9e8347a4cb82" translate="yes" xml:space="preserve">
          <source>The Attribute with the same ID as attr that was previous in this attribute set; null if no such attribute existed.</source>
          <target state="translated">이 속성 세트에서 이전에 attr과 동일한 ID를 가진 속성. 그러한 속성이 존재하지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="188be4b00e3695b200467797aef29ec1a27bdb7b" translate="yes" xml:space="preserve">
          <source>The Attribute with the same ID as attrID that was previous in the attribute set; null if no such attribute existed.</source>
          <target state="translated">속성 세트에서 이전에 attrID와 동일한 ID를 가진 속성. 그러한 속성이 존재하지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="17831de708d75ed43f9af6c62286f3a3d590fbe3" translate="yes" xml:space="preserve">
          <source>The Attributes class maps Manifest attribute names to associated string values.</source>
          <target state="translated">Attributes 클래스는 매니페스트 속성 이름을 관련 문자열 값에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="11106864e8cece63f4df274160f30c89327ce115" translate="yes" xml:space="preserve">
          <source>The Attributes class maps Manifest attribute names to associated string values. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the JAR File Specification for more information about valid attribute names and values.</source>
          <target state="translated">Attributes 클래스는 매니페스트 속성 이름을 관련 문자열 값에 매핑합니다. 유효한 속성 이름은 대소 문자를 구분하지 않으며 [0-9a-zA-Z_-] 집합의 ASCII 문자로 제한되며 70자를 초과 할 수 없습니다. 속성 값은 모든 문자를 포함 할 수 있으며 출력 스트림에 기록 될 때 UTF8로 인코딩됩니다. 유효한 속성 이름 및 값에 대한 자세한 정보는 JAR 파일 스펙을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3ef11f26de12755419a148282a58582ba21062d2" translate="yes" xml:space="preserve">
          <source>The Attributes class maps Manifest attribute names to associated string values. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. There must be a colon and a SPACE after the name; the combined length will not exceed 72 characters. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt; for more information about valid attribute names and values.</source>
          <target state="translated">The Attributes class maps Manifest attribute names to associated string values. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. There must be a colon and a SPACE after the name; the combined length will not exceed 72 characters. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt; for more information about valid attribute names and values.</target>
        </trans-unit>
        <trans-unit id="ce1aaf9434adb65a9c7d2a62816880427b08624f" translate="yes" xml:space="preserve">
          <source>The Attributes class maps Manifest attribute names to associated string values. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. There must be a colon and a SPACE after the name; the combined length will not exceed 72 characters. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt; for more information about valid attribute names and values.</source>
          <target state="translated">Attributes 클래스는 매니페스트 속성 이름을 관련 문자열 값에 매핑합니다. 유효한 속성 이름은 대소 문자를 구분하지 않으며 [0-9a-zA-Z_-] 집합의 ASCII 문자로 제한되며 길이는 70자를 초과 할 수 없습니다. 이름 뒤에는 콜론과 공백이 있어야합니다. 합쳐진 길이는 72자를 초과 할 수 없습니다. 속성 값은 모든 문자를 포함 할 수 있으며 출력 스트림에 기록 될 때 UTF8로 인코딩됩니다. 유효한 속성 이름 및 값에 대한 자세한 정보 는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jar/jar.html&quot;&gt;JAR 파일 스펙&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b1b32f55e754aebc8c66e80e5a265f6ce9b4d29" translate="yes" xml:space="preserve">
          <source>The Attributes.Name class represents an attribute name stored in this Map.</source>
          <target state="translated">Attributes.Name 클래스는이 맵에 저장된 속성 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e586abe0903b7ef3e0a894bd9fa0abd2347cbc7b" translate="yes" xml:space="preserve">
          <source>The Attributes.Name class represents an attribute name stored in this Map. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt; for more information about valid attribute names and values.</source>
          <target state="translated">The Attributes.Name class represents an attribute name stored in this Map. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt; for more information about valid attribute names and values.</target>
        </trans-unit>
        <trans-unit id="cf343f226e4f6526f09040d66bbe4bcf74baa90b" translate="yes" xml:space="preserve">
          <source>The Attributes.Name class represents an attribute name stored in this Map. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jar/jar.html&quot;&gt;JAR File Specification&lt;/a&gt; for more information about valid attribute names and values.</source>
          <target state="translated">Attributes.Name 클래스는이 맵에 저장된 속성 이름을 나타냅니다. 유효한 속성 이름은 대소 문자를 구분하지 않으며 [0-9a-zA-Z_-] 집합의 ASCII 문자로 제한되며 길이는 70자를 초과 할 수 없습니다. 속성 값은 모든 문자를 포함 할 수 있으며 출력 스트림에 기록 될 때 UTF8로 인코딩됩니다. 유효한 속성 이름 및 값에 대한 자세한 정보 는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jar/jar.html&quot;&gt;JAR 파일 스펙&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="130d29f5e1935938287de918b31d59eac532adc8" translate="yes" xml:space="preserve">
          <source>The Attributes.Name class represents an attribute name stored in this Map. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the JAR File Specification for more information about valid attribute names and values.</source>
          <target state="translated">Attributes.Name 클래스는이 맵에 저장된 속성 이름을 나타냅니다. 유효한 속성 이름은 대소 문자를 구분하지 않으며 [0-9a-zA-Z_-] 집합의 ASCII 문자로 제한되며 70자를 초과 할 수 없습니다. 속성 값은 모든 문자를 포함 할 수 있으며 출력 스트림에 기록 될 때 UTF8로 인코딩됩니다. 유효한 속성 이름 및 값에 대한 자세한 정보는 JAR 파일 스펙을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="933c13e97de653f311c0095da4356feb1ef9aa07" translate="yes" xml:space="preserve">
          <source>The BIDI_EMBEDDING attribute in the text, if present, represents embedding level information. Negative values from -1 to -62 indicate overrides at the absolute value of the level. Positive values from 1 to 62 indicate embeddings. Where values are zero or not defined, the base embedding level as determined by the base direction is assumed.</source>
          <target state="translated">텍스트의 BIDI_EMBEDDING 속성 (있는 경우)은 포함 레벨 정보를 나타냅니다. -1에서 -62까지의 음수 값은 레벨의 절대 값에서 재정의를 나타냅니다. 1에서 62 사이의 양수 값은 임베딩을 나타냅니다. 값이 0이거나 정의되지 않은 경우 기본 방향으로 결정된 기본 포함 수준이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="0a6d149de56262f01e5e36cd8497b77dee6738e2" translate="yes" xml:space="preserve">
          <source>The BackSpace key.</source>
          <target state="translated">The BackSpace key.</target>
        </trans-unit>
        <trans-unit id="39a8d250337b403c7a9d7f4737d5c4ebb7d43c9b" translate="yes" xml:space="preserve">
          <source>The Balinese range with the Balinese digits.</source>
          <target state="translated">The Balinese range with the Balinese digits.</target>
        </trans-unit>
        <trans-unit id="479b03243c34870565e01fcb4d8b7558405fd430" translate="yes" xml:space="preserve">
          <source>The Base64 padding character &lt;code&gt;'='&lt;/code&gt; is accepted and interpreted as the end of the encoded byte data, but is not required. So if the final unit of the encoded byte data only has two or three Base64 characters (without the corresponding padding character(s) padded), they are decoded as if followed by padding character(s). If there is a padding character present in the final unit, the correct number of padding character(s) must be present, otherwise &lt;code&gt;IllegalArgumentException&lt;/code&gt; ( &lt;code&gt;IOException&lt;/code&gt; when reading from a Base64 stream) is thrown during decoding.</source>
          <target state="translated">Base64 패딩 문자 &lt;code&gt;'='&lt;/code&gt; 는 인코딩 된 바이트 데이터의 끝으로 승인되고 해석되지만 필수는 아닙니다. 따라서, 인코딩 된 바이트 데이터의 최종 단위가 2 개 또는 3 개의 Base64 문자 (패딩 문자를 채우지 않은 채) 만 가진 경우에는 패딩 문자가 뒤 따르는 것처럼 디코딩됩니다. 최종 단위에 패딩 문자가 있으면 올바른 수의 패딩 문자가 있어야합니다. 그렇지 않으면 디코딩 중에 &lt;code&gt;IllegalArgumentException&lt;/code&gt; ( Base64 스트림에서 읽을 때 &lt;code&gt;IOException&lt;/code&gt; )이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7f2fa42fffaffc455185b2641418acb565381be2" translate="yes" xml:space="preserve">
          <source>The BasicPermission class extends the Permission class, and can be used as the base class for permissions that want to follow the same naming convention as BasicPermission.</source>
          <target state="translated">BasicPermission 클래스는 Permission 클래스를 확장하며 BasicPermission과 동일한 이름 지정 규칙을 따르려는 권한의 기본 클래스로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8109724094de0721a57a12d33075bebc3a6c1d9" translate="yes" xml:space="preserve">
          <source>The BasicReason enumerates the potential reasons that a certification path of any type may be invalid.</source>
          <target state="translated">BasicReason은 모든 유형의 인증 경로가 유효하지 않은 잠재적 이유를 열거합니다.</target>
        </trans-unit>
        <trans-unit id="7f2f07330207c79bdf9b8035cdfc8c33b0b86b6f" translate="yes" xml:space="preserve">
          <source>The BeanContext acts a logical hierarchical container for JavaBeans.</source>
          <target state="translated">BeanContext는 JavaBeans의 논리적 계층 컨테이너 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="db9f214e6794613d1af4a4bd16aca364a324671d" translate="yes" xml:space="preserve">
          <source>The BeanContextServices interface provides a mechanism for a BeanContext to expose generic &quot;services&quot; to the BeanContextChild objects within.</source>
          <target state="translated">BeanContextServices 인터페이스는 BeanContext가 일반 &quot;서비스&quot;를 BeanContextChild 객체에 노출 할 수있는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="28e60bfa8d3958dbf027cd9ce5a707ff9a06e8f0" translate="yes" xml:space="preserve">
          <source>The Bengali range with the Bengali digits.</source>
          <target state="translated">The Bengali range with the Bengali digits.</target>
        </trans-unit>
        <trans-unit id="61f473874cda4877ad49e4b4e18b2669d648bcfa" translate="yes" xml:space="preserve">
          <source>The BigInteger constant one.</source>
          <target state="translated">BigInteger 상수입니다.</target>
        </trans-unit>
        <trans-unit id="4fe20da433bea836e2620a8e5bd24465caa34b0d" translate="yes" xml:space="preserve">
          <source>The BigInteger constant ten.</source>
          <target state="translated">BigInteger 상수 10입니다.</target>
        </trans-unit>
        <trans-unit id="2ae94bca84a3b818bb066e53ab21fbe4a5a93bac" translate="yes" xml:space="preserve">
          <source>The BigInteger constant two.</source>
          <target state="translated">The BigInteger constant two.</target>
        </trans-unit>
        <trans-unit id="eaa19daee6ceb68fa207da723944fc65078e9b5c" translate="yes" xml:space="preserve">
          <source>The BigInteger constant zero.</source>
          <target state="translated">BigInteger 상수 0입니다.</target>
        </trans-unit>
        <trans-unit id="f2abfa8bc11f1cc0906af68cb43302c5e56e7dbc" translate="yes" xml:space="preserve">
          <source>The Boolean class wraps a value of the primitive type &lt;code&gt;boolean&lt;/code&gt; in an object.</source>
          <target state="translated">부울 클래스는 기본 유형의 &lt;code&gt;boolean&lt;/code&gt; 값을 객체에 래핑 합니다.</target>
        </trans-unit>
        <trans-unit id="d66eb41900b1a53b5e15c061f84c26f96aec8f20" translate="yes" xml:space="preserve">
          <source>The Boolean class wraps a value of the primitive type &lt;code&gt;boolean&lt;/code&gt; in an object. An object of type &lt;code&gt;Boolean&lt;/code&gt; contains a single field whose type is &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">부울 클래스는 기본 유형의 &lt;code&gt;boolean&lt;/code&gt; 값을 객체에 래핑 합니다. &lt;code&gt;Boolean&lt;/code&gt; 유형의 객체 에는 유형이 &lt;code&gt;boolean&lt;/code&gt; 인 단일 필드가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="81801484504e216b7fb284280633eaa1558a087c" translate="yes" xml:space="preserve">
          <source>The BoxLayout manager is constructed with an axis parameter that specifies the type of layout that will be done. There are four choices:</source>
          <target state="translated">The BoxLayout manager is constructed with an axis parameter that specifies the type of layout that will be done. There are four choices:</target>
        </trans-unit>
        <trans-unit id="bc0905838de7d1f34ab2990b1ad9e0ca39c77842" translate="yes" xml:space="preserve">
          <source>The Builder class for building the CatalogFeatures object.</source>
          <target state="translated">The Builder class for building the CatalogFeatures object.</target>
        </trans-unit>
        <trans-unit id="efc67a7d1a2c9c36bea385389f98ef36be245ba3" translate="yes" xml:space="preserve">
          <source>The CIEXYZ conversion color space defined above.</source>
          <target state="translated">The CIEXYZ conversion color space defined above.</target>
        </trans-unit>
        <trans-unit id="806e172d08d936be7f9a402bfc1b266638b44841" translate="yes" xml:space="preserve">
          <source>The CLA byte of the command APDU is automatically adjusted to match the channel number of this CardChannel.</source>
          <target state="translated">The CLA byte of the command APDU is automatically adjusted to match the channel number of this CardChannel.</target>
        </trans-unit>
        <trans-unit id="69ad751af3c43bdb33861e917a3b1c15e936c9cf" translate="yes" xml:space="preserve">
          <source>The COLUMN_SIZE column represents the specified column size for the given column. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. Null is returned for data types where the column size is not applicable.</source>
          <target state="translated">The COLUMN_SIZE column represents the specified column size for the given column. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. Null is returned for data types where the column size is not applicable.</target>
        </trans-unit>
        <trans-unit id="36a57ef1b9f6c643e2079cf370e0822f39c24fb7" translate="yes" xml:space="preserve">
          <source>The COLUMN_SIZE column specifies the column size for the given column. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. Null is returned for data types where the column size is not applicable.</source>
          <target state="translated">The COLUMN_SIZE column specifies the column size for the given column. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. Null is returned for data types where the column size is not applicable.</target>
        </trans-unit>
        <trans-unit id="730ba74f50d3f28436fa29f532e375e6c0695ab2" translate="yes" xml:space="preserve">
          <source>The CPU time provided by this interface has nanosecond precision but not necessarily nanosecond accuracy.</source>
          <target state="translated">이 인터페이스가 제공하는 CPU 시간은 나노초 정밀도이지만 반드시 나노초 정확도는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e8f7f2f7ff227a32e7a5531eecf91cf56365cd7f" translate="yes" xml:space="preserve">
          <source>The CRL or OCSP response cannot be obtained because of a network error.</source>
          <target state="translated">네트워크 오류로 인해 CRL 또는 OCSP 응답을 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7089d78e3e0c62b70041275bb433057c167f603b" translate="yes" xml:space="preserve">
          <source>The CRLReason enumeration specifies the reason that a certificate is revoked, as defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc5280&quot;&gt; RFC 5280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt;.</source>
          <target state="translated">The CRLReason enumeration specifies the reason that a certificate is revoked, as defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc5280&quot;&gt; RFC 5280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b4d351c3db241b4d379234c7ac2cb5765fab41d2" translate="yes" xml:space="preserve">
          <source>The CRLReason enumeration specifies the reason that a certificate is revoked, as defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280.txt&quot;&gt; RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt;.</source>
          <target state="translated">CRLReason 열거는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280.txt&quot;&gt;RFC 3280 : Internet X.509 공개 키 인프라 인증서 및 CRL 프로파일에&lt;/a&gt; 정의 된대로 인증서가 취소 된 이유를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="0eb967d9ac7761c67b21583f035b1b382621c4c9" translate="yes" xml:space="preserve">
          <source>The CRLReason enumeration specifies the reason that a certificate is revoked, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot;&gt; RFC 5280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt;.</source>
          <target state="translated">CRLReason 열거 형은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5280&quot;&gt;RFC 5280 : Internet X.509 Public Key Infrastructure Certificate and CRL Profile에&lt;/a&gt; 정의 된대로 인증서가 해지 된 이유를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="d15779cdaa6b6ad714a1c92e09167459cb6fc98f" translate="yes" xml:space="preserve">
          <source>The CSS rule that contains this declaration block or &lt;code&gt;null&lt;/code&gt; if this &lt;code&gt;CSSStyleDeclaration&lt;/code&gt; is not attached to a &lt;code&gt;CSSRule&lt;/code&gt;.</source>
          <target state="translated">이 선언 블록을 포함하는 CSS 규칙 또는 이 &lt;code&gt;CSSStyleDeclaration&lt;/code&gt; 이 &lt;code&gt;CSSRule&lt;/code&gt; 에 첨부되지 않은 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e7812130094f12985b55dbf55a811756b56e1df5" translate="yes" xml:space="preserve">
          <source>The CS_CIEXYZ space used by the toCIEXYZ/fromCIEXYZ methods can be described as follows:</source>
          <target state="translated">The CS_CIEXYZ space used by the toCIEXYZ/fromCIEXYZ methods can be described as follows:</target>
        </trans-unit>
        <trans-unit id="c9919c5ae2bcb3b9d6a077925318f690f537fce5" translate="yes" xml:space="preserve">
          <source>The Caps Lock key, a non-ASCII action key.</source>
          <target state="translated">The Caps Lock key, a non-ASCII action key.</target>
        </trans-unit>
        <trans-unit id="8e67b3c0835b7fe125721227039570d3711aedb5" translate="yes" xml:space="preserve">
          <source>The Catalog API defines a standard solution for resolving external resources referenced by XML documents. It is fully supported by the XML Processors allowing application developers to configure a catalog through an XML processor or system property or the jaxp.properties file to take advantage of the feature.</source>
          <target state="translated">The Catalog API defines a standard solution for resolving external resources referenced by XML documents. It is fully supported by the XML Processors allowing application developers to configure a catalog through an XML processor or system property or the jaxp.properties file to take advantage of the feature.</target>
        </trans-unit>
        <trans-unit id="8c3439a20de44e9f818a8524933afd2726aea753" translate="yes" xml:space="preserve">
          <source>The Catalog Features are supported throughout the JAXP processors, including SAX and DOM (&lt;a href=&quot;../parsers/package-summary&quot;&gt;&lt;code&gt;javax.xml.parsers&lt;/code&gt;&lt;/a&gt;), and StAX parsers (&lt;a href=&quot;../stream/package-summary&quot;&gt;&lt;code&gt;javax.xml.stream&lt;/code&gt;&lt;/a&gt;), Schema Validation (&lt;a href=&quot;../validation/package-summary&quot;&gt;&lt;code&gt;javax.xml.validation&lt;/code&gt;&lt;/a&gt;), and XML Transformation (&lt;a href=&quot;../transform/package-summary&quot;&gt;&lt;code&gt;javax.xml.transform&lt;/code&gt;&lt;/a&gt;). The features described above can be set through JAXP factories or processors that define a setProperty or setAttribute interface. For example, the following code snippet sets a URI to a catalog file on a SAX parser through the &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; property:</source>
          <target state="translated">The Catalog Features are supported throughout the JAXP processors, including SAX and DOM (&lt;a href=&quot;../parsers/package-summary&quot;&gt; &lt;code&gt;javax.xml.parsers&lt;/code&gt; &lt;/a&gt;), and StAX parsers (&lt;a href=&quot;../stream/package-summary&quot;&gt; &lt;code&gt;javax.xml.stream&lt;/code&gt; &lt;/a&gt;), Schema Validation (&lt;a href=&quot;../validation/package-summary&quot;&gt; &lt;code&gt;javax.xml.validation&lt;/code&gt; &lt;/a&gt;), and XML Transformation (&lt;a href=&quot;../transform/package-summary&quot;&gt; &lt;code&gt;javax.xml.transform&lt;/code&gt; &lt;/a&gt;). The features described above can be set through JAXP factories or processors that define a setProperty or setAttribute interface. For example, the following code snippet sets a URI to a catalog file on a SAX parser through the &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; property:</target>
        </trans-unit>
        <trans-unit id="f5c80cce7f8e24a12ba725dd3dd4f782aefcd3e2" translate="yes" xml:space="preserve">
          <source>The Catalog Manager manages the creation of XML Catalogs and Catalog Resolvers.</source>
          <target state="translated">The Catalog Manager manages the creation of XML Catalogs and Catalog Resolvers.</target>
        </trans-unit>
        <trans-unit id="385001113bb38abb20285d1ebb83df4d50340b14" translate="yes" xml:space="preserve">
          <source>The Catalog class represents an entity Catalog as defined by &lt;a href=&quot;https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html&quot;&gt; XML Catalogs, OASIS Standard V1.1, 7 October 2005&lt;/a&gt;.</source>
          <target state="translated">The Catalog class represents an entity Catalog as defined by &lt;a href=&quot;https://www.oasis-open.org/committees/download.php/14809/xml-catalogs.html&quot;&gt; XML Catalogs, OASIS Standard V1.1, 7 October 2005&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1909b728d3f1eea8632e5d9e1f0a292d2819745c" translate="yes" xml:space="preserve">
          <source>The Catalog support is available for any process in the JAXP library that supports a resolver. The following table lists all such processes.</source>
          <target state="translated">The Catalog support is available for any process in the JAXP library that supports a resolver. The following table lists all such processes.</target>
        </trans-unit>
        <trans-unit id="ed3ae395d6b192794b3d15b214dfe88f06d1d0b4" translate="yes" xml:space="preserve">
          <source>The CatalogFeatures holds a collection of features and properties.</source>
          <target state="translated">The CatalogFeatures holds a collection of features and properties.</target>
        </trans-unit>
        <trans-unit id="45bf43ea40ad206a16c91fe7538584c327d0aa28" translate="yes" xml:space="preserve">
          <source>The CatalogResolver however, will throw &lt;a href=&quot;catalogexception&quot;&gt;&lt;code&gt;CatalogException&lt;/code&gt;&lt;/a&gt; only when &lt;code&gt;javax.xml.catalog.resolve&lt;/code&gt; is specified as &lt;code&gt;strict&lt;/code&gt;. For applications that expect to handle the checked Exceptions, it may be necessary to use a custom resolver to wrap the CatalogResolver or implement it with a &lt;a href=&quot;catalog&quot;&gt;&lt;code&gt;Catalog&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">The CatalogResolver however, will throw &lt;a href=&quot;catalogexception&quot;&gt; &lt;code&gt;CatalogException&lt;/code&gt; &lt;/a&gt; only when &lt;code&gt;javax.xml.catalog.resolve&lt;/code&gt; is specified as &lt;code&gt;strict&lt;/code&gt; . For applications that expect to handle the checked Exceptions, it may be necessary to use a custom resolver to wrap the CatalogResolver or implement it with a &lt;a href=&quot;catalog&quot;&gt; &lt;code&gt;Catalog&lt;/code&gt; &lt;/a&gt; object.</target>
        </trans-unit>
        <trans-unit id="3c9da4fdbaba5f8c9f09732fa4d7f6d8a7c39639" translate="yes" xml:space="preserve">
          <source>The ChaCha20 and ChaCha20-Poly1305 algorithms have a similar requirement for unique nonces with a given key. After each encryption or decryption operation, callers should re-initialize their ChaCha20 or ChaCha20-Poly1305 ciphers with parameters that specify a different nonce value. Please see &lt;a href=&quot;https://tools.ietf.org/html/rfc7539&quot;&gt;RFC 7539&lt;/a&gt; for more information on the ChaCha20 and ChaCha20-Poly1305 algorithms.</source>
          <target state="translated">The ChaCha20 and ChaCha20-Poly1305 algorithms have a similar requirement for unique nonces with a given key. After each encryption or decryption operation, callers should re-initialize their ChaCha20 or ChaCha20-Poly1305 ciphers with parameters that specify a different nonce value. Please see &lt;a href=&quot;https://tools.ietf.org/html/rfc7539&quot;&gt;RFC 7539&lt;/a&gt; for more information on the ChaCha20 and ChaCha20-Poly1305 algorithms.</target>
        </trans-unit>
        <trans-unit id="b6a9e74f4885fe7cf70c23e4e55e9a31b16bb5b1" translate="yes" xml:space="preserve">
          <source>The Cham range with the Cham digits.</source>
          <target state="translated">The Cham range with the Cham digits.</target>
        </trans-unit>
        <trans-unit id="33f1a9e451f535334439b331e5952fb5eceaa417" translate="yes" xml:space="preserve">
          <source>The Character Encoding is not supported.</source>
          <target state="translated">문자 인코딩은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a47ec8afb6ab11bcf60e2a316aaa05ee5d6f88e" translate="yes" xml:space="preserve">
          <source>The Class Loader Repository used by the given MBeanServer.</source>
          <target state="translated">주어진 MBeanServer가 사용하는 클래스 로더 저장소</target>
        </trans-unit>
        <trans-unit id="004f0206b3d3d849c825f918d9b68ef429b3b940" translate="yes" xml:space="preserve">
          <source>The Class object for the bean's customizer. This may be null if the bean doesn't have a customizer.</source>
          <target state="translated">Bean 커 스터 마이저의 Class 객체. Bean에 사용자 정의 프로그램이없는 경우 널이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="537754527d3370203382836d7cb800a91b8ee729" translate="yes" xml:space="preserve">
          <source>The Class object for the bean.</source>
          <target state="translated">Bean의 클래스 오브젝트</target>
        </trans-unit>
        <trans-unit id="df1481dabe3eac178ff1405ee9b4259ce1e6e7a5" translate="yes" xml:space="preserve">
          <source>The Class object for the target interface that will get invoked when the event is fired.</source>
          <target state="translated">이벤트가 시작될 때 호출 될 대상 인터페이스의 Class 객체입니다.</target>
        </trans-unit>
        <trans-unit id="7eac5b9958cd8cfff4271334618aee040eeba806" translate="yes" xml:space="preserve">
          <source>The Class object representing the primitive type boolean.</source>
          <target state="translated">프리미티브 유형의 부울을 나타내는 Class 객체입니다.</target>
        </trans-unit>
        <trans-unit id="3618cc4f2a2349312e42daaa29d613987f1e092c" translate="yes" xml:space="preserve">
          <source>The ClassLoader that the module is defined to</source>
          <target state="translated">The ClassLoader that the module is defined to</target>
        </trans-unit>
        <trans-unit id="d40630063d92d99c85238befefd749074cac2197" translate="yes" xml:space="preserve">
          <source>The ClassLoader used for that MBean. If &lt;var&gt;l&lt;/var&gt; is the MBean's actual ClassLoader, and &lt;var&gt;r&lt;/var&gt; is the returned value, then either:</source>
          <target state="translated">해당 MBean에 사용되는 ClassLoader 경우 &lt;var&gt;l&lt;/var&gt; MBean에의 실제 클래스 로더이고, &lt;var&gt;r&lt;/var&gt; 은 다음 중 반환 된 값입니다 :</target>
        </trans-unit>
        <trans-unit id="66051b6d430a30f6ea7fd611d6e0df14e41ad561" translate="yes" xml:space="preserve">
          <source>The ClassLoaderRepository for this MBeanServer.</source>
          <target state="translated">이 MBeanServer의 ClassLoaderRepository입니다.</target>
        </trans-unit>
        <trans-unit id="2fd3574d8c10f0ef7d993b723f5632e342d0a6ee" translate="yes" xml:space="preserve">
          <source>The CodeBase and Signedby components of the triplet name/value pairs are optional. If they are not present, then any any codebase will match, and any signer (including unsigned code) will match. For Example,</source>
          <target state="translated">삼중 항 이름 / 값 쌍의 CodeBase 및 Signedby 구성 요소는 선택 사항입니다. 존재하지 않으면 모든 코드베이스가 일치하고 서명자 (서명되지 않은 코드 포함)가 일치합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c2d96326649dde95c7e44b0d7b9ed5f0eb24edde" translate="yes" xml:space="preserve">
          <source>The Color choice action identifier The color is passed as an argument</source>
          <target state="translated">The Color choice action identifier The color is passed as an argument</target>
        </trans-unit>
        <trans-unit id="9aefa3745661aac9f95067164415b6aba2584a76" translate="yes" xml:space="preserve">
          <source>The ColorType instance to use for specifying color printing.</source>
          <target state="translated">The ColorType instance to use for specifying color printing.</target>
        </trans-unit>
        <trans-unit id="fc12d050c25db30932a215afa844cd2c0a1f9907" translate="yes" xml:space="preserve">
          <source>The ColorType instance to use for specifying monochrome printing.</source>
          <target state="translated">The ColorType instance to use for specifying monochrome printing.</target>
        </trans-unit>
        <trans-unit id="a1a553cf69cfe6ca631789fbb350d1c4c807cf8f" translate="yes" xml:space="preserve">
          <source>The Component that the @{code ComboBoxEditor} uses for editing.</source>
          <target state="translated">The Component that the @{code ComboBoxEditor} uses for editing.</target>
        </trans-unit>
        <trans-unit id="227d796281ad0577957a4e31b0889941847041af" translate="yes" xml:space="preserve">
          <source>The Component this DragGestureRecognizer is associated with</source>
          <target state="translated">The Component this DragGestureRecognizer is associated with</target>
        </trans-unit>
        <trans-unit id="d6129cd0df87476b144f9ae72f10280b8502d399" translate="yes" xml:space="preserve">
          <source>The Component this label is for; null if the label is not the label for a component</source>
          <target state="translated">The Component this label is for; null if the label is not the label for a component</target>
        </trans-unit>
        <trans-unit id="8e16e6d4e4c40d6ee7cab533803dc66da6417071" translate="yes" xml:space="preserve">
          <source>The Component will receive drops only if it is enabled.</source>
          <target state="translated">The Component will receive drops only if it is enabled.</target>
        </trans-unit>
        <trans-unit id="e75fddc976a61c1460b567593850ec1eade9d839" translate="yes" xml:space="preserve">
          <source>The ComponentOrientation class encapsulates the language-sensitive orientation that is to be used to order the elements of a component or of text.</source>
          <target state="translated">The ComponentOrientation class encapsulates the language-sensitive orientation that is to be used to order the elements of a component or of text.</target>
        </trans-unit>
        <trans-unit id="0c349a7e3983834131e43d6005575c88312a4af1" translate="yes" xml:space="preserve">
          <source>The ComponentOrientation class encapsulates the language-sensitive orientation that is to be used to order the elements of a component or of text. It is used to reflect the differences in this ordering between Western alphabets, Middle Eastern (such as Hebrew), and Far Eastern (such as Japanese).</source>
          <target state="translated">The ComponentOrientation class encapsulates the language-sensitive orientation that is to be used to order the elements of a component or of text. It is used to reflect the differences in this ordering between Western alphabets, Middle Eastern (such as Hebrew), and Far Eastern (such as Japanese).</target>
        </trans-unit>
        <trans-unit id="9aa38dfbce4b5e4d29c524de8b044dfa3c6e2aa9" translate="yes" xml:space="preserve">
          <source>The Connection representing the bi-directional communication channel to the target VM.</source>
          <target state="translated">대상 VM에 대한 양방향 통신 채널을 나타내는 연결입니다.</target>
        </trans-unit>
        <trans-unit id="5789b4c7dbeca56610041c215040cd828abe15bd" translate="yes" xml:space="preserve">
          <source>The ConnectionBuilder instance that was created</source>
          <target state="translated">The ConnectionBuilder instance that was created</target>
        </trans-unit>
        <trans-unit id="88c73e6550e83b79c38c378eb869baa98b113ae7" translate="yes" xml:space="preserve">
          <source>The ContentHandler that is to be transformation output.</source>
          <target state="translated">The ContentHandler that is to be transformation output.</target>
        </trans-unit>
        <trans-unit id="17423c94f8f2ce034afcc39cef2cb4df86197b19" translate="yes" xml:space="preserve">
          <source>The Control key extended modifier constant.</source>
          <target state="translated">The Control key extended modifier constant.</target>
        </trans-unit>
        <trans-unit id="d1ab2b838d9028c98dee874736d7f5d9ec2c600c" translate="yes" xml:space="preserve">
          <source>The Control key modifier constant.</source>
          <target state="translated">The Control key modifier constant.</target>
        </trans-unit>
        <trans-unit id="fdf0e01cafa9c24fd0c1cae4915a688195d8ef89" translate="yes" xml:space="preserve">
          <source>The Counter value.</source>
          <target state="translated">카운터 값입니다.</target>
        </trans-unit>
        <trans-unit id="69e37ac36977091dd5dd589e3937201a303cc9c9" translate="yes" xml:space="preserve">
          <source>The DGC abstraction is used for the server side of the distributed garbage collection algorithm.</source>
          <target state="translated">The DGC abstraction is used for the server side of the distributed garbage collection algorithm.</target>
        </trans-unit>
        <trans-unit id="bed07d1e948423e4a8940850acf00fea1b04ba74" translate="yes" xml:space="preserve">
          <source>The DGC abstraction is used for the server side of the distributed garbage collection algorithm. This interface contains the two methods: dirty and clean. A dirty call is made when a remote reference is unmarshaled in a client (the client is indicated by its VMID). A corresponding clean call is made when no more references to the remote reference exist in the client. A failed dirty call must schedule a strong clean call so that the call's sequence number can be retained in order to detect future calls received out of order by the distributed garbage collector. A reference to a remote object is leased for a period of time by the client holding the reference. The lease period starts when the dirty call is received. It is the client's responsibility to renew the leases, by making additional dirty calls, on the remote references it holds before such leases expire. If the client does not renew the lease before it expires, the distributed garbage collector assumes that the remote object is no longer referenced by that client.</source>
          <target state="translated">The DGC abstraction is used for the server side of the distributed garbage collection algorithm. This interface contains the two methods: dirty and clean. A dirty call is made when a remote reference is unmarshaled in a client (the client is indicated by its VMID). A corresponding clean call is made when no more references to the remote reference exist in the client. A failed dirty call must schedule a strong clean call so that the call's sequence number can be retained in order to detect future calls received out of order by the distributed garbage collector. A reference to a remote object is leased for a period of time by the client holding the reference. The lease period starts when the dirty call is received. It is the client's responsibility to renew the leases, by making additional dirty calls, on the remote references it holds before such leases expire. If the client does not renew the lease before it expires, the distributed garbage collector assumes that the remote object is no longer referenced by that client.</target>
        </trans-unit>
        <trans-unit id="7d83f00558a7ea5fd54e20050b4b87aeb295129d" translate="yes" xml:space="preserve">
          <source>The DOM Core does not support editing &lt;code&gt;Notation&lt;/code&gt; nodes; they are therefore readonly.</source>
          <target state="translated">The DOM Core does not support editing &lt;code&gt;Notation&lt;/code&gt; nodes; they are therefore readonly.</target>
        </trans-unit>
        <trans-unit id="43530ca2de642f60fb45cbf08c7d48675f2f6e1a" translate="yes" xml:space="preserve">
          <source>The DOM Core represents all attribute values as simple strings, even if the DTD or schema associated with the document declares them of some specific type such as tokenized.</source>
          <target state="translated">The DOM Core represents all attribute values as simple strings, even if the DTD or schema associated with the document declares them of some specific type such as tokenized.</target>
        </trans-unit>
        <trans-unit id="1199d22f6ddd51766a7301391a2be8379e37ab04" translate="yes" xml:space="preserve">
          <source>The DOM Level 2 does not support editing entities, therefore &lt;code&gt;entities&lt;/code&gt; cannot be altered in any way.</source>
          <target state="translated">The DOM Level 2 does not support editing entities, therefore &lt;code&gt;entities&lt;/code&gt; cannot be altered in any way.</target>
        </trans-unit>
        <trans-unit id="c8bb5a095cdbe93e8badd4f90d462b85913dc20b" translate="yes" xml:space="preserve">
          <source>The DOM Level 2 does not support editing notations, therefore &lt;code&gt;notations&lt;/code&gt; cannot be altered in any way.</source>
          <target state="translated">The DOM Level 2 does not support editing notations, therefore &lt;code&gt;notations&lt;/code&gt; cannot be altered in any way.</target>
        </trans-unit>
        <trans-unit id="38aa50df9727b894588dbbc35c05e27ae364fb85" translate="yes" xml:space="preserve">
          <source>The DOM does not provide any filters. &lt;code&gt;NodeFilter&lt;/code&gt; is just an interface that users can implement to provide their own filters.</source>
          <target state="translated">The DOM does not provide any filters. &lt;code&gt;NodeFilter&lt;/code&gt; is just an interface that users can implement to provide their own filters.</target>
        </trans-unit>
        <trans-unit id="df7387b1fd60bcbca923e30e23e97edc8aba858f" translate="yes" xml:space="preserve">
          <source>The DOM implementation is expected to use the attribute &lt;code&gt;Attr.isId&lt;/code&gt; to determine if an attribute is of type ID.</source>
          <target state="translated">DOM 구현은 속성이 ID 유형인지 확인하기 위해 &lt;code&gt;Attr.isId&lt;/code&gt; 속성을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="261049d3d4a4937744f0dafd0f1e3545c9ba8678" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to ANY</source>
          <target state="translated">DTD 상수는 ANY에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="8c0b4e5d9b4605e3158ab4842fcd5983e5fb8dd8" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to CDATA</source>
          <target state="translated">DTD 상수는 CDATA에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="28996f14fa52b071fff9da5038251a1e16777136" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to CONREF</source>
          <target state="translated">DTD 상수는 CONREF에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f70e3a438499a724f3e9b5b8faacae04267c9342" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to CURRENT</source>
          <target state="translated">DTD 상수는 CURRENT에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="7462581804069a243f9c87bece58e662cb9bbd5a" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to DEFAULT</source>
          <target state="translated">DTD 상수는 DEFAULT에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="c5d9608e6bca1b6ed6581eea2cd2e05102db06db" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to EMPTY</source>
          <target state="translated">DTD 상수는 EMPTY에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="ba76c731eea210411652ded92b544523f559f8cf" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to ENDTAG</source>
          <target state="translated">DTD 상수는 ENDTAG에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="b037b57b7b4055d8226d80e6b35f4dd61693ff9f" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to ENTITIES</source>
          <target state="translated">DTD 상수는 ENTITIES에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="8c124dba0aabae007ca78f786c43238803deb8de" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to ENTITY</source>
          <target state="translated">DTD 상수는 ENTITY에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="92bfbbfc06b21dd3f552573a10a0382a8a8b166c" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to FIXED</source>
          <target state="translated">DTD 상수는 FIXED에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d0730aee51ad3d5e3c5d358c5486abb58f57b053" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to GENERAL</source>
          <target state="translated">DTD 상수는 GENERAL에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d512f886dc03b5f4056a96d2ee1b6e8d93d6234f" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to ID</source>
          <target state="translated">DTD 상수는 ID에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="c82b046bea18e9a490fb2a44c0258368ed834626" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to IDREF</source>
          <target state="translated">DTD 상수는 IDREF에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="6385c232cbf5970b321152ba72e8ec4b8bf03880" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to IDREFS</source>
          <target state="translated">DTD 상수는 IDREFS에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d27662c44dc624358badebfa3780410f2185d572" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to IMPLIED</source>
          <target state="translated">DTD 상수는 IMPLIED에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="0bb5d1554124f83a103f88151731450f51e29063" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to MD</source>
          <target state="translated">DTD 상수는 MD에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="9e2a110f1661c64c646c0d75fca1fd31b10c0d7b" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to MODEL</source>
          <target state="translated">DTD 상수는 MODEL에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="217e0e2fe34e949d8d212ae8100c329e2798959d" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to MS</source>
          <target state="translated">DTD 상수는 MS에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="210401b9f4da9fb6620b3dfe9a679b8ba982571f" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NAME</source>
          <target state="translated">DTD 상수는 NAME에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d059f6bc57570668211b615f9ec763ce6c011d33" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NAMES</source>
          <target state="translated">DTD 상수는 NAMES에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="08d23b2ba3d9d4c0170e8dceb590345eef62e898" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NMTOKEN</source>
          <target state="translated">DTD 상수는 NMTOKEN에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="43e5d6fd6f35ae58bb647fdbe002079d0ef4e79c" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NMTOKENS</source>
          <target state="translated">DTD 상수는 NMTOKENS에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4d3d6809165f3ec86156d0455227d9f935592dc6" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NOTATION</source>
          <target state="translated">DTD 상수는 NOTATION에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="c82aa0c7d66e7bfc1ad232cd78fa3ee3b3837ca2" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NUMBER</source>
          <target state="translated">DTD 상수는 NUMBER에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f6dcc9ece8551b878b9dbb942a5c4193aafd677b" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NUMBERS</source>
          <target state="translated">DTD 상수는 NUMBERS에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="0f4c355ec8195dd5f3a4b693d27573962d42907a" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NUTOKEN</source>
          <target state="translated">DTD 상수는 NUTOKEN에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="464cfae6e349c057b8352dc2ee53bd2e0ce2c4d2" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to NUTOKENS</source>
          <target state="translated">DTD 상수는 NUTOKENS에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f530150f84f7ecb1f890a8d98900f43e6e96c04a" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to PARAMETER</source>
          <target state="translated">DTD 상수는 PARAMETER에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="2b88e73f94ceff69a11fb44af74e03c994ab76c6" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to PI</source>
          <target state="translated">DTD 상수는 PI에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a793a8ddc64beceb41e4cb80ca28fff3889db1b7" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to PUBLIC</source>
          <target state="translated">DTD 상수는 PUBLIC에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4f40a4668a58a1e30057b305854e48fe8a85cb6e" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to RCDATA</source>
          <target state="translated">DTD 상수는 RCDATA에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="594edcbb019633ce1e15d7afb490d0bfd587095c" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to REQUIRED</source>
          <target state="translated">DTD 상수는 REQUIRED에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="3941302d7f73508bc2f880765e67c45b860abdd3" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to SDATA</source>
          <target state="translated">DTD 상수는 SDATA에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="7659fc2638f54b5b97b669423f51591f41e6dd65" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to STARTTAG</source>
          <target state="translated">DTD 상수는 STARTTAG에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="2b30fe032c549b0fe7db4de6e7c9c64ffab5c023" translate="yes" xml:space="preserve">
          <source>The DTD constant corresponds to SYSTEM</source>
          <target state="translated">DTD 상수는 SYSTEM에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="2ced5dc3156a8a4a80da644c296c6141e4689e3c" translate="yes" xml:space="preserve">
          <source>The DTD specification is provided as Appendix A to the Java Logging APIs specification.</source>
          <target state="translated">DTD 사양은 Java Logging API 사양의 부록 A로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a7f4a801e7fcf309a447907757a88537413eb4aa" translate="yes" xml:space="preserve">
          <source>The DataBuffer that stores the image data.</source>
          <target state="translated">이미지 데이터를 저장하는 DataBuffer입니다.</target>
        </trans-unit>
        <trans-unit id="9b8dc3e1ba53caad2f4dafd2ec2d61e42595250b" translate="yes" xml:space="preserve">
          <source>The Delete key.</source>
          <target state="translated">Delete 키입니다.</target>
        </trans-unit>
        <trans-unit id="c016969447ee027a7d4e0c0671983d0d54d60bd4" translate="yes" xml:space="preserve">
          <source>The Descriptor fields contributed in this way by different annotations on the same program element must be consistent. That is, two different annotations, or two members of the same annotation, must not define a different value for the same Descriptor field. Fields from annotations on a getter method must also be consistent with fields from annotations on the corresponding setter method.</source>
          <target state="translated">설명자 필드는 동일한 프로그램 요소에 대해 다른 주석으로 이러한 방식으로 기여해야합니다. 즉, 두 개의 서로 다른 주석 또는 동일한 주석의 두 구성원이 동일한 설명자 필드에 대해 다른 값을 정의해서는 안됩니다. getter 메소드의 주석 필드는 해당 setter 메소드의 주석 필드와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bb6cc0ddd226d41211cd3043455d41114d7cede" translate="yes" xml:space="preserve">
          <source>The Descriptor resulting from these annotations will be merged with any Descriptor fields provided by the implementation, such as the &lt;a href=&quot;descriptor#immutableInfo&quot;&gt;&lt;code&gt;
 immutableInfo&lt;/code&gt;&lt;/a&gt; field for an MBean. The fields from the annotations must be consistent with these fields provided by the implementation.</source>
          <target state="translated">이러한 어노테이션의 결과 인 Descriptor 는 MBean 의 &lt;a href=&quot;descriptor#immutableInfo&quot;&gt; &lt;code&gt; immutableInfo&lt;/code&gt; &lt;/a&gt; 필드 와 같이 구현에서 제공하는 Descriptor 필드와 병합됩니다 . 주석의 필드는 구현에서 제공하는 이러한 필드와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6bee60701b79c62232ecee0abd5ca5f3df40a69c" translate="yes" xml:space="preserve">
          <source>The Descriptor resulting from these annotations will be merged with any Descriptor fields provided by the implementation, such as the &lt;a href=&quot;descriptor#immutableInfo&quot;&gt;&lt;code&gt;immutableInfo&lt;/code&gt;&lt;/a&gt; field for an MBean. The fields from the annotations must be consistent with these fields provided by the implementation.</source>
          <target state="translated">이러한 주석의 결과 인 Descriptor 는 MBean 의 &lt;a href=&quot;descriptor#immutableInfo&quot;&gt; &lt;code&gt;immutableInfo&lt;/code&gt; &lt;/a&gt; 필드 와 같이 구현에서 제공 한 모든 Descriptor 필드와 병합됩니다 . 주석의 필드는 구현에서 제공 한 이러한 필드와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="2264cfb97c49339ec2eb79ff8f9c5b3541970253" translate="yes" xml:space="preserve">
          <source>The Devanagari range with the Devanagari digits.</source>
          <target state="translated">Devanagari 숫자가있는 Devanagari 범위입니다.</target>
        </trans-unit>
        <trans-unit id="c9d5aea86dc06f534995783c5eed783935bbadb9" translate="yes" xml:space="preserve">
          <source>The Directory Context</source>
          <target state="translated">디렉토리 컨텍스트</target>
        </trans-unit>
        <trans-unit id="ccd7ed731b050c5d2f46c1cbaf69cfad44e1f050" translate="yes" xml:space="preserve">
          <source>The Doclet API provides an environment which, in conjunction with the Language Model API and Compiler Tree API, allows clients to inspect the source-level structures of programs and libraries, including API comments embedded in the source.</source>
          <target state="translated">Doclet API는 언어 모델 API 및 컴파일러 트리 API와 함께 클라이언트가 소스에 포함 된 API 주석을 포함하여 프로그램 및 라이브러리의 소스 수준 구조를 검사 할 수있는 환경을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e6ee01f1cfdc49d30867413241b4a4694ea090f" translate="yes" xml:space="preserve">
          <source>The Document Type Declaration (see &lt;code&gt;DocumentType&lt;/code&gt;) associated with this document.</source>
          <target state="translated">이 문서 와 관련된 문서 유형 선언 ( &lt;code&gt;DocumentType&lt;/code&gt; 참조 )입니다.</target>
        </trans-unit>
        <trans-unit id="254ccb37fffeb4d7034d09aace0490d444a1fd8d" translate="yes" xml:space="preserve">
          <source>The Document Type Declaration (see &lt;code&gt;DocumentType&lt;/code&gt;) associated with this document. For XML documents without a document type declaration this returns &lt;code&gt;null&lt;/code&gt;. For HTML documents, a &lt;code&gt;DocumentType&lt;/code&gt; object may be returned, independently of the presence or absence of document type declaration in the HTML document.</source>
          <target state="translated">이 문서 와 관련된 문서 유형 선언 ( &lt;code&gt;DocumentType&lt;/code&gt; 참조 )입니다. 문서 유형 선언이없는 XML 문서의 경우 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . HTML 문서의 경우 HTML 문서 에 문서 유형 선언이 있는지 여부와 관계없이 &lt;code&gt;DocumentType&lt;/code&gt; 객체가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="299aad74666cf0fc920de73b7ea77abf7fe4b895" translate="yes" xml:space="preserve">
          <source>The Document interface is responsible for translating a linear view of the characters into Element operations. It is up to each Document implementation to define what the Element structure is.</source>
          <target state="translated">문서 인터페이스는 문자의 선형보기를 요소 작업으로 변환하는 역할을합니다. 요소 구조가 무엇인지 정의하는 것은 각 문서 구현에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="60d54d249addf311d02c8ca2ce1ec1e6177cdf46" translate="yes" xml:space="preserve">
          <source>The DocumentEvent notification is based upon the JavaBeans event model. There is no guarantee about the order of delivery to listeners, and all listeners must be notified prior to making further mutations to the Document. &lt;em&gt;This means implementations of the DocumentListener may not mutate the source of the event (i.e. the associated Document)&lt;/em&gt;.</source>
          <target state="translated">DocumentEvent 알림은 JavaBeans 이벤트 모델을 기반으로합니다. 청취자에게 전달되는 순서에 대한 보장은 없으며 문서를 추가로 변경하기 전에 모든 청취자에게 알려야합니다. &lt;em&gt;이는 DocumentListener의 구현이 이벤트의 소스 (즉, 관련 문서)를 변경할 수 없음을 의미합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="306e0349e4730fe12ea20a18564d5aded0a959d4" translate="yes" xml:space="preserve">
          <source>The DocumentTypeDefinition is written to the output</source>
          <target state="translated">DocumentTypeDefinition이 출력에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d62abb5465a5124d177e3dae735859f7772db3a7" translate="yes" xml:space="preserve">
          <source>The Down Arrow key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 작업 키인 아래쪽 화살표 키입니다.</target>
        </trans-unit>
        <trans-unit id="535a8c59d3fc6ca72816c57f9fe3cb8a0847b806" translate="yes" xml:space="preserve">
          <source>The DriverManager will try to load as many drivers as it can find and then for any given connection request, it will ask each driver in turn to try to connect to the target URL.</source>
          <target state="translated">DriverManager는 찾을 수있는만큼의 드라이버를로드하려고 시도한 다음 지정된 연결 요청에 대해 차례로 각 드라이버에 대상 URL에 연결을 시도하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="d5be8afdbc6e1810cc1d91e507cb42ef9c4a1bf6" translate="yes" xml:space="preserve">
          <source>The Ed25519 parameters</source>
          <target state="translated">Ed25519 매개 변수</target>
        </trans-unit>
        <trans-unit id="6b245864c9b4d42dd27fe5d8994f419c7c656fd7" translate="yes" xml:space="preserve">
          <source>The Ed448 parameters</source>
          <target state="translated">Ed448 매개 변수</target>
        </trans-unit>
        <trans-unit id="9908e26b6e54260393c71d3b6feaa03992ee4047" translate="yes" xml:space="preserve">
          <source>The End key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 조치 키인 종료 키.</target>
        </trans-unit>
        <trans-unit id="82569fedc0af6f3aed7f65a6a3fe39ea20b67c7c" translate="yes" xml:space="preserve">
          <source>The Enter key.</source>
          <target state="translated">Enter 키입니다.</target>
        </trans-unit>
        <trans-unit id="9467ddc0b1822e3f422eef8fbcd692138357cb1f" translate="yes" xml:space="preserve">
          <source>The ErrorManager's &quot;error&quot; method will be invoked if any errors occur while using this Handler.</source>
          <target state="translated">이 핸들러를 사용하는 동안 오류가 발생하면 ErrorManager의 &quot;error&quot;메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="337111c58074fe3c7a3c0c5188b4a34f626e799a" translate="yes" xml:space="preserve">
          <source>The Escape key.</source>
          <target state="translated">Esc 키입니다.</target>
        </trans-unit>
        <trans-unit id="855ec55237c438b93c6ece3595fe96fed3e0fe47" translate="yes" xml:space="preserve">
          <source>The Ethiopic range with the Ethiopic digits.</source>
          <target state="translated">에티오피아 숫자가있는 에티오피아 범위입니다.</target>
        </trans-unit>
        <trans-unit id="c4abdb2c97b7ad28fbff4b44ab36d6a6f3821d59" translate="yes" xml:space="preserve">
          <source>The Ethiopic range with the Ethiopic digits. Ethiopic does not have a decimal digit 0 so Latin (European) 0 is used.</source>
          <target state="translated">에티오피아 숫자가있는 에티오피아 범위입니다. 에티오피아에는 10 진수 0이 없으므로 라틴 (유럽) 0이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f846f27691c1830b0c4862884909ba741da0054f" translate="yes" xml:space="preserve">
          <source>The F1 function key, a non-ASCII action key.</source>
          <target state="translated">F1 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="e0c99ce79d7c1cf5f028270fbbd639ed83b660bf" translate="yes" xml:space="preserve">
          <source>The F10 function key, a non-ASCII action key.</source>
          <target state="translated">F10 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="34b95e3d41adccd87cc4a5447e94b0969fdf7692" translate="yes" xml:space="preserve">
          <source>The F11 function key, a non-ASCII action key.</source>
          <target state="translated">F11 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="4712072dec079034a0d1d72b4ea1e0bd718589b7" translate="yes" xml:space="preserve">
          <source>The F12 function key, a non-ASCII action key.</source>
          <target state="translated">F12 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="8f3e6133006f60f80467d379477797cb8466f921" translate="yes" xml:space="preserve">
          <source>The F2 function key, a non-ASCII action key.</source>
          <target state="translated">F2 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="8cba0d95d956dcad6261f3c860b0b98ddb8261bd" translate="yes" xml:space="preserve">
          <source>The F3 function key, a non-ASCII action key.</source>
          <target state="translated">F3 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="688fc8033a58b76724aa1e69114742ef26b5aea2" translate="yes" xml:space="preserve">
          <source>The F4 function key, a non-ASCII action key.</source>
          <target state="translated">F4 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="424aca125a04f4c0ca7b024f4f463806f8d801e0" translate="yes" xml:space="preserve">
          <source>The F5 function key, a non-ASCII action key.</source>
          <target state="translated">F5 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="75137fe57f42039f646febcef40c10236bd497b2" translate="yes" xml:space="preserve">
          <source>The F6 function key, a non-ASCII action key.</source>
          <target state="translated">F6 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="32df2a32958042664970351ad3ceae10e39b1214" translate="yes" xml:space="preserve">
          <source>The F7 function key, a non-ASCII action key.</source>
          <target state="translated">F7 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="04f2191aa3813883fac7f747c758351877d2dbd7" translate="yes" xml:space="preserve">
          <source>The F8 function key, a non-ASCII action key.</source>
          <target state="translated">F8 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="1822ce331e4a2923ad9c29fc3b0f664d404ea2c6" translate="yes" xml:space="preserve">
          <source>The F9 function key, a non-ASCII action key.</source>
          <target state="translated">F9 기능 키, 비 ASCII 조치 키.</target>
        </trans-unit>
        <trans-unit id="4d4c7427ed03e2196382cf762ac3a454fd9aad30" translate="yes" xml:space="preserve">
          <source>The FeatureDescriptor class is the common baseclass for PropertyDescriptor, EventSetDescriptor, and MethodDescriptor, etc.</source>
          <target state="translated">FeatureDescriptor 클래스는 PropertyDescriptor, EventSetDescriptor 및 MethodDescriptor 등의 공통 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="5eae005357491fca42dd8644ffbb9527bcbf6e2a" translate="yes" xml:space="preserve">
          <source>The File Upload, Image Read, and Socket Read events happen concurrently (in the same thread), but the events are in different categories so they do not overlap in the visualization.</source>
          <target state="translated">파일 업로드, 이미지 읽기 및 소켓 읽기 이벤트는 동시에 (동일한 스레드에서) 발생하지만 이벤트는 다른 범주에 있으므로 시각화에서 겹치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e02d9b92b748aa46a1fe40c56191a70c2db37b1" translate="yes" xml:space="preserve">
          <source>The ForkJoinTask class is not usually directly subclassed. Instead, you subclass one of the abstract classes that support a particular style of fork/join processing, typically &lt;a href=&quot;recursiveaction&quot;&gt;&lt;code&gt;RecursiveAction&lt;/code&gt;&lt;/a&gt; for most computations that do not return results, &lt;a href=&quot;recursivetask&quot;&gt;&lt;code&gt;RecursiveTask&lt;/code&gt;&lt;/a&gt; for those that do, and &lt;a href=&quot;countedcompleter&quot;&gt;&lt;code&gt;CountedCompleter&lt;/code&gt;&lt;/a&gt; for those in which completed actions trigger other actions. Normally, a concrete ForkJoinTask subclass declares fields comprising its parameters, established in a constructor, and then defines a &lt;code&gt;compute&lt;/code&gt; method that somehow uses the control methods supplied by this base class.</source>
          <target state="translated">ForkJoinTask 클래스는 일반적으로 직접 서브 클래스가 아닙니다. 대신, 포크의 특정 스타일을 지원하는 추상 클래스의 당신 서브 클래스 하나가 / 처리, 일반적으로 가입 &lt;a href=&quot;recursiveaction&quot;&gt; &lt;code&gt;RecursiveAction&lt;/code&gt; 을&lt;/a&gt; 결과를 반환하지 않는 대부분의 계산에, &lt;a href=&quot;recursivetask&quot;&gt; &lt;code&gt;RecursiveTask&lt;/code&gt; &lt;/a&gt; 할 것들, 그리고에 대한 &lt;a href=&quot;countedcompleter&quot;&gt; &lt;code&gt;CountedCompleter&lt;/code&gt; &lt;/a&gt; 하는 사람들을 위해이 행동이 다른 작업을 실행 완료. 일반적으로, 구체적인 ForkJoinTask 서브 클래스는 생성자에서 설정된 해당 매개 변수를 포함하는 필드를 선언 한 다음 이 기본 클래스가 제공하는 제어 메소드를 사용 하는 &lt;code&gt;compute&lt;/code&gt; 메소드 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="b623035f5596637c9505afc931878e7c86c5b5b2" translate="yes" xml:space="preserve">
          <source>The GCM specification states that &lt;code&gt;tLen&lt;/code&gt; may only have the values {128, 120, 112, 104, 96}, or {64, 32} for certain applications. Other values can be specified for this class, but not all CSP implementations will support them.</source>
          <target state="translated">GCM 사양은 &lt;code&gt;tLen&lt;/code&gt; 이 특정 응용 프로그램에 대해 {128, 120, 112, 104, 96} 또는 {64, 32} 값만 가질 수 있다고 명시하고 있습니다. 이 클래스에 다른 값을 지정할 수 있지만 모든 CSP 구현이이를 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="21c0818ef96710144df08a551d7b266882d023aa" translate="yes" xml:space="preserve">
          <source>The GIF image writer plug-in guarantees lossless writing for images which meet the following requirements:</source>
          <target state="translated">GIF 이미지 작성기 플러그인은 다음 요구 사항을 충족하는 이미지에 대한 무손실 쓰기를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="69631d7c8bd6040a091b247bf1496d5ed878fb6f" translate="yes" xml:space="preserve">
          <source>The GIF image writer plug-in supports setting output stream metadata from metadata supplied to the writer in either the native GIF stream metadata format  javax_imageio_gif_stream_1.0  or the standard metadata format  javax_imageio_1.0, and setting output image metadata from metadata supplied to the writer in either the native GIF image metadata format  javax_imageio_gif_image_1.0  or the standard metadata format javax_imageio_1.0. The mapping of standard metadata format to the GIF native stream and image metadata formats is given in the tables  here .</source>
          <target state="translated">GIF 이미지 작성기 플러그인은 기본 GIF 스트림 메타 데이터 형식 javax_imageio_gif_stream_1.0 또는 표준 메타 데이터 형식 javax_imageio_1.0에서 작성기에 제공되는 메타 데이터의 출력 스트림 메타 데이터 설정을 지원합니다. 기본 GIF 이미지 메타 데이터 형식 javax_imageio_gif_image_1.0 또는 표준 메타 데이터 형식 javax_imageio_1.0 중 하나입니다. 표준 메타 데이터 형식을 GIF 기본 스트림 및 이미지 메타 데이터 형식으로 매핑하는 방법은 여기 표에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a39c518ab297860c2f8783913dcca7c6af3666c" translate="yes" xml:space="preserve">
          <source>The GIF image writer plug-in supports setting output stream metadata from metadata supplied to the writer in either the native GIF stream metadata format &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#gif_stream_metadata_format&quot;&gt; javax_imageio_gif_stream_1.0&lt;/a&gt; or the standard metadata format &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/standard_metadata.html&quot;&gt;javax_imageio_1.0&lt;/a&gt;, and setting output image metadata from metadata supplied to the writer in either the native GIF image metadata format &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#gif_image_metadata_format&quot;&gt; javax_imageio_gif_image_1.0&lt;/a&gt; or the standard metadata format &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/standard_metadata.html&quot;&gt;javax_imageio_1.0&lt;/a&gt;. The mapping of standard metadata format to the GIF native stream and image metadata formats is given in the tables &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#mapping&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">GIF 이미지 작성기 플러그인은 기본 GIF 스트림 메타 데이터 형식 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#gif_stream_metadata_format&quot;&gt;javax_imageio_gif_stream_1.0&lt;/a&gt; 또는 표준 메타 데이터 형식 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/standard_metadata.html&quot;&gt;javax_imageio_1.0&lt;/a&gt; 으로 작성기에 제공된 메타 데이터의 출력 스트림 메타 데이터 설정 및 작성기에 제공된 메타 데이터의 출력 이미지 메타 데이터 설정을 지원합니다. 네이티브 GIF 이미지 메타 데이터 형식 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#gif_image_metadata_format&quot;&gt;javax_imageio_gif_image_1.0&lt;/a&gt; 또는 표준 메타 데이터 형식 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/standard_metadata.html&quot;&gt;javax_imageio_1.0&lt;/a&gt; . 표준 메타 데이터 형식과 GIF 네이티브 스트림 및 이미지 메타 데이터 형식의 매핑은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#mapping&quot;&gt;여기&lt;/a&gt; 표에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5740adefc67787e6cc87a34eb2ef2353c96debd5" translate="yes" xml:space="preserve">
          <source>The GIF image writer plug-in supports setting output stream metadata from metadata supplied to the writer in either the native GIF stream metadata format &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#gif_stream_metadata_format&quot;&gt; javax_imageio_gif_stream_1.0&lt;/a&gt; or the standard metadata format &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/javax/imageio/metadata/doc-files/standard_metadata.html&quot;&gt;javax_imageio_1.0&lt;/a&gt;, and setting output image metadata from metadata supplied to the writer in either the native GIF image metadata format &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#gif_image_metadata_format&quot;&gt; javax_imageio_gif_image_1.0&lt;/a&gt; or the standard metadata format &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/javax/imageio/metadata/doc-files/standard_metadata.html&quot;&gt;javax_imageio_1.0&lt;/a&gt;. The mapping of standard metadata format to the GIF native stream and image metadata formats is given in the tables &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#mapping&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">GIF 이미지 작성기 플러그인은 기본 GIF 스트림 메타 데이터 형식 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#gif_stream_metadata_format&quot;&gt;javax_imageio_gif_stream_1.0&lt;/a&gt; 또는 표준 메타 데이터 형식 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/javax/imageio/metadata/doc-files/standard_metadata.html&quot;&gt;javax_imageio_1.0&lt;/a&gt; 으로 작성기에 제공된 메타 데이터의 출력 스트림 메타 데이터 설정 및 작성기에 제공된 메타 데이터의 출력 이미지 메타 데이터 설정을 지원합니다. 네이티브 GIF 이미지 메타 데이터 형식 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#gif_image_metadata_format&quot;&gt;javax_imageio_gif_image_1.0&lt;/a&gt; 또는 표준 메타 데이터 형식 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/javax/imageio/metadata/doc-files/standard_metadata.html&quot;&gt;javax_imageio_1.0&lt;/a&gt; . 표준 메타 데이터 형식과 GIF 네이티브 스트림 및 이미지 메타 데이터 형식의 매핑은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/javax/imageio/metadata/doc-files/gif_metadata.html#mapping&quot;&gt;여기&lt;/a&gt; 표에 나와 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fe47dfc42c1004ae9afdedd5c749c38a37ee470" translate="yes" xml:space="preserve">
          <source>The GIF writer plug-in supports the creation of animated GIF images through the standard sequence writing methods defined in the &lt;code&gt;ImageWriter&lt;/code&gt; class.</source>
          <target state="translated">GIF 작성기 플러그인은 &lt;code&gt;ImageWriter&lt;/code&gt; 클래스에 정의 된 표준 시퀀스 작성 방법을 통해 애니메이션 GIF 이미지 작성을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="36041d90b5051a2148ab5cf02c46a6972de006b3" translate="yes" xml:space="preserve">
          <source>The GSS-API authentication tokens contain a definitive start and end. This method will attempt to read one of these tokens per invocation, and may block on the stream if only part of the token is available. In all other respects this method is equivalent to the byte array based &lt;a href=&quot;#acceptSecContext(byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;acceptSecContext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GSS-API 인증 토큰은 명확한 시작과 끝을 포함합니다. 이 메서드는 호출 당 이러한 토큰 중 하나를 읽으려고 시도하고 토큰의 일부만 사용할 수있는 경우 스트림에서 차단할 수 있습니다. 다른 모든 측면에서이 메소드는 &lt;a href=&quot;#acceptSecContext(byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;acceptSecContext&lt;/code&gt; &lt;/a&gt; 기반의 바이트 배열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="56846475ff5ecbb5782e2832cfad2417350c183f" translate="yes" xml:space="preserve">
          <source>The GSS-API authentication tokens contain a definitive start and end. This method will attempt to read one of these tokens per invocation, and may block on the stream if only part of the token is available. In all other respects this method is equivalent to the byte array based &lt;a href=&quot;#initSecContext(byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;initSecContext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">GSS-API 인증 토큰은 명확한 시작과 끝을 포함합니다. 이 메서드는 호출 당 이러한 토큰 중 하나를 읽으려고 시도하고 토큰의 일부만 사용할 수있는 경우 스트림에서 차단할 수 있습니다. 다른 모든 측면에서이 메서드는 &lt;a href=&quot;#initSecContext(byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;initSecContext&lt;/code&gt; &lt;/a&gt; 기반의 바이트 배열과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="eeb819a0af8bbcd4715be7fc89a01023347f013f" translate="yes" xml:space="preserve">
          <source>The GSS-API does not perform any communication with the peer. It merely produces tokens that the application must somehow transport to the other end.</source>
          <target state="translated">GSS-API는 피어와의 통신을 수행하지 않습니다. 애플리케이션이 어떻게 든 다른 쪽 끝으로 전송해야하는 토큰을 생성 할뿐입니다.</target>
        </trans-unit>
        <trans-unit id="016e2418772c7bef7110806243864d9ad960cfde" translate="yes" xml:space="preserve">
          <source>The GSS-API is defined in a language independent way in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2743.txt&quot;&gt;RFC 2743&lt;/a&gt;. The Java language bindings are defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2853.txt&quot;&gt;RFC 2853&lt;/a&gt;</source>
          <target state="translated">GSS-API는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2743.txt&quot;&gt;RFC 2743&lt;/a&gt; 에서 언어 독립적 인 방식으로 정의됩니다 . Java 언어 바인딩은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2853.txt&quot;&gt;RFC 2853에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec3c90701fefb3ca12b6d1850be7012d813ae214" translate="yes" xml:space="preserve">
          <source>The GSS-API is defined in a language independent way in &lt;a href=&quot;https://www.ietf.org/rfc/rfc2743.txt&quot;&gt;RFC 2743&lt;/a&gt;. The Java language bindings are defined in &lt;a href=&quot;https://www.ietf.org/rfc/rfc2853.txt&quot;&gt;RFC 2853&lt;/a&gt;</source>
          <target state="translated">GSS-API는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2743.txt&quot;&gt;RFC 2743&lt;/a&gt; 에서 언어 독립적 인 방식으로 정의됩니다 . Java 언어 바인딩은 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2853.txt&quot;&gt;RFC 2853에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bda69e49cc0677094f88eb85a8d0e079496d764" translate="yes" xml:space="preserve">
          <source>The GSS-API itself does not dictate how an underlying mechanism obtains the credentials that are needed for authentication. It is assumed that prior to calling the GSS-API, these credentials are obtained and stored in a location that the mechanism provider is aware of. However, the default model in the Java platform will be that mechanism providers must obtain credentials only from the private or public credential sets associated with the &lt;a href=&quot;../../../../java.base/javax/security/auth/subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt; in the current access control context. The Kerberos v5 mechanism will search for the required INITIATE and ACCEPT credentials (&lt;a href=&quot;../../../javax/security/auth/kerberos/kerberosticket&quot;&gt;&lt;code&gt;KerberosTicket&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../javax/security/auth/kerberos/kerberoskey&quot;&gt;&lt;code&gt;KerberosKey&lt;/code&gt;&lt;/a&gt;) in the private credential set where as some other mechanism might look in the public set or in both. If the desired credential is not present in the appropriate sets of the current Subject, the GSS-API call must fail.</source>
          <target state="translated">GSS-API 자체는 기본 메커니즘이 인증에 필요한 자격 증명을 얻는 방법을 지시하지 않습니다. GSS-API를 호출하기 전에 이러한 자격 증명을 획득하여 메커니즘 공급자가 알고있는 위치에 저장한다고 가정합니다. 그러나 Java 플랫폼의 기본 모델은 메커니즘 제공자가 현재 액세스 제어 컨텍스트 의 &lt;a href=&quot;../../../../java.base/javax/security/auth/subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt; 와 연관된 개인 또는 공용 자격 증명 세트에서만 자격 증명을 가져와야한다는 것 입니다. Kerberos v5 메커니즘은 필요한 INITIATE 및 ACCEPT 자격 증명 ( &lt;a href=&quot;../../../javax/security/auth/kerberos/kerberosticket&quot;&gt; &lt;code&gt;KerberosTicket&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../javax/security/auth/kerberos/kerberoskey&quot;&gt; &lt;code&gt;KerberosKey&lt;/code&gt; )을 검색합니다.&lt;/a&gt;) 다른 메커니즘이 공개 세트 또는 둘 다에서 볼 수있는 개인 자격 증명 세트에서. 원하는 자격 증명이 현재 주제의 적절한 집합에 없으면 GSS-API 호출이 실패해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e36671f93a675a82883cad4ce03c74c37680a15" translate="yes" xml:space="preserve">
          <source>The GSSManager would then first check with B if m1 was needed. In case B did not provide support for m1, the GSSManager would continue on to check with A. If any mechanism m2 is needed where m2 is different from m1 then the GSSManager would skip B and check with A directly.</source>
          <target state="translated">그런 다음 GSSManager는 먼저 m1이 필요한지 B와 함께 확인합니다. B가 m1에 대한 지원을 제공하지 않은 경우 GSSManager는 계속해서 A와 확인합니다. m2가 m1과 다른 m2 메커니즘이 필요한 경우 GSSManager는 B를 건너 뛰고 A와 직접 확인합니다.</target>
        </trans-unit>
        <trans-unit id="78d03db12c1f011d0634db41f691571762f77a53" translate="yes" xml:space="preserve">
          <source>The GSSName name class contains public static Oid objects representing the standard name types defined in GSS-API.</source>
          <target state="translated">GSSName 이름 클래스에는 GSS-API에 정의 된 표준 이름 유형을 나타내는 공용 정적 Oid 개체가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c0eb54612e1b91b3d550046715cc18734cac067" translate="yes" xml:space="preserve">
          <source>The Generated annotation is used to mark source code that has been generated.</source>
          <target state="translated">생성 된 주석은 생성 된 소스 코드를 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f56c3c8627f80ee0eab3cf06dab68a8edf476a84" translate="yes" xml:space="preserve">
          <source>The Generated annotation is used to mark source code that has been generated. It can also be used to differentiate user written code from generated code in a single file.</source>
          <target state="translated">생성 된 주석은 생성 된 소스 코드를 표시하는 데 사용됩니다. 또한 사용자가 작성한 코드와 단일 파일에서 생성 된 코드를 구별하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e14d8067e3c65f5d662592905874e96a639ba661" translate="yes" xml:space="preserve">
          <source>The Generated annotation is used to mark source code that has been generated. It can also be used to differentiate user written code from generated code in a single file. When used, the value element must have the name of the code generator. The recommended convention is to use the fully qualified name of the code generator in the value field .</source>
          <target state="translated">생성 된 주석은 생성 된 소스 코드를 표시하는 데 사용됩니다. 또한 사용자가 작성한 코드와 생성 된 코드를 단일 파일로 구별하는 데 사용할 수 있습니다. 사용될 때 value 요소는 코드 생성기의 이름을 가져야합니다. 권장되는 규칙은 값 필드에 완전한 코드 생성기 이름을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7af39d750477e1f9f73af9fe47ad7493425adbba" translate="yes" xml:space="preserve">
          <source>The Grand Unification of the above three.</source>
          <target state="translated">위의 세 가지 대 통일.</target>
        </trans-unit>
        <trans-unit id="04a51ed5fc80fe55a7d442756d529463d0e7f962" translate="yes" xml:space="preserve">
          <source>The GraphicAttribute determines the logical and visual bounds of the text; the actual Font values are ignored.</source>
          <target state="translated">GraphicAttribute는 텍스트의 논리적 및 시각적 경계를 결정합니다. 실제 글꼴 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="80dc94d54b402ab87a3bcf626574c928999dab0b" translate="yes" xml:space="preserve">
          <source>The Gujarati range with the Gujarati digits.</source>
          <target state="translated">Gujarati 숫자가있는 Gujarati 범위입니다.</target>
        </trans-unit>
        <trans-unit id="3204f255d6bf3f20cea1af9b6db821aaebbf6fe0" translate="yes" xml:space="preserve">
          <source>The Gurmukhi range with the Gurmukhi digits.</source>
          <target state="translated">Gurmukhi 숫자가있는 Gurmukhi 범위입니다.</target>
        </trans-unit>
        <trans-unit id="ceab662b8e5ed03e8ac9d3c0a5ad31c99a49f29f" translate="yes" xml:space="preserve">
          <source>The HTML document body.</source>
          <target state="translated">HTML 문서 본문입니다.</target>
        </trans-unit>
        <trans-unit id="9656fd250eadbedcc38887eb760be79e35c0770b" translate="yes" xml:space="preserve">
          <source>The HTML document body. This element is always present in the DOM API, even if the tags are not present in the source document. See the BODY element definition in HTML 4.0.</source>
          <target state="translated">HTML 문서 본문입니다. 이 요소는 소스 문서에 태그가없는 경우에도 항상 DOM API에 있습니다. HTML 4.0의 BODY 요소 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="034f52c179ed2f285aff346a1a725164486ab642" translate="yes" xml:space="preserve">
          <source>The HTTP cookie management in java.net package looks like:</source>
          <target state="translated">java.net 패키지의 HTTP 쿠키 관리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b3a512be37bd12625c3a8628efd22b37676aac1" translate="yes" xml:space="preserve">
          <source>The HTTP method (GET,POST,PUT,etc.).</source>
          <target state="translated">HTTP 메소드 (GET, POST, PUT 등)</target>
        </trans-unit>
        <trans-unit id="45069240481f167a4b1839f87d58530261cd8d54" translate="yes" xml:space="preserve">
          <source>The HTTP protocol handler has a few settings that can be accessed through System Properties. This covers &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/doc-files/net-properties.html#Proxies&quot;&gt;Proxy settings&lt;/a&gt; as well as &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/doc-files/net-properties.html#MiscHTTP&quot;&gt; various other settings&lt;/a&gt;.</source>
          <target state="translated">HTTP 프로토콜 처리기에는 시스템 속성을 통해 액세스 할 수있는 몇 가지 설정이 있습니다. 여기에는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/doc-files/net-properties.html#Proxies&quot;&gt;프록시 설정&lt;/a&gt; 과 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/doc-files/net-properties.html#MiscHTTP&quot;&gt;다양한 기타 설정이 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f75c91eee430b4e549a8250d151e91afa72d2dad" translate="yes" xml:space="preserve">
          <source>The HTTP protocol handler has a few settings that can be accessed through System Properties. This covers &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/net/doc-files/net-properties.html#Proxies&quot;&gt;Proxy settings&lt;/a&gt; as well as &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/net/doc-files/net-properties.html#MiscHTTP&quot;&gt; various other settings&lt;/a&gt;.</source>
          <target state="translated">HTTP 프로토콜 처리기에는 시스템 속성을 통해 액세스 할 수있는 몇 가지 설정이 있습니다. 여기에는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/net/doc-files/net-properties.html#Proxies&quot;&gt;프록시 설정&lt;/a&gt; 과 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/net/doc-files/net-properties.html#MiscHTTP&quot;&gt;다양한 기타 설정이 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="2d94af71e4f20cb6dbee51f81cf708d34fd43e9a" translate="yes" xml:space="preserve">
          <source>The HTTP protocol handler has a few settings that can be accessed through System Properties. This covers Proxy settings as well as  various other settings.</source>
          <target state="translated">HTTP 프로토콜 핸들러에는 시스템 속성을 통해 액세스 할 수있는 몇 가지 설정이 있습니다. 여기에는 프록시 설정 및 기타 다양한 설정이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5cddb7cac72e4320c7958e414281c0eaaa74294f" translate="yes" xml:space="preserve">
          <source>The HTTP protocol version.</source>
          <target state="translated">HTTP 프로토콜 버전입니다.</target>
        </trans-unit>
        <trans-unit id="0965d22a7cf7456f138f50ade9b626d2ce1a8ce8" translate="yes" xml:space="preserve">
          <source>The HTTP response message.</source>
          <target state="translated">HTTP 응답 메시지</target>
        </trans-unit>
        <trans-unit id="342acebe15f32e49ce73e2666488d1f7edf89d4a" translate="yes" xml:space="preserve">
          <source>The Highlighter bound to the associated text component is used to render the selection by default. Selection appearance can be customized by supplying a painter to use for the highlights. By default a painter is used that will render a solid color as specified in the associated text component in the &lt;code&gt;SelectionColor&lt;/code&gt; property. This can easily be changed by reimplementing the &lt;a href=&quot;#getSelectionPainter()&quot;&gt;&lt;code&gt;getSelectionPainter&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">연결된 텍스트 구성 요소에 바인딩 된 형광펜은 기본적으로 선택 항목을 렌더링하는 데 사용됩니다. 하이라이트에 사용할 페인터를 제공하여 선택 모양을 사용자 지정할 수 있습니다. 기본적으로 &lt;code&gt;SelectionColor&lt;/code&gt; 속성 의 관련 텍스트 구성 요소에 지정된 단색을 렌더링하는 페인터가 사용됩니다 . 이는 &lt;a href=&quot;#getSelectionPainter()&quot;&gt; &lt;code&gt;getSelectionPainter&lt;/code&gt; &lt;/a&gt; 메소드 를 다시 구현하여 쉽게 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76c37afd4ebfca43ecc7113a9e735aed8c4a4c59" translate="yes" xml:space="preserve">
          <source>The Hijrah calendar has a different total of days in a year than Gregorian calendar, and the length of each month is based on the period of a complete revolution of the moon around the earth (as between successive new moons). Refer to the &lt;a href=&quot;hijrahchronology&quot;&gt;&lt;code&gt;HijrahChronology&lt;/code&gt;&lt;/a&gt; for details of supported variants.</source>
          <target state="translated">히즈라 달력은 그레고리력과는 달리 일 년에 총 일수가 다르며, 매월의 길이는 지구 주위의 달이 완전히 혁명적 인 기간 (연속적인 새 달 사이)에 기초합니다. 지원되는 변형에 대한 자세한 내용은 &lt;a href=&quot;hijrahchronology&quot;&gt; &lt;code&gt;HijrahChronology&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cbb0a5265ed2b32362a56646ea33dae11e8ddd1" translate="yes" xml:space="preserve">
          <source>The Hijrah calendar is a lunar calendar supporting Islamic calendars.</source>
          <target state="translated">Hijrah 달력은 이슬람 달력을 지원하는 음력입니다.</target>
        </trans-unit>
        <trans-unit id="5ef062b6d3746a7faa9fd4ff82681d5f88437d55" translate="yes" xml:space="preserve">
          <source>The Hijrah calendar system has one era, 'AH', defined by &lt;a href=&quot;hijrahera&quot;&gt;&lt;code&gt;HijrahEra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Hijrah 달력 시스템에는 &lt;a href=&quot;hijrahera&quot;&gt; &lt;code&gt;HijrahEra&lt;/code&gt; 에&lt;/a&gt; 의해 정의 된 'AH'시대가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e597c41e9fa5f54ee9b2548de5fc25d85b9400b7" translate="yes" xml:space="preserve">
          <source>The Hijrah calendar system has only one era covering the proleptic years greater than zero.</source>
          <target state="translated">Hijrah 달력 시스템은 0보다 큰 발화 년을 다루는 시대가 단 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="8c7bf054691c4990879f32b517b7eb5c7c8f7c31" translate="yes" xml:space="preserve">
          <source>The Hijrah property resource is a set of properties that describe the calendar. The syntax is defined by &lt;code&gt;java.util.Properties#load(Reader)&lt;/code&gt;.</source>
          <target state="translated">Hijrah 속성 리소스는 달력을 설명하는 속성 집합입니다. 구문은 &lt;code&gt;java.util.Properties#load(Reader)&lt;/code&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d5f51089d0f9a89148d7f6f56fbc17a08c3c7dd" translate="yes" xml:space="preserve">
          <source>The HijrahChronology follows the rules of the Hijrah calendar system. The Hijrah calendar has several variants based on differences in when the new moon is determined to have occurred and where the observation is made. In some variants the length of each month is computed algorithmically from the astronomical data for the moon and earth and in others the length of the month is determined by an authorized sighting of the new moon. For the algorithmically based calendars the calendar can project into the future. For sighting based calendars only historical data from past sightings is available.</source>
          <target state="translated">HijrahChronology는 Hijrah 일정 시스템의 규칙을 따릅니다. Hijrah 달력에는 초승달이 발생한 것으로 판단 된 시점과 관측 지점의 차이에 따라 여러 가지 변형이 있습니다. 어떤 변형에서, 달과 지구에 대한 천문학적 데이터로부터 각 달의 길이는 알고리즘에 의해 계산되고, 다른 달에서 달의 길이는 승인 된 초승달 관찰에 의해 결정된다. 알고리즘 기반 캘린더의 경우 캘린더는 미래로 투사 할 수 있습니다. 시력 기반 달력의 경우 과거 시력의 과거 데이터 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e24e34ecc8a9ad3b4e4ea87309f75a1db55428a1" translate="yes" xml:space="preserve">
          <source>The Home key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 조치 키인 홈 키.</target>
        </trans-unit>
        <trans-unit id="b30101cf2f801668711691b72956c848b7ff79c7" translate="yes" xml:space="preserve">
          <source>The IANA charset registry does change over time, and so the canonical name and the aliases of a particular charset may also change over time. To ensure compatibility it is recommended that no alias ever be removed from a charset, and that if the canonical name of a charset is changed then its previous canonical name be made into an alias.</source>
          <target state="translated">IANA 문자 집합 레지스트리는 시간이 지남에 따라 변경되므로 특정 문자 집합의 정식 이름과 별칭도 시간이 지남에 따라 변경 될 수 있습니다. 호환성을 보장하기 위해 문자 집합에서 별칭을 제거하지 말고 문자 집합의 정식 이름을 변경하면 이전 정식 이름을 별칭으로 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41785330378e3e8d34f692fda2997c106c6be24f" translate="yes" xml:space="preserve">
          <source>The ICC standard uses a device independent color space (DICS) as the mechanism for converting color from one device to another device. In this architecture, colors are converted from the source device's color space to the ICC DICS and then from the ICC DICS to the destination device's color space. The ICC standard defines device profiles which contain transforms which will convert between a device's color space and the ICC DICS. The overall conversion of colors from a source device to colors of a destination device is done by connecting the device-to-DICS transform of the profile for the source device to the DICS-to-device transform of the profile for the destination device. For this reason, the ICC DICS is commonly referred to as the profile connection space (PCS). The color space used in the methods &lt;code&gt;toCIEXYZ&lt;/code&gt; and &lt;code&gt;fromCIEXYZ&lt;/code&gt; is the CIEXYZ PCS defined by the ICC Specification. This is also the color space represented by &lt;code&gt;ColorSpace.CS_CIEXYZ&lt;/code&gt;.</source>
          <target state="translated">ICC 표준은 한 장치에서 다른 장치로 색상을 변환하는 메커니즘으로 DICS (장치 독립 색상 공간)를 사용합니다. 이 아키텍처에서 색상은 소스 장치의 색상 공간에서 ICC DICS로 변환 된 다음 ICC DICS에서 대상 장치의 색상 공간으로 변환됩니다. ICC 표준은 장치의 색상 공간과 ICC DICS간에 변환되는 변환을 포함하는 장치 프로필을 정의합니다. 소스 장치에서 대상 장치의 색상으로의 전체 색상 변환은 소스 장치에 대한 프로필의 장치 대 DICS 변환을 대상 장치에 대한 프로필의 DICS 대 장치 변환에 연결하여 수행됩니다. 이러한 이유로 ICC DICS를 일반적으로 PCS (프로파일 연결 공간)라고합니다. &lt;code&gt;toCIEXYZ&lt;/code&gt; 메소드에서 사용되는 색 공간그리고 &lt;code&gt;fromCIEXYZ&lt;/code&gt; ICC는 규격에 의해 정의 된 CIEXYZ PCS이다. 이것은 &lt;code&gt;ColorSpace.CS_CIEXYZ&lt;/code&gt; 로 표현되는 색 공간이기도합니다 .</target>
        </trans-unit>
        <trans-unit id="4291d010a17ade250e32deaae43f97dfb3a7ba1f" translate="yes" xml:space="preserve">
          <source>The ICC standard uses a device independent color space (DICS) as the mechanism for converting color from one device to another device. In this architecture, colors are converted from the source device's color space to the ICC DICS and then from the ICC DICS to the destination device's color space. The ICC standard defines device profiles which contain transforms which will convert between a device's color space and the ICC DICS. The overall conversion of colors from a source device to colors of a destination device is done by connecting the device-to-DICS transform of the profile for the source device to the DICS-to-device transform of the profile for the destination device. For this reason, the ICC DICS is commonly referred to as the profile connection space (PCS). The color space used in the methods toCIEXYZ and fromCIEXYZ is the CIEXYZ PCS defined by the ICC Specification. This is also the color space represented by ColorSpace.CS_CIEXYZ.</source>
          <target state="translated">ICC 표준은 한 장치에서 다른 장치로 색상을 변환하는 메커니즘으로 DICS (장치 독립 색상 공간)를 사용합니다. 이 아키텍처에서 색상은 소스 장치의 색상 공간에서 ICC DICS로 변환 된 다음 ICC DICS에서 대상 장치의 색상 공간으로 변환됩니다. ICC 표준은 장치의 색상 공간과 ICC DICS간에 변환되는 변환을 포함하는 장치 프로필을 정의합니다. 소스 장치에서 대상 장치의 색상으로의 전체 색상 변환은 소스 장치에 대한 프로필의 장치 대 DICS 변환을 대상 장치에 대한 프로필의 DICS 대 장치 변환에 연결하여 수행됩니다. 이러한 이유로 ICC DICS를 일반적으로 PCS (프로파일 연결 공간)라고합니다.toCIEXYZ 및 fromCIEXYZ 메서드에서 사용되는 색 공간은 ICC 사양에 정의 된 CIEXYZ PCS입니다. 이것은 ColorSpace.CS_CIEXYZ로 표현되는 색 공간이기도합니다.</target>
        </trans-unit>
        <trans-unit id="e6b1df547566cde6967819973372499ee99ddb22" translate="yes" xml:space="preserve">
          <source>The ICC_ColorSpace class is an implementation of the abstract ColorSpace class.</source>
          <target state="translated">ICC_ColorSpace 클래스는 추상 ColorSpace 클래스의 구현입니다.</target>
        </trans-unit>
        <trans-unit id="29a4fdfa37a516d2928ce968cabea4dcd82635e5" translate="yes" xml:space="preserve">
          <source>The ICC_ColorSpace class is an implementation of the abstract ColorSpace class. This representation of device independent and device dependent color spaces is based on the International Color Consortium Specification ICC.1:2001-12, File Format for Color Profiles (see &lt;a href=&quot;http://www.color.org&quot;&gt;http://www.color.org&lt;/a&gt;).</source>
          <target state="translated">ICC_ColorSpace 클래스는 추상 ColorSpace 클래스의 구현입니다. 장치 독립 및 장치 종속 색상 공간의이 표현은 International Color Consortium Specification ICC.1 : 2001-12, File Format for Color Profiles ( &lt;a href=&quot;http://www.color.org&quot;&gt;http://www.color.org 참조&lt;/a&gt; )를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="72f3ceadbe13561989c9f7b18cd300f66f00b9cf" translate="yes" xml:space="preserve">
          <source>The ICC_ProfileRGB class is a subclass of the ICC_Profile class that represents profiles which meet the following criteria:</source>
          <target state="translated">ICC_ProfileRGB 클래스는 다음 기준을 충족하는 프로필을 나타내는 ICC_Profile 클래스의 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="46384c6ea74d47171799bd6ab4946e6155803a9f" translate="yes" xml:space="preserve">
          <source>The ICC_ProfileRGB class is a subclass of the ICC_Profile class that represents profiles which meet the following criteria: The profile's color space type is RGB. The profile includes the &lt;code&gt;redColorantTag&lt;/code&gt;, &lt;code&gt;greenColorantTag&lt;/code&gt;, &lt;code&gt;blueColorantTag&lt;/code&gt;, &lt;code&gt;redTRCTag&lt;/code&gt;, &lt;code&gt;greenTRCTag&lt;/code&gt;, &lt;code&gt;blueTRCTag&lt;/code&gt;, and &lt;code&gt;mediaWhitePointTag&lt;/code&gt; tags. The &lt;code&gt;ICC_Profile getInstance&lt;/code&gt; method will return an &lt;code&gt;ICC_ProfileRGB&lt;/code&gt; object when these conditions are met.</source>
          <target state="translated">ICC_ProfileRGB 클래스는 다음 기준을 충족하는 프로필을 나타내는 ICC_Profile 클래스의 하위 클래스입니다. 프로필의 색 공간 유형은 RGB입니다. 프로필에는 &lt;code&gt;redColorantTag&lt;/code&gt; , &lt;code&gt;greenColorantTag&lt;/code&gt; , &lt;code&gt;blueColorantTag&lt;/code&gt; , &lt;code&gt;redTRCTag&lt;/code&gt; , &lt;code&gt;greenTRCTag&lt;/code&gt; , &lt;code&gt;blueTRCTag&lt;/code&gt; 및 &lt;code&gt;mediaWhitePointTag&lt;/code&gt; 태그가 포함됩니다. &lt;code&gt;ICC_Profile getInstance&lt;/code&gt; 메소드가 리턴 &lt;code&gt;ICC_ProfileRGB&lt;/code&gt; 의 이러한 조건이 충족 될 때 개체를.</target>
        </trans-unit>
        <trans-unit id="237b13a4a1d88dd1cd58b5de8b3676b6a2af1c85" translate="yes" xml:space="preserve">
          <source>The ID is a unique identifier for the type in the Java Virtual Machine (JVM). The ID might not be the same between JVM instances.</source>
          <target state="translated">ID는 JVM (Java Virtual Machine)의 유형에 대한 고유 식별자입니다. ID는 JVM 인스턴스간에 동일하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a09a7c491e42ec0ccd6087606b59441de1f0715c" translate="yes" xml:space="preserve">
          <source>The ID is minor variation to the standard ISO-8601 formatted string for the offset. There are three formats:</source>
          <target state="translated">ID는 오프셋에 대한 표준 ISO-8601 형식 문자열과 약간 다릅니다. 세 가지 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d29cb73c296776b288211b97e00b807749e9b2d0" translate="yes" xml:space="preserve">
          <source>The ID is unique within the system. There are three types of ID.</source>
          <target state="translated">ID는 시스템 내에서 고유합니다. ID에는 세 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8452b5eaac842a0d2e795c7eda14cf159816708e" translate="yes" xml:space="preserve">
          <source>The ID might not be the same between JVM instances.</source>
          <target state="translated">ID는 JVM 인스턴스간에 동일하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e455bd7cf49d3abbf675e3850b6bdcd9bb42c4a" translate="yes" xml:space="preserve">
          <source>The ID might not be the same between Java Virtual Machine (JVM) instances.</source>
          <target state="translated">JVM (Java Virtual Machine) 인스턴스간에 ID가 동일하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae854760d3f4276cd755511e493cc5a51b830e12" translate="yes" xml:space="preserve">
          <source>The ID of the listener to which the notification is targeted.</source>
          <target state="translated">알림의 대상이되는 리스너의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="01ee2510bd3aca83bad9699f7e3b7df60b473549" translate="yes" xml:space="preserve">
          <source>The ID of the returned offset will be normalized to one of the formats described by &lt;a href=&quot;#getId()&quot;&gt;&lt;code&gt;getId()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 오프셋의 ID는 &lt;a href=&quot;#getId()&quot;&gt; &lt;code&gt;getId()&lt;/code&gt; &lt;/a&gt; 설명 된 형식 중 하나로 정규화됩니다 .</target>
        </trans-unit>
        <trans-unit id="61fd4732cbe2e01752b6c8cf6a30f14f6ab40119" translate="yes" xml:space="preserve">
          <source>The ID of the returned offset will be normalized to one of the formats described by &lt;a href=&quot;zoneoffset#getId--&quot;&gt;&lt;code&gt;getId()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 된 오프셋의 ID는 &lt;a href=&quot;zoneoffset#getId--&quot;&gt; &lt;code&gt;getId()&lt;/code&gt; &lt;/a&gt; 설명 된 형식 중 하나로 정규화됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c8cb46fd48547fa630e300fcba11829a98c4159" translate="yes" xml:space="preserve">
          <source>The ID of the thread that owns the object that the thread is blocked.</source>
          <target state="translated">스레드가 차단 된 오브젝트를 소유 한 스레드의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="4bed910017ae47e15f9fd68ce9f4a7a2eb621fdb" translate="yes" xml:space="preserve">
          <source>The ID uniquely identifies the &lt;code&gt;Chronology&lt;/code&gt;. It can be used to lookup the &lt;code&gt;Chronology&lt;/code&gt; using &lt;a href=&quot;#of(java.lang.String)&quot;&gt;&lt;code&gt;of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ID는 &lt;code&gt;Chronology&lt;/code&gt; 고유하게 식별합니다 . &lt;a href=&quot;#of(java.lang.String)&quot;&gt; &lt;code&gt;of(String)&lt;/code&gt; &lt;/a&gt; 사용 하여 &lt;code&gt;Chronology&lt;/code&gt; 를 조회하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbbbed4ad86feca80f73d8a6ba6de9c29be78a79" translate="yes" xml:space="preserve">
          <source>The ID uniquely identifies the &lt;code&gt;Chronology&lt;/code&gt;. It can be used to lookup the &lt;code&gt;Chronology&lt;/code&gt; using &lt;a href=&quot;chronology#of(java.lang.String)&quot;&gt;&lt;code&gt;Chronology.of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ID는 &lt;code&gt;Chronology&lt;/code&gt; 고유하게 식별합니다 . 이는 조회하는데 사용될 수있다 &lt;code&gt;Chronology&lt;/code&gt; 사용 &lt;a href=&quot;chronology#of(java.lang.String)&quot;&gt; &lt;code&gt;Chronology.of(String)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd6d60e60fa86ec5a78289385fee6d0f6bc1bdd6" translate="yes" xml:space="preserve">
          <source>The ID uniquely identifies the &lt;code&gt;Chronology&lt;/code&gt;. It can be used to lookup the &lt;code&gt;Chronology&lt;/code&gt; using &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt;&lt;code&gt;Chronology.of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ID는 &lt;code&gt;Chronology&lt;/code&gt; 고유하게 식별합니다 . 이는 조회하는데 사용될 수있다 &lt;code&gt;Chronology&lt;/code&gt; 사용 &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt; &lt;code&gt;Chronology.of(String)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1cafcec37d18d1f40c55857c337e84b388be6a4b" translate="yes" xml:space="preserve">
          <source>The ID uniquely identifies the &lt;code&gt;Chronology&lt;/code&gt;. It can be used to lookup the &lt;code&gt;Chronology&lt;/code&gt; using &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt;&lt;code&gt;of(String)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ID는 &lt;code&gt;Chronology&lt;/code&gt; 고유하게 식별합니다 . &lt;a href=&quot;chronology#of-java.lang.String-&quot;&gt; &lt;code&gt;of(String)&lt;/code&gt; &lt;/a&gt; 사용 하여 &lt;code&gt;Chronology&lt;/code&gt; 를 조회하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eec3d7c57ef5447e9bdebab954ee90700a2a652d" translate="yes" xml:space="preserve">
          <source>The IP address of the remote end of this socket.</source>
          <target state="translated">이 소켓의 리모트 엔드의 IP 주소</target>
        </trans-unit>
        <trans-unit id="510660eb55dda01e452a05872bd22f9cfe584483" translate="yes" xml:space="preserve">
          <source>The IPv6-address is a literal IPv6 address as described above. The</source>
          <target state="translated">IPv6- 주소는 위에서 설명한 리터럴 IPv6 주소입니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="4679bfab8bdf1a02bfe30406e4c9f7a2085873a2" translate="yes" xml:space="preserve">
          <source>The ISO 3166-1 codes can be found on-line.</source>
          <target state="translated">ISO 3166-1 코드는 온라인에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="611dd8f9d48699c9411b9432a1cb2dc63863602c" translate="yes" xml:space="preserve">
          <source>The ISO calendar system behaves as follows:</source>
          <target state="translated">ISO 캘린더 시스템은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6082f991bd981467ab45e2ffde3309b5e82f6280" translate="yes" xml:space="preserve">
          <source>The ISO calendar system defines an additional week-based division of years. This defines a year based on whole Monday to Monday weeks. This is modeled in &lt;a href=&quot;isofields&quot;&gt;&lt;code&gt;IsoFields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ISO 캘린더 시스템은 추가 주 단위로 년을 정의합니다. 이것은 월요일부터 월요일까지의 주 전체를 기준으로 연도를 정의합니다. 이것은 &lt;a href=&quot;isofields&quot;&gt; &lt;code&gt;IsoFields&lt;/code&gt; &lt;/a&gt; 에서 모델링되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4d077fd16854767d357096f809fb7b81bacb82c7" translate="yes" xml:space="preserve">
          <source>The ISO calendar system.</source>
          <target state="translated">ISO 캘린더 시스템.</target>
        </trans-unit>
        <trans-unit id="58e26e3bf55479a8a5120fe45b369953d4715df2" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses a date with an offset, such as '2011-12-03+01:00'.</source>
          <target state="translated">'2011-12-03 + 01 : 00'과 같이 오프셋으로 날짜를 형식화하거나 구문 분석하는 ISO 날짜 형식 기입니다.</target>
        </trans-unit>
        <trans-unit id="6de9417addd60d61c439ecd60520ce653b7ff208" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses a date with the offset if available, such as '2011-12-03' or '2011-12-03+01:00'.</source>
          <target state="translated">'2011-12-03'또는 '2011-12-03 + 01 : 00'과 같이 사용 가능한 경우 오프셋으로 날짜를 형식화하거나 구문 분석하는 ISO 날짜 형식 기입니다.</target>
        </trans-unit>
        <trans-unit id="2bed7eaa4131a3fd0eed3c41b0dc86a015ca96db" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses a date without an offset, such as '2011-12-03'.</source>
          <target state="translated">'2011-12-03'과 같이 오프셋없이 날짜를 형식화하거나 구문 분석하는 ISO 날짜 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="21efec4c9a9cd99bd7c37c45effa030d9f01c4ca" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses a date without an offset, such as '20111203'.</source>
          <target state="translated">'20111203'과 같이 오프셋없이 날짜를 형식화하거나 구문 분석하는 ISO 날짜 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="5e79ab154ec99d657cac16998df6c24432d36bfb" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses the ordinal date without an offset, such as '2012-337'.</source>
          <target state="translated">'2012-337'과 같이 오프셋없이 서수를 형식화하거나 구문 분석하는 ISO 날짜 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="8947499950b72303579b6072a1f0f70410f938f9" translate="yes" xml:space="preserve">
          <source>The ISO date formatter that formats or parses the week-based date without an offset, such as '2012-W48-6'.</source>
          <target state="translated">'2012-W48-6'과 같이 오프셋없이 주 기반 날짜를 형식화하거나 구문 분석하는 ISO 날짜 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="ad4a4f923ef1dd96afdbb263d3503d29224e8ce9" translate="yes" xml:space="preserve">
          <source>The ISO date of the first day of the minimum Hijrah year.</source>
          <target state="translated">최소 Hijrah 연도의 첫 날의 ISO 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="ab2094bfe0e934a818f591f8e39df5d0c0f5b428" translate="yes" xml:space="preserve">
          <source>The ISO date-time formatter that formats or parses a date-time with an offset, such as '2011-12-03T10:15:30+01:00'.</source>
          <target state="translated">'2011-12-03T10 : 15 : 30 + 01 : 00'과 같은 오프셋으로 날짜-시간을 형식화하거나 구문 분석하는 ISO 날짜-시간 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="b7f380848807763c304877a683626ef209b2dd72" translate="yes" xml:space="preserve">
          <source>The ISO date-time formatter that formats or parses a date-time without an offset, such as '2011-12-03T10:15:30'.</source>
          <target state="translated">'2011-12-03T10 : 15 : 30'과 같이 오프셋없이 날짜-시간을 형식화하거나 구문 분석하는 ISO 날짜-시간 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="bd2f9f3c47232e93e12ebe7e08b1617ed46664af" translate="yes" xml:space="preserve">
          <source>The ISO instant formatter that formats or parses an instant in UTC, such as '2011-12-03T10:15:30Z'.</source>
          <target state="translated">'2011-12-03T10 : 15 : 30Z'와 같이 UTC로 인스턴트를 형식화하거나 구문 분석하는 ISO 인스턴트 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="95a52b961a46e25216875fca80e6d411d7ab598a" translate="yes" xml:space="preserve">
          <source>The ISO time formatter that formats or parses a time with an offset, such as '10:15+01:00' or '10:15:30+01:00'.</source>
          <target state="translated">'10 : 15 + 01 : 00 '또는 '10 : 15 : 30 + 01 : 00'과 같이 오프셋으로 시간을 형식화하거나 구문 분석하는 ISO 시간 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="df2987c695a53ce54ed87dd02ab3fbad12667817" translate="yes" xml:space="preserve">
          <source>The ISO time formatter that formats or parses a time without an offset, such as '10:15' or '10:15:30'.</source>
          <target state="translated">'10 : 15 '또는 '10 : 15 : 30'과 같이 오프셋없이 시간을 형식화하거나 구문 분석하는 ISO 시간 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="d335e1639bd2cf2c6fa963a589bd508ea6cff667" translate="yes" xml:space="preserve">
          <source>The ISO time formatter that formats or parses a time, with the offset if available, such as '10:15', '10:15:30' or '10:15:30+01:00'.</source>
          <target state="translated">'10 : 15 ', '10 : 15 : 30'또는 '10 : 15 : 30 + 01 : 00 '과 같이 사용 가능한 경우 오프셋을 사용하여 시간을 형식화하거나 구문 분석하는 ISO 시간 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="0a3f5206473b8e9b0e863ce6a87c607ec16d4baa" translate="yes" xml:space="preserve">
          <source>The ISO-8601 calendar system is the modern civil calendar system used today in most of the world. It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time.</source>
          <target state="translated">ISO-8601 캘린더 시스템은 오늘날 대부분의 세계에서 사용되는 최신 민사 캘린더 시스템입니다. 그것은 윤년에 대한 오늘날의 규칙이 모든 시간에 적용되는 다발성 그레고리력 시스템과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6b0753a83aa00ab66715a1d0bce536d311b35dee" translate="yes" xml:space="preserve">
          <source>The ISO-8601 calendar system is the modern civil calendar system used today in most of the world. It is equivalent to the proleptic Gregorian calendar system, in which today's rules for leap years are applied for all time. For most applications written today, the ISO-8601 rules are entirely suitable. However, any application that makes use of historical dates, and requires them to be accurate will find the ISO-8601 approach unsuitable.</source>
          <target state="translated">ISO-8601 캘린더 시스템은 오늘날 대부분의 세계에서 사용되는 최신 민사 캘린더 시스템입니다. 그것은 윤년에 대한 오늘날의 규칙이 모든 시간에 적용되는 다발성 그레고리력 시스템과 동일합니다. 오늘날 작성된 대부분의 응용 프로그램에는 ISO-8601 규칙이 전적으로 적합합니다. 그러나 과거 날짜를 사용하고 정확한 날짜를 요구하는 응용 프로그램은 ISO-8601 접근 방식이 적합하지 않다는 것을 알게됩니다.</target>
        </trans-unit>
        <trans-unit id="2b87b0b3d3f02384c82a8cdf0d2d60d19047ef46" translate="yes" xml:space="preserve">
          <source>The ISO-8601 calendar system is the modern civil calendar system used today in most of the world. This API assumes that all calendar systems use the same representation, this class, for time-of-day.</source>
          <target state="translated">ISO-8601 캘린더 시스템은 오늘날 대부분의 세계에서 사용되는 최신 민사 캘린더 시스템입니다. 이 API는 모든 달력 시스템이 시간에 대해 동일한 클래스 인이 클래스를 사용한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="24cf4f50b66f15436634e4e63889e0eeb0811579" translate="yes" xml:space="preserve">
          <source>The ISO-8601 definition, where a week starts on Monday and the first week has a minimum of 4 days.</source>
          <target state="translated">주가 월요일에 시작하고 첫 번째 주가 최소 4 일인 ISO-8601 정의.</target>
        </trans-unit>
        <trans-unit id="ea56e5764492774cbd5793c14b636ad2fff88f1f" translate="yes" xml:space="preserve">
          <source>The ISO-8601 standard defines a calendar system based on weeks. It uses the week-based-year and week-of-week-based-year concepts to split up the passage of days instead of the standard year/month/day.</source>
          <target state="translated">ISO-8601 표준은 주 단위로 달력 시스템을 정의합니다. 주별 및 주별 개념을 사용하여 표준 연도 / 월 / 일 대신 요일을 분할합니다.</target>
        </trans-unit>
        <trans-unit id="cd8f2e4ef07a7ae4561e3a206df7d9c3194cc3bf" translate="yes" xml:space="preserve">
          <source>The ISO-8601 standard does not define eras. A definition has therefore been created with two eras - 'Current era' (CE) for years on or after 0001-01-01 (ISO), and 'Before current era' (BCE) for years before that.</source>
          <target state="translated">ISO-8601 표준은 시대를 정의하지 않습니다. 따라서 0001-01-01 (ISO) 또는 그 이후 몇 년 동안 '현재 시대'(CE)와 그 이전 몇 년 동안 '현재 시대 이전'(BCE)이라는 두 가지 시대로 정의가 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="15f2960aca862d8387dbd45828c14f2ee1a23360" translate="yes" xml:space="preserve">
          <source>The ISO-8601 standard is based on the standard civic 12 month year. This is commonly divided into four quarters, often abbreviated as Q1, Q2, Q3 and Q4.</source>
          <target state="translated">ISO-8601 표준은 표준 시민 12 개월 연도를 기준으로합니다. 이것은 일반적으로 4 분기로 나누어지며 종종 Q1, Q2, Q3 및 Q4로 약칭됩니다.</target>
        </trans-unit>
        <trans-unit id="6e18900e4d1930d96696f4d4906e19682a06d587" translate="yes" xml:space="preserve">
          <source>The ISO-8601 standard was originally intended as a data interchange format, defining a string format for dates and times. However, it also defines an alternate way of expressing the date, based on the concept of week-based-year.</source>
          <target state="translated">ISO-8601 표준은 원래 날짜와 시간에 대한 문자열 형식을 정의하는 데이터 교환 형식으로 고안되었습니다. 그러나 주별 연도의 개념에 따라 날짜를 표현하는 다른 방법도 정의합니다.</target>
        </trans-unit>
        <trans-unit id="12da9e8bfa2848ec37f88ea0629d59e6306e0906" translate="yes" xml:space="preserve">
          <source>The ISO-like date-time formatter that formats or parses a date-time with offset and zone, such as '2011-12-03T10:15:30+01:00[Europe/Paris]'.</source>
          <target state="translated">'2011-12-03T10 : 15 : 30 + 01 : 00 [유럽 / 파리]'와 같이 오프셋 및 영역으로 날짜 시간을 형식화하거나 구문 분석하는 ISO와 같은 날짜-시간 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="86afa3124f1aed75c36e4dd56bfce8c49977f732" translate="yes" xml:space="preserve">
          <source>The ISO-like date-time formatter that formats or parses a date-time with the offset and zone if available, such as '2011-12-03T10:15:30', '2011-12-03T10:15:30+01:00' or '2011-12-03T10:15:30+01:00[Europe/Paris]'.</source>
          <target state="translated">'2011-12-03T10 : 15 : 30', '2011-12-03T10 : 15 : 30 + 01과 같이 사용 가능한 경우 오프셋 및 영역으로 날짜 시간을 형식화하거나 구문 분석하는 ISO와 같은 날짜-시간 포맷터 : 00 '또는'2011-12-03T10 : 15 : 30 + 01 : 00 [유럽 / 파리] '.</target>
        </trans-unit>
        <trans-unit id="1770c1e43e10767defa4c018f5743b7b2d0ab296" translate="yes" xml:space="preserve">
          <source>The IV is taken from &lt;code&gt;iv&lt;/code&gt;, starting at &lt;code&gt;offset&lt;/code&gt; inclusive. Note that the size of the IV (block size), starting at &lt;code&gt;offset&lt;/code&gt; inclusive, must be twice the word size. The bytes that constitute the IV are those between &lt;code&gt;iv[offset]&lt;/code&gt; and &lt;code&gt;iv[offset+2*(wordSize/8)-1]&lt;/code&gt; inclusive.</source>
          <target state="translated">IV는 &lt;code&gt;offset&lt;/code&gt; 포함 하여 &lt;code&gt;iv&lt;/code&gt; 에서 가져옵니다 . &lt;code&gt;offset&lt;/code&gt; 포함 하여 IV의 크기 (블록 크기) 는 워드 크기의 두 배 여야합니다. IV를 구성하는 바이트는 &lt;code&gt;iv[offset]&lt;/code&gt; 과 &lt;code&gt;iv[offset+2*(wordSize/8)-1]&lt;/code&gt; 사이의 바이트입니다 .</target>
        </trans-unit>
        <trans-unit id="47f00745675042f6a724b595797a24a07101fd7a" translate="yes" xml:space="preserve">
          <source>The IV is taken from &lt;code&gt;iv&lt;/code&gt;, starting at &lt;code&gt;offset&lt;/code&gt; inclusive. The bytes that constitute the IV are those between &lt;code&gt;iv[offset]&lt;/code&gt; and &lt;code&gt;iv[offset+7]&lt;/code&gt; inclusive.</source>
          <target state="translated">IV는 &lt;code&gt;offset&lt;/code&gt; 포함 하여 &lt;code&gt;iv&lt;/code&gt; 에서 가져옵니다 . IV를 구성하는 바이트는 &lt;code&gt;iv[offset]&lt;/code&gt; 과 &lt;code&gt;iv[offset+7]&lt;/code&gt; 사이의 바이트입니다 .</target>
        </trans-unit>
        <trans-unit id="dd985ba4ac843c2aa13ce1073a3079fccc30b81d" translate="yes" xml:space="preserve">
          <source>The Id of the calendar in common usage</source>
          <target state="translated">일반적으로 사용되는 캘린더의 ID</target>
        </trans-unit>
        <trans-unit id="faa9a0061bb28bf6c97cd39acf5b5a828ccf93f4" translate="yes" xml:space="preserve">
          <source>The InetAddress class has a cache to store successful as well as unsuccessful host name resolutions.</source>
          <target state="translated">InetAddress 클래스에는 성공 및 실패한 호스트 이름 확인을 저장하기위한 캐시가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6bf2f6528348c5b02c604ad3248d294717b2a1b" translate="yes" xml:space="preserve">
          <source>The InetAddress class provides methods to resolve host names to their IP addresses and vice versa.</source>
          <target state="translated">InetAddress 클래스는 호스트 이름을 IP 주소로 또는 그 반대로 확인하는 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cc9a029be511dad65fe5032c793e83b48780fe75" translate="yes" xml:space="preserve">
          <source>The InetAddress may not uniquely identify the network interface.</source>
          <target state="translated">InetAddress는 네트워크 인터페이스를 고유하게 식별하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c425709246c3a74df2ab86c6b08f918b251f224f" translate="yes" xml:space="preserve">
          <source>The InetAddress may not uniquely identify the network interface. Use &lt;a href=&quot;#setNetworkInterface(java.net.NetworkInterface)&quot;&gt;&lt;code&gt;setNetworkInterface(NetworkInterface)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">InetAddress는 네트워크 인터페이스를 고유하게 식별하지 못할 수 있습니다. 사용 &lt;a href=&quot;#setNetworkInterface(java.net.NetworkInterface)&quot;&gt; &lt;code&gt;setNetworkInterface(NetworkInterface)&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="65b8748cc6268fcd7ebec74a58229406dde9da72" translate="yes" xml:space="preserve">
          <source>The InetAddress returned will represent the IPv4 loopback address, 127.0.0.1, or the IPv6 loopback address, ::1. The IPv4 loopback address returned is only one of many in the form 127.*.*.*</source>
          <target state="translated">반환 된 InetAddress는 IPv4 루프백 주소 127.0.0.1 또는 IPv6 루프백 주소 :: 1을 나타냅니다. 반환 된 IPv4 루프백 주소는 127. *. *. * 형식의 많은 것 중 하나 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="2152fa5309ac167073dd45954409ff4768fda7a1" translate="yes" xml:space="preserve">
          <source>The Initial Context</source>
          <target state="translated">초기 상황</target>
        </trans-unit>
        <trans-unit id="ac8c89b1c1f180681f98a482edf01b3499693ace" translate="yes" xml:space="preserve">
          <source>The Insert key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 조치 키인 Insert 키.</target>
        </trans-unit>
        <trans-unit id="9ff6f766ad82286cf3b4ec81ad2977fb2af744de" translate="yes" xml:space="preserve">
          <source>The Internet Assigned Numbers Authority maintains the &lt;a href=&quot;http://www.iana.org/assignments/uri-schemes.html&quot;&gt;official list of URI schemes&lt;/a&gt;.</source>
          <target state="translated">인터넷 할당 번호 기관 (Internet Assigned Numbers Authority)은 &lt;a href=&quot;http://www.iana.org/assignments/uri-schemes.html&quot;&gt;공식적인 URI 체계 목록을&lt;/a&gt; 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="f994aa3493fbbe076ad643b790ff4c68651b124a" translate="yes" xml:space="preserve">
          <source>The Internet Assigned Numbers Authority maintains the &lt;a href=&quot;https://www.iana.org/assignments/uri-schemes.html&quot;&gt;official list of URI schemes&lt;/a&gt;.</source>
          <target state="translated">Internet Assigned Numbers Authority &lt;a href=&quot;https://www.iana.org/assignments/uri-schemes.html&quot;&gt;는 URI 체계&lt;/a&gt; 의 공식 목록을 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="d6529cb88cc0262a6e384c19547d019dbb6bed8b" translate="yes" xml:space="preserve">
          <source>The Introspector class provides a standard way for tools to learn about the properties, events, and methods supported by a target Java Bean.</source>
          <target state="translated">Introspector 클래스는 도구가 대상 Java Bean이 지원하는 특성, 이벤트 및 메소드를 학습 할 수있는 표준 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d59d73b56b3dc062d05806ca58651ba62a2b2f54" translate="yes" xml:space="preserve">
          <source>The JAAS login module in the JDK reference implementation destroys all tickets after logout.</source>
          <target state="translated">JDK 참조 구현의 JAAS 로그인 모듈은 로그 아웃 후 모든 티켓을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="fc346e9074de046178b6976458380753f8a1bf98" translate="yes" xml:space="preserve">
          <source>The JAR File Specification defines manifest attributes for standalone applications that are packaged as &lt;em&gt;executable JAR files&lt;/em&gt;. If an implementation supports a mechanism to start an application as an executable JAR then the main manifest may include the &lt;code&gt;Launcher-Agent-Class&lt;/code&gt; attribute to specify the class name of an agent to start before the application &lt;code&gt;main&lt;/code&gt; method is invoked. The Java virtual machine attempts to invoke the following method on the agent class:</source>
          <target state="translated">JAR 파일 사양은 &lt;em&gt;실행 가능한 JAR 파일&lt;/em&gt; 로 패키지 된 독립형 응용 프로그램에 대한 매니페스트 속성을 정의 &lt;em&gt;합니다&lt;/em&gt; . 구현이 애플리케이션을 실행 가능한 JAR로 시작하는 메커니즘을 지원하는 경우 기본 매니페스트에는 애플리케이션 &lt;code&gt;main&lt;/code&gt; 메서드가 호출 되기 전에 시작할 에이전트의 클래스 이름을 지정하는 &lt;code&gt;Launcher-Agent-Class&lt;/code&gt; 속성 이 포함될 수 있습니다 . JVM (Java Virtual Machine)은 에이전트 클래스에서 다음 메소드를 호출하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="9399cacad1f2d454e6eb5e3191a8f321b607ef5b" translate="yes" xml:space="preserve">
          <source>The JAR File Specification: Package Sealing</source>
          <target state="translated">JAR 파일 사양 : 패키지 봉인</target>
        </trans-unit>
        <trans-unit id="e6747986174a0238886b1fc2303c30e9cad08546" translate="yes" xml:space="preserve">
          <source>The JAR file contains a provider configuration named &lt;code&gt;com.sun.tools.attach.spi.AttachProvider&lt;/code&gt; in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;.</source>
          <target state="translated">JAR 파일에는 자원 디렉토리 &lt;code&gt;META-INF/services&lt;/code&gt; 에 &lt;code&gt;com.sun.tools.attach.spi.AttachProvider&lt;/code&gt; 라는 공급자 구성이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb84f09030f91494fb9beb5357d12365eccba462" translate="yes" xml:space="preserve">
          <source>The JAR manifest file name.</source>
          <target state="translated">JAR 매니페스트 파일 이름</target>
        </trans-unit>
        <trans-unit id="767966e80e6e7fb64c0055271e699571168269ff" translate="yes" xml:space="preserve">
          <source>The JAXP Processors' support for Catalog depends on both the &lt;a href=&quot;../xmlconstants#USE_CATALOG&quot;&gt;&lt;code&gt;USE_CATALOG&lt;/code&gt;&lt;/a&gt; feature and the existence of valid Catalog file(s). A JAXP processor will use the Catalog only when the feature is true and valid Catalog file(s) are specified through the &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; property. It will make no attempt to use the Catalog if either &lt;a href=&quot;../xmlconstants#USE_CATALOG&quot;&gt;&lt;code&gt;USE_CATALOG&lt;/code&gt;&lt;/a&gt; is set to false, or there is no Catalog file specified.</source>
          <target state="translated">JAXP 프로세서의 카탈로그 지원은 &lt;a href=&quot;../xmlconstants#USE_CATALOG&quot;&gt; &lt;code&gt;USE_CATALOG&lt;/code&gt; &lt;/a&gt; 기능 및 유효한 카탈로그 파일의 존재 여부에 따라 다릅니다 . JAXP 프로세서는 기능이 true이고 유효한 카탈로그 파일이 &lt;code&gt;javax.xml.catalog.files&lt;/code&gt; 속성을 통해 지정된 경우에만 카탈로그를 사용합니다 . &lt;a href=&quot;../xmlconstants#USE_CATALOG&quot;&gt; &lt;code&gt;USE_CATALOG&lt;/code&gt; &lt;/a&gt; 가 false로 설정되거나 카탈로그 파일이 지정되지 않은 경우 카탈로그 사용을 시도 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="672525f13b4776f4afc24e25f67783864e75b16d" translate="yes" xml:space="preserve">
          <source>The JAXP parsing API has been integrated with the Validation API. Applications may create a &lt;a href=&quot;schema&quot;&gt;&lt;code&gt;Schema&lt;/code&gt;&lt;/a&gt; with the validation API and associate it with a &lt;a href=&quot;../parsers/documentbuilderfactory&quot;&gt;&lt;code&gt;DocumentBuilderFactory&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../parsers/saxparserfactory&quot;&gt;&lt;code&gt;SAXParserFactory&lt;/code&gt;&lt;/a&gt; instance by using the &lt;a href=&quot;../parsers/documentbuilderfactory#setSchema(javax.xml.validation.Schema)&quot;&gt;&lt;code&gt;DocumentBuilderFactory.setSchema(Schema)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../parsers/saxparserfactory#setSchema(javax.xml.validation.Schema)&quot;&gt;&lt;code&gt;SAXParserFactory.setSchema(Schema)&lt;/code&gt;&lt;/a&gt; methods. &lt;strong&gt;You should not&lt;/strong&gt; both set a schema and call &lt;code&gt;setValidating(true)&lt;/code&gt; on a parser factory. The former technique will cause parsers to use the new validation API; the latter will cause parsers to use their own internal validation facilities. &lt;strong&gt;Turning on both of these options simultaneously will cause either redundant behavior or error conditions.&lt;/strong&gt;</source>
          <target state="translated">JAXP 구문 분석 API는 유효성 검사 API와 통합되었습니다. 응용 프로그램은 유효성 검사 API 로 &lt;a href=&quot;schema&quot;&gt; &lt;code&gt;Schema&lt;/code&gt; &lt;/a&gt; 를 만들고 &lt;a href=&quot;../parsers/documentbuilderfactory#setSchema(javax.xml.validation.Schema)&quot;&gt; &lt;code&gt;DocumentBuilderFactory.setSchema(Schema)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../parsers/saxparserfactory#setSchema(javax.xml.validation.Schema)&quot;&gt; &lt;code&gt;SAXParserFactory.setSchema(Schema)&lt;/code&gt; &lt;/a&gt; 메서드 를 사용하여 이를 &lt;a href=&quot;../parsers/documentbuilderfactory&quot;&gt; &lt;code&gt;DocumentBuilderFactory&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../parsers/saxparserfactory&quot;&gt; &lt;code&gt;SAXParserFactory&lt;/code&gt; &lt;/a&gt; 인스턴스 와 연결할 수 있습니다. 파서 팩토리 에서 스키마를 설정하고 &lt;code&gt;setValidating(true)&lt;/code&gt; 을 호출하면 &lt;strong&gt;안됩니다&lt;/strong&gt; . 이전 기술은 파서가 새로운 유효성 검사 API를 사용하도록합니다. 후자는 파서가 자체 내부 유효성 검사 기능을 사용하도록합니다. &lt;strong&gt;이 두 옵션을 동시에 켜면 중복 동작 또는 오류 조건이 발생합니다.&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db8911ccdb0a32b11e7f663779352a6851708390" translate="yes" xml:space="preserve">
          <source>The JAXP processors give preference to user-specified custom resolvers. If such a resolver is registered, it will be used over the CatalogResolver. If it returns null however, the processors will continue resolving with the CatalogResolver. If it returns an empty source, no attempt will be made by the CatalogResolver.</source>
          <target state="translated">JAXP 프로세서는 사용자 지정 사용자 지정 해석기를 선호합니다. 이러한 리졸버가 등록되면 CatalogResolver를 통해 사용됩니다. 그러나 null을 반환하면 프로세서는 CatalogResolver로 계속 분석합니다. 빈 소스를 반환하면 CatalogResolver가 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99f24bc9813db0373534263c88d5131c62a4ac28" translate="yes" xml:space="preserve">
          <source>The JAXP processors will observe the default settings of the &lt;a href=&quot;catalogfeatures&quot;&gt;&lt;code&gt;CatalogFeatures&lt;/code&gt;&lt;/a&gt;. The processors, for example, will report an Exception by default when no matching entry is found since the default value of the &lt;code&gt;javax.xml.catalog.resolve&lt;/code&gt; property is strict.</source>
          <target state="translated">JAXP 프로세서는 &lt;a href=&quot;catalogfeatures&quot;&gt; &lt;code&gt;CatalogFeatures&lt;/code&gt; &lt;/a&gt; 의 기본 설정을 준수합니다 . 예를 들어, 프로세서는 &lt;code&gt;javax.xml.catalog.resolve&lt;/code&gt; 속성 의 기본값 이 엄격하기 때문에 일치하는 항목이없는 경우 기본적으로 예외를보고합니다 .</target>
        </trans-unit>
        <trans-unit id="a2d24c7890bba0f3964cbaede11464e0250281a1" translate="yes" xml:space="preserve">
          <source>The JAXP validation API decouples the validation of an instance document from the parsing of an XML document. This is advantageous for several reasons, some of which are:</source>
          <target state="translated">JAXP 유효성 검사 API는 XML 문서 구문 분석에서 인스턴스 문서 유효성 검사를 분리합니다. 이는 다음과 같은 몇 가지 이유로 유리합니다.</target>
        </trans-unit>
        <trans-unit id="c6740abff5341aaea3d3add9108309db47269f46" translate="yes" xml:space="preserve">
          <source>The JDBC 1.0 API</source>
          <target state="translated">JDBC 1.0 API</target>
        </trans-unit>
        <trans-unit id="2ef0b1e1237f551a4a27a689e562cb12d6000ad9" translate="yes" xml:space="preserve">
          <source>The JDBC 1.2 API</source>
          <target state="translated">JDBC 1.2 API</target>
        </trans-unit>
        <trans-unit id="58d78690167f9669f3dd44eef343f4abed230945" translate="yes" xml:space="preserve">
          <source>The JDBC 2.0 Optional Package API</source>
          <target state="translated">JDBC 2.0 선택적 패키지 API</target>
        </trans-unit>
        <trans-unit id="2210ba25b69c2db4ed032d072c7ec3aa1505d86c" translate="yes" xml:space="preserve">
          <source>The JDBC 2.1 core API</source>
          <target state="translated">JDBC 2.1 핵심 API</target>
        </trans-unit>
        <trans-unit id="ea17f896a65d406c1673560b63457b11cfbedc0c" translate="yes" xml:space="preserve">
          <source>The JDBC 3.0 API</source>
          <target state="translated">JDBC 3.0 API</target>
        </trans-unit>
        <trans-unit id="59a75209b42a7de6d5159a3ca206067460cfc599" translate="yes" xml:space="preserve">
          <source>The JDBC 3.0 specification added the maxStatements &lt;code&gt;ConnectionPooledDataSource&lt;/code&gt; property to provide a standard mechanism for enabling the pooling of &lt;code&gt;PreparedStatements&lt;/code&gt; and to specify the size of the statement pool. However, there was no way for a driver to notify an external statement pool when a &lt;code&gt;PreparedStatement&lt;/code&gt; becomes invalid. For some databases, a statement becomes invalid if a DDL operation is performed that affects the table. For example an application may create a temporary table to do some work on the table and then destroy it. It may later recreate the same table when it is needed again. Some databases will invalidate any prepared statements that reference the temporary table when the table is dropped.</source>
          <target state="translated">JDBC 3.0 사양 은 &lt;code&gt;PreparedStatements&lt;/code&gt; 풀링을 활성화 하고 문 풀의 크기를 지정 하기위한 표준 메커니즘을 제공하기 위해 maxStatements &lt;code&gt;ConnectionPooledDataSource&lt;/code&gt; 속성을 추가했습니다 . 그러나 &lt;code&gt;PreparedStatement&lt;/code&gt; 가 유효하지 않은 경우 드라이버가 외부 명령문 풀에 알릴 수있는 방법이 없습니다 . 일부 데이터베이스의 경우 테이블에 영향을주는 DDL 작업이 수행되면 문이 유효하지 않게됩니다. 예를 들어, 응용 프로그램은 임시 테이블을 생성하여 테이블에 대한 작업을 수행 한 다음이를 삭제할 수 있습니다. 나중에 다시 필요할 때 동일한 테이블을 다시 만들 수 있습니다. 일부 데이터베이스는 테이블이 삭제 될 때 임시 테이블을 참조하는 준비된 명령문을 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="b75de8c2dc71b65df97e8ecbf3ef4bedd3196b45" translate="yes" xml:space="preserve">
          <source>The JDBC 4.0 API</source>
          <target state="translated">JDBC 4.0 API</target>
        </trans-unit>
        <trans-unit id="8537833ae96efc546ce1bf57458bf13e4e00612d" translate="yes" xml:space="preserve">
          <source>The JDBC 4.1 API</source>
          <target state="translated">JDBC 4.1 API</target>
        </trans-unit>
        <trans-unit id="2522ad222d6d4fff647d1822f3c053ef1b208ea1" translate="yes" xml:space="preserve">
          <source>The JDBC 4.2 API</source>
          <target state="translated">JDBC 4.2 API</target>
        </trans-unit>
        <trans-unit id="e8042149b2c345102f76a2b84b87ede611904a61" translate="yes" xml:space="preserve">
          <source>The JDBC 4.3 API includes both the &lt;code&gt;java.sql&lt;/code&gt; package, referred to as the JDBC core API, and the &lt;code&gt;javax.sql&lt;/code&gt; package, referred to as the JDBC Optional Package API. This complete JDBC API is included in the Java Standard Edition (Java SE), version 7. The &lt;code&gt;javax.sql&lt;/code&gt; package extends the functionality of the JDBC API from a client-side API to a server-side API, and it is an essential part of the Java Enterprise Edition (Java EE) technology.</source>
          <target state="translated">JDBC 4.3 API에는 JDBC 코어 API라고 하는 &lt;code&gt;java.sql&lt;/code&gt; 패키지와 JDBC 선택적 패키지 API라고 하는 &lt;code&gt;javax.sql&lt;/code&gt; 패키지 가 모두 포함되어 있습니다 . 이 완전한 JDBC API는 Java SE (Java Standard Edition) 버전 7에 포함되어 있습니다. &lt;code&gt;javax.sql&lt;/code&gt; 패키지는 JDBC API의 기능을 클라이언트 측 API에서 서버 측 API로 확장하며 필수적인 부분입니다. Java EE (Java Enterprise Edition) 기술의.</target>
        </trans-unit>
        <trans-unit id="063101cb057d027845a508bc0a2d52d1e469963b" translate="yes" xml:space="preserve">
          <source>The JDBC 4.3 API incorporates all of the previous JDBC API versions:</source>
          <target state="translated">JDBC 4.3 API는 모든 이전 JDBC API 버전을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="908da5094f4f523619fcbfb6f3b042822f877a05" translate="yes" xml:space="preserve">
          <source>The JDBC API provides mechanisms for mapping an SQL structured type or DISTINCT type to the Java programming language. Typically, a structured type is mapped to a class, and its attributes are mapped to fields in the class. (A DISTINCT type can thought of as having one attribute.) However, there are many other possibilities, and there may be any number of different mappings.</source>
          <target state="translated">JDBC API는 SQL 구조화 유형 또는 DISTINCT 유형을 Java 프로그래밍 언어에 맵핑하기위한 메커니즘을 제공합니다. 일반적으로 구조화 된 유형은 클래스에 매핑되고 해당 속성은 클래스의 필드에 매핑됩니다. (DISTINCT 유형은 하나의 속성을 갖는 것으로 생각할 수 있습니다.) 그러나 다른 많은 가능성이 있으며 여러 다른 맵핑이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e67b3a9fa0b65d4e49f3b35324e61a95fab14b1" translate="yes" xml:space="preserve">
          <source>The JDBC API supports this SQL feature by providing the name of the SQL cursor used by a &lt;code&gt;ResultSet&lt;/code&gt; object. The current row of a &lt;code&gt;ResultSet&lt;/code&gt; object is also the current row of this SQL cursor.</source>
          <target state="translated">JDBC API는 &lt;code&gt;ResultSet&lt;/code&gt; 오브젝트가 사용하는 SQL 커서의 이름을 제공하여이 SQL 기능을 지원 합니다. a의 현재 행 &lt;code&gt;ResultSet&lt;/code&gt; 객체는이 SQL 커서의 현재의 행입니다.</target>
        </trans-unit>
        <trans-unit id="9d48b4e02a7ef8b217df6704fbc3fbef3055bb97" translate="yes" xml:space="preserve">
          <source>The JDBC driver initializes the input stream with a type map before calling this method, which is used by the appropriate &lt;code&gt;SQLInput&lt;/code&gt; reader method on the stream.</source>
          <target state="translated">JDBC 드라이버는이 메서드를 호출하기 전에 형식 맵을 사용하여 입력 스트림을 초기화합니다.이 메서드 는 스트림 의 적절한 &lt;code&gt;SQLInput&lt;/code&gt; 판독기 메서드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcf45bd369f2e97b6bb4e9ebc9b75d647e55ac9a" translate="yes" xml:space="preserve">
          <source>The JDBC driver's static initialization block must call &lt;a href=&quot;drivermanager#registerDriver(java.sql.Driver,java.sql.DriverAction)&quot;&gt;DriverManager.registerDriver(java.sql.Driver, java.sql.DriverAction)&lt;/a&gt; in order to inform &lt;code&gt;DriverManager&lt;/code&gt; which &lt;code&gt;DriverAction&lt;/code&gt; implementation to call when the JDBC driver is de-registered.</source>
          <target state="translated">JDBC 드라이버의 정적 초기화 블록을 호출해야 &lt;a href=&quot;drivermanager#registerDriver(java.sql.Driver,java.sql.DriverAction)&quot;&gt;DriverManager.registerDriver (java.sql.Driver, java.sql.DriverAction)를&lt;/a&gt; 알리기 위해 &lt;code&gt;DriverManager&lt;/code&gt; 를가 한다 &lt;code&gt;DriverAction&lt;/code&gt; JDBC 드라이버가 디 등록되면 호출 구현.</target>
        </trans-unit>
        <trans-unit id="90e93f4c83b64826e6a378f97cf636a358d28bb9" translate="yes" xml:space="preserve">
          <source>The JDBC specification defines a standard mapping from Java &lt;code&gt;Object&lt;/code&gt; types to SQL types. The driver will use this standard mapping to convert the given object to its corresponding SQL type before sending it to the database. If the object has a custom mapping (is of a class implementing &lt;code&gt;SQLData&lt;/code&gt;), the driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write the object to the SQL data stream.</source>
          <target state="translated">JDBC 사양은 Java &lt;code&gt;Object&lt;/code&gt; 유형에서 SQL 유형으로 의 표준 매핑을 정의합니다 . 드라이버는이 표준 매핑을 사용하여 주어진 개체를 데이터베이스로 보내기 전에 해당 SQL 유형으로 변환합니다. 개체에 사용자 지정 매핑이있는 경우 ( &lt;code&gt;SQLData&lt;/code&gt; 를 구현하는 클래스에 속함 ) 드라이버는 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 메서드 를 호출 하여 개체를 SQL 데이터 스트림에 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee974a8e55da2c721c226bef3a30b526c2729b4d" translate="yes" xml:space="preserve">
          <source>The JDBC specification provides a standard mapping from Java Object types to SQL types. The driver will convert the given Java object to its standard SQL mapping before sending it to the database.</source>
          <target state="translated">JDBC 사양은 Java 개체 유형에서 SQL 유형으로의 표준 매핑을 제공합니다. 드라이버는 주어진 Java 객체를 데이터베이스로 보내기 전에 표준 SQL 매핑으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3e9c491f1d268a5ac29eab9e5df11e173ed6c9d0" translate="yes" xml:space="preserve">
          <source>The JDBC specification specifies a standard mapping from Java &lt;code&gt;Object&lt;/code&gt; types to SQL types. The given argument will be converted to the corresponding SQL type before being sent to the database.</source>
          <target state="translated">JDBC 사양은 Java &lt;code&gt;Object&lt;/code&gt; 유형에서 SQL 유형으로 의 표준 매핑을 지정합니다 . 주어진 인수는 데이터베이스로 전송되기 전에 해당 SQL 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="523fd79ec39492a793ce5d43b1d416a59b37eb0f" translate="yes" xml:space="preserve">
          <source>The JDBC technology-enabled driver registers a type map with the stream before passing the stream to the application.</source>
          <target state="translated">JDBC 기술 사용 드라이버는 스트림을 애플리케이션에 전달하기 전에 스트림에 유형 맵을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="4f2501807ea5543e21ac42081e7607f5eda00852" translate="yes" xml:space="preserve">
          <source>The JDBC type specified by &lt;code&gt;sqlType&lt;/code&gt; for an OUT parameter determines the Java type that must be used in the &lt;code&gt;get&lt;/code&gt; method to read the value of that parameter.</source>
          <target state="translated">OUT 매개 변수에 대해 &lt;code&gt;sqlType&lt;/code&gt; 에 지정된 JDBC 유형 은 해당 매개 변수의 값을 읽기 &lt;code&gt;get&lt;/code&gt; 메소드 에서 사용해야하는 Java 유형을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="de789869d263780a3433be03e37625511f9f77e8" translate="yes" xml:space="preserve">
          <source>The JDBC&amp;trade; 4.3 API includes both the &lt;code&gt;java.sql&lt;/code&gt; package, referred to as the JDBC core API, and the &lt;code&gt;javax.sql&lt;/code&gt; package, referred to as the JDBC Optional Package API. This complete JDBC API is included in the Java&amp;trade; Standard Edition (Java SE&amp;trade;), version 7. The &lt;code&gt;javax.sql&lt;/code&gt; package extends the functionality of the JDBC API from a client-side API to a server-side API, and it is an essential part of the Java&amp;trade; Enterprise Edition (Java EE&amp;trade;) technology.</source>
          <target state="translated">JDBC &amp;trade; 4.3 API에는 JDBC 코어 API라고 하는 &lt;code&gt;java.sql&lt;/code&gt; 패키지와 JDBC 선택적 패키지 API라고 하는 &lt;code&gt;javax.sql&lt;/code&gt; 패키지 가 모두 포함되어 있습니다 . 이 완전한 JDBC API는 Java &amp;trade; Standard Edition (Java SE &amp;trade;) 버전 7에 포함되어 있습니다. &lt;code&gt;javax.sql&lt;/code&gt; 패키지는 JDBC API의 기능을 클라이언트 측 API에서 서버 측 API로 확장합니다. Java &amp;trade; Enterprise Edition (Java EE &amp;trade;) 기술의 필수 부분입니다.</target>
        </trans-unit>
        <trans-unit id="f969a21212467360facf86185bc85dca1542c554" translate="yes" xml:space="preserve">
          <source>The JDK 1.0 event system is supported for backwards compatibility, but its use with newer versions of the platform is discouraged. The five types of adjustment events introduced with JDK 1.1 correspond to the five event types that are associated with scroll bars in previous platform versions. The following list gives the adjustment event type, and the corresponding JDK 1.0 event type it replaces.</source>
          <target state="translated">JDK 1.0 이벤트 시스템은 이전 버전과의 호환성을 위해 지원되지만 최신 버전의 플랫폼에서는 사용하지 않는 것이 좋습니다. JDK 1.1에 도입 된 5 가지 유형의 조정 이벤트는 이전 플랫폼 버전의 스크롤 막대와 관련된 5 가지 이벤트 유형에 해당합니다. 다음 목록은 조정 이벤트 유형 및 대체되는 해당 JDK 1.0 이벤트 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3d1c7a729b653acd1693d52a432bb13d5ba67a48" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ffe26effc5f2dd90c2a6cedb9ce1386ed82b03d8" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../../../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../../../../../java.base/java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../../../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../../../../../java.base/java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ac4775b3e40e73761c25007bba30e40be920bc3" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../../../../java.base/java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../../../../java.base/java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="62bf224ef20a8c8efd79de17ded7edf373246c8e" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../../../java.base/java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../../../java.base/java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45825bff39d02867764b21ee89aae790885bd0b7" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../../../java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../../../java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../../../java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../../../java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="803cbab520d0b89989ac7e30afebc082051ee02d" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../../java.base/java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../../java.base/java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../../java.base/java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1cbcd88a86bafdf6f51dcf7a0cbbb0373e437354" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../../java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../../java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../../java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../../java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fc06d2c193c85c4e354c96804cda6886c8cc40b" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../../java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a1a5269b7b6f90524770dbb39e2e220fc9c32ad" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../../java/security/security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../../java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;. See also the Cipher Transformations section of the &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK Providers&lt;/a&gt; document for information on the transformation defaults used by JDK providers.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../../java/security/security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. &lt;a href=&quot;../../java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 반환하는 공급자 순서와 다를 수 있습니다 . &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jdk_providers&quot;&gt;JDK 공급자가&lt;/a&gt; 사용하는 변환 기본값에 대한 정보 는 JDK 공급자 문서 의 암호 변환 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd56ba177b238763ab159cda3e93de4df961c47c" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;../security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;../security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;../security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;../security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2ff4634b7d2e0418683c1f5d82da119c746f73f" translate="yes" xml:space="preserve">
          <source>The JDK Reference Implementation additionally uses the &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt;&lt;a href=&quot;security#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;Security&lt;/code&gt;&lt;/a&gt; property to determine the preferred provider order for the specified algorithm. This may be different than the order of providers returned by &lt;a href=&quot;security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JDK 참조 구현은 &lt;code&gt;jdk.security.provider.preferred&lt;/code&gt; &lt;a href=&quot;security#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;Security&lt;/code&gt; &lt;/a&gt; 속성을 추가로 사용 하여 지정된 알고리즘에 대한 기본 공급자 순서를 결정합니다. 이것은 &lt;a href=&quot;security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 공급자의 순서와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="befa33c1b2a2cde739097412d1f98fd45c743c49" translate="yes" xml:space="preserve">
          <source>The JDK SunJSSE provider implementation default for this mode is false.</source>
          <target state="translated">이 모드의 JDK SunJSSE 공급자 구현 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="8bf12e035729ecbd5e8b0cb95471b6a6dd98ddbd" translate="yes" xml:space="preserve">
          <source>The JDK SunJSSE provider implementation returns false unless &lt;a href=&quot;#setUseClientMode(boolean)&quot;&gt;&lt;code&gt;setUseClientMode(boolean)&lt;/code&gt;&lt;/a&gt; is used to change the mode to true.</source>
          <target state="translated">JDK SunJSSE 공급자 구현은 &lt;a href=&quot;#setUseClientMode(boolean)&quot;&gt; &lt;code&gt;setUseClientMode(boolean)&lt;/code&gt; &lt;/a&gt; 를 사용하여 모드를 true로 변경 하지 않는 한 false를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="358eb35c3338a7ee46a21e172820d69f3e988176" translate="yes" xml:space="preserve">
          <source>The JDK implementation of this module includes a language-independent command-line script shell, &lt;em&gt;&lt;a id=&quot;jrunscript&quot;&gt;jrunscript&lt;/a&gt;&lt;/em&gt;, that supports executing JavaScript and other languages if its corresponding script engine is installed.</source>
          <target state="translated">이 모듈의 JDK 구현에는 해당 스크립트 엔진이 설치된 경우 JavaScript 및 기타 언어 실행을 지원 하는 언어 독립적 명령 줄 스크립트 셸 &lt;em&gt;&lt;a id=&quot;jrunscript&quot;&gt;jrunscript&lt;/a&gt;&lt;/em&gt; 가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1e313c01f91cb65b8f8b490a81c962fc40ccb64a" translate="yes" xml:space="preserve">
          <source>The JDK implementation of this module includes a language-independent command-line script shell, &lt;em&gt;&lt;span id=&quot;jrunscript&quot;&gt;jrunscript&lt;/span&gt;&lt;/em&gt;, that supports executing JavaScript and other languages if its corresponding script engine is installed.</source>
          <target state="translated">이 모듈의 JDK 구현에는 해당 스크립트 엔진이 설치된 경우 JavaScript 및 기타 언어 실행을 지원 하는 언어 독립적 인 명령 줄 스크립트 &lt;em&gt;&lt;span id=&quot;jrunscript&quot;&gt;셸인 jrunscript&lt;/span&gt;&lt;/em&gt; 가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ca8ec67b178a4223fa65b7e67f9198c2b19d7c3c" translate="yes" xml:space="preserve">
          <source>The JDK implementation of this module includes the &lt;em&gt;&lt;a id=&quot;rmiregistry&quot;&gt;rmiregistry&lt;/a&gt;&lt;/em&gt; tool to start a remote object registry, and the &lt;em&gt;&lt;a id=&quot;rmid&quot;&gt;rmid&lt;/a&gt;&lt;/em&gt; tool to start the activation system daemon.</source>
          <target state="translated">이 모듈의 JDK 구현에는 원격 개체 레지스트리를 시작하는 &lt;em&gt;&lt;a id=&quot;rmiregistry&quot;&gt;rmiregistry&lt;/a&gt;&lt;/em&gt; 도구와 활성화 시스템 데몬을 시작하는 &lt;em&gt;&lt;a id=&quot;rmid&quot;&gt;rmid&lt;/a&gt;&lt;/em&gt; 도구가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="056f7da9b57d630a072b21b1ba1153c04acfa1ca" translate="yes" xml:space="preserve">
          <source>The JDK implementation of this module includes the &lt;em&gt;&lt;span id=&quot;rmiregistry&quot;&gt;rmiregistry&lt;/span&gt;&lt;/em&gt; tool to start a remote object registry, and the &lt;em&gt;&lt;span id=&quot;rmid&quot;&gt;rmid&lt;/span&gt;&lt;/em&gt; tool to start the activation system daemon.</source>
          <target state="translated">이 모듈의 JDK 구현에는 원격 개체 레지스트리를 시작하는 &lt;em&gt;&lt;span id=&quot;rmiregistry&quot;&gt;rmiregistry&lt;/span&gt;&lt;/em&gt; 도구와 활성화 시스템 데몬을 시작하는 &lt;em&gt;&lt;span id=&quot;rmid&quot;&gt;rmid&lt;/span&gt;&lt;/em&gt; 도구가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a40a63ec61f8f60c0c587e2bbb0619e0bd28d621" translate="yes" xml:space="preserve">
          <source>The JDK implementation of this module provides an implementation of the &lt;a id=&quot;jrt&quot;&gt;jrt&lt;/a&gt;&lt;a href=&quot;java/nio/file/spi/filesystemprovider&quot;&gt;file system provider&lt;/a&gt; to enumerate and read the class and resource files in a run-time image. The jrt file system can be created by calling &lt;a href=&quot;java/nio/file/filesystems#newFileSystem(java.net.URI,java.util.Map)&quot;&gt;&lt;code&gt;FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 JDK 구현은 런타임 이미지에서 클래스 및 리소스 파일을 열거하고 읽는 &lt;a id=&quot;jrt&quot;&gt;jrt &lt;/a&gt;&lt;a href=&quot;java/nio/file/spi/filesystemprovider&quot;&gt;파일 시스템 공급자&lt;/a&gt; 의 구현을 제공합니다 . jrt 파일 시스템은 &lt;a href=&quot;java/nio/file/filesystems#newFileSystem(java.net.URI,java.util.Map)&quot;&gt; &lt;code&gt;FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;))&lt;/code&gt; &lt;/a&gt; 을 호출하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="188f14a340d1f5ee331fb455e42c168ebbe17438" translate="yes" xml:space="preserve">
          <source>The JDK implementation of this module provides an implementation of the &lt;span id=&quot;jrt&quot;&gt;jrt&lt;/span&gt;&lt;a href=&quot;java/nio/file/spi/filesystemprovider&quot;&gt;file system provider&lt;/a&gt; to enumerate and read the class and resource files in a run-time image. The jrt file system can be created by calling &lt;a href=&quot;java/nio/file/filesystems#newFileSystem(java.net.URI,java.util.Map)&quot;&gt;&lt;code&gt;FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 JDK 구현은 런타임 이미지에서 클래스 및 리소스 파일을 열거하고 읽는 &lt;span id=&quot;jrt&quot;&gt;jrt &lt;/span&gt;&lt;a href=&quot;java/nio/file/spi/filesystemprovider&quot;&gt;파일 시스템 공급자&lt;/a&gt; 의 구현을 제공합니다 . jrt 파일 시스템은 &lt;a href=&quot;java/nio/file/filesystems#newFileSystem(java.net.URI,java.util.Map)&quot;&gt; &lt;code&gt;FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;))&lt;/code&gt; &lt;/a&gt; 을 호출하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="021fab3830ec0a1adca1cc2e47d263506f6a799d" translate="yes" xml:space="preserve">
          <source>The JDK implementation returns the cache size as set by the &lt;code&gt;setSessionCacheSize&lt;/code&gt; method, or if not set, the value of the &lt;code&gt;&lt;span id=&quot;javax.net.ssl.sessionCacheSize&quot;&gt;javax.net.ssl.sessionCacheSize&lt;/span&gt;&lt;/code&gt; system property. If neither is set, it returns a default value of 20480.</source>
          <target state="translated">JDK 구현은 &lt;code&gt;setSessionCacheSize&lt;/code&gt; 메서드에 의해 설정된 캐시 크기를 반환 하거나 설정되지 않은 경우 &lt;code&gt;&lt;span id=&quot;javax.net.ssl.sessionCacheSize&quot;&gt;javax.net.ssl.sessionCacheSize&lt;/span&gt;&lt;/code&gt; 시스템 속성 값을 반환 합니다. 둘 다 설정되지 않은 경우 기본값 20480을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ff828cede05c6d73aace767cbbd1fa03e209c5c1" translate="yes" xml:space="preserve">
          <source>The JDK implementation returns the cache size as set by the &lt;code&gt;setSessionCacheSize&lt;/code&gt; method, or if not set, the value of the system property. If neither is set, it returns a default value of 20480.</source>
          <target state="translated">JDK 구현은 &lt;code&gt;setSessionCacheSize&lt;/code&gt; 메서드에 의해 설정된 캐시 크기 또는 설정되지 않은 경우 시스템 속성 값을 반환합니다. 둘 다 설정되지 않은 경우 기본값 20480을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63abf37567a69daeb1c9eb0eac9845726723f07a" translate="yes" xml:space="preserve">
          <source>The JDK implementation returns the session timeout as set by the &lt;code&gt;setSessionTimeout&lt;/code&gt; method, or if not set, a default value of 86400 seconds (24 hours).</source>
          <target state="translated">JDK 구현은 &lt;code&gt;setSessionTimeout&lt;/code&gt; 메소드에 의해 설정된대로 세션 제한 시간을 리턴 하거나 설정되지 않은 경우 기본값 인 86400 초 (24 시간)를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="974bd73816215210a403a55fc57de388a401d79e" translate="yes" xml:space="preserve">
          <source>The JDK implementation supports static registration of the security providers via the &lt;code&gt;conf/security/java.security&lt;/code&gt; file in the Java installation directory. These providers are automatically installed by the JDK runtime, see &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jca_provider&quot;&gt;The Provider Class&lt;/a&gt; in the Java Cryptography Architecture (JCA) Reference Guide for information about how a particular type of provider, the cryptographic service provider, works and is installed.</source>
          <target state="translated">JDK 구현은 Java 설치 디렉토리 의 &lt;code&gt;conf/security/java.security&lt;/code&gt; 파일을 통해 보안 공급자의 정적 등록을 지원합니다 . 이러한 공급자는 JDK 런타임에 의해 자동으로 설치됩니다. 특정 유형의 공급자 인 암호화 서비스 공급자가 작동하고 설치되는 방법에 대한 자세한 내용은 JCA (Java Cryptography Architecture) 참조 가이드 &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=security_guide_jca_provider&quot;&gt;의 공급자 클래스&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e8321947a5392937c7a6036d74e85eb794e0aeb" translate="yes" xml:space="preserve">
          <source>The JDK implementation supports static registration of the security providers via the &lt;code&gt;conf/security/java.security&lt;/code&gt; file in the Java installation directory. These providers are automatically installed by the JDK runtime, see &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jca_provider&quot;&gt;The Provider Class&lt;/a&gt; in the Java Cryptography Architecture (JCA) Reference Guide for information about how a particular type of provider, the cryptographic service provider, works and is installed.</source>
          <target state="translated">JDK 구현은 Java 설치 디렉토리 의 &lt;code&gt;conf/security/java.security&lt;/code&gt; 파일을 통해 보안 공급자의 정적 등록을 지원합니다 . 이러한 공급자는 JDK 런타임에 의해 자동으로 설치됩니다. 특정 유형의 공급자 인 암호화 서비스 공급자가 작동하고 설치되는 방법에 대한 자세한 내용은 JCA (Java Cryptography Architecture) 참조 가이드 &lt;a href=&quot;https://www.oracle.com/pls/topic/lookup?ctx=javase11&amp;amp;id=security_guide_jca_provider&quot;&gt;의 공급자 클래스&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7977a89a83ddfc3d655c3423c1d5cef0ff1b4d9d" translate="yes" xml:space="preserve">
          <source>The JDK includes &lt;code&gt;PrintServiceLookup&lt;/code&gt; implementations that can locate the standard platform printers. To locate other types of printers, such as IPP printers or JINI printers, a print-service provider can write implementations of &lt;code&gt;PrintServiceLookup&lt;/code&gt;. The print-service provider can dynamically install these &lt;code&gt;PrintServiceLookup&lt;/code&gt; implementations using the  SPI JAR file specification.</source>
          <target state="translated">JDK에는 표준 플랫폼 프린터를 찾을 수있는 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 구현이 포함되어 있습니다. IPP 프린터 또는 JINI 프린터와 같은 다른 유형의 프린터를 찾기 위해 인쇄 서비스 제공 업체는 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 구현을 작성할 수 있습니다 . 인쇄 서비스 제공자는 SPI JAR 파일 스펙을 사용하여 이러한 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 구현을 동적으로 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95544c4457ec318de1023345ff557bed46437913" translate="yes" xml:space="preserve">
          <source>The JDK includes &lt;code&gt;PrintServiceLookup&lt;/code&gt; implementations that can locate the standard platform printers. To locate other types of printers, such as IPP printers or JINI printers, a print-service provider can write implementations of &lt;code&gt;PrintServiceLookup&lt;/code&gt;. The print-service provider can dynamically install these &lt;code&gt;PrintServiceLookup&lt;/code&gt; implementations using the &lt;a href=&quot;../../../java.base/java/util/serviceloader&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt; facility.</source>
          <target state="translated">JDK에는 표준 플랫폼 프린터를 찾을 수있는 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 구현이 포함되어 있습니다. IPP 프린터 또는 JINI 프린터와 같은 다른 유형의 프린터를 찾기 위해 인쇄 서비스 제공 업체는 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 구현을 작성할 수 있습니다 . 인쇄 서비스 공급자는 &lt;a href=&quot;../../../java.base/java/util/serviceloader&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 이러한 &lt;code&gt;PrintServiceLookup&lt;/code&gt; 구현을 동적으로 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d93514a78e7c9e81c3a6c2bad27a8106084096c" translate="yes" xml:space="preserve">
          <source>The JDK provides the following predefined content types:</source>
          <target state="translated">JDK는 다음과 같은 사전 정의 된 컨텐츠 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c17c58306c6fb36155552fb80a036d49556c883b" translate="yes" xml:space="preserve">
          <source>The JDK(tm) 1.1 rendering model is based on a pixelization model that specifies that coordinates are infinitely thin, lying between the pixels. Drawing operations are performed using a one-pixel wide pen that fills the pixel below and to the right of the anchor point on the path. The JDK 1.1 rendering model is consistent with the capabilities of most of the existing class of platform renderers that need to resolve integer coordinates to a discrete pen that must fall completely on a specified number of pixels.</source>
          <target state="translated">JDK (tm) 1.1 렌더링 모델은 좌표가 무한히 얇고 픽셀 사이에 위치하도록 지정하는 픽셀 화 모델을 기반으로합니다. 그리기 작업은 경로의 앵커 포인트 아래 및 오른쪽에있는 픽셀을 채우는 1 픽셀 너비의 펜을 사용하여 수행됩니다. JDK 1.1 렌더링 모델은 정수 좌표를 지정된 픽셀 수에 완전히 포함되어야하는 개별 펜으로 해석해야하는 기존 클래스의 플랫폼 렌더러 대부분의 기능과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b4df1f98a0565fca9a29ad6073a1bc23033b2822" translate="yes" xml:space="preserve">
          <source>The JList used for representing the files is created by subclasses, but the selection is monitored in this class.</source>
          <target state="translated">파일을 나타내는 데 사용되는 JList는 서브 클래스에 의해 생성되지만 선택은이 클래스에서 모니터링됩니다.</target>
        </trans-unit>
        <trans-unit id="7224bc9a099b77a16bc3be0479f9b05ff7eb1a25" translate="yes" xml:space="preserve">
          <source>The JList used for representing the files is created by subclasses, but the selection is monitored in this class. The TransferHandler installed in the JFileChooser is also installed in the file list as it is used as the actual transfer source. The list is updated on a mouse enter to reflect the current data transfer state of the file chooser.</source>
          <target state="translated">파일을 나타내는 데 사용되는 JList는 서브 클래스에 의해 생성되지만 선택은이 클래스에서 모니터링됩니다. JFileChooser에 설치된 TransferHandler는 실제 전송 소스로 사용되기 때문에 파일 목록에도 설치됩니다. 마우스 입력시 목록이 업데이트되어 파일 선택기의 현재 데이터 전송 상태를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="adacbc5dc9ca937440df58f189dfa0a26e578715" translate="yes" xml:space="preserve">
          <source>The JMM specifically allows optimizing compilers to elide reads or writes of variables that are known to be useless. Such elided reads and writes have no effect on the happens-before relation. Regardless of this fact, the volatile &lt;code&gt;V&lt;/code&gt; will not be elided, even though its written value is indeterminate and its read value is not used.</source>
          <target state="translated">JMM을 사용하면 최적화 컴파일러가 쓸모없는 것으로 알려진 변수의 읽기 또는 쓰기를 생략 할 수 있습니다. 이러한 생략 된 읽기 및 쓰기는 이전에 발생한 관계에 영향을 미치지 않습니다. 이러한 사실에 관계없이, 휘발성 &lt;code&gt;V&lt;/code&gt; 는 기록 된 값이 불확실하고 판독 값이 사용되지 않더라도 제거되지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="245a29e6968c20703520c2a92906f5e9e0f071ea" translate="yes" xml:space="preserve">
          <source>The JMX API can also be used as part of a solution for managing systems, networks, and so on.</source>
          <target state="translated">JMX API는 시스템, 네트워크 등을 관리하기위한 솔루션의 일부로 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcfd357aa0013a97754ba965d15a09dda3cf149c" translate="yes" xml:space="preserve">
          <source>The JMX API consists of interfaces for monitoring and management of the JVM and other components in the Java runtime.</source>
          <target state="translated">JMX API는 Java 런타임의 JVM 및 기타 구성 요소를 모니터링하고 관리하기위한 인터페이스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="44195781584f2d466ba7e2c1a615da361d712792" translate="yes" xml:space="preserve">
          <source>The JMX Remote API also defines an optional connector called &lt;b&gt;JMXMP Connector&lt;/b&gt; implementing the JMX Message Protocol (JMXMP). As it is optional, it is not part of this bundle (see note below).</source>
          <target state="translated">JMX 원격 API는 &lt;b&gt;JMXMP&lt;/b&gt; (JMX Message Protocol)를 구현하는 &lt;b&gt;JMXMP&lt;/b&gt; 커넥터라는 선택적 커넥터도 정의합니다 . 선택 사항이므로이 번들의 일부가 아닙니다 (아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="49ce3ebe998d499efd4c77a77394ab17b1f03636" translate="yes" xml:space="preserve">
          <source>The JMX Remote API defines a standard connector, the &lt;b&gt;RMI Connector&lt;/b&gt;, which provides remote access to an MBeanServer through RMI.</source>
          <target state="translated">JMX Remote API는 &lt;b&gt;RMI&lt;/b&gt; 를 통해 MBeanServer에 대한 원격 액세스를 제공 하는 표준 커넥터 &lt;b&gt;RMI Connector를&lt;/b&gt; 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="fd57cf73dfe60c2aa55ec8129a23ade5a302d5fa" translate="yes" xml:space="preserve">
          <source>The JMX specification also defines the notion of an &lt;em&gt;adaptor&lt;/em&gt;. An adaptor translates between requests in a protocol such as SNMP or HTML and accesses to an MBean Server. So for example an SNMP GET operation might result in a &lt;code&gt;getAttribute&lt;/code&gt; on the MBean Server.</source>
          <target state="translated">JMX 사양은 또한 &lt;em&gt;어댑터&lt;/em&gt; 의 개념을 정의합니다 . 어댑터는 SNMP 또는 HTML과 같은 프로토콜의 요청 간을 변환하고 MBean 서버에 액세스합니다. 예를 들어 SNMP GET 조작 으로 인해 MBean 서버 에서 &lt;code&gt;getAttribute&lt;/code&gt; 가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad7600c1b4c4869f0bb7b9d742500b17e728fe9b" translate="yes" xml:space="preserve">
          <source>The JMX specification defines the notion of &lt;b&gt;connectors&lt;/b&gt;. A connector is attached to a JMX API MBean server and makes it accessible to remote Java clients. The client end of a connector exports essentially the same interface as the MBean server, specifically the &lt;a href=&quot;../mbeanserverconnection&quot;&gt;&lt;code&gt;MBeanServerConnection&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">JMX 사양은 &lt;b&gt;커넥터&lt;/b&gt; 의 개념을 정의합니다 . 커넥터는 JMX API MBean 서버에 접속되어 원격 Java 클라이언트가 액세스 할 수있게합니다. 커넥터의 클라이언트 쪽은 기본적으로 MBean 서버와 동일한 인터페이스, 특히 &lt;a href=&quot;../mbeanserverconnection&quot;&gt; &lt;code&gt;MBeanServerConnection&lt;/code&gt; &lt;/a&gt; 인터페이스를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="49f18bdd1f1d911533de33e739a8c7e69a6ea6ce" translate="yes" xml:space="preserve">
          <source>The JNDI API Specification and related documents can be found in the &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=jndi_overview&quot;&gt;JNDI documentation&lt;/a&gt;.</source>
          <target state="translated">JNDI API 사양 및 관련 문서는 &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=jndi_overview&quot;&gt;JNDI 문서&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48496ba0da8b75b3e524f0a5ef74f428d1bc62c0" translate="yes" xml:space="preserve">
          <source>The JNDI SPI Specification and related documents can be found in the &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=jndi_overview&quot;&gt;JNDI documentation&lt;/a&gt;.</source>
          <target state="translated">JNDI SPI 사양 및 관련 문서는 &lt;a href=&quot;https://docs.oracle.com/pls/topic/lookup?ctx=javase15&amp;amp;id=jndi_overview&quot;&gt;JNDI 문서&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96af366dabe06f77839ee8dbe7885151d35d2d4b" translate="yes" xml:space="preserve">
          <source>The JNDI SPI provides the means for creating JNDI service providers, through which JNDI applications access different naming and directory services.</source>
          <target state="translated">JNDI SPI는 JNDI 응용 프로그램이 다른 이름 지정 및 디렉토리 서비스에 액세스하는 JNDI 서비스 공급자를 만드는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33732f94d8d93f615200108becd1fb08f06a0bea" translate="yes" xml:space="preserve">
          <source>The JNDI class library reads the resource files and makes the property values freely available. Thus JNDI resource files should be considered to be &quot;world readable&quot;, and sensitive information such as clear-text passwords should not be stored there.</source>
          <target state="translated">JNDI 클래스 라이브러리는 자원 파일을 읽고 특성 값을 자유롭게 사용할 수있게합니다. 따라서 JNDI 자원 파일은 &quot;세계가 읽을 수있는&quot;것으로 간주되어야하며 일반 텍스트 비밀번호와 같은 민감한 정보는 저장되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="088d7c9d898f7a840b1256be8ddef986f15194cb" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for different initial context implementations to be specified at runtime. An initial context is created using an initial context factory. A program can install its own builder that creates initial context factories, thereby overriding the default policies used by the framework, by calling NamingManager.setInitialContextFactoryBuilder(). The InitialContextFactoryBuilder interface must be implemented by such a builder.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 런타임시 서로 다른 초기 컨텍스트 구현을 지정할 수 있습니다. 초기 컨텍스트 팩토리를 사용하여 초기 컨텍스트가 작성됩니다. 프로그램은 초기 컨텍스트 팩토리를 작성하는 자체 빌더를 설치하여 NamingManager.setInitialContextFactoryBuilder ()를 호출하여 프레임 워크에서 사용하는 기본 정책을 대체합니다. InitialContextFactoryBuilder 인터페이스는 이러한 빌더로 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="d098149f3977423197730ce483608b5d9c5ba323" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for different initial context implementations to be specified at runtime. The initial context is created using an &lt;em&gt;initial context factory&lt;/em&gt;. An initial context factory must implement the InitialContextFactory interface, which provides a method for creating instances of initial context that implement the Context interface. In addition, the factory class must be public and must have a public constructor that accepts no arguments.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 런타임시 서로 다른 초기 컨텍스트 구현을 지정할 수 있습니다. 초기 컨텍스트는 &lt;em&gt;초기 컨텍스트 팩토리를&lt;/em&gt; 사용하여 작성됩니다 . 초기 컨텍스트 팩토리는 Context 인터페이스를 구현하는 초기 컨텍스트 인스턴스를 작성하는 메소드를 제공하는 InitialContextFactory 인터페이스를 구현해야합니다. 또한 팩토리 클래스는 공용이어야하며 인수를 허용하지 않는 공용 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b9064bba67a68203f58a597fa1fa3afbedec89f6" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;code&gt;object factories&lt;/code&gt;.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 &lt;code&gt;object factories&lt;/code&gt; 를 통해 객체 구현을 동적으로로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="134c5f63e690609e9c6a657638ccd21e3550dca4" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;em&gt;object factories&lt;/em&gt;. For example, when looking up a printer bound in the name space, if the print service binds printer names to &lt;code&gt;Reference&lt;/code&gt;s, the printer &lt;code&gt;Reference&lt;/code&gt; could be used to create a printer object, so that the caller of lookup can directly operate on the printer object after the lookup.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 &lt;em&gt;객체 팩토리&lt;/em&gt; 를 통해 &lt;em&gt;객체&lt;/em&gt; 구현을 동적으로로드 할 수 있습니다 . 예를 들어, 네임 스페이스에 바인딩 된 프린터를 &lt;code&gt;Reference&lt;/code&gt; 할 때 인쇄 서비스가 프린터 이름을 Reference에 바인딩 하면 프린터 &lt;code&gt;Reference&lt;/code&gt; 를 사용하여 프린터 개체를 만들 수 있으므로 조회 호출자가 프린터 개체에서 직접 작동 할 수 있습니다 조회 후.</target>
        </trans-unit>
        <trans-unit id="f3b7acec5238c7d2dd7fa0082fb8db71d5d2e9ed" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;em&gt;object factories&lt;/em&gt;. For example, when looking up a printer bound in the name space, if the print service binds printer names to References, the printer Reference could be used to create a printer object, so that the caller of lookup can directly operate on the printer object after the lookup.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 &lt;em&gt;객체 팩토리&lt;/em&gt; 를 통해 &lt;em&gt;객체&lt;/em&gt; 구현을 동적으로로드 할 수 있습니다 . 예를 들어, 네임 스페이스에 바인딩 된 프린터를 조회 할 때 인쇄 서비스가 프린터 이름을 참조에 바인딩하는 경우 프린터 참조를 사용하여 프린터 개체를 생성 할 수 있으므로 프린터 호출자가 프린터 개체에서 직접 작업 할 수 있습니다. 조회.</target>
        </trans-unit>
        <trans-unit id="0f159102714c8eb7af6cff7ee4872dd30ee0cf55" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;em&gt;object factories&lt;/em&gt;. For example, when looking up a printer bound in the name space, if the print service binds printer names to References, the printer Reference could be used to create a printer object, so that the caller of lookup can directly operate on the printer object after the lookup. An ObjectFactory is responsible for creating objects of a specific type. JNDI uses a default policy for using and loading object factories. You can override this default policy by calling &lt;code&gt;NamingManager.setObjectFactoryBuilder()&lt;/code&gt; with an ObjectFactoryBuilder, which contains the program-defined way of creating/loading object factories. Any &lt;code&gt;ObjectFactoryBuilder&lt;/code&gt; implementation must implement this interface that for creating object factories.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 &lt;em&gt;객체 팩토리&lt;/em&gt; 를 통해 &lt;em&gt;객체&lt;/em&gt; 구현을 동적으로로드 할 수 있습니다 . 예를 들어, 네임 스페이스에 바인딩 된 프린터를 조회 할 때 인쇄 서비스가 프린터 이름을 참조에 바인딩하는 경우 프린터 참조를 사용하여 프린터 개체를 생성 할 수 있으므로 프린터 호출자가 프린터 개체에서 직접 작업 할 수 있습니다. 조회. ObjectFactory는 특정 유형의 객체를 생성합니다. JNDI는 객체 팩토리 사용 및로드에 기본 정책을 사용합니다. ObjectFactoryBuilder와 함께 &lt;code&gt;NamingManager.setObjectFactoryBuilder()&lt;/code&gt; 를 호출하여이 기본 정책을 재정의 할 수 있습니다 . ObjectFactoryBuilder에는 오브젝트 팩토리를 작성 /로드하는 프로그램 정의 방법이 포함되어 있습니다. 모든 &lt;code&gt;ObjectFactoryBuilder&lt;/code&gt; 구현은 객체 팩토리를 작성하기위한이 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="88db5d84ce039b71278336e8b1b44b578aa0d61d" translate="yes" xml:space="preserve">
          <source>The JNDI framework allows for object implementations to be loaded in dynamically via &lt;em&gt;object factories&lt;/em&gt;. See &lt;code&gt;ObjectFactory&lt;/code&gt; for details.</source>
          <target state="translated">JNDI 프레임 워크를 사용하면 &lt;em&gt;객체 팩토리&lt;/em&gt; 를 통해 &lt;em&gt;객체&lt;/em&gt; 구현을 동적으로로드 할 수 있습니다 . 자세한 내용은 &lt;code&gt;ObjectFactory&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5669f05609b02ee4c44fdaa5adbcabc508864f50" translate="yes" xml:space="preserve">
          <source>The JNDI library will consult the provider resource file when determining the values of these properties. Properties other than these may be set in the provider resource file at the discretion of the service provider. The service provider's documentation should clearly state which properties are allowed; other properties in the file will be ignored.</source>
          <target state="translated">JNDI 라이브러리는 이러한 특성 값을 결정할 때 제공자 자원 파일을 참조합니다. 이들 이외의 속성은 서비스 공급자의 판단에 따라 공급자 리소스 파일에 설정 될 수 있습니다. 서비스 제공 업체의 문서에는 어떤 속성이 허용되는지 명시해야합니다. 파일의 다른 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bec69931581644a1ef0084216dc02cc47be425fa" translate="yes" xml:space="preserve">
          <source>The JNDI name of the resource. For field annotations, the default is the field name. For method annotations, the default is the JavaBeans property name corresponding to the method. For class annotations, there is no default and this must be specified.</source>
          <target state="translated">자원의 JNDI 이름 필드 주석의 경우 기본값은 필드 이름입니다. 메소드 어노테이션의 경우 기본값은 메소드에 해당하는 JavaBeans 특성 이름입니다. 클래스 주석의 경우 기본값이 없으므로이를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="edc24d0f37d47900732cfdcdc56bc8ec2f6044ca" translate="yes" xml:space="preserve">
          <source>The JPS API is designed to be used in Java profiles which do not support AWT.</source>
          <target state="translated">JPS API는 AWT를 지원하지 않는 Java 프로파일에서 사용하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="363b84f0385d00914c1240423dd0f5bb6b4ee6f6" translate="yes" xml:space="preserve">
          <source>The JRE data transfer implementation interprets the parameter &quot;class&quot; of a MIME type as &lt;b&gt;a representation class&lt;/b&gt;. The representation class reflects the class of the object being transferred. In other words, the representation class is the type of object returned by &lt;a href=&quot;transferable#getTransferData(java.awt.datatransfer.DataFlavor)&quot;&gt;&lt;code&gt;Transferable.getTransferData(java.awt.datatransfer.DataFlavor)&lt;/code&gt;&lt;/a&gt;. For example, the MIME type of &lt;a href=&quot;#imageFlavor&quot;&gt;&lt;code&gt;imageFlavor&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;&quot;image/x-java-image;class=java.awt.Image&quot;&lt;/code&gt;, the primary type is &lt;code&gt;image&lt;/code&gt;, the subtype is &lt;code&gt;x-java-image&lt;/code&gt;, and the representation class is &lt;code&gt;java.awt.Image&lt;/code&gt;. When &lt;code&gt;getTransferData&lt;/code&gt; is invoked with a &lt;code&gt;DataFlavor&lt;/code&gt; of &lt;code&gt;imageFlavor&lt;/code&gt;, an instance of &lt;code&gt;java.awt.Image&lt;/code&gt; is returned. It's important to note that &lt;code&gt;DataFlavor&lt;/code&gt; does no error checking against the representation class. It is up to consumers of &lt;code&gt;DataFlavor&lt;/code&gt;, such as &lt;code&gt;Transferable&lt;/code&gt;, to honor the representation class.</source>
          <target state="translated">JRE 데이터 전송 구현은 MIME 유형의 &quot;클래스&quot;매개 변수를 &lt;b&gt;표현 클래스&lt;/b&gt; 로 해석합니다 . 표현 클래스는 전송되는 객체의 클래스를 반영합니다. 즉, 표현 클래스는 &lt;a href=&quot;transferable#getTransferData(java.awt.datatransfer.DataFlavor)&quot;&gt; &lt;code&gt;Transferable.getTransferData(java.awt.datatransfer.DataFlavor)&lt;/code&gt; &lt;/a&gt; 의해 반환 된 객체의 유형입니다 . 예를 들어, &lt;a href=&quot;#imageFlavor&quot;&gt; &lt;code&gt;imageFlavor&lt;/code&gt; &lt;/a&gt; 의 MIME 유형 은 &lt;code&gt;&quot;image/x-java-image;class=java.awt.Image&quot;&lt;/code&gt; , 기본 유형은 &lt;code&gt;image&lt;/code&gt; , 하위 유형은 &lt;code&gt;x-java-image&lt;/code&gt; , 표현 클래스는 &lt;code&gt;java.awt.Image&lt;/code&gt; . 시 &lt;code&gt;getTransferData&lt;/code&gt; 를 호출 &lt;code&gt;DataFlavor&lt;/code&gt; 의 &lt;code&gt;imageFlavor&lt;/code&gt; , &lt;code&gt;java.awt.Image&lt;/code&gt; 의 인스턴스 가 리턴됩니다. &lt;code&gt;DataFlavor&lt;/code&gt; 는 표현 클래스에 대해 오류 검사를하지 않는다는 점에 유의하는 것이 중요합니다 . 표현 클래스를 존중하는 것은 &lt;code&gt;Transferable&lt;/code&gt; 과 같은 &lt;code&gt;DataFlavor&lt;/code&gt; 소비자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="17a160f7d45e8174e9c03f104bfe115657a97de9" translate="yes" xml:space="preserve">
          <source>The JScrollPane component creates scrollbars (by default) that override this method and delegate to the viewports Scrollable view, if it has one. The Scrollable interface provides a more specialized version of this method.</source>
          <target state="translated">JScrollPane 구성 요소는이 메서드를 재정의하는 스크롤바 (기본적으로)를 생성하고 스크롤 가능 뷰가있는 경우 뷰포트 스크롤 가능 뷰에 위임합니다. Scrollable 인터페이스는이 메서드의보다 전문화 된 버전을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e1ae955d51e9234dabbd5ff6619ba90b3d308714" translate="yes" xml:space="preserve">
          <source>The JShell evaluation state engine.</source>
          <target state="translated">JShell 평가 상태 엔진.</target>
        </trans-unit>
        <trans-unit id="808c7d2879dd45bb29a0e22373995ee648166124" translate="yes" xml:space="preserve">
          <source>The JShell evaluation state engine. This is the central class in the JShell API. A &lt;code&gt;JShell&lt;/code&gt; instance holds the evolving compilation and execution state. The state is changed with the instance methods &lt;a href=&quot;#eval(java.lang.String)&quot;&gt;&lt;code&gt;eval(String)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#drop(jdk.jshell.Snippet)&quot;&gt;&lt;code&gt;drop(Snippet)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#addToClasspath(java.lang.String)&quot;&gt;&lt;code&gt;addToClasspath(String)&lt;/code&gt;&lt;/a&gt;. The majority of methods query the state. A &lt;code&gt;JShell&lt;/code&gt; instance also allows registering for events with &lt;a href=&quot;#onSnippetEvent(java.util.function.Consumer)&quot;&gt;&lt;code&gt;onSnippetEvent(Consumer)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#onShutdown(java.util.function.Consumer)&quot;&gt;&lt;code&gt;onShutdown(Consumer)&lt;/code&gt;&lt;/a&gt;, which are unregistered with &lt;a href=&quot;#unsubscribe(jdk.jshell.JShell.Subscription)&quot;&gt;&lt;code&gt;unsubscribe(Subscription)&lt;/code&gt;&lt;/a&gt;. Access to the source analysis utilities is via &lt;a href=&quot;#sourceCodeAnalysis()&quot;&gt;&lt;code&gt;sourceCodeAnalysis()&lt;/code&gt;&lt;/a&gt;. When complete the instance should be closed to free resources -- &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JShell 평가 상태 엔진. 이것은 JShell API의 중심 클래스입니다. &lt;code&gt;JShell&lt;/code&gt; 의 인스턴스는 진화 컴파일 및 실행 상태를 유지한다. 상태는 인스턴스 메소드 &lt;a href=&quot;#eval(java.lang.String)&quot;&gt; &lt;code&gt;eval(String)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#drop(jdk.jshell.Snippet)&quot;&gt; &lt;code&gt;drop(Snippet)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#addToClasspath(java.lang.String)&quot;&gt; &lt;code&gt;addToClasspath(String)&lt;/code&gt; &lt;/a&gt; 됩니다. 대부분의 메서드는 상태를 쿼리합니다. &lt;code&gt;JShell&lt;/code&gt; 의 예를도와 이벤트에 등록 할 수 있습니다 &lt;a href=&quot;#onSnippetEvent(java.util.function.Consumer)&quot;&gt; &lt;code&gt;onSnippetEvent(Consumer)&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#onShutdown(java.util.function.Consumer)&quot;&gt; &lt;code&gt;onShutdown(Consumer)&lt;/code&gt; &lt;/a&gt; 로 등록 해제되어, &lt;a href=&quot;#unsubscribe(jdk.jshell.JShell.Subscription)&quot;&gt; &lt;code&gt;unsubscribe(Subscription)&lt;/code&gt; &lt;/a&gt; . 소스 분석 유틸리티에 대한 액세스는 &lt;a href=&quot;#sourceCodeAnalysis()&quot;&gt; &lt;code&gt;sourceCodeAnalysis()&lt;/code&gt; &lt;/a&gt; 를 통해 이루어 집니다. 완료되면 인스턴스를 닫아 리소스를 해제해야합니다-close &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8578472fe170c11efcaca36252367b026245c2be" translate="yes" xml:space="preserve">
          <source>The JVM bytecode format supports immediate constants of the classes &lt;a href=&quot;methodhandle&quot;&gt;&lt;code&gt;MethodHandle&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;methodtype&quot;&gt;&lt;code&gt;MethodType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JVM 바이트 코드 형식은 &lt;a href=&quot;methodhandle&quot;&gt; &lt;code&gt;MethodHandle&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;methodtype&quot;&gt; &lt;code&gt;MethodType&lt;/code&gt; &lt;/a&gt; 클래스의 즉시 상수를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="423700bf3f40eb8f7ae2196876409f2568dcd9ca" translate="yes" xml:space="preserve">
          <source>The JVM imposes a similar requirement on &lt;code&gt;invokespecial&lt;/code&gt; instruction, that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt; the current class. Again, this requirement is enforced by narrowing the type of the leading parameter to the resulting method handle. (See the Java Virtual Machine Specification, section 4.10.1.9.)</source>
          <target state="translated">JVM은 &lt;code&gt;invokespecial&lt;/code&gt; 명령 에 대해 비슷한 요구 사항을 적용 합니다. 수신자 인수는 해결 된 메소드 &lt;em&gt;와&lt;/em&gt; 현재 클래스 모두와 일치해야합니다 . 이 요구 사항은 선행 매개 변수의 유형을 결과 메소드 핸들로 좁혀서 적용됩니다. (Java 가상 머신 사양, 섹션 4.10.1.9 참조)</target>
        </trans-unit>
        <trans-unit id="5c33c025595843b85ed46d8fb1228a2c6476481b" translate="yes" xml:space="preserve">
          <source>The JVM imposes a similar requirement on &lt;code&gt;invokespecial&lt;/code&gt; instruction, that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt; the current class. Again, this requirement is enforced by narrowing the type of the leading parameter to the resulting method handle. (See the Java Virtual Machine Specification, section &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.10.1.9&quot;&gt;4.10.1.9&lt;/a&gt;.)</source>
          <target state="translated">JVM은 &lt;code&gt;invokespecial&lt;/code&gt; 명령어 에 유사한 요구 사항을 부과 합니다. 수신자 인수는 해결 된 메소드 &lt;em&gt;와&lt;/em&gt; 현재 클래스 모두와 일치해야합니다 . 다시 말하지만,이 요구 사항은 선행 매개 변수의 유형을 결과 메서드 핸들로 좁혀서 적용됩니다. (Java Virtual Machine 사양, 섹션 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-4.html#jls-4.10.1.9&quot;&gt;4.10.1.9&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="f6a937822298d3770df670d2d33f12a835018bdf" translate="yes" xml:space="preserve">
          <source>The JVM imposes on all methods and constructors of any kind an absolute limit of 255 stacked arguments. This limit can appear more restrictive in certain cases:</source>
          <target state="translated">JVM은 모든 메소드 및 생성자에 255 개의 누적 인수의 절대 한계를 부과합니다. 이 제한은 특정 경우 더 제한적으로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc6a5c598e3c5bccd4ab59217eeb5725b65103d3" translate="yes" xml:space="preserve">
          <source>The JVM represents constructors and static initializer blocks as internal methods with special names (&lt;code&gt;&quot;&amp;lt;init&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;&amp;lt;clinit&amp;gt;&quot;&lt;/code&gt;). The internal syntax of invocation instructions allows them to refer to such internal methods as if they were normal methods, but the JVM bytecode verifier rejects them. A lookup of such an internal method will produce a &lt;code&gt;NoSuchMethodException&lt;/code&gt;.</source>
          <target state="translated">JVM은 생성자와 정적 이니셜 라이저 블록을 특수 이름 ( &lt;code&gt;&quot;&amp;lt;init&amp;gt;&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;&amp;lt;clinit&amp;gt;&quot;&lt;/code&gt; )의 내부 메소드로 나타냅니다 . 호출 명령의 내부 구문을 사용하면 마치 내부 메소드가 일반 메소드 인 것처럼 내부 메소드를 참조 할 수 있지만 JVM 바이트 코드 검증기는이를 거부합니다. 이러한 내부 메소드를 검색하면 &lt;code&gt;NoSuchMethodException&lt;/code&gt; 이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="4bed2dbd7bc1a0a64894245adfbe5487e3761dab" translate="yes" xml:space="preserve">
          <source>The Japanese Imperial calendar system is the same as the ISO calendar system apart from the era-based year numbering. The proleptic-year is defined to be equal to the ISO proleptic-year.</source>
          <target state="translated">일본 제국 달력 시스템은 시대 별 연도 번호를 제외하고 ISO 달력 시스템과 동일합니다. proleptic-year는 ISO proleptic-year와 같은 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1377cea6a56d5ed563cbb1106ccb49deee8306eb" translate="yes" xml:space="preserve">
          <source>The Japanese Imperial calendar system.</source>
          <target state="translated">일본 황실 달력 시스템.</target>
        </trans-unit>
        <trans-unit id="7564ca9cd9ffac61a50b36479cc4d2f52a3b5c1f" translate="yes" xml:space="preserve">
          <source>The Japanese calendar system has multiple eras defined by &lt;a href=&quot;japaneseera&quot;&gt;&lt;code&gt;JapaneseEra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일본어 달력 시스템에는 &lt;a href=&quot;japaneseera&quot;&gt; &lt;code&gt;JapaneseEra&lt;/code&gt; 에&lt;/a&gt; 의해 정의 된 여러 시대가 있습니다.</target>
        </trans-unit>
        <trans-unit id="04fc513b47cf3ef30849ce129084aceb11af3867" translate="yes" xml:space="preserve">
          <source>The Japanese government defines the official name and start date of each era. Eras are consecutive and their date ranges do not overlap, so the end date of one era is always the day before the start date of the next era.</source>
          <target state="translated">일본 정부는 각 시대의 공식 명칭과 시작일을 정의합니다. Eras는 연속적이며 날짜 범위가 겹치지 않으므로 한 시대의 종료 날짜는 항상 다음 시대의 시작 날짜 전날입니다.</target>
        </trans-unit>
        <trans-unit id="265e051cf5be43bb91edb907b6aaa5aa90a2b761" translate="yes" xml:space="preserve">
          <source>The Japanese month and day-of-month are the same as those in the ISO calendar system. They are not reset when the era changes. For example:</source>
          <target state="translated">일본어 월 및 월은 ISO 캘린더 시스템과 동일합니다. 시대가 바뀌더라도 재설정되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a132e736768e81687dffdd4d971dcc6de9796ad" translate="yes" xml:space="preserve">
          <source>The Japanese proleptic year, month and day-of-month are the same as those in the ISO calendar system. They are not reset when the era changes.</source>
          <target state="translated">일본의 proleptic 연도, 월, 일은 ISO 캘린더 시스템과 동일합니다. 시대가 바뀌더라도 재설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab077295795f59b02a71b197389bd1772b628d47" translate="yes" xml:space="preserve">
          <source>The Java 2D(tm) (Java(tm) 2 platform) API supports antialiasing renderers. A pen with a width of one pixel does not need to fall completely on pixel N as opposed to pixel N+1. The pen can fall partially on both pixels. It is not necessary to choose a bias direction for a wide pen since the blending that occurs along the pen traversal edges makes the sub-pixel position of the pen visible to the user. On the other hand, when antialiasing is turned off by setting the &lt;a href=&quot;renderinghints#KEY_ANTIALIASING&quot;&gt;&lt;code&gt;KEY_ANTIALIASING&lt;/code&gt;&lt;/a&gt; hint key to the &lt;a href=&quot;renderinghints#VALUE_ANTIALIAS_OFF&quot;&gt;&lt;code&gt;VALUE_ANTIALIAS_OFF&lt;/code&gt;&lt;/a&gt; hint value, the renderer might need to apply a bias to determine which pixel to modify when the pen is straddling a pixel boundary, such as when it is drawn along an integer coordinate in device space. While the capabilities of an antialiasing renderer make it no longer necessary for the rendering model to specify a bias for the pen, it is desirable for the antialiasing and non-antialiasing renderers to perform similarly for the common cases of drawing one-pixel wide horizontal and vertical lines on the screen. To ensure that turning on antialiasing by setting the &lt;a href=&quot;renderinghints#KEY_ANTIALIASING&quot;&gt;&lt;code&gt;KEY_ANTIALIASING&lt;/code&gt;&lt;/a&gt; hint key to &lt;a href=&quot;renderinghints#VALUE_ANTIALIAS_ON&quot;&gt;&lt;code&gt;VALUE_ANTIALIAS_ON&lt;/code&gt;&lt;/a&gt; does not cause such lines to suddenly become twice as wide and half as opaque, it is desirable to have the model specify a path for such lines so that they completely cover a particular set of pixels to help increase their crispness.</source>
          <target state="translated">Java 2D (tm) (Java (tm) 2 플랫폼) API는 앤티 앨리어싱 렌더러를 지원합니다. 너비가 1 픽셀 인 펜은 픽셀 N + 1과 달리 픽셀 N에 완전히 떨어질 필요가 없습니다. 펜이 두 픽셀에서 부분적으로 떨어질 수 있습니다. 펜 횡단 가장자리를 따라 발생하는 블렌딩으로 인해 펜의 하위 픽셀 위치가 사용자에게 표시되므로 넓은 펜에 대해 바이어스 방향을 선택할 필요가 없습니다. 반면에 &lt;a href=&quot;renderinghints#KEY_ANTIALIASING&quot;&gt; &lt;code&gt;KEY_ANTIALIASING&lt;/code&gt; &lt;/a&gt; 힌트 키를 &lt;a href=&quot;renderinghints#VALUE_ANTIALIAS_OFF&quot;&gt; &lt;code&gt;VALUE_ANTIALIAS_OFF&lt;/code&gt; &lt;/a&gt; 로 설정하여 앤티 앨리어싱을 끄면힌트 값의 경우, 렌더러는 장치 공간에서 정수 좌표를 따라 그려지는 경우와 같이 펜이 픽셀 경계에 걸쳐있을 때 수정할 픽셀을 결정하기 위해 바이어스를 적용해야 할 수 있습니다. 앤티 앨리어싱 렌더러의 기능으로 인해 렌더링 모델에서 더 이상 펜에 대한 바이어스를 지정할 필요가 없지만, 앤티 앨리어싱 및 비 앤티 앨리어싱 렌더러는 일반적인 경우 1 픽셀 너비의 수평 및 화면에 수직선. &lt;a href=&quot;renderinghints#KEY_ANTIALIASING&quot;&gt; &lt;code&gt;KEY_ANTIALIASING&lt;/code&gt; &lt;/a&gt; 힌트 키를 &lt;a href=&quot;renderinghints#VALUE_ANTIALIAS_ON&quot;&gt; &lt;code&gt;VALUE_ANTIALIAS_ON&lt;/code&gt; &lt;/a&gt; 으로 설정하여 앤티 앨리어싱을 켜려면 이러한 선이 갑자기 폭의 두 배와 불투명하게 절반이되지 않도록 모델이 해당 선의 경로를 지정하여 선명도를 높이기 위해 특정 픽셀 집합을 완전히 덮도록하는 것이 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="0fbc55fe3353d168165d01c77ce52a7169349fae" translate="yes" xml:space="preserve">
          <source>The Java AWT Native Interface (JAWT)</source>
          <target state="translated">자바 AWT 네이티브 인터페이스 (JAWT)</target>
        </trans-unit>
        <trans-unit id="3db037c857875b9fa1012171be8083c44281dea6" translate="yes" xml:space="preserve">
          <source>The Java Accessibility API package consists of 8 Java programming language interfaces, and 6 Java programming language classes. These are described below.</source>
          <target state="translated">Java Accessibility API 패키지는 8 개의 Java 프로그래밍 언어 인터페이스와 6 개의 Java 프로그래밍 언어 클래스로 구성됩니다. 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec9ce57118dd5eeebc30267a59845414305f39c4" translate="yes" xml:space="preserve">
          <source>The Java Debug Interface (JDI) is a high level Java API providing information useful for debuggers and similar systems needing access to the running state of a (usually remote) virtual machine.</source>
          <target state="translated">JDI (Java Debug Interface)는 (일반적으로 원격) 가상 머신의 실행 상태에 액세스해야하는 디버거 및 유사한 시스템에 유용한 정보를 제공하는 고급 Java API입니다.</target>
        </trans-unit>
        <trans-unit id="c7cd6bf18e5d512749050266dad5e8ad183ff281" translate="yes" xml:space="preserve">
          <source>The Java Development Kit (JDK) APIs are specific to the JDK and will not necessarily be available in all implementations of the Java SE Platform. These APIs are in modules whose names start with &lt;code&gt;jdk&lt;/code&gt;.</source>
          <target state="translated">JDK (Java Development Kit) API는 JDK에 고유하며 Java SE 플랫폼의 모든 구현에서 반드시 사용할 수있는 것은 아닙니다. 이러한 API는 이름이 &lt;code&gt;jdk&lt;/code&gt; 로 시작하는 모듈에 있습니다.</target>
        </trans-unit>
        <trans-unit id="61602e7596e12b632597fd4f988db4b318fd0d87" translate="yes" xml:space="preserve">
          <source>The Java Language Specification</source>
          <target state="translated">자바 언어 사양</target>
        </trans-unit>
        <trans-unit id="ebc6437d60221359ee032cd72734c3e893152ecb" translate="yes" xml:space="preserve">
          <source>The Java Language Specification, First Edition</source>
          <target state="translated">자바 언어 사양, 초판</target>
        </trans-unit>
        <trans-unit id="c6d7523255fa435c106227002fd7691eedcdb254" translate="yes" xml:space="preserve">
          <source>The Java Language Specification, Second Edition</source>
          <target state="translated">자바 언어 사양, 제 2 판</target>
        </trans-unit>
        <trans-unit id="3f4704dd2a636040f03c24e57dbdac4f22ec8180" translate="yes" xml:space="preserve">
          <source>The Java Language Specification, Third Edition</source>
          <target state="translated">자바 언어 사양, 제 3 판</target>
        </trans-unit>
        <trans-unit id="bbe92060513e13f1787c56819355245bef3c94ab" translate="yes" xml:space="preserve">
          <source>The Java Look and Feel, otherwise known as Metal.</source>
          <target state="translated">Metal이라고도하는 Java Look and Feel.</target>
        </trans-unit>
        <trans-unit id="05622f717f9f313a62126060521423008c4d1058" translate="yes" xml:space="preserve">
          <source>The Java Management Extensions (JMX&amp;trade;) API is a standard API for management and monitoring. Typical uses include:</source>
          <target state="translated">JMX &amp;trade; (Java Management Extensions) API는 관리 및 모니터링을위한 표준 API입니다. 일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d4ddff1e13e642d6bc1fae73d9cb1b5769ed1c8" translate="yes" xml:space="preserve">
          <source>The Java Management Extensions (JMX) API is a standard API for management and monitoring. Typical uses include:</source>
          <target state="translated">JMX (Java Management Extensions) API는 관리 및 모니터링을위한 표준 API입니다. 일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37d13fecff6728378da832d10b9051c944390c97" translate="yes" xml:space="preserve">
          <source>The Java Management Extensions (JMX&lt;sup&gt;TM&lt;/sup&gt;) API is a standard API for management and monitoring. Typical uses include:</source>
          <target state="translated">Java Management Extensions (JMX &lt;sup&gt;TM)&lt;/sup&gt; ) API는 관리 및 모니터링을위한 표준 API입니다. 일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d78753332522c3ae6721300363a5c6096e665327" translate="yes" xml:space="preserve">
          <source>The Java Platform distinguishes between two kinds of fonts: &lt;em&gt;physical&lt;/em&gt; fonts and &lt;em&gt;logical&lt;/em&gt; fonts.</source>
          <target state="translated">Java 플랫폼은 &lt;em&gt;물리적&lt;/em&gt; 글꼴과 &lt;em&gt;논리적&lt;/em&gt; 글꼴 의 두 가지 글꼴을 구분 합니다.</target>
        </trans-unit>
        <trans-unit id="8bef35235f701eb6de58ba31cfe59d2bb33aa8ff" translate="yes" xml:space="preserve">
          <source>The Java Platform provides a number of classes that perform locale-sensitive operations. For example, the &lt;code&gt;NumberFormat&lt;/code&gt; class formats numbers, currency, and percentages in a locale-sensitive manner. Classes such as &lt;code&gt;NumberFormat&lt;/code&gt; have several convenience methods for creating a default object of that type. For example, the &lt;code&gt;NumberFormat&lt;/code&gt; class provides these three convenience methods for creating a default &lt;code&gt;NumberFormat&lt;/code&gt; object:</source>
          <target state="translated">Java 플랫폼은 로케일 구분 조작을 수행하는 많은 클래스를 제공합니다. 예를 들어, &lt;code&gt;NumberFormat&lt;/code&gt; 클래스는 숫자, 통화 및 백분율을 로케일 구분 방식으로 형식화합니다. &lt;code&gt;NumberFormat&lt;/code&gt; 과 같은 클래스 에는 해당 유형의 기본 객체를 작성하기위한 몇 가지 편리한 메소드가 있습니다. 예를 들어, &lt;code&gt;NumberFormat&lt;/code&gt; 클래스는 기본 &lt;code&gt;NumberFormat&lt;/code&gt; 을 작성하기위한이 세 가지 편리한 메소드를 제공합니다. 객체 합니다.</target>
        </trans-unit>
        <trans-unit id="3b60f629f49f10f4985e6a720af54abf514bac30" translate="yes" xml:space="preserve">
          <source>The Java Platform provides three specialized subclasses of &lt;code&gt;Format&lt;/code&gt;-- &lt;code&gt;DateFormat&lt;/code&gt;, &lt;code&gt;MessageFormat&lt;/code&gt;, and &lt;code&gt;NumberFormat&lt;/code&gt;--for formatting dates, messages, and numbers, respectively.</source>
          <target state="translated">자바 플랫폼의 세 가지 전문 서브 클래스 제공 &lt;code&gt;Format&lt;/code&gt; - &lt;code&gt;DateFormat&lt;/code&gt; 의 , &lt;code&gt;MessageFormat&lt;/code&gt; 의 및 &lt;code&gt;NumberFormat&lt;/code&gt; 각각 포맷 날짜, 메시지 및 숫자 --for을.</target>
        </trans-unit>
        <trans-unit id="03ea0cad9aef11b637a3137ff4122043f3493aef" translate="yes" xml:space="preserve">
          <source>The Java Platform provides two subclasses of &lt;code&gt;ResourceBundle&lt;/code&gt;, &lt;code&gt;ListResourceBundle&lt;/code&gt; and &lt;code&gt;PropertyResourceBundle&lt;/code&gt;, that provide a fairly simple way to create resources. As you saw briefly in a previous example, &lt;code&gt;ListResourceBundle&lt;/code&gt; manages its resource as a list of key/value pairs. &lt;code&gt;PropertyResourceBundle&lt;/code&gt; uses a properties file to manage its resources.</source>
          <target state="translated">자바 플랫폼은 두 개의 서브 클래스 제공 &lt;code&gt;ResourceBundle&lt;/code&gt; 를 , &lt;code&gt;ListResourceBundle&lt;/code&gt; 및 &lt;code&gt;PropertyResourceBundle&lt;/code&gt; 가 리소스를 생성 할 수있는 아주 간단한 방법을 제공합니다. 이전 예제에서 간략하게 살펴본 것처럼 &lt;code&gt;ListResourceBundle&lt;/code&gt; 은 리소스를 키 / 값 쌍 목록으로 관리합니다. &lt;code&gt;PropertyResourceBundle&lt;/code&gt; 은 속성 파일을 사용하여 리소스를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="2228edce994b6e3417cf42c80f9c126b6f466b3b" translate="yes" xml:space="preserve">
          <source>The Java Platform supports input methods that have been developed in the Java programming language, using the interfaces in the &lt;a href=&quot;spi/package-summary&quot;&gt;&lt;code&gt;java.awt.im.spi&lt;/code&gt;&lt;/a&gt; package, which can be made available by adding them to the application's class path. Implementations may also support using the native input methods of the platforms they run on; however, not all platforms and locales provide input methods. Keyboard layouts are provided by the host platform.</source>
          <target state="translated">Java 플랫폼은 응용 프로그램의 클래스 경로에 추가하여 사용할 수있는 &lt;a href=&quot;spi/package-summary&quot;&gt; &lt;code&gt;java.awt.im.spi&lt;/code&gt; &lt;/a&gt; 패키지 의 인터페이스를 사용하여 Java 프로그래밍 언어로 개발 된 입력 메소드를 지원 합니다. 구현은 실행되는 플랫폼의 기본 입력 방법 사용을 지원할 수도 있습니다. 그러나 모든 플랫폼과 로케일이 입력 방법을 제공하는 것은 아닙니다. 키보드 레이아웃은 호스트 플랫폼에서 제공합니다.</target>
        </trans-unit>
        <trans-unit id="563105f61580384f40b3157faa1d0806aadcdba7" translate="yes" xml:space="preserve">
          <source>The Java Platform, Standard Edition (Java SE) APIs define the core Java platform for general-purpose computing. These APIs are in modules whose names start with &lt;code&gt;java&lt;/code&gt;.</source>
          <target state="translated">Java SE (Java Platform, Standard Edition) API는 범용 컴퓨팅을위한 핵심 Java 플랫폼을 정의합니다. 이러한 API는 이름이 &lt;code&gt;java&lt;/code&gt; 로 시작하는 모듈에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f239cc990f3edd2c4e5449b541498920cb9d284" translate="yes" xml:space="preserve">
          <source>The Java Print Service API defines a group of standard attribute classes modeled upon the attributes in the Internet Printing Protocol (IPP) version 1.1. The standard attribute classes are in the subpackage &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; to keep the actual attribute classes conceptually separate from the generic apparatus defined in package &lt;code&gt;javax.print.attribute&lt;/code&gt;.</source>
          <target state="translated">Java Print Service API는 IPP (Internet Printing Protocol) 버전 1.1의 속성을 기반으로 모델링 된 표준 속성 클래스 그룹을 정의합니다. 표준 속성 클래스는 &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; 패키지에 정의 된 일반 장치와 개념적으로 분리 된 실제 속성 클래스를 유지하기 위해 서브 패키지 &lt;code&gt;javax.print.attribute&lt;/code&gt; .standard에 있습니다.</target>
        </trans-unit>
        <trans-unit id="94f66170e9f1f394a5254a9fe89af973c28cd26f" translate="yes" xml:space="preserve">
          <source>The Java Print Service API defines a group of standard attribute classes modeled upon the attributes in the Internet Printing Protocol (IPP) version 1.1. The standard attribute classes are in the subpackage javax.print.attribute.standard to keep the actual attribute classes conceptually separate from the generic apparatus defined in package javax.print.attribute.</source>
          <target state="translated">Java Print Service API는 IPP (Internet Printing Protocol) 버전 1.1의 속성을 모델로 한 표준 속성 클래스 그룹을 정의합니다. 표준 속성 클래스는 서브 패키지 javax.print.attribute.standard에 있으며, 실제 속성 클래스는 개념적으로 javax.print.attribute 패키지에 정의 된 일반 장치와 분리되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a818f0937d6870054c9657fd1853dbbf7260285b" translate="yes" xml:space="preserve">
          <source>The Java Print Service API defines these different kinds of attributes with five subinterfaces of &lt;code&gt;Attribute&lt;/code&gt;:</source>
          <target state="translated">Java 인쇄 서비스 API는 다섯 개 서브 인터페이스의 속성이 다른 종류의 정의 &lt;code&gt;Attribute&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4a4823caa7194efcb9ec79cc33455ea92b11d4af" translate="yes" xml:space="preserve">
          <source>The Java Print Service API does not define any mandatorily supported &lt;code&gt;DocFlavors&lt;/code&gt;. However, here are some examples of MIME types that a Java Print Service instance might support for client formatted print data. Nested classes inside class &lt;code&gt;DocFlavor&lt;/code&gt; declare predefined static constant &lt;code&gt;DocFlavor&lt;/code&gt; objects for these example doc flavors; class &lt;code&gt;DocFlavor&lt;/code&gt;'s constructor can be used to create an arbitrary doc flavor.</source>
          <target state="translated">Java Print Service API는 필수로 지원되는 &lt;code&gt;DocFlavors&lt;/code&gt; 정의하지 않습니다 . 그러나 다음은 Java 인쇄 서비스 인스턴스가 클라이언트 형식 인쇄 데이터에 대해 지원할 수있는 MIME 유형의 몇 가지 예입니다. &lt;code&gt;DocFlavor&lt;/code&gt; 클래스 내의 중첩 클래스 는 이러한 예제 문서 특징에 대해 미리 정의 된 정적 상수 &lt;code&gt;DocFlavor&lt;/code&gt; 객체를 선언 합니다 . &lt;code&gt;DocFlavor&lt;/code&gt; 클래스 의 생성자를 사용하여 임의의 문서 풍미를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe3bd743981c387b2400e5d9b97f685293d95022" translate="yes" xml:space="preserve">
          <source>The Java Print Service API does not define any mandatorily supported DocFlavors. However, here are some examples of MIME types that a Java Print Service instance might support for client formatted print data. Nested classes inside class DocFlavor declare predefined static constant DocFlavor objects for these example doc flavors; class DocFlavor's constructor can be used to create an arbitrary doc flavor.</source>
          <target state="translated">Java Print Service API는 반드시 지원되는 DocFlavors를 정의하지 않습니다. 그러나 Java Print Service 인스턴스가 클라이언트 형식의 인쇄 데이터를 지원할 수있는 MIME 유형의 예는 다음과 같습니다. DocFlavor 클래스 내부의 중첩 클래스는이 예제 doc 후 레이 바에 대해 미리 정의 된 정적 상수 DocFlavor 객체를 선언합니다. DocFlavor 클래스의 생성자를 사용해 임의의 doc 후 레이 바를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65c3c2c1fe707b0a8b3bdeea8d3461a62fcf7c49" translate="yes" xml:space="preserve">
          <source>The Java Print Service API is designed so that vendors can:</source>
          <target state="translated">Java 인쇄 서비스 API는 공급 업체가 다음을 수행 할 수 있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="3f34c755601f30797b5c5b7d5b48474498065dd9" translate="yes" xml:space="preserve">
          <source>The Java Print Service API provides four specializations of an attribute set that are restricted to contain just one of the four kinds of attributes, as discussed in the &lt;a href=&quot;#role&quot;&gt;Attribute Roles&lt;/a&gt; section:</source>
          <target state="translated">Java 인쇄 서비스 API는 &lt;a href=&quot;#role&quot;&gt;속성 역할&lt;/a&gt; 섹션 에서 설명한대로 네 가지 속성 중 하나만 포함하도록 제한되는 속성 세트의 네 가지 전문화를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5e75e4ce71063f5deab60042bab1ecda724688fe" translate="yes" xml:space="preserve">
          <source>The Java SE 11 Platform uses character information from version 10.0 of the Unicode Standard, with an extension. The Java SE 11 Platform allows an implementation of class &lt;code&gt;Character&lt;/code&gt; to use the Japanese Era code point, &lt;code&gt;U+32FF&lt;/code&gt;, from the first version of the Unicode Standard after 10.0 that assigns the code point. Consequently, the behavior of fields and methods of class &lt;code&gt;Character&lt;/code&gt; may vary across implementations of the Java SE 11 Platform when processing the aforementioned code point ( outside of version 10.0 ), except for the following methods that define Java identifiers: &lt;a href=&quot;#isJavaIdentifierStart(int)&quot;&gt;&lt;code&gt;isJavaIdentifierStart(int)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#isJavaIdentifierStart(char)&quot;&gt;&lt;code&gt;isJavaIdentifierStart(char)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#isJavaIdentifierPart(int)&quot;&gt;&lt;code&gt;isJavaIdentifierPart(int)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#isJavaIdentifierPart(char)&quot;&gt;&lt;code&gt;isJavaIdentifierPart(char)&lt;/code&gt;&lt;/a&gt;. Code points in Java identifiers must be drawn from version 10.0 of the Unicode Standard.</source>
          <target state="translated">Java SE 11 플랫폼은 확장자가있는 유니 코드 표준 버전 10.0의 문자 정보를 사용합니다. Java SE 11 플랫폼은 &lt;code&gt;Character&lt;/code&gt; 클래스 구현이 코드 포인트 를 할당하는 10.0 이후 유니 코드 표준의 첫 번째 버전에서 일본어 시대 코드 포인트 &lt;code&gt;U+32FF&lt;/code&gt; 를 사용할 수 있도록합니다 . 결과적으로, &lt;code&gt;Character&lt;/code&gt; 클래스의 필드 및 메소드 동작은 Java 식별자를 정의하는 다음 메소드를 제외하고 앞서 언급 한 코드 포인트 (버전 10.0 외부)를 처리 할 때 Java SE 11 플랫폼의 구현에 따라 다를 수 있습니다. &lt;a href=&quot;#isJavaIdentifierStart(int)&quot;&gt; &lt;code&gt;isJavaIdentifierStart(int)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#isJavaIdentifierStart(char)&quot;&gt; &lt;code&gt;isJavaIdentifierStart(char)&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#isJavaIdentifierPart(int)&quot;&gt; &lt;code&gt;isJavaIdentifierPart(int)&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#isJavaIdentifierPart(char)&quot;&gt; &lt;code&gt;isJavaIdentifierPart(char)&lt;/code&gt; &lt;/a&gt; . Java 식별자의 코드 포인트는 유니 코드 표준 버전 10.0에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="44ab385c7dd8fa1da3c53b3392398a85953402b3" translate="yes" xml:space="preserve">
          <source>The Java SE Platform supports all eras defined by the Japanese government, beginning with the Meiji era. Each era is identified in the Platform by an integer value and a name. The &lt;a href=&quot;#of(int)&quot;&gt;&lt;code&gt;of(int)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#valueOf(java.lang.String)&quot;&gt;&lt;code&gt;valueOf(String)&lt;/code&gt;&lt;/a&gt; methods may be used to obtain a singleton instance of &lt;code&gt;JapaneseEra&lt;/code&gt; for each era. The &lt;a href=&quot;#values()&quot;&gt;&lt;code&gt;values()&lt;/code&gt;&lt;/a&gt; method returns the singleton instances of all supported eras.</source>
          <target state="translated">Java SE 플랫폼은 메이지 시대를 시작으로 일본 정부가 정의한 모든 시대를 지원합니다. 각 시대는 정수 값과 이름으로 플랫폼에서 식별됩니다. &lt;a href=&quot;#of(int)&quot;&gt; &lt;code&gt;of(int)&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#valueOf(java.lang.String)&quot;&gt; &lt;code&gt;valueOf(String)&lt;/code&gt; &lt;/a&gt; 방법의 단일 인스턴스를 획득하기 위해 사용될 수있다 &lt;code&gt;JapaneseEra&lt;/code&gt; 를 각 시대. &lt;a href=&quot;#values()&quot;&gt; &lt;code&gt;values()&lt;/code&gt; &lt;/a&gt; 메소드가 반환 지원되는 모든 시대의 싱글 인스턴스.</target>
        </trans-unit>
        <trans-unit id="afb3e24894a90acb5b20ffe967cda4ac6a0179f2" translate="yes" xml:space="preserve">
          <source>The Java SE Platform supports all eras defined by the Japanese government, beginning with the Meiji era. Each era is identified in the Platform by an integer value and a name. The &lt;a href=&quot;#of(int)&quot;&gt;&lt;code&gt;of(int)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#valueOf(java.lang.String)&quot;&gt;&lt;code&gt;valueOf(String)&lt;/code&gt;&lt;/a&gt; methods may be used to obtain a singleton instance of JapaneseEra for each era. The &lt;a href=&quot;#values()&quot;&gt;&lt;code&gt;values()&lt;/code&gt;&lt;/a&gt; method returns the singleton instances of all supported eras.</source>
          <target state="translated">Java SE 플랫폼은 메이지 시대를 시작으로 일본 정부가 정의한 모든 시대를 지원합니다. 플랫폼에서 각 시대는 정수 값과 이름으로 식별됩니다. &lt;a href=&quot;#of(int)&quot;&gt; &lt;code&gt;of(int)&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#valueOf(java.lang.String)&quot;&gt; &lt;code&gt;valueOf(String)&lt;/code&gt; &lt;/a&gt; 방법은 각 시대 JapaneseEra의 단일 인스턴스를 획득하기 위해 사용될 수있다. &lt;a href=&quot;#values()&quot;&gt; &lt;code&gt;values()&lt;/code&gt; &lt;/a&gt; 메소드가 반환 지원되는 모든 시대의 싱글 인스턴스.</target>
        </trans-unit>
        <trans-unit id="020b92794f4c93bc0ed4d9763a4e104a73b9e2f4" translate="yes" xml:space="preserve">
          <source>The Java SQL framework allows for multiple database drivers.</source>
          <target state="translated">Java SQL 프레임 워크는 여러 데이터베이스 드라이버를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a77beb7b7668d78be82a4d8cfa6760cf65edf7a3" translate="yes" xml:space="preserve">
          <source>The Java Series book published by Addison-Wesley Longman provides detailed information about the classes and interfaces in the &lt;code&gt;javax.sql&lt;/code&gt; package:</source>
          <target state="translated">Addison-Wesley Longman이 발행 한 Java Series 책은 &lt;code&gt;javax.sql&lt;/code&gt; 패키지 의 클래스 및 인터페이스에 대한 자세한 정보를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="4cea0620c1bef0b99a18c809ce3bab655ecb274b" translate="yes" xml:space="preserve">
          <source>The Java Sound Tutorial</source>
          <target state="translated">자바 사운드 튜토리얼</target>
        </trans-unit>
        <trans-unit id="c2715c77dd34c70665dfad2f1923e173e786e209" translate="yes" xml:space="preserve">
          <source>The Java Time-Scale divides each calendar day into exactly 86400 subdivisions, known as seconds. These seconds may differ from the SI second. It closely matches the de facto international civil time scale, the definition of which changes from time to time.</source>
          <target state="translated">Java Time-Scale은 매일 달력을 정확히 86400의 세분 (초)으로 나눕니다. 이 초는 SI 초와 다를 수 있습니다. 그것은 사실상 국제 시민의 시간 규모와 밀접하게 일치하며, 그 정의는 때때로 변화합니다.</target>
        </trans-unit>
        <trans-unit id="4bde9066215b58dffb03e10c8882b75db84e87a4" translate="yes" xml:space="preserve">
          <source>The Java Time-Scale has slightly different definitions for different segments of the time-line, each based on the consensus international time scale that is used as the basis for civil time. Whenever the internationally-agreed time scale is modified or replaced, a new segment of the Java Time-Scale must be defined for it. Each segment must meet these requirements:</source>
          <target state="translated">Java Time-Scale은 타임 라인의 각기 다른 세그먼트에 대해 약간 다른 정의를 가지고 있으며, 각각은 민간 시간의 기준으로 사용되는 합의 된 국제 시간 스케일을 기반으로합니다. 국제적으로 합의 된 시간 척도가 수정되거나 교체 될 때마다 Java Time-Scale의 새로운 세그먼트가 정의되어야합니다. 각 세그먼트는 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="f78637fddaa4e53e279355beabee4458db283b36" translate="yes" xml:space="preserve">
          <source>The Java Tutorial</source>
          <target state="translated">자바 튜토리얼</target>
        </trans-unit>
        <trans-unit id="4600970ab5dcc28d471a34b69880d44724af7c9c" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine Specification</source>
          <target state="translated">자바 가상 머신 사양</target>
        </trans-unit>
        <trans-unit id="5e6b0a63803973c77139670d0df2b4f4878bdba5" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine marks &lt;code&gt;L&lt;/code&gt; as the defining class loader of &lt;code&gt;C&lt;/code&gt;, but no class loader is recorded as an initiating class loader of &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">Java Virtual Machine은 &lt;code&gt;L&lt;/code&gt; 을 &lt;code&gt;C&lt;/code&gt; 의 정의 클래스 로더로 표시 하지만 클래스 로더는 &lt;code&gt;C&lt;/code&gt; 의 시작 클래스 로더로 기록되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e3cf148b298a0b996efd7f97bd7f2e6174fda315" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified.</source>
          <target state="translated">Java Virtual Machine은 호스트 환경을 기반으로 시작하는 동안 기본 로캘을 설정합니다. 로케일이 명시 적으로 지정되지 않은 경우 많은 로케일 구분 메소드에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="54550db269bf7cd9cb4b43e4d04a89f68d9ad806" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified. It can be changed using the &lt;a href=&quot;#setDefault(java.util.Locale)&quot;&gt;&lt;code&gt;setDefault&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java Virtual Machine은 호스트 환경을 기반으로 시작하는 동안 기본 로케일을 설정합니다. 로케일이 명시 적으로 지정되지 않은 경우 많은 로케일 구분 방법에서 사용됩니다. &lt;a href=&quot;#setDefault(java.util.Locale)&quot;&gt; &lt;code&gt;setDefault&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9d7a4ea102a2331058fd720ef77be5d28603b6b" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified. It can be changed using the &lt;a href=&quot;locale#setDefault-java.util.Locale-&quot;&gt;&lt;code&gt;setDefault&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java Virtual Machine은 호스트 환경을 기반으로 시작하는 동안 기본 로캘을 설정합니다. 로케일이 명시 적으로 지정되지 않은 경우 많은 로케일 구분 메소드에서 사용됩니다. &lt;a href=&quot;locale#setDefault-java.util.Locale-&quot;&gt; &lt;code&gt;setDefault&lt;/code&gt; 를&lt;/a&gt; 사용하여 변경할 수 있습니다 메소드를 .</target>
        </trans-unit>
        <trans-unit id="935b4a63d6ee5db34b9d75a511cfdfab0947e278" translate="yes" xml:space="preserve">
          <source>The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified. It can be changed using the setDefault(Locale.Category, Locale) method.</source>
          <target state="translated">Java Virtual Machine은 호스트 환경을 기반으로 시작하는 동안 기본 로캘을 설정합니다. 로케일이 명시 적으로 지정되지 않은 경우 많은 로케일 구분 메소드에서 사용됩니다. setDefault (Locale.Category, Locale) 메소드를 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5d4bfdb8b77d90d9d3b5f96ac809bfa715ae313" translate="yes" xml:space="preserve">
          <source>The Java class name of composite data values this composite type represents (ie the class name returned by the &lt;a href=&quot;opentype#getClassName()&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method) is set to the string value returned by &lt;code&gt;CompositeData.class.getName()&lt;/code&gt;.</source>
          <target state="translated">이 복합 유형이 나타내는 복합 데이터 값의 Java 클래스 이름 (즉, &lt;a href=&quot;opentype#getClassName()&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt; 메소드에서 반환 된 클래스 이름 )은 &lt;code&gt;CompositeData.class.getName()&lt;/code&gt; 반환 한 문자열 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bf9c7a5833d85446736a0e1c4523720b0baa70e" translate="yes" xml:space="preserve">
          <source>The Java class name of composite data values this composite type represents (ie the class name returned by the &lt;a href=&quot;opentype#getClassName--&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method) is set to the string value returned by &lt;code&gt;CompositeData.class.getName()&lt;/code&gt;.</source>
          <target state="translated">이 복합 형이 나타내는 복합 데이터 치의 Java 클래스 명 (즉, &lt;a href=&quot;opentype#getClassName--&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴 된 클래스 명 )은 &lt;code&gt;CompositeData.class.getName()&lt;/code&gt; 의해 리턴 된 캐릭터 라인 치로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c797024101e43684f89be3466f4ed077167867bf" translate="yes" xml:space="preserve">
          <source>The Java class name of tabular data values this tabular type represents (ie the class name returned by the &lt;a href=&quot;opentype#getClassName()&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method) is set to the string value returned by &lt;code&gt;TabularData.class.getName()&lt;/code&gt;.</source>
          <target state="translated">이 테이블 형식 유형이 나타내는 테이블 형식 데이터 값의 Java 클래스 이름 (즉, &lt;a href=&quot;opentype#getClassName()&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt; 메서드에서 반환 된 클래스 이름 )은 &lt;code&gt;TabularData.class.getName()&lt;/code&gt; 반환 한 문자열 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="bda12988aff6c0c6b0da57eda918cd7f7e41f2f4" translate="yes" xml:space="preserve">
          <source>The Java class name of tabular data values this tabular type represents (ie the class name returned by the &lt;a href=&quot;opentype#getClassName--&quot;&gt;&lt;code&gt;getClassName&lt;/code&gt;&lt;/a&gt; method) is set to the string value returned by &lt;code&gt;TabularData.class.getName()&lt;/code&gt;.</source>
          <target state="translated">이 테이블 형이 나타내는 테이블 형식의 데이터 치의 Java 클래스 명 (즉, &lt;a href=&quot;opentype#getClassName--&quot;&gt; &lt;code&gt;getClassName&lt;/code&gt; &lt;/a&gt; 메소드에 의해 반환되는 클래스 명 )은 &lt;code&gt;TabularData.class.getName()&lt;/code&gt; 의해 반환되는 캐릭터 라인 치로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c14a043362d4c6a8070d7ef91c6074e182453f3" translate="yes" xml:space="preserve">
          <source>The Java input method framework intends to support all combinations of input methods (host input methods and Java input methods) and components (peered and lightweight). However, because of limitations in the underlying platform, it may not always be possible to enable the communication between Java input methods and peered AWT components. Support for this specific combination is therefore platform dependent. In Sun's Java SE Runtime Environments, this combination is supported on Windows, but not on Solaris.</source>
          <target state="translated">Java 입력 방법 프레임 워크는 입력 방법 (호스트 입력 방법 및 Java 입력 방법)과 구성 요소 (피어 드 및 경량)의 모든 조합을 지원합니다. 그러나 기본 플랫폼의 제한으로 인해 Java 입력 방법과 피어링 된 AWT 구성 요소 간의 통신을 활성화하는 것이 항상 가능한 것은 아닙니다. 따라서이 특정 조합에 대한 지원은 플랫폼에 따라 다릅니다. Sun의 Java SE Runtime Environment에서이 조합은 Windows에서는 지원되지만 Solaris에서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79100a6d797f840a76dcfd0b27ebb8da026f838e" translate="yes" xml:space="preserve">
          <source>The Java interface name for a Standard MBean or MXBean, as returned by &lt;a href=&quot;../../../java.base/java/lang/class#getName()&quot;&gt;&lt;code&gt;Class.getName()&lt;/code&gt;&lt;/a&gt;. A Standard MBean or MXBean registered directly in the MBean Server or created using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class will have this field in its MBeanInfo Descriptor.</source>
          <target state="translated">&lt;a href=&quot;../../../java.base/java/lang/class#getName()&quot;&gt; &lt;code&gt;Class.getName()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 표준 MBean 또는 MXBean의 Java 인터페이스 이름입니다 . MBean 서버에 직접 등록되거나 &lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 생성 된 Standard MBean 또는 MXBean 은 MBeanInfo Descriptor에이 필드를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="51863c4a757aa5599aa4ec4ebb6fdc59f85b517e" translate="yes" xml:space="preserve">
          <source>The Java interface name for a Standard MBean or MXBean, as returned by &lt;a href=&quot;../../java/lang/class#getName--&quot;&gt;&lt;code&gt;Class.getName()&lt;/code&gt;&lt;/a&gt;. A Standard MBean or MXBean registered directly in the MBean Server or created using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class will have this field in its MBeanInfo Descriptor.</source>
          <target state="translated">표준 MBean 또는 MXBean의 Java 인터페이스 명. &lt;a href=&quot;../../java/lang/class#getName--&quot;&gt; &lt;code&gt;Class.getName()&lt;/code&gt; &lt;/a&gt;. MBean 서버에 직접 등록되거나&lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; 을&lt;/a&gt; 사용하여 작성된 표준 MBean 또는 MXBean 클래스를 은이 필드를 MBeanInfo 디스크립터에 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b846c3f527602fad3b8086a6f7a5ad28be2a0b97" translate="yes" xml:space="preserve">
          <source>The Java language provides special support for the string concatenation operator ( + ), and for conversion of other objects to strings. For additional information on string concatenation and conversion, see</source>
          <target state="translated">Java 언어는 문자열 연결 연산자 (+) 및 다른 객체를 문자열로 변환하는 특수 지원을 제공합니다. 문자열 연결 및 변환에 대한 추가 정보는 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1aedb6f153f14e307ee0a63ee1143e333aca4608" translate="yes" xml:space="preserve">
          <source>The Java language provides special support for the string concatenation operator ( + ), and for conversion of other objects to strings. String concatenation is implemented through the &lt;code&gt;StringBuilder&lt;/code&gt;(or &lt;code&gt;StringBuffer&lt;/code&gt;) class and its &lt;code&gt;append&lt;/code&gt; method. String conversions are implemented through the method &lt;code&gt;toString&lt;/code&gt;, defined by &lt;code&gt;Object&lt;/code&gt; and inherited by all classes in Java. For additional information on string concatenation and conversion, see Gosling, Joy, and Steele,</source>
          <target state="translated">Java 언어는 문자열 연결 연산자 (+) 및 다른 객체를 문자열로 변환하는 데 특별한 지원을 제공합니다. 문자열 연결은 &lt;code&gt;StringBuilder&lt;/code&gt; (또는 &lt;code&gt;StringBuffer&lt;/code&gt; ) 클래스와 클래스를 통해 구현됩니다. &lt;code&gt;append&lt;/code&gt; 메소드를 . 문자열 변환은 &lt;code&gt;Object&lt;/code&gt; 에 의해 정의되고 Java의 모든 클래스에 상속되는 &lt;code&gt;toString&lt;/code&gt; 메소드를 통해 구현됩니다 . 문자열 연결 및 변환에 대한 자세한 내용은 Gosling, Joy 및 Steele을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e0998193a86cfe456d402b1f0c70a66b6cd6c11c" translate="yes" xml:space="preserve">
          <source>The Java math library is defined with respect to &lt;code&gt;fdlibm&lt;/code&gt; version 5.3. Where &lt;code&gt;fdlibm&lt;/code&gt; provides more than one definition for a function (such as &lt;code&gt;acos&lt;/code&gt;), use the &quot;IEEE 754 core function&quot; version (residing in a file whose name begins with the letter &lt;code&gt;e&lt;/code&gt;). The methods which require &lt;code&gt;fdlibm&lt;/code&gt; semantics are &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;cbrt&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;hypot&lt;/code&gt;, &lt;code&gt;expm1&lt;/code&gt;, and &lt;code&gt;log1p&lt;/code&gt;.</source>
          <target state="translated">Java 수학 라이브러리는 &lt;code&gt;fdlibm&lt;/code&gt; 버전 5.3 과 관련하여 정의됩니다 . 어디 &lt;code&gt;fdlibm&lt;/code&gt; 이 (같은 기능에 대해 둘 이상의 정의를 제공 &lt;code&gt;acos&lt;/code&gt; ), (이름이 문자로 시작하는 파일에 존재하는 &quot;IEEE 754 핵심 기능&quot;버전 사용하는 &lt;code&gt;e&lt;/code&gt; ). &lt;code&gt;fdlibm&lt;/code&gt; 의미가 필요한 메소드 는 &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;cos&lt;/code&gt; , &lt;code&gt;tan&lt;/code&gt; , &lt;code&gt;asin&lt;/code&gt; , &lt;code&gt;acos&lt;/code&gt; , &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;exp&lt;/code&gt; , &lt;code&gt;log&lt;/code&gt; , &lt;code&gt;log10&lt;/code&gt; , &lt;code&gt;cbrt&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , &lt;code&gt;hypot&lt;/code&gt; , &lt;code&gt;expm1&lt;/code&gt; 입니다. &lt;code&gt;atan2&lt;/code&gt; , &lt;code&gt;pow&lt;/code&gt; , &lt;code&gt;sinh&lt;/code&gt; , &lt;code&gt;cosh&lt;/code&gt; , 및 &lt;code&gt;log1p&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75bc96f1b0cc70e1672a7ea3f62bf4ee8f43d325" translate="yes" xml:space="preserve">
          <source>The Java programming language does not guarantee which thread will invoke the &lt;code&gt;finalize&lt;/code&gt; method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates.</source>
          <target state="translated">Java 프로그래밍 언어는 어떤 스레드가 주어진 객체에 대한 &lt;code&gt;finalize&lt;/code&gt; 메소드를 호출한다고 보장하지 않습니다 . 그러나 finalize를 호출하는 스레드는 finalize가 호출 될 때 사용자가 볼 수있는 동기화 잠금을 보유하지 않습니다. 포착되지 않은 예외가 finalize 메소드에 의해 발생되면 예외가 무시되고 해당 오브젝트의 종료가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="a17398b63cfead5fb4c823a73d9a91965bc4ebc9" translate="yes" xml:space="preserve">
          <source>The Java run-time has the following built-in class loaders:</source>
          <target state="translated">Java 런타임에는 다음과 같은 내장 클래스 로더가 있습니다.</target>
        </trans-unit>
        <trans-unit id="08aaa85f6f705c223cf7d10e7c00860e557c843f" translate="yes" xml:space="preserve">
          <source>The Java run-time may also allow, but is not required to allow, the security manager to be set dynamically by invoking the &lt;a href=&quot;system#setSecurityManager(java.lang.SecurityManager)&quot;&gt;&lt;code&gt;setSecurityManager&lt;/code&gt;&lt;/a&gt; method. In the JDK implementation, if the Java virtual machine is started with the &lt;code&gt;java.security.manager&lt;/code&gt; system property set to the special token &quot;&lt;code&gt;disallow&lt;/code&gt;&quot; then a security manager will not be set at startup and cannot be set dynamically (the &lt;a href=&quot;system#setSecurityManager(java.lang.SecurityManager)&quot;&gt;&lt;code&gt;setSecurityManager&lt;/code&gt;&lt;/a&gt; method will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;). If the &lt;code&gt;java.security.manager&lt;/code&gt; system property is not set or is set to the special token &quot;&lt;code&gt;allow&lt;/code&gt;&quot;, then a security manager will not be set at startup but can be set dynamically. Finally, if the &lt;code&gt;java.security.manager&lt;/code&gt; system property is set to the class name of the security manager, or to the empty String (&quot;&quot;) or the special token &quot;&lt;code&gt;default&lt;/code&gt;&quot;, then a security manager is set at startup (as described previously) and can also be subsequently replaced (or disabled) dynamically (subject to the policy of the currently installed security manager). The following table illustrates the behavior of the JDK implementation for the different settings of the &lt;code&gt;java.security.manager&lt;/code&gt; system property:</source>
          <target state="translated">Java 런타임은 &lt;a href=&quot;system#setSecurityManager(java.lang.SecurityManager)&quot;&gt; &lt;code&gt;setSecurityManager&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 보안 관리자를 동적으로 설정하도록 허용 할 수도 있지만 반드시 허용 할 필요는 없습니다 . JDK 구현에서 Java 가상 머신이 특수 토큰 &quot; &lt;code&gt;disallow&lt;/code&gt; &quot;로 설정된 &lt;code&gt;java.security.manager&lt;/code&gt; 시스템 특성으로 시작 되면 보안 관리자가 시작시 설정되지 않으며 동적으로 설정할 수 없습니다 ( &lt;a href=&quot;system#setSecurityManager(java.lang.SecurityManager)&quot;&gt; &lt;code&gt;setSecurityManager&lt;/code&gt; &lt;/a&gt; 메소드가 발생합니다. &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 가 ). 는 IF &lt;code&gt;java.security.manager&lt;/code&gt; 시스템 속성이 설정되지 않았거나 &quot;토큰 특수로 설정 &lt;code&gt;allow&lt;/code&gt; &quot;을 선택한 후 보안 관리자는 시작시 설정되지 않습니다하지만 동적으로 설정 될 수있다. 마지막으로 &lt;code&gt;java.security.manager&lt;/code&gt; 시스템 특성이 보안 관리자의 클래스 이름, 빈 문자열 ( &quot;&quot;) 또는 특수 토큰 &quot; &lt;code&gt;default&lt;/code&gt; &quot;로 설정되면 보안 관리자가 시작시 (앞서 설명한대로) 설정되고 다음을 수행 할 수 있습니다. 또한 이후에 동적으로 교체 (또는 비활성화)됩니다 (현재 설치된 보안 관리자의 정책에 따라 다름). 다음 표는 &lt;code&gt;java.security.manager&lt;/code&gt; 시스템 특성 의 다양한 설정에 대한 JDK 구현의 동작을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ae9b0a73944b42ff81458d35c69a8c4267a950f1" translate="yes" xml:space="preserve">
          <source>The Java thread ID, or &lt;code&gt;-1&lt;/code&gt; if doesn't exist</source>
          <target state="translated">Java 스레드 ID 또는 존재하지 않는 경우 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af13f60de6a564a40dc8e97ebaf3a0143c84236a" translate="yes" xml:space="preserve">
          <source>The Java time-scale is used for all date-time classes. This includes &lt;code&gt;Instant&lt;/code&gt;, &lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt;, &lt;code&gt;OffsetDateTime&lt;/code&gt;, &lt;code&gt;ZonedDateTime&lt;/code&gt; and &lt;code&gt;Duration&lt;/code&gt;.</source>
          <target state="translated">Java 시간 척도는 모든 날짜-시간 클래스에 사용됩니다. 여기에는 &lt;code&gt;Instant&lt;/code&gt; , &lt;code&gt;LocalDate&lt;/code&gt; , &lt;code&gt;LocalTime&lt;/code&gt; , &lt;code&gt;OffsetDateTime&lt;/code&gt; , &lt;code&gt;ZonedDateTime&lt;/code&gt; 및 &lt;code&gt;Duration&lt;/code&gt; 이 포함됩니다. .</target>
        </trans-unit>
        <trans-unit id="b2da8a881d3a54f6e4f6b884054ec854ec43a1d9" translate="yes" xml:space="preserve">
          <source>The Java type of the resource. For field annotations, the default is the type of the field. For method annotations, the default is the type of the JavaBeans property. For class annotations, there is no default and this must be specified.</source>
          <target state="translated">자원의 Java 유형 필드 주석의 경우 기본값은 필드 유형입니다. 메소드 어노테이션의 경우 기본값은 JavaBeans 특성의 유형입니다. 클래스 주석의 경우 기본값이 없으므로이를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="43d20fd86e33d070ee07b30fb6fd2637b8965aa6" translate="yes" xml:space="preserve">
          <source>The Java virtual machine</source>
          <target state="translated">자바 가상 머신</target>
        </trans-unit>
        <trans-unit id="9b5c7ce28420ae67114f39b12a0543341609a160" translate="yes" xml:space="preserve">
          <source>The Java virtual machine has a</source>
          <target state="translated">Java 가상 머신에는</target>
        </trans-unit>
        <trans-unit id="88c7b1259981c72516090ed9654552f9f3ed6e3b" translate="yes" xml:space="preserve">
          <source>The Java virtual machine has a default provider that provides zone rules for the time-zones defined by IANA Time Zone Database (TZDB). If the system property &lt;code&gt;&lt;span id=&quot;java.time.zone.DefaultZoneRulesProvider&quot;&gt;java.time.zone.DefaultZoneRulesProvider&lt;/span&gt;&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete ZoneRulesProvider class to be loaded as the default provider, using the system class loader. If this system property is not defined, a system-default provider will be loaded to serve as the default provider.</source>
          <target state="translated">JVM (Java Virtual Machine)에는 IANA 시간대 데이터베이스 (TZDB)에서 정의한 시간대에 대한 구역 규칙을 제공하는 기본 제공자가 있습니다. 시스템 특성 &lt;code&gt;&lt;span id=&quot;java.time.zone.DefaultZoneRulesProvider&quot;&gt;java.time.zone.DefaultZoneRulesProvider&lt;/span&gt;&lt;/code&gt; 가 정의 된 경우 시스템 클래스 로더를 사용하여 기본 제공자로로드 될 구체적인 ZoneRulesProvider 클래스의 완전한 이름으로 간주됩니다. 이 시스템 속성이 정의되어 있지 않으면 시스템 기본 공급자가로드되어 기본 공급자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8516f820bb05657121a79dd1bd0a5cddcc1f2f53" translate="yes" xml:space="preserve">
          <source>The Java virtual machine has a default provider that provides zone rules for the time-zones defined by IANA Time Zone Database (TZDB). If the system property &lt;code&gt;java.time.zone.DefaultZoneRulesProvider&lt;/code&gt; is defined then it is taken to be the fully-qualified name of a concrete ZoneRulesProvider class to be loaded as the default provider, using the system class loader. If this system property is not defined, a system-default provider will be loaded to serve as the default provider.</source>
          <target state="translated">Java 가상 머신에는 IANA 시간대 데이터베이스 (TZDB)에서 정의한 시간대에 대한 시간대 규칙을 제공하는 기본 제공자가 있습니다. 시스템 프로퍼티 &lt;code&gt;java.time.zone.DefaultZoneRulesProvider&lt;/code&gt; 인 경우 가 정의 된 경우 시스템 클래스 로더를 사용하여 기본 제공자로로드 할 콘크리트 ZoneRulesProvider 클래스의 완전한 이름이됩니다. 이 시스템 속성이 정의되어 있지 않으면 시스템 기본 공급자가 기본 공급자 역할을하도록로드됩니다.</target>
        </trans-unit>
        <trans-unit id="01e66a7f2f90bc990318958109b0d41e725d670b" translate="yes" xml:space="preserve">
          <source>The Java virtual machine has a heap for object allocation and also maintains non-heap memory for the method area and the Java virtual machine execution. The Java virtual machine can have one or more memory pools. Each memory pool represents a memory area of one of the following types:</source>
          <target state="translated">JVM (Java Virtual Machine)에는 오브젝트 할당을위한 힙이 있으며 메소드 영역 및 JVM (Java Virtual Machine) 실행을 위해 힙이 아닌 메모리를 유지 보수합니다. Java 가상 머신에는 하나 이상의 메모리 풀이있을 수 있습니다. 각 메모리 풀은 다음 유형 중 하나의 메모리 영역을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="20591611464f80238a71287e9fce3d26d00ecfac" translate="yes" xml:space="preserve">
          <source>The Java virtual machine implementation may use a high resolution timer to measure the elapsed time. This method may return the same value even if the collection count has been incremented if the collection elapsed time is very short.</source>
          <target state="translated">JVM (Java Virtual Machine) 구현은 경과 시간을 측정하기 위해 고해상도 타이머를 사용할 수 있습니다. 이 방법은 수집 경과 시간이 매우 짧은 경우 수집 횟수가 증가한 경우에도 동일한 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b9d55292bfb865db4e6b6204b4073d1f202f8ab" translate="yes" xml:space="preserve">
          <source>The Java virtual machine maintains the peak memory usage of a memory pool since the virtual machine was started or the peak was reset. The peak memory usage is returned by the &lt;a href=&quot;#getPeakUsage()&quot;&gt;&lt;code&gt;getPeakUsage()&lt;/code&gt;&lt;/a&gt; method and reset by calling the &lt;a href=&quot;#resetPeakUsage()&quot;&gt;&lt;code&gt;resetPeakUsage()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">JVM (Java Virtual Machine)은 가상 머신이 시작되거나 피크가 재설정 된 이후 메모리 풀의 피크 메모리 사용량을 유지합니다. 최대 메모리 사용량은 &lt;a href=&quot;#getPeakUsage()&quot;&gt; &lt;code&gt;getPeakUsage()&lt;/code&gt; &lt;/a&gt; 메서드에 의해 반환되고 &lt;a href=&quot;#resetPeakUsage()&quot;&gt; &lt;code&gt;resetPeakUsage()&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="21c32d462e38386cb39051b42822e7568e72eaed" translate="yes" xml:space="preserve">
          <source>The Java virtual machine maintains the peak memory usage of a memory pool since the virtual machine was started or the peak was reset. The peak memory usage is returned by the &lt;a href=&quot;memorypoolmxbean#getPeakUsage--&quot;&gt;&lt;code&gt;getPeakUsage()&lt;/code&gt;&lt;/a&gt; method and reset by calling the &lt;a href=&quot;memorypoolmxbean#resetPeakUsage--&quot;&gt;&lt;code&gt;resetPeakUsage()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Java 가상 머신은 가상 머신이 시작되었거나 피크가 재설정 된 이후 메모리 풀의 최대 메모리 사용량을 유지합니다. 최대 메모리 사용량은 &lt;a href=&quot;memorypoolmxbean#getPeakUsage--&quot;&gt; &lt;code&gt;getPeakUsage()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 리턴되고 &lt;a href=&quot;memorypoolmxbean#resetPeakUsage--&quot;&gt; &lt;code&gt;resetPeakUsage()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1dd3f55b5efbf2036c2fe1ec00c3c49d3ddb4916" translate="yes" xml:space="preserve">
          <source>The Java virtual machine manages memory other than the heap (referred as</source>
          <target state="translated">JVM (Java Virtual Machine)은 힙 이외의 메모리를 관리합니다 (</target>
        </trans-unit>
        <trans-unit id="472437aa219a5ab5c682981b0f53bbaf388053c7" translate="yes" xml:space="preserve">
          <source>The Java virtual machine may measure the time with a high resolution timer. This statistic is reset when the thread contention monitoring is reenabled.</source>
          <target state="translated">Java 가상 머신은 고해상도 타이머로 시간을 측정 할 수 있습니다. 이 통계는 스레드 경합 모니터링이 다시 활성화 될 때 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7d5cc1c9e97c8fd121944655161d88c67a4b91ea" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Language Specification</source>
          <target state="translated">자바 언어 사양</target>
        </trans-unit>
        <trans-unit id="fff53af6e46bb1a4be8a5ab0a06369d5f80e1391" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Language Specification, First Edition</source>
          <target state="translated">Java &amp;trade; 언어 사양, 초판</target>
        </trans-unit>
        <trans-unit id="417681d10c199b472becfb181846b8f2351a0cd7" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Language Specification, Second Edition</source>
          <target state="translated">Java &amp;trade; 언어 사양, 제 2 판</target>
        </trans-unit>
        <trans-unit id="a4154fea8bd8d5b8ca35ca7f9f31b5ca95523b77" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Language Specification, Third Edition</source>
          <target state="translated">Java &amp;trade; 언어 사양, 제 3 판</target>
        </trans-unit>
        <trans-unit id="b01e874645c4aa3cc169adba9f26395f941d4bfb" translate="yes" xml:space="preserve">
          <source>The Java&amp;trade; Virtual Machine Specification</source>
          <target state="translated">Java &amp;trade; 가상 머신 스펙</target>
        </trans-unit>
        <trans-unit id="573f4350c0a7648c709160ed919837ba77cd9cc2" translate="yes" xml:space="preserve">
          <source>The Java(tm)2D API adopts the convention that one point is equivalent to one unit in user coordinates. When using a normalized transform for converting user space coordinates to device space coordinates 72 user space units equal 1 inch in device space. In this case one point is 1/72 of an inch.</source>
          <target state="translated">Java (tm) 2D API는 사용자 좌표에서 하나의 포인트가 하나의 단위와 동일하다는 규칙을 채택합니다. 사용자 공간 좌표를 장치 공간 좌표로 변환하기 위해 정규화 된 변환을 사용하는 경우 72 개의 사용자 공간 단위는 장치 공간에서 1 인치와 같습니다. 이 경우 1 포인트는 1/72 인치입니다.</target>
        </trans-unit>
        <trans-unit id="73f06ed2f1aac123ba68f5eb4faa83cf80ea193e" translate="yes" xml:space="preserve">
          <source>The JavaBeans specification defines the notion of design time as is a mode in which JavaBeans instances should function during their composition and customization in a interactive design, composition or construction tool, as opposed to runtime when the JavaBean is part of an applet, application, or other live Java executable abstraction.</source>
          <target state="translated">JavaBeans 사양은 JavaBeans 인스턴스가 대화 형 디자인, 구성 또는 구성 도구에서 구성 및 사용자 정의하는 동안 작동해야하는 모드로 디자인 시간의 개념을 정의합니다. 이는 JavaBean이 애플릿, 응용 프로그램 또는 응용 프로그램의 일부일 때 런타임이 아닙니다. 기타 라이브 Java 실행 가능 추상화.</target>
        </trans-unit>
        <trans-unit id="4cadba2d15fbb9804bf151281d2e05044e9bc484" translate="yes" xml:space="preserve">
          <source>The JavaBeans&amp;trade; specification defines the notion of design time as is a mode in which JavaBeans instances should function during their composition and customization in a interactive design, composition or construction tool, as opposed to runtime when the JavaBean is part of an applet, application, or other live Java executable abstraction.</source>
          <target state="translated">JavaBeans &amp;trade; 사양은 JavaBeans가 애플릿, 응용 프로그램, 응용 프로그램, 또는 기타 라이브 Java 실행 가능 추상화입니다.</target>
        </trans-unit>
        <trans-unit id="2c47a19a69292af9f4d3ab44cef1faa2270339a1" translate="yes" xml:space="preserve">
          <source>The Javanese range with the Javanese digits.</source>
          <target state="translated">자바어 숫자가있는 자바어 범위입니다.</target>
        </trans-unit>
        <trans-unit id="7ece0bccd4f47c81fc16bd9c26fb8dacabc06bc3" translate="yes" xml:space="preserve">
          <source>The Jdbc &lt;code&gt;RowSet&lt;/code&gt; Implementations specification provides two reference implementations of the &lt;code&gt;SyncProvider&lt;/code&gt; abstract class: &lt;code&gt;RIOptimisticProvider&lt;/code&gt; and &lt;code&gt;RIXMLProvider&lt;/code&gt;. The &lt;code&gt;RIOptimisticProvider&lt;/code&gt; can set any &lt;code&gt;RowSet&lt;/code&gt; implementation with a &lt;code&gt;RowSetReader&lt;/code&gt; object and a &lt;code&gt;RowSetWriter&lt;/code&gt; object. However, only the &lt;code&gt;RIXMLProvider&lt;/code&gt; implementation can set an &lt;code&gt;XmlReader&lt;/code&gt; object and an &lt;code&gt;XmlWriter&lt;/code&gt; object. A &lt;code&gt;WebRowSet&lt;/code&gt; object uses the &lt;code&gt;XmlReader&lt;/code&gt; object to read data in XML format to populate itself with that data. It uses the &lt;code&gt;XmlWriter&lt;/code&gt; object to write itself to a stream or &lt;code&gt;java.io.Writer&lt;/code&gt; object in XML format.</source>
          <target state="translated">Jdbc &lt;code&gt;RowSet&lt;/code&gt; 구현 사양은 &lt;code&gt;SyncProvider&lt;/code&gt; 추상 클래스 의 두 가지 참조 구현 인 &lt;code&gt;RIOptimisticProvider&lt;/code&gt; 및 &lt;code&gt;RIXMLProvider&lt;/code&gt; 를 제공 합니다. &lt;code&gt;RIOptimisticProvider&lt;/code&gt; 어떤 설정할 수 &lt;code&gt;RowSet&lt;/code&gt; A를 구현 &lt;code&gt;RowSetReader&lt;/code&gt; 객체와 &lt;code&gt;RowSetWriter&lt;/code&gt; 의의 객체를. 그러나 &lt;code&gt;RIXMLProvider&lt;/code&gt; 구현 만 &lt;code&gt;XmlReader&lt;/code&gt; 개체와 &lt;code&gt;XmlWriter&lt;/code&gt; 개체를 설정할 수 있습니다 . &lt;code&gt;WebRowSet&lt;/code&gt; 객체는 사용 &lt;code&gt;XmlReader&lt;/code&gt; 에서의 데이터 자체를 채우기 위해 XML 형식의 데이터를 읽을 객체. 그것은 &lt;code&gt;XmlWriter&lt;/code&gt; XML 형식으로 스트림 또는 &lt;code&gt;java.io.Writer&lt;/code&gt; 개체에 자신을 쓰는 XmlWriter 개체 입니다.</target>
        </trans-unit>
        <trans-unit id="46152631e4488fac6b1cad7442ef7feac4ea4d12" translate="yes" xml:space="preserve">
          <source>The JobImpressions attribute describes the size of the job. This attribute is not intended to be a counter; it is intended to be useful routing and scheduling information if known. The printer may try to compute the JobImpressions attribute's value if it is not supplied in the Print Request. Even if the client does supply a value for the JobImpressions attribute in the Print Request, the printer may choose to change the value if the printer is able to compute a value which is more accurate than the client supplied value. The printer may be able to determine the correct value for the JobImpressions attribute either right at job submission time or at any later point in time.</source>
          <target state="translated">JobImpressions 속성은 작업 크기를 설명합니다. 이 속성은 카운터가 아닙니다. 알려진 경우 유용한 라우팅 및 스케줄링 정보가되도록 고안되었습니다. 인쇄 요청에 JobImpressions 속성 값이 제공되지 않으면 프린터에서 JobImpressions 속성 값을 계산하려고 시도 할 수 있습니다. 클라이언트가 인쇄 요청에서 JobImpressions 속성 값을 제공하더라도 프린터가 클라이언트 제공 값보다 정확한 값을 계산할 수있는 경우 프린터는 값을 변경하도록 선택할 수 있습니다. 프린터는 작업 제출 시점 또는 이후에 JobImpressions 속성의 올바른 값을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eda45bce719c55226f8cb11330a3730a179a164" translate="yes" xml:space="preserve">
          <source>The JobImpressionsCompleted attribute describes the progress of the job. This attribute is intended to be a counter. That is, the JobImpressionsCompleted value for a job that has not started processing must be 0. When the job's &lt;a href=&quot;jobstate&quot;&gt;&lt;code&gt;JobState&lt;/code&gt;&lt;/a&gt; is PROCESSING or PROCESSING_STOPPED, the JobImpressionsCompleted value is intended to increase as the job is processed; it indicates the amount of the job that has been processed at the time the Print Job's attribute set is queried or at the time a print job event is reported. When the job enters the COMPLETED, CANCELED, or ABORTED states, the JobImpressionsCompleted value is the final value for the job.</source>
          <target state="translated">JobImpressionsCompleted 속성은 작업 진행률을 설명합니다. 이 속성은 카운터가됩니다. 즉, 처리를 시작하지 않은 작업의 JobImpressionsCompleted 값은 0이어야합니다. 작업의 &lt;a href=&quot;jobstate&quot;&gt; &lt;code&gt;JobState&lt;/code&gt; &lt;/a&gt; 가 PROCESSING 또는 PROCESSING_STOPPED 인 경우 JobImpressionsCompleted 값은 작업이 처리됨에 따라 증가합니다. 인쇄 작업의 속성 세트가 조회되거나 인쇄 작업 이벤트가보고 될 때 처리 된 작업의 양을 나타냅니다. 작업이 COMPLETED, CANCELED 또는 ABORTED 상태가되면 JobImpressionsCompleted 값이 작업의 최종 값입니다.</target>
        </trans-unit>
        <trans-unit id="23b552cbebfc9eeb6f00f5f7f1d577e52be27c5e" translate="yes" xml:space="preserve">
          <source>The JobKOctets attribute describes the size of the job. This attribute is not intended to be a counter; it is intended to be useful routing and scheduling information if known. The printer may try to compute the JobKOctets attribute's value if it is not supplied in the Print Request. Even if the client does supply a value for the JobKOctets attribute in the Print Request, the printer may choose to change the value if the printer is able to compute a value which is more accurate than the client supplied value. The printer may be able to determine the correct value for the JobKOctets attribute either right at job submission time or at any later point in time.</source>
          <target state="translated">JobKOctets 속성은 작업 크기를 설명합니다. 이 속성은 카운터가 아닙니다. 알려진 경우 유용한 라우팅 및 스케줄링 정보가되도록 고안되었습니다. 인쇄 요청에 JobKOctets 속성 값이 제공되지 않으면 프린터는 JobKOctets 속성 값을 계산하려고 시도 할 수 있습니다. 클라이언트가 인쇄 요청에서 JobKOctets 속성 값을 제공하더라도 프린터가 클라이언트 제공 값보다 정확한 값을 계산할 수있는 경우 프린터는 값을 변경하도록 선택할 수 있습니다. 프린터는 작업 제출 시점 또는 이후에 JobKOctets 속성의 올바른 값을 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10778b515020fa74e3922d67e4e4cfb07a6b5d4d" translate="yes" xml:space="preserve">
          <source>The JobKOctets value must also not include the multiplicative factor due to a copies instruction embedded in the document data. If the document data actually includes replications of the document data, this value will include such replication. In other words, this value is always the size of the source document data, rather than a measure of the hardcopy output to be produced.</source>
          <target state="translated">문서 데이터에 포함 된 복사 명령으로 인해 JobKOctets 값에도 곱셈 요소가 포함되지 않아야합니다. 문서 데이터에 실제로 문서 데이터의 복제가 포함 된 경우이 값에는 해당 복제가 포함됩니다. 즉,이 값은 생성 할 하드 카피 출력을 측정하는 것이 아니라 항상 소스 문서 데이터의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="4f8e193f841acdf58db4b152692036053ed12078" translate="yes" xml:space="preserve">
          <source>The JobKOctets value must not include the multiplicative factors contributed by the number of copies specified by the &lt;a href=&quot;copies&quot;&gt;&lt;code&gt;Copies&lt;/code&gt;&lt;/a&gt; attribute, independent of whether the device can process multiple copies without making multiple passes over the job or document data and independent of whether the output is collated or not. Thus the value is independent of the implementation and indicates the size of the document(s) measured in K octets independent of the number of copies.</source>
          <target state="translated">JobKOctets 값은 장치가 작업 또는 문서 데이터를 여러 번 전달하지 않고 여러 사본을 처리 할 수 ​​있는지 여부와 출력의 한 부씩 정렬 여부에 관계없이 &lt;a href=&quot;copies&quot;&gt; &lt;code&gt;Copies&lt;/code&gt; &lt;/a&gt; 속성으로 지정된 사본 수에 의해 영향을받는 곱셈 요소를 포함 하지 않아야합니다. . 따라서이 값은 구현과 무관하며 사본 수와 상관없이 K 옥텟으로 측정 된 문서의 크기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="860b972389f862538b6b997fd07b4c1c60636261" translate="yes" xml:space="preserve">
          <source>The JobKOctetsProcessed attribute describes the progress of the job. This attribute is intended to be a counter. That is, the JobKOctetsProcessed value for a job that has not started processing must be 0. When the job's &lt;a href=&quot;jobstate&quot;&gt;&lt;code&gt;JobState&lt;/code&gt;&lt;/a&gt; is PROCESSING or PROCESSING_STOPPED, the JobKOctetsProcessed value is intended to increase as the job is processed; it indicates the amount of the job that has been processed at the time the Print Job's attribute set is queried or at the time a print job event is reported. When the job enters the COMPLETED, CANCELED, or ABORTED states, the JobKOctetsProcessed value is the final value for the job.</source>
          <target state="translated">JobKOctetsProcessed 속성은 작업 진행률을 설명합니다. 이 속성은 카운터가됩니다. 즉, 처리를 시작하지 않은 작업의 JobKOctetsProcessed 값은 0이어야합니다. 작업의 &lt;a href=&quot;jobstate&quot;&gt; &lt;code&gt;JobState&lt;/code&gt; &lt;/a&gt; 가 PROCESSING 또는 PROCESSING_STOPPED 인 경우 JobKOctetsProcessed 값은 작업이 처리됨에 따라 증가합니다. 인쇄 작업의 속성 세트가 조회되거나 인쇄 작업 이벤트가보고 될 때 처리 된 작업의 양을 나타냅니다. 작업이 COMPLETED, CANCELED 또는 ABORTED 상태가되면 JobKOctetsProcessed 값이 작업의 최종 값입니다.</target>
        </trans-unit>
        <trans-unit id="67c4f689dd8dce6456481d0861afa2eb83cc72f8" translate="yes" xml:space="preserve">
          <source>The JobMediaSheets attribute describes the size of the job. This attribute is not intended to be a counter; it is intended to be useful routing and scheduling information if known. The printer may try to compute the JobMediaSheets attribute's value if it is not supplied in the Print Request. Even if the client does supply a value for the JobMediaSheets attribute in the Print Request, the printer may choose to change the value if the printer is able to compute a value which is more accurate than the client supplied value. The printer may be able to determine the correct value for the JobMediaSheets attribute either right at job submission time or at any later point in time.</source>
          <target state="translated">JobMediaSheets 속성은 작업 크기를 설명합니다. 이 속성은 카운터가 아닙니다. 알려진 경우 유용한 라우팅 및 스케줄링 정보가되도록 고안되었습니다. 프린터는 JobMediaSheets 속성 값이 인쇄 요청에 제공되지 않은 경우 계산하려고 시도 할 수 있습니다. 클라이언트가 인쇄 요청에서 JobMediaSheets 속성 값을 제공하더라도 프린터가 클라이언트 제공 값보다 정확한 값을 계산할 수있는 경우 프린터는 값을 변경하도록 선택할 수 있습니다. 프린터는 작업 제출 시점 또는 이후에 JobMediaSheets 속성에 대한 올바른 값을 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27e40040d6353841f04365a16d249f070597a18a" translate="yes" xml:space="preserve">
          <source>The JobMediaSheetsCompleted attribute describes the progress of the job. This attribute is intended to be a counter. That is, the JobMediaSheetsCompleted value for a job that has not started processing must be 0. When the job's &lt;a href=&quot;jobstate&quot;&gt;&lt;code&gt;JobState&lt;/code&gt;&lt;/a&gt; is PROCESSING or PROCESSING_STOPPED, the JobMediaSheetsCompleted value is intended to increase as the job is processed; it indicates the amount of the job that has been processed at the time the Print Job's attribute set is queried or at the time a print job event is reported. When the job enters the COMPLETED, CANCELED, or ABORTED states, the JobMediaSheetsCompleted value is the final value for the job.</source>
          <target state="translated">JobMediaSheetsCompleted 속성은 작업 진행 상황을 설명합니다. 이 속성은 카운터가됩니다. 즉, 처리를 시작하지 않은 작업의 JobMediaSheetsCompleted 값은 0이어야합니다. 작업의 &lt;a href=&quot;jobstate&quot;&gt; &lt;code&gt;JobState&lt;/code&gt; &lt;/a&gt; 가 PROCESSING 또는 PROCESSING_STOPPED 인 경우 JobMediaSheetsCompleted 값은 작업이 처리됨에 따라 증가합니다. 인쇄 작업의 속성 세트가 조회되거나 인쇄 작업 이벤트가보고 될 때 처리 된 작업의 양을 나타냅니다. 작업이 COMPLETED, CANCELED 또는 ABORTED 상태가되면 JobMediaSheetsCompleted 값이 작업의 최종 값입니다.</target>
        </trans-unit>
        <trans-unit id="bc898aeb76a9f867124df93fc92a814fb7980188" translate="yes" xml:space="preserve">
          <source>The Julian Day is a standard way of expressing date and time commonly used in the scientific community. It is expressed as a decimal number of whole days where days start at midday. This class represents variations on Julian Days that count whole days from midnight.</source>
          <target state="translated">Julian Day는 과학계에서 일반적으로 사용되는 날짜와 시간을 표현하는 표준 방법입니다. 요일이 정오에 시작하는 전체 요일의 10 진수로 표시됩니다. 이 클래스는 자정부터 하루 종일 계산되는 Julian Days의 변형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9eef549030343348c0081e0aeeb494d2d5823916" translate="yes" xml:space="preserve">
          <source>The Kannada range with the Kannada digits.</source>
          <target state="translated">칸나다어 숫자가있는 칸나다어 범위입니다.</target>
        </trans-unit>
        <trans-unit id="9d5cb955409a47e5080caa7c35c25ddf731fb54b" translate="yes" xml:space="preserve">
          <source>The Kayah Li range with the Kayah Li digits.</source>
          <target state="translated">Kayah Li 숫자가있는 Kayah Li 범위입니다.</target>
        </trans-unit>
        <trans-unit id="04de0af52612213497a4e8449d41e7beb1c261f5" translate="yes" xml:space="preserve">
          <source>The Kerberos network authentication protocol is defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120&lt;/a&gt;. The Java platform contains support for the client side of Kerberos via the &lt;a href=&quot;../../../../org/ietf/jgss/package-summary&quot;&gt;&lt;code&gt;org.ietf.jgss&lt;/code&gt;&lt;/a&gt; package. There might also be a login module that implements &lt;a href=&quot;../../../../../java.base/javax/security/auth/spi/loginmodule&quot;&gt;&lt;code&gt;LoginModule&lt;/code&gt;&lt;/a&gt; to authenticate Kerberos principals.</source>
          <target state="translated">Kerberos 네트워크 인증 프로토콜은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120에&lt;/a&gt; 정의되어 있습니다. Java 플랫폼에는 &lt;a href=&quot;../../../../org/ietf/jgss/package-summary&quot;&gt; &lt;code&gt;org.ietf.jgss&lt;/code&gt; &lt;/a&gt; 패키지 를 통해 Kerberos의 클라이언트 측에 대한 지원이 포함되어 있습니다 . Kerberos 주체를 인증하기 위해 &lt;a href=&quot;../../../../../java.base/javax/security/auth/spi/loginmodule&quot;&gt; &lt;code&gt;LoginModule&lt;/code&gt; &lt;/a&gt; 을 구현하는 로그인 모듈도있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b31c8a2b1469694c5596d8e7d24f8ca4168d3814" translate="yes" xml:space="preserve">
          <source>The Kerberos network authentication protocol is defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120&lt;/a&gt;. The Java platform contains support for the client side of Kerberos via the &lt;a href=&quot;/openjdk~8_web/org/ietf/jgss/package-summary&quot;&gt;&lt;code&gt;org.ietf.jgss&lt;/code&gt;&lt;/a&gt; package. There might also be a login module that implements &lt;a href=&quot;../spi/loginmodule&quot;&gt;&lt;code&gt;LoginModule&lt;/code&gt;&lt;/a&gt; to authenticate Kerberos principals.</source>
          <target state="translated">Kerberos 네트워크 인증 프로토콜은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120에&lt;/a&gt; 정의되어 있습니다. Java 플랫폼에는 &lt;a href=&quot;/openjdk~8_web/org/ietf/jgss/package-summary&quot;&gt; &lt;code&gt;org.ietf.jgss&lt;/code&gt; &lt;/a&gt; 패키지 를 통해 Kerberos의 클라이언트 측을 지원 합니다. Kerberos 프린시 &lt;a href=&quot;../spi/loginmodule&quot;&gt; &lt;code&gt;LoginModule&lt;/code&gt; &lt;/a&gt; 을 인증하기 위해 LoginModule 을 구현하는 로그인 모듈이있을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="157c69eafa4fbe15c7e8811316a4ab15df7d02af" translate="yes" xml:space="preserve">
          <source>The Kerberos network authentication protocol is defined in &lt;a href=&quot;https://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120&lt;/a&gt;. The Java platform contains support for the client side of Kerberos via the &lt;a href=&quot;../../../../org/ietf/jgss/package-summary&quot;&gt;&lt;code&gt;org.ietf.jgss&lt;/code&gt;&lt;/a&gt; package. There might also be a login module that implements &lt;a href=&quot;../../../../../java.base/javax/security/auth/spi/loginmodule&quot;&gt;&lt;code&gt;LoginModule&lt;/code&gt;&lt;/a&gt; to authenticate Kerberos principals.</source>
          <target state="translated">Kerberos 네트워크 인증 프로토콜은 &lt;a href=&quot;https://www.ietf.org/rfc/rfc4120.txt&quot;&gt;RFC 4120에&lt;/a&gt; 정의되어 있습니다. Java 플랫폼에는 &lt;a href=&quot;../../../../org/ietf/jgss/package-summary&quot;&gt; &lt;code&gt;org.ietf.jgss&lt;/code&gt; &lt;/a&gt; 패키지 를 통해 Kerberos의 클라이언트 측에 대한 지원이 포함되어 있습니다 . Kerberos 주체를 인증하기 위해 &lt;a href=&quot;../../../../../java.base/javax/security/auth/spi/loginmodule&quot;&gt; &lt;code&gt;LoginModule&lt;/code&gt; &lt;/a&gt; 을 구현하는 로그인 모듈도있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="179c153fa31e392a5dae09bfb3ec12cf7382a77e" translate="yes" xml:space="preserve">
          <source>The Kerberos v5 mechanism (&quot;1.2.840.113554.1.2.2&quot;) will always be returned in this list when the indicated nametype is one of &lt;a href=&quot;gssname#NT_HOSTBASED_SERVICE&quot;&gt;&lt;code&gt;GSSName.NT_HOSTBASED_SERVICE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;gssname#NT_EXPORT_NAME&quot;&gt;&lt;code&gt;GSSName.NT_EXPORT_NAME&lt;/code&gt;&lt;/a&gt;, or &quot;1.2.840.113554.1.2.2.1&quot;.</source>
          <target state="translated">표시된 NAMETYPE 중 하나 일 때의 Kerberos V5기구 ( &quot;1.2.840.113554.1.2.2&quot;)는 항상이 목록에 반환됩니다 &lt;a href=&quot;gssname#NT_HOSTBASED_SERVICE&quot;&gt; &lt;code&gt;GSSName.NT_HOSTBASED_SERVICE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;gssname#NT_EXPORT_NAME&quot;&gt; &lt;code&gt;GSSName.NT_EXPORT_NAME&lt;/code&gt; &lt;/a&gt; , 또는 &quot;1.2.840.113554.1.2.2.1&quot;.</target>
        </trans-unit>
        <trans-unit id="1544cf9c5107663734ae872cc327b8154b4bc517" translate="yes" xml:space="preserve">
          <source>The Key interface is the top-level interface for all keys.</source>
          <target state="translated">키 인터페이스는 모든 키의 최상위 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="0f7ba838a05da49357b31ae6823009d4f10f3dbe" translate="yes" xml:space="preserve">
          <source>The Key interface is the top-level interface for all keys. It defines the functionality shared by all key objects. All keys have three characteristics:</source>
          <target state="translated">키 인터페이스는 모든 키의 최상위 인터페이스입니다. 모든 주요 객체가 공유하는 기능을 정의합니다. 모든 키에는 세 가지 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf548aaac46d4e0f0b562c298e02a26e9e223aa6" translate="yes" xml:space="preserve">
          <source>The KeyPairGenerator class is used to generate pairs of public and private keys.</source>
          <target state="translated">KeyPairGenerator 클래스는 공개 및 개인 키 쌍을 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="84ce39b134b25304a741de41814f7513944cfe5b" translate="yes" xml:space="preserve">
          <source>The KeyPairGenerator class is used to generate pairs of public and private keys. Key pair generators are constructed using the &lt;code&gt;getInstance&lt;/code&gt; factory methods (static methods that return instances of a given class).</source>
          <target state="translated">KeyPairGenerator 클래스는 공개 및 개인 키 쌍을 생성하는 데 사용됩니다. 키 페어 생성기는 &lt;code&gt;getInstance&lt;/code&gt; 팩토리 메소드 (주어진 클래스의 인스턴스를 리턴하는 정적 메소드)를 사용하여 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="15b0ebadd884d0b51462c94b77021fc226c8b293" translate="yes" xml:space="preserve">
          <source>The KeyStore is instantiated from &lt;code&gt;provider&lt;/code&gt; if non-null. Otherwise, all installed providers are searched.</source>
          <target state="translated">키 저장소는 널이 아닌 경우 &lt;code&gt;provider&lt;/code&gt; 로부터 인스턴스화됩니다 . 그렇지 않으면 설치된 모든 제공자가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="0e2ef01fdd78023f4e41a2332f54d31d4e897196" translate="yes" xml:space="preserve">
          <source>The KeyboardFocusManager is both a centralized location for client code to query for the focus owner and initiate focus changes, and an event dispatcher for all FocusEvents, WindowEvents related to focus, and KeyEvents.</source>
          <target state="translated">KeyboardFocusManager는 클라이언트 코드가 포커스 소유자를 쿼리하고 포커스 변경을 시작하는 중앙 집중식 위치이자 모든 FocusEvents, 포커스 관련 WindowEvents 및 KeyEvents에 대한 이벤트 디스패처입니다.</target>
        </trans-unit>
        <trans-unit id="fe9108e974a840f34cdac2d8957f8fc6f75c25d0" translate="yes" xml:space="preserve">
          <source>The KeyboardFocusManager is responsible for managing the active and focused Windows, and the current focus owner.</source>
          <target state="translated">KeyboardFocusManager는 활성 및 포커스가있는 Windows와 현재 포커스 소유자를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="c9b92722aba2c53f9e3ad23b73c28a03069188d3" translate="yes" xml:space="preserve">
          <source>The KeyboardFocusManager is responsible for managing the active and focused Windows, and the current focus owner. The focus owner is defined as the Component in an application that will typically receive all KeyEvents generated by the user. The focused Window is the Window that is, or contains, the focus owner. Only a Frame or a Dialog can be the active Window. The native windowing system may denote the active Window or its children with special decorations, such as a highlighted title bar. The active Window is always either the focused Window, or the first Frame or Dialog that is an owner of the focused Window.</source>
          <target state="translated">KeyboardFocusManager는 활성 및 포커스가있는 Windows와 현재 포커스 소유자를 관리합니다. 포커스 소유자는 일반적으로 사용자가 생성 한 모든 KeyEvent를 수신하는 응용 프로그램의 구성 요소로 정의됩니다. 포커스가있는 창은 포커스 소유자이거나 포커스 소유자를 포함하는 창입니다. 프레임 또는 대화 상자 만 활성 창이 될 수 있습니다. 기본 창 시스템은 강조 표시된 제목 표시 줄과 같은 특수 장식으로 활성 창 또는 하위 창을 나타낼 수 있습니다. 활성 창은 항상 초점이 맞춰진 창이거나 초점이 맞춰진 창 소유자 인 첫 번째 프레임 또는 대화 상자입니다.</target>
        </trans-unit>
        <trans-unit id="dfdf028492eeb6a2c0a7e187bb51caef0fe58094" translate="yes" xml:space="preserve">
          <source>The Khmer range with the Khmer digits.</source>
          <target state="translated">크메르 숫자가있는 크메르 범위입니다.</target>
        </trans-unit>
        <trans-unit id="e90bf29f8e3545c413433081172c9465c0614fe9" translate="yes" xml:space="preserve">
          <source>The LDAP directory server must be configured to permit read access to the userPassword attribute. If the user entered a valid username and password, this &lt;code&gt;LoginModule&lt;/code&gt; associates a &lt;code&gt;UnixPrincipal&lt;/code&gt;, &lt;code&gt;UnixNumericUserPrincipal&lt;/code&gt;, and the relevant UnixNumericGroupPrincipals with the &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">LDAP 디렉토리 서버는 userPassword 속성에 대한 읽기 액세스를 허용하도록 구성되어야합니다. 사용자가 유효한 사용자 이름과 암호를 입력 한 경우이 &lt;code&gt;LoginModule&lt;/code&gt; 은 &lt;code&gt;UnixPrincipal&lt;/code&gt; , &lt;code&gt;UnixNumericUserPrincipal&lt;/code&gt; 및 관련 UnixNumericGroupPrincipals를 &lt;code&gt;Subject&lt;/code&gt; 와 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="ba0192d9ab92e21e9c2744dd9f7ef43296184075" translate="yes" xml:space="preserve">
          <source>The LDAPv3 protocol uses controls to send and receive additional data to affect the behavior of predefined operations. Controls can be sent along with any LDAP operation to the server. These are referred to as &lt;em&gt;request controls&lt;/em&gt;. For example, a &quot;sort&quot; control can be sent with an LDAP search operation to request that the results be returned in a particular order. Solicited and unsolicited controls can also be returned with responses from the server. Such controls are referred to as &lt;em&gt;response controls&lt;/em&gt;. For example, an LDAP server might define a special control to return change notifications.</source>
          <target state="translated">LDAPv3 프로토콜은 컨트롤을 사용하여 추가 데이터를 송수신하여 미리 정의 된 작업의 동작에 영향을줍니다. 모든 LDAP 조작과 함께 제어를 서버로 보낼 수 있습니다. 이를 &lt;em&gt;요청 제어&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . 예를 들어 &quot;정렬&quot;컨트롤을 LDAP 검색 작업과 함께 보내 특정 결과로 결과를 반환하도록 요청할 수 있습니다. 요청 및 요청되지 않은 제어는 서버의 응답으로 리턴 될 수도 있습니다. 이러한 컨트롤을 &lt;em&gt;응답 컨트롤&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 예를 들어, LDAP 서버는 변경 알림을 반환하는 특수 컨트롤을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84b009686e42e06098b246c404691be107aa2893" translate="yes" xml:space="preserve">
          <source>The Lao range with the Lao digits.</source>
          <target state="translated">라오스 숫자가있는 라오스 범위입니다.</target>
        </trans-unit>
        <trans-unit id="3d7e088fa5dee667531590ff7a47cda4787dd6af" translate="yes" xml:space="preserve">
          <source>The Latin (European) range with the Latin (ASCII) digits.</source>
          <target state="translated">라틴 (ASCII) 숫자가있는 라틴 (유럽) 범위입니다.</target>
        </trans-unit>
        <trans-unit id="e69f4a3d93cbdffcb22365dd2d768eab2d0fbb22" translate="yes" xml:space="preserve">
          <source>The Left Arrow key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 작업 키인 왼쪽 화살표 키입니다.</target>
        </trans-unit>
        <trans-unit id="625f245af32d880495183dfc988c393be7c10c2c" translate="yes" xml:space="preserve">
          <source>The Lepcha range with the Lepcha digits.</source>
          <target state="translated">Lepcha 숫자가있는 Lepcha 범위입니다.</target>
        </trans-unit>
        <trans-unit id="e247331a2fdfcd1f002adc01fbf899e2a1591f78" translate="yes" xml:space="preserve">
          <source>The Level class defines a set of standard logging levels that can be used to control logging output.</source>
          <target state="translated">Level 클래스는 로깅 출력을 제어하는 ​​데 사용할 수있는 표준 로깅 수준 세트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5e0b0c714c17843fb551c38291dba43f83549e84" translate="yes" xml:space="preserve">
          <source>The Level class defines a set of standard logging levels that can be used to control logging output. The logging Level objects are ordered and are specified by ordered integers. Enabling logging at a given level also enables logging at all higher levels.</source>
          <target state="translated">Level 클래스는 로깅 출력을 제어하는 ​​데 사용할 수있는 표준 로깅 수준 세트를 정의합니다. 로깅 레벨 오브젝트는 순서가 지정된 순서대로 지정됩니다. 특정 수준에서 로깅을 활성화하면 모든 상위 수준에서 로깅을 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eb102e7a522f2dead8bb60ac1334e542914f901" translate="yes" xml:space="preserve">
          <source>The Limbu range with the Limbu digits.</source>
          <target state="translated">Limbu 숫자가있는 Limbu 범위입니다.</target>
        </trans-unit>
        <trans-unit id="23341604b8e30c5db6f5082ffe273ce643ebf866" translate="yes" xml:space="preserve">
          <source>The LineEvent.Type inner class identifies what kind of event occurred on a line.</source>
          <target state="translated">LineEvent.Type 내부 클래스는 회선에서 어떤 종류의 이벤트가 발생했는지 식별합니다.</target>
        </trans-unit>
        <trans-unit id="f4515bae178db99e414cd4419e58ab70e3a4ab78" translate="yes" xml:space="preserve">
          <source>The LineEvent.Type inner class identifies what kind of event occurred on a line. Static instances are provided for the common types (OPEN, CLOSE, START, and STOP).</source>
          <target state="translated">LineEvent.Type 내부 클래스는 회선에서 어떤 종류의 이벤트가 발생했는지 식별합니다. 정적 유형은 공통 유형 (OPEN, CLOSE, START 및 STOP)에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="82041c3f3458b7321d9e6904a9a2fbd85ff5e8fb" translate="yes" xml:space="preserve">
          <source>The ListSelectionListener that's added to the JLists selection model at installUI time, and whenever the JList.selectionModel property changes.</source>
          <target state="translated">installUI시 및 JList.selectionModel 속성이 변경 될 때마다 JList 선택 모델에 추가되는 ListSelectionListener입니다.</target>
        </trans-unit>
        <trans-unit id="9d8a5479edc0054602772a4f3eec0b96299fb21f" translate="yes" xml:space="preserve">
          <source>The ListSelectionListener that's added to the JLists selection model at installUI time, and whenever the JList.selectionModel property changes. When the selection changes we repaint the affected rows.</source>
          <target state="translated">installUI시 및 JList.selectionModel 속성이 변경 될 때마다 JList 선택 모델에 추가되는 ListSelectionListener입니다. 선택이 변경되면 영향을받은 행을 다시 그립니다.</target>
        </trans-unit>
        <trans-unit id="15a370cb868586ab99d868f607377364eaa66939" translate="yes" xml:space="preserve">
          <source>The Locale constructors have always specified that the language and the country param be two characters in length, although in practice they have accepted any length. The specification has now been relaxed to allow language codes of two to eight characters and country (region) codes of two to three characters, and in particular, three-letter language codes and three-digit region codes as specified in the IANA Language Subtag Registry. For compatibility, the implementation still does not impose a length constraint.</source>
          <target state="translated">로케일 생성자는 실제로 언어와 국가 매개 변수의 길이가 두 자로 지정되어 있지만 실제로는 길이를 허용합니다. 이 사양은 이제 2 ~ 8 자의 언어 코드 및 2 ~ 3 자의 국가 (지역) 코드, 특히 IANA 언어 하위 태그 레지스트리에 지정된 3 자리 언어 코드 및 3 자리 지역 코드를 허용하도록 완화되었습니다. . 호환성을 위해 구현시 여전히 길이 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb678f5a8ea6de459807c825837564cfaf1f3ed6" translate="yes" xml:space="preserve">
          <source>The LogManager defines two optional system properties that allow control over the initial configuration, as specified in the &lt;a href=&quot;#readConfiguration()&quot;&gt;&lt;code&gt;readConfiguration()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">LogManager는 &lt;a href=&quot;#readConfiguration()&quot;&gt; &lt;code&gt;readConfiguration()&lt;/code&gt; &lt;/a&gt; 메서드에 지정된대로 초기 구성을 제어 할 수있는 두 가지 선택적 시스템 속성을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="3bb20e6e58795891b26d0418b98b5c49029c3c3e" translate="yes" xml:space="preserve">
          <source>The LogManager defines two optional system properties that allow control over the initial configuration:</source>
          <target state="translated">LogManager는 초기 구성을 제어 할 수있는 두 가지 선택적 시스템 특성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3cca1e6f62e92b82a24f09973b67d35f6162ed74" translate="yes" xml:space="preserve">
          <source>The LogRecord class is serializable.</source>
          <target state="translated">LogRecord 클래스는 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="37b5ec8719483e5837405faf74d2042c53b0e061" translate="yes" xml:space="preserve">
          <source>The Logger factory methods call this method to register each newly created Logger.</source>
          <target state="translated">로거 팩토리 메소드는이 메소드를 호출하여 새로 작성된 각 로거를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="16fa852d45e166564cfd7fb514ab7d4a6acfffbe" translate="yes" xml:space="preserve">
          <source>The Logging APIs offer both static and dynamic configuration control. Static control enables field service staff to set up a particular configuration and then re-launch the application with the new logging settings. Dynamic control allows for updates to the logging configuration within a currently running program. The APIs also allow for logging to be enabled or disabled for different functional areas of the system. For example, a field service engineer might be interested in tracing all AWT events, but might have no interest in socket events or memory management.</source>
          <target state="translated">로깅 API는 정적 및 동적 구성 제어를 모두 제공합니다. 정적 제어를 통해 현장 서비스 직원은 특정 구성을 설정 한 다음 새로운 로깅 설정으로 응용 프로그램을 다시 시작할 수 있습니다. 동적 제어를 통해 현재 실행중인 프로그램 내에서 로깅 구성을 업데이트 할 수 있습니다. API를 사용하면 시스템의 다른 기능 영역에 대해 로깅을 활성화하거나 비활성화 할 수 있습니다. 예를 들어, 현장 서비스 엔지니어는 모든 AWT 이벤트 추적에 관심이 있지만 소켓 이벤트 또는 메모리 관리에는 관심이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d2c9dc56a0259f0e6bad38df059f2ef62f5a015" translate="yes" xml:space="preserve">
          <source>The LoginModule-specific options represent the options configured for this &lt;code&gt;LoginModule&lt;/code&gt; by an administrator or user in the login &lt;code&gt;Configuration&lt;/code&gt;. The options are defined by the &lt;code&gt;LoginModule&lt;/code&gt; itself and control the behavior within it. For example, a &lt;code&gt;LoginModule&lt;/code&gt; may define options to support debugging/testing capabilities. Options are defined using a key-value syntax, such as</source>
          <target state="translated">LoginModule 관련 옵션은 로그인 &lt;code&gt;Configuration&lt;/code&gt; 의 관리자 또는 사용자 가이 &lt;code&gt;LoginModule&lt;/code&gt; 에 대해 구성한 옵션을 나타냅니다 . 옵션은 &lt;code&gt;LoginModule&lt;/code&gt; 자체에 의해 정의되며 그 안에있는 동작을 제어합니다. 예를 들어 &lt;code&gt;LoginModule&lt;/code&gt; 은 디버깅 / 테스트 기능을 지원하는 옵션을 정의 할 수 있습니다. 옵션은 다음과 같은 키-값 구문을 사용하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="873df94afa4e7ad82e48e9073fb806c35bb167b5" translate="yes" xml:space="preserve">
          <source>The MAC result is stored in &lt;code&gt;output&lt;/code&gt;, starting at &lt;code&gt;outOffset&lt;/code&gt; inclusive.</source>
          <target state="translated">MAC 결과는 &lt;code&gt;outOffset&lt;/code&gt; 부터 시작하여 &lt;code&gt;output&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="df379351016742258da0a9b0e11610edb7e1d510" translate="yes" xml:space="preserve">
          <source>The MBean Server can be queried for MBeans that meet a particular condition, using its &lt;a href=&quot;mbeanserver#queryNames(javax.management.ObjectName,javax.management.QueryExp)&quot;&gt;&lt;code&gt;queryNames&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mbeanserver#queryMBeans(javax.management.ObjectName,javax.management.QueryExp)&quot;&gt;&lt;code&gt;queryMBeans&lt;/code&gt;&lt;/a&gt; method. The &lt;a href=&quot;queryexp&quot;&gt;&lt;code&gt;QueryExp&lt;/code&gt;&lt;/a&gt; parameter to the method can be any implementation of the interface &lt;code&gt;QueryExp&lt;/code&gt;, but it is usually best to obtain the &lt;code&gt;QueryExp&lt;/code&gt; value by calling the static methods in this class. This is particularly true when querying a remote MBean Server: a custom implementation of the &lt;code&gt;QueryExp&lt;/code&gt; interface might not be present in the remote MBean Server, but the methods in this class return only standard classes that are part of the JMX implementation.</source>
          <target state="translated">MBean 서버는 &lt;a href=&quot;mbeanserver#queryNames(javax.management.ObjectName,javax.management.QueryExp)&quot;&gt; &lt;code&gt;queryNames&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;mbeanserver#queryMBeans(javax.management.ObjectName,javax.management.QueryExp)&quot;&gt; &lt;code&gt;queryMBeans&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 특정 조건을 충족하는 MBean에 대해 쿼리 할 수 ​​있습니다 . &lt;a href=&quot;queryexp&quot;&gt; &lt;code&gt;QueryExp&lt;/code&gt; 를의&lt;/a&gt; 방법에 파라미터 인터페이스의 어떤 구현 될 수 &lt;code&gt;QueryExp&lt;/code&gt; 를 있지만 수득하는 것이 최상이다 &lt;code&gt;QueryExp&lt;/code&gt; 를의 이 클래스의 정적 메소드를 호출하여 값. 원격 MBean 서버를 쿼리 할 때 특히 그렇습니다. &lt;code&gt;QueryExp&lt;/code&gt; 인터페이스 의 사용자 정의 구현이 원격 MBean 서버에 없을 수도 있지만이 클래스의 메서드는 JMX 구현의 일부인 표준 클래스 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8e20974e279464971ac54f4c492ac718451f3fb7" translate="yes" xml:space="preserve">
          <source>The MBean Server can be queried for MBeans that meet a particular condition, using its &lt;a href=&quot;mbeanserver#queryNames-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt;&lt;code&gt;queryNames&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mbeanserver#queryMBeans-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt;&lt;code&gt;queryMBeans&lt;/code&gt;&lt;/a&gt; method. The &lt;a href=&quot;queryexp&quot;&gt;&lt;code&gt;QueryExp&lt;/code&gt;&lt;/a&gt; parameter to the method can be any implementation of the interface &lt;code&gt;QueryExp&lt;/code&gt;, but it is usually best to obtain the &lt;code&gt;QueryExp&lt;/code&gt; value by calling the static methods in this class. This is particularly true when querying a remote MBean Server: a custom implementation of the &lt;code&gt;QueryExp&lt;/code&gt; interface might not be present in the remote MBean Server, but the methods in this class return only standard classes that are part of the JMX implementation.</source>
          <target state="translated">&lt;a href=&quot;mbeanserver#queryNames-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt; &lt;code&gt;queryNames&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;mbeanserver#queryMBeans-javax.management.ObjectName-javax.management.QueryExp-&quot;&gt; &lt;code&gt;queryMBeans&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 특정 조건을 충족하는 MBean에 대해 MBean 서버를 조회 할 수 있습니다 . &lt;a href=&quot;queryexp&quot;&gt; &lt;code&gt;QueryExp&lt;/code&gt; 를의&lt;/a&gt; 방법에 파라미터 인터페이스의 어떤 구현 될 수 &lt;code&gt;QueryExp&lt;/code&gt; 를 있지만 수득하는 것이 최상이다 &lt;code&gt;QueryExp&lt;/code&gt; 를의 이 클래스의 정적 메소드를 호출하여 값. 이는 원격 MBean 서버를 조회 할 때 특히 그렇습니다. &lt;code&gt;QueryExp&lt;/code&gt; 인터페이스 의 사용자 정의 구현이 원격 MBean 서버에 없을 수 있지만이 클래스의 메소드는 JMX 구현의 일부인 표준 클래스 만 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9b55c952d8b9667a8cd83b230d433a9d1d3bc37d" translate="yes" xml:space="preserve">
          <source>The MBean Server used is the one returned by &lt;a href=&quot;queryeval#getMBeanServer()&quot;&gt;&lt;code&gt;QueryEval.getMBeanServer()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 된 MBean 서버는 &lt;a href=&quot;queryeval#getMBeanServer()&quot;&gt; &lt;code&gt;QueryEval.getMBeanServer()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 것 입니다.</target>
        </trans-unit>
        <trans-unit id="72d1d3a5c29db56a086580b10e87cee9417c2769" translate="yes" xml:space="preserve">
          <source>The MBean Server used is the one returned by &lt;a href=&quot;queryeval#getMBeanServer--&quot;&gt;&lt;code&gt;QueryEval.getMBeanServer()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 된 MBean 서버는 &lt;a href=&quot;queryeval#getMBeanServer--&quot;&gt; &lt;code&gt;QueryEval.getMBeanServer()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 것 입니다.</target>
        </trans-unit>
        <trans-unit id="21324a38f03c31ace3a1e422ca3454c83ac8dbb8" translate="yes" xml:space="preserve">
          <source>The MBean is already registered in the repository.</source>
          <target state="translated">MBean은 이미 저장소에 등록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="43753879ff4a9ab9e94f41c105bc04ec605906f3" translate="yes" xml:space="preserve">
          <source>The MBean must have a listener that exactly matches the given &lt;code&gt;listener&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, and &lt;code&gt;handback&lt;/code&gt; parameters. If there is more than one such listener, only one is removed.</source>
          <target state="translated">MBean에는 지정된 &lt;code&gt;listener&lt;/code&gt; , &lt;code&gt;filter&lt;/code&gt; 및 &lt;code&gt;handback&lt;/code&gt; 매개 변수 와 정확히 일치하는 수신기가 있어야합니다 . 이러한 리스너가 둘 이상 있으면 하나만 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="30152426051a3aa7c2787f9bb448c65fd9d96573" translate="yes" xml:space="preserve">
          <source>The MBean server connection through which the methods of a proxy using this handler are forwarded.</source>
          <target state="translated">이 핸들러를 사용하는 프록시 메소드가 전달되는 MBean 서버 연결입니다.</target>
        </trans-unit>
        <trans-unit id="5a6b667365181658d557141a79bdcd9ae1d79d48" translate="yes" xml:space="preserve">
          <source>The MBeanServer reference is internally kept. This will allow &lt;code&gt;findMBeanServer&lt;/code&gt; to return a reference to this MBeanServer object.</source>
          <target state="translated">MBeanServer 참조는 내부적으로 유지됩니다. 이렇게하면 &lt;code&gt;findMBeanServer&lt;/code&gt; 가이 MBeanServer 오브젝트에 대한 참조를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce98176f741b29841e04388f314ecc341556fb9" translate="yes" xml:space="preserve">
          <source>The MBeanServerBuilder makes it possible to wrap the MBeanServers returned by the default MBeanServerBuilder implementation, for the purpose of e.g. adding an additional security layer.</source>
          <target state="translated">MBeanServerBuilder를 사용하면 추가 보안 계층 ​​추가와 같은 목적으로 기본 MBeanServerBuilder 구현에서 리턴 한 MBeanServer를 랩핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ebb8ef1bdda79f2bf977d8f0f2c843f817752de" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-1&quot; message digest</source>
          <target state="translated">&quot;SHA-1&quot;메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="c43e787474141d0bb72e21314b04491164ecd29c" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-1&quot; message digest.</source>
          <target state="translated">&quot;SHA-1&quot;메시지 요약을 사용하는 MGF1ParameterSpec입니다.</target>
        </trans-unit>
        <trans-unit id="32c91218272c1ce637c8a43d4efa8d7be714817e" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-224&quot; message digest</source>
          <target state="translated">&quot;SHA-224&quot;메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="ded68968556406a67098d9312cb325eb7740b1a7" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-224&quot; message digest.</source>
          <target state="translated">&quot;SHA-224&quot;메시지 요약을 사용하는 MGF1ParameterSpec입니다.</target>
        </trans-unit>
        <trans-unit id="f4145abd624d13b5fd6c271646d555d996874e76" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-256&quot; message digest</source>
          <target state="translated">&quot;SHA-256&quot;메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="30567a972c0ebfa4faa9759c8c4f5615d0736a78" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-256&quot; message digest.</source>
          <target state="translated">&quot;SHA-256&quot;메시지 요약을 사용하는 MGF1ParameterSpec입니다.</target>
        </trans-unit>
        <trans-unit id="ffe8090c162f81eda0ca11ad18b4d00f0460668a" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-384&quot; message digest</source>
          <target state="translated">&quot;SHA-384&quot;메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="8f743fd5434a0de8774dcd2c54b80badfe4a3dec" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses &quot;SHA-384&quot; message digest.</source>
          <target state="translated">&quot;SHA-384&quot;메시지 요약을 사용하는 MGF1ParameterSpec입니다.</target>
        </trans-unit>
        <trans-unit id="9fcd13c9a51cff2dfe34d11d75622669ff7a2f6f" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses SHA-512 message digest</source>
          <target state="translated">SHA-512 메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="773fa0838097295208f32770a4edbdf66bd50a46" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses SHA-512 message digest.</source>
          <target state="translated">SHA-512 메시지 요약을 사용하는 MGF1ParameterSpec입니다.</target>
        </trans-unit>
        <trans-unit id="c6fdeb15a6d0d672938ac7162d09074690eabb53" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses SHA-512/224 message digest</source>
          <target state="translated">SHA-512 / 224 메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="6b740423dca40861f104766ac050de56d78d3f30" translate="yes" xml:space="preserve">
          <source>The MGF1ParameterSpec which uses SHA-512/256 message digest</source>
          <target state="translated">SHA-512 / 256 메시지 다이제스트를 사용하는 MGF1ParameterSpec</target>
        </trans-unit>
        <trans-unit id="516e21a61c986db4b650efb7f3b9edffb19e1c28" translate="yes" xml:space="preserve">
          <source>The MIDI 1.0 Specification defines both 7-bit controllers and 14-bit controllers. Continuous controllers, such as wheels and sliders, typically have 14 bits (two MIDI bytes), while discrete controllers, such as switches, typically have 7 bits (one MIDI byte). Refer to the specification to see the expected resolution for each type of control.</source>
          <target state="translated">MIDI 1.0 사양은 7 비트 컨트롤러와 14 비트 컨트롤러를 모두 정의합니다. 휠 및 슬라이더와 같은 연속 컨트롤러에는 일반적으로 14 비트 (2 개의 MIDI 바이트)가 있고 스위치와 같은 개별 컨트롤러에는 일반적으로 7 비트 (1 개의 MIDI 바이트)가 있습니다. 각 제어 유형에 대한 예상 해상도를 보려면 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3b90ca10823dacdb7ec1aff6e9c338eb2858be24" translate="yes" xml:space="preserve">
          <source>The MIDI 1.0 specification provides for 16 channels, so this method returns an array of at least 16 elements. However, if this synthesizer doesn't make use of all 16 channels, some of the elements of the array might be &lt;code&gt;null&lt;/code&gt;, so you should check each element before using it.</source>
          <target state="translated">MIDI 1.0 사양은 16 개의 채널을 제공하므로이 방법은 16 개 이상의 요소 배열을 반환합니다. 그러나이 신시사이저가 16 개의 채널을 모두 사용하지 않으면 배열의 일부 요소가 &lt;code&gt;null&lt;/code&gt; 이 될 수 있으므로 사용하기 전에 각 요소를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="049c7ab3e0f2c876b50b46fe3789a8747dae1e9c" translate="yes" xml:space="preserve">
          <source>The MIDI channel on which this voice is playing.</source>
          <target state="translated">이 음색이 재생되는 MIDI 채널입니다.</target>
        </trans-unit>
        <trans-unit id="b52e6c1511e484eaf10f9c3556aee2243b42e67c" translate="yes" xml:space="preserve">
          <source>The MIDI channel on which this voice is playing. The value is a zero-based channel number if the voice is active, or unspecified if the voice is inactive.</source>
          <target state="translated">이 음색이 연주되는 MIDI 채널입니다. 음성이 활성화 된 경우이 값은 0부터 시작하는 채널 번호이거나 음성이 비활성화 된 경우 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="526debeb157a66f1367b032953ad21ed8a2a5fd6" translate="yes" xml:space="preserve">
          <source>The MIDI message data.</source>
          <target state="translated">MIDI 메시지 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="72e471be8e18253cd2fa90755b2430be47a7c9c7" translate="yes" xml:space="preserve">
          <source>The MIDI message data. The first byte is the status byte for the message; subsequent bytes up to the length of the message are data bytes for this message.</source>
          <target state="translated">MIDI 메시지 데이터 첫 번째 바이트는 메시지의 상태 바이트입니다. 메시지 길이까지의 후속 바이트는이 메시지의 데이터 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="317772b1f4d7bef7e847f7a2507ef5cf22a36f76" translate="yes" xml:space="preserve">
          <source>The MIDI note that this voice is playing.</source>
          <target state="translated">이 음색이 재생되고있는 MIDI 노트입니다.</target>
        </trans-unit>
        <trans-unit id="09d0f1e1fda22537e5c3106cad4d736b151fe66f" translate="yes" xml:space="preserve">
          <source>The MIDI note that this voice is playing. The range for an active voice is from 0 to 127 in semitones, with 60 referring to Middle C. The value is unspecified if the voice is inactive.</source>
          <target state="translated">이 음색이 연주되고있는 MIDI 음표. 활성 음성의 범위는 반음 단위로 0에서 127까지이며 60은 중간 C를 나타냅니다. 음성이 비활성이면 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f275ac1e77302fd1f9c984942071af0000235dd" translate="yes" xml:space="preserve">
          <source>The MIDI specification does not dictate whether notes that are already sounding should switch to the new instrument (timbre) or continue with their original timbre until terminated by a note-off.</source>
          <target state="translated">MIDI 사양은 이미 소리가 나는 음이 새로운 악기 (음색)로 전환되어야하는지 또는 음표로 종료 될 때까지 원래의 음색으로 계속해야하는지 여부를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="883ec76cbd3a1ad3d350032e79eb664e1f1a784b" translate="yes" xml:space="preserve">
          <source>The MIDI specification stipulates that pitch bend be a 14-bit value, where zero is maximum downward bend, 16383 is maximum upward bend, and 8192 is the center (no pitch bend). The actual amount of pitch change is not specified; it can be changed by a pitch-bend sensitivity setting. However, the General MIDI specification says that the default range should be two semitones up and down from center.</source>
          <target state="translated">MIDI 사양은 피치 벤드를 14 비트 값으로 규정합니다. 여기서 0은 최대 하향 벤드, 16383은 최대 상향 벤드, 8192는 중앙 (피치 벤드 없음)입니다. 실제 피치 변경 량은 지정되지 않습니다. 피치 벤드 감도 설정으로 변경할 수 있습니다. 그러나 일반 MIDI 사양에 따르면 기본 범위는 중앙에서 위아래로 두 반음이어야합니다.</target>
        </trans-unit>
        <trans-unit id="635898bd1d6ec018c38dd8a4feda9d061e0d6d2b" translate="yes" xml:space="preserve">
          <source>The MIDI specification stipulates that pitch bend be a 14-bit value, where zero is maximum downward bend, 16383 is maximum upward bend, and 8192 is the center (no pitch bend). The actual amount of pitch change is not specified; it can be changed by a pitch-bend sensitivity setting. However, the General MIDI specification says that the default range should be two semitones up and down from center. It is possible that the underlying synthesizer does not support this MIDI message. In order to verify that &lt;code&gt;setPitchBend&lt;/code&gt; was successful, use &lt;code&gt;getPitchBend&lt;/code&gt;.</source>
          <target state="translated">MIDI 사양에서는 피치 벤드가 14 비트 값이며, 0은 최대 하향 벤드, 16383은 최대 상향 벤드, 8192는 중심 (피치 벤드 없음)입니다. 실제 피치 변경 량은 지정되어 있지 않습니다. 피치 벤드 감도 설정으로 변경할 수 있습니다. 그러나 일반 MIDI 사양에 따르면 기본 범위는 중앙에서 위 아래로 두 개의 반음이어야합니다. 기본 신디사이저가이 MIDI 메시지를 지원하지 않을 수 있습니다. &lt;code&gt;setPitchBend&lt;/code&gt; 가 성공 했는지 확인 하려면 &lt;code&gt;getPitchBend&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4c4101d3bd5e4e0ccc23d2b59d331c881ddef1d" translate="yes" xml:space="preserve">
          <source>The MIDI standard expresses MIDI data in bytes. However, because Java uses signed bytes, the Java Sound API uses integers instead of bytes when expressing MIDI data. For example, the &lt;a href=&quot;#getStatus()&quot;&gt;&lt;code&gt;getStatus()&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;MidiMessage&lt;/code&gt; returns MIDI status bytes as integers. If you are processing MIDI data that originated outside Java Sound and now is encoded as signed bytes, the bytes can be converted to integers using this conversion:</source>
          <target state="translated">MIDI 표준은 MIDI 데이터를 바이트 단위로 표현합니다. 그러나 Java는 부호있는 바이트를 사용하기 때문에 Java Sound API는 MIDI 데이터를 표현할 때 바이트 대신 정수를 사용합니다. 예를 들어, &lt;code&gt;MidiMessage&lt;/code&gt; 의 &lt;a href=&quot;#getStatus()&quot;&gt; &lt;code&gt;getStatus()&lt;/code&gt; &lt;/a&gt; 메서드 는 MIDI 상태 바이트를 정수로 반환합니다. Java Sound 외부에서 생성 된 MIDI 데이터를 처리 중이고 이제 부호있는 바이트로 인코딩 된 경우 다음 변환을 사용하여 바이트를 정수로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cc37db06eee182d506afa49c0c246f6a9c01a35" translate="yes" xml:space="preserve">
          <source>The MIDI standard expresses MIDI data in bytes. However, because Java&amp;trade; uses signed bytes, the Java Sound API uses integers instead of bytes when expressing MIDI data. For example, the &lt;a href=&quot;#getStatus()&quot;&gt;&lt;code&gt;getStatus()&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;MidiMessage&lt;/code&gt; returns MIDI status bytes as integers. If you are processing MIDI data that originated outside Java Sound and now is encoded as signed bytes, the bytes can be converted to integers using this conversion:</source>
          <target state="translated">MIDI 표준은 MIDI 데이터를 바이트 단위로 표현합니다. 그러나 Java &amp;trade;는 부호있는 바이트를 사용하기 때문에 Java Sound API는 MIDI 데이터를 표현할 때 바이트 대신 정수를 사용합니다. 예를 들어, &lt;code&gt;MidiMessage&lt;/code&gt; 의 &lt;a href=&quot;#getStatus()&quot;&gt; &lt;code&gt;getStatus()&lt;/code&gt; &lt;/a&gt; 메서드 는 MIDI 상태 바이트를 정수로 반환합니다. Java Sound 외부에서 생성 된 MIDI 데이터를 처리 중이고 이제 부호있는 바이트로 인코딩 된 경우 다음 변환을 사용하여 바이트를 정수로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c526e09fb95606778bb5e764a54a0e9f208fc206" translate="yes" xml:space="preserve">
          <source>The MIDI standard expresses MIDI data in bytes. However, because Java&lt;sup id=&quot;integersVsBytes&quot;&gt;TM&lt;/sup&gt; uses signed bytes, the Java Sound API uses integers instead of bytes when expressing MIDI data. For example, the &lt;a href=&quot;midimessage#getStatus--&quot;&gt;&lt;code&gt;getStatus()&lt;/code&gt;&lt;/a&gt; method of &lt;code&gt;MidiMessage&lt;/code&gt; returns MIDI status bytes as integers. If you are processing MIDI data that originated outside Java Sound and now is encoded as signed bytes, the bytes can can be converted to integers using this conversion:</source>
          <target state="translated">MIDI 표준은 MIDI 데이터를 바이트 단위로 표현합니다. 그러나 Java &lt;sup id=&quot;integersVsBytes&quot;&gt;TM&lt;/sup&gt; 는 부호있는 바이트를 사용 하기 때문에 Java Sound API는 MIDI 데이터를 표현할 때 바이트 대신 정수를 사용합니다. 예를 들어 &lt;code&gt;MidiMessage&lt;/code&gt; 의 &lt;a href=&quot;midimessage#getStatus--&quot;&gt; &lt;code&gt;getStatus()&lt;/code&gt; &lt;/a&gt; 메서드 는 MIDI 상태 바이트를 정수로 반환합니다. Java Sound 외부에서 시작하여 부호있는 바이트로 인코딩 된 MIDI 데이터를 처리하는 경우 다음 변환을 사용하여 바이트를 정수로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c8a2781b35fa31817c29abe30b50e8043af665c" translate="yes" xml:space="preserve">
          <source>The MIDI tracks in this sequence.</source>
          <target state="translated">이 순서에서 MIDI 트랙.</target>
        </trans-unit>
        <trans-unit id="23a350af8445001f598c4651a4f45324e9f33c23" translate="yes" xml:space="preserve">
          <source>The MLet text file's base URL.</source>
          <target state="translated">MLet 텍스트 파일의 기본 URL입니다.</target>
        </trans-unit>
        <trans-unit id="db0ce9ae1e5d2f89a8f312663fdfbed2b32ba495" translate="yes" xml:space="preserve">
          <source>The MXBean concept provides a simple way to code an MBean that only references a predefined set of types, the ones defined by &lt;a href=&quot;openmbean/package-summary&quot;&gt;&lt;code&gt;javax.management.openmbean&lt;/code&gt;&lt;/a&gt;. In this way, you can be sure that your MBean will be usable by any client, including remote clients, without any requirement that the client have access to &lt;em&gt;model-specific classes&lt;/em&gt; representing the types of your MBeans.</source>
          <target state="translated">MXBean 개념은 &lt;a href=&quot;openmbean/package-summary&quot;&gt; &lt;code&gt;javax.management.openmbean&lt;/code&gt; 에&lt;/a&gt; 의해 정의 된 사전 정의 된 유형의 세트 만 참조하는 MBean을 코딩하는 간단한 방법을 제공합니다 . 이러한 방식으로, 클라이언트가 MBean 유형을 나타내는 &lt;em&gt;모델 특정 클래스에&lt;/em&gt; 액세스 할 필요없이 원격 클라이언트를 포함한 모든 클라이언트가 MBean을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e33c92fe4338e85410252cbf5f86c27123acc080" translate="yes" xml:space="preserve">
          <source>The Malayalam range with the Malayalam digits.</source>
          <target state="translated">Malayalam 숫자가있는 Malayalam 범위입니다.</target>
        </trans-unit>
        <trans-unit id="d4a3d1afcec2a7b84cb429f3bcbbf430180a0aa8" translate="yes" xml:space="preserve">
          <source>The ManageReferral control's assigned object identifier is 2.16.840.1.113730.3.4.2.</source>
          <target state="translated">ManageReferral 컨트롤의 할당 된 개체 식별자는 2.16.840.1.113730.3.4.2입니다.</target>
        </trans-unit>
        <trans-unit id="f0c9875b8d07e007e2745fc0af6fe732b94df483" translate="yes" xml:space="preserve">
          <source>The Manifest class is used to maintain Manifest entry names and their associated Attributes.</source>
          <target state="translated">매니페스트 클래스는 매니페스트 항목 이름과 관련 속성을 유지하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f91edbc800e6ebe0a97d46777ffeab5dd79019f" translate="yes" xml:space="preserve">
          <source>The Manifest class is used to maintain Manifest entry names and their associated Attributes. There are main Manifest Attributes as well as per-entry Attributes. For information on the Manifest format, please see the  Manifest format specification.</source>
          <target state="translated">매니페스트 클래스는 매니페스트 항목 이름과 관련 속성을 유지하는 데 사용됩니다. 항목 별 속성뿐만 아니라 주요 매니페스트 속성이 있습니다. 매니페스트 형식에 대한 자세한 내용은 매니페스트 형식 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b08c1dceec8f387af3ac7117a090db5f90ca9a8" translate="yes" xml:space="preserve">
          <source>The Manifest class is used to maintain Manifest entry names and their associated Attributes. There are main Manifest Attributes as well as per-entry Attributes. For information on the Manifest format, please see the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jar/jar.html&quot;&gt; Manifest format specification&lt;/a&gt;.</source>
          <target state="translated">Manifest 클래스는 Manifest 항목 이름 및 관련 속성을 유지하는 데 사용됩니다. 주요 매니페스트 속성과 항목 별 속성이 있습니다. 매니페스트 형식에 대한 자세한 내용은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/jar/jar.html&quot;&gt;매니페스트 형식 사양을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="af81b22d465ae1e7d170117e7b040f06e9f7354e" translate="yes" xml:space="preserve">
          <source>The Manifest class is used to maintain Manifest entry names and their associated Attributes. There are main Manifest Attributes as well as per-entry Attributes. For information on the Manifest format, please see the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jar/jar.html&quot;&gt; Manifest format specification&lt;/a&gt;.</source>
          <target state="translated">Manifest 클래스는 Manifest 항목 이름 및 관련 속성을 유지하는 데 사용됩니다. 주요 매니페스트 속성과 항목 별 속성이 있습니다. 매니페스트 형식에 대한 자세한 내용은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jar/jar.html&quot;&gt;매니페스트 형식 사양을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a14dcb9ffe833bd8ff0c3971c624e1ee8fa1ea44" translate="yes" xml:space="preserve">
          <source>The MediaSize is in turn used to locate the MediaSizeName object. This method may return null if the closest matching MediaSize has no corresponding Media instance.</source>
          <target state="translated">MediaSize는 MediaSizeName 개체를 찾는 데 사용됩니다. 가장 일치하는 MediaSize에 해당하는 Media 인스턴스가없는 경우이 메서드는 null을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7f2589c5eb6fefc0630c3f00ed4bcf6743212bf" translate="yes" xml:space="preserve">
          <source>The MediaType instance for 6 3/4 envelope, 3 5/8 x 6 1/2 in.</source>
          <target state="translated">6 3/4 봉투, 3 5/8 x 6 1/2 인치에 대한 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="573f4b6872edf71d06ba58486250a54311c264a2" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Engineering A, 8 1/2 x 11 in.</source>
          <target state="translated">Engineering A의 MediaType 인스턴스, 8 1/2 x 11 인치.</target>
        </trans-unit>
        <trans-unit id="64d3072107241435185f88936c6286ff514d147e" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Engineering B, 11 x 17 in.</source>
          <target state="translated">Engineering B, 11 x 17 인치의 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="c7692968c3215d63e31ac87679acd24d403571f9" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Engineering C, 17 x 22 in.</source>
          <target state="translated">Engineering C의 MediaType 인스턴스, 17 x 22 인치.</target>
        </trans-unit>
        <trans-unit id="9f478c8d9d5bcb2ea8dcf961f52385b3f2895b9b" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Engineering D, 22 x 34 in.</source>
          <target state="translated">Engineering D의 MediaType 인스턴스, 22 x 34 인치.</target>
        </trans-unit>
        <trans-unit id="dbaba1c80bc3cfe1b7c16c807a907a7e87387b83" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Engineering E, 34 x 44 in.</source>
          <target state="translated">Engineering E의 MediaType 인스턴스, 34 x 44 인치</target>
        </trans-unit>
        <trans-unit id="0b90d28550428199920f8f10dbe0d35f58b47e46" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Executive, 7 1/4 x 10 1/2 in.</source>
          <target state="translated">Executive 용 MediaType 인스턴스, 7 1/4 x 10 1/2 인치.</target>
        </trans-unit>
        <trans-unit id="54db702c63c3eba7e3cf9613a7e24e501b5591f5" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Folio, 8 1/2 x 13 in.</source>
          <target state="translated">Folio 용 MediaType 인스턴스, 8 1/2 x 13 인치</target>
        </trans-unit>
        <trans-unit id="ca7bc12d3f763cdf64763c795bba0f7408968808" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO Designated Long, 110 x 220 mm.</source>
          <target state="translated">ISO Designated Long, 110 x 220mm에 대한 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="673633bbfb4eae0e9618c4e988561b66316b66a0" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN B0, 1000 x 1414 mm.</source>
          <target state="translated">ISO / DIN B0, 1000 x 1414mm의 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="633a4f5076112dbd2c6bb5d62adea677c380d4c2" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN B1, 707 x 1000 mm.</source>
          <target state="translated">ISO / DIN B1 용 MediaType 인스턴스, 707 x 1000mm.</target>
        </trans-unit>
        <trans-unit id="bf0b29aa253400f76f92bbb770579b1dcd7bd212" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN B10, 31 x 44 mm.</source>
          <target state="translated">ISO / DIN B10, 31 x 44mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="408b81ca2d63672d842cbe95759d93c0ce23fda0" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN B2, 500 x 707 mm.</source>
          <target state="translated">ISO / DIN B2 용 MediaType 인스턴스, 500 x 707mm.</target>
        </trans-unit>
        <trans-unit id="d35e4f9c90e881101d512c07c9ef78a1b2c0a590" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN B3, 353 x 500 mm.</source>
          <target state="translated">ISO / DIN B3, 353 x 500mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="e85b6c3c90193600f59176d247f27a7869e5f80b" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN B4, 250 x 353 mm.</source>
          <target state="translated">ISO / DIN B4, 250 x 353mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="9466895dc6ed7b01f8a05d2480595fe918fe866f" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN B5, 176 x 250 mm.</source>
          <target state="translated">ISO / DIN B5 용 MediaType 인스턴스, 176 x 250mm.</target>
        </trans-unit>
        <trans-unit id="f5f57afdb5af642624b9ff15644c03935fea3c26" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN B6, 125 x 176 mm.</source>
          <target state="translated">ISO / DIN B6, 125 x 176 mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="bbc65a80b94626d534fba496c26601f37eb9cc7e" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN B7, 88 x 125 mm.</source>
          <target state="translated">ISO / DIN B7, 88 x 125mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="5370845fbcc7ff27e93c3f3b2c5afa54c06aba5d" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN B8, 62 x 88 mm.</source>
          <target state="translated">ISO / DIN B8 용 MediaType 인스턴스, 62 x 88mm.</target>
        </trans-unit>
        <trans-unit id="c7376e552997d46d8fb4da906538a74a1187916b" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN B9, 44 x 62 mm.</source>
          <target state="translated">ISO / DIN B9, 44 x 62mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="b605875476890cef42c14810fd8b9dd8f581a802" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN C0, 917 x 1297 mm.</source>
          <target state="translated">ISO / DIN C0, 917 x 1297mm의 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="138165f085ea155edd49258fe3b30b06ae636a75" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN C1, 648 x 917 mm.</source>
          <target state="translated">ISO / DIN C1 용 MediaType 인스턴스, 648 x 917mm.</target>
        </trans-unit>
        <trans-unit id="be46d31b238340f94c16e8449c4cc1ba35914fba" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN C10, 28 x 40 mm.</source>
          <target state="translated">ISO / DIN C10 용 MediaType 인스턴스, 28 x 40mm.</target>
        </trans-unit>
        <trans-unit id="4b4e963d6d8911274eec2d4e53cbadd5d162003e" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN C2, 458 x 648 mm.</source>
          <target state="translated">ISO / DIN C2 용 MediaType 인스턴스, 458 x 648mm.</target>
        </trans-unit>
        <trans-unit id="2968745b19f968d7dfda3dd7e5b36fc63c8c63f9" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN C3, 324 x 458 mm.</source>
          <target state="translated">ISO / DIN C3 용 MediaType 인스턴스, 324 x 458mm.</target>
        </trans-unit>
        <trans-unit id="2fd2805e5fa3604a42759df5243a86b5bdc6840a" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN C4, 229 x 324 mm.</source>
          <target state="translated">ISO / DIN C4 용 MediaType 인스턴스, 229 x 324mm.</target>
        </trans-unit>
        <trans-unit id="7c6e34d5a1e6aac5f93ac6c39efb2cefc933c905" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN C5, 162 x 229 mm.</source>
          <target state="translated">ISO / DIN C5 용 MediaType 인스턴스, 162 x 229mm.</target>
        </trans-unit>
        <trans-unit id="e88dde0a1f5037536d3ca8917b55e40b8bff2eca" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN C6, 114 x 162 mm.</source>
          <target state="translated">ISO / DIN C6 용 MediaType 인스턴스, 114 x 162mm.</target>
        </trans-unit>
        <trans-unit id="728de0db508ce4ed22627bdf4dff61dcb6ec0b00" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN C7, 81 x 114 mm.</source>
          <target state="translated">ISO / DIN C7, 81 x 114mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="b67749263b75857473962b93d2efb5003c81647c" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN C8, 57 x 81 mm.</source>
          <target state="translated">ISO / DIN C8 용 MediaType 인스턴스, 57 x 81mm.</target>
        </trans-unit>
        <trans-unit id="cc097e0463fec0dad72b2003cd307d811124eca5" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN C9, 40 x 57 mm.</source>
          <target state="translated">ISO / DIN C9, 40 x 57mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="e8fafbff47ed712ab286e6dc1fa034d9363ce45c" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN and JIS 2A0, 1189 x 1682 mm.</source>
          <target state="translated">ISO / DIN 및 JIS 2A0, 1189 x 1682mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="edcb8ad8ea42994b67f5c173c3561cb16040e0aa" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN and JIS 4A0, 1682 x 2378 mm.</source>
          <target state="translated">ISO / DIN 및 JIS 4A0, 1682 x 2378mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="a48de2f0a2ffeecfbbe66c09c3607f92aaa24545" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN and JIS A0, 841 x 1189 mm.</source>
          <target state="translated">ISO / DIN 및 JIS A0, 841 x 1189mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="5152c1950aee7fa8cea203995f6c2ba0e1137c65" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN and JIS A1, 594 x 841 mm.</source>
          <target state="translated">ISO / DIN 및 JIS A1 용 MediaType 인스턴스, 594 x 841mm.</target>
        </trans-unit>
        <trans-unit id="d9b5f248232afa5f459ffca326f0e43135da8cce" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN and JIS A10, 26 x 37 mm.</source>
          <target state="translated">ISO / DIN 및 JIS A10 용 MediaType 인스턴스, 26 x 37mm.</target>
        </trans-unit>
        <trans-unit id="07417af7ef502ffcf2b82a7c0bb15b59d75da8ca" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN and JIS A2, 420 x 594 mm.</source>
          <target state="translated">ISO / DIN 및 JIS A2 용 MediaType 인스턴스, 420 x 594mm.</target>
        </trans-unit>
        <trans-unit id="c18ab19c5b73307d4ae2d012a6c63e869ea1be79" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN and JIS A3, 297 x 420 mm.</source>
          <target state="translated">ISO / DIN 및 JIS A3 용 MediaType 인스턴스, 297 x 420mm.</target>
        </trans-unit>
        <trans-unit id="3e57797753cccdaa5bba861bfecab4b85c3078df" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN and JIS A4, 210 x 297 mm.</source>
          <target state="translated">ISO / DIN 및 JIS A4 용 MediaType 인스턴스, 210 x 297mm.</target>
        </trans-unit>
        <trans-unit id="58e7d9a8b01a945f936e646cc8cac08b4951be27" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN and JIS A5, 148 x 210 mm.</source>
          <target state="translated">ISO / DIN 및 JIS A5 용 MediaType 인스턴스, 148 x 210mm.</target>
        </trans-unit>
        <trans-unit id="29fb2ce4c6f868125b147a456624ea74c38273ea" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN and JIS A6, 105 x 148 mm.</source>
          <target state="translated">ISO / DIN 및 JIS A6 용 MediaType 인스턴스, 105 x 148mm.</target>
        </trans-unit>
        <trans-unit id="d3588072c88be42806e1f398f2dc865322bbd86f" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN and JIS A7, 74 x 105 mm.</source>
          <target state="translated">ISO / DIN 및 JIS A7, 74 x 105mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="1319cf82239614d64b53239bd9ea6fd2c7c9ae03" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN and JIS A8, 52 x 74 mm.</source>
          <target state="translated">ISO / DIN 및 JIS A8 용 MediaType 인스턴스, 52 x 74mm.</target>
        </trans-unit>
        <trans-unit id="8a8577a2d01de8ea714249530b84b9319027e6ef" translate="yes" xml:space="preserve">
          <source>The MediaType instance for ISO/DIN and JIS A9, 37 x 52 mm.</source>
          <target state="translated">ISO / DIN 및 JIS A9 용 MediaType 인스턴스, 37 x 52mm.</target>
        </trans-unit>
        <trans-unit id="6ebdb0af9b5bd1dbcd81aae7f76b05eb82e9f251" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Invitation Envelope, 220 x 220 mm.</source>
          <target state="translated">Invitation Envelope, 220 x 220mm의 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="284a9938133c0bc7737e5a5628d9964a4a455ec9" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Invoice, 5 1/2 x 8 1/2 in.</source>
          <target state="translated">Invoice 용 MediaType 인스턴스, 5 1/2 x 8 1/2 인치.</target>
        </trans-unit>
        <trans-unit id="9df3876557a49a66925ac34f30679b8b271b0ffd" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Italy Envelope, 110 x 230 mm.</source>
          <target state="translated">Italy Envelope 용 MediaType 인스턴스, 110 x 230mm.</target>
        </trans-unit>
        <trans-unit id="d1f205f909b279d4b54614f525425281ab998a62" translate="yes" xml:space="preserve">
          <source>The MediaType instance for JIS B0, 1030 x 1456 mm.</source>
          <target state="translated">JIS B0, 1030 x 1456mm의 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="7a3507131ac0a58b25713da630370ac083d42bad" translate="yes" xml:space="preserve">
          <source>The MediaType instance for JIS B1, 728 x 1030 mm.</source>
          <target state="translated">JIS B1 용 MediaType 인스턴스, 728 x 1030mm.</target>
        </trans-unit>
        <trans-unit id="b6fb0e7883f5067ab230e26f1b7333611f313dac" translate="yes" xml:space="preserve">
          <source>The MediaType instance for JIS B10, 32 x 45 mm.</source>
          <target state="translated">JIS B10, 32 x 45mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="28ca85b7db426b9609f7e87f5b658d49d4b8458c" translate="yes" xml:space="preserve">
          <source>The MediaType instance for JIS B2, 515 x 728 mm.</source>
          <target state="translated">JIS B2 용 MediaType 인스턴스, 515 x 728mm.</target>
        </trans-unit>
        <trans-unit id="559f9edb2d44e6af611dda54ecb423c3659926f1" translate="yes" xml:space="preserve">
          <source>The MediaType instance for JIS B3, 364 x 515 mm.</source>
          <target state="translated">JIS B3, 364 x 515mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="9683c97a0ab0d280070a8d40bbc88bb83ddbc7fc" translate="yes" xml:space="preserve">
          <source>The MediaType instance for JIS B4, 257 x 364 mm.</source>
          <target state="translated">JIS B4 용 MediaType 인스턴스, 257 x 364 mm.</target>
        </trans-unit>
        <trans-unit id="c748db60b813ead222252bc7ed474c22dc101620" translate="yes" xml:space="preserve">
          <source>The MediaType instance for JIS B5, 182 x 257 mm.</source>
          <target state="translated">JIS B5 용 MediaType 인스턴스, 182 x 257mm.</target>
        </trans-unit>
        <trans-unit id="3f710af7e6fad592cae964d3b21f236da76cbd78" translate="yes" xml:space="preserve">
          <source>The MediaType instance for JIS B6, 128 x 182 mm.</source>
          <target state="translated">JIS B6 용 MediaType 인스턴스, 128 x 182 mm.</target>
        </trans-unit>
        <trans-unit id="118ac4356b9094747ba3b05a39dbc303db47f99b" translate="yes" xml:space="preserve">
          <source>The MediaType instance for JIS B7, 91 x 128 mm.</source>
          <target state="translated">JIS B7 용 MediaType 인스턴스, 91 x 128mm.</target>
        </trans-unit>
        <trans-unit id="d2f3ccf956d631e9cb14695a4712862293384cd7" translate="yes" xml:space="preserve">
          <source>The MediaType instance for JIS B8, 64 x 91 mm.</source>
          <target state="translated">JIS B8, 64 x 91mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="965b48c83b9684550d85818602c850891b0bfbac" translate="yes" xml:space="preserve">
          <source>The MediaType instance for JIS B9, 45 x 64 mm.</source>
          <target state="translated">JIS B9, 45 x 64mm 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="08e8d5ad8aedd8df9a2705ecd63e13040f593461" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Ledger, 11 x 17 in.</source>
          <target state="translated">Ledger 용 MediaType 인스턴스, 11 x 17 인치</target>
        </trans-unit>
        <trans-unit id="cbffd20c909d16fb73a0618879035890db592698" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Monarch Envelope, 3 7/8 x 7 1/2 in.</source>
          <target state="translated">Monarch Envelope, 3 7/8 x 7 1/2 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="2809eb9e95cca61581af46e1c5d4b071b752e6e2" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American #10 Business Envelope, 4 1/8 x 9 1/2 in.</source>
          <target state="translated">북미 # 10 Business Envelope, 4 1/8 x 9 1/2 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="6a00b206e640e9009fd313fb09be1fb2b3071af2" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American #11 Business Envelope, 4 1/2 x 10 3/8 in.</source>
          <target state="translated">북미 # 11 Business Envelope, 4 1/2 x 10 3/8 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="58adf13bb88ed68eb98e06f030474a6c380617af" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American #12 Business Envelope, 4 3/4 x 11 in.</source>
          <target state="translated">북미 # 12 Business Envelope, 4 3/4 x 11 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="7e0986a1bed3d7a471357fa11804986a159c01db" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American #14 Business Envelope, 5 x 11 1/2 in.</source>
          <target state="translated">북미 # 14 Business Envelope, 5 x 11 1/2 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="93008a331376be010dd94f80b34dfb88f45f138e" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American #9 Business Envelope, 3 7/8 x 8 7/8 in.</source>
          <target state="translated">북미 # 9 Business Envelope, 3 7/8 x 8 7/8 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="54bd22dfffb84fe412c08cb7e97e0713b39de2c1" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American 10 x 13 in.</source>
          <target state="translated">북미 10 x 13 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="b3e00aa7daada662140fb382c24f0834b8fb0aaa" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American 10 x 14 in.</source>
          <target state="translated">북미 10 x 14 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="437bb5aff9176e384a9a374f460e9b82e4e77e33" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American 10 x 15 in.</source>
          <target state="translated">북미 10 x 15 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="746fa05a28ed0de64b6070da461617a50ce099a9" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American 6 x 9 in.</source>
          <target state="translated">북미 6 x 9 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="3dd618276eaf23db123f5ac0dba2a04b8090db50" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American 7 x 9 in.</source>
          <target state="translated">북미 7 x 9 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="0ad3eb69fcd194e7aefbe10391d439acb76f4834" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American 9 x 11 in.</source>
          <target state="translated">북미 9 x 11 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="d38c08e580f4d74f2d8590c57c9bcd7fc9202c26" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American 9 x 12 in.</source>
          <target state="translated">북미 9 x 12 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="77561bd1ac7d493abd82509f5322a0d89ce61c27" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American Legal, 8 1/2 x 14 in.</source>
          <target state="translated">North American Legal, 8 1/2 x 14 인치 용 MediaType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="b6301557a78b184376740b0bf884635471dd48da" translate="yes" xml:space="preserve">
          <source>The MediaType instance for North American Letter, 8 1/2 x 11 in.</source>
          <target state="translated">North American Letter의 MediaType 인스턴스, 8 1/2 x 11 인치.</target>
        </trans-unit>
        <trans-unit id="f786c8f1c63c1c613edc22c586577870a4531932" translate="yes" xml:space="preserve">
          <source>The MediaType instance for Quarto, 215 x 275 mm.</source>
          <target state="translated">Quarto 용 MediaType 인스턴스, 215 x 275mm.</target>
        </trans-unit>
        <trans-unit id="998f2712a3a90e84218b3e0b194373c93820adc3" translate="yes" xml:space="preserve">
          <source>The Meetei Mayek range with the Meetei Mayek digits.</source>
          <target state="translated">Meetei Mayek 숫자가있는 Meetei Mayek 범위.</target>
        </trans-unit>
        <trans-unit id="7a16633fa40606c8afd41af115a269d2362fbb6e" translate="yes" xml:space="preserve">
          <source>The MemoryImageSource is also capable of managing a memory image which varies over time to allow animation or custom rendering. Here is an example showing how to set up the animation source and signal changes in the data (adapted from the MemoryAnimationSourceDemo by Garth Dickie):</source>
          <target state="translated">MemoryImageSource는 또한 애니메이션 또는 사용자 지정 렌더링을 허용하기 위해 시간에 따라 변하는 메모리 이미지를 관리 할 수 ​​있습니다. 다음은 데이터의 애니메이션 소스 및 신호 변경을 설정하는 방법을 보여주는 예입니다 (Garth Dickie의 MemoryAnimationSourceDemo에서 수정 됨).</target>
        </trans-unit>
        <trans-unit id="2ba25dec67967ea91f752676ffd7c09867b52b7f" translate="yes" xml:space="preserve">
          <source>The MessageProp object is instantiated by the application and is used by the underlying mechanism to return information to the caller such as the QOP indicating the strength of protection that was applied to the message and other supplementary message state information.</source>
          <target state="translated">MessageProp 개체는 응용 프로그램에 의해 인스턴스화되고 기본 메커니즘에서 메시지 및 기타 추가 메시지 상태 정보에 적용된 보호 강도를 나타내는 QOP와 같은 정보를 호출자에게 반환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="237b7bd0839d25260d44d915861351b309bae340" translate="yes" xml:space="preserve">
          <source>The MessageProp object is instantiated by the application and is used by the underlying mechanism to return information to the caller such as the QOP, whether confidentiality was applied to the message, and other supplementary message state information.</source>
          <target state="translated">MessageProp 개체는 응용 프로그램에 의해 인스턴스화되고 기본 메커니즘에서 QOP, 메시지에 기밀성이 적용되었는지 여부 및 기타 추가 메시지 상태 정보와 같은 정보를 호출자에게 반환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f94aa6f7289a229745c48f83698c13d487ddaab9" translate="yes" xml:space="preserve">
          <source>The MessageProp object is instantiated by the application and used to specify a QOP value which selects cryptographic algorithms, and a privacy service to optionally encrypt the message. The underlying mechanism that is used in the call may not be able to provide the privacy service. It sets the actual privacy service that it does provide in this MessageProp object which the caller should then query upon return. If the mechanism is not able to provide the requested QOP, it throws a GSSException with the BAD_QOP code.</source>
          <target state="translated">MessageProp 개체는 응용 프로그램에 의해 인스턴스화되고 암호화 알고리즘을 선택하는 QOP 값과 메시지를 선택적으로 암호화하는 개인 정보 보호 서비스를 지정하는 데 사용됩니다. 호출에 사용되는 기본 메커니즘은 개인 정보 보호 서비스를 제공하지 못할 수 있습니다. 호출자가 반환시 쿼리해야하는이 MessageProp 개체에서 제공하는 실제 개인 정보 보호 서비스를 설정합니다. 메커니즘이 요청 된 QOP를 제공 할 수없는 경우 BAD_QOP 코드와 함께 GSSException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="61516ce935dd7b488fdbc612f5b14f5e3dcf1ad2" translate="yes" xml:space="preserve">
          <source>The Meta key extended modifier constant.</source>
          <target state="translated">Meta 키 확장 수정 자 상수입니다.</target>
        </trans-unit>
        <trans-unit id="507d8e20b6162f00db7d5c2171a5204a0d6e3976" translate="yes" xml:space="preserve">
          <source>The Meta key modifier constant.</source>
          <target state="translated">메타 키 수정 자 상수입니다.</target>
        </trans-unit>
        <trans-unit id="b5d82a163a9f53ffdc5df9d6562d4ccaf06fdd68" translate="yes" xml:space="preserve">
          <source>The Metal implementation of ProgressBarUI.</source>
          <target state="translated">ProgressBarUI의 Metal 구현입니다.</target>
        </trans-unit>
        <trans-unit id="ff60eb164b3eb146d9fb4d86b4417a36702eeb86" translate="yes" xml:space="preserve">
          <source>The Metal subclass of BasicTabbedPaneUI.</source>
          <target state="translated">BasicTabbedPaneUI의 Metal 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="875260bee7cb4b86188f6d5c14bdd4b99434b19c" translate="yes" xml:space="preserve">
          <source>The Minguo calendar system has two eras, 'ROC' and 'BEFORE_ROC', defined by &lt;a href=&quot;minguoera&quot;&gt;&lt;code&gt;MinguoEra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Minguo 캘린더 시스템에는 MinguoEra에 의해 정의 된 'ROC'및 'BEFORE_ROC'의 두 가지 &lt;a href=&quot;minguoera&quot;&gt; &lt;code&gt;MinguoEra&lt;/code&gt; &lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="8488e49133ae34f00360eaccd8da765934bd62e6" translate="yes" xml:space="preserve">
          <source>The Minguo calendar system has two eras. The current era, for years from 1 onwards, is known as the 'Republic of China' era. All previous years, zero or earlier in the proleptic count or one and greater in the year-of-era count, are part of the 'Before Republic of China' era.</source>
          <target state="translated">Minguo 캘린더 시스템에는 두 가지 시대가 있습니다. 1 년부터 수년간의 현재 시대는 '중국 공화국'시대로 알려져 있습니다. 다발성 수치가 0보다 빠르거나 1 년 이상이었던 이전의 모든 해는 '중국 이전'시대의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="82fefb5d3040f57efd3b63bb98ca09fc3ccfc0a0" translate="yes" xml:space="preserve">
          <source>The Minguo calendar system.</source>
          <target state="translated">Minguo 캘린더 시스템.</target>
        </trans-unit>
        <trans-unit id="53001a7acd9647bac32dcf33bf0c1c4be2ae82ab" translate="yes" xml:space="preserve">
          <source>The Minimum size for this component is 10.</source>
          <target state="translated">이 구성 요소의 최소 크기는 10입니다.</target>
        </trans-unit>
        <trans-unit id="893ac55162eba5c07c0982b5961ca183969c45a8" translate="yes" xml:space="preserve">
          <source>The Minimum size for this component is 10. The rationale here is that there should be at least one pixel per 10 percent.</source>
          <target state="translated">이 구성 요소의 최소 크기는 10입니다. 여기서 이론적 근거는 10 % 당 최소 1 개의 픽셀이 있어야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a545218db7a03aed04c1ac511afdb4cfed76973c" translate="yes" xml:space="preserve">
          <source>The ModelMBeanAttributeInfo isReadable method returns 'false'.</source>
          <target state="translated">ModelMBeanAttributeInfo isReadable 메소드는 'false'를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="622c5c9f064611bbc382eb21caab00da9baf69e6" translate="yes" xml:space="preserve">
          <source>The ModelMBeanAttributeInfo object describes an attribute of the ModelMBean.</source>
          <target state="translated">ModelMBeanAttributeInfo 객체는 ModelMBean의 속성을 기술합니다.</target>
        </trans-unit>
        <trans-unit id="7515b956ff4baf3913874b737697b14e24efd566" translate="yes" xml:space="preserve">
          <source>The ModelMBeanAttributeInfo object describes an attribute of the ModelMBean. It is a subclass of MBeanAttributeInfo with the addition of an associated Descriptor and an implementation of the DescriptorAccess interface.</source>
          <target state="translated">ModelMBeanAttributeInfo 객체는 ModelMBean의 속성을 기술합니다. 연관된 Descriptor가 추가되고 DescriptorAccess 인터페이스가 구현 된 MBeanAttributeInfo의 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="0c7970e27c195e599aad6a1440a8c2fd34d10c3b" translate="yes" xml:space="preserve">
          <source>The ModelMBeanAttributeInfo's isWritable method returns 'false'.</source>
          <target state="translated">ModelMBeanAttributeInfo의 isWritable 메소드는 'false'를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ee6068579dec79a74358815593f8fb0ae992ddc8" translate="yes" xml:space="preserve">
          <source>The ModelMBeanConstructorInfo object describes a constructor of the ModelMBean.</source>
          <target state="translated">ModelMBeanConstructorInfo 오브젝트는 ModelMBean의 생성자를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d6d0e1ffbdbc4b382742186b6969198f0e473566" translate="yes" xml:space="preserve">
          <source>The ModelMBeanConstructorInfo object describes a constructor of the ModelMBean. It is a subclass of MBeanConstructorInfo with the addition of an associated Descriptor and an implementation of the DescriptorAccess interface.</source>
          <target state="translated">ModelMBeanConstructorInfo 오브젝트는 ModelMBean의 생성자를 설명합니다. 연관된 Descriptor가 추가되고 DescriptorAccess 인터페이스가 구현 된 MBeanConstructorInfo의 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="9ea1fe7432118222c8edb7be56bce005b9d32202" translate="yes" xml:space="preserve">
          <source>The ModelMBeanInfo of the Model MBean is stored in a file.</source>
          <target state="translated">모델 MBean의 ModelMBeanInfo는 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="be717043f5a4f39bd2bd5c39bd928fa423eadd62" translate="yes" xml:space="preserve">
          <source>The ModelMBeanNotificationInfo object describes a notification emitted by a ModelMBean.</source>
          <target state="translated">ModelMBeanNotificationInfo 객체는 ModelMBean에 의해 발행 된 통지를 기술합니다.</target>
        </trans-unit>
        <trans-unit id="0e87a04c7fd637b21db2de3d9c9f1aa8fb0a7e77" translate="yes" xml:space="preserve">
          <source>The ModelMBeanNotificationInfo object describes a notification emitted by a ModelMBean. It is a subclass of MBeanNotificationInfo with the addition of an associated Descriptor and an implementation of the Descriptor interface.</source>
          <target state="translated">ModelMBeanNotificationInfo 객체는 ModelMBean에 의해 발행 된 통지를 기술합니다. 연관된 Descriptor가 추가되고 Descriptor 인터페이스가 구현 된 MBeanNotificationInfo의 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="fe7d736d21ad24599ca368ba9eda956e4fa29c39" translate="yes" xml:space="preserve">
          <source>The ModelMBeanOperationInfo object describes a management operation of the ModelMBean.</source>
          <target state="translated">ModelMBeanOperationInfo 오브젝트는 ModelMBean의 관리 조작을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f0a2617a3fc98a6c5d488b0a6049a4f3b639a203" translate="yes" xml:space="preserve">
          <source>The ModelMBeanOperationInfo object describes a management operation of the ModelMBean. It is a subclass of MBeanOperationInfo with the addition of an associated Descriptor and an implementation of the DescriptorAccess interface.</source>
          <target state="translated">ModelMBeanOperationInfo 오브젝트는 ModelMBean의 관리 조작을 설명합니다. 연관된 Descriptor가 추가되고 DescriptorAccess 인터페이스가 구현 된 MBeanOperationInfo의 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="513ceb059a7b6fcddfe05011f87eba04b0d4e534" translate="yes" xml:space="preserve">
          <source>The Modifier class provides &lt;code&gt;static&lt;/code&gt; methods and constants to decode class and member access modifiers.</source>
          <target state="translated">Modifier 클래스는 클래스 및 멤버 액세스 수정자를 디코딩하기 위한 &lt;code&gt;static&lt;/code&gt; 메서드 및 상수를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="01b236d448fafe1eecbecf699e0dbd1752899ea4" translate="yes" xml:space="preserve">
          <source>The Modifier class provides &lt;code&gt;static&lt;/code&gt; methods and constants to decode class and member access modifiers. The sets of modifiers are represented as integers with distinct bit positions representing different modifiers. The values for the constants representing the modifiers are taken from the tables in sections 4.1, 4.4, 4.5, and 4.7 of</source>
          <target state="translated">Modifier 클래스는 클래스 및 멤버 액세스 수정자를 디코딩하기 위한 &lt;code&gt;static&lt;/code&gt; 메서드 및 상수를 제공합니다 . 수정 자 세트는 다른 수정자를 나타내는 고유 한 비트 위치를 갖는 정수로 표시됩니다. 수정자를 나타내는 상수 값은 4.1, 4.4, 4.5 및 4.7 섹션의 표에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="147218b3793553c6b152bc61f1b6863a14d4552d" translate="yes" xml:space="preserve">
          <source>The Mongolian range with the Mongolian digits.</source>
          <target state="translated">몽골 숫자가 포함 된 몽골어 범위입니다.</target>
        </trans-unit>
        <trans-unit id="d4ae824181721cb564241d8f0b6762682d46721e" translate="yes" xml:space="preserve">
          <source>The Mouse Button1 extended modifier constant.</source>
          <target state="translated">Mouse Button1 확장 수정 자 상수입니다.</target>
        </trans-unit>
        <trans-unit id="36f1dd4b84698f2f168f968f1caef9d5816c2cad" translate="yes" xml:space="preserve">
          <source>The Mouse Button1 modifier constant.</source>
          <target state="translated">Mouse Button1 수정 자 상수입니다.</target>
        </trans-unit>
        <trans-unit id="7479352e34f2d634b6076357847f56a729ff8cbc" translate="yes" xml:space="preserve">
          <source>The Mouse Button2 extended modifier constant.</source>
          <target state="translated">Mouse Button2 확장 수정 자 상수입니다.</target>
        </trans-unit>
        <trans-unit id="cd5f53c16d765610f8cd6bfeea0f5863ac7f2aa9" translate="yes" xml:space="preserve">
          <source>The Mouse Button2 modifier constant.</source>
          <target state="translated">Mouse Button2 수정 자 상수입니다.</target>
        </trans-unit>
        <trans-unit id="83642f43ba8fddd538948fe313e6eeaae2573de8" translate="yes" xml:space="preserve">
          <source>The Mouse Button3 extended modifier constant.</source>
          <target state="translated">Mouse Button3 확장 수정 자 상수입니다.</target>
        </trans-unit>
        <trans-unit id="a20281ec405691a7568eeb99c14a936676c4035e" translate="yes" xml:space="preserve">
          <source>The Mouse Button3 modifier constant.</source>
          <target state="translated">Mouse Button3 수정 자 상수입니다.</target>
        </trans-unit>
        <trans-unit id="05f5a5006691f90b4276e21b323e87245864d43a" translate="yes" xml:space="preserve">
          <source>The Myanmar Extended-B range with the Myanmar Tai Laing digits.</source>
          <target state="translated">미얀마 Tai Laing 숫자가있는 Myanmar Extended-B 범위입니다.</target>
        </trans-unit>
        <trans-unit id="5d426691e21fd73966b8897676ebfc3571346951" translate="yes" xml:space="preserve">
          <source>The Myanmar range with the Myanmar Shan digits.</source>
          <target state="translated">미얀마 범위는 Myanmar Shan 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="ec1b0128ec2d3f55537b22b5fc6f1544811b51e3" translate="yes" xml:space="preserve">
          <source>The Myanmar range with the Myanmar digits.</source>
          <target state="translated">미얀마 숫자는 미얀마 범위입니다.</target>
        </trans-unit>
        <trans-unit id="38fb7495dfe24e23d739f8db0ae47f092cec8470" translate="yes" xml:space="preserve">
          <source>The N'Ko range with the N'Ko digits.</source>
          <target state="translated">N'Ko 숫자가있는 N'Ko 범위.</target>
        </trans-unit>
        <trans-unit id="2333e86e53a0d2dc1db2ea3db8dcf5c9ff0df51f" translate="yes" xml:space="preserve">
          <source>The NUMERIC_SHAPING attribute in the text, if present, converts European digits to other decimal digits before running the bidi algorithm. This attribute, if present, must be applied to all the text in the paragraph.</source>
          <target state="translated">텍스트의 NUMERIC_SHAPING 속성 (있는 경우)은 bidi 알고리즘을 실행하기 전에 유럽 숫자를 다른 10 진수로 변환합니다. 이 속성이 있으면 단락의 모든 텍스트에 적용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1b0c4095bf6e6786886376a2ab5cf659ab61071c" translate="yes" xml:space="preserve">
          <source>The Namespace URI is not validated as a &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;URI reference&lt;/a&gt;. The local part and prefix are not validated as a &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/#NT-NCName&quot;&gt;NCName&lt;/a&gt; as specified in &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/&quot;&gt;Namespaces in XML&lt;/a&gt;.</source>
          <target state="translated">네임 스페이스 URI는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;URI 참조&lt;/a&gt; 로 확인되지 않습니다 . 로컬 부분과 접두사는 &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/&quot;&gt;XML의 네임 스페이스에&lt;/a&gt; 지정된대로 &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/#NT-NCName&quot;&gt;NCName&lt;/a&gt; 으로 확인되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9860fd3cf2e82656195040828fb908cd32572177" translate="yes" xml:space="preserve">
          <source>The Namespace URI is not validated as a &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;URI reference&lt;/a&gt;. The local part is not validated as a &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/#NT-NCName&quot;&gt;NCName&lt;/a&gt; as specified in &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/&quot;&gt;Namespaces in XML&lt;/a&gt;.</source>
          <target state="translated">네임 스페이스 URI는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;URI 참조&lt;/a&gt; 로 확인되지 않습니다 . 로컬 부분은 &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/&quot;&gt;XML의 네임 스페이스에&lt;/a&gt; 지정된 &lt;a href=&quot;http://www.w3.org/TR/REC-xml-names/#NT-NCName&quot;&gt;NCName&lt;/a&gt; 으로 유효성이 검사되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e9851aa4437262220bf8dbd048bf6ed520942805" translate="yes" xml:space="preserve">
          <source>The Namespace URI is not validated as a &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;URI reference&lt;/a&gt;. The local part and prefix are not validated as a &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/#NT-NCName&quot;&gt;NCName&lt;/a&gt; as specified in &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;Namespaces in XML&lt;/a&gt;.</source>
          <target state="translated">네임 스페이스 URI는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;URI 참조&lt;/a&gt; 로 확인되지 않습니다 . 로컬 부분과 접두사는 &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;XML의 네임 스페이스에&lt;/a&gt; 지정된대로 &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/#NT-NCName&quot;&gt;NCName&lt;/a&gt; 으로 확인되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2ea1b910195c3b31f032d85ab5bd0d269e37b618" translate="yes" xml:space="preserve">
          <source>The Namespace URI is not validated as a &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;URI reference&lt;/a&gt;. The local part is not validated as a &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/#NT-NCName&quot;&gt;NCName&lt;/a&gt; as specified in &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;Namespaces in XML&lt;/a&gt;.</source>
          <target state="translated">네임 스페이스 URI는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;URI 참조&lt;/a&gt; 로 확인되지 않습니다 . 로컬 부분은 &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;XML의 네임 스페이스에&lt;/a&gt; 지정된 &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/#NT-NCName&quot;&gt;NCName&lt;/a&gt; 으로 유효성이 검사되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e0fc16e86f02bd75076a767ae77a361cf9c75705" translate="yes" xml:space="preserve">
          <source>The Namespace URI, or an empty string if none is in use.</source>
          <target state="translated">네임 스페이스 URI 또는 ​​사용중인 것이없는 경우 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8b5974aa1b16d92497e0200180a3ad8896e31774" translate="yes" xml:space="preserve">
          <source>The Namespace URI, or the empty string if none is available, or null if the index is out of range.</source>
          <target state="translated">네임 스페이스 URI 또는 ​​사용할 수없는 경우 빈 문자열, 인덱스가 범위를 벗어난 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="cf7642f87956e8bd9a081d6f1bbf36661694d8ce" translate="yes" xml:space="preserve">
          <source>The Namespace URI, the empty string if none is available, or null if the index is out of range.</source>
          <target state="translated">네임 스페이스 URI, 사용할 수없는 경우 빈 문자열, 인덱스가 범위를 벗어난 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="349839596e03d0ac0126c309092e36e03e011173" translate="yes" xml:space="preserve">
          <source>The Namespace support object always starts with a base context already in force: in this context, only the &quot;xml&quot; prefix is declared.</source>
          <target state="translated">네임 스페이스 지원 개체는 항상 이미 적용된 기본 컨텍스트로 시작합니다.이 컨텍스트에서는 &quot;xml&quot;접두사 만 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="463ad161e211102811e3b4f729e92c59017920f0" translate="yes" xml:space="preserve">
          <source>The NamingEnumeration that results from search() using OBJECT_SCOPE will contain one or zero element. The enumeration contains one element if the named object satisfies the search filter specified in search(). The element will have as its name the empty string because the names of elements in the NamingEnumeration are relative to the target context--in this case, the target context is the named object. It contains zero element if the named object does not satisfy the search filter specified in search().</source>
          <target state="translated">OBJECT_SCOPE를 사용하여 search ()의 결과 인 NamingEnumeration에는 하나 또는 0 개의 요소가 포함됩니다. 명명 된 객체가 search ()에 지정된 검색 필터를 만족하는 경우 열거에는 하나의 요소가 포함됩니다. NamingEnumeration의 요소 이름은 대상 컨텍스트와 관련이 있으므로이 요소의 이름은 빈 문자열입니다.이 경우 대상 컨텍스트는 명명 된 개체입니다. 명명 된 객체가 search ()에 지정된 검색 필터를 만족하지 않으면 0 요소를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f597fd36413579878114afaa6d6023419e477bcb" translate="yes" xml:space="preserve">
          <source>The NamingEnumeration that results from search() using ONELEVEL_SCOPE contains elements with objects in the named context that satisfy the search filter specified in search(). The names of elements in the NamingEnumeration are atomic names relative to the named context.</source>
          <target state="translated">ONELEVEL_SCOPE를 사용하여 search ()에서 발생하는 NamingEnumeration에는 search ()에 지정된 검색 필터를 만족하는 명명 된 컨텍스트의 오브젝트가있는 요소가 포함됩니다. NamingEnumeration의 요소 이름은 명명 된 컨텍스트와 관련된 원자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="da9e1b040a45d5ff3225e516ec2f10b9b87c4fde" translate="yes" xml:space="preserve">
          <source>The NamingEnumeration that results from search() using SUBTREE_SCOPE contains elements of objects from the subtree (including the named context) that satisfy the search filter specified in search(). The names of elements in the NamingEnumeration are either relative to the named context or is a URL string. If the named context satisfies the search filter, it is included in the enumeration with the empty string as its name.</source>
          <target state="translated">SUBTREE_SCOPE를 사용하여 search ()에서 발생하는 NamingEnumeration에는 search ()에 지정된 검색 필터를 만족하는 서브 트리 (명명 된 컨텍스트 포함)의 오브젝트 요소가 포함됩니다. NamingEnumeration의 요소 이름은 명명 된 컨텍스트에 상대적이거나 URL 문자열입니다. 명명 된 컨텍스트가 검색 필터를 만족하는 경우 빈 문자열을 이름으로하여 열거에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0717837b006cdb37b72a3c747375798b59b55ee7" translate="yes" xml:space="preserve">
          <source>The New Tai Lue range with the New Tai Lue digits.</source>
          <target state="translated">New Tai Lue 숫자가있는 New Tai Lue 범위.</target>
        </trans-unit>
        <trans-unit id="6ef92ae8e6bbc492d70f78dfd743db2d2318625d" translate="yes" xml:space="preserve">
          <source>The NimbusLookAndFeel class.</source>
          <target state="translated">NimbusLookAndFeel 클래스.</target>
        </trans-unit>
        <trans-unit id="930af5019cfcdd67f8baecc2face9a22fc4ffedd" translate="yes" xml:space="preserve">
          <source>The NimbusLookAndFeel uses a standard naming scheme for entries in the UIDefaults table. The key for each property, state, painter, and other default registered in UIDefaults for a specific Region will begin with the specified &lt;code&gt;prefix&lt;/code&gt;</source>
          <target state="translated">NimbusLookAndFeel은 UIDefaults 테이블의 항목에 표준 명명 체계를 사용합니다. 특정 지역의 UIDefaults에 등록 된 각 속성, 상태, Painter 및 기타 기본값의 키는 지정된 &lt;code&gt;prefix&lt;/code&gt; 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="030dd257d65fcf8444f5ed24a27c3cbccb19f920" translate="yes" xml:space="preserve">
          <source>The NimbusStyle is reloaded whenever a property change event is fired for a component for &quot;Nimbus.Overrides&quot; or &quot;Nimbus.Overrides.InheritDefaults&quot;. So for example, setting a new UIDefaults on a component would cause the style to be reloaded.</source>
          <target state="translated">NimbusStyle은 &quot;Nimbus.Overrides&quot;또는 &quot;Nimbus.Overrides.InheritDefaults&quot;의 구성 요소에 대해 속성 변경 이벤트가 발생할 때마다 다시로드됩니다. 예를 들어 구성 요소에 새 UIDefaults를 설정하면 스타일이 다시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="b7a36233af8a787ae0e73f20504bb4105ca1942f" translate="yes" xml:space="preserve">
          <source>The Node at the specified position.</source>
          <target state="translated">지정된 위치의 노드입니다.</target>
        </trans-unit>
        <trans-unit id="339f160048f54fde5fb16ed0dd770edbfb611d30" translate="yes" xml:space="preserve">
          <source>The Notification class represents a notification emitted by an MBean.</source>
          <target state="translated">Notification 클래스는 MBean에서 발행 한 알림을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cf39ffb21a4256234c05b38d7bda0371c83db12a" translate="yes" xml:space="preserve">
          <source>The Notification class represents a notification emitted by an MBean. It contains a reference to the source MBean: if the notification has been forwarded through the MBean server, and the original source of the notification was a reference to the emitting MBean object, then the MBean server replaces it by the MBean's ObjectName. If the listener has registered directly with the MBean, this is either the object name or a direct reference to the MBean.</source>
          <target state="translated">Notification 클래스는 MBean에서 발행 한 알림을 나타냅니다. 여기에는 소스 MBean에 대한 참조가 포함됩니다. 통지가 MBean 서버를 통해 전달되고 통지의 원래 소스가 방출하는 MBean 오브젝트에 대한 참조 인 경우 MBean 서버는이를 MBean의 ObjectName으로 대체합니다. 리스너가 MBean에 직접 등록한 경우, 이것은 객체 명 또는 MBean에 대한 직접 참조입니다.</target>
        </trans-unit>
        <trans-unit id="21674881f205ff2b1ebde10ad56146b65e883a73" translate="yes" xml:space="preserve">
          <source>The NullCipher class is a class that provides an &quot;identity cipher&quot; -- one that does not transform the plain text.</source>
          <target state="translated">NullCipher 클래스는 일반 텍스트를 변환하지 않는 &quot;ID 암호&quot;를 제공하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="4eba459ac1063b013ecb05450cfc942330983956" translate="yes" xml:space="preserve">
          <source>The NullCipher class is a class that provides an &quot;identity cipher&quot; -- one that does not transform the plain text. As a consequence, the ciphertext is identical to the plaintext. All initialization methods do nothing, while the blocksize is set to 1 byte.</source>
          <target state="translated">NullCipher 클래스는 일반 텍스트를 변환하지 않는 &quot;ID 암호&quot;를 제공하는 클래스입니다. 결과적으로 암호문은 평문과 동일합니다. 모든 초기화 방법은 아무 것도 수행하지 않지만 블록 크기는 1 바이트로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9bc696b5517a42b3b02a6bb92ed85290770009f8" translate="yes" xml:space="preserve">
          <source>The Num Lock key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 작업 키인 Num Lock 키입니다.</target>
        </trans-unit>
        <trans-unit id="af7f35dd7e76fe866932423b2aed6d1fb8aee4d0" translate="yes" xml:space="preserve">
          <source>The OAEP parameter set with all default values.</source>
          <target state="translated">모든 기본값으로 설정된 OAEP 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="d3c91484eda423d34310b6f683e8f9c4d38353ad" translate="yes" xml:space="preserve">
          <source>The OCSP responder returns one of the following errors specified in section 2.3 of RFC 2560: internalError or tryLater.</source>
          <target state="translated">OCSP 응답자는 RFC 2560의 2.3 절에 지정된 다음 오류 중 하나를 리턴합니다. internalError 또는 tryLater.</target>
        </trans-unit>
        <trans-unit id="590e9f81926a84b9e3f08b8204debee01bf90568" translate="yes" xml:space="preserve">
          <source>The Object to which resolution was successful. Cannot be null.</source>
          <target state="translated">해결에 성공한 객체입니다. null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b04c18b328378819a5abfef3f9602c4688e2f86" translate="yes" xml:space="preserve">
          <source>The ObjectFactoryBuilder determines the policy used when trying to load object factories.</source>
          <target state="translated">ObjectFactoryBuilder는 객체 팩토리를로드하려고 할 때 사용되는 정책을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="2d9af7dd4afe4b3827fea167ae916792006d5495" translate="yes" xml:space="preserve">
          <source>The ObjectFactoryBuilder determines the policy used when trying to load object factories. See getObjectInstance() and class ObjectFactory for a description of the default policy. setObjectFactoryBuilder() overrides this default policy by installing an ObjectFactoryBuilder. Subsequent object factories will be loaded and created using the installed builder.</source>
          <target state="translated">ObjectFactoryBuilder는 오브젝트 팩토리를로드 할 때 사용되는 정책을 결정합니다. 기본 정책에 대한 설명은 getObjectInstance () 및 클래스 ObjectFactory를 참조하십시오. setObjectFactoryBuilder ()는 ObjectFactoryBuilder를 설치하여이 기본 정책을 대체합니다. 후속 오브젝트 팩토리는 설치된 빌더를 사용하여로드 및 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="5419cd5a84f61ee5075bb1b79dcc22de8c464f19" translate="yes" xml:space="preserve">
          <source>The ObjectOutputStream.writeObject method takes a parameter of type Object (as opposed to type Serializable) to allow for cases where non-serializable objects are replaced by serializable ones.</source>
          <target state="translated">ObjectOutputStream.writeObject 메소드는 직렬화 가능 오브젝트가 직렬화 가능 오브젝트로 대체되는 경우를 허용하기 위해 직렬화 가능 유형과 반대로 Object 유형의 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="580f1b6bc8f9c82e08b5a2581e4f010efcf39dbc" translate="yes" xml:space="preserve">
          <source>The ObjectStreamClass of an enum constant does not represent an enum type</source>
          <target state="translated">열거 형 상수의 ObjectStreamClass가 열거 형 유형을 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1e3e58b05fa221f0f71b1840e5fa4b72d867a75" translate="yes" xml:space="preserve">
          <source>The ObjectStreamField object of the named field or null if there is no such named field.</source>
          <target state="translated">명명 된 필드의 ObjectStreamField 객체. 명명 된 필드가없는 경우 null</target>
        </trans-unit>
        <trans-unit id="2ac840327c868e94a9ca4f260da23dea54452a47" translate="yes" xml:space="preserve">
          <source>The Ol Chiki range with the Ol Chiki digits.</source>
          <target state="translated">Ol Chiki 숫자가있는 Ol Chiki 범위.</target>
        </trans-unit>
        <trans-unit id="686dc1c6a4bf6a908c5989eadf0b4e575c563e0a" translate="yes" xml:space="preserve">
          <source>The Open Type of this element. In the case of &lt;code&gt;
 MBeanAttributeInfo&lt;/code&gt; and &lt;code&gt;MBeanParameterInfo&lt;/code&gt;, this is the Open Type of the attribute or parameter. In the case of &lt;code&gt;
 MBeanOperationInfo&lt;/code&gt;, it is the Open Type of the return value. This field is set in the Descriptor for all instances of &lt;a href=&quot;openmbean/openmbeanattributeinfosupport&quot;&gt;&lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;openmbean/openmbeanoperationinfosupport&quot;&gt;&lt;code&gt;OpenMBeanOperationInfoSupport&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;openmbean/openmbeanparameterinfosupport&quot;&gt;&lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt;&lt;/a&gt;. It is also set for attributes, operations, and parameters of MXBeans.</source>
          <target state="translated">이 요소의 개방형입니다. 의 경우 &lt;code&gt; MBeanAttributeInfo&lt;/code&gt; 및 &lt;code&gt;MBeanParameterInfo&lt;/code&gt; 의 ,이 속성 또는 파라미터의 Open Type입니다. &lt;code&gt; MBeanOperationInfo&lt;/code&gt; 의 경우 반환 값의 Open Type입니다. 이 필드는 &lt;a href=&quot;openmbean/openmbeanattributeinfosupport&quot;&gt; &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;openmbean/openmbeanoperationinfosupport&quot;&gt; &lt;code&gt;OpenMBeanOperationInfoSupport&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;openmbean/openmbeanparameterinfosupport&quot;&gt; &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; &lt;/a&gt; 의 모든 인스턴스에 대한 설명자에서 설정됩니다 . MXBean의 속성, 조작 및 매개 변수에 대해서도 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="14746a7869df9344bf3add89eda86eda0f27df41" translate="yes" xml:space="preserve">
          <source>The Open Type of this element. In the case of &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; and &lt;code&gt;MBeanParameterInfo&lt;/code&gt;, this is the Open Type of the attribute or parameter. In the case of &lt;code&gt;MBeanOperationInfo&lt;/code&gt;, it is the Open Type of the return value. This field is set in the Descriptor for all instances of &lt;a href=&quot;openmbean/openmbeanattributeinfosupport&quot;&gt;&lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;openmbean/openmbeanoperationinfosupport&quot;&gt;&lt;code&gt;OpenMBeanOperationInfoSupport&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;openmbean/openmbeanparameterinfosupport&quot;&gt;&lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt;&lt;/a&gt;. It is also set for attributes, operations, and parameters of MXBeans.</source>
          <target state="translated">이 요소의 개방형. &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; 및 &lt;code&gt;MBeanParameterInfo&lt;/code&gt; 의 경우 , 이것은 속성 또는 파라미터의 공개 형입니다. &lt;code&gt;MBeanOperationInfo&lt;/code&gt; 의 경우 , 리턴 값의 공개 형입니다. 이 필드는 Descriptor에서 &lt;a href=&quot;openmbean/openmbeanattributeinfosupport&quot;&gt; &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;openmbean/openmbeanoperationinfosupport&quot;&gt; &lt;code&gt;OpenMBeanOperationInfoSupport&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;openmbean/openmbeanparameterinfosupport&quot;&gt; &lt;code&gt;OpenMBeanParameterInfoSupport&lt;/code&gt; &lt;/a&gt; 의 모든 인스턴스에 대해 설정됩니다 . MXBean의 속성, 조작 및 매개 변수에 대해서도 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1ee8b38b45c5d04256b1084f98f63cbf5cd52ad7" translate="yes" xml:space="preserve">
          <source>The Open Type, &lt;em&gt;opentype(&lt;/em&gt;&lt;code&gt;
        List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;em&gt;)&lt;/em&gt;, is &lt;a href=&quot;openmbean/arraytype&quot;&gt;&lt;code&gt;ArrayType&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(1, &lt;/code&gt;&lt;a href=&quot;openmbean/simpletype#STRING&quot;&gt;&lt;code&gt;SimpleType.STRING&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;, representing a 1-dimensional array of &lt;code&gt;String&lt;/code&gt;s.</source>
          <target state="translated">오픈형, &lt;em&gt;오픈 타입 ( &lt;/em&gt; &lt;code&gt; List&amp;lt;String&amp;gt;&lt;/code&gt; &lt;em&gt;)&lt;/em&gt; 이다 &lt;a href=&quot;openmbean/arraytype&quot;&gt; &lt;code&gt;ArrayType&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(1, &lt;/code&gt; &lt;a href=&quot;openmbean/simpletype#STRING&quot;&gt; &lt;code&gt;SimpleType.STRING&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 의 1 차원 배열을 나타내는 &lt;code&gt;String&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="3d8ca0b1298715049081cc8a7ee921c31ef00c4d" translate="yes" xml:space="preserve">
          <source>The Open Type, &lt;em&gt;opentype(&lt;/em&gt;&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;&lt;em&gt;)&lt;/em&gt;, is &lt;a href=&quot;openmbean/arraytype&quot;&gt;&lt;code&gt;ArrayType&lt;/code&gt;&lt;/a&gt;&lt;code&gt;(1, &lt;/code&gt;&lt;a href=&quot;openmbean/simpletype#STRING&quot;&gt;&lt;code&gt;SimpleType.STRING&lt;/code&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;, representing a 1-dimensional array of &lt;code&gt;String&lt;/code&gt;s.</source>
          <target state="translated">오픈형, &lt;em&gt;오픈 타입 ( &lt;/em&gt; &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; &lt;em&gt;)&lt;/em&gt; 이다 &lt;a href=&quot;openmbean/arraytype&quot;&gt; &lt;code&gt;ArrayType&lt;/code&gt; &lt;/a&gt; &lt;code&gt;(1, &lt;/code&gt; &lt;a href=&quot;openmbean/simpletype#STRING&quot;&gt; &lt;code&gt;SimpleType.STRING&lt;/code&gt; &lt;/a&gt; &lt;code&gt;)&lt;/code&gt; 의 1 차원 배열을 나타내는 &lt;code&gt;String&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="eacc7b04548f8ebda5f388a359ed276237f9e530" translate="yes" xml:space="preserve">
          <source>The OrientationRequestedType instance to use for specifying a landscape orientation.</source>
          <target state="translated">가로 방향을 지정하는 데 사용할 OrientationRequestedType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="d2e78bf087c2f313d0557edb30b321bd5d2675d4" translate="yes" xml:space="preserve">
          <source>The OrientationRequestedType instance to use for specifying a portrait orientation.</source>
          <target state="translated">세로 방향을 지정하는 데 사용할 OrientationRequestedType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="86e97ad57b9b9d8ebd7b9d529990f1d9ae26ec7d" translate="yes" xml:space="preserve">
          <source>The OriginType instance to use for specifying a physical origin.</source>
          <target state="translated">물리적 출처를 지정하는 데 사용할 OriginType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="0c144f2bace2e10e29c5d67044e54b84b1b53676" translate="yes" xml:space="preserve">
          <source>The OriginType instance to use for specifying a printable origin.</source>
          <target state="translated">인쇄 가능한 원본을 지정하는 데 사용할 OriginType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="3daffe642dc56886ac3c7c719d3cf4600cbab1e2" translate="yes" xml:space="preserve">
          <source>The Oriya range with the Oriya digits.</source>
          <target state="translated">Oriya 숫자가있는 Oriya 범위입니다.</target>
        </trans-unit>
        <trans-unit id="604108d7679d35923f2a2666b52d152240872ab8" translate="yes" xml:space="preserve">
          <source>The POSIX attributes of a file are retrieved using a &lt;a href=&quot;posixfileattributeview&quot;&gt;&lt;code&gt;PosixFileAttributeView&lt;/code&gt;&lt;/a&gt; by invoking its &lt;a href=&quot;posixfileattributeview#readAttributes()&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파일의 POSIX 속성은 사용하여 검색됩니다 &lt;a href=&quot;posixfileattributeview&quot;&gt; &lt;code&gt;PosixFileAttributeView&lt;/code&gt; 를&lt;/a&gt; 그 호출하여 &lt;a href=&quot;posixfileattributeview#readAttributes()&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; 의&lt;/a&gt; 방법을.</target>
        </trans-unit>
        <trans-unit id="c8d2a39da861a7048f3bf16ac55acc32a5404839" translate="yes" xml:space="preserve">
          <source>The POSIX attributes of a file are retrieved using a &lt;a href=&quot;posixfileattributeview&quot;&gt;&lt;code&gt;PosixFileAttributeView&lt;/code&gt;&lt;/a&gt; by invoking its &lt;a href=&quot;posixfileattributeview#readAttributes--&quot;&gt;&lt;code&gt;readAttributes&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">파일의 POSIX 속성은 사용하여 검색됩니다 &lt;a href=&quot;posixfileattributeview&quot;&gt; &lt;code&gt;PosixFileAttributeView&lt;/code&gt; 를&lt;/a&gt; 그 호출하여 &lt;a href=&quot;posixfileattributeview#readAttributes--&quot;&gt; &lt;code&gt;readAttributes&lt;/code&gt; 의&lt;/a&gt; 방법을.</target>
        </trans-unit>
        <trans-unit id="c6209ce8603095315802c16ee6435b6d192cd524" translate="yes" xml:space="preserve">
          <source>The PRECISION column represents the maximum column size that the server supports for the given datatype. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. Null is returned for data types where the column size is not applicable.</source>
          <target state="translated">PRECISION 열은 주어진 데이터 유형에 대해 서버가 지원하는 최대 열 크기를 나타냅니다. 숫자 데이터의 경우 이것은 최대 정밀도입니다. 문자 데이터의 경우 문자 길이입니다. datetime 데이터 유형의 경우 이것은 문자열 표현의 문자 길이입니다 (초 분수 구성 요소의 최대 허용 정밀도 가정). 이진 데이터의 경우 길이 (바이트)입니다. ROWID 데이터 유형의 경우 길이 (바이트)입니다. 열 크기를 적용 할 수없는 데이터 형식에 대해서는 Null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="608f908546c6fb2d1a0985679772a6d0fb7a4cd7" translate="yes" xml:space="preserve">
          <source>The PRECISION column represents the specified column size for the given column. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. Null is returned for data types where the column size is not applicable.</source>
          <target state="translated">PRECISION 컬럼은 주어진 컬럼에 대해 지정된 컬럼 크기를 나타냅니다. 숫자 데이터의 경우 이것은 최대 정밀도입니다. 문자 데이터의 경우 문자 길이입니다. datetime 데이터 유형의 경우 이것은 문자열 표현의 문자 길이입니다 (초 분수 구성 요소의 최대 허용 정밀도 가정). 이진 데이터의 경우 길이 (바이트)입니다. ROWID 데이터 유형의 경우 길이 (바이트)입니다. 열 크기를 적용 할 수없는 데이터 형식에 대해서는 Null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1881900cdf6442ca348aababed8d278a05876686" translate="yes" xml:space="preserve">
          <source>The PRECISION column represents the specified column size for the given parameter or column. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. Null is returned for data types where the column size is not applicable.</source>
          <target state="translated">PRECISION 컬럼은 주어진 매개 변수 또는 컬럼에 대해 지정된 컬럼 크기를 나타냅니다. 숫자 데이터의 경우 이것은 최대 정밀도입니다. 문자 데이터의 경우 문자 길이입니다. datetime 데이터 유형의 경우 이것은 문자열 표현의 문자 길이입니다 (초 분수 구성 요소의 최대 허용 정밀도 가정). 이진 데이터의 경우 길이 (바이트)입니다. ROWID 데이터 유형의 경우 길이 (바이트)입니다. 열 크기를 적용 할 수없는 데이터 형식에 대해서는 Null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1079b01e3962327ce622a8802a1cf6880ebb5c6e" translate="yes" xml:space="preserve">
          <source>The PSS parameter set with all default values</source>
          <target state="translated">모든 기본값으로 설정된 PSS 매개 변수</target>
        </trans-unit>
        <trans-unit id="b3ab28242caa847b286fc90013d2b0491ec3901c" translate="yes" xml:space="preserve">
          <source>The PSS parameter set with all default values.</source>
          <target state="translated">모든 기본값으로 설정된 PSS 매개 변수.</target>
        </trans-unit>
        <trans-unit id="7a1a9a52c509b8bf2aa11fc375268d5d4b982847" translate="yes" xml:space="preserve">
          <source>The Page Down key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 조치 키인 Page Down 키.</target>
        </trans-unit>
        <trans-unit id="b6ceff4e733a8fd8dd95849144a04eed6a170dfb" translate="yes" xml:space="preserve">
          <source>The Page Up key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 조치 키인 Page Up 키.</target>
        </trans-unit>
        <trans-unit id="3d027f6c803d6758ba706e29a00afc1193bf2442" translate="yes" xml:space="preserve">
          <source>The ParameterDescriptor class allows bean implementors to provide additional information on each of their parameters, beyond the low level type information provided by the java.lang.reflect.Method class.</source>
          <target state="translated">ParameterDescriptor 클래스는 Bean 구현자가 java.lang.reflect.Method 클래스에서 제공하는 하위 레벨 유형 정보 외에 각 매개 변수에 대한 추가 정보를 제공 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="4d3cbd26cc18d883fce3423f3e8a2d5ef0540f3d" translate="yes" xml:space="preserve">
          <source>The Parser will call this method to report each chunk of character data. SAX parsers may return all contiguous character data in a single chunk, or they may split it into several chunks; however, all of the characters in any single event must come from the same external entity so that the Locator provides useful information.</source>
          <target state="translated">파서는이 방법을 호출하여 각 문자 데이터 청크를보고합니다. SAX 파서는 연속 된 모든 문자 데이터를 단일 청크로 반환하거나 여러 청크로 분할 할 수 있습니다. 그러나 로케이터가 유용한 정보를 제공 할 수 있도록 단일 이벤트의 모든 문자는 동일한 외부 엔티티에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="007f0b4c51a8ac3735f09488d895ca9527132e33" translate="yes" xml:space="preserve">
          <source>The Parser will call this method to report each chunk of character data. SAX parsers may return all contiguous character data in a single chunk, or they may split it into several chunks; however, all of the characters in any single event must come from the same external entity, so that the Locator provides useful information.</source>
          <target state="translated">파서는이 메서드를 호출하여 각 문자 데이터 청크를보고합니다. SAX 구문 분석기는 모든 연속 문자 데이터를 단일 청크로 반환하거나 여러 청크로 분할 할 수 있습니다. 그러나 단일 이벤트의 모든 문자는 동일한 외부 엔터티에서 가져와야하므로 로케이터는 유용한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c553a7aebfb79b4c7d7552c035617009c0021687" translate="yes" xml:space="preserve">
          <source>The Parser will invoke this method at the beginning of every element in the XML document; there will be a corresponding &lt;a href=&quot;#endElement(java.lang.String,java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;endElement&lt;/code&gt;&lt;/a&gt; event for every startElement event (even when the element is empty). All of the element's content will be reported, in order, before the corresponding endElement event.</source>
          <target state="translated">구문 분석기는 XML 문서의 모든 요소 시작 부분에서이 메소드를 호출합니다. 모든 startElement 이벤트에 해당하는 &lt;a href=&quot;#endElement(java.lang.String,java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;endElement&lt;/code&gt; &lt;/a&gt; 이벤트 가 있습니다 (요소가 비어있는 경우에도). 모든 요소의 콘텐츠는 해당 endElement 이벤트 전에 순서대로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="b2ffaeb8d0f43b3556a7668c6a3754787ebdf35f" translate="yes" xml:space="preserve">
          <source>The Parser will invoke this method at the beginning of every element in the XML document; there will be a corresponding endElement() event for every startElement() event (even when the element is empty). All of the element's content will be reported, in order, before the corresponding endElement() event.</source>
          <target state="translated">구문 분석기는 XML 문서의 모든 요소 시작 부분에서이 메소드를 호출합니다. 모든 startElement () 이벤트에 해당하는 endElement () 이벤트가 있습니다 (요소가 비어있는 경우에도). 모든 요소의 콘텐츠는 해당하는 endElement () 이벤트 전에 순서대로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="f1bdbe90a7c340b478f9c1c18b63e2450df851d2" translate="yes" xml:space="preserve">
          <source>The Parser will invoke this method each time the entity is skipped. Non-validating processors may skip entities if they have not seen the declarations (because, for example, the entity was declared in an external DTD subset). All processors may skip external entities, depending on the values of the &lt;code&gt;http://xml.org/sax/features/external-general-entities&lt;/code&gt; and the &lt;code&gt;http://xml.org/sax/features/external-parameter-entities&lt;/code&gt; properties.</source>
          <target state="translated">파서는 엔터티를 건너 뛸 때마다이 메서드를 호출합니다. 검증되지 않은 프로세서는 선언을 보지 못한 경우 엔티티를 건너 뛸 수 있습니다 (예 : 엔티티가 외부 DTD 서브 세트에서 선언 되었기 때문). 모든 프로세서는 &lt;code&gt;http://xml.org/sax/features/external-general-entities&lt;/code&gt; 및 &lt;code&gt;http://xml.org/sax/features/external-parameter-entities&lt;/code&gt; 속성 의 값에 따라 외부 엔터티를 건너 뛸 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="3cc97f14d1c6ed34640e855f6a0e48fc1a501ede" translate="yes" xml:space="preserve">
          <source>The Parser will invoke this method once for each processing instruction found: note that processing instructions may occur before or after the main document element.</source>
          <target state="translated">파서는 발견 된 각 처리 명령에 대해이 메소드를 한 번 호출합니다. 처리 명령은 기본 문서 요소 전후에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b49db7c6419de0ed107d7d806648cd410319d193" translate="yes" xml:space="preserve">
          <source>The PasswordAuthentication collected from the user, or null if none is provided.</source>
          <target state="translated">사용자로부터 수집 한 PasswordAuthentication. 제공되지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="6b93a014cd48ed59022ceab57c22cc48b40d19a2" translate="yes" xml:space="preserve">
          <source>The Pause key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 조치 키인 Pause 키.</target>
        </trans-unit>
        <trans-unit id="9b0ce5aa8f07de13619b19a3de18228946efc98c" translate="yes" xml:space="preserve">
          <source>The Payload Protocol Identifier</source>
          <target state="translated">페이로드 프로토콜 식별자</target>
        </trans-unit>
        <trans-unit id="47162c3848702f346f4c344da14d624a5c12818f" translate="yes" xml:space="preserve">
          <source>The Permission class for reflective operations.</source>
          <target state="translated">반사 작업을위한 Permission 클래스</target>
        </trans-unit>
        <trans-unit id="2fe6df3634a9b58d388e16b81f2a5767b8a67a98" translate="yes" xml:space="preserve">
          <source>The PermissionCollection returned by the &lt;code&gt;Permission.newPermissionCollection&lt;/code&gt; method is a homogeneous collection, which stores only Permission objects for a given Permission type. A PermissionCollection may also be heterogeneous. For example, Permissions is a PermissionCollection subclass that represents a collection of PermissionCollections. That is, its members are each a homogeneous PermissionCollection. For example, a Permissions object might have a FilePermissionCollection for all the FilePermission objects, a SocketPermissionCollection for all the SocketPermission objects, and so on. Its &lt;code&gt;add&lt;/code&gt; method adds a permission to the appropriate collection.</source>
          <target state="translated">&lt;code&gt;Permission.newPermissionCollection&lt;/code&gt; 메소드에 의해 리턴 된 PermissionCollection 은 동종의 콜렉션으로, 주어진 Permission 유형에 대한 Permission 오브젝트 만 저장합니다. PermissionCollection도이기 종일 수 있습니다. 예를 들어 Permissions는 PermissionCollections 컬렉션을 나타내는 PermissionCollection 하위 클래스입니다. 즉, 멤버는 각각 동종 PermissionCollection입니다. 예를 들어 Permissions 객체에는 모든 FilePermission 객체에 대한 FilePermissionCollection, 모든 SocketPermission 객체에 대한 SocketPermissionCollection 등이있을 수 있습니다. 그것의 &lt;code&gt;add&lt;/code&gt; 방법은 액세스권을 적절한 컬렉션에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5b44fa11f797cda619a6aef640c6e5f1150da36c" translate="yes" xml:space="preserve">
          <source>The PersistenceDelegate class takes the responsibility for expressing the state of an instance of a given class in terms of the methods in the class's public API.</source>
          <target state="translated">PersistenceDelegate 클래스는 주어진 클래스의 인스턴스 상태를 클래스의 퍼블릭 API에있는 메소드로 표현할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe7a2d34b2335b92e9d706d17e53c3f47d5a8dbf" translate="yes" xml:space="preserve">
          <source>The PersistenceDelegate class takes the responsibility for expressing the state of an instance of a given class in terms of the methods in the class's public API. Instead of associating the responsibility of persistence with the class itself as is done, for example, by the &lt;code&gt;readObject&lt;/code&gt; and &lt;code&gt;writeObject&lt;/code&gt; methods used by the &lt;code&gt;ObjectOutputStream&lt;/code&gt;, streams like the &lt;code&gt;XMLEncoder&lt;/code&gt; which use this delegation model can have their behavior controlled independently of the classes themselves. Normally, the class is the best place to put such information and conventions can easily be expressed in this delegation scheme to do just that. Sometimes however, it is the case that a minor problem in a single class prevents an entire object graph from being written and this can leave the application developer with no recourse but to attempt to shadow the problematic classes locally or use alternative persistence techniques. In situations like these, the delegation model gives a relatively clean mechanism for the application developer to intervene in all parts of the serialization process without requiring that modifications be made to the implementation of classes which are not part of the application itself.</source>
          <target state="translated">PersistenceDelegate 클래스는 주어진 클래스의 인스턴스 상태를 클래스의 퍼블릭 API에있는 메소드로 표현할 책임이 있습니다. 예를 들어 &lt;code&gt;ObjectOutputStream&lt;/code&gt; 에 의해 사용되는 &lt;code&gt;readObject&lt;/code&gt; 및 &lt;code&gt;writeObject&lt;/code&gt; 메소드에 의해 수행되는 지속성 책임을 클래스 자체와 연관시키는 대신 &lt;code&gt;XMLEncoder&lt;/code&gt; 와 같은 스트림이 위임 모델을 사용하는 클래스는 클래스 자체와 독립적으로 동작을 제어 할 수 있습니다. 일반적으로 수업은 이러한 정보를 넣을 수있는 가장 좋은 장소이며이 위임 구성표에 규칙을 쉽게 표현할 수 있습니다. 그러나 때로는 단일 클래스의 사소한 문제로 인해 전체 객체 그래프가 작성되지 않을 수 있으며 이로 인해 응용 프로그램 개발자가 문제를 일으키지 않고 문제가있는 클래스를 로컬로 숨기거나 대체 지속성 기술을 사용할 수 있습니다. 이러한 상황에서 위임 모델은 응용 프로그램 개발자가 응용 프로그램 자체의 일부가 아닌 클래스의 구현을 수정하지 않고도 직렬화 프로세스의 모든 부분에 개입 할 수있는 비교적 깨끗한 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="583fa9535a80ecfda9fc21924d4be2f9b0f70a94" translate="yes" xml:space="preserve">
          <source>The Photo YCC conversion color space.</source>
          <target state="translated">사진 YCC 변환 색상 공간입니다.</target>
        </trans-unit>
        <trans-unit id="bce29884d2e4006d61c9c4ae80d1499100307e59" translate="yes" xml:space="preserve">
          <source>The PixelGrabber class implements an ImageConsumer which can be attached to an Image or ImageProducer object to retrieve a subset of the pixels in that image.</source>
          <target state="translated">PixelGrabber 클래스는 Image 또는 ImageProducer 개체에 연결하여 해당 이미지의 픽셀 하위 집합을 검색 할 수있는 ImageConsumer를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="62f294221adf8c7cc8209135f1f1270130eba917" translate="yes" xml:space="preserve">
          <source>The PixelGrabber class implements an ImageConsumer which can be attached to an Image or ImageProducer object to retrieve a subset of the pixels in that image. Here is an example:</source>
          <target state="translated">PixelGrabber 클래스는 Image 또는 ImageProducer 개체에 연결하여 해당 이미지의 픽셀 하위 집합을 검색 할 수있는 ImageConsumer를 구현합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f579bdcf97e6eb9cb7574a266fa66a89a905516" translate="yes" xml:space="preserve">
          <source>The PostConstruct annotation is used on a method that needs to be executed after dependency injection is done to perform any initialization.</source>
          <target state="translated">PostConstruct 주석은 초기화를 수행하기 위해 종속성 주입이 완료된 후에 실행되어야하는 메소드에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="663424111809ef7a25cf879a877b2f4c747a5c6b" translate="yes" xml:space="preserve">
          <source>The PostConstruct annotation is used on a method that needs to be executed after dependency injection is done to perform any initialization. This method MUST be invoked before the class is put into service. This annotation MUST be supported on all classes that support dependency injection. The method annotated with PostConstruct MUST be invoked even if the class does not request any resources to be injected. Only one method can be annotated with this annotation. The method on which the PostConstruct annotation is applied MUST fulfill all of the following criteria:</source>
          <target state="translated">PostConstruct 주석은 초기화를 수행하기 위해 종속성 주입이 완료된 후에 실행되어야하는 메소드에서 사용됩니다. 이 메소드는 클래스를 서비스하기 전에 호출해야합니다. 이 주석은 의존성 주입을 지원하는 모든 클래스에서 반드시 지원되어야합니다. PostConstruct로 주석이 달린 메소드는 클래스가 리소스를 주입하도록 요청하지 않더라도 반드시 호출되어야한다. 이 주석에는 한 가지 방법 만 주석을 달 수 있습니다. PostConstruct 주석이 적용되는 방법은 다음 기준을 모두 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="474d2291101f131bfdaaf8be9f4fb6c2d55ed0cb" translate="yes" xml:space="preserve">
          <source>The PreDestroy annotation is used on methods as a callback notification to signal that the instance is in the process of being removed by the container.</source>
          <target state="translated">PreDestroy 어노테이션은 인스턴스가 컨테이너에 의해 제거되고 있음을 알리기 위해 메소드에서 콜백 알림으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f4e141fe06f04a529a2ebb0a5d0f52a343eafc5" translate="yes" xml:space="preserve">
          <source>The PreDestroy annotation is used on methods as a callback notification to signal that the instance is in the process of being removed by the container. The method annotated with PreDestroy is typically used to release resources that it has been holding. This annotation MUST be supported by all container managed objects that support PostConstruct except the application client container in Java EE 5. The method on which the PreDestroy annotation is applied MUST fulfill all of the following criteria:</source>
          <target state="translated">PreDestroy 어노테이션은 인스턴스가 컨테이너에 의해 제거되고 있음을 알리기 위해 메소드에서 콜백 알림으로 사용됩니다. PreDestroy로 주석이 달린 메소드는 일반적으로 보유하고있는 자원을 해제하는 데 사용됩니다. 이 주석은 Java EE 5의 응용 프로그램 클라이언트 컨테이너를 제외하고 PostConstruct를 지원하는 모든 컨테이너 관리 객체에서 지원해야합니다. PreDestroy 주석이 적용되는 방법은 다음 기준을 모두 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1757e1a54444fb1f78c30c52a38118eeb762c87" translate="yes" xml:space="preserve">
          <source>The Principals and credentials from the specified Sets are copied into newly constructed Sets. These newly created Sets check whether this &lt;code&gt;Subject&lt;/code&gt; has been set read-only before permitting subsequent modifications. The newly created Sets also prevent illegal modifications by ensuring that callers have sufficient permissions.</source>
          <target state="translated">지정된 세트의 프린시 펄 및 신임 정보가 새로 구성된 세트로 복사됩니다. 새로 작성된이 세트 는 후속 수정을 허용하기 전에이 &lt;code&gt;Subject&lt;/code&gt; 읽기 전용으로 설정되어 있는지 확인합니다 . 새로 생성 된 세트는 또한 발신자가 충분한 권한을 갖도록하여 불법적 인 수정을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="35d858350b98812050600775afb70417bda94300" translate="yes" xml:space="preserve">
          <source>The Principals and credentials from the specified Sets are copied into newly constructed Sets. These newly created Sets check whether this &lt;code&gt;Subject&lt;/code&gt; has been set read-only before permitting subsequent modifications. The newly created Sets also prevent illegal modifications by ensuring that callers have sufficient permissions. These Sets also prohibit null elements, and attempts to add or query a null element will result in a &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">지정된 집합의 주체와 자격 증명이 새로 구성된 집합에 복사됩니다. 새로 생성 된 이러한 세트 는 후속 수정을 허용하기 전에이 &lt;code&gt;Subject&lt;/code&gt; 읽기 전용으로 설정되었는지 여부를 확인합니다 . 새로 생성 된 세트는 또한 호출자가 충분한 권한을 갖도록하여 불법적 인 수정을 방지합니다. 이러한 집합은 또한 null 요소를 금지하고 null 요소를 추가하거나 쿼리하려고하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="9479f421d53dcb84a15d69adc8edc90fd07e8e87" translate="yes" xml:space="preserve">
          <source>The Print Screen key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 조치 키인 Print Screen 키입니다.</target>
        </trans-unit>
        <trans-unit id="69d951673774bcf174ae72870200da34cf3c5ebe" translate="yes" xml:space="preserve">
          <source>The Print Service API provides one implementation of interface &lt;code&gt;AttributeSet&lt;/code&gt;, class &lt;a href=&quot;hashattributeset&quot;&gt;&lt;code&gt;HashAttributeSet&lt;/code&gt;&lt;/a&gt;. A client can use class &lt;a href=&quot;hashattributeset&quot;&gt;&lt;code&gt;HashAttributeSet&lt;/code&gt;&lt;/a&gt; or provide its own implementation of interface &lt;code&gt;AttributeSet&lt;/code&gt;. The Print Service API also provides implementations of interface &lt;code&gt;AttributeSet&lt;/code&gt;'s subinterfaces -- classes &lt;a href=&quot;hashdocattributeset&quot;&gt;&lt;code&gt;HashDocAttributeSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hashprintrequestattributeset&quot;&gt;&lt;code&gt;HashPrintRequestAttributeSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hashprintjobattributeset&quot;&gt;&lt;code&gt;HashPrintJobAttributeSet&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;hashprintserviceattributeset&quot;&gt;&lt;code&gt;HashPrintServiceAttributeSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인쇄 서비스 API는 &lt;code&gt;AttributeSet&lt;/code&gt; 인터페이스 , &lt;a href=&quot;hashattributeset&quot;&gt; &lt;code&gt;HashAttributeSet&lt;/code&gt; &lt;/a&gt; 클래스 의 하나의 구현을 제공합니다 . 클라이언트는 &lt;a href=&quot;hashattributeset&quot;&gt; &lt;code&gt;HashAttributeSet&lt;/code&gt; &lt;/a&gt; 클래스를 사용 하거나 &lt;code&gt;AttributeSet&lt;/code&gt; 인터페이스의 자체 구현을 제공 할 수 있습니다 . 인쇄 서비스 API는 또한 인터페이스 &lt;code&gt;AttributeSet&lt;/code&gt; 의 하위 인터페이스 ( &lt;a href=&quot;hashdocattributeset&quot;&gt; &lt;code&gt;HashDocAttributeSet&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;hashprintrequestattributeset&quot;&gt; &lt;code&gt;HashPrintRequestAttributeSet&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;hashprintjobattributeset&quot;&gt; &lt;code&gt;HashPrintJobAttributeSet&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;hashprintserviceattributeset&quot;&gt; &lt;code&gt;HashPrintServiceAttributeSet&lt;/code&gt; &lt;/a&gt; 클래스)의 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5023e9c16aece2d432f4a46ffaa75c4a32d41d7b" translate="yes" xml:space="preserve">
          <source>The Print Service API provides one implementation of interface AttributeSet, class &lt;a href=&quot;hashattributeset&quot;&gt;&lt;code&gt;HashAttributeSet&lt;/code&gt;&lt;/a&gt;. A client can use class &lt;a href=&quot;hashattributeset&quot;&gt;&lt;code&gt;HashAttributeSet&lt;/code&gt;&lt;/a&gt; or provide its own implementation of interface AttributeSet. The Print Service API also provides implementations of interface AttributeSet's subinterfaces -- classes &lt;a href=&quot;hashdocattributeset&quot;&gt;&lt;code&gt;HashDocAttributeSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hashprintrequestattributeset&quot;&gt;&lt;code&gt;HashPrintRequestAttributeSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;hashprintjobattributeset&quot;&gt;&lt;code&gt;HashPrintJobAttributeSet&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;hashprintserviceattributeset&quot;&gt;&lt;code&gt;HashPrintServiceAttributeSet&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인쇄 서비스 API는 &lt;a href=&quot;hashattributeset&quot;&gt; &lt;code&gt;HashAttributeSet&lt;/code&gt; &lt;/a&gt; 클래스 인 AttributeSet 인터페이스의 하나의 구현을 제공합니다 . 클라이언트는 &lt;a href=&quot;hashattributeset&quot;&gt; &lt;code&gt;HashAttributeSet&lt;/code&gt; &lt;/a&gt; 클래스를 사용 하거나 자체 인터페이스 AttributeSet 구현을 제공 할 수 있습니다 . 인쇄 서비스 API는 또한 인터페이스 AttributeSet의 하위 인터페이스 ( &lt;a href=&quot;hashdocattributeset&quot;&gt; &lt;code&gt;HashDocAttributeSet&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;hashprintrequestattributeset&quot;&gt; &lt;code&gt;HashPrintRequestAttributeSet&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;hashprintjobattributeset&quot;&gt; &lt;code&gt;HashPrintJobAttributeSet&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;hashprintserviceattributeset&quot;&gt; &lt;code&gt;HashPrintServiceAttributeSet&lt;/code&gt; &lt;/a&gt; 클래스)의 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a36fd7d83fcd442d2ca4e063a3d8df953492d146" translate="yes" xml:space="preserve">
          <source>The PrintQualityType instance to use for specifying a draft print quality.</source>
          <target state="translated">초안 인쇄 품질을 지정하는 데 사용할 PrintQualityType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="031b4b1f0aba81e6ac427aa15ddc998c99500e14" translate="yes" xml:space="preserve">
          <source>The PrintQualityType instance to use for specifying a high print quality.</source>
          <target state="translated">높은 인쇄 품질을 지정하는 데 사용할 PrintQualityType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="784892b08d359d8cf5e053ee18347d2f728babf6" translate="yes" xml:space="preserve">
          <source>The PrintQualityType instance to use for specifying a normal print quality.</source>
          <target state="translated">일반 인쇄 품질을 지정하는 데 사용할 PrintQualityType 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="113ca29dc8899124bef3d1bfa5bd50040ad1d06f" translate="yes" xml:space="preserve">
          <source>The Printer could not access one or more documents passed by reference (i.e., the print data representation object is a URL). This reason is intended to cover any file access problem,including file does not exist and access denied because of an access control problem. Whether the printer aborts the job and moves the job to the ABORTED job state or prints all documents that are accessible and moves the job to the COMPLETED job state and adds the COMPLETED_WITH_ERRORS reason to the job's &lt;a href=&quot;jobstatereasons&quot;&gt;&lt;code&gt;JobStateReasons&lt;/code&gt;&lt;/a&gt; attribute depends on implementation and/or site policy. This value should be supported if the printer supports doc flavors with URL print data representation objects.</source>
          <target state="translated">프린터가 참조로 전달 된 하나 이상의 문서에 액세스 할 수 없습니다 (즉, 인쇄 데이터 표시 객체가 URL 임). 이 이유는 액세스 제어 문제로 인해 파일이 존재하지 않고 액세스 거부를 포함한 모든 파일 액세스 문제를 다루기위한 것입니다. 프린터가 작업을 중단하고 작업을 ABORTED 작업 상태로 이동하거나 액세스 가능한 모든 문서를 인쇄하고 작업을 COMPLETED 작업 상태로 이동하고 COMPLETED_WITH_ERRORS 이유를 작업의 &lt;a href=&quot;jobstatereasons&quot;&gt; &lt;code&gt;JobStateReasons&lt;/code&gt; &lt;/a&gt; 속성에 추가하는지 여부는 구현 및 / 또는 사이트 정책에 따라 다릅니다. 이 값은 프린터가 URL 인쇄 데이터 표현 오브젝트로 문서 특성을 지원하는 경우 지원되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fce18036495868d9659f03df3d44dfcec351c534" translate="yes" xml:space="preserve">
          <source>The Program</source>
          <target state="translated">프로그램</target>
        </trans-unit>
        <trans-unit id="6fcae93a93a1ee82554381525484d5b1b3f879a6" translate="yes" xml:space="preserve">
          <source>The Properties object that was passed to &lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt;&lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt;&lt;/a&gt; won't be effected by calling this method.</source>
          <target state="translated">&lt;a href=&quot;#setOutputProperties(java.util.Properties)&quot;&gt; &lt;code&gt;setOutputProperties(java.util.Properties)&lt;/code&gt; &lt;/a&gt; 에 전달 된 Properties 개체는 이 메서드를 호출해도 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95de950a5d7a1f254995d0b5167a4290a1b7a28e" translate="yes" xml:space="preserve">
          <source>The PropertyChangeListener that will be added to track changes in the desktop pane.</source>
          <target state="translated">데스크톱 창에서 변경 사항을 추적하기 위해 추가 될 PropertyChangeListener입니다.</target>
        </trans-unit>
        <trans-unit id="59a9f4d1b84220d6f2d96b358a0f7ee7ce4bb654" translate="yes" xml:space="preserve">
          <source>The PropertyChangeListener that's added to the JList at installUI time.</source>
          <target state="translated">installUI 시간에 JList에 추가되는 PropertyChangeListener입니다.</target>
        </trans-unit>
        <trans-unit id="2e2d0d45cb9f1cfc9a548fbe762ae6b51166f7c6" translate="yes" xml:space="preserve">
          <source>The PropertyChangeListener that's added to the JList at installUI time. When the value of a JList property that affects layout changes, we set a bit in updateLayoutStateNeeded. If the JLists model changes we additionally remove our listeners from the old model. Likewise for the JList selectionModel.</source>
          <target state="translated">installUI 시간에 JList에 추가되는 PropertyChangeListener입니다. 레이아웃에 영향을 미치는 JList 속성의 값이 변경되면 updateLayoutStateNeeded에 약간을 설정합니다. JLists 모델이 변경되면 이전 모델에서 리스너를 추가로 제거합니다. JList selectionModel도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="79c5bed2e16f2a36efdbb26417f5d432d107c87f" translate="yes" xml:space="preserve">
          <source>The PropertyEditorManager can be used to locate a property editor for any given type name.</source>
          <target state="translated">PropertyEditorManager를 사용하여 지정된 유형 이름의 특성 편집기를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03f186ff2c81c37adab709c0e89d137a465a74c1" translate="yes" xml:space="preserve">
          <source>The PropertyEditorManager can be used to locate a property editor for any given type name. This property editor must support the java.beans.PropertyEditor interface for editing a given object.</source>
          <target state="translated">PropertyEditorManager를 사용하여 지정된 유형 이름의 특성 편집기를 찾을 수 있습니다. 이 프로퍼티 에디터는 지정된 객체를 편집하기위한 java.beans.PropertyEditor 인터페이스를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2d11ff6fce664d384fd5b4cb99275a3053adfd8" translate="yes" xml:space="preserve">
          <source>The PropertyEditorManager uses three techniques for locating an editor for a given type. First, it provides a registerEditor method to allow an editor to be specifically registered for a given type. Second it tries to locate a suitable class by adding &quot;Editor&quot; to the full qualified classname of the given type (e.g. &quot;foo.bah.FozEditor&quot;). Finally it takes the simple classname (without the package name) adds &quot;Editor&quot; to it and looks in a search-path of packages for a matching class.</source>
          <target state="translated">PropertyEditorManager는 주어진 유형에 대한 편집기를 찾는 데 세 가지 기술을 사용합니다. 먼저, 주어진 유형에 대해 편집기를 구체적으로 등록 할 수 있도록 registerEditor 메소드를 제공합니다. 두 번째로 주어진 유형의 정규화 된 클래스 이름에 &quot;Editor&quot;를 추가하여 적합한 클래스를 찾습니다 (예 : &quot;foo.bah.FozEditor&quot;). 마지막으로 패키지 이름이없는 간단한 클래스 이름을 사용하여 &quot;Editor&quot;를 추가하고 일치하는 클래스에 대한 패키지의 검색 경로를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e69e44faf76f952a5c9a199fdcebe3d843730632" translate="yes" xml:space="preserve">
          <source>The ProtectionDomain class encapsulates the characteristics of a domain, which encloses a set of classes whose instances are granted a set of permissions when being executed on behalf of a given set of Principals.</source>
          <target state="translated">ProtectionDomain 클래스는 도메인의 특성을 캡슐화합니다. 도메인의 특성은 지정된 사용자 집합을 대신하여 실행될 때 인스턴스에 권한 집합이 부여 된 클래스 집합을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="dc1a13b023d0705e0b7b2456d0489a32905a21a8" translate="yes" xml:space="preserve">
          <source>The REVERSE_LANDSCAPE value was added because some applications rotate landscape -90 degrees from portrait, rather than +90 degrees.</source>
          <target state="translated">REVERSE_LANDSCAPE 값은 일부 응용 프로그램이 가로에서 +90 도가 아닌 세로에서 -90도 회전하기 때문에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="6db7050862750f47a0efb63666d6d145e9e68f0e" translate="yes" xml:space="preserve">
          <source>The REVERSE_PORTRAIT value was added for use with the &lt;a href=&quot;finishings&quot;&gt;&lt;code&gt;Finishings&lt;/code&gt;&lt;/a&gt; attribute in cases where the opposite edge is desired for finishing a portrait document on simple finishing devices that have only one finishing position. Thus a &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; portrait document can be stapled &quot;on the right&quot; by a simple finishing device as is common use with some Middle Eastern languages such as Hebrew.</source>
          <target state="translated">마무리 위치가 하나 뿐인 간단한 마무리 장치에서 세로 문서를 마무리하기 위해 반대쪽 가장자리가 필요한 경우 &lt;a href=&quot;finishings&quot;&gt; &lt;code&gt;Finishings&lt;/code&gt; &lt;/a&gt; 속성 과 함께 사용하기 위해 REVERSE_PORTRAIT 값이 추가되었습니다 . 따라서 &lt;code&gt;&quot;text/plain&quot;&lt;/code&gt; 세로 문서는 히브리어와 같은 일부 중동 언어에서 일반적으로 사용되는 간단한 마무리 장치로 &quot;오른쪽에&quot;스테이플 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91344e6cf60e370413b5e41435a7570bf1602389" translate="yes" xml:space="preserve">
          <source>The RFC-1123 date-time formatter, such as 'Tue, 3 Jun 2008 11:05:30 GMT'.</source>
          <target state="translated">RFC-1123 날짜-시간 포맷터 (예 : '화, 3 6 월 2008 11:05:30 GMT').</target>
        </trans-unit>
        <trans-unit id="16ee6f4995441de74711ec4a94d4a5fada764a10" translate="yes" xml:space="preserve">
          <source>The RMI Activation mechanism has been deprecated and may be removed from a future version of the Java Platform. All of the classes and interfaces in this package have been terminally deprecated. The &lt;code&gt;rmid&lt;/code&gt; tool has also been terminally deprecated. There is no replacement for the RMI Activation mechanism in the Java Platform. Users of RMI Activation are advised to migrate their applications to other technologies.</source>
          <target state="translated">RMI 활성화 메커니즘은 더 이상 사용되지 않으며 Java 플랫폼의 차기 버전에서 제거 될 수 있습니다. 이 패키지의 모든 클래스와 인터페이스는 더 이상 사용되지 않습니다. &lt;code&gt;rmid&lt;/code&gt; 도구는 끝으로 더 이상 사용되지 않습니다. Java 플랫폼에는 RMI 활성화 메커니즘을 대체 할 수 없습니다. RMI 활성화 사용자는 응용 프로그램을 다른 기술로 마이그레이션하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7bd6b6f1f0aee47728916c5bade09680616f86e1" translate="yes" xml:space="preserve">
          <source>The RMI connector is a connector for the JMX Remote API that uses RMI to transmit client requests to a remote MBean server.</source>
          <target state="translated">RMI 커넥터는 RMI를 사용하여 클라이언트 요청을 원격 MBean 서버로 전송하는 JMX Remote API 용 커넥터입니다.</target>
        </trans-unit>
        <trans-unit id="82677ad477cb29bbe50c6cb2ef69c1f5f53feed1" translate="yes" xml:space="preserve">
          <source>The RMI connector is a connector for the JMX Remote API that uses RMI to transmit client requests to a remote MBean server. This package defines the classes that the user of an RMI connector needs to reference directly, for both the client and server sides. It also defines certain classes that the user will not usually reference directly, but that must be defined so that different implementations of the RMI connector can interoperate.</source>
          <target state="translated">RMI 커넥터는 RMI를 사용하여 클라이언트 요청을 원격 MBean 서버로 전송하는 JMX Remote API 용 커넥터입니다. 이 패키지는 클라이언트 및 서버 측 모두에 대해 RMI 커넥터 사용자가 직접 참조해야하는 클래스를 정의합니다. 또한 사용자가 일반적으로 직접 참조하지 않지만 RMI 커넥터의 다른 구현이 상호 운용 될 수 있도록 정의해야하는 특정 클래스를 정의합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
