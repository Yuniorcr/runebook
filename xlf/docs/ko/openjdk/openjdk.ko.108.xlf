<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="438b4e83ba3d5a96e855b8b912ebb9bba25ed63b" translate="yes" xml:space="preserve">
          <source>NodeChangeEvent.getChild()</source>
          <target state="translated">NodeChangeEvent.getChild()</target>
        </trans-unit>
        <trans-unit id="3e2ea238c6795a4b9a54d042a147af915f31888c" translate="yes" xml:space="preserve">
          <source>NodeChangeEvent.getParent()</source>
          <target state="translated">NodeChangeEvent.getParent()</target>
        </trans-unit>
        <trans-unit id="e162c705d90b58de729272201cf211706490c5ae" translate="yes" xml:space="preserve">
          <source>NodeChangeListener</source>
          <target state="translated">NodeChangeListener</target>
        </trans-unit>
        <trans-unit id="48aa86ccee944f5c610532277f2f7412ab089010" translate="yes" xml:space="preserve">
          <source>NodeChangeListener.childAdded()</source>
          <target state="translated">NodeChangeListener.childAdded()</target>
        </trans-unit>
        <trans-unit id="855d866b1076c758b296e8d9091cc98e214d0e30" translate="yes" xml:space="preserve">
          <source>NodeChangeListener.childRemoved()</source>
          <target state="translated">NodeChangeListener.childRemoved()</target>
        </trans-unit>
        <trans-unit id="6e41c8c0e7ca7b035e09b9c17dc505854e91d557" translate="yes" xml:space="preserve">
          <source>NodeDimensions</source>
          <target state="translated">NodeDimensions</target>
        </trans-unit>
        <trans-unit id="fa2c4125851f6d931bf8fdcfcc77370e04e78aeb" translate="yes" xml:space="preserve">
          <source>NodeDimensionsHandler</source>
          <target state="translated">NodeDimensionsHandler</target>
        </trans-unit>
        <trans-unit id="6d1452836a5e358d27de613d82985d8f206e4345" translate="yes" xml:space="preserve">
          <source>NodeFilter</source>
          <target state="translated">NodeFilter</target>
        </trans-unit>
        <trans-unit id="749f705e68c34826a7cc3dffa5cbbe3e73f820de" translate="yes" xml:space="preserve">
          <source>NodeIterator</source>
          <target state="translated">NodeIterator</target>
        </trans-unit>
        <trans-unit id="05a2a8746fe10231011b4d6850be527a41c1c732" translate="yes" xml:space="preserve">
          <source>NodeList</source>
          <target state="translated">NodeList</target>
        </trans-unit>
        <trans-unit id="337f57c0a2bef0738e912bbca11a9ae7ced157be" translate="yes" xml:space="preserve">
          <source>NodeSetData</source>
          <target state="translated">NodeSetData</target>
        </trans-unit>
        <trans-unit id="e8dd6e62135b63d4af2d51e03f5f8674c31c3a6d" translate="yes" xml:space="preserve">
          <source>Nodes in a preference tree are named in a similar fashion to directories in a hierarchical file system. Every node in a preference tree has a</source>
          <target state="translated">환경 설정 트리의 노드는 계층 파일 시스템의 디렉토리와 유사한 방식으로 이름이 지정됩니다. 기본 설정 트리의 모든 노드에는</target>
        </trans-unit>
        <trans-unit id="f22cc410bf8ce5d75d9f970cdbdbbd68965aa503" translate="yes" xml:space="preserve">
          <source>Non-ISO calendar systems must implement this field as per the definition above. It is just a simple zero-based count of elapsed months from the start of proleptic-year 0. All calendar systems with a full proleptic-year definition will have a year zero. If the calendar system has a minimum year that excludes year zero, then one must be extrapolated in order for this method to be defined.</source>
          <target state="translated">비 ISO 캘린더 시스템은 위 정의에 따라이 필드를 구현해야합니다. 이것은 proleptic-year 0이 시작된 후 경과 된 개월의 간단한 0부터 시작하는 개월 수입니다. 달력 시스템의 최소 연도가 0 년을 제외하면이 방법을 정의하려면 1 년을 외삽해야합니다.</target>
        </trans-unit>
        <trans-unit id="949db60b8f8345e41f783b56c70357e2562a01b0" translate="yes" xml:space="preserve">
          <source>Non-ISO calendar systems should implement this field as follows. If the calendar system has only two eras, before and after a fixed date, then the proleptic-year value must be the same as the year-of-era value for the later era, and increasingly negative for the earlier era. If the calendar system has more than two eras, then the proleptic-year value may be defined with any appropriate value, although defining it to be the same as ISO may be the best option.</source>
          <target state="translated">비 ISO 캘린더 시스템은 다음과 같이이 필드를 구현해야합니다. 달력 시스템에 고정 날짜 전후에 두 개의 기간 만있는 경우, proleptic-year 값은 후기의 연도 값과 같아야하며, 초기의 음수 값은 점점 높아야합니다. 달력 시스템에 세 개 이상의 기간이있는 경우 ISO와 동일하게 정의하는 것이 최선의 선택 일 수 있지만, 다 학년 값은 적절한 값으로 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15106cce29b52f2a8f8dfbc68e05221dfdc4d00e" translate="yes" xml:space="preserve">
          <source>Non-ISO calendar systems should implement this field to define eras. The value of the era that was active on 1970-01-01 (ISO) must be assigned the value 1. Earlier eras must have sequentially smaller values. Later eras must have sequentially larger values,</source>
          <target state="translated">비 ISO 캘린더 시스템은이 필드를 구현하여 시대를 정의해야합니다. 1970 년 1 월 1 일 (ISO)에 활성화 된 기간 값에는 값 1이 할당되어야합니다. 이전 기간은 순차적으로 더 작은 값을 가져야합니다. 나중에는 순차적으로 더 큰 값을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="399cafe8c7d182235eb09aa2d510cf2c91fd2eee" translate="yes" xml:space="preserve">
          <source>Non-ISO calendar systems should implement this field using the most recognized day-of-month values for users of the calendar system. Normally, this is a count of days from 1 to the length of the month.</source>
          <target state="translated">비 ISO 캘린더 시스템은 캘린더 시스템 사용자에게 가장 잘 알려진 월별 값을 사용하여이 필드를 구현해야합니다. 일반적으로 1에서 월까지의 일 수입니다.</target>
        </trans-unit>
        <trans-unit id="9fa751a93e1bbb62975d7f740370f3551da34d53" translate="yes" xml:space="preserve">
          <source>Non-ISO calendar systems should implement this field using the most recognized day-of-year values for users of the calendar system. Normally, this is a count of days from 1 to the length of the year.</source>
          <target state="translated">ISO 이외의 달력 시스템은 달력 시스템 사용자에게 가장 잘 알려진 년 값을 사용하여이 필드를 구현해야합니다. 일반적으로 1에서 연도까지의 일 수입니다.</target>
        </trans-unit>
        <trans-unit id="6ced672a6030f1edd4e70f42e15ab7c0a7c4d751" translate="yes" xml:space="preserve">
          <source>Non-ISO calendar systems should implement this field using the most recognized month-of-year values for users of the calendar system. Normally, this is a count of months starting from 1.</source>
          <target state="translated">비 ISO 캘린더 시스템은 캘린더 시스템 사용자에게 가장 잘 알려진 월별 값을 사용하여이 필드를 구현해야합니다. 일반적으로 이것은 1부터 시작하여 개월 수입니다.</target>
        </trans-unit>
        <trans-unit id="3a1850bd70a3c80d5d5bf7a5f8472a3564db8025" translate="yes" xml:space="preserve">
          <source>Non-ISO calendar systems should implement this field using the most recognized year-of-era value for users of the calendar system. Since most calendar systems have only two eras, the year-of-era numbering approach will typically be the same as that used by the ISO calendar system. The year-of-era value should typically always be positive, however this is not required.</source>
          <target state="translated">비 ISO 캘린더 시스템은 캘린더 시스템 사용자에게 가장 잘 알려진 연도 값을 사용하여이 필드를 구현해야합니다. 대부분의 달력 시스템에는 시대가 두 개뿐이므로 연도 번호 매기기 방식은 일반적으로 ISO 달력 시스템에서 사용하는 방식과 동일합니다. 연도 값은 일반적으로 항상 양수 여야하지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8f90a6758ea2e6415fe86c86a42e67e2c9b0a220" translate="yes" xml:space="preserve">
          <source>Non-baseline &lt;code&gt;ParallelGroup&lt;/code&gt;</source>
          <target state="translated">기준이 아닌 &lt;code&gt;ParallelGroup&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7dbb736214ec191af9372363107db53b0918a17" translate="yes" xml:space="preserve">
          <source>Non-default values for lifetime cannot always be honored by the underlying mechanism, thus applications should be prepared to call &lt;a href=&quot;gsscontext#getLifetime()&quot;&gt;&lt;code&gt;getLifetime&lt;/code&gt;&lt;/a&gt; on the returned context.</source>
          <target state="translated">수명에 대한 기본값이 아닌 값은 기본 메커니즘에서 항상 &lt;a href=&quot;gsscontext#getLifetime()&quot;&gt; &lt;code&gt;getLifetime&lt;/code&gt; &lt;/a&gt; 할 수 없으므로 응용 프로그램은 getLifetime 을 호출 할 준비가되어 있어야합니다. 반환 된 컨텍스트에서 .</target>
        </trans-unit>
        <trans-unit id="e30e6d90707c7f607eff59f63129bf7ade3d8f6f" translate="yes" xml:space="preserve">
          <source>Non-default values for lifetime cannot always be honored by the underlying mechanisms, thus applications should be prepared to call &lt;a href=&quot;gsscredential#getRemainingLifetime()&quot;&gt;&lt;code&gt;getRemainingLifetime&lt;/code&gt;&lt;/a&gt; on the returned credential.</source>
          <target state="translated">수명에 대한 기본값이 아닌 값은 기본 메커니즘이 항상 적용 할 수 없으므로 응용 프로그램은 &lt;a href=&quot;gsscredential#getRemainingLifetime()&quot;&gt; &lt;code&gt;getRemainingLifetime&lt;/code&gt; &lt;/a&gt; 을 호출 할 준비가되어 있어야합니다. 반환 된 자격 증명에 대해 .</target>
        </trans-unit>
        <trans-unit id="3a5a3468bbd58941e7ec9acc7ba2bb862dfd8e94" translate="yes" xml:space="preserve">
          <source>Non-exclusively acquires the lock if it is available within the given time and the current thread has not been interrupted.</source>
          <target state="translated">주어진 시간 내에 잠금을 사용할 수 있고 현재 스레드가 중단되지 않은 경우 비 배타적으로 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="32dce6e773cd7f483be084db84d4b393cd29ae9a" translate="yes" xml:space="preserve">
          <source>Non-exclusively acquires the lock if it is available within the given time and the current thread has not been interrupted. Behavior under timeout and interruption matches that specified for method &lt;a href=&quot;lock#tryLock(long,java.util.concurrent.TimeUnit)&quot;&gt;&lt;code&gt;Lock.tryLock(long,TimeUnit)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 시간 내에 잠금을 사용할 수 있고 현재 스레드가 중단되지 않은 경우 비 배타적으로 잠금을 획득합니다. &lt;a href=&quot;lock#tryLock(long,java.util.concurrent.TimeUnit)&quot;&gt; &lt;code&gt;Lock.tryLock(long,TimeUnit)&lt;/code&gt; &lt;/a&gt; 메서드에 대해 지정된 시간 초과 및 인터럽트 일치 하에서의 동작 .</target>
        </trans-unit>
        <trans-unit id="5255fb9a432fe09f5f2a62f82310fa440eadd993" translate="yes" xml:space="preserve">
          <source>Non-exclusively acquires the lock if it is available within the given time and the current thread has not been interrupted. Behavior under timeout and interruption matches that specified for method &lt;a href=&quot;lock#tryLock-long-java.util.concurrent.TimeUnit-&quot;&gt;&lt;code&gt;Lock.tryLock(long,TimeUnit)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 시간 내에 사용 가능하고 현재 스레드가 인터럽트되지 않은 경우 비 독점적으로 잠금을 획득합니다. 제한 시간 초과 및 인터럽트 일치 동작은 &lt;a href=&quot;lock#tryLock-long-java.util.concurrent.TimeUnit-&quot;&gt; &lt;code&gt;Lock.tryLock(long,TimeUnit)&lt;/code&gt; &lt;/a&gt; 메소드에 지정된 것과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="9271dd0ca3f131305e4de250a63fc130220d3016" translate="yes" xml:space="preserve">
          <source>Non-exclusively acquires the lock if it is immediately available.</source>
          <target state="translated">즉시 사용 가능한 경우 비 독점적으로 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="5b45244bae14c4e409cd9329b228dda406563526" translate="yes" xml:space="preserve">
          <source>Non-exclusively acquires the lock, blocking if necessary until available or the current thread is interrupted.</source>
          <target state="translated">비 독점적으로 잠금을 획득하여 사용 가능하거나 현재 스레드가 인터럽트 될 때까지 필요한 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="c663e11f7b04200f529d63849e9abd41e1bc1dd6" translate="yes" xml:space="preserve">
          <source>Non-exclusively acquires the lock, blocking if necessary until available or the current thread is interrupted. Behavior under interruption matches that specified for method &lt;a href=&quot;lock#lockInterruptibly()&quot;&gt;&lt;code&gt;Lock.lockInterruptibly()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 독점적으로 잠금을 획득하여 사용 가능하거나 현재 스레드가 인터럽트 될 때까지 필요한 경우 차단합니다. 인터럽트시 동작이 &lt;a href=&quot;lock#lockInterruptibly()&quot;&gt; &lt;code&gt;Lock.lockInterruptibly()&lt;/code&gt; &lt;/a&gt; 메서드에 지정된 것과 일치합니다. .</target>
        </trans-unit>
        <trans-unit id="da8dd40ff4ffaeed888e99643a71f1a25ef34f00" translate="yes" xml:space="preserve">
          <source>Non-exclusively acquires the lock, blocking if necessary until available or the current thread is interrupted. Behavior under interruption matches that specified for method &lt;a href=&quot;lock#lockInterruptibly--&quot;&gt;&lt;code&gt;Lock.lockInterruptibly()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 독점적으로 잠금을 획득하여 필요한 경우 사용 가능하거나 현재 스레드가 중단 될 때까지 차단합니다. 잠금 상태의 동작은 &lt;a href=&quot;lock#lockInterruptibly--&quot;&gt; &lt;code&gt;Lock.lockInterruptibly()&lt;/code&gt; &lt;/a&gt; 메소드에 지정된 것과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="6edfabd899e51d161fc2a1dc923b17958bdbff88" translate="yes" xml:space="preserve">
          <source>Non-exclusively acquires the lock, blocking if necessary until available.</source>
          <target state="translated">비 독점적으로 잠금을 획득하고 필요한 경우 사용 가능할 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="c6d7195469d628ce40cf2ce1335cdc397b62b0f3" translate="yes" xml:space="preserve">
          <source>Non-heap memory type.</source>
          <target state="translated">힙이 아닌 메모리 유형.</target>
        </trans-unit>
        <trans-unit id="c71ccfc6eb3d3450456d5bcab2b1d125aa2c1922" translate="yes" xml:space="preserve">
          <source>Non-interference</source>
          <target state="translated">Non-interference</target>
        </trans-unit>
        <trans-unit id="ce4b320c6d46f058245e7b992fd740fbf149dff1" translate="yes" xml:space="preserve">
          <source>Non-null referral information related to this referral.</source>
          <target state="translated">이 추천과 관련된 null이 아닌 추천 정보입니다.</target>
        </trans-unit>
        <trans-unit id="d0ae80262821e68eb1e50306c183e3350f3e4d48" translate="yes" xml:space="preserve">
          <source>Non0Digit</source>
          <target state="translated">Non0Digit</target>
        </trans-unit>
        <trans-unit id="aea43c74a1129f095670cc50d3dc4376e1328a40" translate="yes" xml:space="preserve">
          <source>NonASCIIDigit</source>
          <target state="translated">NonASCIIDigit</target>
        </trans-unit>
        <trans-unit id="78b7213d6517f5ebedb25e0b1b14d65f7d5ca13c" translate="yes" xml:space="preserve">
          <source>NonAsciiDigit</source>
          <target state="translated">NonAsciiDigit</target>
        </trans-unit>
        <trans-unit id="39b74a1ceda20dd15f9f7827e3db15c5965e22fb" translate="yes" xml:space="preserve">
          <source>NonNumber</source>
          <target state="translated">NonNumber</target>
        </trans-unit>
        <trans-unit id="b955712476e3ef475a82b5848e487f258bd1f694" translate="yes" xml:space="preserve">
          <source>NonReadableChannelException</source>
          <target state="translated">NonReadableChannelException</target>
        </trans-unit>
        <trans-unit id="78f4e1ed8736d29ffa9debaf731e70b2410fc9e3" translate="yes" xml:space="preserve">
          <source>NonWritableChannelException</source>
          <target state="translated">NonWritableChannelException</target>
        </trans-unit>
        <trans-unit id="1179ca48470076675d205adcff73d6d61f15f34a" translate="yes" xml:space="preserve">
          <source>Noncharacter_Code_Point</source>
          <target state="translated">Noncharacter_Code_Point</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="5f0f3618800300f866ac08f67dde85709c3fcbec" translate="yes" xml:space="preserve">
          <source>None of the methods in this interface accept null as a valid value for a parameter that is a name or a name component. Likewise, methods that return a name or name component never return null.</source>
          <target state="translated">이 인터페이스의 어떤 메소드도 이름 또는 이름 구성 요소 인 매개 변수의 유효한 값으로 널을 허용하지 않습니다. 마찬가지로 이름 또는 이름 구성 요소를 반환하는 메서드는 null을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cd9bb3129d031be8627a8209858c7018e119fd0" translate="yes" xml:space="preserve">
          <source>None of these values provide means to produce uncollated sheets within a document, i.e., where multiple copies of sheet</source>
          <target state="translated">이러한 값 중 어느 것도 문서 내에서 한 부씩 인쇄되지 않은 시트를 생성하는 수단을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="599d1437fb1d4b20f8fcb3f40ba8518b2fd089a3" translate="yes" xml:space="preserve">
          <source>NoninvertibleTransformException</source>
          <target state="translated">NoninvertibleTransformException</target>
        </trans-unit>
        <trans-unit id="8b4dcbb62bf2292984dac9a5abfb87194643aab1" translate="yes" xml:space="preserve">
          <source>Normal forward keyboard traversal</source>
          <target state="translated">일반적인 앞으로 키보드 순회</target>
        </trans-unit>
        <trans-unit id="c900cf9580c43545a2e0ec64d0cf103b09a4d486" translate="yes" xml:space="preserve">
          <source>Normal integer division operates under the round to zero rounding mode (truncation). This operation instead acts under the round toward negative infinity (floor) rounding mode. The floor rounding mode gives different results from truncation when the exact result is negative.</source>
          <target state="translated">일반 정수 나눗셈은 0으로 반올림 모드 (절단)에서 작동합니다. 대신이 작업은 라운드에서 음의 무한대 (바닥) 반올림 모드로 작동합니다. 바닥 반올림 모드는 정확한 결과가 음수 일 때 잘림과 다른 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4624b02f6df07f5a4e47c2aba9878f777b6506eb" translate="yes" xml:space="preserve">
          <source>Normal integer division operates under the round to zero rounding mode (truncation). This operation instead acts under the round toward negative infinity (floor) rounding mode. The floor rounding mode gives different results than truncation when the exact result is negative.</source>
          <target state="translated">정규 정수 나누기는 반올림에서 제로 반올림 모드 (잘림)로 작동합니다. 이 작업은 대신 음의 무한대 (바닥) 반올림 모드를 향해 반올림됩니다. 바닥 반올림 모드는 정확한 결과가 음수 일 때 절단과 다른 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="847219ace38d1ce9cf1f24e5baca099e76de3801" translate="yes" xml:space="preserve">
          <source>Normal or intermediate quality on the printer.</source>
          <target state="translated">프린터의 정상 또는 중간 품질.</target>
        </trans-unit>
        <trans-unit id="06c961dcd87569238afc936e14968b6aa46a9495" translate="yes" xml:space="preserve">
          <source>Normal resolution of names in context operations always follow links. Resolution of the link name itself may cause resolution to pass through other links. This gives rise to the possibility of a cycle of links whose resolution could not terminate normally. As a simple means to avoid such non-terminating resolutions, service providers may define limits on the number of links that may be involved in any single operation invoked by the caller.</source>
          <target state="translated">컨텍스트 작업에서 이름의 일반적인 확인은 항상 링크를 따릅니다. 링크 이름 자체가 해결되면 다른 링크를 통해 해결 될 수 있습니다. 이로 인해 분석이 정상적으로 종료되지 않은 링크주기가 발생할 수 있습니다. 이러한 비 종료 해상도를 피하기위한 간단한 수단으로, 서비스 제공 업체는 호출자가 호출 한 단일 작업에 관련 될 수있는 링크 수에 제한을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f50f1dd677922b67e6b169c75849475263a658f" translate="yes" xml:space="preserve">
          <source>Normal reverse keyboard traversal</source>
          <target state="translated">일반적인 역방향 키보드 순회</target>
        </trans-unit>
        <trans-unit id="dccd5e9ee5a710fa63bb6bcd6f53871336293bdd" translate="yes" xml:space="preserve">
          <source>Normal writes are not affected by this method, only writes performed using &lt;code&gt;ImageWriter.replacePixels&lt;/code&gt;. For such writes, the offset specified is within the output stream image whose pixels are being modified.</source>
          <target state="translated">일반 쓰기는이 메소드의 영향을받지 않으며 &lt;code&gt;ImageWriter.replacePixels&lt;/code&gt; 를 사용하여 쓰기 만 수행 합니다. 이러한 쓰기에 대해 지정된 오프셋은 픽셀이 수정되는 출력 스트림 이미지 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b70bdaf7cbd091c5650ead3437906aee0b871da2" translate="yes" xml:space="preserve">
          <source>Normal, with one valid offset. For the vast majority of the year, the normal case applies, where there is a single valid offset for the local date-time.</source>
          <target state="translated">하나의 유효한 오프셋이있는 보통입니다. 일년 중 대부분의 경우, 현지 날짜-시간에 대해 유효한 단일 오프셋이있는 일반적인 경우가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b8c54e5e1e867a54e9d75697c450f4be835f910e" translate="yes" xml:space="preserve">
          <source>Normalization</source>
          <target state="translated">Normalization</target>
        </trans-unit>
        <trans-unit id="876a2974753a45d3672d5814829c5070d34b7add" translate="yes" xml:space="preserve">
          <source>Normalize a sequence of char values.</source>
          <target state="translated">일련의 char 값을 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="39354cea243e3d60c7627d62b940772e4831701e" translate="yes" xml:space="preserve">
          <source>Normalize a sequence of char values. The sequence will be normalized according to the specified normalization from.</source>
          <target state="translated">일련의 문자 값을 정규화합니다. 시퀀스는 지정된 정규화에 따라 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="322db090188c52b6e9033f14e22dae4e836689ea" translate="yes" xml:space="preserve">
          <source>Normalize this instance to UTC.</source>
          <target state="translated">이 인스턴스를 UTC로 정규화하십시오.</target>
        </trans-unit>
        <trans-unit id="f12eb5e34450ab78e740fe496c803d12964c3c07" translate="yes" xml:space="preserve">
          <source>Normalized newline between</source>
          <target state="translated">사이의 정규화 된 개행</target>
        </trans-unit>
        <trans-unit id="f4b126cd68b1eba9b799b0ffccc1898e8bfe924f" translate="yes" xml:space="preserve">
          <source>Normalizer</source>
          <target state="translated">Normalizer</target>
        </trans-unit>
        <trans-unit id="24c617d3fa319eaa96d9448d56a0d1dbda9aa6de" translate="yes" xml:space="preserve">
          <source>Normalizer.Form</source>
          <target state="translated">Normalizer.Form</target>
        </trans-unit>
        <trans-unit id="b058cf1c5fae3ad09c947c38d45802b1c36cbfc0" translate="yes" xml:space="preserve">
          <source>Normalizer.Form.valueOf()</source>
          <target state="translated">Normalizer.Form.valueOf()</target>
        </trans-unit>
        <trans-unit id="a996950aecd0be39e23f2392d76449f5ad39f478" translate="yes" xml:space="preserve">
          <source>Normalizer.Form.values()</source>
          <target state="translated">Normalizer.Form.values()</target>
        </trans-unit>
        <trans-unit id="89833c7f445e9357f723e0be088e2cdcfcd18191" translate="yes" xml:space="preserve">
          <source>Normalizer.isNormalized()</source>
          <target state="translated">Normalizer.isNormalized()</target>
        </trans-unit>
        <trans-unit id="746271d3b1527dc5b2e6d5bf1c63b603440bcff9" translate="yes" xml:space="preserve">
          <source>Normalizer.normalize()</source>
          <target state="translated">Normalizer.normalize()</target>
        </trans-unit>
        <trans-unit id="5790f14c06c658a24598260a8d8859e89afb87f7" translate="yes" xml:space="preserve">
          <source>Normalizes the tab runs.</source>
          <target state="translated">탭 실행을 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="051f44cd72eba6a60b0f297b412eb568fe15ac53" translate="yes" xml:space="preserve">
          <source>Normalizes the time-zone ID, returning a &lt;code&gt;ZoneOffset&lt;/code&gt; where possible.</source>
          <target state="translated">시간대 ID를 정규화하여 가능한 경우 &lt;code&gt;ZoneOffset&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="aaa40127b109d11c33fb8e31008f5513b295d742" translate="yes" xml:space="preserve">
          <source>Normalizes this URI's path.</source>
          <target state="translated">이 URI 경로를 표준화합니다.</target>
        </trans-unit>
        <trans-unit id="da1a4c1be29cd2be1d1e2e73be3569102efca42f" translate="yes" xml:space="preserve">
          <source>Normally PropertyChangeEvents are accompanied by the name and the old and new value of the changed property. If the new value is a primitive type (such as int or boolean) it must be wrapped as the corresponding java.lang.* Object type (such as Integer or Boolean).</source>
          <target state="translated">일반적으로 PropertyChangeEvents에는 변경된 속성의 이름과 이전 값과 새 값이 동반됩니다. 새 값이 기본 유형 (예 : int 또는 boolean) 인 경우 해당 java.lang. * 오브젝트 유형 (예 : 정수 또는 부울)으로 랩핑되어야합니다.</target>
        </trans-unit>
        <trans-unit id="25f0bf8218804aa1dda263d9fcb3faacf188fca7" translate="yes" xml:space="preserve">
          <source>Normally PropertyEditors will be found using the PropertyEditorManager.</source>
          <target state="translated">일반적으로 PropertyEditor는 PropertyEditorManager를 사용하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9befea0be7f5f9c0c5a8746a177300a86819cd56" translate="yes" xml:space="preserve">
          <source>Normally PropertyEditors will be found using the PropertyEditorManager. However if for some reason you want to associate a particular PropertyEditor with a given property, then you can do it with this method.</source>
          <target state="translated">일반적으로 PropertyEditor는 PropertyEditorManager를 사용하여 찾을 수 있습니다. 그러나 어떤 이유로 특정 PropertyEditor를 지정된 특성과 연관시키려는 경우이 메소드로이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23c75f898e1b84ce94a236fbf6863d2bd52f87aa" translate="yes" xml:space="preserve">
          <source>Normally a write-lock is held on the Document while the children are being changed, which keeps the rendering and layout threads safe. The exception to this is when the view is initialized to represent an existing element (via this method), so it is synchronized to exclude preferenceChanged while we are initializing.</source>
          <target state="translated">일반적으로 자식이 변경되는 동안 문서에 쓰기 잠금이 유지되어 렌더링 및 레이아웃 스레드를 안전하게 유지합니다. 이에 대한 예외는 뷰가 기존 요소 (이 메서드를 통해)를 나타내도록 초기화 된 경우이므로 초기화하는 동안 preferencesChanged를 제외하도록 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="0ccb3dd246c85fddc131b9c82267e86ea1d2e647" translate="yes" xml:space="preserve">
          <source>Normally causes every selected item in the object to be selected if the object supports multiple selections.</source>
          <target state="translated">개체가 다중 선택을 지원하는 경우 일반적으로 개체에서 선택한 모든 항목이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="d4fa0fef1d1b7bc3427b3ff352b7dba94153bcb4" translate="yes" xml:space="preserve">
          <source>Normally causes every selected item in the object to be selected if the object supports multiple selections. This method makes no sense in a menu bar, and so does nothing.</source>
          <target state="translated">개체가 다중 선택을 지원하는 경우 일반적으로 개체에서 선택한 모든 항목이 선택됩니다. 이 방법은 메뉴 표시 줄에서 의미가 없으며 아무 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="65e73dd302df1231b48586866930db8bd65928a3" translate="yes" xml:space="preserve">
          <source>Normally event sources are multicast.</source>
          <target state="translated">일반적으로 이벤트 소스는 멀티 캐스트입니다.</target>
        </trans-unit>
        <trans-unit id="861c4c8d1f0c7f599c5dc7d4dba828f0571beea7" translate="yes" xml:space="preserve">
          <source>Normally event sources are multicast. However there are some exceptions that are strictly unicast.</source>
          <target state="translated">일반적으로 이벤트 소스는 멀티 캐스트입니다. 그러나 엄격하게 유니 캐스트되는 일부 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c8db891ad10d5eddce51f2cfe21e6e820e9096a" translate="yes" xml:space="preserve">
          <source>Normally streams should be used rather than readers or writers, for both the Source and Result, since readers and writers already have the encoding established to and from the internal Unicode format. However, there are times when it is useful to write to a character stream, such as when using a StringWriter in order to write to a String, or in the case of reading source XML from a StringReader.</source>
          <target state="translated">일반적으로 소스와 결과 모두에 대해 리더 나 작성자가 아닌 스트림을 사용해야합니다. 리더와 작성자는 이미 내부 유니 코드 형식에 대해 설정된 인코딩을 가지고 있기 때문입니다. 그러나 문자열에 쓰기 위해 StringWriter를 사용하거나 StringReader에서 소스 XML을 읽는 경우와 같이 문자 스트림에 쓰는 것이 유용한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdff3f207e07b1aa8666fa18588cb6cfc2672b39" translate="yes" xml:space="preserve">
          <source>Normally the &quot;%u&quot; unique field is set to 0. However, if the &lt;code&gt;FileHandler&lt;/code&gt; tries to open the filename and finds the file is currently in use by another process it will increment the unique number field and try again. This will be repeated until &lt;code&gt;FileHandler&lt;/code&gt; finds a file name that is not currently in use. If there is a conflict and no &quot;%u&quot; field has been specified, it will be added at the end of the filename after a dot. (This will be after any automatically added generation number.)</source>
          <target state="translated">일반적으로 &quot;% u&quot;고유 필드는 0으로 설정됩니다. 그러나 &lt;code&gt;FileHandler&lt;/code&gt; 가 파일 이름을 열려고 시도하고 파일이 현재 다른 프로세스에서 사용중인 것을 발견하면 고유 번호 필드를 증가시키고 다시 시도합니다. &lt;code&gt;FileHandler&lt;/code&gt; 가 현재 사용 중이 아닌 파일 이름을 찾을 때까지이 과정이 반복됩니다 . 충돌이 있고 &quot;% u&quot;필드를 지정하지 않으면 파일 이름 끝에 점 다음에 추가됩니다. (이는 자동으로 추가 된 세대 번호 이후입니다.)</target>
        </trans-unit>
        <trans-unit id="a17c5646187cc1d45a9908f275983da5ec0d0d41" translate="yes" xml:space="preserve">
          <source>Normally the values of &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; are non-negative integers. The constructors that allow you to create a dimension do not prevent you from setting a negative value for these properties. If the value of &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; is negative, the behavior of some methods defined by other objects is undefined.</source>
          <target state="translated">일반적으로 &lt;code&gt;width&lt;/code&gt; 와 &lt;code&gt;height&lt;/code&gt; 의 값은 음이 아닌 정수입니다. 차원을 만들 수있는 생성자는 이러한 속성에 대해 음수 값을 설정하는 것을 방지하지 않습니다. &lt;code&gt;width&lt;/code&gt; 또는 &lt;code&gt;height&lt;/code&gt; 의 값이 이 음수이면 다른 개체에서 정의한 일부 메서드의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e875bba746855d9c053bda5e14102a3cf82de648" translate="yes" xml:space="preserve">
          <source>Normally this &lt;code&gt;Handler&lt;/code&gt; simply stores incoming &lt;code&gt;LogRecords&lt;/code&gt; into its memory buffer and discards earlier records. This buffering is very cheap and avoids formatting costs. On certain trigger conditions, the &lt;code&gt;MemoryHandler&lt;/code&gt; will push out its current buffer contents to a target &lt;code&gt;Handler&lt;/code&gt;, which will typically publish them to the outside world.</source>
          <target state="translated">일반적으로이 &lt;code&gt;Handler&lt;/code&gt; 는 들어오는 &lt;code&gt;LogRecords&lt;/code&gt; 를 메모리 버퍼에 저장하고 이전 레코드를 버립니다. 이 버퍼링은 매우 저렴하며 포맷 비용을 피합니다. 특정 트리거 조건에서 &lt;code&gt;MemoryHandler&lt;/code&gt; 는 현재 버퍼 내용을 대상 &lt;code&gt;Handler&lt;/code&gt; 로 푸시하여 일반적으로 외부 세계에 공개합니다.</target>
        </trans-unit>
        <trans-unit id="81f3b15421b7e0e0e43d5c9f1cdac482d29d3f7b" translate="yes" xml:space="preserve">
          <source>Normally this method will not be called.</source>
          <target state="translated">일반적으로이 메서드는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28945295b05df426e85919f6c409c23a5287feca" translate="yes" xml:space="preserve">
          <source>Normally this method will not be called. If it is, it tries to determine the appropriate parent from the desktopIcon of the frame. Will remove the desktopIcon from its parent if it successfully adds the frame.</source>
          <target state="translated">일반적으로이 메서드는 호출되지 않습니다. 그렇다면 프레임의 desktopIcon에서 적절한 부모를 결정하려고합니다. 프레임을 성공적으로 추가하면 부모에서 desktopIcon을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="5fe4257003e2ec58e3b59a9ad3c926854f100dd0" translate="yes" xml:space="preserve">
          <source>Normally when storing the size and position of entries, one would choose between storing the sizes or storing their positions instead. The two common operations that are needed during rendering are: &lt;code&gt;getIndex(position)&lt;/code&gt; and &lt;code&gt;setSize(index, size)&lt;/code&gt;. Whichever choice of internal format is made one of these operations is costly when the number of entries becomes large. If sizes are stored, finding the index of the entry that encloses a particular position is linear in the number of entries. If positions are stored instead, setting the size of an entry at a particular index requires updating the positions of the affected entries, which is also a linear calculation.</source>
          <target state="translated">일반적으로 항목의 크기와 위치를 저장할 때 크기를 저장하거나 위치를 저장하는 것 중에서 선택합니다. 렌더링 중에 필요한 두 가지 일반적인 작업은 &lt;code&gt;getIndex(position)&lt;/code&gt; 및 &lt;code&gt;setSize(index, size)&lt;/code&gt; 입니다. 어떤 내부 형식을 선택하든 이러한 작업 중 하나를 선택하면 항목 수가 많아지면 비용이 많이 듭니다. 크기가 저장된 경우 특정 위치를 포함하는 항목의 색인을 찾는 것은 항목 수에서 선형입니다. 위치가 대신 저장되는 경우 특정 인덱스에서 항목의 크기를 설정하려면 영향을받는 항목의 위치를 ​​업데이트해야하며 이는 선형 계산이기도합니다.</target>
        </trans-unit>
        <trans-unit id="46e6e17a66af9f3bb97f65b54fe592dd0a69da47" translate="yes" xml:space="preserve">
          <source>Normally, SAX drivers would push a new context at the beginning of each XML element. Then they perform a first pass over the attributes to process all namespace declarations, making &lt;em&gt;ContentHandler.startPrefixMapping()&lt;/em&gt; callbacks. Then a second pass is made, to determine the namespace-qualified names for all attributes and for the element name. Finally all the information for the &lt;em&gt;ContentHandler.startElement()&lt;/em&gt; callback is available, so it can then be made.</source>
          <target state="translated">일반적으로 SAX 드라이버는 각 XML 요소의 시작 부분에 새 컨텍스트를 푸시합니다. 그런 다음 속성에 대한 첫 번째 전달을 수행하여 모든 네임 스페이스 선언을 처리하여 &lt;em&gt;ContentHandler.startPrefixMapping ()&lt;/em&gt; 콜백을 만듭니다. 그런 다음 모든 속성 및 요소 이름에 대한 네임 스페이스 규정 이름을 결정하는 두 번째 단계가 수행됩니다. 마지막으로 &lt;em&gt;ContentHandler.startElement ()&lt;/em&gt; 콜백에 대한 모든 정보를 사용할 수 있으므로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6c838279f3a91ce7a951f75b279b8bda3e9c25e" translate="yes" xml:space="preserve">
          <source>Normally, a program should change a scroll bar's maximum value only by calling &lt;code&gt;setValues&lt;/code&gt;. The &lt;code&gt;setValues&lt;/code&gt; method simultaneously and synchronously sets the minimum, maximum, visible amount, and value properties of a scroll bar, so that they are mutually consistent.</source>
          <target state="translated">일반적으로 프로그램은 &lt;code&gt;setValues&lt;/code&gt; 를 호출하여 스크롤 막대의 최대 값을 변경해야합니다 . &lt;code&gt;setValues&lt;/code&gt; 에 있어서 동시에 동기가 서로 일치되도록, 최소, 최대, 가시 량, 및 스크롤 바의 값의 특성을 설정한다.</target>
        </trans-unit>
        <trans-unit id="f576faa6f2053ce331d641382136b51006de7f87" translate="yes" xml:space="preserve">
          <source>Normally, a program should change a scroll bar's minimum value only by calling &lt;code&gt;setValues&lt;/code&gt;. The &lt;code&gt;setValues&lt;/code&gt; method simultaneously and synchronously sets the minimum, maximum, visible amount, and value properties of a scroll bar, so that they are mutually consistent.</source>
          <target state="translated">일반적으로 프로그램은 &lt;code&gt;setValues&lt;/code&gt; 를 호출하여 스크롤 막대의 최소값을 변경해야합니다 . &lt;code&gt;setValues&lt;/code&gt; 에 있어서 동시에 동기가 서로 일치되도록, 최소, 최대, 가시 량, 및 스크롤 바의 값의 특성을 설정한다.</target>
        </trans-unit>
        <trans-unit id="ef47f365dc358a1ff378d9826f7e6dc49fb0e0b0" translate="yes" xml:space="preserve">
          <source>Normally, a program should change a scroll bar's value only by calling &lt;code&gt;setValues&lt;/code&gt;. The &lt;code&gt;setValues&lt;/code&gt; method simultaneously and synchronously sets the minimum, maximum, visible amount, and value properties of a scroll bar, so that they are mutually consistent.</source>
          <target state="translated">일반적으로 프로그램은 &lt;code&gt;setValues&lt;/code&gt; 를 호출하여 스크롤 막대의 값을 변경해야합니다 . &lt;code&gt;setValues&lt;/code&gt; 에 있어서 동시에 동기가 서로 일치되도록, 최소, 최대, 가시 량, 및 스크롤 바의 값의 특성을 설정한다.</target>
        </trans-unit>
        <trans-unit id="595d678bd982d55a1e4f677e9228945c2082f4ce" translate="yes" xml:space="preserve">
          <source>Normally, only a subset of these will actually be enabled by default, since this list may include cipher suites which do not meet quality of service requirements for those defaults. Such cipher suites are useful in specialized applications.</source>
          <target state="translated">이 목록에는 이러한 기본값에 대한 서비스 품질 요구 사항을 충족하지 않는 암호화 제품군이 포함될 수 있으므로 일반적으로 이들 중 일부만 실제로 기본적으로 활성화됩니다. 이러한 암호 제품군은 특수 응용 프로그램에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0c793af047623ee7a25cf71950eabfc58a729e5b" translate="yes" xml:space="preserve">
          <source>Normally, parser writers will not use this class, since it is more efficient to provide location information only when requested, rather than constantly updating a Locator object.</source>
          <target state="translated">일반적으로 파서 작성자는이 클래스를 사용하지 않습니다. 로케이터 개체를 지속적으로 업데이트하는 것보다 요청 된 경우에만 위치 정보를 제공하는 것이 더 효율적이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="91b850cffc7c42eafec818b7938b03232e24ba19" translate="yes" xml:space="preserve">
          <source>Normally, result tree serialization escapes&amp;amp; and &amp;lt; (and possibly other characters) when outputting text nodes. This ensures that the output is well-formed XML. However, it is sometimes convenient to be able to produce output that is almost, but not quite well-formed XML; for example, the output may include ill-formed sections that will be transformed into well-formed XML by a subsequent non-XML aware process. If a processing instruction is sent with this name, serialization should be output without any escaping.</source>
          <target state="translated">일반적으로 결과 트리 직렬화는 텍스트 노드를 출력 할 때 &amp;amp; 및 &amp;lt;(및 가능한 다른 문자)를 이스케이프합니다. 이렇게하면 출력이 올바른 형식의 XML이됩니다. 그러나 때로는 잘 구성된 XML은 아니지만 거의 출력을 생성 할 수있는 것이 편리합니다. 예를 들어, 출력에는 후속 비 XML 인식 프로세스에 의해 올바른 형식의 XML로 변환 될 잘못된 형식의 섹션이 포함될 수 있습니다. 이 이름으로 처리 명령이 전송되면 이스케이프없이 직렬화가 출력되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a0e0eb11650c8c550f0089caf540613fef9d88e9" translate="yes" xml:space="preserve">
          <source>Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the &lt;code&gt;CLASSPATH&lt;/code&gt; environment variable.</source>
          <target state="translated">일반적으로 Java 가상 머신은 플랫폼에 따라 로컬 파일 시스템에서 클래스를로드합니다. 예를 들어, UNIX 시스템에서 가상 머신은 &lt;code&gt;CLASSPATH&lt;/code&gt; 환경 변수로 정의 된 디렉토리에서 클래스를로드 합니다.</target>
        </trans-unit>
        <trans-unit id="c3a8536654510e2d89585792ce836aba25584e40" translate="yes" xml:space="preserve">
          <source>Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. However, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int)&quot;&gt;&lt;code&gt;defineClass&lt;/code&gt;&lt;/a&gt; converts an array of bytes into an instance of class &lt;code&gt;Class&lt;/code&gt;. Instances of this newly defined class can be created using &lt;a href=&quot;class#newInstance()&quot;&gt;&lt;code&gt;Class.newInstance&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 Java 가상 머신은 플랫폼에 따라 다른 방식으로 로컬 파일 시스템에서 클래스를로드합니다. 그러나 일부 클래스는 파일에서 생성되지 않을 수 있습니다. 네트워크와 같은 다른 소스에서 비롯되거나 애플리케이션에 의해 구성 될 수 있습니다. &lt;a href=&quot;#defineClass(java.lang.String,byte%5B%5D,int,int)&quot;&gt; &lt;code&gt;defineClass&lt;/code&gt; &lt;/a&gt; 메소드 는 바이트 배열을 &lt;code&gt;Class&lt;/code&gt; 클래스 의 인스턴스로 변환합니다 . 새로 정의 된이 클래스의 인스턴스는 &lt;a href=&quot;class#newInstance()&quot;&gt; &lt;code&gt;Class.newInstance&lt;/code&gt; 를&lt;/a&gt; 사용하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0cd54024cd9fd4b959f6a8acaf3be98115f9263" translate="yes" xml:space="preserve">
          <source>Normally, the tables are specified in the &lt;code&gt;IIOMetadata&lt;/code&gt; objects passed in to the writer, and any tables included in these objects are written to the stream. If no tables are specified in the metadata, then an abbreviated stream is written. If no tables are included in the metadata and no tables are specified in a &lt;code&gt;JPEGImageWriteParam&lt;/code&gt;, then an abbreviated stream is encoded using the &quot;standard&quot; visually lossless tables. This class is necessary for specifying tables when an abbreviated stream must be written without writing any tables to a stream first. In order to use this class, the metadata object passed into the writer must contain no tables, and no stream metadata must be provided. See &lt;a href=&quot;jpegqtable&quot;&gt;&lt;code&gt;JPEGQTable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;jpeghuffmantable&quot;&gt;&lt;code&gt;JPEGHuffmanTable&lt;/code&gt;&lt;/a&gt; for more information on the default tables.</source>
          <target state="translated">일반적으로 테이블은 기록기에 전달 된 &lt;code&gt;IIOMetadata&lt;/code&gt; 객체에 지정 되며 이러한 객체에 포함 된 모든 테이블은 스트림에 기록됩니다. 메타 데이터에 테이블이 지정되지 않으면 약식 스트림이 기록됩니다. 메타 데이터에 테이블이 포함되어 있지 않고 &lt;code&gt;JPEGImageWriteParam&lt;/code&gt; 에 테이블이 지정되지 않은 경우 약식 스트림은 &quot;표준&quot;시각적 무손실 테이블을 사용하여 인코딩됩니다. 이 클래스는 먼저 테이블을 스트림에 쓰지 않고 축약 된 스트림을 작성해야 할 때 테이블을 지정하는 데 필요합니다. 이 클래스를 사용하려면 기록기에 전달 된 메타 데이터 개체에 테이블이 없어야하며 스트림 메타 데이터가 제공되지 않아야합니다. &lt;a href=&quot;jpegqtable&quot;&gt; &lt;code&gt;JPEGQTable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;jpeghuffmantable&quot;&gt; &lt;code&gt;JPEGHuffmanTable&lt;/code&gt; &lt;/a&gt; 참조 기본 테이블에 대한 자세한 정보를 .</target>
        </trans-unit>
        <trans-unit id="bc6d97b300ebb28d188762cd929dd4a5c7361386" translate="yes" xml:space="preserve">
          <source>Normally, the user changes the value of the scroll bar by making a gesture with the mouse. For example, the user can drag the scroll bar's bubble up and down, or click in the scroll bar's unit increment or block increment areas. Keyboard gestures can also be mapped to the scroll bar. By convention, the &lt;b&gt;Page Up&lt;/b&gt; and &lt;b&gt;Page Down&lt;/b&gt; keys are equivalent to clicking in the scroll bar's block increment and block decrement areas.</source>
          <target state="translated">일반적으로 사용자는 마우스로 제스처를 수행하여 스크롤 막대의 값을 변경합니다. 예를 들어, 사용자는 스크롤 막대의 풍선을 위아래로 드래그하거나 스크롤 막대의 단위 증가 또는 블록 증가 영역을 클릭 할 수 있습니다. 키보드 제스처를 스크롤 막대에 매핑 할 수도 있습니다. 규칙에 따라 &lt;b&gt;Page Up&lt;/b&gt; 및 &lt;b&gt;Page Down&lt;/b&gt; 키는 스크롤 막대의 블록 증가 및 블록 감소 영역을 클릭하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="03c5ea8322ba7e817c0a136cecaa68f7da66119e" translate="yes" xml:space="preserve">
          <source>Normally, this error is caught by the compiler; this error can only occur at run time if the definition of a class has incompatibly changed.</source>
          <target state="translated">일반적으로이 오류는 컴파일러에서 발생합니다. 이 오류는 클래스 정의가 호환되지 않는 경우에만 런타임시 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07ac7921ed0b57c8acad3c4b53e1ee25939d0bce" translate="yes" xml:space="preserve">
          <source>Normally, this method is invoked at most once per class, but it may be invoked again if there has been a call to &lt;a href=&quot;#remove(java.lang.Class)&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로이 메서드는 클래스 당 한 번만 호출되지만 &lt;a href=&quot;#remove(java.lang.Class)&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 호출이있는 경우 다시 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f50b4a8d77f17af0b364a933991f9010b617625" translate="yes" xml:space="preserve">
          <source>Normally, this method is invoked at most once per class, but it may be invoked again if there has been a call to &lt;a href=&quot;classvalue#remove-java.lang.Class-&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로이 메소드는 클래스 당 최대 한 번만 호출되지만 &lt;a href=&quot;classvalue#remove-java.lang.Class-&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 호출이 있으면 다시 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22ca41928150e819619654fa5a9109a99452337f" translate="yes" xml:space="preserve">
          <source>Normally, you should pop the context at the end of each XML element. After popping the context, all Namespace prefix mappings that were previously in force are restored.</source>
          <target state="translated">일반적으로 각 XML 요소의 끝에 컨텍스트를 표시해야합니다. 컨텍스트를 팝한 후 이전에 적용되었던 모든 네임 스페이스 접두사 매핑이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="cc1efaada9cfbd4fe5316e9ef2d942b1a225fdd8" translate="yes" xml:space="preserve">
          <source>North pane</source>
          <target state="translated">북쪽 창</target>
        </trans-unit>
        <trans-unit id="a678e190ea7d7d8835688b006b8307e3351ec796" translate="yes" xml:space="preserve">
          <source>Norwegian: &quot;&amp;lt; a, A &amp;lt; b, B &amp;lt; c, C &amp;lt; d, D &amp;lt; e, E &amp;lt; f, F &amp;lt; g, G &amp;lt; h, H &amp;lt; i, I &amp;lt; j, J &amp;lt; k, K &amp;lt; l, L &amp;lt; m, M &amp;lt; n, N &amp;lt; o, O &amp;lt; p, P &amp;lt; q, Q &amp;lt; r, R &amp;lt; s, S &amp;lt; t, T &amp;lt; u, U &amp;lt; v, V &amp;lt; w, W &amp;lt; x, X &amp;lt; y, Y &amp;lt; z, Z &amp;lt; \u00E6, \u00C6 &amp;lt; \u00F8, \u00D8 &amp;lt; \u00E5 = a\u030A, \u00C5 = A\u030A; aa, AA&quot;</source>
          <target state="translated">노르웨이어 : &quot;&amp;lt;a, A &amp;lt;b, B &amp;lt;c, C &amp;lt;d, D &amp;lt;e, E &amp;lt;f, F &amp;lt;g, G &amp;lt;h, H &amp;lt;i, I &amp;lt;j, J &amp;lt;k, K &amp;lt;l, L &amp;lt;m, M &amp;lt;n, N &amp;lt;o, O &amp;lt;p, P &amp;lt;q, Q &amp;lt;r, R &amp;lt;s, S &amp;lt;t, T &amp;lt;u, U &amp;lt;v, V &amp;lt;w, W &amp;lt;x, X &amp;lt; y, Y &amp;lt;z, Z &amp;lt;\ u00E6, \ u00C6 &amp;lt;\ u00F8, \ u00D8 &amp;lt;\ u00E5 = a \ u030A, \ u00C5 = A \ u030A; aa, AA &quot;</target>
        </trans-unit>
        <trans-unit id="7e1d156edfb625c87e3f9f18bc15e00ed283c684" translate="yes" xml:space="preserve">
          <source>Not a valid role but role id's greater than this may be used for private roles supported by a service.</source>
          <target state="translated">유효한 역할은 아니지만 이보다 큰 역할 ID는 서비스에서 지원하는 개인 역할에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53ea4a3df064eb5f4ed63ae85d0142982b27c6f8" translate="yes" xml:space="preserve">
          <source>Not a valid role but role id's greater than this may be used for private roles supported by a service. Knowledge of the function performed by this role is required to make proper use of it.</source>
          <target state="translated">유효한 역할이 아니지만 이보다 큰 역할 ID는 서비스에서 지원하는 개인 역할에 사용될 수 있습니다. 이 역할에 의해 수행되는 기능에 대한 지식은 기능을 올바르게 사용하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="76556585145a076d3d78c21f521b40ab216d2726" translate="yes" xml:space="preserve">
          <source>Not all &lt;code&gt;TemporalAccessor&lt;/code&gt; implementations are accepted as return values. Implementations that call this method must accept &lt;code&gt;ChronoLocalDate&lt;/code&gt;, &lt;code&gt;ChronoLocalDateTime&lt;/code&gt;, &lt;code&gt;ChronoZonedDateTime&lt;/code&gt; and &lt;code&gt;LocalTime&lt;/code&gt;.</source>
          <target state="translated">모든 &lt;code&gt;TemporalAccessor&lt;/code&gt; 구현이 리턴 값으로 허용되는 것은 아닙니다 . 이 메소드를 호출하는 구현은 &lt;code&gt;ChronoLocalDate&lt;/code&gt; , &lt;code&gt;ChronoLocalDateTime&lt;/code&gt; , &lt;code&gt;ChronoZonedDateTime&lt;/code&gt; 및 &lt;code&gt;LocalTime&lt;/code&gt; 을 승인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f41446132e60443a4cf00fc1037be5e58ccb5e4b" translate="yes" xml:space="preserve">
          <source>Not all attributes have a default value. For example the service will not have a default value for &lt;code&gt;RequestingUser&lt;/code&gt; i.e. a &lt;code&gt;null&lt;/code&gt; return for a supported category means there is no service default value for that category. Use the &lt;code&gt;isAttributeCategorySupported(Class)&lt;/code&gt; method to distinguish these cases.</source>
          <target state="translated">모든 속성에 기본값이있는 것은 아닙니다. 예를 들어 서비스에는 &lt;code&gt;RequestingUser&lt;/code&gt; 에 대한 기본값이 없습니다. 즉 , 지원되는 범주에 대한 &lt;code&gt;null&lt;/code&gt; 반환은 해당 범주에 대한 서비스 기본값이 없음을 의미합니다. 이러한 경우를 구분 하려면 &lt;code&gt;isAttributeCategorySupported(Class)&lt;/code&gt; 메서드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cd3e32dcc6b53a8da83445933bd09865c3c0139" translate="yes" xml:space="preserve">
          <source>Not all attributes have a default value. For example the service will not have a defaultvalue for &lt;code&gt;RequestingUser&lt;/code&gt; i.e. a null return for a supported category means there is no service default value for that category. Use the &lt;code&gt;isAttributeCategorySupported(Class)&lt;/code&gt; method to distinguish these cases.</source>
          <target state="translated">모든 속성에 기본값이있는 것은 아닙니다. 예를 들어 서비스에는 &lt;code&gt;RequestingUser&lt;/code&gt; 에 대한 기본값이 없습니다. 즉, 지원되는 카테고리에 대한 널 리턴은 해당 카테고리에 대한 서비스 기본값이 없음을 의미합니다. 이러한 경우를 구별 하려면 &lt;code&gt;isAttributeCategorySupported(Class)&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0102d7a3ac1669274ce05a9bd8a70a18171b3868" translate="yes" xml:space="preserve">
          <source>Not all characters have a keycode associated with them. For example, there is no keycode for the question mark because there is no keyboard for which it appears on the primary layer.</source>
          <target state="translated">모든 문자에 관련된 키 코드가있는 것은 아닙니다. 예를 들어, 물음표가 기본 레이어에 표시되는 키보드가 없기 때문에 물음표에 대한 키 코드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e2ca62cfd317694199c1b384c55a910f1f42399" translate="yes" xml:space="preserve">
          <source>Not all environments will contain session contexts.</source>
          <target state="translated">모든 환경에 세션 컨텍스트가 포함되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="923eb8dd08ce82fcd579c4dffe9de57f4bd7b81e" translate="yes" xml:space="preserve">
          <source>Not all field names and values are predefined. New fields can be defined and added by any program.</source>
          <target state="translated">모든 필드 이름과 값이 미리 정의 된 것은 아닙니다. 모든 프로그램에서 새 필드를 정의하고 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a36969afae47ece5c6f00c74a300f111901930a" translate="yes" xml:space="preserve">
          <source>Not all host operating systems provide API to determine the locale of the currently selected native input method or keyboard layout, and to select a native input method or keyboard layout by locale. For host operating systems that don't provide such API, &lt;code&gt;selectInputMethod&lt;/code&gt; assumes that native input methods or keyboard layouts provided by the host operating system support only the system's default locale.</source>
          <target state="translated">모든 호스트 운영 체제가 현재 선택된 기본 입력 방법 또는 키보드 레이아웃의 로케일을 결정하고 언어별로 기본 입력 방법 또는 키보드 레이아웃을 선택하는 API를 제공하는 것은 아닙니다. 이러한 API를 제공하지 않는 호스트 운영 체제의 경우 &lt;code&gt;selectInputMethod&lt;/code&gt; 는 호스트 운영 체제에서 제공 하는 기본 입력 방법 또는 키보드 레이아웃이 시스템의 기본 로케일 만 지원한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b5f11ad21c9e7b3826cc0f5106ab6d4fb53787cb" translate="yes" xml:space="preserve">
          <source>Not all host operating systems provide API to determine the locale of the currently selected native input method or keyboard layout. For host operating systems that don't provide such API, &lt;code&gt;getLocale&lt;/code&gt; assumes that the current locale of all native input methods or keyboard layouts provided by the host operating system is the system's default locale.</source>
          <target state="translated">모든 호스트 운영 체제가 현재 선택한 기본 입력 방법 또는 키보드 레이아웃의 로케일을 결정하는 API를 제공하는 것은 아닙니다. 이러한 API를 제공하지 않는 호스트 운영 체제의 경우 &lt;code&gt;getLocale&lt;/code&gt; 은 호스트 운영 체제에서 제공 하는 모든 기본 입력 방법 또는 키보드 레이아웃의 현재 로케일이 시스템의 기본 로케일이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6a5f78c1c268eaa5406f68f5a1e420277f39f3e4" translate="yes" xml:space="preserve">
          <source>Not all keyboards or systems are capable of generating all virtual key codes. No attempt is made in Java to generate these keys artificially.</source>
          <target state="translated">모든 키보드 또는 시스템이 모든 가상 키 코드를 생성 할 수있는 것은 아닙니다. Java에서는 이러한 키를 인위적으로 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ba5910d407654cba570e2b7458215bbc9f94dfb" translate="yes" xml:space="preserve">
          <source>Not all letters have case. Many characters are letters but are neither uppercase nor lowercase nor titlecase.</source>
          <target state="translated">모든 문자에 대소 문자가있는 것은 아닙니다. 많은 문자는 문자이지만 대문자 나 소문자 또는 제목이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bc6a37703f4d414ac5d598ca848e5118376df7a7" translate="yes" xml:space="preserve">
          <source>Not all mechanisms support mutual authentication and some mechanisms might require mutual authentication even if the application doesn't. Therefore, the application should check to see if the request was honored with the &lt;a href=&quot;#getMutualAuthState()&quot;&gt;&lt;code&gt;getMutualAuthState&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">모든 메커니즘이 상호 인증을 지원하는 것은 아니며 일부 메커니즘은 애플리케이션이 지원하지 않더라도 상호 인증을 요구할 수 있습니다. 따라서 애플리케이션은 요청이 &lt;a href=&quot;#getMutualAuthState()&quot;&gt; &lt;code&gt;getMutualAuthState&lt;/code&gt; &lt;/a&gt; 메소드로 처리 되었는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cef5831573e97a49d1e4e540997a2192ff5509d5" translate="yes" xml:space="preserve">
          <source>Not all mechanisms support replay detection and some mechanisms might require replay detection even if the application doesn't. Therefore, the application should check to see if the request was honored with the &lt;a href=&quot;#getReplayDetState()&quot;&gt;&lt;code&gt;getReplayDetState&lt;/code&gt;&lt;/a&gt; method. If replay detection is enabled then the &lt;a href=&quot;messageprop#isDuplicateToken()&quot;&gt;&lt;code&gt;MessageProp.isDuplicateToken&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;messageprop#isOldToken()&quot;&gt;&lt;code&gt;MessageProp.isOldToken&lt;/code&gt;&lt;/a&gt; methods will return valid results for the &lt;code&gt;MessageProp&lt;/code&gt; object that is passed in to the &lt;code&gt;unwrap&lt;/code&gt; method or the &lt;code&gt;verifyMIC&lt;/code&gt; method.</source>
          <target state="translated">모든 메커니즘이 재생 감지를 지원하는 것은 아니며 일부 메커니즘은 애플리케이션이 지원하지 않더라도 재생 감지가 필요할 수 있습니다. 따라서 응용 프로그램은 요청이 &lt;a href=&quot;#getReplayDetState()&quot;&gt; &lt;code&gt;getReplayDetState&lt;/code&gt; &lt;/a&gt; 메서드로 처리 되었는지 확인해야합니다 . 재생 감지가 활성화 된 경우 &lt;a href=&quot;messageprop#isDuplicateToken()&quot;&gt; &lt;code&gt;MessageProp.isDuplicateToken&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;messageprop#isOldToken()&quot;&gt; &lt;code&gt;MessageProp.isOldToken&lt;/code&gt; &lt;/a&gt; 메서드는 &lt;code&gt;unwrap&lt;/code&gt; 메서드 또는 &lt;code&gt;verifyMIC&lt;/code&gt; 메서드에 전달 된 &lt;code&gt;MessageProp&lt;/code&gt; 개체에 대해 유효한 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="77775a11ecb03265cb835610eae29b67123b7d11" translate="yes" xml:space="preserve">
          <source>Not all mechanisms support sequence checking and some mechanisms might require sequence checking even if the application doesn't. Therefore, the application should check to see if the request was honored with the &lt;a href=&quot;#getSequenceDetState()&quot;&gt;&lt;code&gt;getSequenceDetState&lt;/code&gt;&lt;/a&gt; method. If sequence checking is enabled then the &lt;a href=&quot;messageprop#isDuplicateToken()&quot;&gt;&lt;code&gt;MessageProp.isDuplicateToken&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;messageprop#isOldToken()&quot;&gt;&lt;code&gt;MessageProp.isOldToken&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;messageprop#isUnseqToken()&quot;&gt;&lt;code&gt;MessageProp.isUnseqToken&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;messageprop#isGapToken()&quot;&gt;&lt;code&gt;MessageProp.isGapToken&lt;/code&gt;&lt;/a&gt; methods will return valid results for the &lt;code&gt;MessageProp&lt;/code&gt; object that is passed in to the &lt;code&gt;unwrap&lt;/code&gt; method or the &lt;code&gt;verifyMIC&lt;/code&gt; method.</source>
          <target state="translated">모든 메커니즘이 시퀀스 검사를 지원하는 것은 아니며 일부 메커니즘에서는 응용 프로그램이 지원하지 않더라도 시퀀스 검사가 필요할 수 있습니다. 따라서 응용 프로그램은 요청이 &lt;a href=&quot;#getSequenceDetState()&quot;&gt; &lt;code&gt;getSequenceDetState&lt;/code&gt; &lt;/a&gt; 메서드로 처리 되었는지 확인해야합니다 . 시퀀스 검사가 활성화 된 경우 &lt;a href=&quot;messageprop#isDuplicateToken()&quot;&gt; &lt;code&gt;MessageProp.isDuplicateToken&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;messageprop#isOldToken()&quot;&gt; &lt;code&gt;MessageProp.isOldToken&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;messageprop#isUnseqToken()&quot;&gt; &lt;code&gt;MessageProp.isUnseqToken&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;messageprop#isGapToken()&quot;&gt; &lt;code&gt;MessageProp.isGapToken&lt;/code&gt; &lt;/a&gt; 메서드는 &lt;code&gt;unwrap&lt;/code&gt; 메서드 또는 &lt;code&gt;verifyMIC&lt;/code&gt; 메서드에 전달 된 &lt;code&gt;MessageProp&lt;/code&gt; 개체에 대해 유효한 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b7754c2469b46000e3f443dffbdccd1dcb3755e4" translate="yes" xml:space="preserve">
          <source>Not all modifiers are applicable to all kinds of elements. When two or more modifiers appear in the source code of an element then it is customary, though not required, that they appear in the same order as the constants listed in the detail section below.</source>
          <target state="translated">모든 수정자가 모든 종류의 요소에 적용되는 것은 아닙니다. 두 개 이상의 수정자가 요소의 소스 코드에 나타날 때는 필수는 아니지만 아래 세부 사항 섹션에 나열된 상수와 동일한 순서로 나타나는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="d8814438939faf87f102340d2cda25075bc2eb9a" translate="yes" xml:space="preserve">
          <source>Not all of the operators defined in RFC 2254 are applicable to all attributes. When an operator is not applicable, the exception &lt;code&gt;InvalidSearchFilterException&lt;/code&gt; is thrown.</source>
          <target state="translated">RFC 2254에 정의 된 모든 연산자가 모든 속성에 적용 가능한 것은 아닙니다. 연산자를 적용 할 수 없으면 &lt;code&gt;InvalidSearchFilterException&lt;/code&gt; 예외 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="60494b7b2f7b3b5c42e5147ef12f29cf77342352" translate="yes" xml:space="preserve">
          <source>Not all print services may be capable of delivering interesting events, or even telling when a job is complete.</source>
          <target state="translated">모든 인쇄 서비스가 흥미로운 이벤트를 전달하거나 작업 완료시기를 알려줄 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="37689ea1d145fc5766796b72ced33640c878423f" translate="yes" xml:space="preserve">
          <source>Not all print services may be capable of delivering interesting events, or even telling when a job is complete. This message indicates the print job has no further information or communication with the print service. This message should always be delivered if a terminal event (completed/failed/canceled) is not delivered. For example, if messages such as &lt;code&gt;JOB_COMPLETE&lt;/code&gt; have NOT been received before receiving this message, the only inference that should be drawn is that the print service does not support delivering such an event.</source>
          <target state="translated">모든 인쇄 서비스가 흥미로운 이벤트를 전달하거나 작업 완료시기를 알려줄 수있는 것은 아닙니다. 이 메시지는 인쇄 작업에 추가 정보가 없거나 인쇄 서비스와 통신하지 않음을 나타냅니다. 이 메시지는 터미널 이벤트 (완료 / 실패 / 취소)가 전달되지 않은 경우 항상 전달되어야합니다. 예를 들어, &lt;code&gt;JOB_COMPLETE&lt;/code&gt; 와 같은 메시지 가이 메시지를 수신하기 전에 수신되지 않은 경우, 그려야 하는 유일한 추론은 인쇄 서비스가 그러한 이벤트 전달을 지원하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="35f64ddbca0b54a706e44a4edf5ca413b1c75868" translate="yes" xml:space="preserve">
          <source>Not all print services may be capable of delivering interesting events, or even telling when a job is complete. This message indicates the print job has no further information or communication with the print service. This message should always be delivered if a terminal event (completed/failed/canceled) is not delivered. For example, if messages such as JOB_COMPLETE have NOT been received before receiving this message, the only inference that should be drawn is that the print service does not support delivering such an event.</source>
          <target state="translated">모든 인쇄 서비스가 흥미로운 이벤트를 전달하거나 작업 완료시기를 알려주는 것은 아닙니다. 이 메시지는 인쇄 작업에 더 이상의 정보 나 인쇄 서비스와의 통신이 없음을 나타냅니다. 터미널 이벤트 (완료 / 실패 / 취소)가 전달되지 않으면이 메시지가 항상 전달되어야합니다. 예를 들어,이 메시지를 받기 전에 JOB_COMPLETE와 같은 메시지가 수신되지 않은 경우 인쇄 서비스가 이러한 이벤트 전달을 지원하지 않는다는 것만 유추해야합니다.</target>
        </trans-unit>
        <trans-unit id="a29cbcf85eaefc42cdc231116049bdb2d0b4859d" translate="yes" xml:space="preserve">
          <source>Not all systems have support for the IPv6 protocol, and while the Java networking stack will attempt to detect it and use it transparently when available, it is also possible to disable its use with a system property. In the case where IPv6 is not available, or explicitly disabled, Inet6Address are not valid arguments for most networking operations any more. While methods like &lt;a href=&quot;inetaddress#getByName(java.lang.String)&quot;&gt;&lt;code&gt;InetAddress.getByName(java.lang.String)&lt;/code&gt;&lt;/a&gt; are guaranteed not to return an Inet6Address when looking up host names, it is possible, by passing literals, to create such an object. In which case, most methods, when called with an Inet6Address will throw an Exception.</source>
          <target state="translated">모든 시스템이 IPv6 프로토콜을 지원하는 것은 아니며 Java 네트워킹 스택이이를 감지하고 사용 가능한 경우 투명하게 사용하려고 시도하지만 시스템 속성과 함께 사용을 비활성화 할 수도 있습니다. IPv6를 사용할 수 없거나 명시 적으로 비활성화 된 경우 Inet6Address는 더 이상 대부분의 네트워킹 작업에 유효한 인수가 아닙니다. &lt;a href=&quot;inetaddress#getByName(java.lang.String)&quot;&gt; &lt;code&gt;InetAddress.getByName(java.lang.String)&lt;/code&gt; &lt;/a&gt; 과 같은 메소드 는 호스트 이름을 조회 할 때 Inet6Address를 반환하지 않는 것이 보장 되지만 리터럴을 전달하여 이러한 객체를 생성 할 수 있습니다. 이 경우 대부분의 메서드는 Inet6Address와 함께 호출 될 때 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="e397a6994b2c95a352c9b3b672917a6038d16a3e" translate="yes" xml:space="preserve">
          <source>Not all systems have support for the IPv6 protocol, and while the Java networking stack will attempt to detect it and use it transparently when available, it is also possible to disable its use with a system property. In the case where IPv6 is not available, or explicitly disabled, Inet6Address are not valid arguments for most networking operations any more. While methods like &lt;a href=&quot;inetaddress#getByName-java.lang.String-&quot;&gt;&lt;code&gt;InetAddress.getByName(java.lang.String)&lt;/code&gt;&lt;/a&gt; are guaranteed not to return an Inet6Address when looking up host names, it is possible, by passing literals, to create such an object. In which case, most methods, when called with an Inet6Address will throw an Exception.</source>
          <target state="translated">모든 시스템이 IPv6 프로토콜을 지원하는 것은 아니며 Java 네트워킹 스택이이를 감지하여 사용 가능한 경우 투명하게 사용하려고 시도하지만 시스템 특성과 함께 사용하지 않도록 설정할 수도 있습니다. IPv6을 사용할 수 없거나 명시 적으로 비활성화 된 경우 Inet6Address는 더 이상 대부분의 네트워킹 작업에 유효한 인수가 아닙니다. &lt;a href=&quot;inetaddress#getByName-java.lang.String-&quot;&gt; &lt;code&gt;InetAddress.getByName(java.lang.String)&lt;/code&gt; &lt;/a&gt; 과 같은 메소드 는 호스트 이름을 찾을 때 Inet6Address를 리턴하지 않는 것이 보장 되지만 리터럴을 전달하여 이러한 오브젝트를 작성할 수 있습니다. 이 경우 Inet6Address로 호출하면 대부분의 메소드에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="05aba0437eb3bd7ea2070512e01919750c643e0c" translate="yes" xml:space="preserve">
          <source>Not called directly by applications.</source>
          <target state="translated">응용 프로그램에서 직접 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab2b2dd5ad5194460f39ce97c77efdff8ec39c11" translate="yes" xml:space="preserve">
          <source>Not called directly by applications. Implemented by a service provider, and called by the print lookup service</source>
          <target state="translated">응용 프로그램에서 직접 호출하지 않습니다. 서비스 제공 업체에서 구현하고 인쇄 조회 서비스에서 호출</target>
        </trans-unit>
        <trans-unit id="dd0b8a8946e8e9160c83b6cba603a9e680e19eb4" translate="yes" xml:space="preserve">
          <source>Not called directly by applications. Implemented by a service provider, and called by the print lookup service.</source>
          <target state="translated">응용 프로그램에서 직접 호출하지 않습니다. 서비스 제공 업체에서 구현하고 인쇄 조회 서비스에서 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2a463a7a78bc44fc4334568c6d8f7abbdf4f14d1" translate="yes" xml:space="preserve">
          <source>Not called directly by applications. Implemented by a service provider, used by the static methods of this class.</source>
          <target state="translated">응용 프로그램에서 직접 호출하지 않습니다. 서비스 프로 바이더가 구현해,이 클래스의 정적 메소드에 의해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4c2c4692797b1c72c2490c0e81cb931fc786ce55" translate="yes" xml:space="preserve">
          <source>Not currently used.</source>
          <target state="translated">현재 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25db7b09df7d6a42d624eccea60ad00c4c751826" translate="yes" xml:space="preserve">
          <source>Not implemented, does nothing.</source>
          <target state="translated">구현되지 않고 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a680f57856e3df6f405166c16f4653fa9b47e420" translate="yes" xml:space="preserve">
          <source>Not lossy</source>
          <target state="translated">손실되지 않음</target>
        </trans-unit>
        <trans-unit id="9153f9b5bb1790835ec2ea6612dc284c5c8d06f9" translate="yes" xml:space="preserve">
          <source>Not used by this class.</source>
          <target state="translated">이 클래스에서 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a792494d26a57c3aa80e6c4feca7ed030f741a16" translate="yes" xml:space="preserve">
          <source>Not used in this context.</source>
          <target state="translated">이 문맥에서는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb45945c94c0131f03af3139052abb60708b653a" translate="yes" xml:space="preserve">
          <source>NotActiveException</source>
          <target state="translated">NotActiveException</target>
        </trans-unit>
        <trans-unit id="70f764028352ef77c2d3d134c56787476c4464ca" translate="yes" xml:space="preserve">
          <source>NotBoundException</source>
          <target state="translated">NotBoundException</target>
        </trans-unit>
        <trans-unit id="b1f01dc5096455decfee1f325bf6d67435ff5cf4" translate="yes" xml:space="preserve">
          <source>NotCompliantMBeanException</source>
          <target state="translated">NotCompliantMBeanException</target>
        </trans-unit>
        <trans-unit id="b17c2fa961f935d26f5107d7a2b68b673df1e300" translate="yes" xml:space="preserve">
          <source>NotContextException</source>
          <target state="translated">NotContextException</target>
        </trans-unit>
        <trans-unit id="e829839cc5b1acc0ef27d88bf6d9a18be0f74c3b" translate="yes" xml:space="preserve">
          <source>NotDirectoryException</source>
          <target state="translated">NotDirectoryException</target>
        </trans-unit>
        <trans-unit id="6421f6d867ebf2bac7333163dad093854283bbd7" translate="yes" xml:space="preserve">
          <source>NotLinkException</source>
          <target state="translated">NotLinkException</target>
        </trans-unit>
        <trans-unit id="8a0b22ca48f29ff7c347fdf2e36e8bcf57f0cf37" translate="yes" xml:space="preserve">
          <source>NotOwnerException</source>
          <target state="translated">NotOwnerException</target>
        </trans-unit>
        <trans-unit id="a8101cb03f9e43859d900d164645e1053f92ad69" translate="yes" xml:space="preserve">
          <source>NotSerializableException</source>
          <target state="translated">NotSerializableException</target>
        </trans-unit>
        <trans-unit id="a5fa17dc013886b1dfae0b9d9192b0ec388d8112" translate="yes" xml:space="preserve">
          <source>NotYetBoundException</source>
          <target state="translated">NotYetBoundException</target>
        </trans-unit>
        <trans-unit id="b5726b78b7dec5b00c5f26de15ad4c767cd781f3" translate="yes" xml:space="preserve">
          <source>NotYetConnectedException</source>
          <target state="translated">NotYetConnectedException</target>
        </trans-unit>
        <trans-unit id="4553a1f183efb4313b963f289a47c5ea9be3eb15" translate="yes" xml:space="preserve">
          <source>Notable differences from Perl:</source>
          <target state="translated">Perl과의 현저한 차이점 :</target>
        </trans-unit>
        <trans-unit id="9f3163ffda0d3418a1866865fdb1ef76cb2dbf4b" translate="yes" xml:space="preserve">
          <source>Notation</source>
          <target state="translated">Notation</target>
        </trans-unit>
        <trans-unit id="9f32ace1f288b96d57761c89dd67dad6eef02b7f" translate="yes" xml:space="preserve">
          <source>NotationDeclaration</source>
          <target state="translated">NotationDeclaration</target>
        </trans-unit>
        <trans-unit id="db3cf006ffc0a0f443ff7925a87893e6fd720348" translate="yes" xml:space="preserve">
          <source>Note : Native windowing systems may use different images of differing dimensions to represent a window, depending on the context (e.g. window decoration, window list, taskbar, etc.). They could also use just a single image for all contexts or no image at all.</source>
          <target state="translated">참고 : 기본 창 시스템은 컨텍스트 (예 : 창 장식, 창 목록, 작업 표시 줄 등)에 따라 창을 나타 내기 위해 다른 크기의 다른 이미지를 사용할 수 있습니다. 또한 모든 컨텍스트에 대해 하나의 이미지 만 사용하거나 전혀 이미지를 사용하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="376a8b8e4951d4e55d76a651ff27323ffb68e782" translate="yes" xml:space="preserve">
          <source>Note also that NoSuchElementException is thrown if the program invokes next() or nextElement() when there are no elements left in the enumeration. The program can always avoid this exception by using hasMore() and hasMoreElements() to check whether the end of the enumeration has been reached.</source>
          <target state="translated">열거에 남아있는 요소가 없을 때 프로그램이 next () 또는 nextElement ()를 호출하면 NoSuchElementException이 발생합니다. 프로그램은 열거의 끝에 도달했는지 여부를 확인하기 위해 hasMore () 및 hasMoreElements ()를 사용하여이 예외를 항상 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ada9c8d4e20fbdf3515a0468c2b4e63247d0b0f7" translate="yes" xml:space="preserve">
          <source>Note also that attempting to access mutable state from behavioral parameters presents you with a bad choice with respect to safety and performance; if you do not synchronize access to that state, you have a data race and therefore your code is broken, but if you do synchronize access to that state, you risk having contention undermine the parallelism you are seeking to benefit from. The best approach is to avoid stateful behavioral parameters to stream operations entirely; there is usually a way to restructure the stream pipeline to avoid statefulness.</source>
          <target state="translated">동작 매개 변수에서 변경 가능한 상태에 액세스하려고하면 안전 및 성능과 관련하여 잘못된 선택이 발생합니다. 해당 상태에 대한 액세스를 동기화하지 않으면 데이터 경쟁이 발생하여 코드가 손상되지만 해당 상태에 대한 액세스를 동기화하면 경합이 혜택을 받고자하는 병렬 처리를 손상시킬 위험이 있습니다. 최선의 방법은 상태 저장 동작 매개 변수를 사용하여 작업을 완전히 스트리밍하지 않는 것입니다. 일반적으로 상태 파이프 라인을 피하기 위해 스트림 파이프 라인을 재구성하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfa4cce6c8daefacba480cbe5d00966eb0f7c539" translate="yes" xml:space="preserve">
          <source>Note also that changing the prefix of an attribute that is known to have a default value, does not make a new attribute with the default value and the original prefix appear, since the &lt;code&gt;namespaceURI&lt;/code&gt; and &lt;code&gt;localName&lt;/code&gt; do not change.</source>
          <target state="translated">또한 &lt;code&gt;namespaceURI&lt;/code&gt; 및 &lt;code&gt;localName&lt;/code&gt; 은 변경 되지 않기 때문에 기본값이있는 것으로 알려진 속성의 접두사를 변경해도 기본값이있는 새 속성이 생성되지 않고 원래 접두사가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3415595ff91f0cbd82a66f0a6199ce72eabc6469" translate="yes" xml:space="preserve">
          <source>Note also that the boundaries of character references (which are not really entities anyway) are not reported.</source>
          <target state="translated">문자 참조의 경계 (어쨌든 실제로 엔티티가 아님)는보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b768808bbfa996f7626374e68cb4be0e23bff0a3" translate="yes" xml:space="preserve">
          <source>Note also that the byte array supplied here is cloned to protect against subsequent modifications.</source>
          <target state="translated">여기에 제공된 바이트 배열은 후속 수정으로부터 보호하기 위해 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="cfa0a19e506cbac9c7a0caddb548dfc2e13e7603" translate="yes" xml:space="preserve">
          <source>Note also that when a duplicate method is dispatched to an invocation handler, the &lt;code&gt;invoke&lt;/code&gt; method may only throw checked exception types that are assignable to one of the exception types in the &lt;code&gt;throws&lt;/code&gt; clause of the method in</source>
          <target state="translated">또한 중복 메소드가 호출 핸들러로 디스패치 될 때 &lt;code&gt;invoke&lt;/code&gt; 메소드는 메소드의 &lt;code&gt;throws&lt;/code&gt; 절 에서 예외 유형 중 하나에 지정 가능한 점검 된 예외 유형 만 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b42b878e7b76f52fe6f85e121b10f8a80e676dd" translate="yes" xml:space="preserve">
          <source>Note also, that the numeric</source>
          <target state="translated">또한 숫자는</target>
        </trans-unit>
        <trans-unit id="aeb89a4587f65d207f7dd1a43ebf330f4020926e" translate="yes" xml:space="preserve">
          <source>Note finally that:</source>
          <target state="translated">마지막으로 다음을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="f69840527c1bf4616f3175fecba69b0695804c9a" translate="yes" xml:space="preserve">
          <source>Note for implementors</source>
          <target state="translated">구현 자 참고 사항</target>
        </trans-unit>
        <trans-unit id="4f2e2e958bcbe5c251049e22d87bf27d75ac875a" translate="yes" xml:space="preserve">
          <source>Note however, that there is no guarantee that a particular timeout implementation will be able to notice the passage of time at the same granularity as the given &lt;code&gt;TimeUnit&lt;/code&gt;.</source>
          <target state="translated">그러나 특정 시간 초과 구현이 지정된 &lt;code&gt;TimeUnit&lt;/code&gt; 과 동일한 세부 시간으로 시간 경과를 알 수 있다는 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="25d5eb0421fbf19c890c4cdd11d935c43403896b" translate="yes" xml:space="preserve">
          <source>Note it is illegal for a BeanContextChild to invoke this method associated with a BeanContext that it is nested within.</source>
          <target state="translated">BeanContextChild가 중첩 된 BeanContext와 연관된이 메소드를 호출하는 것은 불법입니다.</target>
        </trans-unit>
        <trans-unit id="c64f31e43d05e3f70c3add1ef329c78da50372dc" translate="yes" xml:space="preserve">
          <source>Note than switching from &lt;a href=&quot;taskbar.state#INDETERMINATE&quot;&gt;&lt;code&gt;INDETERMINATE&lt;/code&gt;&lt;/a&gt; state to any of determinate states may reset value set by &lt;a href=&quot;#setWindowProgressValue(java.awt.Window,int)&quot;&gt;&lt;code&gt;setWindowProgressValue&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;taskbar.state#INDETERMINATE&quot;&gt; &lt;code&gt;INDETERMINATE&lt;/code&gt; &lt;/a&gt; 상태에서 결정 상태로 전환하면 &lt;a href=&quot;#setWindowProgressValue(java.awt.Window,int)&quot;&gt; &lt;code&gt;setWindowProgressValue&lt;/code&gt; 에&lt;/a&gt; 의해 설정된 값이 재설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed1a5713ca95c2fc6cf4c5be606b40352cccb349" translate="yes" xml:space="preserve">
          <source>Note that &quot;the validation&quot; here means &lt;a href=&quot;http://www.w3.org/TR/REC-xml#proc-types&quot;&gt;a validating parser&lt;/a&gt; as defined in the XML recommendation. In other words, it essentially just controls the DTD validation. (except the legacy two properties defined in JAXP 1.2.)</source>
          <target state="translated">여기서 &quot;유효성 검사&quot; 는 XML 권장 사항에 정의 된 &lt;a href=&quot;http://www.w3.org/TR/REC-xml#proc-types&quot;&gt;유효성 검사 구문 분석기&lt;/a&gt; 를 의미 합니다 . 즉, 본질적으로 DTD 유효성 검사 만 제어합니다. (JAXP 1.2에 정의 된 레거시 두 속성 제외)</target>
        </trans-unit>
        <trans-unit id="0dc8e1d721d622d23801e5797defcc02838b37eb" translate="yes" xml:space="preserve">
          <source>Note that &amp;plusmn; means either the plus or minus symbol.</source>
          <target state="translated">&amp;plusmn;는 더하기 또는 빼기 기호를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9c3ad0881c64c35034cb892905b46ab9761fecc9" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#setVisible(boolean)&quot;&gt;&lt;code&gt;setVisible(true)&lt;/code&gt;&lt;/a&gt; may be called indirectly (e.g. when showing an owner of the window makes the window to be shown). &lt;a href=&quot;#toFront()&quot;&gt;&lt;code&gt;toFront()&lt;/code&gt;&lt;/a&gt; may also be called indirectly (e.g. when &lt;a href=&quot;#setVisible(boolean)&quot;&gt;&lt;code&gt;setVisible(true)&lt;/code&gt;&lt;/a&gt; is called on already visible window). In all such cases this property takes effect as well.</source>
          <target state="translated">참고 &lt;a href=&quot;#setVisible(boolean)&quot;&gt; &lt;code&gt;setVisible(true)&lt;/code&gt; &lt;/a&gt; 간접적으로 호출 할 수 있습니다 (예를 들어, 윈도우의 소유자를 표시 할 때 창 표시하도록한다). &lt;a href=&quot;#toFront()&quot;&gt; &lt;code&gt;toFront()&lt;/code&gt; &lt;/a&gt; 는 간접적으로 호출 될 수도 있습니다 (예 : 이미 보이는 창에서 &lt;a href=&quot;#setVisible(boolean)&quot;&gt; &lt;code&gt;setVisible(true)&lt;/code&gt; &lt;/a&gt; 가 호출 될 때 ). 이러한 모든 경우에이 속성도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="12ed974178fb714a814d2645f04845e5748036cd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../bytebuffer&quot;&gt;&lt;code&gt;ByteBuffers&lt;/code&gt;&lt;/a&gt; are not safe for use by multiple concurrent threads. When a read or write operation is initiated then care must be taken to ensure that the buffer is not accessed until the operation completes.</source>
          <target state="translated">참고 &lt;a href=&quot;../bytebuffer&quot;&gt; &lt;code&gt;ByteBuffers&lt;/code&gt; &lt;/a&gt; 복수의 병행 thread로 안전하게 사용할 수 없습니다. 읽기 또는 쓰기 작업이 시작되면 작업이 완료 될 때까지 버퍼에 액세스하지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="86a02fd5610229063b40f764c928b1d94a919ac6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Action&lt;/code&gt; implementations tend to be more expensive in terms of storage than a typical &lt;code&gt;ActionListener&lt;/code&gt;, which does not offer the benefits of centralized control of functionality and broadcast of property changes. For this reason, you should take care to only use &lt;code&gt;Action&lt;/code&gt;s where their benefits are desired, and use simple &lt;code&gt;ActionListener&lt;/code&gt;s elsewhere.</source>
          <target state="translated">참고 &lt;code&gt;Action&lt;/code&gt; 구현은 일반적인 것보다 저장 측면에서 더 비싼 경향이 &lt;code&gt;ActionListener&lt;/code&gt; 기능과의 중앙 제어 나 프로퍼티 변경의 통지의 혜택을 제공하지 않습니다. 따라서 이점이 필요한 경우 에만 &lt;code&gt;Action&lt;/code&gt; 을 사용하고 다른 곳 에서는 간단한 &lt;code&gt;ActionListener&lt;/code&gt; 를 사용 하도록주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e852f1c5096e81d4b549a58e9d4e81aa078fffac" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;AlgorithmConstraints&lt;/code&gt; can be used to represent the restrictions described by the security properties &lt;code&gt;jdk.certpath.disabledAlgorithms&lt;/code&gt; and &lt;code&gt;jdk.tls.disabledAlgorithms&lt;/code&gt;, or could be used by a concrete &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; to check whether a specified certificate in the certification path contains the required algorithm constraints.</source>
          <target state="translated">참고 &lt;code&gt;AlgorithmConstraints&lt;/code&gt; 는 보안 속성에 의해 기술 된 제한을 나타내는 데 사용할 수 있습니다 &lt;code&gt;jdk.certpath.disabledAlgorithms&lt;/code&gt; 및 &lt;code&gt;jdk.tls.disabledAlgorithms&lt;/code&gt; 을 , 또는 콘크리트가 사용할 수있는 &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 의 인증 경로에 지정된 인증 여부를 확인하기 위해 필요한 알고리즘의 제약을 포함 .</target>
        </trans-unit>
        <trans-unit id="5693e990b003b1864adf5153513eee2799bd27ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Character.isLowerCase(Character.toLowerCase(ch))&lt;/code&gt; does not always return &lt;code&gt;true&lt;/code&gt; for some ranges of characters, particularly those that are symbols or ideographs.</source>
          <target state="translated">참고 &lt;code&gt;Character.isLowerCase(Character.toLowerCase(ch))&lt;/code&gt; 항상 반환하지 않습니다 &lt;code&gt;true&lt;/code&gt; 어느 범위의 캐릭터, 표의 문자 나 기호, 특히 사람들을 위해.</target>
        </trans-unit>
        <trans-unit id="5aa889906c2bf5b08e727a2e79f7449c0d2c205e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Character.isLowerCase(Character.toLowerCase(codePoint))&lt;/code&gt; does not always return &lt;code&gt;true&lt;/code&gt; for some ranges of characters, particularly those that are symbols or ideographs.</source>
          <target state="translated">참고 &lt;code&gt;Character.isLowerCase(Character.toLowerCase(codePoint))&lt;/code&gt; 항상 반환하지 않습니다 &lt;code&gt;true&lt;/code&gt; 어느 범위의 캐릭터, 표의 문자 나 기호, 특히 사람들을 위해.</target>
        </trans-unit>
        <trans-unit id="bb53185d5f70e4024135e4a9e50ed39882b81369" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Character.isTitleCase(Character.toTitleCase(ch))&lt;/code&gt; does not always return &lt;code&gt;true&lt;/code&gt; for some ranges of characters.</source>
          <target state="translated">참고 &lt;code&gt;Character.isTitleCase(Character.toTitleCase(ch))&lt;/code&gt; 항상 반환하지 않습니다 &lt;code&gt;true&lt;/code&gt; 어느 범위의 캐릭터에 대해.</target>
        </trans-unit>
        <trans-unit id="fd25284bbdbab09b4e5678a23be0e5888d5aab5d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Character.isTitleCase(Character.toTitleCase(codePoint))&lt;/code&gt; does not always return &lt;code&gt;true&lt;/code&gt; for some ranges of characters.</source>
          <target state="translated">참고 &lt;code&gt;Character.isTitleCase(Character.toTitleCase(codePoint))&lt;/code&gt; 항상 반환하지 않습니다 &lt;code&gt;true&lt;/code&gt; 어느 범위의 캐릭터에 대해.</target>
        </trans-unit>
        <trans-unit id="8c8f5e14f3c45bedc859a28244f2f88bd4fe9f2e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Character.isUpperCase(Character.toUpperCase(ch))&lt;/code&gt; does not always return &lt;code&gt;true&lt;/code&gt; for some ranges of characters, particularly those that are symbols or ideographs.</source>
          <target state="translated">참고 &lt;code&gt;Character.isUpperCase(Character.toUpperCase(ch))&lt;/code&gt; 항상 반환하지 않습니다 &lt;code&gt;true&lt;/code&gt; 어느 범위의 캐릭터, 표의 문자 나 기호, 특히 사람들을 위해.</target>
        </trans-unit>
        <trans-unit id="07b7edc4a186e5fe675652a0f62c1d3726ac037b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Character.isUpperCase(Character.toUpperCase(codePoint))&lt;/code&gt; does not always return &lt;code&gt;true&lt;/code&gt; for some ranges of characters, particularly those that are symbols or ideographs.</source>
          <target state="translated">참고 &lt;code&gt;Character.isUpperCase(Character.toUpperCase(codePoint))&lt;/code&gt; 항상 반환하지 않습니다 &lt;code&gt;true&lt;/code&gt; 어느 범위의 캐릭터, 표의 문자 나 기호, 특히 사람들을 위해.</target>
        </trans-unit>
        <trans-unit id="82a5c68ab87afe780a73e5087aa6eef0b002ca3c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Condition&lt;/code&gt; instances are just normal objects and can themselves be used as the target in a &lt;code&gt;synchronized&lt;/code&gt; statement, and can have their own monitor &lt;a href=&quot;../../../lang/object#wait()&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../lang/object#notify()&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; methods invoked. Acquiring the monitor lock of a &lt;code&gt;Condition&lt;/code&gt; instance, or using its monitor methods, has no specified relationship with acquiring the &lt;a href=&quot;lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; associated with that &lt;code&gt;Condition&lt;/code&gt; or the use of its &lt;a href=&quot;#await()&quot;&gt;waiting&lt;/a&gt; and &lt;a href=&quot;#signal()&quot;&gt;signalling&lt;/a&gt; methods. It is recommended that to avoid confusion you never use &lt;code&gt;Condition&lt;/code&gt; instances in this way, except perhaps within their own implementation.</source>
          <target state="translated">참고 &lt;code&gt;Condition&lt;/code&gt; 인스턴스 그냥 정상적인 개체 스스로가의 대상으로 사용할 수 &lt;code&gt;synchronized&lt;/code&gt; 문, 자신의 모니터 할 수 있습니다 &lt;a href=&quot;../../../lang/object#wait()&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../lang/object#notify()&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; 방법이 호출됩니다. &lt;code&gt;Condition&lt;/code&gt; 인스턴스 의 모니터 잠금을 획득 하거나 해당 모니터 메소드를 사용하는 것은 해당 &lt;code&gt;Condition&lt;/code&gt; 과 연관된 &lt;a href=&quot;lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 획득 또는 &lt;a href=&quot;#await()&quot;&gt;대기&lt;/a&gt; 및 &lt;a href=&quot;#signal()&quot;&gt;신호&lt;/a&gt; 메소드 사용 과 지정된 관계가 없습니다 . 혼동을 피하기 위해 자신의 구현을 제외하고는 이런 방식으로 &lt;code&gt;Condition&lt;/code&gt; 인스턴스를 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="969d87b50048d7224a9eb59de62c9c1b4763dcc2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Condition&lt;/code&gt; instances are just normal objects and can themselves be used as the target in a &lt;code&gt;synchronized&lt;/code&gt; statement, and can have their own monitor &lt;a href=&quot;../../../lang/object#wait-long-&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../lang/object#notify--&quot;&gt;&lt;code&gt;notification&lt;/code&gt;&lt;/a&gt; methods invoked. Acquiring the monitor lock of a &lt;code&gt;Condition&lt;/code&gt; instance, or using its monitor methods, has no specified relationship with acquiring the &lt;a href=&quot;lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; associated with that &lt;code&gt;Condition&lt;/code&gt; or the use of its &lt;a href=&quot;condition#await--&quot;&gt;waiting&lt;/a&gt; and &lt;a href=&quot;condition#signal--&quot;&gt;signalling&lt;/a&gt; methods. It is recommended that to avoid confusion you never use &lt;code&gt;Condition&lt;/code&gt; instances in this way, except perhaps within their own implementation.</source>
          <target state="translated">참고 &lt;code&gt;Condition&lt;/code&gt; 인스턴스 그냥 정상적인 개체 스스로가의 대상으로 사용할 수 &lt;code&gt;synchronized&lt;/code&gt; 문, 자신의 모니터 할 수 있습니다 &lt;a href=&quot;../../../lang/object#wait-long-&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../lang/object#notify--&quot;&gt; &lt;code&gt;notification&lt;/code&gt; &lt;/a&gt; 방법이 호출됩니다. &lt;code&gt;Condition&lt;/code&gt; 인스턴스 의 모니터 잠금을 획득 하거나 모니터 메소드를 사용하여 해당 &lt;code&gt;Condition&lt;/code&gt; 과 연관된 &lt;a href=&quot;lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 을 획득 하거나 &lt;a href=&quot;condition#await--&quot;&gt;대기&lt;/a&gt; 및 &lt;a href=&quot;condition#signal--&quot;&gt;신호&lt;/a&gt; 방식을 사용 하는 것과는 특정한 관계가 없습니다 . 혼동을 피하기 위해 자체 구현 내를 제외하고는 이런 식으로 &lt;code&gt;Condition&lt;/code&gt; 인스턴스를 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a70b4e5ed3f3c4983741e33483880e735127b353" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;DOMSignContext&lt;/code&gt; instances can contain information and state specific to the XML signature structure it is used with. The results are unpredictable if a &lt;code&gt;DOMSignContext&lt;/code&gt; is used with different signature structures (for example, you should not use the same &lt;code&gt;DOMSignContext&lt;/code&gt; instance to sign two different &lt;a href=&quot;../xmlsignature&quot;&gt;&lt;code&gt;XMLSignature&lt;/code&gt;&lt;/a&gt; objects).</source>
          <target state="translated">참고 &lt;code&gt;DOMSignContext&lt;/code&gt; 인스턴스가 함께 사용되는 XML 서명 구조에 대한 정보와 상태 별을 포함 할 수 있습니다. &lt;code&gt;DOMSignContext&lt;/code&gt; 가 다른 서명 구조와 함께 사용되는 경우 결과를 예측할 수 없습니다 (예 : 동일한 &lt;code&gt;DOMSignContext&lt;/code&gt; 인스턴스를 사용하여 두 개의 다른 &lt;a href=&quot;../xmlsignature&quot;&gt; &lt;code&gt;XMLSignature&lt;/code&gt; &lt;/a&gt; 개체 에 서명 하면 안 됨).</target>
        </trans-unit>
        <trans-unit id="29ae460e56b7b6704de58358c727e85a75f2388c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;DataBuffer&lt;/code&gt; objects created by this constructor may be incompatible with &lt;a href=&quot;#optimizations&quot;&gt;performance optimizations&lt;/a&gt; used by some implementations (such as caching an associated image in video memory).</source>
          <target state="translated">참고 &lt;code&gt;DataBuffer&lt;/code&gt; 를는 이 생성자에 의해 생성 개체와 호환 될 수 &lt;a href=&quot;#optimizations&quot;&gt;성능 최적화&lt;/a&gt; (비디오 메모리에 연관된 이미지를 캐싱 같은) 일부 실시 예에서 사용했다.</target>
        </trans-unit>
        <trans-unit id="6f918fc3953109e96da3f24e3a8fbe9164fe30f5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;EndOfLineStringProperty&lt;/code&gt; is set on the &lt;code&gt;Document&lt;/code&gt; using the &lt;code&gt;get/putProperty&lt;/code&gt; methods. Subclasses may override this behavior.</source>
          <target state="translated">참고 &lt;code&gt;EndOfLineStringProperty&lt;/code&gt; 가 온 설정 &lt;code&gt;Document&lt;/code&gt; 사용하여 &lt;code&gt;get/putProperty&lt;/code&gt; 방법을. 서브 클래스는이 동작을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9aac33f2a5f1a7a961261716f9637e334853df9a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;InputEvent.ALT_MASK&lt;/code&gt; and &lt;code&gt;InputEvent.BUTTON2_MASK&lt;/code&gt; have the same value, so the string &quot;Alt&quot; is returned for both modifiers. Likewise, &lt;code&gt;InputEvent.META_MASK&lt;/code&gt; and &lt;code&gt;InputEvent.BUTTON3_MASK&lt;/code&gt; have the same value, so the string &quot;Meta&quot; is returned for both modifiers.</source>
          <target state="translated">참고 &lt;code&gt;InputEvent.ALT_MASK&lt;/code&gt; 및 &lt;code&gt;InputEvent.BUTTON2_MASK&lt;/code&gt; 는 문자열 &quot;Alt를&quot;이 모두 수정에 대해 반환되도록, 같은 값을 가지고있다. 마찬가지로 &lt;code&gt;InputEvent.META_MASK&lt;/code&gt; 및 &lt;code&gt;InputEvent.BUTTON3_MASK&lt;/code&gt; 는 동일한 값을 가지므로 두 수정 자 모두에 대해 문자열 &quot;Meta&quot;가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6e67c10a68b4ce5270a804b321b07cb53f599c6a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;JTree&lt;/code&gt; does not allow duplicate nodes to exist as children under the same parent -- each sibling must be a unique object.</source>
          <target state="translated">주의 &lt;code&gt;JTree&lt;/code&gt; 중복 노드가 같은 부모에서 자식으로 존재하는 것을 허용하지 않습니다 - 각 형제는 고유의 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a821a7e3fe652987c6f808883be56e12f061adcd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Lock&lt;/code&gt; instances are just normal objects and can themselves be used as the target in a &lt;code&gt;synchronized&lt;/code&gt; statement. Acquiring the monitor lock of a &lt;code&gt;Lock&lt;/code&gt; instance has no specified relationship with invoking any of the &lt;a href=&quot;#lock()&quot;&gt;&lt;code&gt;lock()&lt;/code&gt;&lt;/a&gt; methods of that instance. It is recommended that to avoid confusion you never use &lt;code&gt;Lock&lt;/code&gt; instances in this way, except within their own implementation.</source>
          <target state="translated">참고 &lt;code&gt;Lock&lt;/code&gt; 인스턴스 그냥 정상적인 개체 스스로가의 대상으로 사용할 수 &lt;code&gt;synchronized&lt;/code&gt; 문. &lt;code&gt;Lock&lt;/code&gt; 인스턴스 의 모니터 잠금을 획득하는 것은 해당 인스턴스 의 &lt;a href=&quot;#lock()&quot;&gt; &lt;code&gt;lock()&lt;/code&gt; &lt;/a&gt; 메소드 호출과 지정된 관계가 없습니다 . 혼동을 피하기 위해 자체 구현을 제외하고는 이러한 방식으로 &lt;code&gt;Lock&lt;/code&gt; 인스턴스를 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="367f0b7925cfd2c4b0a6daab998802bf5d3119aa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Lock&lt;/code&gt; instances are just normal objects and can themselves be used as the target in a &lt;code&gt;synchronized&lt;/code&gt; statement. Acquiring the monitor lock of a &lt;code&gt;Lock&lt;/code&gt; instance has no specified relationship with invoking any of the &lt;a href=&quot;lock#lock--&quot;&gt;&lt;code&gt;lock()&lt;/code&gt;&lt;/a&gt; methods of that instance. It is recommended that to avoid confusion you never use &lt;code&gt;Lock&lt;/code&gt; instances in this way, except within their own implementation.</source>
          <target state="translated">참고 &lt;code&gt;Lock&lt;/code&gt; 인스턴스 그냥 정상적인 개체 스스로가의 대상으로 사용할 수 &lt;code&gt;synchronized&lt;/code&gt; 문. &lt;code&gt;Lock&lt;/code&gt; 인스턴스 의 모니터 잠금을 확보하는 것은 해당 인스턴스 의 &lt;a href=&quot;lock#lock--&quot;&gt; &lt;code&gt;lock()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것과 관련이 없습니다 . 혼동을 피하기 위해 자체 구현을 제외하고는 이러한 방식으로 &lt;code&gt;Lock&lt;/code&gt; 인스턴스를 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6faa14e5b89a9daf35b25e8e85a4251d2dc97553" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;SNIHostName&lt;/code&gt; objects are immutable.</source>
          <target state="translated">참고 &lt;code&gt;SNIHostName&lt;/code&gt; 의 객체는 불변이다.</target>
        </trans-unit>
        <trans-unit id="9bae93caba5db3c302ed21e48c54c4ee96b50aa2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;XMLCryptoContext&lt;/code&gt; instances can contain information and state specific to the XML cryptographic structure it is used with. The results are unpredictable if an &lt;code&gt;XMLCryptoContext&lt;/code&gt; is used with multiple structures (for example, you should not use the same &lt;a href=&quot;dsig/xmlvalidatecontext&quot;&gt;&lt;code&gt;XMLValidateContext&lt;/code&gt;&lt;/a&gt; instance to validate two different &lt;a href=&quot;dsig/xmlsignature&quot;&gt;&lt;code&gt;XMLSignature&lt;/code&gt;&lt;/a&gt; objects).</source>
          <target state="translated">참고 &lt;code&gt;XMLCryptoContext&lt;/code&gt; 의 인스턴스가 함께 사용되는 XML 암호화 구조에 대한 정보와 상태 별을 포함 할 수 있습니다. &lt;code&gt;XMLCryptoContext&lt;/code&gt; 가 여러 구조와 함께 사용되는 경우 결과를 예측할 수 없습니다 (예를 들어, 동일한 &lt;a href=&quot;dsig/xmlvalidatecontext&quot;&gt; &lt;code&gt;XMLValidateContext&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하여 두 개의 다른 &lt;a href=&quot;dsig/xmlsignature&quot;&gt; &lt;code&gt;XMLSignature&lt;/code&gt; &lt;/a&gt; 개체의 유효성을 검사 하면 안 됨).</target>
        </trans-unit>
        <trans-unit id="c7997674069ee6e64fa278ecbd2e6eb9b1e39f2c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;XMLSignContext&lt;/code&gt; instances can contain information and state specific to the XML signature structure it is used with. The results are unpredictable if an &lt;code&gt;XMLSignContext&lt;/code&gt; is used with different signature structures (for example, you should not use the same &lt;code&gt;XMLSignContext&lt;/code&gt; instance to sign two different &lt;a href=&quot;xmlsignature&quot;&gt;&lt;code&gt;XMLSignature&lt;/code&gt;&lt;/a&gt; objects).</source>
          <target state="translated">참고 &lt;code&gt;XMLSignContext&lt;/code&gt; 를의 인스턴스가 함께 사용되는 XML 서명 구조에 대한 정보와 상태 별을 포함 할 수 있습니다. &lt;code&gt;XMLSignContext&lt;/code&gt; 가 다른 서명 구조와 함께 사용되는 경우 결과를 예측할 수 없습니다 (예를 들어, 동일한 &lt;code&gt;XMLSignContext&lt;/code&gt; 인스턴스를 사용하여 두 개의 다른 &lt;a href=&quot;xmlsignature&quot;&gt; &lt;code&gt;XMLSignature&lt;/code&gt; &lt;/a&gt; 객체 에 서명 하면 안 됨).</target>
        </trans-unit>
        <trans-unit id="430331749e21d3028998a89baa30ce980051c258" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;XMLValidateContext&lt;/code&gt; instances can contain information and state specific to the XML signature structure it is used with. The results are unpredictable if an &lt;code&gt;XMLValidateContext&lt;/code&gt; is used with different signature structures (for example, you should not use the same &lt;code&gt;XMLValidateContext&lt;/code&gt; instance to validate two different &lt;a href=&quot;xmlsignature&quot;&gt;&lt;code&gt;XMLSignature&lt;/code&gt;&lt;/a&gt; objects).</source>
          <target state="translated">참고 &lt;code&gt;XMLValidateContext&lt;/code&gt; 인스턴스가 함께 사용되는 XML 서명 구조에 대한 정보와 상태 별을 포함 할 수 있습니다. &lt;code&gt;XMLValidateContext&lt;/code&gt; 가 다른 서명 구조와 함께 사용되는 경우 결과를 예측할 수 없습니다 (예를 들어, 동일한 &lt;code&gt;XMLValidateContext&lt;/code&gt; 인스턴스를 사용하여 두 개의 다른 &lt;a href=&quot;xmlsignature&quot;&gt; &lt;code&gt;XMLSignature&lt;/code&gt; &lt;/a&gt; 객체의 유효성을 검사 해서는 안 됨 ).</target>
        </trans-unit>
        <trans-unit id="01b565aa70f1c705688ee75054f8530632c06266" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;checkPermission&lt;/code&gt; always performs security checks within the context of the currently executing thread. Sometimes a security check that should be made within a given context will actually need to be done from within a</source>
          <target state="translated">참고 것을 &lt;code&gt;checkPermission&lt;/code&gt; 항상 현재 실행중인 스레드의 컨텍스트 내에서 보안 검사를 수행합니다. 때때로 주어진 맥락 내에서 이루어져야하는 보안 점검은 실제로</target>
        </trans-unit>
        <trans-unit id="e070ad3eeb169492de9989f4604e9e475494594d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;fma(a, 1.0, c)&lt;/code&gt; returns the same result as (&lt;code&gt;a + c&lt;/code&gt;). However, &lt;code&gt;fma(a, b, +0.0)&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; always return the same result as (&lt;code&gt;a * b&lt;/code&gt;) since &lt;code&gt;fma(-0.0, +0.0, +0.0)&lt;/code&gt; is &lt;code&gt;+0.0&lt;/code&gt; while (&lt;code&gt;-0.0 * +0.0&lt;/code&gt;) is &lt;code&gt;-0.0&lt;/code&gt;; &lt;code&gt;fma(a, b, -0.0)&lt;/code&gt; is equivalent to (&lt;code&gt;a * b&lt;/code&gt;) however.</source>
          <target state="translated">참고 &lt;code&gt;fma(a, 1.0, c)&lt;/code&gt; (동일한 결과를 반환 &lt;code&gt;a + c&lt;/code&gt; ). 그러나 &lt;code&gt;fma(a, b, +0.0)&lt;/code&gt; 는 &lt;code&gt;fma(-0.0, +0.0, +0.0)&lt;/code&gt; 이 &lt;code&gt;+0.0&lt;/code&gt; 이고 ( &lt;code&gt;-0.0 * +0.0&lt;/code&gt; )이 &lt;code&gt;-0.0&lt;/code&gt; 이므로 항상 ( &lt;code&gt;a * b&lt;/code&gt; ) 와 동일한 결과를 반환 하지는 &lt;em&gt;않습니다 &lt;/em&gt;. ; &lt;code&gt;fma(a, b, -0.0)&lt;/code&gt; 은 ( &lt;code&gt;a * b&lt;/code&gt; ) 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="46d28d0b05402322819c21979cfdfcb98e5b1456" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;fma(a, 1.0f, c)&lt;/code&gt; returns the same result as (&lt;code&gt;a + c&lt;/code&gt;). However, &lt;code&gt;fma(a, b, +0.0f)&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; always return the same result as (&lt;code&gt;a * b&lt;/code&gt;) since &lt;code&gt;fma(-0.0f, +0.0f, +0.0f)&lt;/code&gt; is &lt;code&gt;+0.0f&lt;/code&gt; while (&lt;code&gt;-0.0f * +0.0f&lt;/code&gt;) is &lt;code&gt;-0.0f&lt;/code&gt;; &lt;code&gt;fma(a, b, -0.0f)&lt;/code&gt; is equivalent to (&lt;code&gt;a * b&lt;/code&gt;) however.</source>
          <target state="translated">참고 &lt;code&gt;fma(a, 1.0f, c)&lt;/code&gt; (동일한 결과를 반환 &lt;code&gt;a + c&lt;/code&gt; ). 그러나 &lt;code&gt;fma(a, b, +0.0f)&lt;/code&gt; 는 &lt;code&gt;fma(-0.0f, +0.0f, +0.0f)&lt;/code&gt; 가 &lt;code&gt;+0.0f&lt;/code&gt; 이고 ( &lt;code&gt;-0.0f * +0.0f&lt;/code&gt; )이므로 항상 ( &lt;code&gt;a * b&lt;/code&gt; ) 와 동일한 결과를 반환 하지는 &lt;em&gt;않습니다. &lt;/em&gt;+ 0.0f )는 &lt;code&gt;-0.0f&lt;/code&gt; 이고; &lt;code&gt;fma(a, b, -0.0f)&lt;/code&gt; 는 ( &lt;code&gt;a * b&lt;/code&gt; ) 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="751635249b1851770502231c6f5f7e862fbadb4c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;fusedMac(a, 1.0, c)&lt;/code&gt; returns the same result as (&lt;code&gt;a + c&lt;/code&gt;). However, &lt;code&gt;fusedMac(a, b, +0.0)&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; always return the same result as (&lt;code&gt;a * b&lt;/code&gt;) since &lt;code&gt;fusedMac(-0.0, +0.0, +0.0)&lt;/code&gt; is &lt;code&gt;+0.0&lt;/code&gt; while (&lt;code&gt;-0.0 * +0.0&lt;/code&gt;) is &lt;code&gt;-0.0&lt;/code&gt;; &lt;code&gt;fusedMac(a, b, -0.0)&lt;/code&gt; is equivalent to (&lt;code&gt;a * b&lt;/code&gt;) however.</source>
          <target state="translated">참고 &lt;code&gt;fusedMac(a, 1.0, c)&lt;/code&gt; (동일한 결과를 반환 &lt;code&gt;a + c&lt;/code&gt; ). 그러나 &lt;code&gt;fusedMac(a, b, +0.0)&lt;/code&gt; 은 &lt;code&gt;fusedMac(-0.0, +0.0, +0.0)&lt;/code&gt; 은 &lt;code&gt;+0.0&lt;/code&gt; 이고 ( &lt;code&gt;-0.0 * +0.0&lt;/code&gt; )은 ( &lt;code&gt;a * b&lt;/code&gt; )이므로 항상 동일한 결과를 반환 하지는 &lt;em&gt;않습니다.&lt;/em&gt; &lt;code&gt;-0.0&lt;/code&gt; . ; &lt;code&gt;fusedMac(a, b, -0.0)&lt;/code&gt; 은 ( &lt;code&gt;a * b&lt;/code&gt; ) 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f1d3ec9620fedb70bb0ad4b44c5b26740fa77bfe" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;getTransferable()&lt;/code&gt; on the &lt;code&gt;DropTargetDragEvent&lt;/code&gt; instance should only be called within the respective listener's method and all the necessary data should be retrieved from the returned &lt;code&gt;Transferable&lt;/code&gt; before that method returns.</source>
          <target state="translated">참고 &lt;code&gt;getTransferable()&lt;/code&gt; 상의 &lt;code&gt;DropTargetDragEvent&lt;/code&gt; 인스턴스가 각 청취자의 메소드 내에서만 호출되어야하며, 필요한 모든 데이터가 반환에서 검색해야 &lt;code&gt;Transferable&lt;/code&gt; 하는 방법을 반환하기 전에.</target>
        </trans-unit>
        <trans-unit id="715c104a070d9004f80b0ac211711f9a1d352c0d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;lhs.add(rhs)&lt;/code&gt; will be always successful if &lt;code&gt;lhs.signum()*rhs.signum()!=-1&lt;/code&gt; or both of them are normalized.</source>
          <target state="translated">참고 &lt;code&gt;lhs.add(rhs)&lt;/code&gt; 경우 항상 성공할 수 &lt;code&gt;lhs.signum()*rhs.signum()!=-1&lt;/code&gt; 정규화 또는 둘 다.</target>
        </trans-unit>
        <trans-unit id="c303f9d44f43e70fd8034e20e43466a550c2db93" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;next()&lt;/code&gt; can also throw the runtime exception NoSuchElementException to indicate that the caller is attempting to enumerate beyond the end of the enumeration. This is different from a NamingException, which indicates that there was a problem in obtaining the next element, for example, due to a referral or server unavailability, etc.</source>
          <target state="translated">주의 &lt;code&gt;next()&lt;/code&gt; 또한 런타임 예외 예외 : NoSuchElementException이 호출 측이 열거의 넘어 열거하려고하고있는 것을 표시하기 위해 던질 수 있습니다. 이는 NamingException과 다릅니다. 예를 들어 조회 또는 서버를 사용할 수없는 등으로 인해 다음 요소를 얻는 데 문제가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0f0f28fe91cf34c0e242b03fcbbbe1817969dcb2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;requestControls&lt;/code&gt; will be in effect until the next invocation of &lt;code&gt;setRequestControls()&lt;/code&gt;. You need to explicitly invoke &lt;code&gt;setRequestControls()&lt;/code&gt; with &lt;code&gt;null&lt;/code&gt; or an empty array to clear the controls if you don't want them to affect the context methods any more. To check what request controls are in effect for this context, use &lt;code&gt;getRequestControls()&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;requestControls&lt;/code&gt; 이 의 다음의 호출 될 때까지 유효합니다 &lt;code&gt;setRequestControls()&lt;/code&gt; . 컨텍스트 메소드에 더 이상 영향을 미치지 않도록하려면 컨트롤을 지우려면 &lt;code&gt;null&lt;/code&gt; 또는 빈 배열을 사용 하여 &lt;code&gt;setRequestControls()&lt;/code&gt; 를 명시 적으로 호출해야합니다 . 이 컨텍스트에 유효한 요청 제어를 확인하려면 &lt;code&gt;getRequestControls()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f555cd9496b7c4ad8d14b942e1f570687e14dab" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;toArray(new Object[0])&lt;/code&gt; is identical in function to &lt;code&gt;toArray()&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;toArray(new Object[0])&lt;/code&gt; 와 기능이 동일하다 &lt;code&gt;toArray()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8acbfd4505485a853ac64781fc06165e36d48cf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;tryFinally&lt;/code&gt; never converts exceptions into normal returns. In rare cases where exceptions must be converted in that way, first wrap the target with &lt;a href=&quot;#catchException(java.lang.invoke.MethodHandle,java.lang.Class,java.lang.invoke.MethodHandle)&quot;&gt;&lt;code&gt;catchException(MethodHandle, Class, MethodHandle)&lt;/code&gt;&lt;/a&gt; to capture an outgoing exception, and then wrap with &lt;code&gt;tryFinally&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;tryFinally&lt;/code&gt; 은 결코 정상적인 반환에 예외를 변환하지 않습니다. 예외를 그런 방식으로 변환해야하는 드문 경우에는 먼저 대상을 다음으로 래핑하십시오.&lt;a href=&quot;#catchException(java.lang.invoke.MethodHandle,java.lang.Class,java.lang.invoke.MethodHandle)&quot;&gt; &lt;code&gt;catchException(MethodHandle, Class, MethodHandle)&lt;/code&gt; &lt;/a&gt; 으로 래핑하여 나가는 예외를 캡처 한 다음 &lt;code&gt;tryFinally&lt;/code&gt; 로 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="c801893278bac63085faee1ba97fecc2829be1a8" translate="yes" xml:space="preserve">
          <source>Note that GCM mode has a uniqueness requirement on IVs used in encryption with a given key. When IVs are repeated for GCM encryption, such usages are subject to forgery attacks. Thus, after each encryption operation using GCM mode, callers should re-initialize the cipher objects with GCM parameters which has a different IV value.</source>
          <target state="translated">GCM 모드에는 지정된 키를 사용하여 암호화하는 데 사용되는 IV에 대한 고유성 요구 사항이 있습니다. GCM 암호화를 위해 IV를 반복하면 그러한 사용은 위조 공격의 대상이됩니다. 따라서 GCM 모드를 사용하는 각 암호화 작업 후에 호출자는 다른 IV 값을 갖는 GCM 매개 변수를 사용하여 암호 오브젝트를 다시 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="a364e70bb1bbc694d72d1d3b629a30773aa861de" translate="yes" xml:space="preserve">
          <source>Note that GCM mode has a uniqueness requirement on IVs used in encryption with a given key. When IVs are repeated for GCM encryption, such usages are subject to forgery attacks. Thus, after each encryption operation using GCM mode, callers should re-initialize the cipher objects with GCM parameters which have a different IV value.</source>
          <target state="translated">GCM 모드에는 지정된 키로 암호화에 사용되는 IV에 대한 고유성 요구 사항이 있습니다. GCM 암호화를 위해 IV가 반복되면 이러한 사용은 위조 공격의 대상이됩니다. 따라서 GCM 모드를 사용하는 각 암호화 작업 후에 호출자는 IV 값이 다른 GCM 매개 변수를 사용하여 암호 객체를 다시 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="b535f9d0cd0047457206fd619751083580f479e2" translate="yes" xml:space="preserve">
          <source>Note that Group extends Principal. Thus, either a Principal or a Group can be passed as an argument to methods containing a Principal parameter. For example, you can add either a Principal or a Group to a Group object by calling the object's &lt;code&gt;addMember&lt;/code&gt; method, passing it the Principal or Group.</source>
          <target state="translated">그룹은 교장을 확장합니다. 따라서 Principal 또는 Group을 Principal 매개 변수를 포함하는 메소드에 인수로 전달할 수 있습니다. 예를 들어 객체의 &lt;code&gt;addMember&lt;/code&gt; 메소드 를 호출 하여 Principal 또는 Group을 전달하여 Principal 또는 Group을 Group 객체에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80e9fd658071ec35671ad6b6a0b5878b5eb26240" translate="yes" xml:space="preserve">
          <source>Note that KeyboardFocusManager itself implements KeyEventDispatcher. By default, the current KeyboardFocusManager will be the sink for all KeyEvents not dispatched by the registered KeyEventDispatchers. The current KeyboardFocusManager cannot be completely deregistered as a KeyEventDispatcher. However, if a KeyEventDispatcher reports that it dispatched the KeyEvent, regardless of whether it actually did so, the KeyboardFocusManager will take no further action with regard to the KeyEvent. (While it is possible for client code to register the current KeyboardFocusManager as a KeyEventDispatcher one or more times, this is usually unnecessary and not recommended.)</source>
          <target state="translated">KeyboardFocusManager 자체는 KeyEventDispatcher를 구현합니다. 기본적으로 현재 KeyboardFocusManager는 등록 된 KeyEventDispatcher에서 전달하지 않은 모든 KeyEvent에 대한 싱크가됩니다. 현재 KeyboardFocusManager는 KeyEventDispatcher로 완전히 등록 취소 할 수 없습니다. 그러나 KeyEventDispatcher가 실제로 KeyEvent를 전달했는지 여부에 관계없이 KeyEvent를 전달했다고보고하면 KeyboardFocusManager는 KeyEvent와 관련하여 추가 작업을 수행하지 않습니다. (클라이언트 코드에서 현재 KeyboardFocusManager를 KeyEventDispatcher로 한 번 이상 등록 할 수 있지만 일반적으로 불필요하며 권장되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="6bd45960e81f3c6748a26ca766fa292258b3b3ca" translate="yes" xml:space="preserve">
          <source>Note that SAX is a callback architecture and the returned SAXResult has a content handler assigned that will receive the SAX events based on the contents of the XML. Call the content handler with the contents of the XML document to assign the values.</source>
          <target state="translated">SAX는 콜백 아키텍처이며 반환 된 SAXResult에는 XML 콘텐츠를 기반으로 SAX 이벤트를 수신하는 콘텐츠 처리기가 할당되어 있습니다. XML 문서의 컨텐츠로 컨텐츠 핸들러를 호출하여 값을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="c89a5d54509298d329502e45b16c2343525bab8a" translate="yes" xml:space="preserve">
          <source>Note that SAX is a callback architecture, so a returned SAXSource should then be set with a content handler that will receive the SAX events from parsing. The content handler will receive callbacks based on the contents of the XML.</source>
          <target state="translated">SAX는 콜백 아키텍처이므로 반환 된 SAXSource는 구문 분석에서 SAX 이벤트를 수신 할 콘텐츠 핸들러로 설정해야합니다. 컨텐츠 핸들러는 XML 컨텐츠를 기반으로 콜백을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="a4c996848157f75849887d36b83d74b354c75b6e" translate="yes" xml:space="preserve">
          <source>Note that Source and Destination may be the same object.</source>
          <target state="translated">소스와 대상은 동일한 개체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="753e0f11ad0db5ec8b955c024e9f76a2de7a424d" translate="yes" xml:space="preserve">
          <source>Note that TemplatesHandler does not need to implement LexicalHandler.</source>
          <target state="translated">TemplatesHandler는 LexicalHandler를 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3af69e2315676a2db438b4e94f0d1a09056758cd" translate="yes" xml:space="preserve">
          <source>Note that XSLT requires namespace support. Attempting to transform a DOM that was not contructed with a namespace-aware parser may result in errors. Parsers can be made namespace aware by calling &lt;a href=&quot;../../parsers/documentbuilderfactory#setNamespaceAware(boolean)&quot;&gt;&lt;code&gt;DocumentBuilderFactory.setNamespaceAware(boolean awareness)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">XSLT에는 네임 스페이스 지원이 필요합니다. 네임 스페이스 인식 파서로 구성되지 않은 DOM을 변환하려고하면 오류가 발생할 수 있습니다. &lt;a href=&quot;../../parsers/documentbuilderfactory#setNamespaceAware(boolean)&quot;&gt; &lt;code&gt;DocumentBuilderFactory.setNamespaceAware(boolean awareness)&lt;/code&gt; &lt;/a&gt; 호출하여 구문 분석기가 네임 스페이스를 인식하도록 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="ebf79c69c1a7ac02ecbb2ddb908527c39c1b4d46" translate="yes" xml:space="preserve">
          <source>Note that XSLT requires namespace support. Attempting to transform an input source that is not generated with a namespace-aware parser may result in errors. Parsers can be made namespace aware by calling the &lt;a href=&quot;../../parsers/saxparserfactory#setNamespaceAware(boolean)&quot;&gt;&lt;code&gt;SAXParserFactory.setNamespaceAware(boolean awareness)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">XSLT에는 네임 스페이스 지원이 필요합니다. 네임 스페이스 인식 파서로 생성되지 않은 입력 소스를 변환하려고하면 오류가 발생할 수 있습니다. 파서는 &lt;a href=&quot;../../parsers/saxparserfactory#setNamespaceAware(boolean)&quot;&gt; &lt;code&gt;SAXParserFactory.setNamespaceAware(boolean awareness)&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여 네임 스페이스를 인식하도록 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d25a7ac12fda91dbfe31fd9689fdc60cfd4bbf4f" translate="yes" xml:space="preserve">
          <source>Note that a</source>
          <target state="translated">참고</target>
        </trans-unit>
        <trans-unit id="292883bb7d98195813924dadc5a5af6a32e90fb3" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;Rectangle&lt;/code&gt; constructed with the default no-argument constructor will have dimensions of &lt;code&gt;0x0&lt;/code&gt; and therefore be empty. That &lt;code&gt;Rectangle&lt;/code&gt; will still have a location of &lt;code&gt;(0,0)&lt;/code&gt; and will contribute that location to the union and add operations. Code attempting to accumulate the bounds of a set of points should therefore initially construct the &lt;code&gt;Rectangle&lt;/code&gt; with a specifically negative width and height or it should use the first point in the set to construct the &lt;code&gt;Rectangle&lt;/code&gt;. For example:</source>
          <target state="translated">인수가없는 기본 생성자로 생성 된 &lt;code&gt;Rectangle&lt;/code&gt; 은 &lt;code&gt;0x0&lt;/code&gt; 크기를 가지 므로 비어 있습니다. 해당 &lt;code&gt;Rectangle&lt;/code&gt; 은 여전히 &lt;code&gt;(0,0)&lt;/code&gt; 의 위치를 ​​가지며 해당 위치를 통합 및 추가 작업에 기여합니다. 코드 따라서 초기 구축한다 포인트들의 집합의 범위를 축적하려고 &lt;code&gt;Rectangle&lt;/code&gt; 특별히 제외 폭과 높이 또는 그것을 구성하는 세트에서 첫 번째 지점을 사용해야 &lt;code&gt;Rectangle&lt;/code&gt; . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="7198a7a427aa50326b21907238753517c6fa2c54" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;SizeSequence&lt;/code&gt; object simply represents intervals along an axis. In our examples, the intervals represent height or width in pixels. However, any other unit of measure (for example, time in days) could be just as valid.</source>
          <target state="translated">&amp;bull; 그래도주의 &lt;code&gt;SizeSequence&lt;/code&gt; 오브젝트는 단지 축으로 따른 간격을 나타냅니다. 예제에서 간격은 높이 또는 너비를 픽셀 단위로 나타냅니다. 그러나 다른 측정 단위 (예 : 시간 (일))도 마찬가지로 유효 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b054443557175839f163b29e72d58ee850c306ea" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;StreamPrintService&lt;/code&gt; is different from a &lt;code&gt;PrintService&lt;/code&gt;, which supports a &lt;a href=&quot;attribute/standard/destination&quot;&gt;&lt;code&gt;Destination&lt;/code&gt;&lt;/a&gt; attribute. A &lt;code&gt;StreamPrintService&lt;/code&gt; always requires an output stream, whereas a &lt;code&gt;PrintService&lt;/code&gt; optionally accepts a &lt;code&gt;Destination&lt;/code&gt;. A &lt;code&gt;StreamPrintService&lt;/code&gt; has no default destination for its formatted output. Additionally a &lt;code&gt;StreamPrintService&lt;/code&gt; is expected to generate output in a format useful in other contexts. &lt;code&gt;StreamPrintService&lt;/code&gt;'s are not expected to support the &lt;code&gt;Destination&lt;/code&gt; attribute.</source>
          <target state="translated">참고 &amp;bull; 그래도 &lt;code&gt;StreamPrintService&lt;/code&gt; 를가 A로부터 다른 &lt;code&gt;PrintService&lt;/code&gt; 의 지원 &lt;a href=&quot;attribute/standard/destination&quot;&gt; &lt;code&gt;Destination&lt;/code&gt; &lt;/a&gt; 속성을. &lt;code&gt;StreamPrintService&lt;/code&gt; 를는 반면 항상 출력 스트림을 필요 &lt;code&gt;PrintService&lt;/code&gt; 임의로 허용 &lt;code&gt;Destination&lt;/code&gt; . &lt;code&gt;StreamPrintService&lt;/code&gt; 를가 포맷 된 출력의 디폴트의 행선지가 없습니다. 또한 &lt;code&gt;StreamPrintService&lt;/code&gt; 는 다른 컨텍스트에서 유용한 형식으로 출력을 생성 할 것으로 예상됩니다. &lt;code&gt;StreamPrintService&lt;/code&gt; 가 &lt;code&gt;Destination&lt;/code&gt; 속성 을 지원하지 않을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6c5b53d66cdf13bfe013b84a77971bbdf1792ff" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;StreamPrintService&lt;/code&gt; is different from a &lt;code&gt;PrintService&lt;/code&gt;, which supports a &lt;a href=&quot;attribute/standard/destination&quot;&gt;&lt;code&gt;Destination&lt;/code&gt;&lt;/a&gt; attribute. A &lt;code&gt;StreamPrintService&lt;/code&gt; always requires an output stream, whereas a &lt;code&gt;PrintService&lt;/code&gt; optionally accepts a &lt;code&gt;Destination&lt;/code&gt;. A &lt;code&gt;StreamPrintService&lt;/code&gt; has no default destination for its formatted output. Additionally a &lt;code&gt;StreamPrintService&lt;/code&gt; is expected to generate output in a format useful in other contexts. StreamPrintService's are not expected to support the Destination attribute.</source>
          <target state="translated">참고 &amp;bull; 그래도 &lt;code&gt;StreamPrintService&lt;/code&gt; 를가 A로부터 다른 &lt;code&gt;PrintService&lt;/code&gt; 의 지원 &lt;a href=&quot;attribute/standard/destination&quot;&gt; &lt;code&gt;Destination&lt;/code&gt; &lt;/a&gt; 속성을. &lt;code&gt;StreamPrintService&lt;/code&gt; 를는 반면 항상 출력 스트림을 필요 &lt;code&gt;PrintService&lt;/code&gt; 임의로 허용 &lt;code&gt;Destination&lt;/code&gt; . &lt;code&gt;StreamPrintService&lt;/code&gt; 를가 포맷 된 출력의 디폴트의 행선지가 없습니다. 또한 &lt;code&gt;StreamPrintService&lt;/code&gt; 는 다른 컨텍스트에서 유용한 형식으로 출력을 생성 할 것으로 예상됩니다. StreamPrintService는 Destination 속성을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="065b9c893c941cc91da53a4905e46e77cc4e3448" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;getRegistry&lt;/code&gt; call does not actually make a connection to the remote host. It simply creates a local reference to the remote registry and will succeed even if no registry is running on the remote host. Therefore, a subsequent method invocation to a remote registry returned as a result of this method may fail.</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;code&gt;getRegistry&lt;/code&gt; 의의 호출이 실제로 원격 호스트로의 연결을하지 않습니다. 단순히 원격 레지스트리에 대한 로컬 참조를 작성하고 원격 호스트에서 실행중인 레지스트리가없는 경우에도 성공합니다. 따라서이 메서드의 결과로 반환 된 원격 레지스트리에 대한 후속 메서드 호출이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8621800d2c0a1c4838da7f61bd55d73d7a8cb633" translate="yes" xml:space="preserve">
          <source>Note that a BeanContextChild may refuse a change in state by throwing PropertyVetoedException in response.</source>
          <target state="translated">BeanContextChild는 응답으로 PropertyVetoedException을 발생시켜 상태 변경을 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9892fd70eedf9e4246f57ad5454b2aad55a8ae12" translate="yes" xml:space="preserve">
          <source>Note that a Namespace URI can be bound to &lt;strong&gt;multiple&lt;/strong&gt; prefixes in the current scope. This can occur when multiple &lt;code&gt;XMLConstants.XMLNS_ATTRIBUTE&lt;/code&gt; (&quot;xmlns&quot;) Namespace declarations occur in the same Start-Tag and refer to the same Namespace URI. e.g.</source>
          <target state="translated">네임 스페이스 URI는 현재 범위의 &lt;strong&gt;여러&lt;/strong&gt; 접두사에 바인딩 될 수 있습니다 . 이는 여러 &lt;code&gt;XMLConstants.XMLNS_ATTRIBUTE&lt;/code&gt; ( &quot;xmlns&quot;) 네임 스페이스 선언이 동일한 시작 태그에서 발생하고 동일한 네임 스페이스 URI를 참조 할 때 발생할 수 있습니다 . 예</target>
        </trans-unit>
        <trans-unit id="1c0b4c6bad4822981c50fad9af3bead9581677b1" translate="yes" xml:space="preserve">
          <source>Note that a caller must use the same &lt;code&gt;KeyInfoFactory&lt;/code&gt; instance to create the &lt;code&gt;XMLStructure&lt;/code&gt;s of a particular &lt;code&gt;KeyInfo&lt;/code&gt; object. The behavior is undefined if &lt;code&gt;XMLStructure&lt;/code&gt;s from different providers or different mechanism types are used together.</source>
          <target state="translated">호출자는 특정 &lt;code&gt;KeyInfo&lt;/code&gt; 객체 의 &lt;code&gt;XMLStructure&lt;/code&gt; 를 생성하기 위해 동일한 &lt;code&gt;KeyInfoFactory&lt;/code&gt; 인스턴스를 사용해야 합니다. 다른 공급자 또는 다른 메커니즘 유형의 &lt;code&gt;XMLStructure&lt;/code&gt; 가 함께 사용되는 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7dfc6ceda52f5bdfc1053bd4356fcab3358647c2" translate="yes" xml:space="preserve">
          <source>Note that a caller must use the same &lt;code&gt;XMLSignatureFactory&lt;/code&gt; instance to create the &lt;code&gt;XMLStructure&lt;/code&gt;s of a particular &lt;code&gt;XMLSignature&lt;/code&gt; that is to be generated. The behavior is undefined if &lt;code&gt;XMLStructure&lt;/code&gt;s from different providers or different mechanism types are used together.</source>
          <target state="translated">호출자는 생성 될 특정 &lt;code&gt;XMLSignature&lt;/code&gt; 의 &lt;code&gt;XMLStructure&lt;/code&gt; 를 생성하기 위해 동일한 &lt;code&gt;XMLSignatureFactory&lt;/code&gt; 인스턴스를 사용해야합니다 . 다른 공급자 또는 다른 메커니즘 유형의 &lt;code&gt;XMLStructure&lt;/code&gt; 가 함께 사용되는 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8f4b7753322255a2f437b72f68cd516efff9e2d7" translate="yes" xml:space="preserve">
          <source>Note that a common prefix length of &lt;code&gt;0&lt;/code&gt; indicates that the first elements from each array mismatch.</source>
          <target state="translated">공통 접두사 길이 &lt;code&gt;0&lt;/code&gt; 은 각 배열의 첫 번째 요소가 일치하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a9595bc40bab29ca925be13eb25848bd5356768e" translate="yes" xml:space="preserve">
          <source>Note that a conflict is a situation where the &lt;code&gt;RowSet&lt;/code&gt; object's original values for a row do not match the values in the data source, which indicates that the data source row has been modified since the last synchronization. Note also that a &lt;code&gt;RowSet&lt;/code&gt; object's original values are the values it had just prior to the the last synchronization, which are not necessarily its initial values.</source>
          <target state="translated">충돌은 행에 대한 &lt;code&gt;RowSet&lt;/code&gt; 개체의 원래 값이 데이터 원본의 값과 일치하지 않는 상황이며, 이는 데이터 원본 행이 마지막 동기화 이후 수정되었음을 나타냅니다. 또한 &lt;code&gt;RowSet&lt;/code&gt; 객체의 원래 값은 마지막 동기화 직전에 가지고 있던 값이며 반드시 초기 값은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6ce89c9484917860e5d23ba2c7c4fe17293ecf2b" translate="yes" xml:space="preserve">
          <source>Note that a control factory must be public and must have a public constructor that accepts no arguments.</source>
          <target state="translated">제어 팩토리는 공용이어야하며 인수를 허용하지 않는 공용 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f2a07378324e46e67c31eff44b1eae1eeba36f83" translate="yes" xml:space="preserve">
          <source>Note that a control factory must be public and must have a public constructor that accepts no arguments. In cases where the factory is in a named module then it must be in a package which is exported by that module to the &lt;code&gt;java.naming&lt;/code&gt; module.</source>
          <target state="translated">컨트롤 팩토리는 공용이어야하며 인수를 허용하지 않는 공용 생성자가 있어야합니다. 팩토리가 명명 된 모듈에있는 경우 해당 모듈에서 &lt;code&gt;java.naming&lt;/code&gt; 모듈 로 내보내는 패키지에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="67757ab345174616d12fc7211a1c332820ffc2af" translate="yes" xml:space="preserve">
          <source>Note that a copy is performed on the &lt;code&gt;Collection&lt;/code&gt; to protect against subsequent modifications.</source>
          <target state="translated">후속 수정으로부터 보호하기 위해 &lt;code&gt;Collection&lt;/code&gt; 에서 복사가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="788a169b36f3add03ea741c08f3772ab5b7f151c" translate="yes" xml:space="preserve">
          <source>Note that a deep copy is performed on the &lt;code&gt;Collection&lt;/code&gt; to protect against subsequent modifications.</source>
          <target state="translated">후속 수정으로부터 보호하기 위해 &lt;code&gt;Collection&lt;/code&gt; 에서 깊은 복사가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c74714de547c9f3179bad79056953a0fd5274a55" translate="yes" xml:space="preserve">
          <source>Note that a different set of metacharacters are in effect inside a character class than outside a character class. For instance, the regular expression &lt;code&gt;.&lt;/code&gt; loses its special meaning inside a character class, while the expression &lt;code&gt;-&lt;/code&gt; becomes a range forming metacharacter.</source>
          <target state="translated">문자 클래스 외부와 다른 메타 문자 집합이 문자 클래스 내부에 적용됩니다. 예를 들어 정규 표현식 &lt;code&gt;.&lt;/code&gt; 식이 동안, 문자 클래스 내에서 특별한 의미를 잃는다 &lt;code&gt;-&lt;/code&gt; 범위 형성 메타 문자가된다.</target>
        </trans-unit>
        <trans-unit id="69d13037a1aa8eb912d998be785b72c28abfc774" translate="yes" xml:space="preserve">
          <source>Note that a non-ISO calendar system may have year numbering system that changes at a different point to the natural reset in the month numbering. An example of this is the Japanese calendar system where a change of era, which resets the year number to 1, can happen on any date. The era and year reset also cause the day-of-year to be reset to 1, but not the month-of-year or day-of-month.</source>
          <target state="translated">비 ISO 캘린더 시스템에는 월 번호 매기기의 자연 재설정과 다른 지점에서 변경되는 연도 번호 시스템이있을 수 있습니다. 예를 들어 연도 번호를 1로 재설정하는 시대 변경이 모든 날짜에서 발생할 수있는 일본 달력 시스템이 그 예입니다. 연도 및 연도 재설정으로 인해 연도는 1로 재설정되지만 월 또는 월은 재설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b98789af50a8efe7a69df22fc573d587833e6ea5" translate="yes" xml:space="preserve">
          <source>Note that a serialized Key may contain sensitive information which should not be exposed in untrusted environments. See the  Security Appendix of the Serialization Specification for more information.</source>
          <target state="translated">직렬화 된 키에는 신뢰할 수없는 환경에 노출되어서는 안되는 민감한 정보가 포함될 수 있습니다. 자세한 내용은 직렬화 사양의 보안 부록을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="23caa8218734c950233a7fe5362d9996f427da4b" translate="yes" xml:space="preserve">
          <source>Note that a serialized Key may contain sensitive information which should not be exposed in untrusted environments. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/security.html&quot;&gt; Security Appendix&lt;/a&gt; of the Serialization Specification for more information.</source>
          <target state="translated">직렬화 된 키에는 신뢰할 수없는 환경에 노출되어서는 안되는 민감한 정보가 포함될 수 있습니다. 자세한 내용은 직렬화 사양 의 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/security.html&quot;&gt;보안 부록&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="85abf2a019a02a3b0ad0f40715a7ab7b9a9a7779" translate="yes" xml:space="preserve">
          <source>Note that a space appears before each &lt;code&gt;\&lt;/code&gt; so that a space will appear after each comma in the final result; the &lt;code&gt;\&lt;/code&gt;, line terminator, and leading white space on the continuation line are merely discarded and are</source>
          <target state="translated">주 공간은 각 전에 나타납니다 &lt;code&gt;\&lt;/code&gt; 그래서 공간이 최종적인 결과로 콤마의 후에 나타날 것입니다; 연속 줄 의 &lt;code&gt;\&lt;/code&gt; , 줄 종결 자 및 선행 공백은 단순히 무시되며</target>
        </trans-unit>
        <trans-unit id="af66d5610f588b95804f84efe617919d8f48b790" translate="yes" xml:space="preserve">
          <source>Note that a state factory (an object that implements the StateFactory interface) must be public and must have a public constructor that accepts no arguments.</source>
          <target state="translated">상태 팩토리 (StateFactory 인터페이스를 구현하는 객체)는 공용이어야하며 인수를 허용하지 않는 공용 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b0c8bd26f94ce38c412a74fe0b08db578c2f63f5" translate="yes" xml:space="preserve">
          <source>Note that a state factory (an object that implements the StateFactory interface) must be public and must have a public constructor that accepts no arguments. In cases where the factory is in a named module then it must be in a package which is exported by that module to the &lt;code&gt;java.naming&lt;/code&gt; module.</source>
          <target state="translated">상태 팩토리 (StateFactory 인터페이스를 구현하는 객체)는 공용이어야하며 인수를 허용하지 않는 공용 생성자가 있어야합니다. 팩토리가 명명 된 모듈에있는 경우 해당 모듈에서 &lt;code&gt;java.naming&lt;/code&gt; 모듈 로 내보내는 패키지에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e3416dc9c8e94484bd0d6f1d95d942570235b88e" translate="yes" xml:space="preserve">
          <source>Note that adding a default implementation of a new visit method in a visitor class will occur instead of adding a &lt;em&gt;default method&lt;/em&gt; directly in the visitor interface since a Java SE 8 language feature cannot be used to this version of the API since this version is required to be runnable on Java SE 7 implementations. Future versions of the API that are only required to run on Java SE 8 and later may take advantage of default methods in this situation.</source>
          <target state="translated">Java SE 8 언어 기능을이 버전의 API에 사용할 수 없기 때문에 방문자 인터페이스에서 직접 &lt;em&gt;기본 메소드&lt;/em&gt; 를 추가하는 대신 방문자 클래스에서 새 방문 메소드의 기본 구현을 추가하면 이 버전이 필요하기 때문에 발생합니다. Java SE 7 구현에서 실행할 수 있습니다. Java SE 8 이상에서만 실행해야하는 이후 버전의 API는이 상황에서 기본 메소드를 이용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0d9504ee3762157c4157df75ceadc4ba79063ba" translate="yes" xml:space="preserve">
          <source>Note that additional source version constants will be added to model future releases of the language.</source>
          <target state="translated">언어의 향후 릴리스를 모델링하기 위해 추가 소스 버전 상수가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6cfe909403c02c7424d6ced0e79dd8f845279e1d" translate="yes" xml:space="preserve">
          <source>Note that all classes loaded during LogManager configuration are first searched on the system class path before any user class path. That includes the LogManager class, any config classes, and any handler classes.</source>
          <target state="translated">LogManager 구성 중에로드 된 모든 클래스는 사용자 클래스 경로보다 먼저 시스템 클래스 경로에서 검색됩니다. 여기에는 LogManager 클래스, 구성 클래스 및 처리기 클래스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="214f385b9be3a097bff040153223e86647a0a506" translate="yes" xml:space="preserve">
          <source>Note that although the same password may be used to load the keystore, to protect the private key entry, to protect the secret key entry, and to store the keystore (as is shown in the sample code above), different passwords or other protection parameters may also be used.</source>
          <target state="translated">동일한 비밀번호를 사용하여 키 저장소를로드하고, 개인 키 항목을 보호하고, 비밀 키 항목을 보호하고, 키 저장소를 저장하기 위해 (위의 샘플 코드에 표시됨) 다른 비밀번호 또는 기타 보호 매개 변수를 사용할 수 있습니다. 또한 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="14ba8e26b60790b5484ab6e2fcb2ad20b8ab0589" translate="yes" xml:space="preserve">
          <source>Note that an annotation mirror of a marker annotation type will by definition have an empty map.</source>
          <target state="translated">마커 주석 유형의 주석 미러에는 정의에 따라 빈 맵이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9fb4caaf617fb5b877f7378da50a7228d7e24cf" translate="yes" xml:space="preserve">
          <source>Note that an implementation may not be able to reliably determine the origin status of the directive if the directive is created from a class file due to limitations of the fidelity of the class file format in preserving information from source code.</source>
          <target state="translated">소스 코드의 정보를 보존 할 때 클래스 파일 형식의 충실도 제한으로 인해 지시문이 클래스 파일에서 생성 된 경우 구현에서 지시문의 출처 상태를 안정적으로 결정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8ca5c96347ffc63451822eade25f5de940c2d7dc" translate="yes" xml:space="preserve">
          <source>Note that an object factory (an object that implements the ObjectFactory interface) must be public and must have a public constructor that accepts no arguments.</source>
          <target state="translated">객체 팩토리 (ObjectFactory 인터페이스를 구현하는 객체)는 공용이어야하며 인수를 허용하지 않는 공용 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="022fa1b6cb5a159c4b338cc316c312e9aeafe779" translate="yes" xml:space="preserve">
          <source>Note that an object factory (an object that implements the ObjectFactory interface) must be public and must have a public constructor that accepts no arguments. In cases where the factory is in a named module then it must be in a package which is exported by that module to the &lt;code&gt;java.naming&lt;/code&gt; module.</source>
          <target state="translated">오브젝트 팩토리 (ObjectFactory 인터페이스를 구현하는 오브젝트)는 공용이어야하며 인수를 허용하지 않는 공용 생성자가 있어야합니다. 팩토리가 명명 된 모듈에있는 경우 해당 모듈에서 &lt;code&gt;java.naming&lt;/code&gt; 모듈 로 내보내는 패키지에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="275f9fe85ff951e77a2d34807ceb543b955c4987" translate="yes" xml:space="preserve">
          <source>Note that annotation processing can process both the compilation units of source code to be compiled, passed with the &lt;code&gt;compilationUnits&lt;/code&gt; parameter, as well as class files, whose names are passed with the &lt;code&gt;classes&lt;/code&gt; parameter.</source>
          <target state="translated">주석 처리는 컴파일 할 소스 코드의 컴파일 단위와 &lt;code&gt;compilationUnits&lt;/code&gt; 매개 변수 와 함께 전달 된 클래스 파일뿐만 아니라 &lt;code&gt;classes&lt;/code&gt; 매개 변수 와 함께 이름이 전달되는 클래스 파일을 모두 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="e63893f8040b6be17cb6ef871570fdaecf1e2bc5" translate="yes" xml:space="preserve">
          <source>Note that any DomainCombiner associated with the current AccessControlContext will be ignored while the action is performed.</source>
          <target state="translated">작업이 수행되는 동안 현재 AccessControlContext와 연결된 모든 DomainCombiner는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9c7af7b634cf4a856f86aa243767a4a8fd27f6cf" translate="yes" xml:space="preserve">
          <source>Note that applets created via beans.instantiate run in a slightly different environment than applets running inside browsers. In particular, bean applets have no access to &quot;parameters&quot;, so they may wish to provide property get/set methods to set parameter values. We advise bean-applet developers to test their bean-applets against both the JDK appletviewer (for a reference browser environment) and the BDK BeanBox (for a reference bean container).</source>
          <target state="translated">beans.instantiate를 통해 생성 된 애플릿은 브라우저 내에서 실행되는 애플릿과 약간 다른 환경에서 실행됩니다. 특히, Bean 애플릿은 &quot;매개 변수&quot;에 액세스 할 수 없으므로 매개 변수 값을 설정하기위한 특성 get / set 메소드를 제공 할 수 있습니다. bean-applet 개발자는 JDK appletviewer (참조 브라우저 환경의 경우)와 BDK BeanBox (참조 bean 컨테이너의 경우)에 대해 bean-applet을 테스트하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dea130717cce2b33119341024233526382650a0c" translate="yes" xml:space="preserve">
          <source>Note that as a particular instance of the &lt;a href=&quot;package-summary&quot;&gt;general accuracy requirements&lt;/a&gt; and the ordering behavior required of this interface, the list of enclosed elements will be returned in the natural order for the originating source of information about the type. For example, if the information about the type is originating from a source file, the elements will be returned in source code order. (However, in that case the the ordering of synthesized elements, such as a default constructor, is not specified.)</source>
          <target state="translated">&lt;a href=&quot;package-summary&quot;&gt;일반적인 정확도 요구 사항&lt;/a&gt; 과이 인터페이스에 필요한 순서 동작 의 특정 인스턴스로, 동봉 된 요소 목록이 유형에 대한 원래 정보 소스에 대해 자연 순서대로 리턴됩니다. 예를 들어, 유형에 대한 정보가 소스 파일에서 시작된 경우 요소는 소스 코드 순서로 리턴됩니다. 그러나이 경우 기본 생성자와 같은 합성 요소의 순서는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de45338b898047e3cfe83d5d950fcbb4ec16b066" translate="yes" xml:space="preserve">
          <source>Note that as of 1.3, this method clears the selection, if any.</source>
          <target state="translated">1.3부터이 방법은 선택 항목을 지 웁니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="871b239a84210e68e8167a62fa00cec7ec66003c" translate="yes" xml:space="preserve">
          <source>Note that attribute names are processed differently than element names: an unprefixed element name will receive the default Namespace (if any), while an unprefixed attribute name will not.</source>
          <target state="translated">속성 이름은 요소 이름과 다르게 처리됩니다. 접두사가없는 요소 이름은 기본 네임 스페이스 (있는 경우)를 수신하지만 접두어가없는 속성 이름은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbddea09dcde2c60b7d4d8d1b4968758b34aa1cf" translate="yes" xml:space="preserve">
          <source>Note that backslashes (&lt;code&gt;\&lt;/code&gt;) and dollar signs (&lt;code&gt;$&lt;/code&gt;) in a replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string.</source>
          <target state="translated">대체 문자열의 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 및 달러 기호 ( &lt;code&gt;$&lt;/code&gt; )로 인해 리터럴 대체 문자열로 처리되는 경우와 결과가 다를 수 있습니다. 달러 기호는 위에서 설명한 것처럼 캡처 된 하위 시퀀스에 대한 참조로 처리 될 수 있으며 백 슬래시는 대체 문자열에서 리터럴 문자를 이스케이프하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3dc7b13aae47f64e8cf7dd1b1d07a15c4c61da83" translate="yes" xml:space="preserve">
          <source>Note that backslashes (&lt;code&gt;\&lt;/code&gt;) and dollar signs (&lt;code&gt;$&lt;/code&gt;) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string.</source>
          <target state="translated">대체 문자열의 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 및 달러 기호 ( &lt;code&gt;$&lt;/code&gt; )로 인해 결과가 리터럴 대체 문자열로 취급되는 경우와 다를 수 있습니다. 달러 기호는 위에서 설명한대로 캡처 된 서브 시퀀스에 대한 참조로 처리 될 수 있으며 백 슬래시는 대체 문자열에서 리터럴 문자를 이스케이프하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="794a21272f22e16257c2e5ac3181d6b10bd1f90b" translate="yes" xml:space="preserve">
          <source>Note that backslashes (&lt;code&gt;\&lt;/code&gt;) and dollar signs (&lt;code&gt;$&lt;/code&gt;) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string; see &lt;a href=&quot;../util/regex/matcher#replaceAll(java.lang.String)&quot;&gt;&lt;code&gt;Matcher.replaceAll&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;../util/regex/matcher#quoteReplacement(java.lang.String)&quot;&gt;&lt;code&gt;Matcher.quoteReplacement(java.lang.String)&lt;/code&gt;&lt;/a&gt; to suppress the special meaning of these characters, if desired.</source>
          <target state="translated">대체 문자열의 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 및 달러 기호 ( &lt;code&gt;$&lt;/code&gt; )로 인해 리터럴 대체 문자열로 처리되는 경우와 결과가 다를 수 있습니다. &lt;a href=&quot;../util/regex/matcher#replaceAll(java.lang.String)&quot;&gt; &lt;code&gt;Matcher.replaceAll&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . 원하는 경우 &lt;a href=&quot;../util/regex/matcher#quoteReplacement(java.lang.String)&quot;&gt; &lt;code&gt;Matcher.quoteReplacement(java.lang.String)&lt;/code&gt; &lt;/a&gt; 를 사용 하여 이러한 문자의 특별한 의미를 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="03f5f96f1631f4a5090a116d17a0b8362cfbc316" translate="yes" xml:space="preserve">
          <source>Note that backslashes (&lt;code&gt;\&lt;/code&gt;) and dollar signs (&lt;code&gt;$&lt;/code&gt;) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string; see &lt;a href=&quot;../util/regex/matcher#replaceAll-java.lang.String-&quot;&gt;&lt;code&gt;Matcher.replaceAll&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;../util/regex/matcher#quoteReplacement-java.lang.String-&quot;&gt;&lt;code&gt;Matcher.quoteReplacement(java.lang.String)&lt;/code&gt;&lt;/a&gt; to suppress the special meaning of these characters, if desired.</source>
          <target state="translated">대체 문자열의 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 및 달러 기호 ( &lt;code&gt;$&lt;/code&gt; )로 인해 결과가 리터럴 대체 문자열로 처리되는 경우와 다를 수 있습니다. &lt;a href=&quot;../util/regex/matcher#replaceAll-java.lang.String-&quot;&gt; &lt;code&gt;Matcher.replaceAll&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . 필요한 경우 &lt;a href=&quot;../util/regex/matcher#quoteReplacement-java.lang.String-&quot;&gt; &lt;code&gt;Matcher.quoteReplacement(java.lang.String)&lt;/code&gt; &lt;/a&gt; 를 사용 하여 이러한 문자의 특수한 의미를 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="90e45d65bbdf63145b4e8fee383accede4f0a8ee" translate="yes" xml:space="preserve">
          <source>Note that backslashes (&lt;code&gt;\&lt;/code&gt;) and dollar signs (&lt;code&gt;$&lt;/code&gt;) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string; see &lt;a href=&quot;../util/regex/matcher#replaceFirst(java.lang.String)&quot;&gt;&lt;code&gt;Matcher.replaceFirst(java.lang.String)&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;../util/regex/matcher#quoteReplacement(java.lang.String)&quot;&gt;&lt;code&gt;Matcher.quoteReplacement(java.lang.String)&lt;/code&gt;&lt;/a&gt; to suppress the special meaning of these characters, if desired.</source>
          <target state="translated">대체 문자열의 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 및 달러 기호 ( &lt;code&gt;$&lt;/code&gt; )로 인해 리터럴 대체 문자열로 처리되는 경우와 결과가 다를 수 있습니다. &lt;a href=&quot;../util/regex/matcher#replaceFirst(java.lang.String)&quot;&gt; &lt;code&gt;Matcher.replaceFirst(java.lang.String)&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 원하는 경우 &lt;a href=&quot;../util/regex/matcher#quoteReplacement(java.lang.String)&quot;&gt; &lt;code&gt;Matcher.quoteReplacement(java.lang.String)&lt;/code&gt; &lt;/a&gt; 를 사용 하여 이러한 문자의 특별한 의미를 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="1ab737305fc0999d0bb7e53367b45466fded99d7" translate="yes" xml:space="preserve">
          <source>Note that backslashes (&lt;code&gt;\&lt;/code&gt;) and dollar signs (&lt;code&gt;$&lt;/code&gt;) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string; see &lt;a href=&quot;../util/regex/matcher#replaceFirst-java.lang.String-&quot;&gt;&lt;code&gt;Matcher.replaceFirst(java.lang.String)&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;../util/regex/matcher#quoteReplacement-java.lang.String-&quot;&gt;&lt;code&gt;Matcher.quoteReplacement(java.lang.String)&lt;/code&gt;&lt;/a&gt; to suppress the special meaning of these characters, if desired.</source>
          <target state="translated">대체 문자열의 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 및 달러 기호 ( &lt;code&gt;$&lt;/code&gt; )로 인해 결과가 리터럴 대체 문자열로 처리되는 경우와 다를 수 있습니다. &lt;a href=&quot;../util/regex/matcher#replaceFirst-java.lang.String-&quot;&gt; &lt;code&gt;Matcher.replaceFirst(java.lang.String)&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 필요한 경우 &lt;a href=&quot;../util/regex/matcher#quoteReplacement-java.lang.String-&quot;&gt; &lt;code&gt;Matcher.quoteReplacement(java.lang.String)&lt;/code&gt; &lt;/a&gt; 를 사용 하여 이러한 문자의 특수한 의미를 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="7de1f29d631b8e3aa5532ffafc72d63a383c4ffb" translate="yes" xml:space="preserve">
          <source>Note that based on the &lt;code&gt;DocumentType&lt;/code&gt; given to create the document, the implementation may instantiate specialized &lt;code&gt;Document&lt;/code&gt; objects that support additional features than the &quot;Core&quot;, such as &quot;HTML&quot; [&lt;a href=&quot;http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109&quot;&gt;DOM Level 2 HTML&lt;/a&gt;] . On the other hand, setting the &lt;code&gt;DocumentType&lt;/code&gt; after the document was created makes this very unlikely to happen. Alternatively, specialized &lt;code&gt;Document&lt;/code&gt; creation methods, such as &lt;code&gt;createHTMLDocument&lt;/code&gt; [&lt;a href=&quot;http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109&quot;&gt;DOM Level 2 HTML&lt;/a&gt;] , can be used to obtain specific types of &lt;code&gt;Document&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;DocumentType&lt;/code&gt; 를 생성하기 위해 제공된 DocumentType 을 기반으로 구현은 &quot;HTML&quot;[ &lt;a href=&quot;http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109&quot;&gt;DOM Level 2 HTML&lt;/a&gt; ] 과 같은 &quot;Core&quot;이외의 추가 기능을 지원하는 특수 &lt;code&gt;Document&lt;/code&gt; 객체를 인스턴스화 할 수 있습니다 . 반면에 문서가 생성 된 후 &lt;code&gt;DocumentType&lt;/code&gt; 을 설정 하면 이런 일이 발생할 가능성이 거의 없습니다. 또는 &lt;code&gt;createHTMLDocument&lt;/code&gt; [ &lt;a href=&quot;http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109&quot;&gt;DOM Level 2 HTML&lt;/a&gt; ] 과 같은 특수한 &lt;code&gt;Document&lt;/code&gt; 생성 방법을 사용하여 특정 유형의 &lt;code&gt;Document&lt;/code&gt; 객체 를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="419355ea0b2e3435255ed5f2c745975b89276425" translate="yes" xml:space="preserve">
          <source>Note that because &lt;a href=&quot;../../../../java.base/java/util/calendar#add(int,int)&quot;&gt;&lt;code&gt;Calendar.add(int, int)&lt;/code&gt;&lt;/a&gt; is using &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;Duration&lt;/code&gt; with values beyond the range of &lt;code&gt;int&lt;/code&gt; in its fields will cause overflow/underflow to the given &lt;a href=&quot;../../../../java.base/java/util/calendar&quot;&gt;&lt;code&gt;Calendar&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;xmlgregoriancalendar#add(javax.xml.datatype.Duration)&quot;&gt;&lt;code&gt;XMLGregorianCalendar.add(Duration)&lt;/code&gt;&lt;/a&gt; provides the same basic operation as this method while avoiding the overflow/underflow issues.</source>
          <target state="translated">참고 때문 &lt;a href=&quot;../../../../java.base/java/util/calendar#add(int,int)&quot;&gt; &lt;code&gt;Calendar.add(int, int)&lt;/code&gt; &lt;/a&gt; 사용 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;Duration&lt;/code&gt; 의 범위를 초과 값을 &lt;code&gt;int&lt;/code&gt; 의 분야에서 것은 주어진에 오버 플로우 / 언더 플로우가 발생합니다 &lt;a href=&quot;../../../../java.base/java/util/calendar&quot;&gt; &lt;code&gt;Calendar&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;xmlgregoriancalendar#add(javax.xml.datatype.Duration)&quot;&gt; &lt;code&gt;XMLGregorianCalendar.add(Duration)&lt;/code&gt; &lt;/a&gt; 는 오버플로 / 언더 플로 문제를 피하면서이 메서드와 동일한 기본 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b9cbd2a7b20ea5686eec0ac7a4c297a447639111" translate="yes" xml:space="preserve">
          <source>Note that because cancellations due to interrupts and timeouts may occur at any time, a &lt;code&gt;true&lt;/code&gt; return does not guarantee that some other thread will acquire before the current thread. Likewise, it is possible for another thread to win a race to enqueue after this method has returned &lt;code&gt;false&lt;/code&gt;, due to the queue being empty.</source>
          <target state="translated">인터럽트 및 시간 초과로 인한 취소는 언제든지 발생할 수 있으므로 &lt;code&gt;true&lt;/code&gt; 리턴은 다른 스레드가 현재 스레드보다 먼저 획득 할 것을 보장하지 않습니다. 마찬가지로 큐가 비어 있기 때문에이 메소드가 &lt;code&gt;false&lt;/code&gt; 를 반환 한 후 다른 스레드가 경쟁 에서이기도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c967057bf157a767c21d5f94cb0958baba15aa4" translate="yes" xml:space="preserve">
          <source>Note that because the SQL &lt;code&gt;JOIN&lt;/code&gt; must be enforced when an application adds a second or subsequent &lt;code&gt;RowSet&lt;/code&gt; object, there may be an initial degradation in performance while the &lt;code&gt;JOIN&lt;/code&gt; is being performed.</source>
          <target state="translated">응용 프로그램이 두 번째 또는 후속 &lt;code&gt;RowSet&lt;/code&gt; 개체를 추가 할 때 SQL &lt;code&gt;JOIN&lt;/code&gt; 을 적용해야하므로 &lt;code&gt;JOIN&lt;/code&gt; 이 수행되는 동안 초기 성능 저하가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f2d479ca269ccb7eee858707c8d03d35390aaa6" translate="yes" xml:space="preserve">
          <source>Note that because the XML DTD is strongly tied to the parsing process and has a significant effect on the parsing process, it is impossible to define the DTD validation as a process independent from parsing. For this reason, this specification does not define the semantics for the XML DTD. This doesn't prohibit implementors from implementing it in a way they see fit, but &lt;em&gt;users are warned that any DTD validation implemented on this interface necessarily deviate from the XML DTD semantics as defined in the XML 1.0&lt;/em&gt;.</source>
          <target state="translated">XML DTD는 파싱 프로세스와 밀접하게 연결되어 있고 파싱 프로세스에 상당한 영향을 미치기 때문에 DTD 유효성 검사를 파싱과 독립적 인 프로세스로 정의하는 것은 불가능합니다. 이러한 이유로이 사양은 XML DTD에 대한 의미를 정의하지 않습니다. 이것은 구현자가 적절하다고 생각하는 방식으로 구현하는 것을 금지하지 않지만, &lt;em&gt;사용자는이 인터페이스에 구현 된 DTD 유효성 검사가 반드시 XML 1.0에 정의 된 XML DTD 의미 체계에서 벗어난다는 경고를&lt;/em&gt; 받습니다.</target>
        </trans-unit>
        <trans-unit id="182a30c3d2ead4a0d3e6961f3850f71bb2c0e25b" translate="yes" xml:space="preserve">
          <source>Note that because the numbering of elements in an array starts at zero, the array element that corresponds to placeholder parameter number</source>
          <target state="translated">배열의 요소 번호 매기기는 0부터 시작하므로 자리 표시 자 매개 변수 번호에 해당하는 배열 요소</target>
        </trans-unit>
        <trans-unit id="8cd342fc79eb8dd9c89557278ec717a1a7eebb88" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;code&gt;plus&lt;/code&gt; followed by &lt;code&gt;minus&lt;/code&gt; is not guaranteed to return the same date-time.</source>
          <target state="translated">&lt;code&gt;plus&lt;/code&gt; 다음에 &lt;code&gt;minus&lt;/code&gt; 를 호출 한다고해서 동일한 날짜-시간이 반환되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="56327414dff77371526ee940407066117291e795" translate="yes" xml:space="preserve">
          <source>Note that calling this method from within the &lt;code&gt;run&lt;/code&gt; method of a repeating timer task absolutely guarantees that the timer task will not run again.</source>
          <target state="translated">반복 타이머 작업 의 &lt;code&gt;run&lt;/code&gt; 메서드 내에서이 메서드를 호출 하면 타이머 작업이 다시 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4586e37475d24f595b14919581e2000377341d50" translate="yes" xml:space="preserve">
          <source>Note that calling this method from within the run method of a timer task that was invoked by this timer absolutely guarantees that the ongoing task execution is the last task execution that will ever be performed by this timer.</source>
          <target state="translated">이 타이머에 의해 호출 된 타이머 태스크의 run 메소드 내에서이 메소드를 호출하면 진행중인 태스크 실행이이 타이머에 의해 수행 될 마지막 태스크 실행임을 절대적으로 보장합니다.</target>
        </trans-unit>
        <trans-unit id="3bf4aeeb12928b06cd1be8d9a90c217603fe3dcf" translate="yes" xml:space="preserve">
          <source>Note that calling this method may cause this &lt;code&gt;DataBuffer&lt;/code&gt; object to be incompatible with &lt;a href=&quot;#optimizations&quot;&gt;performance optimizations&lt;/a&gt; used by some implementations (such as caching an associated image in video memory).</source>
          <target state="translated">이 메서드를 호출하면이 &lt;code&gt;DataBuffer&lt;/code&gt; 개체 가 일부 구현에서 사용되는 &lt;a href=&quot;#optimizations&quot;&gt;성능 최적화&lt;/a&gt; (예 : 비디오 메모리에 관련 이미지 캐싱)와 호환되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a81e06fd273d2eadd9e0b7961f553f85c28b6c3" translate="yes" xml:space="preserve">
          <source>Note that changes to the backing collection might still be possible, and if they occur, they are visible through the unmodifiable view. Thus, an unmodifiable view collection is not necessarily immutable. However, if the backing collection of an unmodifiable view is effectively immutable, or if the only reference to the backing collection is through an unmodifiable view, the view can be considered effectively immutable.</source>
          <target state="translated">백업 컬렉션에 대한 변경은 여전히 ​​가능할 수 있으며 변경이 발생하는 경우 수정 불가능한보기를 통해 볼 수 있습니다. 따라서 수정 불가능한 뷰 콜렉션이 반드시 변경 불가능한 것은 아닙니다. 그러나 수정할 수없는 뷰의 백업 컬렉션이 사실상 변경 불가능하거나 백업 컬렉션에 대한 유일한 참조가 수정할 수없는 뷰를 통하는 경우 뷰는 사실상 변경 불가능한 것으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b106efb061200778a92d449ca4cf694568a757dc" translate="yes" xml:space="preserve">
          <source>Note that cloning an immutable subtree results in a mutable copy, but the children of an &lt;code&gt;EntityReference&lt;/code&gt; clone are readonly . In addition, clones of unspecified &lt;code&gt;Attr&lt;/code&gt; nodes are specified. And, cloning &lt;code&gt;Document&lt;/code&gt;, &lt;code&gt;DocumentType&lt;/code&gt;, &lt;code&gt;Entity&lt;/code&gt;, and &lt;code&gt;Notation&lt;/code&gt; nodes is implementation dependent.</source>
          <target state="translated">변경 불가능한 하위 트리를 복제하면 변경 가능한 복사본이 생성되지만 &lt;code&gt;EntityReference&lt;/code&gt; 복제 의 하위 항목 은 읽기 전용입니다. 또한 지정되지 않은 &lt;code&gt;Attr&lt;/code&gt; 노드의 복제본이 지정 됩니다. 그리고 &lt;code&gt;Document&lt;/code&gt; , &lt;code&gt;DocumentType&lt;/code&gt; , &lt;code&gt;Entity&lt;/code&gt; 및 &lt;code&gt;Notation&lt;/code&gt; 노드를 복제하는 것은 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="45dc085ec7352088bd30cdf3a20a1383b2baeb5a" translate="yes" xml:space="preserve">
          <source>Note that data-related DTD declarations (unparsed entities and notations) are already reported through the &lt;a href=&quot;../dtdhandler&quot;&gt;&lt;code&gt;DTDHandler&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">데이터 관련 DTD 선언 (구문 분석되지 않은 엔티티 및 표기법)은 이미 &lt;a href=&quot;../dtdhandler&quot;&gt; &lt;code&gt;DTDHandler&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a40c29751d1d5baeae5d2cd1aad17dd9584f760" translate="yes" xml:space="preserve">
          <source>Note that different image format readers may produce decoded pixels in a variety of different orders. Many readers will produce pixels in a simple top-to-bottom, left-to-right-order, but others may use multiple passes of interlacing, tiling, etc. The sequence of updates may even differ from call to call depending on network speeds, for example. A call to this method does not guarantee that all the specified pixels have actually been updated, only that some activity has taken place within some subregion of the one specified.</source>
          <target state="translated">상이한 이미지 포맷 판독기는 다양한 상이한 순서로 디코딩 된 픽셀을 생성 할 수있다. 많은 독자들이 간단한 위에서 아래로, 왼쪽에서 오른쪽 순서로 픽셀을 생성하지만, 다른 리더는 여러 단계의 인터레이스, 타일링 등을 사용할 수 있습니다. 업데이트 순서는 네트워크 속도에 따라 호출마다 다를 수도 있습니다 예를 들어. 이 메서드를 호출한다고해서, 지정된 모든 픽셀이 실제로 갱신 된 것은 아니고, 지정된 액티비티의 일부 소구역 내에서 일부 액티비티 만 발생했을뿐입니다.</target>
        </trans-unit>
        <trans-unit id="241d74da481c30042b7a543b05ee18d34c4e3fbd" translate="yes" xml:space="preserve">
          <source>Note that digest objects can compute only one digest (see &lt;a href=&quot;messagedigest&quot;&gt;&lt;code&gt;MessageDigest&lt;/code&gt;&lt;/a&gt;), so that in order to compute intermediate digests, a caller should retain a handle onto the digest object, and clone it for each digest to be computed, leaving the orginal digest untouched.</source>
          <target state="translated">다이제스트 객체는 하나의 다이제스트 만 계산할 수 있으므로 ( &lt;a href=&quot;messagedigest&quot;&gt; &lt;code&gt;MessageDigest&lt;/code&gt; &lt;/a&gt; 참조 ) 중간 다이제스트를 계산하려면 호출자가 다이제스트 객체에 대한 핸들을 유지하고 각 다이제스트가 계산되도록 원본 다이제스트는 그대로 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="62b54c7adc9e4943fce7f532157a4b2f10840c45" translate="yes" xml:space="preserve">
          <source>Note that digest objects can compute only one digest (see &lt;a href=&quot;messagedigest&quot;&gt;&lt;code&gt;MessageDigest&lt;/code&gt;&lt;/a&gt;), so that in order to compute intermediate digests, a caller should retain a handle onto the digest object, and clone it for each digest to be computed, leaving the original digest untouched.</source>
          <target state="translated">다이제스트 객체는 하나의 다이제스트 만 계산할 수 있으므로 ( &lt;a href=&quot;messagedigest&quot;&gt; &lt;code&gt;MessageDigest&lt;/code&gt; &lt;/a&gt; 참조 ) 중간 다이제스트를 계산하려면 호출자가 다이제스트 객체에 대한 핸들을 유지하고 계산할 각 다이제스트에 대해이를 복제하여 원래 다이제스트는 그대로 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="fd4b43cd3a8ad13cc9f2c41596da6c5f64c5d3a3" translate="yes" xml:space="preserve">
          <source>Note that during the closure phase, a &lt;code&gt;SSLEngine&lt;/code&gt; may generate handshake closure data that must be sent to the peer. &lt;code&gt;wrap()&lt;/code&gt; must be called to generate this data. When this method returns true, no more outbound data will be created.</source>
          <target state="translated">클로저 단계 동안 &lt;code&gt;SSLEngine&lt;/code&gt; 은 피어에게 보내야하는 핸드 셰이크 클로저 데이터를 생성 할 수 있습니다. 이 데이터를 생성하려면 &lt;code&gt;wrap()&lt;/code&gt; 을 호출해야합니다. 이 메소드가 true를 리턴하면 더 이상 아웃 바운드 데이터가 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3148771b07995b076b573d2a164f49f5aee5314e" translate="yes" xml:space="preserve">
          <source>Note that during the drag, the set of operations exposed by the source at the start of the drag operation may not change until the operation is complete. The operation(s) are constant for the duration of the operation with respect to the &lt;code&gt;DragSource&lt;/code&gt;.</source>
          <target state="translated">드래그하는 동안 드래그 작업을 시작할 때 소스에 의해 노출 된 작업 집합은 작업이 완료 될 때까지 변경되지 않을 수 있습니다. 작업은 &lt;code&gt;DragSource&lt;/code&gt; 에 대해 작업 기간 동안 일정합니다 .</target>
        </trans-unit>
        <trans-unit id="e67ffd890ca172bd68127f06b5fffc3e564a5aa8" translate="yes" xml:space="preserve">
          <source>Note that elements of certain kinds can be isolated using methods in &lt;a href=&quot;../util/elementfilter&quot;&gt;&lt;code&gt;ElementFilter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../util/elementfilter&quot;&gt; &lt;code&gt;ElementFilter&lt;/code&gt; 의&lt;/a&gt; 메소드를 사용하여 특정 종류의 요소를 분리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="23821c1bf96e102886c1d34c6a746806530ebf07" translate="yes" xml:space="preserve">
          <source>Note that elements of certain kinds can be isolated using methods in &lt;a href=&quot;elementfilter&quot;&gt;&lt;code&gt;ElementFilter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;elementfilter&quot;&gt; &lt;code&gt;ElementFilter&lt;/code&gt; 의&lt;/a&gt; 메소드를 사용하여 특정 종류의 요소를 분리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a3c3651e6bca7d55c4d31094c4cfaed4cc7ce15" translate="yes" xml:space="preserve">
          <source>Note that entropy is obtained from an entropy source. While some data in &lt;code&gt;params&lt;/code&gt; may contain entropy, its main usage is to provide diversity.</source>
          <target state="translated">엔트로피는 엔트로피 소스에서 얻습니다. &lt;code&gt;params&lt;/code&gt; 의 일부 데이터 에는 엔트로피가 포함될 수 있지만 주요 용도는 다양성을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d3fbffa609ca7a7ecd29a25fe3b337771b806415" translate="yes" xml:space="preserve">
          <source>Note that even if a protocol is enabled, it may never be used. This can occur if the peer does not support the protocol, or its use is restricted, or there are no enabled cipher suites supported by the protocol.</source>
          <target state="translated">Note that even if a protocol is enabled, it may never be used. This can occur if the peer does not support the protocol, or its use is restricted, or there are no enabled cipher suites supported by the protocol.</target>
        </trans-unit>
        <trans-unit id="207fa71026561322ff171f66495ba4971ce9ada0" translate="yes" xml:space="preserve">
          <source>Note that even if a suite is enabled, it may never be used. This can occur if the peer does not support it, or its use is restricted, or the requisite certificates (and private keys) for the suite are not available, or an anonymous suite is enabled but authentication is required.</source>
          <target state="translated">Note that even if a suite is enabled, it may never be used. This can occur if the peer does not support it, or its use is restricted, or the requisite certificates (and private keys) for the suite are not available, or an anonymous suite is enabled but authentication is required.</target>
        </trans-unit>
        <trans-unit id="9377c470a6e2e4b1f122a207867c1ce8719ff896" translate="yes" xml:space="preserve">
          <source>Note that even if the security manager does not permit the &lt;code&gt;getProperties&lt;/code&gt; operation, it may choose to permit the &lt;a href=&quot;#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;getProperty(String)&lt;/code&gt;&lt;/a&gt; operation.</source>
          <target state="translated">Note that even if the security manager does not permit the &lt;code&gt;getProperties&lt;/code&gt; operation, it may choose to permit the &lt;a href=&quot;#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;getProperty(String)&lt;/code&gt; &lt;/a&gt; operation.</target>
        </trans-unit>
        <trans-unit id="228e64834f5c005b619425815500e57cbeec6591" translate="yes" xml:space="preserve">
          <source>Note that even if the security manager does not permit the &lt;code&gt;getProperties&lt;/code&gt; operation, it may choose to permit the &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt;&lt;code&gt;getProperty(String)&lt;/code&gt;&lt;/a&gt; operation.</source>
          <target state="translated">보안 관리자가 &lt;code&gt;getProperties&lt;/code&gt; 조작을 허용하지 않더라도 &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt; &lt;code&gt;getProperty(String)&lt;/code&gt; &lt;/a&gt; 조작 을 허용하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1eb677b31a3d02f49ca91d39e9dbf9797853bdcf" translate="yes" xml:space="preserve">
          <source>Note that even if this method returns &lt;code&gt;false&lt;/code&gt;, layout processing may still be invoked when used with any &lt;code&gt;Font&lt;/code&gt; for which &lt;a href=&quot;#hasLayoutAttributes()&quot;&gt;&lt;code&gt;hasLayoutAttributes()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;, so that method will need to be consulted for the specific font, in order to obtain an answer which accounts for such font attributes.</source>
          <target state="translated">Note that even if this method returns &lt;code&gt;false&lt;/code&gt; , layout processing may still be invoked when used with any &lt;code&gt;Font&lt;/code&gt; for which &lt;a href=&quot;#hasLayoutAttributes()&quot;&gt; &lt;code&gt;hasLayoutAttributes()&lt;/code&gt; &lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt; , so that method will need to be consulted for the specific font, in order to obtain an answer which accounts for such font attributes.</target>
        </trans-unit>
        <trans-unit id="e78e85a0e4796f49717cf604ef027214003a73d4" translate="yes" xml:space="preserve">
          <source>Note that fail-fast behavior cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast operations throw &lt;code&gt;ConcurrentModificationException&lt;/code&gt; on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness:</source>
          <target state="translated">일반적으로 말해서 비동기식 동시 수정이있을 경우 확실한 보장을 할 수 없으므로 페일-패스트 동작을 보장 할 수 없습니다. 가장 빠른 작업 은 최선의 노력으로 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 발생시킵니다. 따라서이 예외에 따라 프로그램이 정확한지 작성하는 것은 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="5dc1e900f56e194109775ee12721f8f28a66a7e8" translate="yes" xml:space="preserve">
          <source>Note that for a particular enum type &lt;code&gt;T&lt;/code&gt;, the implicitly declared &lt;code&gt;public static T valueOf(String)&lt;/code&gt; method on that enum may be used instead of this method to map from a name to the corresponding enum constant. All the constants of an enum type can be obtained by calling the implicit &lt;code&gt;public static T[] values()&lt;/code&gt; method of that type.</source>
          <target state="translated">특정 열거 형 &lt;code&gt;T&lt;/code&gt; 의 경우 ,이 열거 형 대신에 암묵적으로 선언 된 &lt;code&gt;public static T valueOf(String)&lt;/code&gt; 메소드를 사용해, 이름으로부터 대응하는 열거 형 정수에 매핑 할 수 있습니다. 열거 형의 모든 상수는 해당 형식의 암시적인 &lt;code&gt;public static T[] values()&lt;/code&gt; 메서드를 호출하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6045e93711eabf1fb3cf25666ed983546557bd5" translate="yes" xml:space="preserve">
          <source>Note that for add, subtract, and multiply, the reduction in scale will equal the number of digit positions of the exact result which are discarded. If the rounding causes a carry propagation to create a new high-order digit position, an additional digit of the result is discarded than when no new digit position is created.</source>
          <target state="translated">더하기, 빼기 및 곱하기의 스케일 축소는 버려지는 정확한 결과의 자릿수와 같습니다. 반올림으로 인해 캐리 전파가 새로운 상위 자릿수 위치를 작성하는 경우, 새 자릿수 위치가 작성되지 않을 때보 다 결과의 추가 숫자가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="d47fb38576e47b7b544d0b34d07b725eb2448f6b" translate="yes" xml:space="preserve">
          <source>Note that for beans which are applets, it is the caller's responsiblity to call &quot;start&quot; on the applet. For correct behaviour, this should be done after the applet has been added into a visible AWT container.</source>
          <target state="translated">애플릿 인 Bean의 경우 애플릿에서 &quot;시작&quot;을 호출하는 것은 호출자의 책임입니다. 올바른 동작을 위해서는 애플릿을 보이는 AWT 컨테이너에 추가 한 후에 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0ed1838066f63b8e41f8b798df4473c036da0ec" translate="yes" xml:space="preserve">
          <source>Note that formats that return &lt;code&gt;false&lt;/code&gt; from this method may nonetheless allow tiling (</source>
          <target state="translated">그럼에도 불구하고이 메소드에서 &lt;code&gt;false&lt;/code&gt; 를 반환하는 형식 은 바둑판 식 배열을 허용 할 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="dcc64255ed8e4cf8b4a37055c39a8705f2f4e7cf" translate="yes" xml:space="preserve">
          <source>Note that formatting need not occur synchronously. It may be delayed until a LogRecord is actually written to an external sink.</source>
          <target state="translated">서식은 동 기적으로 발생하지 않아도됩니다. LogRecord가 실제로 외부 싱크에 기록 될 때까지 지연 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="313e18c8d519e29b3a65a5812fbc567a887b01fb" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;delim&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, this constructor does not throw an exception. However, trying to invoke other methods on the resulting &lt;code&gt;StringTokenizer&lt;/code&gt; may result in a &lt;code&gt;NullPointerException&lt;/code&gt;.</source>
          <target state="translated">경우 참고 &lt;code&gt;delim&lt;/code&gt; 있다 &lt;code&gt;null&lt;/code&gt; 이 생성자가 예외를 throw하지 않습니다. 그러나 결과 &lt;code&gt;StringTokenizer&lt;/code&gt; 에서 다른 메소드를 호출하려고 하면 &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="b327bbbb69b7b67667284e563b95ce92dacc0d61" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;index&lt;/code&gt; is greater than &lt;code&gt;length&lt;/code&gt; the value returned may be meaningless.</source>
          <target state="translated">Note that if &lt;code&gt;index&lt;/code&gt; is greater than &lt;code&gt;length&lt;/code&gt; the value returned may be meaningless.</target>
        </trans-unit>
        <trans-unit id="b10eb57d6408f705ea07799de8f18ff9c86ac56e" translate="yes" xml:space="preserve">
          <source>Note that if a &lt;code&gt;null&lt;/code&gt; command string was passed to the constructor for this &lt;code&gt;ActionEvent&lt;/code&gt;, this this method returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Note that if a &lt;code&gt;null&lt;/code&gt; command string was passed to the constructor for this &lt;code&gt;ActionEvent&lt;/code&gt; , this this method returns &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8de154d974f3eeff31c72efc965511104f07ddb5" translate="yes" xml:space="preserve">
          <source>Note that if a given implementation is not cloneable, it is still possible to compute intermediate digests by instantiating several instances, if the number of digests is known in advance.</source>
          <target state="translated">주어진 구현을 복제 할 수없는 경우에도 다이제스트 수를 미리 알고 있으면 여러 인스턴스를 인스턴스화하여 중간 다이제스트를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c186c86d45c03ecc52b8b60127c4f9371e9220b" translate="yes" xml:space="preserve">
          <source>Note that if a method returns &lt;code&gt;int[]&lt;/code&gt;, this will be represented by the string &lt;code&gt;&quot;[I&quot;&lt;/code&gt; returned by &lt;code&gt;
      Class.getName()&lt;/code&gt;, but if a method returns &lt;code&gt;List&amp;lt;int[]&amp;gt;&lt;/code&gt;, this will be represented by the string &lt;code&gt;
      &quot;java.util.List&amp;lt;int[]&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">Note that if a method returns &lt;code&gt;int[]&lt;/code&gt; , this will be represented by the string &lt;code&gt;&quot;[I&quot;&lt;/code&gt; returned by &lt;code&gt; Class.getName()&lt;/code&gt; , but if a method returns &lt;code&gt;List&amp;lt;int[]&amp;gt;&lt;/code&gt; , this will be represented by the string &lt;code&gt; &quot;java.util.List&amp;lt;int[]&amp;gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="433ded20e283859ed49d1dd0ff8968d681ab2e98" translate="yes" xml:space="preserve">
          <source>Note that if a method returns &lt;code&gt;int[]&lt;/code&gt;, this will be represented by the string &lt;code&gt;&quot;[I&quot;&lt;/code&gt; returned by &lt;code&gt;Class.getName()&lt;/code&gt;, but if a method returns &lt;code&gt;List&amp;lt;int[]&amp;gt;&lt;/code&gt;, this will be represented by the string &lt;code&gt;&quot;java.util.List&amp;lt;int[]&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">메소드가 &lt;code&gt;int[]&lt;/code&gt; 리턴하면 &lt;code&gt;Class.getName()&lt;/code&gt; 에서 리턴 한 &lt;code&gt;&quot;[I&quot;&lt;/code&gt; 문자열로 표시 되지만, &lt;code&gt;List&amp;lt;int[]&amp;gt;&lt;/code&gt; 리턴 하면 &lt;code&gt;&quot;java.util.List&amp;lt;int[]&amp;gt;&quot;&lt;/code&gt; 문자열로 표시됩니다. .util.List &amp;lt;int []&amp;gt; &quot; .</target>
        </trans-unit>
        <trans-unit id="7777a7df35be6376d57fccbc74d503fdfe0ec2c9" translate="yes" xml:space="preserve">
          <source>Note that if a processor supports &lt;code&gt;&quot;*&quot;&lt;/code&gt; and returns &lt;code&gt;
 true&lt;/code&gt;, all annotations are claimed. Therefore, a universal processor being used to, for example, implement additional validity checks should return &lt;code&gt;false&lt;/code&gt; so as to not prevent other such checkers from being able to run.</source>
          <target state="translated">Note that if a processor supports &lt;code&gt;&quot;*&quot;&lt;/code&gt; and returns &lt;code&gt; true&lt;/code&gt; , all annotations are claimed. Therefore, a universal processor being used to, for example, implement additional validity checks should return &lt;code&gt;false&lt;/code&gt; so as to not prevent other such checkers from being able to run.</target>
        </trans-unit>
        <trans-unit id="d8adb955ab8ea1c93720a774cb1ce354cd65ec1c" translate="yes" xml:space="preserve">
          <source>Note that if a processor supports &lt;code&gt;&quot;*&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;, all annotations are claimed. Therefore, a universal processor being used to, for example, implement additional validity checks should return &lt;code&gt;false&lt;/code&gt; so as to not prevent other such checkers from being able to run.</source>
          <target state="translated">프로세서가 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 를 지원 하고 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 모든 주석이 청구됩니다. 따라서 추가 유효성 검사를 구현하는 데 사용되는 범용 프로세서는 &lt;code&gt;false&lt;/code&gt; 를 반환해야합니다. 다른 검사기가 실행되지 못하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="52f68ddd38d67d672a89f2843df1e927f2a43f83" translate="yes" xml:space="preserve">
          <source>Note that if an attribute was defaulted (&lt;em&gt;!isSpecified()&lt;/em&gt;) it will of necessity also have been declared (&lt;em&gt;isDeclared()&lt;/em&gt;) in the DTD. Similarly if an attribute's type is anything except CDATA, then it must have been declared.</source>
          <target state="translated">Note that if an attribute was defaulted (&lt;em&gt;!isSpecified()&lt;/em&gt;) it will of necessity also have been declared (&lt;em&gt;isDeclared()&lt;/em&gt;) in the DTD. Similarly if an attribute's type is anything except CDATA, then it must have been declared.</target>
        </trans-unit>
        <trans-unit id="3d8d20d3ffbbe0f4f3b52fb57b430bb24dc726a4" translate="yes" xml:space="preserve">
          <source>Note that if an element is null, then &lt;code&gt;&quot;null&quot;&lt;/code&gt; is added.</source>
          <target state="translated">요소가 null이면 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5732e39c261ad45a46e1ff1f64f24af0d58290bb" translate="yes" xml:space="preserve">
          <source>Note that if an individual element is &lt;code&gt;null&lt;/code&gt;, then &lt;code&gt;&quot;null&quot;&lt;/code&gt; is added.</source>
          <target state="translated">개별 요소가 &lt;code&gt;null&lt;/code&gt; 인 경우 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2bc9e52aec97c9649f65d7fccceb6ac91a53c424" translate="yes" xml:space="preserve">
          <source>Note that if any other secondary loop is started while this loop is running, the blocked thread will not resume execution until the nested loop is terminated.</source>
          <target state="translated">Note that if any other secondary loop is started while this loop is running, the blocked thread will not resume execution until the nested loop is terminated.</target>
        </trans-unit>
        <trans-unit id="092551d4016cb9b4e9fc2e439b067f7680224046" translate="yes" xml:space="preserve">
          <source>Note that if both the integer quotient and remainder are needed, this method is faster than using the &lt;code&gt;divideToIntegralValue&lt;/code&gt; and &lt;code&gt;remainder&lt;/code&gt; methods separately because the division need only be carried out once.</source>
          <target state="translated">정수 몫과 나머지가 모두 필요한 경우이 방법은 &lt;code&gt;divideToIntegralValue&lt;/code&gt; 및 &lt;code&gt;remainder&lt;/code&gt; 사용하는 것보다 빠릅니다. 경우 나누기가 한 번만 수행되면되므로 메소드를 개별적으로 .</target>
        </trans-unit>
        <trans-unit id="d3a2200eed1ffa4b7f49f79dc2e9fa8566b65b7b" translate="yes" xml:space="preserve">
          <source>Note that if it is important that the elements for a given key appear in the order they appear in the source, then we cannot use a concurrent reduction, as ordering is one of the casualties of concurrent insertion. We would then be constrained to implement either a sequential reduction or a merge-based parallel reduction.</source>
          <target state="translated">주어진 키의 요소가 소스에 나타나는 순서대로 나타나는 것이 중요하다면, 순서는 동시 삽입의 희생자 중 하나이므로 동시 축소를 사용할 수 없습니다. 그런 다음 순차적 축소 또는 병합 기반 병렬 축소를 구현하도록 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="f052fae04181e04f18acf801b6aeeae3a31ae3d3" translate="yes" xml:space="preserve">
          <source>Note that if no transform is applied to the gradient when it is created, the identity transform is used.</source>
          <target state="translated">Note that if no transform is applied to the gradient when it is created, the identity transform is used.</target>
        </trans-unit>
        <trans-unit id="7c7485b64a1bcc0b312e40ebbe08f7d4dc7db6ac" translate="yes" xml:space="preserve">
          <source>Note that if no type is set, the &lt;code&gt;JOIN&lt;/code&gt; will automatically be an inner join. The comments for the fields in the &lt;code&gt;JoinRowSet&lt;/code&gt; interface explain these &lt;code&gt;JOIN&lt;/code&gt; types, which are standard SQL &lt;code&gt;JOIN&lt;/code&gt; types.</source>
          <target state="translated">Note that if no type is set, the &lt;code&gt;JOIN&lt;/code&gt; will automatically be an inner join. The comments for the fields in the &lt;code&gt;JoinRowSet&lt;/code&gt; interface explain these &lt;code&gt;JOIN&lt;/code&gt; types, which are standard SQL &lt;code&gt;JOIN&lt;/code&gt; types.</target>
        </trans-unit>
        <trans-unit id="8da58e5799766c1707c13ed638b6f03380fa372b" translate="yes" xml:space="preserve">
          <source>Note that if one of the arguments is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;
 NullPointerException&lt;/code&gt; may or may not be thrown depending on what ordering policy, if any, the &lt;a href=&quot;comparator&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt; chooses to have for &lt;code&gt;null&lt;/code&gt; values.</source>
          <target state="translated">Note that if one of the arguments is &lt;code&gt;null&lt;/code&gt; , a &lt;code&gt; NullPointerException&lt;/code&gt; may or may not be thrown depending on what ordering policy, if any, the &lt;a href=&quot;comparator&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt; chooses to have for &lt;code&gt;null&lt;/code&gt; values.</target>
        </trans-unit>
        <trans-unit id="eb503aa30fc1ac3377f74194327710a61494da89" translate="yes" xml:space="preserve">
          <source>Note that if one of the arguments is &lt;code&gt;null&lt;/code&gt;, a &lt;code&gt;NullPointerException&lt;/code&gt; may or may not be thrown depending on what ordering policy, if any, the &lt;a href=&quot;comparator&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt; chooses to have for &lt;code&gt;null&lt;/code&gt; values.</source>
          <target state="translated">인수 중 하나 인 경우주의 &lt;code&gt;null&lt;/code&gt; 하는 &lt;code&gt;NullPointerException&lt;/code&gt; 의있는 경우 나, 무엇을 주문 정책에 따라 발생되지 않을 수 &lt;a href=&quot;comparator&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt; 에 대해 갖고 선택 &lt;code&gt;null&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="23236ea0d90e947ea5d4906783c6f38d8d69e571" translate="yes" xml:space="preserve">
          <source>Note that if proxy interfaces with a mix of accessibilities -- for example, an exported public interface and a non-exported non-public interface -- are proxied by the same instance, then the proxy class's accessibility is governed by the least accessible proxy interface.</source>
          <target state="translated">Note that if proxy interfaces with a mix of accessibilities -- for example, an exported public interface and a non-exported non-public interface -- are proxied by the same instance, then the proxy class's accessibility is governed by the least accessible proxy interface.</target>
        </trans-unit>
        <trans-unit id="97b5d25de9ae4d42221d9291b66f30608053245d" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;Runnable.run&lt;/code&gt; method throws an uncaught exception (on the event dispatching thread) it's caught and rethrown, as an &lt;code&gt;InvocationTargetException&lt;/code&gt;, on the caller's thread.</source>
          <target state="translated">Note that if the &lt;code&gt;Runnable.run&lt;/code&gt; method throws an uncaught exception (on the event dispatching thread) it's caught and rethrown, as an &lt;code&gt;InvocationTargetException&lt;/code&gt; , on the caller's thread.</target>
        </trans-unit>
        <trans-unit id="ddbd1613a8e07d0dbe9f73374cdc3d8746b897e2" translate="yes" xml:space="preserve">
          <source>Note that if the argument is equal to the value of &lt;a href=&quot;integer#MIN_VALUE&quot;&gt;&lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;&lt;/a&gt;, the most negative representable &lt;code&gt;int&lt;/code&gt; value, the result is that same value, which is negative.</source>
          <target state="translated">인수가 표현할 수있는 가장 음의 &lt;code&gt;int&lt;/code&gt; 값인 &lt;a href=&quot;integer#MIN_VALUE&quot;&gt; &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; &lt;/a&gt; 의 값과 같으면 결과는 동일한 값이며 음수입니다.</target>
        </trans-unit>
        <trans-unit id="551a700f57d929e8f9029d7c02782936756d7d55" translate="yes" xml:space="preserve">
          <source>Note that if the argument is equal to the value of &lt;a href=&quot;long#MIN_VALUE&quot;&gt;&lt;code&gt;Long.MIN_VALUE&lt;/code&gt;&lt;/a&gt;, the most negative representable &lt;code&gt;long&lt;/code&gt; value, the result is that same value, which is negative.</source>
          <target state="translated">인수가 &lt;a href=&quot;long#MIN_VALUE&quot;&gt; &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; &lt;/a&gt; 값과 동일한 경우 가장 음수로 표현할 수있는 &lt;code&gt;long&lt;/code&gt; 값, 부정 결과가 동일한 값이다.</target>
        </trans-unit>
        <trans-unit id="344b650dfc6ccc8374c6e92872a7dc2b09bfc90e" translate="yes" xml:space="preserve">
          <source>Note that if the client application has not specified an explicit source method name and source class name, then the LogRecord class will infer them automatically when they are first accessed (due to a call on getSourceMethodName or getSourceClassName) by analyzing the call stack. Therefore, if a logging Handler wants to pass off a LogRecord to another thread, or to transmit it over RMI, and if it wishes to subsequently obtain method name or class name information it should call one of getSourceClassName or getSourceMethodName to force the values to be filled in.</source>
          <target state="translated">클라이언트 애플리케이션이 명시 적 소스 메소드 이름 및 소스 클래스 이름을 지정하지 않은 경우, LogRecord 클래스는 호출 스택을 분석하여 처음 액세스 할 때 (getSourceMethodName 또는 getSourceClassName의 호출로 인해) 자동으로이를 유추합니다. 따라서 로깅 처리기가 LogRecord를 다른 스레드로 전달하거나 RMI를 통해 전송하려는 경우 메소드 이름 또는 클래스 이름 정보를 나중에 얻으려면 getSourceClassName 또는 getSourceMethodName 중 하나를 호출하여 값을 강제로 지정해야합니다. 채워.</target>
        </trans-unit>
        <trans-unit id="dd5e0eb89387b146744e893bba6b204ebdd172ee" translate="yes" xml:space="preserve">
          <source>Note that if the event parameter is &lt;code&gt;null&lt;/code&gt; the behavior is unspecified and may result in an exception.</source>
          <target state="translated">Note that if the event parameter is &lt;code&gt;null&lt;/code&gt; the behavior is unspecified and may result in an exception.</target>
        </trans-unit>
        <trans-unit id="0c7f6aa9e75f6c42c57215519e6085ee22e050fa" translate="yes" xml:space="preserve">
          <source>Note that if the given input stream does not support &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../io/inputstream#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt;, this method will consume the entire input stream.</source>
          <target state="translated">Note that if the given input stream does not support &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;../../io/inputstream#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt;, this method will consume the entire input stream.</target>
        </trans-unit>
        <trans-unit id="90240e919fc9f9c729c2517c2ae0e2a7eec36fcc" translate="yes" xml:space="preserve">
          <source>Note that if the given input stream does not support &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../io/inputstream#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt;, this method will consume the entire input stream. Otherwise, each call to this method consumes one CRL and the read position of the input stream is positioned to the next available byte after the inherent end-of-CRL marker. If the data in the input stream does not contain an inherent end-of-CRL marker (other than EOF) and there is trailing data after the CRL is parsed, a &lt;code&gt;CRLException&lt;/code&gt; is thrown.</source>
          <target state="translated">Note that if the given input stream does not support &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;../../io/inputstream#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt;, this method will consume the entire input stream. Otherwise, each call to this method consumes one CRL and the read position of the input stream is positioned to the next available byte after the inherent end-of-CRL marker. If the data in the input stream does not contain an inherent end-of-CRL marker (other than EOF) and there is trailing data after the CRL is parsed, a &lt;code&gt;CRLException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="2e7620054a0441dcb3c95edb39638ba8ef20a98a" translate="yes" xml:space="preserve">
          <source>Note that if the given input stream does not support &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../io/inputstream#reset()&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt;, this method will consume the entire input stream. Otherwise, each call to this method consumes one certificate and the read position of the input stream is positioned to the next available byte after the inherent end-of-certificate marker. If the data in the input stream does not contain an inherent end-of-certificate marker (other than EOF) and there is trailing data after the certificate is parsed, a &lt;code&gt;CertificateException&lt;/code&gt; is thrown.</source>
          <target state="translated">Note that if the given input stream does not support &lt;a href=&quot;../../io/inputstream#mark(int)&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;../../io/inputstream#reset()&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt;, this method will consume the entire input stream. Otherwise, each call to this method consumes one certificate and the read position of the input stream is positioned to the next available byte after the inherent end-of-certificate marker. If the data in the input stream does not contain an inherent end-of-certificate marker (other than EOF) and there is trailing data after the certificate is parsed, a &lt;code&gt;CertificateException&lt;/code&gt; is thrown.</target>
        </trans-unit>
        <trans-unit id="54f7c4f974f4265dbf7fc95a7341065c5377d9b9" translate="yes" xml:space="preserve">
          <source>Note that if the given input stream does not support &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt;, this method will consume the entire input stream.</source>
          <target state="translated">주어진 입력 스트림이 &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; 지원하지 않는 경우 이 메소드는 전체 입력 스트림을 소비합니다.</target>
        </trans-unit>
        <trans-unit id="f1827091b34459c49e7bed5c479a4f915cee04ae" translate="yes" xml:space="preserve">
          <source>Note that if the given input stream does not support &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt;, this method will consume the entire input stream. Otherwise, each call to this method consumes one CRL and the read position of the input stream is positioned to the next available byte after the inherent end-of-CRL marker. If the data in the input stream does not contain an inherent end-of-CRL marker (other than EOF) and there is trailing data after the CRL is parsed, a &lt;code&gt;CRLException&lt;/code&gt; is thrown.</source>
          <target state="translated">주어진 입력 스트림이 &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; 을&lt;/a&gt; 지원하지 않으면 이 메소드는 전체 입력 스트림을 소비합니다. 그렇지 않으면,이 메소드에 대한 각 호출은 하나의 CRL을 소비하고 입력 스트림의 읽기 위치는 고유 한 CRL 종료 마커 다음에 사용 가능한 다음 바이트에 배치됩니다. 입력 스트림의 데이터에 고유 COF 종료 마커 (EOF 이외)가 포함되어 있지 않고 CRL을 구문 분석 한 후 후행 데이터가 있으면 &lt;code&gt;CRLException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c95b62711973f523009364195f62b57b8a599ba2" translate="yes" xml:space="preserve">
          <source>Note that if the given input stream does not support &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt;&lt;code&gt;mark&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt;, this method will consume the entire input stream. Otherwise, each call to this method consumes one certificate and the read position of the input stream is positioned to the next available byte after the inherent end-of-certificate marker. If the data in the input stream does not contain an inherent end-of-certificate marker (other than EOF) and there is trailing data after the certificate is parsed, a &lt;code&gt;CertificateException&lt;/code&gt; is thrown.</source>
          <target state="translated">주어진 입력 스트림이 &lt;a href=&quot;../../io/inputstream#mark-int-&quot;&gt; &lt;code&gt;mark&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;../../io/inputstream#reset--&quot;&gt; &lt;code&gt;reset&lt;/code&gt; 을&lt;/a&gt; 지원하지 않으면 이 메소드는 전체 입력 스트림을 소비합니다. 그렇지 않으면,이 메소드에 대한 각 호출은 하나의 인증서를 소비하고 입력 스트림의 읽기 위치는 고유 한 인증서 끝 마커 다음에 사용 가능한 다음 바이트에 배치됩니다. 입력 스트림의 데이터에 고유의 EOF 이외의 마커가 포함되어 있지 않고 인증서를 구문 분석 한 후 후행 데이터가 있으면 &lt;code&gt;CertificateException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5bbaa75ffe6518429b117d97bb9e13fa7aeb2fe4" translate="yes" xml:space="preserve">
          <source>Note that if the given number of bytes to be copied is larger than the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object's array of bytes, the given number will be shortened to the array's length.</source>
          <target state="translated">Note that if the given number of bytes to be copied is larger than the length of this &lt;code&gt;SerialBlob&lt;/code&gt; object's array of bytes, the given number will be shortened to the array's length.</target>
        </trans-unit>
        <trans-unit id="534ad76bbd0db642a4a5fde4047cfc008cd5e798" translate="yes" xml:space="preserve">
          <source>Note that if the given output stream is &lt;a href=&quot;../../io/flushable&quot;&gt;&lt;code&gt;Flushable&lt;/code&gt;&lt;/a&gt; then its &lt;a href=&quot;../../io/flushable#flush()&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; method may need to invoked after this method completes so as to flush any buffered output.</source>
          <target state="translated">Note that if the given output stream is &lt;a href=&quot;../../io/flushable&quot;&gt; &lt;code&gt;Flushable&lt;/code&gt; &lt;/a&gt; then its &lt;a href=&quot;../../io/flushable#flush()&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; method may need to invoked after this method completes so as to flush any buffered output.</target>
        </trans-unit>
        <trans-unit id="b0d5df812dafb964f11dce9b421edee0651600af" translate="yes" xml:space="preserve">
          <source>Note that if the given output stream is &lt;a href=&quot;../../io/flushable&quot;&gt;&lt;code&gt;Flushable&lt;/code&gt;&lt;/a&gt; then its &lt;a href=&quot;../../io/flushable#flush--&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; method may need to invoked after this method completes so as to flush any buffered output.</source>
          <target state="translated">주어진 출력 스트림이 &lt;a href=&quot;../../io/flushable&quot;&gt; &lt;code&gt;Flushable&lt;/code&gt; 인&lt;/a&gt; 경우 버퍼링 된 출력을 플러시하기 위해이 메소드가 완료된 후 해당 &lt;a href=&quot;../../io/flushable#flush--&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b1a99706a5ea258fbc53a080b302dff06b37c31" translate="yes" xml:space="preserve">
          <source>Note that if the program uses hasMoreElements() and nextElement() instead to iterate through the NamingEnumeration, because these methods cannot throw exceptions, no exception will be thrown. Instead, in the previous example, after the n'th result has been returned by nextElement(), invoking hasMoreElements() would return false.</source>
          <target state="translated">프로그램이 NamingEnumeration을 통해 반복하기 위해 hasMoreElements () 및 nextElement ()를 대신 사용하는 경우 이러한 메소드는 예외를 처리 할 수 ​​없으므로 예외는 발생하지 않습니다. 대신 이전 예제에서 nextElement ()에서 n 번째 결과를 반환 한 후 hasMoreElements ()를 호출하면 false가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="74d9644d5ed77ea6ee5a9c09c65d61b1fec65648" translate="yes" xml:space="preserve">
          <source>Note that if the result is &lt;code&gt;null&lt;/code&gt;, then the Logger will use a resource bundle or resource bundle name inherited from its parent.</source>
          <target state="translated">결과가 &lt;code&gt;null&lt;/code&gt; 인 경우 로거는 상위에서 상속 된 자원 번들 또는 자원 번들 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="774d989105eaf3efacce03fa62042e7823cce473" translate="yes" xml:space="preserve">
          <source>Note that if the sequence of characters is already available as a character array, using this constructor is faster than converting the &lt;code&gt;char&lt;/code&gt; array to string and using the &lt;code&gt;BigDecimal(String)&lt;/code&gt; constructor .</source>
          <target state="translated">문자 시퀀스를 문자 배열로 이미 사용할 수있는 경우이 생성자를 사용하면 &lt;code&gt;char&lt;/code&gt; 배열을 문자열 로 변환 하고 &lt;code&gt;BigDecimal(String)&lt;/code&gt; 생성자를 사용하는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="ee5d641dbc68d85341336041df46fcac48f42a89" translate="yes" xml:space="preserve">
          <source>Note that if the sequence of characters is already available within a character array, using this constructor is faster than converting the &lt;code&gt;char&lt;/code&gt; array to string and using the &lt;code&gt;BigDecimal(String)&lt;/code&gt; constructor .</source>
          <target state="translated">문자 배열 내에서 일련의 문자를 이미 사용할 수있는 경우이 생성자를 사용하면 &lt;code&gt;char&lt;/code&gt; 배열을 문자열 로 변환 하고 &lt;code&gt;BigDecimal(String)&lt;/code&gt; 사용하는 것보다 빠릅니다. 생성자를 .</target>
        </trans-unit>
        <trans-unit id="c653832fe9e9a5a7b45e88d7b4b7c78e7e8a24e0" translate="yes" xml:space="preserve">
          <source>Note that if the state is not supported on a given platform, neither the state nor the return value of the &lt;a href=&quot;#getExtendedState()&quot;&gt;&lt;code&gt;getExtendedState()&lt;/code&gt;&lt;/a&gt; method will be changed. The application may determine whether a specific state is supported via the &lt;a href=&quot;toolkit#isFrameStateSupported(int)&quot;&gt;&lt;code&gt;Toolkit.isFrameStateSupported(int)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Note that if the state is not supported on a given platform, neither the state nor the return value of the &lt;a href=&quot;#getExtendedState()&quot;&gt; &lt;code&gt;getExtendedState()&lt;/code&gt; &lt;/a&gt; method will be changed. The application may determine whether a specific state is supported via the &lt;a href=&quot;toolkit#isFrameStateSupported(int)&quot;&gt; &lt;code&gt;Toolkit.isFrameStateSupported(int)&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="c009d66492b671713524ebe2a8347822c7b30890" translate="yes" xml:space="preserve">
          <source>Note that if the state is not supported on a given platform, neither the state nor the return value of the &lt;a href=&quot;#getState()&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; method will be changed. The application may determine whether a specific state is supported via the &lt;a href=&quot;toolkit#isFrameStateSupported(int)&quot;&gt;&lt;code&gt;Toolkit.isFrameStateSupported(int)&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Note that if the state is not supported on a given platform, neither the state nor the return value of the &lt;a href=&quot;#getState()&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt; method will be changed. The application may determine whether a specific state is supported via the &lt;a href=&quot;toolkit#isFrameStateSupported(int)&quot;&gt; &lt;code&gt;Toolkit.isFrameStateSupported(int)&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="a478ef65e641810f99e57f9e4607b22c57a2ef28" translate="yes" xml:space="preserve">
          <source>Note that if the underlying input stream is able to supply</source>
          <target state="translated">기본 입력 스트림이 공급할 수있는 경우</target>
        </trans-unit>
        <trans-unit id="be5c7f889ab46e8fe7728832c7b1fd8abf4e82be" translate="yes" xml:space="preserve">
          <source>Note that if this &lt;code&gt;Component&lt;/code&gt; is inheriting a bound property, then no event will be fired in response to a change in the inherited property.</source>
          <target state="translated">Note that if this &lt;code&gt;Component&lt;/code&gt; is inheriting a bound property, then no event will be fired in response to a change in the inherited property.</target>
        </trans-unit>
        <trans-unit id="7796f46b951fee5509c7b9824042436c7fa444f6" translate="yes" xml:space="preserve">
          <source>Note that if this CodeSource has a null location and a null certificate chain, then it implies every other CodeSource.</source>
          <target state="translated">이 CodeSource에 null 위치와 null 인증서 체인이 있으면 다른 모든 CodeSource를 암시합니다.</target>
        </trans-unit>
        <trans-unit id="b866f620e2031fa2f054dd0ffed73c80c3041462" translate="yes" xml:space="preserve">
          <source>Note that if this Container is inheriting a bound property, then no event will be fired in response to a change in the inherited property.</source>
          <target state="translated">Note that if this Container is inheriting a bound property, then no event will be fired in response to a change in the inherited property.</target>
        </trans-unit>
        <trans-unit id="f282243a057f406380e2cad62f7ad0f39f73366b" translate="yes" xml:space="preserve">
          <source>Note that if this KeyStore has already been loaded, it is reinitialized and loaded again from the given parameter.</source>
          <target state="translated">이 KeyStore가 이미로드 된 경우 지정된 매개 변수에서 다시 초기화되고 다시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="73a443184e6e036601ed7ff0d4e667c642992672" translate="yes" xml:space="preserve">
          <source>Note that if this Window is inheriting a bound property, then no event will be fired in response to a change in the inherited property.</source>
          <target state="translated">Note that if this Window is inheriting a bound property, then no event will be fired in response to a change in the inherited property.</target>
        </trans-unit>
        <trans-unit id="42c51aafbd8982934ba161bd487f452aa086da40" translate="yes" xml:space="preserve">
          <source>Note that if this keystore has already been loaded, it is reinitialized and loaded again from the given input stream.</source>
          <target state="translated">이 키 스토어가 벌써로드되어있는 경우, 지정된 입력 스트림로부터 다시 초기화되어 다시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="c8ee85c349c252d854e34e0f8c5468b749453d00" translate="yes" xml:space="preserve">
          <source>Note that if this method enters the &lt;code&gt;abort&lt;/code&gt; phase (either the &lt;code&gt;login&lt;/code&gt; or &lt;code&gt;commit&lt;/code&gt; phase failed), this method invokes all LoginModules configured for the application regardless of their respective &lt;code&gt;Configuration&lt;/code&gt; flag parameters. Essentially this means that &lt;code&gt;Requisite&lt;/code&gt; and &lt;code&gt;Sufficient&lt;/code&gt; semantics are ignored during the &lt;code&gt;abort&lt;/code&gt; phase. This guarantees that proper cleanup and state restoration can take place.</source>
          <target state="translated">이 메소드가 &lt;code&gt;abort&lt;/code&gt; 단계에 들어가면 ( &lt;code&gt;login&lt;/code&gt; 또는 &lt;code&gt;commit&lt;/code&gt; 단계 실패)이 메소드는 각각의 &lt;code&gt;Configuration&lt;/code&gt; 플래그 매개 변수에 관계없이 애플리케이션에 대해 구성된 모든 LoginModule을 호출합니다 . 본질적으로 이것은 &lt;code&gt;abort&lt;/code&gt; 단계 동안 &lt;code&gt;Requisite&lt;/code&gt; 및 &lt;code&gt;Sufficient&lt;/code&gt; 의미가 무시됨을 의미 합니다. 이를 통해 적절한 정리 및 상태 복원이 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="380d9f6f566ca3699136e0c02058775f57d47362" translate="yes" xml:space="preserve">
          <source>Note that if this method returns &lt;a href=&quot;elements.origin#EXPLICIT&quot;&gt;&lt;code&gt;EXPLICIT&lt;/code&gt;&lt;/a&gt; and the annotation mirror was created from a class file, then the element may not, in fact, correspond to an explicitly declared construct in source code. This is due to limitations of the fidelity of the class file format in preserving information from source code. For example, at least some versions of the class file format do not preserve whether an annotation was explicitly declared by the programmer or was implicitly declared as a &lt;em&gt;container annotation&lt;/em&gt;.</source>
          <target state="translated">Note that if this method returns &lt;a href=&quot;elements.origin#EXPLICIT&quot;&gt; &lt;code&gt;EXPLICIT&lt;/code&gt; &lt;/a&gt; and the annotation mirror was created from a class file, then the element may not, in fact, correspond to an explicitly declared construct in source code. This is due to limitations of the fidelity of the class file format in preserving information from source code. For example, at least some versions of the class file format do not preserve whether an annotation was explicitly declared by the programmer or was implicitly declared as a &lt;em&gt;container annotation&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="1503afd9d58cfcf8d964d3dd4ac77a75801db3a6" translate="yes" xml:space="preserve">
          <source>Note that if this method returns &lt;a href=&quot;elements.origin#EXPLICIT&quot;&gt;&lt;code&gt;EXPLICIT&lt;/code&gt;&lt;/a&gt; and the element was created from a class file, then the element may not, in fact, correspond to an explicitly declared construct in source code. This is due to limitations of the fidelity of the class file format in preserving information from source code. For example, at least some versions of the class file format do not preserve whether a constructor was explicitly declared by the programmer or was implicitly declared as the &lt;em&gt;default constructor&lt;/em&gt;.</source>
          <target state="translated">Note that if this method returns &lt;a href=&quot;elements.origin#EXPLICIT&quot;&gt; &lt;code&gt;EXPLICIT&lt;/code&gt; &lt;/a&gt; and the element was created from a class file, then the element may not, in fact, correspond to an explicitly declared construct in source code. This is due to limitations of the fidelity of the class file format in preserving information from source code. For example, at least some versions of the class file format do not preserve whether a constructor was explicitly declared by the programmer or was implicitly declared as the &lt;em&gt;default constructor&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="4c79731215980bfcfd36f07188150a9ea1bb8f25" translate="yes" xml:space="preserve">
          <source>Note that if this method returns &lt;a href=&quot;elements.origin#EXPLICIT&quot;&gt;&lt;code&gt;EXPLICIT&lt;/code&gt;&lt;/a&gt; and the module directive was created from a class file, then the module directive may not, in fact, correspond to an explicitly declared construct in source code. This is due to limitations of the fidelity of the class file format in preserving information from source code. For example, at least some versions of the class file format do not preserve whether a &lt;code&gt;uses&lt;/code&gt; directive was explicitly declared by the programmer or was added as a synthetic construct.</source>
          <target state="translated">Note that if this method returns &lt;a href=&quot;elements.origin#EXPLICIT&quot;&gt; &lt;code&gt;EXPLICIT&lt;/code&gt; &lt;/a&gt; and the module directive was created from a class file, then the module directive may not, in fact, correspond to an explicitly declared construct in source code. This is due to limitations of the fidelity of the class file format in preserving information from source code. For example, at least some versions of the class file format do not preserve whether a &lt;code&gt;uses&lt;/code&gt; directive was explicitly declared by the programmer or was added as a synthetic construct.</target>
        </trans-unit>
        <trans-unit id="8baa95b0fed125c2956cc64c3d8d5a6a764365cb" translate="yes" xml:space="preserve">
          <source>Note that if your application creates its own custom activation group, a security manager must be set for that group. Otherwise objects cannot be activated in the group. &lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt;&lt;code&gt;SecurityManager&lt;/code&gt;&lt;/a&gt; is set by default.</source>
          <target state="translated">Note that if your application creates its own custom activation group, a security manager must be set for that group. Otherwise objects cannot be activated in the group. &lt;a href=&quot;../../../../java.base/java/lang/securitymanager&quot;&gt; &lt;code&gt;SecurityManager&lt;/code&gt; &lt;/a&gt; is set by default.</target>
        </trans-unit>
        <trans-unit id="c68c212551671e7a9a78eff5842cbd110b381643" translate="yes" xml:space="preserve">
          <source>Note that implementors of this interface may find it convenient to extend &lt;a href=&quot;abstractprocessor&quot;&gt;&lt;code&gt;AbstractProcessor&lt;/code&gt;&lt;/a&gt; rather than implementing this interface directly.</source>
          <target state="translated">이 인터페이스의 구현자는 이 인터페이스를 직접 구현하지 않고 &lt;a href=&quot;abstractprocessor&quot;&gt; &lt;code&gt;AbstractProcessor&lt;/code&gt; &lt;/a&gt; 를 확장하는 것이 편리하다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bff893394739c0ef400ed7cf72c30c877d1ec67" translate="yes" xml:space="preserve">
          <source>Note that in most cases, for two instances of class &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;d1&lt;/code&gt; and &lt;code&gt;d2&lt;/code&gt;, the value of &lt;code&gt;d1.equals(d2)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if and only if</source>
          <target state="translated">클래스의 두 인스턴스를 들어, 대부분의 경우 그 주 &lt;code&gt;Double&lt;/code&gt; , &lt;code&gt;d1&lt;/code&gt; 과 &lt;code&gt;d2&lt;/code&gt; 의 값 &lt;code&gt;d1.equals(d2)&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; 경우만</target>
        </trans-unit>
        <trans-unit id="db1a95736593416bcb8de2009e96c016884dd267" translate="yes" xml:space="preserve">
          <source>Note that in most cases, for two instances of class &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, the value of &lt;code&gt;f1.equals(f2)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if and only if</source>
          <target state="translated">대부분의 경우에, 두 클래스의 인스턴스 참고 &lt;code&gt;Float&lt;/code&gt; , &lt;code&gt;f1&lt;/code&gt; 및 &lt;code&gt;f2&lt;/code&gt; 의 값 &lt;code&gt;f1.equals(f2)&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 경우만</target>
        </trans-unit>
        <trans-unit id="d51cf871f36d469a8dae4cb42f7f423179b12d12" translate="yes" xml:space="preserve">
          <source>Note that in some cases, the returned array be empty. This can occur if this type represents a non-parameterized type nested within a parameterized type.</source>
          <target state="translated">어떤 경우에는 반환 된 배열이 비어 있습니다. 이 유형이 매개 변수화 된 유형 내에 중첩 된 매개 변수화되지 않은 유형을 나타내는 경우 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="688de592429793ab731dc8b40412487515fe62b5" translate="yes" xml:space="preserve">
          <source>Note that in two's complement arithmetic, the three other basic arithmetic operations of add, subtract, and multiply are bit-wise identical if the two operands are regarded as both being signed or both being unsigned. Therefore separate &lt;code&gt;
 addUnsigned&lt;/code&gt;, etc. methods are not provided.</source>
          <target state="translated">Note that in two's complement arithmetic, the three other basic arithmetic operations of add, subtract, and multiply are bit-wise identical if the two operands are regarded as both being signed or both being unsigned. Therefore separate &lt;code&gt; addUnsigned&lt;/code&gt; , etc. methods are not provided.</target>
        </trans-unit>
        <trans-unit id="90385339e440dcaf46fa13bfdfc451d03cfb3ffd" translate="yes" xml:space="preserve">
          <source>Note that in two's complement arithmetic, the three other basic arithmetic operations of add, subtract, and multiply are bit-wise identical if the two operands are regarded as both being signed or both being unsigned. Therefore separate &lt;code&gt;addUnsigned&lt;/code&gt;, etc. methods are not provided.</source>
          <target state="translated">2의 보수 산술에서, 두 피연산자가 모두 부호가 있거나 부호가없는 것으로 간주되면 더하기, 빼기 및 곱하기의 세 가지 기본 산술 연산은 비트 단위로 동일합니다. 따라서 별도의 &lt;code&gt;addUnsigned&lt;/code&gt; 등의 메소드가 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12aef33363d17a4c6e02dc22fc7eb3169bf5fbda" translate="yes" xml:space="preserve">
          <source>Note that in-place operation is allowed (i.e. the source and destination can be the same object).</source>
          <target state="translated">Note that in-place operation is allowed (i.e. the source and destination can be the same object).</target>
        </trans-unit>
        <trans-unit id="33f090933196b0569df5dee7f5639217a6f1abc1" translate="yes" xml:space="preserve">
          <source>Note that instances of functional interfaces can be created with lambda expressions, method references, or constructor references.</source>
          <target state="translated">기능적 인터페이스의 인스턴스는 람다 식, 메서드 참조 또는 생성자 참조를 사용하여 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f6063427e8c944851a127a8a980db65f71eccb7" translate="yes" xml:space="preserve">
          <source>Note that interleaved &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt; Rasters are not supported. To create a 1-band Raster of type &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;, use Raster.createPackedRaster().</source>
          <target state="translated">Note that interleaved &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt; Rasters are not supported. To create a 1-band Raster of type &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt; , use Raster.createPackedRaster().</target>
        </trans-unit>
        <trans-unit id="03a2a95c70448b11bc7a63fb28605b1d15f58b57" translate="yes" xml:space="preserve">
          <source>Note that it is</source>
          <target state="translated">참고</target>
        </trans-unit>
        <trans-unit id="c274a59c364571cd5df5639ee2ea0b7c4310bc45" translate="yes" xml:space="preserve">
          <source>Note that it is generally necessary to override the &lt;code&gt;hashCode&lt;/code&gt; method whenever this method is overridden, so as to maintain the general contract for the &lt;code&gt;hashCode&lt;/code&gt; method, which states that equal objects must have equal hash codes.</source>
          <target state="translated">동일한 객체가 동일한 해시 코드를 가져야한다는 &lt;code&gt;hashCode&lt;/code&gt; 메소드 의 일반 계약을 유지하려면이 메소드를 대체 할 때마다 &lt;code&gt;hashCode&lt;/code&gt; 메소드 를 대체 해야합니다.</target>
        </trans-unit>
        <trans-unit id="514b591f2671cfba70b4bb5d123384cc09690e27" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to write the leading zeros in an individual field. However, there must be at least one numeral in every field, except as described below.</source>
          <target state="translated">개별 필드에 선행 0을 쓸 필요는 없습니다. 그러나 아래 설명 된 경우를 제외하고 모든 필드에 하나 이상의 숫자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="612fc8f699533c0572cad0aabd37cf2b64c11f57" translate="yes" xml:space="preserve">
          <source>Note that it is permissible to call this method from within a a task scheduled on this timer.</source>
          <target state="translated">이 타이머에 예약 된 작업 내에서이 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8ffa1f0aab195658061dc58f2243864af22f511" translate="yes" xml:space="preserve">
          <source>Note that it is permissible to call this method from within a task scheduled on this timer.</source>
          <target state="translated">Note that it is permissible to call this method from within a task scheduled on this timer.</target>
        </trans-unit>
        <trans-unit id="e7eaed8d271a7e84daafee89532064975d9d98b6" translate="yes" xml:space="preserve">
          <source>Note that it is permissible to pass the same collection in both parameters, in which case the method will return &lt;code&gt;true&lt;/code&gt; if and only if the collection is empty.</source>
          <target state="translated">두 매개 변수에서 동일한 콜렉션을 전달할 수 있습니다.이 경우 콜렉션이 비어있는 경우에만 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="6a6d728f3ec6e999e954980cbcd91941d2c13e09" translate="yes" xml:space="preserve">
          <source>Note that it is possible additional directive kinds will be added to accommodate new, currently unknown, language structures added to future versions of the Java&amp;trade; programming language.</source>
          <target state="translated">Note that it is possible additional directive kinds will be added to accommodate new, currently unknown, language structures added to future versions of the Java&amp;trade; programming language.</target>
        </trans-unit>
        <trans-unit id="1b45ff14fe471afc8dd4539952c88140ba928538" translate="yes" xml:space="preserve">
          <source>Note that it is possible additional element kinds will be added to accommodate new, currently unknown, language structures added to future versions of the Java&amp;trade; programming language.</source>
          <target state="translated">향후 버전의 Java &amp;trade; 프로그래밍 언어에 추가 된 현재 알려지지 않은 새로운 언어 구조를 수용하기 위해 추가 요소 유형이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dce6d5cde5e40ff1def189511080929fe993f48e" translate="yes" xml:space="preserve">
          <source>Note that it is possible additional kinds of origin values will be added in future versions of the platform.</source>
          <target state="translated">Note that it is possible additional kinds of origin values will be added in future versions of the platform.</target>
        </trans-unit>
        <trans-unit id="ec923ba157248b446f6924fc83ad0b4fe2cd2e61" translate="yes" xml:space="preserve">
          <source>Note that it is possible additional modifiers will be added in future versions of the platform.</source>
          <target state="translated">이후 버전의 플랫폼에서 추가 수정자가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73597df8bc84a4a2c3eecefc968ea11e99cf5171" translate="yes" xml:space="preserve">
          <source>Note that it is possible additional nesting kinds will be added in future versions of the platform.</source>
          <target state="translated">향후 버전의 플랫폼에서 추가 중첩 유형이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e0a5e5f09dd75db9579ada2258fe863c5bc3e49" translate="yes" xml:space="preserve">
          <source>Note that it is possible additional type kinds will be added to accommodate new, currently unknown, language structures added to future versions of the Java&amp;trade; programming language.</source>
          <target state="translated">향후 버전의 Java &amp;trade; 프로그래밍 언어에 추가 된 현재 알려지지 않은 새로운 언어 구조를 수용하기 위해 추가 유형 유형이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f55c4eac0b599bdd2d137d8a743054595b1ad9" translate="yes" xml:space="preserve">
          <source>Note that it is possible for arbitrary code to obtain access to a proxy class in an open package with &lt;a href=&quot;accessibleobject#setAccessible(java.lang.reflect.AccessibleObject%5B%5D,boolean)&quot;&gt;&lt;code&gt;setAccessible&lt;/code&gt;&lt;/a&gt;, whereas a proxy class in a non-open package is never accessible to code outside the module of the proxy class.</source>
          <target state="translated">Note that it is possible for arbitrary code to obtain access to a proxy class in an open package with &lt;a href=&quot;accessibleobject#setAccessible(java.lang.reflect.AccessibleObject%5B%5D,boolean)&quot;&gt; &lt;code&gt;setAccessible&lt;/code&gt; &lt;/a&gt;, whereas a proxy class in a non-open package is never accessible to code outside the module of the proxy class.</target>
        </trans-unit>
        <trans-unit id="da59aa19f6e708cf0efe0a237175ae4abc480637" translate="yes" xml:space="preserve">
          <source>Note that it is possible that &lt;code&gt;acceptSecContext&lt;/code&gt; return a token for the peer, and &lt;code&gt;isEstablished&lt;/code&gt; return &lt;code&gt;true&lt;/code&gt; also. This indicates that the token needs to be sent to the peer, but the local end of the context is now fully established.</source>
          <target state="translated">Note that it is possible that &lt;code&gt;acceptSecContext&lt;/code&gt; return a token for the peer, and &lt;code&gt;isEstablished&lt;/code&gt; return &lt;code&gt;true&lt;/code&gt; also. This indicates that the token needs to be sent to the peer, but the local end of the context is now fully established.</target>
        </trans-unit>
        <trans-unit id="4d63431903a8b9f7a47f669cdbe8c4a1d7329911" translate="yes" xml:space="preserve">
          <source>Note that it is possible that the &lt;code&gt;initSecContext&lt;/code&gt; method return a token for the peer, and &lt;code&gt;isEstablished&lt;/code&gt; return &lt;code&gt;true&lt;/code&gt; also. This indicates that the token needs to be sent to the peer, but the local end of the context is now fully established.</source>
          <target state="translated">Note that it is possible that the &lt;code&gt;initSecContext&lt;/code&gt; method return a token for the peer, and &lt;code&gt;isEstablished&lt;/code&gt; return &lt;code&gt;true&lt;/code&gt; also. This indicates that the token needs to be sent to the peer, but the local end of the context is now fully established.</target>
        </trans-unit>
        <trans-unit id="3c14a0d344b2c94f579cdcede2142e2eb8b98458" translate="yes" xml:space="preserve">
          <source>Note that it is possible to encounter method types which cannot be constructed by this method, because their component types are not all reachable from a common class loader.</source>
          <target state="translated">구성 요소 유형이 모두 공통 클래스 로더에서 도달 할 수 없기 때문에이 메소드로 구성 할 수없는 메소드 유형이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f96cf68a097455094b72486bf393aef74e0e72c6" translate="yes" xml:space="preserve">
          <source>Note that it is possible to skip something without risking a &lt;code&gt;NoSuchElementException&lt;/code&gt; by using a pattern that can match nothing, e.g., &lt;code&gt;sc.skip(&quot;[ \t]*&quot;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sc.skip(&quot;[ \t]*&quot;)&lt;/code&gt; 와 같이 아무것도 일치하지 않는 패턴을 사용하여 &lt;code&gt;NoSuchElementException&lt;/code&gt; 을 발생 시키지 않고 무언가를 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b744b87c89c989ec2dcd5f9b9dde9806c9036e1" translate="yes" xml:space="preserve">
          <source>Note that it is the programmer's responsibility to ensure that each tab has a unique mnemonic or unpredictable results may occur.</source>
          <target state="translated">Note that it is the programmer's responsibility to ensure that each tab has a unique mnemonic or unpredictable results may occur.</target>
        </trans-unit>
        <trans-unit id="164cd6aa37467bb1f41e6b81eca3e9257f606c95" translate="yes" xml:space="preserve">
          <source>Note that it is valid for an &lt;code&gt;ImageReader&lt;/code&gt; to call &lt;code&gt;flushBefore&lt;/code&gt; as part of a read operation. Therefore, if an application calls &lt;code&gt;mark&lt;/code&gt; prior to passing that stream to an &lt;code&gt;ImageReader&lt;/code&gt;, the application should not assume that the marked position will remain valid after the read operation has completed.</source>
          <target state="translated">읽기 작업의 일부로 &lt;code&gt;ImageReader&lt;/code&gt; 가 &lt;code&gt;flushBefore&lt;/code&gt; 를 호출 하는 것이 유효 합니다. 따라서 응용 프로그램이 해당 스트림을 &lt;code&gt;ImageReader&lt;/code&gt; 로 전달하기 전에 &lt;code&gt;mark&lt;/code&gt; 를 호출 하면 응용 프로그램은 읽기 작업이 완료된 후에 표시된 위치가 유효한 것으로 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e0fd39277be040bfbac37951a43994c90b966b0b" translate="yes" xml:space="preserve">
          <source>Note that left rotation with a negative distance is equivalent to right rotation: &lt;code&gt;rotateLeft(val, -distance) == rotateRight(val,
 distance)&lt;/code&gt;. Note also that rotation by any multiple of 32 is a no-op, so all but the last five bits of the rotation distance can be ignored, even if the distance is negative: &lt;code&gt;rotateLeft(val,
 distance) == rotateLeft(val, distance &amp;amp; 0x1F)&lt;/code&gt;.</source>
          <target state="translated">거리가 음수 인 왼쪽 회전은 오른쪽 회전과 같습니다. &lt;code&gt;rotateLeft(val, -distance) == rotateRight(val, distance)&lt;/code&gt; . 32의 배수에 의한 회전은 no-op이므로 거리가 음수 일지라도 회전 거리의 마지막 5 비트를 제외한 모든 비트는 무시할 수 있습니다. &lt;code&gt;rotateLeft(val, distance) == rotateLeft(val, distance &amp;amp; 0x1F)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26468a8d8b5ccff2233a9b49e4c86accd8f5eb28" translate="yes" xml:space="preserve">
          <source>Note that left rotation with a negative distance is equivalent to right rotation: &lt;code&gt;rotateLeft(val, -distance) == rotateRight(val,
 distance)&lt;/code&gt;. Note also that rotation by any multiple of 64 is a no-op, so all but the last six bits of the rotation distance can be ignored, even if the distance is negative: &lt;code&gt;rotateLeft(val,
 distance) == rotateLeft(val, distance &amp;amp; 0x3F)&lt;/code&gt;.</source>
          <target state="translated">거리가 음수 인 왼쪽 회전은 오른쪽 회전과 같습니다. &lt;code&gt;rotateLeft(val, -distance) == rotateRight(val, distance)&lt;/code&gt; . 또한 64의 배수로 회전하는 것은 작동하지 않으므로 거리가 음수 인 경우에도 회전 거리의 마지막 6 비트를 제외한 모든 비트를 무시할 수 있습니다. &lt;code&gt;rotateLeft(val, distance) == rotateLeft(val, distance &amp;amp; 0x3F)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93396dda53e50cf9b2def5407a12b6a0dbacb521" translate="yes" xml:space="preserve">
          <source>Note that little memory is freed by this call: the current array is kept so it can be reused.</source>
          <target state="translated">Note that little memory is freed by this call: the current array is kept so it can be reused.</target>
        </trans-unit>
        <trans-unit id="6fb4f9f3642190b80d4ad72b097413701ea41f24" translate="yes" xml:space="preserve">
          <source>Note that many implementations might return an unmodifiable list.</source>
          <target state="translated">Note that many implementations might return an unmodifiable list.</target>
        </trans-unit>
        <trans-unit id="64c6f2af99e15a3012af3f6044d8aa02f65faae7" translate="yes" xml:space="preserve">
          <source>Note that methods in this class which take a &lt;code&gt;Graphics&lt;/code&gt; parameter measure text using the &lt;code&gt;FontRenderContext&lt;/code&gt; of that &lt;code&gt;Graphics&lt;/code&gt; object, and not this &lt;code&gt;FontRenderContext&lt;/code&gt;</source>
          <target state="translated">Note that methods in this class which take a &lt;code&gt;Graphics&lt;/code&gt; parameter measure text using the &lt;code&gt;FontRenderContext&lt;/code&gt; of that &lt;code&gt;Graphics&lt;/code&gt; object, and not this &lt;code&gt;FontRenderContext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f98f379f65d6b9dfddd6607a9b53556e1d216bb" translate="yes" xml:space="preserve">
          <source>Note that methods to accommodate new language constructs could be added in a source &lt;em&gt;compatible&lt;/em&gt; way if they were added as &lt;em&gt;default methods&lt;/em&gt;. However, default methods are only available on Java SE 8 and higher releases and the &lt;code&gt;
 javax.lang.model.*&lt;/code&gt; packages bundled in Java SE 8 were required to also be runnable on Java SE 7. Therefore, default methods were &lt;em&gt;not&lt;/em&gt; used when extending &lt;code&gt;javax.lang.model.*&lt;/code&gt; to cover Java SE 8 language features. However, default methods are used in subsequent revisions of the &lt;code&gt;javax.lang.model.*&lt;/code&gt; packages that are only required to run on Java SE 8 and higher platform versions.</source>
          <target state="translated">Note that methods to accommodate new language constructs could be added in a source &lt;em&gt;compatible&lt;/em&gt; way if they were added as &lt;em&gt;default methods&lt;/em&gt;. However, default methods are only available on Java SE 8 and higher releases and the &lt;code&gt; javax.lang.model.*&lt;/code&gt; packages bundled in Java SE 8 were required to also be runnable on Java SE 7. Therefore, default methods were &lt;em&gt;not&lt;/em&gt; used when extending &lt;code&gt;javax.lang.model.*&lt;/code&gt; to cover Java SE 8 language features. However, default methods are used in subsequent revisions of the &lt;code&gt;javax.lang.model.*&lt;/code&gt; packages that are only required to run on Java SE 8 and higher platform versions.</target>
        </trans-unit>
        <trans-unit id="c54c6c466bd9a64456f370c0102774692a65eeb5" translate="yes" xml:space="preserve">
          <source>Note that methods to accommodate new language constructs could be added in a source &lt;em&gt;compatible&lt;/em&gt; way if they were added as &lt;em&gt;default methods&lt;/em&gt;. However, default methods are only available on Java SE 8 and higher releases and the &lt;code&gt;javax.lang.model.*&lt;/code&gt; packages bundled in Java SE 8 are required to also be runnable on Java SE 7. Therefore, default methods &lt;em&gt;cannot&lt;/em&gt; be used when extending &lt;code&gt;javax.lang.model.*&lt;/code&gt; to cover Java SE 8 language features. However, default methods may be used in subsequent revisions of the &lt;code&gt;javax.lang.model.*&lt;/code&gt; packages that are only required to run on Java SE 8 and higher platform versions.</source>
          <target state="translated">새로운 언어 구조를 수용하는 메소드 는 &lt;em&gt;기본 메소드&lt;/em&gt; 로 추가 된 경우 소스 &lt;em&gt;호환&lt;/em&gt; 방식 으로 추가 될 수 있습니다 . 그러나 기본 메소드는 Java SE 8 이상 릴리스에서만 사용 가능하며 Java SE 8에 번들로 제공되는 &lt;code&gt;javax.lang.model.*&lt;/code&gt; 패키지는 Java SE 7에서도 실행 가능해야합니다. 따라서 &lt;code&gt;javax.lang.model.*&lt;/code&gt; 확장 할 때 기본 메소드를 &lt;em&gt;사용할 수 없습니다&lt;/em&gt; . Java SE 8 언어 기능을 다루는 .lang.model. * 그러나 기본 메소드는 Java SE 8 이상 플랫폼 버전에서만 실행되는 &lt;code&gt;javax.lang.model.*&lt;/code&gt; 패키지 의 후속 개정판에서 사용될 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c20a27a461415de2d9e542cbffefe98047074ae2" translate="yes" xml:space="preserve">
          <source>Note that multi-frame images are invalid and may cause this method to hang.</source>
          <target state="translated">Note that multi-frame images are invalid and may cause this method to hang.</target>
        </trans-unit>
        <trans-unit id="dcf5ed9ef9f92cbb9f69eece33ec244c4e623965" translate="yes" xml:space="preserve">
          <source>Note that multiples of 24 hours are not output as days to avoid confusion with &lt;code&gt;Period&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Period&lt;/code&gt; 와의 혼동을 피하기 위해 24 시간의 배수는 일로 출력되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="39ee9e5502987b70feee792e5ccd5966e98cdc49" translate="yes" xml:space="preserve">
          <source>Note that mutation of the Properties object returned will not effect the properties that the transformer contains.</source>
          <target state="translated">Note that mutation of the Properties object returned will not effect the properties that the transformer contains.</target>
        </trans-unit>
        <trans-unit id="28a362bf13dc33d93aeda88e8ac936d95db601e4" translate="yes" xml:space="preserve">
          <source>Note that neither the character &lt;code&gt;L&lt;/code&gt; (&lt;code&gt;'\u004C'&lt;/code&gt;) nor &lt;code&gt;l&lt;/code&gt; (&lt;code&gt;'\u006C'&lt;/code&gt;) is permitted to appear at the end of the string as a type indicator, as would be permitted in Java programming language source code - except that either &lt;code&gt;L&lt;/code&gt; or &lt;code&gt;l&lt;/code&gt; may appear as a digit for a radix greater than or equal to 22.</source>
          <target state="translated">문자 &lt;code&gt;L&lt;/code&gt; ( &lt;code&gt;'\u004C'&lt;/code&gt; )과 &lt;code&gt;l&lt;/code&gt; ( &lt;code&gt;'\u006C'&lt;/code&gt; )은 문자열의 끝에 Java 프로그래밍 언어 소스 코드에서 허용되는 &lt;code&gt;L&lt;/code&gt; 을 제외하고 유형 표시 자로 표시 할 수 없습니다. 또는 &lt;code&gt;l&lt;/code&gt; 은 22 이상의 기수에 대한 숫자로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a255730394476eced606a6b74069e5847d5d6ca1" translate="yes" xml:space="preserve">
          <source>Note that neither the character &lt;code&gt;L&lt;/code&gt; (&lt;code&gt;'\u004C'&lt;/code&gt;) nor &lt;code&gt;l&lt;/code&gt; (&lt;code&gt;'\u006C'&lt;/code&gt;) is permitted to appear at the end of the string as a type indicator, as would be permitted in Java programming language source code.</source>
          <target state="translated">Java 프로그래밍 언어 소스 코드에서 허용되는 것처럼 문자 &lt;code&gt;L&lt;/code&gt; ( &lt;code&gt;'\u004C'&lt;/code&gt; )과 &lt;code&gt;l&lt;/code&gt; ( &lt;code&gt;'\u006C'&lt;/code&gt; )은 문자열 끝에 유형 표시 자로 표시 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="43fc524362be5054f36b79406d37776d6000a71a" translate="yes" xml:space="preserve">
          <source>Note that non Principal-based grant entries are not permitted in this &lt;code&gt;Policy&lt;/code&gt;. Therefore, grant entries such as:</source>
          <target state="translated">이 &lt;code&gt;Policy&lt;/code&gt; 에서는 교장 기반의 보조금 항목이 허용되지 않습니다 . 따라서 다음과 같은 항목을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="d62741466c85b19fc04a0b58158b50a2b84f67d2" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;final&lt;/code&gt; fields will have constant values. In particular, &lt;code&gt;enum&lt;/code&gt; constants are &lt;em&gt;not&lt;/em&gt; considered to be compile-time constants. To have a constant value, a field's type must be either a primitive type or &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">모든 &lt;code&gt;final&lt;/code&gt; 필드에 상수 값이있는 것은 아닙니다 . 특히 &lt;code&gt;enum&lt;/code&gt; 상수는 컴파일 타임 상수로 간주 &lt;em&gt;되지 않습니다&lt;/em&gt; . 상수 값을 가지려면 필드의 유형이 기본 유형이거나 &lt;code&gt;String&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cae23aa3ae509c428060eb33e16efef843733839" translate="yes" xml:space="preserve">
          <source>Note that objects specified by a descriptor created with this constructor will only be activated on demand (by default, the restart mode is &lt;code&gt;false&lt;/code&gt;). If an activatable object requires restart services, use one of the &lt;code&gt;ActivationDesc&lt;/code&gt; constructors that takes a boolean parameter, &lt;code&gt;restart&lt;/code&gt;.</source>
          <target state="translated">Note that objects specified by a descriptor created with this constructor will only be activated on demand (by default, the restart mode is &lt;code&gt;false&lt;/code&gt; ). If an activatable object requires restart services, use one of the &lt;code&gt;ActivationDesc&lt;/code&gt; constructors that takes a boolean parameter, &lt;code&gt;restart&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34f77e2a4766bc2bca16bd2d7f577f25792a0a22" translate="yes" xml:space="preserve">
          <source>Note that once a class loader is registered as parallel capable, there is no way to change it back.</source>
          <target state="translated">클래스 로더가 병렬 가능으로 등록되면 다시 변경할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="811d61dcfa693cab96a984bd139826cb0637cdad" translate="yes" xml:space="preserve">
          <source>Note that once the timer notification has been added into the list of notifications, its associated date, period and number of occurrences cannot be updated.</source>
          <target state="translated">타이머 알림이 알림 목록에 추가되면 관련 날짜, 기간 및 발생 횟수를 업데이트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="34aae5f2f18a9fea60dff8bd9b9848e321e039f0" translate="yes" xml:space="preserve">
          <source>Note that optimizations such as the removal of duplicate ProtectionDomains may have occurred. In addition, caching of ProtectionDomains may be permitted.</source>
          <target state="translated">중복 ProtectionDomain 제거와 같은 최적화가 수행되었을 수 있습니다. 또한 ProtectionDomain 캐싱이 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a4f92395e6778edbb89e42aa54d76583bc4bd7" translate="yes" xml:space="preserve">
          <source>Note that original direct method handle may include a leading &lt;code&gt;this&lt;/code&gt; parameter, or (in the case of a constructor) will replace the &lt;code&gt;void&lt;/code&gt; return type with the constructed class. The nominal type does not include any &lt;code&gt;this&lt;/code&gt; parameter, and (in the case of a constructor) will return &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">원래의 직접 메서드 핸들에는 &lt;code&gt;this&lt;/code&gt; 매개 변수 &lt;code&gt;void&lt;/code&gt; 오는 매개 변수 가 포함 되거나 생성자의 경우 void 반환 형식이 생성 된 클래스로 대체됩니다 . 공칭 유형에는 &lt;code&gt;this&lt;/code&gt; 매개 변수가 포함되지 않으며 (생성자의 경우) &lt;code&gt;void&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="6352c64da2feb606c170a2a3a17e25cfd0850b4f" translate="yes" xml:space="preserve">
          <source>Note that packing and unpacking a JAR will in general alter the bytewise contents of classfiles in the JAR. This means that packing and unpacking will in general invalidate any digital signatures which rely on bytewise images of JAR elements. In order both to sign and to pack a JAR, you must first pack and unpack the JAR to &quot;normalize&quot; it, then compute signatures on the unpacked JAR elements, and finally repack the signed JAR. Both packing steps should use precisely the same options, and the segment limit may also need to be set to &quot;-1&quot;, to prevent accidental variation of segment boundaries as class file sizes change slightly.</source>
          <target state="translated">JAR의 패킹 및 압축 해제는 일반적으로 JAR에있는 클래스 파일의 바이트 단위 내용을 변경합니다. 이는 패킹 및 패킹 해제는 일반적으로 JAR 요소의 바이트 단위 이미지에 의존하는 모든 디지털 서명을 무효화 함을 의미합니다. JAR을 서명하고 압축하려면 먼저 JAR을 압축하여 압축을 풀고 &quot;정상화&quot;한 다음 압축을 푼 JAR 요소에서 서명을 계산 한 다음 서명 된 JAR을 다시 포장해야합니다. 두 패킹 단계 모두 정확히 동일한 옵션을 사용해야하며 클래스 파일 크기가 약간 변경 될 때 세그먼트 경계가 실수로 변경되는 것을 방지하기 위해 세그먼트 제한을 &quot;-1&quot;로 설정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="297255e27261783e638479d0cac35de9b29f1f53" translate="yes" xml:space="preserve">
          <source>Note that painting a pixel with the alpha value of &lt;code&gt;0&lt;/code&gt; may or may not disable the mouse event handling on this pixel. This is a platform-dependent behavior. To make sure the mouse events do not get dispatched to a particular pixel, the pixel must be excluded from the shape of the window.</source>
          <target state="translated">Note that painting a pixel with the alpha value of &lt;code&gt;0&lt;/code&gt; may or may not disable the mouse event handling on this pixel. This is a platform-dependent behavior. To make sure the mouse events do not get dispatched to a particular pixel, the pixel must be excluded from the shape of the window.</target>
        </trans-unit>
        <trans-unit id="62fcba02ea3df7d77dc5e7fce22ecfcf437c1b5d" translate="yes" xml:space="preserve">
          <source>Note that passing &lt;code&gt;null&lt;/code&gt; or inconsistent parameters is invalid and will result in unspecified behavior.</source>
          <target state="translated">Note that passing &lt;code&gt;null&lt;/code&gt; or inconsistent parameters is invalid and will result in unspecified behavior.</target>
        </trans-unit>
        <trans-unit id="b6c1fc8199f1ac8758890318d0d1791aa6be332f" translate="yes" xml:space="preserve">
          <source>Note that passing in a &lt;code&gt;null&lt;/code&gt; value for &lt;code&gt;dataVector&lt;/code&gt; results in unspecified behavior, an possibly an exception.</source>
          <target state="translated">Note that passing in a &lt;code&gt;null&lt;/code&gt; value for &lt;code&gt;dataVector&lt;/code&gt; results in unspecified behavior, an possibly an exception.</target>
        </trans-unit>
        <trans-unit id="2c7365c75aa81e942a50bdebcef4f4b8ad7cc408" translate="yes" xml:space="preserve">
          <source>Note that passing in an invalid &lt;code&gt;id&lt;/code&gt; parameter results in unspecified behavior. This method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if &lt;code&gt;source&lt;/code&gt; equals &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Note that passing in an invalid &lt;code&gt;id&lt;/code&gt; parameter results in unspecified behavior. This method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if &lt;code&gt;source&lt;/code&gt; equals &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a4f2ac33caabca57dc53903c29be545850bcdd7" translate="yes" xml:space="preserve">
          <source>Note that passing in an invalid &lt;code&gt;id&lt;/code&gt; results in unspecified behavior. This method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if &lt;code&gt;source&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Note that passing in an invalid &lt;code&gt;id&lt;/code&gt; results in unspecified behavior. This method throws an &lt;code&gt;IllegalArgumentException&lt;/code&gt; if &lt;code&gt;source&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="060981dd4168e6863db78bc1880cf224e32e6a93" translate="yes" xml:space="preserve">
          <source>Note that passing negative parameter is incorrect, and will cause the returning an unspecified string. Zero parameter means that no modifiers were passed and will cause the returning an empty string.</source>
          <target state="translated">Note that passing negative parameter is incorrect, and will cause the returning an unspecified string. Zero parameter means that no modifiers were passed and will cause the returning an empty string.</target>
        </trans-unit>
        <trans-unit id="fac77538eccb3fb44152cf5c06cedec1ee3917d0" translate="yes" xml:space="preserve">
          <source>Note that passing out of range parameters is invalid, and will result in unspecified behavior.</source>
          <target state="translated">Note that passing out of range parameters is invalid, and will result in unspecified behavior.</target>
        </trans-unit>
        <trans-unit id="1f31c35203a39590c2e35b09e92f6158f97d1fc9" translate="yes" xml:space="preserve">
          <source>Note that per &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;RFC 6066&lt;/a&gt;, the encoded server name value of a hostname is &lt;a href=&quot;../../../java/nio/charset/standardcharsets#US_ASCII&quot;&gt;&lt;code&gt;StandardCharsets.US_ASCII&lt;/code&gt;&lt;/a&gt;-compliant. In this method, &lt;code&gt;hostname&lt;/code&gt; can be a user-friendly Internationalized Domain Name (IDN). &lt;a href=&quot;../../../java/net/idn#toASCII(java.lang.String,int)&quot;&gt;&lt;code&gt;IDN.toASCII(String, int)&lt;/code&gt;&lt;/a&gt; is used to enforce the restrictions on ASCII characters in hostnames (see &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;, &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt;, &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;) and translate the &lt;code&gt;hostname&lt;/code&gt; into ASCII Compatible Encoding (ACE), as:</source>
          <target state="translated">Note that per &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;RFC 6066&lt;/a&gt;, the encoded server name value of a hostname is &lt;a href=&quot;../../../java/nio/charset/standardcharsets#US_ASCII&quot;&gt; &lt;code&gt;StandardCharsets.US_ASCII&lt;/code&gt; &lt;/a&gt;-compliant. In this method, &lt;code&gt;hostname&lt;/code&gt; can be a user-friendly Internationalized Domain Name (IDN). &lt;a href=&quot;../../../java/net/idn#toASCII(java.lang.String,int)&quot;&gt; &lt;code&gt;IDN.toASCII(String, int)&lt;/code&gt; &lt;/a&gt; is used to enforce the restrictions on ASCII characters in hostnames (see &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;, &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt;, &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;) and translate the &lt;code&gt;hostname&lt;/code&gt; into ASCII Compatible Encoding (ACE), as:</target>
        </trans-unit>
        <trans-unit id="3a6394653c37e537549d2577cb7fa90b35c6e451" translate="yes" xml:space="preserve">
          <source>Note that per &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;RFC 6066&lt;/a&gt;, the encoded server name value of a hostname is &lt;a href=&quot;../../../java/nio/charset/standardcharsets#US_ASCII&quot;&gt;&lt;code&gt;StandardCharsets.US_ASCII&lt;/code&gt;&lt;/a&gt;-compliant. In this method, &lt;code&gt;hostname&lt;/code&gt; can be a user-friendly Internationalized Domain Name (IDN). &lt;a href=&quot;../../../java/net/idn#toASCII-java.lang.String-int-&quot;&gt;&lt;code&gt;IDN.toASCII(String, int)&lt;/code&gt;&lt;/a&gt; is used to enforce the restrictions on ASCII characters in hostnames (see &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt;, &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt;, &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123&lt;/a&gt;) and translate the &lt;code&gt;hostname&lt;/code&gt; into ASCII Compatible Encoding (ACE), as:</source>
          <target state="translated">주 당 것으로 &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;RFC 6066&lt;/a&gt; , 호스트 이름의 인코딩 서버 이름 값은 &lt;a href=&quot;../../../java/nio/charset/standardcharsets#US_ASCII&quot;&gt; &lt;code&gt;StandardCharsets.US_ASCII&lt;/code&gt; 의&lt;/a&gt; 호환은. 이 방법에서 &lt;code&gt;hostname&lt;/code&gt; 은 사용자 친화적 인 국제화 도메인 이름 (IDN) 일 수 있습니다. &lt;a href=&quot;../../../java/net/idn#toASCII-java.lang.String-int-&quot;&gt; &lt;code&gt;IDN.toASCII(String, int)&lt;/code&gt; &lt;/a&gt; 는 호스트 이름의 ASCII 문자에 대한 제한을 적용하고 ( &lt;a href=&quot;http://www.ietf.org/rfc/rfc3490.txt&quot;&gt;RFC 3490&lt;/a&gt; , &lt;a href=&quot;http://www.ietf.org/rfc/rfc1122.txt&quot;&gt;RFC 1122&lt;/a&gt; , &lt;a href=&quot;http://www.ietf.org/rfc/rfc1123.txt&quot;&gt;RFC 1123 참조&lt;/a&gt; ) &lt;code&gt;hostname&lt;/code&gt; 을 ASCII 호환 인코딩 (ACE)으로 변환하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="053d7f649cd8f419cb1e245e690acf560385d7d4" translate="yes" xml:space="preserve">
          <source>Note that physical card readers with slots for multiple cards are represented by one &lt;code&gt;CardTerminal&lt;/code&gt; object per such slot.</source>
          <target state="translated">Note that physical card readers with slots for multiple cards are represented by one &lt;code&gt;CardTerminal&lt;/code&gt; object per such slot.</target>
        </trans-unit>
        <trans-unit id="3f16b837dbf5ab89f85dcecb647b27918e8cf71a" translate="yes" xml:space="preserve">
          <source>Note that privacy can only be applied through the wrap call.</source>
          <target state="translated">Note that privacy can only be applied through the wrap call.</target>
        </trans-unit>
        <trans-unit id="27959893141a0d567fb5c44db662e8371cc70d03" translate="yes" xml:space="preserve">
          <source>Note that programmer written code is also able to take advantage of calling this method in situations where there are multiple sibling exceptions and only one can be propagated.</source>
          <target state="translated">프로그래머가 작성한 코드는 또한 여러 형제 예외가 있고 하나만 전파 될 수있는 상황에서이 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="658d306ee00871ed2db739b911285df59abd60b0" translate="yes" xml:space="preserve">
          <source>Note that result of this method is immediately outdated, there is no guarantee that a subsequent attempt to open the file for writing will succeed (or even that it will access the same file). Care should be taken when using this method in security sensitive applications.</source>
          <target state="translated">이 방법의 결과는 즉시 구식입니다. 파일을 쓰기 위해 이후에 파일을 열려는 시도가 성공하거나 심지어 동일한 파일에 액세스한다고 보장 할 수 없습니다. 보안에 민감한 응용 프로그램에서이 방법을 사용할 때는주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="49ce8687756db21eadb2917f3ddd5371fa1ac976" translate="yes" xml:space="preserve">
          <source>Note that right rotation with a negative distance is equivalent to left rotation: &lt;code&gt;rotateRight(val, -distance) == rotateLeft(val,
 distance)&lt;/code&gt;. Note also that rotation by any multiple of 32 is a no-op, so all but the last five bits of the rotation distance can be ignored, even if the distance is negative: &lt;code&gt;rotateRight(val,
 distance) == rotateRight(val, distance &amp;amp; 0x1F)&lt;/code&gt;.</source>
          <target state="translated">거리가 음수 인 오른쪽 회전은 왼쪽 회전과 같습니다. &lt;code&gt;rotateRight(val, -distance) == rotateLeft(val, distance)&lt;/code&gt; . 32의 배수로 회전하는 것은 작동하지 않으므로 거리가 음수 일지라도 회전 거리의 마지막 5 비트를 제외한 모든 비트는 무시할 수 있습니다. &lt;code&gt;rotateRight(val, distance) == rotateRight(val, distance &amp;amp; 0x1F)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f052c07fd86b9f8f91267b03c38d8d38cff6f45" translate="yes" xml:space="preserve">
          <source>Note that right rotation with a negative distance is equivalent to left rotation: &lt;code&gt;rotateRight(val, -distance) == rotateLeft(val,
 distance)&lt;/code&gt;. Note also that rotation by any multiple of 64 is a no-op, so all but the last six bits of the rotation distance can be ignored, even if the distance is negative: &lt;code&gt;rotateRight(val,
 distance) == rotateRight(val, distance &amp;amp; 0x3F)&lt;/code&gt;.</source>
          <target state="translated">거리가 음수 인 오른쪽 회전은 왼쪽 회전과 같습니다. &lt;code&gt;rotateRight(val, -distance) == rotateLeft(val, distance)&lt;/code&gt; . 또한 64의 배수로 회전하는 것은 작동하지 않으므로 거리가 음수 일지라도 회전 거리의 마지막 6 비트를 제외한 모든 비트는 무시할 수 있습니다. &lt;code&gt;rotateRight(val, distance) == rotateRight(val, distance &amp;amp; 0x3F)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb516b7d8eee3df14676bec660a003dce7df4328" translate="yes" xml:space="preserve">
          <source>Note that sequence number is an unsigned long and cannot exceed &lt;code&gt;-1L&lt;/code&gt;. It is desired to use the unsigned long comparing mode for comparison of unsigned long values (see also &lt;a href=&quot;../../../java/lang/long#compareUnsigned(long,long)&quot;&gt;&lt;code&gt;Long.compareUnsigned()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Note that sequence number is an unsigned long and cannot exceed &lt;code&gt;-1L&lt;/code&gt; . It is desired to use the unsigned long comparing mode for comparison of unsigned long values (see also &lt;a href=&quot;../../../java/lang/long#compareUnsigned(long,long)&quot;&gt; &lt;code&gt;Long.compareUnsigned()&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="629996c0f7127d1270cd5d9d7ebf084cd080f3d9" translate="yes" xml:space="preserve">
          <source>Note that setting the maximum value to &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; will result in the new maximum value being set to &lt;code&gt;Integer.MIN_VALUE + 1&lt;/code&gt;.</source>
          <target state="translated">Note that setting the maximum value to &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt; will result in the new maximum value being set to &lt;code&gt;Integer.MIN_VALUE + 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1344da9466e1cf3b5d4c83444e6b3319fd07bd58" translate="yes" xml:space="preserve">
          <source>Note that setting the minimum value to &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; will result in the new minimum value being set to &lt;code&gt;Integer.MAX_VALUE - 1&lt;/code&gt;.</source>
          <target state="translated">Note that setting the minimum value to &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; will result in the new minimum value being set to &lt;code&gt;Integer.MAX_VALUE - 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ffba4287c4f058227753f4d8b5a7b3fcccb2a3f" translate="yes" xml:space="preserve">
          <source>Note that setting this attribute, when permitted, changes the &lt;code&gt;nodeName&lt;/code&gt; attribute, which holds the qualified name, as well as the &lt;code&gt;tagName&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; attributes of the &lt;code&gt;Element&lt;/code&gt; and &lt;code&gt;Attr&lt;/code&gt; interfaces, when applicable.</source>
          <target state="translated">Note that setting this attribute, when permitted, changes the &lt;code&gt;nodeName&lt;/code&gt; attribute, which holds the qualified name, as well as the &lt;code&gt;tagName&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; attributes of the &lt;code&gt;Element&lt;/code&gt; and &lt;code&gt;Attr&lt;/code&gt; interfaces, when applicable.</target>
        </trans-unit>
        <trans-unit id="45ffc6fbb881829e1ad6ffebfc117ac9cb6c51f7" translate="yes" xml:space="preserve">
          <source>Note that shortcuts created with a keycode or an extended keycode defined as a constant in &lt;code&gt;KeyEvent&lt;/code&gt; work regardless of the current keyboard layout. However, a shortcut made of an extended keycode not listed in &lt;code&gt;KeyEvent&lt;/code&gt; only work if the current keyboard layout produces a corresponding letter.</source>
          <target state="translated">Note that shortcuts created with a keycode or an extended keycode defined as a constant in &lt;code&gt;KeyEvent&lt;/code&gt; work regardless of the current keyboard layout. However, a shortcut made of an extended keycode not listed in &lt;code&gt;KeyEvent&lt;/code&gt; only work if the current keyboard layout produces a corresponding letter.</target>
        </trans-unit>
        <trans-unit id="ede87b1353a7da6b24f9d427496be29bba25a965" translate="yes" xml:space="preserve">
          <source>Note that since &lt;code&gt;BigDecimal&lt;/code&gt; objects are immutable, calls of this method do</source>
          <target state="translated">주 이후 있음을 &lt;code&gt;BigDecimal&lt;/code&gt; 객체는 불변,이 방법으로 호출 할</target>
        </trans-unit>
        <trans-unit id="9f80cc629bbf0cbd7e59b58fc6dd7c9d304af812" translate="yes" xml:space="preserve">
          <source>Note that since BigDecimal objects are immutable, calls of this method do</source>
          <target state="translated">BigDecimal 객체는 변경할 수 없으므로이 메서드를 호출하면</target>
        </trans-unit>
        <trans-unit id="46ea9907be7a1fc93267c92764e045ed963e26e5" translate="yes" xml:space="preserve">
          <source>Note that since information about the runtime representation of a type is being generated, modifiers not present on the originating source code or illegal on the originating source code may be present.</source>
          <target state="translated">유형의 런타임 표현에 대한 정보가 생성되고 있기 때문에 원래 소스 코드에 존재하지 않거나 원래 소스 코드에 잘못된 수정자가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e240f792bd1f1b1a1e8b2c029b16165e0777053a" translate="yes" xml:space="preserve">
          <source>Note that since the Calendar class uses &lt;code&gt;int&lt;/code&gt; to hold the value of year and month, this method may produce an unexpected result if this duration object holds a very large value in the years or months fields.</source>
          <target state="translated">Note that since the Calendar class uses &lt;code&gt;int&lt;/code&gt; to hold the value of year and month, this method may produce an unexpected result if this duration object holds a very large value in the years or months fields.</target>
        </trans-unit>
        <trans-unit id="3e80a4c138028509aeb325edff3e229e11198396" translate="yes" xml:space="preserve">
          <source>Note that since the division is undefined if the resulting alpha is zero, the division in that case is omitted to avoid the &quot;divide by zero&quot; and the color components are left as all zeros.</source>
          <target state="translated">Note that since the division is undefined if the resulting alpha is zero, the division in that case is omitted to avoid the &quot;divide by zero&quot; and the color components are left as all zeros.</target>
        </trans-unit>
        <trans-unit id="b3fb90979366c5fefbd1205a3455819d3d69b58d" translate="yes" xml:space="preserve">
          <source>Note that since the first argument is treated as an unsigned value, no leading sign character is printed.</source>
          <target state="translated">첫 번째 인수는 부호없는 값으로 취급되므로 선행 부호 문자가 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2affb207dff6ee7d6daba1bded38344953ce355" translate="yes" xml:space="preserve">
          <source>Note that since the prefix is only used when standard resolution fails, native methods can be wrapped selectively.</source>
          <target state="translated">접두사는 표준 해상도가 실패 할 때만 사용되므로 기본 메소드를 선택적으로 랩핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="907ba471f23a37b8313b03dc0b56889949dcf8d1" translate="yes" xml:space="preserve">
          <source>Note that since these keys and values are</source>
          <target state="translated">Note that since these keys and values are</target>
        </trans-unit>
        <trans-unit id="b27ed8f2250cedc5cde89da227e91406cd971a09" translate="yes" xml:space="preserve">
          <source>Note that since untrusted code may create loggers with arbitrary names this method should not be relied on to find Loggers for security sensitive logging. It is also important to note that the Logger associated with the String &lt;code&gt;name&lt;/code&gt; may be garbage collected at any time if there is no strong reference to the Logger. The caller of this method must check the return value for null in order to properly handle the case where the Logger has been garbage collected.</source>
          <target state="translated">신뢰할 수없는 코드는 임의의 이름을 가진 로거를 생성 할 수 있으므로 보안에 민감한 로깅을위한 로거를 찾기 위해이 방법을 사용해서는 안됩니다. 또한 로거 에 대한 강력한 참조가 없으면 문자열 &lt;code&gt;name&lt;/code&gt; 과 관련된 로거 가 언제든지 가비지 수집 될 수 있습니다. 이 메소드의 호출자는 로거가 가비지 수집 된 경우를 올바르게 처리하려면 리턴 값이 널인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b893176debeef2a1795c8f8c9947557edc10d8d" translate="yes" xml:space="preserve">
          <source>Note that skipped entities will be reported through the &lt;a href=&quot;../contenthandler#skippedEntity(java.lang.String)&quot;&gt;&lt;code&gt;skippedEntity&lt;/code&gt;&lt;/a&gt; event, which is part of the ContentHandler interface.</source>
          <target state="translated">Note that skipped entities will be reported through the &lt;a href=&quot;../contenthandler#skippedEntity(java.lang.String)&quot;&gt; &lt;code&gt;skippedEntity&lt;/code&gt; &lt;/a&gt; event, which is part of the ContentHandler interface.</target>
        </trans-unit>
        <trans-unit id="4bf429ba70c87d9c5f3d5318272715fb6f04ba94" translate="yes" xml:space="preserve">
          <source>Note that some attributes may be set directly on the PrinterJob by equivalent method calls, (for example), copies: &lt;code&gt;setCopies(int)&lt;/code&gt;, job name: &lt;code&gt;setJobName(String)&lt;/code&gt; and specifying media size and orientation though the &lt;code&gt;PageFormat&lt;/code&gt; object.</source>
          <target state="translated">Note that some attributes may be set directly on the PrinterJob by equivalent method calls, (for example), copies: &lt;code&gt;setCopies(int)&lt;/code&gt; , job name: &lt;code&gt;setJobName(String)&lt;/code&gt; and specifying media size and orientation though the &lt;code&gt;PageFormat&lt;/code&gt; object.</target>
        </trans-unit>
        <trans-unit id="ee41bcf541b5fe036bd5e0c5d5b8f00351410590" translate="yes" xml:space="preserve">
          <source>Note that some devices, once closed, cannot be reopened. Attempts to reopen such a device will always result in a &lt;code&gt;MidiUnavailableException&lt;/code&gt;.</source>
          <target state="translated">Note that some devices, once closed, cannot be reopened. Attempts to reopen such a device will always result in a &lt;code&gt;MidiUnavailableException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2a842cd743848ed24086b097aed577ecb2f89bb" translate="yes" xml:space="preserve">
          <source>Note that some devices, once closed, cannot be reopened. Attempts to reopen such a device will always result in a MidiUnavailableException.</source>
          <target state="translated">한 번 닫은 일부 장치는 다시 열 수 없습니다. 이러한 장치를 다시 열려고하면 항상 MidiUnavailableException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e3f4eaafc012a53481bbf63540d42651fd837c26" translate="yes" xml:space="preserve">
          <source>Note that some doc flavors may not be supported in combination with all attributes. Use &lt;code&gt;getUnsupportedAttributes(..)&lt;/code&gt; to validate specific combinations.</source>
          <target state="translated">일부 doc 플레이버는 모든 속성과 함께 지원되지 않을 수 있습니다. &lt;code&gt;getUnsupportedAttributes(..)&lt;/code&gt; 를 사용 하여 특정 조합의 유효성을 검증하십시오.</target>
        </trans-unit>
        <trans-unit id="b5f1f782f81948948a98fc10e168c4d30914315e" translate="yes" xml:space="preserve">
          <source>Note that some image formats (such as animated GIF) do not specify how many images are present in the stream. Thus determining the number of images will require the entire stream to be scanned and may require memory for buffering. If images are to be processed in order, it may be more efficient to simply call &lt;code&gt;read&lt;/code&gt; with increasing indices until an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; is thrown to indicate that no more images are available. The &lt;code&gt;allowSearch&lt;/code&gt; parameter may be set to &lt;code&gt;false&lt;/code&gt; to indicate that an exhaustive search is not desired; the return value will be &lt;code&gt;-1&lt;/code&gt; to indicate that a search is necessary. If the input has been specified with &lt;code&gt;seekForwardOnly&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, this method throws an &lt;code&gt;IllegalStateException&lt;/code&gt; if &lt;code&gt;allowSearch&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">애니메이션 GIF와 같은 일부 이미지 형식은 스트림에 몇 개의 이미지가 있는지 지정하지 않습니다. 따라서 이미지 수를 결정하려면 전체 스트림을 스캔해야하고 버퍼링을 위해 메모리가 필요할 수 있습니다. 이미지를 순서대로 처리 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 경우 더 이상 사용할 수있는 이미지가 없음을 나타 내기 위해 IndexOutOfBoundsException 이 발생 될 때까지 인덱스를 늘려 &lt;code&gt;read&lt;/code&gt; 를 호출하는 것이 더 효율적일 수 있습니다. &lt;code&gt;allowSearch&lt;/code&gt; 파라미터가 설정 될 수있다 &lt;code&gt;false&lt;/code&gt; 철저한 탐색이 바람직하지 않은 것을 나타내는; 리턴 값은 &lt;code&gt;-1&lt;/code&gt; 이되어 검색이 필요함을 나타냅니다. &lt;code&gt;seekForwardOnly&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되어 입력이 지정된 경우 &lt;code&gt;allowSearch&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우이 메소드는 &lt;code&gt;IllegalStateException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="865695d1dd8e71d33e196ad236035d5b4c691fb1" translate="yes" xml:space="preserve">
          <source>Note that some implementations may function more efficiently if they can maintain control over how the data for an image is stored. For example, optimizations such as caching an image in video memory require that the implementation track all modifications to that data. Other implementations may operate better if they can store the data in locations other than a Java array. To maintain optimum compatibility with various optimizations it is best to avoid constructors and methods which expose the underlying storage as a Java array as noted below in the documentation for those methods.</source>
          <target state="translated">Note that some implementations may function more efficiently if they can maintain control over how the data for an image is stored. For example, optimizations such as caching an image in video memory require that the implementation track all modifications to that data. Other implementations may operate better if they can store the data in locations other than a Java array. To maintain optimum compatibility with various optimizations it is best to avoid constructors and methods which expose the underlying storage as a Java array as noted below in the documentation for those methods.</target>
        </trans-unit>
        <trans-unit id="a530e973686039c3bf1cb0d979c517cd7c9b2fe7" translate="yes" xml:space="preserve">
          <source>Note that some implementations may function more efficiently if they can maintain control over how the data for an image is stored. For example, optimizations such as caching an image in video memory require that the implementation track all modifications to that data. Other implementations may operate better if they can store the data in locations other than a Java array. To maintain optimum compatibility with various optimizations it is best to avoid constructors and methods which expose the underlying storage as a Java array, as noted below in the documentation for those methods.</source>
          <target state="translated">Note that some implementations may function more efficiently if they can maintain control over how the data for an image is stored. For example, optimizations such as caching an image in video memory require that the implementation track all modifications to that data. Other implementations may operate better if they can store the data in locations other than a Java array. To maintain optimum compatibility with various optimizations it is best to avoid constructors and methods which expose the underlying storage as a Java array, as noted below in the documentation for those methods.</target>
        </trans-unit>
        <trans-unit id="c78d0a28ab77e573dc3b66cff673c03ef951b81b" translate="yes" xml:space="preserve">
          <source>Note that some lines, once closed, cannot be reopened. Attempts to reopen such a line will always result in a &lt;code&gt;&lt;a href=&quot;lineunavailableexception&quot;&gt;&lt;code&gt;LineUnavailableException&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">한 번 닫힌 일부 라인은 다시 열 수 없습니다. 이러한 행을 다시 열려면 항상 &lt;code&gt;&lt;a href=&quot;lineunavailableexception&quot;&gt;&lt;code&gt;LineUnavailableException&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4533d4887b736be85ab5aea39d82cfcd61d75987" translate="yes" xml:space="preserve">
          <source>Note that some lines, once closed, cannot be reopened. Attempts to reopen such a line will always result in a &lt;code&gt;LineUnavailableException&lt;/code&gt;.</source>
          <target state="translated">한 번 닫힌 일부 라인은 다시 열 수 없습니다. 이러한 행을 다시 열려면 항상 &lt;code&gt;LineUnavailableException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4a86216860426da9a4e352c5f028305dfc06624a" translate="yes" xml:space="preserve">
          <source>Note that some lines, once closed, cannot be reopened. Attempts to reopen such a line will always result in an &lt;code&gt;LineUnavailableException&lt;/code&gt;.</source>
          <target state="translated">한 번 닫힌 일부 라인은 다시 열 수 없습니다. 이러한 행을 다시 열려면 항상 &lt;code&gt;LineUnavailableException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f2a6579f26b29e3c26de24c155a91cd2053f795f" translate="yes" xml:space="preserve">
          <source>Note that some minor variations in distances may occur due to sampling at the granularity of a pixel. If no cycle method is specified, &lt;code&gt;NO_CYCLE&lt;/code&gt; will be chosen by default, which means the last keyframe color will be used to fill the remaining area.</source>
          <target state="translated">Note that some minor variations in distances may occur due to sampling at the granularity of a pixel. If no cycle method is specified, &lt;code&gt;NO_CYCLE&lt;/code&gt; will be chosen by default, which means the last keyframe color will be used to fill the remaining area.</target>
        </trans-unit>
        <trans-unit id="d75497502ac57e88855c2e4d41743f1515d312d8" translate="yes" xml:space="preserve">
          <source>Note that some of the effect of overwriting a file can be achieved by using a</source>
          <target state="translated">파일 덮어 쓰기의 일부 효과는 다음을 사용하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28fb43a3227044bd4007b3d08b3b0318eb90c4f6" translate="yes" xml:space="preserve">
          <source>Note that some parsers will report whitespace in element content using the &lt;a href=&quot;#ignorableWhitespace(char%5B%5D,int,int)&quot;&gt;&lt;code&gt;ignorableWhitespace&lt;/code&gt;&lt;/a&gt; method rather than this one (validating parsers &lt;em&gt;must&lt;/em&gt; do so).</source>
          <target state="translated">Note that some parsers will report whitespace in element content using the &lt;a href=&quot;#ignorableWhitespace(char%5B%5D,int,int)&quot;&gt; &lt;code&gt;ignorableWhitespace&lt;/code&gt; &lt;/a&gt; method rather than this one (validating parsers &lt;em&gt;must&lt;/em&gt; do so).</target>
        </trans-unit>
        <trans-unit id="bf0738e26bf4ef13426b4d5b1f2c28d218427c15" translate="yes" xml:space="preserve">
          <source>Note that some parsers will report whitespace using the ignorableWhitespace() method rather than this one (validating parsers must do so).</source>
          <target state="translated">Note that some parsers will report whitespace using the ignorableWhitespace() method rather than this one (validating parsers must do so).</target>
        </trans-unit>
        <trans-unit id="c485dfc4a00cf4e59758fbbdafffb9b469db558a" translate="yes" xml:space="preserve">
          <source>Note that some patterns, for example &lt;code&gt;a*&lt;/code&gt;, match the empty string. This method will return the empty string when the pattern successfully matches the empty string in the input.</source>
          <target state="translated">&lt;code&gt;a*&lt;/code&gt; 와 같은 일부 패턴 은 빈 문자열과 일치합니다. 이 메소드는 패턴이 입력의 빈 문자열과 성공적으로 일치하면 빈 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4f431a982225fc72b2d6e9e2277e1fedbdc6e9d8" translate="yes" xml:space="preserve">
          <source>Note that some platforms require special privileges or extensions to access low-level input control. If the current platform configuration does not allow input control, an &lt;code&gt;AWTException&lt;/code&gt; will be thrown when trying to construct Robot objects. For example, X-Window systems will throw the exception if the XTEST 2.2 standard extension is not supported (or not enabled) by the X server.</source>
          <target state="translated">Note that some platforms require special privileges or extensions to access low-level input control. If the current platform configuration does not allow input control, an &lt;code&gt;AWTException&lt;/code&gt; will be thrown when trying to construct Robot objects. For example, X-Window systems will throw the exception if the XTEST 2.2 standard extension is not supported (or not enabled) by the X server.</target>
        </trans-unit>
        <trans-unit id="0eab954b7fc780ccee32d71949f0e59cae06718c" translate="yes" xml:space="preserve">
          <source>Note that some recent W3C specifications require that text in some encodings be normalized, using Unicode Normalization Form C, before processing. Such normalization must be performed by applications, and would normally be triggered based on the value returned by this method.</source>
          <target state="translated">Note that some recent W3C specifications require that text in some encodings be normalized, using Unicode Normalization Form C, before processing. Such normalization must be performed by applications, and would normally be triggered based on the value returned by this method.</target>
        </trans-unit>
        <trans-unit id="6838c3b88eeb6c3bcec8ec40c940ab261f201f67" translate="yes" xml:space="preserve">
          <source>Note that some subclasses may not have a &lt;code&gt;type&lt;/code&gt; attribute and for objects of those types, the &lt;a href=&quot;#getType()&quot;&gt;&lt;code&gt;getType()&lt;/code&gt;&lt;/a&gt; method always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Note that some subclasses may not have a &lt;code&gt;type&lt;/code&gt; attribute and for objects of those types, the &lt;a href=&quot;#getType()&quot;&gt; &lt;code&gt;getType()&lt;/code&gt; &lt;/a&gt; method always returns &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32566c3e724df2b1cc25ad0b22e1482b38513e3a" translate="yes" xml:space="preserve">
          <source>Note that sometimes this &lt;code&gt;AffineTransform&lt;/code&gt; is identity, such as for printers or metafile output, and that this &lt;code&gt;AffineTransform&lt;/code&gt; is only as accurate as the information supplied by the underlying system. For image buffers not associated with a device, such as those not created by &lt;code&gt;createCompatibleImage&lt;/code&gt;, this &lt;code&gt;AffineTransform&lt;/code&gt; is the Identity transform since there is no valid distance measurement.</source>
          <target state="translated">Note that sometimes this &lt;code&gt;AffineTransform&lt;/code&gt; is identity, such as for printers or metafile output, and that this &lt;code&gt;AffineTransform&lt;/code&gt; is only as accurate as the information supplied by the underlying system. For image buffers not associated with a device, such as those not created by &lt;code&gt;createCompatibleImage&lt;/code&gt; , this &lt;code&gt;AffineTransform&lt;/code&gt; is the Identity transform since there is no valid distance measurement.</target>
        </trans-unit>
        <trans-unit id="976b26e68d21240dd452dcb04c993672bd3eddf8" translate="yes" xml:space="preserve">
          <source>Note that start/endPrefixMapping events are not guaranteed to be properly nested relative to each other: all startPrefixMapping events will occur immediately before the corresponding &lt;a href=&quot;#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)&quot;&gt;&lt;code&gt;startElement&lt;/code&gt;&lt;/a&gt; event, and all &lt;a href=&quot;#endPrefixMapping(java.lang.String)&quot;&gt;&lt;code&gt;endPrefixMapping&lt;/code&gt;&lt;/a&gt; events will occur immediately after the corresponding &lt;a href=&quot;#endElement(java.lang.String,java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;endElement&lt;/code&gt;&lt;/a&gt; event, but their order is not otherwise guaranteed.</source>
          <target state="translated">Note that start/endPrefixMapping events are not guaranteed to be properly nested relative to each other: all startPrefixMapping events will occur immediately before the corresponding &lt;a href=&quot;#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)&quot;&gt; &lt;code&gt;startElement&lt;/code&gt; &lt;/a&gt; event, and all &lt;a href=&quot;#endPrefixMapping(java.lang.String)&quot;&gt; &lt;code&gt;endPrefixMapping&lt;/code&gt; &lt;/a&gt; events will occur immediately after the corresponding &lt;a href=&quot;#endElement(java.lang.String,java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;endElement&lt;/code&gt; &lt;/a&gt; event, but their order is not otherwise guaranteed.</target>
        </trans-unit>
        <trans-unit id="2cb685fae358dd9b061ba139a3bdb43001e462da" translate="yes" xml:space="preserve">
          <source>Note that supporting a given concept is a platform- dependent feature. Due to native limitations the Toolkit object may report a particular state as supported, however at the same time the Toolkit object will be unable to apply the state to a given frame. This circumstance has two following consequences:</source>
          <target state="translated">Note that supporting a given concept is a platform- dependent feature. Due to native limitations the Toolkit object may report a particular state as supported, however at the same time the Toolkit object will be unable to apply the state to a given frame. This circumstance has two following consequences:</target>
        </trans-unit>
        <trans-unit id="2e3465c3d7cbfa831d9cce56582cb00fecdc72ad" translate="yes" xml:space="preserve">
          <source>Note that text is not a bound property, so no &lt;code&gt;PropertyChangeEvent
 &lt;/code&gt; is fired when it changes. To listen for changes to the text, use &lt;code&gt;DocumentListener&lt;/code&gt;.</source>
          <target state="translated">Note that text is not a bound property, so no &lt;code&gt;PropertyChangeEvent &lt;/code&gt; is fired when it changes. To listen for changes to the text, use &lt;code&gt;DocumentListener&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ea24d264d2009f98a0518af8b7b24137391614c" translate="yes" xml:space="preserve">
          <source>Note that the &quot;... n more&quot; notation is used on suppressed exceptions just at it is used on causes. Unlike causes, suppressed exceptions are indented beyond their &quot;containing exceptions.&quot;</source>
          <target state="translated">&quot;... n more&quot;표기법은 원인에 사용될 때 억제 된 예외에 사용됩니다. 원인과 달리 억제 된 예외는 &quot;예외 포함&quot;이상으로 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="e6efbe4260c1559a0e7528b69d6ffc1bb70c3244" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#peek()&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; method works equally well when a deque is used as a queue or a stack; in either case, elements are drawn from the beginning of the deque.</source>
          <target state="translated">Note that the &lt;a href=&quot;#peek()&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt; method works equally well when a deque is used as a queue or a stack; in either case, elements are drawn from the beginning of the deque.</target>
        </trans-unit>
        <trans-unit id="e3edf91dbdf2f16062f3624914a282815a27b866" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#remove()&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#set(E)&quot;&gt;&lt;code&gt;set(Object)&lt;/code&gt;&lt;/a&gt; methods are</source>
          <target state="translated">Note that the &lt;a href=&quot;#remove()&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;#set(E)&quot;&gt; &lt;code&gt;set(Object)&lt;/code&gt; &lt;/a&gt; methods are</target>
        </trans-unit>
        <trans-unit id="19a4e2d4390ad60c093e79f5605378ef8b572c2a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../nio/file/files&quot;&gt;&lt;code&gt;Files&lt;/code&gt;&lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/files#delete(java.nio.file.Path)&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; method to throw an &lt;a href=&quot;ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; when a file cannot be deleted. This is useful for error reporting and to diagnose why a file cannot be deleted.</source>
          <target state="translated">Note that the &lt;a href=&quot;../nio/file/files&quot;&gt; &lt;code&gt;Files&lt;/code&gt; &lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/files#delete(java.nio.file.Path)&quot;&gt; &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt; method to throw an &lt;a href=&quot;ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; &lt;/a&gt; when a file cannot be deleted. This is useful for error reporting and to diagnose why a file cannot be deleted.</target>
        </trans-unit>
        <trans-unit id="34a8bbe15d24a86a2e622539fa27f78132a1836d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../nio/file/files&quot;&gt;&lt;code&gt;Files&lt;/code&gt;&lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/files#delete-java.nio.file.Path-&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; method to throw an &lt;a href=&quot;ioexception&quot;&gt;&lt;code&gt;IOException&lt;/code&gt;&lt;/a&gt; when a file cannot be deleted. This is useful for error reporting and to diagnose why a file cannot be deleted.</source>
          <target state="translated">있습니다 &lt;a href=&quot;../nio/file/files&quot;&gt; &lt;code&gt;Files&lt;/code&gt; &lt;/a&gt; 클래스는 정의 &lt;a href=&quot;../nio/file/files#delete-java.nio.file.Path-&quot;&gt; &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt; 던지는 방법 &lt;a href=&quot;ioexception&quot;&gt; &lt;code&gt;IOException&lt;/code&gt; 가&lt;/a&gt; 파일을 삭제할 수 없습니다 때를. 이는 오류보고 및 파일을 삭제할 수없는 이유를 진단하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e9c31a917c9d7564af821e975e655fa709c72534" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../nio/file/files&quot;&gt;&lt;code&gt;Files&lt;/code&gt;&lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/files#move(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)&quot;&gt;&lt;code&gt;move&lt;/code&gt;&lt;/a&gt; method to move or rename a file in a platform independent manner.</source>
          <target state="translated">Note that the &lt;a href=&quot;../nio/file/files&quot;&gt; &lt;code&gt;Files&lt;/code&gt; &lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/files#move(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)&quot;&gt; &lt;code&gt;move&lt;/code&gt; &lt;/a&gt; method to move or rename a file in a platform independent manner.</target>
        </trans-unit>
        <trans-unit id="6db4292cd540b40b6745f83a2b2f178c9b829375" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../nio/file/files&quot;&gt;&lt;code&gt;Files&lt;/code&gt;&lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/files#move-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-&quot;&gt;&lt;code&gt;move&lt;/code&gt;&lt;/a&gt; method to move or rename a file in a platform independent manner.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;../nio/file/files&quot;&gt; &lt;code&gt;Files&lt;/code&gt; &lt;/a&gt; 클래스는 정의 &lt;a href=&quot;../nio/file/files#move-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-&quot;&gt; &lt;code&gt;move&lt;/code&gt; &lt;/a&gt; 이동하거나 플랫폼에 독립적 인 방식으로 파일의 이름을 변경하는 방법을.</target>
        </trans-unit>
        <trans-unit id="8fe520767419d55a02f8d111e380de652ac28988" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../nio/file/files&quot;&gt;&lt;code&gt;Files&lt;/code&gt;&lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/files#newDirectoryStream(java.nio.file.Path)&quot;&gt;&lt;code&gt;newDirectoryStream&lt;/code&gt;&lt;/a&gt; method to open a directory and iterate over the names of the files in the directory. This may use less resources when working with very large directories, and may be more responsive when working with remote directories.</source>
          <target state="translated">Note that the &lt;a href=&quot;../nio/file/files&quot;&gt; &lt;code&gt;Files&lt;/code&gt; &lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/files#newDirectoryStream(java.nio.file.Path)&quot;&gt; &lt;code&gt;newDirectoryStream&lt;/code&gt; &lt;/a&gt; method to open a directory and iterate over the names of the files in the directory. This may use less resources when working with very large directories, and may be more responsive when working with remote directories.</target>
        </trans-unit>
        <trans-unit id="3d71d4c365eb91c7625b97355ba9210228308a25" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../nio/file/files&quot;&gt;&lt;code&gt;Files&lt;/code&gt;&lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/files#newDirectoryStream(java.nio.file.Path)&quot;&gt;&lt;code&gt;newDirectoryStream&lt;/code&gt;&lt;/a&gt; method to open a directory and iterate over the names of the files in the directory. This may use less resources when working with very large directories.</source>
          <target state="translated">Note that the &lt;a href=&quot;../nio/file/files&quot;&gt; &lt;code&gt;Files&lt;/code&gt; &lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/files#newDirectoryStream(java.nio.file.Path)&quot;&gt; &lt;code&gt;newDirectoryStream&lt;/code&gt; &lt;/a&gt; method to open a directory and iterate over the names of the files in the directory. This may use less resources when working with very large directories.</target>
        </trans-unit>
        <trans-unit id="38f521314da41a4582840b74bc65ac7e600e3be0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../nio/file/files&quot;&gt;&lt;code&gt;Files&lt;/code&gt;&lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/files#newDirectoryStream-java.nio.file.Path-&quot;&gt;&lt;code&gt;newDirectoryStream&lt;/code&gt;&lt;/a&gt; method to open a directory and iterate over the names of the files in the directory. This may use less resources when working with very large directories, and may be more responsive when working with remote directories.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;../nio/file/files&quot;&gt; &lt;code&gt;Files&lt;/code&gt; &lt;/a&gt; 클래스는 정의 &lt;a href=&quot;../nio/file/files#newDirectoryStream-java.nio.file.Path-&quot;&gt; &lt;code&gt;newDirectoryStream&lt;/code&gt; 의&lt;/a&gt; 디렉토리에있는 파일의 이름을 통해 디렉토리 및 반복 처리를 엽니 방법. 이것은 매우 큰 디렉토리로 작업 할 때 더 적은 자원을 사용할 수 있으며 원격 디렉토리로 작업 할 때 더 반응이 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="39a341f6e18ba122b4e59b6da0da8d7d2db499a5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../nio/file/files&quot;&gt;&lt;code&gt;Files&lt;/code&gt;&lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/files#newDirectoryStream-java.nio.file.Path-&quot;&gt;&lt;code&gt;newDirectoryStream&lt;/code&gt;&lt;/a&gt; method to open a directory and iterate over the names of the files in the directory. This may use less resources when working with very large directories.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;../nio/file/files&quot;&gt; &lt;code&gt;Files&lt;/code&gt; &lt;/a&gt; 클래스는 정의 &lt;a href=&quot;../nio/file/files#newDirectoryStream-java.nio.file.Path-&quot;&gt; &lt;code&gt;newDirectoryStream&lt;/code&gt; 의&lt;/a&gt; 디렉토리에있는 파일의 이름을 통해 디렉토리 및 반복 처리를 엽니 방법. 매우 큰 디렉토리로 작업 할 때 더 적은 리소스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27087e882f58a5e15e9125a78d8f0a3b9a3cc6f4" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../shape#def_insideness&quot;&gt; definition of insideness&lt;/a&gt; can lead to situations where points on the defining outline of the &lt;code&gt;shape&lt;/code&gt; may not be considered contained in the returned &lt;code&gt;bounds&lt;/code&gt; object, but only in cases where those points are also not considered contained in the original &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">Note that the &lt;a href=&quot;../shape#def_insideness&quot;&gt; definition of insideness&lt;/a&gt; can lead to situations where points on the defining outline of the &lt;code&gt;shape&lt;/code&gt; may not be considered contained in the returned &lt;code&gt;bounds&lt;/code&gt; object, but only in cases where those points are also not considered contained in the original &lt;code&gt;shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c36f673075fbd855a8b32b8a5e09ee855f13576" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;deque#peek--&quot;&gt;&lt;code&gt;peek&lt;/code&gt;&lt;/a&gt; method works equally well when a deque is used as a queue or a stack; in either case, elements are drawn from the beginning of the deque.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;deque#peek--&quot;&gt; &lt;code&gt;peek&lt;/code&gt; &lt;/a&gt; 방법 똑같이 잘 양단이 큐 또는 적층으로 사용될 때 작동; 두 경우 모두 요소는 deque의 시작 부분에서 그려집니다.</target>
        </trans-unit>
        <trans-unit id="aa8e0fa4ccac519769dcd246d9e27f7bfa942af3" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;listiterator#remove--&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;listiterator#set-E-&quot;&gt;&lt;code&gt;set(Object)&lt;/code&gt;&lt;/a&gt; methods are</source>
          <target state="translated">점을 유의 &lt;a href=&quot;listiterator#remove--&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;listiterator#set-E-&quot;&gt; &lt;code&gt;set(Object)&lt;/code&gt; &lt;/a&gt; 방법은</target>
        </trans-unit>
        <trans-unit id="20a97b61e51049ba047964839d1bd03301972ade" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;shape#def_insideness&quot;&gt; definition of insideness&lt;/a&gt; can lead to situations where points on the defining outline of the &lt;code&gt;shape&lt;/code&gt; may not be considered contained in the returned &lt;code&gt;bounds&lt;/code&gt; object, but only in cases where those points are also not considered contained in the original &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">Note that the &lt;a href=&quot;shape#def_insideness&quot;&gt; definition of insideness&lt;/a&gt; can lead to situations where points on the defining outline of the &lt;code&gt;shape&lt;/code&gt; may not be considered contained in the returned &lt;code&gt;bounds&lt;/code&gt; object, but only in cases where those points are also not considered contained in the original &lt;code&gt;shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="991b6fac869e71fa9b427db3579f4fa43b3879e6" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;AccessibleRole&lt;/code&gt; class is also extensible, so custom component developers can define their own &lt;code&gt;AccessibleRole&lt;/code&gt;'s if the set of predefined roles is inadequate.</source>
          <target state="translated">Note that the &lt;code&gt;AccessibleRole&lt;/code&gt; class is also extensible, so custom component developers can define their own &lt;code&gt;AccessibleRole&lt;/code&gt; 's if the set of predefined roles is inadequate.</target>
        </trans-unit>
        <trans-unit id="988280b60a9995bf010788246fd4d02592e34922" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;CertSelector&lt;/code&gt; returned is cloned to protect against subsequent modifications.</source>
          <target state="translated">점을 유의 &lt;code&gt;CertSelector&lt;/code&gt; 이후의 변경으로부터 보호하기 위해서 복제되어 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="e0a5fe5d70f7e3a3a322d4355524c0333b97592e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;CertSelector&lt;/code&gt; specified is cloned to protect against subsequent modifications.</source>
          <target state="translated">주의 &lt;code&gt;CertSelector&lt;/code&gt; 지정된 이후의 변경으로부터 보호하기 위해서 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="6938d302e9a62e94240ab0a6e295eb1f73bdbab4" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;CertStore.getInstance&lt;/code&gt; methods make a copy of the specified &lt;code&gt;CertStoreParameters&lt;/code&gt;. A deep copy implementation of &lt;code&gt;clone&lt;/code&gt; is safer and more robust, as it prevents the caller from corrupting a shared &lt;code&gt;CertStore&lt;/code&gt; by subsequently modifying the contents of its initialization parameters. However, a shallow copy implementation of &lt;code&gt;clone&lt;/code&gt; is more appropriate for applications that need to hold a reference to a parameter contained in the &lt;code&gt;CertStoreParameters&lt;/code&gt;. For example, a shallow copy clone allows an application to release the resources of a particular &lt;code&gt;CertStore&lt;/code&gt; initialization parameter immediately, rather than waiting for the garbage collection mechanism. This should be done with the utmost care, since the &lt;code&gt;CertStore&lt;/code&gt; may still be in use by other threads.</source>
          <target state="translated">있습니다 &lt;code&gt;CertStore.getInstance&lt;/code&gt; 의 방법은 지정된의 복사본을 만들 &lt;code&gt;CertStoreParameters&lt;/code&gt; 라고를 . &lt;code&gt;clone&lt;/code&gt; 의 딥 카피 구현은 호출자 가 초기화 매개 변수의 내용을 수정하여 공유 &lt;code&gt;CertStore&lt;/code&gt; 를 손상시키지 못하도록보다 안전하고 강력 합니다. 그러나 &lt;code&gt;CertStoreParameters&lt;/code&gt; 에 포함 된 매개 변수에 대한 참조를 보유해야하는 애플리케이션 에는 &lt;code&gt;clone&lt;/code&gt; 의 단순 사본 구현 이 더 적합합니다 . 예를 들어, 얕은 사본 복제본을 사용하면 응용 프로그램이 특정 &lt;code&gt;CertStore&lt;/code&gt; 의 자원을 해제 할 수 있습니다가비지 콜렉션 메커니즘을 기다리지 않고 즉시 초기화 매개 변수. &lt;code&gt;CertStore&lt;/code&gt; 는 여전히 다른 스레드에서 사용 중일 수 있으므로 최대한주의를 기울여야 합니다.</target>
        </trans-unit>
        <trans-unit id="e740657b93d5694f7439e9ca2e8c1172e00478ae" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Collection&lt;/code&gt; returned may contain more than one name of the same type. Also, note that the returned &lt;code&gt;Collection&lt;/code&gt; is immutable and any entries containing byte arrays are cloned to protect against subsequent modifications.</source>
          <target state="translated">반환 된 &lt;code&gt;Collection&lt;/code&gt; 은 같은 유형의 이름을 두 개 이상 포함 할 수 있습니다. 또한 반환 된 &lt;code&gt;Collection&lt;/code&gt; 은 변경할 수 없으며 바이트 배열을 포함하는 모든 항목이 복제되어 후속 수정으로부터 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="7de40aed3c95c99dad627f4045f1deea9418d7cd" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Date&lt;/code&gt; returned is cloned to protect against subsequent modifications.</source>
          <target state="translated">점을 유의 &lt;code&gt;Date&lt;/code&gt; 반환 이후의 변경으로부터 보호하기 위해서 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="9b5f5bbd270dce2b0f4bfc5466e8309055235ad3" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Date&lt;/code&gt; returned is copied to protect against subsequent modifications.</source>
          <target state="translated">점을 유의 &lt;code&gt;Date&lt;/code&gt; 반환 이후의 변경으로부터 보호하기 위해서 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="756c1ee00a664d513b2780d37cb85b56ab66facd" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Date&lt;/code&gt; supplied here is cloned to protect against subsequent modifications.</source>
          <target state="translated">점을 유의 &lt;code&gt;Date&lt;/code&gt; 여기에 제공된 이후의 변경으로부터 보호하기 위해서 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="7142600977b8c132471aedf48221b5e358b67466" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Date&lt;/code&gt; supplied here is copied to protect against subsequent modifications.</source>
          <target state="translated">점을 유의 &lt;code&gt;Date&lt;/code&gt; 여기에 제공된 이후의 변경으로부터 보호하기 위해서 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="0f4df85403b87e28e6aaf9e3605181e8cefc47d1" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;DragSourceContext&lt;/code&gt; itself implements the &lt;code&gt;DragSourceListener&lt;/code&gt; and &lt;code&gt;DragSourceMotionListener&lt;/code&gt; interfaces. This is to allow the platform peer (the &lt;code&gt;DragSourceContextPeer&lt;/code&gt; instance) created by the &lt;a href=&quot;dragsource&quot;&gt;&lt;code&gt;DragSource&lt;/code&gt;&lt;/a&gt; to notify the &lt;code&gt;DragSourceContext&lt;/code&gt; of state changes in the ongoing operation. This allows the &lt;code&gt;DragSourceContext&lt;/code&gt; object to interpose itself between the platform and the listeners provided by the initiator of the drag operation.</source>
          <target state="translated">Note that the &lt;code&gt;DragSourceContext&lt;/code&gt; itself implements the &lt;code&gt;DragSourceListener&lt;/code&gt; and &lt;code&gt;DragSourceMotionListener&lt;/code&gt; interfaces. This is to allow the platform peer (the &lt;code&gt;DragSourceContextPeer&lt;/code&gt; instance) created by the &lt;a href=&quot;dragsource&quot;&gt; &lt;code&gt;DragSource&lt;/code&gt; &lt;/a&gt; to notify the &lt;code&gt;DragSourceContext&lt;/code&gt; of state changes in the ongoing operation. This allows the &lt;code&gt;DragSourceContext&lt;/code&gt; object to interpose itself between the platform and the listeners provided by the initiator of the drag operation.</target>
        </trans-unit>
        <trans-unit id="687a40347734d2bb22d765a5ed8d1992b4e155c5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;InputEvent.ALT_MASK&lt;/code&gt; and &lt;code&gt;InputEvent.BUTTON2_MASK&lt;/code&gt; have equal values, so the &quot;Alt&quot; string is returned for both modifiers. Likewise, the &lt;code&gt;InputEvent.META_MASK&lt;/code&gt; and &lt;code&gt;InputEvent.BUTTON3_MASK&lt;/code&gt; have equal values, so the &quot;Meta&quot; string is returned for both modifiers.</source>
          <target state="translated">Note that the &lt;code&gt;InputEvent.ALT_MASK&lt;/code&gt; and &lt;code&gt;InputEvent.BUTTON2_MASK&lt;/code&gt; have equal values, so the &quot;Alt&quot; string is returned for both modifiers. Likewise, the &lt;code&gt;InputEvent.META_MASK&lt;/code&gt; and &lt;code&gt;InputEvent.BUTTON3_MASK&lt;/code&gt; have equal values, so the &quot;Meta&quot; string is returned for both modifiers.</target>
        </trans-unit>
        <trans-unit id="24ce15afd7e02392b41ed1c9692fd88b772af77e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;List&lt;/code&gt; is copied to protect against subsequent modifications.</source>
          <target state="translated">합니다 &lt;code&gt;List&lt;/code&gt; 이후의 변경으로부터 보호하기 위해서 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="1c16ce2f70e6154517db9ecc56262ca103e696ba" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;List&lt;/code&gt; supplied here is copied and each &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; in the list is cloned to protect against subsequent modifications.</source>
          <target state="translated">참고 것을 &lt;code&gt;List&lt;/code&gt; 복사되고 각 여기서 제공 &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 의 목록에서 이후의 변경으로부터 보호하기 위해서 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="7ee01b4b23f75a243dec18f025f614495d62b3b3" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; is cloned to protect against subsequent modifications.</source>
          <target state="translated">있습니다 &lt;code&gt;PKIXCertPathChecker&lt;/code&gt; 가가 이후의 변경으로부터 보호하기 위해서 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="b602381aafbbaaafbf002fc029131252825c1179" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Set&lt;/code&gt; is cloned to protect against subsequent modifications.</source>
          <target state="translated">점을 유의 &lt;code&gt;Set&lt;/code&gt; 이후의 변경으로부터 보호하기 위해서 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="bfc0d202956cd45c30f4cbb883974be9fbfaffb6" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Set&lt;/code&gt; is copied to protect against subsequent modifications.</source>
          <target state="translated">점을 유의 &lt;code&gt;Set&lt;/code&gt; 이후의 변경으로부터 보호하기 위해서 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="14c25e75dc5956b5c15c3185a91822f794243c22" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;checkPermission&lt;/code&gt; method with just a single permission argument always performs security checks within the context of the currently executing thread. Sometimes a security check that should be made within a given context will actually need to be done from within a</source>
          <target state="translated">참고는 것을 &lt;code&gt;checkPermission&lt;/code&gt; 단 하나의 권한 인수 방법은 항상 현재 실행중인 스레드의 컨텍스트 내에서 보안 검사를 수행합니다. 때때로 주어진 맥락 내에서 이루어져야하는 보안 점검은 실제로</target>
        </trans-unit>
        <trans-unit id="d465d184a0a220937c7f4b0c463b0c1f3e4251fd" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;encoded&lt;/code&gt; byte array is cloned to protect against subsequent modification.</source>
          <target state="translated">점을 유의 &lt;code&gt;encoded&lt;/code&gt; 바이트 어레이는 후속의 변경을 방지하도록 복제된다.</target>
        </trans-unit>
        <trans-unit id="7eae258fdea7d49cd9e60454fc50d715893b28a8" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;getName&lt;/code&gt; method for an &lt;code&gt;UnresolvedPermission&lt;/code&gt; returns the &lt;code&gt;type&lt;/code&gt; (class name) for the underlying permission that has not been resolved.</source>
          <target state="translated">&lt;code&gt;UnresolvedPermission&lt;/code&gt; 의 &lt;code&gt;getName&lt;/code&gt; 메소드는 해결되지 않은 기본 권한 의 &lt;code&gt;type&lt;/code&gt; (클래스 이름)을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="146132f5e8a49b60e391eb6983257148a8a7fa71" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;getSubjectX500Principal&lt;/code&gt; and &lt;code&gt;getIssuerX500Principal&lt;/code&gt; methods of &lt;code&gt;X509Certificate&lt;/code&gt; return X500Principals representing the issuer and subject fields of the certificate.</source>
          <target state="translated">&lt;code&gt;X509Certificate&lt;/code&gt; 의 &lt;code&gt;getSubjectX500Principal&lt;/code&gt; 및 &lt;code&gt;getIssuerX500Principal&lt;/code&gt; 메소드 는 인증서의 발행자 및 주제 필드를 나타내는 X500Principals를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a10930bdbea930ae33d125a9efd9b3ffc1189c20" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;matchers&lt;/code&gt; collection is cloned to protect against subsequent modification.</source>
          <target state="translated">있습니다 &lt;code&gt;matchers&lt;/code&gt; 컬렉션 이후의 변경으로부터 보호하기 위해 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="39b07685c295c896af82ad752b60da85dafcf372" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;names&lt;/code&gt; parameter can contain duplicate distinguished names, but they may be removed from the &lt;code&gt;Collection&lt;/code&gt; of names returned by the &lt;a href=&quot;#getIssuerNames()&quot;&gt;&lt;code&gt;getIssuerNames&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Note that the &lt;code&gt;names&lt;/code&gt; parameter can contain duplicate distinguished names, but they may be removed from the &lt;code&gt;Collection&lt;/code&gt; of names returned by the &lt;a href=&quot;#getIssuerNames()&quot;&gt; &lt;code&gt;getIssuerNames&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="aba0bf08ad49fd21d205f268291460e6faaec6dc" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;names&lt;/code&gt; parameter can contain duplicate distinguished names, but they may be removed from the &lt;code&gt;Collection&lt;/code&gt; of names returned by the &lt;a href=&quot;#getIssuers()&quot;&gt;&lt;code&gt;getIssuers&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Note that the &lt;code&gt;names&lt;/code&gt; parameter can contain duplicate distinguished names, but they may be removed from the &lt;code&gt;Collection&lt;/code&gt; of names returned by the &lt;a href=&quot;#getIssuers()&quot;&gt; &lt;code&gt;getIssuers&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="853e395d16304dc7d59e521564cfcbdf1fe1d9b4" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;names&lt;/code&gt; parameter can contain duplicate distinguished names, but they may be removed from the &lt;code&gt;Collection&lt;/code&gt; of names returned by the &lt;a href=&quot;x509crlselector#getIssuerNames--&quot;&gt;&lt;code&gt;getIssuerNames&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">주의 &lt;code&gt;names&lt;/code&gt; 매개 변수가 중복 된 고유 이름을 포함 할 수 있지만이에서 제거 될 수 있습니다 &lt;code&gt;Collection&lt;/code&gt; 에 의해 반환 된 이름의 &lt;a href=&quot;x509crlselector#getIssuerNames--&quot;&gt; &lt;code&gt;getIssuerNames&lt;/code&gt; 의&lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="62d07c17e7376f897ae6e5662db428da35939cda" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;names&lt;/code&gt; parameter can contain duplicate distinguished names, but they may be removed from the &lt;code&gt;Collection&lt;/code&gt; of names returned by the &lt;a href=&quot;x509crlselector#getIssuers--&quot;&gt;&lt;code&gt;getIssuers&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">주의 &lt;code&gt;names&lt;/code&gt; 매개 변수가 중복 된 고유 이름을 포함 할 수 있지만이에서 제거 될 수 있습니다 &lt;code&gt;Collection&lt;/code&gt; 에 의해 반환 된 이름의 &lt;a href=&quot;x509crlselector#getIssuers--&quot;&gt; &lt;code&gt;getIssuers&lt;/code&gt; 의&lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="13ef70dac2da666b040fbff34e7767e491843b4c" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;names&lt;/code&gt; parameter can contain duplicate names (same name and name type), but they may be removed from the &lt;code&gt;Collection&lt;/code&gt; of names returned by the &lt;a href=&quot;#getPathToNames()&quot;&gt;&lt;code&gt;getPathToNames&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Note that the &lt;code&gt;names&lt;/code&gt; parameter can contain duplicate names (same name and name type), but they may be removed from the &lt;code&gt;Collection&lt;/code&gt; of names returned by the &lt;a href=&quot;#getPathToNames()&quot;&gt; &lt;code&gt;getPathToNames&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="bd8079ea1525eea916ad6dd7786f08ee373f4961" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;names&lt;/code&gt; parameter can contain duplicate names (same name and name type), but they may be removed from the &lt;code&gt;Collection&lt;/code&gt; of names returned by the &lt;a href=&quot;#getSubjectAlternativeNames()&quot;&gt;&lt;code&gt;getSubjectAlternativeNames&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">Note that the &lt;code&gt;names&lt;/code&gt; parameter can contain duplicate names (same name and name type), but they may be removed from the &lt;code&gt;Collection&lt;/code&gt; of names returned by the &lt;a href=&quot;#getSubjectAlternativeNames()&quot;&gt; &lt;code&gt;getSubjectAlternativeNames&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="c9f4d19ea1348edcedbc943a51ba8eeea9d518fb" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;names&lt;/code&gt; parameter can contain duplicate names (same name and name type), but they may be removed from the &lt;code&gt;Collection&lt;/code&gt; of names returned by the &lt;a href=&quot;x509certselector#getPathToNames--&quot;&gt;&lt;code&gt;getPathToNames&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">주의 &lt;code&gt;names&lt;/code&gt; 매개 변수가 중복 된 이름 (같은 이름과 이름 타입)을 포함 할 수 있지만이에서 제거 될 수 있습니다 &lt;code&gt;Collection&lt;/code&gt; 에 의해 반환 된 이름의 &lt;a href=&quot;x509certselector#getPathToNames--&quot;&gt; &lt;code&gt;getPathToNames&lt;/code&gt; 의&lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="6e54c0ff1cfb2d8ca5a1acdffc8213c5e0f8728b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;names&lt;/code&gt; parameter can contain duplicate names (same name and name type), but they may be removed from the &lt;code&gt;Collection&lt;/code&gt; of names returned by the &lt;a href=&quot;x509certselector#getSubjectAlternativeNames--&quot;&gt;&lt;code&gt;getSubjectAlternativeNames&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">주의 &lt;code&gt;names&lt;/code&gt; 매개 변수가 중복 된 이름 (같은 이름과 이름 타입)을 포함 할 수 있지만이에서 제거 될 수 있습니다 &lt;code&gt;Collection&lt;/code&gt; 에 의해 반환 된 이름의 &lt;a href=&quot;x509certselector#getSubjectAlternativeNames--&quot;&gt; &lt;code&gt;getSubjectAlternativeNames&lt;/code&gt; 의&lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="c14e64acfe94227c43f719a746e86900d00f7090" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;serverNames&lt;/code&gt; list is cloned to protect against subsequent modification.</source>
          <target state="translated">있습니다 &lt;code&gt;serverNames&lt;/code&gt; 의 목록이 이후의 변경으로부터 보호하기 위해 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="38308d874924a7942d1f42ff6dc2f346097d2c75" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;thrown&lt;/code&gt; argument is stored in the &lt;code&gt;LogRecord&lt;/code&gt;&lt;code&gt;thrown&lt;/code&gt; property, rather than the &lt;code&gt;LogRecord&lt;/code&gt;&lt;code&gt;parameters&lt;/code&gt; property. Thus it is processed specially by output &lt;code&gt;Formatter&lt;/code&gt; objects and is not treated as a formatting parameter to the &lt;code&gt;LogRecord&lt;/code&gt;&lt;code&gt;message&lt;/code&gt; property.</source>
          <target state="translated">Note that the &lt;code&gt;thrown&lt;/code&gt; argument is stored in the &lt;code&gt;LogRecord&lt;/code&gt; &lt;code&gt;thrown&lt;/code&gt; property, rather than the &lt;code&gt;LogRecord&lt;/code&gt; &lt;code&gt;parameters&lt;/code&gt; property. Thus it is processed specially by output &lt;code&gt;Formatter&lt;/code&gt; objects and is not treated as a formatting parameter to the &lt;code&gt;LogRecord&lt;/code&gt; &lt;code&gt;message&lt;/code&gt; property.</target>
        </trans-unit>
        <trans-unit id="986f8676d3727f0a03ee61225473768e48b647c0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;wait&lt;/code&gt; method, as it places the current thread into the wait set for this object, unlocks only this object; any other objects on which the current thread may be synchronized remain locked while the thread waits.</source>
          <target state="translated">점을 유의 &lt;code&gt;wait&lt;/code&gt; 는이 오브젝트에 대해 설정된 대기로 현재 스레드 배치 방법으로서,이 개체를 여는; 스레드가 대기하는 동안 현재 스레드가 동기화 될 수있는 다른 객체는 잠금 상태를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="66466b6a777448675550c25b8e8f2061272618e6" translate="yes" xml:space="preserve">
          <source>Note that the AccessibleRole class is also extensible, so custom component developers can define their own AccessibleRole's if the set of predefined roles is inadequate.</source>
          <target state="translated">Note that the AccessibleRole class is also extensible, so custom component developers can define their own AccessibleRole's if the set of predefined roles is inadequate.</target>
        </trans-unit>
        <trans-unit id="600b2598cbec0c4cc1f12fff57a0af82e4bcf29f" translate="yes" xml:space="preserve">
          <source>Note that the AdjustmentEvents type property will always have a placeholder value of AdjustmentEvent.TRACK because all changes to a BoundedRangeModels value are considered equivalent. To change the value of a BoundedRangeModel one just sets its value property, i.e. model.setValue(123). No information about the origin of the change, e.g. it's a block decrement, is provided. We don't try fabricate the origin of the change here.</source>
          <target state="translated">Note that the AdjustmentEvents type property will always have a placeholder value of AdjustmentEvent.TRACK because all changes to a BoundedRangeModels value are considered equivalent. To change the value of a BoundedRangeModel one just sets its value property, i.e. model.setValue(123). No information about the origin of the change, e.g. it's a block decrement, is provided. We don't try fabricate the origin of the change here.</target>
        </trans-unit>
        <trans-unit id="a287cdfb1fc2b02b06ee414104dfacf6356bcb46" translate="yes" xml:space="preserve">
          <source>Note that the Cipher object must be fully initialized with the correct algorithm, key, padding scheme, etc., before being applied to a SealedObject.</source>
          <target state="translated">Cipher 객체는 SealedObject에 적용되기 전에 올바른 알고리즘, 키, 패딩 스키마 등으로 완전히 초기화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7d03efa61acd1db505ae1fdd84d2f4633f1dfef9" translate="yes" xml:space="preserve">
          <source>Note that the Handler class &lt;b&gt;has to&lt;/b&gt; be a subclass of the abstract class &lt;a href=&quot;urlstreamhandler&quot;&gt;&lt;code&gt;URLStreamHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Handler 클래스 &lt;b&gt;는&lt;/b&gt; 추상 클래스 &lt;a href=&quot;urlstreamhandler&quot;&gt; &lt;code&gt;URLStreamHandler&lt;/code&gt; &lt;/a&gt; 의 서브 클래스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="68f6e49f723f29675cd4fcbbf1374b27c75a9085" translate="yes" xml:space="preserve">
          <source>Note that the ISO-8601 standard does not actually define eras. Note also that the ISO eras do not align with the well-known AD/BC eras due to the change between the Julian and Gregorian calendar systems.</source>
          <target state="translated">ISO-8601 표준은 실제로 시대를 정의하지는 않습니다. 또한 줄리안 달력과 그레고리력 시스템 사이의 변화로 인해 ISO 시대는 잘 알려진 AD / BC 시대와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5e022cddaafb15b12bb5f906b9ebec484bf96fd" translate="yes" xml:space="preserve">
          <source>Note that the InputSource gets no further resolution. Implementations of this method may wish to invoke &lt;a href=&quot;#resolveEntity(java.lang.String,java.lang.String,java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;resolveEntity()&lt;/code&gt;&lt;/a&gt; to gain benefits such as use of local caches of DTD entities. Also, this method will never be used by a (non-validating) processor that is not including external parameter entities.</source>
          <target state="translated">Note that the InputSource gets no further resolution. Implementations of this method may wish to invoke &lt;a href=&quot;#resolveEntity(java.lang.String,java.lang.String,java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;resolveEntity()&lt;/code&gt; &lt;/a&gt; to gain benefits such as use of local caches of DTD entities. Also, this method will never be used by a (non-validating) processor that is not including external parameter entities.</target>
        </trans-unit>
        <trans-unit id="d96c739af6d6be683992dca18c88ca500390be00" translate="yes" xml:space="preserve">
          <source>Note that the JDBC RowSet Implementations include the &lt;code&gt;SyncProvider&lt;/code&gt; implementations &lt;code&gt;RIOptimisticProvider&lt;/code&gt; and &lt;code&gt;RIXmlProvider&lt;/code&gt;, which satisfy this requirement.</source>
          <target state="translated">Note that the JDBC RowSet Implementations include the &lt;code&gt;SyncProvider&lt;/code&gt; implementations &lt;code&gt;RIOptimisticProvider&lt;/code&gt; and &lt;code&gt;RIXmlProvider&lt;/code&gt; , which satisfy this requirement.</target>
        </trans-unit>
        <trans-unit id="9cbc3c1c73b61088bab97a479f1657a4bfb13701" translate="yes" xml:space="preserve">
          <source>Note that the JDK Implementation uses default values for both the session cache size and timeout. See &lt;code&gt;getSessionCacheSize&lt;/code&gt; and &lt;code&gt;getSessionTimeout&lt;/code&gt; for more information. Applications should consider their performance requirements and override the defaults if necessary.</source>
          <target state="translated">JDK 구현은 세션 캐시 크기와 시간 제한 모두에 기본값을 사용합니다. 자세한 정보는 &lt;code&gt;getSessionCacheSize&lt;/code&gt; 및 &lt;code&gt;getSessionTimeout&lt;/code&gt; 을 참조하십시오. 응용 프로그램은 성능 요구 사항을 고려하고 필요한 경우 기본값을 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="121207ea3168ff93d476e2c34ba63695f18f95e3" translate="yes" xml:space="preserve">
          <source>Note that the KeyboardFocusManager itself implements KeyEventPostProcessor. By default, the current KeyboardFocusManager will be the final KeyEventPostProcessor in the chain. The current KeyboardFocusManager cannot be completely deregistered as a KeyEventPostProcessor. However, if a KeyEventPostProcessor reports that no further post-processing of the KeyEvent should take place, the AWT will consider the event fully handled and will take no additional action with regard to the event. (While it is possible for client code to register the current KeyboardFocusManager as a KeyEventPostProcessor one or more times, this is usually unnecessary and not recommended.)</source>
          <target state="translated">KeyboardFocusManager 자체는 KeyEventPostProcessor를 구현합니다. 기본적으로 현재 KeyboardFocusManager는 체인의 최종 KeyEventPostProcessor가됩니다. 현재 KeyboardFocusManager는 KeyEventPostProcessor로 완전히 등록 취소 할 수 없습니다. 그러나 KeyEventPostProcessor가 KeyEvent의 추가 후 처리가 발생하지 않아야한다고보고하면 AWT는 이벤트가 완전히 처리 된 것으로 간주하고 이벤트와 관련하여 추가 조치를 취하지 않습니다. (클라이언트 코드에서 현재 KeyboardFocusManager를 KeyEventPostProcessor로 한 번 이상 등록 할 수 있지만 일반적으로 불필요하며 권장되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="b9ae63fa5c8deaf38cfe3d102c2fe3407bd5110b" translate="yes" xml:space="preserve">
          <source>Note that the PKIX certification path validation algorithm specifies that any policy qualifier in a certificate policies extension that is marked critical must be processed and validated. Otherwise the certification path must be rejected. If the &lt;code&gt;policyQualifiersRejected&lt;/code&gt; flag is set to false, it is up to the application to validate all policy qualifiers in this manner in order to be PKIX compliant.</source>
          <target state="translated">PKIX 인증 경로 유효성 검증 알고리즘은 중요로 표시된 인증서 정책 확장의 모든 정책 규정자가 처리 및 유효성 검증되어야 함을 지정합니다. 그렇지 않으면 인증 경로를 거부해야합니다. 경우 &lt;code&gt;policyQualifiersRejected&lt;/code&gt; 플래그가 false로 설정되어, 그것은 PKIX의 준수를 위해서이 방법으로 모든 정책 수식을 검증 할 수있는 응용 프로그램까지입니다.</target>
        </trans-unit>
        <trans-unit id="dde6773f95e2d3779484c97f76fa50444b81e507" translate="yes" xml:space="preserve">
          <source>Note that the PKIX certification path validation algorithm specifies that any policy qualifier in a certificate policies extension that is marked critical must be processed and validated. Otherwise the certification path must be rejected. If the policyQualifiersRejected flag is set to false, it is up to the application to validate all policy qualifiers in this manner in order to be PKIX compliant.</source>
          <target state="translated">PKIX 인증 경로 유효성 검증 알고리즘은 중요로 표시된 인증서 정책 확장의 모든 정책 규정자가 처리 및 유효성 검증되어야 함을 지정합니다. 그렇지 않으면 인증 경로를 거부해야합니다. policyQualifiersRejected 플래그가 false로 설정되면 PKIX 호환을 위해이 방식으로 모든 정책 규정자를 유효성 검증하는 것은 응용 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="33c761075e29dd51a74c05bc4d8dc691c2c1c4c7" translate="yes" xml:space="preserve">
          <source>Note that the SAX1 document handler has no Namespace support.</source>
          <target state="translated">SAX1 문서 핸들러는 네임 스페이스를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a059b0c65ef0e0bb868d6fa0585b56507219ee9b" translate="yes" xml:space="preserve">
          <source>Note that the Source and the Destination may not be the same object.</source>
          <target state="translated">소스와 대상은 동일한 개체가 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94b011083096b9aaef46ca0541befae36befe3f5" translate="yes" xml:space="preserve">
          <source>Note that the above example will throw a &lt;code&gt;ClassCastException&lt;/code&gt; if the &lt;code&gt;Object&lt;/code&gt; passed to &lt;code&gt;compareTo(Object)&lt;/code&gt; is not a &lt;code&gt;Date&lt;/code&gt;.</source>
          <target state="translated">위의 예는 Throw합니다 &lt;code&gt;ClassCastException&lt;/code&gt; 이 경우 생성 &lt;code&gt;Object&lt;/code&gt; 로 전달 &lt;code&gt;compareTo(Object)&lt;/code&gt; 하지 않은 것입니다 &lt;code&gt;Date&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2921ae2b51a2608125abd4de9ba75dd67e47a0c" translate="yes" xml:space="preserve">
          <source>Note that the activator receives a &quot;marshalled&quot; object instead of a Remote object so that the activator does not need to load the code for that object, or participate in distributed garbage collection for that object. If the activator kept a strong reference to the remote object, the activator would then prevent the object from being garbage collected under the normal distributed garbage collection mechanism.</source>
          <target state="translated">활성기는 원격 개체 대신 &quot;마샬링 된&quot;개체를 수신하므로 활성기가 해당 개체에 대한 코드를로드하거나 해당 개체에 대한 분산 가비지 수집에 참여할 필요가 없습니다. 활성기가 원격 개체에 대한 강력한 참조를 유지하는 경우 활성기는 일반 분산 가비지 수집 메커니즘에서 개체가 가비지 수집되는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="8231e5a7ba75fd3f4a7b548d4f38a359f02d6907" translate="yes" xml:space="preserve">
          <source>Note that the actual maximum value of the scroll bar is the &lt;code&gt;maximum&lt;/code&gt; minus the &lt;code&gt;visible amount&lt;/code&gt;. In the previous example, because the &lt;code&gt;maximum&lt;/code&gt; is 300 and the &lt;code&gt;visible amount&lt;/code&gt; is 60, the actual maximum value is 240. The range of the scrollbar track is 0 - 300. The left side of the bubble indicates the value of the scroll bar.</source>
          <target state="translated">스크롤 막대의 실제 최대 값은 &lt;code&gt;maximum&lt;/code&gt; 값에서 &lt;code&gt;visible amount&lt;/code&gt; 뺀 값입니다 . 이전 예에서 &lt;code&gt;maximum&lt;/code&gt; 은 300이고 &lt;code&gt;visible amount&lt;/code&gt; 60이므로 실제 최대 값은 240입니다. 스크롤 막대 트랙의 범위는 0-300입니다. 거품의 왼쪽은 스크롤 막대의 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d76bf6c9a5ad363caa881145d8e63d00bf1d2f45" translate="yes" xml:space="preserve">
          <source>Note that the address returned may be &lt;code&gt;null&lt;/code&gt; if the &lt;code&gt;JMXConnectorServer&lt;/code&gt; is not yet &lt;a href=&quot;#isActive()&quot;&gt;&lt;code&gt;active&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;JMXConnectorServer&lt;/code&gt; 가 아직 &lt;a href=&quot;#isActive()&quot;&gt; &lt;code&gt;active&lt;/code&gt; &lt;/a&gt; 되지 않은 경우 반환 된 주소는 &lt;code&gt;null&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecc4da7e122b65298caf6a2e895a645b6616f131" translate="yes" xml:space="preserve">
          <source>Note that the address returned may be &lt;code&gt;null&lt;/code&gt; if the &lt;code&gt;JMXConnectorServer&lt;/code&gt; is not yet &lt;a href=&quot;../jmxconnectorservermbean#isActive--&quot;&gt;&lt;code&gt;active&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;JMXConnectorServer&lt;/code&gt; 가 아직 &lt;a href=&quot;../jmxconnectorservermbean#isActive--&quot;&gt; &lt;code&gt;active&lt;/code&gt; &lt;/a&gt; 되지 않은 경우 리턴 된 주소는 &lt;code&gt;null&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="920497d5c91ba08bc2aeb7e0378b6373891c2edc" translate="yes" xml:space="preserve">
          <source>Note that the address returned may be &lt;code&gt;null&lt;/code&gt; if the &lt;code&gt;JMXConnectorServer&lt;/code&gt; is not yet &lt;a href=&quot;jmxconnectorservermbean#isActive--&quot;&gt;&lt;code&gt;active&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 주소는 &lt;code&gt;null&lt;/code&gt; &lt;code&gt;JMXConnectorServer&lt;/code&gt; 가 아직 &lt;a href=&quot;jmxconnectorservermbean#isActive--&quot;&gt; &lt;code&gt;active&lt;/code&gt; &lt;/a&gt; 되지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="8e8a6c5c436497327540e915498e571b20a4e36c" translate="yes" xml:space="preserve">
          <source>Note that the advance of a &lt;code&gt;String&lt;/code&gt; is not necessarily the sum of the advances of its characters measured in isolation because the width of a character can vary depending on its context. For example, in Arabic text, the shape of a character can change in order to connect to other characters. Also, in some scripts, certain character sequences can be represented by a single shape, called a &lt;em&gt;ligature&lt;/em&gt;. Measuring characters individually does not account for these transformations.</source>
          <target state="translated">a의 사전 참고 &lt;code&gt;String&lt;/code&gt; 문자의 폭은 상황에 따라 달라질 수 있기 때문에 분리 측정되는 문자의 발전의 합이 필요하지 않습니다. 예를 들어 아랍어 텍스트에서는 다른 문자와 연결하기 위해 문자 모양을 변경할 수 있습니다. 또한 일부 스크립트에서 특정 문자 시퀀스는 &lt;em&gt;합자&lt;/em&gt; 라는 단일 모양으로 표현 될 수 있습니다 . 문자를 개별적으로 측정하는 것은 이러한 변환을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd11d5a6ae37c0d6eef1c289136d03d68dc85af5" translate="yes" xml:space="preserve">
          <source>Note that the advance of a &lt;code&gt;String&lt;/code&gt; is not necessarily the sum of the advances of its characters.</source>
          <target state="translated">a의 사전 참고 &lt;code&gt;String&lt;/code&gt; 은 문자의 발전의 합이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb4126fa9d9faed592884a76d3b6107dd436533c" translate="yes" xml:space="preserve">
          <source>Note that the alpha component of the returned color indicates whether the window is in the non-opaque (per-pixel translucent) mode.</source>
          <target state="translated">반환 된 색상의 알파 구성 요소는 창이 불투명하지 않은 (픽셀 당 반투명) 모드인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3a9c5b7cece8dc2d1ad438dbda9df46cfa8ae964" translate="yes" xml:space="preserve">
          <source>Note that the amount of memory required to hold an object of any given type may be implementation-dependent.</source>
          <target state="translated">주어진 유형의 객체를 보유하는 데 필요한 메모리 양은 구현에 따라 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="934be15369a61ef84c3edd2151ffea066f9a92cf" translate="yes" xml:space="preserve">
          <source>Note that the apdu bytes are copied to protect against subsequent modification.</source>
          <target state="translated">후속 수정으로부터 보호하기 위해 apdu 바이트가 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="d796ae851754144d274240a149124fe4220a5372" translate="yes" xml:space="preserve">
          <source>Note that the appearance and metrics of a 12pt font with a 2x transform might be different than that of a 24 point font with no transform.</source>
          <target state="translated">2x 변환이있는 12pt 글꼴의 모양과 메트릭은 변환이없는 24 포인트 글꼴의 모양과 메트릭과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57f1a04431ccdbe43c858a1eb88e0c07c789405b" translate="yes" xml:space="preserve">
          <source>Note that the application still requires an XML parser that implements SAX1.</source>
          <target state="translated">응용 프로그램에는 여전히 SAX1을 구현하는 XML 파서가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8ddf6ff0f9abe3d75a3ab55e218e948878271c8d" translate="yes" xml:space="preserve">
          <source>Note that the attribute list provided will contain only attributes with explicit values (specified or defaulted): #IMPLIED attributes will be omitted. The attribute list will contain attributes used for Namespace declarations (xmlns* attributes) only if the &lt;code&gt;http://xml.org/sax/features/namespace-prefixes&lt;/code&gt; property is true (it is false by default, and support for a true value is optional).</source>
          <target state="translated">제공된 속성 목록에는 명시 적 값 (지정 또는 기본값)이있는 속성 만 포함됩니다. #IMPLIED 속성은 생략됩니다. 속성 목록에는 &lt;code&gt;http://xml.org/sax/features/namespace-prefixes&lt;/code&gt; 속성이 true (기본적으로 false이고 true 값에 대한 지원이 다음과 같음 ) 인 경우에만 네임 스페이스 선언 (xmlns * 속성)에 사용되는 속성이 포함됩니다. 선택 과목).</target>
        </trans-unit>
        <trans-unit id="8e33f6be631338d60a61e74693b8502af9b70f67" translate="yes" xml:space="preserve">
          <source>Note that the basic logical channel cannot be closed using this method. It can be closed by calling &lt;a href=&quot;card#disconnect(boolean)&quot;&gt;&lt;code&gt;Card.disconnect(boolean)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 논리 채널은이 방법을 사용하여 닫을 수 없습니다. &lt;a href=&quot;card#disconnect(boolean)&quot;&gt; &lt;code&gt;Card.disconnect(boolean)&lt;/code&gt; &lt;/a&gt; 호출하여 닫을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e2ae11ad7c1eb4cf56305e5ee766ced0ade23b6" translate="yes" xml:space="preserve">
          <source>Note that the behavior of an unmarshalled &lt;code&gt;XMLSignature&lt;/code&gt; is undefined if the contents of the underlying DOM tree are modified by the caller after the &lt;code&gt;XMLSignature&lt;/code&gt; is created.</source>
          <target state="translated">&lt;code&gt;XMLSignature&lt;/code&gt; 가 생성 된 후 호출자가 기본 DOM 트리의 내용을 수정 하면 정렬 되지 않은 &lt;code&gt;XMLSignature&lt;/code&gt; 의 동작 이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="550b6222365f457f22bc34c5aacfcb00df5bdd91" translate="yes" xml:space="preserve">
          <source>Note that the behavior of this method differs from the older &lt;a href=&quot;../../util/calendar#getInstance(java.util.Locale)&quot;&gt;&lt;code&gt;Calendar.getInstance(Locale)&lt;/code&gt;&lt;/a&gt; method. If that method receives a locale of &quot;th_TH&quot; it will return &lt;code&gt;BuddhistCalendar&lt;/code&gt;. By contrast, this method will return &lt;code&gt;IsoChronology&lt;/code&gt;. Passing the locale &quot;th-TH-u-ca-buddhist&quot; into either method will result in the Thai Buddhist calendar system and is therefore the recommended approach going forward for Thai calendar system localization.</source>
          <target state="translated">이 메서드의 동작은 이전 &lt;a href=&quot;../../util/calendar#getInstance(java.util.Locale)&quot;&gt; &lt;code&gt;Calendar.getInstance(Locale)&lt;/code&gt; &lt;/a&gt; 메서드 와 다릅니다 . 해당 메소드가 &quot;th_TH&quot;로케일을 수신하면 &lt;code&gt;BuddhistCalendar&lt;/code&gt; 를 반환 합니다. &lt;code&gt;IsoChronology&lt;/code&gt; 메서드는 IsoChronology 를 반환 합니다 . 로케일 &quot;th-TH-u-ca-buddhist&quot;를 두 방법 중 하나로 전달하면 태국 불교 달력 시스템이 생성되므로 앞으로 태국 달력 시스템 현지화에 권장되는 접근 방식입니다.</target>
        </trans-unit>
        <trans-unit id="69e96d1eff90e87219450cb830b0087bcbd1f472" translate="yes" xml:space="preserve">
          <source>Note that the behavior of this method differs from the older &lt;a href=&quot;../../util/calendar#getInstance-java.util.Locale-&quot;&gt;&lt;code&gt;Calendar.getInstance(Locale)&lt;/code&gt;&lt;/a&gt; method. If that method receives a locale of &quot;th_TH&quot; it will return &lt;code&gt;BuddhistCalendar&lt;/code&gt;. By contrast, this method will return &lt;code&gt;IsoChronology&lt;/code&gt;. Passing the locale &quot;th-TH-u-ca-buddhist&quot; into either method will result in the Thai Buddhist calendar system and is therefore the recommended approach going forward for Thai calendar system localization.</source>
          <target state="translated">이 메소드의 동작은 이전 &lt;a href=&quot;../../util/calendar#getInstance-java.util.Locale-&quot;&gt; &lt;code&gt;Calendar.getInstance(Locale)&lt;/code&gt; &lt;/a&gt; 와 다릅니다. getInstance (Locale) 메소드 . 그 방법의 로케일을받는 경우 &quot;TH_TH&quot;이 반환됩니다 &lt;code&gt;BuddhistCalendar&lt;/code&gt; . &lt;code&gt;IsoChronology&lt;/code&gt; 방법은 IsoChronology 를 반환 합니다 . 로케일 &quot;th-TH-u-ca-buddhist&quot;를 두 방법 중 하나로 전달하면 태국 불교 달력 시스템이 생성되므로 태국 달력 시스템 현지화를 위해 권장되는 접근 방식입니다.</target>
        </trans-unit>
        <trans-unit id="1bd3f5a92243df95297353a9159f4efa867d4186" translate="yes" xml:space="preserve">
          <source>Note that the boolean array returned is cloned to protect against subsequent modifications.</source>
          <target state="translated">반환 된 부울 배열은 후속 수정으로부터 보호하기 위해 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="3b3cb8ceaed97cd58e9edb158792a15db18b86d9" translate="yes" xml:space="preserve">
          <source>Note that the boolean array supplied here is cloned to protect against subsequent modifications.</source>
          <target state="translated">여기에 제공된 부울 배열은 후속 수정으로부터 보호하기 위해 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="55c11de13fa984fca718431350a4374223af903b" translate="yes" xml:space="preserve">
          <source>Note that the byte array is cloned to protect against subsequent modification.</source>
          <target state="translated">후속 수정으로부터 보호하기 위해 바이트 배열이 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="98649c3120125f2624d5cd0a0dec5d4c2f57bed7" translate="yes" xml:space="preserve">
          <source>Note that the byte array returned is cloned to protect against subsequent modifications.</source>
          <target state="translated">리턴 된 바이트 배열은 후속 수정으로부터 보호하기 위해 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="48bc667fcbc1193935c676094d360ff45b02053f" translate="yes" xml:space="preserve">
          <source>Note that the byte array specified here is cloned to protect against subsequent modifications.</source>
          <target state="translated">여기에 지정된 바이트 배열은 후속 수정으로부터 보호하기 위해 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="7758e3dfa3aa64e8b941cb39f33bb199b7fd1668" translate="yes" xml:space="preserve">
          <source>Note that the byte array supplied here is cloned to protect against subsequent modifications.</source>
          <target state="translated">여기에 제공된 바이트 배열은 후속 수정으로부터 보호하기 위해 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="41bb19948a64112bc0391f87fa9476ebf0815a3c" translate="yes" xml:space="preserve">
          <source>Note that the byte is written as given; to write a character that will be translated according to the platform's default character encoding, use the &lt;code&gt;print(char)&lt;/code&gt; or &lt;code&gt;println(char)&lt;/code&gt; methods.</source>
          <target state="translated">바이트는 주어진대로 작성됩니다. 플랫폼의 기본 문자 인코딩에 따라 번역 될 문자를 작성하려면 &lt;code&gt;print(char)&lt;/code&gt; 또는 &lt;code&gt;println(char)&lt;/code&gt; 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a8c74a9984fdd8c9d87f727f57f5a335309bbb62" translate="yes" xml:space="preserve">
          <source>Note that the bytes will be written as given; to write characters that will be translated according to the platform's default character encoding, use the &lt;code&gt;print(char)&lt;/code&gt; or &lt;code&gt;println(char)&lt;/code&gt; methods.</source>
          <target state="translated">바이트는 주어진대로 작성됩니다. 플랫폼의 기본 문자 인코딩에 따라 번역 될 문자를 쓰려면 &lt;code&gt;print(char)&lt;/code&gt; 또는 &lt;code&gt;println(char)&lt;/code&gt; 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b0197d36c9a659c37258beb06c7b044615539fcf" translate="yes" xml:space="preserve">
          <source>Note that the column in</source>
          <target state="translated">열은</target>
        </trans-unit>
        <trans-unit id="23bfe2093adaaafcbc8bda1fce5f8ab6c1fd3efc" translate="yes" xml:space="preserve">
          <source>Note that the contents of &lt;code&gt;otherPrimeInfo&lt;/code&gt; are copied to protect against subsequent modification when constructing this object.</source>
          <target state="translated">&lt;code&gt;otherPrimeInfo&lt;/code&gt; 의 내용은 이 객체를 구성 할 때 후속 수정을 방지하기 위해 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="3985eefbac725ccfaa52ab83f8ebeb4f3d574ab1" translate="yes" xml:space="preserve">
          <source>Note that the contents of the three array parameters &lt;var&gt;itemNames&lt;/var&gt;, &lt;var&gt;itemDescriptions&lt;/var&gt; and &lt;var&gt;itemTypes&lt;/var&gt; are internally copied so that any subsequent modification of these arrays by the caller of this constructor has no impact on the constructed &lt;code&gt;CompositeType&lt;/code&gt; instance.</source>
          <target state="translated">세 개의 배열 매개 변수 &lt;var&gt;itemNames&lt;/var&gt; , &lt;var&gt;itemDescriptions&lt;/var&gt; 및 &lt;var&gt;itemTypes&lt;/var&gt; 의 내용 은 내부적으로 복사 되므로이 생성자의 호출자가이 배열을 계속 수정하면 생성 된 &lt;code&gt;CompositeType&lt;/code&gt; 인스턴스 에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="97b8cc9f6f9fcaf3a27fa5979e52f60691e56da5" translate="yes" xml:space="preserve">
          <source>Note that the correct test for frame being fully maximized is</source>
          <target state="translated">프레임이 완전히 최대화되는 올바른 테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d800cff1bd4bf70f8b643ab1d8f447daa20fd543" translate="yes" xml:space="preserve">
          <source>Note that the created empty descriptor is not a valid descriptor (the method &lt;a href=&quot;#isValid()&quot;&gt;&lt;code&gt;isValid&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;)</source>
          <target state="translated">생성 된 빈 설명자는 유효한 설명자가 아닙니다 ( &lt;a href=&quot;#isValid()&quot;&gt; &lt;code&gt;isValid&lt;/code&gt; &lt;/a&gt; 메서드 는 &lt;code&gt;false&lt;/code&gt; 반환 ).</target>
        </trans-unit>
        <trans-unit id="676b59d52306c71979ac5eb91682fb0ecdb9f5ac" translate="yes" xml:space="preserve">
          <source>Note that the created empty descriptor is not a valid descriptor (the method &lt;a href=&quot;#isValid()&quot;&gt;&lt;code&gt;isValid&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">생성 된 빈 설명자는 유효한 설명자가 아닙니다 ( &lt;a href=&quot;#isValid()&quot;&gt; &lt;code&gt;isValid&lt;/code&gt; &lt;/a&gt; 메서드 는 &lt;code&gt;false&lt;/code&gt; 를 반환 함 ).</target>
        </trans-unit>
        <trans-unit id="ca390b7381733866c3f8e18b0c9b52cfd0d778f1" translate="yes" xml:space="preserve">
          <source>Note that the created empty descriptor is not a valid descriptor (the method &lt;a href=&quot;descriptorsupport#isValid--&quot;&gt;&lt;code&gt;isValid&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;)</source>
          <target state="translated">작성된 빈 디스크립터는 올바른 디스크립터가 아닙니다 ( &lt;a href=&quot;descriptorsupport#isValid--&quot;&gt; &lt;code&gt;isValid&lt;/code&gt; &lt;/a&gt; 메소드 는 &lt;code&gt;false&lt;/code&gt; 를 리턴 함) )</target>
        </trans-unit>
        <trans-unit id="e27b5561a032ed45ad699f657a2b94172fc213cd" translate="yes" xml:space="preserve">
          <source>Note that the created empty descriptor is not a valid descriptor (the method &lt;a href=&quot;descriptorsupport#isValid--&quot;&gt;&lt;code&gt;isValid&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">작성된 빈 디스크립터는 유효한 디스크립터가 아닙니다 ( &lt;a href=&quot;descriptorsupport#isValid--&quot;&gt; &lt;code&gt;isValid&lt;/code&gt; &lt;/a&gt; 메소드 는 &lt;code&gt;false&lt;/code&gt; 를 리턴 함 ).</target>
        </trans-unit>
        <trans-unit id="baf343d35540a57cd7c53dee5c944b386bccc482" translate="yes" xml:space="preserve">
          <source>Note that the current contents of the &lt;code&gt;MemoryHandler&lt;/code&gt; buffer are &lt;b&gt;not&lt;/b&gt; written out. That requires a &quot;push&quot;.</source>
          <target state="translated">&lt;code&gt;MemoryHandler&lt;/code&gt; 버퍼 의 현재 내용은 기록 &lt;b&gt;되지 않습니다&lt;/b&gt; . &quot;푸시&quot;가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3576536b476d6f288e2b5a53508435a74c1d403e" translate="yes" xml:space="preserve">
          <source>Note that the data bytes are copied to protect against subsequent modification.</source>
          <target state="translated">후속 수정으로부터 보호하기 위해 데이터 바이트가 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="4ab0623562d136095e890e92aba942e9d0d832a1" translate="yes" xml:space="preserve">
          <source>Note that the data in the ByteBuffer is copied to protect against subsequent modification.</source>
          <target state="translated">후속 수정으로부터 보호하기 위해 ByteBuffer의 데이터가 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="28497725bea56b4157226139f8b58b8f2b3ba826" translate="yes" xml:space="preserve">
          <source>Note that the default uncaught exception handler should not usually defer to the thread's &lt;code&gt;ThreadGroup&lt;/code&gt; object, as that could cause infinite recursion.</source>
          <target state="translated">기본 포착되지 않은 예외 핸들러는 일반적으로 스레드의 &lt;code&gt;ThreadGroup&lt;/code&gt; 객체를 지연시키지 않아야합니다 . 이로 인해 무한 재귀가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6439914cf505a34ff736faeb01cc44494c444e3" translate="yes" xml:space="preserve">
          <source>Note that the detail message associated with &lt;code&gt;cause&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;cause&lt;/code&gt; 과 관련된 세부 정보 메시지 는</target>
        </trans-unit>
        <trans-unit id="88232412e9dcc9c9bbfef39a0ab00545e0407f57" translate="yes" xml:space="preserve">
          <source>Note that the detail message associated with &lt;code&gt;cause&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; automatically incorporated in this exception's detail message.</source>
          <target state="translated">&lt;code&gt;cause&lt;/code&gt; 과 관련된 세부 메시지 가 &lt;em&gt;아닙니다&lt;/em&gt; 이 예외의 상세 메세지에 자동적으로 통합.</target>
        </trans-unit>
        <trans-unit id="aef5718ac8a718341271d71f7d02357f742fe24f" translate="yes" xml:space="preserve">
          <source>Note that the embedded parser cannot be changed once the adapter is created; to embed a different parser, allocate a new ParserAdapter.</source>
          <target state="translated">포함 된 구문 분석기는 어댑터가 생성 된 후에는 변경할 수 없습니다. 다른 파서를 포함하려면 새 ParserAdapter를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="1e7f5bb03635f522408aedb8ad78692fe96ee461" translate="yes" xml:space="preserve">
          <source>Note that the entity naming scheme used here is the same one used in the &lt;a href=&quot;lexicalhandler&quot;&gt;&lt;code&gt;LexicalHandler&lt;/code&gt;&lt;/a&gt;, or in the &lt;a href=&quot;../contenthandler#skippedEntity(java.lang.String)&quot;&gt;&lt;code&gt;ContentHandler.skippedEntity()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">여기에 사용 된 엔티티 이름 지정 체계는 &lt;a href=&quot;lexicalhandler&quot;&gt; &lt;code&gt;LexicalHandler&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../contenthandler#skippedEntity(java.lang.String)&quot;&gt; &lt;code&gt;ContentHandler.skippedEntity()&lt;/code&gt; &lt;/a&gt; 메서드 에서 사용 된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="7e4b0865b4080fb87868f3b75be237d2d26483e0" translate="yes" xml:space="preserve">
          <source>Note that the event source is always the same &lt;code&gt;EventContext&lt;/code&gt;&lt;em&gt;instance&lt;/em&gt; that the listener has registered with. Furthermore, the names of the bindings in the &lt;code&gt;NamingEvent&lt;/code&gt; are always relative to that instance. For example, suppose a listener makes the following registration:</source>
          <target state="translated">이벤트 소스는 항상 리스너가 등록한 &lt;code&gt;EventContext&lt;/code&gt; &lt;em&gt;인스턴스&lt;/em&gt; 와 동일 합니다. 또한 &lt;code&gt;NamingEvent&lt;/code&gt; 의 바인딩 이름 은 항상 해당 인스턴스와 관련이 있습니다. 예를 들어, 리스너가 다음 등록을한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="4774d2e10632edf7ff877f3c231d1bf1b64bae21" translate="yes" xml:space="preserve">
          <source>Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw &lt;code&gt;ConcurrentModificationException&lt;/code&gt; on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness:</source>
          <target state="translated">일반적으로 말하자면, 비 동기화 된 동시 수정이있을 경우 어떠한 엄격한 보장도 불가능하므로 반복자의 페일-패스트 동작을 보장 할 수 없습니다. 가장 빠른 반복기 는 최선의 노력으로 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 발생시킵니다. 따라서이 예외에 따라 프로그램이 정확한지 작성하는 것은 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="bbc013ccb3bec6f168006262e334cd1b0cec1863" translate="yes" xml:space="preserve">
          <source>Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw &lt;code&gt;ConcurrentModificationException&lt;/code&gt; on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: &lt;em&gt;the fail-fast behavior of iterators should be used only to detect bugs.&lt;/em&gt;</source>
          <target state="translated">일반적으로 말하자면, 비 동기화 된 동시 수정이있을 경우 어떠한 엄격한 보장도 불가능하므로 반복자의 페일-패스트 동작을 보장 할 수 없습니다. 가장 빠른 반복기 는 최선의 노력으로 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 을 발생시킵니다. 따라서이 예외에 따라 프로그램이 올바른지 작성하는 것은 잘못 &lt;em&gt;입니다. 반복기의 빠른 동작은 버그를 탐지하는 데만 사용해야합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f337cec4dfd1e9f682c8b7a6e3c6946ba4dbd75" translate="yes" xml:space="preserve">
          <source>Note that the first week may start in the previous calendar year. Note also that the first few days of a calendar year may be in the week-based-year corresponding to the previous calendar year.</source>
          <target state="translated">첫주는 전년도에 시작될 수 있습니다. 또한 달력 연도의 처음 며칠은 전년도에 해당하는 주 기반 연도 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69508ccded1b20ac4486f64b2ed05294ca9fbcb9" translate="yes" xml:space="preserve">
          <source>Note that the following constraints have to be met:</source>
          <target state="translated">다음 제약 조건을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="e667691834c8d4e8229d4ee44568cb94337cfec9" translate="yes" xml:space="preserve">
          <source>Note that the get and set methods operate on references. Therefore, one must be careful not to share references between &lt;code&gt;ParameterBlock&lt;/code&gt;s when this is inappropriate. For example, to create a new &lt;code&gt;ParameterBlock&lt;/code&gt; that is equal to an old one except for an added source, one might be tempted to write:</source>
          <target state="translated">get 및 set 메서드는 참조에서 작동합니다. 따라서 부적절 할 때 &lt;code&gt;ParameterBlock&lt;/code&gt; 간에 참조를 공유하지 않도록주의해야합니다 . 예를 들어, 추가 된 소스를 제외하고 이전 것과 동일한 새 &lt;code&gt;ParameterBlock&lt;/code&gt; 을 만들려면 다음과 같이 작성하고 싶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13faa83e4779d055ea26b88d6004778b95615cf5" translate="yes" xml:space="preserve">
          <source>Note that the given user password is cloned before it is stored in the new &lt;code&gt;PasswordAuthentication&lt;/code&gt; object.</source>
          <target state="translated">지정된 사용자 비밀번호는 새 &lt;code&gt;PasswordAuthentication&lt;/code&gt; 오브젝트에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a8c5aba5fc2532c8859fbda2e23acb653b9d28c" translate="yes" xml:space="preserve">
          <source>Note that the guarantees of the &lt;code&gt;compareAndSet&lt;/code&gt; method in this class are weaker than in other atomic classes. Because this class cannot ensure that all uses of the field are appropriate for purposes of atomic access, it can guarantee atomicity only with respect to other invocations of &lt;code&gt;compareAndSet&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; on the same updater.</source>
          <target state="translated">이 클래스에서 &lt;code&gt;compareAndSet&lt;/code&gt; 메소드 의 보장은 다른 원자 클래스보다 약합니다. 이 클래스는 필드의 사용 모든 것이 원자 액세스에 적절하고있는 것을 보증 할 수 없기 때문에, 그것은 단지 다른 호출에 대한 자성을 보장 할 수 &lt;code&gt;compareAndSet&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 같은 갱신합니다.</target>
        </trans-unit>
        <trans-unit id="b804b647329bdff8f758509b4d8f13c3b9079097" translate="yes" xml:space="preserve">
          <source>Note that the hash code changes if the set of bits is altered.</source>
          <target state="translated">비트 세트가 변경되면 해시 코드가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="258c33c886c5d29594915bd1f976580525b30f2e" translate="yes" xml:space="preserve">
          <source>Note that the helper method is always invoked with all ancestors up to the &quot;closest non-removed ancestor&quot; locked.</source>
          <target state="translated">도우미 메소드는 항상 &quot;가장 가까운 비 분리형 조상&quot;까지 모든 조상과 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3ef91b3470959891a41c7245d3f844ec5afad75e" translate="yes" xml:space="preserve">
          <source>Note that the identity of a &lt;code&gt;Name&lt;/code&gt; is a function both of its content in terms of a sequence of characters as well as the implementation which created it.</source>
          <target state="translated">&lt;code&gt;Name&lt;/code&gt; 의 아이덴티티 는 일련의 문자와 그것을 만든 구현의 측면에서 내용의 함수입니다.</target>
        </trans-unit>
        <trans-unit id="05ba6d97e3f33ed432996a46f57b9d3bd3038782" translate="yes" xml:space="preserve">
          <source>Note that the identity of an element involves implicit state not directly accessible from the element's methods, including state about the presence of unrelated types. Element objects created by different implementations of these interfaces should</source>
          <target state="translated">요소의 아이덴티티는 관련없는 타입의 존재에 관한 상태를 포함하여 요소의 메소드에서 직접 액세스 할 수없는 암시 적 상태를 포함합니다. 이러한 인터페이스의 다른 구현으로 생성 된 요소 객체는</target>
        </trans-unit>
        <trans-unit id="f3b5901a8c579a9ef06c950615f94f36152d1902" translate="yes" xml:space="preserve">
          <source>Note that the implementations of these methods are inefficient, so they are usually overridden with more efficient toolkit-specific implementations.</source>
          <target state="translated">이러한 메서드의 구현은 비효율적이므로 일반적으로보다 효율적인 툴킷 별 구현으로 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a2329d90263935f0406de753b625d6727ab1ca6a" translate="yes" xml:space="preserve">
          <source>Note that the index represents the i-th selected child, which is different from the i-th child.</source>
          <target state="translated">인덱스는 i 번째 하위 항목과 다른 i 번째 선택된 하위 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6e30b802cf97843092ae3b7a5b0cae6a1163a62c" translate="yes" xml:space="preserve">
          <source>Note that the intermediate values, which are always in premultiplied form, would only allow the integer red component to be either 0x00 or 0x01. When we try to store this result back into a destination that is not premultiplied, dividing out the alpha will give us very few choices for the non-premultiplied red value. In this case an implementation that performs the math in integer space without shortcuts is likely to end up with the final pixel values of:</source>
          <target state="translated">항상 미리 곱해진 형식 인 중간 값은 정수 빨강 구성 요소가 0x00 또는 0x01이되도록 허용합니다. 이 결과를 미리 곱하지 않은 대상에 다시 저장하려고 할 때 알파를 나누면 미리 곱하지 않은 빨간색 값에 대한 선택이 거의 없습니다. 이 경우 바로 가기없이 정수 공간에서 수학을 수행하는 구현은 다음과 같은 최종 픽셀 값으로 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="229fc4bfd58116957da0dab64f4bc26e0a0bc97b" translate="yes" xml:space="preserve">
          <source>Note that the iterator returned by this method will throw an &lt;a href=&quot;../lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; in response to its &lt;code&gt;remove&lt;/code&gt; method unless the list's &lt;code&gt;remove(int)&lt;/code&gt; method is overridden.</source>
          <target state="translated">리스트의 &lt;code&gt;remove(int)&lt;/code&gt; 메소드를 오버라이드 (override ) 하지 않는 한, 이 메소드에 의해 리턴 된 반복자 는 &lt;code&gt;remove&lt;/code&gt; 메소드 에 대한 응답으로 &lt;a href=&quot;../lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; &lt;/a&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="ff9125628bfea09fc35d842b223dd7f7041ea321" translate="yes" xml:space="preserve">
          <source>Note that the lack of an AuthenticationException does not mean that the failure was not due to an authentication error. A SASL mechanism implementation might throw the more general SaslException instead of AuthenticationException if it is unable to determine the nature of the failure, or if does not want to disclose the nature of the failure, for example, due to security reasons.</source>
          <target state="translated">AuthenticationException이 없다고해서 인증 에러에 의한 것이 아닌 것은 아닙니다. SASL 메커니즘 구현은 실패의 특성을 판별 할 수 없거나 보안상의 이유로 실패의 특성을 공개하지 않으려는 경우 AuthenticationException 대신보다 일반적인 SaslException을 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c73f10a6be0d5219ce292432d09603a8ed3c17ab" translate="yes" xml:space="preserve">
          <source>Note that the list in the example shown was created with four visible rows. Once the list has been created, the number of visible rows cannot be changed. A default &lt;code&gt;List&lt;/code&gt; is created with four rows, so that &lt;code&gt;lst = new List()&lt;/code&gt; is equivalent to &lt;code&gt;list = new List(4, false)&lt;/code&gt;.</source>
          <target state="translated">표시된 예의 목록은 4 개의 보이는 행으로 생성되었습니다. 목록이 생성되면 표시되는 행 수를 변경할 수 없습니다. 기본 &lt;code&gt;List&lt;/code&gt; 는 4 개의 행으로 생성되므로 &lt;code&gt;lst = new List()&lt;/code&gt; 는 &lt;code&gt;list = new List(4, false)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5f1f03809857ac1de5284b44a53caaae867a9f93" translate="yes" xml:space="preserve">
          <source>Note that the list iterator returned by this implementation will throw an &lt;a href=&quot;../lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; in response to its &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; methods unless the list's &lt;code&gt;remove(int)&lt;/code&gt;, &lt;code&gt;set(int, E)&lt;/code&gt;, and &lt;code&gt;add(int, E)&lt;/code&gt; methods are overridden.</source>
          <target state="translated">이 구현에 의해 리턴 된리스트 반복 자는리스트의 &lt;code&gt;remove(int)&lt;/code&gt; , &lt;code&gt;set(int, E)&lt;/code&gt; 및 &lt;code&gt;add(int, E)&lt;/code&gt; 메소드가 오버라이드 되지 않는 한 &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; 및 &lt;code&gt;add&lt;/code&gt; 메소드 에 대한 응답으로 &lt;a href=&quot;../lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; &lt;/a&gt; 을 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="17eb1c72aa5ddca414f02eb29d9bc096f0e3d5a3" translate="yes" xml:space="preserve">
          <source>Note that the list of registered providers may be retrieved via the &lt;a href=&quot;../../../../../../java.base/java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">등록 된 공급자 목록은 &lt;a href=&quot;../../../../../../java.base/java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83929de1a909f2fb9df2da20c5d783d12ab4c1e3" translate="yes" xml:space="preserve">
          <source>Note that the list of registered providers may be retrieved via the &lt;a href=&quot;../../../../../java.base/java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">등록 된 공급자 목록은 &lt;a href=&quot;../../../../../java.base/java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="012d9303710def6228cc8ab3d3e6f2932a16ab21" translate="yes" xml:space="preserve">
          <source>Note that the list of registered providers may be retrieved via the &lt;a href=&quot;../../../../java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">등록 된 공급자 목록은 &lt;a href=&quot;../../../../java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10129b77e42f81a6268ee0a21cc2420cef62a225" translate="yes" xml:space="preserve">
          <source>Note that the list of registered providers may be retrieved via the &lt;a href=&quot;../../../../java/security/security#getProviders--&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">등록 된 제공자 목록은 &lt;a href=&quot;../../../../java/security/security#getProviders--&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 검색 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf6b66d8a188283cff0a6d146c69eba17aa08f86" translate="yes" xml:space="preserve">
          <source>Note that the list of registered providers may be retrieved via the &lt;a href=&quot;../../../java.base/java/security/security#getProviders()&quot;&gt;Security.getProviders()&lt;/a&gt; method.</source>
          <target state="translated">등록 된 공급자 목록은 &lt;a href=&quot;../../../java.base/java/security/security#getProviders()&quot;&gt;Security.getProviders ()&lt;/a&gt; 메서드 를 통해 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10926b00a637451690eb0c9fe0e9ee59eb256998" translate="yes" xml:space="preserve">
          <source>Note that the list of registered providers may be retrieved via the &lt;a href=&quot;../../../java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">등록 된 공급자 목록은 &lt;a href=&quot;../../../java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="204a2be22f7f82158aecee05d7924d8f4b87f8fc" translate="yes" xml:space="preserve">
          <source>Note that the list of registered providers may be retrieved via the &lt;a href=&quot;../../../java/security/security#getProviders--&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">등록 된 제공자 목록은 &lt;a href=&quot;../../../java/security/security#getProviders--&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 검색 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0b3b371c08a4eeb47d328b984affb68887daad7" translate="yes" xml:space="preserve">
          <source>Note that the list of registered providers may be retrieved via the &lt;a href=&quot;../../java/security/security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">등록 된 공급자 목록은 &lt;a href=&quot;../../java/security/security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00593fdf7ef77ce3d513e5cc4b947b0eb66f4945" translate="yes" xml:space="preserve">
          <source>Note that the list of registered providers may be retrieved via the &lt;a href=&quot;../../java/security/security#getProviders--&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">등록 된 제공자 목록은 &lt;a href=&quot;../../java/security/security#getProviders--&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 검색 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="924275ee694c5f6dac362a944997e4455f44df30" translate="yes" xml:space="preserve">
          <source>Note that the list of registered providers may be retrieved via the &lt;a href=&quot;../security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">등록 된 공급자 목록은 &lt;a href=&quot;../security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8317a604eddf777cc96e78b5ccb62bd7d32404e" translate="yes" xml:space="preserve">
          <source>Note that the list of registered providers may be retrieved via the &lt;a href=&quot;../security#getProviders--&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">등록 된 제공자 목록은 &lt;a href=&quot;../security#getProviders--&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 검색 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d243e984bb629973c73e8177810560cd4540d21c" translate="yes" xml:space="preserve">
          <source>Note that the list of registered providers may be retrieved via the &lt;a href=&quot;security#getProviders()&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">등록 된 공급자 목록은 &lt;a href=&quot;security#getProviders()&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f835ba60c148664984eeda8b8c760c1b3abd491" translate="yes" xml:space="preserve">
          <source>Note that the list of registered providers may be retrieved via the &lt;a href=&quot;security#getProviders--&quot;&gt;&lt;code&gt;Security.getProviders()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">등록 된 제공자 목록은 &lt;a href=&quot;security#getProviders--&quot;&gt; &lt;code&gt;Security.getProviders()&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 검색 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a49d08b5d064cb200a01555ea2ace93a8f701f9" translate="yes" xml:space="preserve">
          <source>Note that the localized pattern is looked up lazily. This &lt;code&gt;DateTimeFormatter&lt;/code&gt; holds the style required and the locale, looking up the pattern required on demand.</source>
          <target state="translated">현지화 된 패턴은 느리게 조회됩니다. 이 &lt;code&gt;DateTimeFormatter&lt;/code&gt; 에는 필요한 스타일과 로캘이 있으며 요청시 필요한 패턴을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="26388d49767254efc73f1c3daeae745601a775a1" translate="yes" xml:space="preserve">
          <source>Note that the locator will return correct information only during the invocation SAX event callbacks after &lt;a href=&quot;#startDocument()&quot;&gt;&lt;code&gt;startDocument&lt;/code&gt;&lt;/a&gt; returns and before &lt;a href=&quot;#endDocument()&quot;&gt;&lt;code&gt;endDocument&lt;/code&gt;&lt;/a&gt; is called. The application should not attempt to use it at any other time.</source>
          <target state="translated">로케이터는 &lt;a href=&quot;#startDocument()&quot;&gt; &lt;code&gt;startDocument&lt;/code&gt; 가&lt;/a&gt; 반환 된 후 &lt;a href=&quot;#endDocument()&quot;&gt; &lt;code&gt;endDocument&lt;/code&gt; &lt;/a&gt; 가 호출 되기 전에 SAX 이벤트 콜백을 호출하는 동안에 만 올바른 정보를 반환합니다 . 응용 프로그램은 다른 시간에 사용을 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="cc6ae65cf6a2c6b690528b4be599e5bed47ef7e9" translate="yes" xml:space="preserve">
          <source>Note that the locator will return correct information only during the invocation of the events in this interface. The application should not attempt to use it at any other time.</source>
          <target state="translated">로케이터는이 인터페이스에서 이벤트를 호출하는 동안에 만 올바른 정보를 리턴합니다. 응용 프로그램은 다른 시간에 응용 프로그램을 사용하려고 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e52d303130e845867576cea312679b44a28ef742" translate="yes" xml:space="preserve">
          <source>Note that the media white point tag in an ICC profile is not the same as the device white point. The media white point tag is expressed in PCS values and is used to represent the difference between the XYZ of device illuminant and the XYZ of the device media when measured under that illuminant. The device white point is expressed as the device XYZ values corresponding to white displayed on the device. For example, displaying the RGB color (1.0, 1.0, 1.0) on an sRGB device will result in a measured device XYZ value of D65. This will not be the same as the media white point tag XYZ value in the ICC profile for an sRGB device.</source>
          <target state="translated">ICC 프로파일의 미디어 화이트 포인트 태그는 장치 화이트 포인트와 동일하지 않습니다. 미디어 화이트 포인트 태그는 PCS 값으로 표현되며 해당 광원 아래에서 측정 할 때 장치 광원의 XYZ와 장치 미디어의 XYZ 간의 차이를 나타내는 데 사용됩니다. 디바이스 화이트 포인트는 디바이스에 표시된 화이트에 해당하는 디바이스 XYZ 값으로 표현됩니다. 예를 들어 sRGB 장치에 RGB 색상 (1.0, 1.0, 1.0)을 표시하면 측정 된 장치 XYZ 값이 D65가됩니다. 이는 sRGB 장치에 대한 ICC 프로파일의 미디어 화이트 포인트 태그 XYZ 값과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b8f59a6194b868cadeeb6447b52ba7208396da7" translate="yes" xml:space="preserve">
          <source>Note that the messages &quot;printed&quot; by methods in this interface may or may not appear as textual output to a location like &lt;a href=&quot;../../../../java.base/java/lang/system#out&quot;&gt;&lt;code&gt;System.out&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../java.base/java/lang/system#err&quot;&gt;&lt;code&gt;System.err&lt;/code&gt;&lt;/a&gt;. Implementations may choose to present this information in a different fashion, such as messages in a window.</source>
          <target state="translated">이 인터페이스의 메소드에 의해 &quot;인쇄 된&quot;메시지는 &lt;a href=&quot;../../../../java.base/java/lang/system#out&quot;&gt; &lt;code&gt;System.out&lt;/code&gt; &lt;/a&gt; 과 같은 위치에 텍스트 출력으로 표시되거나 표시되지 않을 수 있습니다. 또는 &lt;a href=&quot;../../../../java.base/java/lang/system#err&quot;&gt; &lt;code&gt;System.err&lt;/code&gt; &lt;/a&gt; . 구현은이 정보를 창에있는 메시지와 같은 다른 방식으로 표시하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67933009b5727550e61b88131764b34c42222511" translate="yes" xml:space="preserve">
          <source>Note that the messages &quot;printed&quot; by methods in this interface may or may not appear as textual output to a location like &lt;a href=&quot;../../../java/lang/system#out&quot;&gt;&lt;code&gt;System.out&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../java/lang/system#err&quot;&gt;&lt;code&gt;System.err&lt;/code&gt;&lt;/a&gt;. Implementations may choose to present this information in a different fashion, such as messages in a window.</source>
          <target state="translated">이 인터페이스에서 메소드로 &quot;인쇄 된&quot;메시지는 &lt;a href=&quot;../../../java/lang/system#out&quot;&gt; &lt;code&gt;System.out&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../java/lang/system#err&quot;&gt; &lt;code&gt;System.err&lt;/code&gt; &lt;/a&gt; 와 같은 위치에 텍스트 출력으로 표시되거나 표시되지 않을 수 있습니다 . 구현은이 정보를 창에있는 메시지와 같은 다른 방식으로 제시하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0f9135ac947c073e6eff42971b888a63a119961" translate="yes" xml:space="preserve">
          <source>Note that the name constraints byte array supplied here is cloned to protect against subsequent modifications.</source>
          <target state="translated">여기에 제공된 이름 제한 바이트 배열은 후속 수정으로부터 보호하기 위해 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="e2991014ac8dfac6b89fbdf6e61d82d4f89c0766" translate="yes" xml:space="preserve">
          <source>Note that the name constraints byte array supplied is cloned to protect against subsequent modifications.</source>
          <target state="translated">제공된 이름 제한 바이트 배열은 후속 수정으로부터 보호하기 위해 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="988ca2f219cbe734841c9e53cfd0824a297c6a15" translate="yes" xml:space="preserve">
          <source>Note that the naming convention for this interface reflects the relationship between the line and its mixer. From the perspective of an application, a source data line may act as a target for audio data.</source>
          <target state="translated">이 인터페이스의 명명 규칙은 라인과 믹서 간의 관계를 반영합니다. 애플리케이션의 관점에서, 소스 데이터 라인은 오디오 데이터의 타겟으로서 작용할 수있다.</target>
        </trans-unit>
        <trans-unit id="288339971a575eedd16610ea5ca3b9faa2540bb1" translate="yes" xml:space="preserve">
          <source>Note that the naming convention for this interface reflects the relationship between the line and its mixer. From the perspective of an application, a target data line may act as a source for audio data.</source>
          <target state="translated">이 인터페이스의 명명 규칙은 라인과 믹서 간의 관계를 반영합니다. 애플리케이션의 관점에서, 타겟 데이터 라인은 오디오 데이터의 소스로서 작용할 수있다.</target>
        </trans-unit>
        <trans-unit id="961ebafe62b074003933c2d8bfa9a9efc7d3ffde" translate="yes" xml:space="preserve">
          <source>Note that the native platform may delay presenting the splash screen native window on the screen. The return value of &lt;code&gt;true&lt;/code&gt; for this method only guarantees that the conditions to hide the splash screen window have not occurred yet.</source>
          <target state="translated">기본 플랫폼은 화면에 스플래시 화면 기본 창 표시를 지연시킬 수 있습니다. 반환 값 &lt;code&gt;true&lt;/code&gt; 이 메서드에 대한 true 스플래시 화면 창을 숨기는 조건이 아직 발생하지 않았 음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="caa52462b541aabea83c601148bfe9c61c81299b" translate="yes" xml:space="preserve">
          <source>Note that the notation name corresponds to a notation reported by the &lt;a href=&quot;#notationDecl(java.lang.String,java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;notationDecl&lt;/code&gt;&lt;/a&gt; event. It is up to the application to record the entity for later reference, if necessary; unparsed entities may appear as attribute values.</source>
          <target state="translated">표기법 이름은 &lt;a href=&quot;#notationDecl(java.lang.String,java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;notationDecl&lt;/code&gt; &lt;/a&gt; 이벤트에. 필요한 경우 나중에 참조 할 수 있도록 엔티티를 기록하는 것은 애플리케이션에 달려 있습니다. 구문 분석되지 않은 엔티티는 속성 값으로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d44e80bc6f958b1b209aebde28e3986d985541c" translate="yes" xml:space="preserve">
          <source>Note that the number returned is a snapshot of how much memory is available; some images may still have problems being allocated into that memory. For example, depending on operating system, driver, memory configuration, and thread situations, the full extent of the size reported may not be available for a given image. There are further inquiry methods on the &lt;a href=&quot;imagecapabilities&quot;&gt;&lt;code&gt;ImageCapabilities&lt;/code&gt;&lt;/a&gt; object associated with a VolatileImage that can be used to determine whether a particular VolatileImage has been created in accelerated memory.</source>
          <target state="translated">반환 된 숫자는 사용 가능한 메모리 양의 스냅 샷입니다. 일부 이미지는 여전히 해당 메모리에 할당되는 데 문제가있을 수 있습니다. 예를 들어 운영 체제, 드라이버, 메모리 구성 및 스레드 상황에 따라보고 된 크기의 전체 범위를 주어진 이미지에 사용하지 못할 수 있습니다. 더 많은 문의 방법이 있습니다.&lt;a href=&quot;imagecapabilities&quot;&gt; &lt;code&gt;ImageCapabilities&lt;/code&gt; &lt;/a&gt;가속 메모리에 특정 VolatileImage가 생성되었는지 여부를 확인하는 데 사용할 수있는 VolatileImage와 관련된 ImageCapabilities 개체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="478dc80354ae2071dceabdec088f6095cb9b0bd3" translate="yes" xml:space="preserve">
          <source>Note that the numeric day-of-week representation differs from the ISO 8601 standard, and that the &lt;code&gt;weekOfYear&lt;/code&gt; numbering is compatible with the standard when &lt;code&gt;
 getFirstDayOfWeek()&lt;/code&gt; is &lt;code&gt;MONDAY&lt;/code&gt; and &lt;code&gt;
 getMinimalDaysInFirstWeek()&lt;/code&gt; is 4.</source>
          <target state="translated">숫자 요일 표현은 ISO 8601 표준과 다르며, &lt;code&gt;weekOfYear&lt;/code&gt; 번호 매기기는 &lt;code&gt; getFirstDayOfWeek()&lt;/code&gt; 가 &lt;code&gt;MONDAY&lt;/code&gt; 이고 표준과 호환됩니다. &lt;code&gt; getMinimalDaysInFirstWeek()&lt;/code&gt; 가 4 일 .</target>
        </trans-unit>
        <trans-unit id="156c436788f24f5adb474e0551c7880f5d168c3b" translate="yes" xml:space="preserve">
          <source>Note that the numeric day-of-week representation differs from the ISO 8601 standard, and that the &lt;code&gt;weekOfYear&lt;/code&gt; numbering is compatible with the standard when &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; is &lt;code&gt;MONDAY&lt;/code&gt; and &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; is 4.</source>
          <target state="translated">숫자 요일 표시는 ISO 8601 표준과 다르며, &lt;code&gt;getFirstDayOfWeek()&lt;/code&gt; 가 &lt;code&gt;MONDAY&lt;/code&gt; 이고 &lt;code&gt;getMinimalDaysInFirstWeek()&lt;/code&gt; 가 4 인 경우 &lt;code&gt;weekOfYear&lt;/code&gt; 번호 매기기는 표준과 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="ded8859876c1b1125e6f346cb280192c0d32a59b" translate="yes" xml:space="preserve">
          <source>Note that the order of the specified proxy interfaces is significant: two requests for a proxy class with the same combination of interfaces but in a different order will result in two distinct proxy classes.</source>
          <target state="translated">지정된 프록시 인터페이스의 순서는 중요합니다. 인터페이스 조합은 동일하지만 순서가 다른 프록시 클래스에 대한 두 개의 요청은 두 개의 별개의 프록시 클래스가됩니다.</target>
        </trans-unit>
        <trans-unit id="e5b9178f245231baa4452e11b727dfafc65ffdf5" translate="yes" xml:space="preserve">
          <source>Note that the ordering maintained by a set (whether or not an explicit comparator is provided) must be</source>
          <target state="translated">세트에 의해 유지되는 순서 (명시적인 비교기가 제공되는지 여부)는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="9e198b477df4c65dd838c69d955961384e32f7f2" translate="yes" xml:space="preserve">
          <source>Note that the ordering maintained by a sorted map (whether or not an explicit comparator is provided) must be &lt;em&gt;consistent with equals&lt;/em&gt; if the sorted map is to correctly implement the &lt;code&gt;Map&lt;/code&gt; interface. (See the &lt;code&gt;Comparable&lt;/code&gt; interface or &lt;code&gt;Comparator&lt;/code&gt; interface for a precise definition of &lt;em&gt;consistent with equals&lt;/em&gt;.) This is so because the &lt;code&gt;Map&lt;/code&gt; interface is defined in terms of the &lt;code&gt;equals&lt;/code&gt; operation, but a sorted map performs all key comparisons using its &lt;code&gt;compareTo&lt;/code&gt; (or &lt;code&gt;compare&lt;/code&gt;) method, so two keys that are deemed equal by this method are, from the standpoint of the sorted map, equal. The behavior of a tree map &lt;em&gt;is&lt;/em&gt; well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the &lt;code&gt;Map&lt;/code&gt; interface.</source>
          <target state="translated">정렬 된 맵이 &lt;code&gt;Map&lt;/code&gt; 인터페이스 를 올바르게 구현하려면 정렬 된 맵에 의해 유지되는 순서 (명시 적 비교기가 제공되는지 여부에 관계없이)가 &lt;em&gt;동일&lt;/em&gt; 해야합니다 . ( &lt;em&gt;equals와 일치&lt;/em&gt; 하는 것에 대한 정확한 정의 는 &lt;code&gt;Comparable&lt;/code&gt; 인터페이스 또는 &lt;code&gt;Comparator&lt;/code&gt; 인터페이스를 참조하십시오 .) 이는 &lt;code&gt;Map&lt;/code&gt; 인터페이스가 &lt;code&gt;equals&lt;/code&gt; 연산 측면에서 정의 되었기 때문에 정렬 된 맵은 &lt;code&gt;compareTo&lt;/code&gt; (또는 &lt;code&gt;compare&lt;/code&gt; ) 메소드를 사용하여 모든 주요 비교를 수행 하기 때문입니다. 따라서이 방법으로 동등한 것으로 간주되는 두 개의 키는 정렬 된지도의 관점에서 동일합니다. 트리 맵의 동작&lt;em&gt;&lt;/em&gt;&lt;em&gt;이다&lt;/em&gt; 그 순서 부가 equals와 일관성이없는 경우 잘 정의; &lt;code&gt;Map&lt;/code&gt; 인터페이스 의 일반 계약에 따르지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="199e68b39f22422dbca48a75470d62097940952d" translate="yes" xml:space="preserve">
          <source>Note that the ordering maintained by a sorted set (whether or not an explicit comparator is provided) must be</source>
          <target state="translated">정렬 된 세트에 의해 유지되는 순서 (명시적인 비교기가 제공되는지 여부)는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="e9e22df42ea44a2a29df28280edcc58bd7eae8fb" translate="yes" xml:space="preserve">
          <source>Note that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, must be &lt;em&gt;consistent with &lt;code&gt;equals&lt;/code&gt;&lt;/em&gt; if this sorted map is to correctly implement the &lt;code&gt;Map&lt;/code&gt; interface. (See &lt;code&gt;Comparable&lt;/code&gt; or &lt;code&gt;Comparator&lt;/code&gt; for a precise definition of &lt;em&gt;consistent with equals&lt;/em&gt;.) This is so because the &lt;code&gt;Map&lt;/code&gt; interface is defined in terms of the &lt;code&gt;equals&lt;/code&gt; operation, but a sorted map performs all key comparisons using its &lt;code&gt;
 compareTo&lt;/code&gt; (or &lt;code&gt;compare&lt;/code&gt;) method, so two keys that are deemed equal by this method are, from the standpoint of the sorted map, equal. The behavior of a sorted map &lt;em&gt;is&lt;/em&gt; well-defined even if its ordering is inconsistent with &lt;code&gt;equals&lt;/code&gt;; it just fails to obey the general contract of the &lt;code&gt;Map&lt;/code&gt; interface.</source>
          <target state="translated">정렬 된 맵과 마찬가지로 트리 맵에 의해 유지되는 순서 및 명시 적 비교기가 제공되는지 여부는 이 정렬 된 맵이 &lt;code&gt;Map&lt;/code&gt; 인터페이스 를 올바르게 구현하려면 &lt;em&gt; &lt;code&gt;equals&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 과 일치&lt;/em&gt; 해야합니다 . ( &lt;em&gt;일관성&lt;/em&gt; 에 대한 정확한 정의는 &lt;code&gt;Comparable&lt;/code&gt; 또는 &lt;code&gt;Comparator&lt;/code&gt; 를 참조하십시오 .) 이는 &lt;code&gt;Map&lt;/code&gt; 인터페이스가 &lt;code&gt;equals&lt;/code&gt; 연산 측면에서 정의 되었지만 정렬 된 맵은 사용하여 모든 키 비교를 수행&lt;em&gt;&lt;/em&gt; &lt;code&gt; compareTo&lt;/code&gt; (또는 &lt;code&gt;compare&lt;/code&gt; ) 메서드이므로이 메서드에서 동일하다고 간주되는 두 개의 키는 정렬 된 맵의 관점에서 동일합니다. 소트 맵의 동작은, &lt;em&gt;이다&lt;/em&gt; , 그 순서와 일관성이없는 경우에서도 명확하게 정의 &lt;code&gt;equals&lt;/code&gt; ; &lt;code&gt;Map&lt;/code&gt; 인터페이스 의 일반 계약을 따르지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="875a2b57c1f5ecdeb4903f8f8db692901646f720" translate="yes" xml:space="preserve">
          <source>Note that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, must be &lt;em&gt;consistent with &lt;code&gt;equals&lt;/code&gt;&lt;/em&gt; if this sorted map is to correctly implement the &lt;code&gt;Map&lt;/code&gt; interface. (See &lt;code&gt;Comparable&lt;/code&gt; or &lt;code&gt;Comparator&lt;/code&gt; for a precise definition of &lt;em&gt;consistent with equals&lt;/em&gt;.) This is so because the &lt;code&gt;Map&lt;/code&gt; interface is defined in terms of the &lt;code&gt;equals&lt;/code&gt; operation, but a sorted map performs all key comparisons using its &lt;code&gt;compareTo&lt;/code&gt; (or &lt;code&gt;compare&lt;/code&gt;) method, so two keys that are deemed equal by this method are, from the standpoint of the sorted map, equal. The behavior of a sorted map &lt;em&gt;is&lt;/em&gt; well-defined even if its ordering is inconsistent with &lt;code&gt;equals&lt;/code&gt;; it just fails to obey the general contract of the &lt;code&gt;Map&lt;/code&gt; interface.</source>
          <target state="translated">정렬 된 맵과 같이 트리 맵에 의해 유지되는 순서와 명시 적 비교기가 제공되는지 여부는 이 정렬 된 맵이 &lt;code&gt;Map&lt;/code&gt; 인터페이스 를 올바르게 구현하는 경우 &lt;em&gt;와 &lt;code&gt;equals&lt;/code&gt; &lt;/em&gt; 해야합니다 . (참조 &lt;code&gt;Comparable&lt;/code&gt; 또는 &lt;code&gt;Comparator&lt;/code&gt; 의 정확한 정의에 대한 &lt;em&gt;equals와 일관성&lt;/em&gt; 때문에 그렇게합니다.) &lt;code&gt;Map&lt;/code&gt; 인터페이스는이 측면에서 정의 된 &lt;code&gt;equals&lt;/code&gt; 작업을하지만, 정렬 된지도가 수행하는 모든 키 비교의 사용 &lt;code&gt;compareTo&lt;/code&gt; (또는 &lt;code&gt;compare&lt;/code&gt; &lt;em&gt;&lt;/em&gt;) 메소드를 사용하므로이 메소드에서 동일한 것으로 간주되는 두 개의 키는 정렬 된 맵의 관점에서 동일합니다. 소트 맵의 동작은, &lt;em&gt;이다&lt;/em&gt; , 그 순서와 일관성이없는 경우에서도 명확하게 정의 &lt;code&gt;equals&lt;/code&gt; ; &lt;code&gt;Map&lt;/code&gt; 인터페이스 의 일반 계약에 따르지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b49a89fe8fa0a7c36fa24d531ff00e285ec132b7" translate="yes" xml:space="preserve">
          <source>Note that the other constructors of &lt;code&gt;Throwable&lt;/code&gt; treat suppression as being enabled and the stack trace as being writable. Subclasses of &lt;code&gt;Throwable&lt;/code&gt; should document any conditions under which suppression is disabled and document conditions under which the stack trace is not writable. Disabling of suppression should only occur in exceptional circumstances where special requirements exist, such as a virtual machine reusing exception objects under low-memory situations. Circumstances where a given exception object is repeatedly caught and rethrown, such as to implement control flow between two sub-systems, is another situation where immutable throwable objects would be appropriate.</source>
          <target state="translated">&lt;code&gt;Throwable&lt;/code&gt; 의 다른 생성자는 억제가 활성화 된 것으로 간주하고 스택 추적은 쓰기 가능한 것으로 간주합니다. &lt;code&gt;Throwable&lt;/code&gt; 의 서브 클래스는 억제가 비활성화 된 조건과 스택 추적을 쓸 수없는 조건을 문서화해야합니다. 메모리 부족 상황에서 예외 개체를 재사용하는 가상 시스템과 같은 특별한 요구 사항이 존재하는 예외적 인 상황에서만 억제 기능을 해제해야합니다. 두 하위 시스템 간의 제어 흐름을 구현하는 등 주어진 예외 개체가 반복적으로 포착되고 다시 발생하는 상황은 불변의 던질 수있는 개체가 적절한 또 다른 상황입니다.</target>
        </trans-unit>
        <trans-unit id="9a0a16374bd06c1364d484f2843a1edc0119bea4" translate="yes" xml:space="preserve">
          <source>Note that the parameter type lists &lt;code&gt;(V...)&lt;/code&gt; and &lt;code&gt;(A...)&lt;/code&gt; have been expanded to their full length, even though individual clause functions may neglect to take them all. As noted above, missing parameters are filled in as if by &lt;a href=&quot;#dropArgumentsToMatch(java.lang.invoke.MethodHandle,int,java.util.List,int)&quot;&gt;&lt;code&gt;dropArgumentsToMatch(MethodHandle, int, List, int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수 유형 목록 &lt;code&gt;(V...)&lt;/code&gt; 및 &lt;code&gt;(A...)&lt;/code&gt; 는 개별 절 함수가 모두를 무시할 수 있지만 전체 길이로 확장되었습니다. 위에서 언급했듯이 누락 된 매개 변수는 &lt;a href=&quot;#dropArgumentsToMatch(java.lang.invoke.MethodHandle,int,java.util.List,int)&quot;&gt; &lt;code&gt;dropArgumentsToMatch(MethodHandle, int, List, int)&lt;/code&gt; &lt;/a&gt; 처럼 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="3d89b562b4b5e1aa1b59ec026c09b7ae3cdf143b" translate="yes" xml:space="preserve">
          <source>Note that the passed &lt;var&gt;delegate&lt;/var&gt; might not be directly the MBeanServerDelegate that was returned by this implementation. It could be, for instance, a new object wrapping the previously returned delegate.</source>
          <target state="translated">전달 된 &lt;var&gt;delegate&lt;/var&gt; 가이 구현에 의해 리턴 된 MBeanServerDelegate가 아닐 수도 있습니다. 예를 들어, 이전에 리턴 된 델리게이트를 랩핑하는 새 오브젝트 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d6d56b3e03ba20e886d0e62e57b3daaa69b5e3" translate="yes" xml:space="preserve">
          <source>Note that the passed &lt;var&gt;delegate&lt;/var&gt; might not be directly the MBeanServerDelegate that was returned by this method. It could be, for instance, a new object wrapping the previously returned object.</source>
          <target state="translated">전달 된 &lt;var&gt;delegate&lt;/var&gt; 가이 메소드에 의해 리턴 된 MBeanServerDelegate가 아닐 수도 있습니다. 예를 들어, 이전에 리턴 된 오브젝트를 랩핑하는 새 오브젝트 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="616efdd09b5e59d66bf9b938ff4ea81918f0b20f" translate="yes" xml:space="preserve">
          <source>Note that the pattern string is similar, but not identical, to &lt;a href=&quot;../../text/simpledateformat&quot;&gt;&lt;code&gt;SimpleDateFormat&lt;/code&gt;&lt;/a&gt;. The pattern string is also similar, but not identical, to that defined by the Unicode Common Locale Data Repository (CLDR/LDML). Pattern letters 'X' and 'u' are aligned with Unicode CLDR/LDML. By contrast, &lt;code&gt;SimpleDateFormat&lt;/code&gt; uses 'u' for the numeric day of week. Pattern letters 'y' and 'Y' parse years of two digits and more than 4 digits differently. Pattern letters 'n', 'A', 'N', and 'p' are added. Number types will reject large numbers.</source>
          <target state="translated">패턴 문자열은 &lt;a href=&quot;../../text/simpledateformat&quot;&gt; &lt;code&gt;SimpleDateFormat&lt;/code&gt; &lt;/a&gt; 과 유사하지만 동일하지는 않습니다 . 패턴 문자열은 또한 CLDR / LDML (Unicode Common Locale Data Repository)에서 정의한 것과 유사하지만 동일하지는 않습니다. 패턴 문자 'X'및 'u'는 유니 코드 CLDR / LDML과 정렬됩니다. 반대로 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 은 숫자 요일에 'u'를 사용합니다. 패턴 문자 'y'와 'Y'는 연도를 두 자리 숫자와 4 자리 이상의 숫자로 다르게 구문 분석합니다. 패턴 문자 'n', 'A', 'N'및 'p'가 추가됩니다. 숫자 유형은 큰 숫자를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="7e0a964b958122f28c1b26edc36fc68bc446c6d6" translate="yes" xml:space="preserve">
          <source>Note that the peer may also request a session renegotiation with this &lt;code&gt;SSLEngine&lt;/code&gt; by sending the appropriate session renegotiate handshake message.</source>
          <target state="translated">피어는 적절한 세션 재협상 핸드 셰이크 메시지를 전송 하여이 &lt;code&gt;SSLEngine&lt;/code&gt; 과의 세션 재협상을 요청할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="895a126c3269573a0eee9a955d709271fbfa8d7f" translate="yes" xml:space="preserve">
          <source>Note that the result of &lt;code&gt;readBits(32)&lt;/code&gt; may thus not be equal to that of &lt;code&gt;readInt()&lt;/code&gt; if a reverse network byte order is being used (i.e., &lt;code&gt;getByteOrder() == false&lt;/code&gt;).</source>
          <target state="translated">역방향 네트워크 바이트 순서를 사용하는 경우 (즉, &lt;code&gt;getByteOrder() == false&lt;/code&gt; ) &lt;code&gt;readBits(32)&lt;/code&gt; 의 결과는 &lt;code&gt;readInt()&lt;/code&gt; 의 결과와 같지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5164f3c20d1567cd2d890e8869e17807a5d1ed8c" translate="yes" xml:space="preserve">
          <source>Note that the result of this method is immediately outdated, there is no guarantee that a subsequent attempt to execute the file will succeed (or even that it will access the same file). Care should be taken when using this method in security sensitive applications.</source>
          <target state="translated">이 방법의 결과는 즉시 구식이므로 파일을 실행하려는 후속 시도가 성공하거나 심지어 동일한 파일에 액세스한다고 보장 할 수 없습니다. 보안에 민감한 응용 프로그램에서이 방법을 사용할 때는주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="c5486aacd8f76343dcee4f5c2308c7e2148deab3" translate="yes" xml:space="preserve">
          <source>Note that the result of this method is immediately outdated, there is no guarantee that a subsequent attempt to open the file for reading will succeed (or even that it will access the same file). Care should be taken when using this method in security sensitive applications.</source>
          <target state="translated">이 방법의 결과는 즉시 구식입니다. 읽기 위해 파일을 연 다음에 시도해도 성공할 것이라는 보장은 없습니다 (또는 동일한 파일에 액세스 할 수도 있음). 보안에 민감한 응용 프로그램에서이 방법을 사용할 때는주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="98a01f5f039ff94dd1fb418058665f9f4c4e9292" translate="yes" xml:space="preserve">
          <source>Note that the result of this method is immediately outdated. If this method indicates the file exists then there is no guarantee that a subsequence access will succeed. Care should be taken when using this method in security sensitive applications.</source>
          <target state="translated">이 방법의 결과는 즉시 구식입니다. 이 방법으로 파일이 존재하면 하위 시퀀스 액세스가 성공할 것이라는 보장이 없습니다. 보안에 민감한 응용 프로그램에서이 방법을 사용할 때는주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="034c5b83063bdd90fbcfb07a7d6733ff5becc2fd" translate="yes" xml:space="preserve">
          <source>Note that the result of this method is immediately outdated. If this method indicates the file exists then there is no guarantee that a subsequent access will succeed. Care should be taken when using this method in security sensitive applications.</source>
          <target state="translated">이 방법의 결과는 즉시 구식입니다. 이 방법이 파일이 있음을 나타내면 후속 액세스가 성공할 것이라는 보장이 없습니다. 보안에 민감한 응용 프로그램에서이 방법을 사용할 때는주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="063f9f6459bb715bee62b476cbbbb311b5fc5400" translate="yes" xml:space="preserve">
          <source>Note that the result only describes the minimum and maximum valid values and it is important not to read too much into them. For example, there could be values within the range that are invalid for the field.</source>
          <target state="translated">결과는 최소 및 최대 유효 값 만 설명하므로 너무 많이 읽지 않는 것이 중요합니다. 예를 들어, 범위 내에 해당 필드에 유효하지 않은 값이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0901c71ef6d3aef58ba9bcbd542f94c540f8806" translate="yes" xml:space="preserve">
          <source>Note that the results returned by the object will be valid only during the scope of each callback method: the application will receive unpredictable results if it attempts to use the locator at any other time, or after parsing completes.</source>
          <target state="translated">객체에서 반환 된 결과는 각 콜백 메서드의 범위 내에서만 유효합니다. 응용 프로그램은 다른 시간에 로케이터를 사용하려고 시도하거나 구문 분석이 완료된 후에 예측할 수없는 결과를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="69baa900bee1487b8c4753c6e2ab43871f7fe469" translate="yes" xml:space="preserve">
          <source>Note that the returned executable pathname and the arguments may be truncated on some platforms due to system limitations.</source>
          <target state="translated">반환 된 실행 가능 경로 이름과 인수는 시스템 제한으로 인해 일부 플랫폼에서 잘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50d3658e064c37097f7278405648c7436c70d8ea" translate="yes" xml:space="preserve">
          <source>Note that the reverse operation may result in producing surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation. For example, reversing &quot;\uDC00\uD800&quot; produces &quot;\uD800\uDC00&quot; which is a valid surrogate pair.</source>
          <target state="translated">역 동작으로 인해 수술 전에 쌍을 이루지 않은 낮은 대리모 및 높은 대리모가 된 대리 쌍이 생성 될 수 있습니다. 예를 들어, &quot;\ uDC00 \ uD800&quot;을 되 돌리면 유효한 대리 쌍인 &quot;\ uD800 \ uDC00&quot;이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e4e13275cdc9d405aa078b15a0e1145e8860cb07" translate="yes" xml:space="preserve">
          <source>Note that the rowHeader is calculated as part of the preferred width and the colHeader is calculated as part of the preferred size.</source>
          <target state="translated">rowHeader는 기본 너비의 일부로 계산되고 colHeader는 기본 크기의 일부로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="a41eae8474d8f24c456b27413e788c42d49a06d8" translate="yes" xml:space="preserve">
          <source>Note that the saved arguments (&lt;code&gt;a...&lt;/code&gt; in the pseudocode) cannot be modified by execution of the target, and so are passed unchanged from the caller to the cleanup, if it is invoked.</source>
          <target state="translated">저장된 인수 ( &lt;code&gt;a...&lt;/code&gt; 의사 코드에서 )는 대상을 실행하여 수정할 수 없으므로 호출 된 경우 호출자에서 정리로 변경되지 않고 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="52b7cb8a72f12d22f6db9a266b7085c69b8799b8" translate="yes" xml:space="preserve">
          <source>Note that the saved arguments (&lt;code&gt;a...&lt;/code&gt; in the pseudocode) cannot be modified by execution of the target, and so are passed unchanged from the caller to the handler, if the handler is invoked.</source>
          <target state="translated">저장된 인수 ( 의사 코드의 &lt;code&gt;a...&lt;/code&gt; )는 대상을 실행하여 수정할 수 없으므로 처리기가 호출 된 경우 호출자에서 처리기로 변경되지 않은 상태로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="35ac28fb0c33af926b3c96614b59ca95b53bf96d" translate="yes" xml:space="preserve">
          <source>Note that the second parameter tells the DBMS the data type of the value being set to &lt;code&gt;NULL&lt;/code&gt;. Some DBMSs require this information, so it is required in order to make code more portable.</source>
          <target state="translated">두 번째 매개 변수는 DBMS에 &lt;code&gt;NULL&lt;/code&gt; 로 설정되는 값의 데이터 유형을 알려줍니다 . 일부 DBMS에서는이 정보가 필요하므로 코드의 이식성을 높이기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4c59fc84e26aa8039886e3c6237e97460faa6515" translate="yes" xml:space="preserve">
          <source>Note that the size of the IV (block size) must be twice the word size. The bytes that constitute the IV are those between &lt;code&gt;iv[0]&lt;/code&gt; and &lt;code&gt;iv[2*(wordSize/8)-1]&lt;/code&gt; inclusive.</source>
          <target state="translated">IV의 크기 (블록 크기)는 단어 크기의 두 배 여야합니다. IV를 구성하는 바이트는 &lt;code&gt;iv[0]&lt;/code&gt; 과 &lt;code&gt;iv[2*(wordSize/8)-1]&lt;/code&gt; 사이의 바이트입니다 .</target>
        </trans-unit>
        <trans-unit id="699ae6a3370d747a9ba38ef57bdd053040288175" translate="yes" xml:space="preserve">
          <source>Note that the source and destination can be the same object.</source>
          <target state="translated">소스와 대상은 동일한 개체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a690030c09dd08a246f4a078af9b9af019c43774" translate="yes" xml:space="preserve">
          <source>Note that the standard list of cipher suite names may be found in the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#jsse-cipher-suite-names&quot;&gt; JSSE Cipher Suite Names&lt;/a&gt; section of the Java Cryptography Architecture Standard Algorithm Name Documentation. Providers may support cipher suite names not found in this list or might not use the recommended name for a certain cipher suite.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#jsse-cipher-suite-names&quot;&gt;Cipher Suite 이름&lt;/a&gt; 의 표준 목록은 Java Cryptography Architecture Standard Algorithm Name Documentation 의 JSSE Cipher Suite Names 섹션 에서 찾을 수 있습니다 . 공급자는이 목록에없는 암호 제품군 이름을 지원하거나 특정 암호 제품군에 권장되는 이름을 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="313fa080eea425f5c1ea2994d6e097a4038a67bf" translate="yes" xml:space="preserve">
          <source>Note that the start/endDTD events will appear within the start/endDocument events from ContentHandler and before the first &lt;a href=&quot;../contenthandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)&quot;&gt;&lt;code&gt;startElement&lt;/code&gt;&lt;/a&gt; event.</source>
          <target state="translated">start / endDTD 이벤트는 ContentHandler의 start / endDocument 이벤트와 첫 번째 &lt;a href=&quot;../contenthandler#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)&quot;&gt; &lt;code&gt;startElement&lt;/code&gt; &lt;/a&gt; 이벤트 전에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="54e83ad4a1b1d311acafc15f34a16c65ba816fc1" translate="yes" xml:space="preserve">
          <source>Note that the subclass &lt;code&gt;Menu&lt;/code&gt; overrides this behavior and does not send any event to the frame until one of its subitems is selected.</source>
          <target state="translated">하위 클래스 &lt;code&gt;Menu&lt;/code&gt; 는이 동작을 재정의하고 하위 항목 중 하나가 선택 될 때까지 프레임에 이벤트를 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="726c3ca85cff8c01c9c25cb65210c4d8df3fb97c" translate="yes" xml:space="preserve">
          <source>Note that the system URI (http://java.sun.com/dtd/preferences.dtd) is</source>
          <target state="translated">시스템 URI (http://java.sun.com/dtd/preferences.dtd)는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ac7933b38c2448d212dead7e2f156330da66016" translate="yes" xml:space="preserve">
          <source>Note that the system URI (http://java.sun.com/dtd/properties.dtd) is</source>
          <target state="translated">시스템 URI (http://java.sun.com/dtd/properties.dtd)는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db0199ba9005778443a3b03d4210df3f6d5e06f3" translate="yes" xml:space="preserve">
          <source>Note that the tempo factor cannot be adjusted when external synchronization is used. In that situation, &lt;code&gt;setTempoFactor&lt;/code&gt; always sets the tempo factor to 1.0.</source>
          <target state="translated">외부 동기화를 사용하는 경우 템포 팩터를 조정할 수 없습니다. 이 경우 &lt;code&gt;setTempoFactor&lt;/code&gt; 는 항상 템포 팩터를 1.0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="fef5913a6beb3d5aae70d81792ea2e59e94166eb" translate="yes" xml:space="preserve">
          <source>Note that the test arguments (&lt;code&gt;a...&lt;/code&gt; in the pseudocode) cannot be modified by execution of the test, and so are passed unchanged from the caller to the target or fallback as appropriate.</source>
          <target state="translated">테스트 인수 ( 의사 코드에서 &lt;code&gt;a...&lt;/code&gt; )는 테스트를 실행하여 수정할 수 없으므로 호출자에서 대상 또는 변경으로 변경없이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6e14e664b9f51652bb936848986e286261484ce2" translate="yes" xml:space="preserve">
          <source>Note that the thrown argument is stored in the LogRecord thrown property, rather than the LogRecord parameters property. Thus it is processed specially by output Formatters and is not treated as a formatting parameter to the LogRecord message property.</source>
          <target state="translated">throw 된 인수는 LogRecord 매개 변수 속성이 아니라 LogRecord thrown 속성에 저장됩니다. 따라서 출력 포맷터에서 특수하게 처리되며 LogRecord 메시지 특성에 대한 형식화 매개 변수로 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="166cbdfdccd8403b15bc4e6d3f70208a1bc5a81c" translate="yes" xml:space="preserve">
          <source>Note that the unit's &lt;code&gt;between&lt;/code&gt; method must only be invoked if the two temporal objects have exactly the same type evaluated by &lt;code&gt;getClass()&lt;/code&gt;.</source>
          <target state="translated">두 임시 객체가 &lt;code&gt;getClass()&lt;/code&gt; 의해 정확히 동일한 유형을 평가 한 경우에만 유닛 &lt;code&gt;between&lt;/code&gt; 메소드를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="da6ac505f87ae2298d762448c0d6b681899cacca" translate="yes" xml:space="preserve">
          <source>Note that the units used are bytes, but will always correspond to an integral number of sample frames of audio data.</source>
          <target state="translated">사용되는 단위는 바이트이지만 항상 오디오 데이터의 샘플 프레임의 정수에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d5ce67a9dd43304ad2b44fdf81b4a8392939c09c" translate="yes" xml:space="preserve">
          <source>Note that the use of schema location hints introduces a vulnerability to denial-of-service attacks.</source>
          <target state="translated">스키마 위치 힌트를 사용하면 서비스 거부 공격에 취약성이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79a718f1a2db800292680ea5dcf70340d28d0964" translate="yes" xml:space="preserve">
          <source>Note that the use of this class is optional.</source>
          <target state="translated">이 클래스의 사용은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="b5fb9e083dafa947687d5f765039d7683e6b855d" translate="yes" xml:space="preserve">
          <source>Note that the use of this method is discouraged because its behavior is platform dependent. Instead we recommend the use of &lt;a href=&quot;#requestFocusInWindow()&quot;&gt;&lt;code&gt;requestFocusInWindow()&lt;/code&gt;&lt;/a&gt;. If you would like more information on focus, see &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt; How to Use the Focus Subsystem&lt;/a&gt;, a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.</source>
          <target state="translated">이 메서드의 동작은 플랫폼에 따라 다르므로 사용하지 않는 것이 좋습니다. 대신 &lt;a href=&quot;#requestFocusInWindow()&quot;&gt; &lt;code&gt;requestFocusInWindow()&lt;/code&gt; &lt;/a&gt; 사용을 권장합니다 . 포커스에 대한 자세한 내용 은 &lt;em&gt;The Java Tutorial&lt;/em&gt; 의 섹션 인 &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;How to Use the Focus Subsystem을&lt;/a&gt; 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e8c03652bfc5259fa04bb9921f963eae3e81833" translate="yes" xml:space="preserve">
          <source>Note that the use of this method is discouraged because its behavior is platform dependent. Instead we recommend the use of &lt;a href=&quot;#requestFocusInWindow(boolean)&quot;&gt;&lt;code&gt;requestFocusInWindow(boolean)&lt;/code&gt;&lt;/a&gt;. If you would like more information on focus, see &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt; How to Use the Focus Subsystem&lt;/a&gt;, a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.</source>
          <target state="translated">이 메서드의 동작은 플랫폼에 따라 다르므로 사용하지 않는 것이 좋습니다. 대신 &lt;a href=&quot;#requestFocusInWindow(boolean)&quot;&gt; &lt;code&gt;requestFocusInWindow(boolean)&lt;/code&gt; &lt;/a&gt; 사용을 권장합니다 . 포커스에 대한 자세한 내용 은 &lt;em&gt;The Java Tutorial&lt;/em&gt; 의 섹션 인 &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;How to Use the Focus Subsystem을&lt;/a&gt; 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bdd74f817df9b83efa8db0aee029011ef615673c" translate="yes" xml:space="preserve">
          <source>Note that the use of unique ids to avoid conflicts is only guaranteed to work reliably when using a local disk file system.</source>
          <target state="translated">충돌을 피하기 위해 고유 ID를 사용하면 로컬 디스크 파일 시스템을 사용할 때만 안정적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="45bef0511d5530d6f1ca1301d778c9ab6fdb30d5" translate="yes" xml:space="preserve">
          <source>Note that the value (data) of the &lt;code&gt;TIFFField&lt;/code&gt; will always be the actual field value regardless of the number of bytes required for that value. This is the case despite the fact that the TIFF</source>
          <target state="translated">&lt;code&gt;TIFFField&lt;/code&gt; 의 값 (데이터)은 해당 값에 필요한 바이트 수에 관계없이 항상 실제 필드 값입니다. 이것은 TIFF가</target>
        </trans-unit>
        <trans-unit id="55c86c9bf088e0f798106b89373ada491d3e4464" translate="yes" xml:space="preserve">
          <source>Note that the value is not authenticated, and should not be relied upon.</source>
          <target state="translated">이 값은 인증되지 않았으므로 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7762620ccd17b40256538b7163c3c26067ae36b5" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;Math.ceil(x)&lt;/code&gt; is exactly the value of &lt;code&gt;-Math.floor(-x)&lt;/code&gt;.</source>
          <target state="translated">값 유의 &lt;code&gt;Math.ceil(x)&lt;/code&gt; 정확히의 값 &lt;code&gt;-Math.floor(-x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53fceacdee3ee3f5b8c8a4c8b401fcb821b40df9" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;StrictMath.ceil(x)&lt;/code&gt; is exactly the value of &lt;code&gt;-StrictMath.floor(-x)&lt;/code&gt;.</source>
          <target state="translated">값 유의 &lt;code&gt;StrictMath.ceil(x)&lt;/code&gt; 정확히의 값 &lt;code&gt;-StrictMath.floor(-x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04ba68f671e05828e7ea3934d37dff9bb5c6a9a7" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;visibleRect&lt;/code&gt; must be the equal to &lt;code&gt;this.getVisibleRect()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;visibleRect&lt;/code&gt; 의 값은 &lt;code&gt;this.getVisibleRect()&lt;/code&gt; 와 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="26e834aa2e38626e6191c62e7f86b13a2c6d3982" translate="yes" xml:space="preserve">
          <source>Note that the values in the &lt;code&gt;defaultValue&lt;/code&gt;, &lt;code&gt;
 legalValues&lt;/code&gt;, &lt;code&gt;maxValue&lt;/code&gt;, and &lt;code&gt;minValue&lt;/code&gt; fields should be consistent with the type returned by the &lt;code&gt;getType()&lt;/code&gt; method for the associated &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; or &lt;code&gt;
 MBeanParameterInfo&lt;/code&gt;. For MXBeans, this means that they should be of the mapped Java type, called &lt;em&gt;opendata&lt;/em&gt;(J) in the &lt;a href=&quot;mxbean#mapping-rules&quot;&gt;MXBean type mapping rules&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defaultValue&lt;/code&gt; , &lt;code&gt; legalValues&lt;/code&gt; , &lt;code&gt;maxValue&lt;/code&gt; 및 &lt;code&gt;minValue&lt;/code&gt; 필드 의 값 은 연관된 &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; 또는 &lt;code&gt; MBeanParameterInfo&lt;/code&gt; 에 대해 &lt;code&gt;getType()&lt;/code&gt; 메소드가 리턴 한 유형과 일치해야합니다 . MXBean의 경우 이는 &lt;a href=&quot;mxbean#mapping-rules&quot;&gt;MXBean 유형 매핑 규칙&lt;/a&gt; 에서 &lt;em&gt;opendata&lt;/em&gt; (J) 라고하는 매핑 된 Java 유형이어야 함을 의미합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db639c8216139e803d890c9c06f8d4f62c5058ce" translate="yes" xml:space="preserve">
          <source>Note that the values in the &lt;code&gt;defaultValue&lt;/code&gt;, &lt;code&gt;legalValues&lt;/code&gt;, &lt;code&gt;maxValue&lt;/code&gt;, and &lt;code&gt;minValue&lt;/code&gt; fields should be consistent with the type returned by the &lt;code&gt;getType()&lt;/code&gt; method for the associated &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; or &lt;code&gt;MBeanParameterInfo&lt;/code&gt;. For MXBeans, this means that they should be of the mapped Java type, called &lt;em&gt;opendata&lt;/em&gt;(J) in the &lt;a href=&quot;mxbean#mapping-rules&quot;&gt;MXBean type mapping rules&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;defaultValue&lt;/code&gt; , &lt;code&gt;legalValues&lt;/code&gt; , &lt;code&gt;maxValue&lt;/code&gt; 및 &lt;code&gt;minValue&lt;/code&gt; 필드 의 값 은 연관된 &lt;code&gt;MBeanAttributeInfo&lt;/code&gt; 또는 &lt;code&gt;MBeanParameterInfo&lt;/code&gt; 에 대한 &lt;code&gt;getType()&lt;/code&gt; 메소드가 리턴 한 유형과 일치해야합니다 . MXBean의 경우 이는 &lt;a href=&quot;mxbean#mapping-rules&quot;&gt;MXBean 유형 맵핑 규칙&lt;/a&gt; 에서 &lt;em&gt;opendata&lt;/em&gt; (J) 라고하는 맵핑 된 Java 유형이어야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8526fec3aa3f6a400bd9c8544b805eb2452f38af" translate="yes" xml:space="preserve">
          <source>Note that the way in which these system colors are applied to GUI objects may vary slightly from platform to platform since GUI objects may be rendered differently on each platform.</source>
          <target state="translated">이러한 시스템 색상이 GUI 개체에 적용되는 방식은 각 플랫폼에서 GUI 개체가 다르게 렌더링 될 수 있으므로 플랫폼마다 약간 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b3075508a7662835798f320ab0d117f1fb75c35" translate="yes" xml:space="preserve">
          <source>Note that there are cases where two &lt;code&gt;Duration&lt;/code&gt;s are &quot;incomparable&quot; to each other, like one month and 30 days. For example,</source>
          <target state="translated">한 달 및 30 일과 같이 두 개의 &lt;code&gt;Duration&lt;/code&gt; 이 서로 &quot;비교할 수없는&quot;경우가 있습니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="b1f0cea8ee87ff8ddd478c0549d5ffcbb19c336f" translate="yes" xml:space="preserve">
          <source>Note that there are two differences between the following code fragment and the previous one. First, the method &lt;code&gt;setMaxRows&lt;/code&gt; is not called, so there is no limit set for the number of rows that</source>
          <target state="translated">다음 코드 조각과 이전 코드 조각 사이에는 두 가지 차이점이 있습니다. 먼저 &lt;code&gt;setMaxRows&lt;/code&gt; 메소드 가 호출되지 않으므로 행 수에 대한 제한 설정이 없습니다.</target>
        </trans-unit>
        <trans-unit id="06910af6b38a5034f49d0f9e7e0b87247ac85575" translate="yes" xml:space="preserve">
          <source>Note that there is an asymmetry in this library: &lt;a href=&quot;#getPrefix(java.lang.String)&quot;&gt;&lt;code&gt;getPrefix&lt;/code&gt;&lt;/a&gt; will not return the &quot;&quot; prefix, even if you have declared a default element namespace. To check for a default namespace, you have to look it up explicitly using &lt;a href=&quot;#getURI(java.lang.String)&quot;&gt;&lt;code&gt;getURI&lt;/code&gt;&lt;/a&gt;. This asymmetry exists to make it easier to look up prefixes for attribute names, where the default prefix is not allowed.</source>
          <target state="translated">이 라이브러리에는 비대칭이 있습니다. &lt;a href=&quot;#getPrefix(java.lang.String)&quot;&gt; &lt;code&gt;getPrefix&lt;/code&gt; &lt;/a&gt; 는 기본 요소 네임 스페이스를 선언 한 경우에도 &quot;&quot;접두사를 반환하지 않습니다. 기본 네임 스페이스를 확인하려면 &lt;a href=&quot;#getURI(java.lang.String)&quot;&gt; &lt;code&gt;getURI&lt;/code&gt; 를&lt;/a&gt; 사용하여 명시 적으로 조회해야합니다 . 이 비대칭은 기본 접두사가 허용되지 않는 속성 이름의 접두사를보다 쉽게 ​​찾을 수 있도록하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="9743c906150d32aff6aed6f7527337a2c3554e87" translate="yes" xml:space="preserve">
          <source>Note that there is no &lt;code&gt;read&lt;/code&gt; method that takes a filename as a &lt;code&gt;String&lt;/code&gt;; use this method instead after creating a &lt;code&gt;File&lt;/code&gt; from the filename.</source>
          <target state="translated">파일 이름을 &lt;code&gt;String&lt;/code&gt; 로 취하는 &lt;code&gt;read&lt;/code&gt; 메소드 는 없습니다 . &lt;code&gt;File&lt;/code&gt; 이름에서 파일 을 만든 후 대신이 방법을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a1dd6a52f016e5e16c70d9a0d4d6b28f6bfe694" translate="yes" xml:space="preserve">
          <source>Note that there may be more than one matching method in a class because while the Java language forbids a class to declare multiple methods with the same signature but different return types, the Java virtual machine does not. This increased flexibility in the virtual machine can be used to implement various language features. For example, covariant returns can be implemented with &lt;a href=&quot;reflect/method#isBridge--&quot;&gt;bridge methods&lt;/a&gt;; the bridge method and the method being overridden would have the same signature but different return types.</source>
          <target state="translated">Java 언어는 클래스가 동일한 서명이지만 리턴 유형이 다른 여러 메소드를 선언하는 것을 금지하지만 Java 가상 머신은 그렇지 않기 때문에 클래스에 둘 이상의 일치하는 메소드가있을 수 있습니다. 가상 머신의 유연성 향상으로 다양한 언어 기능을 구현할 수 있습니다. 예를 들어, 공변량 리턴은 &lt;a href=&quot;reflect/method#isBridge--&quot;&gt;브리지 방법&lt;/a&gt; 으로 구현할 수 있습니다 . 브릿지 메소드와 대체되는 메소드는 동일한 서명이지만 리턴 유형이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cc0e37e1c50893d6f5604c0242e70dc21e6a2f25" translate="yes" xml:space="preserve">
          <source>Note that these conditions apply to both OCSP and CRLs, and unless the &lt;code&gt;NO_FALLBACK&lt;/code&gt; option is set, the revocation check is allowed to succeed only if both mechanisms fail under one of the conditions as stated above. Exceptions that cause the network errors are ignored but can be later retrieved by calling the &lt;a href=&quot;pkixrevocationchecker#getSoftFailExceptions()&quot;&gt;&lt;code&gt;getSoftFailExceptions&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이러한 조건은 OCSP 및 CRL 모두에 적용되며 &lt;code&gt;NO_FALLBACK&lt;/code&gt; 옵션이 설정 되지 않은 경우 위에 언급 된 조건 중 하나에서 두 메커니즘이 모두 실패하는 경우에만 해지 검사가 성공할 수 있습니다. 네트워크 오류를 유발하는 예외는 무시되지만 나중에 &lt;a href=&quot;pkixrevocationchecker#getSoftFailExceptions()&quot;&gt; &lt;code&gt;getSoftFailExceptions&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ede1c71c79d19b7fc51ad715288dc33776ee674" translate="yes" xml:space="preserve">
          <source>Note that these conditions apply to both OCSP and CRLs, and unless the &lt;code&gt;NO_FALLBACK&lt;/code&gt; option is set, the revocation check is allowed to succeed only if both mechanisms fail under one of the conditions as stated above. Exceptions that cause the network errors are ignored but can be later retrieved by calling the &lt;a href=&quot;pkixrevocationchecker#getSoftFailExceptions--&quot;&gt;&lt;code&gt;getSoftFailExceptions&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이러한 조건은 OCSP 및 CRL 모두에 적용되며, &lt;code&gt;NO_FALLBACK&lt;/code&gt; 옵션이 설정 되어 있지 않으면 두 메커니즘 모두 위에서 언급 한 조건 중 하나에서 실패 할 경우에만 해지 확인이 성공할 수 있습니다. 네트워크 오류를 발생시키는 예외는 무시되지만 나중에 &lt;a href=&quot;pkixrevocationchecker#getSoftFailExceptions--&quot;&gt; &lt;code&gt;getSoftFailExceptions&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ceef1399d6e40b51dfa976632229489886791713" translate="yes" xml:space="preserve">
          <source>Note that these interfaces are intended only for key implementations whose key material is accessible and available. These interfaces are not intended for key implementations whose key material resides in inaccessible, protected storage (such as in a hardware device).</source>
          <target state="translated">이러한 인터페이스는 주요 자료에 액세스하고 사용할 수있는 주요 구현에만 사용됩니다. 이러한 인터페이스는 주요 자료가 액세스 할 수없는 보호 된 저장소 (예 : 하드웨어 장치)에있는 주요 구현을위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e3778fef4aa1c275c5abbe241cb85d468270b18f" translate="yes" xml:space="preserve">
          <source>Note that this &lt;code&gt;popup&lt;/code&gt; must not be added to any parent before or after it is set on the tray icon. If you add it to some parent, the &lt;code&gt;popup&lt;/code&gt; may be removed from that parent.</source>
          <target state="translated">이 &lt;code&gt;popup&lt;/code&gt; 은 트레이 아이콘에 설정되기 전이나 후에 어떤 부모에도 추가되어서는 안됩니다. 일부 부모에 추가하면 해당 부모에서 &lt;code&gt;popup&lt;/code&gt; 이 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="952655a12627e2e815438c884d9cc296cc9858d2" translate="yes" xml:space="preserve">
          <source>Note that this Comparator does &lt;em&gt;not&lt;/em&gt; take locale into account, and will result in an unsatisfactory ordering for certain locales. The &lt;a href=&quot;../text/collator&quot;&gt;&lt;code&gt;Collator&lt;/code&gt;&lt;/a&gt; class provides locale-sensitive comparison.</source>
          <target state="translated">이 비교기는 로케일을 고려 하지 &lt;em&gt;않으며&lt;/em&gt; 특정 로케일에 대해 만족스럽지 못한 순서를 초래합니다. &lt;a href=&quot;../text/collator&quot;&gt; &lt;code&gt;Collator&lt;/code&gt; &lt;/a&gt; 클래스는 로케일에 의존하는 비교를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="eb9957cf33f666608bcbef3daaa0fd7de1c946de" translate="yes" xml:space="preserve">
          <source>Note that this Comparator does &lt;em&gt;not&lt;/em&gt; take locale into account, and will result in an unsatisfactory ordering for certain locales. The java.text package provides &lt;em&gt;Collators&lt;/em&gt; to allow locale-sensitive ordering.</source>
          <target state="translated">이 비교기는 로케일을 고려 하지 &lt;em&gt;않으므로&lt;/em&gt; 특정 로케일에 대한 순서가 만족스럽지 않습니다. java.text 패키지는 로케일 구분 순서를 허용 하는 &lt;em&gt;Collators&lt;/em&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="ad4860a999c34686c221743d1d993625c50ea204" translate="yes" xml:space="preserve">
          <source>Note that this class does not override any of the implementations from the &lt;code&gt;AbstractCollection&lt;/code&gt; class. It merely adds implementations for &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hashCode&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 &lt;code&gt;AbstractCollection&lt;/code&gt; 클래스 의 구현을 재정의하지 않습니다 . &lt;code&gt;equals&lt;/code&gt; 및 &lt;code&gt;hashCode&lt;/code&gt; 구현 만 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="929c9e03f915978aaf48314d9a623a4a76189102" translate="yes" xml:space="preserve">
          <source>Note that this class does not perform any validation on specified parameters. Thus, the specified values are returned directly even if they are null.</source>
          <target state="translated">이 클래스는 지정된 매개 변수에 대한 유효성 검사를 수행하지 않습니다. 따라서 지정된 값은 null 인 경우에도 직접 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e621b57163b13d0a775297f885fb1d7287c503c" translate="yes" xml:space="preserve">
          <source>Note that this class does not provide a means for obtaining the tables found in a stream. These may be extracted from a stream by consulting the IIOMetadata object returned by the reader.</source>
          <target state="translated">이 클래스는 스트림에서 찾은 테이블을 얻는 방법을 제공하지 않습니다. 이들은 독자에 의해 리턴 된 IIOMetadata 오브젝트를 참조하여 스트림에서 추출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce96925db3fe4b1b1bb845ef36f30eaac160b9d" translate="yes" xml:space="preserve">
          <source>Note that this class is abstract and extends from &lt;code&gt;KeyPairGeneratorSpi&lt;/code&gt; for historical reasons. Application developers should only take notice of the methods defined in this &lt;code&gt;KeyPairGenerator&lt;/code&gt; class; all the methods in the superclass are intended for cryptographic service providers who wish to supply their own implementations of key pair generators.</source>
          <target state="translated">이 클래스는 추상적이며 역사적 이유로 &lt;code&gt;KeyPairGeneratorSpi&lt;/code&gt; 에서 확장됩니다 . 응용 프로그램 개발자는이 &lt;code&gt;KeyPairGenerator&lt;/code&gt; 클래스에 정의 된 메소드 만주의해야 합니다. 수퍼 클래스의 모든 메소드는 고유 한 키 쌍 생성기 구현을 제공하려는 암호화 서비스 제공자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1258f1977d0984bd47aa412f3ee01486b4648771" translate="yes" xml:space="preserve">
          <source>Note that this class is abstract and extends from &lt;code&gt;MessageDigestSpi&lt;/code&gt; for historical reasons. Application developers should only take notice of the methods defined in this &lt;code&gt;MessageDigest&lt;/code&gt; class; all the methods in the superclass are intended for cryptographic service providers who wish to supply their own implementations of message digest algorithms.</source>
          <target state="translated">이 클래스는 추상적이며 역사적 이유로 &lt;code&gt;MessageDigestSpi&lt;/code&gt; 에서 확장됩니다 . 응용 프로그램 개발자는이 &lt;code&gt;MessageDigest&lt;/code&gt; 클래스에 정의 된 메소드 만주의해야 합니다. 수퍼 클래스의 모든 메소드는 자체 메시지 요약 알고리즘 구현을 제공하려는 암호화 서비스 제공자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ae9d9042b4412cecbe9eecb37942945baf66350a" translate="yes" xml:space="preserve">
          <source>Note that this class is abstract and extends from &lt;code&gt;SignatureSpi&lt;/code&gt; for historical reasons. Application developers should only take notice of the methods defined in this &lt;code&gt;Signature&lt;/code&gt; class; all the methods in the superclass are intended for cryptographic service providers who wish to supply their own implementations of digital signature algorithms.</source>
          <target state="translated">이 클래스는 추상적이며 역사적 이유로 &lt;code&gt;SignatureSpi&lt;/code&gt; 에서 확장됩니다 . 응용 프로그램 개발자는이 &lt;code&gt;Signature&lt;/code&gt; 클래스에 정의 된 메소드 만주의해야합니다 . 수퍼 클래스의 모든 메소드는 자체 디지털 서명 알고리즘 구현을 제공하려는 암호화 서비스 제공자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="bca01d41c7ee09c177e42cb9065cae541c703f52" translate="yes" xml:space="preserve">
          <source>Note that this class is applicable to both ticket granting tickets and other regular service tickets. A ticket granting ticket is just a special case of a more generalized service ticket.</source>
          <target state="translated">이 클래스는 티켓 부여 티켓 및 기타 일반 서비스 티켓 모두에 적용됩니다. 티켓 부여 티켓은보다 일반화 된 서비스 티켓의 특별한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="47e75f75611f69d79b42af2071cccd1178888747" translate="yes" xml:space="preserve">
          <source>Note that this class is named &lt;code&gt;XMLObject&lt;/code&gt; rather than &lt;code&gt;Object&lt;/code&gt; to avoid naming clashes with the existing &lt;a href=&quot;../../../../../java.base/java/lang/object&quot;&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">이 클래스는 기존 &lt;a href=&quot;../../../../../java.base/java/lang/object&quot;&gt; &lt;code&gt;java.lang.Object&lt;/code&gt; &lt;/a&gt; 클래스 와 이름 충돌을 피하기 위해 &lt;code&gt;Object&lt;/code&gt; 가 아닌 &lt;code&gt;XMLObject&lt;/code&gt; 로 명명 됩니다.</target>
        </trans-unit>
        <trans-unit id="bb10025086af2ee7b0b9c8525e6f26e484d89376" translate="yes" xml:space="preserve">
          <source>Note that this class is named &lt;code&gt;XMLSignature&lt;/code&gt; rather than &lt;code&gt;Signature&lt;/code&gt; to avoid naming clashes with the existing &lt;a href=&quot;../../../../../java.base/java/security/signature&quot;&gt;&lt;code&gt;java.security.Signature&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">이 클래스는 기존 &lt;a href=&quot;../../../../../java.base/java/security/signature&quot;&gt; &lt;code&gt;java.security.Signature&lt;/code&gt; &lt;/a&gt; 클래스 와 이름 충돌을 피하기 위해 &lt;code&gt;Signature&lt;/code&gt; 이 아니라 &lt;code&gt;XMLSignature&lt;/code&gt; 로 명명 됩니다.</target>
        </trans-unit>
        <trans-unit id="2b321d008fe97a4a046429d819164edd9d49d391" translate="yes" xml:space="preserve">
          <source>Note that this class is optimized for the use case where most elements do not contain Namespace declarations: if the same prefix/URI mapping is repeated for each context (for example), this class will be somewhat less efficient.</source>
          <target state="translated">이 클래스는 대부분의 요소가 네임 스페이스 선언을 포함하지 않는 사용 사례에 최적화되어 있습니다. 예를 들어 각 컨텍스트에 대해 동일한 접두사 / URI 매핑이 반복되는 경우이 클래스는 다소 덜 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="d1a9f9d3aae3908c0e374aea8150d2ed6428cc48" translate="yes" xml:space="preserve">
          <source>Note that this class reuses several classes from the SAX API. This does not require that the implementor of the underlying DOM implementation use a SAX parser to parse XML document into a &lt;code&gt;Document&lt;/code&gt;. It merely requires that the implementation communicate with the application using these existing APIs.</source>
          <target state="translated">이 클래스는 SAX API의 여러 클래스를 재사용합니다. 기본 DOM 구현의 구현자가 SAX 파서를 사용하여 XML 문서를 &lt;code&gt;Document&lt;/code&gt; 로 구문 분석 할 필요는 없습니다 . 구현시 이러한 기존 API를 사용하여 애플리케이션과 통신하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="520d821f07468edec20ba3827c6db570a09bb7f7" translate="yes" xml:space="preserve">
          <source>Note that this class subclasses from the &lt;a href=&quot;../image&quot;&gt;&lt;code&gt;Image&lt;/code&gt;&lt;/a&gt; class, which includes methods that take an &lt;a href=&quot;imageobserver&quot;&gt;&lt;code&gt;ImageObserver&lt;/code&gt;&lt;/a&gt; parameter for asynchronous notifications as information is received from a potential &lt;a href=&quot;imageproducer&quot;&gt;&lt;code&gt;ImageProducer&lt;/code&gt;&lt;/a&gt;. Since this &lt;code&gt;VolatileImage&lt;/code&gt; is not loaded from an asynchronous source, the various methods that take an &lt;code&gt;ImageObserver&lt;/code&gt; parameter will behave as if the data has already been obtained from the &lt;code&gt;ImageProducer&lt;/code&gt;. Specifically, this means that the return values from such methods will never indicate that the information is not yet available and the &lt;code&gt;ImageObserver&lt;/code&gt; used in such methods will never need to be recorded for an asynchronous callback notification.</source>
          <target state="translated">이 클래스 는 잠재적 인 &lt;a href=&quot;imageproducer&quot;&gt; &lt;code&gt;ImageProducer&lt;/code&gt; &lt;/a&gt; 로부터 정보가 수신 될 때 비동기 알림을 위해 &lt;a href=&quot;imageobserver&quot;&gt; &lt;code&gt;ImageObserver&lt;/code&gt; &lt;/a&gt; 매개 변수를 사용하는 메소드를 포함 하는 &lt;a href=&quot;../image&quot;&gt; &lt;code&gt;Image&lt;/code&gt; &lt;/a&gt; 클래스 에서 하위 클래스입니다 . 이 &lt;code&gt;VolatileImage&lt;/code&gt; 는 비동기 소스에서로드되지 않으므로 &lt;code&gt;ImageObserver&lt;/code&gt; 매개 변수 를 사용하는 다양한 메소드 는 &lt;code&gt;ImageProducer&lt;/code&gt; 에서 이미 데이터를 얻은 것처럼 작동합니다 . 특히 이는 이러한 메서드의 반환 값이 정보를 아직 사용할 수 없음을 나타내지 않으며 이러한 메서드에 사용 된 &lt;code&gt;ImageObserver&lt;/code&gt; 가 비동기 콜백 알림에 대해 기록 될 필요가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ed299b560d1f05b11ce8d4135192783c2c148f34" translate="yes" xml:space="preserve">
          <source>Note that this constructor is &quot;protected&quot; to allow subclassing. In general clients of logging should use one of the constant Level objects such as SEVERE or FINEST. However, if clients need to add new logging levels, they may subclass Level and define new constants.</source>
          <target state="translated">이 생성자는 &quot;클래스&quot;되어 서브 클래 싱을 허용합니다. 일반적으로 로깅 클라이언트는 SEVERE 또는 FINEST와 같은 상수 레벨 오브젝트 중 하나를 사용해야합니다. 그러나 클라이언트가 새 로깅 레벨을 추가해야하는 경우 레벨을 서브 클래스 화하고 새 상수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2da2d9d25ff3d441e31a0ef5d2f344c3d4c6f7f0" translate="yes" xml:space="preserve">
          <source>Note that this constructor only stores references to the public and private key components in the generated key pair. This is safe, because &lt;code&gt;Key&lt;/code&gt; objects are immutable.</source>
          <target state="translated">이 생성자는 생성 된 키 쌍의 공개 및 개인 키 구성 요소에 대한 참조 만 저장합니다. &lt;code&gt;Key&lt;/code&gt; 객체는 불변 이므로 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="d1e3eafd89be7fc614d269bfd221c748478bfe9b" translate="yes" xml:space="preserve">
          <source>Note that this definition permits &lt;code&gt;null&lt;/code&gt; elements at any depth.</source>
          <target state="translated">이 정의는 모든 깊이에서 &lt;code&gt;null&lt;/code&gt; 요소를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="9f0f633aad5e50d26b0994bd03344b8c6fd53dea" translate="yes" xml:space="preserve">
          <source>Note that this exception does not always indicate that an object has been concurrently modified by a</source>
          <target state="translated">이 예외가 항상 개체가 동시에 개체를 수정했음을 나타내는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="40b84543e4934fdd06df621a721ae6d97b481b6a" translate="yes" xml:space="preserve">
          <source>Note that this exception may be used when undefined type variables are accessed as well as when types (e.g., classes, interfaces or annotation types) are loaded. In particular, this exception can be thrown by the &lt;a href=&quot;reflect/annotatedelement&quot;&gt;API used to read annotations reflectively&lt;/a&gt;.</source>
          <target state="translated">이 예외는 정의되지 않은 유형 변수에 액세스 할 때뿐만 아니라 유형 (예 : 클래스, 인터페이스 또는 주석 유형)이로드 될 때 사용될 수 있습니다. 특히이 예외는 &lt;a href=&quot;reflect/annotatedelement&quot;&gt;주석을 반사적으로 읽는 데 사용되는 API에&lt;/a&gt; 의해 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7f4d54ec9feeae5b3023107ca73e81fa932d8fd" translate="yes" xml:space="preserve">
          <source>Note that this feature does &lt;em&gt;NOT&lt;/em&gt; affect the way a &lt;a href=&quot;validatorhandler&quot;&gt;&lt;code&gt;ValidatorHandler&lt;/code&gt;&lt;/a&gt; receives SAX events. It merely changes the way it augments SAX events.</source>
          <target state="translated">이 기능은 &lt;em&gt; NOT&lt;/em&gt;&lt;a href=&quot;validatorhandler&quot;&gt; &lt;code&gt;ValidatorHandler&lt;/code&gt; 가&lt;/a&gt; SAX 이벤트를 수신 하는 방식에 영향을 . SAX 이벤트를 증가시키는 방식 만 변경합니다.</target>
        </trans-unit>
        <trans-unit id="044b07da3c160d6dd45c096ab357368dcf06ea39" translate="yes" xml:space="preserve">
          <source>Note that this field is relevant only to certain events generated by data lines, such as &lt;code&gt;START&lt;/code&gt; and &lt;code&gt;STOP&lt;/code&gt;. For events generated by lines that do not count sample frames, and for any other events for which this value is not known, the position value should be &lt;a href=&quot;audiosystem#NOT_SPECIFIED&quot;&gt;&lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 필드는 &lt;code&gt;START&lt;/code&gt; 및 &lt;code&gt;STOP&lt;/code&gt; 과 같은 데이터 라인에 의해 생성 된 특정 이벤트에만 관련됩니다 . 샘플 프레임을 계산하지 않는 라인에 의해 생성 된 이벤트 및이 값을 알 수없는 다른 이벤트의 경우 위치 값은 &lt;a href=&quot;audiosystem#NOT_SPECIFIED&quot;&gt; &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; &lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="7c6dc2724c4f696c95471b6371b96bccbec1ff22" translate="yes" xml:space="preserve">
          <source>Note that this implementation throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if the &lt;code&gt;entrySet&lt;/code&gt; does not support the &lt;code&gt;clear&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;entrySet&lt;/code&gt; 이 &lt;code&gt;clear&lt;/code&gt; 작업을 지원하지 않으면 이 구현은 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="cb5512e594933521dc30b9b992079194b3c8a5f9" translate="yes" xml:space="preserve">
          <source>Note that this implementation throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if the &lt;code&gt;entrySet&lt;/code&gt; iterator does not support the &lt;code&gt;remove&lt;/code&gt; method and this map contains a mapping for the specified key.</source>
          <target state="translated">&lt;code&gt;entrySet&lt;/code&gt; 반복자가 &lt;code&gt;remove&lt;/code&gt; 메소드를 지원하지 않고이 맵에 지정된 키의 매핑이 포함되어있는 경우, 이 구현은 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="975f8928795c3f5c020f5ef1b74be06f52b23843" translate="yes" xml:space="preserve">
          <source>Note that this implementation throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if the iterator returned by this collection's iterator method does not implement the &lt;code&gt;remove&lt;/code&gt; method and this collection contains the specified object.</source>
          <target state="translated">이 콜렉션의 반복자 메소드에 의해 리턴 된 반복자가 &lt;code&gt;remove&lt;/code&gt; 메소드를 구현하지 않고이 콜렉션에 지정된 오브젝트가 포함되는 경우, 이 구현은 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 Throw 합니다.</target>
        </trans-unit>
        <trans-unit id="db212b8c2dab328f5c6b17a946f2fe81565c10f0" translate="yes" xml:space="preserve">
          <source>Note that this implementation throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if this map does not support the &lt;code&gt;put&lt;/code&gt; operation and the specified map is nonempty.</source>
          <target state="translated">이 맵이 &lt;code&gt;put&lt;/code&gt; 조작을 지원하지 않고 , 지정된 맵이 비어 있지 않은 경우 ,이 구현은 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="e84e2a2f4a4d926bb901360c6bdfe8682010e5a8" translate="yes" xml:space="preserve">
          <source>Note that this implementation throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; unless &lt;a href=&quot;#add(int,E)&quot;&gt;&lt;code&gt;add(int, E)&lt;/code&gt;&lt;/a&gt; is overridden.</source>
          <target state="translated">이 구현에서는 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생합니다. 하지 않는 한을&lt;a href=&quot;#add(int,E)&quot;&gt; &lt;code&gt;add(int, E)&lt;/code&gt; &lt;/a&gt; 가 재정의.</target>
        </trans-unit>
        <trans-unit id="8df6e86eb00d3a73d7d1d698efbe5ac2a73104b2" translate="yes" xml:space="preserve">
          <source>Note that this implementation throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; unless &lt;a href=&quot;abstractlist#add-int-E-&quot;&gt;&lt;code&gt;add(int, E)&lt;/code&gt;&lt;/a&gt; is overridden.</source>
          <target state="translated">&lt;a href=&quot;abstractlist#add-int-E-&quot;&gt; &lt;code&gt;add(int, E)&lt;/code&gt; &lt;/a&gt; 를 재정의 하지 않으면 이 구현에서 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3c6fb5eaa34edfe2ff03ab385518b84ec2516cf7" translate="yes" xml:space="preserve">
          <source>Note that this implementation throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; unless &lt;code&gt;remove(int
 index)&lt;/code&gt; or &lt;code&gt;removeRange(int fromIndex, int toIndex)&lt;/code&gt; is overridden.</source>
          <target state="translated">&lt;code&gt;remove(int index)&lt;/code&gt; 또는 &lt;code&gt;removeRange(int fromIndex, int toIndex)&lt;/code&gt; 가 재정의 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 않는 한이 구현에서는 UnsupportedOperationException 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="422ea04f5194ee01853ea418d58ef8d86379e24a" translate="yes" xml:space="preserve">
          <source>Note that this implementation will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if the iterator returned by the &lt;code&gt;iterator&lt;/code&gt; method does not implement the &lt;code&gt;remove&lt;/code&gt; method and this collection contains one or more elements in common with the specified collection.</source>
          <target state="translated">&lt;code&gt;iterator&lt;/code&gt; 메소드에 의해 리턴 된 반복자 가 &lt;code&gt;remove&lt;/code&gt; 메소드를 구현하지 않고이 콜렉션에 지정된 콜렉션과 공통 인 하나 이상의 요소가 포함 된 경우이 구현은 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5988cf643aa33a5bd4d014ed12015866d3fbeeba" translate="yes" xml:space="preserve">
          <source>Note that this implementation will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if the iterator returned by the &lt;code&gt;iterator&lt;/code&gt; method does not implement the &lt;code&gt;remove&lt;/code&gt; method and this collection contains one or more elements not present in the specified collection.</source>
          <target state="translated">&lt;code&gt;iterator&lt;/code&gt; 메소드에 의해 리턴 된 반복자 가 &lt;code&gt;remove&lt;/code&gt; 메소드를 구현하지 않고이 콜렉션에 지정된 콜렉션에없는 하나 이상의 요소가 포함 된 경우이 구현은 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="525bf326636aff0af8a9f15a5f10c17ca53eb171" translate="yes" xml:space="preserve">
          <source>Note that this implementation will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if the iterator returned by the &lt;code&gt;iterator&lt;/code&gt; method does not implement the &lt;code&gt;remove&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;iterator&lt;/code&gt; 메소드에 의해 리턴 된 반복자 가 &lt;code&gt;remove&lt;/code&gt; 메소드를 구현하지 않으면 이 구현은 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="3e60f8e679a9f7d85915be0ab99b0f33ba4ab1db" translate="yes" xml:space="preserve">
          <source>Note that this implementation will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if the iterator returned by this collection's &lt;code&gt;iterator&lt;/code&gt; method does not implement the &lt;code&gt;remove&lt;/code&gt; method and this collection is non-empty.</source>
          <target state="translated">이 콜렉션의 &lt;code&gt;iterator&lt;/code&gt; 메소드에 의해 리턴 된 반복자 가 &lt;code&gt;remove&lt;/code&gt; 메소드를 구현하지 않고이 콜렉션이 비어 있지 않은 경우, 이 구현은 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="35e5896bdd589a9b6213fb5e4ea8e6765a26357e" translate="yes" xml:space="preserve">
          <source>Note that this implementation will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if the list iterator does not implement the &lt;code&gt;add&lt;/code&gt; operation.</source>
          <target state="translated">리스트 반복자가 &lt;code&gt;add&lt;/code&gt; 오퍼레이션을 구현하지 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 경우, 이 구현은 UnsupportedOperationException 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="85346ec6bcd94e9c56ca9f83cf9ad0129e133f29" translate="yes" xml:space="preserve">
          <source>Note that this implementation will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if the list iterator does not implement the &lt;code&gt;remove&lt;/code&gt; operation.</source>
          <target state="translated">리스트 반복자가 &lt;code&gt;remove&lt;/code&gt; 오퍼레이션을 구현하지 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 경우, 이 구현은 UnsupportedOperationException 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="2988484bc36257f1ca3eece7c1a9cf6517c20350" translate="yes" xml:space="preserve">
          <source>Note that this implementation will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if the list iterator does not implement the &lt;code&gt;set&lt;/code&gt; operation.</source>
          <target state="translated">리스트 반복자가 &lt;code&gt;set&lt;/code&gt; 조작을 구현하지 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 경우, 이 구현은 UnsupportedOperationException 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="1783eb4951e40a0fff0a5ffff6c87d7ea0bf6655" translate="yes" xml:space="preserve">
          <source>Note that this implementation will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if the list iterator returned by the &lt;code&gt;listIterator&lt;/code&gt; method does not implement the &lt;code&gt;add&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;listIterator&lt;/code&gt; 메소드에 의해 리턴 된리스트 반복자 가 &lt;code&gt;add&lt;/code&gt; 오퍼레이션을 구현하지 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 경우, 이 구현은 UnsupportedOperationException 을 Throw합니다 .</target>
        </trans-unit>
        <trans-unit id="f327fdcaeba70cad3d57b84dbcb0e1ebcd97037f" translate="yes" xml:space="preserve">
          <source>Note that this implementation will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; unless &lt;code&gt;add&lt;/code&gt; is overridden (assuming the specified collection is non-empty).</source>
          <target state="translated">이 구현은 &lt;code&gt;add&lt;/code&gt; 가 오버라이드 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 한 (지정된 컬렉션이 비어 있지 않은 경우) UnsupportedOperationException을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="4ab2481d2b630803d9173d0def46d838c199222e" translate="yes" xml:space="preserve">
          <source>Note that this interface does</source>
          <target state="translated">이 인터페이스는</target>
        </trans-unit>
        <trans-unit id="153f2cc4fdf4685234f5500ca348f3c32aaead68" translate="yes" xml:space="preserve">
          <source>Note that this interface includes only those DTD events that the XML recommendation &lt;em&gt;requires&lt;/em&gt; processors to report: notation and unparsed entity declarations.</source>
          <target state="translated">이 인터페이스에는 XML 권장 사항에 해당하는 DTD 이벤트 만 포함됩니다. &lt;em&gt;&lt;/em&gt; 프로세서가보고 &lt;em&gt;해야하는&lt;/em&gt; 표기법 및 구문 분석되지 않은 엔티티 선언) 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d7f4f82f399d57015cedf4a75d3e039251e05b16" translate="yes" xml:space="preserve">
          <source>Note that this is a new method that replaces the deprecated &lt;a href=&quot;#newInstance(java.lang.String,java.lang.ClassLoader)&quot;&gt;&lt;code&gt;newInstance(String factoryId, ClassLoader classLoader)&lt;/code&gt;&lt;/a&gt; method. No changes in behavior are defined by this replacement method relative to the deprecated method.</source>
          <target state="translated">이것은 더 이상 사용되지 않는 &lt;a href=&quot;#newInstance(java.lang.String,java.lang.ClassLoader)&quot;&gt; &lt;code&gt;newInstance(String factoryId, ClassLoader classLoader)&lt;/code&gt; &lt;/a&gt; 메서드. 더 이상 사용되지 않는 메서드와 관련하여이 대체 메서드에 의해 정의 된 동작의 변경 사항은 없습니다.</target>
        </trans-unit>
        <trans-unit id="960b0f6ffdab9a4a559ec1529401c17cd0345edd" translate="yes" xml:space="preserve">
          <source>Note that this is a new method that replaces the deprecated &lt;a href=&quot;#newInstance(java.lang.String,java.lang.ClassLoader)&quot;&gt;&lt;code&gt;newInstance(String factoryId, ClassLoader classLoader)&lt;/code&gt;&lt;/a&gt; method. The original method was incorrectly defined to return XMLInputFactory.</source>
          <target state="translated">이것은 더 이상 사용되지 않는 &lt;a href=&quot;#newInstance(java.lang.String,java.lang.ClassLoader)&quot;&gt; &lt;code&gt;newInstance(String factoryId, ClassLoader classLoader)&lt;/code&gt; &lt;/a&gt; 메서드. XMLInputFactory를 반환하도록 원래 메서드가 잘못 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="5301f6a7aaaf900be91043cae59868ad5d51a18b" translate="yes" xml:space="preserve">
          <source>Note that this is a one-way operation. There is no &quot;un-die&quot; method.</source>
          <target state="translated">이것은 단방향 작업입니다. &quot;un-die&quot;방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="3c2caf6e5b1723320743debc3005629f763fe343" translate="yes" xml:space="preserve">
          <source>Note that this is not a strict inverse of &lt;a href=&quot;#fromMethodDescriptorString(java.lang.String,java.lang.ClassLoader)&quot;&gt;&lt;code&gt;fromMethodDescriptorString&lt;/code&gt;&lt;/a&gt;. Two distinct classes which share a common name but have different class loaders will appear identical when viewed within descriptor strings.</source>
          <target state="translated">이것은 &lt;a href=&quot;#fromMethodDescriptorString(java.lang.String,java.lang.ClassLoader)&quot;&gt; &lt;code&gt;fromMethodDescriptorString&lt;/code&gt; &lt;/a&gt; 의 엄격한 역이 아닙니다. . 공통 이름을 공유하지만 클래스 로더가 다른 두 개의 별개 클래스는 설명자 문자열 내에서 볼 때 동일하게 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d592a9f323fa58c445e7e3eb0745ef34fe888513" translate="yes" xml:space="preserve">
          <source>Note that this is not a strict inverse of &lt;a href=&quot;methodtype#fromMethodDescriptorString-java.lang.String-java.lang.ClassLoader-&quot;&gt;&lt;code&gt;fromMethodDescriptorString&lt;/code&gt;&lt;/a&gt;. Two distinct classes which share a common name but have different class loaders will appear identical when viewed within descriptor strings.</source>
          <target state="translated">이것은 &lt;a href=&quot;methodtype#fromMethodDescriptorString-java.lang.String-java.lang.ClassLoader-&quot;&gt; &lt;code&gt;fromMethodDescriptorString&lt;/code&gt; 과&lt;/a&gt; 엄격하게 반대되는 것은 아닙니다 . 공통 이름을 공유하지만 클래스 로더가 다른 두 개의 개별 클래스는 설명자 문자열 내에서 동일하게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3085b4ad1dbd6340c8f8b80f102960b77bef6e60" translate="yes" xml:space="preserve">
          <source>Note that this meta-annotation type has no effect if the annotated type is used to annotate anything other than a class. Note also that this meta-annotation only causes annotations to be inherited from superclasses; annotations on implemented interfaces have no effect.</source>
          <target state="translated">주석 유형이 클래스 이외의 주석에 사용되는 경우이 메타 주석 유형은 영향을 미치지 않습니다. 이 메타 주석은 주석이 슈퍼 클래스에서만 상속되도록합니다. 구현 된 인터페이스에 대한 주석은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a5a94267a3705a2122fc8b5081814450ae70967" translate="yes" xml:space="preserve">
          <source>Note that this method can usefully be applied to sublists to move one or more elements within a list while preserving the order of the remaining elements. For example, the following idiom moves the element at index &lt;code&gt;j&lt;/code&gt; forward to position &lt;code&gt;k&lt;/code&gt; (which must be greater than or equal to &lt;code&gt;j&lt;/code&gt;):</source>
          <target state="translated">이 방법은 하위 요소에 유용하게 적용되어 나머지 요소의 순서를 유지하면서 목록 내에서 하나 이상의 요소를 이동할 수 있습니다. 예를 들어, 다음 관용구 인덱스의 요소 이동 &lt;code&gt;j&lt;/code&gt; 전진 위치로 &lt;code&gt;k&lt;/code&gt; (보다 크거나 동일해야한다 &lt;code&gt;j&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="f881e7c5908f2c072f7ba70b7a7c3d38afbb2344" translate="yes" xml:space="preserve">
          <source>Note that this method cannot be used to transmit &lt;code&gt;MANAGE CHANNEL&lt;/code&gt; APDUs. Logical channels should be managed using the &lt;a href=&quot;card#openLogicalChannel()&quot;&gt;Card.openLogicalChannel()&lt;/a&gt; and &lt;a href=&quot;#close()&quot;&gt;CardChannel.close()&lt;/a&gt; methods.</source>
          <target state="translated">이 방법은 &lt;code&gt;MANAGE CHANNEL&lt;/code&gt; APDU 를 전송하는 데 사용할 수 없습니다 . 논리 채널은 &lt;a href=&quot;card#openLogicalChannel()&quot;&gt;Card.openLogicalChannel ()&lt;/a&gt; 및 &lt;a href=&quot;#close()&quot;&gt;CardChannel.close ()&lt;/a&gt; 메서드를 사용하여 관리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ab7834403354feb3439539896960c8ef42fe2b2d" translate="yes" xml:space="preserve">
          <source>Note that this method does &lt;em&gt;not&lt;/em&gt; take locale into account, and will result in an unsatisfactory ordering for certain locales. The &lt;a href=&quot;../text/collator&quot;&gt;&lt;code&gt;Collator&lt;/code&gt;&lt;/a&gt; class provides locale-sensitive comparison.</source>
          <target state="translated">이 방법은 로케일을 고려 하지 &lt;em&gt;않으며&lt;/em&gt; 특정 로케일의 순서가 만족스럽지 않습니다. &lt;a href=&quot;../text/collator&quot;&gt; &lt;code&gt;Collator&lt;/code&gt; &lt;/a&gt; 클래스는 로케일에 의존하는 비교를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="20eb6a4da01ded7eeea08a815df0efb0d37f211a" translate="yes" xml:space="preserve">
          <source>Note that this method does &lt;em&gt;not&lt;/em&gt; take locale into account, and will result in an unsatisfactory ordering for certain locales. The java.text package provides &lt;em&gt;collators&lt;/em&gt; to allow locale-sensitive ordering.</source>
          <target state="translated">이 방법은 로케일을 고려 하지 &lt;em&gt;않으므로&lt;/em&gt; 특정 로케일에 대한 순서가 만족스럽지 않습니다. java.text 패키지는 로케일 구분 순서를 허용 하는 &lt;em&gt;콜렉터&lt;/em&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d5a4dd3741621d78b646a191cd0cf0ef257dd40e" translate="yes" xml:space="preserve">
          <source>Note that this method does &lt;em&gt;not&lt;/em&gt; take locale into account, and will result in unsatisfactory results for certain locales when &lt;code&gt;ignoreCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. The &lt;a href=&quot;../text/collator&quot;&gt;&lt;code&gt;Collator&lt;/code&gt;&lt;/a&gt; class provides locale-sensitive comparison.</source>
          <target state="translated">이 메소드는 로케일을 고려 하지 &lt;em&gt;않으며 &lt;/em&gt; &lt;code&gt;ignoreCase&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 특정 로케일에 대해 만족스럽지 못한 결과를 초래 합니다 . &lt;a href=&quot;../text/collator&quot;&gt; &lt;code&gt;Collator&lt;/code&gt; &lt;/a&gt; 클래스는 로케일에 의존하는 비교를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="40a2a3bb1d07ddbbbbd69885b81211e7ac032cc1" translate="yes" xml:space="preserve">
          <source>Note that this method does &lt;em&gt;not&lt;/em&gt; take locale into account, and will result in unsatisfactory results for certain locales. The &lt;a href=&quot;../text/collator&quot;&gt;&lt;code&gt;Collator&lt;/code&gt;&lt;/a&gt; class provides locale-sensitive comparison.</source>
          <target state="translated">이 방법은 로케일을 고려 하지 &lt;em&gt;않으며&lt;/em&gt; 특정 로케일에 대해 만족스럽지 않은 결과를 초래합니다. &lt;a href=&quot;../text/collator&quot;&gt; &lt;code&gt;Collator&lt;/code&gt; &lt;/a&gt; 클래스는 로케일에 의존하는 비교를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="207d87ac62d6b9031321e630cca7a1b52a78d900" translate="yes" xml:space="preserve">
          <source>Note that this method does &lt;em&gt;not&lt;/em&gt; take locale into account. The &lt;a href=&quot;../text/collator&quot;&gt;&lt;code&gt;Collator&lt;/code&gt;&lt;/a&gt; class provides locale-sensitive comparison.</source>
          <target state="translated">이 방법은 로케일을 고려 하지 &lt;em&gt;않습니다&lt;/em&gt; . &lt;a href=&quot;../text/collator&quot;&gt; &lt;code&gt;Collator&lt;/code&gt; &lt;/a&gt; 클래스는 로케일에 의존하는 비교를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f3dd28effd74b6f8c2fcfc05b89de02aee634ab3" translate="yes" xml:space="preserve">
          <source>Note that this method does not call the &lt;code&gt;write&lt;/code&gt; method of its underlying input stream with the same arguments. Subclasses of &lt;code&gt;FilterOutputStream&lt;/code&gt; should provide a more efficient implementation of this method.</source>
          <target state="translated">이 메소드는 동일한 인수로 기본 입력 스트림 의 &lt;code&gt;write&lt;/code&gt; 메소드를 호출하지 않습니다 . &lt;code&gt;FilterOutputStream&lt;/code&gt; 의 서브 클래스는 이 메소드의보다 효율적인 구현을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef01d93965b1db4c07fa75e1840b1a354851a5b9" translate="yes" xml:space="preserve">
          <source>Note that this method does not call the &lt;code&gt;write&lt;/code&gt; method of its underlying output stream with the same arguments. Subclasses of &lt;code&gt;FilterOutputStream&lt;/code&gt; should provide a more efficient implementation of this method.</source>
          <target state="translated">이 메서드는 동일한 인수를 사용하여 기본 출력 스트림 의 &lt;code&gt;write&lt;/code&gt; 메서드를 호출하지 않습니다 . &lt;code&gt;FilterOutputStream&lt;/code&gt; 의 서브 클래스는 이 메소드의보다 효율적인 구현을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4611493bb994e2035a9c309dd4d1f3bcdf66997" translate="yes" xml:space="preserve">
          <source>Note that this method does not call the one-argument &lt;code&gt;write&lt;/code&gt; method of its underlying output stream with the single argument &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 단일 인수 &lt;code&gt;b&lt;/code&gt; 를 사용하여 기본 출력 스트림의 단일 인수 &lt;code&gt;write&lt;/code&gt; 메서드를 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ac12c4ad7508b820c717cab29f284f23852b29ba" translate="yes" xml:space="preserve">
          <source>Note that this method does not call the one-argument &lt;code&gt;write&lt;/code&gt; method of its underlying stream with the single argument &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 단일 인수 &lt;code&gt;b&lt;/code&gt; 를 사용하여 기본 스트림의 단일 인수 &lt;code&gt;write&lt;/code&gt; 메소드를 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="afbe663b4c55e68667941ceb44df6bef21667350" translate="yes" xml:space="preserve">
          <source>Note that this method does not return obsolete 2-letter country codes. ISO3166-3 codes which designate country codes for those obsolete codes, can be retrieved from &lt;a href=&quot;#getISOCountries(java.util.Locale.IsoCountryCode)&quot;&gt;&lt;code&gt;getISOCountries(Locale.IsoCountryCode type)&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;type&lt;/code&gt;&lt;a href=&quot;locale.isocountrycode#PART3&quot;&gt;&lt;code&gt;Locale.IsoCountryCode.PART3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드는 사용되지 않는 2 자리 국가 코드를 반환하지 않습니다. 그 쓸모없는 코드에 대한 지정 국가 코드가에서 검색 할 수 있습니다 ISO3166-3 코드 &lt;a href=&quot;#getISOCountries(java.util.Locale.IsoCountryCode)&quot;&gt; &lt;code&gt;getISOCountries(Locale.IsoCountryCode type)&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;type&lt;/code&gt; &lt;a href=&quot;locale.isocountrycode#PART3&quot;&gt; &lt;code&gt;Locale.IsoCountryCode.PART3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5aab9bdd875aafdc85fd0158236e9a17a8e750e" translate="yes" xml:space="preserve">
          <source>Note that this method does not return the manifest's main attributes; see &lt;a href=&quot;#getMainAttributes()&quot;&gt;&lt;code&gt;getMainAttributes()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드는 매니페스트의 기본 속성을 반환하지 않습니다. &lt;a href=&quot;#getMainAttributes()&quot;&gt; &lt;code&gt;getMainAttributes()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b85aa59e04cc406d60996088e348b5995dbf5b88" translate="yes" xml:space="preserve">
          <source>Note that this method does not return the manifest's main attributes; see &lt;a href=&quot;manifest#getMainAttributes--&quot;&gt;&lt;code&gt;getMainAttributes()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 매니페스트의 주요 속성을 반환하지 않습니다. &lt;a href=&quot;manifest#getMainAttributes--&quot;&gt; &lt;code&gt;getMainAttributes()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="52b41a870664bd30dd4e85746b0ca25c65347ae6" translate="yes" xml:space="preserve">
          <source>Note that this method does not take any precautions to avoid problems caused by storing results into &lt;code&gt;Point2D&lt;/code&gt; objects that will be used as the source for calculations further down the source array. This method does guarantee that if a specified &lt;code&gt;Point2D&lt;/code&gt; object is both the source and destination for the same single point transform operation then the results will not be stored until the calculations are complete to avoid storing the results on top of the operands. If, however, the destination &lt;code&gt;Point2D&lt;/code&gt; object for one operation is the same object as the source &lt;code&gt;Point2D&lt;/code&gt; object for another operation further down the source array then the original coordinates in that point are overwritten before they can be converted.</source>
          <target state="translated">이 방법은 결과를 소스 배열 아래에서 계산을위한 소스로 사용할 &lt;code&gt;Point2D&lt;/code&gt; 객체 에 저장하여 발생하는 문제를 방지하기위한 예방 조치를 취하지 않습니다 . 이 메서드는 지정된 &lt;code&gt;Point2D&lt;/code&gt; 객체가 동일한 단일 포인트 변환 작업의 소스이자 대상인 경우 피연산자 위에 결과를 저장하지 않도록 계산이 완료 될 때까지 결과가 저장되지 않음을 보장합니다 . 그러나 한 작업 의 대상 &lt;code&gt;Point2D&lt;/code&gt; 객체가 소스 &lt;code&gt;Point2D&lt;/code&gt; 와 동일한 객체 인 경우 가 소스 배열 아래의 다른 작업에 대한 객체 해당 지점의 원래 좌표를 덮어 쓰고 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5915d01cdbf8df7d6e4bc4b96fe69c77ad00d1c" translate="yes" xml:space="preserve">
          <source>Note that this method does not wait if there are no events pending.</source>
          <target state="translated">보류중인 이벤트가없는 경우이 메소드는 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b0e08602b6b04dd768eb247d52038820cc559d5" translate="yes" xml:space="preserve">
          <source>Note that this method invokes all LoginModules configured for the application regardless of their respective &lt;code&gt;Configuration&lt;/code&gt; flag parameters. Essentially this means that &lt;code&gt;Requisite&lt;/code&gt; and &lt;code&gt;Sufficient&lt;/code&gt; semantics are ignored for this method. This guarantees that proper cleanup and state restoration can take place.</source>
          <target state="translated">이 메소드는 각각의 &lt;code&gt;Configuration&lt;/code&gt; 플래그 매개 변수에 관계없이 응용 프로그램에 대해 구성된 모든 LoginModule을 호출합니다 . 본질적으로 이것은 &lt;code&gt;Requisite&lt;/code&gt; 및 &lt;code&gt;Sufficient&lt;/code&gt; 의미론이이 방법에서 무시됨을 의미합니다. 이를 통해 적절한 정리 및 상태 복원이 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c023cf439620551995c39891114d9afaef9ddaa7" translate="yes" xml:space="preserve">
          <source>Note that this method is closely related to the logarithm base 2. For all positive &lt;code&gt;int&lt;/code&gt; values x:</source>
          <target state="translated">이 방법은 로그베이스 2와 밀접한 관련이 있습니다. 모든 양수 &lt;code&gt;int&lt;/code&gt; 값 x :</target>
        </trans-unit>
        <trans-unit id="bd0441be66e5d6fa52ee698997e024320ab62a95" translate="yes" xml:space="preserve">
          <source>Note that this method is closely related to the logarithm base 2. For all positive &lt;code&gt;long&lt;/code&gt; values x:</source>
          <target state="translated">이 방법은 로그 기수 2와 밀접한 관련이 있습니다. 모든 양의 &lt;code&gt;long&lt;/code&gt; 값 x :</target>
        </trans-unit>
        <trans-unit id="b177aa3daa87387f07254a1305a9335e89e8ef05" translate="yes" xml:space="preserve">
          <source>Note that this method is executed only once.</source>
          <target state="translated">이 메서드는 한 번만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4246746d66dd6bc090d92b55a4fe75b72024142f" translate="yes" xml:space="preserve">
          <source>Note that this method is identical in functionality to &lt;a href=&quot;#contains(java.lang.Object)&quot;&gt;&lt;code&gt;contains&lt;/code&gt;&lt;/a&gt; (which predates the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; interface).</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;#contains(java.lang.Object)&quot;&gt; &lt;code&gt;contains&lt;/code&gt; &lt;/a&gt; 하는 기능이 동일 합니다 ( &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 인터페이스 이전 ).</target>
        </trans-unit>
        <trans-unit id="1f7516ea894d475f1b968f7444c8c167aed023af" translate="yes" xml:space="preserve">
          <source>Note that this method is identical in functionality to &lt;a href=&quot;#containsValue(java.lang.Object)&quot;&gt;&lt;code&gt;containsValue(Object)&lt;/code&gt;&lt;/a&gt;, and exists solely to ensure full compatibility with class &lt;a href=&quot;../hashtable&quot;&gt;&lt;code&gt;Hashtable&lt;/code&gt;&lt;/a&gt;, which supported this method prior to introduction of the Java Collections Framework.</source>
          <target state="translated">이 메소드는 기능면에서 &lt;a href=&quot;#containsValue(java.lang.Object)&quot;&gt; &lt;code&gt;containsValue(Object)&lt;/code&gt; &lt;/a&gt; 와 동일 하며 Java Collections Framework 도입 이전에이 메소드를 지원했던 &lt;a href=&quot;../hashtable&quot;&gt; &lt;code&gt;Hashtable&lt;/code&gt; &lt;/a&gt; 클래스와의 완전한 호환성을 보장하기 위해서만 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="bb1e4aa770f04d58546154dbf8d6782ac6ec2ab4" translate="yes" xml:space="preserve">
          <source>Note that this method is identical in functionality to &lt;a href=&quot;#containsValue(java.lang.Object)&quot;&gt;&lt;code&gt;containsValue&lt;/code&gt;&lt;/a&gt;, (which is part of the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; interface in the collections framework).</source>
          <target state="translated">이 메소드는 기능면에서 &lt;a href=&quot;#containsValue(java.lang.Object)&quot;&gt; &lt;code&gt;containsValue&lt;/code&gt; &lt;/a&gt; 와 동일 합니다 (컬렉션 프레임 워크에서 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 인터페이스의 일부 ).</target>
        </trans-unit>
        <trans-unit id="966c4ce85eb881416ac77e81f217612eeac1a64d" translate="yes" xml:space="preserve">
          <source>Note that this method is identical in functionality to &lt;a href=&quot;hashtable#contains-java.lang.Object-&quot;&gt;&lt;code&gt;contains&lt;/code&gt;&lt;/a&gt; (which predates the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; interface).</source>
          <target state="translated">주목하는 방법이 기능적으로 동일 함을 &lt;a href=&quot;hashtable#contains-java.lang.Object-&quot;&gt; &lt;code&gt;contains&lt;/code&gt; &lt;/a&gt; (이는 선행 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 인터페이스).</target>
        </trans-unit>
        <trans-unit id="2b3ffa961e85c18bf1fcbf365bd71d275411701d" translate="yes" xml:space="preserve">
          <source>Note that this method is identical in functionality to &lt;a href=&quot;hashtable#containsValue-java.lang.Object-&quot;&gt;&lt;code&gt;containsValue&lt;/code&gt;&lt;/a&gt;, (which is part of the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; interface in the collections framework).</source>
          <target state="translated">이 메소드는 기능적으로 는 collectionValue 에있는 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 인터페이스의 일부인 &lt;a href=&quot;hashtable#containsValue-java.lang.Object-&quot;&gt; &lt;code&gt;containsValue&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="b37d06a604e1e64eee7ea9b46c91c1ab033efe66" translate="yes" xml:space="preserve">
          <source>Note that this method is identical to &lt;code&gt;appendZoneId()&lt;/code&gt; except in the mechanism used to obtain the zone.</source>
          <target state="translated">이 메소드는 영역을 얻는 데 사용되는 메커니즘을 제외하고 &lt;code&gt;appendZoneId()&lt;/code&gt; 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e6a32d16159408432a700f5390c4af48bb644349" translate="yes" xml:space="preserve">
          <source>Note that this method is identical to &lt;code&gt;appendZoneId()&lt;/code&gt; except in the mechanism used to obtain the zone. Note also that parsing accepts offsets, whereas formatting will never produce one.</source>
          <target state="translated">이 메소드는 영역을 얻는 데 사용되는 메커니즘을 제외하고 &lt;code&gt;appendZoneId()&lt;/code&gt; 동일합니다. 구문 분석은 오프셋을 허용하지만 형식화는 오프셋을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28c3977e6ed55d778f86a7dc3e903ddce83777f0" translate="yes" xml:space="preserve">
          <source>Note that this method is intended for simple cases where it is convenient to read all bytes into a byte array. It is not intended for reading in large files.</source>
          <target state="translated">이 방법은 모든 바이트를 바이트 배열로 읽는 것이 편리한 간단한 경우를위한 것입니다. 큰 파일을 읽기위한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="576bfc74b2f08fc61e5aa989e2be8d88ac2273a0" translate="yes" xml:space="preserve">
          <source>Note that this method is intended for simple cases where it is convenient to read all bytes into a byte array. It is not intended for reading input streams with large amounts of data.</source>
          <target state="translated">이 메서드는 모든 바이트를 바이트 배열로 읽는 것이 편리한 간단한 경우를위한 것입니다. 많은 양의 데이터가있는 입력 스트림을 읽기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a0fa0cde9c64ed8274dcf0707bf3e19e94043a69" translate="yes" xml:space="preserve">
          <source>Note that this method is intended for simple cases where it is convenient to read all lines in a single operation. It is not intended for reading in large files.</source>
          <target state="translated">이 방법은 한 번의 작업으로 모든 줄을 읽는 것이 편리한 간단한 경우를위한 것입니다. 큰 파일을 읽기위한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="07de1ec0939ac126800611c4a941e7c27e8a503d" translate="yes" xml:space="preserve">
          <source>Note that this method is intended for simple cases where it is convenient to read the specified number of bytes into a byte array. The total amount of memory allocated by this method is proportional to the number of bytes read from the stream which is bounded by &lt;code&gt;len&lt;/code&gt;. Therefore, the method may be safely called with very large values of &lt;code&gt;len&lt;/code&gt; provided sufficient memory is available.</source>
          <target state="translated">이 메서드는 지정된 바이트 수를 바이트 배열로 읽는 것이 편리한 간단한 경우를위한 것입니다. 이 메서드에 의해 할당 된 총 메모리 양은 &lt;code&gt;len&lt;/code&gt; 에 의해 제한되는 스트림에서 읽은 바이트 수에 비례합니다 . 따라서 충분한 메모리를 사용할 수 있는 경우 매우 큰 &lt;code&gt;len&lt;/code&gt; 값으로 메서드를 안전하게 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b3cf977fbf294e60ff58b5f2113a576cf207fd" translate="yes" xml:space="preserve">
          <source>Note that this method is not the complement of the &lt;a href=&quot;#exists(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; method. Where it is not possible to determine if a file exists or not then both methods return &lt;code&gt;false&lt;/code&gt;. As with the &lt;code&gt;exists&lt;/code&gt; method, the result of this method is immediately outdated. If this method indicates the file does exist then there is no guarantee that a subsequent attempt to create the file will succeed. Care should be taken when using this method in security sensitive applications.</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;#exists(java.nio.file.Path,java.nio.file.LinkOption...)&quot;&gt; &lt;code&gt;exists&lt;/code&gt; &lt;/a&gt; 메서드 의 보완이 아닙니다 . 파일이 있는지 여부를 확인할 수없는 경우 두 메서드 모두 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다. &lt;code&gt;exists&lt;/code&gt; 메서드 와 마찬가지로이 메서드의 결과는 즉시 구식입니다. 이 방법이 파일이 존재 함을 나타내면 후속 파일 생성 시도가 성공할 것이라는 보장이 없습니다. 보안에 민감한 응용 프로그램에서이 방법을 사용할 때는주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="4538812a937a9f7b64aabc96676c3f0f780a15fb" translate="yes" xml:space="preserve">
          <source>Note that this method is not the complement of the &lt;a href=&quot;files#exists-java.nio.file.Path-java.nio.file.LinkOption...-&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; method. Where it is not possible to determine if a file exists or not then both methods return &lt;code&gt;false&lt;/code&gt;. As with the &lt;code&gt;exists&lt;/code&gt; method, the result of this method is immediately outdated. If this method indicates the file does exist then there is no guarantee that a subsequence attempt to create the file will succeed. Care should be taken when using this method in security sensitive applications.</source>
          <target state="translated">이 방법은 &lt;a href=&quot;files#exists-java.nio.file.Path-java.nio.file.LinkOption...-&quot;&gt; &lt;code&gt;exists&lt;/code&gt; &lt;/a&gt; 방법을 보완하지 않습니다 . 파일이 존재하는지 여부를 판별 할 수없는 경우 두 메소드 모두 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다. &lt;code&gt;exists&lt;/code&gt; 방법 과 마찬가지로이 방법의 결과는 즉시 구식입니다. 이 방법으로 파일이 존재한다고 표시되면 파일을 작성하는 서브 시퀀스 시도가 성공한다는 보장이 없습니다. 보안에 민감한 응용 프로그램에서이 방법을 사용할 때는주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="af46e2390301ab36cf58844f68139f609ff82b32" translate="yes" xml:space="preserve">
          <source>Note that this method is public but is used by the look and feel engine and should not be called by client applications.</source>
          <target state="translated">이 메서드는 공용이지만 룩앤필 엔진에서 사용되며 클라이언트 애플리케이션에서 호출하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5c536ae45fe51704315cd4860b374f8d2c7f1d48" translate="yes" xml:space="preserve">
          <source>Note that this method is security checked and is not available to (for example) untrusted applets. More specifically, if there is a security manager, its &lt;code&gt;checkPropertiesAccess&lt;/code&gt; method is called. This could result in a SecurityException.</source>
          <target state="translated">이 방법은 보안이 검사되어 신뢰할 수없는 애플릿에는 사용할 수 없습니다. 보다 구체적으로 보안 관리자가 있으면 &lt;code&gt;checkPropertiesAccess&lt;/code&gt; 메소드가 호출됩니다. 이로 인해 SecurityException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a1013621b1c25803b67632835c2b6327a0957ce" translate="yes" xml:space="preserve">
          <source>Note that this method may be used to pass database- specific abstract data types, by using a driver-specific Java type. If the object is of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;, the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write it to the SQL data stream. If, on the other hand, the object is of a class implementing &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;, &lt;code&gt;NClob&lt;/code&gt;, &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;, &lt;code&gt;RowId&lt;/code&gt;, &lt;code&gt;SQLXML&lt;/code&gt; or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a value of the corresponding SQL type.</source>
          <target state="translated">이 메소드는 드라이버 특정 Java 유형을 사용하여 데이터베이스 특정 추상 데이터 유형을 전달하는 데 사용될 수 있습니다. 객체가 &lt;code&gt;SQLData&lt;/code&gt; 인터페이스를 구현하는 클래스 인 경우 JDBC 드라이버는 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 메서드 를 호출 하여 SQL 데이터 스트림에 기록해야합니다. 반면에 객체가 &lt;code&gt;Ref&lt;/code&gt; , &lt;code&gt;Blob&lt;/code&gt; , &lt;code&gt;Clob&lt;/code&gt; , &lt;code&gt;NClob&lt;/code&gt; , &lt;code&gt;Struct&lt;/code&gt; , &lt;code&gt;java.net.URL&lt;/code&gt; , &lt;code&gt;RowId&lt;/code&gt; , &lt;code&gt;SQLXML&lt;/code&gt; 또는 &lt;code&gt;Array&lt;/code&gt; 를 인 경우 드라이버는 해당 값을 데이터베이스에 전달해야합니다. SQL 유형.</target>
        </trans-unit>
        <trans-unit id="f6b1b3b07894fb34fc1c6f37da4f2f7e640d8cf6" translate="yes" xml:space="preserve">
          <source>Note that this method may be used to pass database- specific abstract data types, by using a driver-specific Java type. If the object is of a class implementing the interface &lt;code&gt;SQLData&lt;/code&gt;, the JDBC driver should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write it to the SQL data stream. If, on the other hand, the object is of a class implementing &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;, &lt;code&gt;NClob&lt;/code&gt;, &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a value of the corresponding SQL type.</source>
          <target state="translated">이 메소드는 드라이버 특정 Java 유형을 사용하여 데이터베이스 특정 추상 데이터 유형을 전달하는 데 사용될 수 있습니다. 객체가 &lt;code&gt;SQLData&lt;/code&gt; 인터페이스를 구현하는 클래스 인 경우 JDBC 드라이버는 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 메서드 를 호출 하여 SQL 데이터 스트림에 기록해야합니다. 반면에 객체가 &lt;code&gt;Ref&lt;/code&gt; , &lt;code&gt;Blob&lt;/code&gt; , &lt;code&gt;Clob&lt;/code&gt; , &lt;code&gt;NClob&lt;/code&gt; 을 구현하는 클래스 인 경우 , &lt;code&gt;Struct&lt;/code&gt; , &lt;code&gt;java.net.URL&lt;/code&gt; 또는 &lt;code&gt;Array&lt;/code&gt; 를 인 경우 드라이버는 해당 SQL 유형의 값으로 데이터베이스에 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="50668c292bb17d26944090bb68d263a3c5bc6986" translate="yes" xml:space="preserve">
          <source>Note that this method may be used to pass database- specific abstract data types.</source>
          <target state="translated">이 메소드는 데이터베이스 특정 추상 데이터 유형을 전달하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7d4c1e090a790c3de485c0151a929ce42d41c96" translate="yes" xml:space="preserve">
          <source>Note that this method may be used to pass database-specific abstract data types by using a driver-specific Java type. If the object is of a class implementing &lt;code&gt;SQLData&lt;/code&gt;, the rowset should call the method &lt;code&gt;SQLData.writeSQL&lt;/code&gt; to write the object to an &lt;code&gt;SQLOutput&lt;/code&gt; data stream. If, on the other hand, the object is of a class implementing &lt;code&gt;Ref&lt;/code&gt;, &lt;code&gt;Blob&lt;/code&gt;, &lt;code&gt;Clob&lt;/code&gt;, &lt;code&gt;NClob&lt;/code&gt;, &lt;code&gt;Struct&lt;/code&gt;, &lt;code&gt;java.net.URL&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;, the driver should pass it to the database as a value of the corresponding SQL type.</source>
          <target state="translated">이 메소드는 드라이버 특정 Java 유형을 사용하여 데이터베이스 특정 추상 데이터 유형을 전달하는 데 사용될 수 있습니다. 개체가 &lt;code&gt;SQLData&lt;/code&gt; 를 구현하는 클래스 인 경우 행 집합은 &lt;code&gt;SQLData.writeSQL&lt;/code&gt; 메서드 를 호출 하여 개체를 &lt;code&gt;SQLOutput&lt;/code&gt; 데이터 스트림 에 기록해야합니다 . 반면에 객체가 &lt;code&gt;Ref&lt;/code&gt; , &lt;code&gt;Blob&lt;/code&gt; , &lt;code&gt;Clob&lt;/code&gt; , &lt;code&gt;NClob&lt;/code&gt; , &lt;code&gt;Struct&lt;/code&gt; , &lt;code&gt;java.net.URL&lt;/code&gt; 또는 &lt;code&gt;Array&lt;/code&gt; 를 구현하는 클래스 인 경우 드라이버는 해당 SQL 유형의 값으로 데이터베이스에 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="553d4117f60da0fb301a0966016f70aca8113905" translate="yes" xml:space="preserve">
          <source>Note that this method may be used to pass database-specific abstract data types.</source>
          <target state="translated">이 메소드는 데이터베이스 특정 추상 데이터 유형을 전달하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7730bd819d75e6aa02578efa2e9441e7a2bf25" translate="yes" xml:space="preserve">
          <source>Note that this method may be used to pass datatabase- specific abstract data types.</source>
          <target state="translated">이 메서드는 데이터베이스 특정 추상 데이터 유형을 전달하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="696d88c7e4fbeaa6d598552c1c9ec811d23f5407" translate="yes" xml:space="preserve">
          <source>Note that this method may not be able to return a &lt;code&gt;double&lt;/code&gt; NaN with exactly same bit pattern as the &lt;code&gt;long&lt;/code&gt; argument. IEEE 754 distinguishes between two kinds of NaNs, quiet NaNs and</source>
          <target state="translated">이 메소드는 &lt;code&gt;long&lt;/code&gt; 인수 와 정확히 동일한 비트 패턴으로 &lt;code&gt;double&lt;/code&gt; NaN 을 리턴하지 못할 수 있습니다 . IEEE 754는 두 종류의 NaN, 조용한 NaN과</target>
        </trans-unit>
        <trans-unit id="99db841235c5ffab9ca03c9f0d8ccfef1739d0ac" translate="yes" xml:space="preserve">
          <source>Note that this method may not be able to return a &lt;code&gt;float&lt;/code&gt; NaN with exactly same bit pattern as the &lt;code&gt;int&lt;/code&gt; argument. IEEE 754 distinguishes between two kinds of NaNs, quiet NaNs and</source>
          <target state="translated">이 메소드는 &lt;code&gt;int&lt;/code&gt; 인수 와 정확히 동일한 비트 패턴으로 &lt;code&gt;float&lt;/code&gt; NaN 을 리턴하지 못할 수도 있습니다 . IEEE 754는 두 종류의 NaN, 조용한 NaN과</target>
        </trans-unit>
        <trans-unit id="4c707cfe9b0be5010f0ba7940f4114887cccbbc2" translate="yes" xml:space="preserve">
          <source>Note that this method propagates any exception thrown by the nullary constructor, including a checked exception. Use of this method effectively bypasses the compile-time exception checking that would otherwise be performed by the compiler. The &lt;a href=&quot;reflect/constructor#newInstance-java.lang.Object...-&quot;&gt;&lt;code&gt;Constructor.newInstance&lt;/code&gt;&lt;/a&gt; method avoids this problem by wrapping any exception thrown by the constructor in a (checked) &lt;a href=&quot;reflect/invocationtargetexception&quot;&gt;&lt;code&gt;InvocationTargetException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 확인 된 예외를 포함하여 널 (null) 생성자가 던진 모든 예외를 전파합니다. 이 방법을 사용하면 컴파일러가 수행하는 컴파일 타임 예외 검사를 효과적으로 무시합니다. &lt;a href=&quot;reflect/constructor#newInstance-java.lang.Object...-&quot;&gt; &lt;code&gt;Constructor.newInstance&lt;/code&gt; &lt;/a&gt; 방법은 (선택)의 생성자에 의해 발생 예외 배치함으로써 이러한 문제를 피할 수 &lt;a href=&quot;reflect/invocationtargetexception&quot;&gt; &lt;code&gt;InvocationTargetException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f2ec30f1341df7ef8b9ea732a2e91136cb668fc" translate="yes" xml:space="preserve">
          <source>Note that this method provides similar functionality to methods on &lt;code&gt;DateFormat&lt;/code&gt; such as &lt;a href=&quot;../../text/dateformat#getDateTimeInstance(int,int)&quot;&gt;&lt;code&gt;DateFormat.getDateTimeInstance(int, int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드는 다음과 같은 &lt;code&gt;DateFormat&lt;/code&gt; 의 메서드와 유사한 기능을 제공합니다.&lt;a href=&quot;../../text/dateformat#getDateTimeInstance(int,int)&quot;&gt; &lt;code&gt;DateFormat.getDateTimeInstance(int, int)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2b76a1b626eab6d7248d3bd24d3815277260de1" translate="yes" xml:space="preserve">
          <source>Note that this method provides similar functionality to methods on &lt;code&gt;DateFormat&lt;/code&gt; such as &lt;a href=&quot;../../text/dateformat#getDateTimeInstance-int-int-&quot;&gt;&lt;code&gt;DateFormat.getDateTimeInstance(int, int)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법에 대한 방법과 유사한 기능을 제공하는 것을 주 &lt;code&gt;DateFormat&lt;/code&gt; 의 같은 &lt;a href=&quot;../../text/dateformat#getDateTimeInstance-int-int-&quot;&gt; &lt;code&gt;DateFormat.getDateTimeInstance(int, int)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12d9c9d351d4678f222639e1a82253b1be4f2d86" translate="yes" xml:space="preserve">
          <source>Note that this method returns a reference to the password. If a clone of the array is created it is the caller's responsibility to zero out the password information after it is no longer needed.</source>
          <target state="translated">이 메소드는 비밀번호에 대한 참조를 리턴합니다. 배열의 복제본이 생성되면 더 이상 필요하지 않은 암호 정보를 제로화하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="6b7f1e14f1eb10864276d31bd94bfd0f39407834" translate="yes" xml:space="preserve">
          <source>Note that this method returns a reference to the password. It is the caller's responsibility to zero out the password information after it is no longer needed.</source>
          <target state="translated">이 메소드는 비밀번호에 대한 참조를 리턴합니다. 더 이상 필요하지 않은 비밀번호 정보를 제로화하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="dfe51901c961117b55961f779113b9ab751bfbef" translate="yes" xml:space="preserve">
          <source>Note that this method sets the default fetch direction for result sets generated by this &lt;code&gt;Statement&lt;/code&gt; object. Each result set has its own methods for getting and setting its own fetch direction.</source>
          <target state="translated">이 메소드는 이로 생성 된 결과 세트의 기본 가져 오기 방향을 설정합니다. &lt;code&gt;Statement&lt;/code&gt; 오브젝트에 합니다. 각 결과 집합에는 자체 가져 오기 방향을 가져오고 설정하는 자체 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="142466c43ed923eac8ea1fef7a9199aa60dd0025" translate="yes" xml:space="preserve">
          <source>Note that this method should be primarily used to initialize the state of the check box menu item. Programmatically setting the state of the check box menu item will</source>
          <target state="translated">이 메서드는 주로 확인란 메뉴 항목의 상태를 초기화하는 데 사용해야합니다. 확인란 메뉴 항목의 상태를 프로그래밍 방식으로 설정하면</target>
        </trans-unit>
        <trans-unit id="d35ae4657737da617ea6337f36ace435fea4112c" translate="yes" xml:space="preserve">
          <source>Note that this method should be primarily used to initialize the state of the checkbox. Programmatically setting the state of the checkbox will</source>
          <target state="translated">이 메서드는 주로 확인란의 상태를 초기화하는 데 사용해야합니다. 체크 박스 상태를 프로그래밍 방식으로 설정하면</target>
        </trans-unit>
        <trans-unit id="f32fd67b4ed6bea16ffb22dc0246fe4e75a32573" translate="yes" xml:space="preserve">
          <source>Note that this method should be primarily used to initially select an item in this component. Programmatically calling this method will</source>
          <target state="translated">이 방법은 주로이 구성 요소에서 항목을 처음 선택하는 데 사용되어야합니다. 이 메서드를 프로그래밍 방식으로 호출하면</target>
        </trans-unit>
        <trans-unit id="b422a1d63f4f0ffbda45d1b435ba9cb1ded5c119" translate="yes" xml:space="preserve">
          <source>Note that this method supports only the bit mask-based ranges. Call &lt;a href=&quot;#getRangeSet()&quot;&gt;&lt;code&gt;getRangeSet()&lt;/code&gt;&lt;/a&gt; for the enum-based ranges.</source>
          <target state="translated">이 방법은 비트 마스크 기반 범위 만 지원합니다. &lt;a href=&quot;#getRangeSet()&quot;&gt; &lt;code&gt;getRangeSet()&lt;/code&gt; &lt;/a&gt; 호출열거 형 기반 범위에 대해 를 합니다.</target>
        </trans-unit>
        <trans-unit id="805ac6ba76cb55023340f31df6b16e4bc7aec282" translate="yes" xml:space="preserve">
          <source>Note that this method throws errors related to loading, linking or initializing as specified in Sections 12.2, 12.3 and 12.4 of &lt;em&gt;The Java Language Specification&lt;/em&gt;. Note that this method does not check whether the requested class is accessible to its caller.</source>
          <target state="translated">이 메소드는 &lt;em&gt;The Java Language Specification&lt;/em&gt; 의 12.2, 12.3 및 12.4 섹션에 지정된대로로드, 링크 또는 초기화와 관련된 오류를 발생시킵니다 . 이 메소드는 요청한 클래스가 호출자에게 액세스 가능한지 여부를 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee028283d18fd793b2649a0899170975f3d894e8" translate="yes" xml:space="preserve">
          <source>Note that this method uses the &lt;a href=&quot;#addTo(java.util.Calendar)&quot;&gt;&lt;code&gt;addTo(Calendar)&lt;/code&gt;&lt;/a&gt; method, which may work incorrectly with &lt;code&gt;Duration&lt;/code&gt; objects with very large values in its fields. See the &lt;a href=&quot;#addTo(java.util.Calendar)&quot;&gt;&lt;code&gt;addTo(Calendar)&lt;/code&gt;&lt;/a&gt; method for details.</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;#addTo(java.util.Calendar)&quot;&gt; &lt;code&gt;addTo(Calendar)&lt;/code&gt; &lt;/a&gt; 메서드를 사용합니다.이 메서드는 해당 필드에 매우 큰 값이있는 &lt;code&gt;Duration&lt;/code&gt; 개체에서 잘못 작동 할 수 있습니다. &lt;a href=&quot;#addTo(java.util.Calendar)&quot;&gt; &lt;code&gt;addTo(Calendar)&lt;/code&gt; &lt;/a&gt; 참조하십시오. 메서드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="60c0a9df7c1489a4d6bfeea45d2e9818706900bd" translate="yes" xml:space="preserve">
          <source>Note that this method uses the &lt;a href=&quot;#addTo(java.util.Date)&quot;&gt;&lt;code&gt;addTo(Date)&lt;/code&gt;&lt;/a&gt; method, which may work incorrectly with &lt;code&gt;Duration&lt;/code&gt; objects with very large values in its fields. See the &lt;a href=&quot;#addTo(java.util.Date)&quot;&gt;&lt;code&gt;addTo(Date)&lt;/code&gt;&lt;/a&gt; method for details.</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;#addTo(java.util.Date)&quot;&gt; &lt;code&gt;addTo(Date)&lt;/code&gt; &lt;/a&gt; 메서드를 사용합니다.이 메서드는 해당 필드에 값이 매우 큰 &lt;code&gt;Duration&lt;/code&gt; 개체에서 제대로 작동하지 않을 수 있습니다. 참조 &lt;a href=&quot;#addTo(java.util.Date)&quot;&gt; &lt;code&gt;addTo(Date)&lt;/code&gt; &lt;/a&gt; 메서드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="51c991358efc6fdab00e0efd7eb0e963522c2717" translate="yes" xml:space="preserve">
          <source>Note that this method will not be usable in environments where the caller (perhaps an applet) is not permitted to load classes dynamically.</source>
          <target state="translated">이 메소드는 호출자 (아마도 애플릿)가 클래스를 동적으로로드 할 수없는 환경에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="84470b99872e593b80de8a654e4099aa1a42862a" translate="yes" xml:space="preserve">
          <source>Note that this method will not scroll outside of the valid viewport; for example, if &lt;code&gt;contentRect&lt;/code&gt; is larger than the viewport, scrolling will be confined to the viewport's bounds.</source>
          <target state="translated">이 메서드는 유효한 뷰포트 외부로 스크롤되지 않습니다. 예를 들어 &lt;code&gt;contentRect&lt;/code&gt; 가 뷰포트보다 크면 스크롤이 뷰포트의 경계로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="2c135ec7686c884cbfa703e4257e9a93c4683519" translate="yes" xml:space="preserve">
          <source>Note that this method will only be called if the ObjectOutputStream is not using the old serialization stream format (set by calling ObjectOutputStream's &lt;code&gt;useProtocolVersion&lt;/code&gt; method). If this serialization stream is using the old format (&lt;code&gt;PROTOCOL_VERSION_1&lt;/code&gt;), the class descriptor will be written internally in a manner that cannot be overridden or customized.</source>
          <target state="translated">이 메소드는 ObjectOutputStream이 이전 직렬화 스트림 형식을 사용하지 않는 경우에만 호출됩니다 (ObjectOutputStream의 &lt;code&gt;useProtocolVersion&lt;/code&gt; 메소드를 호출하여 설정 ). 이 직렬화 스트림이 이전 형식 ( &lt;code&gt;PROTOCOL_VERSION_1&lt;/code&gt; )을 사용하는 경우 클래스 설명자는 재정의하거나 사용자 정의 할 수없는 방식으로 내부적으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9836a98493b03a9138a4744311c0c0e9dbbc0ca5" translate="yes" xml:space="preserve">
          <source>Note that this method will reset the byte stream if it is provided, or the character stream if the byte stream is not provided.</source>
          <target state="translated">이 메소드는 제공된 경우 바이트 스트림을 재설정하고 바이트 스트림이 제공되지 않은 경우 문자 스트림을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="6b4c803bd907f1cd9a6ea01493bf0b78266af8d4" translate="yes" xml:space="preserve">
          <source>Note that this notification mechanism has nothing to do with threads and is completely separate from the &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;notify&lt;/code&gt; mechanism of class &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">이 통지기구는 thread와는 관련이없고 , &lt;code&gt;Object&lt;/code&gt; 클래스 의 &lt;code&gt;wait&lt;/code&gt; 및 &lt;code&gt;notify&lt;/code&gt; 기구 와는 완전히 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="55d1f6a9c47780474a2729c0424f32c202de9d28" translate="yes" xml:space="preserve">
          <source>Note that this sourceClassName is not verified and may be spoofed. This information may either have been provided as part of the logging call, or it may have been inferred automatically by the logging framework. In the latter case, the information may only be approximate and may in fact describe an earlier call on the stack frame.</source>
          <target state="translated">이 sourceClassName은 확인되지 않았으며 스푸핑 될 수 있습니다. 이 정보는 로깅 호출의 일부로 제공되었거나 로깅 프레임 워크에 의해 자동으로 추론되었을 수 있습니다. 후자의 경우, 정보는 대략적인 것일 수 있으며 실제로 스택 프레임상의 이전 호출을 기술 할 수있다.</target>
        </trans-unit>
        <trans-unit id="4fecf0125546b77ee442bf47a1deb3e28d7aaefd" translate="yes" xml:space="preserve">
          <source>Note that this sourceMethodName is not verified and may be spoofed. This information may either have been provided as part of the logging call, or it may have been inferred automatically by the logging framework. In the latter case, the information may only be approximate and may in fact describe an earlier call on the stack frame.</source>
          <target state="translated">이 sourceMethodName은 확인되지 않았으며 스푸핑 될 수 있습니다. 이 정보는 로깅 호출의 일부로 제공되었거나 로깅 프레임 워크에 의해 자동으로 추론되었을 수 있습니다. 후자의 경우, 정보는 대략적인 것일 수 있으며 실제로 스택 프레임의 이전 호출을 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="072c9369f2d0d7264b8145910d01f238de126855" translate="yes" xml:space="preserve">
          <source>Note that this value does not necessarily reflect the instantaneous level of the sound produced by this voice; that level is the result of many contributing factors, including the current instrument and the shape of the amplitude envelope it produces.</source>
          <target state="translated">이 값이이 음색에 의해 생성 된 사운드의 순간 레벨을 반드시 반영하는 것은 아닙니다. 이 레벨은 현재 계측기 및 진폭 엔벨로프의 모양을 포함하여 많은 기여 요인의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="207e2858d8fbb89a9e980fbe4de50e9d78b6f8e0" translate="yes" xml:space="preserve">
          <source>Note that to use a particular &lt;a href=&quot;../../../java/nio/charset/charset&quot;&gt;charset&lt;/a&gt; to encode the contents of the file, an &lt;code&gt;OutputStreamWriter&lt;/code&gt; with the chosen charset can be created from the &lt;code&gt;OutputStream&lt;/code&gt; from the returned object. If the &lt;code&gt;Writer&lt;/code&gt; from the returned object is directly used for writing, its charset is determined by the implementation. An annotation processing tool may have an &lt;code&gt;-encoding&lt;/code&gt; flag or analogous option for specifying this; otherwise, it will typically be the platform's default encoding.</source>
          <target state="translated">특정 &lt;a href=&quot;../../../java/nio/charset/charset&quot;&gt;문자 집합&lt;/a&gt; 을 사용하여 파일의 내용을 인코딩하기 위해 반환 된 객체 의 &lt;code&gt;OutputStream&lt;/code&gt; 에서 선택한 문자 &lt;code&gt;OutputStreamWriter&lt;/code&gt; 이 있는 OutputStreamWriter 를 만들 수 있습니다 . 리턴 된 오브젝트 의 &lt;code&gt;Writer&lt;/code&gt; 가 쓰기에 직접 사용되는 경우 해당 문자 세트는 구현에 의해 결정됩니다. 주석 처리 도구에는 이를 지정하기위한 &lt;code&gt;-encoding&lt;/code&gt; 플래그 또는 유사한 옵션이있을 수 있습니다. 그렇지 않으면 일반적으로 플랫폼의 기본 인코딩이됩니다.</target>
        </trans-unit>
        <trans-unit id="6a4e909d9659e363b65c49c622d4ba876251e24f" translate="yes" xml:space="preserve">
          <source>Note that tracks are not by default enabled for recording. In order to record MIDI data, at least one track must be specifically enabled for recording.</source>
          <target state="translated">트랙은 기본적으로 녹음을 위해 활성화되어 있지 않습니다. MIDI 데이터를 녹음하려면 녹음을 위해 하나 이상의 트랙을 특별히 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bbf644c605a281f000618bbb262296d588bd839" translate="yes" xml:space="preserve">
          <source>Note that trailing format specifiers, specifiers that determine the type of a floating-point literal (&lt;code&gt;1.0f&lt;/code&gt; is a &lt;code&gt;float&lt;/code&gt; value; &lt;code&gt;1.0d&lt;/code&gt; is a &lt;code&gt;double&lt;/code&gt; value), do &lt;em&gt;not&lt;/em&gt; influence the results of this method. In other words, the numerical value of the input string is converted directly to the target floating-point type. In general, the two-step sequence of conversions, string to &lt;code&gt;double&lt;/code&gt; followed by &lt;code&gt;double&lt;/code&gt; to &lt;code&gt;float&lt;/code&gt;, is &lt;em&gt;not&lt;/em&gt; equivalent to converting a string directly to &lt;code&gt;float&lt;/code&gt;. For example, if first converted to an intermediate &lt;code&gt;double&lt;/code&gt; and then to &lt;code&gt;float&lt;/code&gt;, the string</source>
          <target state="translated">부동 소수점 리터럴의 유형을 결정하는 지정자 인 후행 형식 지정자 ( &lt;code&gt;1.0f&lt;/code&gt; 는 &lt;code&gt;float&lt;/code&gt; 값, &lt;code&gt;1.0d&lt;/code&gt; 는 &lt;code&gt;double&lt;/code&gt; 값임) 는이 메소드의 결과에 영향을 주지 &lt;em&gt;않습니다&lt;/em&gt; . 즉, 입력 문자열의 숫자 값이 대상 부동 소수점 유형으로 직접 변환됩니다. 일반적으로 변환하는 2 단계의 순서, 문자열하는 &lt;code&gt;double&lt;/code&gt; 이어서 &lt;code&gt;double&lt;/code&gt; 하는 &lt;code&gt;float&lt;/code&gt; 이다 &lt;em&gt;하지&lt;/em&gt; 에 직접 열로 변환하는 것과 &lt;code&gt;float&lt;/code&gt; . 예를 들어, 먼저 중간 &lt;code&gt;double&lt;/code&gt; 로 변환 한 다음 &lt;code&gt;float&lt;/code&gt; 로 변환하면, 문자열</target>
        </trans-unit>
        <trans-unit id="6716acfb0124f8d53ffe289e1b47bcf968a971e7" translate="yes" xml:space="preserve">
          <source>Note that trailing format specifiers, specifiers that determine the type of a floating-point literal (&lt;code&gt;1.0f&lt;/code&gt; is a &lt;code&gt;float&lt;/code&gt; value; &lt;code&gt;1.0d&lt;/code&gt; is a &lt;code&gt;double&lt;/code&gt; value), do &lt;em&gt;not&lt;/em&gt; influence the results of this method. In other words, the numerical value of the input string is converted directly to the target floating-point type. The two-step sequence of conversions, string to &lt;code&gt;float&lt;/code&gt; followed by &lt;code&gt;float&lt;/code&gt; to &lt;code&gt;double&lt;/code&gt;, is &lt;em&gt;not&lt;/em&gt; equivalent to converting a string directly to &lt;code&gt;double&lt;/code&gt;. For example, the &lt;code&gt;float&lt;/code&gt; literal &lt;code&gt;0.1f&lt;/code&gt; is equal to the &lt;code&gt;double&lt;/code&gt; value &lt;code&gt;0.10000000149011612&lt;/code&gt;; the &lt;code&gt;float&lt;/code&gt; literal &lt;code&gt;0.1f&lt;/code&gt; represents a different numerical value than the &lt;code&gt;double&lt;/code&gt; literal &lt;code&gt;0.1&lt;/code&gt;. (The numerical value 0.1 cannot be exactly represented in a binary floating-point number.)</source>
          <target state="translated">부동 소수점 리터럴의 유형을 결정하는 지정자 인 후행 형식 지정자 ( &lt;code&gt;1.0f&lt;/code&gt; 는 &lt;code&gt;float&lt;/code&gt; 값, &lt;code&gt;1.0d&lt;/code&gt; 는 &lt;code&gt;double&lt;/code&gt; 값임) 는이 메소드의 결과에 영향을 주지 &lt;em&gt;않습니다&lt;/em&gt; . 즉, 입력 문자열의 숫자 값이 대상 부동 소수점 유형으로 직접 변환됩니다. 전환 문자열의 2 단계의 시퀀스는하기 &lt;code&gt;float&lt;/code&gt; 를 이어서 &lt;code&gt;float&lt;/code&gt; 하는 &lt;code&gt;double&lt;/code&gt; 이다 &lt;em&gt;하지&lt;/em&gt; 에 직접 열로 변환하는 것과 &lt;code&gt;double&lt;/code&gt; . 예를 들어, &lt;code&gt;float&lt;/code&gt; 리터럴 &lt;code&gt;0.1f&lt;/code&gt; 는 &lt;code&gt;double&lt;/code&gt; 과 같습니다.값 &lt;code&gt;0.10000000149011612&lt;/code&gt; ; &lt;code&gt;float&lt;/code&gt; 리터럴 &lt;code&gt;0.1f&lt;/code&gt; 댄 다른 수치를 나타내고 &lt;code&gt;double&lt;/code&gt; 리터럴 &lt;code&gt;0.1&lt;/code&gt; . 숫자 0.1은 이진 부동 소수점 숫자로 정확하게 표현할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fcef5cfdd10d59acbdf3f4548f1f32292907968d" translate="yes" xml:space="preserve">
          <source>Note that unless a query method exists for a capability, it must be supported by all &lt;code&gt;ImageReader&lt;/code&gt; implementations (</source>
          <target state="translated">기능에 대한 쿼리 메소드가 없으면 모든 &lt;code&gt;ImageReader&lt;/code&gt; 구현에서 지원해야합니다 (</target>
        </trans-unit>
        <trans-unit id="d366be049fdb017948d0324c3732cd70c194a8c5" translate="yes" xml:space="preserve">
          <source>Note that unless a query method exists for a capability, it must be supported by all &lt;code&gt;ImageWriter&lt;/code&gt; implementations (</source>
          <target state="translated">기능에 대한 쿼리 메소드가 존재하지 않으면 모든 &lt;code&gt;ImageWriter&lt;/code&gt; 구현에서 지원되어야합니다 (</target>
        </trans-unit>
        <trans-unit id="e1cb4f0ec383633bbf43f9b612cc119172f5fa55" translate="yes" xml:space="preserve">
          <source>Note that unlike the &lt;a href=&quot;../io/closeable#close()&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;../io/closeable&quot;&gt;&lt;code&gt;Closeable&lt;/code&gt;&lt;/a&gt;, this &lt;code&gt;close&lt;/code&gt; method is &lt;em&gt;not&lt;/em&gt; required to be idempotent. In other words, calling this &lt;code&gt;close&lt;/code&gt; method more than once may have some visible side effect, unlike &lt;code&gt;Closeable.close&lt;/code&gt; which is required to have no effect if called more than once. However, implementers of this interface are strongly encouraged to make their &lt;code&gt;close&lt;/code&gt; methods idempotent.</source>
          <target state="translated">달리합니다 &lt;a href=&quot;../io/closeable#close()&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 방법 &lt;a href=&quot;../io/closeable&quot;&gt; &lt;code&gt;Closeable&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;close&lt;/code&gt; 방법입니다 &lt;em&gt;하지&lt;/em&gt; 나무 등이 요구. 즉,이 &lt;code&gt;close&lt;/code&gt; 메소드를 두 번 이상 호출하면 두 번 이상 호출하면 효과 가 없어야하는 &lt;code&gt;Closeable.close&lt;/code&gt; 와는 달리 눈에 보이는 부작용이있을 수 있습니다 . 그러나이 인터페이스의 구현자는 &lt;code&gt;close&lt;/code&gt; 를 강력히 권장합니다. 메소드를 멱등 적 .</target>
        </trans-unit>
        <trans-unit id="a30da7354901dee5f1d818bad173553c3e9b94a2" translate="yes" xml:space="preserve">
          <source>Note that unlike the &lt;a href=&quot;../io/closeable#close--&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;../io/closeable&quot;&gt;&lt;code&gt;Closeable&lt;/code&gt;&lt;/a&gt;, this &lt;code&gt;close&lt;/code&gt; method is &lt;em&gt;not&lt;/em&gt; required to be idempotent. In other words, calling this &lt;code&gt;close&lt;/code&gt; method more than once may have some visible side effect, unlike &lt;code&gt;Closeable.close&lt;/code&gt; which is required to have no effect if called more than once. However, implementers of this interface are strongly encouraged to make their &lt;code&gt;close&lt;/code&gt; methods idempotent.</source>
          <target state="translated">달리합니다 &lt;a href=&quot;../io/closeable#close--&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 방법 &lt;a href=&quot;../io/closeable&quot;&gt; &lt;code&gt;Closeable&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;close&lt;/code&gt; 방법입니다 &lt;em&gt;하지&lt;/em&gt; 나무 등이 요구. 다시 말해,이 &lt;code&gt;close&lt;/code&gt; 메소드를 두 번 이상 호출하면 &lt;code&gt;Closeable.close&lt;/code&gt; 와는 달리 한 번 이상 호출해도 아무런 영향을 미치지 않는 부작용이있을 수 있습니다. 그러나이 인터페이스의 구현자는 &lt;code&gt;close&lt;/code&gt; 메소드를 dem 등원 으로 만들 것을 강력히 권장합니다 .</target>
        </trans-unit>
        <trans-unit id="463b310cfe0a3025153890ea8ed2d15070d4468b" translate="yes" xml:space="preserve">
          <source>Note that updates to &lt;code&gt;Attribute&lt;/code&gt; (such as adding or removing a value) do not affect the corresponding representation of the attribute in the directory. Updates to the directory can only be effected using operations in the &lt;code&gt;DirContext&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;Attribute&lt;/code&gt; 대한 업데이트 (예 : 값 추가 또는 제거)는 디렉토리에서 해당 속성의 표현에 영향을 미치지 않습니다. 디렉토리 업데이트는 &lt;code&gt;DirContext&lt;/code&gt; 인터페이스의 조작을 통해서만 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9658d928e17ed5bc32b8907400db77094be24023" translate="yes" xml:space="preserve">
          <source>Note that updates to &lt;code&gt;BasicAttribute&lt;/code&gt; (such as adding or removing a value) does not affect the corresponding representation of the attribute in the directory. Updates to the directory can only be effected using operations in the &lt;code&gt;DirContext&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;BasicAttribute&lt;/code&gt; 에 대한 업데이트 (예 : 값 추가 또는 제거)는 디렉토리의 해당 속성 표현에 영향을 미치지 않습니다. 디렉토리 업데이트는 &lt;code&gt;DirContext&lt;/code&gt; 인터페이스의 조작을 통해서만 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d9cc65a9f73f29d33f4ea5be300462a48c22763" translate="yes" xml:space="preserve">
          <source>Note that updates to Attributes (such as adding or removing an attribute) do not affect the corresponding representation in the directory. Updates to the directory can only be effected using operations in the DirContext interface.</source>
          <target state="translated">속성 업데이트 (예 : 속성 추가 또는 제거)는 디렉토리의 해당 표현에 영향을 미치지 않습니다. 디렉토리 업데이트는 DirContext 인터페이스의 조작을 통해서만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="750ce2520a6a585da6d396316ab26f61252e2cb5" translate="yes" xml:space="preserve">
          <source>Note that updates to BasicAttributes (such as adding or removing an attribute) does not affect the corresponding representation in the directory. Updates to the directory can only be effected using operations in the DirContext interface.</source>
          <target state="translated">속성 추가 또는 제거와 같은 BasicAttributes 업데이트는 디렉토리의 해당 표현에 영향을 미치지 않습니다. 디렉토리 업데이트는 DirContext 인터페이스의 조작을 통해서만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4ae42cc278ca49314365093d2e8dd37bbe8b83" translate="yes" xml:space="preserve">
          <source>Note that user code cannot perform such an action directly in a subclass constructor, since the target must be fixed before the &lt;code&gt;ConstantCallSite&lt;/code&gt; constructor returns.</source>
          <target state="translated">&lt;code&gt;ConstantCallSite&lt;/code&gt; 생성자가 반환 되기 전에 대상을 수정해야하므로 사용자 코드는 서브 클래스 생성자에서 직접 이러한 작업을 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f79ec50bd9087460aae4469560b406104ab064d0" translate="yes" xml:space="preserve">
          <source>Note that we declare the value of the returned expression so that the value of the expression (as returned by &lt;code&gt;getValue&lt;/code&gt;) will be identical to &lt;code&gt;oldInstance&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;getValue&lt;/code&gt; 로 반환 된 표현식의 값이 &lt;code&gt;oldInstance&lt;/code&gt; 와 동일하도록 반환 된 표현식의 값을 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="c75e9a6ff05a55d9a150fd1393998104746b2424" translate="yes" xml:space="preserve">
          <source>Note that when a &lt;code&gt;PKIXRevocationChecker&lt;/code&gt; is added to &lt;code&gt;PKIXParameters&lt;/code&gt;, it clones the &lt;code&gt;PKIXRevocationChecker&lt;/code&gt;; thus any subsequent modifications to the &lt;code&gt;PKIXRevocationChecker&lt;/code&gt; have no effect.</source>
          <target state="translated">때 참고 &lt;code&gt;PKIXRevocationChecker&lt;/code&gt; 이 추가됩니다 &lt;code&gt;PKIXParameters&lt;/code&gt; , 그것은 클론 &lt;code&gt;PKIXRevocationChecker&lt;/code&gt; 을 ; 따라서 &lt;code&gt;PKIXRevocationChecker&lt;/code&gt; 에 대한 후속 수정 사항 은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="473638d91537ea67128bf789916fd2efeb4aa2db" translate="yes" xml:space="preserve">
          <source>Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.</source>
          <target state="translated">Cipher 객체가 초기화되면 이전에 획득 한 모든 상태가 손실됩니다. 즉, 암호를 초기화하는 것은 해당 암호의 새 인스턴스를 작성하고 초기화하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="300a2db0a001c3ca5ab320a539a7a1566452da5e" translate="yes" xml:space="preserve">
          <source>Note that when multiple windows is grouped in the task area the behavior is platform specific.</source>
          <target state="translated">작업 영역에 여러 개의 창이 그룹화되어있는 경우 동작은 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7ccbb44d396138e99d2c81b88d2a1f2ee0b1dc2f" translate="yes" xml:space="preserve">
          <source>Note that when one exception &lt;a href=&quot;#initCause(java.lang.Throwable)&quot;&gt;causes&lt;/a&gt; another exception, the first exception is usually caught and then the second exception is thrown in response. In other words, there is a causal connection between the two exceptions. In contrast, there are situations where two independent exceptions can be thrown in sibling code blocks, in particular in the &lt;code&gt;try&lt;/code&gt; block of a &lt;code&gt;try&lt;/code&gt;-with-resources statement and the compiler-generated &lt;code&gt;finally&lt;/code&gt; block which closes the resource. In these situations, only one of the thrown exceptions can be propagated. In the &lt;code&gt;try&lt;/code&gt;-with-resources statement, when there are two such exceptions, the exception originating from the &lt;code&gt;try&lt;/code&gt; block is propagated and the exception from the &lt;code&gt;finally&lt;/code&gt; block is added to the list of exceptions suppressed by the exception from the &lt;code&gt;try&lt;/code&gt; block. As an exception unwinds the stack, it can accumulate multiple suppressed exceptions.</source>
          <target state="translated">한 예외로 &lt;a href=&quot;#initCause(java.lang.Throwable)&quot;&gt;인해&lt;/a&gt; 다른 예외가 발생 하면 일반적으로 첫 번째 예외가 포착되고 응답으로 두 번째 예외가 발생합니다. 즉, 두 예외 사이에는 인과 관계가 있습니다. 반대로 형제 코드 블록, 특히 &lt;code&gt;try&lt;/code&gt; -with-resources 문의 &lt;code&gt;try&lt;/code&gt; 블록과 리소스 를 닫는 컴파일러 생성 &lt;code&gt;finally&lt;/code&gt; 블록 에서 두 개의 독립적 인 예외가 발생할 수있는 상황 이 있습니다. 이러한 상황에서는 throw 된 예외 중 하나만 전파 될 수 있습니다. 에서 &lt;code&gt;try&lt;/code&gt; 가진 - - 자원 문, 때이 개 같은 예외로부터 예외 원래가 &lt;code&gt;try&lt;/code&gt; 블록 전파되고에서 예외가 &lt;code&gt;finally&lt;/code&gt; 블록은 &lt;code&gt;try&lt;/code&gt; 블록 의 예외에 의해 억제 된 예외 목록에 추가됩니다 . 예외로 인해 스택이 해제되므로 억제 된 여러 예외가 누적 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d407988a5b8d89845a30695f7bfe6e712dd9bc67" translate="yes" xml:space="preserve">
          <source>Note that when one exception &lt;a href=&quot;throwable#initCause-java.lang.Throwable-&quot;&gt;causes&lt;/a&gt; another exception, the first exception is usually caught and then the second exception is thrown in response. In other words, there is a causal connection between the two exceptions. In contrast, there are situations where two independent exceptions can be thrown in sibling code blocks, in particular in the &lt;code&gt;try&lt;/code&gt; block of a &lt;code&gt;try&lt;/code&gt;-with-resources statement and the compiler-generated &lt;code&gt;finally&lt;/code&gt; block which closes the resource. In these situations, only one of the thrown exceptions can be propagated. In the &lt;code&gt;try&lt;/code&gt;-with-resources statement, when there are two such exceptions, the exception originating from the &lt;code&gt;try&lt;/code&gt; block is propagated and the exception from the &lt;code&gt;finally&lt;/code&gt; block is added to the list of exceptions suppressed by the exception from the &lt;code&gt;try&lt;/code&gt; block. As an exception unwinds the stack, it can accumulate multiple suppressed exceptions.</source>
          <target state="translated">한 예외에서 다른 예외가 발생 &lt;a href=&quot;throwable#initCause-java.lang.Throwable-&quot;&gt;하면&lt;/a&gt; 일반적으로 첫 번째 예외가 발생하고 두 번째 예외가 응답으로 발생합니다. 다시 말해, 두 예외 사이에는 인과 관계가 있습니다. 반대로 형제 코드 블록, 특히 &lt;code&gt;try&lt;/code&gt; -with-resources 문의 &lt;code&gt;try&lt;/code&gt; 블록 및 리소스 를 닫는 컴파일러 생성 &lt;code&gt;finally&lt;/code&gt; 블록 에서 두 개의 독립적 인 예외가 발생할 수 있습니다 . 이러한 상황에서는 예외 중 하나만 전파 될 수 있습니다. 에서 &lt;code&gt;try&lt;/code&gt; 가진 - - 자원 문, 때이 개 같은 예외로부터 예외 원래가 &lt;code&gt;try&lt;/code&gt; 블록 전파되고에서 예외가 &lt;code&gt;finally&lt;/code&gt; 블록은 &lt;code&gt;try&lt;/code&gt; 블록 의 예외에 의해 억제 된 예외 목록에 추가됩니다 . 예외가 스택을 풀면 억제 된 여러 예외가 누적 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a5969c36884031eafa96ad5f4f9d137d63672fc" translate="yes" xml:space="preserve">
          <source>Note that when the expected length of the response APDU is specified in the &lt;a href=&quot;#%3Cinit%3E(int,int,int,int,int)&quot;&gt;constructors&lt;/a&gt;, the actual length (Ne) must be specified, not its encoded form (Le). Similarly, &lt;a href=&quot;#getNe()&quot;&gt;getNe()&lt;/a&gt; returns the actual value Ne. In other words, a value of 0 means &quot;no data in the response APDU&quot; rather than &quot;maximum length.&quot;</source>
          <target state="translated">응답 APDU의 예상 길이가 &lt;a href=&quot;#%3Cinit%3E(int,int,int,int,int)&quot;&gt;생성자&lt;/a&gt; 에 지정되면 인코딩 된 형식 (Le)이 ​​아니라 실제 길이 (Ne)를 지정해야합니다. 마찬가지로 &lt;a href=&quot;#getNe()&quot;&gt;getNe ()&lt;/a&gt; 는 실제 값 Ne를 반환합니다. 즉, 값이 0이면 &quot;최대 길이&quot;가 아니라 &quot;응답 APDU에 데이터가 없음&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="87f57622cf6b5f42a3c92ce69152ee817f8a71fc" translate="yes" xml:space="preserve">
          <source>Note that when this abstract pathname represents a UNC pathname then all components of the UNC (including the server name component) are encoded in the &lt;code&gt;URI&lt;/code&gt; path. The authority component is undefined, meaning that it is represented as &lt;code&gt;null&lt;/code&gt;. The &lt;a href=&quot;../nio/file/path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/path#toUri()&quot;&gt;&lt;code&gt;toUri&lt;/code&gt;&lt;/a&gt; method to encode the server name in the authority component of the resulting &lt;code&gt;URI&lt;/code&gt;. The &lt;a href=&quot;#toPath()&quot;&gt;&lt;code&gt;toPath&lt;/code&gt;&lt;/a&gt; method may be used to obtain a &lt;code&gt;Path&lt;/code&gt; representing this abstract pathname.</source>
          <target state="translated">이 추상 경로 이름이 UNC 경로 이름을 나타내는 경우 UNC의 모든 구성 요소 (서버 이름 구성 요소 포함)가 &lt;code&gt;URI&lt;/code&gt; 경로에 인코딩됩니다 . 권한 구성 요소가 정의되지 않았으며 이는 &lt;code&gt;null&lt;/code&gt; 로 표시됨을 의미합니다 . &lt;a href=&quot;../nio/file/path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 클래스는 정의 &lt;a href=&quot;../nio/file/path#toUri()&quot;&gt; &lt;code&gt;toUri&lt;/code&gt; &lt;/a&gt; 결과의 기관 컴퍼넌트에 서버 이름을 인코딩하는 방법 &lt;code&gt;URI&lt;/code&gt; 를 . &lt;a href=&quot;#toPath()&quot;&gt; &lt;code&gt;toPath&lt;/code&gt; 의&lt;/a&gt; 방법은 얻을 수 있습니다 &lt;code&gt;Path&lt;/code&gt; 이 추상 패스를 표현합니다.</target>
        </trans-unit>
        <trans-unit id="8010171859f8ce8e980b17a675037b7e43dc29a9" translate="yes" xml:space="preserve">
          <source>Note that when this abstract pathname represents a UNC pathname then all components of the UNC (including the server name component) are encoded in the &lt;code&gt;URI&lt;/code&gt; path. The authority component is undefined, meaning that it is represented as &lt;code&gt;null&lt;/code&gt;. The &lt;a href=&quot;../nio/file/path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; class defines the &lt;a href=&quot;../nio/file/path#toUri--&quot;&gt;&lt;code&gt;toUri&lt;/code&gt;&lt;/a&gt; method to encode the server name in the authority component of the resulting &lt;code&gt;URI&lt;/code&gt;. The &lt;a href=&quot;file#toPath--&quot;&gt;&lt;code&gt;toPath&lt;/code&gt;&lt;/a&gt; method may be used to obtain a &lt;code&gt;Path&lt;/code&gt; representing this abstract pathname.</source>
          <target state="translated">이 추상 경로 이름이 UNC 경로 이름을 나타내는 경우 UNC의 모든 구성 요소 (서버 이름 구성 요소 포함)가 &lt;code&gt;URI&lt;/code&gt; 경로 로 인코딩됩니다 . 권한 구성 요소가 정의되지 않았으므로 이는 &lt;code&gt;null&lt;/code&gt; 로 표시됩니다 . &lt;a href=&quot;../nio/file/path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 클래스는 정의 &lt;a href=&quot;../nio/file/path#toUri--&quot;&gt; &lt;code&gt;toUri&lt;/code&gt; &lt;/a&gt; 결과의 기관 컴퍼넌트에 서버 이름을 인코딩하는 방법 &lt;code&gt;URI&lt;/code&gt; 를 . &lt;a href=&quot;file#toPath--&quot;&gt; &lt;code&gt;toPath&lt;/code&gt; 의&lt;/a&gt; 방법은 얻을 수 있습니다 &lt;code&gt;Path&lt;/code&gt; 이 추상 패스를 표현합니다.</target>
        </trans-unit>
        <trans-unit id="635e35af1584073cab6870c5956117e7936c22ce" translate="yes" xml:space="preserve">
          <source>Note that when using an enumeration type as the type of a set or as the type of the keys in a map, specialized and efficient &lt;a href=&quot;../util/enumset&quot;&gt;set&lt;/a&gt; and &lt;a href=&quot;../util/enummap&quot;&gt;map&lt;/a&gt; implementations are available.</source>
          <target state="translated">열거 유형을 세트의 유형 또는 맵의 키 유형으로 사용하는 경우 특수하고 효율적인 &lt;a href=&quot;../util/enumset&quot;&gt;세트&lt;/a&gt; 및 &lt;a href=&quot;../util/enummap&quot;&gt;맵&lt;/a&gt; 구현을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="096ca5bac8931eb0075687206638be08dcde240b" translate="yes" xml:space="preserve">
          <source>Note that while some implementations of &lt;code&gt;InputStream&lt;/code&gt; will return the total number of bytes in the stream, many will not. It is never correct to use the return value of this method to allocate a buffer intended to hold all data in this stream.</source>
          <target state="translated">&lt;code&gt;InputStream&lt;/code&gt; 의 일부 구현은 스트림의 총 바이트 수를 반환하지만 대부분은 그렇지 않습니다. 이 스트림 내의 모든 데이터를 보관 유지하기위한 버퍼를 할당하기 위해서,이 메서드의 반환 값을 사용하는 것은 결코 올바른 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fb21d9190ee8fde43a50a9160cc07aba90233f74" translate="yes" xml:space="preserve">
          <source>Note that while tasks running within such threads will have the same access control and class loader settings as the current thread, they need not have the same &lt;a href=&quot;../../lang/threadlocal&quot;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../lang/inheritablethreadlocal&quot;&gt;&lt;code&gt;InheritableThreadLocal&lt;/code&gt;&lt;/a&gt; values. If necessary, particular values of thread locals can be set or reset before any task runs in &lt;a href=&quot;threadpoolexecutor&quot;&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/a&gt; subclasses using &lt;a href=&quot;threadpoolexecutor#beforeExecute(java.lang.Thread,java.lang.Runnable)&quot;&gt;&lt;code&gt;ThreadPoolExecutor.beforeExecute(Thread, Runnable)&lt;/code&gt;&lt;/a&gt;. Also, if it is necessary to initialize worker threads to have the same InheritableThreadLocal settings as some other designated thread, you can create a custom ThreadFactory in which that thread waits for and services requests to create others that will inherit its values.</source>
          <target state="translated">이러한 스레드 내에서 실행되는 작업은 현재 스레드와 동일한 액세스 제어 및 클래스 로더 설정을 &lt;a href=&quot;../../lang/threadlocal&quot;&gt; &lt;code&gt;ThreadLocal&lt;/code&gt; &lt;/a&gt; 동일한 ThreadLocal 또는 &lt;a href=&quot;../../lang/inheritablethreadlocal&quot;&gt; &lt;code&gt;InheritableThreadLocal&lt;/code&gt; &lt;/a&gt; 값을 가질 필요는 없습니다 . 필요한 경우, 스레드 지역 주민의 특정 값이 설정 될 또는 모든 작업이 실행되기 전에 재설정 할 수 &lt;a href=&quot;threadpoolexecutor&quot;&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; &lt;/a&gt; 사용 서브 클래스 &lt;a href=&quot;threadpoolexecutor#beforeExecute(java.lang.Thread,java.lang.Runnable)&quot;&gt; &lt;code&gt;ThreadPoolExecutor.beforeExecute(Thread, Runnable)&lt;/code&gt; &lt;/a&gt; . 또한 지정된 다른 스레드와 동일한 InheritableThreadLocal 설정을 갖도록 작업자 스레드를 초기화해야하는 경우 해당 스레드가 대기하고 값을 상속 할 다른 스레드를 생성하도록 요청을 처리하는 사용자 지정 ThreadFactory를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e65c28c5d460ba343c8a5353abb3934f52b76850" translate="yes" xml:space="preserve">
          <source>Note that while tasks running within such threads will have the same access control and class loader settings as the current thread, they need not have the same &lt;a href=&quot;../../lang/threadlocal&quot;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../lang/inheritablethreadlocal&quot;&gt;&lt;code&gt;InheritableThreadLocal&lt;/code&gt;&lt;/a&gt; values. If necessary, particular values of thread locals can be set or reset before any task runs in &lt;a href=&quot;threadpoolexecutor&quot;&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/a&gt; subclasses using &lt;a href=&quot;threadpoolexecutor#beforeExecute-java.lang.Thread-java.lang.Runnable-&quot;&gt;&lt;code&gt;ThreadPoolExecutor.beforeExecute(Thread, Runnable)&lt;/code&gt;&lt;/a&gt;. Also, if it is necessary to initialize worker threads to have the same InheritableThreadLocal settings as some other designated thread, you can create a custom ThreadFactory in which that thread waits for and services requests to create others that will inherit its values.</source>
          <target state="translated">이러한 스레드 내에서 실행되는 작업은 현재 스레드와 동일한 액세스 제어 및 클래스 로더 설정을 &lt;a href=&quot;../../lang/threadlocal&quot;&gt; &lt;code&gt;ThreadLocal&lt;/code&gt; &lt;/a&gt; 동일한 ThreadLocal 또는 &lt;a href=&quot;../../lang/inheritablethreadlocal&quot;&gt; &lt;code&gt;InheritableThreadLocal&lt;/code&gt; &lt;/a&gt; 값을 가질 필요는 없습니다 . 필요한 경우, 스레드 지역 주민의 특정 값 설정을 할 수 또는 모든 작업이 실행되기 전에 재설정 할 수 &lt;a href=&quot;threadpoolexecutor&quot;&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; &lt;/a&gt; 사용 서브 클래스 &lt;a href=&quot;threadpoolexecutor#beforeExecute-java.lang.Thread-java.lang.Runnable-&quot;&gt; &lt;code&gt;ThreadPoolExecutor.beforeExecute(Thread, Runnable)&lt;/code&gt; &lt;/a&gt; . 또한 지정된 다른 스레드와 동일한 InheritableThreadLocal 설정을 갖도록 작업자 스레드를 초기화해야하는 경우 해당 스레드가 대기하고 서비스 요청이 해당 값을 상속 할 다른 스레드를 작성하도록 요청하는 사용자 정의 ThreadFactory를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e100312f904c8d8b5483aa1dd39df75ec3b71ab5" translate="yes" xml:space="preserve">
          <source>Note that while there are a large number of classes representing different aspects of dates, there are relatively few dealing with different aspects of time. Following type-safety to its logical conclusion would have resulted in classes for hour-minute, hour-minute-second and hour-minute-second-nanosecond. While logically pure, this was not a practical option as it would have almost tripled the number of classes due to the combinations of date and time. Thus, &lt;code&gt;LocalTime&lt;/code&gt; is used for all precisions of time, with zeroes used to imply lower precision.</source>
          <target state="translated">날짜의 다른 측면을 나타내는 많은 클래스가 있지만 시간의 다른 측면을 다루는 것은 상대적으로 적습니다. 논리적 결론에 따른 유형 안전성에 따라 시간-분,시-분-초 및 시간-분-초-나노초의 클래스가 생겼을 것입니다. 논리적으로 순수하지만 날짜와 시간의 조합으로 인해 클래스 수를 거의 세 배로 늘렸으므로 실용적인 옵션은 아니 었습니다. 따라서 &lt;code&gt;LocalTime&lt;/code&gt; 은 모든 정밀도에 사용되며 0은 정밀도를 낮추는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="235c832a76e8a80ded3ea667d040f28fd40e430c" translate="yes" xml:space="preserve">
          <source>Note that while this method is very convenient, using it will imply an assumed reference to the default &lt;code&gt;FileSystem&lt;/code&gt; and limit the utility of the calling code. Hence it should not be used in library code intended for flexible reuse. A more flexible alternative is to use an existing &lt;code&gt;Path&lt;/code&gt; instance as an anchor, such as:</source>
          <target state="translated">이 방법은 매우 편리하지만이 방법을 사용하면 기본 &lt;code&gt;FileSystem&lt;/code&gt; 에 대한 가정 된 참조를 나타내며 호출 코드의 유틸리티가 제한됩니다. 따라서 유연한 재사용을 목적으로하는 라이브러리 코드에는 사용해서는 안됩니다. 보다 유연한 대안은 기존 &lt;code&gt;Path&lt;/code&gt; 인스턴스를 다음과 같은 앵커로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="42119696d3ecadf8ddca514373c793769844a59d" translate="yes" xml:space="preserve">
          <source>Note that you &lt;em&gt;cannot&lt;/em&gt; always tell if an attempt to insert an element will succeed by inspecting &lt;code&gt;remainingCapacity&lt;/code&gt; because it may be the case that another thread is about to insert or remove an element.</source>
          <target state="translated">당신이주의 &lt;em&gt;할 수없는&lt;/em&gt; 요소를 삽입하는 시도가 검사하여 성공하면 항상 이야기 &lt;code&gt;remainingCapacity&lt;/code&gt; 또 다른 스레드 삽입하거나 요소를 제거하기에 관하여 인 경우 될 수 있기 때문이다.</target>
        </trans-unit>
        <trans-unit id="e4839f77da1e7400cd3ad07ff82c23bd1d881cd6" translate="yes" xml:space="preserve">
          <source>Note that you don't use this method to find out which instruments are currently loaded onto the synthesizer; for that purpose, you use &lt;code&gt;getLoadedInstruments()&lt;/code&gt;. Nor does the method indicate all the instruments that can be loaded onto the synthesizer; it only indicates the subset that come with the synthesizer. To learn whether another instrument can be loaded, you can invoke &lt;code&gt;isSoundbankSupported()&lt;/code&gt;, and if the instrument's &lt;code&gt;Soundbank&lt;/code&gt; is supported, you can try loading the instrument.</source>
          <target state="translated">신디사이저에 현재로드 된 악기를 찾기 위해이 방법을 사용하지 않습니다. 이를 위해 &lt;code&gt;getLoadedInstruments()&lt;/code&gt; 를 사용 합니다 . 이 방법은 신시사이저에로드 할 수있는 모든 악기를 나타내지 않습니다. 신디사이저와 함께 제공되는 부분 집합 만 나타냅니다. 다른 악기를로드 할 수 있는지 알아 보려면 &lt;code&gt;isSoundbankSupported()&lt;/code&gt; 호출 하고 악기의 &lt;code&gt;Soundbank&lt;/code&gt; 가 지원되는 경우 악기를로드 해보십시오.</target>
        </trans-unit>
        <trans-unit id="75e1575269eadeeb8434f2d0c79e9cbd283bd74a" translate="yes" xml:space="preserve">
          <source>Note that, as a consequence of the above rules, the bootstrap method may accept a primitive argument, if it can be represented by a constant pool entry. However, arguments of type &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, or &lt;code&gt;char&lt;/code&gt; cannot be created for bootstrap methods, since such constants cannot be directly represented in the constant pool, and the invocation of the bootstrap method will not perform the necessary narrowing primitive conversions.</source>
          <target state="translated">위 규칙의 결과로 부트 스트랩 메소드는 상수 풀 항목으로 표시 될 수있는 경우 기본 인수를 승인 할 수 있습니다. 그러나 상수 풀에서 상수를 직접 표현할 수 없으므로 부트 스트랩 메소드에 대해 &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;byte&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; 또는 &lt;code&gt;char&lt;/code&gt; 유형의 인수를 작성할 수 없으며 부트 스트랩 메소드를 호출하면 필요한 축소 기본 변환을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="712ca22ba90f577e307971b0b5b345db88cbe031" translate="yes" xml:space="preserve">
          <source>Note that, in every case, neither &lt;code&gt;L&lt;/code&gt; (&lt;code&gt;'\u004C'&lt;/code&gt;) nor &lt;code&gt;l&lt;/code&gt; (&lt;code&gt;'\u006C'&lt;/code&gt;) is permitted to appear at the end of the property value as a type indicator, as would be permitted in Java programming language source code.</source>
          <target state="translated">모든 경우 에 Java 프로그래밍 언어 소스 코드에서 허용되는 것처럼 &lt;code&gt;L&lt;/code&gt; ( &lt;code&gt;'\u004C'&lt;/code&gt; ) 및 &lt;code&gt;l&lt;/code&gt; ( &lt;code&gt;'\u006C'&lt;/code&gt; )은 특성 값의 끝에 유형 표시 자로 표시 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="07f4e5af4d2e7cce73f43342b4c4feb9f7ca2d08" translate="yes" xml:space="preserve">
          <source>Note that, per &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;RFC 6066&lt;/a&gt;, the returned hostname may be an internationalized domain name that contains A-labels. See &lt;a href=&quot;http://www.ietf.org/rfc/rfc5890.txt&quot;&gt;RFC 5890&lt;/a&gt; for more information about the detailed A-label specification.</source>
          <target state="translated">그 주, 당 &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;RFC 6066&lt;/a&gt; , 반환 된 호스트 이름은 A-라벨을 포함하는 국제화 된 도메인 이름 일 수도있다. 자세한 A- 라벨 사양에 대한 자세한 내용은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc5890.txt&quot;&gt;RFC 5890&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="77516cf2fb9e01ababe923552c392c12f3052832" translate="yes" xml:space="preserve">
          <source>Note the prefix value is &lt;strong&gt;&lt;em&gt;NOT&lt;/em&gt;&lt;/strong&gt; returned as part of the &lt;code&gt;String&lt;/code&gt; representation.</source>
          <target state="translated">접두사 값은 &lt;code&gt;String&lt;/code&gt; 일부로 반환 &lt;strong&gt;&lt;em&gt;되지 않습니다.&lt;/em&gt;&lt;/strong&gt; 표현의 .</target>
        </trans-unit>
        <trans-unit id="495a6f1c8c0b0b4b96ed615b23e5da838f33dc77" translate="yes" xml:space="preserve">
          <source>Note the presence of lines containing the characters &lt;code&gt;&quot;...&quot;&lt;/code&gt;. These lines indicate that the remainder of the stack trace for this exception matches the indicated number of frames from the bottom of the stack trace of the exception that was caused by this exception (the &quot;enclosing&quot; exception). This shorthand can greatly reduce the length of the output in the common case where a wrapped exception is thrown from same method as the &quot;causative exception&quot; is caught. The above example was produced by running the program:</source>
          <target state="translated">&lt;code&gt;&quot;...&quot;&lt;/code&gt; 문자를 포함하는 행이 있는지 확인하십시오 . 이 행은이 예외에 대한 나머지 스택 추적이이 예외로 인해 발생한 예외 ( &quot;클로 싱&quot;예외)의 스택 추적 맨 아래부터 표시된 프레임 수와 일치 함을 나타냅니다. 이 속기는 &quot;원인 예외&quot;가 발생하는 것과 같은 방법으로 랩핑 된 예외가 발생하는 일반적인 경우 출력 길이를 크게 줄일 수 있습니다. 위 예제는 프로그램을 실행하여 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="10fe1fc9733f539af2c0011e136b7e2e97d0e17f" translate="yes" xml:space="preserve">
          <source>Note the term</source>
          <target state="translated">용어를 참고하십시오</target>
        </trans-unit>
        <trans-unit id="7b2ccf196feed5bf7fcff8d2d49a80db7f6e9ca5" translate="yes" xml:space="preserve">
          <source>Note these are not the same as the installed look and feels.</source>
          <target state="translated">이들은 설치된 모양과 느낌과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="341f4cface17a7596330a94ffc95a397337cf425" translate="yes" xml:space="preserve">
          <source>Note, all conforming implementations must support at least one &lt;code&gt;NetworkInterface&lt;/code&gt; object, which must either be connected to a network, or be a &quot;loopback&quot; interface that can only communicate with entities on the same machine.</source>
          <target state="translated">준수하는 모든 구현은 하나 이상의 &lt;code&gt;NetworkInterface&lt;/code&gt; 개체를 지원해야합니다.이 개체는 네트워크에 연결되어 있거나 동일한 컴퓨터의 엔터티와 만 통신 할 수있는 &quot;루프백&quot;인터페이스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="084c3539e8b26595361c61c6fa36633c74e6d1d2" translate="yes" xml:space="preserve">
          <source>Note, any URL instance that complies with RFC 2396 can be converted to a URI. However, some URLs that are not strictly in compliance can not be converted to a URI.</source>
          <target state="translated">RFC 2396을 준수하는 모든 URL 인스턴스는 URI로 변환 될 수 있습니다. 그러나 엄격하게 준수하지 않는 일부 URL은 URI로 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e2d1f3266163ca19cb060c172f09b6771ea53a1a" translate="yes" xml:space="preserve">
          <source>Note, if you do not specify a representation class when creating a &lt;code&gt;DataFlavor&lt;/code&gt;, the default representation class is used. See appropriate documentation for &lt;code&gt;DataFlavor&lt;/code&gt;'s constructors.</source>
          <target state="translated">&lt;code&gt;DataFlavor&lt;/code&gt; 를 만들 때 표현 클래스를 지정하지 않으면 기본 표현 클래스가 사용됩니다. &lt;code&gt;DataFlavor&lt;/code&gt; 생성자에 대한 적절한 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29145475c6b41db96b48e5a5de3ccad2255f094c" translate="yes" xml:space="preserve">
          <source>Note, only limited support is provided for handling incoming urgent data. In particular, no notification of incoming urgent data is provided and there is no capability to distinguish between normal data and urgent data unless provided by a higher level protocol.</source>
          <target state="translated">긴급 데이터 수신에 대한 지원은 제한적입니다. 특히, 긴급 데이터 수신에 대한 알림이 제공되지 않으며 상위 레벨 프로토콜에 의해 제공되지 않는 한 일반 데이터와 긴급 데이터를 구별 할 수있는 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e28b19f4cf6dfb7832cacb558945a2be00ef26cf" translate="yes" xml:space="preserve">
          <source>Note, that although InvalidPropertiesFormatException inherits Serializable interface from Exception, it is not intended to be Serializable. Appropriate serialization methods are implemented to throw NotSerializableException.</source>
          <target state="translated">InvalidPropertiesFormatException은 Exception에서 Serializable 인터페이스를 상속하지만 Serializable이 아닙니다. NotSerializableException을 발생시키기 위해 적절한 직렬화 메소드가 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="8d4b6b457cc5cdc10b1a20ebc442039387063f68" translate="yes" xml:space="preserve">
          <source>Note, that although NodeChangeEvent inherits Serializable interface from java.util.EventObject, it is not intended to be Serializable. Appropriate serialization methods are implemented to throw NotSerializableException.</source>
          <target state="translated">NodeChangeEvent는 java.util.EventObject에서 Serializable 인터페이스를 상속하지만 Serializable이 아닙니다. NotSerializableException을 발생시키기 위해 적절한 직렬화 메소드가 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="6dd561571f45d254c0c45958c4922d21e5682327" translate="yes" xml:space="preserve">
          <source>Note, that although PreferenceChangeEvent inherits Serializable interface from EventObject, it is not intended to be Serializable. Appropriate serialization methods are implemented to throw NotSerializableException.</source>
          <target state="translated">PreferenceChangeEvent는 EventObject에서 Serializable 인터페이스를 상속하지만 Serializable이 아닙니다. NotSerializableException을 발생시키기 위해 적절한 직렬화 메소드가 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="214391d9f91af17d005e04a8d8ab851efe21ab64" translate="yes" xml:space="preserve">
          <source>Note, that even though the pre-defined handlers do not examine the response code, the response code and headers are always retrievable from the &lt;a href=&quot;httpresponse&quot;&gt;&lt;code&gt;HttpResponse&lt;/code&gt;&lt;/a&gt;, when it is returned.</source>
          <target state="translated">미리 정의 된 처리기가 응답 코드를 검사하지 않더라도 응답 코드와 헤더 는 반환 될 때 항상 &lt;a href=&quot;httpresponse&quot;&gt; &lt;code&gt;HttpResponse&lt;/code&gt; &lt;/a&gt; 에서 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bd7e87c03806c8220816ba8ec6abf245afeedce" translate="yes" xml:space="preserve">
          <source>Note, that if the argument is equal to the value of Integer.MIN_VALUE, the most look and feels will not provide the scrolling to the right/down.</source>
          <target state="translated">인수가 Integer.MIN_VALUE의 값과 같으면 대부분의 모양과 느낌이 오른쪽 / 아래로 스크롤을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f38a9358dc4ad4564a3ec5b572aa862055d02e21" translate="yes" xml:space="preserve">
          <source>Note, that not all request headers may be set by user code. Some are restricted for security reasons and others such as the headers relating to authentication, redirection and cookie management may be managed by specific APIs rather than through directly user set headers.</source>
          <target state="translated">모든 요청 헤더가 사용자 코드로 설정되는 것은 아닙니다. 일부는 보안상의 이유로 제한되며 인증, 리디렉션 및 쿠키 관리와 관련된 헤더와 같은 일부는 직접 사용자 설정 헤더를 통하지 않고 특정 API에 의해 관리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0139a4fdaef91bf5619c5e533f6d5b29a102e12" translate="yes" xml:space="preserve">
          <source>Note, the &lt;a href=&quot;uri&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; class does perform escaping of its component fields in certain circumstances. The recommended way to manage the encoding and decoding of URLs is to use &lt;a href=&quot;uri&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt;, and to convert between these two classes using &lt;a href=&quot;#toURI()&quot;&gt;&lt;code&gt;toURI()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;uri#toURL()&quot;&gt;&lt;code&gt;URI.toURL()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고는 &lt;a href=&quot;uri&quot;&gt; &lt;code&gt;URI&lt;/code&gt; 의&lt;/a&gt; 클래스는 특정 상황에서의 구성 요소 필드의 탈출 수행 않습니다. URL의 인코딩 및 디코딩을 관리하는 권장 방법은 &lt;a href=&quot;uri&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 를 사용 하고 &lt;a href=&quot;#toURI()&quot;&gt; &lt;code&gt;toURI()&lt;/code&gt; &lt;/a&gt; 및 URI.toURL () 을 사용 &lt;a href=&quot;uri#toURL()&quot;&gt; &lt;code&gt;URI.toURL()&lt;/code&gt; &lt;/a&gt; 두 클래스간에 변환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7b9791ad29280564bc91eb9bf5bf14b3ec9cd93f" translate="yes" xml:space="preserve">
          <source>Note, the &lt;a href=&quot;uri&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt; class does perform escaping of its component fields in certain circumstances. The recommended way to manage the encoding and decoding of URLs is to use &lt;a href=&quot;uri&quot;&gt;&lt;code&gt;URI&lt;/code&gt;&lt;/a&gt;, and to convert between these two classes using &lt;a href=&quot;url#toURI--&quot;&gt;&lt;code&gt;toURI()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;uri#toURL--&quot;&gt;&lt;code&gt;URI.toURL()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고는 &lt;a href=&quot;uri&quot;&gt; &lt;code&gt;URI&lt;/code&gt; 의&lt;/a&gt; 클래스는 특정 상황에서의 구성 요소 필드의 탈출 수행 않습니다. URL의 인코딩 및 디코딩을 관리하는 권장 방법은 &lt;a href=&quot;uri&quot;&gt; &lt;code&gt;URI&lt;/code&gt; &lt;/a&gt; 를 사용 하고 &lt;a href=&quot;url#toURI--&quot;&gt; &lt;code&gt;toURI()&lt;/code&gt; &lt;/a&gt; 및 URI.toURL () 을 사용 &lt;a href=&quot;uri#toURL--&quot;&gt; &lt;code&gt;URI.toURL()&lt;/code&gt; &lt;/a&gt; 두 클래스 사이를 변환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="799dedf2fa84e1db557a5a29b441de63fb5b0e62" translate="yes" xml:space="preserve">
          <source>Note, the given maximized bounds are used as a hint for the native system, because the underlying platform may not support setting the location and/or size of the maximized windows. If that is the case, the provided values do not affect the appearance of the frame in the maximized state.</source>
          <target state="translated">기본 플랫폼이 최대화 된 창의 위치 및 / 또는 크기 설정을 지원하지 않을 수 있기 때문에 주어진 최대화 된 경계는 기본 시스템에 대한 힌트로 사용됩니다. 이 경우 제공된 값은 최대화 된 상태의 프레임 모양에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4030ed735109102fede2865591b8e0c081abfc6" translate="yes" xml:space="preserve">
          <source>Note, the value actually set in the accepted socket is determined by calling &lt;a href=&quot;socket#getReceiveBufferSize()&quot;&gt;&lt;code&gt;Socket.getReceiveBufferSize()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">허용 된 소켓에 실제로 설정된 값은 &lt;a href=&quot;socket#getReceiveBufferSize()&quot;&gt; &lt;code&gt;Socket.getReceiveBufferSize()&lt;/code&gt; &lt;/a&gt; 를 호출하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="008f4765e87008d4171d92e49f2d63d5f2239062" translate="yes" xml:space="preserve">
          <source>Note, the value actually set in the accepted socket is determined by calling &lt;a href=&quot;socket#getReceiveBufferSize--&quot;&gt;&lt;code&gt;Socket.getReceiveBufferSize()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">수락 된 소켓에 실제로 설정된 값은 &lt;a href=&quot;socket#getReceiveBufferSize--&quot;&gt; &lt;code&gt;Socket.getReceiveBufferSize()&lt;/code&gt; &lt;/a&gt; 를 호출하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a192e7d4822486a83d4b72809b9cd678009ae005" translate="yes" xml:space="preserve">
          <source>Note. Depending on the context of use, some request methods and headers may be permitted at all times, and others may not be permitted at any time. For example, the HTTP protocol handler might disallow certain headers such as Content-Length from being set by application code, regardless of whether the security policy in force, permits it.</source>
          <target state="translated">노트. 사용 컨텍스트에 따라 일부 요청 메소드 및 헤더는 항상 허용 될 수 있고 다른 요청 방법은 언제든지 허용되지 않을 수 있습니다. 예를 들어, HTTP 프로토콜 핸들러는 적용되는 보안 정책에 관계없이 Content-Length와 같은 특정 헤더가 애플리케이션 코드에 의해 설정되는 것을 허용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="1c1e292502c948ea2540aa911417c3ba6f0a7b88" translate="yes" xml:space="preserve">
          <source>Note: (1) The &lt;code&gt;Array&lt;/code&gt; object from which a &lt;code&gt;SerialArray&lt;/code&gt; object is created must have materialized the SQL &lt;code&gt;ARRAY&lt;/code&gt; value's data on the client before it is passed to the constructor. Otherwise, the new &lt;code&gt;SerialArray&lt;/code&gt; object will contain no data.</source>
          <target state="translated">주 : (1) &lt;code&gt;Array&lt;/code&gt; 있는 오브젝트 &lt;code&gt;SerialArray&lt;/code&gt; 객체가 SQL의 구체화해야합니다 생성 &lt;code&gt;ARRAY&lt;/code&gt; 의 이 생성자에 전달되기 전에 클라이언트에서 값의 데이터를. 그렇지 않으면 새 &lt;code&gt;SerialArray&lt;/code&gt; 개체에 데이터가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86419567047c8e33df7551a77183455cadf6415e" translate="yes" xml:space="preserve">
          <source>Note: (2) If the &lt;code&gt;Array&lt;/code&gt; contains &lt;code&gt;java.sql.Types.JAVA_OBJECT&lt;/code&gt; types, the &lt;code&gt;SerialJavaObject&lt;/code&gt; constructor is called where checks are made to ensure this object is serializable.</source>
          <target state="translated">참고 : (2) &lt;code&gt;Array&lt;/code&gt; 에 &lt;code&gt;java.sql.Types.JAVA_OBJECT&lt;/code&gt; 유형이 포함 된 경우 &lt;code&gt;SerialJavaObject&lt;/code&gt; 경우이 객체가 직렬화 가능한지 확인 생성자가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f2ab5273ebaf50850efbb3a5a3fae2eeb69eea14" translate="yes" xml:space="preserve">
          <source>Note: (2) The &lt;code&gt;Array&lt;/code&gt; object supplied to this constructor cannot return &lt;code&gt;null&lt;/code&gt; for any &lt;code&gt;Array.getArray()&lt;/code&gt; methods. &lt;code&gt;SerialArray&lt;/code&gt; cannot serialize &lt;code&gt;null&lt;/code&gt; array values.</source>
          <target state="translated">참고 : (2) 이 생성자에 제공된 &lt;code&gt;Array&lt;/code&gt; 객체는 &lt;code&gt;Array.getArray()&lt;/code&gt; 메서드에 대해 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수 없습니다 . &lt;code&gt;SerialArray&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 배열 값을 직렬화 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="77cbdc153f74b52e2330c098817f10ac4ac6e23d" translate="yes" xml:space="preserve">
          <source>Note: (3) The &lt;code&gt;Array&lt;/code&gt; object supplied to this constructor cannot return &lt;code&gt;null&lt;/code&gt; for any &lt;code&gt;Array.getArray()&lt;/code&gt; methods. &lt;code&gt;SerialArray&lt;/code&gt; cannot serialize null array values.</source>
          <target state="translated">참고 : (3) 이 생성자에 제공된 &lt;code&gt;Array&lt;/code&gt; 객체는 &lt;code&gt;Array.getArray()&lt;/code&gt; 메서드에 대해 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수 없습니다 . &lt;code&gt;SerialArray&lt;/code&gt; 는 null 배열 값을 직렬화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="743169cc2f7786ab9238e67965adb946d4be8d89" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;JdbcRowSet&lt;/code&gt; does not require the &lt;code&gt;populate&lt;/code&gt; method as it is undefined in this class.</source>
          <target state="translated">참고 : &lt;code&gt;JdbcRowSet&lt;/code&gt; 는 이 클래스에 정의되어 있지 않으므로 &lt;code&gt;populate&lt;/code&gt; 메소드가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0c9c385460860b0e957297b560d1b453306ec982" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;SwingWorker&lt;/code&gt; is only designed to be executed once. Executing a &lt;code&gt;SwingWorker&lt;/code&gt; more than once will not result in invoking the &lt;code&gt;doInBackground&lt;/code&gt; method twice.</source>
          <target state="translated">참고 : &lt;code&gt;SwingWorker&lt;/code&gt; 는 한 번만 실행되도록 설계되었습니다. &lt;code&gt;SwingWorker&lt;/code&gt; 를 두 번 이상 실행 해도 &lt;code&gt;doInBackground&lt;/code&gt; 메서드가 두 번 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="254dafe97410ce13ab669b9f0949b009f389b447" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;password&lt;/code&gt; is cloned before it is stored in the new &lt;code&gt;PBEKeySpec&lt;/code&gt; object.</source>
          <target state="translated">참고 : &lt;code&gt;password&lt;/code&gt; 는 새 &lt;code&gt;PBEKeySpec&lt;/code&gt; 오브젝트에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="46ab5930f3cbabd25f39b229ec05b8cfaba390de" translate="yes" xml:space="preserve">
          <source>Note: A &lt;code&gt;Joinable&lt;/code&gt; object is any &lt;code&gt;RowSet&lt;/code&gt; object that has implemented the &lt;code&gt;Joinable&lt;/code&gt; interface.</source>
          <target state="translated">참고 : &lt;code&gt;Joinable&lt;/code&gt; 개체는 &lt;code&gt;Joinable&lt;/code&gt; 인터페이스를 구현 한 &lt;code&gt;RowSet&lt;/code&gt; 개체입니다 .</target>
        </trans-unit>
        <trans-unit id="040b0e9f8c6554028c4dc40a0cf14489770cd695" translate="yes" xml:space="preserve">
          <source>Note: A PostConstruct interceptor method must not throw application exceptions, but it may be declared to throw checked exceptions including the java.lang.Exception if the same interceptor method interposes on business or timeout methods in addition to lifecycle events. If a PostConstruct interceptor method returns a value, it is ignored by the container.</source>
          <target state="translated">참고 : PostConstruct 인터셉터 메소드는 애플리케이션 예외를 발생시키지 않아야하지만, 동일한 인터셉터 메소드가 라이프 사이클 이벤트 외에 비즈니스 또는 제한 시간 초과 메소드에 삽입되는 경우 java.lang.Exception을 포함하여 확인 된 예외를 발생 시키도록 선언 될 수 있습니다. PostConstruct 인터셉터 메소드가 값을 리턴하면 컨테이너에서이를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="fea6b6198364e245978b1624df46b8baf87128b5" translate="yes" xml:space="preserve">
          <source>Note: A PreDestroy interceptor method must not throw application exceptions, but it may be declared to throw checked exceptions including the java.lang.Exception if the same interceptor method interposes on business or timeout methods in addition to lifecycle events. If a PreDestroy interceptor method returns a value, it is ignored by the container.</source>
          <target state="translated">참고 : PreDestroy 인터셉터 메소드는 애플리케이션 예외를 발생시키지 않아야하지만 동일한 인터셉터 메소드가 라이프 사이클 이벤트 외에 비즈니스 또는 제한 시간 초과 메소드에 삽입되는 경우 java.lang.Exception을 포함하여 확인 된 예외를 발생 시키도록 선언 될 수 있습니다. PreDestroy 인터셉터 메소드가 값을 리턴하면 컨테이너에서이를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="dfa725603a4fb969b0f8ddaaff6ff51bf646fedb" translate="yes" xml:space="preserve">
          <source>Note: A pathname consisting of a single &quot;*&quot; indicates all the files in the current directory, while a pathname consisting of a single &quot;-&quot; indicates all the files in the current directory and (recursively) all files and subdirectories contained in the current directory.</source>
          <target state="translated">참고 : 단일 &quot;*&quot;로 구성된 경로 이름은 현재 디렉토리의 모든 파일을 나타내고, 단일 &quot;-&quot;로 구성된 경로 이름은 현재 디렉토리의 모든 파일 및 현재에 포함 된 모든 파일 및 서브 디렉토리를 나타냅니다. 예배 규칙서.</target>
        </trans-unit>
        <trans-unit id="601d43cd3faf7f02357671bd5912f9638a00920c" translate="yes" xml:space="preserve">
          <source>Note: A valid reduction polynomial is either a trinomial (X^&lt;code&gt;m&lt;/code&gt; + X^&lt;code&gt;k&lt;/code&gt; + 1 with &lt;code&gt;m&lt;/code&gt; &amp;gt; &lt;code&gt;k&lt;/code&gt; &amp;gt;= 1) or a pentanomial (X^&lt;code&gt;m&lt;/code&gt; + X^&lt;code&gt;k3&lt;/code&gt; + X^&lt;code&gt;k2&lt;/code&gt; + X^&lt;code&gt;k1&lt;/code&gt; + 1 with &lt;code&gt;m&lt;/code&gt; &amp;gt; &lt;code&gt;k3&lt;/code&gt; &amp;gt; &lt;code&gt;k2&lt;/code&gt; &amp;gt; &lt;code&gt;k1&lt;/code&gt; &amp;gt;= 1).</source>
          <target state="translated">참고 : 유효한 축소 다항식은 삼항식 (X ^ &lt;code&gt;m&lt;/code&gt; + X ^ &lt;code&gt;k&lt;/code&gt; + 1 인 &lt;code&gt;m&lt;/code&gt; &amp;gt; &lt;code&gt;k&lt;/code&gt; &amp;gt; = 1)이거나 오각형 (X ^ &lt;code&gt;m&lt;/code&gt; + X ^ &lt;code&gt;k3&lt;/code&gt; + X ^ &lt;code&gt;k2&lt;/code&gt; + X ^ &lt;code&gt;k1&lt;/code&gt; + 1)입니다. &lt;code&gt;m&lt;/code&gt; &amp;gt; &lt;code&gt;k3&lt;/code&gt; &amp;gt; &lt;code&gt;k2&lt;/code&gt; &amp;gt; &lt;code&gt;k1&lt;/code&gt; &amp;gt; = 1).</target>
        </trans-unit>
        <trans-unit id="6c108a434a0cc7b49517402fe3622f9977c52431" translate="yes" xml:space="preserve">
          <source>Note: All X509Certificate subclasses must provide a constructor of the form:</source>
          <target state="translated">참고 : 모든 X509Certificate 서브 클래스는 다음 형식의 생성자를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="23a9717c05af24a9b056171e4e2e247ae12ed3ce" translate="yes" xml:space="preserve">
          <source>Note: Allowing deleted rows to remain visible complicates the behavior of some of the methods. However, most &lt;code&gt;RowSet&lt;/code&gt; object users can simply ignore this extra detail because only sophisticated applications will likely want to take advantage of this feature.</source>
          <target state="translated">참고 : 삭제 된 행이 계속 표시되도록 허용하면 일부 메서드의 동작이 복잡해집니다. 그러나 대부분의 &lt;code&gt;RowSet&lt;/code&gt; 개체 사용자는 정교한 응용 프로그램 만이 기능을 이용하기를 원하기 때문에이 추가 세부 사항을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a5399bf0b815dcc23647625f34051f621f58516" translate="yes" xml:space="preserve">
          <source>Note: Allowing deleted rows to remain visible complicates the behavior of some standard JDBC &lt;code&gt;RowSet&lt;/code&gt; Implementations methods. However, most rowset users can simply ignore this extra detail because only very specialized applications will likely want to take advantage of this feature.</source>
          <target state="translated">참고 : 삭제 된 행이 계속 표시되도록 허용하면 일부 표준 JDBC &lt;code&gt;RowSet&lt;/code&gt; 구현 메소드 의 동작이 복잡해집니다 . 그러나 대부분의 행 집합 사용자는 매우 전문화 된 응용 프로그램 만이 기능을 이용하기를 원하기 때문에이 추가 세부 정보를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70bf90b0059e20282dec8b1fc95979dce51ba913" translate="yes" xml:space="preserve">
          <source>Note: Allowing deleted rows to remain visible complicates the behavior of some standard JDBC &lt;code&gt;RowSet&lt;/code&gt; implementations methods. However, most rowset users can simply ignore this extra detail because only very specialized applications will likely want to take advantage of this feature.</source>
          <target state="translated">참고 : 삭제 된 행이 계속 표시되도록 허용하면 일부 표준 JDBC &lt;code&gt;RowSet&lt;/code&gt; 구현 메소드 의 동작이 복잡해집니다 . 그러나 대부분의 행 집합 사용자는 매우 전문화 된 응용 프로그램 만이 기능을 이용하기를 원하기 때문에이 추가 세부 정보를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb1e0cf5a0c0e42b2b6e16c731f84f74ed100301" translate="yes" xml:space="preserve">
          <source>Note: Although this API consistently refers to the stimulus for a drag and drop operation being a physical gesture by a human user, this does not preclude a programmatically driven DnD operation given the appropriate implementation of a &lt;code&gt;DragSource&lt;/code&gt;. This package contains the abstract class &lt;code&gt;MouseDragGestureRecognizer&lt;/code&gt; for recognizing mouse device gestures. Other abstract subclasses may be provided by the platform to support other input devices or particular &lt;code&gt;Component&lt;/code&gt; class semantics.</source>
          <target state="translated">참고 :이 API는 드래그 앤 드롭 작업에 대한 자극을 인간 사용자의 물리적 제스처라고 일관되게 언급하지만, 이는 &lt;code&gt;DragSource&lt;/code&gt; 의 적절한 구현을 고려할 때 프로그래밍 방식으로 구동되는 DnD 작업을 배제하지 않습니다 . 이 패키지에는 마우스 장치 제스처를 인식하기위한 추상 클래스 &lt;code&gt;MouseDragGestureRecognizer&lt;/code&gt; 가 포함되어 있습니다. 다른 입력 장치 또는 특정 &lt;code&gt;Component&lt;/code&gt; 클래스 의미 체계 를 지원하기 위해 다른 추상 하위 클래스가 플랫폼에 의해 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb229cc90e4f767f54fad19b5d97dbde1db2768c" translate="yes" xml:space="preserve">
          <source>Note: Always use the &lt;a href=&quot;datatypefactory&quot;&gt;&lt;code&gt;DatatypeFactory&lt;/code&gt;&lt;/a&gt; to construct an instance of &lt;code&gt;Duration&lt;/code&gt;. The constructor on this class cannot be guaranteed to produce an object with a consistent state and may be removed in the future.</source>
          <target state="translated">참고 : 항상 &lt;a href=&quot;datatypefactory&quot;&gt; &lt;code&gt;DatatypeFactory&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;Duration&lt;/code&gt; 인스턴스를 생성하십시오 . 이 클래스의 생성자는 일관성있는 상태의 객체를 생성한다고 보장 할 수 없으며 나중에 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="252b6b87f84154da1d9cf7e84d8916f68a9053a3" translate="yes" xml:space="preserve">
          <source>Note: Always use the &lt;a href=&quot;datatypefactory&quot;&gt;&lt;code&gt;DatatypeFactory&lt;/code&gt;&lt;/a&gt; to construct an instance of &lt;code&gt;XMLGregorianCalendar&lt;/code&gt;. The constructor on this class cannot be guaranteed to produce an object with a consistent state and may be removed in the future.</source>
          <target state="translated">참고 : 항상 &lt;a href=&quot;datatypefactory&quot;&gt; &lt;code&gt;DatatypeFactory&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;XMLGregorianCalendar&lt;/code&gt; 인스턴스를 생성하십시오 . 이 클래스의 생성자는 일관성있는 상태의 객체를 생성한다고 보장 할 수 없으며 나중에 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8153ceb395f3c9c5fbce1183a9833ea16ba0054" translate="yes" xml:space="preserve">
          <source>Note: Applications should use the &lt;code&gt;JScrollPane&lt;/code&gt; version of this method. It only exists for backwards compatibility with the Swing 1.0.2 (and earlier) versions of this class.</source>
          <target state="translated">참고 : 애플리케이션은 이 메소드 의 &lt;code&gt;JScrollPane&lt;/code&gt; 버전을 사용해야합니다 . 이 클래스의 Swing 1.0.2 (및 이전) 버전과의 하위 호환성을 위해서만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a1cc2841647fc82f79501840eb2841a8531b0315" translate="yes" xml:space="preserve">
          <source>Note: As of v1.3, it is recommended that developers call &lt;code&gt;Component.AccessibleAWTComponent.getAccessibleChild()&lt;/code&gt; instead of this method.</source>
          <target state="translated">참고 : v1.3부터는 개발자 가이 메소드 대신 &lt;code&gt;Component.AccessibleAWTComponent.getAccessibleChild()&lt;/code&gt; 를 호출하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f37e0e69a5ef16e424f1577f447cc44c2f9db3cb" translate="yes" xml:space="preserve">
          <source>Note: Attempting to show the printing dialog or run interactively, while in headless mode, will result in a &lt;code&gt;HeadlessException&lt;/code&gt;.</source>
          <target state="translated">참고 : 헤드리스 모드에서 인쇄 대화 상자를 표시하거나 대화식으로 실행하려고하면 &lt;code&gt;HeadlessException&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="2adec88ec6d6cd35667bae332e97cb78b026a927" translate="yes" xml:space="preserve">
          <source>Note: By default, a node allows children.</source>
          <target state="translated">참고 : 기본적으로 노드는 자식을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c06f5db077ab1ba124afa4d306145569d1a0a304" translate="yes" xml:space="preserve">
          <source>Note: Calling &lt;code&gt;setTime()&lt;/code&gt; with &lt;code&gt;Date(Long.MAX_VALUE)&lt;/code&gt; or &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; may yield incorrect field values from &lt;code&gt;get()&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Date(Long.MAX_VALUE)&lt;/code&gt; 또는 &lt;code&gt;Date(Long.MIN_VALUE)&lt;/code&gt; &lt;code&gt;setTime()&lt;/code&gt; 을 호출 &lt;code&gt;get()&lt;/code&gt; 에서 잘못된 필드 값이 생성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f47afedb3f3f0b810383c13f7dd2ba3a43b6925e" translate="yes" xml:space="preserve">
          <source>Note: Calling the method &lt;code&gt;relative(1)&lt;/code&gt; is identical to calling the method &lt;code&gt;next()&lt;/code&gt; and calling the method &lt;code&gt;relative(-1)&lt;/code&gt; is identical to calling the method &lt;code&gt;previous()&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;relative(1)&lt;/code&gt; 메서드를 호출하는 것은 &lt;code&gt;next()&lt;/code&gt; 메서드 를 호출하는 것과 &lt;code&gt;relative(-1)&lt;/code&gt; 메서드를 호출하는 것은 &lt;code&gt;previous()&lt;/code&gt; 메서드를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6a685b174efe46752fec09e8d8e263034bafa3cd" translate="yes" xml:space="preserve">
          <source>Note: Closing a socket doesn't clear its binding state, which means this method will return &lt;code&gt;true&lt;/code&gt; for a closed socket (see &lt;a href=&quot;#isClosed()&quot;&gt;&lt;code&gt;isClosed()&lt;/code&gt;&lt;/a&gt;) if it was successfuly bound prior to being closed.</source>
          <target state="translated">참고 : 소켓을 닫는 것은 바인딩 상태를 지우지 않습니다. 즉,이 메서드는 닫히기 전에 성공적으로 바인딩 된 경우 닫힌 소켓에 대해 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 ( &lt;a href=&quot;#isClosed()&quot;&gt; &lt;code&gt;isClosed()&lt;/code&gt; &lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="a83420c07620959c69b392fced7ba206ef6cf144" translate="yes" xml:space="preserve">
          <source>Note: Closing a socket doesn't clear its binding state, which means this method will return &lt;code&gt;true&lt;/code&gt; for a closed socket (see &lt;a href=&quot;socket#isClosed--&quot;&gt;&lt;code&gt;isClosed()&lt;/code&gt;&lt;/a&gt;) if it was successfuly bound prior to being closed.</source>
          <target state="translated">참고 : 소켓을 닫아도 바인딩 상태가 지워지지 않습니다. 즉,이 메소드가 닫힌 소켓 ( &lt;a href=&quot;socket#isClosed--&quot;&gt; &lt;code&gt;isClosed()&lt;/code&gt; &lt;/a&gt; 참조 ) 이 닫히기 전에 성공적으로 바인드 된 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="7761002f54a9c1f2f804c509442839f0ba8dca1d" translate="yes" xml:space="preserve">
          <source>Note: Closing a socket doesn't clear its connection state, which means this method will return &lt;code&gt;true&lt;/code&gt; for a closed socket (see &lt;a href=&quot;#isClosed()&quot;&gt;&lt;code&gt;isClosed()&lt;/code&gt;&lt;/a&gt;) if it was successfuly connected prior to being closed.</source>
          <target state="translated">참고 : 소켓을 닫아도 연결 상태는 지워지지 않습니다. 즉,이 메서드는 닫히기 전에 성공적으로 연결된 경우 닫힌 소켓에 대해 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 ( &lt;a href=&quot;#isClosed()&quot;&gt; &lt;code&gt;isClosed()&lt;/code&gt; &lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="10f01f12f1a698aba85aafe79f168cd72a588f9c" translate="yes" xml:space="preserve">
          <source>Note: Closing a socket doesn't clear its connection state, which means this method will return &lt;code&gt;true&lt;/code&gt; for a closed socket (see &lt;a href=&quot;socket#isClosed--&quot;&gt;&lt;code&gt;isClosed()&lt;/code&gt;&lt;/a&gt;) if it was successfuly connected prior to being closed.</source>
          <target state="translated">참고 : 소켓을 닫아도 연결 상태가 지워지지 않습니다. 즉,이 방법은 닫힌 소켓 ( &lt;a href=&quot;socket#isClosed--&quot;&gt; &lt;code&gt;isClosed()&lt;/code&gt; &lt;/a&gt; 참조 ) 이 닫히기 전에 성공적으로 연결되면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="9f4ba21d3677cf8ccb8a6bd9c2bc3be7c6f13481" translate="yes" xml:space="preserve">
          <source>Note: Depending on the implementation, the &lt;code&gt;generateSeed&lt;/code&gt; and &lt;code&gt;nextBytes&lt;/code&gt; methods may block as entropy is being gathered, for example, if they need to read from /dev/random on various Unix-like operating systems.</source>
          <target state="translated">참고 : 구현에 따라 &lt;code&gt;generateSeed&lt;/code&gt; 및 &lt;code&gt;nextBytes&lt;/code&gt; 메소드는 엔트로피가 수집 될 때 차단 될 수 있습니다 (예 : 다양한 Unix 계열 운영 체제의 / dev / random에서 읽어야하는 경우).</target>
        </trans-unit>
        <trans-unit id="91f49ae78c5e67b727b21e0329fb8dd1044cc68f" translate="yes" xml:space="preserve">
          <source>Note: Depending on the implementation, the &lt;code&gt;generateSeed&lt;/code&gt;, &lt;code&gt;reseed&lt;/code&gt; and &lt;code&gt;nextBytes&lt;/code&gt; methods may block as entropy is being gathered, for example, if the entropy source is /dev/random on various Unix-like operating systems.</source>
          <target state="translated">참고 : 구현에 따라 엔트로피가 수집되는 동안 &lt;code&gt;generateSeed&lt;/code&gt; , &lt;code&gt;reseed&lt;/code&gt; 및 &lt;code&gt;nextBytes&lt;/code&gt; 메서드가 차단 될 수 있습니다 (예 : 다양한 Unix 유사 운영 체제에서 엔트로피 소스가 / dev / random 인 경우).</target>
        </trans-unit>
        <trans-unit id="e3abcb90f9fca795630637ce723df4e905c92f8c" translate="yes" xml:space="preserve">
          <source>Note: Disabling a component does not disable its children.</source>
          <target state="translated">참고 : 구성 요소를 비활성화해도 하위 구성 요소는 비활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a75c1b491a3283d2385a1f5bed1105019f4b2f7" translate="yes" xml:space="preserve">
          <source>Note: Disabling a heavyweight container prevents all components in this container from receiving any input events. But disabling a lightweight container affects only this container.</source>
          <target state="translated">참고 : 중량 컨테이너를 비활성화하면이 컨테이너의 모든 구성 요소가 입력 이벤트를 수신하지 못합니다. 그러나 경량 컨테이너를 비활성화하면이 컨테이너에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="ea026c18f95ff0c7387c7ef585b985251ee796e3" translate="yes" xml:space="preserve">
          <source>Note: Disabling a lightweight component does not prevent it from receiving MouseEvents.</source>
          <target state="translated">참고 : 경량 구성 요소를 비활성화해도 MouseEvents를 수신하지 못하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f5434552960c8c2dea533b2ca1ddeb3927183d35" translate="yes" xml:space="preserve">
          <source>Note: During the creation of a new &lt;a href=&quot;thread#%3Cinit%3E(java.lang.ThreadGroup,java.lang.Runnable,java.lang.String,long,boolean)&quot;&gt;&lt;code&gt;thread&lt;/code&gt;&lt;/a&gt;, it is possible to</source>
          <target state="translated">참고 : 새 &lt;a href=&quot;thread#%3Cinit%3E(java.lang.ThreadGroup,java.lang.Runnable,java.lang.String,long,boolean)&quot;&gt; &lt;code&gt;thread&lt;/code&gt; &lt;/a&gt; 만드는 동안 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50dffa9483cbb54d86f861329d63921441eea696" translate="yes" xml:space="preserve">
          <source>Note: Each string should be of the form</source>
          <target state="translated">참고 : 각 문자열은 형식이어야합니다</target>
        </trans-unit>
        <trans-unit id="6a3087288ea895ef3d6a3ca12adc1620eb080716" translate="yes" xml:space="preserve">
          <source>Note: End users are able to determine the nature and details of the color support by querying the &lt;a href=&quot;printermoreinfomanufacturer&quot;&gt;&lt;code&gt;PrinterMoreInfoManufacturer&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">참고 : 최종 사용자는 &lt;a href=&quot;printermoreinfomanufacturer&quot;&gt; &lt;code&gt;PrinterMoreInfoManufacturer&lt;/code&gt; &lt;/a&gt; 속성 을 쿼리하여 색상 지원의 특성과 세부 사항을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20b962ae0f4b168a0cc979f0b6847c9bed17ec93" translate="yes" xml:space="preserve">
          <source>Note: Font rotations can cause text baselines to be rotated, and multiple runs with different rotations can cause the baseline to bend or zig-zag. In order to account for this (rare) possibility, some APIs are specified to return metrics and take parameters 'in baseline-relative coordinates' (e.g. ascent, advance), and others are in 'in standard coordinates' (e.g. getBounds). Values in baseline-relative coordinates map the 'x' coordinate to the distance along the baseline, (positive x is forward along the baseline), and the 'y' coordinate to a distance along the perpendicular to the baseline at 'x' (positive y is 90 degrees clockwise from the baseline vector). Values in standard coordinates are measured along the x and y axes, with 0,0 at the origin of the TextLayout. Documentation for each relevant API indicates what values are in what coordinate system. In general, measurement-related APIs are in baseline-relative coordinates, while display-related APIs are in standard coordinates.</source>
          <target state="translated">참고 : 글꼴 회전으로 인해 텍스트 기준선이 회전 될 수 있으며, 다른 회전으로 여러 번 실행하면 기준선이 구부러 지거나 지그재그로 표시 될 수 있습니다. 이 (희귀 한) 가능성을 설명하기 위해 일부 API는 메트릭을 반환하고 '기준선-상대 좌표'(예 : 상승, 전진)에서 매개 변수를 취하도록 지정되고 다른 API는 '표준 좌표'(예 : getBounds)에 있습니다. 기준선 상대 좌표의 값은 'x'좌표를 기준선을 따라 거리에 매핑하고 (양수 x는 기준선을 따라 앞쪽), 'y'좌표를 'x'에서 기준선에 수직 인 거리에 매핑합니다 (양수). y는 기준선 벡터에서 시계 방향으로 90 도입니다. 표준 좌표의 값은 x 및 y 축을 따라 측정되며 TextLayout의 원점에 0,0이 있습니다.각 관련 API에 대한 문서는 어떤 좌표계에 어떤 값이 있는지를 나타냅니다. 일반적으로 측정 관련 API는 기준선 기준 좌표에있는 반면 디스플레이 관련 API는 표준 좌표에 있습니다.</target>
        </trans-unit>
        <trans-unit id="53dbd3840742378264064623ca4a25b31735498f" translate="yes" xml:space="preserve">
          <source>Note: Font rotations can cause text baselines to be rotated. In order to account for this (rare) possibility, font APIs are specified to return metrics and take parameters 'in baseline-relative coordinates'. This maps the 'x' coordinate to the advance along the baseline, (positive x is forward along the baseline), and the 'y' coordinate to a distance along the perpendicular to the baseline at 'x' (positive y is 90 degrees clockwise from the baseline vector). APIs for which this is especially important are called out as having 'baseline-relative coordinates.'</source>
          <target state="translated">참고 : 글꼴을 회전하면 텍스트 기준선이 회전 될 수 있습니다. 이 (드문) 가능성을 고려하기 위해 글꼴 API는 메트릭을 반환하고 '기준선 상대 좌표'에서 매개 변수를 사용하도록 지정됩니다. 이것은 'x'좌표를 기준선을 따라 진행 (양수 x는 기준선을 따라 앞쪽)에 매핑하고 'y'좌표는 'x'기준선에 수직 인 거리 (양수 y는 시계 방향으로 90도)에 매핑합니다. 기준 벡터에서). 이것이 특히 중요한 API는 '기준 기준 좌표'를 갖는 것으로 불립니다.</target>
        </trans-unit>
        <trans-unit id="4139c01db4343c79097098788239a9b16c7e48ab" translate="yes" xml:space="preserve">
          <source>Note: For components with built-in drop support, this location will be a subclass of &lt;code&gt;DropLocation&lt;/code&gt; of the same type returned by that component's &lt;code&gt;getDropLocation&lt;/code&gt; method.</source>
          <target state="translated">참고 : 기본 제공 놓기 지원이 있는 구성 요소의 &lt;code&gt;getDropLocation&lt;/code&gt; 위치는 해당 구성 요소의 getDropLocation 메서드 에서 반환 된 동일한 유형 의 &lt;code&gt;DropLocation&lt;/code&gt; 하위 클래스가 됩니다.</target>
        </trans-unit>
        <trans-unit id="60f68f1265565a7812dc791614b1dbe6455201b6" translate="yes" xml:space="preserve">
          <source>Note: For values other than &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; NaN and &amp;plusmn;Infinity, this constructor is compatible with the values returned by &lt;a href=&quot;../lang/float#toString-float-&quot;&gt;&lt;code&gt;Float.toString(float)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../lang/double#toString-double-&quot;&gt;&lt;code&gt;Double.toString(double)&lt;/code&gt;&lt;/a&gt;. This is generally the preferred way to convert a &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; into a BigDecimal, as it doesn't suffer from the unpredictability of the &lt;a href=&quot;bigdecimal#BigDecimal-double-&quot;&gt;&lt;code&gt;BigDecimal(double)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">참고 : &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;double&lt;/code&gt; NaN 및 &amp;plusmn; Infinity 이외의 값의 경우이 생성자는 &lt;a href=&quot;../lang/float#toString-float-&quot;&gt; &lt;code&gt;Float.toString(float)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../lang/double#toString-double-&quot;&gt; &lt;code&gt;Double.toString(double)&lt;/code&gt; &lt;/a&gt; 반환 된 값과 호환됩니다 . 이는 일반적으로 &lt;code&gt;float&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 을 BigDecimal로 변환하는 데 선호되는 방법 입니다. &lt;a href=&quot;bigdecimal#BigDecimal-double-&quot;&gt; &lt;code&gt;BigDecimal(double)&lt;/code&gt; &lt;/a&gt; 생성자 의 예측 불가능으로 어려움을 겪지 않기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="f894b657e9d4f97ef5bbf661355e6ceddf605aba" translate="yes" xml:space="preserve">
          <source>Note: Granting code permission to accept or make connections to remote hosts may be dangerous because malevolent code can then more easily transfer and share confidential data among parties who may not otherwise have access to the data.</source>
          <target state="translated">참고 : 악의적 인 코드는 데이터에 액세스 할 수없는 당사자간에 기밀 데이터를보다 쉽게 ​​전송하고 공유 할 수 있기 때문에 원격 호스트를 수락하거나 연결하는 코드 권한을 부여하는 것은 위험 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b51214b61156f3a246b3290a74dbc8a2e74b40eb" translate="yes" xml:space="preserve">
          <source>Note: Great care must be exercised if mutable objects are used as set elements. The behavior of a set is not specified if the value of an object is changed in a manner that affects &lt;code&gt;equals&lt;/code&gt; comparisons while the object is an element in the set. A special case of this prohibition is that it is not permissible for a set to contain itself as an element.</source>
          <target state="translated">참고 : 가변 객체를 세트 요소로 사용하는 경우 각별히주의해야합니다. 오브젝트가 세트의 요소 인 동안 오브젝트의 값이 &lt;code&gt;equals&lt;/code&gt; 비교에 영향을주는 방식으로 변경되는 경우 세트의 동작이 지정되지 않습니다 . 이 금지의 특별한 경우는 세트가 자신을 요소로 포함하는 것이 허용되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="aa4ec39829945455942368945581912399ff4861" translate="yes" xml:space="preserve">
          <source>Note: IETF BCP 47 places syntactic restrictions on variant subtags. Also BCP 47 subtags are strictly used to indicate additional variations that define a language or its dialects that are not covered by any combinations of language, script and region subtags. You can find a full list of valid variant codes in the IANA Language Subtag Registry (search for &quot;Type: variant&quot;).</source>
          <target state="translated">참고 : IETF BCP 47은 변형 하위 태그에 구문 제한을두고 있습니다. 또한 BCP 47 하위 태그는 언어, 스크립트 및 지역 하위 태그의 조합으로 다루지 않는 언어 또는 언어를 정의하는 추가 변형을 나타내는 데 엄격하게 사용됩니다. IANA Language Subtag Registry에서 유효한 변형 코드의 전체 목록을 찾을 수 있습니다 ( &quot;Type : variant&quot;검색).</target>
        </trans-unit>
        <trans-unit id="d3678099dea00b684cd036ffeb8507d5238df9b9" translate="yes" xml:space="preserve">
          <source>Note: If &lt;a href=&quot;#send(java.net.DatagramPacket)&quot;&gt;&lt;code&gt;send(DatagramPacket)&lt;/code&gt;&lt;/a&gt; is used to send a &lt;code&gt;DatagramPacket&lt;/code&gt; that is larger than the setting of SO_SNDBUF then it is implementation specific if the packet is sent or discarded.</source>
          <target state="translated">참고 : &lt;a href=&quot;#send(java.net.DatagramPacket)&quot;&gt; &lt;code&gt;send(DatagramPacket)&lt;/code&gt; &lt;/a&gt; 를 사용하여 SO_SNDBUF의 설정보다 큰 &lt;code&gt;DatagramPacket&lt;/code&gt; 을 전송하는 경우 패킷이 전송되거나 폐기되는 경우 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9551c9847eec1ce96e4a8eea3102dc88018de79b" translate="yes" xml:space="preserve">
          <source>Note: If &lt;a href=&quot;datagramsocket#send-java.net.DatagramPacket-&quot;&gt;&lt;code&gt;send(DatagramPacket)&lt;/code&gt;&lt;/a&gt; is used to send a &lt;code&gt;DatagramPacket&lt;/code&gt; that is larger than the setting of SO_SNDBUF then it is implementation specific if the packet is sent or discarded.</source>
          <target state="translated">참고 : &lt;a href=&quot;datagramsocket#send-java.net.DatagramPacket-&quot;&gt; &lt;code&gt;send(DatagramPacket)&lt;/code&gt; &lt;/a&gt; 를 사용하여 SO_SNDBUF의 설정보다 큰 &lt;code&gt;DatagramPacket&lt;/code&gt; 을 보내는 경우 패킷을 보내거나 버릴 경우 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="412bec2a9cc39312861108c58e11aacc5e6a6ae3" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;border&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, this method will throw an exception as borders are not supported on a &lt;code&gt;JViewPort&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;border&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이 &lt;code&gt;JViewPort&lt;/code&gt; 에서 테두리가 지원되지 않으므로이 메서드는 예외를 throw합니다 .</target>
        </trans-unit>
        <trans-unit id="0fd951afc544adf41cc0d9a745afbc720a08b745" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;mgr&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, this method will throw an exception as layout managers are not supported on a &lt;code&gt;JLayer&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;mgr&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이 아닌 경우 레이아웃 관리자가 &lt;code&gt;JLayer&lt;/code&gt; 에서 지원되지 않으므로이 메서드는 예외를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="7a93b19789849e21dab5046a5d7210e76b18c634" translate="yes" xml:space="preserve">
          <source>Note: If support for extended mouse buttons is &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt;&lt;code&gt;disabled&lt;/code&gt;&lt;/a&gt; by Java then the AWT event subsystem does not produce mouse events for the extended mouse buttons. So it is not expected that this method returns anything except &lt;code&gt;NOBUTTON&lt;/code&gt;, &lt;code&gt;BUTTON1&lt;/code&gt;, &lt;code&gt;BUTTON2&lt;/code&gt;, &lt;code&gt;BUTTON3&lt;/code&gt;.</source>
          <target state="translated">참고 : 확장 된 마우스 단추에 대한 지원 이 Java에 의해 &lt;a href=&quot;../toolkit#areExtraMouseButtonsEnabled()&quot;&gt; &lt;code&gt;disabled&lt;/code&gt; &lt;/a&gt; 된 경우 AWT 이벤트 서브 시스템은 확장 된 마우스 단추에 대한 마우스 이벤트를 생성하지 않습니다. 따라서이 메서드는 &lt;code&gt;NOBUTTON&lt;/code&gt; , &lt;code&gt;BUTTON1&lt;/code&gt; , &lt;code&gt;BUTTON2&lt;/code&gt; , &lt;code&gt;BUTTON3&lt;/code&gt; 이외의 항목을 반환 할 것으로 예상되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f21babe50fa616f9cdc93212eb79bc61122ee54b" translate="yes" xml:space="preserve">
          <source>Note: If the character at the given index is a supplementary character, this method does not remove the entire character. If correct handling of supplementary characters is required, determine the number of &lt;code&gt;char&lt;/code&gt;s to remove by calling &lt;code&gt;Character.charCount(thisSequence.codePointAt(index))&lt;/code&gt;, where &lt;code&gt;thisSequence&lt;/code&gt; is this sequence.</source>
          <target state="translated">참고 : 지정된 색인의 문자가 보충 문자 인 경우이 방법으로 전체 문자를 제거하지는 않습니다. 보충 문자를 올바르게 처리해야하는 경우 &lt;code&gt;Character.charCount(thisSequence.codePointAt(index))&lt;/code&gt; 를 호출하여 제거 할 &lt;code&gt;char&lt;/code&gt; 수를 판별하십시오 . 여기서 &lt;code&gt;thisSequence&lt;/code&gt; 는이 순서입니다.</target>
        </trans-unit>
        <trans-unit id="b0582b661e46b6e1ec1c1aa47237e51fd281161c" translate="yes" xml:space="preserve">
          <source>Note: In</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="a9204ecfd44447c273dec742a35d1dc5e57a1462" translate="yes" xml:space="preserve">
          <source>Note: In headless mode, no dialogs are shown and printing occurs on the default printer.</source>
          <target state="translated">참고 : 헤드리스 모드에서는 대화 상자가 표시되지 않으며 기본 프린터에서 인쇄가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="80314b1180455ac678366834d1e02acb97495d07" translate="yes" xml:space="preserve">
          <source>Note: In order for this class to function correctly, a connection to the data source must be available in order for the SQL &lt;code&gt;Array&lt;/code&gt; object to be materialized (have all of its elements brought to the client server) if necessary. At this time, logical pointers to the data in the data source, such as locators, are not currently supported.</source>
          <target state="translated">참고 :이 클래스가 올바르게 작동하려면 필요한 경우 SQL &lt;code&gt;Array&lt;/code&gt; 객체를 구체화 (모든 요소를 ​​클라이언트 서버로 가져옴) 할 수 있도록 데이터 소스에 대한 연결을 사용할 수 있어야합니다 . 현재 로케이터와 같은 데이터 소스의 데이터에 대한 논리적 포인터는 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3b1a2c5e2a2e0399f254c3d98b5564c349ce290" translate="yes" xml:space="preserve">
          <source>Note: In order to successfully retrieve the enclosed PKCS8EncodedKeySpec object, &lt;code&gt;cipher&lt;/code&gt; needs to be initialized to either Cipher.DECRYPT_MODE or Cipher.UNWRAP_MODE, with the same key and parameters used for generating the encrypted data.</source>
          <target state="translated">참고 : 동봉 된 PKCS8EncodedKeySpec 오브젝트를 검색 하려면 암호화 된 데이터를 생성하는 데 사용 된 동일한 키 및 매개 변수를 사용하여 Cipher.DECRYPT_MODE 또는 Cipher.UNWRAP_MODE로 &lt;code&gt;cipher&lt;/code&gt; 를 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="35f4e4d2c03ea17823a71d15896db48d9f259672" translate="yes" xml:space="preserve">
          <source>Note: Invoking close() on this class has no effect, and methods of this class can be called after the stream has closed without generating an IOException.</source>
          <target state="translated">참고 :이 클래스에서 close ()를 호출해도 효과가 없으며 IOException을 생성하지 않고 스트림을 닫은 후에이 클래스의 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9acd43684782f4c36516fa96703a712377fa15d3" translate="yes" xml:space="preserve">
          <source>Note: It is generally a good idea for comparators to also implement &lt;code&gt;java.io.Serializable&lt;/code&gt;, as they may be used as ordering methods in serializable data structures (like &lt;a href=&quot;treeset&quot;&gt;&lt;code&gt;TreeSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;treemap&quot;&gt;&lt;code&gt;TreeMap&lt;/code&gt;&lt;/a&gt;). In order for the data structure to serialize successfully, the comparator (if provided) must implement &lt;code&gt;Serializable&lt;/code&gt;.</source>
          <target state="translated">참고 : 일반적으로 비교기는 &lt;code&gt;java.io.Serializable&lt;/code&gt; 을 구현하는 것이 좋습니다.이 메소드는 직렬화 가능한 데이터 구조 ( &lt;a href=&quot;treeset&quot;&gt; &lt;code&gt;TreeSet&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;treemap&quot;&gt; &lt;code&gt;TreeMap&lt;/code&gt; 등&lt;/a&gt; ) 에서 순서 메소드로 사용될 수 있기 때문 입니다. 데이터 구조를 직렬화하려면 비교기 (제공된 경우)가 &lt;code&gt;Serializable&lt;/code&gt; 을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0ea2906d3917b8abbddbc2038796605eff4c7ae5" translate="yes" xml:space="preserve">
          <source>Note: It is implementation specific if a packet larger than SO_RCVBUF can be received.</source>
          <target state="translated">참고 : SO_RCVBUF보다 큰 패킷을 수신 할 수있는 경우 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2239f01d37c61b0ecb9c5783ae42b578b987f2ee" translate="yes" xml:space="preserve">
          <source>Note: It is possible for the lead or anchor to be changed without a change to the selection. Notification of these changes is often important, such as when the new lead or anchor needs to be updated in the view. Therefore, caution is urged when changing the default value.</source>
          <target state="translated">참고 : 선택 항목을 변경하지 않고 리드 또는 앵커를 변경할 수 있습니다. 새 리드 또는 앵커를보기에서 업데이트해야하는 경우와 같이 이러한 변경 사항에 대한 알림은 종종 중요합니다. 따라서 기본값을 변경할 때는주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c15fcfabb87eeba8b7d67b1dcd02e626c1d13a0" translate="yes" xml:space="preserve">
          <source>Note: Loggers may be added dynamically as new classes are loaded. This method only reports on the loggers that are currently registered. It is also important to note that this method only returns the name of a Logger, not a strong reference to the Logger itself. The returned String does nothing to prevent the Logger from being garbage collected. In particular, if the returned name is passed to &lt;code&gt;LogManager.getLogger()&lt;/code&gt;, then the caller must check the return value from &lt;code&gt;LogManager.getLogger()&lt;/code&gt; for null to properly handle the case where the Logger has been garbage collected in the time since its name was returned by this method.</source>
          <target state="translated">참고 : 새 클래스가로드되면 로거가 동적으로 추가 될 수 있습니다. 이 방법은 현재 등록 된 로거에 대해서만보고합니다. 이 방법은 Logger 자체에 대한 강력한 참조가 아니라 Logger의 이름 만 반환한다는 점에 유의해야합니다. 반환 된 String은 Logger가 가비지 수집되는 것을 막기 위해 아무 것도 수행하지 않습니다. 특히, 리턴 된 이름이 &lt;code&gt;LogManager.getLogger()&lt;/code&gt; 전달 되면 호출자는 Logger가 이름 이후 시간에 가비지 수집 된 경우를 올바르게 처리하기 위해 &lt;code&gt;LogManager.getLogger()&lt;/code&gt; 의 리턴 값 을 널 ( null ) 로 확인해야합니다. 이 메소드에 의해 반환되었습니다.</target>
        </trans-unit>
        <trans-unit id="3ec3a90b9ec368a0c2060da5080fdcc9de372e44" translate="yes" xml:space="preserve">
          <source>Note: Many methods in &lt;code&gt;java.applet.Applet&lt;/code&gt; may be invoked by the applet only after the applet is fully constructed; applet should avoid calling methods in &lt;code&gt;java.applet.Applet&lt;/code&gt; in the constructor.</source>
          <target state="translated">주 : &lt;code&gt;java.applet.Applet&lt;/code&gt; 의 많은 메소드 는 애플릿이 완전히 구성된 후에 만 ​​애플릿에 의해 호출 될 수 있습니다. 애플릿은 생성자의 &lt;code&gt;java.applet.Applet&lt;/code&gt; 에서 메소드 호출을 피해야 합니다.</target>
        </trans-unit>
        <trans-unit id="651a2063ac716df1b0bb56e33cf3b1186971a0c0" translate="yes" xml:space="preserve">
          <source>Note: Not all focus transfers result from invoking this method. As such, a component may receive focus without this or any of the other &lt;code&gt;requestFocus&lt;/code&gt; methods of &lt;code&gt;Component&lt;/code&gt; being invoked.</source>
          <target state="translated">참고 : 모든 포커스 전송이이 메서드 호출로 인해 발생하는 것은 아닙니다. 따라서 &lt;code&gt;Component&lt;/code&gt; 는 호출되는 컴포넌트 의 다른 &lt;code&gt;requestFocus&lt;/code&gt; 메소드 없이도 포커스를받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d91232c24d23c2f41135390407008447460af5f6" translate="yes" xml:space="preserve">
          <source>Note: Only one DER-encoded certificate is expected to be in the input stream. Also, all X509Certificate subclasses must provide a constructor of the form:</source>
          <target state="translated">참고 : 하나의 DER 인코딩 된 인증서 만 입력 스트림에 있어야합니다. 또한 모든 X509Certificate 서브 클래스는 다음 형식의 생성자를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d691f41b6dcafd57b2df8df59ee659db9896ed3" translate="yes" xml:space="preserve">
          <source>Note: Since &lt;code&gt;PreparedStatement&lt;/code&gt; objects have usually been parsed prior to making this call, disabling escape processing for prepared statements will likely have no effect.</source>
          <target state="translated">참고 : &lt;code&gt;PreparedStatement&lt;/code&gt; 오브젝트는 일반적으로이 호출을 작성하기 전에 구문 분석되었으므로 준비된 명령문에 대해 이스케이프 처리를 비활성화해도 효과가 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="848e86494df548fc6ea5713503f79da2648aee28" translate="yes" xml:space="preserve">
          <source>Note: Since prepared statements have usually been parsed prior to making this call, disabling escape processing for &lt;code&gt;PreparedStatements&lt;/code&gt; objects will have no effect.</source>
          <target state="translated">참고 : 준비된 명령문은 일반적으로이 호출을 작성하기 전에 구문 분석되었으므로 &lt;code&gt;PreparedStatements&lt;/code&gt; 오브젝트에 대한 이스케이프 처리를 사용 안함으로 설정해 도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="caf027bde669dbaaf11479083f77dbafe0d2c487" translate="yes" xml:space="preserve">
          <source>Note: Some earlier implementations of this interface may not support larger sizes of DSA parameters such as 2048 and 3072-bit.</source>
          <target state="translated">참고 :이 인터페이스의 일부 이전 구현은 2048 및 3072 비트와 같은 더 큰 크기의 DSA 매개 변수를 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec2b6fdf03e13d06e9e0b6a98f8b7548c1440c31" translate="yes" xml:space="preserve">
          <source>Note: Some earlier implementations of this interface may not support larger values of DSA parameters such as 3072-bit.</source>
          <target state="translated">참고 :이 인터페이스의 일부 이전 구현은 3072 비트와 같은 더 큰 DSA 매개 변수 값을 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba511f3a441875e19dfaf22c49c2beaa4e9cb0ef" translate="yes" xml:space="preserve">
          <source>Note: Standard name is returned instead of the specified one in the constructor when such mapping is available. See Appendix A in the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA&quot;&gt; Java Cryptography Architecture Reference Guide&lt;/a&gt; for information about standard Cipher algorithm names.</source>
          <target state="translated">참고 : 이러한 맵핑이 사용 가능한 경우 생성자에서 지정된 이름 대신 표준 이름이 리턴됩니다. 표준 암호 알고리즘 이름에 대한 정보 는 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html#AppA&quot;&gt;Java 암호화 아키텍처 참조 안내서&lt;/a&gt; 의 부록 A를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c2db3c69c7f69e3cb2b89f81c974e5aff29dd2e" translate="yes" xml:space="preserve">
          <source>Note: Standard name is returned instead of the specified one in the constructor when such mapping is available. See the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html&quot;&gt; Java Security Standard Algorithm Names&lt;/a&gt; document for information about standard Cipher algorithm names.</source>
          <target state="translated">참고 : 이러한 매핑을 사용할 수있는 경우 생성자에 지정된 이름 대신 표준 이름이 반환됩니다. 표준 Cipher 알고리즘 이름에 대한 정보 는 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html&quot;&gt;Java Security Standard Algorithm Names&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02ca53e7426de968d6b4390467d9ce03282652d8" translate="yes" xml:space="preserve">
          <source>Note: Subclasses should override this method. If not overridden, it will default to returning the X500Principal of the end-entity certificate that was sent to the server for certificate-based ciphersuites or, return null for non-certificate based ciphersuites, such as Kerberos.</source>
          <target state="translated">참고 : 서브 클래스는이 메소드를 대체해야합니다. 재정의되지 않은 경우 기본적으로 인증서 기반 암호 슈트를 위해 서버로 전송 된 엔드 엔티티 인증서의 X500Principal을 반환하거나 Kerberos와 같은 비 인증서 기반 암호 슈트는 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="181b38b916afc9a7e3cb0592916dee2435bd4057" translate="yes" xml:space="preserve">
          <source>Note: Subclasses should override this method. If not overridden, it will default to returning the X500Principal of the server's end-entity certificate for certificate-based ciphersuites, or throw an SSLPeerUnverifiedException for non-certificate based ciphersuites, such as Kerberos.</source>
          <target state="translated">참고 : 서브 클래스는이 메소드를 대체해야합니다. 재정의되지 않은 경우 기본적으로 인증서 기반 암호 슈트에 대한 서버의 엔드 엔터티 인증서 X500Principal을 반환하거나 Kerberos와 같은 비 인증서 기반 암호 슈트에 대해 SSLPeerUnverifiedException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4e0597c375ecd77e983347a6d8f736bf62b1ab15" translate="yes" xml:space="preserve">
          <source>Note: Subclasses should overwrite the default implementation.</source>
          <target state="translated">참고 : 서브 클래스는 기본 구현을 덮어 써야합니다.</target>
        </trans-unit>
        <trans-unit id="16a58c6ce5f2e360c902df800db7fbc9d1fe59ed" translate="yes" xml:space="preserve">
          <source>Note: Swing now calls the newer version of &lt;code&gt;canImport&lt;/code&gt; that takes a &lt;code&gt;TransferSupport&lt;/code&gt;, which in turn calls this method (only if the component in the &lt;code&gt;TransferSupport&lt;/code&gt; is a &lt;code&gt;JComponent&lt;/code&gt;). Developers are encouraged to call and override the newer version as it provides more information (and is the only version that supports use with a &lt;code&gt;TransferHandler&lt;/code&gt; set directly on a &lt;code&gt;JFrame&lt;/code&gt; or other non-&lt;code&gt;JComponent&lt;/code&gt;).</source>
          <target state="translated">참고 : Swing은 이제 &lt;code&gt;TransferSupport&lt;/code&gt; 를받는 최신 버전의 &lt;code&gt;canImport&lt;/code&gt; 를 호출하며 ,이 메서드 는 차례로이 메서드를 호출합니다 ( &lt;code&gt;TransferSupport&lt;/code&gt; 의 구성 요소가 가 &lt;code&gt;JComponent&lt;/code&gt; 인 ). 개발자는 더 많은 정보를 제공하므로 최신 버전을 호출하고 재정의하는 것이 좋습니다 (그리고 &lt;code&gt;JFrame&lt;/code&gt; 또는 기타 비 &lt;code&gt;JComponent&lt;/code&gt; 에 직접 설정된 &lt;code&gt;TransferHandler&lt;/code&gt; 와 함께 사용을 지원하는 유일한 버전입니다 ).</target>
        </trans-unit>
        <trans-unit id="a2ef303dc5896a382bfeec9da600a255a8435449" translate="yes" xml:space="preserve">
          <source>Note: Swing now calls the newer version of &lt;code&gt;importData&lt;/code&gt; that takes a &lt;code&gt;TransferSupport&lt;/code&gt;, which in turn calls this method (if the component in the &lt;code&gt;TransferSupport&lt;/code&gt; is a &lt;code&gt;JComponent&lt;/code&gt;). Developers are encouraged to call and override the newer version as it provides more information (and is the only version that supports use with a &lt;code&gt;TransferHandler&lt;/code&gt; set directly on a &lt;code&gt;JFrame&lt;/code&gt; or other non-&lt;code&gt;JComponent&lt;/code&gt;).</source>
          <target state="translated">참고 : Swing은 이제 &lt;code&gt;TransferSupport&lt;/code&gt; 를받는 최신 버전의 &lt;code&gt;importData&lt;/code&gt; 를 호출하고이 메서드 는 차례로이 메서드를 호출합니다 ( &lt;code&gt;TransferSupport&lt;/code&gt; 의 구성 요소 가 &lt;code&gt;JComponent&lt;/code&gt; 인 경우 ). 개발자는 더 많은 정보를 제공하므로 최신 버전을 호출하고 재정의하는 것이 좋습니다 (그리고 &lt;code&gt;JFrame&lt;/code&gt; 또는 기타 비 &lt;code&gt;JComponent&lt;/code&gt; 에 직접 설정된 &lt;code&gt;TransferHandler&lt;/code&gt; 와 함께 사용을 지원하는 유일한 버전입니다 ).</target>
        </trans-unit>
        <trans-unit id="eefb4ab75388eb8e2bf68b8d0b97c4da599de784" translate="yes" xml:space="preserve">
          <source>Note: That to the right of the caret will have the same index value as the offset (the caret is between two characters).</source>
          <target state="translated">참고 : 캐럿 오른쪽에는 오프셋과 동일한 인덱스 값이 있습니다 (캐럿은 두 문자 사이에 있음).</target>
        </trans-unit>
        <trans-unit id="829e8ef4ac4910ca11bd792b728127d71a3ea5d8" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;executors&quot;&gt;&lt;code&gt;Executors&lt;/code&gt;&lt;/a&gt; class includes a set of methods that can convert some other common closure-like objects, for example, &lt;a href=&quot;../../security/privilegedaction&quot;&gt;&lt;code&gt;PrivilegedAction&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;callable&quot;&gt;&lt;code&gt;Callable&lt;/code&gt;&lt;/a&gt; form so they can be submitted.</source>
          <target state="translated">참고 : &lt;a href=&quot;executors&quot;&gt; &lt;code&gt;Executors&lt;/code&gt; &lt;/a&gt; 클래스는 다른 일반적인 폐쇄와 같은 물체, 예를 들어, 변환 할 수있는 메소드 세트가 포함 &lt;a href=&quot;../../security/privilegedaction&quot;&gt; &lt;code&gt;PrivilegedAction&lt;/code&gt; 의&lt;/a&gt; 에 &lt;a href=&quot;callable&quot;&gt; &lt;code&gt;Callable&lt;/code&gt; &lt;/a&gt; 양식들이 제출 될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="d038e2ac66816e885c5abe1b8f25d98475e2e3be" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Clob&lt;/code&gt; object supplied to this constructor must return non-null for both the &lt;code&gt;Clob.getCharacterStream()&lt;/code&gt; and &lt;code&gt;Clob.getAsciiStream&lt;/code&gt; methods. This &lt;code&gt;SerialClob&lt;/code&gt; constructor cannot serialize a &lt;code&gt;Clob&lt;/code&gt; object in this instance and will throw an &lt;code&gt;SQLException&lt;/code&gt; object.</source>
          <target state="translated">참고 : 이 생성자에 제공된 &lt;code&gt;Clob&lt;/code&gt; 객체는 &lt;code&gt;Clob.getCharacterStream()&lt;/code&gt; 및 &lt;code&gt;Clob.getAsciiStream&lt;/code&gt; 메서드 모두에 대해 null이 아닌 값을 반환해야합니다 . 이 &lt;code&gt;SerialClob&lt;/code&gt; 생성자는 이 인스턴스에서 &lt;code&gt;Clob&lt;/code&gt; 개체를 직렬화 할 수 없으며 &lt;code&gt;SQLException&lt;/code&gt; 개체를 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="59edeaff2e6ceb0a281032fa44a530fb015d75d0" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;TransferSupport&lt;/code&gt; object passed to this method is only valid for the duration of the method call. It is undefined what values it may contain after this method returns.</source>
          <target state="translated">참고 : 이 메서드에 전달 된 &lt;code&gt;TransferSupport&lt;/code&gt; 개체는 메서드 호출 기간 동안 만 유효합니다. 이 메서드가 반환 된 후 어떤 값이 포함될 수 있는지는 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="86df5714c64fe20e95c1bd1a299337b5666514b4" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;acceptChanges()&lt;/code&gt; method will determine if the &lt;code&gt;COMMIT_ON_ACCEPT_CHANGES&lt;/code&gt; is set to true or not. If it is set to true, all updates in the synchronization are committed to the data source. Otherwise, the application &lt;b&gt;must&lt;/b&gt; explicitly call the &lt;code&gt;commit()&lt;/code&gt; or &lt;code&gt;rollback()&lt;/code&gt; methods as appropriate.</source>
          <target state="translated">참고 : &lt;code&gt;acceptChanges()&lt;/code&gt; 메소드는 &lt;code&gt;COMMIT_ON_ACCEPT_CHANGES&lt;/code&gt; 가 true로 설정 되었는지 여부를 판별합니다 . true로 설정하면 동기화의 모든 업데이트가 데이터 소스에 커밋됩니다. 그렇지 않으면 응용 프로그램 &lt;b&gt;이&lt;/b&gt; 명시 적으로 &lt;code&gt;commit()&lt;/code&gt; 또는 &lt;code&gt;rollback()&lt;/code&gt; 메서드를 적절 하게 호출 &lt;b&gt;해야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="e09b6f97f52df276a7f2d8e7779b8d21ae07350e" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;acceptChanges()&lt;/code&gt; method will determine if the &lt;code&gt;COMMIT_ON_ACCEPT_CHANGES&lt;/code&gt; is set to true or not. If it is set to true, all updates in the synchronization are committed to the data source. Otherwise, the application &lt;b&gt;must&lt;/b&gt; explicitly call the &lt;code&gt;commit&lt;/code&gt; or &lt;code&gt;rollback&lt;/code&gt; methods as appropriate.</source>
          <target state="translated">참고 : &lt;code&gt;acceptChanges()&lt;/code&gt; 메소드는 &lt;code&gt;COMMIT_ON_ACCEPT_CHANGES&lt;/code&gt; 가 true로 설정 되었는지 여부를 판별합니다 . true로 설정하면 동기화의 모든 업데이트가 데이터 소스에 커밋됩니다. 그렇지 않으면 응용 프로그램 이 &lt;code&gt;commit&lt;/code&gt; 또는 &lt;code&gt;rollback&lt;/code&gt; 메서드를 적절하게 명시 적으로 호출 &lt;b&gt;해야합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="5fc7d3199e794e858e1fae14ccd1dd4da161d25c" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;readAheadLimit&lt;/code&gt; for this class has no meaning.</source>
          <target state="translated">참고 : 이 클래스 의 &lt;code&gt;readAheadLimit&lt;/code&gt; 는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c70d1e1b6f573784d8c941b1e75ceb283fad1d2" translate="yes" xml:space="preserve">
          <source>Note: The LogManager may only retain a weak reference to the newly created Logger. It is important to understand that a previously created Logger with the given name may be garbage collected at any time if there is no strong reference to the Logger. In particular, this means that two back-to-back calls like &lt;code&gt;getLogger(&quot;MyLogger&quot;).log(...)&lt;/code&gt; may use different Logger objects named &quot;MyLogger&quot; if there is no strong reference to the Logger named &quot;MyLogger&quot; elsewhere in the program.</source>
          <target state="translated">참고 : LogManager는 새로 작성된 Logger에 대한 약한 참조 만 보유 할 수 있습니다. 지정된 이름으로 이전에 작성된 로거가 로거에 대한 강한 참조가없는 경우 언제든지 가비지 콜렉션 될 수 있음을 이해해야합니다. 특히, 다른 곳에 &quot;MyLogger&quot;라는 로거에 대한 참조가 없으면 &lt;code&gt;getLogger(&quot;MyLogger&quot;).log(...)&lt;/code&gt; 와 같은 두 개의 연속 호출이 &quot;MyLogger&quot; 라는 다른 Logger 객체를 사용할 수 있음을 의미합니다. 프로그램에서.</target>
        </trans-unit>
        <trans-unit id="92741ee82cf7d8822f7fe805f7832a246f91b414" translate="yes" xml:space="preserve">
          <source>Note: The LogManager may only retain a weak reference to the newly created Logger. It is important to understand that a previously created Logger with the given name may be garbage collected at any time if there is no strong reference to the Logger. In particular, this means that two back-to-back calls like &lt;code&gt;getLogger(&quot;MyLogger&quot;, ...).log(...)&lt;/code&gt; may use different Logger objects named &quot;MyLogger&quot; if there is no strong reference to the Logger named &quot;MyLogger&quot; elsewhere in the program.</source>
          <target state="translated">참고 : LogManager는 새로 작성된 Logger에 대한 약한 참조 만 보유 할 수 있습니다. 지정된 이름으로 이전에 작성된 로거가 로거에 대한 강한 참조가없는 경우 언제든지 가비지 콜렉션 될 수 있음을 이해해야합니다. 특히, 이는 &lt;code&gt;getLogger(&quot;MyLogger&quot;, ...).log(...)&lt;/code&gt; 에 대한 강력한 참조가 없으면 getLogger ( &quot;MyLogger&quot;, ...). log (...) 와 같은 두 개의 연속 호출에서 &quot;MyLogger&quot; 라는 다른 Logger 객체를 사용할 수 있음을 의미합니다. 프로그램의 다른 곳에서 &quot;MyLogger&quot;</target>
        </trans-unit>
        <trans-unit id="feb96d73bb909fef954b2328b78013fad55f611e" translate="yes" xml:space="preserve">
          <source>Note: The component must not be one that the developer has already added to the tabbed pane.</source>
          <target state="translated">참고 : 구성 요소는 개발자가 탭 창에 이미 추가 한 구성 요소가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="0c41d54bb9b5669b0c64912f8485c39fa1e24012" translate="yes" xml:space="preserve">
          <source>Note: The data transfer should be completed before the call to the &lt;code&gt;DropTargetDropEvent&lt;/code&gt;'s dropComplete(boolean success) method. After that, a call to the getTransferData() method of the &lt;code&gt;Transferable&lt;/code&gt; returned by &lt;code&gt;DropTargetDropEvent.getTransferable()&lt;/code&gt; is guaranteed to succeed only if the data transfer is local; that is, only if &lt;code&gt;DropTargetDropEvent.isLocalTransfer()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. Otherwise, the behavior of the call is implementation-dependent.</source>
          <target state="translated">참고 : 데이터 전송은 &lt;code&gt;DropTargetDropEvent&lt;/code&gt; 의 dropComplete (boolean success) 메서드를 호출하기 전에 완료되어야합니다 . 그 후 &lt;code&gt;DropTargetDropEvent.getTransferable()&lt;/code&gt; 이 반환 한 &lt;code&gt;Transferable&lt;/code&gt; 의 getTransferData () 메서드에 대한 호출 은 데이터 전송이 로컬 인 경우에만 성공할 수 있습니다. 즉, &lt;code&gt;DropTargetDropEvent.isLocalTransfer()&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 . 그렇지 않으면 호출 동작이 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="dc241da938e654c2874870e524b6658bbd0bf4e6" translate="yes" xml:space="preserve">
          <source>Note: The defined behavior for &lt;code&gt;equals&lt;/code&gt; is known to be inconsistent with virtual hosting in HTTP.</source>
          <target state="translated">참고 : &lt;code&gt;equals&lt;/code&gt; 에 대해 정의 된 동작 은 HTTP의 가상 호스팅과 일치하지 않는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="468af138ea1737287630fec9eab7e7e34cfe5243" translate="yes" xml:space="preserve">
          <source>Note: The object returned from this method may be an instance of an implementation-specific class. The &lt;code&gt;RemoteObject&lt;/code&gt; class ensures serialization portability of its instances' remote references through the behavior of its custom &lt;code&gt;writeObject&lt;/code&gt; and &lt;code&gt;readObject&lt;/code&gt; methods. An instance of &lt;code&gt;RemoteRef&lt;/code&gt; should not be serialized outside of its &lt;code&gt;RemoteObject&lt;/code&gt; wrapper instance or the result may be unportable.</source>
          <target state="translated">참고 :이 메서드에서 반환 된 개체는 구현 별 클래스의 인스턴스 일 수 있습니다. &lt;code&gt;RemoteObject&lt;/code&gt; 에의 그 사용자의 동작을 통해 인스턴스 '원격 참조의 클래스 보장하지만 직렬화 이동성 &lt;code&gt;writeObject&lt;/code&gt; 와 &lt;code&gt;readObject&lt;/code&gt; 에 방법. &lt;code&gt;RemoteRef&lt;/code&gt; 의 인스턴스는 &lt;code&gt;RemoteObject&lt;/code&gt; 래퍼 인스턴스 외부에서 직렬화되어서는 안됩니다. 그렇지 않으면 결과를 이식 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb2c0125ca52804eb84e6185f726b4defde7f085" translate="yes" xml:space="preserve">
          <source>Note: The platform MXBean interfaces (i.e. all subinterfaces of &lt;code&gt;PlatformManagedObject&lt;/code&gt;) are implemented by the Java platform only. New methods may be added in these interfaces in future Java SE releases. In addition, this &lt;code&gt;PlatformManagedObject&lt;/code&gt; interface is only intended for the management interfaces for the platform to extend but not for applications.</source>
          <target state="translated">참고 : 플랫폼 MXBean 인터페이스 (예 : &lt;code&gt;PlatformManagedObject&lt;/code&gt; 의 모든 하위 인터페이스 )는 Java 플랫폼으로 만 구현됩니다. 향후 Java SE 릴리스에서는 이러한 인터페이스에 새로운 메소드가 추가 될 수 있습니다. 또한이 &lt;code&gt;PlatformManagedObject&lt;/code&gt; 인터페이스는 플랫폼 의 관리 인터페이스만을위한 것이지 애플리케이션을위한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b080218a8b8b36e4aa5303cc15460cb9371e046f" translate="yes" xml:space="preserve">
          <source>Note: The process may not terminate immediately. For example, &lt;code&gt;isAlive()&lt;/code&gt; may return true for a brief period after &lt;code&gt;destroy()&lt;/code&gt; is called.</source>
          <target state="translated">참고 : 프로세스가 즉시 종료되지 않을 수 있습니다. 예를 들어 &lt;code&gt;isAlive()&lt;/code&gt; 는 &lt;code&gt;destroy()&lt;/code&gt; 가 호출 된 후 잠시 동안 true를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d0bdb488b2efc07500d457d8d10faa20dc11ebe" translate="yes" xml:space="preserve">
          <source>Note: The process may not terminate immediately. For example, &lt;code&gt;isAlive()&lt;/code&gt; may return true for a brief period after &lt;code&gt;destroyForcibly()&lt;/code&gt; is called.</source>
          <target state="translated">참고 : 프로세스가 즉시 종료되지 않을 수 있습니다. 예를 들어 &lt;code&gt;isAlive()&lt;/code&gt; 는 다음과 같은 짧은 기간 동안 true를 반환 할 수 있습니다. &lt;code&gt;destroyForcibly()&lt;/code&gt; 가 호출 된 .</target>
        </trans-unit>
        <trans-unit id="6f19f44a34138ef570fdb2e012d7bf045747baf1" translate="yes" xml:space="preserve">
          <source>Note: The resolved address may be cached for a short period of time.</source>
          <target state="translated">참고 : 확인 된 주소는 짧은 시간 동안 캐시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6529efd19f9ce88cc38433cb40d4dbd8c320abb9" translate="yes" xml:space="preserve">
          <source>Note: The returned &lt;code&gt;PropertyChangeSupport&lt;/code&gt; notifies any &lt;code&gt;PropertyChangeListener&lt;/code&gt;s asynchronously on the</source>
          <target state="translated">참고 : 반환 &lt;code&gt;PropertyChangeSupport&lt;/code&gt; 어떤 통지 &lt;code&gt;PropertyChangeListener&lt;/code&gt; 를 비동기 적으로</target>
        </trans-unit>
        <trans-unit id="099e578890eb02c5778f7dbd870796b27e93416c" translate="yes" xml:space="preserve">
          <source>Note: The returned bounds is in baseline-relative coordinates (see &lt;a href=&quot;font&quot;&gt;&lt;code&gt;class notes&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">참고 : 반환 된 경계는 기준선 기준 좌표에 있습니다 ( &lt;a href=&quot;font&quot;&gt; &lt;code&gt;class notes&lt;/code&gt; &lt;/a&gt; 참조). ).</target>
        </trans-unit>
        <trans-unit id="6b486ec4bb546b81e2bef4f03226078b2ee42cd9" translate="yes" xml:space="preserve">
          <source>Note: The returned bounds is in baseline-relative coordinates (see &lt;a href=&quot;fontmetrics&quot;&gt;&lt;code&gt;class notes&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">참고 : 반환 된 경계는 기준선 기준 좌표에 있습니다 ( &lt;a href=&quot;fontmetrics&quot;&gt; &lt;code&gt;class notes&lt;/code&gt; &lt;/a&gt; 참조). ).</target>
        </trans-unit>
        <trans-unit id="b3bfd4426fc891728706d1757aab601cdbe3889d" translate="yes" xml:space="preserve">
          <source>Note: The returned object is not guaranteed to operate correctly if multiple threads use it at the same time. A multi-threaded application should either allocate multiple packer engines, or else serialize use of one engine with a lock.</source>
          <target state="translated">참고 : 여러 스레드에서 동시에 사용하는 경우 반환 된 개체가 올바르게 작동하지 않을 수 있습니다. 멀티 스레드 응용 프로그램은 여러 패커 엔진을 할당하거나 잠금이있는 하나의 엔진 사용을 직렬화해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa12d2d2d24e785c7e1d72092e7d61dfd111c7aa" translate="yes" xml:space="preserve">
          <source>Note: The returned object is not guaranteed to operate correctly if multiple threads use it at the same time. A multi-threaded application should either allocate multiple unpacker engines, or else serialize use of one engine with a lock.</source>
          <target state="translated">참고 : 여러 스레드에서 동시에 사용하는 경우 반환 된 개체가 올바르게 작동하지 않을 수 있습니다. 다중 스레드 응용 프로그램은 여러 언 패커 엔진을 할당하거나 잠금이있는 하나의 엔진 사용을 직렬화해야합니다.</target>
        </trans-unit>
        <trans-unit id="106838bc9b93664cc34ef27cb55a64598b97cd81" translate="yes" xml:space="preserve">
          <source>Note: The returned value may not be a valid certificate chain and should not be relied on for trust decisions.</source>
          <target state="translated">참고 : 반환 된 값은 유효한 인증서 체인이 아닐 수 있으며 신뢰 결정에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4cb9867785bc909af714b72748d5541deebbcd80" translate="yes" xml:space="preserve">
          <source>Note: The specialized private key interfaces extend this interface. See, for example, the &lt;code&gt;DSAPrivateKey&lt;/code&gt; interface in &lt;a href=&quot;interfaces/package-summary&quot;&gt;&lt;code&gt;java.security.interfaces&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 : 특수한 개인 키 인터페이스는이 인터페이스를 확장합니다. 예를 들어 &lt;a href=&quot;interfaces/package-summary&quot;&gt; &lt;code&gt;java.security.interfaces&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;DSAPrivateKey&lt;/code&gt; 인터페이스를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6eb3a7abe026de2d8a10bdb0a405dc217846b10a" translate="yes" xml:space="preserve">
          <source>Note: The subprocess may not terminate immediately. i.e. &lt;code&gt;isAlive()&lt;/code&gt; may return true for a brief period after &lt;code&gt;destroyForcibly()&lt;/code&gt; is called. This method may be chained to &lt;code&gt;waitFor()&lt;/code&gt; if needed.</source>
          <target state="translated">참고 : 하위 프로세스가 즉시 종료되지 않을 수 있습니다. 즉, &lt;code&gt;destroyForcibly()&lt;/code&gt; 가 호출 된 후 &lt;code&gt;isAlive()&lt;/code&gt; 가 잠시 동안 true를 리턴 할 수 있습니다 . 이 메소드는 필요한 경우 &lt;code&gt;waitFor()&lt;/code&gt; 연결될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eef0e99dd372e2efc3310880c1b817efec541eab" translate="yes" xml:space="preserve">
          <source>Note: There is also a &lt;code&gt;java.security.AllPermission&lt;/code&gt; permission that implies all permissions. It exists to simplify the work of system administrators who might need to perform multiple tasks that require all (or numerous) permissions.</source>
          <target state="translated">참고 : 모든 권한을 암시 하는 &lt;code&gt;java.security.AllPermission&lt;/code&gt; 권한 도 있습니다 . 모든 (또는 수많은) 권한이 필요한 여러 작업을 수행해야하는 시스템 관리자의 작업을 단순화하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="161f6f9af0674cbec18438ee5499c28ed89293de" translate="yes" xml:space="preserve">
          <source>Note: This constructor will use null as the value of the algorithm parameters. If the encryption algorithm has parameters whose value is not null, a different constructor, e.g. EncryptedPrivateKeyInfo(AlgorithmParameters, byte[]), should be used.</source>
          <target state="translated">참고 :이 생성자는 알고리즘 매개 변수의 값으로 null을 사용합니다. 암호화 알고리즘에 값이 null이 아닌 매개 변수가있는 경우 다른 생성자 (예 : EncryptedPrivateKeyInfo (AlgorithmParameters, byte []))를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2df387d6ffad1cd1feb5babdedafd6cd1f5f317" translate="yes" xml:space="preserve">
          <source>Note: This functionality is not supported by all existing platforms, so it is implementation specific whether this option will be ignored or not. However, if it is not supported then &lt;a href=&quot;#getReuseAddress()&quot;&gt;&lt;code&gt;getReuseAddress()&lt;/code&gt;&lt;/a&gt; will always return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">참고 :이 기능은 모든 기존 플랫폼에서 지원되지 않으므로이 옵션을 무시할지 여부는 구현에 따라 다릅니다. 그러나 지원되지 않는 경우 &lt;a href=&quot;#getReuseAddress()&quot;&gt; &lt;code&gt;getReuseAddress()&lt;/code&gt; &lt;/a&gt; 는 항상 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0a0a4ee13e9a6c6b352dbd8267c67b65f32862ca" translate="yes" xml:space="preserve">
          <source>Note: This functionality is not supported by all existing platforms, so it is implementation specific whether this option will be ignored or not. However, if it is not supported then &lt;a href=&quot;datagramsocket#getReuseAddress--&quot;&gt;&lt;code&gt;getReuseAddress()&lt;/code&gt;&lt;/a&gt; will always return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">참고 :이 기능은 모든 기존 플랫폼에서 지원되지 않으므로이 옵션을 무시할지 여부에 따라 구현에 따라 다릅니다. 그러나 지원되지 않으면 &lt;a href=&quot;datagramsocket#getReuseAddress--&quot;&gt; &lt;code&gt;getReuseAddress()&lt;/code&gt; &lt;/a&gt; 는 항상 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="636978926816ab760e5f8bfa6d24cf456467b20b" translate="yes" xml:space="preserve">
          <source>Note: This is merely a convenience wrapper. All work is delegated to &lt;code&gt;PropertyChangeSupport&lt;/code&gt; from &lt;a href=&quot;#getPropertyChangeSupport()&quot;&gt;&lt;code&gt;getPropertyChangeSupport()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 : 이것은 단지 편의 래퍼입니다. 모든 작업은 &lt;a href=&quot;#getPropertyChangeSupport()&quot;&gt; &lt;code&gt;getPropertyChangeSupport()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;PropertyChangeSupport&lt;/code&gt; 로 위임됩니다 .</target>
        </trans-unit>
        <trans-unit id="94361f297ac53fd6e2fe262dfb0ec7c6082e72f2" translate="yes" xml:space="preserve">
          <source>Note: This method can be used only when using certificate-based cipher suites; using it with non-certificate-based cipher suites, such as Kerberos, will throw an SSLPeerUnverifiedException.</source>
          <target state="translated">참고 :이 방법은 인증서 기반 암호 제품군을 사용할 때만 사용할 수 있습니다. Kerberos와 같은 비인증 기반 암호 그룹과 함께 사용하면 SSLPeerUnverifiedException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="33eea527f5ec580857a4627523cfd3c4cde86c2c" translate="yes" xml:space="preserve">
          <source>Note: This method exists for backward binary compatibility with earlier versions of the Swing library. It simply returns the result returned by &lt;a href=&quot;#currentManager(java.awt.Component)&quot;&gt;&lt;code&gt;currentManager(Component)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 :이 메서드는 이전 버전의 Swing 라이브러리와의 하위 바이너리 호환성을 위해 존재합니다. 단순히 &lt;a href=&quot;#currentManager(java.awt.Component)&quot;&gt; &lt;code&gt;currentManager(Component)&lt;/code&gt; &lt;/a&gt; 의해 반환 된 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e5a14fa0e58bb4ad092b08d41779f8de970fe707" translate="yes" xml:space="preserve">
          <source>Note: This method is intended to be called by the &lt;a href=&quot;imageproducer&quot;&gt;&lt;code&gt;ImageProducer&lt;/code&gt;&lt;/a&gt; of the &lt;code&gt;Image&lt;/code&gt; whose pixels are being filtered. Developers using this class to retrieve pixels from an image should avoid calling this method directly since that operation could result in problems with retrieving the requested pixels.</source>
          <target state="translated">참고 :이 메서드는 픽셀이 필터링되는 &lt;code&gt;Image&lt;/code&gt; 의 &lt;a href=&quot;imageproducer&quot;&gt; &lt;code&gt;ImageProducer&lt;/code&gt; &lt;/a&gt; 에 의해 호출됩니다 . 이 클래스를 사용하여 이미지에서 픽셀을 검색하는 개발자는이 메서드를 직접 호출하지 않아야합니다.이 작업은 요청 된 픽셀 검색에 문제를 일으킬 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f4b7e71d9afb52221bee88c0a4a2f9ffcdbd8c6f" translate="yes" xml:space="preserve">
          <source>Note: This method is intended to be called by the &lt;code&gt;ImageProducer&lt;/code&gt; of the &lt;code&gt;Image&lt;/code&gt; whose pixels are being filtered. Developers using this class to filter pixels from an image should avoid calling this method directly since that operation could interfere with the filtering operation.</source>
          <target state="translated">참고 :이 메서드는 &lt;code&gt;Image&lt;/code&gt; 의 &lt;code&gt;ImageProducer&lt;/code&gt; 에 의해 호출됩니다. 픽셀이 필터링되는 . 이 클래스를 사용하여 이미지에서 픽셀을 필터링하는 개발자는이 작업이 필터링 작업을 방해 할 수 있으므로이 메서드를 직접 호출하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="0cef8832cdd205b2719b0e0946fff4fc10ffc81d" translate="yes" xml:space="preserve">
          <source>Note: This method is intended to be called by the &lt;code&gt;ImageProducer&lt;/code&gt; of the &lt;code&gt;Image&lt;/code&gt; whose pixels are being filtered. Developers using this class to retrieve pixels from an image should avoid calling this method directly since that operation could result in problems with retrieving the requested pixels.</source>
          <target state="translated">참고 :이 메서드는 픽셀이 필터링되는 &lt;code&gt;Image&lt;/code&gt; 의 &lt;code&gt;ImageProducer&lt;/code&gt; 에 의해 호출됩니다 . 이 클래스를 사용하여 이미지에서 픽셀을 검색하는 개발자는이 메서드를 직접 호출하지 않아야합니다.이 작업은 요청 된 픽셀 검색에 문제를 일으킬 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9cbed1da035477ce5bc0b5afa5763ab6f9fcd84e" translate="yes" xml:space="preserve">
          <source>Note: This method is intended to be called by the ImageProducer of the Image whose pixels are being filtered. Developers using this class to filter pixels from an image should avoid calling this method directly since that operation could interfere with the filtering operation.</source>
          <target state="translated">Note: This method is intended to be called by the ImageProducer of the Image whose pixels are being filtered. Developers using this class to filter pixels from an image should avoid calling this method directly since that operation could interfere with the filtering operation.</target>
        </trans-unit>
        <trans-unit id="100545d6f4bfc8cd356ed5027863a959afefa37f" translate="yes" xml:space="preserve">
          <source>Note: This method is intended to be called by the ImageProducer of the Image whose pixels are being grabbed. Developers using this class to retrieve pixels from an image should avoid calling this method directly since that operation could result in problems with retrieving the requested pixels.</source>
          <target state="translated">Note: This method is intended to be called by the ImageProducer of the Image whose pixels are being grabbed. Developers using this class to retrieve pixels from an image should avoid calling this method directly since that operation could result in problems with retrieving the requested pixels.</target>
        </trans-unit>
        <trans-unit id="8e332b3dabe0b9e378ed40e7be4f3e446472fccd" translate="yes" xml:space="preserve">
          <source>Note: This method is useful only when using certificate-based cipher suites.</source>
          <target state="translated">참고 :이 방법은 인증서 기반 암호 제품군을 사용하는 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="66ae0f7e3684dd3137d4b1574bf70434fe5d283b" translate="yes" xml:space="preserve">
          <source>Note: This method provides complimentary functionality to that provided by other high level Swing printing APIs. However, it deals strictly with painting and should not be confused as providing information on higher level print processes. For example, a &lt;a href=&quot;jtable#print()&quot;&gt;&lt;code&gt;JTable.print()&lt;/code&gt;&lt;/a&gt; operation doesn't necessarily result in a continuous rendering of the full component, and the return value of this method can change multiple times during that operation. It is even possible for the component to be painted to the screen while the printing process is ongoing. In such a case, the return value of this method is &lt;code&gt;true&lt;/code&gt; when, and only when, the table is being painted as part of the printing process.</source>
          <target state="translated">Note: This method provides complimentary functionality to that provided by other high level Swing printing APIs. However, it deals strictly with painting and should not be confused as providing information on higher level print processes. For example, a &lt;a href=&quot;jtable#print()&quot;&gt; &lt;code&gt;JTable.print()&lt;/code&gt; &lt;/a&gt; operation doesn't necessarily result in a continuous rendering of the full component, and the return value of this method can change multiple times during that operation. It is even possible for the component to be painted to the screen while the printing process is ongoing. In such a case, the return value of this method is &lt;code&gt;true&lt;/code&gt; when, and only when, the table is being painted as part of the printing process.</target>
        </trans-unit>
        <trans-unit id="bbe8d1e4d86c4411b4dfede1ea9306782c513bfb" translate="yes" xml:space="preserve">
          <source>Note: This method provides the same functionality as &lt;code&gt;getWindowAncestor&lt;/code&gt;.</source>
          <target state="translated">Note: This method provides the same functionality as &lt;code&gt;getWindowAncestor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aabebac2509a2877a3ddc5ae871ed25bf3913a4" translate="yes" xml:space="preserve">
          <source>Note: This method should be called under AWT tree lock.</source>
          <target state="translated">Note: This method should be called under AWT tree lock.</target>
        </trans-unit>
        <trans-unit id="477184c0322c989403dcf2a2ce082334f1041366" translate="yes" xml:space="preserve">
          <source>Note: Unless it is necessary to fetch the &lt;code&gt;Transferable&lt;/code&gt; directly, use one of the other methods on this class to inquire about the transfer. This may perform better than fetching the &lt;code&gt;Transferable&lt;/code&gt; and asking it directly.</source>
          <target state="translated">Note: Unless it is necessary to fetch the &lt;code&gt;Transferable&lt;/code&gt; directly, use one of the other methods on this class to inquire about the transfer. This may perform better than fetching the &lt;code&gt;Transferable&lt;/code&gt; and asking it directly.</target>
        </trans-unit>
        <trans-unit id="0025b496272ff53acd29d2ec8253eb1cf0ca5710" translate="yes" xml:space="preserve">
          <source>Note: Unless otherwise noted, passing a &lt;code&gt;null&lt;/code&gt; argument to a constructor or method in this class will cause a &lt;a href=&quot;../../lang/nullpointerexception&quot;&gt;&lt;code&gt;NullPointerException&lt;/code&gt;&lt;/a&gt; to be thrown.</source>
          <target state="translated">참고 : 달리 명시되지 않는 한이 클래스의 생성자 또는 메서드에 &lt;code&gt;null&lt;/code&gt; 인수를 전달 하면 &lt;a href=&quot;../../lang/nullpointerexception&quot;&gt; &lt;code&gt;NullPointerException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d73b71abd37a6b70a78bd968c113e2554e93e98" translate="yes" xml:space="preserve">
          <source>Note: Use &lt;code&gt;setBlockIncrement&lt;/code&gt; to set the block increment to a size slightly smaller than the view's extent. That way, when the user jumps the knob to an adjacent position, one or two lines of the original contents remain in view.</source>
          <target state="translated">Note: Use &lt;code&gt;setBlockIncrement&lt;/code&gt; to set the block increment to a size slightly smaller than the view's extent. That way, when the user jumps the knob to an adjacent position, one or two lines of the original contents remain in view.</target>
        </trans-unit>
        <trans-unit id="34ede23809d266a2bb257d3aae7951ad307ef882" translate="yes" xml:space="preserve">
          <source>Note: When used with &lt;code&gt;JApplet&lt;/code&gt;, &lt;code&gt;TransferHandler&lt;/code&gt; only provides data import capability, as the data export related methods are currently typed to &lt;code&gt;JComponent&lt;/code&gt;.</source>
          <target state="translated">Note: When used with &lt;code&gt;JApplet&lt;/code&gt; , &lt;code&gt;TransferHandler&lt;/code&gt; only provides data import capability, as the data export related methods are currently typed to &lt;code&gt;JComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df06db0f3294c6120242097a6af4757bb34f882c" translate="yes" xml:space="preserve">
          <source>Note: When used with &lt;code&gt;JDialog&lt;/code&gt;, &lt;code&gt;TransferHandler&lt;/code&gt; only provides data import capability, as the data export related methods are currently typed to &lt;code&gt;JComponent&lt;/code&gt;.</source>
          <target state="translated">Note: When used with &lt;code&gt;JDialog&lt;/code&gt; , &lt;code&gt;TransferHandler&lt;/code&gt; only provides data import capability, as the data export related methods are currently typed to &lt;code&gt;JComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="322e15c7dadef29a3e87b89c79ffab47c2a53df2" translate="yes" xml:space="preserve">
          <source>Note: When used with &lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;TransferHandler&lt;/code&gt; only provides data import capability, as the data export related methods are currently typed to &lt;code&gt;JComponent&lt;/code&gt;.</source>
          <target state="translated">Note: When used with &lt;code&gt;JFrame&lt;/code&gt; , &lt;code&gt;TransferHandler&lt;/code&gt; only provides data import capability, as the data export related methods are currently typed to &lt;code&gt;JComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="197740af44caa7532f1e472ba1b85b1abffff1fa" translate="yes" xml:space="preserve">
          <source>Note: When used with &lt;code&gt;JWindow&lt;/code&gt;, &lt;code&gt;TransferHandler&lt;/code&gt; only provides data import capability, as the data export related methods are currently typed to &lt;code&gt;JComponent&lt;/code&gt;.</source>
          <target state="translated">Note: When used with &lt;code&gt;JWindow&lt;/code&gt; , &lt;code&gt;TransferHandler&lt;/code&gt; only provides data import capability, as the data export related methods are currently typed to &lt;code&gt;JComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f23f77f4ad25e60f14465494e7ece9e030e6cbf0" translate="yes" xml:space="preserve">
          <source>Note: When using the 'nowrap' option it is also necessary to provide an extra &quot;dummy&quot; byte as input. This is required by the ZLIB native library in order to support certain optimizations.</source>
          <target state="translated">참고 : 'nowrap'옵션을 사용하는 경우 추가 &quot;더미&quot;바이트를 입력으로 제공해야합니다. 이는 특정 최적화를 지원하기 위해 ZLIB 기본 라이브러리에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3f937bca17c9ac9472d4a1054b2dbdf22c1cacc4" translate="yes" xml:space="preserve">
          <source>Note: While it is permissible for lists to contain themselves as elements, extreme caution is advised: the &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hashCode&lt;/code&gt; methods are no longer well defined on such a list.</source>
          <target state="translated">참고 :리스트가 자신을 요소로 포함하는 것이 허용되지만 극도의주의가 필요합니다. &lt;code&gt;equals&lt;/code&gt; 및 &lt;code&gt;hashCode&lt;/code&gt; 메소드는 더 이상 이러한리스트에서 잘 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="505eabdf8606963a0a713cdc819bdc17903921f9" translate="yes" xml:space="preserve">
          <source>Note: array sizes of parameters should match. If both arrays are empty, then an empty descriptor is created.</source>
          <target state="translated">참고 : 매개 변수의 배열 크기가 일치해야합니다. 두 배열이 모두 비어 있으면 빈 설명자가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9cb7ccc0dba74e30da8abb592eb7db1f3faea618" translate="yes" xml:space="preserve">
          <source>Note: as of the Java 2 platform v1.3, it is recommended that developers call Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead of using this method.</source>
          <target state="translated">Note: as of the Java 2 platform v1.3, it is recommended that developers call Component.AccessibleAWTComponent.getAccessibleIndexInParent() instead of using this method.</target>
        </trans-unit>
        <trans-unit id="23df42e7e6dc01a77c67ab6ce4ec9cc24c2a3029" translate="yes" xml:space="preserve">
          <source>Note: calling &lt;code&gt;get&lt;/code&gt; on the</source>
          <target state="translated">Note: calling &lt;code&gt;get&lt;/code&gt; on the</target>
        </trans-unit>
        <trans-unit id="16c77652d4c9e7acdab4bd784b702218d68992cf" translate="yes" xml:space="preserve">
          <source>Note: care should be exercised if &lt;code&gt;BigDecimal&lt;/code&gt; objects are used as keys in a &lt;a href=&quot;../util/sortedmap&quot;&gt;&lt;code&gt;SortedMap&lt;/code&gt;&lt;/a&gt; or elements in a &lt;a href=&quot;../util/sortedset&quot;&gt;&lt;code&gt;SortedSet&lt;/code&gt;&lt;/a&gt; since &lt;code&gt;BigDecimal&lt;/code&gt;'s</source>
          <target state="translated">참고 : 경우에주의를 기울여야한다 &lt;code&gt;BigDecimal&lt;/code&gt; 객체가 키로서 사용 &lt;a href=&quot;../util/sortedmap&quot;&gt; &lt;code&gt;SortedMap&lt;/code&gt; &lt;/a&gt; A의 또는 요소 &lt;a href=&quot;../util/sortedset&quot;&gt; &lt;code&gt;SortedSet&lt;/code&gt; 의&lt;/a&gt; 이후 &lt;code&gt;BigDecimal&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="741b0ef233c352c251d9a74cef092014bc932507" translate="yes" xml:space="preserve">
          <source>Note: changing modality of the visible dialog may have no effect until it is hidden and then shown again.</source>
          <target state="translated">Note: changing modality of the visible dialog may have no effect until it is hidden and then shown again.</target>
        </trans-unit>
        <trans-unit id="d7e1d73aa585de626fdba584c2f16fba537745eb" translate="yes" xml:space="preserve">
          <source>Note: changing the modal exclusion type for a visible window may have no effect until it is hidden and then shown again.</source>
          <target state="translated">Note: changing the modal exclusion type for a visible window may have no effect until it is hidden and then shown again.</target>
        </trans-unit>
        <trans-unit id="1798306e90fb7c0582f65fa555645adc7b33a9b8" translate="yes" xml:space="preserve">
          <source>Note: developers/admininstrators are responsible for verifying the trustworthiness of content and structure of the Java Agents they deploy, since those are able to arbitrarily transform the bytecode from other JAR files. Since that happens after the Jars containing the bytecode have been verified as trusted, the trustworthiness of a Java Agent can determine the trust towards the entire program.</source>
          <target state="translated">Note: developers/admininstrators are responsible for verifying the trustworthiness of content and structure of the Java Agents they deploy, since those are able to arbitrarily transform the bytecode from other JAR files. Since that happens after the Jars containing the bytecode have been verified as trusted, the trustworthiness of a Java Agent can determine the trust towards the entire program.</target>
        </trans-unit>
        <trans-unit id="6921cbe0752e6d510f001c2f6210fb8c10abaff6" translate="yes" xml:space="preserve">
          <source>Note: even if the given location is unknown to this file manager, it may not return &lt;code&gt;null&lt;/code&gt;. Also, an unknown location may not cause an exception.</source>
          <target state="translated">참고 : 지정된 위치를이 파일 관리자에게 알 수없는 경우에도 &lt;code&gt;null&lt;/code&gt; 을 반환하지 않을 수 있습니다 . 또한 알 수없는 위치에서 예외가 발생하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5124f5aec598032623493444e4d1dac43bd422f0" translate="yes" xml:space="preserve">
          <source>Note: event listener use is not recommended for normal application use, but are intended solely to support special purpose facilities including support for accessibility, event record/playback, and diagnostic tracing. If listener is null, no exception is thrown and no action is performed.</source>
          <target state="translated">Note: event listener use is not recommended for normal application use, but are intended solely to support special purpose facilities including support for accessibility, event record/playback, and diagnostic tracing. If listener is null, no exception is thrown and no action is performed.</target>
        </trans-unit>
        <trans-unit id="180c34d2e81d8e434398cee9487b9d0319236ffd" translate="yes" xml:space="preserve">
          <source>Note: great care must be exercised if mutable objects are used as map keys. The behavior of a map is not specified if the value of an object is changed in a manner that affects &lt;code&gt;equals&lt;/code&gt; comparisons while the object is a key in the map. A special case of this prohibition is that it is not permissible for a map to contain itself as a key. While it is permissible for a map to contain itself as a value, extreme caution is advised: the &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hashCode&lt;/code&gt; methods are no longer well defined on such a map.</source>
          <target state="translated">참고 : 가변 객체를 맵 키로 사용하는 경우 각별히주의해야합니다. 객체의 값이 &lt;code&gt;equals&lt;/code&gt; 비교에 영향을주는 방식으로 변경되고 객체가 맵의 키인 경우 맵의 동작이 지정되지 않습니다 . 이 금지의 특별한 경우는지도 자체를 키로 포함 할 수 없다는 것입니다. 맵 자체를 값으로 포함하는 것이 허용되지만, &lt;code&gt;equals&lt;/code&gt; 및 &lt;code&gt;hashCode&lt;/code&gt; 메소드는 더 이상 이러한 맵에서 잘 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a75de3ff31fb77a6247d0aa1dbb039e97f176e62" translate="yes" xml:space="preserve">
          <source>Note: identifiers are not used by the &lt;code&gt;JTable&lt;/code&gt;, they are purely a convenience for the external tagging and location of columns.</source>
          <target state="translated">Note: identifiers are not used by the &lt;code&gt;JTable&lt;/code&gt; , they are purely a convenience for the external tagging and location of columns.</target>
        </trans-unit>
        <trans-unit id="2931b23d7b7b4db43ee8187342264bc1d9c15128" translate="yes" xml:space="preserve">
          <source>Note: if a character is not assigned a name by the</source>
          <target state="translated">Note: if a character is not assigned a name by the</target>
        </trans-unit>
        <trans-unit id="ee88c3e4d27839298d1c22f3efa586d46721def1" translate="yes" xml:space="preserve">
          <source>Note: if an image is used which has more colors in its palette than the supported maximum, the Toolkit implementation will attempt to flatten the palette to the maximum. Since converting low-resolution images is difficult, no guarantees are made as to the quality of a cursor image which has more colors than the system supports. It is therefore recommended that this method be called and an appropriate image used so no image conversion is made.</source>
          <target state="translated">Note: if an image is used which has more colors in its palette than the supported maximum, the Toolkit implementation will attempt to flatten the palette to the maximum. Since converting low-resolution images is difficult, no guarantees are made as to the quality of a cursor image which has more colors than the system supports. It is therefore recommended that this method be called and an appropriate image used so no image conversion is made.</target>
        </trans-unit>
        <trans-unit id="4efe3de41f67dbcc306f4e2b9489df3b7a541757" translate="yes" xml:space="preserve">
          <source>Note: if an image is used whose dimensions don't match a supported size (as returned by this method), the Toolkit implementation will attempt to resize the image to a supported size. Since converting low-resolution images is difficult, no guarantees are made as to the quality of a cursor image which isn't a supported size. It is therefore recommended that this method be called and an appropriate image used so no image conversion is made.</source>
          <target state="translated">Note: if an image is used whose dimensions don't match a supported size (as returned by this method), the Toolkit implementation will attempt to resize the image to a supported size. Since converting low-resolution images is difficult, no guarantees are made as to the quality of a cursor image which isn't a supported size. It is therefore recommended that this method be called and an appropriate image used so no image conversion is made.</target>
        </trans-unit>
        <trans-unit id="8a697d8c55e21f60ed4e4901b9287f9774c575bd" translate="yes" xml:space="preserve">
          <source>Note: if any exception is thrown, this cipher object may need to be reset before it can be used again.</source>
          <target state="translated">참고 : 예외가 발생하면이 암호 오브젝트를 다시 사용하기 전에 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="2fbce5af855378db205c37caeced27c12b4240bc" translate="yes" xml:space="preserve">
          <source>Note: if the absolute value of the &lt;code&gt;year&lt;/code&gt; parameter is less than 10^9, the eon component of the XSD year field is set to &lt;code&gt;null&lt;/code&gt; by this method.</source>
          <target state="translated">Note: if the absolute value of the &lt;code&gt;year&lt;/code&gt; parameter is less than 10^9, the eon component of the XSD year field is set to &lt;code&gt;null&lt;/code&gt; by this method.</target>
        </trans-unit>
        <trans-unit id="c4d18bf16fef65ee4df5429425c0b70bc20fc2c8" translate="yes" xml:space="preserve">
          <source>Note: if the specified character is not assigned a name by the</source>
          <target state="translated">참고 : 지정된 문자에 이름이 지정되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="8d8eeafbd4864744c1b8efac25892d3e6593e811" translate="yes" xml:space="preserve">
          <source>Note: if the specified input stream is null, a NullPointerException may be thrown later when it is used.</source>
          <target state="translated">참고 : 지정된 입력 스트림이 null 인 경우 NullPointerException은 나중에 사용될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="db21cd5e3700d9fbc6e2592e22159b2290890ef5" translate="yes" xml:space="preserve">
          <source>Note: if the specified input stream or cipher is null, a NullPointerException may be thrown later when they are used.</source>
          <target state="translated">참고 : 지정된 입력 스트림 또는 암호가 null 인 경우, NullPointerException은 나중에 사용될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1d9c7d9dcc35f4bd90cfea6bfb1874a257dce012" translate="yes" xml:space="preserve">
          <source>Note: if the specified output stream is null, a NullPointerException may be thrown later when it is used.</source>
          <target state="translated">참고 : 지정된 출력 스트림이 null 인 경우 나중에 사용될 때 NullPointerException이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8856a6ecaa819114e46b4324d69892be4a896b4" translate="yes" xml:space="preserve">
          <source>Note: if the specified output stream or cipher is null, a NullPointerException may be thrown later when they are used.</source>
          <target state="translated">참고 : 지정된 출력 스트림 또는 암호가 null 인 경우 NullPointerException은 나중에 사용될 때 throw 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="897316a0899efbadf3a585a6787a4cbe227b984f" translate="yes" xml:space="preserve">
          <source>Note: if there was a previous accessory, you should unregister any listeners that the accessory might have registered with the file chooser.</source>
          <target state="translated">Note: if there was a previous accessory, you should unregister any listeners that the accessory might have registered with the file chooser.</target>
        </trans-unit>
        <trans-unit id="c4fb9251f8e5e6cedab11c66269a494e164be98c" translate="yes" xml:space="preserve">
          <source>Note: it is not always necessary to do algorithm-specific initialization for a DSA key pair generator. That is, it is not always necessary to call an &lt;code&gt;initialize&lt;/code&gt; method in this interface. Algorithm-independent initialization using the &lt;code&gt;initialize&lt;/code&gt; method in the KeyPairGenerator interface is all that is needed when you accept defaults for algorithm-specific parameters.</source>
          <target state="translated">Note: it is not always necessary to do algorithm-specific initialization for a DSA key pair generator. That is, it is not always necessary to call an &lt;code&gt;initialize&lt;/code&gt; method in this interface. Algorithm-independent initialization using the &lt;code&gt;initialize&lt;/code&gt; method in the KeyPairGenerator interface is all that is needed when you accept defaults for algorithm-specific parameters.</target>
        </trans-unit>
        <trans-unit id="6e1bf534d41e15a9a6cf514a78139f8a46a780c7" translate="yes" xml:space="preserve">
          <source>Note: it is not always necessary to do do algorithm-specific initialization for a DSA key pair generator. That is, it is not always necessary to call an &lt;code&gt;initialize&lt;/code&gt; method in this interface. Algorithm-independent initialization using the &lt;code&gt;initialize&lt;/code&gt; method in the KeyPairGenerator interface is all that is needed when you accept defaults for algorithm-specific parameters.</source>
          <target state="translated">참고 : DSA 키 쌍 생성기에 대해 알고리즘 별 초기화를 항상 수행 할 필요는 없습니다. 즉, 이 인터페이스에서 항상 &lt;code&gt;initialize&lt;/code&gt; 메소드 를 호출 할 필요는 없습니다 . KeyPairGenerator 인터페이스에서 &lt;code&gt;initialize&lt;/code&gt; 메소드를 사용한 알고리즘 독립적 초기화 는 알고리즘 특정 매개 변수에 대한 기본값을 승인 할 때 필요한 모든 것입니다.</target>
        </trans-unit>
        <trans-unit id="4e86deb3c86955cf59ec0fb10a08a9b557e8c2a0" translate="yes" xml:space="preserve">
          <source>Note: several methods return subsets with restricted ranges. Such ranges are</source>
          <target state="translated">참고 : 일부 방법은 제한된 범위의 하위 집합을 반환합니다. 이러한 범위는</target>
        </trans-unit>
        <trans-unit id="ace7b5d400945c269ef96078c34aaecd9a3f554b" translate="yes" xml:space="preserve">
          <source>Note: some implementations may cache the value returned from the &lt;code&gt;LayoutManager2&lt;/code&gt;. Implementations that cache need not invoke &lt;code&gt;maximumLayoutSize&lt;/code&gt; on the &lt;code&gt;LayoutManager2&lt;/code&gt; every time this method is invoked, rather the &lt;code&gt;LayoutManager2&lt;/code&gt; will only be queried after the &lt;code&gt;Container&lt;/code&gt; becomes invalid.</source>
          <target state="translated">Note: some implementations may cache the value returned from the &lt;code&gt;LayoutManager2&lt;/code&gt; . Implementations that cache need not invoke &lt;code&gt;maximumLayoutSize&lt;/code&gt; on the &lt;code&gt;LayoutManager2&lt;/code&gt; every time this method is invoked, rather the &lt;code&gt;LayoutManager2&lt;/code&gt; will only be queried after the &lt;code&gt;Container&lt;/code&gt; becomes invalid.</target>
        </trans-unit>
        <trans-unit id="f13ee6cf9d73ed78cf46e2da2b90cecbc2454544" translate="yes" xml:space="preserve">
          <source>Note: some implementations may cache the value returned from the &lt;code&gt;LayoutManager&lt;/code&gt;. Implementations that cache need not invoke &lt;code&gt;minimumLayoutSize&lt;/code&gt; on the &lt;code&gt;LayoutManager&lt;/code&gt; every time this method is invoked, rather the &lt;code&gt;LayoutManager&lt;/code&gt; will only be queried after the &lt;code&gt;Container&lt;/code&gt; becomes invalid.</source>
          <target state="translated">Note: some implementations may cache the value returned from the &lt;code&gt;LayoutManager&lt;/code&gt; . Implementations that cache need not invoke &lt;code&gt;minimumLayoutSize&lt;/code&gt; on the &lt;code&gt;LayoutManager&lt;/code&gt; every time this method is invoked, rather the &lt;code&gt;LayoutManager&lt;/code&gt; will only be queried after the &lt;code&gt;Container&lt;/code&gt; becomes invalid.</target>
        </trans-unit>
        <trans-unit id="4ad34544e3be908d5dd481733189cf6dd60c0b4c" translate="yes" xml:space="preserve">
          <source>Note: some implementations may cache the value returned from the &lt;code&gt;LayoutManager&lt;/code&gt;. Implementations that cache need not invoke &lt;code&gt;preferredLayoutSize&lt;/code&gt; on the &lt;code&gt;LayoutManager&lt;/code&gt; every time this method is invoked, rather the &lt;code&gt;LayoutManager&lt;/code&gt; will only be queried after the &lt;code&gt;Container&lt;/code&gt; becomes invalid.</source>
          <target state="translated">Note: some implementations may cache the value returned from the &lt;code&gt;LayoutManager&lt;/code&gt; . Implementations that cache need not invoke &lt;code&gt;preferredLayoutSize&lt;/code&gt; on the &lt;code&gt;LayoutManager&lt;/code&gt; every time this method is invoked, rather the &lt;code&gt;LayoutManager&lt;/code&gt; will only be queried after the &lt;code&gt;Container&lt;/code&gt; becomes invalid.</target>
        </trans-unit>
        <trans-unit id="16136af4648dce88819b215df9b172cff3b42293" translate="yes" xml:space="preserve">
          <source>Note: some methods, such as &lt;code&gt;getLocationOnScreen&lt;/code&gt;, can only provide meaningful results if the applet is showing. Because &lt;code&gt;isShowing&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; when the applet's &lt;code&gt;start&lt;/code&gt; is first called, methods requiring &lt;code&gt;isShowing&lt;/code&gt; to return &lt;code&gt;true&lt;/code&gt; should be called from a &lt;code&gt;ComponentListener&lt;/code&gt;.</source>
          <target state="translated">Note: some methods, such as &lt;code&gt;getLocationOnScreen&lt;/code&gt; , can only provide meaningful results if the applet is showing. Because &lt;code&gt;isShowing&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; when the applet's &lt;code&gt;start&lt;/code&gt; is first called, methods requiring &lt;code&gt;isShowing&lt;/code&gt; to return &lt;code&gt;true&lt;/code&gt; should be called from a &lt;code&gt;ComponentListener&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9f5ecb473ea61e73f17835fd480c39b90f7da88" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;password&lt;/code&gt; and &lt;code&gt;salt&lt;/code&gt; are cloned before they are stored in the new &lt;code&gt;PBEKeySpec&lt;/code&gt; object.</source>
          <target state="translated">참고 : &lt;code&gt;password&lt;/code&gt; 와 &lt;code&gt;salt&lt;/code&gt; 는 새 &lt;code&gt;PBEKeySpec&lt;/code&gt; 오브젝트에 저장되기 전에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="215af8f9227e90af523822742aff59c3c61b8c2d" translate="yes" xml:space="preserve">
          <source>Note: the JTextComponent must have a valid size (e.g. have been added to a parent container whose ancestor container is a valid top-level window) for this method to be able to return a meaningful (non-null) value.</source>
          <target state="translated">Note: the JTextComponent must have a valid size (e.g. have been added to a parent container whose ancestor container is a valid top-level window) for this method to be able to return a meaningful (non-null) value.</target>
        </trans-unit>
        <trans-unit id="1f392a63ce8ca769190caf163bdd91184bd81b83" translate="yes" xml:space="preserve">
          <source>Note: the OAEPParameterSpec.DEFAULT uses the following:</source>
          <target state="translated">Note: the OAEPParameterSpec.DEFAULT uses the following:</target>
        </trans-unit>
        <trans-unit id="492c6d682f7eec9130f0855cc45fe510c22313ba" translate="yes" xml:space="preserve">
          <source>Note: the OAEPParameterSpec.DEFAULT uses the following: message digest -- &quot;SHA-1&quot; mask generation function (mgf) -- &quot;MGF1&quot; parameters for mgf -- MGF1ParameterSpec.SHA1 source of encoding input -- PSource.PSpecified.DEFAULT</source>
          <target state="translated">참고 : OAEPParameterSpec.DEFAULT는 다음을 사용합니다. 메시지 요약- &quot;SHA-1&quot;마스크 생성 함수 (mgf)-mgf의 &quot;MGF1&quot;매개 변수-MGF1ParameterSpec.SHA1 인코딩 입력 소스-PSource.PSpecified.DEFAULT</target>
        </trans-unit>
        <trans-unit id="b2ce9a87943a98d1b667c474c5c442d833fc1655" translate="yes" xml:space="preserve">
          <source>Note: the PSSParameterSpec.DEFAULT uses the following: message digest -- &quot;SHA-1&quot; mask generation function (mgf) -- &quot;MGF1&quot; parameters for mgf -- MGF1ParameterSpec.SHA1 SaltLength -- 20 TrailerField -- 1</source>
          <target state="translated">참고 : PSSParameterSpec.DEFAULT는 다음을 사용합니다. 메시지 요약- &quot;SHA-1&quot;마스크 생성 기능 (mgf)-mgf의 &quot;MGF1&quot;매개 변수-MGF1ParameterSpec.SHA1 SaltLength-20 TrailerField-1</target>
        </trans-unit>
        <trans-unit id="2d8b28baf51e748dc2d7af5797db037130390694" translate="yes" xml:space="preserve">
          <source>Note: the X509ExtendedKeyManager should be used in favor of this class.</source>
          <target state="translated">참고 :이 클래스를 위해 X509ExtendedKeyManager를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7325e6d320a9d911fcb0df72ba0a06d4d0671a0" translate="yes" xml:space="preserve">
          <source>Note: the local supported signature algorithms should conform to the algorithm constraints specified by &lt;a href=&quot;sslparameters#getAlgorithmConstraints()&quot;&gt;&lt;code&gt;getAlgorithmConstraints()&lt;/code&gt;&lt;/a&gt; method in &lt;code&gt;SSLParameters&lt;/code&gt;.</source>
          <target state="translated">Note: the local supported signature algorithms should conform to the algorithm constraints specified by &lt;a href=&quot;sslparameters#getAlgorithmConstraints()&quot;&gt; &lt;code&gt;getAlgorithmConstraints()&lt;/code&gt; &lt;/a&gt; method in &lt;code&gt;SSLParameters&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5510435a1a81e326f18dfb97c9eee1b6a3319a1" translate="yes" xml:space="preserve">
          <source>Note: the local supported signature algorithms should conform to the algorithm constraints specified by &lt;a href=&quot;sslparameters#getAlgorithmConstraints--&quot;&gt;&lt;code&gt;getAlgorithmConstraints()&lt;/code&gt;&lt;/a&gt; method in &lt;code&gt;SSLParameters&lt;/code&gt;.</source>
          <target state="translated">참고 : 로컬 지원 서명 알고리즘은 &lt;code&gt;SSLParameters&lt;/code&gt; 의&lt;a href=&quot;sslparameters#getAlgorithmConstraints--&quot;&gt; &lt;code&gt;getAlgorithmConstraints()&lt;/code&gt; &lt;/a&gt; 메소드로 지정된 알고리즘 제한 조건을 준수해야합니다 .</target>
        </trans-unit>
        <trans-unit id="41a3633c298cff106784ca675b5b46e661326da3" translate="yes" xml:space="preserve">
          <source>Note: the location and size of top-level windows (including &lt;code&gt;Window&lt;/code&gt;s, &lt;code&gt;Frame&lt;/code&gt;s, and &lt;code&gt;Dialog&lt;/code&gt;s) are under the control of the desktop's window management system. Calls to &lt;code&gt;setLocation&lt;/code&gt;, &lt;code&gt;setSize&lt;/code&gt;, and &lt;code&gt;setBounds&lt;/code&gt; are requests (not directives) which are forwarded to the window management system. Every effort will be made to honor such requests. However, in some cases the window management system may ignore such requests, or modify the requested geometry in order to place and size the &lt;code&gt;Window&lt;/code&gt; in a way that more closely matches the desktop settings.</source>
          <target state="translated">Note: the location and size of top-level windows (including &lt;code&gt;Window&lt;/code&gt; s, &lt;code&gt;Frame&lt;/code&gt; s, and &lt;code&gt;Dialog&lt;/code&gt; s) are under the control of the desktop's window management system. Calls to &lt;code&gt;setLocation&lt;/code&gt; , &lt;code&gt;setSize&lt;/code&gt; , and &lt;code&gt;setBounds&lt;/code&gt; are requests (not directives) which are forwarded to the window management system. Every effort will be made to honor such requests. However, in some cases the window management system may ignore such requests, or modify the requested geometry in order to place and size the &lt;code&gt;Window&lt;/code&gt; in a way that more closely matches the desktop settings.</target>
        </trans-unit>
        <trans-unit id="c67d873a58583850056bdd0c1c817640a6fc6e81" translate="yes" xml:space="preserve">
          <source>Note: the value of this field is prefixed with 'Swing' to avoid possible collisions with existing &lt;code&gt;Actions&lt;/code&gt;.</source>
          <target state="translated">Note: the value of this field is prefixed with 'Swing' to avoid possible collisions with existing &lt;code&gt;Actions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b5d13ed7a83329befedbde9d06258643c673381" translate="yes" xml:space="preserve">
          <source>Note: this constructor should only be used by AWT implementations as part of their support for custom cursors. Applications should use Toolkit.createCustomCursor().</source>
          <target state="translated">Note: this constructor should only be used by AWT implementations as part of their support for custom cursors. Applications should use Toolkit.createCustomCursor().</target>
        </trans-unit>
        <trans-unit id="28fdef5134bffa1cd75bacd02dbb9d809fb19a01" translate="yes" xml:space="preserve">
          <source>Note: this interface is required to permit the safe association of a DropTarget with a Component in one of two ways, either: &lt;code&gt;component.setDropTarget(droptarget);&lt;/code&gt; or &lt;code&gt;droptarget.setComponent(component);&lt;/code&gt;</source>
          <target state="translated">Note: this interface is required to permit the safe association of a DropTarget with a Component in one of two ways, either: &lt;code&gt;component.setDropTarget(droptarget);&lt;/code&gt; or &lt;code&gt;droptarget.setComponent(component);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02f494dd31cb8ad0cb9346d53aa1b53cc95d6141" translate="yes" xml:space="preserve">
          <source>Note: this is used to indicate the preference on key length for variable-key-size ciphers. The actual key size depends on each provider's implementation.</source>
          <target state="translated">참고 : 가변 키 크기 암호의 키 길이에 대한 기본 설정을 나타내는 데 사용됩니다. 실제 키 크기는 각 공급자의 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="918c568ceea4a8ffb21d10a648c7036d7c8da530" translate="yes" xml:space="preserve">
          <source>Note: this method currently performs a shallow copy of the object (simply calls &lt;code&gt;Object.clone()&lt;/code&gt;). This may be changed in a future revision to perform a deep copy if new parameters are added that should not be shared.</source>
          <target state="translated">참고 :이 메서드는 현재 개체의 단순 복사본을 수행합니다 (단순히 &lt;code&gt;Object.clone()&lt;/code&gt; ). 공유하지 않아야 할 새 매개 변수가 추가 된 경우 딥 카피를 수행하기 위해 향후 개정판에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d8a9a0b5b93dae27f5f652a83007a6b2e89daa5" translate="yes" xml:space="preserve">
          <source>Note: this method is executed in a background thread.</source>
          <target state="translated">Note: this method is executed in a background thread.</target>
        </trans-unit>
        <trans-unit id="fbff139858d8c3526b7324d91174db8507a07ba4" translate="yes" xml:space="preserve">
          <source>Note: this method is used to indicate to the local side which signature algorithms may be used for digital signatures in TLS 1.2. It is not meaningful for TLS versions prior to 1.2.</source>
          <target state="translated">참고 :이 방법은 TLS 1.2에서 디지털 서명에 사용할 서명 알고리즘을 로컬에 표시하는 데 사용됩니다. 1.2 이전의 TLS 버전에는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f5169cbd1f9ba0ec8524abb160abb0f38a96e90b" translate="yes" xml:space="preserve">
          <source>Note: this method is used to indicate to the local side which signature algorithms may be used for digital signatures in TLS/DTLS 1.2. It is not meaningful for TLS/DTLS versions prior to 1.2.</source>
          <target state="translated">Note: this method is used to indicate to the local side which signature algorithms may be used for digital signatures in TLS/DTLS 1.2. It is not meaningful for TLS/DTLS versions prior to 1.2.</target>
        </trans-unit>
        <trans-unit id="b08ad47a1ab3e6fc63e3c26fff3909e3eac34fb8" translate="yes" xml:space="preserve">
          <source>Note: this method is used to indicate to the peer which signature algorithms may be used for digital signatures in TLS 1.2. It is not meaningful for TLS versions prior to 1.2.</source>
          <target state="translated">참고 :이 방법은 TLS 1.2에서 디지털 서명에 사용할 수있는 서명 알고리즘을 피어에게 표시하는 데 사용됩니다. 1.2 이전의 TLS 버전에는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a17cea5e85f658d0657fd0051ca3130494d5cdbe" translate="yes" xml:space="preserve">
          <source>Note: this method is used to indicate to the peer which signature algorithms may be used for digital signatures in TLS/DTLS 1.2. It is not meaningful for TLS/DTLS versions prior to 1.2.</source>
          <target state="translated">Note: this method is used to indicate to the peer which signature algorithms may be used for digital signatures in TLS/DTLS 1.2. It is not meaningful for TLS/DTLS versions prior to 1.2.</target>
        </trans-unit>
        <trans-unit id="8dd36c038ea2dda3842c71babdcf4b3bb8420720" translate="yes" xml:space="preserve">
          <source>Note: this method returns a copy of the password. It is the caller's responsibility to zero out the password information after it is no longer needed.</source>
          <target state="translated">참고 :이 메소드는 비밀번호 사본을 리턴합니다. 더 이상 필요하지 않은 비밀번호 정보를 제로화하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="0b9dba489ed38fc4a7327905b4ad19a291ade04c" translate="yes" xml:space="preserve">
          <source>Note: this method should</source>
          <target state="translated">참고 :이 방법은</target>
        </trans-unit>
        <trans-unit id="0cfe9c139559b84a217a77a85af3cdffe08474ba" translate="yes" xml:space="preserve">
          <source>Note: this method should be copy-safe, which means the &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; buffers can reference the same block of memory and no unprocessed input data is overwritten when the result is copied into the output buffer.</source>
          <target state="translated">참고 :이 방법은 복사 안전해야합니다. 즉, &lt;code&gt;input&lt;/code&gt; 및 &lt;code&gt;output&lt;/code&gt; 버퍼가 동일한 메모리 블록을 참조 할 수 있으며 결과를 출력 버퍼에 복사 할 때 처리되지 않은 입력 데이터를 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f4c8629628bd84ad72106429b5a2cd1ed15ba33" translate="yes" xml:space="preserve">
          <source>Note: this method should be copy-safe, which means the &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; buffers can reference the same byte array and no unprocessed input data is overwritten when the result is copied into the output buffer.</source>
          <target state="translated">참고 :이 방법은 복사 안전해야합니다. 즉, &lt;code&gt;input&lt;/code&gt; 및 &lt;code&gt;output&lt;/code&gt; 버퍼가 동일한 바이트 배열을 참조 할 수 있으며 결과를 출력 버퍼에 복사 할 때 처리되지 않은 입력 데이터를 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97ef58a2f1d6e59b709e15310606bab2789a38da" translate="yes" xml:space="preserve">
          <source>Note: this method should return a copy of the password. It is the caller's responsibility to zero out the password information after it is no longer needed.</source>
          <target state="translated">참고 :이 방법은 비밀번호 사본을 반환해야합니다. 더 이상 필요하지 않은 비밀번호 정보를 제로화하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="4551232f2a171e3a0d31788752ebdc2ee26b0971" translate="yes" xml:space="preserve">
          <source>Note: this method should return a copy of the salt. It is the caller's responsibility to zero out the salt information after it is no longer needed.</source>
          <target state="translated">참고 :이 방법은 소금 사본을 반환해야합니다. 더 이상 필요하지 않은 염분 정보를 제로화하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="be197317472aebc075cccf57792852ff71c0d925" translate="yes" xml:space="preserve">
          <source>Note: use the &lt;a href=&quot;#invokeLater(java.lang.Runnable)&quot;&gt;&lt;code&gt;invokeLater(java.lang.Runnable)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#invokeAndWait(java.lang.Runnable)&quot;&gt;&lt;code&gt;invokeAndWait(java.lang.Runnable)&lt;/code&gt;&lt;/a&gt; methods to execute a task in &lt;a href=&quot;toolkit#getSystemEventQueue()&quot;&gt;&lt;code&gt;the current AWT EventQueue&lt;/code&gt;&lt;/a&gt;'s dispatch thread.</source>
          <target state="translated">Note: use the &lt;a href=&quot;#invokeLater(java.lang.Runnable)&quot;&gt; &lt;code&gt;invokeLater(java.lang.Runnable)&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;#invokeAndWait(java.lang.Runnable)&quot;&gt; &lt;code&gt;invokeAndWait(java.lang.Runnable)&lt;/code&gt; &lt;/a&gt; methods to execute a task in &lt;a href=&quot;toolkit#getSystemEventQueue()&quot;&gt; &lt;code&gt;the current AWT EventQueue&lt;/code&gt; &lt;/a&gt;'s dispatch thread.</target>
        </trans-unit>
        <trans-unit id="f0b92ce9d6be916045a08369abb63760c0b2e0e8" translate="yes" xml:space="preserve">
          <source>Note: when some action is invoked and the associated application is executed, it will be executed on the same system as the one on which the Java application was launched.</source>
          <target state="translated">Note: when some action is invoked and the associated application is executed, it will be executed on the same system as the one on which the Java application was launched.</target>
        </trans-unit>
        <trans-unit id="5d23ad42e7b1b94cdae4b3885610d8f7d25da71e" translate="yes" xml:space="preserve">
          <source>Note: you do not have to forward the event to sub-components. This is done automatically by the &lt;code&gt;MenuSelectionManager&lt;/code&gt;.</source>
          <target state="translated">Note: you do not have to forward the event to sub-components. This is done automatically by the &lt;code&gt;MenuSelectionManager&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="cab86ce653fd9d36eb02158c05614338a3ba6063" translate="yes" xml:space="preserve">
          <source>Notes on specific components</source>
          <target state="translated">Notes on specific components</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="4049468e6c6681b457b2a4eaf4db4bf2b0debae5" translate="yes" xml:space="preserve">
          <source>Nothing is done at the Relation Service level, i.e. the &lt;code&gt;RelationSupport&lt;/code&gt; object is not added to the &lt;code&gt;RelationService&lt;/code&gt; and no checks are performed to see if the provided values are correct. The object is always created, EXCEPT if:</source>
          <target state="translated">아무것도 즉, 관계 서비스 레벨에서 수행되지 않는 &lt;code&gt;RelationSupport&lt;/code&gt; 객체가 추가되지 않습니다 &lt;code&gt;RelationService&lt;/code&gt; 않고 검사가 제공된 값이 올바른지 있는지 확인하기 위해 수행되지 않습니다. 다음과 같은 경우에는 개체가 항상 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9b893c7a20a2c07eedb44134ccd2d552d0e50174" translate="yes" xml:space="preserve">
          <source>Nothing is written to the output</source>
          <target state="translated">Nothing is written to the output</target>
        </trans-unit>
        <trans-unit id="591911d96d6cbaf146e6d8b47666e6f26b0f155a" translate="yes" xml:space="preserve">
          <source>Nothing prevents the use of these fields in MBeans that are not Model MBeans. The &lt;a href=&quot;#displayName&quot;&gt;displayName&lt;/a&gt;, &lt;a href=&quot;#severity&quot;&gt;severity&lt;/a&gt;, and &lt;a href=&quot;#visibility&quot;&gt;visibility&lt;/a&gt; fields are of interest outside Model MBeans, for example. But only Model MBeans have a predefined behavior for these fields.</source>
          <target state="translated">Model MBean이 아닌 MBean에서이 필드를 사용하는 것을 막는 것은 없습니다. &lt;a href=&quot;#displayName&quot;&gt;나 displayName&lt;/a&gt; , &lt;a href=&quot;#severity&quot;&gt;심각도&lt;/a&gt; 및 &lt;a href=&quot;#visibility&quot;&gt;가시성&lt;/a&gt; 필드는 예를 들어, 모델의 MBean 외부의 관심이다. 그러나 Model MBean 만이 필드에 대해 사전 정의 된 동작을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="970af143a639a5c1f5ce065871e6baf24e38c36e" translate="yes" xml:space="preserve">
          <source>Nothing, but ends quoting started by &lt;code&gt;\Q&lt;/code&gt;</source>
          <target state="translated">아무것도 없지만 &lt;code&gt;\Q&lt;/code&gt; 인용 인용</target>
        </trans-unit>
        <trans-unit id="153bd5cc523c8d331c4f6365c680600b92fc6d03" translate="yes" xml:space="preserve">
          <source>Nothing, but quotes all characters until &lt;code&gt;\E&lt;/code&gt;</source>
          <target state="translated">아무것도 아니지만 &lt;code&gt;\E&lt;/code&gt; 까지 모든 문자를 인용</target>
        </trans-unit>
        <trans-unit id="e7cfd3c952e52da6c393469ae466f5d942220df2" translate="yes" xml:space="preserve">
          <source>Nothing, but quotes the following character</source>
          <target state="translated">아무것도 아니지만 다음 문자를 인용</target>
        </trans-unit>
        <trans-unit id="f89ebdddae5018434afcfef64baa8e70cb6efb64" translate="yes" xml:space="preserve">
          <source>Nothing, but turns match flags &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;i&lt;/a&gt;&lt;a href=&quot;#UNIX_LINES&quot;&gt;d&lt;/a&gt;&lt;a href=&quot;#MULTILINE&quot;&gt;m&lt;/a&gt;&lt;a href=&quot;#DOTALL&quot;&gt;s&lt;/a&gt;&lt;a href=&quot;#UNICODE_CASE&quot;&gt;u&lt;/a&gt;&lt;a href=&quot;#COMMENTS&quot;&gt;x&lt;/a&gt;&lt;a href=&quot;#UNICODE_CHARACTER_CLASS&quot;&gt;U&lt;/a&gt; on - off</source>
          <target state="translated">아무것도하지만, 회전이 플래그를 일치 &lt;a href=&quot;#CASE_INSENSITIVE&quot;&gt;내가 &lt;/a&gt;&lt;a href=&quot;#UNIX_LINES&quot;&gt;D &lt;/a&gt;&lt;a href=&quot;#MULTILINE&quot;&gt;m &lt;/a&gt;&lt;a href=&quot;#DOTALL&quot;&gt;s의 &lt;/a&gt;&lt;a href=&quot;#UNICODE_CASE&quot;&gt;u는 &lt;/a&gt;&lt;a href=&quot;#COMMENTS&quot;&gt;X &lt;/a&gt;&lt;a href=&quot;#UNICODE_CHARACTER_CLASS&quot;&gt;U를&lt;/a&gt; 에 - 오프</target>
        </trans-unit>
        <trans-unit id="ce1341fdc4c6c8f554a498bc9f036be29f8ffa4d" translate="yes" xml:space="preserve">
          <source>Notice that an application can supersede the registration of an earlier created font with a new one.</source>
          <target state="translated">Notice that an application can supersede the registration of an earlier created font with a new one.</target>
        </trans-unit>
        <trans-unit id="6e59ad8d4a856db627b0584733edb4bafea74dbf" translate="yes" xml:space="preserve">
          <source>Notice that only four kinds of attribute sets are listed here, but there are five kinds of attributes. Interface &lt;a href=&quot;supportedvaluesattribute&quot;&gt;SupportedValuesAttribute&lt;/a&gt; denotes an attribute that gives the supported values for another attribute. Supported-values attributes are never aggregated into attribute sets, so there is no attribute set subinterface defined for them.</source>
          <target state="translated">여기에는 4 가지 종류의 속성 세트 만 나열되어 있지만 5 가지 종류의 속성이 있습니다. &lt;a href=&quot;supportedvaluesattribute&quot;&gt;SupportedValuesAttribute&lt;/a&gt; 인터페이스 는 다른 속성에 지원되는 값을 제공하는 속성을 나타냅니다. 지원되는 값 속성은 속성 집합으로 집계되지 않으므로 속성 집합 하위 인터페이스가 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8f022b5a1b710bbe975a5c370ec133a15d6f10b" translate="yes" xml:space="preserve">
          <source>Notice that the first character (or code point) is converted to lower case. This follows the Java Beans convention, which for historical reasons is different from the Standard MBean convention. In a Standard MBean or MXBean interface, a method &lt;code&gt;getOwner&lt;/code&gt; defines an attribute called &lt;code&gt;Owner&lt;/code&gt;, while in a Java Bean or mapped &lt;code&gt;CompositeType&lt;/code&gt;, a method &lt;code&gt;
      getOwner&lt;/code&gt; defines a property or item called &lt;code&gt;owner&lt;/code&gt;.</source>
          <target state="translated">Notice that the first character (or code point) is converted to lower case. This follows the Java Beans convention, which for historical reasons is different from the Standard MBean convention. In a Standard MBean or MXBean interface, a method &lt;code&gt;getOwner&lt;/code&gt; defines an attribute called &lt;code&gt;Owner&lt;/code&gt; , while in a Java Bean or mapped &lt;code&gt;CompositeType&lt;/code&gt; , a method &lt;code&gt; getOwner&lt;/code&gt; defines a property or item called &lt;code&gt;owner&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="417940b08f0f0f774790ee4661177279a6e94316" translate="yes" xml:space="preserve">
          <source>Notice that the first character (or code point) is converted to lower case. This follows the Java Beans convention, which for historical reasons is different from the Standard MBean convention. In a Standard MBean or MXBean interface, a method &lt;code&gt;getOwner&lt;/code&gt; defines an attribute called &lt;code&gt;Owner&lt;/code&gt;, while in a Java Bean or mapped &lt;code&gt;CompositeType&lt;/code&gt;, a method &lt;code&gt;getOwner&lt;/code&gt; defines a property or item called &lt;code&gt;owner&lt;/code&gt;.</source>
          <target state="translated">첫 문자 (또는 코드 포인트)는 소문자로 변환됩니다. 이것은 역사적 이유로 표준 MBean 규칙과 다른 Java Beans 규칙을 따릅니다. 표준 MBean 또는 MXBean 인터페이스에서 &lt;code&gt;getOwner&lt;/code&gt; 메소드 는 &lt;code&gt;Owner&lt;/code&gt; 라는 속성을 정의 하지만 Java Bean 또는 맵핑 된 &lt;code&gt;CompositeType&lt;/code&gt; 에서는 &lt;code&gt;getOwner&lt;/code&gt; 메소드가 &lt;code&gt;owner&lt;/code&gt; 라는 특성 또는 항목을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="835f19c3b0ad65e9e0400e2bf5db621f6319e918" translate="yes" xml:space="preserve">
          <source>Notice that the order is important, as the subsequent item goes immediately after the text-argument. The following are not equivalent:</source>
          <target state="translated">후속 항목이 텍스트 인수 직후에 오기 때문에 순서가 중요합니다. 다음은 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c18f8f255ab9c208f23d0340eb9dff5a84efe311" translate="yes" xml:space="preserve">
          <source>Notification</source>
          <target state="translated">Notification</target>
        </trans-unit>
        <trans-unit id="939ed73960efba652806e6d5e4587c8e931369e8" translate="yes" xml:space="preserve">
          <source>Notification dispatch</source>
          <target state="translated">알림 발송</target>
        </trans-unit>
        <trans-unit id="a0582a95d51911509a77ba131393f5b5d51a1d31" translate="yes" xml:space="preserve">
          <source>Notification emitted when a client connection is opened or closed or when notifications are lost.</source>
          <target state="translated">클라이언트 연결을 열거 나 닫을 때 또는 알림이 유실 될 때 알림이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d8add2cfda10bdc1d97d2cc180d9eff9ad450493" translate="yes" xml:space="preserve">
          <source>Notification emitted when a client connection is opened or closed or when notifications are lost. These notifications are sent by connector servers (instances of &lt;a href=&quot;jmxconnectorserver&quot;&gt;&lt;code&gt;JMXConnectorServer&lt;/code&gt;&lt;/a&gt;) and by connector clients (instances of &lt;a href=&quot;jmxconnector&quot;&gt;&lt;code&gt;JMXConnector&lt;/code&gt;&lt;/a&gt;). For certain connectors, a session can consist of a sequence of connections. Connection-opened and connection-closed notifications will be sent for each one.</source>
          <target state="translated">클라이언트 연결을 열거 나 닫을 때 또는 알림이 유실 될 때 알림이 생성됩니다. 이러한 알림은 커넥터 서버 (인스턴스에서 보낸 &lt;a href=&quot;jmxconnectorserver&quot;&gt; &lt;code&gt;JMXConnectorServer&lt;/code&gt; 를&lt;/a&gt; ) 및 커넥터 클라이언트 (의 인스턴스가 &lt;a href=&quot;jmxconnector&quot;&gt; &lt;code&gt;JMXConnector&lt;/code&gt; 에&lt;/a&gt; ). 특정 커넥터의 경우 세션은 일련의 연결로 구성 될 수 있습니다. 연결 열기 및 연결 닫기 알림이 각 알림에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="372e0b46f21822b738d250fc0fc4972b96208cbf" translate="yes" xml:space="preserve">
          <source>Notification from the &lt;code&gt;UIFactory&lt;/code&gt; that the L&amp;amp;F has changed.</source>
          <target state="translated">Notification from the &lt;code&gt;UIFactory&lt;/code&gt; that the L&amp;amp;F has changed.</target>
        </trans-unit>
        <trans-unit id="802b0fb55cae7d438ff32da5956fecbb2b9dc7c3" translate="yes" xml:space="preserve">
          <source>Notification from the &lt;code&gt;UIFactory&lt;/code&gt; that the L&amp;amp;F has changed. Called to replace the UI with the latest version from the &lt;code&gt;UIFactory&lt;/code&gt;.</source>
          <target state="translated">Notification from the &lt;code&gt;UIFactory&lt;/code&gt; that the L&amp;amp;F has changed. Called to replace the UI with the latest version from the &lt;code&gt;UIFactory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ba46dbd2044a663917fd460cbfb13c6b6b32851" translate="yes" xml:space="preserve">
          <source>Notification from the &lt;code&gt;UIManager&lt;/code&gt; that the L&amp;amp;F has changed.</source>
          <target state="translated">Notification from the &lt;code&gt;UIManager&lt;/code&gt; that the L&amp;amp;F has changed.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
