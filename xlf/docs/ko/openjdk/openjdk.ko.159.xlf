<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="openjdk">
    <body>
      <group id="openjdk">
        <trans-unit id="60f37692d373183aabc13cdc8073b22c431d845f" translate="yes" xml:space="preserve">
          <source>The RMI connector supports the JRMP transport for RMI, and optionally the IIOP transport.</source>
          <target state="translated">RMI 커넥터는 RMI 용 JRMP 전송 및 선택적으로 IIOP 전송을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="570c495a46ceab7cbdd8bad4657ef4c433b7368b" translate="yes" xml:space="preserve">
          <source>The RMI connector supports the JRMP transport for RMI.</source>
          <target state="translated">RMI 커넥터는 RMI 용 JRMP 전송을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="41b3ef650c3626ba1e54f00218353c90a916a9f7" translate="yes" xml:space="preserve">
          <source>The RUN_DIRECTION attribute in the text, if present, determines the base direction (left-to-right or right-to-left). If not present, the base direction is computes using the Unicode Bidirectional Algorithm, defaulting to left-to-right if there are no strong directional characters in the text. This attribute, if present, must be applied to all the text in the paragraph.</source>
          <target state="translated">텍스트의 RUN_DIRECTION 속성이 있으면 기본 방향 (왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽)을 결정합니다. 존재하지 않는 경우, 기본 방향은 유니 코드 양방향 알고리즘을 사용하여 계산되며 텍스트에 강한 방향 문자가없는 경우 기본적으로 왼쪽에서 오른쪽으로 설정됩니다. 이 속성이 있으면 단락의 모든 텍스트에 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f60c0ed8c51e78726f1dd29af9cd9a1b5c043ca4" translate="yes" xml:space="preserve">
          <source>The Rdn class represents an RDN as attribute type/value mappings, which can be viewed using &lt;a href=&quot;../directory/attributes&quot;&gt;&lt;code&gt;Attributes&lt;/code&gt;&lt;/a&gt;. In addition, it contains convenience methods that allow easy retrieval of type and value when the Rdn consist of a single type/value pair, which is how it appears in a typical usage. It also contains helper methods that allow escaping of the unformatted attribute value and unescaping of the value formatted according to the escaping syntax defined in RFC2253. For methods that take or return attribute value as an Object, the value is either a String (in unescaped form) or a byte array.</source>
          <target state="translated">RDN이 클래스를 사용하여 볼 수있는 속성 타입 / 값 매핑 같은 RDN 나타내는 &lt;a href=&quot;../directory/attributes&quot;&gt; &lt;code&gt;Attributes&lt;/code&gt; &lt;/a&gt; . 또한 Rdn이 단일 유형 / 값 쌍으로 구성 될 때 유형과 값을 쉽게 검색 할 수있는 편리한 방법이 포함되어 있으며 이는 일반적인 사용법에서 나타나는 방식입니다. 또한 형식화되지 않은 속성 값을 이스케이프하고 RFC2253에 정의 된 이스케이프 구문에 따라 형식이 지정된 값을 이스케이프 해제 할 수있는 헬퍼 메소드도 포함되어 있습니다. 속성 값을 Object로 가져 오거나 리턴하는 메소드의 경우 값은 문자열 (이스케이프되지 않은 형식) 또는 바이트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a849576e7ae20b99a97e2290e52281e573c37c08" translate="yes" xml:space="preserve">
          <source>The Reader/Writer Facility</source>
          <target state="translated">리더 / 라이터 시설</target>
        </trans-unit>
        <trans-unit id="f67aafa071c625422dd5982cd650b730e8294670" translate="yes" xml:space="preserve">
          <source>The Rect value.</source>
          <target state="translated">Rect 값입니다.</target>
        </trans-unit>
        <trans-unit id="8b6069851d3227d9bd020f5065d9d5fd26f5eea7" translate="yes" xml:space="preserve">
          <source>The ReferenceType of obj will mirror java.lang.String and not java.lang.Object.</source>
          <target state="translated">obj의 ReferenceType은 java.lang.Object가 아니라 java.lang.String을 미러링합니다.</target>
        </trans-unit>
        <trans-unit id="ef154a572a8dd8cfa5c8cd77b99196da2d668b74" translate="yes" xml:space="preserve">
          <source>The Relation Service is in charge of creating and deleting relation types and relations, of handling the consistency and of providing query mechanisms.</source>
          <target state="translated">관계 서비스는 관계 유형 및 관계 작성 및 삭제, 일관성 처리 및 쿼리 메커니즘 제공을 담당합니다.</target>
        </trans-unit>
        <trans-unit id="9b94248d10d22c5d522221db774ab1a81ba0ecb4" translate="yes" xml:space="preserve">
          <source>The Relation Service keeps track of the changes to keep the consistency of relations by handling referenced MBean deregistrations.</source>
          <target state="translated">관계 서비스는 참조 된 MBean 등록 취소를 처리하여 관계의 일관성을 유지하기 위해 변경 사항을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="c58fe2a5c62a124e8b18b80e2e230da01543a005" translate="yes" xml:space="preserve">
          <source>The Relation Service will call this method to let the relation take action to reflect the impact of such unregistration.</source>
          <target state="translated">관계 서비스는 등록 취소의 영향을 반영하기 위해 조치를 취할 수 있도록이 방법을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="674d8706acecd74bfff3ea199d92ca522dde4abd" translate="yes" xml:space="preserve">
          <source>The Relation Service will keep track of the change to keep the consistency of relations by handling referenced MBean deregistrations.</source>
          <target state="translated">관계 서비스는 참조 된 MBean 등록 취소를 처리하여 관계의 일관성을 유지하기 위해 변경 사항을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="7430d227a34803554e11c267caf31a7db4f67140" translate="yes" xml:space="preserve">
          <source>The RelationType interface has to be implemented by any class expected to represent a relation type.</source>
          <target state="translated">RelationType 인터페이스는 관계 유형을 나타내는 모든 클래스에서 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9fb237f760545b443ba0679158f9d8fc3816d76" translate="yes" xml:space="preserve">
          <source>The RenderedImageFactory interface (often abbreviated RIF) is intended to be implemented by classes that wish to act as factories to produce different renderings, for example by executing a series of BufferedImageOps on a set of sources, depending on a specific set of parameters, properties, and rendering hints.</source>
          <target state="translated">RenderedImageFactory 인터페이스 (종종 약어 RIF)는 다른 렌더링을 생성하는 팩토리 역할을하려는 클래스에 의해 구현되도록되어 있습니다. 및 렌더링 힌트.</target>
        </trans-unit>
        <trans-unit id="a337fa27f6d6da6026749563f7a0cc62c8e19a0f" translate="yes" xml:space="preserve">
          <source>The Rendering Process can be broken down into four phases that are controlled by the &lt;code&gt;Graphics2D&lt;/code&gt; rendering attributes. The renderer can optimize many of these steps, either by caching the results for future calls, by collapsing multiple virtual steps into a single operation, or by recognizing various attributes as common simple cases that can be eliminated by modifying other parts of the operation.</source>
          <target state="translated">렌더링 프로세스는 &lt;code&gt;Graphics2D&lt;/code&gt; 렌더링 속성에 의해 제어되는 4 단계로 나눌 수 있습니다 . 렌더러는 향후 호출에 대한 결과를 캐싱하거나 여러 가상 단계를 단일 작업으로 축소하거나 다양한 속성을 작업의 다른 부분을 수정하여 제거 할 수있는 일반적인 단순 사례로 인식하여 이러한 단계의 대부분을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddbb219fcd07b33ac1516eb03081d9b6c2932596" translate="yes" xml:space="preserve">
          <source>The RequiredModelMBean's MBeanInfo and Descriptors can be customized using the &lt;a href=&quot;#setModelMBeanInfo(javax.management.modelmbean.ModelMBeanInfo)&quot;&gt;&lt;code&gt;setModelMBeanInfo(javax.management.modelmbean.ModelMBeanInfo)&lt;/code&gt;&lt;/a&gt; method. After the RequiredModelMBean's MBeanInfo and Descriptors are customized, the RequiredModelMBean can be registered with the MBeanServer.</source>
          <target state="translated">RequiredModelMBean의 MBeanInfo 및 설명자는 &lt;a href=&quot;#setModelMBeanInfo(javax.management.modelmbean.ModelMBeanInfo)&quot;&gt; &lt;code&gt;setModelMBeanInfo(javax.management.modelmbean.ModelMBeanInfo)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 사용자 정의 할 수 있습니다 . RequiredModelMBean의 MBeanInfo 및 Descriptor가 사용자 정의 된 후 RequiredModelMBean을 MBeanServer에 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="223356c4d1a561d92448c2d007a52122fdfdc7b7" translate="yes" xml:space="preserve">
          <source>The RequiredModelMBean's MBeanInfo and Descriptors can be customized using the &lt;a href=&quot;requiredmodelmbean#setModelMBeanInfo-javax.management.modelmbean.ModelMBeanInfo-&quot;&gt;&lt;code&gt;setModelMBeanInfo(javax.management.modelmbean.ModelMBeanInfo)&lt;/code&gt;&lt;/a&gt; method. After the RequiredModelMBean's MBeanInfo and Descriptors are customized, the RequiredModelMBean can be registered with the MBeanServer.</source>
          <target state="translated">&lt;a href=&quot;requiredmodelmbean#setModelMBeanInfo-javax.management.modelmbean.ModelMBeanInfo-&quot;&gt; &lt;code&gt;setModelMBeanInfo(javax.management.modelmbean.ModelMBeanInfo)&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 RequiredModelMBean의 MBeanInfo 및 설명자를 사용자 정의 할 수 있습니다 . RequiredModelMBean의 MBeanInfo 및 Descriptor가 사용자 정의 된 후, RequiredModelMBean을 MBeanServer에 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0e463000d15f695be884764e6e32e805dc3c334" translate="yes" xml:space="preserve">
          <source>The Resolver interface contains methods that are implemented by contexts that do not support subtypes of Context, but which can act as intermediate contexts for resolution purposes.</source>
          <target state="translated">Resolver 인터페이스에는 컨텍스트의 하위 유형을 지원하지 않지만 해결 목적으로 중간 컨텍스트로 작동 할 수있는 컨텍스트로 구현되는 메소드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="99887f811b190671c4ccc42930750f2de5fbdd99" translate="yes" xml:space="preserve">
          <source>The Resource annotation marks a resource that is needed by the application.</source>
          <target state="translated">자원 어노테이션은 응용 프로그램에 필요한 자원을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="30acb209089a83083042aff0a92fb6de49bfdcc2" translate="yes" xml:space="preserve">
          <source>The Resource annotation marks a resource that is needed by the application. This annotation may be applied to an application component class, or to fields or methods of the component class. When the annotation is applied to a field or method, the container will inject an instance of the requested resource into the application component when the component is initialized. If the annotation is applied to the component class, the annotation declares a resource that the application will look up at runtime.</source>
          <target state="translated">자원 어노테이션은 응용 프로그램에 필요한 자원을 표시합니다. 이 주석은 응용 프로그램 구성 요소 클래스 또는 구성 요소 클래스의 필드 또는 메서드에 적용될 수 있습니다. 주석이 필드 또는 메소드에 적용되면 컨테이너는 컴포넌트가 초기화 될 때 요청 된 자원의 인스턴스를 애플리케이션 컴포넌트에 삽입합니다. 주석이 구성 요소 클래스에 적용되면 주석은 응용 프로그램이 런타임시 조회 할 리소스를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="f23f9e9a62bb221b645f78eb5486063e2b452cdf" translate="yes" xml:space="preserve">
          <source>The ResourceBundle is not transmitted as part of the serialized form, but the resource bundle name is, and the recipient object's readObject method will attempt to locate a suitable resource bundle.</source>
          <target state="translated">ResourceBundle은 직렬화 된 형식의 일부로 전송되지 않지만 자원 번들 이름은 수신자 오브젝트의 readObject 메소드가 적합한 자원 번들을 찾으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="d6ee805b8aa7ef74a04fa65888bac1d8f985f41c" translate="yes" xml:space="preserve">
          <source>The ResponseAPDU returned by this method is the result after this processing has been performed.</source>
          <target state="translated">이 메서드에서 반환 된 ResponseAPDU는이 처리가 수행 된 후의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="614f4429ada7f2ea49d4dd70089a45d01bafee6b" translate="yes" xml:space="preserve">
          <source>The ResponseCache implementation decides which resources should be cached, and for how long they should be cached. If a request resource cannot be retrieved from the cache, then the protocol handlers will fetch the resource from its original location. The settings for URLConnection#useCaches controls whether the protocol is allowed to use a cached response. For more information on HTTP caching, see &lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;&lt;i&gt;RFC 2616: Hypertext Transfer Protocol -- HTTP/1.1&lt;/i&gt;&lt;/a&gt;</source>
          <target state="translated">ResponseCache 구현은 캐시해야 할 리소스와 캐시 기간을 결정합니다. 요청 리소스를 캐시에서 검색 할 수없는 경우 프로토콜 핸들러는 원래 위치에서 리소스를 가져옵니다. URLConnection # useCaches 설정은 프로토콜이 캐시 된 응답을 사용할 수 있는지 여부를 제어합니다. HTTP 캐싱에 대한 자세한 내용은 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot;&gt;&lt;i&gt;RFC 2616 : 하이퍼 텍스트 전송 프로토콜-HTTP / 1.1을&lt;/i&gt;&lt;/a&gt; 참조하십시오 &lt;i&gt;.&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="935a42c427fe51122b894d702d13464aad00d0f1" translate="yes" xml:space="preserve">
          <source>The ResponseCache implementation decides which resources should be cached, and for how long they should be cached. If a request resource cannot be retrieved from the cache, then the protocol handlers will fetch the resource from its original location. The settings for URLConnection#useCaches controls whether the protocol is allowed to use a cached response. For more information on HTTP caching, see &lt;a href=&quot;https://www.ietf.org/rfc/rfc2616.txt&quot;&gt;&lt;i&gt;RFC 2616: Hypertext Transfer Protocol -- HTTP/1.1&lt;/i&gt;&lt;/a&gt;</source>
          <target state="translated">ResponseCache 구현은 캐시 할 리소스와 캐시 할 기간을 결정합니다. 요청 리소스를 캐시에서 검색 할 수없는 경우 프로토콜 처리기는 원래 위치에서 리소스를 가져옵니다. URLConnection # useCaches 설정은 프로토콜이 캐시 된 응답을 사용할 수 있는지 여부를 제어합니다. HTTP 캐싱에 대한 자세한 내용은 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2616.txt&quot;&gt;&lt;i&gt;RFC 2616 : Hypertext Transfer Protocol-HTTP / 1.1을&lt;/i&gt;&lt;/a&gt; 참조하십시오 &lt;i&gt;.&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="f0b5078ba2dde6d8ec482aabb1ace67355919a20" translate="yes" xml:space="preserve">
          <source>The Right Arrow key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 작업 키인 오른쪽 화살표 키입니다.</target>
        </trans-unit>
        <trans-unit id="9fbe965bb87ba8783bba46c5f0fe3df1fcfff68a" translate="yes" xml:space="preserve">
          <source>The Runnable whose run() method will be called.</source>
          <target state="translated">run () 메서드가 호출 될 Runnable입니다.</target>
        </trans-unit>
        <trans-unit id="2586f0407a1e198d96fea8891fb951edd91991b7" translate="yes" xml:space="preserve">
          <source>The SAX API, originally developed at &lt;a href=&quot;http://www.saxproject.org&quot;&gt;the SAX Project&lt;/a&gt;, has been defined by Java SE since 1.4.</source>
          <target state="translated">원래 &lt;a href=&quot;http://www.saxproject.org&quot;&gt;SAX Project&lt;/a&gt; 에서 개발 된 SAX API 는 1.4 이후 Java SE에 의해 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="3a16b84e1bc358f31d40ba5a4b337df55f87d7be" translate="yes" xml:space="preserve">
          <source>The SAX parser may provide attributes in any arbitrary order, regardless of the order in which they were declared or specified. The number of attributes may be zero.</source>
          <target state="translated">SAX 파서는 속성이 선언되거나 지정된 순서에 관계없이 임의의 순서로 속성을 제공 할 수 있습니다. 속성 수는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e63fa2b756d87b3586bfd310da39dbd9f7945e7b" translate="yes" xml:space="preserve">
          <source>The SAX parser may report these events in any order, regardless of the order in which the notations and unparsed entities were declared; however, all DTD events must be reported after the document handler's startDocument event, and before the first startElement event. (If the &lt;a href=&quot;ext/lexicalhandler&quot;&gt;&lt;code&gt;LexicalHandler&lt;/code&gt;&lt;/a&gt; is used, these events must also be reported before the endDTD event.)</source>
          <target state="translated">SAX 구문 분석기는 표기법 및 구문 분석되지 않은 엔티티가 선언 된 순서에 관계없이 이러한 이벤트를 임의의 순서로보고 할 수 있습니다. 그러나 모든 DTD 이벤트는 문서 처리기의 startDocument 이벤트 이후와 첫 번째 startElement 이벤트 이전에보고되어야합니다. ( &lt;a href=&quot;ext/lexicalhandler&quot;&gt; &lt;code&gt;LexicalHandler&lt;/code&gt; &lt;/a&gt; 를 사용하는 경우 이러한 이벤트는 endDTD 이벤트 전에보고되어야합니다.)</target>
        </trans-unit>
        <trans-unit id="368395370323e5ccebf814c99f7fd9cf3e529bd5" translate="yes" xml:space="preserve">
          <source>The SAX parser must continue to provide normal parsing events after invoking this method: it should still be possible for the application to process the document through to the end.</source>
          <target state="translated">SAX 구문 분석기는이 메소드를 호출 한 후에도 계속해서 정상적인 구문 분석 이벤트를 제공해야합니다. 애플리케이션이 문서를 끝까지 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="da62af055484bbb2f62cfb79051f7678dab35fc7" translate="yes" xml:space="preserve">
          <source>The SAX parser must continue to provide normal parsing events after invoking this method: it should still be possible for the application to process the document through to the end. If the application cannot do so, then the parser should report a fatal error even if the XML recommendation does not require it to do so.</source>
          <target state="translated">SAX 구문 분석기는이 메소드를 호출 한 후에도 계속해서 정상적인 구문 분석 이벤트를 제공해야합니다. 애플리케이션이 문서를 끝까지 처리 할 수 ​​있어야합니다. 애플리케이션이이를 수행 할 수없는 경우 XML 권장 사항에서이를 요구하지 않더라도 구문 분석기는 치명적인 오류를보고해야합니다.</target>
        </trans-unit>
        <trans-unit id="814687b8ba81764a2d75e29f4e4ae3fda2735a98" translate="yes" xml:space="preserve">
          <source>The SAX parser that is encapsulated by the implementation of this class.</source>
          <target state="translated">이 클래스의 구현에 의해 캡슐화 된 SAX 구문 분석기입니다.</target>
        </trans-unit>
        <trans-unit id="8e45a78d79d0524145dc4edd32e06f22f85cede3" translate="yes" xml:space="preserve">
          <source>The SAX parser will ignore this if there is also a character stream specified, but it will use a byte stream in preference to opening a URI connection itself.</source>
          <target state="translated">문자 스트림도 지정된 경우 SAX 구문 분석기는이를 무시하지만 URI 연결 자체를 여는 것보다 바이트 스트림을 우선적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fa6e839e3e27650319aa05a16679d3576c718618" translate="yes" xml:space="preserve">
          <source>The SAX parser will invoke this method at the end of every element in the XML document; there will be a corresponding &lt;a href=&quot;#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)&quot;&gt;&lt;code&gt;startElement&lt;/code&gt;&lt;/a&gt; event for every endElement event (even when the element is empty).</source>
          <target state="translated">SAX 구문 분석기는 XML 문서의 모든 요소 끝에이 메소드를 호출합니다. 모든 endElement 이벤트에 해당하는 &lt;a href=&quot;#startElement(java.lang.String,java.lang.String,java.lang.String,org.xml.sax.Attributes)&quot;&gt; &lt;code&gt;startElement&lt;/code&gt; &lt;/a&gt; 이벤트 가 있습니다 (요소가 비어있는 경우에도).</target>
        </trans-unit>
        <trans-unit id="55c1ad9ba79369db1d5d99451a5a6808b96d398b" translate="yes" xml:space="preserve">
          <source>The SAX parser will invoke this method at the end of every element in the XML document; there will be a corresponding startElement() event for every endElement() event (even when the element is empty).</source>
          <target state="translated">SAX 구문 분석기는 XML 문서의 모든 요소 끝에이 메소드를 호출합니다. 모든 endElement () 이벤트에 해당하는 startElement () 이벤트가 있습니다 (요소가 비어있는 경우에도).</target>
        </trans-unit>
        <trans-unit id="707dc789f59e976c73fe4ffebb33bc0207ccae0c" translate="yes" xml:space="preserve">
          <source>The SAX parser will invoke this method only once, and it will be the last method invoked during the parse. The parser shall not invoke this method until it has either abandoned parsing (because of an unrecoverable error) or reached the end of input.</source>
          <target state="translated">SAX 구문 분석기는이 메소드를 한 번만 호출하며 구문 분석 중에 마지막으로 호출 된 메소드가됩니다. 구문 분석기는 구문 분석을 포기했거나 (복구 할 수없는 오류로 인해) 입력 끝에 도달 할 때까지이 메소드를 호출하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="2b43a9231f333a7eb2c324e9cf076db0efd49487" translate="yes" xml:space="preserve">
          <source>The SAX parser will invoke this method only once, before any other event callbacks (except for &lt;a href=&quot;#setDocumentLocator(org.xml.sax.Locator)&quot;&gt;&lt;code&gt;setDocumentLocator&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">SAX 파서는 다른 이벤트 콜백 ( &lt;a href=&quot;#setDocumentLocator(org.xml.sax.Locator)&quot;&gt; &lt;code&gt;setDocumentLocator&lt;/code&gt; &lt;/a&gt; 제외) 전에이 메서드를 한 번만 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="91ce2c6c168a5e69dd6cb165d398da053396b376" translate="yes" xml:space="preserve">
          <source>The SAX parser will invoke this method only once, before any other methods in this interface or in DTDHandler (except for setDocumentLocator).</source>
          <target state="translated">SAX 구문 분석기는이 인터페이스 또는 DTDHandler (setDocumentLocator 제외)의 다른 메소드보다 먼저이 메소드를 한 번만 호출합니다.</target>
        </trans-unit>
        <trans-unit id="92f190c7672eba65413ab1a87999fff01c6aa425" translate="yes" xml:space="preserve">
          <source>The SAX parser will use the InputSource object to determine how to read XML input. If there is a character stream available, the parser will read that stream directly, disregarding any text encoding declaration found in that stream. If there is no character stream, but there is a byte stream, the parser will use that byte stream, using the encoding specified in the InputSource or else (if no encoding is specified) autodetecting the character encoding using an algorithm such as the one in the XML specification. If neither a character stream nor a byte stream is available, the parser will attempt to open a URI connection to the resource identified by the system identifier.</source>
          <target state="translated">SAX 파서는 InputSource 객체를 사용하여 XML 입력을 읽는 방법을 결정합니다. 사용 가능한 문자 스트림이있는 경우 구문 분석기는 해당 스트림에서 발견 된 모든 텍스트 인코딩 선언을 무시하고 해당 스트림을 직접 읽습니다. 문자 스트림이 없지만 바이트 스트림이있는 경우 파서는 InputSource에 지정된 인코딩을 사용하거나 인코딩이 지정되지 않은 경우 다음과 같은 알고리즘을 사용하여 문자 인코딩을 자동 감지하여 해당 바이트 스트림을 사용합니다. XML 사양. 문자 스트림과 바이트 스트림을 모두 사용할 수없는 경우 파서는 시스템 식별자로 식별되는 리소스에 대한 URI 연결을 열려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="b2a2d489fcc5f68dcf345133a52e2a505c4fed93" translate="yes" xml:space="preserve">
          <source>The SCTP channel for the new association, or &lt;code&gt;null&lt;/code&gt; if this channel is in non-blocking mode and no association is available to be accepted</source>
          <target state="translated">새 연결에 대한 SCTP 채널 또는 이 채널이 비 차단 모드이고 허용 할 연결이없는 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66ec555eb24ca6d8f2ecdf7d959ed82b6d6debca" translate="yes" xml:space="preserve">
          <source>The SCTP channels defined in this package allow a notification handler to be specified to consume notifications from the SCTP stack. When a notification is received the &lt;a href=&quot;#handleNotification(com.sun.nio.sctp.Notification,T)&quot;&gt;handleNotification&lt;/a&gt; method of the handler is invoked to handle that notification.</source>
          <target state="translated">이 패키지에 정의 된 SCTP 채널을 사용하면 SCTP 스택에서 알림을 사용하도록 알림 처리기를 지정할 수 있습니다. 알림이 수신되면 핸들러 의 &lt;a href=&quot;#handleNotification(com.sun.nio.sctp.Notification,T)&quot;&gt;handleNotification&lt;/a&gt; 메소드가 호출되어 해당 알림을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8b6863ecbbbbc5c0b151ecc507b9e96ec1ba0ab1" translate="yes" xml:space="preserve">
          <source>The SCTP protocol is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc4960&quot;&gt;RFC4960&lt;/a&gt;, and the optional extension for</source>
          <target state="translated">SCTP 프로토콜은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4960&quot;&gt;RFC4960&lt;/a&gt; 에 의해 정의되며</target>
        </trans-unit>
        <trans-unit id="8be8119ae420632d994ffa43dca6763be5bf54df" translate="yes" xml:space="preserve">
          <source>The SMPTE-based timing type with 24 frames per second (resolution is expressed in ticks per frame).</source>
          <target state="translated">초당 24 프레임의 SMPTE 기반 타이밍 유형 (해상도는 프레임 당 틱으로 표시됨).</target>
        </trans-unit>
        <trans-unit id="a87aead941ca1f4be07e3fb05a0f9f240ce25f4b" translate="yes" xml:space="preserve">
          <source>The SMPTE-based timing type with 25 frames per second (resolution is expressed in ticks per frame).</source>
          <target state="translated">초당 25 프레임의 SMPTE 기반 타이밍 유형입니다 (해상도는 프레임 당 틱 단위로 표시됨).</target>
        </trans-unit>
        <trans-unit id="66c45c4346ca292d94c0c47d075fff0695e0d64c" translate="yes" xml:space="preserve">
          <source>The SMPTE-based timing type with 29.97 frames per second (resolution is expressed in ticks per frame).</source>
          <target state="translated">초당 29.97 프레임의 SMPTE 기반 타이밍 유형 (해상도는 프레임 당 틱으로 표시됨).</target>
        </trans-unit>
        <trans-unit id="711626f5460469b9d83bfa23335e9135ed9a25b4" translate="yes" xml:space="preserve">
          <source>The SMPTE-based timing type with 30 frames per second (resolution is expressed in ticks per frame).</source>
          <target state="translated">초당 30 프레임의 SMPTE 기반 타이밍 유형 (해상도는 프레임 당 틱 단위로 표시됨).</target>
        </trans-unit>
        <trans-unit id="2df02aa64906f5064858d7196a521480f396ca2b" translate="yes" xml:space="preserve">
          <source>The SNI extension is a feature that extends the SSL/TLS protocols to indicate what server name the client is attempting to connect to during handshaking. See section 3, &quot;Server Name Indication&quot;, of &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS Extensions (RFC 6066)&lt;/a&gt;.</source>
          <target state="translated">SNI 확장은 SSL / TLS 프로토콜을 확장하여 핸드 셰이 킹 중에 클라이언트가 연결하려는 서버 이름을 표시하는 기능입니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS 확장 (RFC 6066)의&lt;/a&gt; 3 절, &quot;서버 이름 표시&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c1bfb8757c18c2008df29d76508abfc11b3b83e" translate="yes" xml:space="preserve">
          <source>The SNI extension is a feature that extends the SSL/TLS protocols to indicate what server name the client is attempting to connect to during handshaking. See section 3, &quot;Server Name Indication&quot;, of &lt;a href=&quot;https://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS Extensions (RFC 6066)&lt;/a&gt;.</source>
          <target state="translated">SNI 확장은 SSL / TLS 프로토콜을 확장하여 클라이언트가 핸드 셰이 킹 중에 연결을 시도하는 서버 이름을 나타내는 기능입니다. &lt;a href=&quot;https://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS 확장 (RFC 6066)의&lt;/a&gt; 섹션 3, &quot;서버 이름 표시&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68467bc4ba49ffa6a43f30ebf1a538f8cdd977f6" translate="yes" xml:space="preserve">
          <source>The SNI extension is a feature that extends the SSL/TLS/DTLS protocols to indicate what server name the client is attempting to connect to during handshaking. See section 3, &quot;Server Name Indication&quot;, of &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS Extensions (RFC 6066)&lt;/a&gt;.</source>
          <target state="translated">SNI 확장은 SSL / TLS / DTLS 프로토콜을 확장하여 클라이언트가 핸드 셰이 킹 중에 연결을 시도하는 서버 이름을 나타내는 기능입니다. &lt;a href=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS 확장 (RFC 6066)의&lt;/a&gt; 섹션 3, &quot;서버 이름 표시&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94f5a32e5721a25357fae79f78bb07c66798a2c8" translate="yes" xml:space="preserve">
          <source>The SNI extension is a feature that extends the SSL/TLS/DTLS protocols to indicate what server name the client is attempting to connect to during handshaking. See section 3, &quot;Server Name Indication&quot;, of &lt;a href=&quot;https://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS Extensions (RFC 6066)&lt;/a&gt;.</source>
          <target state="translated">SNI 확장은 SSL / TLS / DTLS 프로토콜을 확장하여 클라이언트가 핸드 셰이 킹 중에 연결을 시도하는 서버 이름을 나타내는 기능입니다. &lt;a href=&quot;https://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS 확장 (RFC 6066)의&lt;/a&gt; 섹션 3, &quot;서버 이름 표시&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a239b45b59c1640fe8670eb7a46577feb10b2c67" translate="yes" xml:space="preserve">
          <source>The SPI methods fall into three groups concerning exception behavior. The &lt;code&gt;getSpi&lt;/code&gt; method should never throw exceptions, but it doesn't really matter, as any exception thrown by this method will be intercepted by &lt;a href=&quot;#get(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;get(String,String)&lt;/code&gt;&lt;/a&gt;, which will return the specified default value to the caller. The &lt;code&gt;removeNodeSpi, keysSpi,
 childrenNamesSpi, syncSpi&lt;/code&gt; and &lt;code&gt;flushSpi&lt;/code&gt; methods are specified to throw &lt;a href=&quot;backingstoreexception&quot;&gt;&lt;code&gt;BackingStoreException&lt;/code&gt;&lt;/a&gt;, and the implementation is required to throw this checked exception if it is unable to perform the operation. The exception propagates outward, causing the corresponding API method to fail.</source>
          <target state="translated">SPI 메서드는 예외 동작과 관련하여 세 그룹으로 나뉩니다. &lt;code&gt;getSpi&lt;/code&gt; 의 방법은 예외가 발생해서는 안하지만,이 방법에 의해 throw 예외가에 의해 차단 될 것이다 그것은 정말 중요하지 않습니다 &lt;a href=&quot;#get(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;get(String,String)&lt;/code&gt; &lt;/a&gt; 호출에 지정된 기본값을 반환하는. &lt;code&gt;removeNodeSpi, keysSpi, childrenNamesSpi, syncSpi&lt;/code&gt; 및 &lt;code&gt;flushSpi&lt;/code&gt; 방법 던져 지정된 &lt;a href=&quot;backingstoreexception&quot;&gt; &lt;code&gt;BackingStoreException&lt;/code&gt; &lt;/a&gt; 하고 구현이 동작을 수행 할 수없는 경우,이 체크 예외를 발생해야한다. 예외가 외부로 전파되어 해당 API 메서드가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e72c29b257096b441d7a94ae631930942e7eed15" translate="yes" xml:space="preserve">
          <source>The SPI methods fall into three groups concerning exception behavior. The &lt;code&gt;getSpi&lt;/code&gt; method should never throw exceptions, but it doesn't really matter, as any exception thrown by this method will be intercepted by &lt;a href=&quot;abstractpreferences#get-java.lang.String-java.lang.String-&quot;&gt;&lt;code&gt;get(String,String)&lt;/code&gt;&lt;/a&gt;, which will return the specified default value to the caller. The &lt;code&gt;removeNodeSpi, keysSpi, childrenNamesSpi, syncSpi&lt;/code&gt; and &lt;code&gt;flushSpi&lt;/code&gt; methods are specified to throw &lt;a href=&quot;backingstoreexception&quot;&gt;&lt;code&gt;BackingStoreException&lt;/code&gt;&lt;/a&gt;, and the implementation is required to throw this checked exception if it is unable to perform the operation. The exception propagates outward, causing the corresponding API method to fail.</source>
          <target state="translated">SPI 방법은 예외 동작에 관한 세 그룹으로 나뉩니다. &lt;code&gt;getSpi&lt;/code&gt; 의 방법은 예외가 발생해서는 안하지만,이 방법에 의해 throw 예외가에 의해 차단 될 것이다 그것은 정말 중요하지 않습니다 &lt;a href=&quot;abstractpreferences#get-java.lang.String-java.lang.String-&quot;&gt; &lt;code&gt;get(String,String)&lt;/code&gt; &lt;/a&gt; 호출에 지정된 기본값을 반환하는. &lt;code&gt;removeNodeSpi, keysSpi, childrenNamesSpi, syncSpi&lt;/code&gt; 및 &lt;code&gt;flushSpi&lt;/code&gt; 방법 던져 지정된 &lt;a href=&quot;backingstoreexception&quot;&gt; &lt;code&gt;BackingStoreException&lt;/code&gt; &lt;/a&gt; 하고 구현이 동작을 수행 할 수없는 경우,이 체크 예외를 발생해야한다. 예외가 바깥쪽으로 전파되어 해당 API 메소드가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b8b035de1ca402a2ac6d14617a04b7bf0c69468c" translate="yes" xml:space="preserve">
          <source>The SQL XML object becomes not readable when this method is called and may also become not writable depending on implementation.</source>
          <target state="translated">이 메서드를 호출하면 SQL XML 개체를 읽을 수 없으며 구현에 따라 쓰기가 불가능할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4d000eeee591dc24dbe21cb0dcab4271463087f" translate="yes" xml:space="preserve">
          <source>The SQL XML object becomes not writable when this method is called and may also become not readable depending on implementation.</source>
          <target state="translated">SQL XML 객체는이 메서드가 호출 될 때 쓰기가 불가능하며 구현에 따라 읽을 수 없게 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e995fb08754884662dfac9b7b56c2cf5aebe877" translate="yes" xml:space="preserve">
          <source>The SQL query returned by this method is used by &lt;code&gt;RowSet&lt;/code&gt; methods such as &lt;code&gt;execute&lt;/code&gt; and &lt;code&gt;populate&lt;/code&gt;, which may be implemented by any class that extends the &lt;code&gt;BaseRowSet&lt;/code&gt; abstract class and implements one or more of the standard JSR-114 &lt;code&gt;RowSet&lt;/code&gt; interfaces.</source>
          <target state="translated">이 메서드에 의해 반환 된 SQL 쿼리는 &lt;code&gt;execute&lt;/code&gt; 및 &lt;code&gt;populate&lt;/code&gt; 와 같은 &lt;code&gt;RowSet&lt;/code&gt; 메서드에서 사용되며 &lt;code&gt;BaseRowSet&lt;/code&gt; 추상 클래스 를 확장 하고 표준 JSR-114 &lt;code&gt;RowSet&lt;/code&gt; 인터페이스 중 하나 이상을 구현하는 모든 클래스에서 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2eea95fab9154e9d5d751dc37c5284e3a88dfb7a" translate="yes" xml:space="preserve">
          <source>The SQLXML interface provides methods for accessing the XML value as a String, a Reader or Writer, or as a Stream. The XML value may also be accessed through a Source or set as a Result, which are used with XML Parser APIs such as DOM, SAX, and StAX, as well as with XSLT transforms and XPath evaluations.</source>
          <target state="translated">SQLXML 인터페이스는 XML 값에 문자열, 판독기 또는 기록기 또는 스트림으로 액세스하는 방법을 제공합니다. XML 값은 소스를 통해 액세스하거나 결과로 설정할 수 있으며, 이는 DOM, SAX 및 StAX와 같은 XML 파서 API와 함께 사용되며 XSLT 변환 및 XPath 평가와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e68718ccd895f30f212819652bf6d7a839f3e354" translate="yes" xml:space="preserve">
          <source>The SQLstate for a &lt;code&gt;DataTruncation&lt;/code&gt; during read is &lt;code&gt;01004&lt;/code&gt;.</source>
          <target state="translated">읽기 중 &lt;code&gt;DataTruncation&lt;/code&gt; 의 SQLstate 는 &lt;code&gt;01004&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="873b4b6d913a2bdc904f26a2445522f64b0f3f24" translate="yes" xml:space="preserve">
          <source>The SQLstate for a &lt;code&gt;DataTruncation&lt;/code&gt; during write is &lt;code&gt;22001&lt;/code&gt;.</source>
          <target state="translated">쓰기 중 &lt;code&gt;DataTruncation&lt;/code&gt; 에 대한 SQLstate 는 &lt;code&gt;22001&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b6cde8fa0c00b8ce15c90873f656db7588e3214e" translate="yes" xml:space="preserve">
          <source>The SSL/TLS protocols employ ordered packets. Applications must take care to ensure that generated packets are delivered in sequence. If packets arrive out-of-order, unexpected or fatal results may occur.</source>
          <target state="translated">SSL / TLS 프로토콜은 순서가 지정된 패킷을 사용합니다. 애플리케이션은 생성 된 패킷이 순서대로 전달되도록주의해야합니다. 패킷이 고장난 경우 예기치 않은 결과 나 치명적인 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71fae155106cea8c5be1c9cdef429f9ad50b8140" translate="yes" xml:space="preserve">
          <source>The SSL/TLS/DTLS protocols employ ordered packets. Applications must take care to ensure that generated packets are delivered in sequence. If packets arrive out-of-order, unexpected or fatal results may occur.</source>
          <target state="translated">SSL / TLS / DTLS 프로토콜은 정렬 된 패킷을 사용합니다. 애플리케이션은 생성 된 패킷이 순서대로 전달되도록주의해야합니다. 패킷이 순서없이 도착하면 예상치 못한 또는 치명적인 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a5cbc0fa7d23029290836f25878e9b66351852c" translate="yes" xml:space="preserve">
          <source>The STAPLE_</source>
          <target state="translated">STAPLE_</target>
        </trans-unit>
        <trans-unit id="5bc4f92ece868c235f44c85040bf78cf79bdbc43" translate="yes" xml:space="preserve">
          <source>The SampleModel that describes how pixels from this Raster are stored in the DataBuffer.</source>
          <target state="translated">이 Raster의 픽셀이 DataBuffer에 저장되는 방법을 설명하는 SampleModel입니다.</target>
        </trans-unit>
        <trans-unit id="7f7ceb87bfd1664512bdfb9d97a72b792f1d9e31" translate="yes" xml:space="preserve">
          <source>The Saurashtra range with the Saurashtra digits.</source>
          <target state="translated">Saurashtra 숫자가있는 Saurashtra 범위.</target>
        </trans-unit>
        <trans-unit id="eb7e3d36792b3be33972f8e4b880e172f779b82d" translate="yes" xml:space="preserve">
          <source>The Scope of a Multicast Address</source>
          <target state="translated">멀티 캐스트 주소의 범위</target>
        </trans-unit>
        <trans-unit id="6be1580631b431c1e834d7a9f38eecee1d025127" translate="yes" xml:space="preserve">
          <source>The Scroll Lock key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 동작 키인 Scroll Lock 키입니다.</target>
        </trans-unit>
        <trans-unit id="67fb24c7eef4c2e723e18db6e3d490bf340d7d44" translate="yes" xml:space="preserve">
          <source>The SecurityManager set at startup</source>
          <target state="translated">시작시 설정된 SecurityManager</target>
        </trans-unit>
        <trans-unit id="bc25470783378de6eaa1e1a9d2ee4f23a7811fd9" translate="yes" xml:space="preserve">
          <source>The Segment implements the java.text.CharacterIterator interface to support use with the i18n support without copying text into a string.</source>
          <target state="translated">Segment는 문자열에 텍스트를 복사하지 않고 i18n 지원과 함께 사용할 수 있도록 java.text.CharacterIterator 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="6fe02d845f0c88f5c76dd6ee524b87fdcbd0bcff" translate="yes" xml:space="preserve">
          <source>The ServcieProvider may always return the same instance, or it may construct a new instance for each request.</source>
          <target state="translated">ServcieProvider는 항상 동일한 인스턴스를 반환하거나 각 요청에 대해 새 인스턴스를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5ec2b1af5f857a8c469337c6ffcf5b3cbaab840" translate="yes" xml:space="preserve">
          <source>The Service Provider Interface (SPI) mechanism that generates &lt;code&gt;SyncProvider&lt;/code&gt; instances to be used by disconnected &lt;code&gt;RowSet&lt;/code&gt; objects.</source>
          <target state="translated">연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체에서 사용할 &lt;code&gt;SyncProvider&lt;/code&gt; 인스턴스를 생성하는 SPI (서비스 공급자 인터페이스) 메커니즘입니다 .</target>
        </trans-unit>
        <trans-unit id="efb7ab5906edc177c43b85efb3780ea561b67685" translate="yes" xml:space="preserve">
          <source>The Service Provider Interface (SPI) mechanism that generates &lt;code&gt;SyncProvider&lt;/code&gt; instances to be used by disconnected &lt;code&gt;RowSet&lt;/code&gt; objects. The &lt;code&gt;SyncProvider&lt;/code&gt; instances in turn provide the &lt;code&gt;javax.sql.RowSetReader&lt;/code&gt; object the &lt;code&gt;RowSet&lt;/code&gt; object needs to populate itself with data and the &lt;code&gt;javax.sql.RowSetWriter&lt;/code&gt; object it needs to propagate changes to its data back to the underlying data source.</source>
          <target state="translated">연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체에서 사용할 &lt;code&gt;SyncProvider&lt;/code&gt; 인스턴스를 생성하는 SPI (서비스 공급자 인터페이스) 메커니즘입니다 . &lt;code&gt;SyncProvider&lt;/code&gt; 차례로 인스턴스가 제공 &lt;code&gt;javax.sql.RowSetReader&lt;/code&gt; 의 객체에게 &lt;code&gt;RowSet&lt;/code&gt; 데이터와 자신을 채우는 오브젝트의 요구를 &lt;code&gt;javax.sql.RowSetWriter&lt;/code&gt; 의 는 기본 데이터 소스에 데이터를 다시 변경 사항을 전파해야하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="602bac65ff18054bb2c4f3ab27ed1dab7754a538" translate="yes" xml:space="preserve">
          <source>The Service Provider Interface provides a pluggable mechanism by which &lt;code&gt;SyncProvider&lt;/code&gt; implementations can be registered and then generated when required. The lazy reference mechanism employed by the &lt;code&gt;SyncFactory&lt;/code&gt; limits unnecessary resource consumption by not creating an instance until it is required by a disconnected &lt;code&gt;RowSet&lt;/code&gt; object. The &lt;code&gt;SyncFactory&lt;/code&gt; class also provides a standard API to configure logging options and streams that &lt;b&gt;may&lt;/b&gt; be provided by a particular &lt;code&gt;SyncProvider&lt;/code&gt; implementation.</source>
          <target state="translated">서비스 공급자 인터페이스는 &lt;code&gt;SyncProvider&lt;/code&gt; 구현을 등록한 다음 필요할 때 생성 할 수 있는 플러그 형 메커니즘을 제공 합니다. &lt;code&gt;SyncFactory&lt;/code&gt; 에서 사용하는 지연 참조 메커니즘 은 연결이 끊어진 &lt;code&gt;RowSet&lt;/code&gt; 개체에 필요할 때까지 인스턴스를 생성하지 않음으로써 불필요한 리소스 소비를 제한 합니다. &lt;code&gt;SyncFactory&lt;/code&gt; 에의 클래스는 구성 로깅 옵션과 스트림 표준 API 제공 &lt;b&gt;할 수 있습니다&lt;/b&gt; 특정에 의해 제공 &lt;code&gt;SyncProvider&lt;/code&gt; 구현을.</target>
        </trans-unit>
        <trans-unit id="28b7987465eb7e220fbabc8609ba006f994d2083" translate="yes" xml:space="preserve">
          <source>The SetOfIntegerSyntax object's value is actually stored in &quot;</source>
          <target state="translated">SetOfIntegerSyntax 객체의 값은 실제로 &quot;</target>
        </trans-unit>
        <trans-unit id="96099b9b6f42e5249cd78c77635e4a0f8a2a0dac" translate="yes" xml:space="preserve">
          <source>The ShardingKeyBuilder instance that was created</source>
          <target state="translated">생성 된 ShardingKeyBuilder 인스턴스</target>
        </trans-unit>
        <trans-unit id="6c5041dd8df9ea9caf67044040d1ba01f76f902a" translate="yes" xml:space="preserve">
          <source>The SheetCollate attribute interacts with the &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; attribute. The &lt;a href=&quot;multipledocumenthandling&quot;&gt;&lt;code&gt;MultipleDocumentHandling&lt;/code&gt;&lt;/a&gt; attribute describes the collation of entire documents, and the SheetCollate attribute describes the semantics of collating individual pages within a document.</source>
          <target state="translated">SheetCollate 특성은 &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 특성 과 상호 작용 합니다. &lt;a href=&quot;multipledocumenthandling&quot;&gt; &lt;code&gt;MultipleDocumentHandling&lt;/code&gt; &lt;/a&gt; 속성은 전체 문서의 정렬을 설명하고 SheetCollate 속성은 문서 내에서 개별 페이지를 대조의 의미를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1ecd659b4a0ca913c67177150d19f336226c4f73" translate="yes" xml:space="preserve">
          <source>The Shift key extended modifier constant.</source>
          <target state="translated">Shift 키 확장 수정 자 상수입니다.</target>
        </trans-unit>
        <trans-unit id="46d6fae5700013c2ced96c7ed9a5e8ba45e8dae0" translate="yes" xml:space="preserve">
          <source>The Shift key modifier constant.</source>
          <target state="translated">Shift 키 수정 자 상수입니다.</target>
        </trans-unit>
        <trans-unit id="bbab176333078e20d34f38e545765b360e204697" translate="yes" xml:space="preserve">
          <source>The Signature class is used to provide applications the functionality of a digital signature algorithm.</source>
          <target state="translated">Signature 클래스는 응용 프로그램에 디지털 서명 알고리즘의 기능을 제공하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="80aa8cc11bad31a562a0297268322354d94eb7e4" translate="yes" xml:space="preserve">
          <source>The Signature class is used to provide applications the functionality of a digital signature algorithm. Digital signatures are used for authentication and integrity assurance of digital data.</source>
          <target state="translated">Signature 클래스는 응용 프로그램에 디지털 서명 알고리즘의 기능을 제공하는 데 사용됩니다. 디지털 서명은 디지털 데이터의 인증 및 무결성 보증에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d41a605fdc7b865337a0bc057f56fcea7b8ddc5f" translate="yes" xml:space="preserve">
          <source>The Sinhala range with the Sinhala digits.</source>
          <target state="translated">Sinhala 숫자가있는 Sinhala 범위.</target>
        </trans-unit>
        <trans-unit id="65be5afaeaad26e2d27394fc97b7904d20bf1370" translate="yes" xml:space="preserve">
          <source>The Snippet which has changed</source>
          <target state="translated">변경된 스 니펫</target>
        </trans-unit>
        <trans-unit id="aebb54655e0e730d9559b9dd9eb5dc0745cb12ec" translate="yes" xml:space="preserve">
          <source>The Start TLS extended request and response are used to establish a TLS connection over the existing LDAP connection associated with the JNDI context on which &lt;code&gt;extendedOperation()&lt;/code&gt; is invoked. Typically, a JNDI program uses the StartTLS extended request and response classes as follows.</source>
          <target state="translated">Start TLS 확장 요청 및 응답은 &lt;code&gt;extendedOperation()&lt;/code&gt; 이 호출 된 JNDI 컨텍스트와 연관된 기존 LDAP 연결을 통해 TLS 연결을 설정하는 데 사용 됩니다. 일반적으로 JNDI 프로그램은 다음과 같이 StartTLS 확장 요청 및 응답 클래스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1423e0f8d722fdf2f6932cbc25dbd3c9f5de2e15" translate="yes" xml:space="preserve">
          <source>The StartElement interface provides access to information about start elements.</source>
          <target state="translated">StartElement 인터페이스는 시작 요소에 대한 정보에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ca6d1e7ae197141f374372fa7f9334ecb12a9022" translate="yes" xml:space="preserve">
          <source>The StartElement interface provides access to information about start elements. A StartElement is reported for each Start Tag in the document.</source>
          <target state="translated">StartElement 인터페이스는 시작 요소에 대한 정보에 대한 액세스를 제공합니다. 문서의 각 시작 태그에 대해 StartElement가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="35ff6607428d35279a8e24fbc8d925b3e95c9fcb" translate="yes" xml:space="preserve">
          <source>The StartTLS extended request's assigned object identifier is 1.3.6.1.4.1.1466.20037.</source>
          <target state="translated">StartTLS 확장 요청의 할당 된 개체 식별자는 1.3.6.1.4.1.1466.20037입니다.</target>
        </trans-unit>
        <trans-unit id="f63533d528c41767afbaa8d3a271f97753da5dd2" translate="yes" xml:space="preserve">
          <source>The StartTLS extended response object.</source>
          <target state="translated">StartTLS 확장 응답 오브젝트.</target>
        </trans-unit>
        <trans-unit id="23f3a42343c6b0cebaecc8d191002f4fb77f9cf4" translate="yes" xml:space="preserve">
          <source>The StartTLS extended response's assigned object identifier is 1.3.6.1.4.1.1466.20037.</source>
          <target state="translated">StartTLS 확장 응답의 할당 된 개체 식별자는 1.3.6.1.4.1.1466.20037입니다.</target>
        </trans-unit>
        <trans-unit id="a2a2d794cbb4e33768f2db2ddbc166a2913834ca" translate="yes" xml:space="preserve">
          <source>The Stream Control Transport Protocol (SCTP) is a reliable, message-oriented, transport protocol existing at an equivalent level with UDP (User Datagram Protocol) and TCP (Transmission Control Protocol). SCTP is session oriented and an association between the endpoints must be established before any data can be transmitted.</source>
          <target state="translated">SCTP (Stream Control Transport Protocol)는 UDP (사용자 데이터 그램 프로토콜) 및 TCP (전송 제어 프로토콜)와 동등한 수준에 존재하는 신뢰할 수있는 메시지 지향 전송 프로토콜입니다. SCTP는 세션 지향적이며 데이터를 전송하기 전에 엔드 포인트 간의 연결을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac5f7218b83207bb23413d3351defe6e6d2953f5" translate="yes" xml:space="preserve">
          <source>The String &lt;code&gt;&quot;[George:Sally:Fred]&quot;&lt;/code&gt; may be constructed as follows:</source>
          <target state="translated">문자열 &lt;code&gt;&quot;[George:Sally:Fred]&quot;&lt;/code&gt; 는 다음과 같이 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4277b18bac7bf3deb5ddf1d71e76efde20397d80" translate="yes" xml:space="preserve">
          <source>The String has the format, &quot;LoginModuleControlFlag:</source>
          <target state="translated">문자열의 형식은 &quot;LoginModuleControlFlag :</target>
        </trans-unit>
        <trans-unit id="7899700d276a926be17ddd3f94305f484b5ca153" translate="yes" xml:space="preserve">
          <source>The String representation of the local connector's service address. The value can be parsed by the &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxserviceurl#%3Cinit%3E(java.lang.String)&quot;&gt;&lt;code&gt;JMXServiceURL(String)&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">로컬 커넥터의 서비스 주소에 대한 문자열 표현입니다. 값은 &lt;a href=&quot;../../../../../java.management/javax/management/remote/jmxserviceurl#%3Cinit%3E(java.lang.String)&quot;&gt; &lt;code&gt;JMXServiceURL(String)&lt;/code&gt; &lt;/a&gt; 생성자에 의해 구문 분석 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d633506a68191ed3a5c157daa149f9cc24706511" translate="yes" xml:space="preserve">
          <source>The String used to invoke the method in the syntax of the scripting language.</source>
          <target state="translated">스크립팅 언어의 구문에서 메소드를 호출하는 데 사용되는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d408b15cf0cc800c0587990d248adb6b6d4ba6cb" translate="yes" xml:space="preserve">
          <source>The StyledDocument class provides a method named &lt;code&gt;setParagraphAttributes()&lt;/code&gt;, which can be used to change the attributes of a paragraph Element:</source>
          <target state="translated">StyledDocument 클래스는 단락 요소의 속성을 변경하는 데 사용할 수있는 &lt;code&gt;setParagraphAttributes()&lt;/code&gt; 라는 메서드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="efa4faa380d57bd7ed8bf7808ed5d82b7790de0c" translate="yes" xml:space="preserve">
          <source>The Sundanese range with the Sundanese digits.</source>
          <target state="translated">순 다어 숫자가있는 순 다어 범위입니다.</target>
        </trans-unit>
        <trans-unit id="67f1c667a0dc189e9e17357576a58fa7c7e69def" translate="yes" xml:space="preserve">
          <source>The Swing Connection</source>
          <target state="translated">스윙 연결</target>
        </trans-unit>
        <trans-unit id="f4827b1c320f594012fd0e1692f2b80e280f4ee0" translate="yes" xml:space="preserve">
          <source>The Swing JEditorPane text component supports different kinds of content via a plug-in mechanism called an EditorKit.</source>
          <target state="translated">Swing JEditorPane 텍스트 구성 요소는 EditorKit이라는 플러그인 메커니즘을 통해 다양한 종류의 콘텐츠를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="319ec0528dbc3887826587918f6e21e7dd2b3539" translate="yes" xml:space="preserve">
          <source>The Swing JEditorPane text component supports different kinds of content via a plug-in mechanism called an EditorKit. Because HTML is a very popular format of content, some support is provided by default. The default support is provided by this class, which supports HTML version 3.2 (with some extensions), and is migrating toward version 4.0. The &amp;lt;applet&amp;gt; tag is not supported, but some support is provided for the &amp;lt;object&amp;gt; tag.</source>
          <target state="translated">Swing JEditorPane 텍스트 구성 요소는 EditorKit이라는 플러그인 메커니즘을 통해 다양한 종류의 콘텐츠를 지원합니다. HTML은 매우 널리 사용되는 콘텐츠 형식이므로 기본적으로 일부 지원이 제공됩니다. 기본 지원은 HTML 버전 3.2 (일부 확장 포함)를 지원하고 버전 4.0으로 마이그레이션하는이 클래스에서 제공합니다. &amp;lt;applet&amp;gt; 태그는 지원되지 않지만 &amp;lt;object&amp;gt; 태그에 대한 일부 지원이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7a802aa7bf26ec7a1cc42a344ad8a273e764c485" translate="yes" xml:space="preserve">
          <source>The Swing component being edited.</source>
          <target state="translated">편집중인 Swing 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="16daa8aab641953108c6e986bcf3e33a22837802" translate="yes" xml:space="preserve">
          <source>The System property &lt;code&gt;javax.sql.rowset.RowSetFactory&lt;/code&gt;. For example:</source>
          <target state="translated">시스템 속성 &lt;code&gt;javax.sql.rowset.RowSetFactory&lt;/code&gt; . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="9d84cba8f116bdd2043a66090499e5ef8c24b412" translate="yes" xml:space="preserve">
          <source>The SystemFlavorMap is a configurable map between &quot;natives&quot; (Strings), which correspond to platform-specific data formats, and &quot;flavors&quot; (DataFlavors), which correspond to platform-independent MIME types.</source>
          <target state="translated">SystemFlavorMap은 플랫폼 별 데이터 형식에 해당하는 &quot;natives&quot;(문자열)와 플랫폼에 독립적 인 MIME 유형에 해당하는 &quot;flavors&quot;(DataFlavors) 간의 구성 가능한 맵입니다.</target>
        </trans-unit>
        <trans-unit id="b5813b81eda26f878234e81d02d361a85d5cf193" translate="yes" xml:space="preserve">
          <source>The SystemFlavorMap is a configurable map between &quot;natives&quot; (Strings), which correspond to platform-specific data formats, and &quot;flavors&quot; (DataFlavors), which correspond to platform-independent MIME types. This mapping is used by the data transfer subsystem to transfer data between Java and native applications, and between Java applications in separate VMs.</source>
          <target state="translated">SystemFlavorMap은 플랫폼 별 데이터 형식에 해당하는 &quot;natives&quot;(문자열)와 플랫폼에 독립적 인 MIME 유형에 해당하는 &quot;flavors&quot;(DataFlavors) 간의 구성 가능한 맵입니다. 이 매핑은 데이터 전송 하위 시스템에서 Java와 기본 응용 프로그램간에 그리고 별도의 VM에있는 Java 응용 프로그램간에 데이터를 전송하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="36a344b14192606d7007c8e5f4bd436d06f82568" translate="yes" xml:space="preserve">
          <source>The TGT will be obtained from the cache specified. The Kerberos principal name used will be the principal name in the Ticket cache. If the TGT is not available in the ticket cache the user will be prompted for the principal name and the password. The TGT will be obtained using the authentication exchange with the KDC. The Subject will be populated with the TGT.</source>
          <target state="translated">TGT는 지정된 캐시에서 가져옵니다. 사용되는 Kerberos 프린시 펄 이름은 티켓 캐시의 프린시 펄 이름이됩니다. 티켓 캐시에서 TGT를 사용할 수없는 경우 사용자에게 주체 이름과 암호를 입력하라는 메시지가 표시됩니다. TGT는 KDC와의 인증 교환을 사용하여 얻습니다. 주제는 TGT로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="45d271600f336347aec6e7496112e1d9c74773af" translate="yes" xml:space="preserve">
          <source>The TSA certificate. May be null.</source>
          <target state="translated">TSA 인증서입니다. null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8905c2f60ea8028c08384cdfd02cc0e2c77d87e" translate="yes" xml:space="preserve">
          <source>The TSA identifier. May be null.</source>
          <target state="translated">TSA 식별자입니다. null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d6515747116f06f0b4ebe8765048b16a027c64c" translate="yes" xml:space="preserve">
          <source>The TSA's certificate path.</source>
          <target state="translated">TSA의 인증서 경로.</target>
        </trans-unit>
        <trans-unit id="3d6ab354a1aec8e2022633af6fac62b3c9e4b57d" translate="yes" xml:space="preserve">
          <source>The TSAPolicyID. May be null.</source>
          <target state="translated">TSAPolicyID입니다. null 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="279a82b9ea6132c64be5159d3877fb3798d40d5e" translate="yes" xml:space="preserve">
          <source>The Tab key.</source>
          <target state="translated">Tab 키입니다.</target>
        </trans-unit>
        <trans-unit id="ce3965031176178302e2bce833e7a0126175e511" translate="yes" xml:space="preserve">
          <source>The Tai Tham Hora range with the Tai Tham Hora digits.</source>
          <target state="translated">Tai Tham Hora 숫자가있는 Tai Tham Hora 범위.</target>
        </trans-unit>
        <trans-unit id="0fb7e85bff2825624cbc6d0d50d696d005db5b3b" translate="yes" xml:space="preserve">
          <source>The Tai Tham Tham range with the Tai Tham Tham digits.</source>
          <target state="translated">Tai Tham Tham 숫자가있는 Tai Tham Tham 범위입니다.</target>
        </trans-unit>
        <trans-unit id="da235aa7c91bc5dd35a2bba7861ab4559045171e" translate="yes" xml:space="preserve">
          <source>The Tamil range with the Tamil digits.</source>
          <target state="translated">타밀 숫자가있는 타밀 범위입니다.</target>
        </trans-unit>
        <trans-unit id="467c3241caab4e5f12439a4c16369d283debdbc0" translate="yes" xml:space="preserve">
          <source>The Telugu range with the Telugu digits.</source>
          <target state="translated">Telugu 숫자가있는 Telugu 범위입니다.</target>
        </trans-unit>
        <trans-unit id="17fc89d3978c8f500acb4dcf7ce7a033b40f948a" translate="yes" xml:space="preserve">
          <source>The Templates object that was created during the SAX event process, or null if no Templates object has been created.</source>
          <target state="translated">SAX 이벤트 프로세스 중에 생성 된 Templates 개체 또는 생성 된 Templates 개체가 없으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="b66d10d978e928f5397551ee66b7d9d0e065a2d3" translate="yes" xml:space="preserve">
          <source>The TerminalFactorySpi class defines the service provider interface.</source>
          <target state="translated">TerminalFactorySpi 클래스는 서비스 제공자 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d2cb5428d31bc0f81921036924321ca2906daa87" translate="yes" xml:space="preserve">
          <source>The TerminalFactorySpi class defines the service provider interface. Applications do not access this class directly, instead see &lt;a href=&quot;terminalfactory&quot;&gt;TerminalFactory&lt;/a&gt;.</source>
          <target state="translated">TerminalFactorySpi 클래스는 서비스 제공자 인터페이스를 정의합니다. 애플리케이션은이 클래스에 직접 액세스하지 않고 대신 &lt;a href=&quot;terminalfactory&quot;&gt;TerminalFactory&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cf59134294aaac83b765e65055974c0b11987dd" translate="yes" xml:space="preserve">
          <source>The Thai Buddhist calendar system has two eras, 'BE' and 'BEFORE_BE', defined by &lt;a href=&quot;thaibuddhistera&quot;&gt;&lt;code&gt;ThaiBuddhistEra&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">태국 불교 달력 시스템에는 ThaiBuddhistEra에 의해 정의 된 'BE'와 'BEFORE_BE'의 두 시대가 &lt;a href=&quot;thaibuddhistera&quot;&gt; &lt;code&gt;ThaiBuddhistEra&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ecc0e2cb52a9d0ca6c0b7fe7e98e97c74af1351" translate="yes" xml:space="preserve">
          <source>The Thai Buddhist calendar system has two eras. The current era, for years from 1 onwards, is known as the 'Buddhist' era. All previous years, zero or earlier in the proleptic count or one and greater in the year-of-era count, are part of the 'Before Buddhist' era.</source>
          <target state="translated">태국 불교 달력 시스템에는 두 가지 시대가 있습니다. 1 년부터 수년 동안 현재의 시대는 '불교'시대로 알려져 있습니다. 이전의 모든 년, proleptic 수에서 0 또는 그 이전 또는 1 년 이상의 숫자는 '불교 전'시대의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="110e78cab6d0a551308dd194cfdb9cad42b2df2d" translate="yes" xml:space="preserve">
          <source>The Thai Buddhist calendar system.</source>
          <target state="translated">태국 불교 달력 시스템.</target>
        </trans-unit>
        <trans-unit id="c58273bf0b4717f994a35a5209495c6fa0fcf4e8" translate="yes" xml:space="preserve">
          <source>The Thai range with the Thai digits.</source>
          <target state="translated">태국 숫자가있는 태국 범위입니다.</target>
        </trans-unit>
        <trans-unit id="e80c502116521746009b55cc3645ee88df29fce8" translate="yes" xml:space="preserve">
          <source>The Tibetan range with the Tibetan digits.</source>
          <target state="translated">티베트 숫자가있는 티베트 범위입니다.</target>
        </trans-unit>
        <trans-unit id="6fe517aef41bbdd4bd416297127f15e6b61ba17c" translate="yes" xml:space="preserve">
          <source>The Timezone offset in minutes of this &lt;code&gt;XMLGregorianCalendar&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;XMLGregorianCalendar&lt;/code&gt; 의 시간대 오프셋 (분)입니다 .</target>
        </trans-unit>
        <trans-unit id="543f4f61ebf4fe0c42957ec1af50500e4fd6fa60" translate="yes" xml:space="preserve">
          <source>The ToggleButton model</source>
          <target state="translated">ToggleButton 모델</target>
        </trans-unit>
        <trans-unit id="0b298fd2191bf011e3f43ce2df9992fad3a92ca5" translate="yes" xml:space="preserve">
          <source>The Type of Service (ToS) octet in the Internet Protocol (IP) header</source>
          <target state="translated">인터넷 프로토콜 (IP) 헤더의 ToS (Type of Service) 옥텟</target>
        </trans-unit>
        <trans-unit id="f71c6d9015d5bc5b86df61acaea348d89e3cf6a7" translate="yes" xml:space="preserve">
          <source>The Type of Service (ToS) octet in the Internet Protocol (IP) header.</source>
          <target state="translated">인터넷 프로토콜 (IP) 헤더의 서비스 유형 (ToS) 옥텟.</target>
        </trans-unit>
        <trans-unit id="19101f75dc37b2579815ebc4357149d12524b4c0" translate="yes" xml:space="preserve">
          <source>The UI resource version of &lt;code&gt;ScrollPaneLayout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ScrollPaneLayout&lt;/code&gt; 의 UI 리소스 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="cf6d22f3428bd802d71f25d5491e0567edb2b4a1" translate="yes" xml:space="preserve">
          <source>The UNICODE_CHARACTER_CLASS mode can also be enabled via the embedded flag expression &lt;code&gt;(?U)&lt;/code&gt;.</source>
          <target state="translated">UNICODE_CHARACTER_CLASS 모드는 내장 플래그 표현식 &lt;code&gt;(?U)&lt;/code&gt; 통해 활성화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f1d108a6186828d250a4d1cb21aff931336104d" translate="yes" xml:space="preserve">
          <source>The URI &lt;a href=&quot;../java.base/java/net/uri#getScheme()&quot;&gt;&lt;code&gt;scheme&lt;/code&gt;&lt;/a&gt; that identifies the ZIP file system is &lt;code&gt;jar&lt;/code&gt;.</source>
          <target state="translated">ZIP 파일 시스템을 식별하는 URI &lt;a href=&quot;../java.base/java/net/uri#getScheme()&quot;&gt; &lt;code&gt;scheme&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;jar&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="326383c46666e162db1fa95baa23aad12c87163b" translate="yes" xml:space="preserve">
          <source>The URI for the DOM object model, &quot;http://java.sun.com/jaxp/xpath/dom&quot;.</source>
          <target state="translated">DOM 개체 모델 &quot;http://java.sun.com/jaxp/xpath/dom&quot;의 URI입니다.</target>
        </trans-unit>
        <trans-unit id="2242def2c4eb4abea5ce4858ddf1f81c88a339f2" translate="yes" xml:space="preserve">
          <source>The URI of the linked resource.</source>
          <target state="translated">링크 된 리소스의 URI입니다.</target>
        </trans-unit>
        <trans-unit id="7cb9418c74098a11e7075457371e1f6d9873c8a2" translate="yes" xml:space="preserve">
          <source>The URI of the linked resource. See the href attribute definition in HTML 4.0.</source>
          <target state="translated">링크 된 리소스의 URI입니다. HTML 4.0의 href 속성 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2eaff71d0d443b89396e5dd66fa648f0b90bc362" translate="yes" xml:space="preserve">
          <source>The URI scheme</source>
          <target state="translated">URI 체계</target>
        </trans-unit>
        <trans-unit id="e120019222e9ac801c09d5e215e9d9753f9b73ed" translate="yes" xml:space="preserve">
          <source>The URI this locator is pointing to, or &lt;code&gt;null&lt;/code&gt; if no URI is available.</source>
          <target state="translated">이 로케이터가 가리키는 URI 또는 사용 가능한 URI가 &lt;code&gt;null&lt;/code&gt; 경우 null 입니다.</target>
        </trans-unit>
        <trans-unit id="3db755192093bf9ea9914eeed5bafdc43cf4e80f" translate="yes" xml:space="preserve">
          <source>The URIResolver that was set with setURIResolver.</source>
          <target state="translated">setURIResolver로 설정된 URIResolver입니다.</target>
        </trans-unit>
        <trans-unit id="90ea2269619fa9adad45716a63c561b727a10b95" translate="yes" xml:space="preserve">
          <source>The URL Path part of the Service URL.</source>
          <target state="translated">서비스 URL의 URL 경로 부분입니다.</target>
        </trans-unit>
        <trans-unit id="4ec678dde97f73fd23031533e67d7bb41d25cf06" translate="yes" xml:space="preserve">
          <source>The URL Path part of the Service URL. This is an empty string, or a string beginning with a slash (&lt;code&gt;/&lt;/code&gt;), or a string beginning with a semicolon (&lt;code&gt;;&lt;/code&gt;).</source>
          <target state="translated">서비스 URL의 URL 경로 부분. 빈 문자열이거나 슬래시 ( &lt;code&gt;/&lt;/code&gt; )로 시작하는 문자열 또는 세미콜론 ( &lt;code&gt;;&lt;/code&gt; )으로 시작하는 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="39cdd25064bd89d0ba41d92df7b08df17d225061" translate="yes" xml:space="preserve">
          <source>The URL above indicates that the protocol to use is &lt;code&gt;http&lt;/code&gt; (HyperText Transfer Protocol) and that the information resides on a host machine named &lt;code&gt;www.example.com&lt;/code&gt;. The information on that host machine is named &lt;code&gt;/docs/resource1.html&lt;/code&gt;. The exact meaning of this name on the host machine is both protocol dependent and host dependent. The information normally resides in a file, but it could be generated on the fly. This component of the URL is called the</source>
          <target state="translated">위의 URL은 사용할 프로토콜이 &lt;code&gt;http&lt;/code&gt; (HyperText Transfer Protocol)이며 해당 정보가 &lt;code&gt;www.example.com&lt;/code&gt; 이라는 호스트 시스템에 있음을 나타냅니다 . 해당 호스트 시스템에 대한 정보는 &lt;code&gt;/docs/resource1.html&lt;/code&gt; 입니다. 호스트 시스템에서이 이름의 정확한 의미는 프로토콜 및 호스트에 따라 다릅니다. 정보는 일반적으로 파일에 있지만 즉시 생성 될 수 있습니다. 이 URL 구성 요소를</target>
        </trans-unit>
        <trans-unit id="5dda6bed3bc097d11c3c752b8ec21e906c5b5c6b" translate="yes" xml:space="preserve">
          <source>The URL class does not itself encode or decode any URL components according to the escaping mechanism defined in RFC2396. It is the responsibility of the caller to encode any fields, which need to be escaped prior to calling URL, and also to decode any escaped fields, that are returned from URL. Furthermore, because URL has no knowledge of URL escaping, it does not recognise equivalence between the encoded or decoded form of the same URL. For example, the two URLs:</source>
          <target state="translated">URL 클래스는 RFC2396에 정의 된 이스케이프 메커니즘에 따라 URL 구성 요소 자체를 인코딩하거나 디코딩하지 않습니다. URL을 호출하기 전에 이스케이프해야하는 필드를 인코딩하고 URL에서 반환 된 이스케이프 된 필드를 디코딩하는 것은 호출자의 책임입니다. 또한 URL에는 URL 이스케이프에 대한 지식이 없으므로 동일한 URL의 인코딩 된 형식 또는 디코딩 된 형식 사이의 동등성을 인식하지 못합니다. 예를 들어 두 URL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="835069e3781db123058f4a2e3fd826ffcf3ca50d" translate="yes" xml:space="preserve">
          <source>The URL for the XML Schema definition file that defines the XML tags and their valid values for a &lt;code&gt;WebRowSet&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;WebRowSet&lt;/code&gt; 구현에 대한 XML 태그 및 유효한 값을 정의하는 XML 스키마 정의 파일의 URL입니다 .</target>
        </trans-unit>
        <trans-unit id="f1a13564394debd029b9191db3b513542cc43cd6" translate="yes" xml:space="preserve">
          <source>The URL represents the remote object on the World Wide Web to which this connection is opened.</source>
          <target state="translated">URL은이 연결이 열린 월드 와이드 웹의 원격 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2512db9d0f42c72fcc0e7d06aea9f96b3260a8c8" translate="yes" xml:space="preserve">
          <source>The US-ASCII alphabetic characters, &lt;code&gt;'A'&lt;/code&gt; through &lt;code&gt;'Z'&lt;/code&gt; and &lt;code&gt;'a'&lt;/code&gt; through &lt;code&gt;'z'&lt;/code&gt;</source>
          <target state="translated">미국-ASCII 알파벳 문자, &lt;code&gt;'A'&lt;/code&gt; 를 통해 &lt;code&gt;'Z'&lt;/code&gt; 와 &lt;code&gt;'a'&lt;/code&gt; 를 통해 &lt;code&gt;'z'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ddab5d100cab95e4d1bbb59f061bb561cce4653" translate="yes" xml:space="preserve">
          <source>The US-ASCII decimal digit characters, &lt;code&gt;'0'&lt;/code&gt; through &lt;code&gt;'9'&lt;/code&gt;</source>
          <target state="translated">US-ASCII 10 진수 ( &lt;code&gt;'0'&lt;/code&gt; 0'- &lt;code&gt;'9'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="12e3bf91f40d535acdcd4f7b782ae2318ee3eb7e" translate="yes" xml:space="preserve">
          <source>The UTC time-scale is a standard approach to bundle up all the additional fractions of a second from UT1 into whole seconds, known as</source>
          <target state="translated">UTC 시간 척도는 UT1에서 1 초의 모든 추가 부분을 초 단위로 묶는 표준 방식입니다.</target>
        </trans-unit>
        <trans-unit id="2bad15b1f327afb2fe620089520eb64352143c23" translate="yes" xml:space="preserve">
          <source>The UTC type uses the UTC offset. The STANDARD type uses the standard offset. The WALL type returns the input date-time. The result is intended for use with the wall-offset.</source>
          <target state="translated">UTC 유형은 UTC 오프셋을 사용합니다. STANDARD 유형은 표준 오프셋을 사용합니다. WALL 유형은 입력 날짜-시간을 리턴합니다. 결과는 벽 오프셋과 함께 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b2ba5a9b64c11e97775b5e2c453a61f37605ac19" translate="yes" xml:space="preserve">
          <source>The UTF-16, as defined in [Unicode] and Amendment 1 of [ISO/IEC 10646], offset into the input source this locator is pointing to or &lt;code&gt;-1&lt;/code&gt; if there is no UTF-16 offset available.</source>
          <target state="translated">[유니 코드] 및 [ISO / IEC 10646]의 개정 1에 정의 된 UTF-16은이 로케이터가 가리키는 입력 소스로 오프셋되거나 사용 가능한 UTF-16 오프셋이없는 경우 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30f27ccfa5d0569e8811312c5e589ba65ce5e892" translate="yes" xml:space="preserve">
          <source>The UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt; is used to decode the entry names and comments</source>
          <target state="translated">UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; &lt;/a&gt; 은 항목 이름과 주석을 해독하는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="dc1d3d9d30059176fa63317d871ad36c396c8256" translate="yes" xml:space="preserve">
          <source>The UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt; is used to decode the entry names and comments.</source>
          <target state="translated">UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; &lt;/a&gt; 는 항목 이름과 주석을 디코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6dcf3103182b65318ead8734e909a9308659e2" translate="yes" xml:space="preserve">
          <source>The UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt; is used to decode the entry names.</source>
          <target state="translated">UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; &lt;/a&gt; 는 항목 이름을 디코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35058fd7e1cae4d49e6ba8bb36a8e490aefa08a7" translate="yes" xml:space="preserve">
          <source>The UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt;&lt;code&gt;charset&lt;/code&gt;&lt;/a&gt; is used to encode the entry names and comments.</source>
          <target state="translated">UTF-8 &lt;a href=&quot;../../nio/charset/charset&quot;&gt; &lt;code&gt;charset&lt;/code&gt; &lt;/a&gt; 는 항목 이름과 주석을 인코딩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="97b660089cda0a866df93a5f2e1fb2461fc59e7d" translate="yes" xml:space="preserve">
          <source>The UTF-8 character encoding will be used.</source>
          <target state="translated">UTF-8 문자 인코딩이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba90dc4402c6ec2d6a6525f2ffe4acf21c1feb8f" translate="yes" xml:space="preserve">
          <source>The UUID string representation is as described by this BNF:</source>
          <target state="translated">UUID 문자열 표현은이 BNF에서 설명한대로입니다.</target>
        </trans-unit>
        <trans-unit id="e675ff6fc3d5c45e1c9594760191e675eb31248d" translate="yes" xml:space="preserve">
          <source>The Unicode Standard, Version 4.0</source>
          <target state="translated">유니 코드 표준, 버전 4.0</target>
        </trans-unit>
        <trans-unit id="f6652d81c5a885e6be2ae5f690d28ef1986bf40d" translate="yes" xml:space="preserve">
          <source>The Unicode characters that are not in the US-ASCII character set, are not control characters (according to the &lt;a href=&quot;../lang/character#isISOControl(char)&quot;&gt;&lt;code&gt;Character.isISOControl&lt;/code&gt;&lt;/a&gt; method), and are not space characters (according to the &lt;a href=&quot;../lang/character#isSpaceChar(char)&quot;&gt;&lt;code&gt;Character.isSpaceChar&lt;/code&gt;&lt;/a&gt; method)</source>
          <target state="translated">US-ASCII 문자 세트에없는 유니 코드 문자는합니다 (에 따라 제어 문자를 &lt;a href=&quot;../lang/character#isISOControl(char)&quot;&gt; &lt;code&gt;Character.isISOControl&lt;/code&gt; 의&lt;/a&gt; 방법), 그리고합니다 (에 따라 공백 문자가 아닌 &lt;a href=&quot;../lang/character#isSpaceChar(char)&quot;&gt; &lt;code&gt;Character.isSpaceChar&lt;/code&gt; 의&lt;/a&gt; 방법)</target>
        </trans-unit>
        <trans-unit id="4574e99fb15d0779dd2dc27a40a2ac1c1b6c5bf5" translate="yes" xml:space="preserve">
          <source>The Unicode characters that are not in the US-ASCII character set, are not control characters (according to the &lt;a href=&quot;../lang/character#isISOControl(int)&quot;&gt;&lt;code&gt;Character.isISOControl&lt;/code&gt;&lt;/a&gt; method), and are not space characters (according to the &lt;a href=&quot;../lang/character#isSpaceChar(int)&quot;&gt;&lt;code&gt;Character.isSpaceChar&lt;/code&gt;&lt;/a&gt; method)</source>
          <target state="translated">US-ASCII 문자 세트에없는 유니 코드 문자는합니다 (에 따라 제어 문자를 &lt;a href=&quot;../lang/character#isISOControl(int)&quot;&gt; &lt;code&gt;Character.isISOControl&lt;/code&gt; 의&lt;/a&gt; 방법), 그리고합니다 (에 따라 공백 문자가 아닌 &lt;a href=&quot;../lang/character#isSpaceChar(int)&quot;&gt; &lt;code&gt;Character.isSpaceChar&lt;/code&gt; 의&lt;/a&gt; 방법)</target>
        </trans-unit>
        <trans-unit id="855f6f6b04fe01a58122fa0578b047dec0b2396f" translate="yes" xml:space="preserve">
          <source>The Unicode characters that are not in the US-ASCII character set, are not control characters (according to the &lt;a href=&quot;../lang/character#isISOControl-char-&quot;&gt;&lt;code&gt;Character.isISOControl&lt;/code&gt;&lt;/a&gt; method), and are not space characters (according to the &lt;a href=&quot;../lang/character#isSpaceChar-char-&quot;&gt;&lt;code&gt;Character.isSpaceChar&lt;/code&gt;&lt;/a&gt; method)</source>
          <target state="translated">US-ASCII 문자 세트에없고 유니 코드 문자는 제어 문자가 아니며 ( &lt;a href=&quot;../lang/character#isISOControl-char-&quot;&gt; &lt;code&gt;Character.isISOControl&lt;/code&gt; &lt;/a&gt; 메소드 에 따라 ) 공백 문자가 아닙니다 ( &lt;a href=&quot;../lang/character#isSpaceChar-char-&quot;&gt; &lt;code&gt;Character.isSpaceChar&lt;/code&gt; &lt;/a&gt; 메소드 에 따라 ).</target>
        </trans-unit>
        <trans-unit id="f3dfcb36136372d42f03d3313790b203a822b063" translate="yes" xml:space="preserve">
          <source>The Unicode locale extension specifies optional behavior in locale-sensitive services. Although the LDML specification defines various keys and values, actual locale-sensitive service implementations in a Java Runtime Environment might not support any particular Unicode locale attributes or key/type pairs.</source>
          <target state="translated">유니 코드 로캘 확장은 로캘 구분 서비스에서 선택적 동작을 지정합니다. LDML 스펙이 다양한 키와 값을 정의하지만 Java Runtime Environment의 실제 로케일 구분 서비스 구현은 특정 유니 코드 로케일 속성 또는 키 / 유형 쌍을 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86012cec961e3da55accb740a355d0cd5b30a87a" translate="yes" xml:space="preserve">
          <source>The Unicode locale type associated with the key, or null if the locale does not define the key.</source>
          <target state="translated">키와 관련된 유니 코드 로캘 유형이거나 로캘이 키를 정의하지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="d327177e0e897e771e7bf07ac35916baa4874517" translate="yes" xml:space="preserve">
          <source>The UnresolvedPermission class is used to hold Permissions that were &quot;unresolved&quot; when the Policy was initialized.</source>
          <target state="translated">UnresolvedPermission 클래스는 정책이 초기화 될 때 &quot;해결되지 않은&quot;권한을 보유하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="106451eadba0a3f499c5e0507a145120909609cc" translate="yes" xml:space="preserve">
          <source>The UnresolvedPermission class is used to hold Permissions that were &quot;unresolved&quot; when the Policy was initialized. An unresolved permission is one whose actual Permission class does not yet exist at the time the Policy is initialized (see below).</source>
          <target state="translated">UnresolvedPermission 클래스는 정책이 초기화 될 때 &quot;해결되지 않은&quot;권한을 보유하는 데 사용됩니다. 확인할 수없는 권한은 정책이 초기화 될 때 실제 권한 클래스가 아직없는 권한입니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="2df5d6a200c9fc79968c79ca58277554b4e41cb6" translate="yes" xml:space="preserve">
          <source>The Unspecified Address -- Also called anylocal or wildcard address. It must never be assigned to any node. It indicates the absence of an address. One example of its use is as the target of bind, which allows a server to accept a client connection on any interface, in case the server host has multiple interfaces.</source>
          <target state="translated">지정되지 않은 주소-로컬 또는 와일드 카드 주소라고도합니다. 어떤 노드에도 할당되어서는 안됩니다. 주소가 없음을 나타냅니다. 사용의 한 예는 바인드 대상으로 서버 호스트에 여러 인터페이스가있는 경우 서버가 모든 인터페이스에서 클라이언트 연결을 승인 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="bd20bc73b6aece0146112ebca13eded1589d290b" translate="yes" xml:space="preserve">
          <source>The Up Arrow key, a non-ASCII action key.</source>
          <target state="translated">비 ASCII 작업 키인 위쪽 화살표 키입니다.</target>
        </trans-unit>
        <trans-unit id="6724e5a163e445518058720da3c6ac21ef6fb9c3" translate="yes" xml:space="preserve">
          <source>The VM is still intact and can be queried at the point this event was initiated but immediately thereafter it is not considered intact and cannot be queried. Note: If the enclosing &lt;a href=&quot;eventset&quot;&gt;&lt;code&gt;EventSet&lt;/code&gt;&lt;/a&gt; has a &lt;a href=&quot;../request/eventrequest#suspendPolicy()&quot;&gt;&lt;code&gt;suspend policy&lt;/code&gt;&lt;/a&gt; other than &lt;a href=&quot;../request/eventrequest#SUSPEND_ALL&quot;&gt;&lt;code&gt;SUSPEND_ALL&lt;/code&gt;&lt;/a&gt; the initiating point may be long past.</source>
          <target state="translated">VM은 여전히 ​​손상되지 않았으며이 이벤트가 시작된 시점에서 쿼리 할 수 ​​있지만 그 직후에는 손상되지 않은 것으로 간주되어 쿼리 할 수 ​​없습니다. 참고 : 포함하는 &lt;a href=&quot;eventset&quot;&gt; &lt;code&gt;EventSet&lt;/code&gt; 에&lt;/a&gt;&lt;a href=&quot;../request/eventrequest#SUSPEND_ALL&quot;&gt; &lt;code&gt;SUSPEND_ALL&lt;/code&gt; &lt;/a&gt; 이외 의 &lt;a href=&quot;../request/eventrequest#suspendPolicy()&quot;&gt; &lt;code&gt;suspend policy&lt;/code&gt; &lt;/a&gt; 이있는 경우 시작 지점이 오래되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2d31287a3b8f4339eb0d0cf7dab0c5f2dcf36d3" translate="yes" xml:space="preserve">
          <source>The VM option has not been set and its value is the default value.</source>
          <target state="translated">VM 옵션이 설정되지 않았으며 해당 값이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="58a6db9113a24bfd678e87ed151d28b28cc7f436" translate="yes" xml:space="preserve">
          <source>The VM option was set at VM creation time typically as a command line argument to the launcher or an argument passed to the VM created using the JNI invocation interface.</source>
          <target state="translated">VM 옵션은 일반적으로 실행기에 대한 명령 줄 인수 또는 JNI 호출 인터페이스를 사용하여 만든 VM에 전달 된 인수로 VM 생성시 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="04c62e2ba5cbd5a7a86b6e497fd23f3db9c9fa3c" translate="yes" xml:space="preserve">
          <source>The VM option was set using the attach framework.</source>
          <target state="translated">VM 옵션은 연결 프레임 워크를 사용하여 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="79a64ba41e7ffe78d0ed342152844ccb819511b0" translate="yes" xml:space="preserve">
          <source>The VM option was set via a configuration file.</source>
          <target state="translated">VM 옵션은 구성 파일을 통해 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="dfa0a3737c32224e915bcd9427f5a0c8376be4cb" translate="yes" xml:space="preserve">
          <source>The VM option was set via an environment variable.</source>
          <target state="translated">VM 옵션은 환경 변수를 통해 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="6e3d8d1048f77734e35cbb6155408a2e5d337461" translate="yes" xml:space="preserve">
          <source>The VM option was set via some other mechanism.</source>
          <target state="translated">VM 옵션은 다른 메커니즘을 통해 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="c2f232d8661c6c95daf95fc5e9d9e9d9f5f796ce" translate="yes" xml:space="preserve">
          <source>The VM option was set via the VM ergonomic support.</source>
          <target state="translated">VM 옵션은 VM 인체 공학적 지원을 통해 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="f3b667ec526ddbc98fae5b94ec7d19b76dd1adba" translate="yes" xml:space="preserve">
          <source>The VM option was set via the management interface after the VM was started.</source>
          <target state="translated">VM 옵션은 VM이 시작된 후 관리 인터페이스를 통해 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="7e28d7a80fdff0332c032ae2b51a3644b3d9c8c9" translate="yes" xml:space="preserve">
          <source>The Vai range with the Vai digits.</source>
          <target state="translated">Vai 숫자가있는 Vai 범위입니다.</target>
        </trans-unit>
        <trans-unit id="04555f9a29ee22667f4761f1aaad71988d945afa" translate="yes" xml:space="preserve">
          <source>The Version of the given string</source>
          <target state="translated">주어진 문자열의 버전</target>
        </trans-unit>
        <trans-unit id="a9b4cea609363e45ecf25383ee3bf51308373973" translate="yes" xml:space="preserve">
          <source>The View implementations work primarily off of CSS attributes, which are kept in the views. This makes it possible to have multiple views mapped over the same model that appear substantially different. This can be especially useful for printing. For most HTML attributes, the HTML attributes are converted to CSS attributes for display. This helps make the View implementations more general purpose</source>
          <target state="translated">보기 구현은 주로보기에 유지되는 CSS 속성으로 작동합니다. 이를 통해 실질적으로 다르게 보이는 동일한 모델에 대해 여러 뷰를 매핑 할 수 있습니다. 이것은 특히 인쇄에 유용 할 수 있습니다. 대부분의 HTML 속성에서 HTML 속성은 표시를 위해 CSS 속성으로 변환됩니다. 이는 View 구현을보다 일반적인 용도로 만드는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="aa5c0089c966db938a1c123dec34b5f8b4b2218a" translate="yes" xml:space="preserve">
          <source>The VirtualMachineManager supports many different scenarios for connecting a debugger to a virtual machine. Four examples are presented in the table below. The examples use the command line syntax in Sun's implementation. Some &lt;a href=&quot;connect/connector&quot;&gt;&lt;code&gt;Connector&lt;/code&gt;&lt;/a&gt; implementations may require slightly different handling than presented below.</source>
          <target state="translated">VirtualMachineManager는 디버거를 가상 머신에 연결하기위한 다양한 시나리오를 지원합니다. 아래 표에는 네 가지 예가 나와 있습니다. 예제는 Sun 구현에서 명령 줄 구문을 사용합니다. 일부 &lt;a href=&quot;connect/connector&quot;&gt; &lt;code&gt;Connector&lt;/code&gt; &lt;/a&gt; 구현은 아래에 제시된 것과 약간 다른 처리가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fddbcce63ee0a84bbd29b9306e28dc855a2a0ee4" translate="yes" xml:space="preserve">
          <source>The W3C generally recommends to exchange texts in NFC. Note also that most legacy character encodings use only precomposed forms and often do not encode any combining marks by themselves. For conversion to such character encodings the Unicode text needs to be normalized to NFC. For more usage examples, see the Unicode Standard Annex.</source>
          <target state="translated">W3C는 일반적으로 텍스트를 NFC로 교환 할 것을 권장합니다. 또한 대부분의 레거시 문자 인코딩은 미리 작성된 형식 만 사용하며 종종 자체적으로 결합 표시를 인코딩하지 않습니다. 이러한 문자 인코딩으로 변환하려면 유니 코드 텍스트를 NFC로 정규화해야합니다. 더 많은 사용 예는 Unicode Standard Annex를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="60ac13ebc0cab7b9e0634b27241f8e673d632adb" translate="yes" xml:space="preserve">
          <source>The WebSocket Close message status code (&lt;code&gt;1000&lt;/code&gt;), indicating normal closure, meaning that the purpose for which the connection was established has been fulfilled.</source>
          <target state="translated">WebSocket Close 메시지 상태 코드 ( &lt;code&gt;1000&lt;/code&gt; )는 정상적인 폐쇄를 나타내며 연결이 설정된 목적이 충족되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="41e8da58505ee8c3ae1d982bba7ecf2bd62e9f66" translate="yes" xml:space="preserve">
          <source>The X coordinate of the control point of the quadratic curve segment.</source>
          <target state="translated">2 차 곡선 세그먼트 제어점의 X 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="401e075d4c2b1f357f9012c25aa07a683039b0da" translate="yes" xml:space="preserve">
          <source>The X coordinate of the end point of the cubic curve segment.</source>
          <target state="translated">3 차 곡선 세그먼트 끝점의 X 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="f7efa57304a45f3c6814d34dd1048664a0909348" translate="yes" xml:space="preserve">
          <source>The X coordinate of the end point of the line segment.</source>
          <target state="translated">선분 끝점의 X 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="4603844126315239bb6312b9788fc2023035beb3" translate="yes" xml:space="preserve">
          <source>The X coordinate of the end point of the quadratic curve segment.</source>
          <target state="translated">2 차 곡선 세그먼트 끝점의 X 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="691c8e7fa81d3b27433b1e3e9057ea9f73ac34e5" translate="yes" xml:space="preserve">
          <source>The X coordinate of the first control point of the cubic curve segment.</source>
          <target state="translated">3 차 곡선 세그먼트의 첫 번째 제어점의 X 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="e8cd385fc2609ecde044fcc1b96de7a6632616ea" translate="yes" xml:space="preserve">
          <source>The X coordinate of the second control point of the cubic curve segment.</source>
          <target state="translated">3 차 곡선 세그먼트의 두 번째 제어점에 대한 X 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="4e105b004476e1f6b93a05b4b2cbb4ec787c32ff" translate="yes" xml:space="preserve">
          <source>The X coordinate of the start point of the cubic curve segment.</source>
          <target state="translated">3 차 곡선 세그먼트 시작점의 X 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="7fc449b82c1e260f2b89b5d215b9aea34ccdc8a8" translate="yes" xml:space="preserve">
          <source>The X coordinate of the start point of the line segment.</source>
          <target state="translated">선분 시작점의 X 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="fc588bc9ea9be612bdc6e0d0f6e97aebc72a8f0e" translate="yes" xml:space="preserve">
          <source>The X coordinate of the start point of the quadratic curve segment.</source>
          <target state="translated">2 차 곡선 세그먼트 시작점의 X 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="9601ffd175558f2678972eb432b25213e5b9f0c8" translate="yes" xml:space="preserve">
          <source>The X coordinate of the upper-left corner of the &lt;code&gt;Rectangle&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rectangle&lt;/code&gt; 왼쪽 위 모서리의 X 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="c9cc4dd79b0e244982c4d88a897ee0c104cc27ee" translate="yes" xml:space="preserve">
          <source>The X coordinate of the upper-left corner of the framing rectangle of the arc.</source>
          <target state="translated">호의 프레임 사각형 왼쪽 위 모서리의 X 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="b32e36d6a7f30d46236257f4b5d84d8942b801c8" translate="yes" xml:space="preserve">
          <source>The X coordinate of the upper-left corner of the framing rectangle of this &lt;code&gt;Ellipse2D&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Ellipse2D&lt;/code&gt; 프레임 사각형의 왼쪽 위 모서리에 대한 X 좌표 입니다 .</target>
        </trans-unit>
        <trans-unit id="95606612e219fb19f54e24c5e7dfa2551032497d" translate="yes" xml:space="preserve">
          <source>The X coordinate of the upper-left pixel of this Raster.</source>
          <target state="translated">이 Raster 왼쪽 위 픽셀의 X 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="38ca8a3388bec64f90e6d26918b12b71ff42687f" translate="yes" xml:space="preserve">
          <source>The X coordinate of this &lt;code&gt;Point2D&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Point2D&lt;/code&gt; 의 X 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="89d7d8876e2326dfc2ff18b4a96c3610526a83ee" translate="yes" xml:space="preserve">
          <source>The X coordinate of this &lt;code&gt;Point&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Point&lt;/code&gt; 의 X 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="35b90c3703acb704b5fa5158c7094b49787b3e08" translate="yes" xml:space="preserve">
          <source>The X coordinate of this &lt;code&gt;Point&lt;/code&gt;. If no X coordinate is set it will default to 0.</source>
          <target state="translated">이 &lt;code&gt;Point&lt;/code&gt; 의 X 좌표입니다 . X 좌표가 설정되지 않은 경우 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="9a0bfe96c0302f89ffbf03c8ae15f37335e0ade7" translate="yes" xml:space="preserve">
          <source>The X coordinate of this &lt;code&gt;Rectangle2D&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Rectangle2D&lt;/code&gt; 의 X 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="0ccc656f3811ee1ef399fbdf791ef3b1b379a04b" translate="yes" xml:space="preserve">
          <source>The X coordinate of this &lt;code&gt;RoundRectangle2D&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;RoundRectangle2D&lt;/code&gt; 의 X 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="eca24f91a898f09198ad942add403cf1dae1222d" translate="yes" xml:space="preserve">
          <source>The X translation from the coordinate space of the Raster's SampleModel to that of the Raster.</source>
          <target state="translated">Raster의 SampleModel 좌표 공간에서 Raster의 좌표 공간으로의 X 변환입니다.</target>
        </trans-unit>
        <trans-unit id="18ef77b0858f46134ac7b482ee49bb629a564dee" translate="yes" xml:space="preserve">
          <source>The X.509 v2 CRL format is described below in ASN.1:</source>
          <target state="translated">X.509 v2 CRL 형식은 아래 ASN.1에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="900649950dc9363bc48952d77bd40c61cbb4b3c1" translate="yes" xml:space="preserve">
          <source>The X/Y alignment of the component or component group.</source>
          <target state="translated">구성 요소 또는 구성 요소 그룹의 X / Y 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="a61090b1dc4815673d2c5d9710def49ab609c3aa" translate="yes" xml:space="preserve">
          <source>The X25519 parameters</source>
          <target state="translated">X25519 매개 변수</target>
        </trans-unit>
        <trans-unit id="b9fcd80872a7ab82bc8eeea007d48c23637dc911" translate="yes" xml:space="preserve">
          <source>The X3.274-1996 algorithm is:</source>
          <target state="translated">X3.274-1996 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="577c540d3af208b1f4a60c3c61604fe6ef53e60c" translate="yes" xml:space="preserve">
          <source>The X448 parameters</source>
          <target state="translated">X448 매개 변수</target>
        </trans-unit>
        <trans-unit id="34a2973111908baa92387abe40a1cd27d4ba8033" translate="yes" xml:space="preserve">
          <source>The XA interface defines the contract between a Resource Manager and a Transaction Manager in a distributed transaction processing (DTP) environment. A JDBC driver or a JMS provider implements this interface to support the association between a global transaction and a database or message service connection.</source>
          <target state="translated">XA 인터페이스는 분산 트랜잭션 처리 (DTP) 환경에서 리소스 관리자와 트랜잭션 관리자 간의 계약을 정의합니다. JDBC 드라이버 또는 JMS 공급자는이 인터페이스를 구현하여 전역 트랜잭션과 데이터베이스 또는 메시지 서비스 연결 간의 연결을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b8f8c7169835890a8600663be0b69ec310c14f2a" translate="yes" xml:space="preserve">
          <source>The XAConnectionBuilder instance that was created</source>
          <target state="translated">생성 된 XAConnectionBuilder 인스턴스</target>
        </trans-unit>
        <trans-unit id="43787955dfe90e5dad1fb6fa639556dad80e2773" translate="yes" xml:space="preserve">
          <source>The XAException is thrown by the Resource Manager (RM) to inform the Transaction Manager of an error encountered by the involved transaction.</source>
          <target state="translated">XAException은 RM (Resource Manager)에서 발생하여 트랜잭션 관리자에게 관련 트랜잭션에서 발생한 오류를 알립니다.</target>
        </trans-unit>
        <trans-unit id="9a44963ca495bf774450bf82872f90b22374db2d" translate="yes" xml:space="preserve">
          <source>The XAResource interface can be supported by any transactional resource that is intended to be used by application programs in an environment where transactions are controlled by an external transaction manager. An example of such a resource is a database management system. An application may access data through multiple database connections. Each database connection is enlisted with the transaction manager as a transactional resource. The transaction manager obtains an XAResource for each connection participating in a global transaction. The transaction manager uses the &lt;code&gt;start&lt;/code&gt; method to associate the global transaction with the resource, and it uses the &lt;code&gt;end&lt;/code&gt; method to disassociate the transaction from the resource. The resource manager is responsible for associating the global transaction to all work performed on its data between the start and end method invocations.</source>
          <target state="translated">XAResource 인터페이스는 트랜잭션이 외부 트랜잭션 관리자에 의해 제어되는 환경에서 애플리케이션 프로그램이 사용하도록 의도 된 모든 트랜잭션 자원에 의해 지원 될 수 있습니다. 이러한 리소스의 예는 데이터베이스 관리 시스템입니다. 응용 프로그램은 여러 데이터베이스 연결을 통해 데이터에 액세스 할 수 있습니다. 각 데이터베이스 연결은 트랜잭션 관리자와 함께 트랜잭션 자원으로 등록됩니다. 트랜잭션 관리자는 전역 트랜잭션에 참여하는 각 연결에 대해 XAResource를 얻습니다. 트랜잭션 관리자는 &lt;code&gt;start&lt;/code&gt; 메서드를 사용하여 전역 트랜잭션을 리소스와 연결하고 &lt;code&gt;end&lt;/code&gt; 사용합니다.자원에서 트랜잭션을 분리하는 방법. 자원 관리자는 시작 및 종료 메소드 호출 사이에 데이터에 대해 수행 된 모든 작업에 글로벌 트랜잭션을 연관시키는 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="effc5c0ebfbe6e453062d625c4d7142b8661d8ba" translate="yes" xml:space="preserve">
          <source>The XAResource interface is a Java mapping of the industry standard XA interface based on the X/Open CAE Specification (Distributed Transaction Processing: The XA Specification).</source>
          <target state="translated">XAResource 인터페이스는 X / Open CAE 사양 (분산 트랜잭션 처리 : XA 사양)을 기반으로 한 산업 표준 XA 인터페이스의 Java 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="23ff7a672258a1e25daf961e8eb39ca21e4f2eb9" translate="yes" xml:space="preserve">
          <source>The XID already exists.</source>
          <target state="translated">XID가 이미 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b17720086c9c5944af271412cbcf0e41ed9412" translate="yes" xml:space="preserve">
          <source>The XID is not valid.</source>
          <target state="translated">XID가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5b18bd8e595ddb6833bc036a8038513cc9a90ff" translate="yes" xml:space="preserve">
          <source>The XML Catalog API defines the following interfaces:</source>
          <target state="translated">XML 카탈로그 API는 다음 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="9617ef24b4c10a831130bfddddf713cf84152d9a" translate="yes" xml:space="preserve">
          <source>The XML Namespace URI as a constant.</source>
          <target state="translated">상수로서의 XML 네임 스페이스 URI입니다.</target>
        </trans-unit>
        <trans-unit id="a2fb8ea4d644914f0c91126a2661ba2954ad39a8" translate="yes" xml:space="preserve">
          <source>The XML Namespace URI as a constant. The value is &lt;code&gt;http://www.w3.org/XML/1998/namespace&lt;/code&gt; as defined in the &quot;Namespaces in XML&quot; * recommendation.</source>
          <target state="translated">상수로서의 XML 네임 스페이스 URI입니다. 값은 &quot;XML의 네임 스페이스&quot;* 권장 사항에 정의 된대로 &lt;code&gt;http://www.w3.org/XML/1998/namespace&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="235f7a6ae01eba16539559cbf5d02588685f7b59" translate="yes" xml:space="preserve">
          <source>The XML Namespace URI of the W3C Recommendation for XML-Signature Syntax and Processing.</source>
          <target state="translated">XML 서명 구문 및 처리를위한 W3C 권장 사항의 XML 네임 스페이스 URI입니다.</target>
        </trans-unit>
        <trans-unit id="aa072d61d484a286ec2d0a646ad2cad48fa5aed5" translate="yes" xml:space="preserve">
          <source>The XML Schema Definition of the &lt;code&gt;XPath&lt;/code&gt; element as defined in the &lt;a href=&quot;http://www.w3.org/TR/xmldsig-filter2&quot;&gt; W3C Recommendation for XML-Signature XPath Filter 2.0&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/xmldsig-filter2&quot;&gt;XML-Signature XPath Filter 2.0&lt;/a&gt; 에 대한 W3C 권장 사항에 정의 된 &lt;code&gt;XPath&lt;/code&gt; 요소 의 XML 스키마 정의 :</target>
        </trans-unit>
        <trans-unit id="3d86f9527ae16a7cb70d3cdfd08508a7d4bdf3eb" translate="yes" xml:space="preserve">
          <source>The XML Schema Definition of the &lt;code&gt;XPath&lt;/code&gt; element as defined in the &lt;a href=&quot;https://www.w3.org/TR/xmldsig-filter2&quot;&gt; W3C Recommendation for XML-Signature XPath Filter 2.0&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/xmldsig-filter2&quot;&gt;W3C Recommendation for XML-Signature XPath Filter 2.0에&lt;/a&gt; 정의 된 &lt;code&gt;XPath&lt;/code&gt; 요소 의 XML 스키마 정의 :</target>
        </trans-unit>
        <trans-unit id="75bc17ee4eab36314c9e9f43387521e57b050047" translate="yes" xml:space="preserve">
          <source>The XML Schema specification states that values can be of an arbitrary size. Implementations may chose not to or be incapable of supporting arbitrarily large and/or small values. An &lt;a href=&quot;../../../../java.base/java/lang/unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; will be thrown with a message indicating implementation limits if implementation capacities are exceeded.</source>
          <target state="translated">XML 스키마 사양에는 값이 임의의 크기가 될 수 있다고 명시되어 있습니다. 구현은 임의로 크거나 작은 값을 지원하지 않거나 지원하지 않을 수 있습니다. &lt;a href=&quot;../../../../java.base/java/lang/unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; &lt;/a&gt; 구현 능력을 초과하는 경우 구현 한계를 나타내는 메시지와 함께 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d95b6397dfa92d8f4b39c1f5c3b582df31001acd" translate="yes" xml:space="preserve">
          <source>The XML description shows the third row is marked as a &lt;code&gt;deleteRow&lt;/code&gt;, which eliminates the third row in the &lt;code&gt;WebRowSet&lt;/code&gt; object.</source>
          <target state="translated">XML 설명은 &lt;code&gt;WebRowSet&lt;/code&gt; 객체 에서 세 번째 행을 제거 하는 &lt;code&gt;deleteRow&lt;/code&gt; 로 표시된 세 번째 행을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="cc613ef20555d504cf2e4f94f40c5f23bc8ce169" translate="yes" xml:space="preserve">
          <source>The XML document has the following DOCTYPE declaration:</source>
          <target state="translated">XML 문서에는 다음 DOCTYPE 선언이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9e5faa87bff8499273f37dda3b048324b3c5c25" translate="yes" xml:space="preserve">
          <source>The XML document must have the following DOCTYPE declaration:</source>
          <target state="translated">XML 문서에는 다음 DOCTYPE 선언이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2ed02856deeab148266a90a042c02b0613dd709e" translate="yes" xml:space="preserve">
          <source>The XML document will have the following DOCTYPE declaration:</source>
          <target state="translated">XML 문서에는 다음 DOCTYPE 선언이 있습니다.</target>
        </trans-unit>
        <trans-unit id="20ccdce0ef571f49b358b0be0cece0a5f5de07e0" translate="yes" xml:space="preserve">
          <source>The XML qualified name, or the empty string if none is available, or null if the index is out of range.</source>
          <target state="translated">XML 규정 된 이름 또는 사용할 수없는 경우 빈 문자열, 인덱스가 범위를 벗어난 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="8863fe588cd102610730b2b73cbc39fc9b448c45" translate="yes" xml:space="preserve">
          <source>The XML reader will then allow the application to intercept any external entities (including the external DTD subset and external parameter entities, if any) before including them.</source>
          <target state="translated">그런 다음 XML 판독기는 애플리케이션이 외부 엔티티 (외부 DTD 서브 세트 및 외부 매개 변수 엔티티 (있는 경우) 포함)를 포함하기 전에 가로 채도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6b9f663ea5bf11d78ff348081d07ce6ea4fbf89a" translate="yes" xml:space="preserve">
          <source>The XML syntax uses the following conventions:</source>
          <target state="translated">XML 구문은 다음 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8bdca97ca7d79f02e422fa0d34751b5a61cc11e5" translate="yes" xml:space="preserve">
          <source>The XML value of the SQLXML instance may be obtained as a BinaryStream using</source>
          <target state="translated">SQLXML 인스턴스의 XML 값은 다음을 사용하여 BinaryStream으로 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b42e7c311f45ae7ee79d61a150929e9d03e90a0" translate="yes" xml:space="preserve">
          <source>The XMLFilterImpl helper class provides a convenient base for creating SAX2 filters, by passing on all &lt;a href=&quot;entityresolver&quot;&gt;&lt;code&gt;EntityResolver&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtdhandler&quot;&gt;&lt;code&gt;DTDHandler&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;contenthandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;errorhandler&quot;&gt;&lt;code&gt;ErrorHandler&lt;/code&gt;&lt;/a&gt; events automatically.</source>
          <target state="translated">XMLFilterImpl 도우미 클래스는 모든 &lt;a href=&quot;entityresolver&quot;&gt; &lt;code&gt;EntityResolver&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;dtdhandler&quot;&gt; &lt;code&gt;DTDHandler&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;contenthandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;errorhandler&quot;&gt; &lt;code&gt;ErrorHandler&lt;/code&gt; &lt;/a&gt; 이벤트를 자동으로 전달하여 SAX2 필터를 만들기위한 편리한 기반을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8446a8dce024b6c36553b2bd7e95801c55dc721f" translate="yes" xml:space="preserve">
          <source>The XMLFormatter can be used with arbitrary character encodings, but it is recommended that it normally be used with UTF-8. The character encoding can be set on the output Handler.</source>
          <target state="translated">XMLFormatter는 임의 문자 인코딩과 함께 사용할 수 있지만 일반적으로 UTF-8과 함께 사용하는 것이 좋습니다. 출력 처리기에서 문자 인코딩을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26815ce18d41c685dd831510e0677a43f7a4e128" translate="yes" xml:space="preserve">
          <source>The XMLReader that is encapsulated by the implementation of this class.</source>
          <target state="translated">이 클래스의 구현에 의해 캡슐화 된 XMLReader입니다.</target>
        </trans-unit>
        <trans-unit id="5fa66fc82e21063d8c3feebbb4aa380490af03a6" translate="yes" xml:space="preserve">
          <source>The XMLStreamReader interface allows forward, read-only access to XML.</source>
          <target state="translated">XMLStreamReader 인터페이스는 XML에 대한 정방향 읽기 전용 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f21b56e75fa5d9db106fd89c9a880c19e1820f93" translate="yes" xml:space="preserve">
          <source>The XMLStreamReader interface allows forward, read-only access to XML. It is designed to be the lowest level and most efficient way to read XML data.</source>
          <target state="translated">XMLStreamReader 인터페이스는 XML에 대한 정방향 읽기 전용 액세스를 허용합니다. XML 데이터를 읽는 가장 낮은 수준의 가장 효율적인 방법으로 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="4825b1ae671b4e54d4886336a9c3c76b72337020" translate="yes" xml:space="preserve">
          <source>The XMLStreamReader is designed to iterate over XML using next() and hasNext(). The data can be accessed using methods such as getEventType(), getNamespaceURI(), getLocalName() and getText();</source>
          <target state="translated">XMLStreamReader는 next () 및 hasNext ()를 사용하여 XML을 반복하도록 설계되었습니다. 데이터는 getEventType (), getNamespaceURI (), getLocalName () 및 getText ()와 같은 메소드를 사용하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9331df6a394e75235c3e87a73d0062dd6ad4c23" translate="yes" xml:space="preserve">
          <source>The XMLStreamWriter interface specifies how to write XML.</source>
          <target state="translated">XMLStreamWriter 인터페이스는 XML 작성 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e82bec965d3d81eed9765555bf4a5432f988fc43" translate="yes" xml:space="preserve">
          <source>The XMLStreamWriter interface specifies how to write XML. The XMLStreamWriter does not perform well formedness checking on its input. However the writeCharacters method is required to escape &amp;amp;, &amp;lt; and &amp;gt; For attribute values the writeAttribute method will escape the above characters plus &quot; to ensure that all character content and attribute values are well formed. Each NAMESPACE and ATTRIBUTE must be individually written.</source>
          <target state="translated">XMLStreamWriter 인터페이스는 XML 작성 방법을 지정합니다. XMLStreamWriter는 입력에 대해 올바른 형식 검사를 수행하지 않습니다. 그러나 writeCharacters 메소드는 &amp;amp;, &amp;lt;및&amp;gt;를 이스케이프해야합니다. 속성 값의 경우 writeAttribute 메소드는 위의 문자와 &quot;를 이스케이프하여 모든 문자 내용 및 속성 값이 올바른 형식을 갖도록합니다. 각 NAMESPACE 및 ATTRIBUTE는 개별적으로 작성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4ae2c936ada87ee2568d8205ed12fdae4315792a" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 NodeSet data type.</source>
          <target state="translated">XPath 1.0 NodeSet 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d960022571c4fe8489f08cf9c8a83b5200f78c24" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 NodeSet data type. Maps to &lt;a href=&quot;../../../org/w3c/dom/node&quot;&gt;&lt;code&gt;Node&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">XPath 1.0 NodeSet 데이터 유형입니다. 에 매핑 &lt;a href=&quot;../../../org/w3c/dom/node&quot;&gt; &lt;code&gt;Node&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddc662198ba49dcd6a46d26b93c41e38739232f3" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 NodeSet data type. Maps to &lt;a href=&quot;../../../org/w3c/dom/nodelist&quot;&gt;&lt;code&gt;NodeList&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">XPath 1.0 NodeSet 데이터 유형입니다. 에지도 &lt;a href=&quot;../../../org/w3c/dom/nodelist&quot;&gt; &lt;code&gt;NodeList&lt;/code&gt; 입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f657e6974ef28fe7722344d50a803d87f3c3ac6" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 Number data type is defined as a double. However, the XPath specification also provides functions that returns Integer type. To facilitate such operations, the XPath API allows Integer and Long to be used in &lt;code&gt;evaluateExpression&lt;/code&gt; method such as the following code:</source>
          <target state="translated">XPath 1.0 Number 데이터 유형은 double로 정의됩니다. 그러나 XPath 사양은 Integer 유형을 반환하는 함수도 제공합니다. 이러한 작업을 용이하게하기 위해 XPath API는 Integer 및 Long을 다음 코드와 같은 &lt;code&gt;evaluateExpression&lt;/code&gt; 메서드 에서 사용할 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="3a135a87c27994eea483fb468c5680717945f419" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 Number data type.</source>
          <target state="translated">XPath 1.0 숫자 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="25b74af48327c9206cd771fe2f01a49be71afadc" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 Number data type. Maps to Java &lt;a href=&quot;../../../../java.base/java/lang/number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;. Of the subtypes of Number, only Double, Integer and Long are required.</source>
          <target state="translated">XPath 1.0 숫자 데이터 유형입니다. Java &lt;a href=&quot;../../../../java.base/java/lang/number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; 에 매핑&lt;/a&gt; 됩니다. Number의 하위 유형 중 Double, Integer 및 Long 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2d1b0c8d57921aa0cb9a132602a38756677b1e4e" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 String data type.</source>
          <target state="translated">XPath 1.0 문자열 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9192ecbf183486264728a6ca4e07c49ffb9123f9" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 String data type. Maps to Java &lt;a href=&quot;../../../../java.base/java/lang/string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">XPath 1.0 문자열 데이터 유형입니다. Java &lt;a href=&quot;../../../../java.base/java/lang/string&quot;&gt; &lt;code&gt;String&lt;/code&gt; 에 매핑&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8e14b19762dc89f6fb59346b1eb722df3127473a" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 boolean data type.</source>
          <target state="translated">XPath 1.0 부울 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="172c71f7eb0e6136e0c2c51221f8489af13cf106" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 boolean data type. Maps to Java &lt;a href=&quot;../../../../java.base/java/lang/boolean&quot;&gt;&lt;code&gt;Boolean&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">XPath 1.0 부울 데이터 유형입니다. Java &lt;a href=&quot;../../../../java.base/java/lang/boolean&quot;&gt; &lt;code&gt;Boolean&lt;/code&gt; 에 매핑&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="07d2f66e0a4df68ace0c3ca95441742315f631eb" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 number data type.</source>
          <target state="translated">XPath 1.0 숫자 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0a87078260d2fef802e5db265713a09998f49cc9" translate="yes" xml:space="preserve">
          <source>The XPath 1.0 string data type.</source>
          <target state="translated">XPath 1.0 문자열 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a0e50be82dcaa8cca183227b2ce731608e3053e9" translate="yes" xml:space="preserve">
          <source>The XPath API defines the following &lt;a href=&quot;../namespace/qname&quot;&gt;&lt;code&gt;QName&lt;/code&gt;&lt;/a&gt; types to represent return types of an XPath evaluation:</source>
          <target state="translated">XPath API는 XPath 평가의 반환 유형을 나타 내기 위해 다음 &lt;a href=&quot;../namespace/qname&quot;&gt; &lt;code&gt;QName&lt;/code&gt; &lt;/a&gt; 유형을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="44309bdc6771edbd79a98740febbf0b5e0b9b67f" translate="yes" xml:space="preserve">
          <source>The XPath API supports &lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt; XML Path Language (XPath) Version 1.0&lt;/a&gt;</source>
          <target state="translated">XPath API는 XPath &lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;(XML Path Language) 버전 1.0을 지원합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae52f2bb81079bfb6ad930b9844476ec68489553" translate="yes" xml:space="preserve">
          <source>The XPath API supports &lt;a href=&quot;https://www.w3.org/TR/xpath&quot;&gt; XML Path Language (XPath) Version 1.0&lt;/a&gt;</source>
          <target state="translated">XPath API는 XPath &lt;a href=&quot;https://www.w3.org/TR/xpath&quot;&gt;(XML Path Language) 버전 1.0을 지원합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="017bbc08f2a909978e384513041dd95c49aaf031" translate="yes" xml:space="preserve">
          <source>The XPath language provides a simple, concise syntax for selecting nodes from an XML document. XPath also provides rules for converting a node in an XML document object model (DOM) tree to a boolean, double, or string value. XPath is a W3C-defined language and an official W3C recommendation; the W3C hosts the XML Path Language (XPath) Version 1.0 specification.</source>
          <target state="translated">XPath 언어는 XML 문서에서 노드를 선택하기위한 간단하고 간결한 구문을 제공합니다. XPath는 XML DOM (문서 개체 모델) 트리의 노드를 부울, 이중 또는 문자열 값으로 변환하는 규칙도 제공합니다. XPath는 W3C 정의 언어이며 공식 W3C 권장 사항입니다. W3C는 XPath (XML Path Language) 버전 1.0 사양을 호스팅합니다.</target>
        </trans-unit>
        <trans-unit id="0232bb6000493a8eebee9e39e7d53c87b696a6dd" translate="yes" xml:space="preserve">
          <source>The XYZ values of a color are often represented as relative to some white point, so the actual meaning of the XYZ values cannot be known without knowing the white point of those values. This is known as relative colorimetry. The PCS uses a white point of D50, so the XYZ values of the PCS are relative to D50. For example, white in the PCS will have the XYZ values of D50, which is defined to be X=.9642, Y=1.000, and Z=0.8249. This white point is commonly used for graphic arts applications, but others are often used in other applications.</source>
          <target state="translated">색상의 XYZ 값은 종종 일부 흰색 점에 상대적으로 표시되므로 해당 값의 흰색 점을 알지 못하면 XYZ 값의 실제 의미를 알 수 없습니다. 이를 상대 비색계라고합니다. PCS는 D50의 흰색 점을 사용하므로 PCS의 XYZ 값은 D50에 상대적입니다. 예를 들어 PCS의 흰색은 X = .9642, Y = 1.000 및 Z = 0.8249로 정의 된 D50의 XYZ 값을 갖습니다. 이 흰색 점은 일반적으로 그래픽 아트 응용 프로그램에 사용되지만 다른 점은 다른 응용 프로그램에서 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a088b538189992d30c3929d02641dea771bdd9f" translate="yes" xml:space="preserve">
          <source>The Xid interface is a Java mapping of the X/Open transaction identifier XID structure.</source>
          <target state="translated">Xid 인터페이스는 X / Open 트랜잭션 식별자 XID 구조의 Java 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="31062a72442ad36ae6a406366086e20a36ff7340" translate="yes" xml:space="preserve">
          <source>The Xid interface is a Java mapping of the X/Open transaction identifier XID structure. This interface specifies three accessor methods to retrieve a global transaction format ID, global transaction ID, and branch qualifier. The Xid interface is used by the transaction manager and the resource managers. This interface is not visible to the application programs.</source>
          <target state="translated">Xid 인터페이스는 X / Open 트랜잭션 식별자 XID 구조의 Java 매핑입니다. 이 인터페이스는 글로벌 트랜잭션 형식 ID, 글로벌 트랜잭션 ID 및 분기 규정자를 검색하는 세 가지 접근 자 메소드를 지정합니다. Xid 인터페이스는 트랜잭션 관리자와 리소스 관리자가 사용합니다. 이 인터페이스는 응용 프로그램에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9310aa501debf48a6688cdabf626cc91d5b4e594" translate="yes" xml:space="preserve">
          <source>The Y coordinate of the control point of the quadratic curve segment.</source>
          <target state="translated">2 차 곡선 세그먼트 제어점의 Y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="3b6dc70decc317c9d42f4d1bd85fa8605f1f2eb0" translate="yes" xml:space="preserve">
          <source>The Y coordinate of the end point of the cubic curve segment.</source>
          <target state="translated">3 차 곡선 세그먼트 끝점의 Y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="801ba9e957d7305f207ac65b15258f09261dedc4" translate="yes" xml:space="preserve">
          <source>The Y coordinate of the end point of the line segment.</source>
          <target state="translated">선분 끝점의 Y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="0870dad978bd5e3b56a29089b3adcbf20f0405c9" translate="yes" xml:space="preserve">
          <source>The Y coordinate of the end point of the quadratic curve segment.</source>
          <target state="translated">2 차 곡선 세그먼트 끝점의 Y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="082b3b2fa60174d4797e2af8881b14aa4b65ba1f" translate="yes" xml:space="preserve">
          <source>The Y coordinate of the first control point of the cubic curve segment.</source>
          <target state="translated">3 차 곡선 세그먼트의 첫 번째 제어점의 Y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="70ef1dbc442d9fd1c13a154ee75092425b3d2bd3" translate="yes" xml:space="preserve">
          <source>The Y coordinate of the second control point of the cubic curve segment.</source>
          <target state="translated">3 차 곡선 세그먼트의 두 번째 제어점의 Y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="5ac29f3bed5c0e7aac7e74cff9fc23066cdf3c10" translate="yes" xml:space="preserve">
          <source>The Y coordinate of the start point of the cubic curve segment.</source>
          <target state="translated">3 차 곡선 세그먼트 시작점의 Y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="10b573f3cf4e97410edba5b112ab861e68272878" translate="yes" xml:space="preserve">
          <source>The Y coordinate of the start point of the line segment.</source>
          <target state="translated">선분 시작점의 Y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="1c04997ffc6f91e7d954a6a64d1bc6d7174fcc8c" translate="yes" xml:space="preserve">
          <source>The Y coordinate of the start point of the quadratic curve segment.</source>
          <target state="translated">2 차 곡선 세그먼트 시작점의 Y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="85d733333f00046d08367293edcd192d17af552c" translate="yes" xml:space="preserve">
          <source>The Y coordinate of the upper-left corner of the &lt;code&gt;Rectangle&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rectangle&lt;/code&gt; 왼쪽 위 모서리의 Y 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="347465f3a7c9d3fd8fb81508c0543636a3632b65" translate="yes" xml:space="preserve">
          <source>The Y coordinate of the upper-left corner of the framing rectangle of the arc.</source>
          <target state="translated">호의 프레임 사각형 왼쪽 위 모서리의 Y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="1fe20011d8c213da2684ac5695cac5b2e089333a" translate="yes" xml:space="preserve">
          <source>The Y coordinate of the upper-left corner of the framing rectangle of this &lt;code&gt;Ellipse2D&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Ellipse2D&lt;/code&gt; 프레임 사각형의 왼쪽 위 모서리에 대한 Y 좌표 입니다 .</target>
        </trans-unit>
        <trans-unit id="2fc4bc81834b28690ff1cdfa84b865124f85e433" translate="yes" xml:space="preserve">
          <source>The Y coordinate of the upper-left pixel of this Raster.</source>
          <target state="translated">이 Raster 왼쪽 위 픽셀의 Y 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="5391b38e2330b49c1049e50f417b9ab77c418660" translate="yes" xml:space="preserve">
          <source>The Y coordinate of this &lt;code&gt;Point2D&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Point2D&lt;/code&gt; 의 Y 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="047af80c54ef5c1db4c7cf93c90b0aad478cfd3e" translate="yes" xml:space="preserve">
          <source>The Y coordinate of this &lt;code&gt;Point&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Point&lt;/code&gt; 의 Y 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="788705b123f338c32b65af50ace299c5fa0476d7" translate="yes" xml:space="preserve">
          <source>The Y coordinate of this &lt;code&gt;Point&lt;/code&gt;. If no Y coordinate is set it will default to 0.</source>
          <target state="translated">이 &lt;code&gt;Point&lt;/code&gt; 의 Y 좌표입니다 . Y 좌표가 설정되지 않은 경우 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="4169528dc15c39e0372902b833b4e2f498be19ef" translate="yes" xml:space="preserve">
          <source>The Y coordinate of this &lt;code&gt;Rectangle2D&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Rectangle2D&lt;/code&gt; Y 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="26ef453579b356ae1f544c6fe6fe1d2352f0c75e" translate="yes" xml:space="preserve">
          <source>The Y coordinate of this &lt;code&gt;RoundRectangle2D&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;RoundRectangle2D&lt;/code&gt; Y 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="436993701f30b566fac48276fc325f734d2851cf" translate="yes" xml:space="preserve">
          <source>The Y translation from the coordinate space of the Raster's SampleModel to that of the Raster.</source>
          <target state="translated">Raster의 SampleModel 좌표 공간에서 Raster의 좌표 공간으로의 Y 변환.</target>
        </trans-unit>
        <trans-unit id="4f137bc5a9d63bb2e7c9bdc0a3694b96fcb5e712" translate="yes" xml:space="preserve">
          <source>The ZapfDingbats fontname is also deprecated in 1.1 but the characters are defined in Unicode starting at 0x2700, and as of 1.1 Java supports those characters.</source>
          <target state="translated">ZapfDingbats 글꼴 이름도 1.1에서 더 이상 사용되지 않지만 문자는 0x2700에서 시작하는 유니 코드로 정의되며 1.1부터 Java는 이러한 문자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="94ac00d5f8bad09d25d989c532f0827c6c5a442b" translate="yes" xml:space="preserve">
          <source>The ability to ask the authenticator registered with the system for a password</source>
          <target state="translated">시스템에 등록 된 인증 자에게 비밀번호를 요청할 수있는 기능</target>
        </trans-unit>
        <trans-unit id="6a9ad9381470ef3c14b283bd3a6021b551af7fac" translate="yes" xml:space="preserve">
          <source>The ability to create a sub-class of Socket or ServerSocket with a user specified SocketImpl.</source>
          <target state="translated">사용자 지정 SocketImpl을 사용하여 Socket 또는 ServerSocket의 하위 클래스를 만드는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="2391fc7f737dac42143927879754a5942eeed9dd" translate="yes" xml:space="preserve">
          <source>The ability to create instances of &lt;code&gt;JColorChooser&lt;/code&gt; panes directly (within any container). &lt;code&gt;PropertyChange&lt;/code&gt; listeners can be added to detect when the current &quot;color&quot; property changes.</source>
          <target state="translated">컨테이너 내에서 직접 &lt;code&gt;JColorChooser&lt;/code&gt; 창의 인스턴스를 생성하는 기능 . &lt;code&gt;PropertyChange&lt;/code&gt; 리스너를 추가하여 현재 &quot;color&quot;속성이 변경되는시기를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f6c85667f40550ed984e7d465e987fb50b1cee5" translate="yes" xml:space="preserve">
          <source>The ability to get the SSLSessionContext of an SSLSession.</source>
          <target state="translated">SSLSession의 SSLSessionContext를 얻는 기능.</target>
        </trans-unit>
        <trans-unit id="c08cb64a173c4838bf0ab57b143814354d1d878a" translate="yes" xml:space="preserve">
          <source>The ability to get the cookie handler that processes highly security sensitive cookie information for an Http session.</source>
          <target state="translated">Http 세션에 대해 보안에 민감한 쿠키 정보를 처리하는 쿠키 처리기를 얻는 기능.</target>
        </trans-unit>
        <trans-unit id="747dfd09cac650048472c89cdbbbf59e4084fb21" translate="yes" xml:space="preserve">
          <source>The ability to get the proxy selector used to make decisions on which proxies to use when making network connections.</source>
          <target state="translated">프록시 선택기를 사용하여 네트워크 연결을 만들 때 사용할 프록시를 결정하는 기능.</target>
        </trans-unit>
        <trans-unit id="eb846b7dea720d16a96e23598e4c9f77568665c4" translate="yes" xml:space="preserve">
          <source>The ability to get the response cache that provides access to a local response cache.</source>
          <target state="translated">로컬 응답 캐시에 대한 액세스를 제공하는 응답 캐시를 얻는 기능</target>
        </trans-unit>
        <trans-unit id="0101c8dcdd9124ae9e9dc071a563cf4befcd5dc2" translate="yes" xml:space="preserve">
          <source>The ability to interrupt a lock acquisition in some implementations may not be possible, and if possible may be an expensive operation. The programmer should be aware that this may be the case. An implementation should document when this is the case.</source>
          <target state="translated">일부 구현에서 잠금 획득을 중단시키는 능력은 가능하지 않을 수 있으며, 가능하면 고가의 작동 일 수있다. 프로그래머는 이것이 사실 일 수 있음을 알고 있어야합니다. 이 경우 구현시 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6fad9c27e4f8a6493f7feabf035fe54852835fe" translate="yes" xml:space="preserve">
          <source>The ability to read (non-acl) file attributes.</source>
          <target state="translated">비 속성 파일 속성을 읽는 기능.</target>
        </trans-unit>
        <trans-unit id="4dc25dabb4df1918d4e24db4d9c3ddb2ce955dbc" translate="yes" xml:space="preserve">
          <source>The ability to retrieve all information about local network interfaces.</source>
          <target state="translated">로컬 네트워크 인터페이스에 대한 모든 정보를 검색하는 기능</target>
        </trans-unit>
        <trans-unit id="8d62361f7d663bbcd4ccf2897e33eedf52e2f92b" translate="yes" xml:space="preserve">
          <source>The ability to set a callback which can decide whether to allow a mismatch between the host being connected to by an HttpsURLConnection and the common name field in server certificate.</source>
          <target state="translated">HttpsURLConnection으로 연결된 호스트와 서버 인증서의 일반 이름 필드간에 불일치를 허용할지 여부를 결정할 수있는 콜백 설정 기능.</target>
        </trans-unit>
        <trans-unit id="c8fd9ad3f015a0c63d2df8d095236f1dc4f764c2" translate="yes" xml:space="preserve">
          <source>The ability to set the cookie handler that processes highly security sensitive cookie information for an Http session.</source>
          <target state="translated">Http 세션에 대해 보안에 민감한 쿠키 정보를 처리하는 쿠키 핸들러를 설정하는 기능.</target>
        </trans-unit>
        <trans-unit id="728c49b4a4c3274c673e299fc6abf84bf96e38a8" translate="yes" xml:space="preserve">
          <source>The ability to set the default SSL context</source>
          <target state="translated">기본 SSL 컨텍스트를 설정하는 기능</target>
        </trans-unit>
        <trans-unit id="523d52b8be5bc53ba69bacce4312e572cfbcee19" translate="yes" xml:space="preserve">
          <source>The ability to set the proxy selector used to make decisions on which proxies to use when making network connections.</source>
          <target state="translated">네트워크 연결을 할 때 사용할 프록시를 결정하는 데 사용되는 프록시 선택기를 설정하는 기능.</target>
        </trans-unit>
        <trans-unit id="6a66a567e4af10bb233d87868b18a39623d36448" translate="yes" xml:space="preserve">
          <source>The ability to set the response cache that provides access to a local response cache.</source>
          <target state="translated">로컬 응답 캐시에 대한 액세스를 제공하는 응답 캐시를 설정하는 기능</target>
        </trans-unit>
        <trans-unit id="ea953d76621b3799d35d695029de5de0d988b3b4" translate="yes" xml:space="preserve">
          <source>The ability to set the subsampling grid to start somewhere other than the source region origin is useful if the region is being used to create subsampled tiles of a large image, where the tile width and height are not multiples of the subsampling periods. If the subsampling grid does not remain consistent from tile to tile, there will be artifacts at the tile boundaries. By adjusting the subsampling grid offset for each tile to compensate, these artifacts can be avoided. The tradeoff is that in order to avoid these artifacts, the tiles are not all the same size. The grid offset to use in this case is given by:</source>
          <target state="translated">소스 영역 원점이 아닌 다른 곳에서 시작하도록 서브 샘플링 그리드를 설정하는 기능은 영역이 큰 이미지의 서브 샘플링 된 타일을 만드는 데 사용되는 경우에 유용합니다. 여기서 타일 너비와 높이는 서브 샘플링 기간의 배수가 아닙니다. 서브 샘플링 그리드가 타일마다 일치하지 않으면 타일 경계에 아티팩트가 있습니다. 보상하기 위해 각 타일에 대한 서브 샘플링 그리드 오프셋을 조정함으로써 이러한 아티팩트를 피할 수 있습니다. 단점은 이러한 인공물을 피하기 위해 타일의 크기가 모두 동일하지 않다는 것입니다. 이 경우 사용할 그리드 오프셋은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d302e4f1c649bfc96b09fc919581ac270437619a" translate="yes" xml:space="preserve">
          <source>The ability to set the way authentication information is retrieved when a proxy or HTTP server asks for authentication</source>
          <target state="translated">프록시 또는 HTTP 서버가 인증을 요청할 때 인증 정보를 검색하는 방법을 설정하는 기능</target>
        </trans-unit>
        <trans-unit id="89f72a0701e76fa12481a67aeda6de0afe701332" translate="yes" xml:space="preserve">
          <source>The ability to specify a stream handler when constructing a URL</source>
          <target state="translated">URL을 구성 할 때 스트림 핸들러를 지정하는 기능</target>
        </trans-unit>
        <trans-unit id="3b52910e750a521c4270f9ad1e92d1182fab62a3" translate="yes" xml:space="preserve">
          <source>The ability to use the HTTP TRACE method in HttpURLConnection.</source>
          <target state="translated">HttpURLConnection에서 HTTP TRACE 메소드를 사용하는 기능</target>
        </trans-unit>
        <trans-unit id="6af3beb90f71de8d44827b35e1c4fa464ca9ab63" translate="yes" xml:space="preserve">
          <source>The ability to write (non-acl) file attributes.</source>
          <target state="translated">acl이 아닌 파일 속성을 작성하는 기능</target>
        </trans-unit>
        <trans-unit id="0c1c6a0d4d30fea8f449c62d5b4c29cc1544ce21" translate="yes" xml:space="preserve">
          <source>The above assumes you want the binding to be applicable for &lt;code&gt;WHEN_FOCUSED&lt;/code&gt;. To register bindings for other focus states use the &lt;code&gt;getInputMap&lt;/code&gt; method that takes an integer.</source>
          <target state="translated">위는 바인딩이 &lt;code&gt;WHEN_FOCUSED&lt;/code&gt; 에 적용되기를 원한다고 가정합니다 . 다른 초점 상태에 대한 바인딩을 등록하려면 정수를 취하는 &lt;code&gt;getInputMap&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3b848411cf45fc02dcdb3486e2b857957033a00" translate="yes" xml:space="preserve">
          <source>The above code will work even if new modifiers are added.</source>
          <target state="translated">위 코드는 새 수정자가 추가 되어도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="34947d5ffe16787f06077e5d442016b4db2123d1" translate="yes" xml:space="preserve">
          <source>The above declaration can be modelled using a layout object, as follows:</source>
          <target state="translated">위의 선언은 다음과 같이 레이아웃 객체를 사용하여 모델링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c5e8bb2f63dfd41e23a9a1df7ddbcc71f5f3612" translate="yes" xml:space="preserve">
          <source>The above example does not differentiate the case where the memory usage has temporarily dropped below the usage threshold from the case where the memory usage remains above the threshold between two iterations. The usage threshold count returned by the &lt;a href=&quot;#getUsageThresholdCount()&quot;&gt;&lt;code&gt;getUsageThresholdCount()&lt;/code&gt;&lt;/a&gt; method can be used to determine if the memory usage has returned below the threshold between two polls.</source>
          <target state="translated">위의 예는 메모리 사용량이 일시적으로 사용량 임계 값 아래로 떨어진 경우와 메모리 사용량이 두 반복 사이의 임계 값 이상으로 유지되는 경우를 구별하지 않습니다. &lt;a href=&quot;#getUsageThresholdCount()&quot;&gt; &lt;code&gt;getUsageThresholdCount()&lt;/code&gt; &lt;/a&gt; 메서드 에서 반환 된 사용량 임계 값 수를 사용하여 메모리 사용량이 두 폴 사이의 임계 값 미만으로 반환되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75a1e459161bc40b650d129db959cfadba7b7567" translate="yes" xml:space="preserve">
          <source>The above example does not differentiate the case where the memory usage has temporarily dropped below the usage threshold from the case where the memory usage remains above the threshold between two iterations. The usage threshold count returned by the &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt;&lt;code&gt;getUsageThresholdCount()&lt;/code&gt;&lt;/a&gt; method can be used to determine if the memory usage has returned below the threshold between two polls.</source>
          <target state="translated">위의 예는 메모리 사용량이 두 반복 사이의 임계 값보다 높은 경우 메모리 사용량이 일시적으로 사용량 임계 값 아래로 떨어진 경우를 구별하지 않습니다. &lt;a href=&quot;memorypoolmxbean#getUsageThresholdCount--&quot;&gt; &lt;code&gt;getUsageThresholdCount()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 사용 임계 값 수 메소드가 는 메모리 사용이 두 폴 사이의 임계 값 아래로 리턴되었는지 판별하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11a11e7a079a4b4c5ac0f002d2763bf2a39aa9e4" translate="yes" xml:space="preserve">
          <source>The above grants access to the private Credential, &quot;a.b.Credential&quot;, belonging to a &lt;code&gt;Subject&lt;/code&gt; with at least two associated Principals: &quot;a.b.Principal&quot; with the name, &quot;duke&quot;, and &quot;c.d.Principal&quot;, with the name, &quot;dukette&quot;.</source>
          <target state="translated">위의 &lt;code&gt;Subject&lt;/code&gt; 는 주제에 속하는 개인 신임 정보 &quot;abCredential&quot;에 대한 액세스 권한을 부여합니다. 은 최소한 &quot;dPettecipal&quot;이라는 이름을 가진 &quot;abPrincipal&quot;과 &quot;dukette&quot;라는 이름을 가진 &quot;cdPrincipal&quot;을 가진 .</target>
        </trans-unit>
        <trans-unit id="d0d78bad927052e929e2c13a12936aa17618df1d" translate="yes" xml:space="preserve">
          <source>The above layout is used when the option pane's &lt;code&gt;ComponentOrientation&lt;/code&gt; property is horizontal, left-to-right. The layout will be adjusted appropriately for other orientations.</source>
          <target state="translated">위의 레이아웃은 옵션 창의 &lt;code&gt;ComponentOrientation&lt;/code&gt; 속성이 왼쪽에서 오른쪽으로 수 평일 때 사용됩니다 . 레이아웃은 다른 방향에 맞게 적절하게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="d2440a7cce344e487bff12583861535eeb47489e" translate="yes" xml:space="preserve">
          <source>The above setup of one static linker instance is often too simple. You will often have your language runtime have a concept of some kind of &quot;context class loader&quot; and you will want to create one dynamic linker per such class loader, to ensure it incorporates linkers for all other language runtimes visible to that class loader (see &lt;a href=&quot;dynamiclinkerfactory#setClassLoader(java.lang.ClassLoader)&quot;&gt;&lt;code&gt;DynamicLinkerFactory.setClassLoader(ClassLoader)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">하나의 정적 링커 인스턴스에 대한 위의 설정은 종종 너무 간단합니다. 종종 언어 런타임에 일종의 &quot;컨텍스트 클래스 로더&quot;라는 개념이 있고 해당 클래스 로더에 표시되는 다른 모든 언어 런타임에 대한 링커를 통합하기 위해 이러한 클래스 로더 당 하나의 동적 링커를 만들고 싶을 것입니다 (참조 : &lt;a href=&quot;dynamiclinkerfactory#setClassLoader(java.lang.ClassLoader)&quot;&gt; &lt;code&gt;DynamicLinkerFactory.setClassLoader(ClassLoader)&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fe88899731a3341ed49b0e76cb60624786847128" translate="yes" xml:space="preserve">
          <source>The above specifies the raw preferred width and height. The resulting preferred width is the above width + insets.left + insets.right and the resulting preferred height is the above height + insets.top + insets.bottom. Where the &lt;code&gt;Insets&lt;/code&gt; are determined from &lt;code&gt;list.getInsets()&lt;/code&gt;.</source>
          <target state="translated">위는 원시 기본 너비와 높이를 지정합니다. 결과 기본 너비는 위 너비 + insets.left + insets.right이고 결과 기본 높이는 위 높이 + insets.top + insets.bottom입니다. 를 Where &lt;code&gt;Insets&lt;/code&gt; 결정된다 &lt;code&gt;list.getInsets()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edbd434347b519de487f2abd90d51adf485fdec2" translate="yes" xml:space="preserve">
          <source>The absolute abstract pathname denoting the same file or directory as this abstract pathname</source>
          <target state="translated">이 추상 경로 이름과 동일한 파일 또는 디렉토리를 나타내는 절대 추상 경로 이름</target>
        </trans-unit>
        <trans-unit id="5dfa1ff2b58f5591841ef53f2f383cabbaed249c" translate="yes" xml:space="preserve">
          <source>The absolute base URI of this node or &lt;code&gt;null&lt;/code&gt; if the implementation wasn't able to obtain an absolute URI.</source>
          <target state="translated">이 노드의 절대 기본 URI 또는 구현이 절대 URI를 가져올 수 &lt;code&gt;null&lt;/code&gt; 경우 null 입니다.</target>
        </trans-unit>
        <trans-unit id="6a5333d7155c43688a2060915cfaa8a9ee660736" translate="yes" xml:space="preserve">
          <source>The absolute base URI of this node or &lt;code&gt;null&lt;/code&gt; if the implementation wasn't able to obtain an absolute URI. This value is computed as described in . However, when the &lt;code&gt;Document&lt;/code&gt; supports the feature &quot;HTML&quot; [&lt;a href=&quot;http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109&quot;&gt;DOM Level 2 HTML&lt;/a&gt;] , the base URI is computed using first the value of the href attribute of the HTML BASE element if any, and the value of the &lt;code&gt;documentURI&lt;/code&gt; attribute from the &lt;code&gt;Document&lt;/code&gt; interface otherwise.</source>
          <target state="translated">이 노드의 절대 기본 URI 또는 구현이 절대 URI를 얻을 수 &lt;code&gt;null&lt;/code&gt; 경우 null 입니다. 이 값은에 설명 된대로 계산됩니다. 그러나 &lt;code&gt;Document&lt;/code&gt; 가 &quot;HTML&quot;[ &lt;a href=&quot;http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109&quot;&gt;DOM Level 2 HTML&lt;/a&gt; ] 기능을 지원하는 경우 기본 URI는 먼저 HTML BASE 요소의 href 속성 값 (있는 경우)과 &lt;code&gt;Document&lt;/code&gt; 인터페이스 의 &lt;code&gt;documentURI&lt;/code&gt; 속성 값을 사용하여 계산 됩니다. 그렇지 않으면.</target>
        </trans-unit>
        <trans-unit id="86a4d232302f396d9be4d5a16a144e3820600aab" translate="yes" xml:space="preserve">
          <source>The absolute base URI of this node or &lt;code&gt;null&lt;/code&gt; if the implementation wasn't able to obtain an absolute URI. This value is computed as described in . However, when the &lt;code&gt;Document&lt;/code&gt; supports the feature &quot;HTML&quot; [&lt;a href=&quot;https://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109&quot;&gt;DOM Level 2 HTML&lt;/a&gt;] , the base URI is computed using first the value of the href attribute of the HTML BASE element if any, and the value of the &lt;code&gt;documentURI&lt;/code&gt; attribute from the &lt;code&gt;Document&lt;/code&gt; interface otherwise.</source>
          <target state="translated">이 노드의 절대 기본 URI 또는 구현이 절대 URI를 얻을 수 &lt;code&gt;null&lt;/code&gt; 경우 null 입니다. 이 값은에 설명 된대로 계산됩니다. 그러나 &lt;code&gt;Document&lt;/code&gt; 가 &quot;HTML&quot;[ &lt;a href=&quot;https://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109&quot;&gt;DOM Level 2 HTML&lt;/a&gt; ] 기능을 지원하는 경우 기본 URI는 먼저 HTML BASE 요소의 href 속성 값 (있는 경우)과 &lt;code&gt;Document&lt;/code&gt; 인터페이스 의 &lt;code&gt;documentURI&lt;/code&gt; 속성 값을 사용하여 계산 됩니다. 그렇지 않으면.</target>
        </trans-unit>
        <trans-unit id="ec2d2417f86515cab10b6adbdf408e19019363aa" translate="yes" xml:space="preserve">
          <source>The absolute path of the native library</source>
          <target state="translated">기본 라이브러리의 절대 경로</target>
        </trans-unit>
        <trans-unit id="e572ffca3dbcbc1dee7ecbdd936a165e89cf3f71" translate="yes" xml:space="preserve">
          <source>The absolute path of the native library.</source>
          <target state="translated">기본 라이브러리의 절대 경로입니다.</target>
        </trans-unit>
        <trans-unit id="96304c31818a11d31d7bb72121ee4dcd82da0c5c" translate="yes" xml:space="preserve">
          <source>The absolute pathname string denoting the same file or directory as this abstract pathname</source>
          <target state="translated">이 추상 경로명과 동일한 파일 또는 디렉토리를 나타내는 절대 경로명 문자열</target>
        </trans-unit>
        <trans-unit id="b97a547f84c84d49fdb1c0345c84aeb7ed065c63" translate="yes" xml:space="preserve">
          <source>The absolute tracking adjustment type.</source>
          <target state="translated">절대 추적 조정 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4522858a3ab2baf679fd706527b4659784b7f6e1" translate="yes" xml:space="preserve">
          <source>The abstract base of all &lt;code&gt;ExecutionControl&lt;/code&gt; exceptions.</source>
          <target state="translated">모든 &lt;code&gt;ExecutionControl&lt;/code&gt; 예외 의 추상 기반입니다 .</target>
        </trans-unit>
        <trans-unit id="e047a25c1f893d23d1a9d1506f177e2de8d081cd" translate="yes" xml:space="preserve">
          <source>The abstract base of of exceptions specific to running user code.</source>
          <target state="translated">실행중인 사용자 코드와 관련된 예외의 추상 기반입니다.</target>
        </trans-unit>
        <trans-unit id="26ceb41a43a33e3dffbfc97a7a937681a96cef0a" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;ContentHandler&lt;/code&gt; is the superclass of all classes that read an &lt;code&gt;Object&lt;/code&gt; from a &lt;code&gt;URLConnection&lt;/code&gt;.</source>
          <target state="translated">추상 클래스 &lt;code&gt;ContentHandler&lt;/code&gt; 는 &lt;code&gt;URLConnection&lt;/code&gt; 에서 &lt;code&gt;Object&lt;/code&gt; 를 읽는 모든 클래스의 수퍼 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="4dc378f79fea52885b50964fed0cc7c9d28653dd" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;Image&lt;/code&gt; is the superclass of all classes that represent graphical images.</source>
          <target state="translated">추상 클래스 &lt;code&gt;Image&lt;/code&gt; 는 그래픽 이미지를 나타내는 모든 클래스의 수퍼 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="cbd3495b1f0ecafb30b239c35572b409957c57d3" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;Image&lt;/code&gt; is the superclass of all classes that represent graphical images. The image must be obtained in a platform-specific manner.</source>
          <target state="translated">추상 클래스 &lt;code&gt;Image&lt;/code&gt; 는 그래픽 이미지를 나타내는 모든 클래스의 수퍼 클래스입니다. 이미지는 플랫폼 별 방식으로 얻어야합니다.</target>
        </trans-unit>
        <trans-unit id="01c4c08ef556b021a175aa3d913b1a909dfbc1f0" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;MenuComponent&lt;/code&gt; is the superclass of all menu-related components.</source>
          <target state="translated">추상 클래스 &lt;code&gt;MenuComponent&lt;/code&gt; 는 모든 메뉴 관련 구성 요소의 수퍼 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="2e35378e49adb26abdae09f4fcaa6182e223f6ee" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;MenuComponent&lt;/code&gt; is the superclass of all menu-related components. In this respect, the class &lt;code&gt;MenuComponent&lt;/code&gt; is analogous to the abstract superclass &lt;code&gt;Component&lt;/code&gt; for AWT components.</source>
          <target state="translated">추상 클래스 &lt;code&gt;MenuComponent&lt;/code&gt; 는 모든 메뉴 관련 구성 요소의 수퍼 클래스입니다. 이 점에서 &lt;code&gt;MenuComponent&lt;/code&gt; 클래스 는 AWT 구성 &lt;code&gt;Component&lt;/code&gt; 대한 추상 수퍼 클래스 Component 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="65c203cead129ce8a815a0aa0bfbe863e0adcb15" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;Number&lt;/code&gt; is the superclass of platform classes representing numeric values that are convertible to the primitive types &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;
 int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">추상 클래스 &lt;code&gt;Number&lt;/code&gt; 는 기본 유형 인 &lt;code&gt;byte&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt; int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; 및 &lt;code&gt;short&lt;/code&gt; 로 변환 할 수있는 숫자 값을 나타내는 플랫폼 클래스의 수퍼 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="803e4e52f44b53b0d80594aa223ca7c56e1fe6d9" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;Number&lt;/code&gt; is the superclass of platform classes representing numeric values that are convertible to the primitive types &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;
 int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;short&lt;/code&gt;. The specific semantics of the conversion from the numeric value of a particular &lt;code&gt;Number&lt;/code&gt; implementation to a given primitive type is defined by the &lt;code&gt;Number&lt;/code&gt; implementation in question. For platform classes, the conversion is often analogous to a narrowing primitive conversion or a widening primitive conversion as defined in</source>
          <target state="translated">추상 클래스 &lt;code&gt;Number&lt;/code&gt; 는 기본 유형 인 &lt;code&gt;byte&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt; int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; 및 &lt;code&gt;short&lt;/code&gt; 로 변환 할 수있는 숫자 값을 나타내는 플랫폼 클래스의 수퍼 클래스입니다 . 특정 &lt;code&gt;Number&lt;/code&gt; 구현 의 숫자 값 에서 주어진 기본 유형으로 변환하는 특정 의미는 해당 &lt;code&gt;Number&lt;/code&gt; 구현에 의해 정의됩니다 . 플랫폼 클래스의 경우 변환은 종종 좁아지는 기본 변환 또는 확장되는 기본 변환과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="ef4fe4e3d9f2f3d537889773b4af854337477934" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;Number&lt;/code&gt; is the superclass of platform classes representing numeric values that are convertible to the primitive types &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">추상 클래스 &lt;code&gt;Number&lt;/code&gt; 는 원시 형 &lt;code&gt;byte&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; 및 &lt;code&gt;short&lt;/code&gt; 로 변환 할 수있는 숫자 값을 나타내는 플랫폼 클래스의 수퍼 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="3cef21ebdb6ade078e43294abd142a0407b82a51" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;Number&lt;/code&gt; is the superclass of platform classes representing numeric values that are convertible to the primitive types &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;short&lt;/code&gt;. The specific semantics of the conversion from the numeric value of a particular &lt;code&gt;Number&lt;/code&gt; implementation to a given primitive type is defined by the &lt;code&gt;Number&lt;/code&gt; implementation in question. For platform classes, the conversion is often analogous to a narrowing primitive conversion or a widening primitive conversion as defining in</source>
          <target state="translated">추상 클래스 &lt;code&gt;Number&lt;/code&gt; 는 원시 형 &lt;code&gt;byte&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; 및 &lt;code&gt;short&lt;/code&gt; 로 변환 할 수있는 숫자 값을 나타내는 플랫폼 클래스의 수퍼 클래스입니다 . 특정 &lt;code&gt;Number&lt;/code&gt; 구현 의 숫자 값 에서 지정된 기본 유형으로 변환하는 특정 시맨틱은 해당 &lt;code&gt;Number&lt;/code&gt; 구현에 의해 정의됩니다 . 플랫폼 클래스의 경우 변환은 종종 축소 기본 변환 또는 확장 기본 변환과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="7471b19f604dcfd018473768425dd3d88567b855" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;SocketImpl&lt;/code&gt; is a common superclass of all classes that actually implement sockets.</source>
          <target state="translated">추상 클래스 &lt;code&gt;SocketImpl&lt;/code&gt; 은 실제로 소켓을 구현하는 모든 클래스의 공통 수퍼 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="61d7aa3ed568898a90d798649c3d36186093daf9" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;SocketImpl&lt;/code&gt; is a common superclass of all classes that actually implement sockets. It is used to create both client and server sockets.</source>
          <target state="translated">추상 클래스 &lt;code&gt;SocketImpl&lt;/code&gt; 은 실제로 소켓을 구현하는 모든 클래스의 공통 수퍼 클래스입니다. 클라이언트와 서버 소켓을 모두 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="456bb9271567243e4cd050a468dafa3e449e2d3b" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;URLConnection&lt;/code&gt; is the superclass of all classes that represent a communications link between the application and a URL.</source>
          <target state="translated">추상 클래스 &lt;code&gt;URLConnection&lt;/code&gt; 은 애플리케이션과 URL 간의 통신 링크를 나타내는 모든 클래스의 수퍼 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="c20c6696d9f30f916aba7d95067c78a31c054b1e" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;URLConnection&lt;/code&gt; is the superclass of all classes that represent a communications link between the application and a URL. Instances of this class can be used both to read from and to write to the resource referenced by the URL.</source>
          <target state="translated">추상 클래스 &lt;code&gt;URLConnection&lt;/code&gt; 은 애플리케이션과 URL 간의 통신 링크를 나타내는 모든 클래스의 수퍼 클래스입니다. 이 클래스의 인스턴스는 URL에서 참조하는 리소스를 읽고 쓰는 데 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76cea7d35ffe4da75cc712cb986a9f4a981aee90" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;URLConnection&lt;/code&gt; is the superclass of all classes that represent a communications link between the application and a URL. Instances of this class can be used both to read from and to write to the resource referenced by the URL. In general, creating a connection to a URL is a multistep process:</source>
          <target state="translated">추상 클래스 &lt;code&gt;URLConnection&lt;/code&gt; 은 애플리케이션과 URL 간의 통신 링크를 나타내는 모든 클래스의 수퍼 클래스입니다. 이 클래스의 인스턴스는 URL이 참조하는 리소스에서 읽고 쓸 수 있습니다. 일반적으로 URL 연결은 여러 단계로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="30ca6e222c37a7c8793230b3a0c7767b66c517e7" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;URLStreamHandler&lt;/code&gt; is the common superclass for all stream protocol handlers.</source>
          <target state="translated">추상 클래스 &lt;code&gt;URLStreamHandler&lt;/code&gt; 는 모든 스트림 프로토콜 핸들러의 공통 수퍼 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="d07377ac8882b20ce73ef6e587a0c0d99b110d29" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;code&gt;URLStreamHandler&lt;/code&gt; is the common superclass for all stream protocol handlers. A stream protocol handler knows how to make a connection for a particular protocol type, such as &lt;code&gt;http&lt;/code&gt; or &lt;code&gt;https&lt;/code&gt;.</source>
          <target state="translated">추상 클래스 &lt;code&gt;URLStreamHandler&lt;/code&gt; 는 모든 스트림 프로토콜 핸들러의 공통 수퍼 클래스입니다. 스트림 프로토콜 핸들러는 &lt;code&gt;http&lt;/code&gt; 또는 &lt;code&gt;https&lt;/code&gt; 와 같은 특정 프로토콜 유형에 연결하는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cc8e5427b10107c4b13456b30226c7cd3468de3" translate="yes" xml:space="preserve">
          <source>The abstract class from which all persistence delegates descend. Your subclass should use its knowledge of the bean's type to provide whatever &lt;code&gt;Statement&lt;/code&gt;s and &lt;code&gt;Expression&lt;/code&gt;s are necessary to create the bean and restore its state.</source>
          <target state="translated">모든 퍼시스턴스 델리게이트가 내려 오는 추상 클래스. 서브 클래스는 Bean의 유형에 대한 지식 을 사용하여 Bean을 작성하고 상태를 복원하는 데 필요한 &lt;code&gt;Statement&lt;/code&gt; 및 &lt;code&gt;Expression&lt;/code&gt; 을 제공 해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ec621176f89bf2f0489f0d51a90802fcc67d044" translate="yes" xml:space="preserve">
          <source>The abstract definition for the data model that provides a &lt;code&gt;List&lt;/code&gt; with its contents.</source>
          <target state="translated">콘텐츠와 함께 &lt;code&gt;List&lt;/code&gt; 를 제공하는 데이터 모델에 대한 추상적 인 정의입니다 .</target>
        </trans-unit>
        <trans-unit id="6dc2a8c084fa084c4968e651ae19cc9b52c0ec9e" translate="yes" xml:space="preserve">
          <source>The abstract description consists of three fields: &lt;code&gt;selected&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, and &lt;code&gt;variation&lt;/code&gt;. &lt;code&gt;selected&lt;/code&gt; indicates whether the text range is the one that the input method is currently working on, for example, the segment for which conversion candidates are currently shown in a menu. &lt;code&gt;state&lt;/code&gt; represents the conversion state. State values are defined by the input method framework and should be distinguished in all mappings from abstract to concrete styles. Currently defined state values are raw (unconverted) and converted. These state values are recommended for use before and after the main conversion step of text composition, say, before and after kana-&amp;gt;kanji or pinyin-&amp;gt;hanzi conversion. The &lt;code&gt;variation&lt;/code&gt; field allows input methods to express additional information about the conversion results.</source>
          <target state="translated">추상적 인 설명은 &lt;code&gt;selected&lt;/code&gt; , &lt;code&gt;state&lt;/code&gt; 및 &lt;code&gt;variation&lt;/code&gt; 의 세 가지 필드로 구성됩니다 . &lt;code&gt;selected&lt;/code&gt; 는 텍스트 범위가 입력 방법이 현재 작업중인 범위인지 여부를 나타냅니다 (예 : 현재 메뉴에 전환 후보가 표시되는 세그먼트). &lt;code&gt;state&lt;/code&gt; 는 변환 상태를 나타냅니다. 상태 값은 입력 방법 프레임 워크에 의해 정의되며 추상에서 구체적인 스타일까지의 모든 매핑에서 구별되어야합니다. 현재 정의 된 상태 값은 원시 (변환되지 않음)이며 변환됩니다. 이러한 상태 값은 가나-&amp;gt; 한자 또는 병음-&amp;gt; 한자 변환 전후와 같이 텍스트 작성의 주요 변환 단계 전후에 사용하는 것이 좋습니다. &lt;code&gt;variation&lt;/code&gt; 필드를 사용하면 입력 방법이 변환 결과에 대한 추가 정보를 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e33bef79f2b898deb8cd8c8cf089745eb2108b2c" translate="yes" xml:space="preserve">
          <source>The abstract pathname of the parent directory named by this abstract pathname, or &lt;code&gt;null&lt;/code&gt; if this pathname does not name a parent</source>
          <target state="translated">이 추상 패스 명이 가리키는 부모 디렉토리의 추상 패스 명.이 패스 명이 부모를 지정 하지 않는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80237c2613dc82633718c694ff63ccd5e8f49761" translate="yes" xml:space="preserve">
          <source>The abstract syntax classes are independent of the attributes that use them. In fact, applications that have nothing to do with printing can use the abstract syntax classes. Although most of the standard attribute classes extend one of the abstract syntax classes, no attribute class is required to extend one of these classes. The abstract syntax classes merely provide a convenient implementation that can be shared by many attribute classes.</source>
          <target state="translated">추상 구문 클래스는이를 사용하는 속성과 무관합니다. 실제로 인쇄와 관련이없는 응용 프로그램은 추상 구문 클래스를 사용할 수 있습니다. 대부분의 표준 속성 클래스는 추상 구문 클래스 중 하나를 확장하지만 이러한 클래스 중 하나를 확장하는 데 속성 클래스는 필요하지 않습니다. 추상 구문 클래스는 많은 속성 클래스가 공유 할 수있는 편리한 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="92e9e2194307a587ee2809534fb875cd926aaad1" translate="yes" xml:space="preserve">
          <source>The accelerator font.</source>
          <target state="translated">가속기 글꼴입니다.</target>
        </trans-unit>
        <trans-unit id="bb87762d78e5184f59d7ec87c95bb4034300b5a1" translate="yes" xml:space="preserve">
          <source>The accelerator key is platform-dependent and may be obtained via &lt;a href=&quot;toolkit#getMenuShortcutKeyMaskEx()&quot;&gt;&lt;code&gt;Toolkit.getMenuShortcutKeyMaskEx()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">액셀러레이터 키는 플랫폼에 따라 다르며 &lt;a href=&quot;toolkit#getMenuShortcutKeyMaskEx()&quot;&gt; &lt;code&gt;Toolkit.getMenuShortcutKeyMaskEx()&lt;/code&gt; &lt;/a&gt; 를 통해 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5595dab62172a7649640a0f8e6e97935ad5079a2" translate="yes" xml:space="preserve">
          <source>The acceptor will be an unbound acceptor and it can act as any principal as long that principal has keys in the keytab.</source>
          <target state="translated">수락자는 바인딩되지 않은 수락 자이며 해당 주체가 키 탭에 키를 가지고있는 한 어떤 주체로도 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53a1270b928fa269be35cd6184d6f0e41a1d9e8c" translate="yes" xml:space="preserve">
          <source>The access mode type's parameter types will consist of a prefix that is the coordinate types of this VarHandle followed by further types as defined by the access mode method. The access mode type's return type is defined by the return type of the access mode method.</source>
          <target state="translated">액세스 모드 유형의 매개 변수 유형은이 VarHandle의 좌표 유형 인 접두사 다음에 액세스 모드 메소드에 정의 된 추가 유형으로 구성됩니다. 액세스 모드 유형의 리턴 유형은 액세스 모드 메소드의 리턴 유형에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="89942dab9dde8879bbc845c729f98929069191a8" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#compareAndExchange(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.compareAndExchange&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메서드 &lt;a href=&quot;varhandle#compareAndExchange(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.compareAndExchange&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정되는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="a8906e0b571c63ed09786b20dd7874f0c6021fc4" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#compareAndExchangeAcquire(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.compareAndExchangeAcquire&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메서드 &lt;a href=&quot;varhandle#compareAndExchangeAcquire(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.compareAndExchangeAcquire&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정되는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="b39e559e3792cd4f745907191c494bd731bae526" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#compareAndExchangeRelease(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.compareAndExchangeRelease&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메서드 &lt;a href=&quot;varhandle#compareAndExchangeRelease(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.compareAndExchangeRelease&lt;/code&gt; &lt;/a&gt; 에서 액세스를 지정하는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="f93091a340be6373d2e3e97a8a7b92e27a2d19b3" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#compareAndSet(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.compareAndSet&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메서드 &lt;a href=&quot;varhandle#compareAndSet(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.compareAndSet&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정되는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="65656db6c6740de37653226a4b1bf63d7ab1bd61" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#get(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.get&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#get(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.get&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정되는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="112b9a5a830f1494039e7b377605a9af3b69ebfb" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAcquire(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAcquire&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getAcquire(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAcquire&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정되는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="81c4ca0b2a114b2d2482b5f541df66a8279e9bea" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndAdd(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndAdd&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메서드 &lt;a href=&quot;varhandle#getAndAdd(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndAdd&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정되는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="a4794b9aa0f0704a6bfbf1f4b7425bcb87a17501" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndAddAcquire(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndAddAcquire&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메서드 &lt;a href=&quot;varhandle#getAndAddAcquire(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndAddAcquire&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="6ad5e992cd4d7a5b5984079fa52f13d67669ac03" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndAddRelease(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndAddRelease&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getAndAddRelease(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndAddRelease&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="91ded8748dd3d3720672fa5d530144e7e727f27f" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndBitwiseAnd(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndBitwiseAnd&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메서드 &lt;a href=&quot;varhandle#getAndBitwiseAnd(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndBitwiseAnd&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정되는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="96d6c169f6d2ea9c378bf8f7cc94432b59afdd4c" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndBitwiseAndAcquire(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndBitwiseAndAcquire&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getAndBitwiseAndAcquire(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndBitwiseAndAcquire&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="463fc71756be8a706bfd12c38d70a98afbdf444a" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndBitwiseAndRelease(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndBitwiseAndRelease&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getAndBitwiseAndRelease(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndBitwiseAndRelease&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="3d56affeca23d68ba13cc60a354981cb8830f108" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndBitwiseOr(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndBitwiseOr&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getAndBitwiseOr(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndBitwiseOr&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정되는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="f64228b6d67bb648ba0773294497503b992af034" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndBitwiseOrAcquire(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndBitwiseOrAcquire&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getAndBitwiseOrAcquire(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndBitwiseOrAcquire&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="78c62f5ac54490b40af6542fe2ef022cd14b6354" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndBitwiseOrRelease(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndBitwiseOrRelease&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getAndBitwiseOrRelease(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndBitwiseOrRelease&lt;/code&gt; &lt;/a&gt; 에서 액세스를 지정하는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="d0a4712e907db915c1d22dccd96bde099e9296f0" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndBitwiseXor(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndBitwiseXor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getAndBitwiseXor(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndBitwiseXor&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="01f58a3fa9632e770d2d77cec576875b11c3ea44" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndBitwiseXorAcquire(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndBitwiseXorAcquire&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getAndBitwiseXorAcquire(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndBitwiseXorAcquire&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="877bb0085f5211c20d1a1eae202d18df3a873ea0" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndBitwiseXorRelease(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndBitwiseXorRelease&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getAndBitwiseXorRelease(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndBitwiseXorRelease&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="7b47aa9d37a1f91bacfdaf216fd018cc8c4623c7" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndSet(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndSet&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getAndSet(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndSet&lt;/code&gt; &lt;/a&gt; 에서 액세스를 지정하는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="76ed31fce5d3e399e0fa72c84cc6be1c1b2c1c4a" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndSetAcquire(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndSetAcquire&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getAndSetAcquire(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndSetAcquire&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정되는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="9d11bf019ffaf8602567deb90ec9205f4bcbe717" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getAndSetRelease(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getAndSetRelease&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getAndSetRelease(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getAndSetRelease&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="5b9a7aeb37379aa01e007c481501e4cdad8c266e" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getOpaque(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getOpaque&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getOpaque(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getOpaque&lt;/code&gt; &lt;/a&gt; 에서 액세스를 지정하는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="c9590a346f908624c40de7a17df78e4121eb5264" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#getVolatile(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.getVolatile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#getVolatile(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.getVolatile&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="0b7f51b6aebb43a9e08bb75607268e4fca6e31c4" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#set(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.set&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메서드 &lt;a href=&quot;varhandle#set(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.set&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="c23cb01f941f5b600a4f48fb67215ce77c1973a1" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#setOpaque(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.setOpaque&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#setOpaque(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.setOpaque&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정되는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="76234d63e81658a05d75e065cc4996bf55be363f" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#setRelease(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.setRelease&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메서드 &lt;a href=&quot;varhandle#setRelease(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.setRelease&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="4356cc4abbdc6a9387706364c67858f69c26f55a" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#setVolatile(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.setVolatile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#setVolatile(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.setVolatile&lt;/code&gt; &lt;/a&gt; 로 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="5b026cd13df336d4cdfd528a2a818118518057f5" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#weakCompareAndSet(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.weakCompareAndSet&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메서드 &lt;a href=&quot;varhandle#weakCompareAndSet(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.weakCompareAndSet&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정되는 액세스 모드</target>
        </trans-unit>
        <trans-unit id="0c3ff7be38123f63e27cd161d584e9a62a9e806d" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#weakCompareAndSetAcquire(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.weakCompareAndSetAcquire&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메서드 &lt;a href=&quot;varhandle#weakCompareAndSetAcquire(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.weakCompareAndSetAcquire&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="5a88b41196b0528b391c257c12732c59161355a0" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#weakCompareAndSetPlain(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.weakCompareAndSetPlain&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메서드 &lt;a href=&quot;varhandle#weakCompareAndSetPlain(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.weakCompareAndSetPlain&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="90eea3e4a9c690b47b117882779f2fb01dd8b5e6" translate="yes" xml:space="preserve">
          <source>The access mode whose access is specified by the corresponding method &lt;a href=&quot;varhandle#weakCompareAndSetRelease(java.lang.Object...)&quot;&gt;&lt;code&gt;VarHandle.weakCompareAndSetRelease&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">해당 메소드 &lt;a href=&quot;varhandle#weakCompareAndSetRelease(java.lang.Object...)&quot;&gt; &lt;code&gt;VarHandle.weakCompareAndSetRelease&lt;/code&gt; 에&lt;/a&gt; 의해 액세스가 지정된 액세스 모드</target>
        </trans-unit>
        <trans-unit id="98f9919547d9e7324fbeace7ddfba4ce592d0afd" translate="yes" xml:space="preserve">
          <source>The access modifiers are placed in canonical order as specified by &quot;The Java Language Specification&quot;. This is &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt; first, and then other modifiers in the following order: &lt;code&gt;abstract&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;final&lt;/code&gt;, &lt;code&gt;synchronized&lt;/code&gt;, &lt;code&gt;native&lt;/code&gt;, &lt;code&gt;strictfp&lt;/code&gt;.</source>
          <target state="translated">액세스 수정자는 &quot;The Java Language Specification&quot;에 지정된대로 정식 순서로 배치됩니다. 이것은 &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; 또는 &lt;code&gt;private&lt;/code&gt; 이며, 다음의 순서로 &lt;code&gt;abstract&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;static&lt;/code&gt; , &lt;code&gt;final&lt;/code&gt; , &lt;code&gt;synchronized&lt;/code&gt; , &lt;code&gt;native&lt;/code&gt; , &lt;code&gt;strictfp&lt;/code&gt; 순서로 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="be0ae7123e469c04cedfc5880f6ac421c3288f41" translate="yes" xml:space="preserve">
          <source>The accesses permitted to a given lookup object may be limited, according to its set of &lt;a href=&quot;#lookupModes()&quot;&gt;&lt;code&gt;lookupModes&lt;/code&gt;&lt;/a&gt;, to a subset of members normally accessible to the lookup class. For example, the &lt;a href=&quot;methodhandles#publicLookup()&quot;&gt;&lt;code&gt;publicLookup&lt;/code&gt;&lt;/a&gt; method produces a lookup object which is only allowed to access public members in public classes of exported packages. The caller sensitive method &lt;a href=&quot;methodhandles#lookup()&quot;&gt;&lt;code&gt;lookup&lt;/code&gt;&lt;/a&gt; produces a lookup object with full capabilities relative to its caller class, to emulate all supported bytecode behaviors. Also, the &lt;a href=&quot;#in(java.lang.Class)&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; method may produce a lookup object with fewer access modes than the original lookup object.</source>
          <target state="translated">주어진 조회 객체에 허용되는 액세스는 &lt;a href=&quot;#lookupModes()&quot;&gt; &lt;code&gt;lookupModes&lt;/code&gt; &lt;/a&gt; 집합에 따라 조회 클래스에 일반적으로 액세스 할 수있는 멤버의 하위 집합 으로 제한 될 수 있습니다 . 예를 들어 &lt;a href=&quot;methodhandles#publicLookup()&quot;&gt; &lt;code&gt;publicLookup&lt;/code&gt; &lt;/a&gt; 메서드는 내 보낸 패키지의 공용 클래스에있는 공용 멤버에만 액세스 할 수있는 조회 개체를 생성합니다. 호출자 감지 메서드 &lt;a href=&quot;methodhandles#lookup()&quot;&gt; &lt;code&gt;lookup&lt;/code&gt; &lt;/a&gt; 는 지원되는 모든 바이트 코드 동작을 에뮬레이트하기 위해 호출자 클래스와 관련된 모든 기능을 가진 조회 개체를 생성합니다. 또한 &lt;a href=&quot;#in(java.lang.Class)&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; &lt;/a&gt; 메서드는 원래 조회 개체보다 액세스 모드가 더 적은 조회 개체를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df151d45df66db7ce016a4b7c1366a40643ea380" translate="yes" xml:space="preserve">
          <source>The accesses permitted to a given lookup object may be limited, according to its set of &lt;a href=&quot;methodhandles.lookup#lookupModes--&quot;&gt;&lt;code&gt;lookupModes&lt;/code&gt;&lt;/a&gt;, to a subset of members normally accessible to the lookup class. For example, the &lt;a href=&quot;methodhandles#publicLookup--&quot;&gt;&lt;code&gt;publicLookup&lt;/code&gt;&lt;/a&gt; method produces a lookup object which is only allowed to access public members in public classes. The caller sensitive method &lt;a href=&quot;methodhandles#lookup--&quot;&gt;&lt;code&gt;lookup&lt;/code&gt;&lt;/a&gt; produces a lookup object with full capabilities relative to its caller class, to emulate all supported bytecode behaviors. Also, the &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt;&lt;code&gt;Lookup.in&lt;/code&gt;&lt;/a&gt; method may produce a lookup object with fewer access modes than the original lookup object.</source>
          <target state="translated">지정된 조회 객체에 허용 된 액세스는 해당 &lt;a href=&quot;methodhandles.lookup#lookupModes--&quot;&gt; &lt;code&gt;lookupModes&lt;/code&gt; &lt;/a&gt; 세트에 따라 일반적으로 조회 클래스에 액세스 할 수있는 멤버의 서브 세트 로 제한 될 수 있습니다 . 예를 들어 &lt;a href=&quot;methodhandles#publicLookup--&quot;&gt; &lt;code&gt;publicLookup&lt;/code&gt; &lt;/a&gt; 메서드는 공용 클래스의 공용 멤버에만 액세스 할 수있는 조회 개체를 생성합니다. 호출자 구분 메소드 &lt;a href=&quot;methodhandles#lookup--&quot;&gt; &lt;code&gt;lookup&lt;/code&gt; &lt;/a&gt; 은 호출자 클래스와 관련된 모든 기능을 갖춘 검색 오브젝트를 생성하여 지원되는 모든 바이트 코드 동작을 에뮬레이트합니다. 또한 &lt;a href=&quot;methodhandles.lookup#in-java.lang.Class-&quot;&gt; &lt;code&gt;Lookup.in&lt;/code&gt; &lt;/a&gt; 메서드는 원래 조회 개체보다 액세스 모드가 적은 조회 개체를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76788cadfceaff47c7fb9767823398f68ffc9874" translate="yes" xml:space="preserve">
          <source>The accessible context property.</source>
          <target state="translated">액세스 가능한 컨텍스트 속성입니다.</target>
        </trans-unit>
        <trans-unit id="7084e6fbe3e20e10bd23419215103055dd31f260" translate="yes" xml:space="preserve">
          <source>The accessible context.</source>
          <target state="translated">액세스 가능한 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="75db9a371728ce144ac76511e116beb515e41303" translate="yes" xml:space="preserve">
          <source>The accessible parent of this object.</source>
          <target state="translated">이 개체의 액세스 가능한 부모입니다.</target>
        </trans-unit>
        <trans-unit id="f06cdbab14ab99f1592a1624e691fc0e2691e805" translate="yes" xml:space="preserve">
          <source>The accumulated elapsed time that the thread has blocked for synchronization or waited for notification since &lt;a href=&quot;threadmxbean#setThreadContentionMonitoringEnabled(boolean)&quot;&gt;&lt;code&gt;thread contention monitoring&lt;/code&gt;&lt;/a&gt; was enabled. Some Java virtual machine implementation may not support this. The &lt;a href=&quot;threadmxbean#isThreadContentionMonitoringSupported()&quot;&gt;&lt;code&gt;ThreadMXBean.isThreadContentionMonitoringSupported()&lt;/code&gt;&lt;/a&gt; method can be used to determine if a Java virtual machine supports this.</source>
          <target state="translated">&lt;a href=&quot;threadmxbean#setThreadContentionMonitoringEnabled(boolean)&quot;&gt; &lt;code&gt;thread contention monitoring&lt;/code&gt; &lt;/a&gt; 이 활성화 된 이후 스레드 가 동기화를 차단하거나 알림을 기다린 누적 경과 시간입니다 . 일부 Java 가상 머신 구현은이를 지원하지 않을 수 있습니다. &lt;a href=&quot;threadmxbean#isThreadContentionMonitoringSupported()&quot;&gt; &lt;code&gt;ThreadMXBean.isThreadContentionMonitoringSupported()&lt;/code&gt; &lt;/a&gt; 메소드는 자바 가상 머신이 지원하는지 결정하기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="336019016c9cfc89449e3197f835520dcb785799" translate="yes" xml:space="preserve">
          <source>The accumulated elapsed time that the thread has blocked for synchronization or waited for notification since &lt;a href=&quot;threadmxbean#setThreadContentionMonitoringEnabled-boolean-&quot;&gt;&lt;code&gt;thread contention monitoring&lt;/code&gt;&lt;/a&gt; was enabled. Some Java virtual machine implementation may not support this. The &lt;a href=&quot;threadmxbean#isThreadContentionMonitoringSupported--&quot;&gt;&lt;code&gt;ThreadMXBean.isThreadContentionMonitoringSupported()&lt;/code&gt;&lt;/a&gt; method can be used to determine if a Java virtual machine supports this.</source>
          <target state="translated">&lt;a href=&quot;threadmxbean#setThreadContentionMonitoringEnabled-boolean-&quot;&gt; &lt;code&gt;thread contention monitoring&lt;/code&gt; &lt;/a&gt; 이 활성화 된 후 스레드가 동기화를 차단하거나 알림을 기다린 누적 경과 시간입니다 . 일부 Java 가상 머신 구현은이를 지원하지 않을 수 있습니다. &lt;a href=&quot;threadmxbean#isThreadContentionMonitoringSupported--&quot;&gt; &lt;code&gt;ThreadMXBean.isThreadContentionMonitoringSupported()&lt;/code&gt; &lt;/a&gt; 메소드는 자바 가상 머신이 지원하는지 결정하기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="d9ac1702947023ef1d0eeb84fb64f986c75a794a" translate="yes" xml:space="preserve">
          <source>The accuracy of the results depends on the manner in which pixels are stored in the destination. An image format that provides at least 8 bits of storage per color and alpha component is at least adequate for use as a destination for a sequence of a few to a dozen compositing operations. An image format with fewer than 8 bits of storage per component is of limited use for just one or two compositing operations before the rounding errors dominate the results. An image format that does not separately store color components is not a good candidate for any type of translucent blending. For example, &lt;code&gt;BufferedImage.TYPE_BYTE_INDEXED&lt;/code&gt; should not be used as a destination for a blending operation because every operation can introduce large errors, due to the need to choose a pixel from a limited palette to match the results of the blending equations.</source>
          <target state="translated">결과의 정확도는 픽셀이 대상에 저장되는 방식에 따라 다릅니다. 색상 및 알파 구성 요소 당 최소 8 비트의 저장 공간을 제공하는 이미지 형식은 적어도 몇 개에서 수십 개의 합성 작업 시퀀스의 대상으로 사용하기에 적합합니다. 구성 요소 당 저장 공간이 8 비트 미만인 이미지 형식은 반올림 오류가 결과를 지배하기 전에 한두 가지 합성 작업에 제한적으로 사용됩니다. 색상 구성 요소를 별도로 저장하지 않는 이미지 형식은 모든 유형의 반투명 블렌딩에 적합하지 않습니다. 예 : &lt;code&gt;BufferedImage.TYPE_BYTE_INDEXED&lt;/code&gt; 혼합 방정식의 결과와 일치하도록 제한된 팔레트에서 픽셀을 선택해야하기 때문에 모든 작업에 큰 오류가 발생할 수 있으므로 혼합 작업의 대상으로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="af1a87a952cd530fa175899a2c113a780239cff9" translate="yes" xml:space="preserve">
          <source>The action command string fired by the button.</source>
          <target state="translated">버튼에 의해 실행 된 작업 명령 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="65c1d5cdd4b632aab8e5755d90f09a8b2a2a15d0" translate="yes" xml:space="preserve">
          <source>The action is returned by &lt;a href=&quot;#getActions()&quot;&gt;&lt;code&gt;getActions()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">조치는 &lt;a href=&quot;#getActions()&quot;&gt; &lt;code&gt;getActions()&lt;/code&gt; &lt;/a&gt; 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c3240d64320b1f694103cbb6fbd69517a656609" translate="yes" xml:space="preserve">
          <source>The action is returned by &lt;a href=&quot;mbeanpermission#getActions--&quot;&gt;&lt;code&gt;getActions()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">조치는 &lt;a href=&quot;mbeanpermission#getActions--&quot;&gt; &lt;code&gt;getActions()&lt;/code&gt; &lt;/a&gt; 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="2204717897733b758c56c1617cf93b7214027f2a" translate="yes" xml:space="preserve">
          <source>The action of applying &lt;code&gt;f&lt;/code&gt; for one element &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt; the action of applying &lt;code&gt;f&lt;/code&gt; for subsequent elements. For any given element the action may be performed in whatever thread the library chooses.</source>
          <target state="translated">인가하는 동작 &lt;code&gt;f&lt;/code&gt; 하나 개의 요소가 &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;발생-전에&lt;/i&gt;&lt;/a&gt; 도포하는 동작 &lt;code&gt;f&lt;/code&gt; 후속 요소. 주어진 요소에 대해 라이브러리가 선택한 스레드에서 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e16b3441f27b6dc2076bfcb1f15f3cdd5cce643a" translate="yes" xml:space="preserve">
          <source>The action of applying the &lt;code&gt;hasNext&lt;/code&gt; predicate to an element &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt; the action of applying the &lt;code&gt;next&lt;/code&gt; function to that element. The action of applying the &lt;code&gt;next&lt;/code&gt; function for one element</source>
          <target state="translated">도포의 작용 &lt;code&gt;hasNext&lt;/code&gt; 의 요소에 술어가 &lt;a href=&quot;../concurrent/package-summary#MemoryVisibility&quot;&gt;&lt;i&gt;발생-전에&lt;/i&gt;&lt;/a&gt; , 도포의 작용 &lt;code&gt;next&lt;/code&gt; 해당 요소로 기능한다. 한 요소에 &lt;code&gt;next&lt;/code&gt; 기능을 적용하는 동작</target>
        </trans-unit>
        <trans-unit id="3d1fbd4606181f922e816928b698ac0a5b50b96c" translate="yes" xml:space="preserve">
          <source>The action performed by the garbage collector.</source>
          <target state="translated">가비지 수집기가 수행하는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="fa53698de684065668ab67c1cd5cf7f587771eef" translate="yes" xml:space="preserve">
          <source>The action string (inherited from Permission) is unused. Thus, BasicPermission is commonly used as the base class for &quot;named&quot; permissions (ones that contain a name but no actions list; you either have the named permission or you don't.) Subclasses may implement actions on top of BasicPermission, if desired.</source>
          <target state="translated">Permission에서 상속 된 작업 문자열이 사용되지 않습니다. 따라서 BasicPermission은 일반적으로 &quot;명명 된&quot;권한 (이름을 포함하지만 조치 목록이없는 것, 명명 된 권한이 있거나없는 것)에 대한 기본 클래스로 사용됩니다. 서브 클래스는 원하는 경우 BasicPermission의 위에 조치를 구현할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="b89f2a92f81a09e2b5a3fdf7ab6a827e43f7b72e" translate="yes" xml:space="preserve">
          <source>The action that is executed by default if a &lt;em&gt;key typed event&lt;/em&gt; is received and there is no keymap entry.</source>
          <target state="translated">&lt;em&gt;키 입력 이벤트&lt;/em&gt; 가 수신되고 키맵 항목이없는 경우 기본적으로 실행되는 조치입니다 .</target>
        </trans-unit>
        <trans-unit id="cd0e7ff53feb35bceca55a7a02ccc2eec9bd9558" translate="yes" xml:space="preserve">
          <source>The action that is executed by default if a &lt;em&gt;key typed event&lt;/em&gt; is received and there is no keymap entry. There is a variation across different VM's in what gets sent as a &lt;em&gt;key typed&lt;/em&gt; event, and this action tries to filter out the undesired events. This filters the control characters and those with the ALT modifier. It allows Control-Alt sequences through as these form legitimate unicode characters on some PC keyboards.</source>
          <target state="translated">&lt;em&gt;키 입력 이벤트&lt;/em&gt; 가 수신되고 키맵 항목이없는 경우 기본적으로 실행되는 조치입니다 . &lt;em&gt;키 입력&lt;/em&gt; 이벤트 로 전송되는 내용에는 VM마다 차이가 있으며이 작업은 원하지 않는 이벤트를 필터링하려고 시도합니다. 이렇게하면 제어 문자와 ALT 수정자가있는 문자가 필터링됩니다. 일부 PC 키보드에서 합법적 인 유니 코드 문자를 형성하므로 Control-Alt 시퀀스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a391d8169ef81029e091e136d4c09fc86d81e0fb" translate="yes" xml:space="preserve">
          <source>The action to be performed by this timer task.</source>
          <target state="translated">이 타이머 작업에서 수행 할 작업입니다.</target>
        </trans-unit>
        <trans-unit id="820fbea1c0f1ce22dab8033446b99a734da5a8ae" translate="yes" xml:space="preserve">
          <source>The action will be invoked only when the keystroke occurs while the component has the focus.</source>
          <target state="translated">작업은 구성 요소에 포커스가있는 동안 키 입력이 발생하는 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b15fba696d103d0335755074a43a4fe901eaa5db" translate="yes" xml:space="preserve">
          <source>The action will be invoked when the keystroke occurs while the component has the focus or if the component is an ancestor of the component that has the focus.</source>
          <target state="translated">구성 요소에 포커스가있는 동안 키 입력이 발생하거나 구성 요소가 포커스가있는 구성 요소의 조상 인 경우 작업이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9cf31d6476ce1934389eb0d6f448abdf4cd9e5c8" translate="yes" xml:space="preserve">
          <source>The action will be invoked when the keystroke occurs while the component has the focus or if the component is in the window that has the focus. Note that the component need not be an immediate descendent of the window -- it can be anywhere in the window's containment hierarchy. In other words, whenever &lt;em&gt;any&lt;/em&gt; component in the window has the focus, the action registered with this component is invoked.</source>
          <target state="translated">구성 요소에 포커스가있는 동안 키 입력이 발생하거나 구성 요소가 포커스가있는 창에있는 경우 작업이 호출됩니다. 구성 요소는 창의 직계 하위 항목 일 필요는 없습니다. 창의 포함 계층 구조의 어느 위치 에나있을 수 있습니다. 때마다 즉, &lt;em&gt;어떤&lt;/em&gt; 창에서 구성 요소에 포커스가이 구성 요소를 호출하여, 작업이 등록했다.</target>
        </trans-unit>
        <trans-unit id="f7096d2bffa5dec03522218205f50ac60f72bdfe" translate="yes" xml:space="preserve">
          <source>The actions parameter contains a comma-separated list of the desired actions granted on the target name. It must not be empty or null.</source>
          <target state="translated">actions 매개 변수에는 대상 이름에 부여 된 원하는 작업 목록이 쉼표로 구분되어 있습니다. 비어 있거나 null이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="c8cca4f8acc451307827a22daeee56bcf88f5e0c" translate="yes" xml:space="preserve">
          <source>The actions string is converted to lowercase before processing.</source>
          <target state="translated">처리하기 전에 작업 문자열이 소문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="0a4a303a8ca535a1283105909db26fc04234c9e3" translate="yes" xml:space="preserve">
          <source>The actions string of a URLPermission is a concatenation of the</source>
          <target state="translated">URLPermission의 액션 문자열은</target>
        </trans-unit>
        <trans-unit id="b3c62e9495ee4ac46ead6ccca9eb89cb863dc5fd" translate="yes" xml:space="preserve">
          <source>The actions to be granted are passed to the constructor in a string containing a list of one or more comma-separated keywords. The possible keywords are &quot;read&quot; and &quot;write&quot;. Their meaning is defined as follows:</source>
          <target state="translated">부여 할 조치는 하나 이상의 쉼표로 구분 된 키워드 목록이 포함 된 문자열로 생성자에 전달됩니다. 가능한 키워드는 &quot;읽기&quot;및 &quot;쓰기&quot;입니다. 그 의미는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d1b568cd9af613226967c935a47a44c2811969df" translate="yes" xml:space="preserve">
          <source>The actions to be granted are passed to the constructor in a string containing a list of one or more comma-separated keywords. The possible keywords are &quot;read&quot;, &quot;write&quot;, &quot;execute&quot;, &quot;delete&quot;, and &quot;readlink&quot;. Their meaning is defined as follows:</source>
          <target state="translated">부여 할 조치는 하나 이상의 쉼표로 구분 된 키워드 목록이 포함 된 문자열로 생성자에 전달됩니다. 가능한 키워드는 &quot;읽기&quot;, &quot;쓰기&quot;, &quot;실행&quot;, &quot;삭제&quot;및 &quot;읽기 링크&quot;입니다. 그 의미는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="224720993bd6f9101dec8c6bf70dadb73fb710c6" translate="yes" xml:space="preserve">
          <source>The activator calls an instantiator's &lt;code&gt;newInstance&lt;/code&gt; method in order to recreate in that group an object with the activation identifier, &lt;code&gt;id&lt;/code&gt;, and descriptor, &lt;code&gt;desc&lt;/code&gt;.</source>
          <target state="translated">활성화 기는 활성화 식별자, &lt;code&gt;id&lt;/code&gt; 및 설명 &lt;code&gt;desc&lt;/code&gt; 를 사용하여 해당 그룹에서 객체를 다시 생성하기 위해 인스턴스화 자의 &lt;code&gt;newInstance&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f7ff923ac2bdcb753652b7f79445c58132684717" translate="yes" xml:space="preserve">
          <source>The activator calls an instantiator's &lt;code&gt;newInstance&lt;/code&gt; method in order to recreate in that group an object with the activation identifier, &lt;code&gt;id&lt;/code&gt;, and descriptor, &lt;code&gt;desc&lt;/code&gt;. The instantiator is responsible for:</source>
          <target state="translated">활성화 기는 활성화 식별자, &lt;code&gt;id&lt;/code&gt; 및 설명 &lt;code&gt;desc&lt;/code&gt; 를 사용하여 해당 그룹에서 객체를 다시 생성하기 위해 인스턴스화 자의 &lt;code&gt;newInstance&lt;/code&gt; 메서드를 호출합니다 . 인스턴스화자는 다음을 담당합니다.</target>
        </trans-unit>
        <trans-unit id="bcc30f46478a62407cc2ae9c82db6faf715f3ca9" translate="yes" xml:space="preserve">
          <source>The activator is responsible for monitoring and detecting when activation groups fail so that it can remove stale remote references to groups and active object's within those groups.</source>
          <target state="translated">활성자는 활성 그룹이 실패 할 때 모니터링하고 감지하여 해당 그룹 내의 활성 오브젝트 및 그룹에 대한 오래된 원격 참조를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8349ac70b9484e5273627a78e2b21c654e0bfa3d" translate="yes" xml:space="preserve">
          <source>The active cell editor object, that overwrites the screen real estate occupied by the current cell and allows the user to change its contents.</source>
          <target state="translated">현재 셀이 차지하는 화면 영역을 덮어 쓰고 사용자가 해당 내용을 변경할 수 있도록하는 활성 셀 편집기 개체입니다.</target>
        </trans-unit>
        <trans-unit id="4f08d6aa4591cd96cfd871fa0afd9f984e68787d" translate="yes" xml:space="preserve">
          <source>The active cell editor object, that overwrites the screen real estate occupied by the current cell and allows the user to change its contents. &lt;code&gt;null&lt;/code&gt; if the table isn't currently editing.</source>
          <target state="translated">현재 셀이 차지하는 화면 영역을 덮어 쓰고 사용자가 해당 내용을 변경할 수 있도록하는 활성 셀 편집기 개체입니다. 테이블이 현재 편집 &lt;code&gt;null&lt;/code&gt; 아니면 null 입니다.</target>
        </trans-unit>
        <trans-unit id="eee4da237f5aebf576ed00ab0b2f49310cddee45" translate="yes" xml:space="preserve">
          <source>The actual &lt;a href=&quot;font&quot;&gt;&lt;code&gt;Font&lt;/code&gt;&lt;/a&gt; from which the font metrics are created.</source>
          <target state="translated">글꼴 메트릭이 생성되는 실제 &lt;a href=&quot;font&quot;&gt; &lt;code&gt;Font&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="31dbe6dc4db2d3fbe64bcf0a549424c784885e35" translate="yes" xml:space="preserve">
          <source>The actual &lt;a href=&quot;font&quot;&gt;&lt;code&gt;Font&lt;/code&gt;&lt;/a&gt; from which the font metrics are created. This cannot be null.</source>
          <target state="translated">글꼴 메트릭이 생성되는 실제 &lt;a href=&quot;font&quot;&gt; &lt;code&gt;Font&lt;/code&gt; &lt;/a&gt; 입니다. null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc14d6c59502ef37434f04213e34e85f51e0fdc8" translate="yes" xml:space="preserve">
          <source>The actual &lt;code&gt;BufferedImage&lt;/code&gt; referenced by the returned &lt;code&gt;IIOImage&lt;/code&gt; will be chosen using the algorithm defined by the &lt;code&gt;getDestination&lt;/code&gt; method.</source>
          <target state="translated">실제 &lt;code&gt;BufferedImage&lt;/code&gt; 리턴 된 &lt;code&gt;IIOImage&lt;/code&gt; 가 참조하는 BufferedImage 는 &lt;code&gt;getDestination&lt;/code&gt; 메소드에 의해 정의 된 알고리즘을 사용하여 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="aee4a0d5a3aed8d41f92b1bdfebee288637b4d1b" translate="yes" xml:space="preserve">
          <source>The actual &lt;code&gt;BufferedImage&lt;/code&gt; returned will be chosen using the algorithm defined by the &lt;code&gt;getDestination&lt;/code&gt; method.</source>
          <target state="translated">실제 &lt;code&gt;BufferedImage&lt;/code&gt; 리턴 BufferedImage 는 &lt;code&gt;getDestination&lt;/code&gt; 메소드에 의해 정의 된 알고리즘을 사용하여 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="170861f30d6e03c3821b423d0f531663af887967" translate="yes" xml:space="preserve">
          <source>The actual change in font rendering behavior resulting from a call to this method is implementation dependent; it may have no effect at all, or the requested behavior may already match the default behavior. The behavior may differ between font rendering in lightweight and peered components. Since calling this method requests a different font, clients should expect different metrics, and may need to recalculate window sizes and layout. Therefore this method should be called before user interface initialisation.</source>
          <target state="translated">이 메서드에 대한 호출로 인한 글꼴 렌더링 동작의 실제 변경은 구현에 따라 다릅니다. 전혀 효과가 없거나 요청 된 동작이 이미 기본 동작과 일치 할 수 있습니다. 경량 구성 요소와 피어링 구성 요소의 글꼴 렌더링간에 동작이 다를 수 있습니다. 이 메서드를 호출하면 다른 글꼴이 요청되므로 클라이언트는 다른 메트릭을 예상해야하며 창 크기와 레이아웃을 다시 계산해야 할 수 있습니다. 따라서이 메서드는 사용자 인터페이스 초기화 전에 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="e5fb63043fa9b253b3ef4aeca26f50954fd17f9a" translate="yes" xml:space="preserve">
          <source>The actual change in font rendering behavior resulting from a call to this method is implementation dependent; it may have no effect at all. The behavior may differ between font rendering in lightweight and peered components. Since calling this method requests a different font, clients should expect different metrics, and may need to recalculate window sizes and layout. Therefore this method should be called before user interface initialisation.</source>
          <target state="translated">이 메서드에 대한 호출로 인한 글꼴 렌더링 동작의 실제 변경은 구현에 따라 다릅니다. 전혀 효과가 없을 수 있습니다. 경량 구성 요소와 피어링 구성 요소의 글꼴 렌더링간에 동작이 다를 수 있습니다. 이 메서드를 호출하면 다른 글꼴이 요청되므로 클라이언트는 다른 메트릭을 예상해야하며 창 크기와 레이아웃을 다시 계산해야 할 수 있습니다. 따라서이 메서드는 사용자 인터페이스 초기화 전에 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="f77aaa09a80a3467887894d4370199393029c250" translate="yes" xml:space="preserve">
          <source>The actual connection to the remote object is made, using the &lt;a href=&quot;#connect()&quot;&gt;&lt;code&gt;connect&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">원격 개체에 대한 실제 연결은 &lt;a href=&quot;#connect()&quot;&gt; &lt;code&gt;connect&lt;/code&gt; &lt;/a&gt; 방법을 사용하여 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="6ed82671a5099d02bc4ad95bcdef0c774f23476b" translate="yes" xml:space="preserve">
          <source>The actual connection to the remote object is made, using the &lt;code&gt;connect&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 메소드를 사용하여 원격 오브젝트에 실제로 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="02600ea475ec423c00be1655967502d1587e439e" translate="yes" xml:space="preserve">
          <source>The actual installation of the value on the class is performed atomically. At that point, if several racing threads have computed values, one is chosen, and returned to all the racing threads.</source>
          <target state="translated">클래스에 실제 값 설치는 원자 적으로 수행됩니다. 이때 여러 레이싱 스레드에 계산 된 값이 있으면 하나가 선택되어 모든 레이싱 스레드로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="30c0ee8111932e38a07701eb819a3079fc0c5eba" translate="yes" xml:space="preserve">
          <source>The actual level of translucency of a given pixel also depends on window opacity (see &lt;a href=&quot;#setOpacity(float)&quot;&gt;&lt;code&gt;setOpacity(float)&lt;/code&gt;&lt;/a&gt;), as well as the current shape of this window (see &lt;a href=&quot;#setShape(java.awt.Shape)&quot;&gt;&lt;code&gt;setShape(Shape)&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">주어진 픽셀의 실제 반투명도는 창 불투명도 ( &lt;a href=&quot;#setOpacity(float)&quot;&gt; &lt;code&gt;setOpacity(float)&lt;/code&gt; &lt;/a&gt; 참조) &lt;a href=&quot;#setShape(java.awt.Shape)&quot;&gt; &lt;code&gt;setShape(Shape)&lt;/code&gt; &lt;/a&gt; 창의 현재 모양 ( setShape (Shape) 참조 ) 에 따라 달라집니다 .</target>
        </trans-unit>
        <trans-unit id="ced3415c822981d42d6ea63b3150a6e9d4c8cc10" translate="yes" xml:space="preserve">
          <source>The actual lifetime of the context will depend on the capabilities of the underlying mechanism and the application should call the &lt;a href=&quot;#getLifetime()&quot;&gt;&lt;code&gt;getLifetime&lt;/code&gt;&lt;/a&gt; method to determine this.</source>
          <target state="translated">컨텍스트의 실제 수명은 기본 메커니즘의 기능에 따라 다르며 응용 프로그램은 이를 확인하기 위해 &lt;a href=&quot;#getLifetime()&quot;&gt; &lt;code&gt;getLifetime&lt;/code&gt; &lt;/a&gt; 메서드를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="af13a097906e4621821341553b5dbc08b523da1a" translate="yes" xml:space="preserve">
          <source>The actual number of bytes skipped is returned.</source>
          <target state="translated">건너 뛴 실제 바이트 수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="671467fba02c14caa04b6f11f619a6c32257e26e" translate="yes" xml:space="preserve">
          <source>The actual number of characters read, or -1 if the end of the stream has been reached</source>
          <target state="translated">읽은 실제 문자 수 또는 스트림 끝에 도달 한 경우 -1</target>
        </trans-unit>
        <trans-unit id="059f9bec40ef8abe09f7c4c1f2b0e3a447ff1b0c" translate="yes" xml:space="preserve">
          <source>The actual number of passes to be decoded is determined during decoding, based on the number of actual passes available in the stream. Thus if &lt;code&gt;minPass + numPasses - 1&lt;/code&gt; is larger than the index of the last available passes, decoding will end with that pass.</source>
          <target state="translated">디코딩 될 실제 패스 수는 스트림에서 이용 가능한 실제 패스 수에 기초하여 디코딩 동안 결정된다. 따라서 &lt;code&gt;minPass + numPasses - 1&lt;/code&gt; 이면 이 사용 가능한 마지막 패스의 인덱스보다 크면 해당 패스로 디코딩이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4af28a9f594a9ed5cf3201a7e40a2eb12e34f9dd" translate="yes" xml:space="preserve">
          <source>The actual output length of the next &lt;a href=&quot;#engineGenExemptionBlob(byte%5B%5D,int)&quot;&gt;&lt;code&gt;engineGenExemptionBlob&lt;/code&gt;&lt;/a&gt; call may be smaller than the length returned by this method.</source>
          <target state="translated">다음 &lt;a href=&quot;#engineGenExemptionBlob(byte%5B%5D,int)&quot;&gt; &lt;code&gt;engineGenExemptionBlob&lt;/code&gt; &lt;/a&gt; 호출 의 실제 출력 길이는 이 메서드에서 반환 된 길이보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4cd2faecc50b365d00fc06df66b1e7ab69d7d74" translate="yes" xml:space="preserve">
          <source>The actual output length of the next &lt;a href=&quot;#genExemptionBlob(byte%5B%5D)&quot;&gt;&lt;code&gt;genExemptionBlob&lt;/code&gt;&lt;/a&gt; call may be smaller than the length returned by this method.</source>
          <target state="translated">다음 &lt;a href=&quot;#genExemptionBlob(byte%5B%5D)&quot;&gt; &lt;code&gt;genExemptionBlob&lt;/code&gt; &lt;/a&gt; 호출 의 실제 출력 길이는 이 메서드에서 반환 된 길이보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82700f258fcadc84f9879bec102ae1591cfaca9" translate="yes" xml:space="preserve">
          <source>The actual output length of the next &lt;a href=&quot;exemptionmechanism#genExemptionBlob-byte:A-&quot;&gt;&lt;code&gt;genExemptionBlob&lt;/code&gt;&lt;/a&gt; call may be smaller than the length returned by this method.</source>
          <target state="translated">다음 &lt;a href=&quot;exemptionmechanism#genExemptionBlob-byte:A-&quot;&gt; &lt;code&gt;genExemptionBlob&lt;/code&gt; &lt;/a&gt; 호출 의 실제 출력 길이는 이 메소드가 리턴 한 길이보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="905d6033fae48670e75b261f56eb861a8b025e25" translate="yes" xml:space="preserve">
          <source>The actual output length of the next &lt;a href=&quot;exemptionmechanismspi#engineGenExemptionBlob-byte:A-int-&quot;&gt;&lt;code&gt;engineGenExemptionBlob&lt;/code&gt;&lt;/a&gt; call may be smaller than the length returned by this method.</source>
          <target state="translated">다음 &lt;a href=&quot;exemptionmechanismspi#engineGenExemptionBlob-byte:A-int-&quot;&gt; &lt;code&gt;engineGenExemptionBlob&lt;/code&gt; &lt;/a&gt; 호출 의 실제 출력 길이는 이 메소드가 리턴 한 길이보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0b999dc9952fdc4bc163efd809eb4b540035151" translate="yes" xml:space="preserve">
          <source>The actual output length of the next &lt;code&gt;update&lt;/code&gt; or &lt;code&gt;doFinal&lt;/code&gt; call may be smaller than the length returned by this method.</source>
          <target state="translated">다음 &lt;code&gt;update&lt;/code&gt; 또는 &lt;code&gt;doFinal&lt;/code&gt; 호출 의 실제 출력 길이는 이 메소드가 리턴 한 길이보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c672f3632d6634aa05d5efd1e829e67334a8823" translate="yes" xml:space="preserve">
          <source>The actual rules, describing when and how the offset changes, are defined by &lt;a href=&quot;zone/zonerules&quot;&gt;&lt;code&gt;ZoneRules&lt;/code&gt;&lt;/a&gt;. This class is simply an ID used to obtain the underlying rules. This approach is taken because rules are defined by governments and change frequently, whereas the ID is stable.</source>
          <target state="translated">오프셋이 언제 어떻게 변경되는지를 설명하는 실제 규칙은 &lt;a href=&quot;zone/zonerules&quot;&gt; &lt;code&gt;ZoneRules&lt;/code&gt; 에&lt;/a&gt; 의해 정의됩니다 . 이 클래스는 단순히 기본 규칙을 얻는 데 사용되는 ID입니다. 이 접근법은 규칙이 정부에 의해 정의되고 자주 변경되는 반면 ID는 안정적이기 때문에 취해집니다.</target>
        </trans-unit>
        <trans-unit id="d261f4e32e03b296b3d60d10e2127eba85081b3b" translate="yes" xml:space="preserve">
          <source>The actual storage representation of the coordinates is left to the subclass.</source>
          <target state="translated">좌표의 실제 저장소 표현은 하위 클래스에 남겨집니다.</target>
        </trans-unit>
        <trans-unit id="166cfc102671a62d42630221e5f653a77c6dc21e" translate="yes" xml:space="preserve">
          <source>The actual tag values used in the root IFD of a standard (&quot;baseline&quot;) tiff stream are defined in the &lt;a href=&quot;baselinetifftagset&quot;&gt;&lt;code&gt;BaselineTIFFTagSet&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">표준 ( &quot;baseline&quot;) tiff 스트림의 루트 IFD에 사용되는 실제 태그 값은 &lt;a href=&quot;baselinetifftagset&quot;&gt; &lt;code&gt;BaselineTIFFTagSet&lt;/code&gt; &lt;/a&gt; 클래스에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a8a6705f91238a61dfbbb0d224ce49b1650a684" translate="yes" xml:space="preserve">
          <source>The actual work of the server socket is performed by an instance of the &lt;code&gt;SocketImpl&lt;/code&gt; class. An application can change the socket factory that creates the socket implementation to configure itself to create sockets appropriate to the local firewall.</source>
          <target state="translated">서버 소켓의 실제 작업은 &lt;code&gt;SocketImpl&lt;/code&gt; 클래스 의 인스턴스에 의해 수행됩니다 . 응용 프로그램은 소켓 구현을 작성하는 소켓 팩토리를 변경하여 로컬 방화벽에 적합한 소켓을 작성하도록 자체 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b2d531952326e9ae5acc2e183a81fbf168e4f22" translate="yes" xml:space="preserve">
          <source>The actual work of the socket is performed by an instance of the &lt;code&gt;SocketImpl&lt;/code&gt; class. An application, by changing the socket factory that creates the socket implementation, can configure itself to create sockets appropriate to the local firewall.</source>
          <target state="translated">소켓의 실제 작업은 &lt;code&gt;SocketImpl&lt;/code&gt; 클래스 의 인스턴스에 의해 수행됩니다 . 소켓 구현을 작성하는 소켓 팩토리를 변경하여 애플리케이션이 로컬 방화벽에 적합한 소켓을 작성하도록 자체 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6d4c2e3ca0dfe41abe5b7683cb0723c98bef90a" translate="yes" xml:space="preserve">
          <source>The addSource, setSource, add, and set methods are defined to return 'this' after adding their argument. This allows use of syntax like:</source>
          <target state="translated">addSource, setSource, add 및 set 메서드는 인수를 추가 한 후 'this'를 반환하도록 정의됩니다. 이를 통해 다음과 같은 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c52fcad8240289893d4eaf9e9bd3a09a6e65683c" translate="yes" xml:space="preserve">
          <source>The addition of the annotations of type</source>
          <target state="translated">유형의 주석 추가</target>
        </trans-unit>
        <trans-unit id="7d1225e18c065ce8b5b65c6424eb1bdb34bfbf23" translate="yes" xml:space="preserve">
          <source>The additional stipulation on constructors is, not surprisingly, that all constructors must create a set that contains no duplicate elements (as defined above).</source>
          <target state="translated">생성자에 대한 추가 규정은 놀랍게도 모든 생성자가 중복 요소가없는 세트를 작성해야한다는 것입니다 (위에 정의 된대로).</target>
        </trans-unit>
        <trans-unit id="6d4d7fd7de63074cc28843a0d9ac3ddd2b5ab0c4" translate="yes" xml:space="preserve">
          <source>The address at the 0-based index posn. It must be in the range [0,getAddressCount()).</source>
          <target state="translated">0부터 시작하는 인덱스 위치의 주소입니다. [0, getAddressCount ()) 범위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="acf519d18f988e1d4f17bff6c076ffba8b178197" translate="yes" xml:space="preserve">
          <source>The address can instead indicate where to find an RMI stub through JNDI, using one of the following syntaxes:</source>
          <target state="translated">주소는 대신 다음 구문 중 하나를 사용하여 JNDI를 통해 RMI 스텁을 찾을 위치를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18912a72a502e2b6847bd2811fbf6415acf60d84" translate="yes" xml:space="preserve">
          <source>The address can instead indicate where to find an RMI stub through JNDI, using the following syntax:</source>
          <target state="translated">대신 주소는 다음 구문을 사용하여 JNDI를 통해 RMI 스텁을 찾을 위치를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c5756a8e726f896e4ca08c8947bb793ca198bf8" translate="yes" xml:space="preserve">
          <source>The address can refer directly to the connector server, using one of the following syntaxes:</source>
          <target state="translated">주소는 다음 구문 중 하나를 사용하여 커넥터 서버를 직접 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc02357cfa2a4998b25c22fbfde8704008e3e756" translate="yes" xml:space="preserve">
          <source>The address can refer directly to the connector server, using the following syntax:</source>
          <target state="translated">주소는 다음 구문을 사용하여 커넥터 서버를 직접 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17266b0b87c9c379a4e49f37b5e4beaaf014b1ed" translate="yes" xml:space="preserve">
          <source>The address in this reference with address type 'addrType'; null if no such address exists.</source>
          <target state="translated">이 참조에서 주소 유형이 'addrType'인 주소입니다. 해당 주소가 없으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="73a61fe4e9ac93744841f28ec8ac19091292e962" translate="yes" xml:space="preserve">
          <source>The address in this reference with address type 'addrType; null if no such address exist.</source>
          <target state="translated">이 참조에서 주소 유형 'addrType; 그러한 주소가 존재하지 않는 경우는 null</target>
        </trans-unit>
        <trans-unit id="1ae2b9a5a8bb1f512366590bc69983d2d8d4b80c" translate="yes" xml:space="preserve">
          <source>The address is an &lt;em&gt;Abstract Service URL&lt;/em&gt; for SLP, as defined in RFC 2609 and amended by RFC 3111. It must look like this:</source>
          <target state="translated">주소는 RFC 2609에 정의되고 RFC 3111에 의해 수정 된 SLP 의 &lt;em&gt;추상 서비스 URL&lt;/em&gt; 입니다. 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="428a31f83107944e1c38942b4b57256802e2e6e0" translate="yes" xml:space="preserve">
          <source>The address is no longer part of the association.</source>
          <target state="translated">주소는 더 이상 협회의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ee67192524c3daac2fb313b70b34e7109ce5cc17" translate="yes" xml:space="preserve">
          <source>The address is now part of the association.</source>
          <target state="translated">주소는 이제 협회의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="b2d8cc9e90317711c8a0f41b88e1676a7ca465b5" translate="yes" xml:space="preserve">
          <source>The address of a JMX API connector server.</source>
          <target state="translated">JMX API 커넥터 서버의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="a4d7eacf72ff3ed3d8e0d07482c00d672118ff08" translate="yes" xml:space="preserve">
          <source>The address of a JMX API connector server. Instances of this class are immutable.</source>
          <target state="translated">JMX API 커넥터 서버의 주소입니다. 이 클래스의 인스턴스는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba3c7b74f23c4583d4b444f591e20adf3f4aa41b" translate="yes" xml:space="preserve">
          <source>The address of this connector server.</source>
          <target state="translated">이 커넥터 서버의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="e06cc9043fd1b212e6c9273048ab4a11862abe21" translate="yes" xml:space="preserve">
          <source>The address of this connector.</source>
          <target state="translated">이 커넥터의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="bab9a87aaeb2101b2a58a43fae60b598d81efc1f" translate="yes" xml:space="preserve">
          <source>The address of this object.</source>
          <target state="translated">이 객체의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="2d5c9fe06015caa29475e0490fe944507228cefb" translate="yes" xml:space="preserve">
          <source>The address removed.</source>
          <target state="translated">주소가 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="220e4c6a5e8db780a03f0ab0f7e8134a6d8babd4" translate="yes" xml:space="preserve">
          <source>The address returned may not be the exact original &lt;a href=&quot;../jmxserviceurl&quot;&gt;&lt;code&gt;JMXServiceURL&lt;/code&gt;&lt;/a&gt; that was supplied when creating the connector server, since the original address may not always be complete. For example the port number may be dynamically allocated when starting the connector server. Instead the address returned is the actual &lt;a href=&quot;../jmxserviceurl&quot;&gt;&lt;code&gt;JMXServiceURL&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;../jmxconnectorserver&quot;&gt;&lt;code&gt;JMXConnectorServer&lt;/code&gt;&lt;/a&gt;. This is the address that clients supply to &lt;a href=&quot;../jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-&quot;&gt;&lt;code&gt;JMXConnectorFactory.connect(JMXServiceURL)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원래 주소가 항상 완전한 것은 아니기 때문에 리턴 된 주소 가 커넥터 서버를 작성할 때 제공 한 정확한 원래 &lt;a href=&quot;../jmxserviceurl&quot;&gt; &lt;code&gt;JMXServiceURL&lt;/code&gt; &lt;/a&gt; 이 아닐 수 있습니다. 예를 들어, 포트 번호는 커넥터 서버를 시작할 때 동적으로 할당 될 수 있습니다. 대신에 리턴 된 주소 는 &lt;a href=&quot;../jmxconnectorserver&quot;&gt; &lt;code&gt;JMXConnectorServer&lt;/code&gt; &lt;/a&gt; 의 실제 &lt;a href=&quot;../jmxserviceurl&quot;&gt; &lt;code&gt;JMXServiceURL&lt;/code&gt; &lt;/a&gt; 입니다 . 이것은 클라이언트가 &lt;a href=&quot;../jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-&quot;&gt; &lt;code&gt;JMXConnectorFactory.connect(JMXServiceURL)&lt;/code&gt; &lt;/a&gt; 제공하는 주소입니다 .</target>
        </trans-unit>
        <trans-unit id="9700021783ff77fe0bd95175332c08c598fedab4" translate="yes" xml:space="preserve">
          <source>The address returned may not be the exact original &lt;a href=&quot;jmxserviceurl&quot;&gt;&lt;code&gt;JMXServiceURL&lt;/code&gt;&lt;/a&gt; that was supplied when creating the connector server, since the original address may not always be complete. For example the port number may be dynamically allocated when starting the connector server. Instead the address returned is the actual &lt;a href=&quot;jmxserviceurl&quot;&gt;&lt;code&gt;JMXServiceURL&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;jmxconnectorserver&quot;&gt;&lt;code&gt;JMXConnectorServer&lt;/code&gt;&lt;/a&gt;. This is the address that clients supply to &lt;a href=&quot;jmxconnectorfactory#connect(javax.management.remote.JMXServiceURL)&quot;&gt;&lt;code&gt;JMXConnectorFactory.connect(JMXServiceURL)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 주소 는 원래 주소가 항상 완전하지 않을 수 있으므로 커넥터 서버를 만들 때 제공된 정확한 원래 &lt;a href=&quot;jmxserviceurl&quot;&gt; &lt;code&gt;JMXServiceURL&lt;/code&gt; &lt;/a&gt; 이 아닐 수 있습니다. 예를 들어 포트 번호는 커넥터 서버를 시작할 때 동적으로 할당 될 수 있습니다. 대신 반환 된 주소 는 &lt;a href=&quot;jmxconnectorserver&quot;&gt; &lt;code&gt;JMXConnectorServer&lt;/code&gt; &lt;/a&gt; 의 실제 &lt;a href=&quot;jmxserviceurl&quot;&gt; &lt;code&gt;JMXServiceURL&lt;/code&gt; &lt;/a&gt; 입니다 . 이것은 클라이언트가 &lt;a href=&quot;jmxconnectorfactory#connect(javax.management.remote.JMXServiceURL)&quot;&gt; &lt;code&gt;JMXConnectorFactory.connect(JMXServiceURL)&lt;/code&gt; &lt;/a&gt; 제공하는 주소입니다 .</target>
        </trans-unit>
        <trans-unit id="64e70a0a071f31f810c944e102a872232bd00f6d" translate="yes" xml:space="preserve">
          <source>The address returned may not be the exact original &lt;a href=&quot;jmxserviceurl&quot;&gt;&lt;code&gt;JMXServiceURL&lt;/code&gt;&lt;/a&gt; that was supplied when creating the connector server, since the original address may not always be complete. For example the port number may be dynamically allocated when starting the connector server. Instead the address returned is the actual &lt;a href=&quot;jmxserviceurl&quot;&gt;&lt;code&gt;JMXServiceURL&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;jmxconnectorserver&quot;&gt;&lt;code&gt;JMXConnectorServer&lt;/code&gt;&lt;/a&gt;. This is the address that clients supply to &lt;a href=&quot;jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-&quot;&gt;&lt;code&gt;JMXConnectorFactory.connect(JMXServiceURL)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원래 주소가 항상 완전한 것은 아니기 때문에 리턴 된 주소 가 커넥터 서버를 작성할 때 제공 한 정확한 원래 &lt;a href=&quot;jmxserviceurl&quot;&gt; &lt;code&gt;JMXServiceURL&lt;/code&gt; &lt;/a&gt; 이 아닐 수 있습니다. 예를 들어, 포트 번호는 커넥터 서버를 시작할 때 동적으로 할당 될 수 있습니다. 대신에 리턴 된 주소 는 &lt;a href=&quot;jmxconnectorserver&quot;&gt; &lt;code&gt;JMXConnectorServer&lt;/code&gt; &lt;/a&gt; 의 실제 &lt;a href=&quot;jmxserviceurl&quot;&gt; &lt;code&gt;JMXServiceURL&lt;/code&gt; &lt;/a&gt; 입니다 . 이것은 클라이언트가 &lt;a href=&quot;jmxconnectorfactory#connect-javax.management.remote.JMXServiceURL-&quot;&gt; &lt;code&gt;JMXConnectorFactory.connect(JMXServiceURL)&lt;/code&gt; &lt;/a&gt; 제공하는 주소입니다 .</target>
        </trans-unit>
        <trans-unit id="6f03d57204e6bbe6719c4b339f86db3a8193edb9" translate="yes" xml:space="preserve">
          <source>The address specified can no longer be reached.</source>
          <target state="translated">지정된 주소에 더 이상 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8346ec1bae8218311cd0a4de019a84ebf7384f03" translate="yes" xml:space="preserve">
          <source>The address specified can no longer be reached. Any data sent to this address is rerouted to an alternate until this address becomes reachable.</source>
          <target state="translated">지정된 주소에 더 이상 연결할 수 없습니다. 이 주소로 전송 된 모든 데이터는이 주소에 도달 할 수있을 때까지 대체로 다시 라우팅됩니다.</target>
        </trans-unit>
        <trans-unit id="6241bef1e5fade87c6fb4134f49cb46aed6feb8c" translate="yes" xml:space="preserve">
          <source>The adjacent floating-point value closer to negative infinity.</source>
          <target state="translated">음의 무한대에 가까운 인접 부동 소수점 값.</target>
        </trans-unit>
        <trans-unit id="d7287ef5a420daf086005caedeba3f1999cd4f1b" translate="yes" xml:space="preserve">
          <source>The adjacent floating-point value closer to positive infinity.</source>
          <target state="translated">양의 무한대에 가까운 인접한 부동 소수점 값.</target>
        </trans-unit>
        <trans-unit id="97bdef735eafda13b258ec390ff82bc27f35811f" translate="yes" xml:space="preserve">
          <source>The adjusted &lt;em&gt;A&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;A&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;C&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt;, and &lt;em&gt;C&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; are used in the standard Porter and Duff equations to calculate the blending factors &lt;em&gt;F&lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;F&lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; and then the resulting premultiplied components &lt;em&gt;A&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; and &lt;em&gt;C&lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt;.</source>
          <target state="translated">조정 된 &lt;em&gt;A &lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; , &lt;em&gt;A &lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; , &lt;em&gt;C &lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; 및 &lt;em&gt;C &lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; 는 표준 Porter 및 Duff 방정식에서 혼합 계수 &lt;em&gt;F &lt;sub&gt;s&lt;/sub&gt;&lt;/em&gt; 및 &lt;em&gt;F &lt;sub&gt;d&lt;/sub&gt;&lt;/em&gt; 를 계산 한 다음 결과로 미리 곱해진 성분 &lt;em&gt;A &lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; 및 &lt;em&gt;C &lt;sub&gt;r&lt;/sub&gt;&lt;/em&gt; 을 계산하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1bb6f923b60e5eb464a50908db7bee15548769eb" translate="yes" xml:space="preserve">
          <source>The adjustment event emitted by Adjustable objects like &lt;a href=&quot;../scrollbar&quot;&gt;&lt;code&gt;Scrollbar&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../scrollpane&quot;&gt;&lt;code&gt;ScrollPane&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../scrollbar&quot;&gt; &lt;code&gt;Scrollbar&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../scrollpane&quot;&gt; &lt;code&gt;ScrollPane&lt;/code&gt; &lt;/a&gt; 과 같은 조정 가능한 개체에서 발생하는 조정 이벤트 입니다 .</target>
        </trans-unit>
        <trans-unit id="81859fd01b2e0f0ce2fddb3d9c66e4bc26b7a448" translate="yes" xml:space="preserve">
          <source>The adjustment event emitted by Adjustable objects like &lt;a href=&quot;../scrollbar&quot;&gt;&lt;code&gt;Scrollbar&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../scrollpane&quot;&gt;&lt;code&gt;ScrollPane&lt;/code&gt;&lt;/a&gt;. When the user changes the value of the scrolling component, it receives an instance of &lt;code&gt;AdjustmentEvent&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../scrollbar&quot;&gt; &lt;code&gt;Scrollbar&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../scrollpane&quot;&gt; &lt;code&gt;ScrollPane&lt;/code&gt; &lt;/a&gt; 과 같은 조정 가능한 개체에서 발생하는 조정 이벤트 입니다 . 사용자가 스크롤링 구성 요소의 값을 변경하면 &lt;code&gt;AdjustmentEvent&lt;/code&gt; 인스턴스를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="e557c3c0491805657994651bb703f8e531d46510" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;../temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">조정은 &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;../temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="7e0ac0c2021098e29d8455928e36fe81f20af125" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;../temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;../temporal/chronofield#ERA&quot;&gt;&lt;code&gt;ChronoField.ERA&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">조정은 &lt;a href=&quot;../temporal/chronofield#ERA&quot;&gt; &lt;code&gt;ChronoField.ERA&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;../temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="eb4d8a39d6c7a5737e574183f1b6ea6d04cd3795" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;../temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">조정은 &lt;a href=&quot;../temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 두 번 사용하여 &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 를 필드로 전달하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9660f4df915ae438aaa1ca69a926277eb5e438e2" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">이 조정은 &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 을 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1af39ea9e620defde8decc9abf70f8893f08effe" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;../temporal/chronofield#ERA&quot;&gt;&lt;code&gt;ChronoField.ERA&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">이 조정은 &lt;a href=&quot;../temporal/chronofield#ERA&quot;&gt; &lt;code&gt;ChronoField.ERA&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 을 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fda27fe7600ef055a1fc731d1cae77fdc5cf2c6d" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">이 조정은 &lt;a href=&quot;../temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하여 &lt;a href=&quot;../temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 두 번 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e1730bd4303c805d9c684c6ed7e47af3157dfece" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;ChronoField.DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; as the field. Note that this adjusts forwards or backwards within a Monday to Sunday week. See &lt;a href=&quot;temporal/weekfields#dayOfWeek()&quot;&gt;&lt;code&gt;WeekFields.dayOfWeek()&lt;/code&gt;&lt;/a&gt; for localized week start days. See &lt;code&gt;TemporalAdjuster&lt;/code&gt; for other adjusters with more control, such as &lt;code&gt;next(MONDAY)&lt;/code&gt;.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;ChronoField.DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것과 동일 합니다. 이것은 월요일부터 일요일까지 앞뒤로 조정됩니다. 지역화 된 주 시작 요일 은 &lt;a href=&quot;temporal/weekfields#dayOfWeek()&quot;&gt; &lt;code&gt;WeekFields.dayOfWeek()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . &lt;code&gt;next(MONDAY)&lt;/code&gt; 와 같이 더 많은 제어가 가능한 다른 조정자는 &lt;code&gt;TemporalAdjuster&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f5779d9d6f286d32498c7b4d89ab367dbfab8eb" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="89486faf7e5f8ac9cb17bf398ea4eb6495722017" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;ChronoField.MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; as the field. If the specified temporal object does not use the ISO calendar system then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;ChronoField.MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것과 동일 합니다. 지정된 임시 객체가 ISO 달력 시스템을 사용하지 않으면 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cd9e1f7cd9119478dd93065f01fda508c25eed24" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="4669766726ffe7539e6940ff67b15bb0def98d61" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt;&lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt; &lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="19ddf0d6618d281f56aeb7b15d248ac5e09f4469" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#PROLEPTIC_MONTH&quot;&gt;&lt;code&gt;ChronoField.PROLEPTIC_MONTH&lt;/code&gt;&lt;/a&gt; as the field. If the specified temporal object does not use the ISO calendar system then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/chronofield#PROLEPTIC_MONTH&quot;&gt; &lt;code&gt;ChronoField.PROLEPTIC_MONTH&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것과 동일 합니다. 지정된 임시 객체가 ISO 달력 시스템을 사용하지 않으면 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fbc63115de826a58b0a5e14541e01d47ddc81320" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#YEAR&quot;&gt;&lt;code&gt;ChronoField.YEAR&lt;/code&gt;&lt;/a&gt; as the field. If the specified temporal object does not use the ISO calendar system then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/chronofield#YEAR&quot;&gt; &lt;code&gt;ChronoField.YEAR&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 를 사용하는 것과 동일 합니다. 지정된 임시 객체가 ISO 달력 시스템을 사용하지 않으면 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fec4d9e8d74e6bbd27eb5ea8b9e3383952ea13fa" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; three times, passing &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt;&lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 세 번 사용하여 &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt; &lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt; &lt;/a&gt; 를 필드로 전달하는 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5c9930247318e9a371ae061edf6b9eb8cf0eb0ab" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 두 번 사용하여 &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 를 필드로 전달하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f623698db1a4da528c6a5d292749e115985015e6" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;temporal/chronofield#INSTANT_SECONDS&quot;&gt;&lt;code&gt;ChronoField.INSTANT_SECONDS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 두 번 사용하여 &lt;a href=&quot;temporal/chronofield#INSTANT_SECONDS&quot;&gt; &lt;code&gt;ChronoField.INSTANT_SECONDS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt; 를 필드로 전달하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="bca10f048a41b29ffdec68a7f2072b22b86c1577" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;ChronoField.MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#DAY_OF_MONTH&quot;&gt;&lt;code&gt;ChronoField.DAY_OF_MONTH&lt;/code&gt;&lt;/a&gt; as the fields. If the specified temporal object does not use the ISO calendar system then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 두 번 사용하여 &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;ChronoField.MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronofield#DAY_OF_MONTH&quot;&gt; &lt;code&gt;ChronoField.DAY_OF_MONTH&lt;/code&gt; &lt;/a&gt; 를 필드로 전달하는 것과 같습니다 . 지정된 임시 객체가 ISO 달력 시스템을 사용하지 않으면 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3784004fa04661f78d5d607017041ed27c93ae85" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt;&lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/temporal#with(java.time.temporal.TemporalField,long)&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 두 번 사용하여 &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt; &lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt; &lt;/a&gt; 를 필드로 전달하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e44cad48b9827c5f480b34333f1a973611fd9388" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt;&lt;code&gt;ChronoField.DAY_OF_WEEK&lt;/code&gt;&lt;/a&gt; as the field. Note that this adjusts forwards or backwards within a Monday to Sunday week. See &lt;a href=&quot;temporal/weekfields#dayOfWeek--&quot;&gt;&lt;code&gt;WeekFields.dayOfWeek()&lt;/code&gt;&lt;/a&gt; for localized week start days. See &lt;code&gt;TemporalAdjuster&lt;/code&gt; for other adjusters with more control, such as &lt;code&gt;next(MONDAY)&lt;/code&gt;.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/chronofield#DAY_OF_WEEK&quot;&gt; &lt;code&gt;ChronoField.DAY_OF_WEEK&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 을 사용하는 것과 같습니다 . 월요일부터 일요일 주 사이에 앞뒤로 조정됩니다. 현지화 된 주 시작일 은 &lt;a href=&quot;temporal/weekfields#dayOfWeek--&quot;&gt; &lt;code&gt;WeekFields.dayOfWeek()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . &lt;code&gt;next(MONDAY)&lt;/code&gt; 와 같이 더 많은 제어 기능을 가진 다른 조정자에 대해서는 &lt;code&gt;TemporalAdjuster&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b611d529bc1f3d60bbf9c910262c56861a5e1e8" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">이 조정은 &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 을 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="257599f217c60f1b286ca03e73c123884296cb3b" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;ChronoField.MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; as the field. If the specified temporal object does not use the ISO calendar system then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 조정은 &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;ChronoField.MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 을 사용하는 것과 같습니다 . 지정된 임시 객체가 ISO 달력 시스템을 사용하지 않으면 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5802986909900e31119ae14ea5be02213c50d0be" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">이 조정은 &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 을 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="88987ee5b08a8d2a074850d0b9773a025b06b4d1" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt;&lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt;&lt;/a&gt; as the field.</source>
          <target state="translated">이 조정은 &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt; &lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 을 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="98164a2c75da7f81c3334e95803d9d828422a751" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#PROLEPTIC_MONTH&quot;&gt;&lt;code&gt;ChronoField.PROLEPTIC_MONTH&lt;/code&gt;&lt;/a&gt; as the field. If the specified temporal object does not use the ISO calendar system then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 조정은 &lt;a href=&quot;temporal/chronofield#PROLEPTIC_MONTH&quot;&gt; &lt;code&gt;ChronoField.PROLEPTIC_MONTH&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 을 사용하는 것과 같습니다 . 지정된 임시 객체가 ISO 달력 시스템을 사용하지 않으면 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a5129d3f5b2d1ff47e62137527b8ffc36da581cf" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;temporal/chronofield#YEAR&quot;&gt;&lt;code&gt;ChronoField.YEAR&lt;/code&gt;&lt;/a&gt; as the field. If the specified temporal object does not use the ISO calendar system then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 조정은 &lt;a href=&quot;temporal/chronofield#YEAR&quot;&gt; &lt;code&gt;ChronoField.YEAR&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하는 &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 을 사용하는 것과 같습니다 . 지정된 임시 객체가 ISO 달력 시스템을 사용하지 않으면 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f2a30a7c22625abb73e11626e5ddcf7795b8d68d" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; three times, passing &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt;&lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">이 조정은 &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt; &lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하여 &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 세 번 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e7da8868c418c745ff4cc22056878587f0c5e004" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt;&lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">이 조정은 &lt;a href=&quot;temporal/chronofield#EPOCH_DAY&quot;&gt; &lt;code&gt;ChronoField.EPOCH_DAY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 를 필드로 전달 하여 &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 두 번 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fbe1b4b3b564d51f43b80e201aaa4bed1b896b23" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;temporal/chronofield#INSTANT_SECONDS&quot;&gt;&lt;code&gt;ChronoField.INSTANT_SECONDS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_SECOND&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">이 조정은 &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 두 번 사용하여 &lt;a href=&quot;temporal/chronofield#INSTANT_SECONDS&quot;&gt; &lt;code&gt;ChronoField.INSTANT_SECONDS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronofield#NANO_OF_SECOND&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_SECOND&lt;/code&gt; &lt;/a&gt; 를 필드로 전달하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5eb1c9d6c698514069a9fa5a2aefedfa05f03d19" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt;&lt;code&gt;ChronoField.MONTH_OF_YEAR&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#DAY_OF_MONTH&quot;&gt;&lt;code&gt;ChronoField.DAY_OF_MONTH&lt;/code&gt;&lt;/a&gt; as the fields. If the specified temporal object does not use the ISO calendar system then a &lt;code&gt;DateTimeException&lt;/code&gt; is thrown.</source>
          <target state="translated">이 조정은 &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 두 번 사용하여 &lt;a href=&quot;temporal/chronofield#MONTH_OF_YEAR&quot;&gt; &lt;code&gt;ChronoField.MONTH_OF_YEAR&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronofield#DAY_OF_MONTH&quot;&gt; &lt;code&gt;ChronoField.DAY_OF_MONTH&lt;/code&gt; &lt;/a&gt; 를 필드로 전달하는 것과 같습니다 . 지정된 임시 객체가 ISO 달력 시스템을 사용하지 않으면 &lt;code&gt;DateTimeException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="92d2244665cb53572ff5bdf04962e104a4097d36" translate="yes" xml:space="preserve">
          <source>The adjustment is equivalent to using &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt;&lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt;&lt;/a&gt; twice, passing &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt;&lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt;&lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt;&lt;/a&gt; as the fields.</source>
          <target state="translated">조정은 &lt;a href=&quot;temporal/temporal#with-java.time.temporal.TemporalField-long-&quot;&gt; &lt;code&gt;Temporal.with(TemporalField, long)&lt;/code&gt; &lt;/a&gt; 두 번 사용하여 &lt;a href=&quot;temporal/chronofield#NANO_OF_DAY&quot;&gt; &lt;code&gt;ChronoField.NANO_OF_DAY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;temporal/chronofield#OFFSET_SECONDS&quot;&gt; &lt;code&gt;ChronoField.OFFSET_SECONDS&lt;/code&gt; &lt;/a&gt; 를 필드로 전달하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7052b76c26a9f245bbf7fa1c775a97b3b70d9f09" translate="yes" xml:space="preserve">
          <source>The adjustment value changed event.</source>
          <target state="translated">조정 값 변경 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="72bb1012d4519b8297cefba7f3a72d3a8bdfaba8" translate="yes" xml:space="preserve">
          <source>The adopted node, or &lt;code&gt;null&lt;/code&gt; if this operation fails, such as when the source node comes from a different implementation.</source>
          <target state="translated">채택 된 노드 또는 소스 노드가 다른 구현에서 오는 경우와 같이이 작업이 실패하는 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="68429bfb49870e89a3004fadc7e460bdb5d5149b" translate="yes" xml:space="preserve">
          <source>The advance is the distance from the leftmost point used to position the character to the rightmost point along the baseline. This is not the same thing as the visible width of the glyph image representing the character.</source>
          <target state="translated">진행은 캐릭터를 기준선을 따라 가장 오른쪽 지점으로 배치하는 데 사용되는 가장 왼쪽 지점에서 거리입니다. 이것은 캐릭터를 나타내는 글리프 이미지의 보이는 너비와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9291cb5337faaddf5bc68a54d026f779b12f07c3" translate="yes" xml:space="preserve">
          <source>The advance of a &lt;code&gt;String&lt;/code&gt; is not necessarily the sum of the advances of its characters. It may differ substantially if complex text layout is required for proper rendering.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 의 전진은 반드시 문자의 전진의 합이 아닙니다. 적절한 렌더링을 위해 복잡한 텍스트 레이아웃이 필요한 경우 크게 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f23abbebb1e1b5d3ab99a59cb292dcbe2d1fcfa0" translate="yes" xml:space="preserve">
          <source>The advance of a glyph is the distance from the glyph's origin to the origin of the next glyph along the baseline, which is either vertical or horizontal. Note that, in a &lt;code&gt;GlyphVector&lt;/code&gt;, the distance from a glyph to its following glyph might not be the glyph's advance, because of kerning or other positioning adjustments.</source>
          <target state="translated">글리프의 진행은 글리프의 원점에서 기준선을 따라 수직 또는 수평 인 다음 글리프의 원점까지의 거리입니다. 그 참고 A의 &lt;code&gt;GlyphVector&lt;/code&gt; 에 , 그 다음 그래프에 그리으로부터의 거리가 kerning 나 그 외의 위치 조정, 문양의 사전되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b5b5724c0a57b62a52b3eab73e29070d3716304" translate="yes" xml:space="preserve">
          <source>The advantage of an extended range is that variables from recently exited scopes may remain available for examination (this is especially useful for loop indices). If, as a result of the extensions above, the current frame location is contained within the range of multiple local variables of the same name, the variable with the highest-starting range is chosen for the returned list.</source>
          <target state="translated">확장 된 범위의 장점은 최근에 종료 된 범위의 변수를 검사에 사용할 수 있다는 것입니다 (특히 루프 인덱스에 유용함). 위의 확장의 결과로 현재 프레임 위치가 동일한 이름의 여러 로컬 변수 범위 내에 포함되는 경우 반환 된 목록에 대해 시작 범위가 가장 높은 변수가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="3d4aa0730e6af4e6b0f30036b6ea8bb5b04ea326" translate="yes" xml:space="preserve">
          <source>The advantage of this class is that it provides a lookup table that Java or native methods can use directly to optimize color conversion in some cases.</source>
          <target state="translated">이 클래스의 장점은 Java 또는 기본 메소드가 일부 경우 색상 변환을 최적화하는 데 직접 사용할 수있는 조회 테이블을 제공한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd87f01d6e120b4856f168c7c03ef40ca772d785" translate="yes" xml:space="preserve">
          <source>The advantage of this class is that it provides color transform matrices and lookup tables that Java or native methods can use directly to optimize color conversion in some cases.</source>
          <target state="translated">이 클래스의 장점은 Java 또는 기본 메소드가 일부 경우 색상 변환을 최적화하는 데 직접 사용할 수있는 색상 변환 매트릭스 및 조회 테이블을 제공한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1551f53b8f0e67738cca4fd3f85ad70fd654293c" translate="yes" xml:space="preserve">
          <source>The advisory title.</source>
          <target state="translated">자문 제목입니다.</target>
        </trans-unit>
        <trans-unit id="b4103ddf1e40bd3bd7a46b2d8955f52d92ac37f5" translate="yes" xml:space="preserve">
          <source>The advisory title. The title is often specified in the &lt;code&gt;ownerNode&lt;/code&gt;. See the title attribute definition for the &lt;code&gt;LINK&lt;/code&gt; element in HTML 4.0, and the title pseudo-attribute for the XML style sheet processing instruction.</source>
          <target state="translated">자문 제목입니다. 제목은 종종 &lt;code&gt;ownerNode&lt;/code&gt; 에 지정됩니다 . HTML 4.0 의 &lt;code&gt;LINK&lt;/code&gt; 요소에 대한 제목 속성 정의 와 XML 스타일 시트 처리 명령에 대한 제목 의사 속성을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f1c1af2cab6e1d6f619470ad3ce08e32ec8818dd" translate="yes" xml:space="preserve">
          <source>The affected area of the table can be determined by the other four methods which specify ranges of rows and columns</source>
          <target state="translated">테이블의 영향을받는 영역은 행과 열의 범위를 지정하는 다른 네 가지 방법으로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd74e671d7cc74fe7d0e90d8ba1e0b7d911947ff" translate="yes" xml:space="preserve">
          <source>The after status.</source>
          <target state="translated">사후 상태.</target>
        </trans-unit>
        <trans-unit id="1fb5511f673949e41c35d98464ff0b81e5dc570c" translate="yes" xml:space="preserve">
          <source>The after status. Note: this may be the same as the previous status (not all changes cause a &lt;code&gt;Status&lt;/code&gt; change.</source>
          <target state="translated">사후 상태. 참고 : 이는 이전 상태와 동일 할 수 있습니다 (모든 변경으로 인해 &lt;code&gt;Status&lt;/code&gt; 변경 되는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="cf50960dcad4907b659b7a2865632db4d3f3d553" translate="yes" xml:space="preserve">
          <source>The agent class may also have a &lt;code&gt;premain&lt;/code&gt; method for use when the agent is started using a command-line option. When the agent is started after VM startup the &lt;code&gt;premain&lt;/code&gt; method is not invoked.</source>
          <target state="translated">에이전트 클래스 에는 명령 줄 옵션을 사용하여 에이전트를 시작할 때 사용할 &lt;code&gt;premain&lt;/code&gt; 메서드 도있을 수 있습니다 . VM 시작 후 에이전트가 시작되면 &lt;code&gt;premain&lt;/code&gt; 메서드가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fcc8835dfee0f090d10a2e1133f4fe53b06409d" translate="yes" xml:space="preserve">
          <source>The agent class may also have an &lt;code&gt;agentmain&lt;/code&gt; method for use when the agent is started after VM startup (see below). When the agent is started using a command-line option, the &lt;code&gt;agentmain&lt;/code&gt; method is not invoked.</source>
          <target state="translated">에이전트 클래스에는 VM 시작 후 에이전트가 시작될 때 사용할 &lt;code&gt;agentmain&lt;/code&gt; 메서드 도있을 수 있습니다 (아래 참조). 명령 줄 옵션을 사용하여 에이전트를 시작하면 &lt;code&gt;agentmain&lt;/code&gt; 메서드가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc9ffdbceb3383c8bd2459b0a01c981ded082eda" translate="yes" xml:space="preserve">
          <source>The agent class must implement a public static &lt;code&gt;agentmain&lt;/code&gt; method.</source>
          <target state="translated">에이전트 클래스는 공용 정적 &lt;code&gt;agentmain&lt;/code&gt; 메서드를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e191eb332e6d12e06e97c3fbb03226bcafccd10" translate="yes" xml:space="preserve">
          <source>The agent is passed its agent options via the &lt;code&gt;agentArgs&lt;/code&gt; parameter. The agent options are passed as a single string, any additional parsing should be performed by the agent itself.</source>
          <target state="translated">에이전트는 &lt;code&gt;agentArgs&lt;/code&gt; 매개 변수 를 통해 에이전트 옵션을 전달합니다 . 에이전트 옵션은 단일 문자열로 전달되며 추가 구문 분석은 에이전트 자체에서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="78dfeebfad16da9fcb03659009ad0b0fe8960360" translate="yes" xml:space="preserve">
          <source>The agent library provided is the absolute path from which to load the agent library. Unlike &lt;a href=&quot;#loadAgentLibrary(java.lang.String,java.lang.String)&quot;&gt;&lt;code&gt;loadAgentLibrary&lt;/code&gt;&lt;/a&gt;, the library name is not expanded in the target virtual machine.</source>
          <target state="translated">제공된 에이전트 라이브러리는 에이전트 라이브러리를로드 할 절대 경로입니다. &lt;a href=&quot;#loadAgentLibrary(java.lang.String,java.lang.String)&quot;&gt; &lt;code&gt;loadAgentLibrary&lt;/code&gt; &lt;/a&gt; 와 달리 라이브러리 이름은 대상 가상 머신에서 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="555721ed51e0d250b99782d03fd02f8a0ae22020" translate="yes" xml:space="preserve">
          <source>The agent library provided is the name of the agent library. It is interpreted in the target virtual machine in an implementation-dependent manner. Typically an implementation will expand the library name into an operating system specific file name. For example, on UNIX systems, the name &lt;code&gt;L&lt;/code&gt; might be expanded to &lt;code&gt;libL.so&lt;/code&gt;, and located using the search path specified by the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; environment variable. If the agent named 'L' is statically linked into the VM then the VM must export a function named &lt;code&gt;Agent_OnAttach_L&lt;/code&gt;.</source>
          <target state="translated">제공된 에이전트 라이브러리는 에이전트 라이브러리의 이름입니다. 구현에 따라 대상 가상 머신에서 해석됩니다. 일반적으로 구현은 라이브러리 이름을 운영 체제 별 파일 이름으로 확장합니다. 예를 들어, UNIX 시스템에서 이름 &lt;code&gt;L&lt;/code&gt; 은 &lt;code&gt;libL.so&lt;/code&gt; 로 확장되고 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; 환경 변수 로 지정된 검색 경로를 사용하여 찾을 수 있습니다. 'L'이라는 에이전트가 VM에 정적으로 연결된 경우 VM은 &lt;code&gt;Agent_OnAttach_L&lt;/code&gt; 이라는 함수를 내 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc14d4a9214560f0c9bea064fba9b8d0012531ef" translate="yes" xml:space="preserve">
          <source>The agent properties</source>
          <target state="translated">에이전트 속성</target>
        </trans-unit>
        <trans-unit id="a9fc43469e24935d0a375bd2c3c35774a4f5b970" translate="yes" xml:space="preserve">
          <source>The agent provided to this method is a path name to a JAR file on the file system of the target virtual machine. This path is passed to the target virtual machine where it is interpreted. The target virtual machine attempts to start the agent as specified by the &lt;a href=&quot;../../../../../java.instrument/java/lang/instrument/package-summary&quot;&gt;&lt;code&gt;java.lang.instrument&lt;/code&gt;&lt;/a&gt; specification. That is, the specified JAR file is added to the system class path (of the target virtual machine), and the &lt;code&gt;agentmain&lt;/code&gt; method of the agent class, specified by the &lt;code&gt;Agent-Class&lt;/code&gt; attribute in the JAR manifest, is invoked. This method completes when the &lt;code&gt;agentmain&lt;/code&gt; method completes.</source>
          <target state="translated">이 메소드에 제공된 에이전트는 대상 가상 머신의 파일 시스템에있는 JAR 파일의 경로 이름입니다. 이 경로는 해석되는 대상 가상 머신으로 전달됩니다. 대상 가상 머신은 &lt;a href=&quot;../../../../../java.instrument/java/lang/instrument/package-summary&quot;&gt; &lt;code&gt;java.lang.instrument&lt;/code&gt; &lt;/a&gt; 스펙에 지정된대로 에이전트를 시작하려고합니다 . 즉, 지정된 JAR 파일이 대상 가상 머신의 시스템 클래스 경로에 추가되고 JAR 매니페스트 의 &lt;code&gt;Agent-Class&lt;/code&gt; 속성에 지정된 에이전트 클래스 의 &lt;code&gt;agentmain&lt;/code&gt; 메서드 가 호출됩니다. 이 메서드는 &lt;code&gt;agentmain&lt;/code&gt; 메서드가 완료되면 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="c765c5d385607a3d8763df3c64f7ac4e847c83f3" translate="yes" xml:space="preserve">
          <source>The agent should take care to ensure that the JAR does not contain any classes or resources other than those to be defined by the bootstrap class loader for the purpose of instrumentation. Failure to observe this warning could result in unexpected behavior that is difficult to diagnose. For example, suppose there is a loader L, and L's parent for delegation is the bootstrap class loader. Furthermore, a method in class C, a class defined by L, makes reference to a non-public accessor class C$1. If the JAR file contains a class C$1 then the delegation to the bootstrap class loader will cause C$1 to be defined by the bootstrap class loader. In this example an &lt;code&gt;IllegalAccessError&lt;/code&gt; will be thrown that may cause the application to fail. One approach to avoiding these types of issues, is to use a unique package name for the instrumentation classes.</source>
          <target state="translated">에이전트는 JAR에 계측 목적으로 부트 스트랩 클래스 로더가 정의한 것 이외의 클래스 나 자원을 포함하지 않도록주의해야합니다. 이 경고를 준수하지 않으면 예기치 않은 동작이 발생하여 진단하기가 어려울 수 있습니다. 예를 들어 로더 L이 있고 위임의 L 부모가 부트 스트랩 클래스 로더라고 가정합니다. 또한 클래스 C의 메소드, L로 정의 된 클래스는 비 공용 접근 자 클래스 C $ 1을 참조합니다. JAR 파일에 클래스 C $ 1이 포함 된 경우 부트 스트랩 클래스 로더에 위임하면 C $ 1이 부트 스트랩 클래스 로더에 의해 정의됩니다. 이 예에서 &lt;code&gt;IllegalAccessError&lt;/code&gt; 응용 프로그램이 실패 할 수있는가 발생합니다. 이러한 유형의 문제를 피하는 한 가지 방법은 계측 클래스에 고유 한 패키지 이름을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f94c6f3421719c3e55edd167c31c3bf752b82f1" translate="yes" xml:space="preserve">
          <source>The agent should take care to ensure that the JAR does not contain any classes or resources other than those to be defined by the system class loader for the purpose of instrumentation. Failure to observe this warning could result in unexpected behavior that is difficult to diagnose (see &lt;a href=&quot;#appendToBootstrapClassLoaderSearch(java.util.jar.JarFile)&quot;&gt;&lt;code&gt;appendToBootstrapClassLoaderSearch&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">에이전트는 JAR에 계측 목적으로 시스템 클래스 로더에 의해 정의 된 것 이외의 클래스 또는 리소스가 포함되지 않도록주의해야합니다. 이 경고를 준수하지 않으면 진단하기 어려운 예기치 않은 동작이 발생할 수 있습니다 ( &lt;a href=&quot;#appendToBootstrapClassLoaderSearch(java.util.jar.JarFile)&quot;&gt; &lt;code&gt;appendToBootstrapClassLoaderSearch&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="678b2dbe34d546f1b97104a1122aecca882d6d38" translate="yes" xml:space="preserve">
          <source>The agent should take care to ensure that the JAR does not contain any classes or resources other than those to be defined by the system class loader for the purpose of instrumentation. Failure to observe this warning could result in unexpected behavior that is difficult to diagnose (see &lt;a href=&quot;instrumentation#appendToBootstrapClassLoaderSearch-java.util.jar.JarFile-&quot;&gt;&lt;code&gt;appendToBootstrapClassLoaderSearch&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">에이전트는 JAR에 계측 목적으로 시스템 클래스 로더가 정의한 것 이외의 클래스 나 자원이 포함되지 않도록주의해야합니다. 이 경고를 준수하지 않으면 예기치 않은 동작으로 인해 진단하기가 어려울 수 있습니다 ( &lt;a href=&quot;instrumentation#appendToBootstrapClassLoaderSearch-java.util.jar.JarFile-&quot;&gt; &lt;code&gt;appendToBootstrapClassLoaderSearch&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="037a496f1ea03103e1143a34faae8304d6d4c08b" translate="yes" xml:space="preserve">
          <source>The aggregate components which comprise the combo box are unregistered and uninitialized.</source>
          <target state="translated">콤보 상자를 구성하는 집계 구성 요소가 등록 취소되고 초기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5733aad941f9711eeb32c5fb9a7972423ec9e93f" translate="yes" xml:space="preserve">
          <source>The aggregate components which comprise the combo box are unregistered and uninitialized. This method is called as part of the UI uninstallation process.</source>
          <target state="translated">콤보 상자를 구성하는 집계 구성 요소가 등록 취소되고 초기화되지 않습니다. 이 메서드는 UI 제거 프로세스의 일부로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="546cbc1f7664aeb26e996479ae09bc8d8a9e3a69" translate="yes" xml:space="preserve">
          <source>The alert (bell) character (&lt;code&gt;'\u0007'&lt;/code&gt;)</source>
          <target state="translated">경고 (종) 문자 ( &lt;code&gt;'\u0007'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="444bb5c356a78bf33726541cd6e8ccb0df8b7f4a" translate="yes" xml:space="preserve">
          <source>The algorithm in this step enumerates the same module name twice. This indicates a cycle in the 'requires' directives, disregarding any 'transitive' modifiers.</source>
          <target state="translated">이 단계의 알고리즘은 동일한 모듈 이름을 두 번 열거합니다. 이는 '전이'수정자를 무시하고 'requires'지시문의주기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5626138a26257368698eb4794c202820b5b71ee2" translate="yes" xml:space="preserve">
          <source>The algorithm is slightly tricky. It rejects values that would result in an uneven distribution (due to the fact that 2^31 is not divisible by n). The probability of a value being rejected depends on n. The worst case is n=2^30+1, for which the probability of a reject is 1/2, and the expected number of iterations before the loop terminates is 2.</source>
          <target state="translated">알고리즘은 약간 까다 롭습니다. (2 ^ 31을 n으로 나눌 수 없다는 사실 때문에) 고르지 않은 분포를 초래하는 값을 거부합니다. 값이 거부 될 확률은 n에 따라 다릅니다. 최악의 경우는 n = 2 ^ 30 + 1이며 거부 확률은 1/2이고 루프가 종료되기 전에 예상되는 반복 횟수는 2입니다.</target>
        </trans-unit>
        <trans-unit id="93921a1e862ec851c3cf638cc9b61cb2cd976324" translate="yes" xml:space="preserve">
          <source>The algorithm name is determined from the &lt;code&gt;algorithm&lt;/code&gt; OID string.</source>
          <target state="translated">알고리즘 이름은 &lt;code&gt;algorithm&lt;/code&gt; OID 문자열 에서 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8cbe7a291f4857cdb30840b2cc49d1408615e64a" translate="yes" xml:space="preserve">
          <source>The algorithm to compute the SerialVersionUID is described in &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/class.html#stream-unique-identifiers&quot;&gt; Object Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.</source>
          <target state="translated">SerialVersionUID를 계산하는 알고리즘은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/specs/serialization/class.html#stream-unique-identifiers&quot;&gt;객체 직렬화 사양, 섹션 4.6, 스트림 고유 식별자에 설명되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a0c4d1db578d4017bbd26c5ac721b154e166fde" translate="yes" xml:space="preserve">
          <source>The algorithm to compute the SerialVersionUID is described in &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/serialization/class.html#stream-unique-identifiers&quot;&gt; Object Serialization Specification, Section 4.6, Stream Unique Identifiers&lt;/a&gt;.</source>
          <target state="translated">SerialVersionUID를 계산하는 알고리즘은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/serialization/class.html#stream-unique-identifiers&quot;&gt;객체 직렬화 사양, 섹션 4.6, 스트림 고유 식별자에 설명되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a01ab90b6863321fb8006c5a10111bddcd7ece11" translate="yes" xml:space="preserve">
          <source>The algorithm to compute the SerialVersionUID is described in Object Serialization Specification, Section 4.6, Stream Unique Identifiers.</source>
          <target state="translated">SerialVersionUID를 계산하는 알고리즘은 객체 직렬화 사양, 섹션 4.6, 스트림 고유 식별자에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f567977a50b87c4c64f739289bf0274a0cee555" translate="yes" xml:space="preserve">
          <source>The algorithm treats the case where n is a power of two specially: it returns the correct number of high-order bits from the underlying pseudo-random number generator. In the absence of special treatment, the correct number of</source>
          <target state="translated">이 알고리즘은 n이 2의 거듭 제곱 인 경우를 처리합니다. 기본 의사 난수 생성기에서 올바른 수의 상위 비트를 반환합니다. 특별한 대우가 없으면 올바른 수의</target>
        </trans-unit>
        <trans-unit id="cfaae3f12961bc0e6e9294755ef603cdce9972b1" translate="yes" xml:space="preserve">
          <source>The algorithm used herein tests the BeanContextPeer, and its current children to determine if they are either Containers, Components, or if they implement Visibility and return needsGui() == true.</source>
          <target state="translated">여기에 사용 된 알고리즘은 BeanContextPeer 및 현재 하위를 테스트하여 컨테이너, 컴포넌트인지 또는 가시성을 구현하고 needsGui () == true를 리턴하는지 판별합니다.</target>
        </trans-unit>
        <trans-unit id="10dd4c8624a895a56b821b1c12192fac44c25877" translate="yes" xml:space="preserve">
          <source>The algorithm used to convert from pixel values to color and alpha components varies by subclass. For example, there is not necessarily a one-to-one correspondence between samples obtained from the &lt;code&gt;SampleModel&lt;/code&gt; of a &lt;code&gt;BufferedImage&lt;/code&gt; object's &lt;code&gt;Raster&lt;/code&gt; and color/alpha components. Even when there is such a correspondence, the number of bits in a sample is not necessarily the same as the number of bits in the corresponding color/alpha component. Each subclass must specify how the translation from pixel values to color/alpha components is done.</source>
          <target state="translated">픽셀 값에서 색상 및 알파 구성 요소로 변환하는 데 사용되는 알고리즘은 하위 클래스에 따라 다릅니다. 예를 들어, 상기에서 얻은 샘플 간의 일대일 대응이 필요하지 않다 &lt;code&gt;SampleModel&lt;/code&gt; 의 (A)의 &lt;code&gt;BufferedImage&lt;/code&gt; 오브젝트의 &lt;code&gt;Raster&lt;/code&gt; 컬러 / 알파 컴포넌트. 이러한 대응이 있더라도 샘플의 비트 수는 해당 색상 / 알파 성분의 비트 수와 반드시 동일하지는 않습니다. 각 하위 클래스는 픽셀 값에서 색상 / 알파 구성 요소로 변환하는 방법을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6cb3e1bfb6ce2cfa6d3a5700e0fc1aa8f7b1471d" translate="yes" xml:space="preserve">
          <source>The algorithm-independent approach uses the fact that all parameter generators share the concept of a &quot;size&quot; and a source of randomness. The measure of size is universally shared by all algorithm parameters, though it is interpreted differently for different algorithms. For example, in the case of parameters for the</source>
          <target state="translated">알고리즘 독립적 인 접근 방식은 모든 매개 변수 생성기가 &quot;크기&quot;개념과 임의성 소스를 공유한다는 사실을 사용합니다. 크기 측정은 모든 알고리즘 매개 변수가 공통적으로 공유하지만, 알고리즘마다 다르게 해석됩니다. 예를 들어 매개 변수의 경우</target>
        </trans-unit>
        <trans-unit id="cf8486342f66f70d87128cfd826de9b0ef988360" translate="yes" xml:space="preserve">
          <source>The algorithms implemented by class &lt;code&gt;Random&lt;/code&gt; use a &lt;code&gt;protected&lt;/code&gt; utility method that on each invocation can supply up to 32 pseudorandomly generated bits.</source>
          <target state="translated">&lt;code&gt;Random&lt;/code&gt; 클래스에 의해 구현 된 알고리즘 은 각 호출에서 최대 32 개의 의사 난수 생성 비트를 제공 할 수 있는 &lt;code&gt;protected&lt;/code&gt; 유틸리티 메소드를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="2d16bc9d8fcd12891fbdfcf612e7fa19fd0e5d78" translate="yes" xml:space="preserve">
          <source>The alias in the key store to login as. Required when no callback handler is provided. No default value.</source>
          <target state="translated">로그인 할 키 저장소의 별칭입니다. 콜백 핸들러가 제공되지 않은 경우 필요합니다. 기본값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f935ac023e4757a422d3c1d9477a8b333c5e7e8b" translate="yes" xml:space="preserve">
          <source>The aligned day-of-week within a month.</source>
          <target state="translated">한 달 안에 정렬 된 요일입니다.</target>
        </trans-unit>
        <trans-unit id="5b65ab21d464a2cd9f17e050364212fad42369dd" translate="yes" xml:space="preserve">
          <source>The aligned day-of-week within a year.</source>
          <target state="translated">일 년 중 정렬 된 요일입니다.</target>
        </trans-unit>
        <trans-unit id="8a31b06194c7afca8df2f57e58bdedb9af17f0a1" translate="yes" xml:space="preserve">
          <source>The aligned week within a month.</source>
          <target state="translated">한 달 안에 정렬 된 주입니다.</target>
        </trans-unit>
        <trans-unit id="36cc382669e126a3d83f765fd4596aa08b57e640" translate="yes" xml:space="preserve">
          <source>The aligned week within a year.</source>
          <target state="translated">일주일 내에 정렬 된 주.</target>
        </trans-unit>
        <trans-unit id="2ff32c70f78c53b33b9ed02ef7bf5d8a2a244196" translate="yes" xml:space="preserve">
          <source>The alignment, specified as a value between 0.0 and 1.0, inclusive.</source>
          <target state="translated">0.0에서 1.0 사이의 값으로 지정되는 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="886ef7b897d2855c29bd02854779679b05ffaf02" translate="yes" xml:space="preserve">
          <source>The alignment, specified as a value between 0.0 and 1.0, inclusive. To specify centering, the alignment should be 0.5.</source>
          <target state="translated">0.0에서 1.0 사이의 값으로 지정되는 정렬입니다. 센터링을 지정하려면 정렬이 0.5 여야합니다.</target>
        </trans-unit>
        <trans-unit id="be2aadfb060fe765686655310a20b2376b2c5773" translate="yes" xml:space="preserve">
          <source>The allowable values for this hint are</source>
          <target state="translated">이 힌트에 허용되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="faf477dd852c83df2b1921adb3f308581aa65e63" translate="yes" xml:space="preserve">
          <source>The allowable values for this key are</source>
          <target state="translated">이 키에 허용되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26dbbc9f7a0de79a6502b93ab645baa214f96b54" translate="yes" xml:space="preserve">
          <source>The alpha component for the specified pixel, as an int.</source>
          <target state="translated">지정된 픽셀의 알파 구성 요소 (int)입니다.</target>
        </trans-unit>
        <trans-unit id="e05b8cc0941345bc1cb1c86f03f948c5b63217be" translate="yes" xml:space="preserve">
          <source>The alphanumeric characters &quot;&lt;code&gt;a&lt;/code&gt;&quot; through &quot;&lt;code&gt;z&lt;/code&gt;&quot;, &quot;&lt;code&gt;A&lt;/code&gt;&quot; through &quot;&lt;code&gt;Z&lt;/code&gt;&quot; and &quot;&lt;code&gt;0&lt;/code&gt;&quot; through &quot;&lt;code&gt;9&lt;/code&gt;&quot; remain the same.</source>
          <target state="translated">영숫자 문자 &quot; &lt;code&gt;a&lt;/code&gt; &quot;~ &quot; &lt;code&gt;z&lt;/code&gt; &quot;, &quot; &lt;code&gt;A&lt;/code&gt; &quot;~ &quot; &lt;code&gt;Z&lt;/code&gt; &quot;및 &quot; &lt;code&gt;0&lt;/code&gt; &quot;~ &quot; &lt;code&gt;9&lt;/code&gt; &quot;는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4de99a71510486f7e37d746816616f03fc75f487" translate="yes" xml:space="preserve">
          <source>The alt modifier.</source>
          <target state="translated">alt 수정 자.</target>
        </trans-unit>
        <trans-unit id="9d1d12c566ef3dc02aadfadb573407cff3656370" translate="yes" xml:space="preserve">
          <source>The alt modifier. An indicator that the alt key was held down during the event.</source>
          <target state="translated">alt 수정 자. 이벤트 중에 Alt 키를 눌렀 음을 나타내는 표시기입니다.</target>
        </trans-unit>
        <trans-unit id="0d03e6c114b536e99e6fd8371e2230d27e2363b1" translate="yes" xml:space="preserve">
          <source>The alternative way to specify the traversal order of this Container's children is to make this Container a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;focus traversal policy provider&lt;/a&gt;.</source>
          <target state="translated">이 Container 자식의 순회 순서를 지정하는 다른 방법은이 Container를 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;포커스 순회 정책 공급자&lt;/a&gt; 로 만드는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="db16b00dd173e235fbd2087e49d2b0c566b39595" translate="yes" xml:space="preserve">
          <source>The alternative way to specify the traversal order of this Container's children is to make this Container a &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;focus traversal policy provider&lt;/a&gt;.</source>
          <target state="translated">이 Container 자식의 순회 순서를 지정하는 다른 방법은이 Container를 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/api/java.desktop/java/awt/doc-files/FocusSpec.html#FocusTraversalPolicyProviders&quot;&gt;포커스 순회 정책 공급자&lt;/a&gt; 로 만드는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7c0572c1c7ca3bf68a193c2c809c446abfe2afa3" translate="yes" xml:space="preserve">
          <source>The am-pm-of-day.</source>
          <target state="translated">오전-오후.</target>
        </trans-unit>
        <trans-unit id="74edaecf476996f8978f77b9b1cf0182dc658e02" translate="yes" xml:space="preserve">
          <source>The amount by which the capacity of the monitor arrays are automatically incremented when their size becomes greater than their capacity.</source>
          <target state="translated">모니터 어레이의 용량이 용량보다 커지면 모니터 어레이의 용량이 자동으로 증가합니다.</target>
        </trans-unit>
        <trans-unit id="76ff6953115ca652a9f1d9e24eead3f4a4468727" translate="yes" xml:space="preserve">
          <source>The amount by which the capacity of the vector is automatically incremented when its size becomes greater than its capacity.</source>
          <target state="translated">크기가 용량보다 커질 때 벡터의 용량이 자동으로 증가하는 양입니다.</target>
        </trans-unit>
        <trans-unit id="9076e761c5f29e8f67b1371daf80d922283c4c18" translate="yes" xml:space="preserve">
          <source>The amount by which the capacity of the vector is automatically incremented when its size becomes greater than its capacity. If the capacity increment is less than or equal to zero, the capacity of the vector is doubled each time it needs to grow.</source>
          <target state="translated">크기가 용량보다 커지면 벡터 용량이 자동으로 증가하는 양입니다. 용량 증분이 0보다 작거나 같으면 벡터 용량이 커질 때마다 두 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="e58b8d27b0ef7f7a3fd9f8bb646e6646ccb4917d" translate="yes" xml:space="preserve">
          <source>The amount by which the tile grid origin should be offset horizontally from the image origin if tiling has been set, or 0 otherwise.</source>
          <target state="translated">타일링이 설정된 경우 타일 그리드 원점이 이미지 원점에서 수평으로 오프셋되어야하는 양, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="f126ed1fd82891599e13c33def786ee88595c928" translate="yes" xml:space="preserve">
          <source>The amount by which the tile grid origin should be offset horizontally from the image origin if tiling has been set, or 0 otherwise. The initial value is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">바둑판 식 배열이 설정된 경우 타일 격자 원점을 이미지 원점에서 수평으로 오프셋해야하는 양, 그렇지 않으면 0입니다. 초기 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f40ddbdd85fd8b01699d656146c356ca0d61cbc1" translate="yes" xml:space="preserve">
          <source>The amount by which the tile grid origin should be offset vertically from the image origin if tiling has been set, or 0 otherwise.</source>
          <target state="translated">타일링이 설정된 경우 타일 그리드 원점이 이미지 원점에서 수직으로 오프셋되어야하는 양, 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="90dc34eb07729c8e77187523b54e04f1056c08b6" translate="yes" xml:space="preserve">
          <source>The amount by which the tile grid origin should be offset vertically from the image origin if tiling has been set, or 0 otherwise. The initial value is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">바둑판 식 배열을 설정 한 경우 타일 격자 원점을 이미지 원점에서 수직으로 오프셋해야하는 양, 그렇지 않으면 0입니다. 초기 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d8ba62643ca1f13cb1ee68331e33107c86d9257" translate="yes" xml:space="preserve">
          <source>The amount can be thought of as a &lt;code&gt;Map&lt;/code&gt; of &lt;a href=&quot;temporalunit&quot;&gt;&lt;code&gt;TemporalUnit&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;long&lt;/code&gt;, exposed via &lt;a href=&quot;#getUnits()&quot;&gt;&lt;code&gt;getUnits()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#get(java.time.temporal.TemporalUnit)&quot;&gt;&lt;code&gt;get(TemporalUnit)&lt;/code&gt;&lt;/a&gt;. A simple case might have a single unit-value pair, such as &quot;6 hours&quot;. A more complex case may have multiple unit-value pairs, such as &quot;7 years, 3 months and 5 days&quot;.</source>
          <target state="translated">금액은로 생각 될 수있다 &lt;code&gt;Map&lt;/code&gt; 의 &lt;a href=&quot;temporalunit&quot;&gt; &lt;code&gt;TemporalUnit&lt;/code&gt; &lt;/a&gt; 에 &lt;code&gt;long&lt;/code&gt; 통해 노출, &lt;a href=&quot;#getUnits()&quot;&gt; &lt;code&gt;getUnits()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#get(java.time.temporal.TemporalUnit)&quot;&gt; &lt;code&gt;get(TemporalUnit)&lt;/code&gt; &lt;/a&gt; . 간단한 케이스에는 &quot;6 시간&quot;과 같은 단일 단위-값 쌍이있을 수 있습니다. 더 복잡한 케이스에는 &quot;7 년, 3 개월 및 5 일&quot;과 같이 여러 단위 값 쌍이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f834737d8ddeb7615f0e64cb1071bcd66b90fc0e" translate="yes" xml:space="preserve">
          <source>The amount can be thought of as a &lt;code&gt;Map&lt;/code&gt; of &lt;a href=&quot;temporalunit&quot;&gt;&lt;code&gt;TemporalUnit&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;long&lt;/code&gt;, exposed via &lt;a href=&quot;temporalamount#getUnits--&quot;&gt;&lt;code&gt;getUnits()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;temporalamount#get-java.time.temporal.TemporalUnit-&quot;&gt;&lt;code&gt;get(TemporalUnit)&lt;/code&gt;&lt;/a&gt;. A simple case might have a single unit-value pair, such as &quot;6 hours&quot;. A more complex case may have multiple unit-value pairs, such as &quot;7 years, 3 months and 5 days&quot;.</source>
          <target state="translated">금액은로 생각 될 수있다 &lt;code&gt;Map&lt;/code&gt; 의 &lt;a href=&quot;temporalunit&quot;&gt; &lt;code&gt;TemporalUnit&lt;/code&gt; &lt;/a&gt; 에 &lt;code&gt;long&lt;/code&gt; 통해 노출, &lt;a href=&quot;temporalamount#getUnits--&quot;&gt; &lt;code&gt;getUnits()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;temporalamount#get-java.time.temporal.TemporalUnit-&quot;&gt; &lt;code&gt;get(TemporalUnit)&lt;/code&gt; &lt;/a&gt; . 간단한 경우에는 &quot;6 시간&quot;과 같은 단일 단위 값 쌍이있을 수 있습니다. 더 복잡한 경우에는 &quot;7 년, 3 개월 및 5 일&quot;과 같은 여러 단위-값 쌍이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e7f6582eee725100e61f95974a148a4c4b55a89" translate="yes" xml:space="preserve">
          <source>The amount of space above the paragraph.</source>
          <target state="translated">단락 위의 공간입니다.</target>
        </trans-unit>
        <trans-unit id="31bc20173688c8e7fc77e978ebae620749d7ff33" translate="yes" xml:space="preserve">
          <source>The amount of space above the paragraph. Type is float and specifies the size in points.</source>
          <target state="translated">단락 위의 공간입니다. 유형은 부동 소수점이며 크기를 포인트 단위로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0e05553b5933cb5b682bf7fcb78443d9318ae75b" translate="yes" xml:space="preserve">
          <source>The amount of space below the paragraph.</source>
          <target state="translated">단락 아래의 공간입니다.</target>
        </trans-unit>
        <trans-unit id="54fa2c87414099814ad19a2fe8eec923ef1c1afc" translate="yes" xml:space="preserve">
          <source>The amount of space below the paragraph. Type is float and specifies the size in points.</source>
          <target state="translated">단락 아래의 공간입니다. 유형은 부동 소수점이며 크기를 포인트 단위로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3c8b635d9fb74a69cb3609a6fbb145cfad98591d" translate="yes" xml:space="preserve">
          <source>The amount of space between lines of the paragraph.</source>
          <target state="translated">단락 줄 사이의 간격입니다.</target>
        </trans-unit>
        <trans-unit id="951e02d3e0735e5e27ea067a73372607e6249442" translate="yes" xml:space="preserve">
          <source>The amount of space between lines of the paragraph. Type is float and specifies the size as a factor of the line height</source>
          <target state="translated">단락 줄 사이의 간격입니다. 유형은 부동이며 줄 높이의 요소로 크기를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b5e4f4b75f8179292c8fe5fce25461aebd301048" translate="yes" xml:space="preserve">
          <source>The amount of space to indent the first line of the paragraph.</source>
          <target state="translated">단락의 첫 줄을 들여 쓰기 할 공간입니다.</target>
        </trans-unit>
        <trans-unit id="41d3059b2cf56e2bf26016690e4f3f87cff59f51" translate="yes" xml:space="preserve">
          <source>The amount of space to indent the first line of the paragraph. This value may be negative to offset in the reverse direction. The type is Float and specifies the size of the space in points.</source>
          <target state="translated">단락의 첫 줄을 들여 쓰기 할 공간입니다. 이 값은 반대 방향으로 오프셋하려면 음수 일 수 있습니다. 유형은 Float이며 공간의 크기를 포인트 단위로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="96e079013258b0a98e4cf07cec126bc98f35b93b" translate="yes" xml:space="preserve">
          <source>The amount of subdivision of the curved segments is controlled by the &lt;code&gt;flatness&lt;/code&gt; parameter, which specifies the maximum distance that any point on the unflattened transformed curve can deviate from the returned flattened path segments. An optional &lt;a href=&quot;affinetransform&quot;&gt;&lt;code&gt;AffineTransform&lt;/code&gt;&lt;/a&gt; can be specified so that the coordinates returned in the iteration are transformed accordingly.</source>
          <target state="translated">곡선 세그먼트의 세분화 양은 &lt;code&gt;flatness&lt;/code&gt; 매개 변수에 의해 제어됩니다.이 매개 변수 는 평탄화 되지 않은 변형 된 곡선의 모든 점이 반환 된 평평해진 경로 세그먼트에서 벗어날 수있는 최대 거리를 지정합니다. 반복에서 반환 된 좌표가 그에 따라 변환되도록 선택적 &lt;a href=&quot;affinetransform&quot;&gt; &lt;code&gt;AffineTransform&lt;/code&gt; 을&lt;/a&gt; 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed145745ae75cfb21df1e47c533800e93ec11acc" translate="yes" xml:space="preserve">
          <source>The amount of subdivision of the curved segments is controlled by the &lt;code&gt;flatness&lt;/code&gt; parameter, which specifies the maximum distance that any point on the unflattened transformed curve can deviate from the returned flattened path segments. Note that a limit on the accuracy of the flattened path might be silently imposed, causing very small flattening parameters to be treated as larger values. This limit, if there is one, is defined by the particular implementation that is used.</source>
          <target state="translated">곡선 세그먼트의 세분화 양은 &lt;code&gt;flatness&lt;/code&gt; 매개 변수에 의해 제어됩니다.이 매개 변수 는 평탄화 되지 않은 변형 된 곡선의 모든 점이 반환 된 평평해진 경로 세그먼트에서 벗어날 수있는 최대 거리를 지정합니다. 병합 된 경로의 정확도에 대한 제한이 자동으로 부과되어 매우 작은 병합 매개 변수가 더 큰 값으로 처리 될 수 있습니다. 이 제한 (있는 경우)은 사용되는 특정 구현에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="33d418714a49c19fb47687fd2e9fa81de86a9809" translate="yes" xml:space="preserve">
          <source>The amount of used memory in the returned memory usage is the amount of memory occupied by both live objects and garbage objects that have not been collected, if any.</source>
          <target state="translated">리턴 된 메모리 사용량에서 사용한 메모리 양은 수집되지 않은 라이브 오브젝트 및 가비지 오브젝트가 모두 차지하는 메모리 양입니다.</target>
        </trans-unit>
        <trans-unit id="4f98aaf663f717e8039fd97703020e95c45490d3" translate="yes" xml:space="preserve">
          <source>The amount to indent the left side of the paragraph.</source>
          <target state="translated">단락의 왼쪽을 들여 쓰는 양입니다.</target>
        </trans-unit>
        <trans-unit id="488a9e713bc84d3f197568e26a08ccef79288ea8" translate="yes" xml:space="preserve">
          <source>The amount to indent the left side of the paragraph. Type is float and specifies the size in points.</source>
          <target state="translated">단락의 왼쪽을 들여 쓰는 양입니다. 유형은 부동 소수점이며 크기를 포인트 단위로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e2a2a4487dfef7cccab469fcac320564190b4d7e" translate="yes" xml:space="preserve">
          <source>The amount to indent the right side of the paragraph.</source>
          <target state="translated">단락의 오른쪽을 들여 쓰는 양입니다.</target>
        </trans-unit>
        <trans-unit id="61f3f5ffc581163cc2e1a65f64fb331a420b723a" translate="yes" xml:space="preserve">
          <source>The amount to indent the right side of the paragraph. Type is float and specifies the size in points.</source>
          <target state="translated">단락의 오른쪽을 들여 쓰는 양입니다. 유형은 부동 소수점이며 크기를 포인트 단위로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9c935a7fc3a39d6cc8f6aaa5b7f9f5ebb94b6c21" translate="yes" xml:space="preserve">
          <source>The analyzed completeness of the input.</source>
          <target state="translated">분석 된 입력의 완성도입니다.</target>
        </trans-unit>
        <trans-unit id="071df7555bbab5dae809a58615f391d357f053f8" translate="yes" xml:space="preserve">
          <source>The anchor element.</source>
          <target state="translated">앵커 요소.</target>
        </trans-unit>
        <trans-unit id="486b374126917cfb4072a700697af3800a2b9410" translate="yes" xml:space="preserve">
          <source>The anchor element. See the A element definition in HTML 4.0.</source>
          <target state="translated">앵커 요소. HTML 4.0의 A 요소 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57200acee95554fe9255e1ef5f8c2757f96f708f" translate="yes" xml:space="preserve">
          <source>The angle (vertical, horizontal, angled) of each staple with respect to the document depends on the implementation which may in turn depend on the value of the attribute.</source>
          <target state="translated">문서에 대한 각 스테이플의 각도 (수직, 수평, 앵글)는 구현에 따라 달라지며, 속성 값에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="746d708b4410b1c9e8f8ba96c8d12ad3dea602bb" translate="yes" xml:space="preserve">
          <source>The angles are specified relative to the non-square extents of the bounding rectangle such that 45 degrees always falls on the line from the center of the ellipse to the upper right corner of the bounding rectangle. As a result, if the bounding rectangle is noticeably longer in one axis than the other, the angles to the start and end of the arc segment will be skewed farther along the longer axis of the bounds.</source>
          <target state="translated">각도는 경계 직사각형의 정사각형이 아닌 범위에 상대적으로 지정되어 45 도가 항상 경계 직사각형의 타원 중심에서 오른쪽 위 모서리까지의 선에 떨어지도록 지정됩니다. 결과적으로 경계 사각형이 한 축에서 다른 축보다 눈에 띄게 길면 호 세그먼트의 시작 및 끝 각도가 경계의 긴 축을 따라 더 많이 기울어집니다.</target>
        </trans-unit>
        <trans-unit id="eeebfb90efd50664f3427dfe157ce3b0909ad510" translate="yes" xml:space="preserve">
          <source>The angular extent of the arc in degrees.</source>
          <target state="translated">호의 각도 범위 (도)입니다.</target>
        </trans-unit>
        <trans-unit id="56ebb191a856df2f8f893c582ce5c05707593b3e" translate="yes" xml:space="preserve">
          <source>The annotated type satisfies the requirements of a functional interface.</source>
          <target state="translated">주석이 달린 유형은 기능 인터페이스의 요구 사항을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="30fd00f24b91bf4b27ca9bbed8fa14682d926579" translate="yes" xml:space="preserve">
          <source>The annotation returned by this method could contain an element whose value is of type &lt;code&gt;Class&lt;/code&gt;. This value cannot be returned directly: information necessary to locate and load a class (such as the class loader to use) is not available, and the class might not be loadable at all. Attempting to read a &lt;code&gt;Class&lt;/code&gt; object by invoking the relevant method on the returned annotation will result in a &lt;a href=&quot;../type/mirroredtypeexception&quot;&gt;&lt;code&gt;MirroredTypeException&lt;/code&gt;&lt;/a&gt;, from which the corresponding &lt;a href=&quot;../type/typemirror&quot;&gt;&lt;code&gt;TypeMirror&lt;/code&gt;&lt;/a&gt; may be extracted. Similarly, attempting to read a &lt;code&gt;Class[]&lt;/code&gt;-valued element will result in a &lt;a href=&quot;../type/mirroredtypesexception&quot;&gt;&lt;code&gt;MirroredTypesException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 주석에는 값이 &lt;code&gt;Class&lt;/code&gt; 유형의 요소가 포함될 수 있습니다 . 이 값은 직접 리턴 될 수 없습니다. 클래스를 찾아서로드하는 데 필요한 정보 (예 : 사용할 클래스 로더)를 사용할 수 없으며 클래스를 전혀로드 할 수 없습니다. 리턴 된 주석에서 관련 메소드를 호출하여 &lt;code&gt;Class&lt;/code&gt; 오브젝트 를 읽으려고 하면 해당 &lt;a href=&quot;../type/typemirror&quot;&gt; &lt;code&gt;TypeMirror&lt;/code&gt; &lt;/a&gt; 가 추출 될 수 있는 &lt;a href=&quot;../type/mirroredtypeexception&quot;&gt; &lt;code&gt;MirroredTypeException&lt;/code&gt; &lt;/a&gt; 이 발생 합니다. 마찬가지로 &lt;code&gt;Class[]&lt;/code&gt; 값 요소 를 읽으려고 하면 &lt;a href=&quot;../type/mirroredtypesexception&quot;&gt; &lt;code&gt;MirroredTypesException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0e07943efaf6be3152fef21878eaec8919ff3584" translate="yes" xml:space="preserve">
          <source>The annotation returned by this method could contain an element whose value is of type &lt;code&gt;Class&lt;/code&gt;. This value cannot be returned directly: information necessary to locate and load a class (such as the class loader to use) is not available, and the class might not be loadable at all. Attempting to read a &lt;code&gt;Class&lt;/code&gt; object by invoking the relevant method on the returned annotation will result in a &lt;a href=&quot;mirroredtypeexception&quot;&gt;&lt;code&gt;MirroredTypeException&lt;/code&gt;&lt;/a&gt;, from which the corresponding &lt;a href=&quot;typemirror&quot;&gt;&lt;code&gt;TypeMirror&lt;/code&gt;&lt;/a&gt; may be extracted. Similarly, attempting to read a &lt;code&gt;Class[]&lt;/code&gt;-valued element will result in a &lt;a href=&quot;mirroredtypesexception&quot;&gt;&lt;code&gt;MirroredTypesException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드에서 반환 된 주석에는 값이 &lt;code&gt;Class&lt;/code&gt; 유형 인 요소가 포함될 수 있습니다 . 이 값은 직접 반환 할 수 없습니다. 클래스를 찾고로드하는 데 필요한 정보 (예 : 사용할 클래스 로더)를 사용할 수 없으며 클래스를 전혀로드 할 수 없습니다. 반환 된 어노테이션에서 관련 메서드를 호출하여 &lt;code&gt;Class&lt;/code&gt; 객체 를 읽으려고 하면 &lt;a href=&quot;mirroredtypeexception&quot;&gt; &lt;code&gt;MirroredTypeException&lt;/code&gt; &lt;/a&gt; 이 발생하며 여기에서 해당 &lt;a href=&quot;typemirror&quot;&gt; &lt;code&gt;TypeMirror&lt;/code&gt; 를&lt;/a&gt; 추출 할 수 있습니다. 마찬가지로 &lt;code&gt;Class[]&lt;/code&gt; 값 요소 를 읽으려고 하면 &lt;a href=&quot;mirroredtypesexception&quot;&gt; &lt;code&gt;MirroredTypesException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b0a49070278463b21887a752144f83b535b48961" translate="yes" xml:space="preserve">
          <source>The annotation returned by this method could contain an element whose value is of type &lt;code&gt;Class&lt;/code&gt;. This value cannot be returned directly: information necessary to locate and load a class (such as the class loader to use) is not available, and the class might not be loadable at all. Attempting to read a &lt;code&gt;Class&lt;/code&gt; object by invoking the relevant method on the returned annotation will result in a &lt;a href=&quot;type/mirroredtypeexception&quot;&gt;&lt;code&gt;MirroredTypeException&lt;/code&gt;&lt;/a&gt;, from which the corresponding &lt;a href=&quot;type/typemirror&quot;&gt;&lt;code&gt;TypeMirror&lt;/code&gt;&lt;/a&gt; may be extracted. Similarly, attempting to read a &lt;code&gt;Class[]&lt;/code&gt;-valued element will result in a &lt;a href=&quot;type/mirroredtypesexception&quot;&gt;&lt;code&gt;MirroredTypesException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 주석에는 값이 &lt;code&gt;Class&lt;/code&gt; 유형의 요소가 포함될 수 있습니다 . 이 값은 직접 리턴 될 수 없습니다. 클래스를 찾아서로드하는 데 필요한 정보 (예 : 사용할 클래스 로더)를 사용할 수 없으며 클래스를 전혀로드 할 수 없습니다. 리턴 된 주석에서 관련 메소드를 호출하여 &lt;code&gt;Class&lt;/code&gt; 오브젝트 를 읽으려고 하면 해당 &lt;a href=&quot;type/typemirror&quot;&gt; &lt;code&gt;TypeMirror&lt;/code&gt; &lt;/a&gt; 가 추출 될 수 있는 &lt;a href=&quot;type/mirroredtypeexception&quot;&gt; &lt;code&gt;MirroredTypeException&lt;/code&gt; &lt;/a&gt; 이 발생 합니다. 마찬가지로 &lt;code&gt;Class[]&lt;/code&gt; 값 요소 를 읽으려고 하면 &lt;a href=&quot;type/mirroredtypesexception&quot;&gt; &lt;code&gt;MirroredTypesException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="1318a61239cd02c52f57f0f00301e894201c9ba0" translate="yes" xml:space="preserve">
          <source>The annotation shows that the first parameter of the constructor can be retrieved with the &lt;code&gt;getInit()&lt;/code&gt; method, the second one with the &lt;code&gt;getUsed()&lt;/code&gt; method, and so on. Since parameter names are not in general available at runtime, without the annotation there would be no way of knowing which parameter corresponds to which property.</source>
          <target state="translated">주석은 생성자의 첫 번째 매개 변수는 &lt;code&gt;getInit()&lt;/code&gt; 메소드 로 검색 할 수 있고 두 번째 매개 변수 는 &lt;code&gt;getUsed()&lt;/code&gt; 메소드 로 검색 할 수 있음을 보여줍니다 . 매개 변수 이름은 일반적으로 런타임에 사용할 수 없기 때문에 주석이 없으면 어떤 매개 변수가 어떤 속성에 해당하는지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1be4894a9e8c13443a271ac0ee4a590cf0278b93" translate="yes" xml:space="preserve">
          <source>The annotation shows that the first parameter of the constructor can be retrieved with the &lt;code&gt;getX()&lt;/code&gt; method and the second with the &lt;code&gt;getY()&lt;/code&gt; method. Since parameter names are not in general available at runtime, without the annotation there would be no way to know whether the parameters correspond to &lt;code&gt;getX()&lt;/code&gt; and &lt;code&gt;getY()&lt;/code&gt; or the other way around.</source>
          <target state="translated">주석은 생성자의 첫 번째 매개 변수가 &lt;code&gt;getX()&lt;/code&gt; 메소드 로 검색되고 두 번째 매개 변수 는 &lt;code&gt;getY()&lt;/code&gt; 메소드 로 검색 될 수 있음 을 보여 줍니다 . 매개 변수 이름은 런타임에 일반적으로 사용 가능하지 않으므로 주석이 없으면 매개 변수가 &lt;code&gt;getX()&lt;/code&gt; 및 &lt;code&gt;getY()&lt;/code&gt; 해당하는지 아니면 다른 방법으로 해당하는지 알 수있는 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c3e7f1b2fb83a88edaed871cf9cb4d36156ccd28" translate="yes" xml:space="preserve">
          <source>The annotation type &lt;code&gt;java.lang.annotation.Repeatable&lt;/code&gt; is used to indicate that the annotation type whose declaration it (meta-)annotates is &lt;em&gt;repeatable&lt;/em&gt;.</source>
          <target state="translated">어노테이션 유형 &lt;code&gt;java.lang.annotation.Repeatable&lt;/code&gt; 은 선언 (메타) 어노테이션이있는 어노테이션 유형이 &lt;em&gt;반복&lt;/em&gt; 가능함을 표시하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c8eb831e645e1ed4e3178ca8da9b0533b5263c4" translate="yes" xml:space="preserve">
          <source>The annotation type &lt;code&gt;java.lang.annotation.Repeatable&lt;/code&gt; is used to indicate that the annotation type whose declaration it (meta-)annotates is &lt;em&gt;repeatable&lt;/em&gt;. The value of &lt;code&gt;@Repeatable&lt;/code&gt; indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the repeatable annotation type.</source>
          <target state="translated">어노테이션 유형 &lt;code&gt;java.lang.annotation.Repeatable&lt;/code&gt; 은 선언 (메타) 어노테이션이있는 어노테이션 유형이 &lt;em&gt;반복&lt;/em&gt; 가능함을 표시하는 데 사용됩니다 . &lt;code&gt;@Repeatable&lt;/code&gt; 의 값은 반복 가능한 주석 유형에 대한 &lt;em&gt;주석 유형&lt;/em&gt; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="05cc93a1381d4c49da7cb61906da8e017a9db413" translate="yes" xml:space="preserve">
          <source>The annotations returned by this method could contain an element whose value is of type &lt;code&gt;Class&lt;/code&gt;. This value cannot be returned directly: information necessary to locate and load a class (such as the class loader to use) is not available, and the class might not be loadable at all. Attempting to read a &lt;code&gt;Class&lt;/code&gt; object by invoking the relevant method on the returned annotation will result in a &lt;a href=&quot;../type/mirroredtypeexception&quot;&gt;&lt;code&gt;MirroredTypeException&lt;/code&gt;&lt;/a&gt;, from which the corresponding &lt;a href=&quot;../type/typemirror&quot;&gt;&lt;code&gt;TypeMirror&lt;/code&gt;&lt;/a&gt; may be extracted. Similarly, attempting to read a &lt;code&gt;Class[]&lt;/code&gt;-valued element will result in a &lt;a href=&quot;../type/mirroredtypesexception&quot;&gt;&lt;code&gt;MirroredTypesException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드에서 반환 된 주석에는 값이 &lt;code&gt;Class&lt;/code&gt; 유형 인 요소가 포함될 수 있습니다 . 이 값은 직접 반환 할 수 없습니다. 클래스를 찾고로드하는 데 필요한 정보 (예 : 사용할 클래스 로더)를 사용할 수 없으며 클래스를 전혀로드 할 수 없습니다. 반환 된 어노테이션에서 관련 메서드를 호출하여 &lt;code&gt;Class&lt;/code&gt; 객체 를 읽으려고 하면 &lt;a href=&quot;../type/mirroredtypeexception&quot;&gt; &lt;code&gt;MirroredTypeException&lt;/code&gt; &lt;/a&gt; 이 발생하며 여기에서 해당 &lt;a href=&quot;../type/typemirror&quot;&gt; &lt;code&gt;TypeMirror&lt;/code&gt; 를&lt;/a&gt; 추출 할 수 있습니다. 마찬가지로 &lt;code&gt;Class[]&lt;/code&gt; 값 요소 를 읽으려고 하면 &lt;a href=&quot;../type/mirroredtypesexception&quot;&gt; &lt;code&gt;MirroredTypesException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="39634dde1d5bb1fad9936f3184e979c88ab0ad7e" translate="yes" xml:space="preserve">
          <source>The annotations returned by this method could contain an element whose value is of type &lt;code&gt;Class&lt;/code&gt;. This value cannot be returned directly: information necessary to locate and load a class (such as the class loader to use) is not available, and the class might not be loadable at all. Attempting to read a &lt;code&gt;Class&lt;/code&gt; object by invoking the relevant method on the returned annotation will result in a &lt;a href=&quot;mirroredtypeexception&quot;&gt;&lt;code&gt;MirroredTypeException&lt;/code&gt;&lt;/a&gt;, from which the corresponding &lt;a href=&quot;typemirror&quot;&gt;&lt;code&gt;TypeMirror&lt;/code&gt;&lt;/a&gt; may be extracted. Similarly, attempting to read a &lt;code&gt;Class[]&lt;/code&gt;-valued element will result in a &lt;a href=&quot;mirroredtypesexception&quot;&gt;&lt;code&gt;MirroredTypesException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드에서 반환 된 주석에는 값이 &lt;code&gt;Class&lt;/code&gt; 유형 인 요소가 포함될 수 있습니다 . 이 값은 직접 반환 할 수 없습니다. 클래스를 찾고로드하는 데 필요한 정보 (예 : 사용할 클래스 로더)를 사용할 수 없으며 클래스를 전혀로드 할 수 없습니다. 반환 된 어노테이션에서 관련 메서드를 호출하여 &lt;code&gt;Class&lt;/code&gt; 객체 를 읽으려고 하면 &lt;a href=&quot;mirroredtypeexception&quot;&gt; &lt;code&gt;MirroredTypeException&lt;/code&gt; &lt;/a&gt; 이 발생하며 여기에서 해당 &lt;a href=&quot;typemirror&quot;&gt; &lt;code&gt;TypeMirror&lt;/code&gt; 를&lt;/a&gt; 추출 할 수 있습니다. 마찬가지로 &lt;code&gt;Class[]&lt;/code&gt; 값 요소 를 읽으려고 하면 &lt;a href=&quot;mirroredtypesexception&quot;&gt; &lt;code&gt;MirroredTypesException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="124cefaf63ca067dbef195779acbe222323d7001" translate="yes" xml:space="preserve">
          <source>The annotations returned by this method could contain an element whose value is of type &lt;code&gt;Class&lt;/code&gt;. This value cannot be returned directly: information necessary to locate and load a class (such as the class loader to use) is not available, and the class might not be loadable at all. Attempting to read a &lt;code&gt;Class&lt;/code&gt; object by invoking the relevant method on the returned annotation will result in a &lt;a href=&quot;type/mirroredtypeexception&quot;&gt;&lt;code&gt;MirroredTypeException&lt;/code&gt;&lt;/a&gt;, from which the corresponding &lt;a href=&quot;type/typemirror&quot;&gt;&lt;code&gt;TypeMirror&lt;/code&gt;&lt;/a&gt; may be extracted. Similarly, attempting to read a &lt;code&gt;Class[]&lt;/code&gt;-valued element will result in a &lt;a href=&quot;type/mirroredtypesexception&quot;&gt;&lt;code&gt;MirroredTypesException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 주석에는 값이 &lt;code&gt;Class&lt;/code&gt; 유형의 요소가 포함될 수 있습니다 . 이 값은 직접 리턴 될 수 없습니다. 클래스를 찾아서로드하는 데 필요한 정보 (예 : 사용할 클래스 로더)를 사용할 수 없으며 클래스를 전혀로드 할 수 없습니다. 리턴 된 주석에서 관련 메소드를 호출하여 &lt;code&gt;Class&lt;/code&gt; 오브젝트 를 읽으려고 하면 해당 &lt;a href=&quot;type/typemirror&quot;&gt; &lt;code&gt;TypeMirror&lt;/code&gt; &lt;/a&gt; 가 추출 될 수 있는 &lt;a href=&quot;type/mirroredtypeexception&quot;&gt; &lt;code&gt;MirroredTypeException&lt;/code&gt; &lt;/a&gt; 이 발생 합니다. 마찬가지로 &lt;code&gt;Class[]&lt;/code&gt; 값 요소 를 읽으려고 하면 &lt;a href=&quot;type/mirroredtypesexception&quot;&gt; &lt;code&gt;MirroredTypesException&lt;/code&gt; 이 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2a51ff0a60470eb4cb4a051b95fe4f6ba8f896db" translate="yes" xml:space="preserve">
          <source>The applet context is an application that is responsible for loading and running applets. For example, the applet context could be a Web browser or an applet development environment.</source>
          <target state="translated">애플릿 컨텍스트는 애플릿로드 및 실행을 담당하는 응용 프로그램입니다. 예를 들어, 애플릿 컨텍스트는 웹 브라우저 또는 애플릿 개발 환경 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d0d975f376e5b19fe7a1f075e883131442868b9" translate="yes" xml:space="preserve">
          <source>The applet framework involves two entities: the</source>
          <target state="translated">애플릿 프레임 워크에는 두 개의 엔티티가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="05cf45d45200392a55a02f920db72d76c4e7695b" translate="yes" xml:space="preserve">
          <source>The application can also use this interface to redirect system identifiers to local URIs or to look up replacements in a catalog (possibly by using the public identifier).</source>
          <target state="translated">애플리케이션은 또한이 인터페이스를 사용하여 시스템 식별자를 로컬 URI로 리디렉션하거나 카탈로그에서 대체 항목을 조회 할 수 있습니다 (공용 식별자 사용 가능).</target>
        </trans-unit>
        <trans-unit id="43a63ff0f07c9418e757018f02f139d365b1225c" translate="yes" xml:space="preserve">
          <source>The application can call &lt;a href=&quot;#isEstablished()&quot;&gt;&lt;code&gt;isEstablished&lt;/code&gt;&lt;/a&gt; to determine if the context establishment phase is complete for this peer. A return value of &lt;code&gt;false&lt;/code&gt; from &lt;code&gt;isEstablished&lt;/code&gt; indicates that more tokens are expected to be supplied to this method. Upon completion of the context establishment, the available context options may be queried through the get methods.</source>
          <target state="translated">애플리케이션은 &lt;a href=&quot;#isEstablished()&quot;&gt; &lt;code&gt;isEstablished&lt;/code&gt; &lt;/a&gt; 를 호출 하여이 피어에 대한 컨텍스트 설정 단계가 완료되었는지 판별 할 수 있습니다 . &lt;code&gt;isEstablished&lt;/code&gt; 에서 반환 값이 &lt;code&gt;false&lt;/code&gt; 이면이 메서드에 더 많은 토큰이 제공 될 것으로 예상됩니다. 컨텍스트 설정이 완료되면 get 메소드를 통해 사용 가능한 컨텍스트 옵션을 조회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="197ab2a881a32f8f812c8cba1a4699d78ddeac9a" translate="yes" xml:space="preserve">
          <source>The application can then use &lt;code&gt;SyncResolver&lt;/code&gt; methods to get information about each conflict and decide what to do. If the application logic or the user decides that a value in the &lt;code&gt;RowSet&lt;/code&gt; object should be the one to persist, the application or user can overwrite the data source value with it.</source>
          <target state="translated">그런 다음 애플리케이션은 &lt;code&gt;SyncResolver&lt;/code&gt; 메소드를 사용 하여 각 충돌에 대한 정보를 얻고 수행 할 작업을 결정할 수 있습니다. 응용 프로그램 논리 또는 사용자가 &lt;code&gt;RowSet&lt;/code&gt; 개체 의 값 이 지속되어야한다고 결정 하면 응용 프로그램이나 사용자가 데이터 원본 값을 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ffb63d507b41e909d69572c31f7399dc454ec2" translate="yes" xml:space="preserve">
          <source>The application can use this method to instruct the SAX parser to begin parsing an XML document from any valid input source (a character stream, a byte stream, or a URI).</source>
          <target state="translated">응용 프로그램은이 메서드를 사용하여 유효한 입력 소스 (문자 스트림, 바이트 스트림 또는 URI)에서 XML 문서 구문 분석을 시작하도록 SAX 구문 분석기에 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad4989a5d05b7103401b638caaf9f834a979efe4" translate="yes" xml:space="preserve">
          <source>The application can use this method to instruct the XML reader to begin parsing an XML document from any valid input source (a character stream, a byte stream, or a URI).</source>
          <target state="translated">응용 프로그램은이 메서드를 사용하여 유효한 입력 소스 (문자 스트림, 바이트 스트림 또는 URI)에서 XML 문서의 구문 분석을 시작하도록 XML 판독기에 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fd5aba49e8b7cd3886958446edf7a85706d7f07" translate="yes" xml:space="preserve">
          <source>The application does not care about what provider is used (the default case).</source>
          <target state="translated">응용 프로그램은 어떤 공급자가 사용되는지 (기본 케이스) 상관하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="528ad56c45da427cafb5a2892f4c9dbaa6da9f0e" translate="yes" xml:space="preserve">
          <source>The application is expected to provide objects that implement this interface whenever such objects are needed. The application can either provide its own objects that implement this interface, or it can use the generic factory method &lt;code&gt;DOMImplementationLS.createLSInput()&lt;/code&gt; to create objects that implement this interface.</source>
          <target state="translated">응용 프로그램은 이러한 개체가 필요할 때마다이 인터페이스를 구현하는 개체를 제공해야합니다. 응용 프로그램은이 인터페이스를 구현하는 자체 개체를 제공하거나 일반 팩토리 메서드 &lt;code&gt;DOMImplementationLS.createLSInput()&lt;/code&gt; 을 사용하여이 인터페이스를 구현하는 개체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0077397bcab7795c70697b20b7676749c6ece6e6" translate="yes" xml:space="preserve">
          <source>The application is expected to provide objects that implement this interface whenever such objects are needed. The application can either provide its own objects that implement this interface, or it can use the generic factory method &lt;code&gt;DOMImplementationLS.createLSOutput()&lt;/code&gt; to create objects that implement this interface.</source>
          <target state="translated">응용 프로그램은 이러한 개체가 필요할 때마다이 인터페이스를 구현하는 개체를 제공해야합니다. 응용 프로그램은이 인터페이스를 구현하는 자체 객체를 제공하거나 일반 팩토리 메소드 &lt;code&gt;DOMImplementationLS.createLSOutput()&lt;/code&gt; 을 사용하여이 인터페이스를 구현하는 객체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0e7f0049df502b987281c3346589bd6cffbab2b" translate="yes" xml:space="preserve">
          <source>The application is responsible for reliably obtaining the network data from the peer, and for invoking unwrap() on the data in the order it was received. The application must properly synchronize multiple calls to this method.</source>
          <target state="translated">응용 프로그램은 피어에서 네트워크 데이터를 안정적으로 가져오고 수신 된 순서대로 데이터에 대해 unwrap ()을 호출해야합니다. 애플리케이션은이 메소드에 대한 여러 호출을 올바르게 동기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a9de3f971900bc689d7e04c1be8704459fc234c" translate="yes" xml:space="preserve">
          <source>The application is responsible for reliably transporting the network data to the peer, and for ensuring that data created by multiple calls to wrap() is transported in the same order in which it was generated. The application must properly synchronize multiple calls to this method.</source>
          <target state="translated">응용 프로그램은 네트워크 데이터를 피어로 안정적으로 전송하고 wrap ()에 대한 여러 호출로 작성된 데이터가 생성 된 순서와 동일한 순서로 전송되도록합니다. 애플리케이션은이 메소드에 대한 여러 호출을 올바르게 동기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f83084225c68b8bb9818111775b9d435a186f48" translate="yes" xml:space="preserve">
          <source>The application module path</source>
          <target state="translated">애플리케이션 모듈 경로</target>
        </trans-unit>
        <trans-unit id="24a382f6bd333e0f3daa49b7feec798cbfe8d141" translate="yes" xml:space="preserve">
          <source>The application module path. This path contains compiled definitions of library and application modules.</source>
          <target state="translated">애플리케이션 모듈 경로입니다. 이 경로에는 라이브러리 및 애플리케이션 모듈의 컴파일 된 정의가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="492930b1c26560af84c461727aeb835e9331724d" translate="yes" xml:space="preserve">
          <source>The application must assume that the document is unusable after the parser has invoked this method, and should continue (if at all) only for the sake of collecting additional error messages: in fact, SAX parsers are free to stop reporting any other events once this method has been invoked.</source>
          <target state="translated">응용 프로그램은 파서가이 메서드를 호출 한 후 문서를 사용할 수 없다고 가정해야하며 추가 오류 메시지를 수집하기 위해서만 계속해야합니다. 메소드가 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="62db49d3db787af33b9c941978c4e99dc61cb13f" translate="yes" xml:space="preserve">
          <source>The application must not attempt to read from the array outside of the specified range.</source>
          <target state="translated">애플리케이션은 지정된 범위를 벗어난 배열에서 읽기를 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="430098f5fdc52060873446cbe704ed4ec2f907a5" translate="yes" xml:space="preserve">
          <source>The application resource files (&lt;code&gt;jndi.properties&lt;/code&gt;).</source>
          <target state="translated">애플리케이션 자원 파일 ( &lt;code&gt;jndi.properties&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e17b5b526cb20504035514498f620be9bcb8a571" translate="yes" xml:space="preserve">
          <source>The application should retain its own reference to the Logger object to avoid it being garbage collected. The LogManager may only retain a weak reference.</source>
          <target state="translated">가비지 수집을 피하려면 응용 프로그램에서 Logger 객체에 대한 자체 참조를 유지해야합니다. LogManager는 약한 참조 만 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70c35120b966bbbc27374090d748d52f2c0cd17b" translate="yes" xml:space="preserve">
          <source>The application that is using the DOM implementation is expected to implement this interface.</source>
          <target state="translated">DOM 구현을 사용하는 애플리케이션은이 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e15d8ec0489f75d8de5272df1a1bbd215255877" translate="yes" xml:space="preserve">
          <source>The application wants a particular provider to be used preferentially, either for a particular mechanism or all the time, irrespective of mechanism.</source>
          <target state="translated">애플리케이션은 특정 메커니즘에 대해 또는 메커니즘에 관계없이 항상 특정 공급자를 우선적으로 사용하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="a673c682f810cb47abb70c8f49a523ff232f34eb" translate="yes" xml:space="preserve">
          <source>The application wants to use the locally configured providers as far as possible but if support is missing for one or more mechanisms then it wants to fall back on its own provider.</source>
          <target state="translated">응용 프로그램은 가능한 한 로컬로 구성된 공급자를 사용하려고하지만 하나 이상의 메커니즘에 대한 지원이 누락 된 경우 자체 공급자로 대체하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a52404cc107f1ef484b4f6010d7b0991ee6878d4" translate="yes" xml:space="preserve">
          <source>The application will be responsible for sending the token to the peer.</source>
          <target state="translated">애플리케이션은 토큰을 피어에게 보내는 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="65cbe22589c33b2fcbca4e92f7cdbcc0d67ba66f" translate="yes" xml:space="preserve">
          <source>The application will be responsible for sending the token to the peer. Typically, the application would ensure this by calling the &lt;a href=&quot;../../../../java.base/java/io/outputstream#flush()&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; method on an &lt;code&gt;OutputStream&lt;/code&gt; that encapsulates the connection between the two peers.</source>
          <target state="translated">애플리케이션은 토큰을 피어에게 보내는 책임이 있습니다. 일반적으로 응용 프로그램은 두 피어 간의 연결을 캡슐화 하는 &lt;code&gt;OutputStream&lt;/code&gt; 에서 &lt;a href=&quot;../../../../java.base/java/io/outputstream#flush()&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여이를 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="78c8eb514e9857e5665de81ae11d8cacb10ac02f" translate="yes" xml:space="preserve">
          <source>The appropriate &lt;code&gt;DragGestureRecognizer&lt;/code&gt; subclass instance is obtained from the &lt;a href=&quot;dragsource&quot;&gt;&lt;code&gt;DragSource&lt;/code&gt;&lt;/a&gt; associated with a particular &lt;code&gt;Component&lt;/code&gt;, or from the &lt;code&gt;Toolkit&lt;/code&gt; object via its &lt;a href=&quot;../toolkit#createDragGestureRecognizer(java.lang.Class,java.awt.dnd.DragSource,java.awt.Component,int,java.awt.dnd.DragGestureListener)&quot;&gt;&lt;code&gt;createDragGestureRecognizer()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">적절한 &lt;code&gt;DragGestureRecognizer&lt;/code&gt; 하위 클래스 인스턴스는 특정 &lt;code&gt;Component&lt;/code&gt; 에 연결된 &lt;a href=&quot;dragsource&quot;&gt; &lt;code&gt;DragSource&lt;/code&gt; &lt;/a&gt; 에서 얻 거나 &lt;a href=&quot;../toolkit#createDragGestureRecognizer(java.lang.Class,java.awt.dnd.DragSource,java.awt.Component,int,java.awt.dnd.DragGestureListener)&quot;&gt; &lt;code&gt;createDragGestureRecognizer()&lt;/code&gt; &lt;/a&gt; 메서드 를 통해 &lt;code&gt;Toolkit&lt;/code&gt; 개체 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3fcee94e7e9528705654f860965116639d53c580" translate="yes" xml:space="preserve">
          <source>The approximate index in the pattern of the error, or &lt;code&gt;-1&lt;/code&gt; if the index is not known</source>
          <target state="translated">오류 패턴의 근사 색인 또는 색인을 알 수없는 경우 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fd826b5f3e4e5c2eb31198d40e2ef051276f4dc" translate="yes" xml:space="preserve">
          <source>The area inside the polygon is defined using an even-odd fill rule, also known as the alternating rule.</source>
          <target state="translated">다각형 내부 영역은 교대 규칙이라고도하는 짝수 홀수 채우기 규칙을 사용하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="419d0d58a09314d4bafea3e4f16b707dfcaedd5d" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;action&lt;/code&gt; should be one of &lt;code&gt;DnDConstants&lt;/code&gt; that represents a single action. This constructor does not throw any exception for invalid &lt;code&gt;action&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;action&lt;/code&gt; 는 단일 조치를 나타내는 &lt;code&gt;DnDConstants&lt;/code&gt; 중 하나 여야합니다 . 이 생성자는 잘못된 &lt;code&gt;action&lt;/code&gt; 대한 예외를 throw하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="67d1d866bf4648b082727fe60e90f5387a6b5589" translate="yes" xml:space="preserve">
          <source>The argument becomes the current set of system properties for use by the &lt;a href=&quot;#getProperty(java.lang.String)&quot;&gt;&lt;code&gt;getProperty(String)&lt;/code&gt;&lt;/a&gt; method. If the argument is &lt;code&gt;null&lt;/code&gt;, then the current set of system properties is forgotten.</source>
          <target state="translated">인수는 &lt;a href=&quot;#getProperty(java.lang.String)&quot;&gt; &lt;code&gt;getProperty(String)&lt;/code&gt; &lt;/a&gt; 메서드 에서 사용할 현재 시스템 속성 집합이됩니다 . 인수가 &lt;code&gt;null&lt;/code&gt; 이면 현재 시스템 속성 집합을 잊습니다.</target>
        </trans-unit>
        <trans-unit id="d18258b8a09318c0fe716980f2513c6b7d689eb8" translate="yes" xml:space="preserve">
          <source>The argument becomes the current set of system properties for use by the &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt;&lt;code&gt;getProperty(String)&lt;/code&gt;&lt;/a&gt; method. If the argument is &lt;code&gt;null&lt;/code&gt;, then the current set of system properties is forgotten.</source>
          <target state="translated">인수는 &lt;a href=&quot;system#getProperty-java.lang.String-&quot;&gt; &lt;code&gt;getProperty(String)&lt;/code&gt; &lt;/a&gt; 메소드 에서 사용하기위한 현재 시스템 특성 세트가됩니다 . 인수가 &lt;code&gt;null&lt;/code&gt; 인 경우, 현재의 시스템 프로퍼티 세트를 잊어 버립니다.</target>
        </trans-unit>
        <trans-unit id="3eda6b061d52f9633b11dd4adf55839255cf403b" translate="yes" xml:space="preserve">
          <source>The argument index is a decimal integer indicating the position of the argument in the argument list. The first argument is referenced by &quot;&lt;code&gt;1$&lt;/code&gt;&quot;, the second by &quot;&lt;code&gt;2$&lt;/code&gt;&quot;, etc.</source>
          <target state="translated">인수 색인은 인수 목록에서 인수의 위치를 ​​나타내는 10 진 정수입니다. 첫 번째 인수는 &quot; &lt;code&gt;1$&lt;/code&gt; &quot;로, 두 번째 인수는 &quot; &lt;code&gt;2$&lt;/code&gt; &quot;등으로 참조됩니다 .</target>
        </trans-unit>
        <trans-unit id="36fe37d9ecd17b34dcfdd919af406581f5ff63ca" translate="yes" xml:space="preserve">
          <source>The argument is appended to the contents of this sequence. The length of this sequence increases by &lt;a href=&quot;character#charCount(int)&quot;&gt;&lt;code&gt;Character.charCount(codePoint)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수는이 시퀀스의 내용에 추가됩니다. 이 시퀀스의 길이는 &lt;a href=&quot;character#charCount(int)&quot;&gt; &lt;code&gt;Character.charCount(codePoint)&lt;/code&gt; &lt;/a&gt; 만큼 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="99ae0b95c82d7e5d456a4b05f7772782c73566c3" translate="yes" xml:space="preserve">
          <source>The argument is appended to the contents of this sequence. The length of this sequence increases by &lt;a href=&quot;character#charCount-int-&quot;&gt;&lt;code&gt;Character.charCount(codePoint)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 순서의 내용에 인수가 추가됩니다. 이 순서의 길이는 &lt;a href=&quot;character#charCount-int-&quot;&gt; &lt;code&gt;Character.charCount(codePoint)&lt;/code&gt; &lt;/a&gt; 만큼 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="530578e360d335fe358bf50135b12bdaa9833c94" translate="yes" xml:space="preserve">
          <source>The argument is appended to the contents of this sequence. The length of this sequence increases by &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">이 순서의 내용에 인수가 추가됩니다. 이 시퀀스의 길이는 &lt;code&gt;1&lt;/code&gt; 씩 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="788a7a6ce6c9ea62e7dc789924dd4e36ba49ea04" translate="yes" xml:space="preserve">
          <source>The argument is treated as the name of a system property to be obtained. The string value of this property is then interpreted as an integer which is then converted to a &lt;code&gt;Color&lt;/code&gt; object.</source>
          <target state="translated">인수는 확보 할 시스템 특성의 이름으로 처리됩니다. 이 속성의 문자열 값은 정수로 해석 된 다음 &lt;code&gt;Color&lt;/code&gt; 객체 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f6d8165e4787ec54c7633c17f8460e647d868e0" translate="yes" xml:space="preserve">
          <source>The argument list for this method includes three fixed parameters, corresponding to the parameters automatically stacked by the VM for the bootstrap method in an &lt;code&gt;invokedynamic&lt;/code&gt; invocation, and an &lt;code&gt;Object[]&lt;/code&gt; parameter that contains additional parameters. The declared argument list for this method is:</source>
          <target state="translated">이 메소드의 인수 목록에는 3 개의 고정 매개 변수가 있으며, 이는 호출 &lt;code&gt;invokedynamic&lt;/code&gt; 호출 에서 부트 스트랩 메소드를 위해 VM에 의해 자동으로 누적 된 매개 변수 및 추가 매개 변수를 포함 하는 &lt;code&gt;Object[]&lt;/code&gt; 매개 변수를 포함합니다. 이 메소드에 선언 된 인수 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fb9985f7d13d4b1f9cd222839ca8db9be97981a" translate="yes" xml:space="preserve">
          <source>The argument list of the implementation method and the argument list of the interface method(s) may differ in several ways. The implementation methods may have additional arguments to accommodate arguments captured by the lambda expression; there may also be differences resulting from permitted adaptations of arguments, such as casting, boxing, unboxing, and primitive widening. (Varargs adaptations are not handled by the metafactories; these are expected to be handled by the caller.)</source>
          <target state="translated">구현 메소드의 인수 목록과 인터페이스 메소드의 인수 목록은 몇 가지면에서 다를 수 있습니다. 구현 방법은 람다 식에 의해 포착 된 인수를 수용하기위한 추가 인수를 가질 수있다. 캐스팅, 복싱, 언 박싱 및 기본 확장과 같은 인수의 허용 된 조정으로 인해 차이가있을 수도 있습니다. (Varargs 적응은 메타 팩터에 의해 처리되지 않으며, 호출자가 처리해야합니다.)</target>
        </trans-unit>
        <trans-unit id="12d5e1c43667219539fb595ce70de6f6a54bd967" translate="yes" xml:space="preserve">
          <source>The argument map associates argument name strings to instances of &lt;a href=&quot;connector.argument&quot;&gt;&lt;code&gt;Connector.Argument&lt;/code&gt;&lt;/a&gt;. The default argument map for a connector can be obtained through &lt;a href=&quot;connector#defaultArguments()&quot;&gt;&lt;code&gt;Connector.defaultArguments()&lt;/code&gt;&lt;/a&gt;. Argument map values can be changed, but map entries should not be added or deleted.</source>
          <target state="translated">인수 맵은 인수 이름 문자열을 &lt;a href=&quot;connector.argument&quot;&gt; &lt;code&gt;Connector.Argument&lt;/code&gt; &lt;/a&gt; 인스턴스에 연결 합니다. 커넥터의 기본 인수 맵은 &lt;a href=&quot;connector#defaultArguments()&quot;&gt; &lt;code&gt;Connector.defaultArguments()&lt;/code&gt; &lt;/a&gt; 를 통해 얻을 수 있습니다 . 인수 맵 값은 변경할 수 있지만 맵 항목을 추가하거나 삭제하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="dba085c7b50d6043549c3ebae9230f8d1dc02715" translate="yes" xml:space="preserve">
          <source>The argument string may consist of either a level name or an integer value.</source>
          <target state="translated">인수 문자열은 레벨 이름 또는 정수 값으로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a409707495e7aa4d57fd8347009cb66d93f0721f" translate="yes" xml:space="preserve">
          <source>The argument types (if any) of the filter replace zero or one argument types of the target, at position &lt;code&gt;pos&lt;/code&gt;, in the resulting adapted method handle. The return type of the filter (if any) must be identical to the argument type of the target at position &lt;code&gt;pos&lt;/code&gt;, and that target argument is supplied by the return value of the filter.</source>
          <target state="translated">필터의 인수 유형 (있는 경우)은 결과로 조정 된 메소드 핸들 에서 위치 &lt;code&gt;pos&lt;/code&gt; 에서 대상의 0 또는 1 개의 인수 유형을 대체합니다 . 필터의 리턴 유형 (있는 경우)은 &lt;code&gt;pos&lt;/code&gt; 위치에있는 대상의 인수 유형과 동일해야하며 해당 대상 인수는 필터의 리턴 값에 의해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8f1d3710045d57635ae5591d4ec802d1c9820287" translate="yes" xml:space="preserve">
          <source>The argument types (if any) of the filter replace zero or one coordinate types of the target var handle, at position &lt;code&gt;pos&lt;/code&gt;, in the resulting adapted var handle. The return type of the filter must be identical to the coordinate type of the target var handle at position &lt;code&gt;pos&lt;/code&gt;, and that target var handle coordinate is supplied by the return value of the filter.</source>
          <target state="translated">필터의 인수 유형 (있는 경우)은 결과로 조정 된 var 핸들 에서 위치 &lt;code&gt;pos&lt;/code&gt; 에서 대상 var 핸들의 0 개 또는 1 개의 좌표 유형을 대체합니다 . 필터의 반환 유형은 &lt;code&gt;pos&lt;/code&gt; 위치에있는 대상 var 핸들의 좌표 유형과 동일해야하며 해당 대상 var 핸들 좌표는 필터의 반환 값에 의해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a2449a6e62dbf9e8a64d2cd3671941b111814ddd" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;dropAction&lt;/code&gt; and &lt;code&gt;action&lt;/code&gt; should be one of &lt;code&gt;DnDConstants&lt;/code&gt; that represents a single action. The argument &lt;code&gt;modifiers&lt;/code&gt; should be either a bitwise mask of old &lt;code&gt;java.awt.event.InputEvent.*_MASK&lt;/code&gt; constants or a bitwise mask of extended &lt;code&gt;java.awt.event.InputEvent.*_DOWN_MASK&lt;/code&gt; constants. This constructor does not throw any exception for invalid &lt;code&gt;dropAction&lt;/code&gt;, &lt;code&gt;action&lt;/code&gt; and &lt;code&gt;modifiers&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dropAction&lt;/code&gt; 및 &lt;code&gt;action&lt;/code&gt; 인수 는 단일 조치를 나타내는 &lt;code&gt;DnDConstants&lt;/code&gt; 중 하나 여야합니다 . 인수 &lt;code&gt;modifiers&lt;/code&gt; 이전 &lt;code&gt;java.awt.event.InputEvent.*_MASK&lt;/code&gt; 상수의 비트 마스크이거나 확장 &lt;code&gt;java.awt.event.InputEvent.*_DOWN_MASK&lt;/code&gt; 상수 의 비트 마스크 여야 합니다. 이 생성자는 유효하지 않은 &lt;code&gt;dropAction&lt;/code&gt; , &lt;code&gt;action&lt;/code&gt; 및 &lt;code&gt;modifiers&lt;/code&gt; 대한 예외를 발생시키지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a71e8602f21bd4d85dc70744b51fdc810e20bd61" translate="yes" xml:space="preserve">
          <source>The arguments give the indices of the effected range and are in terms of the model &lt;b&gt;before&lt;/b&gt; the change. For example, if you have a 5-row model and delete 3 items from the end of the model the indices are 2, 4.</source>
          <target state="translated">인수는 영향을받는 범위의 인덱스를 제공 하며 변경 &lt;b&gt;전의&lt;/b&gt; 모델을 기준으로합니다 . 예를 들어, 5 행 모델이 있고 모델 끝에서 3 개 항목을 삭제하는 경우 인덱스는 2, 4입니다.</target>
        </trans-unit>
        <trans-unit id="6c069c9968d777122dec0d4b2b0c61810dea5208" translate="yes" xml:space="preserve">
          <source>The arguments give the indices of the effected range. The first argument is in terms of the model before the change, and must be less than or equal to the size of the model before the change. The second argument is in terms of the model after the change and must be less than the size of the model after the change. For example, if you have a 5-row model and add 3 items to the end of the model the indices are 5, 7.</source>
          <target state="translated">인수는 영향을받는 범위의 인덱스를 제공합니다. 첫 번째 인수는 변경 전 모델에 관한 것이며 변경 전 모델 크기보다 작거나 같아야합니다. 두 번째 인수는 변경 후 모델과 관련이 있으며 변경 후 모델 크기보다 작아야합니다. 예를 들어 5 행 모델이 있고 모델 끝에 3 개 항목을 추가하면 인덱스는 5, 7입니다.</target>
        </trans-unit>
        <trans-unit id="c7a1affcb922dffb08b9bc26f38f2fcd2ff544f2" translate="yes" xml:space="preserve">
          <source>The arguments to this method provide the state of the phaser prevailing for the current transition. The effects of invoking arrival, registration, and waiting methods on this phaser from within &lt;code&gt;onAdvance&lt;/code&gt; are unspecified and should not be relied on.</source>
          <target state="translated">이 방법에 대한 인수는 현재 전환에 널리 사용되는 페이저의 상태를 제공합니다. &lt;code&gt;onAdvance&lt;/code&gt; 내에서이 페이저에 대한 도착, 등록 및 대기 방법 호출의 영향 은 지정되지 않았으며 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6a5780e32ca901cbb32b194668ffd8aed9709eb9" translate="yes" xml:space="preserve">
          <source>The arguments' type in the argument list should be a Java primitive type or a Java basic type (&lt;code&gt;java.lang.Boolean, java.lang.Byte, java.lang.Short, java.lang.Long, java.lang.Integer, java.lang.Float, java.lang.Double, java.lang.String&lt;/code&gt;).</source>
          <target state="translated">인수 목록의 인수 유형은 Java 기본 유형 또는 Java 기본 유형 ( &lt;code&gt;java.lang.Boolean, java.lang.Byte, java.lang.Short, java.lang.Long, java.lang.Integer, java.lang.Float, java.lang.Double, java.lang.String&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e3eff702de68d57af015cf4b99e531b32b5ea13c" translate="yes" xml:space="preserve">
          <source>The arithmetic mean of values, or zero if none</source>
          <target state="translated">값의 산술 평균 또는없는 경우 0</target>
        </trans-unit>
        <trans-unit id="eb1c1d45501fcca075791bbb3a7622bf9d201af7" translate="yes" xml:space="preserve">
          <source>The arity and types of arguments to the invocation of an access mode method are not checked statically. Instead, each access mode method specifies an &lt;a href=&quot;#accessModeType(java.lang.invoke.VarHandle.AccessMode)&quot;&gt;&lt;code&gt;access mode type&lt;/code&gt;&lt;/a&gt;, represented as an instance of &lt;a href=&quot;methodtype&quot;&gt;&lt;code&gt;MethodType&lt;/code&gt;&lt;/a&gt;, that serves as a kind of method signature against which the arguments are checked dynamically. An access mode type gives formal parameter types in terms of the coordinate types of a VarHandle instance and the types for values of importance to the access mode. An access mode type also gives a return type, often in terms of the variable type of a VarHandle instance. When an access mode method is invoked on a VarHandle instance, the symbolic type descriptor at the call site, the run time types of arguments to the invocation, and the run time type of the return value, must &lt;a href=&quot;#invoke&quot;&gt;match&lt;/a&gt; the types given in the access mode type. A runtime exception will be thrown if the match fails. For example, the access mode method &lt;a href=&quot;#compareAndSet(java.lang.Object...)&quot;&gt;&lt;code&gt;compareAndSet(java.lang.Object...)&lt;/code&gt;&lt;/a&gt; specifies that if its receiver is a VarHandle instance with coordinate types &lt;code&gt;CT1, ..., CTn&lt;/code&gt; and variable type &lt;code&gt;T&lt;/code&gt;, then its access mode type is &lt;code&gt;(CT1 c1, ..., CTn cn, T expectedValue, T newValue)boolean&lt;/code&gt;. Suppose that a VarHandle instance can access array elements, and that its coordinate types are &lt;code&gt;String[]&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; while its variable type is &lt;code&gt;String&lt;/code&gt;. The access mode type for &lt;code&gt;compareAndSet&lt;/code&gt; on this VarHandle instance would be &lt;code&gt;(String[] c1, int c2, String expectedValue, String newValue)boolean&lt;/code&gt;. Such a VarHandle instance may be produced by the &lt;a href=&quot;methodhandles#arrayElementVarHandle(java.lang.Class)&quot;&gt;&lt;code&gt;array factory method&lt;/code&gt;&lt;/a&gt; and access array elements as follows:</source>
          <target state="translated">액세스 모드 메서드 호출에 대한 인수의 배열과 유형은 정적으로 확인되지 않습니다. 대신 각 액세스 모드 메서드 는 인수가 동적으로 확인되는 메서드 서명의 일종으로 사용되는 &lt;a href=&quot;methodtype&quot;&gt; &lt;code&gt;MethodType&lt;/code&gt; &lt;/a&gt; 인스턴스로 표시 되는 &lt;a href=&quot;#accessModeType(java.lang.invoke.VarHandle.AccessMode)&quot;&gt; &lt;code&gt;access mode type&lt;/code&gt; &lt;/a&gt; 지정합니다 . 액세스 모드 유형은 VarHandle 인스턴스의 좌표 유형과 액세스 모드에 중요한 값의 유형 측면에서 형식 매개 변수 유형을 제공합니다. 액세스 모드 유형은 또한 종종 VarHandle 인스턴스의 변수 유형 측면에서 반환 유형을 제공합니다. 액세스 모드 메서드가 VarHandle 인스턴스에서 호출되면 호출 사이트의 기호 형식 설명자, 호출에 대한 인수의 런타임 형식 및 반환 값의 런타임 형식이&lt;a href=&quot;#invoke&quot;&gt;&lt;/a&gt;액세스 모드 유형에 지정된 유형 과 일치 합니다. 일치가 실패하면 런타임 예외가 발생합니다. 예를 들어, 액세스 모드 메소드 &lt;a href=&quot;#compareAndSet(java.lang.Object...)&quot;&gt; &lt;code&gt;compareAndSet(java.lang.Object...)&lt;/code&gt; &lt;/a&gt; 는 수신자가 좌표 유형 &lt;code&gt;CT1, ..., CTn&lt;/code&gt; 및 변수 유형 &lt;code&gt;T&lt;/code&gt; 인 VarHandle 인스턴스 인 경우 액세스 모드 유형이 &lt;code&gt;(CT1 c1, ..., CTn cn, T expectedValue, T newValue)boolean&lt;/code&gt; 임을 지정합니다. c1, ..., CTn cn, T expectedValue, T newValue) boolean . VarHandle 인스턴스가 배열 요소에 액세스 할 수 있고 좌표 유형이 &lt;code&gt;String[]&lt;/code&gt; 및 &lt;code&gt;int&lt;/code&gt; 이고 변수 유형이 &lt;code&gt;String&lt;/code&gt; 이라고 가정 합니다. 이 VarHandle 인스턴스 에서 &lt;code&gt;compareAndSet&lt;/code&gt; 의 액세스 모드 유형은 다음과 같습니다. &lt;code&gt;(String[] c1, int c2, String expectedValue, String newValue)boolean&lt;/code&gt; . 이러한 VarHandle 인스턴스는 &lt;a href=&quot;methodhandles#arrayElementVarHandle(java.lang.Class)&quot;&gt; &lt;code&gt;array factory method&lt;/code&gt; &lt;/a&gt; 의해 생성되고 다음과 같이 배열 요소에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0805b1ca4fb7bc6237b3574631bb6020be90742" translate="yes" xml:space="preserve">
          <source>The array buffer into which the components of the vector are stored.</source>
          <target state="translated">벡터의 구성 요소가 저장되는 배열 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="e46894470d324ef2c838dfa52d4db4c7490f2a91" translate="yes" xml:space="preserve">
          <source>The array buffer into which the components of the vector are stored. The capacity of the vector is the length of this array buffer, and is at least large enough to contain all the vector's elements.</source>
          <target state="translated">벡터의 성분이 저장되는 배열 버퍼입니다. 벡터의 용량은이 배열 버퍼의 길이이며 모든 벡터의 요소를 포함 할 수있을만큼 커야합니다.</target>
        </trans-unit>
        <trans-unit id="8edac6b3a9ce81ace37f7f334768352523d414ad" translate="yes" xml:space="preserve">
          <source>The array could be empty (zero-length), in which case protocol indications will not be used.</source>
          <target state="translated">배열은 비어있을 수 있으며 (길이가 0)이 경우 프로토콜 표시가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6fe71ec29cbf98988ead3fb5f77509bbc5f99173" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#activeCaption&quot;&gt;&lt;code&gt;activeCaption&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#activeCaption&quot;&gt; &lt;code&gt;activeCaption&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="a0c103acf332c5893b5b5c07c50b6116009c76f3" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#activeCaptionBorder&quot;&gt;&lt;code&gt;activeCaptionBorder&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#activeCaptionBorder&quot;&gt; &lt;code&gt;activeCaptionBorder&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="8484da89e851cb6835d71433e52b1938f0ff907e" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#activeCaptionText&quot;&gt;&lt;code&gt;activeCaptionText&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#activeCaptionText&quot;&gt; &lt;code&gt;activeCaptionText&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="9e34e2aed0acc8f1899d85d0eda3af45f7ba4a95" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#control&quot;&gt;&lt;code&gt;control&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#control&quot;&gt; &lt;code&gt;control&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="399c5848fed51234cd0f1d1f756152ea8cba0a42" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#controlDkShadow&quot;&gt;&lt;code&gt;controlDkShadow&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#controlDkShadow&quot;&gt; &lt;code&gt;controlDkShadow&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="122e8124485ee52bb32f7a1a735194646c1ebefa" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#controlHighlight&quot;&gt;&lt;code&gt;controlHighlight&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#controlHighlight&quot;&gt; &lt;code&gt;controlHighlight&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="ae3cf7af2101240c17dc58170003c113eb29e9ae" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#controlLtHighlight&quot;&gt;&lt;code&gt;controlLtHighlight&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#controlLtHighlight&quot;&gt; &lt;code&gt;controlLtHighlight&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="bd0a5f2f62b38b9226891f7578d46566126a3ad5" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#controlShadow&quot;&gt;&lt;code&gt;controlShadow&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#controlShadow&quot;&gt; &lt;code&gt;controlShadow&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="774331787a7a5d8118fffcab6acfc3474cf465d2" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#controlText&quot;&gt;&lt;code&gt;controlText&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#controlText&quot;&gt; &lt;code&gt;controlText&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="5c88566c6a74a6121e86907c1ed28d9b1eea42a8" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#desktop&quot;&gt;&lt;code&gt;desktop&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#desktop&quot;&gt; &lt;code&gt;desktop&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 색인입니다 .</target>
        </trans-unit>
        <trans-unit id="519233d9978fad4d4791c34b5301fa10c53e9df9" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#inactiveCaption&quot;&gt;&lt;code&gt;inactiveCaption&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#inactiveCaption&quot;&gt; &lt;code&gt;inactiveCaption&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="a68875ef6b4104353ddfcb38e10001077f3ebf2c" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#inactiveCaptionBorder&quot;&gt;&lt;code&gt;inactiveCaptionBorder&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#inactiveCaptionBorder&quot;&gt; &lt;code&gt;inactiveCaptionBorder&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="92f9617bb1ade53425a9ea98a7b7f9dc24ccdb01" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#inactiveCaptionText&quot;&gt;&lt;code&gt;inactiveCaptionText&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#inactiveCaptionText&quot;&gt; &lt;code&gt;inactiveCaptionText&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="d05398ad66329c2c12623c144049b5d02c873284" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#info&quot;&gt;&lt;code&gt;info&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#info&quot;&gt; &lt;code&gt;info&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 색인입니다 .</target>
        </trans-unit>
        <trans-unit id="45849a893275208a209da29d938c3ebbcb8a4a6f" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#infoText&quot;&gt;&lt;code&gt;infoText&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#infoText&quot;&gt; &lt;code&gt;infoText&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="2b4d63c56a906b2d3ccbc5efe52d8f5bcae100a0" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#menu&quot;&gt;&lt;code&gt;menu&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#menu&quot;&gt; &lt;code&gt;menu&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 색인입니다 .</target>
        </trans-unit>
        <trans-unit id="c420f5b180ba105a27152ba64667c6ab53cc7486" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#menuText&quot;&gt;&lt;code&gt;menuText&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#menuText&quot;&gt; &lt;code&gt;menuText&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="e0509629f7da5b797dbbed61a8638c3e5d5393bd" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#scrollbar&quot;&gt;&lt;code&gt;scrollbar&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#scrollbar&quot;&gt; &lt;code&gt;scrollbar&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="d673c665852a57ea07778dd1d4695a8cfef0ca7b" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#text&quot;&gt;&lt;code&gt;text&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#text&quot;&gt; &lt;code&gt;text&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="4bb160375a7ecad73be262a188adb7d163ca7011" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#textHighlight&quot;&gt;&lt;code&gt;textHighlight&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#textHighlight&quot;&gt; &lt;code&gt;textHighlight&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스 입니다 .</target>
        </trans-unit>
        <trans-unit id="4922c9e1a368f46a883c6155855e228497b7b2c8" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#textHighlightText&quot;&gt;&lt;code&gt;textHighlightText&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#textHighlightText&quot;&gt; &lt;code&gt;textHighlightText&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스 입니다 .</target>
        </trans-unit>
        <trans-unit id="1e2903728943bf2babbc2fc9bf4a7e54fc141f02" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#textInactiveText&quot;&gt;&lt;code&gt;textInactiveText&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#textInactiveText&quot;&gt; &lt;code&gt;textInactiveText&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="c7c9d4a0f8c29118c30eaaa31f74b78e888fa31c" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#textText&quot;&gt;&lt;code&gt;textText&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#textText&quot;&gt; &lt;code&gt;textText&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="30af053a379188f7a8fd76f2b9b06a2dab743f60" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#window&quot;&gt;&lt;code&gt;window&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#window&quot;&gt; &lt;code&gt;window&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="e83c63df71c18266fd598ffb89da5143f9cdea0f" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#windowBorder&quot;&gt;&lt;code&gt;windowBorder&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#windowBorder&quot;&gt; &lt;code&gt;windowBorder&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="d81438e96997cbbb7997a138a7213cc902fbb5e2" translate="yes" xml:space="preserve">
          <source>The array index for the &lt;a href=&quot;#windowText&quot;&gt;&lt;code&gt;windowText&lt;/code&gt;&lt;/a&gt; system color.</source>
          <target state="translated">&lt;a href=&quot;#windowText&quot;&gt; &lt;code&gt;windowText&lt;/code&gt; &lt;/a&gt; 시스템 색상 의 배열 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="0704d29a87f1c7b976c24e06c27c6cff76a33ed6" translate="yes" xml:space="preserve">
          <source>The array is indexed by one of the values defined in &lt;code&gt;Font&lt;/code&gt;, which are roman, centered and hanging. The values are relative to this &lt;code&gt;TextLayout&lt;/code&gt; object's baseline, so that &lt;code&gt;getBaselineOffsets[getBaseline()] == 0&lt;/code&gt;. Offsets are added to the position of the &lt;code&gt;TextLayout&lt;/code&gt; object's baseline to get the position for the new baseline.</source>
          <target state="translated">배열은 &lt;code&gt;Font&lt;/code&gt; 에 정의 된 값 중 하나로 인덱싱되며 , 로마자, 가운데 정렬 및 매달림입니다. 값은이 &lt;code&gt;TextLayout&lt;/code&gt; 객체의 기준선에 상대적 이므로 &lt;code&gt;getBaselineOffsets[getBaseline()] == 0&lt;/code&gt; 입니다. 새 기준선의 위치를 ​​가져 오기 위해 &lt;code&gt;TextLayout&lt;/code&gt; 개체의 기준선 위치에 오프셋이 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="df96b8a4607fb626cc5f918559d4d97edf1931c5" translate="yes" xml:space="preserve">
          <source>The array of &lt;code&gt;Package&lt;/code&gt; objects defined by this &lt;code&gt;ClassLoader&lt;/code&gt;</source>
          <target state="translated">이 &lt;code&gt;ClassLoader&lt;/code&gt; 에 의해 정의 된 &lt;code&gt;Package&lt;/code&gt; 객체 의 배열</target>
        </trans-unit>
        <trans-unit id="a264cc5e827b38fc9f7fc13f9c9c4f9059d4dc7f" translate="yes" xml:space="preserve">
          <source>The array of &lt;code&gt;Package&lt;/code&gt; objects defined by this class loader and its ancestors</source>
          <target state="translated">이 클래스 로더와 그 조상이 정의한 &lt;code&gt;Package&lt;/code&gt; 객체 의 배열</target>
        </trans-unit>
        <trans-unit id="63ce6b35b889cbcbac4d1ed224c154c53a4cccb6" translate="yes" xml:space="preserve">
          <source>The array of &lt;code&gt;Package&lt;/code&gt; objects that have been defined by this class loader and its ancestors</source>
          <target state="translated">이 클래스 로더와 그 조상에 의해 정의 된 &lt;code&gt;Package&lt;/code&gt; 객체 의 배열</target>
        </trans-unit>
        <trans-unit id="7d5dc1f2fccbcb2df085256b48bea933e356eca9" translate="yes" xml:space="preserve">
          <source>The array of &lt;code&gt;Package&lt;/code&gt; objects that have been defined by this class loader; or an zero length array if no package has been defined by this class loader.</source>
          <target state="translated">이 클래스 로더에 의해 정의 된 &lt;code&gt;Package&lt;/code&gt; 객체 의 배열입니다 . 또는이 클래스 로더에 의해 정의 된 패키지가없는 경우 길이가 0 인 배열.</target>
        </trans-unit>
        <trans-unit id="229186e31009fdabd4e7ec862830948505def6b6" translate="yes" xml:space="preserve">
          <source>The array of X coordinates.</source>
          <target state="translated">X 좌표의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="daee7913a2cd233a60ddab888ddd8e17ea04cdc7" translate="yes" xml:space="preserve">
          <source>The array of X coordinates. The number of elements in this array might be more than the number of X coordinates in this &lt;code&gt;Polygon&lt;/code&gt;. The extra elements allow new points to be added to this &lt;code&gt;Polygon&lt;/code&gt; without re-creating this array. The value of &lt;a href=&quot;#npoints&quot;&gt;&lt;code&gt;npoints&lt;/code&gt;&lt;/a&gt; is equal to the number of valid points in this &lt;code&gt;Polygon&lt;/code&gt;.</source>
          <target state="translated">X 좌표의 배열입니다. 이 배열의 요소 수는이 &lt;code&gt;Polygon&lt;/code&gt; 의 X 좌표 수보다 많을 수 있습니다 . 추가 요소를 사용하면 이 배열을 다시 만들지 &lt;code&gt;Polygon&lt;/code&gt; 새 점을 추가 할 수 있습니다 . &lt;a href=&quot;#npoints&quot;&gt; &lt;code&gt;npoints&lt;/code&gt; &lt;/a&gt; 의 값은 이 &lt;code&gt;Polygon&lt;/code&gt; 의 유효한 포인트 수와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2c1730c789b9e5ca21a867ef718bba3f086f3150" translate="yes" xml:space="preserve">
          <source>The array of Y coordinates.</source>
          <target state="translated">Y 좌표의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="b9fc2496767e8e79a8ef6a5bdc7ccc9b81c5bacc" translate="yes" xml:space="preserve">
          <source>The array of Y coordinates. The number of elements in this array might be more than the number of Y coordinates in this &lt;code&gt;Polygon&lt;/code&gt;. The extra elements allow new points to be added to this &lt;code&gt;Polygon&lt;/code&gt; without re-creating this array. The value of &lt;code&gt;npoints&lt;/code&gt; is equal to the number of valid points in this &lt;code&gt;Polygon&lt;/code&gt;.</source>
          <target state="translated">Y 좌표의 배열입니다. 이 배열의 요소 수는이 &lt;code&gt;Polygon&lt;/code&gt; 의 Y 좌표 수보다 많을 수 있습니다 . 추가 요소를 사용하면 이 배열을 다시 만들지 &lt;code&gt;Polygon&lt;/code&gt; 새 점을 추가 할 수 있습니다 . &lt;code&gt;npoints&lt;/code&gt; 의 값은 이 &lt;code&gt;Polygon&lt;/code&gt; 의 유효한 포인트 수와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="705218ba2f4229324522ac940a920cb455e867d6" translate="yes" xml:space="preserve">
          <source>The array of attributes that were set, with their new values in Attribute instances.</source>
          <target state="translated">속성 인스턴스에 새 값이 설정된 속성의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="77a8c9ed11761ff4386bd7ca5d0373c19f7fc098" translate="yes" xml:space="preserve">
          <source>The array of cells' height</source>
          <target state="translated">셀 배열의 높이</target>
        </trans-unit>
        <trans-unit id="d18586b0a5a989f9e37a3fc179f2e307cbdbddde" translate="yes" xml:space="preserve">
          <source>The array of default color choosers.</source>
          <target state="translated">기본 색상 선택기의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="9697bed1808f42335a55834ef84607ba8834115c" translate="yes" xml:space="preserve">
          <source>The array of names for the public static fields that contains the valid values of the annotated property.</source>
          <target state="translated">주석이 추가 된 속성의 유효한 값이 포함 된 공용 정적 필드의 이름 배열입니다.</target>
        </trans-unit>
        <trans-unit id="c42005ccd2b608d294b4caaf00b147e6112cbde8" translate="yes" xml:space="preserve">
          <source>The array of names for the public static fields that contains the valid values of the annotated property. These names are used to generate the &lt;code&gt;enumerationValues&lt;/code&gt;&lt;a href=&quot;featuredescriptor#getValue(java.lang.String)&quot;&gt;&lt;code&gt;feature attribute&lt;/code&gt;&lt;/a&gt; that must contain the following items per each property value: a displayable name for the property value, the actual property value, and a Java code piece used for the code generator.</source>
          <target state="translated">주석이 추가 된 속성의 유효한 값이 포함 된 공용 정적 필드의 이름 배열입니다. 이러한 이름은 각 속성 값마다 표시 가능한 속성 값 이름, 실제 속성 값 및 코드 생성기에 사용되는 Java 코드 조각을 포함해야하는 &lt;code&gt;enumerationValues&lt;/code&gt; &lt;a href=&quot;featuredescriptor#getValue(java.lang.String)&quot;&gt; &lt;code&gt;feature attribute&lt;/code&gt; &lt;/a&gt; 을 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="caefd62107a7a262c81c7e3a9d33603c440bbe5e" translate="yes" xml:space="preserve">
          <source>The array of notification types returned by &lt;a href=&quot;mbeaninfo#getNotifications()&quot;&gt;&lt;code&gt;MBeanInfo.getNotifications()&lt;/code&gt;&lt;/a&gt; for an MXBean that is directly registered in the MBean Server will be empty if the MXBean does not implement the &lt;a href=&quot;notificationbroadcaster&quot;&gt;&lt;code&gt;NotificationBroadcaster&lt;/code&gt;&lt;/a&gt; interface. Otherwise, it will be the result of calling &lt;a href=&quot;notificationbroadcaster#getNotificationInfo()&quot;&gt;&lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt;&lt;/a&gt; at the time the MXBean was registered. Even if the result of this method changes subsequently, the result of &lt;code&gt;MBeanInfo.getNotifications()&lt;/code&gt; will not. The list returned for an MXBean that is constructed using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;standardemittermbean&quot;&gt;&lt;code&gt;StandardEmitterMBean&lt;/code&gt;&lt;/a&gt; class is derived in the same way as for Standard MBeans.</source>
          <target state="translated">MBean 서버에 직접 등록 된 MXBean에 대한 &lt;a href=&quot;mbeaninfo#getNotifications()&quot;&gt; &lt;code&gt;MBeanInfo.getNotifications()&lt;/code&gt; &lt;/a&gt; 에 의해 리턴 된 알림 유형의 배열은 MXBean이 &lt;a href=&quot;notificationbroadcaster&quot;&gt; &lt;code&gt;NotificationBroadcaster&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하지 않는 경우 비어 있습니다. 그렇지 않으면 MXBean이 등록되었을 때 &lt;a href=&quot;notificationbroadcaster#getNotificationInfo()&quot;&gt; &lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt; &lt;/a&gt; 를 호출 한 결과입니다 . 이 메서드의 결과가 나중에 변경 되더라도 &lt;code&gt;MBeanInfo.getNotifications()&lt;/code&gt; 의 결과는 변경 되지 않습니다. &lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;standardemittermbean&quot;&gt; &lt;code&gt;StandardEmitterMBean&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 구성된 MXBean에 대해 리턴 된 목록 은 Standard MBean과 동일한 방식으로 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="ece62f0c726122c250dc236e28fb201902c1b37c" translate="yes" xml:space="preserve">
          <source>The array of notification types returned by &lt;a href=&quot;mbeaninfo#getNotifications--&quot;&gt;&lt;code&gt;MBeanInfo.getNotifications()&lt;/code&gt;&lt;/a&gt; for an MXBean that is directly registered in the MBean Server will be empty if the MXBean does not implement the &lt;a href=&quot;notificationbroadcaster&quot;&gt;&lt;code&gt;NotificationBroadcaster&lt;/code&gt;&lt;/a&gt; interface. Otherwise, it will be the result of calling &lt;a href=&quot;notificationbroadcaster#getNotificationInfo--&quot;&gt;&lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt;&lt;/a&gt; at the time the MXBean was registered. Even if the result of this method changes subsequently, the result of &lt;code&gt;MBeanInfo.getNotifications()&lt;/code&gt; will not. The list returned for an MXBean that is constructed using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;standardemittermbean&quot;&gt;&lt;code&gt;StandardEmitterMBean&lt;/code&gt;&lt;/a&gt; class is derived in the same way as for Standard MBeans.</source>
          <target state="translated">MBean 서버에 직접 등록 된 MXBean에 대해 &lt;a href=&quot;mbeaninfo#getNotifications--&quot;&gt; &lt;code&gt;MBeanInfo.getNotifications()&lt;/code&gt; &lt;/a&gt; 에 의해 리턴 된 통지 유형의 배열은 MXBean이 &lt;a href=&quot;notificationbroadcaster&quot;&gt; &lt;code&gt;NotificationBroadcaster&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하지 않으면 비어 있습니다. 그렇지 않으면 MXBean이 등록 될 때 &lt;a href=&quot;notificationbroadcaster#getNotificationInfo--&quot;&gt; &lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt; &lt;/a&gt; 를 호출 한 결과입니다 . 이 메소드의 결과가 계속 변경 되어도 &lt;code&gt;MBeanInfo.getNotifications()&lt;/code&gt; 의 결과 는 바뀌지 않습니다. &lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;standardemittermbean&quot;&gt; &lt;code&gt;StandardEmitterMBean&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 생성 된 MXBean에 대해 리턴 된 목록 은 표준 MBean과 동일한 방식으로 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="8033f974991351ace5422d567e6168d796751594" translate="yes" xml:space="preserve">
          <source>The array of package names that will be searched in order to find BeanInfo classes. The default value for this array is implementation-dependent; e.g. Sun implementation initially sets to {&quot;sun.beans.infos&quot;}.</source>
          <target state="translated">BeanInfo 클래스를 찾기 위해 검색 할 패키지 이름의 배열. 이 배열의 기본값은 구현에 따라 다릅니다. 예를 들어 Sun 구현은 초기에 { &quot;sun.beans.infos&quot;}로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ea0e9468c9d76c117ad93cb29d44a9ac61c3edbb" translate="yes" xml:space="preserve">
          <source>The array of package names that will be searched in order to find property editors.</source>
          <target state="translated">속성 편집기를 찾기 위해 검색 할 패키지 이름의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a9430a16cc5d6d9e81bbe1c9322d8ca2a9f99c81" translate="yes" xml:space="preserve">
          <source>The array of public constructors returned by &lt;a href=&quot;mbeaninfo#getConstructors()&quot;&gt;&lt;code&gt;MBeanInfo.getConstructors()&lt;/code&gt;&lt;/a&gt; for an MXBean that is directly registered in the MBean Server will contain all of the public constructors of that MXBean. If the class of the MXBean is not public then its constructors are not considered public either. The list returned for an MXBean that is constructed using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class is derived in the same way as for Standard MBeans. Regardless of how the MXBean was constructed, its constructor parameters are not subject to MXBean mapping rules and do not have a corresponding &lt;code&gt;OpenType&lt;/code&gt;.</source>
          <target state="translated">MBean 서버에 직접 등록 된 MXBean에 대한 &lt;a href=&quot;mbeaninfo#getConstructors()&quot;&gt; &lt;code&gt;MBeanInfo.getConstructors()&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 공용 생성자의 배열은 해당 MXBean의 모든 공용 생성자를 포함합니다. MXBean의 클래스가 공용이 아니면 생성자도 공용으로 간주되지 않습니다. &lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 구성된 MXBean에 대해 리턴 된 목록 은 Standard MBeans와 동일한 방식으로 파생됩니다. MXBean의 구성 방법에 관계없이 생성자 매개 변수는 MXBean 매핑 규칙의 적용을받지 않으며 해당하는 &lt;code&gt;OpenType&lt;/code&gt; 을 갖지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="928ffa64af02531e697e049765f39cfb4189454d" translate="yes" xml:space="preserve">
          <source>The array of public constructors returned by &lt;a href=&quot;mbeaninfo#getConstructors--&quot;&gt;&lt;code&gt;MBeanInfo.getConstructors()&lt;/code&gt;&lt;/a&gt; for an MXBean that is directly registered in the MBean Server will contain all of the public constructors of that MXBean. If the class of the MXBean is not public then its constructors are not considered public either. The list returned for an MXBean that is constructed using the &lt;a href=&quot;standardmbean&quot;&gt;&lt;code&gt;StandardMBean&lt;/code&gt;&lt;/a&gt; class is derived in the same way as for Standard MBeans. Regardless of how the MXBean was constructed, its constructor parameters are not subject to MXBean mapping rules and do not have a corresponding &lt;code&gt;OpenType&lt;/code&gt;.</source>
          <target state="translated">MBean Server에 직접 등록 된 MXBean에 대해 &lt;a href=&quot;mbeaninfo#getConstructors--&quot;&gt; &lt;code&gt;MBeanInfo.getConstructors()&lt;/code&gt; &lt;/a&gt; 에 의해 리턴 된 공용 생성자 배열 에는 해당 MXBean의 모든 공용 생성자가 포함됩니다. MXBean의 클래스가 public이 아닌 경우, 생성자도 public으로 간주되지 않습니다. &lt;a href=&quot;standardmbean&quot;&gt; &lt;code&gt;StandardMBean&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 생성 된 MXBean에 대해 리턴 된 목록 은 표준 MBean과 동일한 방식으로 파생됩니다. MXBean의 구성 방법에 관계없이 생성자 매개 변수에는 MXBean 맵핑 규칙이 적용되지 않으며 해당 &lt;code&gt;OpenType&lt;/code&gt; 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="db434f017939a212924ae8b2ae76ae4c1e7e5572" translate="yes" xml:space="preserve">
          <source>The array of strings computed by splitting the input around matches of this pattern</source>
          <target state="translated">이 패턴의 일치 항목 주위에 입력을 분할하여 계산 된 문자열 배열</target>
        </trans-unit>
        <trans-unit id="21e99c99c3f91ab24ab86736735d1d0c34a806e4" translate="yes" xml:space="preserve">
          <source>The array of the retrieved attributes.</source>
          <target state="translated">검색된 속성의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="750a6ad2c07339ebe350acb6969bf48fa9863598" translate="yes" xml:space="preserve">
          <source>The array returned by &lt;a href=&quot;notificationbroadcaster#getNotificationInfo()&quot;&gt;&lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt;&lt;/a&gt; on the new MBean is a copy of the array returned by &lt;code&gt;emitter.&lt;/code&gt;&lt;a href=&quot;notificationbroadcaster#getNotificationInfo()&quot;&gt;&lt;code&gt;getNotificationInfo()&lt;/code&gt;&lt;/a&gt; at the time of construction. If the array returned by &lt;code&gt;emitter.getNotificationInfo()&lt;/code&gt; later changes, that will have no effect on this object's &lt;code&gt;getNotificationInfo()&lt;/code&gt;.</source>
          <target state="translated">어레이에 의해 리턴 &lt;a href=&quot;notificationbroadcaster#getNotificationInfo()&quot;&gt; &lt;code&gt;NotificationBroadcaster.getNotificationInfo()&lt;/code&gt; &lt;/a&gt; 새의 MBean에 의해 반환되는 배열의 복사 &lt;code&gt;emitter.&lt;/code&gt; &lt;a href=&quot;notificationbroadcaster#getNotificationInfo()&quot;&gt; &lt;code&gt;getNotificationInfo()&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;emitter.getNotificationInfo()&lt;/code&gt; 의해 반환 된 배열이 나중에 변경되면이 객체의 &lt;code&gt;getNotificationInfo()&lt;/code&gt; 에 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d4bac7b4df1de55c6f27580125aa0401038db85c" translate="yes" xml:space="preserve">
          <source>The array returned by &lt;a href=&quot;standardemittermbean#getNotificationInfo--&quot;&gt;&lt;code&gt;getNotificationInfo()&lt;/code&gt;&lt;/a&gt; on the new MBean is a copy of the array returned by &lt;code&gt;emitter.&lt;/code&gt;&lt;a href=&quot;notificationbroadcaster#getNotificationInfo--&quot;&gt;&lt;code&gt;getNotificationInfo()&lt;/code&gt;&lt;/a&gt; at the time of construction. If the array returned by &lt;code&gt;emitter.getNotificationInfo()&lt;/code&gt; later changes, that will have no effect on this object's &lt;code&gt;getNotificationInfo()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;standardemittermbean#getNotificationInfo--&quot;&gt; &lt;code&gt;getNotificationInfo()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 배열 새의 MBean에 의해 반환되는 배열의 복사 &lt;code&gt;emitter.&lt;/code&gt; &lt;a href=&quot;notificationbroadcaster#getNotificationInfo--&quot;&gt; &lt;code&gt;getNotificationInfo()&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;emitter.getNotificationInfo()&lt;/code&gt; 의해 반환 된 배열이 나중에 변경되면,이 객체의 &lt;code&gt;getNotificationInfo()&lt;/code&gt; 에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e92705f378bd923a26c73b7355c18555646036fe" translate="yes" xml:space="preserve">
          <source>The array returned by this method contains each substring of the input sequence that is terminated by another subsequence that matches this pattern or is terminated by the end of the input sequence. The substrings in the array are in the order in which they occur in the input. If this pattern does not match any subsequence of the input then the resulting array has just one element, namely the input sequence in string form.</source>
          <target state="translated">이 메소드에 의해 리턴 된 배열에는이 패턴과 일치하는 다른 서브 시퀀스에 의해 종료되거나 입력 시퀀스의 끝에 의해 종료되는 입력 시퀀스의 각 서브 스트링이 포함됩니다. 배열의 하위 문자열은 입력에서 발생하는 순서입니다. 이 패턴이 입력의 서브 시퀀스와 일치하지 않으면 결과 배열에는 하나의 요소, 즉 문자열 형식의 입력 시퀀스 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="f71572fbf727c562642b1ff0c2f9fbfecd555f50" translate="yes" xml:space="preserve">
          <source>The array returned by this method contains each substring of this string that is terminated by another substring that matches the given expression or is terminated by the end of the string. The substrings in the array are in the order in which they occur in this string. If the expression does not match any part of the input then the resulting array has just one element, namely this string.</source>
          <target state="translated">이 메소드에 의해 돌려 주어지는 배열에는,이 식의 각 부분 캐릭터 라인이 포함됩니다. 배열의 하위 문자열은이 문자열에서 순서대로 나타납니다. 표현식이 입력의 일부와 일치하지 않으면 결과 배열에는 하나의 요소, 즉이 문자열 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd8e2a59c6f597467816fcfb0a55337513d7ca3b" translate="yes" xml:space="preserve">
          <source>The array returned by this method should not include two or more &lt;code&gt;Locale&lt;/code&gt; objects only differing in their extensions.</source>
          <target state="translated">이 메소드에 의해 돌려 주어지는 배열에는 , 확장자가 다른 2 개 이상의 &lt;code&gt;Locale&lt;/code&gt; 객체가 포함되지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="127b2b126ce707a25ed2dfc831df19ca1f0f57ef" translate="yes" xml:space="preserve">
          <source>The array that backs this buffer</source>
          <target state="translated">이 버퍼를 지원하는 배열</target>
        </trans-unit>
        <trans-unit id="e0bbbe0e3e85f862ede0796bc8df9c4b03d6c6f6" translate="yes" xml:space="preserve">
          <source>The arrow button that invokes the popup.</source>
          <target state="translated">팝업을 호출하는 화살표 버튼입니다.</target>
        </trans-unit>
        <trans-unit id="1e406842fb0df72655a966ff88f0915d7c2fb634" translate="yes" xml:space="preserve">
          <source>The arrow icon.</source>
          <target state="translated">화살표 아이콘.</target>
        </trans-unit>
        <trans-unit id="5d03d9390a63454e465cc3c9c4d6d0d807c23033" translate="yes" xml:space="preserve">
          <source>The assignment of the actions described is shown in the following table for the tags defined in &lt;code&gt;HTML.Tag&lt;/code&gt;.</source>
          <target state="translated">설명 된 작업의 할당은 &lt;code&gt;HTML.Tag&lt;/code&gt; 에 정의 된 태그에 대해 다음 표에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="55ad773221907d42c4b5de9996c45dad816d6669" translate="yes" xml:space="preserve">
          <source>The associated &lt;code&gt;Bindings&lt;/code&gt;. Returns &lt;code&gt;null&lt;/code&gt; if it has not been set.</source>
          <target state="translated">관련 &lt;code&gt;Bindings&lt;/code&gt; . 설정되어 있지 않은 경우는 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="90730d30c6fe4fba1e92d78af9008f60c7d25eb8" translate="yes" xml:space="preserve">
          <source>The associated &lt;code&gt;TIFFTag&lt;/code&gt;.</source>
          <target state="translated">연관된 &lt;code&gt;TIFFTag&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef54210faa00c830b7922493db2b370b6c05b9cb" translate="yes" xml:space="preserve">
          <source>The associated Namespace URI, or null if the prefix is undeclared in this context.</source>
          <target state="translated">연관된 네임 스페이스 URI입니다. 접두사가이 컨텍스트에서 선언되지 않은 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="4b859c3a6fabb8b1abaeafc55b664e21f2a1ed05" translate="yes" xml:space="preserve">
          <source>The association</source>
          <target state="translated">협회</target>
        </trans-unit>
        <trans-unit id="c81e5747a461ac9ae94a43607a013480f924b2ab" translate="yes" xml:space="preserve">
          <source>The association ID</source>
          <target state="translated">연관 ID</target>
        </trans-unit>
        <trans-unit id="e4a73f941bbe2ab18b55fcec984be29a7845a3a2" translate="yes" xml:space="preserve">
          <source>The association failed to setup.</source>
          <target state="translated">연결을 설정하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="3324ecabcd8f38b8a0611114fc37be56fa9af2bf" translate="yes" xml:space="preserve">
          <source>The association failed to setup. If a message was sent on a &lt;a href=&quot;sctpmultichannel&quot;&gt;&lt;code&gt;SctpMultiChannel&lt;/code&gt;&lt;/a&gt; in non-blocking mode, an SCTP send failed notification will follow this notification for the outstanding message.</source>
          <target state="translated">연결을 설정하지 못했습니다. 비 차단 모드 의 &lt;a href=&quot;sctpmultichannel&quot;&gt; &lt;code&gt;SctpMultiChannel&lt;/code&gt; &lt;/a&gt; 에서 메시지가 전송 된 경우 SCTP 전송 실패 알림은 미해결 메시지에 대해이 알림을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="f76369b63b4539b2476e0c4138bf959483b191ff" translate="yes" xml:space="preserve">
          <source>The association has failed.</source>
          <target state="translated">연결에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="fa37a8389465590041cd278061604e204a8a65dd" translate="yes" xml:space="preserve">
          <source>The association has failed. A series of SCTP send failed notifications will follow this notification, one for each outstanding message.</source>
          <target state="translated">연결에 실패했습니다. 일련의 SCTP 전송 실패 알림은 각 미해결 메시지에 대해 하나씩이 알림을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="22ea323d2f5b3e79a7c32e1b38c7664ef70a2c3c" translate="yes" xml:space="preserve">
          <source>The association has gracefully closed.</source>
          <target state="translated">협회가 정상적으로 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="b1a1d06f9c6962681f2bec65847f01452c5f42a4" translate="yes" xml:space="preserve">
          <source>The association that failed to send, or &lt;code&gt;null&lt;/code&gt; if there is no association, that is, the notification follows a &lt;a href=&quot;associationchangenotification.assocchangeevent#CANT_START&quot;&gt;AssociationChangeNotification.AssocChangeEvent.CANT_START&lt;/a&gt;</source>
          <target state="translated">전송에 실패한 연결 또는 연결이없는 경우 &lt;code&gt;null&lt;/code&gt; , 즉 알림이 &lt;a href=&quot;associationchangenotification.assocchangeevent#CANT_START&quot;&gt;AssociationChangeNotification.AssocChangeEvent.CANT_START를&lt;/a&gt; 따릅니다.</target>
        </trans-unit>
        <trans-unit id="fe14ba67b8cac22b9d98d00e3c44c9fb3226c38e" translate="yes" xml:space="preserve">
          <source>The association that received the shutdown</source>
          <target state="translated">종료를받은 연결</target>
        </trans-unit>
        <trans-unit id="7ec13aef6c637245cbb18de2ae71224e4239f1e1" translate="yes" xml:space="preserve">
          <source>The association whose peer address changed</source>
          <target state="translated">피어 주소가 변경된 연관</target>
        </trans-unit>
        <trans-unit id="4592d1672504823f25d46eae80e5ae26b183442f" translate="yes" xml:space="preserve">
          <source>The association whose state has changed, or &lt;code&gt;null&lt;/code&gt; if there is no association, that is &lt;a href=&quot;associationchangenotification.assocchangeevent#CANT_START&quot;&gt;CANT_START&lt;/a&gt;</source>
          <target state="translated">상태가 변경된 연관 또는 연관이없는 경우 &lt;code&gt;null&lt;/code&gt; , 즉 &lt;a href=&quot;associationchangenotification.assocchangeevent#CANT_START&quot;&gt;CANT_START&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2901f7698e2f47f9cbc6146ccd7f12d324c37abb" translate="yes" xml:space="preserve">
          <source>The association, or &lt;code&gt;null&lt;/code&gt; if this instance is to be used for sending a message and has been construced using the the &lt;a href=&quot;#createOutgoing(java.net.SocketAddress,int)&quot;&gt;&lt;code&gt;createOutgoing(SocketAddress,int)&lt;/code&gt;&lt;/a&gt; static factory method</source>
          <target state="translated">협회, 또는 &lt;code&gt;null&lt;/code&gt; 이 예에서는 메시지를 송신을 위해 사용되어야하며 상기 이용 construced되었는지 &lt;a href=&quot;#createOutgoing(java.net.SocketAddress,int)&quot;&gt; &lt;code&gt;createOutgoing(SocketAddress,int)&lt;/code&gt; &lt;/a&gt; 정적 공장 메소드</target>
        </trans-unit>
        <trans-unit id="17debbc5f42393fd96f9ca2904b4a3088a73d0b0" translate="yes" xml:space="preserve">
          <source>The associativity constraint says that splitting the computation must produce an equivalent result. That is, for any input elements &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;, the results &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; in the computation below must be equivalent:</source>
          <target state="translated">연관성 제약 조건에 따르면 계산을 분할하면 동등한 결과가 생성되어야합니다. 즉, 모든 입력 요소 &lt;code&gt;t1&lt;/code&gt; 및 &lt;code&gt;t2&lt;/code&gt; 의 경우 결과 &lt;code&gt;r1&lt;/code&gt; 아래 계산에서 r1 및 &lt;code&gt;r2&lt;/code&gt; 는 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c2594d2d7c8eeee929f5c18765c60eb8a9dda4f" translate="yes" xml:space="preserve">
          <source>The asymptotic complexity of the layout operation of a &lt;code&gt;SpringLayout&lt;/code&gt; is linear in the number of constraints (and/or components).</source>
          <target state="translated">&lt;code&gt;SpringLayout&lt;/code&gt; 의 레이아웃 작업의 점근 적 복잡성은 제약 (및 / 또는 구성 요소)의 수에서 선형 적입니다.</target>
        </trans-unit>
        <trans-unit id="1966a02163049d6e69f033c1659860a7439bc111" translate="yes" xml:space="preserve">
          <source>The asynchronous channels defined in this package allow a completion handler to be specified to consume the result of an asynchronous operation. The &lt;a href=&quot;#completed(V,A)&quot;&gt;&lt;code&gt;completed&lt;/code&gt;&lt;/a&gt; method is invoked when the I/O operation completes successfully. The &lt;a href=&quot;#failed(java.lang.Throwable,A)&quot;&gt;&lt;code&gt;failed&lt;/code&gt;&lt;/a&gt; method is invoked if the I/O operations fails. The implementations of these methods should complete in a timely manner so as to avoid keeping the invoking thread from dispatching to other completion handlers.</source>
          <target state="translated">이 패키지에 정의 된 비동기 채널을 사용하면 비동기 작업의 결과를 사용하도록 완료 핸들러를 지정할 수 있습니다. &lt;a href=&quot;#completed(V,A)&quot;&gt; &lt;code&gt;completed&lt;/code&gt; &lt;/a&gt; I / O 작업이 성공적으로 완료 될 때 메서드가 호출됩니다. &lt;a href=&quot;#failed(java.lang.Throwable,A)&quot;&gt; &lt;code&gt;failed&lt;/code&gt; &lt;/a&gt; 의 I / O 작업이 실패 할 경우 메서드가 호출됩니다. 이러한 메서드의 구현은 호출 스레드가 다른 완료 핸들러로 디스패치하지 않도록 적시에 완료해야합니다.</target>
        </trans-unit>
        <trans-unit id="67ec3ad0e3e68650ab013d136deb39b2f3be1878" translate="yes" xml:space="preserve">
          <source>The asynchronous channels defined in this package allow a completion handler to be specified to consume the result of an asynchronous operation. The &lt;a href=&quot;completionhandler#completed-V-A-&quot;&gt;&lt;code&gt;completed&lt;/code&gt;&lt;/a&gt; method is invoked when the I/O operation completes successfully. The &lt;a href=&quot;completionhandler#failed-java.lang.Throwable-A-&quot;&gt;&lt;code&gt;failed&lt;/code&gt;&lt;/a&gt; method is invoked if the I/O operations fails. The implementations of these methods should complete in a timely manner so as to avoid keeping the invoking thread from dispatching to other completion handlers.</source>
          <target state="translated">이 패키지에 정의 된 비동기 채널을 사용하면 완료 조작을 지정하여 비동기 작업의 결과를 사용할 수 있습니다. &lt;a href=&quot;completionhandler#completed-V-A-&quot;&gt; &lt;code&gt;completed&lt;/code&gt; &lt;/a&gt; I / O 작업이 성공적으로 완료 될 때 메서드가 호출됩니다. 그만큼&lt;a href=&quot;completionhandler#failed-java.lang.Throwable-A-&quot;&gt; &lt;code&gt;failed&lt;/code&gt; &lt;/a&gt; 의 I / O 작업이 실패 할 경우 메서드가 호출됩니다. 이 메소드의 구현은 호출하는 스레드가 다른 완료 핸들러로 디스패치되지 않도록 적시에 완료해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2643efcacf971e061ea507c97d7776dc8feca47" translate="yes" xml:space="preserve">
          <source>The atomic classes also support method &lt;code&gt;weakCompareAndSet&lt;/code&gt;, which has limited applicability. On some platforms, the weak version may be more efficient than &lt;code&gt;compareAndSet&lt;/code&gt; in the normal case, but differs in that any given invocation of the &lt;code&gt;weakCompareAndSet&lt;/code&gt; method may return &lt;code&gt;false&lt;/code&gt;&lt;em&gt;spuriously&lt;/em&gt; (that is, for no apparent reason). A &lt;code&gt;false&lt;/code&gt; return means only that the operation may be retried if desired, relying on the guarantee that repeated invocation when the variable holds &lt;code&gt;expectedValue&lt;/code&gt; and no other thread is also attempting to set the variable will eventually succeed. (Such spurious failures may for example be due to memory contention effects that are unrelated to whether the expected and current values are equal.) Additionally &lt;code&gt;weakCompareAndSet&lt;/code&gt; does not provide ordering guarantees that are usually needed for synchronization control. However, the method may be useful for updating counters and statistics when such updates are unrelated to the other happens-before orderings of a program. When a thread sees an update to an atomic variable caused by a &lt;code&gt;weakCompareAndSet&lt;/code&gt;, it does not necessarily see updates to any &lt;em&gt;other&lt;/em&gt; variables that occurred before the &lt;code&gt;weakCompareAndSet&lt;/code&gt;. This may be acceptable when, for example, updating performance statistics, but rarely otherwise.</source>
          <target state="translated">원자 클래스는 응용 프로그램이 제한적인 &lt;code&gt;weakCompareAndSet&lt;/code&gt; 메소드도 지원 합니다. 일부 플랫폼에서 약한 버전보다 더 효율적으로 할 수 &lt;code&gt;compareAndSet&lt;/code&gt; 일반적인 경우에, 그러나 어떤 주어진 호출 점에서 다릅니다 &lt;code&gt;weakCompareAndSet&lt;/code&gt; 도의 방법은 반환 할 수 있습니다 &lt;code&gt;false&lt;/code&gt; &lt;em&gt;외관상&lt;/em&gt; (즉, 명백한 이유없이) . &lt;code&gt;false&lt;/code&gt; 원한다면 복귀 수단 동작 변수가 유지 될 때 호출을 반복한다는 보증에 의존하고, 재 시행 될 수 있음을 단지 &lt;code&gt;expectedValue&lt;/code&gt; 를을 하고 다른 스레드가 또한 변수가 결국 성공 설정하려고하지 않습니다. (예를 들어, 이러한 스퓨리어스 실패는 예상 값과 현재 값이 같은지 여부와 관련이없는 메모리 경합 효과로 인한 것일 수 있습니다.) 또한 &lt;code&gt;weakCompareAndSet&lt;/code&gt; 은 일반적으로 동기화 제어에 필요한 순서 보장을 제공하지 않습니다. 그러나이 방법은 이러한 업데이트가 프로그램 순서 이전의 다른 업데이트와 관련이없는 경우 카운터 및 통계를 업데이트하는 데 유용 할 수 있습니다. 스레드가 &lt;code&gt;weakCompareAndSet&lt;/code&gt; 로 인한 원자 변수에 대한 업데이트를 볼 때 &lt;code&gt;weakCompareAndSet&lt;/code&gt; 전에 발생한 &lt;em&gt;다른&lt;/em&gt; 변수에 대한 업데이트를 반드시 볼 필요는 없습니다. 예를 들어 성능 통계를 업데이트 할 때 허용되지만 그렇지 않은 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="837a62ce5f716699ec0e3d1b69c98c9b8c8b81f8" translate="yes" xml:space="preserve">
          <source>The attempt to stop the user's code may fail in some case, which may include when the execution is blocked on an I/O operation, or when the user's code is catching the &lt;a href=&quot;../../../java.base/java/lang/threaddeath&quot;&gt;&lt;code&gt;ThreadDeath&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">I / O 작업에서 실행이 차단되거나 사용자 코드가 &lt;a href=&quot;../../../java.base/java/lang/threaddeath&quot;&gt; &lt;code&gt;ThreadDeath&lt;/code&gt; &lt;/a&gt; 예외를 포착하는 경우를 포함하여 경우에 따라 사용자 코드를 중지하려는 시도가 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac4d2ba6afc8f8ee440138a683ef1064620a944b" translate="yes" xml:space="preserve">
          <source>The attribute being observed.</source>
          <target state="translated">관찰되는 속성.</target>
        </trans-unit>
        <trans-unit id="b8a37f33dcee88edb23054b891ea94a382817041" translate="yes" xml:space="preserve">
          <source>The attribute classes in package &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; are based on the Internet Printing Protocol (IPP) attributes as defined in the Internet RFC document,</source>
          <target state="translated">패키지 &lt;code&gt;javax.print.attribute.standard&lt;/code&gt; 의 속성 클래스 는 인터넷 RFC 문서에 정의 된 IPP (Internet Printing Protocol) 속성을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="ae483aeff395b3de4d450d6d9ace753544821cfa" translate="yes" xml:space="preserve">
          <source>The attribute classes in package javax.print.attribute.standard are based on the Internet Printing Protocol (IPP) attributes as defined in the Internet RFC document,</source>
          <target state="translated">javax.print.attribute.standard 패키지의 속성 클래스는 인터넷 RFC 문서에 정의 된 IPP (Internet Printing Protocol) 속성을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="e05558897f0a001d5208b09a07d6aa1c98e2cd44" translate="yes" xml:space="preserve">
          <source>The attribute identified by attrID; null if not found.</source>
          <target state="translated">attrID로 식별되는 속성. 찾을 수 없으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="21ca2cce962bb3642d18085407ad8b8aae8f16be" translate="yes" xml:space="preserve">
          <source>The attribute information returned by &lt;a href=&quot;../mbeaninfo#getAttributes()&quot;&gt;&lt;code&gt;MBeanInfo.getAttributes&lt;/code&gt;&lt;/a&gt; for an Open MBean is an array of objects implementing &lt;a href=&quot;openmbeanattributeinfo&quot;&gt;&lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt;&lt;/a&gt;, usually instances of &lt;a href=&quot;openmbeanattributeinfosupport&quot;&gt;&lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt;&lt;/a&gt;. In addition to the usual information about attributes, an &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; specifies the &lt;a href=&quot;opentype&quot;&gt;&lt;code&gt;OpenType&lt;/code&gt;&lt;/a&gt; of the attribute. The possible &lt;code&gt;OpenType&lt;/code&gt; values are predefined, which is what ensures that remote managers will understand them.</source>
          <target state="translated">Open MBean에 대한 &lt;a href=&quot;../mbeaninfo#getAttributes()&quot;&gt; &lt;code&gt;MBeanInfo.getAttributes&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 속성 정보는 &lt;a href=&quot;openmbeanattributeinfo&quot;&gt; &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; 를&lt;/a&gt; 구현하는 객체의 배열이며 , 일반적으로 &lt;a href=&quot;openmbeanattributeinfosupport&quot;&gt; &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; 의&lt;/a&gt; 인스턴스입니다 . 속성에 대한 일반적인 정보 외에도 &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; 는 속성 의 &lt;a href=&quot;opentype&quot;&gt; &lt;code&gt;OpenType&lt;/code&gt; &lt;/a&gt; 을 지정 합니다. 가능한 &lt;code&gt;OpenType&lt;/code&gt; 값은 미리 정의되어 있으므로 원격 관리자가이를 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14f0f29c3610d7bdbde3a9395cb830c538b88095" translate="yes" xml:space="preserve">
          <source>The attribute information returned by &lt;a href=&quot;../mbeaninfo#getAttributes--&quot;&gt;&lt;code&gt;MBeanInfo.getAttributes&lt;/code&gt;&lt;/a&gt; for an Open MBean is an array of objects implementing &lt;a href=&quot;openmbeanattributeinfo&quot;&gt;&lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt;&lt;/a&gt;, usually instances of &lt;a href=&quot;openmbeanattributeinfosupport&quot;&gt;&lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt;&lt;/a&gt;. In addition to the usual information about attributes, an &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; specifies the &lt;a href=&quot;opentype&quot;&gt;&lt;code&gt;OpenType&lt;/code&gt;&lt;/a&gt; of the attribute. The possible &lt;code&gt;OpenType&lt;/code&gt; values are predefined, which is what ensures that remote managers will understand them.</source>
          <target state="translated">Open MBean에 대해 &lt;a href=&quot;../mbeaninfo#getAttributes--&quot;&gt; &lt;code&gt;MBeanInfo.getAttributes&lt;/code&gt; &lt;/a&gt; 에 의해 리턴 된 속성 정보는 &lt;a href=&quot;openmbeanattributeinfo&quot;&gt; &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; 를&lt;/a&gt; 구현하는 객체의 배열로 , 일반적으로 &lt;a href=&quot;openmbeanattributeinfosupport&quot;&gt; &lt;code&gt;OpenMBeanAttributeInfoSupport&lt;/code&gt; 의&lt;/a&gt; 인스턴스입니다 . 속성에 대한 일반적인 정보 외에도 &lt;code&gt;OpenMBeanAttributeInfo&lt;/code&gt; 는 속성 의 &lt;a href=&quot;opentype&quot;&gt; &lt;code&gt;OpenType&lt;/code&gt; &lt;/a&gt; 을 지정 합니다. 가능한 &lt;code&gt;OpenType&lt;/code&gt; 값이 미리 정의되어 있으므로 원격 관리자가이를 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a34ae87a4441eaa7165be74012804b6e6e4684c" translate="yes" xml:space="preserve">
          <source>The attribute is not described in terms of the distance from the edge of the paper, in part to emphasise that this attribute is not independent of a particular media, but must be described within the context of a choice of other attributes. Additionally it is usually more convenient for a client to use the printable area.</source>
          <target state="translated">이 속성은 용지의 가장자리와의 거리로 설명되지 않으며,이 속성은 특정 매체와 무관하지만 다른 속성을 선택할 때 설명해야합니다. 또한 클라이언트가 인쇄 가능 영역을 사용하는 것이 일반적으로 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="b86da5762895b62d07d727f375dd129e08e17f2a" translate="yes" xml:space="preserve">
          <source>The attribute modifier</source>
          <target state="translated">속성 수정 자</target>
        </trans-unit>
        <trans-unit id="9468efb616ab2d3e6fc89d10bca6b8e41e4686d0" translate="yes" xml:space="preserve">
          <source>The attribute name</source>
          <target state="translated">속성 이름</target>
        </trans-unit>
        <trans-unit id="9a0fed704da4a2bd2003ddd858a8950daa587360" translate="yes" xml:space="preserve">
          <source>The attribute name as a string, or null if there is no attribute at that position.</source>
          <target state="translated">속성 이름 (문자열). 해당 위치에 속성이없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="982ed456989e65fdd484ae4e5cc16efdb533dab0" translate="yes" xml:space="preserve">
          <source>The attribute name-value mappings.</source>
          <target state="translated">속성 이름-값 매핑</target>
        </trans-unit>
        <trans-unit id="0e520d7f76b80d19d6afab265e6113914f902be7" translate="yes" xml:space="preserve">
          <source>The attribute or its value usually do no longer apply if the underlying text is changed.</source>
          <target state="translated">기본 텍스트가 변경된 경우 일반적으로 속성 또는 해당 값이 더 이상 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc9dc9f433ec124b5677089f1a30558c9357186b" translate="yes" xml:space="preserve">
          <source>The attribute type</source>
          <target state="translated">속성 유형</target>
        </trans-unit>
        <trans-unit id="6f0189c1a4a9f3d326e775b5da3b0b10bb82b286" translate="yes" xml:space="preserve">
          <source>The attribute type and value pairs of the RDNs are lined up against each other and compared lexicographically. The order of components in multi-valued Rdns (such as &quot;ou=Sales+cn=Bob&quot;) is not significant.</source>
          <target state="translated">RDN의 속성 유형과 값 쌍은 서로 정렬되어 사전 식으로 비교됩니다. 다중 값 Rdn의 구성 요소 순서 (예 : &quot;ou = Sales + cn = Bob&quot;)는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b60d00b9a66cd23764e835057db9d82f2e7f2b37" translate="yes" xml:space="preserve">
          <source>The attribute type as a string (&quot;NMTOKEN&quot; for an enumeration, and &quot;CDATA&quot; if no declaration was read), or null if there is no attribute at that position.</source>
          <target state="translated">문자열 (열거 형의 경우 &quot;NMTOKEN&quot;, 읽은 선언이없는 경우 &quot;CDATA&quot;)의 속성 유형 또는 해당 위치에 속성이없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="5914749a8344a5c2a45cc055ef9b26298a8df810" translate="yes" xml:space="preserve">
          <source>The attribute type as a string (&quot;NMTOKEN&quot; for an enumeration, and &quot;CDATA&quot; if no declaration was read).</source>
          <target state="translated">문자열의 속성 유형 (열거의 경우 &quot;NMTOKEN&quot;, 읽은 선언이없는 경우 &quot;CDATA&quot;)</target>
        </trans-unit>
        <trans-unit id="d158f9a3d8131516173878cbcff0e7fa45ad6294" translate="yes" xml:space="preserve">
          <source>The attribute type as a string, or null if no such attribute exists.</source>
          <target state="translated">속성 유형 (문자열) 또는 해당 속성이없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="5a39a5e21b35af155db18c027ea7284429a22676" translate="yes" xml:space="preserve">
          <source>The attribute type as a string, or null if the attribute is not in the list or if Namespace processing is not being performed.</source>
          <target state="translated">속성 유형 (문자열). 속성이 목록에 없거나 네임 스페이스 처리가 수행되지 않는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="e267e7f0478cff602614974e7026d647943c0902" translate="yes" xml:space="preserve">
          <source>The attribute type as a string, or null if the attribute is not in the list or if qualified names are not available.</source>
          <target state="translated">속성 유형은 문자열이거나 속성이 목록에 없거나 규정 된 이름을 사용할 수없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="945cd3e20f85ad4ae3e96096b911845526312d0b" translate="yes" xml:space="preserve">
          <source>The attribute type as a string, or null if the index is out of range.</source>
          <target state="translated">속성 유형 (문자열) 또는 인덱스가 범위를 벗어난 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="6fa8c56efe78aad0503f63c6b7162e9f82bbb16a" translate="yes" xml:space="preserve">
          <source>The attribute type is one of the strings &quot;CDATA&quot;, &quot;ID&quot;, &quot;IDREF&quot;, &quot;IDREFS&quot;, &quot;NMTOKEN&quot;, &quot;NMTOKENS&quot;, &quot;ENTITY&quot;, &quot;ENTITIES&quot;, or &quot;NOTATION&quot; (always in upper case).</source>
          <target state="translated">속성 유형은 문자열 &quot;CDATA&quot;, &quot;ID&quot;, &quot;IDREF&quot;, &quot;IDREFS&quot;, &quot;NMTOKEN&quot;, &quot;NMTOKENS&quot;, &quot;ENTITY&quot;, &quot;ENTITIES&quot;또는 &quot;NOTATION&quot;(항상 대문자) 중 하나입니다. .</target>
        </trans-unit>
        <trans-unit id="6d2a41c58f84b983c4307e184fcf2882ccbdc7cf" translate="yes" xml:space="preserve">
          <source>The attribute value</source>
          <target state="translated">속성 값</target>
        </trans-unit>
        <trans-unit id="2c9d736b62023b8a2f3a237901452f52fae10788" translate="yes" xml:space="preserve">
          <source>The attribute value as a string, or null if no such attribute exists.</source>
          <target state="translated">속성 값 (문자열) 또는 해당 속성이없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="c445a39c3d36d4fa6b8d45ea0dd908849ba600ea" translate="yes" xml:space="preserve">
          <source>The attribute value as a string, or null if the attribute is not in the list or if qualified names are not available.</source>
          <target state="translated">속성 값 (문자열). 속성이 목록에 없거나 규정 된 이름을 사용할 수없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="aefb1ad63cc6f055a21e7cb7abc5ae5f1e7f9c39" translate="yes" xml:space="preserve">
          <source>The attribute value as a string, or null if the attribute is not in the list.</source>
          <target state="translated">속성 값 (문자열) 또는 속성이 목록에없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="164de96b6da0b90c5309861bbfb4a4505a4612e4" translate="yes" xml:space="preserve">
          <source>The attribute value as a string, or null if the index is out of range.</source>
          <target state="translated">속성 값 (문자열) 또는 인덱스가 범위를 벗어난 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="f3f060f62953dc9115b0b7d54def2c51566e89b4" translate="yes" xml:space="preserve">
          <source>The attribute value as a string, or null if there is no attribute at that position.</source>
          <target state="translated">속성 값 (문자열). 해당 위치에 속성이없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="1dd4ad63a087a507070b2c6d348bcb8ed887c556" translate="yes" xml:space="preserve">
          <source>The attribute value in the given attribute category contained in this attribute set, or &lt;code&gt;null&lt;/code&gt; if this attribute set does not contain any attribute value in the given attribute category.</source>
          <target state="translated">이 속성 세트에 포함 된 지정된 속성 카테고리의 속성치, 또는 &lt;code&gt;null&lt;/code&gt; 이 속성 세트가 지정된 속성 카테고리의 속성치를 포함하지 않는 경우는</target>
        </trans-unit>
        <trans-unit id="c9b3c532b4fd8604d6498fcad4c2d6d37be688c5" translate="yes" xml:space="preserve">
          <source>The attribute value is empty.</source>
          <target state="translated">속성 값이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="45bdb71209fadde1b748a91c98474797f9408b98" translate="yes" xml:space="preserve">
          <source>The attribute value is enclosed in double quotation marks.</source>
          <target state="translated">속성 값은 큰 따옴표로 묶여 있습니다.</target>
        </trans-unit>
        <trans-unit id="2562d079213f9c72ba8f5c44c3b30816e7f295f7" translate="yes" xml:space="preserve">
          <source>The attribute value is enclosed in single quotation marks.</source>
          <target state="translated">속성 값은 작은 따옴표로 묶여 있습니다.</target>
        </trans-unit>
        <trans-unit id="e698eca87d650219a97764123c1a01c79c3be291" translate="yes" xml:space="preserve">
          <source>The attribute value is not enclosed in quotes.</source>
          <target state="translated">속성 값은 따옴표로 묶여 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5faf6d2dd43f858156ee6f32627f58f5d29b0a69" translate="yes" xml:space="preserve">
          <source>The attribute's effective value is determined as follows: if this attribute has been explicitly assigned any value, that value is the attribute's effective value; otherwise, if there is a declaration for this attribute, and that declaration includes a default value, then that default value is the attribute's effective value; otherwise, the attribute does not exist on this element in the structure model until it has been explicitly added. Note that the &lt;code&gt;Node.nodeValue&lt;/code&gt; attribute on the &lt;code&gt;Attr&lt;/code&gt; instance can also be used to retrieve the string version of the attribute's value(s).</source>
          <target state="translated">속성의 유효 값은 다음과 같이 결정됩니다.이 속성에 명시 적으로 값이 할당 된 경우 해당 값은 속성의 유효 값입니다. 그렇지 않으면이 속성에 대한 선언이 있고 해당 선언에 기본값이 포함되어 있으면 해당 기본값이 속성의 유효 값입니다. 그렇지 않으면 속성이 명시 적으로 추가 될 때까지 구조 모델의이 요소에 존재하지 않습니다. &lt;code&gt;Attr&lt;/code&gt; 인스턴스 의 &lt;code&gt;Node.nodeValue&lt;/code&gt; 속성을 사용하여 속성 값의 문자열 버전을 검색 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f441c4bf41be66006b6033e98e5ac552faa0471c" translate="yes" xml:space="preserve">
          <source>The attribute's index, or -1 if none matches.</source>
          <target state="translated">속성의 색인 또는 일치하는 항목이 없으면 -1입니다.</target>
        </trans-unit>
        <trans-unit id="3c94d6258ca6f36faf508a8c820562e2abf738d1" translate="yes" xml:space="preserve">
          <source>The attribute's local name, the empty string if none is available, or null if the index if out of range.</source>
          <target state="translated">속성의 로컬 이름, 사용할 수없는 경우 빈 문자열, 범위를 벗어난 경우 인덱스가 null 인 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="c2360410f79db0374ab884c53a1a6803022e6907" translate="yes" xml:space="preserve">
          <source>The attribute's qualified name, the empty string if none is available, or null if the index is out of bounds.</source>
          <target state="translated">속성의 정규화 된 이름, 사용할 수없는 경우 빈 문자열, 인덱스가 범위를 벗어난 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="bd99275c284235d7cf7a419987d70ea2029d7722" translate="yes" xml:space="preserve">
          <source>The attribute's syntax definition. Null if the implementation supports schemas but this particular attribute does not have any schema information.</source>
          <target state="translated">속성의 구문 정의 구현이 스키마를 지원하지만이 특정 속성에 스키마 정보가없는 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="59fc8784133fd5b0f312f19ab90228ec4791d333" translate="yes" xml:space="preserve">
          <source>The attribute's type as a string, or null if the index is out of range.</source>
          <target state="translated">속성의 유형 (문자열) 또는 색인이 범위를 벗어난 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="f992d75e6f693cc0ae9d073b592d5c2334e49074" translate="yes" xml:space="preserve">
          <source>The attribute's type, &quot;CDATA&quot; if the type is unknown, or null if the index is out of bounds.</source>
          <target state="translated">속성의 유형, 유형을 알 수없는 경우 &quot;CDATA&quot;, 인덱스가 범위를 벗어난 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="01426a98113a985e00c602b255a397064f8815be" translate="yes" xml:space="preserve">
          <source>The attribute's type, or null if there is no matching attribute.</source>
          <target state="translated">속성의 유형 또는 일치하는 속성이없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="5f9c5163ce57c86085d588d45eed0bee6b04e956" translate="yes" xml:space="preserve">
          <source>The attribute's value as a string, or null if the index is out of range.</source>
          <target state="translated">속성 값 (문자열) 또는 색인이 범위를 벗어난 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="30fe5760fab206aee6af7b71187c4047d60fd6de" translate="yes" xml:space="preserve">
          <source>The attribute's value or null if the index is out of bounds.</source>
          <target state="translated">속성의 값 또는 인덱스가 범위를 벗어난 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="3897ad8bf9ce337b7658e25aa43ebc1e61c7d8fa" translate="yes" xml:space="preserve">
          <source>The attribute's value, or null if there is no matching attribute.</source>
          <target state="translated">속성의 값 또는 일치하는 속성이없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="d549ddcd3fccf22b90744c0d31091b163d4ce4d5" translate="yes" xml:space="preserve">
          <source>The attributes</source>
          <target state="translated">속성</target>
        </trans-unit>
        <trans-unit id="d08b86f739c4b3f9ebb6ffd6f713209c2439cb17" translate="yes" xml:space="preserve">
          <source>The attributes &lt;code&gt;Element.schemaTypeInfo&lt;/code&gt; and &lt;code&gt;Attr.schemaTypeInfo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Element.schemaTypeInfo&lt;/code&gt; 및 &lt;code&gt;Attr.schemaTypeInfo&lt;/code&gt; 속성 .</target>
        </trans-unit>
        <trans-unit id="f8018fa7e84d66d6555397bce089b3f6a322b597" translate="yes" xml:space="preserve">
          <source>The attributes &lt;code&gt;nodeName&lt;/code&gt;, &lt;code&gt;nodeValue&lt;/code&gt; and &lt;code&gt;attributes&lt;/code&gt; are included as a mechanism to get at node information without casting down to the specific derived interface. In cases where there is no obvious mapping of these attributes for a specific &lt;code&gt;nodeType&lt;/code&gt; (e.g., &lt;code&gt;nodeValue&lt;/code&gt; for an &lt;code&gt;Element&lt;/code&gt; or &lt;code&gt;attributes&lt;/code&gt; for a &lt;code&gt;Comment&lt;/code&gt; ), this returns &lt;code&gt;null&lt;/code&gt;. Note that the specialized interfaces may contain additional and more convenient mechanisms to get and set the relevant information.</source>
          <target state="translated">속성 &lt;code&gt;nodeName&lt;/code&gt; , &lt;code&gt;nodeValue&lt;/code&gt; 를을 하고 &lt;code&gt;attributes&lt;/code&gt; 특정의 파생 인터페이스에 아래로 캐스팅하지 않고 노드 정보를 취득하는 메카니즘입니다. 경우에 특정의 이러한 속성의 명백한 매핑이없는 경우 &lt;code&gt;nodeType&lt;/code&gt; (예를 들어, &lt;code&gt;nodeValue&lt;/code&gt; 를 에 대한 &lt;code&gt;Element&lt;/code&gt; 또는 &lt;code&gt;attributes&lt;/code&gt; A에 대한 &lt;code&gt;Comment&lt;/code&gt; )이 반환 &lt;code&gt;null&lt;/code&gt; . 특수 인터페이스에는 관련 정보를 가져오고 설정하기위한보다 편리한 추가 메커니즘이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86ed9a68fddb96d8ff1b0eb2448e67c28c87e615" translate="yes" xml:space="preserve">
          <source>The attributes and the types the given CompositeData contains</source>
          <target state="translated">주어진 CompositeData에 포함 된 속성 및 유형</target>
        </trans-unit>
        <trans-unit id="fecaf517cb0c1d23a14d8af1b1ef81c1133e3d9e" translate="yes" xml:space="preserve">
          <source>The attributes and their types for StackTraceElement's composite data</source>
          <target state="translated">StackTraceElement의 복합 데이터에 대한 속성 및 유형</target>
        </trans-unit>
        <trans-unit id="0bac6135e470634c271aad8f1e5b0b2839010edd" translate="yes" xml:space="preserve">
          <source>The attributes and their types for ThreadInfo's composite data</source>
          <target state="translated">ThreadInfo의 복합 데이터에 대한 속성 및 유형</target>
        </trans-unit>
        <trans-unit id="a76ea94b7d99de3067d75d28a78025ca20943179" translate="yes" xml:space="preserve">
          <source>The attributes and their types the given CompositeData contains</source>
          <target state="translated">주어진 CompositeData에 포함 된 속성 및 유형</target>
        </trans-unit>
        <trans-unit id="3b4fb6a472a0a1c0664b9c45a0e5bd747e2f2099" translate="yes" xml:space="preserve">
          <source>The attributes for this connector server.</source>
          <target state="translated">이 커넥터 서버의 속성</target>
        </trans-unit>
        <trans-unit id="e44bd03ed9e10bb6dbf4066de22a75ed290d8fb8" translate="yes" xml:space="preserve">
          <source>The attributes of the returned Style will change as rules are added and removed. That is if you to ask for a rule with a selector &quot;table p&quot; and a new rule was added with a selector of &quot;p&quot; the returned Style would include the new attributes from the rule &quot;p&quot;.</source>
          <target state="translated">반환 된 Style의 속성은 규칙이 추가 및 제거됨에 따라 변경됩니다. 즉, &quot;table p&quot;선택기로 규칙을 요청하고 &quot;p&quot;선택기로 새 규칙을 추가 한 경우 반환 된 Style에는 &quot;p&quot;규칙의 새 속성이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e9c201f44e4ca609a7b0b4b06480ad2ced2b1001" translate="yes" xml:space="preserve">
          <source>The attributes parameter on input will reflect the applications required initial selections in the user dialog. Attributes not specified display using the default for the service. On return it will reflect the user's choices. Selections may be updated by the implementation to be consistent with the supported values for the currently selected print service.</source>
          <target state="translated">입력시 속성 매개 변수는 사용자 대화 상자에서 초기 선택에 필요한 애플리케이션을 반영합니다. 지정되지 않은 속성은 서비스의 기본값을 사용하여 표시됩니다. 반환시 사용자의 선택을 반영합니다. 현재 선택된 인쇄 서비스에 대해 지원되는 값과 일치하도록 구현에서 선택 사항을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25bb87449b4defed08782d572513bafb2c821a9e" translate="yes" xml:space="preserve">
          <source>The attributes parameter on input will reflect the client's required initial selections in the user dialog. Attributes which are not specified display using the default for the service. On return it will reflect the user's choices. Selections may be updated by the implementation to be consistent with the supported values for the currently selected print service.</source>
          <target state="translated">입력시 속성 매개 변수는 사용자 대화 상자에서 클라이언트의 필수 초기 선택을 반영합니다. 지정되지 않은 속성은 서비스의 기본값을 사용하여 표시됩니다. 반환시 사용자의 선택을 반영합니다. 현재 선택된 인쇄 서비스에 대해 지원되는 값과 일치하도록 구현에서 선택 사항을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96a7dc35d5c6ff09c07ad1bfd51ce24fab766779" translate="yes" xml:space="preserve">
          <source>The attributes/value from the underlying &lt;code&gt;Format&lt;/code&gt; instances that &lt;code&gt;MessageFormat&lt;/code&gt; uses will also be placed in the resulting &lt;code&gt;AttributedCharacterIterator&lt;/code&gt;. This allows you to not only find where an argument is placed in the resulting String, but also which fields it contains in turn.</source>
          <target state="translated">&lt;code&gt;MessageFormat&lt;/code&gt; 이 사용 하는 기본 &lt;code&gt;Format&lt;/code&gt; 인스턴스 의 속성 / 값 도 결과 &lt;code&gt;AttributedCharacterIterator&lt;/code&gt; 에 배치됩니다 . 이를 통해 결과 문자열에서 인수가 배치되는 위치뿐만 아니라 포함 된 필드도 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f322ed5c4ad34a9a63ed80e9eb3ea43df736b5d" translate="yes" xml:space="preserve">
          <source>The audience for this Service Provider Interface is engineers wishing to implement their own version of the execution engine in support of the JShell API.</source>
          <target state="translated">이 서비스 공급자 인터페이스의 대상은 JShell API를 지원하는 자체 버전의 실행 엔진을 구현하려는 엔지니어입니다.</target>
        </trans-unit>
        <trans-unit id="c6c9bdf9ddd1d7bebd18e501edcfe1c5e07915f2" translate="yes" xml:space="preserve">
          <source>The audio encoding technique used by this format.</source>
          <target state="translated">이 형식에서 사용되는 오디오 인코딩 기술입니다.</target>
        </trans-unit>
        <trans-unit id="3ee0fa3c0794117f8475306ae21eb1f01db34317" translate="yes" xml:space="preserve">
          <source>The authentication id to check.</source>
          <target state="translated">확인할 인증 ID입니다.</target>
        </trans-unit>
        <trans-unit id="b4dbd2e0b17a4fa9c9109e46037e682fe9637ca2" translate="yes" xml:space="preserve">
          <source>The authentication type is determined by the actual certificate used. For instance, if RSAPublicKey is used, the authType should be &quot;RSA&quot;. Checking is case-sensitive.</source>
          <target state="translated">인증 유형은 사용 된 실제 인증서에 따라 결정됩니다. 예를 들어, RSAPublicKey가 사용되는 경우 authType은 &quot;RSA&quot;여야합니다. 확인은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="40ca0bf39b10369e774c84090c9b0218a501eccc" translate="yes" xml:space="preserve">
          <source>The authentication type is the key exchange algorithm portion of the cipher suites represented as a String, such as &quot;RSA&quot;, &quot;DHE_DSS&quot;. Note: for some exportable cipher suites, the key exchange algorithm is determined at run time during the handshake. For instance, for TLS_RSA_EXPORT_WITH_RC4_40_MD5, the authType should be RSA_EXPORT when an ephemeral RSA key is used for the key exchange, and RSA when the key from the server certificate is used. Checking is case-sensitive.</source>
          <target state="translated">인증 유형은 &quot;RSA&quot;, &quot;DHE_DSS&quot;와 같은 문자열로 표시되는 암호 제품군의 키 교환 알고리즘 부분입니다. 참고 : 일부 내보낼 수있는 암호 제품군의 경우 키 교환 알고리즘은 핸드 셰이크 중에 런타임에 결정됩니다. 예를 들어, TLS_RSA_EXPORT_WITH_RC4_40_MD5의 경우 임시 RSA 키가 키 교환에 사용될 경우 authType은 RSA_EXPORT이고 서버 인증서의 키가 사용될 때는 RSA 여야합니다. 확인은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="da52d0384721ee0710abc385996af9e46a62ac13" translate="yes" xml:space="preserve">
          <source>The authentication type to use for this resource. This may be specified for resources representing a connection factory of any supported type, and must not be specified for resources of other types.</source>
          <target state="translated">이 자원에 사용할 인증 유형입니다. 지원되는 모든 유형의 연결 팩토리를 나타내는 자원에 대해 지정 될 수 있으며 다른 유형의 자원에 대해서는 지정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2a4a45fa984ec8bf14546e0f53e88faedba04946" translate="yes" xml:space="preserve">
          <source>The authority component of a URI, if defined, only contains the commercial-at character (&lt;code&gt;'@'&lt;/code&gt;) and characters in the</source>
          <target state="translated">URI의 권한 구성 요소는 정의 된 경우 상업 문자 ( &lt;code&gt;'@'&lt;/code&gt; ) 및</target>
        </trans-unit>
        <trans-unit id="a6af6b54b90269c0178a9319b6ac6d1d5547a316" translate="yes" xml:space="preserve">
          <source>The authority component of a hierarchical URI is, if specified, either</source>
          <target state="translated">계층 적 URI의 권한 구성 요소는 지정된 경우 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ee24e9771cc2c195ad59121d1a3d3bba72a163ad" translate="yes" xml:space="preserve">
          <source>The authorization ID of the client.</source>
          <target state="translated">클라이언트의 인증 ID.</target>
        </trans-unit>
        <trans-unit id="aec37cf9a0d4085765621bd0ceedb68819e4688e" translate="yes" xml:space="preserve">
          <source>The automatic redirection policy is checked whenever a &lt;code&gt;3XX&lt;/code&gt; response code is received. If redirection does not happen automatically, then the response, containing the &lt;code&gt;3XX&lt;/code&gt; response code, is returned, where it can be handled manually.</source>
          <target state="translated">자동 리디렉션 정책은 &lt;code&gt;3XX&lt;/code&gt; 응답 코드가 수신 될 때마다 확인 됩니다. 리디렉션이 자동으로 발생하지 않으면 &lt;code&gt;3XX&lt;/code&gt; 응답 코드가 포함 된 응답이 반환되며 여기서 수동으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="8523bec44f565ab76c484d97519aa9a3dfce94c9" translate="yes" xml:space="preserve">
          <source>The availability of a line number for a location will depend on the level of debugging information available from the target VM.</source>
          <target state="translated">위치에 대한 줄 번호의 가용성은 대상 VM에서 사용할 수있는 디버깅 정보의 수준에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="384af224756a5ae102067cba3f04e5f5aec1f4e8" translate="yes" xml:space="preserve">
          <source>The average is a special case of a &lt;a href=&quot;package-summary#Reduction&quot;&gt;reduction&lt;/a&gt;.</source>
          <target state="translated">평균은 &lt;a href=&quot;package-summary#Reduction&quot;&gt;축소&lt;/a&gt; 의 특별한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="bb72a1ed708709d8af323cafd1c14f03fc2702fe" translate="yes" xml:space="preserve">
          <source>The average number of bytes produced per character of input</source>
          <target state="translated">입력 문자 당 생성 된 평균 바이트 수</target>
        </trans-unit>
        <trans-unit id="61e1e4d7a028374e193be9a8bb07584ca34ed0c2" translate="yes" xml:space="preserve">
          <source>The average number of characters produced per byte of input</source>
          <target state="translated">입력 바이트 당 생성 된 평균 문자 수</target>
        </trans-unit>
        <trans-unit id="63d8732752ab98346e8809a4b5543eeb11a12175" translate="yes" xml:space="preserve">
          <source>The average returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a &lt;code&gt;NaN&lt;/code&gt; or the sum is at any point a &lt;code&gt;NaN&lt;/code&gt; then the average will be &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">반환되는 평균은 크기가 다른 값의 누적 반올림 오차로 인해 값이 기록되는 순서에 따라 달라질 수 있습니다. 절대 크기를 늘리면 정렬 된 값이 더 정확한 결과를 얻는 경향이 있습니다. 기록 된 값이 &lt;code&gt;NaN&lt;/code&gt; 이거나 합계가 &lt;code&gt;NaN&lt;/code&gt; 인 경우 평균은 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0994cf127413fed7f22b3a2b60b751f5b71c9f67" translate="yes" xml:space="preserve">
          <source>The average returned can vary depending upon the order in which values are recorded. This method may be implemented using compensated summation or other technique to reduce the error bound in the &lt;a href=&quot;doublestream#sum--&quot;&gt;&lt;code&gt;numerical sum&lt;/code&gt;&lt;/a&gt; used to compute the average.</source>
          <target state="translated">반환되는 평균값은 값이 기록되는 순서에 따라 달라질 수 있습니다. 이 방법은 평균을 계산하기 위해 사용 된 &lt;a href=&quot;doublestream#sum--&quot;&gt; &lt;code&gt;numerical sum&lt;/code&gt; &lt;/a&gt; 에서 오차 한계를 감소시키기 위해 보상 합 또는 다른 기술을 사용하여 구현 될 수있다 .</target>
        </trans-unit>
        <trans-unit id="1c0a64799c5be05a53a7a6b2d455ab60be8b27d5" translate="yes" xml:space="preserve">
          <source>The average returned can vary depending upon the order in which values are recorded. This method may be implemented using compensated summation or other technique to reduce the error bound in the &lt;a href=&quot;doublesummarystatistics#getSum--&quot;&gt;&lt;code&gt;numerical sum&lt;/code&gt;&lt;/a&gt; used to compute the average.</source>
          <target state="translated">반환되는 평균값은 값이 기록되는 순서에 따라 달라질 수 있습니다. 이 방법은 평균을 계산하기 위해 사용 된 &lt;a href=&quot;doublesummarystatistics#getSum--&quot;&gt; &lt;code&gt;numerical sum&lt;/code&gt; &lt;/a&gt; 에서 오차 한계를 감소시키기 위해 보상 합 또는 다른 기술을 사용하여 구현 될 수있다 .</target>
        </trans-unit>
        <trans-unit id="df4fb0a2f2eee660620ab243296b5b926ea78b61" translate="yes" xml:space="preserve">
          <source>The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object. The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object.</source>
          <target state="translated">깨어 난 스레드는 현재 스레드가이 개체에 대한 잠금을 해제 할 때까지 진행할 수 없습니다. 깨어 난 스레드는 일반적인 방식으로이 개체에서 동기화하기 위해 경쟁하는 다른 스레드와 경쟁합니다. 예를 들어, 깨어 난 스레드는이 개체를 잠그는 다음 스레드가 될 때 신뢰할 수있는 특권이나 단점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b5974bbfcd5ae065e5d3709711a9478f3485161b" translate="yes" xml:space="preserve">
          <source>The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object. The awakened threads will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened threads enjoy no reliable privilege or disadvantage in being the next thread to lock this object.</source>
          <target state="translated">깨어 난 스레드는 현재 스레드가이 개체에 대한 잠금을 해제 할 때까지 진행할 수 없습니다. 깨어 난 스레드는 일반적인 방식으로이 개체에서 동기화하기 위해 경쟁하는 다른 스레드와 경쟁합니다. 예를 들어, 깨어 난 스레드는이 개체를 잠그는 다음 스레드가 될 때 신뢰할 수있는 특권이나 단점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9fd801ec67dfa40187b8831fc899e417cef55b15" translate="yes" xml:space="preserve">
          <source>The back buffers</source>
          <target state="translated">백 버퍼</target>
        </trans-unit>
        <trans-unit id="475c859e9f4908b7f138258f2157091a01d81ce5" translate="yes" xml:space="preserve">
          <source>The background color affects each component differently and the parts of the component that are affected by the background color may differ between operating systems.</source>
          <target state="translated">배경색은 각 구성 요소에 다르게 영향을 미치며 배경색의 영향을받는 구성 요소 부분은 운영 체제마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90d94568a36055805975892d5e726d5cd72e9d2a" translate="yes" xml:space="preserve">
          <source>The background color of selected cells.</source>
          <target state="translated">선택한 셀의 배경색입니다.</target>
        </trans-unit>
        <trans-unit id="ff1b127e9666d20c9623315fca87c2cf41ceaa52" translate="yes" xml:space="preserve">
          <source>The background color of the docking border.</source>
          <target state="translated">도킹 테두리의 배경색입니다.</target>
        </trans-unit>
        <trans-unit id="a6765dea91ecf06864319ebfcc08a7eb3474a02d" translate="yes" xml:space="preserve">
          <source>The background color of the not docking border.</source>
          <target state="translated">고정되지 않은 테두리의 배경색입니다.</target>
        </trans-unit>
        <trans-unit id="0e901ca887d3a1d6eb5deb5a88ec3143d3921b5c" translate="yes" xml:space="preserve">
          <source>The background painter associated for the given state, or null if none could be found.</source>
          <target state="translated">지정된 상태에 연결된 배경 페인터입니다. 찾을 수없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="ff6828ab1479966e10f027d5d9d9b14a226945f1" translate="yes" xml:space="preserve">
          <source>The backlog parameter is the maximum number of pending associations on the socket. Its exact semantics are implementation specific. An implementation may impose an implementation specific maximum length or may choose to ignore the parameter. If the backlog parameter has the value &lt;code&gt;0&lt;/code&gt;, or a negative value, then an implementation specific default is used.</source>
          <target state="translated">backlog 매개 변수는 소켓에서 보류중인 최대 연관 수입니다. 정확한 의미는 구현에 따라 다릅니다. 구현은 구현 특정 최대 길이를 부과하거나 매개 변수를 무시하도록 선택할 수 있습니다. backlog 매개 변수의 값이 &lt;code&gt;0&lt;/code&gt; 이거나 음수이면 구현 별 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b602590fd64c98a3f6f7121d5df4bc045f576a6f" translate="yes" xml:space="preserve">
          <source>The backlog parameter is the maximum number of pending connections on the socket. Its exact semantics are implementation specific. An implementation may impose an implementation specific maximum length or may choose to ignore the parameter. If the backlog parameter has the value &lt;code&gt;0&lt;/code&gt;, or a negative value, then an implementation specific default is used.</source>
          <target state="translated">backlog 매개 변수는 소켓에서 보류중인 최대 연결 수입니다. 정확한 의미는 구현에 따라 다릅니다. 구현은 구현 특정 최대 길이를 부과하거나 매개 변수를 무시하도록 선택할 수 있습니다. backlog 매개 변수의 값이 &lt;code&gt;0&lt;/code&gt; 이거나 음수이면 구현 별 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ffe3bc3630669ac9a0d1cced2c0acfc7fe9a5bcc" translate="yes" xml:space="preserve">
          <source>The backreference constructs, &lt;code&gt;\g{&lt;/code&gt;</source>
          <target state="translated">역 참조 구문 &lt;code&gt;\g{&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba7183c765033aa363e3f66588a84ad98b740066" translate="yes" xml:space="preserve">
          <source>The backslash character</source>
          <target state="translated">백 슬래시 문자</target>
        </trans-unit>
        <trans-unit id="c54d456d477cda60e00f39118969acd00278ac3c" translate="yes" xml:space="preserve">
          <source>The backslash character (&lt;code&gt;'\'&lt;/code&gt;) serves to introduce escaped constructs, as defined in the table above, as well as to quote characters that otherwise would be interpreted as unescaped constructs. Thus the expression &lt;code&gt;\\&lt;/code&gt; matches a single backslash and &lt;code&gt;\{&lt;/code&gt; matches a left brace.</source>
          <target state="translated">백 슬래시 문자 ( &lt;code&gt;'\'&lt;/code&gt; )는 위 표에 정의 된대로 이스케이프 된 구문을 소개하고 이스케이프되지 않은 구문으로 해석되는 문자를 인용하는 역할을합니다. 따라서 &lt;code&gt;\\&lt;/code&gt; 표현식 은 단일 백 슬래시와 일치 하고 &lt;code&gt;\{&lt;/code&gt; 는 왼쪽 괄호와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="23aae77df11f01ad715953290d7bfdadcde657dc" translate="yes" xml:space="preserve">
          <source>The backslash character (&lt;code&gt;\&lt;/code&gt;) is used to escape characters that would otherwise be interpreted as special characters. The expression &lt;code&gt;\\&lt;/code&gt; matches a single backslash and &quot;\{&quot; matches a left brace for example.</source>
          <target state="translated">백 슬래시 문자 ( &lt;code&gt;\&lt;/code&gt; )는 특수 문자로 해석되는 문자를 이스케이프하는 데 사용됩니다. 예를 들어, &lt;code&gt;\\&lt;/code&gt; 표현식 은 단일 백 슬래시와 일치하고 &quot;\ {&quot;는 왼쪽 괄호와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="173f1752d2ba0fc408c016b82a7acf729f9be4f0" translate="yes" xml:space="preserve">
          <source>The backtrace for a throwable with an initialized, non-null cause should generally include the backtrace for the cause. The format of this information depends on the implementation, but the following example may be regarded as typical:</source>
          <target state="translated">널이 아닌 초기화 된 원인으로 발생 가능한 던지기에 대한 역 추적에는 일반적으로 원인에 대한 역 추적이 포함되어야합니다. 이 정보의 형식은 구현에 따라 다르지만 다음 예는 일반적인 것으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="829ef4e7edc7626ebd6182d71b577fce329016b8" translate="yes" xml:space="preserve">
          <source>The bank number of the instrument that this voice is currently using.</source>
          <target state="translated">이 음색이 현재 사용중인 악기의 뱅크 번호입니다.</target>
        </trans-unit>
        <trans-unit id="f7a908d77eceb25de71b84720c94aed1fee43c91" translate="yes" xml:space="preserve">
          <source>The bank number of the instrument that this voice is currently using. This is a number dictated by the MIDI bank-select message; it does not refer to a &lt;code&gt;SoundBank&lt;/code&gt; object. The value ranges from 0 to 16383 if the voice is active, and is unspecified if the voice is inactive.</source>
          <target state="translated">이 음색이 현재 사용중인 악기의 뱅크 번호입니다. 이것은 MIDI 뱅크 선택 메시지에 의해 지시 된 숫자입니다. &lt;code&gt;SoundBank&lt;/code&gt; 객체를 참조하지 않습니다 . 음성이 활성화 된 경우 값의 범위는 0-16383이며 음성이 비활성화 된 경우 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ab8a2ea7c84500b3dbb48c10ba75066f2c5af4f" translate="yes" xml:space="preserve">
          <source>The base &lt;code&gt;MidiMessage&lt;/code&gt; class provides access to three types of information about a MIDI message:</source>
          <target state="translated">기본 &lt;code&gt;MidiMessage&lt;/code&gt; 클래스는 MIDI 메시지에 대한 세 가지 유형의 정보에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="28004b526fdc9f2be85945c6ecb7bb8bcb938f22" translate="yes" xml:space="preserve">
          <source>The base URI to be used (see section 5.1.4 in [&lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;]) for resolving a relative &lt;code&gt;systemId&lt;/code&gt; to an absolute URI.</source>
          <target state="translated">상대 &lt;code&gt;systemId&lt;/code&gt; 를 절대 URI로 확인하기 위해 사용할 기본 URI ([ &lt;a href=&quot;http://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]의 섹션 5.1.4 참조 ) .</target>
        </trans-unit>
        <trans-unit id="f4cbf186c4b8b51c1161bbb96639dc3cc1c27337" translate="yes" xml:space="preserve">
          <source>The base URI to be used (see section 5.1.4 in [&lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt;]) for resolving a relative &lt;code&gt;systemId&lt;/code&gt; to an absolute URI.</source>
          <target state="translated">상대 &lt;code&gt;systemId&lt;/code&gt; 를 절대 URI로 확인하기 위해 사용할 기본 URI ([ &lt;a href=&quot;https://www.ietf.org/rfc/rfc2396.txt&quot;&gt;IETF RFC 2396&lt;/a&gt; ]의 섹션 5.1.4 참조 ) .</target>
        </trans-unit>
        <trans-unit id="28c558dd659dfb60707db86bc9a3479a721eca02" translate="yes" xml:space="preserve">
          <source>The base URI.</source>
          <target state="translated">기본 URI입니다.</target>
        </trans-unit>
        <trans-unit id="35c05535d0e99831d85c084856086df7b471b8f5" translate="yes" xml:space="preserve">
          <source>The base URI. See the href attribute definition in HTML 4.0.</source>
          <target state="translated">기본 URI입니다. HTML 4.0의 href 속성 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d12b90fe1b4a68d472c93bfe1c3b4f948e5ba33a" translate="yes" xml:space="preserve">
          <source>The base class for all &lt;a href=&quot;../jlayer&quot;&gt;&lt;code&gt;JLayer&lt;/code&gt;&lt;/a&gt;'s UI delegates.</source>
          <target state="translated">모든 &lt;a href=&quot;../jlayer&quot;&gt; &lt;code&gt;JLayer&lt;/code&gt; &lt;/a&gt; 의 UI 델리게이트에 대한 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="caac9d461a8f53343f359328652245110c6772eb" translate="yes" xml:space="preserve">
          <source>The base class for all Swing components except top-level containers.</source>
          <target state="translated">최상위 컨테이너를 제외한 모든 Swing 구성 요소의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="d7fa2d529b63aa5395c76f93fdfe2dbbf426c553" translate="yes" xml:space="preserve">
          <source>The base class for all Swing components except top-level containers. To use a component that inherits from &lt;code&gt;JComponent&lt;/code&gt;, you must place the component in a containment hierarchy whose root is a top-level Swing container. Top-level Swing containers -- such as &lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;, and &lt;code&gt;JApplet&lt;/code&gt; -- are specialized components that provide a place for other Swing components to paint themselves. For an explanation of containment hierarchies, see &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/toplevel.html&quot;&gt;Swing Components and the Containment Hierarchy&lt;/a&gt;, a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.</source>
          <target state="translated">최상위 컨테이너를 제외한 모든 Swing 구성 요소의 기본 클래스입니다. &lt;code&gt;JComponent&lt;/code&gt; 에서 상속 된 컴포넌트를 사용하려면 루트가 최상위 스윙 컨테이너 인 포함 계층 구조에 컴포넌트를 배치해야합니다. &lt;code&gt;JFrame&lt;/code&gt; , &lt;code&gt;JDialog&lt;/code&gt; 및 &lt;code&gt;JApplet&lt;/code&gt; 과 같은 최상위 스윙 컨테이너 는 다른 Swing 구성 요소가 스스로 페인트 할 수있는 장소를 제공하는 특수 구성 요소입니다. &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/toplevel.html&quot;&gt;포함 계층&lt;/a&gt; 에 대한 &lt;em&gt;설명&lt;/em&gt; 은 &lt;em&gt;The Java Tutorial&lt;/em&gt; 의 섹션 인 Swing Components 및 Containment Hierarchy를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="994a84956ab19d870862ff8b5c9b19b1b1871bc8" translate="yes" xml:space="preserve">
          <source>The base class for all Swing components except top-level containers. To use a component that inherits from &lt;code&gt;JComponent&lt;/code&gt;, you must place the component in a containment hierarchy whose root is a top-level Swing container. Top-level Swing containers -- such as &lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;, and &lt;code&gt;JApplet&lt;/code&gt; -- are specialized components that provide a place for other Swing components to paint themselves. For an explanation of containment hierarchies, see &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/uiswing/components/toplevel.html&quot;&gt;Swing Components and the Containment Hierarchy&lt;/a&gt;, a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.</source>
          <target state="translated">최상위 컨테이너를 제외한 모든 Swing 구성 요소의 기본 클래스입니다. &lt;code&gt;JComponent&lt;/code&gt; 에서 상속 된 구성 요소를 사용하려면 루트가 최상위 스윙 컨테이너 인 포함 계층 구조에 구성 요소를 배치해야합니다. &lt;code&gt;JFrame&lt;/code&gt; , &lt;code&gt;JDialog&lt;/code&gt; 및 &lt;code&gt;JApplet&lt;/code&gt; 과 같은 최상위 스윙 컨테이너 는 다른 Swing 구성 요소가 스스로 페인트 할 수있는 장소를 제공하는 특수 구성 요소입니다. &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/uiswing/components/toplevel.html&quot;&gt;포함 계층&lt;/a&gt; 에 대한 &lt;em&gt;설명&lt;/em&gt; 은 &lt;em&gt;The Java Tutorial&lt;/em&gt; 의 섹션 인 Swing Components 및 Containment Hierarchy를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="673323cb4efd578cf53a2e6bdd4fc577e79d8592" translate="yes" xml:space="preserve">
          <source>The base class for all UI delegate objects in the Swing pluggable look and feel architecture.</source>
          <target state="translated">Swing 플러그 형 룩앤필 아키텍처의 모든 UI 델리게이트 객체에 대한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="7f4e080fbd1063b1e0ce3f5ef88573ebd3ff712e" translate="yes" xml:space="preserve">
          <source>The base class for all UI delegate objects in the Swing pluggable look and feel architecture. The UI delegate object for a Swing component is responsible for implementing the aspects of the component that depend on the look and feel. The &lt;code&gt;JComponent&lt;/code&gt; class invokes methods from this class in order to delegate operations (painting, layout calculations, etc.) that may vary depending on the look and feel installed. &lt;b&gt;Client programs should not invoke methods on this class directly.&lt;/b&gt;</source>
          <target state="translated">Swing 플러그 형 룩앤필 아키텍처의 모든 UI 델리게이트 객체에 대한 기본 클래스입니다. Swing 컴포넌트의 UI 델리게이트 객체는 룩앤필에 의존하는 컴포넌트의 측면을 구현합니다. &lt;code&gt;JComponent&lt;/code&gt; 의 모양에 따라 달라질 수 있으며, 설치 느낄 위임 작업 (그림, 레이아웃의 계산 등)하기 위해이 클래스의 클래스가 호출하는 방법. &lt;b&gt;클라이언트 프로그램은이 클래스에서 직접 메서드를 호출해서는 안됩니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d34a65c87ecde42a4ca602b29050ad16b177edad" translate="yes" xml:space="preserve">
          <source>The base class for both standard and custom components that use the Swing architecture.</source>
          <target state="translated">Swing 아키텍처를 사용하는 표준 및 사용자 지정 구성 요소 모두에 대한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="2d8ea37b9287753a5e0ba2a565a7f46956883b1c" translate="yes" xml:space="preserve">
          <source>The base date is used to calculate the full value during parsing. For example, if the base date is 1950-01-01 then parsed values for a two digit year parse will be in the range 1950-01-01 to 2049-12-31. Only the year would be extracted from the date, thus a base date of 1950-08-25 would also parse to the range 1950-01-01 to 2049-12-31. This behavior is necessary to support fields such as week-based-year or other calendar systems where the parsed value does not align with standard ISO years.</source>
          <target state="translated">기준 날짜는 구문 분석 중 전체 값을 계산하는 데 사용됩니다. 예를 들어 기준 날짜가 1950-01-01 인 경우 두 자리 연도 구문 분석에 대한 구문 분석 된 값의 범위는 1950-01-01에서 2049-12-31 사이입니다. 날짜에서 연도 만 추출되므로 1950-08-25의 기본 날짜도 1950-01-01에서 2049-12-31 범위로 구문 분석됩니다. 이 동작은 주별 연도 또는 구문 분석 된 값이 표준 ISO 연도와 일치하지 않는 다른 달력 시스템과 같은 필드를 지원하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b8249397911e630616bfc25e7c327b7a51957437" translate="yes" xml:space="preserve">
          <source>The base exception for unexpected processing errors.</source>
          <target state="translated">예기치 않은 처리 오류에 대한 기본 예외입니다.</target>
        </trans-unit>
        <trans-unit id="341bc61cc2b10889ba5471f4989c7c0e64368b21" translate="yes" xml:space="preserve">
          <source>The base exception for unexpected processing errors. This Exception class is used to report well-formedness errors as well as unexpected processing conditions.</source>
          <target state="translated">예기치 않은 처리 오류에 대한 기본 예외입니다. 이 Exception 클래스는 예상치 못한 처리 조건뿐만 아니라 올바른 형식 오류를보고하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="88a4010b498850217ae4d51240587800dcf52fc4" translate="yes" xml:space="preserve">
          <source>The base interface for language-specific dynamic linkers.</source>
          <target state="translated">언어 별 동적 링커의 기본 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="e0b7a0da3ad40497ee4f294378c49ceb63041ce0" translate="yes" xml:space="preserve">
          <source>The base interface for language-specific dynamic linkers. Such linkers always have to produce method handles with guards, as the validity of the method handle for calls at a call site inevitably depends on some condition (at the very least, it depends on the receiver belonging to the language runtime of the linker). Language runtime implementors will normally implement the linking logic for their own language as one or more &lt;a href=&quot;guardingdynamiclinker&quot;&gt;&lt;code&gt;GuardingDynamicLinker&lt;/code&gt;&lt;/a&gt; classes. They will typically set them as &lt;a href=&quot;../dynamiclinkerfactory#setPrioritizedLinkers(java.util.List)&quot;&gt;&lt;code&gt;prioritized linkers&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;DynamicLinkerFactory&lt;/code&gt; they configure for themselves, and maybe also set some as &lt;a href=&quot;../dynamiclinkerfactory#setFallbackLinkers(java.util.List)&quot;&gt;&lt;code&gt;fallback
 linkers&lt;/code&gt;&lt;/a&gt; to handle language-specific &quot;property not found&quot; etc. conditions.</source>
          <target state="translated">언어 별 동적 링커의 기본 인터페이스입니다. 이러한 링커는 항상 가드가있는 메서드 핸들을 생성해야합니다. 호출 사이트에서 호출에 대한 메서드 핸들의 유효성은 필연적으로 일부 조건에 따라 달라지기 때문입니다 (적어도 링커의 언어 런타임에 속하는 수신자에 따라 다릅니다). 언어 런타임 구현자는 일반적으로 자신의 언어에 대한 연결 논리를 하나 이상의 &lt;a href=&quot;guardingdynamiclinker&quot;&gt; &lt;code&gt;GuardingDynamicLinker&lt;/code&gt; &lt;/a&gt; 클래스 로 구현합니다 . 일반적으로 &lt;code&gt;DynamicLinkerFactory&lt;/code&gt; 에서 자체적으로 구성 하는 &lt;a href=&quot;../dynamiclinkerfactory#setPrioritizedLinkers(java.util.List)&quot;&gt; &lt;code&gt;prioritized linkers&lt;/code&gt; &lt;/a&gt; 로 설정하고 일부는 언어 별 &quot;속성을 찾을 수 없음&quot;등의 조건을 처리하기 위해 &lt;a href=&quot;../dynamiclinkerfactory#setFallbackLinkers(java.util.List)&quot;&gt; &lt;code&gt;fallback linkers&lt;/code&gt; &lt;/a&gt; 로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a94b660699b5701cab32f8cf67ce77d005827383" translate="yes" xml:space="preserve">
          <source>The base memory address associated with this memory segment.</source>
          <target state="translated">이 메모리 세그먼트와 연관된 기본 메모리 주소입니다.</target>
        </trans-unit>
        <trans-unit id="1c13fd4b29ef27054b9399ed60b4e7952a4444f9" translate="yes" xml:space="preserve">
          <source>The base memory address associated with this memory segment. The returned address is a &lt;em&gt;checked&lt;/em&gt; memory address and can therefore be used in derefrence operations (see &lt;a href=&quot;memoryaddress&quot;&gt;&lt;code&gt;MemoryAddress&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 메모리 세그먼트와 연관된 기본 메모리 주소입니다. 반환 된 주소는 &lt;em&gt;확인 된&lt;/em&gt; 메모리 주소이므로 derefrence 작업에 사용할 수 있습니다 ( &lt;a href=&quot;memoryaddress&quot;&gt; &lt;code&gt;MemoryAddress&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="12185566e392d5a87d2e2869027cdc930ecabcb8" translate="yes" xml:space="preserve">
          <source>The base memory address.</source>
          <target state="translated">기본 메모리 주소입니다.</target>
        </trans-unit>
        <trans-unit id="a3bd05f667e3af60fd628c72d54eea43ed8ab06d" translate="yes" xml:space="preserve">
          <source>The base name for the &lt;a href=&quot;../../../java.base/java/util/resourcebundle&quot;&gt;&lt;code&gt;ResourceBundle&lt;/code&gt;&lt;/a&gt; in which the key given in the &lt;code&gt;descriptionResourceKey&lt;/code&gt; field can be found, for example &lt;code&gt;&quot;com.example.myapp.MBeanResources&quot;&lt;/code&gt;. The meaning of this field is defined by this specification but the field is not set or used by the JMX API itself.</source>
          <target state="translated">&lt;code&gt;descriptionResourceKey&lt;/code&gt; 필드에 제공된 키를 찾을 수있는 &lt;a href=&quot;../../../java.base/java/util/resourcebundle&quot;&gt; &lt;code&gt;ResourceBundle&lt;/code&gt; &lt;/a&gt; 의 기본 이름입니다 ( 예 : &lt;code&gt;&quot;com.example.myapp.MBeanResources&quot;&lt;/code&gt; ) . 이 필드의 의미는이 사양에 정의되어 있지만 JMX API 자체에서 설정하거나 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db101bc81e018a709756e424cfa5aecef7b94b31" translate="yes" xml:space="preserve">
          <source>The base name for the &lt;a href=&quot;../../java/util/resourcebundle&quot;&gt;&lt;code&gt;ResourceBundle&lt;/code&gt;&lt;/a&gt; in which the key given in the &lt;code&gt;descriptionResourceKey&lt;/code&gt; field can be found, for example &lt;code&gt;&quot;com.example.myapp.MBeanResources&quot;&lt;/code&gt;. The meaning of this field is defined by this specification but the field is not set or used by the JMX API itself.</source>
          <target state="translated">&lt;code&gt;descriptionResourceKey&lt;/code&gt; 필드에 제공된 키를 찾을 수있는 &lt;a href=&quot;../../java/util/resourcebundle&quot;&gt; &lt;code&gt;ResourceBundle&lt;/code&gt; &lt;/a&gt; 의 기본 이름입니다 ( 예 : &lt;code&gt;&quot;com.example.myapp.MBeanResources&quot;&lt;/code&gt; ) . 이 필드의 의미는이 스펙에서 정의되지만 JMX API 자체에서 필드를 설정하거나 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f3860eb6983917dd41e74b2471fbc7e734a2839" translate="yes" xml:space="preserve">
          <source>The base name of the resource bundle, as provided to and expected by the &lt;code&gt;ResourceBundle.getBundle(...)&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;ResourceBundle.getBundle(...)&lt;/code&gt; 메소드에 제공되고 예상되는 자원 번들의 기본 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="f5d5c0913b836b4a432df04868fa79954b56822a" translate="yes" xml:space="preserve">
          <source>The base operation of a namespace operation can not itself be a namespace or named operation, but rather one of simple operations such are elements of &lt;a href=&quot;standardoperation&quot;&gt;&lt;code&gt;StandardOperation&lt;/code&gt;&lt;/a&gt;. A namespace operation itself can serve as the base operation of a named operation, though; a typical way to construct e.g. the &lt;code&gt;GET:ELEMENT|PROPERTY:empty&lt;/code&gt; from above would be:</source>
          <target state="translated">네임 스페이스 작업의 기본 작업은 그 자체가 네임 스페이스 또는 명명 된 작업이 될 수 없지만 &lt;a href=&quot;standardoperation&quot;&gt; &lt;code&gt;StandardOperation&lt;/code&gt; 의&lt;/a&gt; 요소와 같은 간단한 작업 중 하나입니다 . 하지만 네임 스페이스 작업 자체는 명명 된 작업의 기본 작업 역할을 할 수 있습니다. 예를 들어 위에서 &lt;code&gt;GET:ELEMENT|PROPERTY:empty&lt;/code&gt; 를 구성하는 일반적인 방법 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b8c08a8db8d8c053315eb0ddb9eabf15da05825" translate="yes" xml:space="preserve">
          <source>The base-independent settings are:</source>
          <target state="translated">기본 독립 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="178835a96e3705f81ea2aa6a3c013f32bcd65492" translate="yes" xml:space="preserve">
          <source>The baseline anchor may be explicitly specified by the &lt;code&gt;createBaselineGroup&lt;/code&gt; method, or determined based on the elements. If not explicitly specified, the baseline will be anchored to the bottom if all the elements with a baseline, and that are aligned to the baseline, have a baseline resize behavior of &lt;code&gt;CONSTANT_DESCENT&lt;/code&gt;; otherwise the baseline is anchored to the top of the group.</source>
          <target state="translated">기준 앵커는 &lt;code&gt;createBaselineGroup&lt;/code&gt; 메소드에 의해 명시 적으로 지정 되거나 요소에 따라 결정될 수 있습니다 . 명시 적으로 지정되지 않은 경우 기준선이 있고 기준선에 정렬 된 모든 요소가 &lt;code&gt;CONSTANT_DESCENT&lt;/code&gt; 의 기준선 크기 조정 동작을 갖는 경우 기준선은 맨 아래에 고정됩니다 . 그렇지 않으면 기준선이 그룹의 맨 위에 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="b13e3ec606cf84eb9000668b4f81c591da47f8d4" translate="yes" xml:space="preserve">
          <source>The baseline is calculated based on the preferred height of each of the elements that have a baseline. The baseline is calculated using the following algorithm: &lt;code&gt;max(maxNonBaselineHeight, maxAscent + maxDescent)&lt;/code&gt;, where the &lt;code&gt;maxNonBaselineHeight&lt;/code&gt; is the maximum height of all elements that do not have a baseline, or are not aligned along the baseline. &lt;code&gt;maxAscent&lt;/code&gt; is the maximum ascent (baseline) of all elements that have a baseline and are aligned along the baseline. &lt;code&gt;maxDescent&lt;/code&gt; is the maximum descent (preferred height - baseline) of all elements that have a baseline and are aligned along the baseline.</source>
          <target state="translated">기준선은 기준선이있는 각 요소의 기본 높이를 기준으로 계산됩니다. 기준선은 &lt;code&gt;max(maxNonBaselineHeight, maxAscent + maxDescent)&lt;/code&gt; 알고리즘을 사용하여 계산됩니다. 여기서 &lt;code&gt;maxNonBaselineHeight&lt;/code&gt; 는 기준선이 없거나 기준선을 따라 정렬되지 않은 모든 요소의 최대 높이입니다. &lt;code&gt;maxAscent&lt;/code&gt; 는 기준선이 있고 기준선을 따라 정렬 된 모든 요소의 최대 상승 (기준선)입니다. &lt;code&gt;maxDescent&lt;/code&gt; 는 기준선이 있고 기준선을 따라 정렬 된 모든 요소의 최대 하강 (기본 높이-기준선)입니다.</target>
        </trans-unit>
        <trans-unit id="cf6b192777a130271185d5153662231d00979dda" translate="yes" xml:space="preserve">
          <source>The baseline of the first character is at position (</source>
          <target state="translated">첫 번째 문자의 기준선은 위치 (</target>
        </trans-unit>
        <trans-unit id="f1732e3aae9d17aa7261774f1829b82afeac44ae" translate="yes" xml:space="preserve">
          <source>The baseline of the leftmost character is at position (</source>
          <target state="translated">가장 왼쪽 문자의 기준선은 위치 (</target>
        </trans-unit>
        <trans-unit id="c561cc2da5280b44cc8e5e983e3666a821872eb1" translate="yes" xml:space="preserve">
          <source>The baseline used in Devanagari and similar scripts when laying out text.</source>
          <target state="translated">텍스트를 배치 할 때 Devanagari 및 유사한 스크립트에서 사용되는 기준선입니다.</target>
        </trans-unit>
        <trans-unit id="80762b66d10a773611c5a42382bc0e7afa20705c" translate="yes" xml:space="preserve">
          <source>The baseline used in ideographic scripts like Chinese, Japanese, and Korean when laying out text.</source>
          <target state="translated">텍스트를 배치 할 때 중국어, 일본어 및 한국어와 같은 표의 문자에 사용되는 기준선입니다.</target>
        </trans-unit>
        <trans-unit id="942abc2b441fb3d2080152a71e753b76ca62143a" translate="yes" xml:space="preserve">
          <source>The baseline used in most Roman scripts when laying out text.</source>
          <target state="translated">텍스트를 배치 할 때 대부분의 로마자 스크립트에서 사용되는 기준선입니다.</target>
        </trans-unit>
        <trans-unit id="908d0cb3e8b0ec0ea7b58e706bf53d271dae8a68" translate="yes" xml:space="preserve">
          <source>The basic L&amp;amp;F for a hierarchical data structure.</source>
          <target state="translated">계층 적 데이터 구조에 대한 기본 L &amp;amp; F.</target>
        </trans-unit>
        <trans-unit id="22c030ed5821c260423b1c4753dbb8e2a6a8f1d5" translate="yes" xml:space="preserve">
          <source>The basic X.509 format was defined by ISO/IEC and ANSI X9 and is described below in ASN.1:</source>
          <target state="translated">기본 X.509 형식은 ISO / IEC 및 ANSI X9에 의해 정의되었으며 아래 ASN.1에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd54f4614d132fbbda5026892eb97f40f214ca51" translate="yes" xml:space="preserve">
          <source>The basic appearance of one of these dialog boxes is generally similar to the picture above, although the various look-and-feels are ultimately responsible for the final result. In particular, the look-and-feels will adjust the layout to accommodate the option pane's &lt;code&gt;ComponentOrientation&lt;/code&gt; property.</source>
          <target state="translated">이러한 대화 상자 중 하나의 기본 모양은 일반적으로 위 그림과 유사하지만 최종 결과는 다양한 모양과 느낌이 궁극적으로 책임집니다. 특히 룩앤필은 옵션 창의 &lt;code&gt;ComponentOrientation&lt;/code&gt; 속성 을 수용하도록 레이아웃을 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="0785d4b501d4138551df284c612b88d563d171dd" translate="yes" xml:space="preserve">
          <source>The basic constraints extension identifies whether the subject of the certificate is a Certificate Authority (CA) and how deep a certification path may exist through that CA. The &lt;code&gt;pathLenConstraint&lt;/code&gt; field (see below) is meaningful only if &lt;code&gt;cA&lt;/code&gt; is set to TRUE. In this case, it gives the maximum number of CA certificates that may follow this certificate in a certification path. A value of zero indicates that only an end-entity certificate may follow in the path.</source>
          <target state="translated">기본 제한 조건 확장은 인증서의 주제가 인증 기관 (CA)인지 여부와 해당 CA를 통해 인증 경로가 존재할 수있는 깊이를 식별합니다. &lt;code&gt;pathLenConstraint&lt;/code&gt; 의 경우에만 필드 (아래 참조) 의미있는 &lt;code&gt;cA&lt;/code&gt; TRUE로 설정됩니다. 이 경우 인증 경로에서이 인증서 뒤에 올 수있는 최대 CA 인증서 수를 제공합니다. 값이 0이면 최종 엔터티 인증서 만 경로를 따를 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9d3e4470fb6fef2183cdb8feb8f069433d3267c8" translate="yes" xml:space="preserve">
          <source>The basic design intent is to allow applications to lazily locate and initialize services only when needed without any API dependencies except in an environment in which they are used.</source>
          <target state="translated">기본 디자인 의도는 응용 프로그램이 사용되는 환경을 제외하고 API 종속성없이 필요할 때만 서비스를 느리게 찾아서 초기화 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d9903103f8e3fb722ce3e381557a9ebadabbb1b5" translate="yes" xml:space="preserve">
          <source>The basic elements of date-time can all be added:</source>
          <target state="translated">날짜-시간의 기본 요소를 모두 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7256bc1b2ec603616f9dade14bcec445dc660430" translate="yes" xml:space="preserve">
          <source>The basic implementation of this method returns the conjunction of results obtained from &lt;code&gt;verify(input)&lt;/code&gt; and &lt;code&gt;verifyTarget(input)&lt;/code&gt; to ensure that both the source and the target components are in valid state.</source>
          <target state="translated">이 메서드의 기본 구현은 &lt;code&gt;verify(input)&lt;/code&gt; 및 &lt;code&gt;verifyTarget(input)&lt;/code&gt; 에서 얻은 결과의 결합을 반환 하여 소스 및 대상 구성 요소가 모두 유효한 상태인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0e71e801dc1e9f404b8698d22efcae2cd935213d" translate="yes" xml:space="preserve">
          <source>The basic service for managing a set of JDBC drivers.</source>
          <target state="translated">JDBC 드라이버 세트를 관리하기위한 기본 서비스입니다.</target>
        </trans-unit>
        <trans-unit id="df730da662879ba7ad947e6e095591e4eb5f371c" translate="yes" xml:space="preserve">
          <source>The bean context.</source>
          <target state="translated">빈 컨텍스트.</target>
        </trans-unit>
        <trans-unit id="a7c9bd47e337bf8f0e24f3fd1a3997732c06fa62" translate="yes" xml:space="preserve">
          <source>The bean is created based on a name relative to a class-loader. This name should be a dot-separated name such as &quot;a.b.c&quot;.</source>
          <target state="translated">Bean은 클래스 로더에 상대적인 이름을 기반으로 작성됩니다. 이 이름은 &quot;abc&quot;와 같이 점으로 구분 된 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="01fa9a9232e07d2331f9abf70122c26f44cb6dc7" translate="yes" xml:space="preserve">
          <source>The beginning of a line</source>
          <target state="translated">줄의 시작</target>
        </trans-unit>
        <trans-unit id="84c05d7f91bdedeed5670ac539f8d7123633e4bf" translate="yes" xml:space="preserve">
          <source>The beginning of the input</source>
          <target state="translated">입력의 시작</target>
        </trans-unit>
        <trans-unit id="4bf4be7cd283b65eee1ee51c2ca2edc17597e0a0" translate="yes" xml:space="preserve">
          <source>The behavior depends on the cardinality of the role where the unregistered MBean is referenced:</source>
          <target state="translated">동작은 등록되지 않은 MBean이 참조되는 역할의 카디널리티에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="17788ba641abd63899c4fce2ee10286755878197" translate="yes" xml:space="preserve">
          <source>The behavior for keeping the flow updated.</source>
          <target state="translated">흐름을 업데이트하기위한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="ee4de42c0517d47076e8bbabfc844b50c8d116d8" translate="yes" xml:space="preserve">
          <source>The behavior for keeping the flow updated. By default this is a singleton shared by all instances of FlowView (FlowStrategy is stateless). Subclasses can create an alternative strategy, which might keep state.</source>
          <target state="translated">흐름을 업데이트하기위한 동작입니다. 기본적으로 이것은 FlowView의 모든 인스턴스에서 공유하는 싱글 톤입니다 (FlowStrategy는 상태 비 저장). 하위 클래스는 상태를 유지할 수있는 대체 전략을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b749ed90eb455461fae07cc467bb93011fc93aa" translate="yes" xml:space="preserve">
          <source>The behavior for the case where the input stream is</source>
          <target state="translated">입력 스트림이있는 경우의 동작</target>
        </trans-unit>
        <trans-unit id="5aab83b129a0c7ffdae67ec9a21f46443c7f36f5" translate="yes" xml:space="preserve">
          <source>The behavior is suitable for use with most calendar systems. It is equivalent to:</source>
          <target state="translated">이 동작은 대부분의 달력 시스템에서 사용하기에 적합합니다. 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3fd6de2d8c10eb73ee592774720bf1e065b01d9b" translate="yes" xml:space="preserve">
          <source>The behavior is suitable for use with most calendar systems. It uses the &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; and &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; fields and the &lt;code&gt;DAYS&lt;/code&gt; unit, and assumes a seven day week.</source>
          <target state="translated">이 동작은 대부분의 달력 시스템에서 사용하기에 적합합니다. 그것은 사용 &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; 및 &lt;code&gt;DAY_OF_MONTH&lt;/code&gt; 필드와 &lt;code&gt;DAYS&lt;/code&gt; 단위를하고, 주 7 일이 가정합니다.</target>
        </trans-unit>
        <trans-unit id="bdd6f3ee23355515e15e9110422cea8654165976" translate="yes" xml:space="preserve">
          <source>The behavior is suitable for use with most calendar systems. It uses the &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; field and the &lt;code&gt;DAYS&lt;/code&gt; unit, and assumes a seven day week.</source>
          <target state="translated">이 동작은 대부분의 달력 시스템에서 사용하기에 적합합니다. 그것은 사용 &lt;code&gt;DAY_OF_WEEK&lt;/code&gt; 의 필드와 &lt;code&gt;DAYS&lt;/code&gt; 단위를하고, 주 7 일이 가정합니다.</target>
        </trans-unit>
        <trans-unit id="74bdca1a42ee6189cbe82e420cd1871137858f78" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt; is also specialized for variable arity adapters, to maintain the invariant that plain, inexact &lt;code&gt;invoke&lt;/code&gt; is always equivalent to an &lt;code&gt;asType&lt;/code&gt; call to adjust the target type, followed by &lt;code&gt;invokeExact&lt;/code&gt;. Therefore, a variable arity adapter responds to an &lt;code&gt;asType&lt;/code&gt; request by building a fixed arity collector, if and only if the adapter and requested type differ either in arity or trailing argument type. The resulting fixed arity collector has its type further adjusted (if necessary) to the requested type by pairwise conversion, as if by another application of &lt;code&gt;asType&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#asType(java.lang.invoke.MethodType)&quot;&gt; &lt;code&gt;asType&lt;/code&gt; &lt;/a&gt; 의 동작 은 또한 변수 arity 어댑터에 특화되어 있으며, 단순하고 정확하지 않은 &lt;code&gt;invoke&lt;/code&gt; 이 항상 대상 유형을 조정 하는 &lt;code&gt;asType&lt;/code&gt; 호출과 &lt;code&gt;invokeExact&lt;/code&gt; 그 뒤에 invokeExact가 오는 불변성을 유지합니다 . 따라서 가변 arity 어댑터 는 어댑터와 요청 된 유형이 arity 또는 후행 인수 유형이 다른 경우에만 고정 arity 수집기를 빌드 하여 &lt;code&gt;asType&lt;/code&gt; 요청에 응답 합니다. 결과 고정 arity 수집기는 &lt;code&gt;asType&lt;/code&gt; 의 다른 응용 프로그램 에서처럼 쌍으로 변환하여 요청 된 유형으로 추가 조정 (필요한 경우)합니다 .</target>
        </trans-unit>
        <trans-unit id="c78a1d17ae0c3c3a48da69bd93f5bf924cfc22fc" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt;&lt;code&gt;asType&lt;/code&gt;&lt;/a&gt; is also specialized for variable arity adapters, to maintain the invariant that plain, inexact &lt;code&gt;invoke&lt;/code&gt; is always equivalent to an &lt;code&gt;asType&lt;/code&gt; call to adjust the target type, followed by &lt;code&gt;invokeExact&lt;/code&gt;. Therefore, a variable arity adapter responds to an &lt;code&gt;asType&lt;/code&gt; request by building a fixed arity collector, if and only if the adapter and requested type differ either in arity or trailing argument type. The resulting fixed arity collector has its type further adjusted (if necessary) to the requested type by pairwise conversion, as if by another application of &lt;code&gt;asType&lt;/code&gt;.</source>
          <target state="translated">의 동작 &lt;a href=&quot;methodhandle#asType-java.lang.invoke.MethodType-&quot;&gt; &lt;code&gt;asType&lt;/code&gt; 은&lt;/a&gt; 또한 일반, 부정확 한 것을 불변 유지하기 위해, 가변 인수에 대응 어댑터에 대한 전문 &lt;code&gt;invoke&lt;/code&gt; 항상 동일합니다 &lt;code&gt;asType&lt;/code&gt; 의 다음 대상 유형, 조정 호출 &lt;code&gt;invokeExact&lt;/code&gt; 을 . 따라서 가변 arity 어댑터 는 어댑터 및 요청 된 유형이 arity 또는 후행 인수 유형이 다른 경우에만 고정 arity 콜렉터를 빌드 하여 &lt;code&gt;asType&lt;/code&gt; 요청에 응답 합니다. 결과 고정 arity 수집기는 &lt;code&gt;asType&lt;/code&gt; 의 다른 응용 프로그램에서와 같이 쌍으로 변환하여 요청 된 유형으로 유형을 추가로 조정합니다 (필요한 경우) .</target>
        </trans-unit>
        <trans-unit id="9928e84708937d65d173868df25d6628e2c4c51b" translate="yes" xml:space="preserve">
          <source>The behavior of aforementioned conversion process can be adjusted by various flags:</source>
          <target state="translated">위에서 언급 한 변환 프로세스의 동작은 다양한 플래그로 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fbcf3a96df41e03392144c63f6cb8863c78b90f" translate="yes" xml:space="preserve">
          <source>The behavior of an iterator is unspecified if the action modifies the collection in any way (even by calling the &lt;a href=&quot;#remove()&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; method or other mutator methods of &lt;code&gt;Iterator&lt;/code&gt; subtypes), unless an overriding class has specified a concurrent modification policy.</source>
          <target state="translated">오버라이드 클래스가 동시 수정 정책을 지정하지 않는 한, 액션이 컬렉션을 어떤 방식 으로든 수정하면 ( &lt;code&gt;Iterator&lt;/code&gt; 하위 유형 의 &lt;a href=&quot;#remove()&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 메서드 또는 다른 뮤 테이터 메서드를 호출하여도) 반복자의 동작이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8305c9515a4e412b39c823d6f18777785da93ef" translate="yes" xml:space="preserve">
          <source>The behavior of an iterator is unspecified if the action modifies the collection in any way (even by calling the &lt;a href=&quot;iterator#remove()&quot;&gt;&lt;code&gt;remove&lt;/code&gt;&lt;/a&gt; method or other mutator methods of &lt;code&gt;Iterator&lt;/code&gt; subtypes), unless an overriding class has specified a concurrent modification policy.</source>
          <target state="translated">오버라이드 클래스가 동시 수정 정책을 지정하지 않는 한, 액션이 컬렉션을 어떤 방식 으로든 수정하면 ( &lt;code&gt;Iterator&lt;/code&gt; 하위 유형 의 &lt;a href=&quot;iterator#remove()&quot;&gt; &lt;code&gt;remove&lt;/code&gt; &lt;/a&gt; 메서드 또는 다른 뮤 테이터 메서드를 호출하여도) 반복자의 동작이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0fa955e8e31221d07dcf9a5342ab84300fa2b4f6" translate="yes" xml:space="preserve">
          <source>The behavior of an iterator is unspecified if the underlying collection is modified while the iteration is in progress in any way other than by calling this method, unless an overriding class has specified a concurrent modification policy.</source>
          <target state="translated">재정의하는 클래스가 동시 수정 정책을 지정하지 않는 한이 메서드를 호출하는 것 이외의 방법으로 반복이 진행되는 동안 기본 컬렉션이 수정되면 반복기의 동작이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8cc1b6ee519eeb1ca565b40a3de66aee8c6ff4fc" translate="yes" xml:space="preserve">
          <source>The behavior of an iterator is unspecified if this method is called after a call to the &lt;a href=&quot;#forEachRemaining(java.util.function.Consumer)&quot;&gt;&lt;code&gt;forEachRemaining&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#forEachRemaining(java.util.function.Consumer)&quot;&gt; &lt;code&gt;forEachRemaining&lt;/code&gt; &lt;/a&gt; 메서드를 호출 한 후이 메서드 가 호출되면 반복기의 동작이 지정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9bf59e865382fd690a311ac0d41c086c6e20bedf" translate="yes" xml:space="preserve">
          <source>The behavior of calling next() when being on foo will be:</source>
          <target state="translated">foo에있을 때 next ()를 호출하는 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f50ced7d165236065e413bcf4586210358e70631" translate="yes" xml:space="preserve">
          <source>The behavior of cleaners during &lt;a href=&quot;../system#exit(int)&quot;&gt;&lt;code&gt;System.exit&lt;/code&gt;&lt;/a&gt; is implementation specific. No guarantees are made relating to whether cleaning actions are invoked or not.</source>
          <target state="translated">&lt;a href=&quot;../system#exit(int)&quot;&gt; &lt;code&gt;System.exit&lt;/code&gt; &lt;/a&gt; 동안 클리너의 동작 은 구현에 따라 다릅니다. 청소 작업의 실행 여부와 관련하여 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c42f6d49512d93fbc8cb3b5798a78129ce98efbe" translate="yes" xml:space="preserve">
          <source>The behavior of radixes and the characters used as digits are the same as &lt;a href=&quot;#toString(int,int)&quot;&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기수와 숫자로 사용되는 문자의 동작은 &lt;a href=&quot;#toString(int,int)&quot;&gt; &lt;code&gt;toString&lt;/code&gt; &lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="72c1b90efc36e384a511780ee9110f25b18fcdf4" translate="yes" xml:space="preserve">
          <source>The behavior of radixes and the characters used as digits are the same as &lt;a href=&quot;#toString(long,int)&quot;&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기수와 숫자로 사용되는 문자의 동작은 &lt;a href=&quot;#toString(long,int)&quot;&gt; &lt;code&gt;toString&lt;/code&gt; &lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="09786826b0bc4001e9b5554b263b6d5f4bb895ae" translate="yes" xml:space="preserve">
          <source>The behavior of radixes and the characters used as digits are the same as &lt;a href=&quot;integer#toString-int-int-&quot;&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기수의 동작과 숫자로 사용되는 문자는 &lt;a href=&quot;integer#toString-int-int-&quot;&gt; &lt;code&gt;toString&lt;/code&gt; &lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2327f433d1a38b7e2e39780763df7142425c0d7a" translate="yes" xml:space="preserve">
          <source>The behavior of radixes and the characters used as digits are the same as &lt;a href=&quot;long#toString-long-int-&quot;&gt;&lt;code&gt;toString&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기수의 동작과 숫자로 사용되는 문자는 &lt;a href=&quot;long#toString-long-int-&quot;&gt; &lt;code&gt;toString&lt;/code&gt; &lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="bc46c31b73f5a4c03e122bdac42a6357c999abe4" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;code&gt;WeakHashMap&lt;/code&gt; class depends in part upon the actions of the garbage collector, so several familiar (though not required) &lt;code&gt;Map&lt;/code&gt; invariants do not hold for this class. Because the garbage collector may discard keys at any time, a &lt;code&gt;WeakHashMap&lt;/code&gt; may behave as though an unknown thread is silently removing entries. In particular, even if you synchronize on a &lt;code&gt;WeakHashMap&lt;/code&gt; instance and invoke none of its mutator methods, it is possible for the &lt;code&gt;size&lt;/code&gt; method to return smaller values over time, for the &lt;code&gt;isEmpty&lt;/code&gt; method to return &lt;code&gt;false&lt;/code&gt; and then &lt;code&gt;true&lt;/code&gt;, for the &lt;code&gt;containsKey&lt;/code&gt; method to return &lt;code&gt;true&lt;/code&gt; and later &lt;code&gt;false&lt;/code&gt; for a given key, for the &lt;code&gt;get&lt;/code&gt; method to return a value for a given key but later return &lt;code&gt;null&lt;/code&gt;, for the &lt;code&gt;put&lt;/code&gt; method to return &lt;code&gt;null&lt;/code&gt; and the &lt;code&gt;remove&lt;/code&gt; method to return &lt;code&gt;false&lt;/code&gt; for a key that previously appeared to be in the map, and for successive examinations of the key set, the value collection, and the entry set to yield successively smaller numbers of elements.</source>
          <target state="translated">&lt;code&gt;WeakHashMap&lt;/code&gt; 클래스 의 동작은 부분적으로 가비지 콜렉터의 조치에 따라 달라 지므로 (필수 는 아니지만 ) 일부 익숙 하지 않은 &lt;code&gt;Map&lt;/code&gt; 불변 인이이 클래스에 대해 보유하지 않습니다. 가비지 콜렉터는 언제든지 키를 삭제할 수 있으므로 &lt;code&gt;WeakHashMap&lt;/code&gt; 은 알 수없는 스레드가 자동으로 항목을 제거하는 것처럼 작동 할 수 있습니다. 당신이에 동기화 할 경우에도, 특히 &lt;code&gt;WeakHashMap&lt;/code&gt; 인스턴스와 그 뮤 테이터 방법 없음 호출 가능합니다 &lt;code&gt;size&lt;/code&gt; 방법은을 위해, 시간이 지남에 따라 더 작은 값을 반환 &lt;code&gt;isEmpty&lt;/code&gt; 반환에 방법 &lt;code&gt;false&lt;/code&gt; 하고 &lt;code&gt;true&lt;/code&gt; 를 들어, &lt;code&gt;containsKey&lt;/code&gt; 의 반환에 방법 &lt;code&gt;true&lt;/code&gt; 나중에 &lt;code&gt;false&lt;/code&gt; 를 들어, 지정된 키 &lt;code&gt;get&lt;/code&gt; 메소드는 지정된 키하지만 나중에 반환 값을 돌려 &lt;code&gt;null&lt;/code&gt; 를 들어, &lt;code&gt;put&lt;/code&gt; 반환하는 방법 &lt;code&gt;null&lt;/code&gt; 과 &lt;code&gt;remove&lt;/code&gt; 반환하는 방법 &lt;code&gt;false&lt;/code&gt; 이전 맵으로 등장하는 키 키 세트, 값 수집 및 항목 세트의 연속적인 검토를 위해 더 적은 수의 요소를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3d39533880be9739a470b0410eccddc80033cddf" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;setLayout&lt;/code&gt; methods for &lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;, &lt;code&gt;JWindow&lt;/code&gt;, &lt;code&gt;JApplet&lt;/code&gt; and &lt;code&gt;JInternalFrame&lt;/code&gt; is controlled by the &lt;code&gt;rootPaneCheckingEnabled&lt;/code&gt; property. If this property is true (the default), then calls to these methods are forwarded to the &lt;code&gt;contentPane&lt;/code&gt;; if false, these methods operate directly on the &lt;code&gt;RootPaneContainer&lt;/code&gt;. This property is only intended for subclasses, and is therefore protected.</source>
          <target state="translated">&lt;code&gt;JFrame&lt;/code&gt; , &lt;code&gt;JDialog&lt;/code&gt; , &lt;code&gt;JWindow&lt;/code&gt; , &lt;code&gt;JApplet&lt;/code&gt; 및 &lt;code&gt;JInternalFrame&lt;/code&gt; 에 대한 &lt;code&gt;add&lt;/code&gt; 및 &lt;code&gt;setLayout&lt;/code&gt; 메서드 의 동작은 &lt;code&gt;rootPaneCheckingEnabled&lt;/code&gt; 속성에 의해 제어됩니다 . 이 속성이 true (기본값)이면 이러한 메서드에 대한 호출이 &lt;code&gt;contentPane&lt;/code&gt; 으로 전달됩니다 . false이면 이러한 메서드는 &lt;code&gt;RootPaneContainer&lt;/code&gt; 에서 직접 작동합니다 . 이 속성은 하위 클래스 전용이므로 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="3e02ad5d427f7e98147ba48075552194761f98de" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;code&gt;addAll()&lt;/code&gt; operation is unspecified if the specified set is modified while the operation is in progress.</source>
          <target state="translated">의 동작 &lt;code&gt;addAll()&lt;/code&gt; 의 동작이 진행되는 동안 지정된 세트가 변경되었을 경우 조작이 지정된다.</target>
        </trans-unit>
        <trans-unit id="b83e52cc0d9f0ee6925ee95a78e5d492ce7cd65d" translate="yes" xml:space="preserve">
          <source>The behavior of the input stream when used after the module reader is closed is implementation specific and therefore not specified.</source>
          <target state="translated">모듈 판독기가 닫힌 후 사용될 때 입력 스트림의 동작은 구현에 따라 다르므로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd3a0b270d27c03418b33e302ccbdd164f36924b" translate="yes" xml:space="preserve">
          <source>The behavior of the returned map is system-dependent. A system may not allow modifications to environment variables or may forbid certain variable names or values. For this reason, attempts to modify the map may fail with &lt;a href=&quot;unsupportedoperationexception&quot;&gt;&lt;code&gt;UnsupportedOperationException&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;illegalargumentexception&quot;&gt;&lt;code&gt;IllegalArgumentException&lt;/code&gt;&lt;/a&gt; if the modification is not permitted by the operating system.</source>
          <target state="translated">반환 된 맵의 동작은 시스템에 따라 다릅니다. 시스템은 환경 변수 수정을 허용하지 않거나 특정 변수 이름 또는 값을 금지 할 수 있습니다. 이러한 이유로 운영 체제에서 수정이 허용되지 않으면 &lt;a href=&quot;unsupportedoperationexception&quot;&gt; &lt;code&gt;UnsupportedOperationException&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;illegalargumentexception&quot;&gt; &lt;code&gt;IllegalArgumentException&lt;/code&gt; 으로&lt;/a&gt; 맵 수정 시도가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba0ea93844ac842fe0ad23c8ba7cc272b8f53619" translate="yes" xml:space="preserve">
          <source>The behavior of the stream when used after the module reader is closed is implementation specific and therefore not specified.</source>
          <target state="translated">모듈 판독기가 닫힌 후 사용될 때 스트림의 동작은 구현에 따라 다르므로 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fe6e71635b80bfba7b21f293fdc2c363d272846" translate="yes" xml:space="preserve">
          <source>The behavior of this constructor when the given bytes are not valid in the default charset is unspecified. The &lt;a href=&quot;../nio/charset/charsetdecoder&quot;&gt;&lt;code&gt;CharsetDecoder&lt;/code&gt;&lt;/a&gt; class should be used when more control over the decoding process is required.</source>
          <target state="translated">지정된 바이트가 디폴트 캐릭터 세트로 유효하지 않은 경우,이 생성자의 동작은 지정되지 않습니다. &lt;a href=&quot;../nio/charset/charsetdecoder&quot;&gt; &lt;code&gt;CharsetDecoder&lt;/code&gt; 의&lt;/a&gt; 부호화 처리 된 데이터를 복호화하는 과정을 더 제어 할 필요가있는 경우, 클래스를 사용하여야한다.</target>
        </trans-unit>
        <trans-unit id="ef46977efa30131184db5ba7badc7bce2b48869e" translate="yes" xml:space="preserve">
          <source>The behavior of this constructor when the given bytes are not valid in the given charset is unspecified. The &lt;a href=&quot;../nio/charset/charsetdecoder&quot;&gt;&lt;code&gt;CharsetDecoder&lt;/code&gt;&lt;/a&gt; class should be used when more control over the decoding process is required.</source>
          <target state="translated">주어진 바이트가 주어진 문자셋에서 유효하지 않을 때이 생성자의 동작은 지정되지 않습니다. &lt;a href=&quot;../nio/charset/charsetdecoder&quot;&gt; &lt;code&gt;CharsetDecoder&lt;/code&gt; 의&lt;/a&gt; 부호화 처리 된 데이터를 복호화하는 과정을 더 제어 할 필요가있는 경우, 클래스를 사용하여야한다.</target>
        </trans-unit>
        <trans-unit id="9505fc9c83fecb64cfc95870354b442fd902f91b" translate="yes" xml:space="preserve">
          <source>The behavior of this method is unspecified if the action performs side-effects that modify the underlying source of elements, unless an overriding class has specified a concurrent modification policy.</source>
          <target state="translated">재정의하는 클래스가 동시 수정 정책을 지정하지 않는 한 작업이 요소의 기본 소스를 수정하는 부작용을 수행하는 경우이 메서드의 동작은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4162fcc908ad41b2e0249c4243e7e3c867cf837" translate="yes" xml:space="preserve">
          <source>The behavior of this method is unspecified when invoked with a socket that is not newly created and unbound. Any socket options set on the given socket prior to invoking this method may or may not be preserved when the connection is accepted. It may not be possible to accept a connection when this socket has a &lt;code&gt;SocketImpl&lt;/code&gt; of one type and the given socket has a &lt;code&gt;SocketImpl&lt;/code&gt; of a completely different type.</source>
          <target state="translated">이 메서드의 동작은 새로 생성되지 않고 바인딩 해제되지 않은 소켓으로 호출 될 때 지정되지 않습니다. 이 메소드를 호출하기 전에 주어진 소켓에 설정된 소켓 옵션은 연결이 승인 될 때 ​​보존 될 수도 있고 보존되지 않을 수도 있습니다. 이 소켓 에 한 유형 의 &lt;code&gt;SocketImpl&lt;/code&gt; 이 있고 지정된 소켓 에 완전히 다른 유형 의 &lt;code&gt;SocketImpl&lt;/code&gt; 이있는 경우 연결을 수락하지 못할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3d627d59df90697e2b554f3a55de8ccd2ce8753" translate="yes" xml:space="preserve">
          <source>The behavior of this method when called for the first time depends on the parameters that were supplied at construction, as described below.</source>
          <target state="translated">처음 호출 할 때이 메소드의 동작은 아래 설명 된대로 구성시 제공된 매개 변수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4f973622f5301926870bc25f4502c72fb450009b" translate="yes" xml:space="preserve">
          <source>The behavior of this method when this string cannot be encoded in the default charset is unspecified. The &lt;a href=&quot;../nio/charset/charsetencoder&quot;&gt;&lt;code&gt;CharsetEncoder&lt;/code&gt;&lt;/a&gt; class should be used when more control over the encoding process is required.</source>
          <target state="translated">이 캐릭터 라인을 디폴트 캐릭터 세트로 encode 할 수없는 경우의이 동작은 지정되지 않습니다. &lt;a href=&quot;../nio/charset/charsetencoder&quot;&gt; &lt;code&gt;CharsetEncoder&lt;/code&gt; 의&lt;/a&gt; 부호화 처리를 더 제어 할 필요가있는 경우, 클래스가 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="6473ebdc9f7cacf7ddaf2b7432bd6ab177ee9d47" translate="yes" xml:space="preserve">
          <source>The behavior of this method when this string cannot be encoded in the given charset is unspecified. The &lt;a href=&quot;../nio/charset/charsetencoder&quot;&gt;&lt;code&gt;CharsetEncoder&lt;/code&gt;&lt;/a&gt; class should be used when more control over the encoding process is required.</source>
          <target state="translated">이 캐릭터 라인을 지정된 캐릭터 세트로 encode 할 수없는 경우의이 메소드의 동작은 지정되지 않습니다. &lt;a href=&quot;../nio/charset/charsetencoder&quot;&gt; &lt;code&gt;CharsetEncoder&lt;/code&gt; 의&lt;/a&gt; 부호화 처리를 더 제어 할 필요가있는 경우, 클래스가 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="2ae57d2eaaf4445efb0e51f92a31f9d7f1d65948" translate="yes" xml:space="preserve">
          <source>The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does &lt;em&gt;not&lt;/em&gt; guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses. If the action accesses shared state, it is responsible for providing the required synchronization.</source>
          <target state="translated">이 작업의 동작은 명시 적으로 비 결정적입니다. 병렬 스트림 파이프 라인의 경우이 작업은 스트림 의 발생 순서를 준수한다고 보장 하지는 &lt;em&gt;않습니다&lt;/em&gt; . 병렬 처리의 이점을 희생 할 수 있습니다. 주어진 요소에 대해, 언제 어디서나 라이브러리가 선택한 스레드에서 작업이 수행 될 수 있습니다. 조치가 공유 상태에 액세스하는 경우 필요한 동기화를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="b88434d6a50722a24d06d1ddb6c6054857b0af16" translate="yes" xml:space="preserve">
          <source>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use &lt;a href=&quot;#findFirst()&quot;&gt;&lt;code&gt;findFirst()&lt;/code&gt;&lt;/a&gt; instead.)</source>
          <target state="translated">이 작업의 동작은 명시 적으로 비 결정적입니다. 스트림의 모든 요소를 ​​자유롭게 선택할 수 있습니다. 이는 병렬 작업에서 최대 성능을 허용하기위한 것입니다. 비용은 동일한 소스에서 여러 호출이 동일한 결과를 반환하지 않을 수 있다는 것입니다. (안정적인 결과를 원하면 &lt;a href=&quot;#findFirst()&quot;&gt; &lt;code&gt;findFirst()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="7523e5e5c512c923c9b5e8efbcae139dd68a3aac" translate="yes" xml:space="preserve">
          <source>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use &lt;a href=&quot;doublestream#findFirst--&quot;&gt;&lt;code&gt;findFirst()&lt;/code&gt;&lt;/a&gt; instead.)</source>
          <target state="translated">이 작업의 동작은 명시 적으로 비 결정적입니다. 스트림에서 요소를 자유롭게 선택할 수 있습니다. 이는 병렬 작업에서 최대 성능을 제공하기위한 것입니다. 비용은 동일한 소스에서 여러 번의 호출이 동일한 결과를 리턴하지 않을 수 있다는 것입니다. (안정적인 결과를 원하면 &lt;a href=&quot;doublestream#findFirst--&quot;&gt; &lt;code&gt;findFirst()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="c3ed65b77c994c2fc97e72428779c268f50ba7b6" translate="yes" xml:space="preserve">
          <source>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use &lt;a href=&quot;intstream#findFirst--&quot;&gt;&lt;code&gt;findFirst()&lt;/code&gt;&lt;/a&gt; instead.)</source>
          <target state="translated">이 작업의 동작은 명시 적으로 비 결정적입니다. 스트림에서 요소를 자유롭게 선택할 수 있습니다. 이는 병렬 작업에서 최대 성능을 제공하기위한 것입니다. 비용은 동일한 소스에서 여러 번의 호출이 동일한 결과를 리턴하지 않을 수 있다는 것입니다. (안정적인 결과를 원하면 &lt;a href=&quot;intstream#findFirst--&quot;&gt; &lt;code&gt;findFirst()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="91343b7a97cce9e49bf7bfd43ef77ddc9e9de3c1" translate="yes" xml:space="preserve">
          <source>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use &lt;a href=&quot;longstream#findFirst--&quot;&gt;&lt;code&gt;findFirst()&lt;/code&gt;&lt;/a&gt; instead.)</source>
          <target state="translated">이 작업의 동작은 명시 적으로 비 결정적입니다. 스트림에서 요소를 자유롭게 선택할 수 있습니다. 이는 병렬 작업에서 최대 성능을 제공하기위한 것입니다. 비용은 동일한 소스에서 여러 번의 호출이 동일한 결과를 리턴하지 않을 수 있다는 것입니다. (안정적인 결과를 원하면 &lt;a href=&quot;longstream#findFirst--&quot;&gt; &lt;code&gt;findFirst()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="ac4f8664629b9c54913b4e09c46aa5ed184dae26" translate="yes" xml:space="preserve">
          <source>The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use &lt;a href=&quot;stream#findFirst--&quot;&gt;&lt;code&gt;findFirst()&lt;/code&gt;&lt;/a&gt; instead.)</source>
          <target state="translated">이 작업의 동작은 명시 적으로 비 결정적입니다. 스트림에서 요소를 자유롭게 선택할 수 있습니다. 이는 병렬 작업에서 최대 성능을 제공하기위한 것입니다. 비용은 동일한 소스에서 여러 번의 호출이 동일한 결과를 리턴하지 않을 수 있다는 것입니다. (안정적인 결과를 원하면 &lt;a href=&quot;stream#findFirst--&quot;&gt; &lt;code&gt;findFirst()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="de5bd53441d47c5af575e182bec3b83289b02191" translate="yes" xml:space="preserve">
          <source>The behavior of this socket option on a stream-oriented socket, or an &lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt;&lt;code&gt;IPv6&lt;/code&gt;&lt;/a&gt; socket, is not defined in this release.</source>
          <target state="translated">스트림 지향 소켓 또는 &lt;a href=&quot;standardprotocolfamily#INET6&quot;&gt; &lt;code&gt;IPv6&lt;/code&gt; &lt;/a&gt; 소켓 에서이 소켓 옵션의 동작은 이 릴리스에서 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1948fdb6e5f0e37d4d3127a1dee0880f5b26239c" translate="yes" xml:space="preserve">
          <source>The behavior when the URL path is neither empty nor a JNDI directory URL, or when the protocol is neither &lt;code&gt;rmi&lt;/code&gt; nor &lt;code&gt;iiop&lt;/code&gt;, is implementation defined, and may include throwing &lt;a href=&quot;../../../../java/net/malformedurlexception&quot;&gt;&lt;code&gt;MalformedURLException&lt;/code&gt;&lt;/a&gt; when the connector server is created or when it is started.</source>
          <target state="translated">URL 경로가 비어 있지 않거나 JNDI 디렉토리 URL이 아니 거나 프로토콜이 &lt;code&gt;rmi&lt;/code&gt; 또는 &lt;code&gt;iiop&lt;/code&gt; 가 아닌 경우 동작이 정의되어 있으며 커넥터 서버가 작성되거나 시작될 때 &lt;a href=&quot;../../../../java/net/malformedurlexception&quot;&gt; &lt;code&gt;MalformedURLException&lt;/code&gt; 이&lt;/a&gt; 발생하는 것을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21042f53373d478747862ca15394b0c027167712" translate="yes" xml:space="preserve">
          <source>The behavior when the URL path is neither empty nor a JNDI directory URL, or when the protocol is not &lt;code&gt;rmi&lt;/code&gt;, is implementation defined, and may include throwing &lt;a href=&quot;../../../../../java.base/java/net/malformedurlexception&quot;&gt;&lt;code&gt;MalformedURLException&lt;/code&gt;&lt;/a&gt; when the connector server is created or when it is started.</source>
          <target state="translated">URL 경로가 비어 있거나 JNDI 디렉토리 URL이 아니거나 프로토콜이 &lt;code&gt;rmi&lt;/code&gt; 가 아닌 경우의 동작 은 구현이 정의되어 있으며 커넥터 서버가 생성되거나 시작될 때 &lt;a href=&quot;../../../../../java.base/java/net/malformedurlexception&quot;&gt; &lt;code&gt;MalformedURLException&lt;/code&gt; &lt;/a&gt; 발생을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52bb3f58a08177a0b2dccbcfe8b7621c236f7348" translate="yes" xml:space="preserve">
          <source>The behavior when this method is called more than once is unspecified.</source>
          <target state="translated">이 메소드가 두 번 이상 호출 될 때의 동작은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4cfccd3b74eb932b400bc3a8fcf62cad9b1cdb7a" translate="yes" xml:space="preserve">
          <source>The behaviour when &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is enabled or disabled after a socket is bound (See &lt;a href=&quot;#isBound()&quot;&gt;&lt;code&gt;isBound()&lt;/code&gt;&lt;/a&gt;) is not defined.</source>
          <target state="translated">소켓이 바인드 된 후 &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt; 이 활성화되거나 비활성화 될 때의 동작 ( &lt;a href=&quot;#isBound()&quot;&gt; &lt;code&gt;isBound()&lt;/code&gt; &lt;/a&gt; 참조 )은 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="cc00fc99ac6d19fed1822d5b36037c02e19215d2" translate="yes" xml:space="preserve">
          <source>The behaviour when &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is enabled or disabled after a socket is bound (See &lt;a href=&quot;serversocket#isBound--&quot;&gt;&lt;code&gt;isBound()&lt;/code&gt;&lt;/a&gt;) is not defined.</source>
          <target state="translated">소켓이 바인드 된 후 &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt; 이 활성화 또는 비활성화 될 때의 동작 ( &lt;a href=&quot;serversocket#isBound--&quot;&gt; &lt;code&gt;isBound()&lt;/code&gt; &lt;/a&gt; 참조 )이 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="813b8a785ddc662d03b34c45ccd8c027a04fb706" translate="yes" xml:space="preserve">
          <source>The behaviour when &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt;&lt;code&gt;SO_REUSEADDR&lt;/code&gt;&lt;/a&gt; is enabled or disabled after a socket is bound (See &lt;a href=&quot;socket#isBound--&quot;&gt;&lt;code&gt;isBound()&lt;/code&gt;&lt;/a&gt;) is not defined.</source>
          <target state="translated">소켓이 바인드 된 후 &lt;a href=&quot;socketoptions#SO_REUSEADDR&quot;&gt; &lt;code&gt;SO_REUSEADDR&lt;/code&gt; &lt;/a&gt; 이 활성화 또는 비활성화 될 때의 동작 ( &lt;a href=&quot;socket#isBound--&quot;&gt; &lt;code&gt;isBound()&lt;/code&gt; &lt;/a&gt; 참조 )이 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ae128957d8bece3a0be0b88cce8ca92b62ee9079" translate="yes" xml:space="preserve">
          <source>The behaviour when &lt;code&gt;SO_REUSEADDR&lt;/code&gt; is enabled or disabled after a socket is bound (See &lt;a href=&quot;#isBound()&quot;&gt;&lt;code&gt;isBound()&lt;/code&gt;&lt;/a&gt;) is not defined.</source>
          <target state="translated">소켓이 바인드 된 후 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 이 활성화되거나 비활성화 될 때의 동작 ( &lt;a href=&quot;#isBound()&quot;&gt; &lt;code&gt;isBound()&lt;/code&gt; &lt;/a&gt; 참조 )은 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c3662286b844f4d43a48e82d7a61531172d3a7f6" translate="yes" xml:space="preserve">
          <source>The behaviour when &lt;code&gt;SO_REUSEADDR&lt;/code&gt; is enabled or disabled after a socket is bound (See &lt;a href=&quot;datagramsocket#isBound--&quot;&gt;&lt;code&gt;isBound()&lt;/code&gt;&lt;/a&gt;) is not defined.</source>
          <target state="translated">소켓이 바인드 된 후 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 이 활성화 또는 비활성화 될 때의 동작 ( &lt;a href=&quot;datagramsocket#isBound--&quot;&gt; &lt;code&gt;isBound()&lt;/code&gt; &lt;/a&gt; 참조 )이 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ec8605f5932b60aa18480347bbe8295238cc8d8d" translate="yes" xml:space="preserve">
          <source>The best algorithms for manipulating random access lists (such as &lt;code&gt;ArrayList&lt;/code&gt;) can produce quadratic behavior when applied to sequential access lists (such as &lt;code&gt;LinkedList&lt;/code&gt;). Generic list algorithms are encouraged to check whether the given list is an &lt;code&gt;instanceof&lt;/code&gt; this interface before applying an algorithm that would provide poor performance if it were applied to a sequential access list, and to alter their behavior if necessary to guarantee acceptable performance.</source>
          <target state="translated">임의 액세스 목록 (예 : &lt;code&gt;ArrayList&lt;/code&gt; ) 을 조작하기위한 최상의 알고리즘은 순차적 액세스 목록 (예 : &lt;code&gt;LinkedList&lt;/code&gt; )에 적용될 때 2 차 동작을 생성 할 수 있습니다 . 일반 목록 알고리즘은 순차 액세스 목록에 적용된 경우 성능이 저하되는 알고리즘을 적용하기 전에 주어진 목록 이이 인터페이스 의 &lt;code&gt;instanceof&lt;/code&gt; 인지 확인 하고 필요한 경우 허용 가능한 성능을 보장하기 위해 동작을 변경하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="aa63c846ce6c63983851d6cc1315cae60e071eef" translate="yes" xml:space="preserve">
          <source>The best value of &lt;code&gt;TASKS_PER_PHASER&lt;/code&gt; depends mainly on expected synchronization rates. A value as low as four may be appropriate for extremely small per-phase task bodies (thus high rates), or up to hundreds for extremely large ones.</source>
          <target state="translated">&lt;code&gt;TASKS_PER_PHASER&lt;/code&gt; 의 최상의 값은 주로 예상 동기화 속도에 따라 다릅니다. 매우 작은 단계별 작업 기관 (따라서 높은 비율)에는 최대 4 개의 값이, 매우 큰 작업 단위에는 최대 수백 개의 값이 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6f8f4e386a57e7108856d3ddc0667b1fe8fec3e" translate="yes" xml:space="preserve">
          <source>The bevel type.</source>
          <target state="translated">베벨 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e04209ad3d05621b8a42c0de27ff8910369553f0" translate="yes" xml:space="preserve">
          <source>The binding must be nonnull if the object existed after the change relative to the source context (&lt;code&gt;getEventContext()&lt;/code&gt;). That is, it must be nonnull for &lt;code&gt;OBJECT_ADDED&lt;/code&gt; and &lt;code&gt;OBJECT_CHANGED&lt;/code&gt;. For &lt;code&gt;OBJECT_RENAMED&lt;/code&gt;, it is null if the object after the rename is outside the scope for which the listener registered interest; it is nonnull if the object is inside the scope after the rename.</source>
          <target state="translated">소스 컨텍스트 ( &lt;code&gt;getEventContext()&lt;/code&gt; )를 기준으로 변경 한 후 오브젝트가 존재하면 바인딩은 널이 아니어야합니다 . 즉, &lt;code&gt;OBJECT_ADDED&lt;/code&gt; 및 &lt;code&gt;OBJECT_CHANGED&lt;/code&gt; 의 경우 널이 아니 어야합니다 . 들면 &lt;code&gt;OBJECT_RENAMED&lt;/code&gt; 바꾸기 후의 오브젝트 청취자가 관심을 등록하는 범위를 벗어나는 경우, 널 (null)이고; 이름을 바꾼 후 오브젝트가 범위 내에 있으면 널이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="47fe787308677096c8310117b4783e3ddb5d20ff" translate="yes" xml:space="preserve">
          <source>The binding must be nonnull if the object existed before the change relative to the source context (&lt;code&gt;getEventContext()&lt;/code&gt;). That is, it must be nonnull for &lt;code&gt;OBJECT_REMOVED&lt;/code&gt; and &lt;code&gt;OBJECT_CHANGED&lt;/code&gt;. For &lt;code&gt;OBJECT_RENAMED&lt;/code&gt;, it is null if the object before the rename is outside of the scope for which the listener has registered interest; it is nonnull if the object is inside the scope before the rename.</source>
          <target state="translated">소스 컨텍스트 ( &lt;code&gt;getEventContext()&lt;/code&gt; )를 기준으로 변경하기 전에 오브젝트가 존재하는 경우 바인딩은 널이 아니어야합니다 . 즉, &lt;code&gt;OBJECT_REMOVED&lt;/code&gt; 및 &lt;code&gt;OBJECT_CHANGED&lt;/code&gt; 의 경우 널이 아니 어야합니다 . 들면 &lt;code&gt;OBJECT_RENAMED&lt;/code&gt; 바꾸기 전에 개체가 등록 청취자가 관심을 가지고있는 범위 이외 인 경우, 널 (null)이고; 이름을 바꾸기 전에 개체가 범위 안에 있으면 null이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a540813c3623088162eddf8021387f816ab7189e" translate="yes" xml:space="preserve">
          <source>The binding of the changed object can be obtained using &lt;code&gt;evt.getNewBinding()&lt;/code&gt;. Its old binding (before the change) can be obtained using &lt;code&gt;evt.getOldBinding()&lt;/code&gt;.</source>
          <target state="translated">변경된 객체의 바인딩은 &lt;code&gt;evt.getNewBinding()&lt;/code&gt; 사용하여 얻을 수 있습니다 . 이전 바인딩 (변경 전)은 &lt;code&gt;evt.getOldBinding()&lt;/code&gt; 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00b0bb606f5c3ecd51111e3a9af417eb62109163" translate="yes" xml:space="preserve">
          <source>The binding of the newly added object can be obtained using &lt;code&gt;evt.getNewBinding()&lt;/code&gt;.</source>
          <target state="translated">새로 추가 된 객체의 바인딩은 &lt;code&gt;evt.getNewBinding()&lt;/code&gt; 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97025602c1b0354a00b10c74a226ea38edab7a3f" translate="yes" xml:space="preserve">
          <source>The binding of the newly removed object can be obtained using &lt;code&gt;evt.getOldBinding()&lt;/code&gt;.</source>
          <target state="translated">새로 제거 된 객체의 바인딩은 &lt;code&gt;evt.getOldBinding()&lt;/code&gt; 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db5d5c2755a2f75964c67f244f9ab71ecafaefa5" translate="yes" xml:space="preserve">
          <source>The binding of the renamed object can be obtained using &lt;code&gt;evt.getNewBinding()&lt;/code&gt;. Its old binding (before the rename) can be obtained using &lt;code&gt;evt.getOldBinding()&lt;/code&gt;. One of these may be null if the old/new binding was outside the scope in which the listener has registered interest.</source>
          <target state="translated">이름이 바뀐 오브젝트의 바인딩은 &lt;code&gt;evt.getNewBinding()&lt;/code&gt; 사용하여 얻을 수 있습니다 . 이전 바인딩 (이름 바꾸기 전)은 &lt;code&gt;evt.getOldBinding()&lt;/code&gt; 사용하여 얻을 수 있습니다 . 이전 / 새 바인딩이 리스너가 관심을 등록한 범위를 벗어난 경우 이들 중 하나가 널일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="079c4a4960105f0bcb70c588ac7cf3a47369d2d9" translate="yes" xml:space="preserve">
          <source>The bit initially has the value &lt;code&gt;false&lt;/code&gt;, and the corresponding bit in the argument has the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">비트의 초기 값은 &lt;code&gt;false&lt;/code&gt; 이며 인수의 해당 비트의 값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4610a19fe62a2028d5853d8b6146bdb1583011d" translate="yes" xml:space="preserve">
          <source>The bit initially has the value &lt;code&gt;true&lt;/code&gt;, and the corresponding bit in the argument has the value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">비트의 초기 값은 &lt;code&gt;true&lt;/code&gt; 이며 인수의 해당 비트의 값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff50d0696df1c1a5ec402d78f6f92cd39d7bbb84" translate="yes" xml:space="preserve">
          <source>The bit offset is reset to zero.</source>
          <target state="translated">비트 오프셋이 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a4f3cc1d878069548160bce5242336d5060d3770" translate="yes" xml:space="preserve">
          <source>The bit offset is set to 0 when a stream is first opened, and is reset to 0 by calls to &lt;code&gt;seek&lt;/code&gt;, &lt;code&gt;skipBytes&lt;/code&gt;, or any &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;readFully&lt;/code&gt; method.</source>
          <target state="translated">스트림을 처음 열면 비트 오프셋이 0으로 설정되고 &lt;code&gt;seek&lt;/code&gt; , &lt;code&gt;skipBytes&lt;/code&gt; 또는 &lt;code&gt;read&lt;/code&gt; 또는 &lt;code&gt;readFully&lt;/code&gt; 메소드 를 호출하여 0으로 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c6a80445d0b4a5f294f45e1bc9db4bc04950ba0" translate="yes" xml:space="preserve">
          <source>The bit offset within the stream is ignored and treated as though it were zero.</source>
          <target state="translated">스트림 내의 비트 오프셋은 무시되고 마치 0 인 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="60ed439e4fa50c248e920b1ada61a8fb85641cf5" translate="yes" xml:space="preserve">
          <source>The bit offset within the stream is reset to zero before the read occurs.</source>
          <target state="translated">스트림 내 비트 오프셋은 읽기가 발생하기 전에 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d25884e217e3d3f03765741523ec4f8df4d1e73e" translate="yes" xml:space="preserve">
          <source>The bit offset within the stream must be reset to zero before the read occurs.</source>
          <target state="translated">읽기가 발생하기 전에 스트림 내의 비트 오프셋을 0으로 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="392be8ef692e481c422de130596efeb38786c416" translate="yes" xml:space="preserve">
          <source>The bit position used by the &lt;code&gt;readBits&lt;/code&gt; method is saved and restored by each pair of calls to &lt;code&gt;mark&lt;/code&gt; and &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;readBits&lt;/code&gt; 메소드가 사용하는 비트 위치 는 각 호출 쌍에 의해 저장 및 복원되어 &lt;code&gt;mark&lt;/code&gt; 및 &lt;code&gt;reset&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f065f4500a0e2d19cc80a71c2e6f639ba72adc36" translate="yes" xml:space="preserve">
          <source>The bit relates to cell renderer changed property.</source>
          <target state="translated">비트는 셀 렌더러 변경된 속성과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="517b871d7f1cacbde8b4520a7110a596c84b5767" translate="yes" xml:space="preserve">
          <source>The bit relates to fixed cell height changed property.</source>
          <target state="translated">비트는 고정 셀 높이 변경 속성과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="51ead4a0c1c309a404567b4910fb436fdb9adda9" translate="yes" xml:space="preserve">
          <source>The bit relates to fixed cell width changed property.</source>
          <target state="translated">비트는 고정 셀 너비 변경 속성과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="905250a6bffe865c0181a3dcf009de269acaa0e3" translate="yes" xml:space="preserve">
          <source>The bit relates to font changed property.</source>
          <target state="translated">비트는 글꼴 변경 속성과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0fdf5cdf841fbdc77f739e0cf8f44357633d733" translate="yes" xml:space="preserve">
          <source>The bit relates to model changed property.</source>
          <target state="translated">비트는 모델 변경 속성과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2ba1fa565e81a183859cc0c055fac23ebd07954" translate="yes" xml:space="preserve">
          <source>The bit relates to prototype cell value changed property.</source>
          <target state="translated">비트는 프로토 타입 셀 값 변경 속성과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dd09d67266ea7e5152fe4bb698888335e7695f6" translate="yes" xml:space="preserve">
          <source>The bit relates to selection model changed property.</source>
          <target state="translated">비트는 선택 모델 변경 속성과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e616b2a044370cc64835bc4bb4e31fc5edbf070f" translate="yes" xml:space="preserve">
          <source>The bit set must remain constant during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined.</source>
          <target state="translated">터미널 스트림 작업을 실행하는 동안 비트 세트는 일정하게 유지되어야합니다. 그렇지 않으면 터미널 스트림 작업의 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ed6c3e459a64a5fa650f74fb463e334c284f228" translate="yes" xml:space="preserve">
          <source>The bitmask that indicates that a point lies above this &lt;code&gt;Rectangle2D&lt;/code&gt;.</source>
          <target state="translated">점이이 &lt;code&gt;Rectangle2D&lt;/code&gt; 위에 있음을 나타내는 비트 마스크입니다 .</target>
        </trans-unit>
        <trans-unit id="525dd7770bc211ebaf870daa92a3dfdba277e9ac" translate="yes" xml:space="preserve">
          <source>The bitmask that indicates that a point lies below this &lt;code&gt;Rectangle2D&lt;/code&gt;.</source>
          <target state="translated">점이이 &lt;code&gt;Rectangle2D&lt;/code&gt; 아래에 있음을 나타내는 비트 마스크입니다 .</target>
        </trans-unit>
        <trans-unit id="51c3e681a0408ee2d6a3956e4a45e34b88acbd59" translate="yes" xml:space="preserve">
          <source>The bitmask that indicates that a point lies to the left of this &lt;code&gt;Rectangle2D&lt;/code&gt;.</source>
          <target state="translated">점이이 &lt;code&gt;Rectangle2D&lt;/code&gt; 왼쪽에 있음을 나타내는 비트 마스크입니다 .</target>
        </trans-unit>
        <trans-unit id="cc76b4634b61a6ddc46b7878cc058711db293d91" translate="yes" xml:space="preserve">
          <source>The bitmask that indicates that a point lies to the right of this &lt;code&gt;Rectangle2D&lt;/code&gt;.</source>
          <target state="translated">점이이 &lt;code&gt;Rectangle2D&lt;/code&gt; 오른쪽에 있음을 나타내는 비트 마스크입니다 .</target>
        </trans-unit>
        <trans-unit id="40a18158059c50e97a80d7cded4b26a35829619e" translate="yes" xml:space="preserve">
          <source>The bitmask used to store the state of the button.</source>
          <target state="translated">버튼 상태를 저장하는 데 사용되는 비트 마스크입니다.</target>
        </trans-unit>
        <trans-unit id="08ac5f0c28c0fc877f224f69bf1274cdc2e32ae8" translate="yes" xml:space="preserve">
          <source>The block decrement adjustment type.</source>
          <target state="translated">블록 감소 조정 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ca440f22a5a9cd19a85c1fbb7925221a160e4d25" translate="yes" xml:space="preserve">
          <source>The block increment adjustment type.</source>
          <target state="translated">블록 증분 조정 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e09cad1c828643fa611127bbd432dc5a9c875056" translate="yes" xml:space="preserve">
          <source>The block increment is the value that is added or subtracted when the user activates the block increment area of the scroll bar, generally through a mouse or keyboard gesture that the scroll bar receives as an adjustment event. The block increment must be greater than zero.</source>
          <target state="translated">블록 증분은 일반적으로 스크롤 막대가 조정 이벤트로 수신하는 마우스 또는 키보드 제스처를 통해 사용자가 스크롤 막대의 블록 증분 영역을 활성화 할 때 더하거나 빼는 값입니다. 블록 증분은 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="773a4f0006dc919dc3a563e208b9c1d2e567273c" translate="yes" xml:space="preserve">
          <source>The block increment is the value that is added or subtracted when the user activates the block increment area of the scroll bar, generally through a mouse or keyboard gesture that the scroll bar receives as an adjustment event. The block increment must be greater than zero. Attempts to set the block increment to a value lower than 1 will result in a value of 1 being set.</source>
          <target state="translated">블록 증분은 일반적으로 스크롤 막대가 조정 이벤트로 수신하는 마우스 또는 키보드 제스처를 통해 사용자가 스크롤 막대의 블록 증분 영역을 활성화 할 때 더하거나 빼는 값입니다. 블록 증분은 0보다 커야합니다. 블록 증분을 1보다 낮은 값으로 설정하려고하면 값 1이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e21e431f736e80c157423cb9f9c120cb4852cdaa" translate="yes" xml:space="preserve">
          <source>The block names supported by &lt;code&gt;Pattern&lt;/code&gt; are the valid block names accepted and defined by &lt;a href=&quot;../../lang/character.unicodeblock#forName(java.lang.String)&quot;&gt;&lt;code&gt;UnicodeBlock.forName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 에서 지원하는 블록 이름은 &lt;a href=&quot;../../lang/character.unicodeblock#forName(java.lang.String)&quot;&gt; &lt;code&gt;UnicodeBlock.forName&lt;/code&gt; 에서&lt;/a&gt; 허용하고 정의한 유효한 블록 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="5cb03212f5537c4a0b8ecd683f1339aea4a69290" translate="yes" xml:space="preserve">
          <source>The block names supported by &lt;code&gt;Pattern&lt;/code&gt; are the valid block names accepted and defined by &lt;a href=&quot;../../lang/character.unicodeblock#forName-java.lang.String-&quot;&gt;&lt;code&gt;UnicodeBlock.forName&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Pattern&lt;/code&gt; 에서 지원하는 블록 이름은 &lt;a href=&quot;../../lang/character.unicodeblock#forName-java.lang.String-&quot;&gt; &lt;code&gt;UnicodeBlock.forName&lt;/code&gt; 에&lt;/a&gt; 의해 허용되고 정의 된 유효한 블록 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="3b2c63619faefbb7050698c0df35a5437ae2f8a1" translate="yes" xml:space="preserve">
          <source>The block of off-heap memory associated with the returned native memory segment is initialized to zero. Moreover, a client is responsible to call the &lt;a href=&quot;#close()&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; on a native memory segment, to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.</source>
          <target state="translated">리턴 된 원시 메모리 세그먼트와 연관된 힙 오프 메모리 블록은 0으로 초기화됩니다. 또한 클라이언트는 기본 메모리 세그먼트 에서 &lt;a href=&quot;#close()&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 백업 오프 힙 메모리 블록이 적절하게 할당 해제되도록해야합니다. 그렇지 않으면 힙이 아닌 메모리 누수가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c9151392927171f66644b3edff8dd9467431d179" translate="yes" xml:space="preserve">
          <source>The blocking-mode lock object</source>
          <target state="translated">차단 모드 잠금 객체</target>
        </trans-unit>
        <trans-unit id="b0ff8720d7de8db2a1e787173bbd032dae056cd2" translate="yes" xml:space="preserve">
          <source>The blue color component for the specified pixel, as an int.</source>
          <target state="translated">지정된 픽셀의 파란색 구성 요소 (int)입니다.</target>
        </trans-unit>
        <trans-unit id="c424f9ac5bce10e99f2c2880b959e00aa4b64679" translate="yes" xml:space="preserve">
          <source>The body of the default method is specified to be the code above.</source>
          <target state="translated">기본 메소드의 본문은 위의 코드로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="11a6748648cf5b00019dda6cf54e2eb8f3bf8d61" translate="yes" xml:space="preserve">
          <source>The body of the method or constructor declaration performs potentially unsafe operations, such as an assignment to an element of the variable arity parameter's array that generates an unchecked warning. Some unsafe operations do not trigger an unchecked warning. For example, the aliasing in</source>
          <target state="translated">메소드 또는 생성자 선언의 본문은 검사되지 않은 경고를 생성하는 변수 arity 매개 변수 배열의 요소에 대한 지정과 같이 잠재적으로 안전하지 않은 조작을 수행합니다. 일부 안전하지 않은 작업은 확인되지 않은 경고를 트리거하지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6ad923cbb344e2e5e611fd37a12eedc4c5f4a4e9" translate="yes" xml:space="preserve">
          <source>The body return type &lt;code&gt;V&lt;/code&gt;, if non-&lt;code&gt;void&lt;/code&gt;, determines the type of an additional state variable of the loop. The body must both accept a leading parameter and return a value of this type &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">본문 반환 유형 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;void&lt;/code&gt; 가 아닌 경우 루프의 추가 상태 변수 유형을 결정합니다. 본문은 선행 매개 변수를 허용하고이 유형의 값 &lt;code&gt;V&lt;/code&gt; 를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="05a04824adae3459a5749bc49bce848c38594456" translate="yes" xml:space="preserve">
          <source>The body return type &lt;code&gt;V&lt;/code&gt;, if non-&lt;code&gt;void&lt;/code&gt;, determines the type of an additional state variable of the loop. The body must both accept and return a value of this type &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">본문 반환 유형 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;void&lt;/code&gt; 가 아닌 경우 루프의 추가 상태 변수 유형을 결정합니다. 본문은 &lt;code&gt;V&lt;/code&gt; 유형의 값을 허용하고 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dc5cacddafbf4617cb6384dfa5cef5ad6f2c7e48" translate="yes" xml:space="preserve">
          <source>The bold action identifier</source>
          <target state="translated">굵은 작업 식별자</target>
        </trans-unit>
        <trans-unit id="cc34b91e6655b483b0c37fb242b5853482d9c7dc" translate="yes" xml:space="preserve">
          <source>The bold style constant.</source>
          <target state="translated">대담한 스타일 상수.</target>
        </trans-unit>
        <trans-unit id="45103bdc1a08a97e0e5d23fc553ce45c7d1a9686" translate="yes" xml:space="preserve">
          <source>The bold style constant. This can be combined with the other style constants (except PLAIN) for mixed styles.</source>
          <target state="translated">대담한 스타일 상수. 혼합 스타일의 경우 다른 스타일 상수 (PLAIN 제외)와 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c983fae9d373293fdb9dcc71dcb1886ffc8d3444" translate="yes" xml:space="preserve">
          <source>The boot layer</source>
          <target state="translated">부팅 계층</target>
        </trans-unit>
        <trans-unit id="b4e40444f8fc152eb16ab3eaf704c842ce4a6de9" translate="yes" xml:space="preserve">
          <source>The bootstrap method is invoked on at least three values:</source>
          <target state="translated">부트 스트랩 메소드는 최소한 세 개의 값에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9951d470ae0e4c4b7cfefa1e69971ec5f7c86a2d" translate="yes" xml:space="preserve">
          <source>The bootstrap method is then invoked, as if by &lt;a href=&quot;methodhandle#invoke(java.lang.Object...)&quot;&gt;&lt;code&gt;MethodHandle.invoke&lt;/code&gt;&lt;/a&gt;, with the following arguments:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;methodhandle#invoke(java.lang.Object...)&quot;&gt; &lt;code&gt;MethodHandle.invoke&lt;/code&gt; &lt;/a&gt; 에서처럼 다음 인수를 사용하여 부트 스트랩 메서드가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8adecc2101d7005121e4be92f59dfde092b68067" translate="yes" xml:space="preserve">
          <source>The bootstrap methods in this class will throw a &lt;code&gt;NullPointerException&lt;/code&gt; for any reference argument that is &lt;code&gt;null&lt;/code&gt;, unless the argument is specified to be unused or specified to accept a &lt;code&gt;null&lt;/code&gt; value.</source>
          <target state="translated">이 클래스의 부트 스트랩 메서드 는 인수가 사용되지 않도록 지정되거나 &lt;code&gt;null&lt;/code&gt; 값 을 허용하도록 지정되지 않는 한 &lt;code&gt;null&lt;/code&gt; 인 참조 인수에 대해 &lt;code&gt;NullPointerException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="17214954c4d069cd73851a29ded58baa4c28bfd7" translate="yes" xml:space="preserve">
          <source>The border insets.</source>
          <target state="translated">테두리가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="7f42745bac99508b34591e3dd40062b50391d75e" translate="yes" xml:space="preserve">
          <source>The border painter associated for the given state, or null if none could be found.</source>
          <target state="translated">주어진 상태와 관련된 테두리 페인터. 찾을 수없는 경우 null입니다.</target>
        </trans-unit>
        <trans-unit id="30781226a7a43d08fe81fa069815460c63b16d26" translate="yes" xml:space="preserve">
          <source>The border.</source>
          <target state="translated">국경.</target>
        </trans-unit>
        <trans-unit id="cfae179ea42664d99bcc9a1d13b597aac8360806" translate="yes" xml:space="preserve">
          <source>The bottom input tray in the printer.</source>
          <target state="translated">프린터의 하단 입력 용지함.</target>
        </trans-unit>
        <trans-unit id="d7d10d54e8a4f3158d26dcf8670aced46674b3f7" translate="yes" xml:space="preserve">
          <source>The bottom inset of the border.</source>
          <target state="translated">테두리의 하단 삽입.</target>
        </trans-unit>
        <trans-unit id="ce460ef4959b06b1d25e366288616b130e7eaec7" translate="yes" xml:space="preserve">
          <source>The bound property name for the focus accelerator.</source>
          <target state="translated">포커스 가속기의 바인딩 된 속성 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b8c68a2dc0225e92f68a9a3acbd002d846eea3db" translate="yes" xml:space="preserve">
          <source>The bounding box of the source &lt;code&gt;Image&lt;/code&gt; is transformed from user space into device space using the current &lt;code&gt;Transform&lt;/code&gt;. Note that the result of transforming the bounding box does not necessarily result in a rectangular region in device space.</source>
          <target state="translated">소스 &lt;code&gt;Image&lt;/code&gt; 의 경계 상자 는 현재 &lt;code&gt;Transform&lt;/code&gt; 을 사용하여 사용자 공간에서 장치 공간으로 변환 됩니다. 경계 상자를 변환 한 결과 반드시 ​​장치 공간의 직사각형 영역이되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6ce7dadffb10f6fef9c66938fc65a30ab5367cb0" translate="yes" xml:space="preserve">
          <source>The bounds is the smallest rectangle that completely contains the outline of the glyph. The bounds rectangle is relative to the glyph's origin. The left-side bearing is the distance from the glyph origin to the left of its bounds rectangle. If the left-side bearing is negative, part of the glyph is drawn to the left of its origin. The right-side bearing is the distance from the right side of the bounds rectangle to the next glyph origin (the origin plus the advance). If negative, part of the glyph is drawn to the right of the next glyph's origin. Note that the bounds does not necessarily enclose all the pixels affected when rendering the glyph, because of rasterization and pixel adjustment effects.</source>
          <target state="translated">경계는 글리프의 윤곽선을 완전히 포함하는 가장 작은 직사각형입니다. 경계 사각형은 글리프의 원점을 기준으로합니다. 왼쪽 방향 각은 글리프 원점에서 경계 직사각형의 왼쪽까지의 거리입니다. 왼쪽 방향 각이 음수이면 그림 문자의 일부가 원점 왼쪽에 그려집니다. 오른쪽 방향 각은 경계 사각형의 오른쪽에서 다음 글리프 원점 (원점 + 진행)까지의 거리입니다. 음수이면 글리프의 일부가 다음 글리프의 원점 오른쪽에 그려집니다. 래스터 화 및 픽셀 조정 효과로 인해 글리프를 렌더링 할 때 영향을받는 모든 픽셀이 경계에 반드시 포함되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="adc0456f9705ad31063dbf76bd8f9343136ad752" translate="yes" xml:space="preserve">
          <source>The bounds of this &lt;code&gt;Polygon&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Polygon&lt;/code&gt; 경계입니다 .</target>
        </trans-unit>
        <trans-unit id="8ae28136b7309fc0eb4097babab217f5419985e0" translate="yes" xml:space="preserve">
          <source>The bounds of this &lt;code&gt;Polygon&lt;/code&gt;. This value can be null.</source>
          <target state="translated">이 &lt;code&gt;Polygon&lt;/code&gt; 경계입니다 . 이 값은 널일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f35df29ba4c1a160c83b07bf44b764120a88cd3" translate="yes" xml:space="preserve">
          <source>The buffer is then cleared.</source>
          <target state="translated">그런 다음 버퍼가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="5267ec36b82dc0a5af7120233d80dbb488a5d391" translate="yes" xml:space="preserve">
          <source>The buffer of a tick.</source>
          <target state="translated">틱 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="0f3d2700605180a4ce193dca76f09b0360fed042" translate="yes" xml:space="preserve">
          <source>The buffer size is specified in bytes, but must represent an integral number of sample frames. Invoking this method with a requested buffer size that does not meet this requirement may result in an &lt;code&gt;IllegalArgumentException&lt;/code&gt;. The actual buffer size for the open line may differ from the requested buffer size. The value actually set may be queried by subsequently calling &lt;a href=&quot;dataline#getBufferSize()&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">버퍼 크기는 바이트 단위로 지정되지만 샘플 프레임의 정수를 나타내야합니다. 이 요구 사항을 충족하지 않는 요청 된 버퍼 크기로이 메서드를 호출하면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생할 수 있습니다 . 오픈 라인의 실제 버퍼 크기는 요청 된 버퍼 크기와 다를 수 있습니다. 실제로 설정된 값은 나중에 &lt;a href=&quot;dataline#getBufferSize()&quot;&gt; &lt;code&gt;DataLine.getBufferSize()&lt;/code&gt; &lt;/a&gt; 호출하여 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="076f9653bc023708e8c501870ffc3cb05502a95e" translate="yes" xml:space="preserve">
          <source>The buffer size is specified in bytes, but must represent an integral number of sample frames. Invoking this method with a requested buffer size that does not meet this requirement may result in an &lt;code&gt;IllegalArgumentException&lt;/code&gt;. The actual buffer size for the open line may differ from the requested buffer size. The value actually set may be queried by subsequently calling &lt;a href=&quot;dataline#getBufferSize()&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버퍼 크기는 바이트 단위로 지정되지만 샘플 프레임의 정수를 나타내야합니다. 이 요구 사항을 충족하지 않는 요청 된 버퍼 크기로이 메서드를 호출하면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생할 수 있습니다 . 오픈 라인의 실제 버퍼 크기는 요청 된 버퍼 크기와 다를 수 있습니다. 실제로 설정된 값은 나중에 &lt;a href=&quot;dataline#getBufferSize()&quot;&gt; &lt;code&gt;DataLine.getBufferSize()&lt;/code&gt; &lt;/a&gt; 호출하여 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="4670c8f1cdd40c40a543b1304e16c713499f0559" translate="yes" xml:space="preserve">
          <source>The buffer size is specified in bytes, but must represent an integral number of sample frames. Invoking this method with a requested buffer size that does not meet this requirement may result in an IllegalArgumentException. The actual buffer size for the open line may differ from the requested buffer size. The value actually set may be queried by subsequently calling &lt;code&gt;&lt;a href=&quot;dataline#getBufferSize--&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">버퍼 크기는 바이트 단위로 지정되지만 정수 샘플 프레임 수를 나타내야합니다. 이 요구 사항에 맞지 않는 요청 된 버퍼 크기로이 메소드를 호출하면 IllegalArgumentException이 발생할 수 있습니다. 열린 라인의 실제 버퍼 크기는 요청 된 버퍼 크기와 다를 수 있습니다. 이후에 &lt;code&gt;&lt;a href=&quot;dataline#getBufferSize--&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 호출하여 실제로 설정된 값을 조회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3a95695f406bd68814b7b0423d52d5848fcda1f" translate="yes" xml:space="preserve">
          <source>The buffer size is specified in bytes, but must represent an integral number of sample frames. Invoking this method with a requested buffer size that does not meet this requirement may result in an IllegalArgumentException. The actual buffer size for the open line may differ from the requested buffer size. The value actually set may be queried by subsequently calling &lt;code&gt;&lt;a href=&quot;dataline#getBufferSize--&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">버퍼 크기는 바이트 단위로 지정되지만 정수 샘플 프레임 수를 나타내야합니다. 이 요구 사항에 맞지 않는 요청 된 버퍼 크기로이 메소드를 호출하면 IllegalArgumentException이 발생할 수 있습니다. 열린 라인의 실제 버퍼 크기는 요청 된 버퍼 크기와 다를 수 있습니다. 실제로 설정된 값은 이후에 &lt;code&gt;&lt;a href=&quot;dataline#getBufferSize--&quot;&gt;&lt;code&gt;DataLine.getBufferSize()&lt;/code&gt;&lt;/a&gt;&lt;/code&gt; 호출하여 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="42d1dfe3731b63adb6323291fca8d27b9b77331b" translate="yes" xml:space="preserve">
          <source>The buffer size may be specified, or the default size may be accepted. The default is large enough for most purposes.</source>
          <target state="translated">버퍼 크기를 지정하거나 기본 크기를 사용할 수 있습니다. 대부분의 경우 기본값은 충분히 큽니다.</target>
        </trans-unit>
        <trans-unit id="8a55978bf856d3f06d55763ba0704c1f8c5f25a9" translate="yes" xml:space="preserve">
          <source>The buffer size may be specified, or the default size may be used. The default is large enough for most purposes.</source>
          <target state="translated">버퍼 크기를 지정하거나 기본 크기를 사용할 수 있습니다. 대부분의 경우 기본값은 충분히 큽니다.</target>
        </trans-unit>
        <trans-unit id="1c56115fb03b357a45a3b5437c42a2575ecdf670" translate="yes" xml:space="preserve">
          <source>The buffer where data is stored.</source>
          <target state="translated">데이터가 저장되는 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="054e837f56115320c3003e3d454659e29001c412" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">버퍼의 위치는 0이 아닌 복사 된 바이트 수로 설정되므로이 메소드를 호출 한 직후 다른 상대를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="188fa3815ba94bd3d52f1e5d7a2b576e266716ff" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of chars copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">버퍼의 위치는 0이 아닌 복사 된 문자 수로 설정되므로이 메소드를 호출 한 직후 다른 친척을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="268283661585dc5a43f5d101b5eb0cb7c4bd1ba0" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of doubles copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">버퍼의 위치는 0이 아닌 복사 된 복식 수로 설정되므로이 메소드를 호출 한 직후 다른 친척을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a818e9c80711ad62073fa38012777538062ecb70" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of floats copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">버퍼의 위치는 0이 아닌 복사 된 float 수로 설정되므로이 메소드를 호출 한 직후 다른 친척을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9ac4899062f4a8080e7bb42619ee1993a91107" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of ints copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">버퍼의 위치는 0이 아닌 복사 된 int 수로 설정되므로이 메소드를 호출 한 직후 다른 친척을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b0cc21acda56fdd53c62463623d224a17371a3" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of longs copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">버퍼의 위치는 0이 아닌 복사 된 long의 수로 설정되므로이 메소드를 호출 한 직후 다른 친척을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="750514a6ac223b844a07865b20d67f5ea7c24baf" translate="yes" xml:space="preserve">
          <source>The buffer's position is set to the number of shorts copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative</source>
          <target state="translated">버퍼의 위치는 0이 아닌 복사 된 반바지 수로 설정되므로이 메소드를 호출 한 직후 다른 친척을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ed8fbb1c3f820632b62e90292a556bfb0eaae47" translate="yes" xml:space="preserve">
          <source>The buffering capabilities</source>
          <target state="translated">버퍼링 기능</target>
        </trans-unit>
        <trans-unit id="a76b2857d5eedcf4fcf9af3ec043ce6700a4b3cb" translate="yes" xml:space="preserve">
          <source>The buffers are read from, and written to, starting at their current positions. At most &lt;a href=&quot;../buffer#remaining()&quot;&gt;&lt;code&gt;in.remaining()&lt;/code&gt;&lt;/a&gt; bytes will be read and at most &lt;a href=&quot;../buffer#remaining()&quot;&gt;&lt;code&gt;out.remaining()&lt;/code&gt;&lt;/a&gt; characters will be written. The buffers' positions will be advanced to reflect the bytes read and the characters written, but their marks and limits will not be modified.</source>
          <target state="translated">버퍼는 현재 위치에서 시작하여 읽고 씁니다. 기껏해야 &lt;a href=&quot;../buffer#remaining()&quot;&gt; &lt;code&gt;in.remaining()&lt;/code&gt; &lt;/a&gt; 바이트가 읽히고 기껏해야 &lt;a href=&quot;../buffer#remaining()&quot;&gt; &lt;code&gt;out.remaining()&lt;/code&gt; &lt;/a&gt; 문자가 기록됩니다. 버퍼의 위치는 읽은 바이트와 기록 된 문자를 반영하도록 진행되지만 해당 표시와 한계는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91ce3e07b95f497eca4ad27872d87d0b79957efb" translate="yes" xml:space="preserve">
          <source>The buffers are read from, and written to, starting at their current positions. At most &lt;a href=&quot;../buffer#remaining()&quot;&gt;&lt;code&gt;in.remaining()&lt;/code&gt;&lt;/a&gt; bytes will be read, and at most &lt;a href=&quot;../buffer#remaining()&quot;&gt;&lt;code&gt;out.remaining()&lt;/code&gt;&lt;/a&gt; characters will be written. The buffers' positions will be advanced to reflect the bytes read and the characters written, but their marks and limits will not be modified.</source>
          <target state="translated">버퍼는 현재 위치에서 시작하여 읽고 씁니다. 기껏해야 &lt;a href=&quot;../buffer#remaining()&quot;&gt; &lt;code&gt;in.remaining()&lt;/code&gt; &lt;/a&gt; 바이트가 읽히고 기껏해야 &lt;a href=&quot;../buffer#remaining()&quot;&gt; &lt;code&gt;out.remaining()&lt;/code&gt; &lt;/a&gt; 문자가 기록됩니다. 버퍼의 위치는 읽은 바이트와 기록 된 문자를 반영하도록 진행되지만 해당 표시와 한계는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c84073a1b40a0fce2b3b077f558986fbab072af3" translate="yes" xml:space="preserve">
          <source>The buffers are read from, and written to, starting at their current positions. At most &lt;a href=&quot;../buffer#remaining()&quot;&gt;&lt;code&gt;in.remaining()&lt;/code&gt;&lt;/a&gt; characters will be read and at most &lt;a href=&quot;../buffer#remaining()&quot;&gt;&lt;code&gt;out.remaining()&lt;/code&gt;&lt;/a&gt; bytes will be written. The buffers' positions will be advanced to reflect the characters read and the bytes written, but their marks and limits will not be modified.</source>
          <target state="translated">버퍼는 현재 위치에서 시작하여 읽고 씁니다. 최대 &lt;a href=&quot;../buffer#remaining()&quot;&gt; &lt;code&gt;in.remaining()&lt;/code&gt; &lt;/a&gt; 문자가 읽히고 최대 &lt;a href=&quot;../buffer#remaining()&quot;&gt; &lt;code&gt;out.remaining()&lt;/code&gt; &lt;/a&gt; 바이트가 기록됩니다. 버퍼의 위치는 읽은 문자와 쓴 바이트를 반영하도록 진행되지만 표시 및 제한은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8f9b4cf7ca1d13bbd7775f1178c68819ad41706" translate="yes" xml:space="preserve">
          <source>The buffers are read from, and written to, starting at their current positions. At most &lt;a href=&quot;../buffer#remaining()&quot;&gt;&lt;code&gt;in.remaining()&lt;/code&gt;&lt;/a&gt; characters will be read, and at most &lt;a href=&quot;../buffer#remaining()&quot;&gt;&lt;code&gt;out.remaining()&lt;/code&gt;&lt;/a&gt; bytes will be written. The buffers' positions will be advanced to reflect the characters read and the bytes written, but their marks and limits will not be modified.</source>
          <target state="translated">버퍼는 현재 위치에서 시작하여 읽고 씁니다. 기껏해야 &lt;a href=&quot;../buffer#remaining()&quot;&gt; &lt;code&gt;in.remaining()&lt;/code&gt; &lt;/a&gt; 문자가 읽히고 기껏해야 &lt;a href=&quot;../buffer#remaining()&quot;&gt; &lt;code&gt;out.remaining()&lt;/code&gt; &lt;/a&gt; 바이트가 기록됩니다. 버퍼의 위치는 읽은 문자와 쓴 바이트를 반영하도록 진행되지만 표시 및 제한은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="293bbf9dbaac98ff56c4b3e964c2a85c882bdba5" translate="yes" xml:space="preserve">
          <source>The buffers are read from, and written to, starting at their current positions. At most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;in.remaining()&lt;/code&gt;&lt;/a&gt; bytes will be read and at most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;out.remaining()&lt;/code&gt;&lt;/a&gt; characters will be written. The buffers' positions will be advanced to reflect the bytes read and the characters written, but their marks and limits will not be modified.</source>
          <target state="translated">현재 위치에서 시작하여 버퍼를 읽고 씁니다. 최대 &lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;in.remaining()&lt;/code&gt; &lt;/a&gt; 바이트를 읽고 최대 &lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;out.remaining()&lt;/code&gt; &lt;/a&gt; 문자를 씁니다 . 버퍼의 위치는 읽은 바이트와 문자를 반영하기 위해 진행되지만 마크 및 한계는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63913af10c4a2a952523c8a79b63028c30d3d4bb" translate="yes" xml:space="preserve">
          <source>The buffers are read from, and written to, starting at their current positions. At most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;in.remaining()&lt;/code&gt;&lt;/a&gt; bytes will be read, and at most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;out.remaining()&lt;/code&gt;&lt;/a&gt; characters will be written. The buffers' positions will be advanced to reflect the bytes read and the characters written, but their marks and limits will not be modified.</source>
          <target state="translated">현재 위치에서 시작하여 버퍼를 읽고 씁니다. 최대 &lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;in.remaining()&lt;/code&gt; &lt;/a&gt; 바이트를 읽고 최대 &lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;out.remaining()&lt;/code&gt; &lt;/a&gt; 문자를 씁니다 . 버퍼의 위치는 읽은 바이트와 문자를 반영하기 위해 진행되지만 마크 및 한계는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ea75e8b0576a0fab591f0e6c8cfa51a7d1af8b0" translate="yes" xml:space="preserve">
          <source>The buffers are read from, and written to, starting at their current positions. At most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;in.remaining()&lt;/code&gt;&lt;/a&gt; characters will be read and at most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;out.remaining()&lt;/code&gt;&lt;/a&gt; bytes will be written. The buffers' positions will be advanced to reflect the characters read and the bytes written, but their marks and limits will not be modified.</source>
          <target state="translated">현재 위치에서 시작하여 버퍼를 읽고 씁니다. 최대 &lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;in.remaining()&lt;/code&gt; &lt;/a&gt; 문자를 읽고 최대 &lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;out.remaining()&lt;/code&gt; &lt;/a&gt; 바이트를 씁니다 . 버퍼의 위치는 읽은 문자와 쓴 바이트 수를 반영하여 향상되지만 해당 표시와 한계는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7363ecd6d3a0468acc64ed1a76fb03af75bdb558" translate="yes" xml:space="preserve">
          <source>The buffers are read from, and written to, starting at their current positions. At most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;in.remaining()&lt;/code&gt;&lt;/a&gt; characters will be read, and at most &lt;a href=&quot;../buffer#remaining--&quot;&gt;&lt;code&gt;out.remaining()&lt;/code&gt;&lt;/a&gt; bytes will be written. The buffers' positions will be advanced to reflect the characters read and the bytes written, but their marks and limits will not be modified.</source>
          <target state="translated">현재 위치에서 시작하여 버퍼를 읽고 씁니다. 최대 &lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;in.remaining()&lt;/code&gt; &lt;/a&gt; 문자를 읽고 최대 &lt;a href=&quot;../buffer#remaining--&quot;&gt; &lt;code&gt;out.remaining()&lt;/code&gt; &lt;/a&gt; 바이트를 씁니다 . 버퍼의 위치는 읽은 문자와 쓴 바이트 수를 반영하여 향상되지만 해당 표시와 한계는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2c2fc65dcd0260a84a04aee6cff1e866cb1bcaf" translate="yes" xml:space="preserve">
          <source>The builder can be configured and the start can have arguments:</source>
          <target state="translated">빌더를 구성 할 수 있으며 시작은 인수를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0005a7a0f59c8f93ffbf86aec3e2386f246f3c0c" translate="yes" xml:space="preserve">
          <source>The builder can be used to configure per-request state, such as: the request URI, the request method (default is GET unless explicitly set), specific request headers, etc. Each of the setter methods modifies the state of the builder and returns the same instance. The methods are not synchronized and should not be called from multiple threads without external synchronization. The &lt;a href=&quot;#build()&quot;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/a&gt; method returns a new &lt;code&gt;HttpRequest&lt;/code&gt; each time it is invoked. Once built an &lt;code&gt;
 HttpRequest&lt;/code&gt; is immutable, and can be sent multiple times.</source>
          <target state="translated">빌더는 요청 URI, 요청 메소드 (명시 적으로 설정되지 않은 경우 기본값은 GET 임), 특정 요청 헤더 등과 같은 요청 별 상태를 구성하는 데 사용할 수 있습니다. 각 setter 메소드는 빌더의 상태를 수정하고 리턴합니다. 동일한 인스턴스. 메서드는 동기화되지 않으며 외부 동기화없이 여러 스레드에서 호출하면 안됩니다. &lt;a href=&quot;#build()&quot;&gt; &lt;code&gt;build&lt;/code&gt; &lt;/a&gt; 방법은 새 반환 &lt;code&gt;HttpRequest&lt;/code&gt; 를 가 호출 될 때마다. 일단 빌드되면 &lt;code&gt; HttpRequest&lt;/code&gt; 는 변경할 수 없으며 여러 번 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d6d45090b38927980128fdfc30c28845132395a" translate="yes" xml:space="preserve">
          <source>The builder can only be installed if the executing thread is allowed (by the security manager's checkSetFactory() method) to do so. Once installed, the builder cannot be replaced.</source>
          <target state="translated">빌더는 실행중인 스레드가 보안 관리자의 checkSetFactory () 메소드에 의해 허용 된 경우에만 설치할 수 있습니다. 일단 설치되면 빌더를 교체 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="94162d4cf2c341f565021f495ec547084eb7ab50" translate="yes" xml:space="preserve">
          <source>The builder can only be installed if the executing thread is allowed by the security manager to do so. Once installed, the builder cannot be replaced.</source>
          <target state="translated">보안 관리자가 실행 스레드를 허용 한 경우에만 빌더를 설치할 수 있습니다. 일단 설치되면 빌더를 교체 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0b725d5619c0e7bf77c36fba4cad953f5d80cf9" translate="yes" xml:space="preserve">
          <source>The builder for an automatic module cannot be used to declare module or service dependences. It also cannot be used to declare any exported or open packages.</source>
          <target state="translated">자동 모듈의 빌더는 모듈 또는 서비스 종속성을 선언하는 데 사용할 수 없습니다. 또한 내보내거나 열려있는 패키지를 선언하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="554f54568793972ed2310419c981d6a0e3bc6753" translate="yes" xml:space="preserve">
          <source>The builder for an open module cannot be used to declare any open packages.</source>
          <target state="translated">열린 모듈의 빌더는 열린 패키지를 선언하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="be760ed8b2889bc581b1bef89b9c8cbf61fdd1a7" translate="yes" xml:space="preserve">
          <source>The built object</source>
          <target state="translated">빌드 된 개체</target>
        </trans-unit>
        <trans-unit id="e343b27a869a5ecde5a06f223584b48609e88448" translate="yes" xml:space="preserve">
          <source>The built-in linear gray scale color space.</source>
          <target state="translated">내장 된 선형 회색조 색 공간.</target>
        </trans-unit>
        <trans-unit id="37a2c933f4668392796de54b4c2a00c581a9b6b0" translate="yes" xml:space="preserve">
          <source>The bulk read operations &lt;a href=&quot;reader#read(char%5B%5D)&quot;&gt;&lt;code&gt;read(char[]) &lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reader#read(char%5B%5D,int,int)&quot;&gt;&lt;code&gt;read(char[], int, int) &lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reader#read(java.nio.CharBuffer)&quot;&gt;&lt;code&gt;read(java.nio.CharBuffer)&lt;/code&gt;&lt;/a&gt; on the returned object will not read in characters beyond the line bound for each invocation, even if the destination buffer has space for more characters. The &lt;code&gt;Reader&lt;/code&gt;'s &lt;code&gt;read&lt;/code&gt; methods may block if a line bound has not been entered or reached on the console's input device. A line bound is considered to be any one of a line feed (&lt;code&gt;'\n'&lt;/code&gt;), a carriage return (&lt;code&gt;'\r'&lt;/code&gt;), a carriage return followed immediately by a linefeed, or an end of stream.</source>
          <target state="translated">반환 된 객체에 대한 대량 읽기 작업 &lt;a href=&quot;reader#read(char%5B%5D)&quot;&gt; &lt;code&gt;read(char[]) &lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reader#read(char%5B%5D,int,int)&quot;&gt; &lt;code&gt;read(char[], int, int) &lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;reader#read(java.nio.CharBuffer)&quot;&gt; &lt;code&gt;read(java.nio.CharBuffer)&lt;/code&gt; &lt;/a&gt; 는 각 호출에 대해 바인딩 된 줄을 초과하는 문자를 읽지 않습니다. 대상 버퍼에 더 많은 문자를위한 공간이 있습니다. &lt;code&gt;Reader&lt;/code&gt; 의 &lt;code&gt;read&lt;/code&gt; 행 라인 입력 또는 콘솔의 입력 장치에 도달하지 않은 경우, 방법은 블록있다. 줄 바운딩은 줄 바꿈 ( &lt;code&gt;'\n'&lt;/code&gt; ), 캐리지 리턴 ( &lt;code&gt;'\r'&lt;/code&gt; ), 캐리지 리턴 바로 다음에 줄 바꿈 또는 스트림의 끝 중 하나로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="57bc2cca5ed13a9fc84b6171112f0807ef63a7e4" translate="yes" xml:space="preserve">
          <source>The bulk read operations &lt;a href=&quot;reader#read-char:A-&quot;&gt;&lt;code&gt;read(char[]) &lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reader#read-char:A-int-int-&quot;&gt;&lt;code&gt;read(char[], int, int) &lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reader#read-java.nio.CharBuffer-&quot;&gt;&lt;code&gt;read(java.nio.CharBuffer)&lt;/code&gt;&lt;/a&gt; on the returned object will not read in characters beyond the line bound for each invocation, even if the destination buffer has space for more characters. The &lt;code&gt;Reader&lt;/code&gt;'s &lt;code&gt;read&lt;/code&gt; methods may block if a line bound has not been entered or reached on the console's input device. A line bound is considered to be any one of a line feed (&lt;code&gt;'\n'&lt;/code&gt;), a carriage return (&lt;code&gt;'\r'&lt;/code&gt;), a carriage return followed immediately by a linefeed, or an end of stream.</source>
          <target state="translated">리턴 된 오브젝트 의 벌크 읽기 조작 &lt;a href=&quot;reader#read-char:A-&quot;&gt; &lt;code&gt;read(char[]) &lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reader#read-char:A-int-int-&quot;&gt; &lt;code&gt;read(char[], int, int) &lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;reader#read-java.nio.CharBuffer-&quot;&gt; &lt;code&gt;read(java.nio.CharBuffer)&lt;/code&gt; &lt;/a&gt; 는 각 호출에 대해 바인드 된 행 이후의 문자를 읽지 않습니다. 대상 버퍼에는 더 많은 문자를위한 공간이 있습니다. &lt;code&gt;Reader&lt;/code&gt; 의 &lt;code&gt;read&lt;/code&gt; 행 라인 입력 또는 콘솔의 입력 장치에 도달하지 않은 경우, 방법은 블록있다. 줄 바인은 줄 바꿈 ( &lt;code&gt;'\n'&lt;/code&gt; ), 캐리지 리턴 ( &lt;code&gt;'\r'&lt;/code&gt; ), 캐리지 리턴 바로 다음에 줄 바꿈 또는 스트림 끝 중 하나로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="067475d20de825eccf0c1e0b6c1755d01e4ad9ae" translate="yes" xml:space="preserve">
          <source>The bundle name is obtained by calling &lt;a href=&quot;#toBundleName(java.lang.String,java.util.Locale)&quot;&gt;&lt;code&gt;toBundleName(baseName,
 locale)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">번들 이름은 &lt;a href=&quot;#toBundleName(java.lang.String,java.util.Locale)&quot;&gt; &lt;code&gt;toBundleName(baseName, locale)&lt;/code&gt; &lt;/a&gt; 을 호출하여 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="4906528df4e968c4a2fd97b5d59c3f8587333b5e" translate="yes" xml:space="preserve">
          <source>The bundle name is obtained by calling &lt;a href=&quot;resourcebundle.control#toBundleName-java.lang.String-java.util.Locale-&quot;&gt;&lt;code&gt;toBundleName(baseName,
 locale)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">번들 이름은 &lt;a href=&quot;resourcebundle.control#toBundleName-java.lang.String-java.util.Locale-&quot;&gt; &lt;code&gt;toBundleName(baseName, locale)&lt;/code&gt; &lt;/a&gt; 을 호출하여 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="86425cf46dc2c1b45f5201ffd34e95808bf62687" translate="yes" xml:space="preserve">
          <source>The button group that the button belongs to.</source>
          <target state="translated">버튼이 속한 버튼 그룹입니다.</target>
        </trans-unit>
        <trans-unit id="8b1ee1070dd15797865cb3a4bd40925d1f17dcdd" translate="yes" xml:space="preserve">
          <source>The button labeled &lt;code&gt;one&lt;/code&gt; is in the &quot;on&quot; state, and the other two are in the &quot;off&quot; state. In this example, which uses the &lt;code&gt;GridLayout&lt;/code&gt; class, the states of the three check boxes are set independently.</source>
          <target state="translated">버튼 레이블 &lt;code&gt;one&lt;/code&gt; 를 &quot;ON&quot;상태이고, 다른 두 사람은 &quot;OFF&quot;상태에 있습니다. &lt;code&gt;GridLayout&lt;/code&gt; 클래스 를 사용하는이 예제에서는 세 개의 확인란 상태가 독립적으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="af0776528051c36883f5d4ccad77bb0a6703bfbb" translate="yes" xml:space="preserve">
          <source>The button model's &lt;code&gt;ActionListener&lt;/code&gt;.</source>
          <target state="translated">버튼 모델의 &lt;code&gt;ActionListener&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45d7f0bc0500e1df69a9f509abae765e43298e8c" translate="yes" xml:space="preserve">
          <source>The button model's &lt;code&gt;ItemListener&lt;/code&gt;.</source>
          <target state="translated">버튼 모델의 &lt;code&gt;ItemListener&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c908cac20b61837bb8aede2a0023cc05a8749c3" translate="yes" xml:space="preserve">
          <source>The button model's &lt;code&gt;changeListener&lt;/code&gt;.</source>
          <target state="translated">버튼 모델의 &lt;code&gt;changeListener&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f845bf91f6f3cd8bc66ff8b453ed6b8a5158316" translate="yes" xml:space="preserve">
          <source>The button that gets activated when the pane has the focus and a UI-specific action like pressing the &lt;b&gt;Enter&lt;/b&gt; key occurs.</source>
          <target state="translated">창에 포커스가있을 때 활성화되는 버튼과 &lt;b&gt;Enter&lt;/b&gt; 키를 누르는 것과 같은 UI 관련 작업 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3f92842ca5ff5e5cc61ba710720f050663b78c8e" translate="yes" xml:space="preserve">
          <source>The button's mnemonic.</source>
          <target state="translated">버튼의 니모닉입니다.</target>
        </trans-unit>
        <trans-unit id="c1634abc23996fb99c8c020f9a51cad91db9b9e6" translate="yes" xml:space="preserve">
          <source>The byte array provided to this method should be laid out as per the &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jdwp/jdwp-spec.html&quot;&gt; JDWP specification&lt;/a&gt;. That is, all fields in the packet are in big endian order. The first byte, that is element &lt;code&gt;pkt[0]&lt;/code&gt;, is the first byte of the &lt;code&gt;length&lt;/code&gt; field. &lt;code&gt;pkt[1]&lt;/code&gt; is the second byte of the &lt;code&gt;length&lt;/code&gt; field, and so on.</source>
          <target state="translated">이 메소드에 제공되는 바이트 배열은 &lt;a href=&quot;https://docs.oracle.com/en/java/javase/15/docs/specs/jdwp/jdwp-spec.html&quot;&gt;JDWP 사양에&lt;/a&gt; 따라 배치되어야합니다 . 즉, 패킷의 모든 필드는 빅 엔디안 순서입니다. 첫 번째 바이트, 즉 요소 &lt;code&gt;pkt[0]&lt;/code&gt; 은 &lt;code&gt;length&lt;/code&gt; 필드 의 첫 번째 바이트입니다 . &lt;code&gt;pkt[1]&lt;/code&gt; 은 &lt;code&gt;length&lt;/code&gt; 필드 의 두 번째 바이트입니다 .</target>
        </trans-unit>
        <trans-unit id="a4a52b4593f9a8a8dd2e70ebe00138c0d2b17c41" translate="yes" xml:space="preserve">
          <source>The byte array referenced by an &lt;code&gt;IIOByteBuffer&lt;/code&gt; will generally be part of an internal data structure belonging to an &lt;code&gt;ImageReader&lt;/code&gt; implementation; its contents should be considered read-only and must not be modified.</source>
          <target state="translated">&lt;code&gt;IIOByteBuffer&lt;/code&gt; 가 참조하는 바이트 배열 은 일반적으로 &lt;code&gt;ImageReader&lt;/code&gt; 구현에 속하는 내부 데이터 구조의 일부입니다 . 내용은 읽기 전용으로 간주되어야하며 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1355d05c2748f9dfcf75dbdc8ead75958008b92d" translate="yes" xml:space="preserve">
          <source>The byte at the buffer's current position</source>
          <target state="translated">버퍼의 현재 위치의 바이트</target>
        </trans-unit>
        <trans-unit id="47ca471c96d31b5f0031a2837a68bf4083a1dc36" translate="yes" xml:space="preserve">
          <source>The byte at the given index</source>
          <target state="translated">주어진 인덱스의 바이트</target>
        </trans-unit>
        <trans-unit id="deb4c87efe1222286df56bf2a615595a08fdcbc1" translate="yes" xml:space="preserve">
          <source>The byte buffer is not modified by this method, and no reference to the buffer is retained by the bit set.</source>
          <target state="translated">바이트 버퍼는이 방법으로 수정되지 않으며 비트 세트에 의해 버퍼에 대한 참조가 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63a728366ae9c365dd8b934a38844c6d8865bed5" translate="yes" xml:space="preserve">
          <source>The byte offset into the input source this locator is pointing to or &lt;code&gt;-1&lt;/code&gt; if there is no byte offset available.</source>
          <target state="translated">이 로케이터가 가리키는 입력 소스에 대한 바이트 오프셋 또는 사용 가능한 바이트 오프셋이없는 경우 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1ccd18330dd5450f1b6655054edb6878c9c12957" translate="yes" xml:space="preserve">
          <source>The byte order has no effect on the results returned from the &lt;code&gt;readBits&lt;/code&gt; method (or the value written by &lt;code&gt;ImageOutputStream.writeBits&lt;/code&gt;).</source>
          <target state="translated">바이트 순서는 &lt;code&gt;readBits&lt;/code&gt; 메소드 에서 리턴 된 결과 (또는 &lt;code&gt;ImageOutputStream.writeBits&lt;/code&gt; 에 의해 작성된 값) 에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="14aafe7666eb5797f1333016b720d9c302895a7b" translate="yes" xml:space="preserve">
          <source>The byte order is used when reading or writing multibyte values, and when creating buffers that are views of this byte buffer. The order of a newly-created byte buffer is always &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt;&lt;code&gt;BIG_ENDIAN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">바이트 순서는 멀티 바이트 값을 읽거나 쓸 때와이 바이트 버퍼의 뷰인 버퍼를 만들 때 사용됩니다. 새로 작성된 바이트 버퍼의 순서는 항상 &lt;a href=&quot;byteorder#BIG_ENDIAN&quot;&gt; &lt;code&gt;BIG_ENDIAN&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4cc5ed997e081b7b31bde626bd68b9254ed59d17" translate="yes" xml:space="preserve">
          <source>The byte order of a char buffer created by allocation or by wrapping an existing &lt;code&gt;char&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a char buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">할당 또는 기존 &lt;code&gt;char&lt;/code&gt; 배열 을 래핑하여 생성 된 char 버퍼의 바이트 순서 는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 입니다. 바이트 버퍼의 &lt;a href=&quot;bytebuffer#views&quot;&gt;뷰로&lt;/a&gt; 생성 된 char 버퍼의 바이트 순서 는 뷰가 생성되는 순간의 바이트 버퍼의 순서입니다.</target>
        </trans-unit>
        <trans-unit id="9cc687ee55e65629bf7cb07b117a3609d5c3c138" translate="yes" xml:space="preserve">
          <source>The byte order of a char buffer created by allocation or by wrapping an existing &lt;code&gt;char&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a char buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">할당 또는 기존 &lt;code&gt;char&lt;/code&gt; 배열 을 래핑하여 생성 된 문자 버퍼의 바이트 순서 는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 입니다. 바이트 버퍼의 &lt;a href=&quot;bytebuffer#views&quot;&gt;뷰로&lt;/a&gt; 생성 된 char 버퍼의 바이트 순서 는 뷰가 생성되는 순간의 바이트 버퍼 의 바이트 순서입니다 .</target>
        </trans-unit>
        <trans-unit id="ad07033ac4a28f23e49c92546714e0062d88b9e4" translate="yes" xml:space="preserve">
          <source>The byte order of a double buffer created by allocation or by wrapping an existing &lt;code&gt;double&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a double buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">할당 또는 기존 &lt;code&gt;double&lt;/code&gt; 배열 을 래핑하여 만든 이중 버퍼의 바이트 순서 는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 입니다. 바이트 버퍼의 &lt;a href=&quot;bytebuffer#views&quot;&gt;뷰로&lt;/a&gt; 생성 된 이중 버퍼의 바이트 순서 는 뷰가 생성되는 순간의 바이트 버퍼의 순서입니다.</target>
        </trans-unit>
        <trans-unit id="0b6816216a3e49126f17437c6afe4b84167bb241" translate="yes" xml:space="preserve">
          <source>The byte order of a double buffer created by allocation or by wrapping an existing &lt;code&gt;double&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a double buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">할당 또는 기존 &lt;code&gt;double&lt;/code&gt; 배열 을 래핑하여 생성 된 이중 버퍼의 바이트 순서 는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 입니다. 바이트 버퍼의 &lt;a href=&quot;bytebuffer#views&quot;&gt;뷰로&lt;/a&gt; 생성 된 더블 버퍼의 바이트 순서 는 뷰가 생성되는 순간의 바이트 버퍼 의 바이트 순서입니다 .</target>
        </trans-unit>
        <trans-unit id="445cfe173d2d37f4d0540ab4f09eb151d40dd663" translate="yes" xml:space="preserve">
          <source>The byte order of a float buffer created by allocation or by wrapping an existing &lt;code&gt;float&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a float buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">할당 또는 기존 &lt;code&gt;float&lt;/code&gt; 배열 을 래핑하여 생성 된 부동 버퍼의 바이트 순서 는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 입니다. 바이트 버퍼의 &lt;a href=&quot;bytebuffer#views&quot;&gt;뷰로&lt;/a&gt; 생성 된 부동 버퍼의 바이트 순서 는 뷰가 생성되는 순간의 바이트 버퍼의 순서입니다.</target>
        </trans-unit>
        <trans-unit id="44939b5e6d7ee751fc60184ae79f1bdd2b79b9e1" translate="yes" xml:space="preserve">
          <source>The byte order of a float buffer created by allocation or by wrapping an existing &lt;code&gt;float&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a float buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">할당 또는 기존 &lt;code&gt;float&lt;/code&gt; 배열 을 래핑하여 생성 된 float 버퍼의 바이트 순서 는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 입니다. 바이트 버퍼의 &lt;a href=&quot;bytebuffer#views&quot;&gt;뷰로&lt;/a&gt; 생성 된 부동 버퍼의 바이트 순서 는 뷰가 생성되는 순간의 바이트 버퍼 의 바이트 순서입니다 .</target>
        </trans-unit>
        <trans-unit id="d9bf87c99b3482a165d5f42fc45d647f23c42549" translate="yes" xml:space="preserve">
          <source>The byte order of a long buffer created by allocation or by wrapping an existing &lt;code&gt;long&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a long buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">할당 또는 기존 &lt;code&gt;long&lt;/code&gt; 배열 을 래핑하여 생성 된 긴 버퍼의 바이트 순서 는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 입니다. 바이트 버퍼의 &lt;a href=&quot;bytebuffer#views&quot;&gt;뷰로&lt;/a&gt; 생성 된 롱 버퍼의 바이트 순서 는 뷰가 생성 된 순간의 바이트 버퍼의 순서입니다.</target>
        </trans-unit>
        <trans-unit id="e097a7b495f686009fc938ec60647ad742832ccc" translate="yes" xml:space="preserve">
          <source>The byte order of a long buffer created by allocation or by wrapping an existing &lt;code&gt;long&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a long buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">할당 또는 기존 &lt;code&gt;long&lt;/code&gt; 배열 을 래핑하여 생성 된 긴 버퍼의 바이트 순서 는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder--&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 입니다. 바이트 버퍼의 &lt;a href=&quot;bytebuffer#views&quot;&gt;뷰로&lt;/a&gt; 생성 된 긴 버퍼의 바이트 순서 는 뷰가 생성되는 순간의 바이트 버퍼 의 바이트 순서입니다 .</target>
        </trans-unit>
        <trans-unit id="e14d106f129af656c0cc5ea2e08517556d02b5e1" translate="yes" xml:space="preserve">
          <source>The byte order of a short buffer created by allocation or by wrapping an existing &lt;code&gt;short&lt;/code&gt; array is the &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt;&lt;code&gt;native order&lt;/code&gt;&lt;/a&gt; of the underlying hardware. The byte order of a short buffer created as a &lt;a href=&quot;bytebuffer#views&quot;&gt;view&lt;/a&gt; of a byte buffer is that of the byte buffer at the moment that the view is created.</source>
          <target state="translated">할당 또는 기존 &lt;code&gt;short&lt;/code&gt; 배열 을 래핑하여 만든 짧은 버퍼의 바이트 순서 는 기본 하드웨어 의 &lt;a href=&quot;byteorder#nativeOrder()&quot;&gt; &lt;code&gt;native order&lt;/code&gt; &lt;/a&gt; 입니다. 바이트 버퍼의 &lt;a href=&quot;bytebuffer#views&quot;&gt;뷰로&lt;/a&gt; 생성 된 쇼트 버퍼의 바이트 순서 는 뷰가 생성되는 순간의 바이트 버퍼의 순서입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
