<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="fish">
    <body>
      <group id="fish">
        <trans-unit id="eb050233a037dea5009df6afea79c6a67545439a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math $status - 128&lt;/code&gt; outputs the numerical exit status of the last command minus 128.</source>
          <target state="translated">&lt;code&gt;math $status - 128&lt;/code&gt; 은 마지막 명령 빼기 128의 숫자 종료 상태를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="62f5bddd60dd031bee23091b7071808993dd4f83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math -s0 10.0 / 6.0&lt;/code&gt; outputs &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;math -s0 10.0 / 6.0&lt;/code&gt; 출력 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee576ca1237b790b579b57a522ac77fdfe4dace9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math -s3 10 / 6&lt;/code&gt; outputs &lt;code&gt;1.666&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;math -s3 10 / 6&lt;/code&gt; &lt;code&gt;1.666&lt;/code&gt; 출력 1.666 .</target>
        </trans-unit>
        <trans-unit id="2afd4d22ab4aec5b0acabaa13fdb5dab928d4b72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math 0xFF&lt;/code&gt; outputs 255, &lt;code&gt;math 0 x 3&lt;/code&gt; outputs 0 (because it computes 0 multiplied by 3).</source>
          <target state="translated">&lt;code&gt;math 0xFF&lt;/code&gt; 는 255를 출력하고 &lt;code&gt;math 0 x 3&lt;/code&gt; 은 0을 출력합니다 (0에 3을 곱한 값을 계산하기 때문).</target>
        </trans-unit>
        <trans-unit id="81cc154eafffdbcc1fc0bc775abc9037a8ee7f57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math 1+1&lt;/code&gt; outputs 2.</source>
          <target state="translated">&lt;code&gt;math 1+1&lt;/code&gt; 출력 2.</target>
        </trans-unit>
        <trans-unit id="0b9bceb25a6bea3bf050d266eb2dabb87359d38c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math 10 / 6&lt;/code&gt; outputs &lt;code&gt;1.666667&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;math 10 / 6&lt;/code&gt; &lt;code&gt;1.666667&lt;/code&gt; 출력 1.666667 .</target>
        </trans-unit>
        <trans-unit id="0506f0b9975fb7a5dac75392d203b4e4d03c48aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math 5 \* 2&lt;/code&gt; or &lt;code&gt;math &quot;5 * 2&quot;&lt;/code&gt; or &lt;code&gt;math 5 &quot;*&quot; 2&lt;/code&gt; all output &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;math 5 \* 2&lt;/code&gt; 또는 &lt;code&gt;math &quot;5 * 2&quot;&lt;/code&gt; 또는 &lt;code&gt;math 5 &quot;*&quot; 2&lt;/code&gt; 모두 &lt;code&gt;10&lt;/code&gt; 을 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="ac2f6b46e44457ebc6c17a24cac39023b91980ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math&lt;/code&gt; ignores whitespace between arguments and takes its input as multiple arguments (internally joined with a space), so &lt;code&gt;math 2 +2&lt;/code&gt; and &lt;code&gt;math &quot;2 +    2&quot;&lt;/code&gt; work the same. &lt;code&gt;math 2 2&lt;/code&gt; is an error.</source>
          <target state="translated">&lt;code&gt;math&lt;/code&gt; 는 인수 사이의 공백을 무시하고 입력을 여러 인수 (내부적으로 공백으로 결합)로 사용하므로 &lt;code&gt;math 2 +2&lt;/code&gt; 와 &lt;code&gt;math &quot;2 + 2&quot;&lt;/code&gt; 는 동일하게 작동합니다. &lt;code&gt;math 2 2&lt;/code&gt; 는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="5cfe1d0b897a4b186b164463b5e374849fe22e37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math&lt;/code&gt; ignores whitespace between arguments and takes its input as multiple arguments (internally joined with a space), so &lt;code&gt;math 2 +2&lt;/code&gt; and &lt;code&gt;math &quot;2 +&amp;nbsp;&amp;nbsp;&amp;nbsp; 2&quot;&lt;/code&gt; work the same. &lt;code&gt;math 2 2&lt;/code&gt; is an error.</source>
          <target state="translated">&lt;code&gt;math&lt;/code&gt; 는 인수 사이의 공백을 무시하고 입력을 여러 인수 (내부적으로 공백으로 결합)로 취하므로 &lt;code&gt;math 2 +2&lt;/code&gt; 와 &lt;code&gt;math &quot;2 +&amp;nbsp;&amp;nbsp;&amp;nbsp; 2&quot;&lt;/code&gt; 가 동일하게 작동합니다. &lt;code&gt;math 2 2&lt;/code&gt; 는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="9ba0660e6966691b91248fb2bd5f96aab0fbeb26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math&lt;/code&gt; is used to perform mathematical calculations. It supports all the usual operations such as addition, subtraction, etc. As well as functions like &lt;code&gt;abs()&lt;/code&gt;, &lt;code&gt;sqrt()&lt;/code&gt; and &lt;code&gt;log2()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;math&lt;/code&gt; 은 수학 계산을 수행하는 데 사용됩니다. &lt;code&gt;abs()&lt;/code&gt; , &lt;code&gt;sqrt()&lt;/code&gt; 및 &lt;code&gt;log2()&lt;/code&gt; 와 같은 함수뿐만 아니라 더하기, 빼기 등과 같은 모든 일반적인 작업을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="f0c967cc75c19f494f0c88a7accc5d3cf4435577" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math&lt;/code&gt; knows some operators, constants, functions and can (obviously) read numbers.</source>
          <target state="translated">&lt;code&gt;math&lt;/code&gt; 은 일부 연산자, 상수, 함수를 알고 있으며 숫자를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be9c5baace2aafc6d8913dc0e713e617b094c022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math&lt;/code&gt; knows the following constants:</source>
          <target state="translated">&lt;code&gt;math&lt;/code&gt; 은 다음 상수를 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="54b59170a6a2d63ae4126c98f35573504c3fe866" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math&lt;/code&gt; knows the following operators:</source>
          <target state="translated">&lt;code&gt;math&lt;/code&gt; 은 다음 연산자를 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="009be72b39b76a473ac24d04bf2afb4a541294d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math&lt;/code&gt; supports the following functions:</source>
          <target state="translated">&lt;code&gt;math&lt;/code&gt; 은 다음 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="be1434f80555c9e72306465d0deaafae514e79ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; immediately incorporates history changes from other sessions. Ordinarily &lt;code&gt;fish&lt;/code&gt; ignores history changes from sessions started after the current one. This command applies those changes immediately.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 즉시 다른 세션의 기록 변경 사항을 통합합니다. 일반적으로 &lt;code&gt;fish&lt;/code&gt; 는 현재 세션 이후에 시작된 세션의 기록 변경을 무시합니다. 이 명령은 이러한 변경 사항을 즉시 적용합니다.</target>
        </trans-unit>
        <trans-unit id="774a283e059b420761769f3fd4e58b1c4617fff8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mv&lt;/code&gt;, move (rename) files</source>
          <target state="translated">&lt;code&gt;mv&lt;/code&gt; , 파일 이동 (이름 바꾸기)</target>
        </trans-unit>
        <trans-unit id="d5068ef44383529da8a297fad4521ff3def0b93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n#max&lt;/code&gt; means that flags matching the regex &quot;^--?d+$&quot; are valid. When seen they are assigned to the variables &lt;code&gt;_flag_n&lt;/code&gt; and &lt;code&gt;_flag_max&lt;/code&gt;. This allows any valid positive or negative integer to be specified by prefixing it with a single &quot;-&quot;. Many commands support this idiom. For example &lt;code&gt;head -3 /a/file&lt;/code&gt; to emit only the first three lines of /a/file. You can also specify the value using either flag: &lt;code&gt;-n NNN&lt;/code&gt; or &lt;code&gt;--max NNN&lt;/code&gt; in this example.</source>
          <target state="translated">&lt;code&gt;n#max&lt;/code&gt; 는 정규식 &quot;^-? d + $&quot;와 일치하는 플래그가 유효 함을 의미합니다. 볼 때 변수 &lt;code&gt;_flag_n&lt;/code&gt; 및 &lt;code&gt;_flag_max&lt;/code&gt; 에 할당됩니다 . 이것은 하나의 &quot;-&quot;를 접두사로 붙여서 유효한 양 또는 음의 정수를 지정할 수 있도록합니다. 많은 명령이이 관용구를 지원합니다. 예를 들어 &lt;code&gt;head -3 /a/file&lt;/code&gt; 은 / a / file 의 처음 세 줄만 내 보냅니다. 이 예에서는 &lt;code&gt;-n NNN&lt;/code&gt; 또는 &lt;code&gt;--max NNN&lt;/code&gt; 플래그를 사용하여 값을 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7023e674591c966dcf0f86a6fe75236339070f1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n-name=+&lt;/code&gt; means that only &lt;code&gt;--name&lt;/code&gt; is valid. It requires a value and can be used more than once. If the flag is seen then &lt;code&gt;_flag_n&lt;/code&gt; and &lt;code&gt;_flag_name&lt;/code&gt; will be set with the values associated with each occurrence of the flag.</source>
          <target state="translated">&lt;code&gt;n-name=+&lt;/code&gt; 는 &lt;code&gt;--name&lt;/code&gt; 만 유효 함을 의미 합니다. 값이 필요하며 두 번 이상 사용할 수 있습니다. 플래그가 표시되면 &lt;code&gt;_flag_n&lt;/code&gt; 및 &lt;code&gt;_flag_name&lt;/code&gt; 은 플래그의 각 발생과 연관된 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="10c98ccb9e926b5c88017fefb6f1a99d034b3aee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n/name=&lt;/code&gt; means that both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;--name&lt;/code&gt; are valid. It requires a value and can be used at most once. If the flag is seen then &lt;code&gt;_flag_n&lt;/code&gt; and &lt;code&gt;_flag_name&lt;/code&gt; will be set with the single mandatory value associated with the flag.</source>
          <target state="translated">&lt;code&gt;n/name=&lt;/code&gt; 은 &lt;code&gt;-n&lt;/code&gt; 과 &lt;code&gt;--name&lt;/code&gt; 이 모두 유효 함을 의미 합니다. 값이 필요하며 최대 한 번 사용할 수 있습니다. 플래그가 표시되면 &lt;code&gt;_flag_n&lt;/code&gt; 및 &lt;code&gt;_flag_name&lt;/code&gt; 이 플래그와 연관된 단일 필수 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="11979a51fb38eb5d6b66a5b8c9d7f5b86329e977" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n/name=?&lt;/code&gt; means that both &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;--name&lt;/code&gt; are valid. It accepts an optional value and can be used at most once. If the flag is seen then &lt;code&gt;_flag_n&lt;/code&gt; and &lt;code&gt;_flag_name&lt;/code&gt; will be set with the value associated with the flag if one was provided else it will be set with no values.</source>
          <target state="translated">&lt;code&gt;n/name=?&lt;/code&gt; &lt;code&gt;-n&lt;/code&gt; 과 &lt;code&gt;--name&lt;/code&gt; 이 모두 유효 함을 의미 합니다. 선택적 값을 허용하며 최대 한 번 사용할 수 있습니다. 플래그가 표시되면 &lt;code&gt;_flag_n&lt;/code&gt; 및 &lt;code&gt;_flag_name&lt;/code&gt; 은 플래그가 제공된 경우 플래그와 연관된 값으로 설정되며, 그렇지 않은 경우 값이 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a3aaaa7ebe33bd42f7c7723f56bc9270c4a585f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n::max&lt;/code&gt; means that flags matching the regex &quot;^--?\d+$&quot; are valid. When seen they are assigned to the variables &lt;code&gt;_flag_n&lt;/code&gt; and &lt;code&gt;_flag_max&lt;/code&gt;. This allows any valid positive or negative integer to be specified by prefixing it with a single &quot;-&quot;. Many commands support this idiom. For example &lt;code&gt;head -3 /a/file&lt;/code&gt; to emit only the first three lines of /a/file. You can also specify the value using either flag: &lt;code&gt;-n NNN&lt;/code&gt; or &lt;code&gt;--max NNN&lt;/code&gt; in this example.</source>
          <target state="translated">&lt;code&gt;n::max&lt;/code&gt; 는 정규식 &quot;^-? \ d + $&quot;와 일치하는 플래그가 유효 함을 의미합니다. 보았을 때 변수 &lt;code&gt;_flag_n&lt;/code&gt; 및 &lt;code&gt;_flag_max&lt;/code&gt; 에 할당되었습니다 . 이를 통해 단일 &quot;-&quot;접두어를 사용하여 유효한 양수 또는 음수를 지정할 수 있습니다. 많은 명령이이 관용구를 지원합니다. 예를 들어 &lt;code&gt;head -3 /a/file&lt;/code&gt; 은 / a / file 의 처음 세 줄만 내 보냅니다. 이 예에서 플래그 &lt;code&gt;-n NNN&lt;/code&gt; 또는 &lt;code&gt;--max NNN&lt;/code&gt; 을 사용하여 값을 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18757061001b09cf2873d7ed5d548b11e41c7525" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nextd&lt;/code&gt; moves forwards &lt;code&gt;POS&lt;/code&gt; positions in the history of visited directories; if the end of the history has been hit, a warning is printed.</source>
          <target state="translated">&lt;code&gt;nextd&lt;/code&gt; 는 방문한 디렉토리 기록에서 &lt;code&gt;POS&lt;/code&gt; 위치를 앞으로 이동 시킵니다 . 히스토리의 끝에 도달하면 경고가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="cea306a2ee9cfb2d8fb7788331bf26c28447c7f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not&lt;/code&gt; negates the exit status of another command. If the exit status is zero, &lt;code&gt;not&lt;/code&gt; returns 1. Otherwise, &lt;code&gt;not&lt;/code&gt; returns 0.</source>
          <target state="translated">&lt;code&gt;not&lt;/code&gt; 다른 명령의 종료 상태를 무효화 하지 않습니다 . 종료 상태가 제로의 경우, &lt;code&gt;not&lt;/code&gt; 1. 그렇지 않으면 반환 &lt;code&gt;not&lt;/code&gt; 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="db48abf0126ad617f48775398922a0b4b30d0bc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open *.txt&lt;/code&gt; opens all the text files in the current directory using your system's default text editor.</source>
          <target state="translated">&lt;code&gt;open *.txt&lt;/code&gt; 는 시스템의 기본 텍스트 편집기를 사용하여 현재 디렉토리의 모든 텍스트 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="e94f06b97a3cfcb7ec8a4770650b1e748f69af17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open&lt;/code&gt; opens a file in its default application, using the appropriate tool for the operating system. On GNU/Linux, this requires the common but optional &lt;code&gt;xdg-open&lt;/code&gt; utility, from the &lt;code&gt;xdg-utils&lt;/code&gt; package.</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 은 운영 체제에 적합한 도구를 사용하여 기본 응용 프로그램에서 파일을 엽니 다. GNU / Linux에서는 &lt;code&gt;xdg-utils&lt;/code&gt; 패키지 의 일반적이지만 선택적인 &lt;code&gt;xdg-open&lt;/code&gt; 유틸리티 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="23eeee895599e5eae80cda23801496141175086a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open&lt;/code&gt;, open files with the default application associated with each filetype</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 각 파일 형식과 관련된 기본 응용 프로그램과 함께, 열려있는 파일</target>
        </trans-unit>
        <trans-unit id="6f86ac0554f4a4cf4f28495788244852b2e6599f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;or&lt;/code&gt; does not change the current exit status itself, but the command it runs most likely will. The exit status of the last foreground command to exit can always be accessed using the &lt;a href=&quot;../index#variables-status&quot;&gt;$status&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; 현재 종료 상태 자체를 변경하지 않지만 실행되는 명령은 대부분 변경됩니다. 종료 할 마지막 포 그라운드 명령의 종료 상태는 항상 &lt;a href=&quot;../index#variables-status&quot;&gt;$ status&lt;/a&gt; 변수를 사용하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dac5a9585518dd59c14ca7616fb90e727007732e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;or&lt;/code&gt; does not change the current exit status itself, but the command it runs most likely will. The exit status of the last foreground command to exit can always be accessed using the &lt;a href=&quot;index#variables-status&quot;&gt;$status&lt;/a&gt; variable.</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; 현재 종료 상태 자체를 변경하지는 않지만 가장 많이 실행되는 명령이 작동합니다. 종료 할 마지막 포 그라운드 명령의 종료 상태는 항상 &lt;a href=&quot;index#variables-status&quot;&gt;$ status&lt;/a&gt; 변수를 사용하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="011af2ca1a12c1a3f3a067f4ab735209202aafb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;or&lt;/code&gt; is used to execute a command if the previous command was not successful (returned a status of something other than 0).</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; 이전 명령이 성공적이지 않은 경우 명령을 실행하는 데 사용됩니다 (0 이외의 상태를 반환 함).</target>
        </trans-unit>
        <trans-unit id="afa6b74bd124cb8b57c3d66b4c7a1084e37218d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;or&lt;/code&gt; statements may be used as part of the condition in an &lt;a href=&quot;#if&quot;&gt;&lt;code&gt;and&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#while&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; block. See the documentation for &lt;a href=&quot;#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#while&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; for examples.</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; 문은 &lt;a href=&quot;#if&quot;&gt; &lt;code&gt;and&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#while&quot;&gt; &lt;code&gt;while&lt;/code&gt; &lt;/a&gt; 블록 에서 조건의 일부로 사용될 수 있습니다 . &lt;a href=&quot;#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#while&quot;&gt; &lt;code&gt;while&lt;/code&gt; &lt;/a&gt; 문서 는 예제 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c73d73d5ebdf318201e26c0530d1eeb58fc2ce6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;or&lt;/code&gt; statements may be used as part of the condition in an &lt;a href=&quot;if#cmd-if&quot;&gt;and&lt;/a&gt; or &lt;a href=&quot;while#cmd-while&quot;&gt;while&lt;/a&gt; block.</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; 문은 &lt;a href=&quot;if#cmd-if&quot;&gt;and&lt;/a&gt; 또는 &lt;a href=&quot;while#cmd-while&quot;&gt;while&lt;/a&gt; 블록 에서 조건의 일부로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f200b52a1765aa96f91d9512533bf90cd4d3e3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pager-toggle-search&lt;/code&gt;, toggles the search field if the completions pager is visible.</source>
          <target state="translated">&lt;code&gt;pager-toggle-search&lt;/code&gt; , 완료 페이저가 표시되면 검색 필드를 토글합니다.</target>
        </trans-unit>
        <trans-unit id="93e6cd2cf57f32f0f1074687103ba4dd1420c892" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pi&lt;/code&gt; - You know that one. Half of Tau. (Tau is not implemented)</source>
          <target state="translated">&lt;code&gt;pi&lt;/code&gt; - 당신은 저것을 알고 있습니다. 타우의 절반. (타우 구현되지 않음)</target>
        </trans-unit>
        <trans-unit id="0f446d5ed35eb5048e4c7f001b1f27dc9402116e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pipestatus&lt;/code&gt;, a list of exit statuses of all processes that made up the last executed pipe.</source>
          <target state="translated">&lt;code&gt;pipestatus&lt;/code&gt; , 마지막으로 실행 된 파이프를 구성한 모든 프로세스의 종료 상태 목록입니다.</target>
        </trans-unit>
        <trans-unit id="91f28400f6533478b46d55c90e3c872cc0eaea4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;popd&lt;/code&gt; removes the top directory from the directory stack and changes the working directory to the new top directory. Use &lt;a href=&quot;#pushd&quot;&gt;&lt;code&gt;pushd&lt;/code&gt;&lt;/a&gt; to add directories to the stack.</source>
          <target state="translated">&lt;code&gt;popd&lt;/code&gt; 는 디렉토리 스택에서 최상위 디렉토리를 제거하고 작업 디렉토리를 새 최상위 디렉토리로 변경합니다. &lt;a href=&quot;#pushd&quot;&gt; &lt;code&gt;pushd&lt;/code&gt; &lt;/a&gt; 를 사용 하여 스택에 디렉토리를 추가 하십시오 .</target>
        </trans-unit>
        <trans-unit id="67a047b7a48542b870bd5211e515649aee68917e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;popd&lt;/code&gt; removes the top directory from the directory stack and changes the working directory to the new top directory. Use &lt;a href=&quot;pushd#cmd-pushd&quot;&gt;pushd&lt;/a&gt; to add directories to the stack or &lt;a href=&quot;dirs#cmd-dirs&quot;&gt;dirs&lt;/a&gt; to print it.</source>
          <target state="translated">&lt;code&gt;popd&lt;/code&gt; 는 디렉토리 스택에서 최상위 디렉토리를 제거하고 작업 디렉토리를 새 최상위 디렉토리로 변경합니다. 사용 &lt;a href=&quot;pushd#cmd-pushd&quot;&gt;PUSHD를&lt;/a&gt; 스택이나 디렉토리를 추가 할 &lt;a href=&quot;dirs#cmd-dirs&quot;&gt;DIRS&lt;/a&gt; 를 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c23cde6c68fbe655e308c020e25d49d09dd62da1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(x,y)&lt;/code&gt; returns x to the y (and can be written as &lt;code&gt;x ^ y&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pow(x,y)&lt;/code&gt; 는 x를 y에 반환합니다 ( &lt;code&gt;x ^ y&lt;/code&gt; 로 쓸 수 있음 )</target>
        </trans-unit>
        <trans-unit id="287de450b9e0483d85e25a5a84e5f182194a1456" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prevd&lt;/code&gt; moves backwards &lt;code&gt;POS&lt;/code&gt; positions in the history of visited directories; if the beginning of the history has been hit, a warning is printed.</source>
          <target state="translated">&lt;code&gt;prevd&lt;/code&gt; 는 방문한 디렉토리 기록에서 &lt;code&gt;POS&lt;/code&gt; 위치를 뒤로 이동합니다 . 히스토리의 시작 부분에 도달하면 경고가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="758894fa9ac3dcdc16edfc52096829dc60931b04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prompt_pwd&lt;/code&gt; is a function to print the current working directory in a way suitable for prompts. It will replace the home directory with &quot;~&quot; and shorten every path component but the last to a default of one character.</source>
          <target state="translated">&lt;code&gt;prompt_pwd&lt;/code&gt; 는 프롬프트에 적합한 방식으로 현재 작업 디렉토리를 인쇄하는 함수입니다. 홈 디렉토리를 &quot;~&quot;로 바꾸고 모든 경로 구성 요소를 줄이지 만 마지막은 기본값 인 한 문자로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="e5c43c64e240d0f4ae1a99ca5c42cd0423139bc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pushd +NUMBER&lt;/code&gt; rotates the stack counter-clockwise i.e. from bottom to top</source>
          <target state="translated">&lt;code&gt;pushd +NUMBER&lt;/code&gt; 누르면 스택이 시계 반대 방향으로 회전합니다. 즉, 아래에서 위로</target>
        </trans-unit>
        <trans-unit id="6ba679406b42673c5180f9bba2472c6204d8f0cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pushd -NUMBER&lt;/code&gt; rotates clockwise i.e. top to bottom.</source>
          <target state="translated">&lt;code&gt;pushd -NUMBER&lt;/code&gt; 시계 방향으로 (예 : 위에서 아래로) 회전합니다.</target>
        </trans-unit>
        <trans-unit id="d9173c9010853802ba5c4a311f821ba14078009e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pwd&lt;/code&gt; outputs (prints) the current working directory.</source>
          <target state="translated">&lt;code&gt;pwd&lt;/code&gt; 는 현재 작업 디렉토리를 출력 (인쇄)합니다.</target>
        </trans-unit>
        <trans-unit id="72ec7167859aebdbfb7c4a4a7e1050eee5ed4896" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read&lt;/code&gt; reads from standard input and either writes the result back to standard output (for use in command substitution), or stores the result in one or more shell variables. By default, &lt;code&gt;read&lt;/code&gt; reads a single line and splits it into variables on spaces or tabs. Alternatively, a null character or a maximum number of characters can be used to terminate the input, and other delimiters can be given. Unlike other shells, there is no default variable (such as &lt;code&gt;REPLY&lt;/code&gt;) for storing the result - instead, it is printed on standard output.</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; 표준 입력에서 읽고 결과를 표준 출력에 다시 쓰거나 (명령 대체에 사용) 하나 이상의 쉘 변수에 결과를 저장합니다. 기본적으로 &lt;code&gt;read&lt;/code&gt; 는 단일 행을 읽고 공백 또는 탭의 변수로 분할합니다. 또는 널 문자 또는 최대 문자 수를 사용하여 입력을 종료하고 다른 구분 기호를 지정할 수 있습니다. 다른 쉘과 달리 결과를 저장하기위한 기본 변수 (예 : &lt;code&gt;REPLY&lt;/code&gt; ) 는 없습니다. 대신 표준 출력에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="581f42e718d0bcfbf0164027aaefb2e2e09daff6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;realpath&lt;/code&gt; resolves a path to its absolute path.</source>
          <target state="translated">&lt;code&gt;realpath&lt;/code&gt; 는 절대 경로에 대한 경로를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="35bd00f382e8670d7d44d2b40cf3fca33494e874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repaint-mode&lt;/code&gt; reexecutes the fish_mode_prompt function and redraws the prompt. This is useful for vi-mode. If no fish_mode_prompt exists, it acts like a normal repaint.</source>
          <target state="translated">&lt;code&gt;repaint-mode&lt;/code&gt; 는 fish_mode_prompt 함수를 다시 실행하고 프롬프트를 다시 그립니다. 이것은 vi-mode에 유용합니다. fish_mode_prompt가 존재하지 않으면 일반적인 다시 그리기처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8af37077a702119f1289199205be5c8570e1f654" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repaint&lt;/code&gt; reexecutes the prompt functions and redraws the prompt. Multiple successive repaints are coalesced.</source>
          <target state="translated">&lt;code&gt;repaint&lt;/code&gt; 는 프롬프트 기능을 다시 실행하고 프롬프트를 다시 그립니다. 여러 번의 연속 다시 그리기가 합쳐집니다.</target>
        </trans-unit>
        <trans-unit id="ff49b83e64396ed910787499c3a6a700a00c3e74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repeat-jump&lt;/code&gt; and &lt;code&gt;repeat-jump-reverse&lt;/code&gt;, redo the last jump in the same/opposite direction</source>
          <target state="translated">&lt;code&gt;repeat-jump&lt;/code&gt; 및 &lt;code&gt;repeat-jump-reverse&lt;/code&gt; , 동일한 / 반대 방향으로 마지막 점프를 다시 실행</target>
        </trans-unit>
        <trans-unit id="4b249dc97dd0ed2d7efc75e8750d13ccd586b86f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; halts a currently running function. The exit status is set to &lt;code&gt;STATUS&lt;/code&gt; if it is given.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; 은 현재 실행중인 기능을 중지합니다. 종료 상태가 제공되면 &lt;code&gt;STATUS&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2dff648efb696543bf4783ef158dc6faac05096b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round&lt;/code&gt; - rounds to the nearest integer, away from 0</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; -0에서 가장 가까운 정수로 반올림</target>
        </trans-unit>
        <trans-unit id="9ae815b29923bb2081652f0d74075b638b35e307" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save&lt;/code&gt; immediately writes all changes to the history file. The shell automatically saves the history file; this option is provided for internal use and should not normally need to be used by the user.</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; 즉시 모든 변경 사항을 기록 파일에 씁니다. 쉘은 자동으로 히스토리 파일을 저장합니다. 이 옵션은 내부 용으로 제공되며 일반적으로 사용자가 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9cbc63b923d6e80c08215a900beb75279f6f039" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scope-shadowing&lt;/code&gt; if the function shadows the vars in the calling function (the normal case if it wasn't defined with &lt;code&gt;--no-scope-shadowing&lt;/code&gt;), else &lt;code&gt;no-scope-shadowing&lt;/code&gt;, or &lt;code&gt;n/a&lt;/code&gt; if the function isn't defined,</source>
          <target state="translated">&lt;code&gt;scope-shadowing&lt;/code&gt; 함수가 호출 함수에서 var를 음영 처리하는 경우 scope-shadowing ( &lt;code&gt;--no-scope-shadowing&lt;/code&gt; 으로 정의되지 않은 경우 일반적인 경우 ), 그렇지 않으면 &lt;code&gt;no-scope-shadowing&lt;/code&gt; 또는 함수가 아닌 경우 &lt;code&gt;n/a&lt;/code&gt; 한정된,</target>
        </trans-unit>
        <trans-unit id="28ff499477de962fb27a4867869e04752ace3e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;search&lt;/code&gt; returns history items matching the search string. If no search string is provided it returns all history items. This is the default operation if no other operation is specified. You only have to explicitly say &lt;code&gt;history search&lt;/code&gt; if you wish to search for one of the subcommands. The &lt;code&gt;--contains&lt;/code&gt; search option will be used if you don't specify a different search option. Entries are ordered newest to oldest unless you use the &lt;code&gt;--reverse&lt;/code&gt; flag. If stdout is attached to a tty the output will be piped through your pager by the history function. The history builtin simply writes the results to stdout.</source>
          <target state="translated">&lt;code&gt;search&lt;/code&gt; 은 검색 문자열과 일치하는 기록 항목을 반환합니다. 검색 문자열이 제공되지 않으면 모든 기록 항목을 반환합니다. 다른 작업이 지정되지 않은 경우 이것이 기본 작업입니다. 부속 명령 중 하나를 검색하려면 &lt;code&gt;history search&lt;/code&gt; 만 명시 적으로 말하면 됩니다. &lt;code&gt;--contains&lt;/code&gt; 의 다른 검색 옵션을 지정하지 않으면 검색 옵션이 사용됩니다. &lt;code&gt;--reverse&lt;/code&gt; 플래그 를 사용하지 않으면 항목은 최신에서 가장 오래된 항목으로 정렬 됩니다. stdout이 tty에 연결되면 출력은 히스토리 기능에 의해 호출기를 통해 파이프됩니다. 히스토리 내장은 단순히 결과를 표준 출력에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="f3f96766ba4c2b74ccc38f1a311d22fc52bcedcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self-insert-notfirst&lt;/code&gt;, inserts the matching sequence into the command line, unless the cursor is at the beginning</source>
          <target state="translated">&lt;code&gt;self-insert-notfirst&lt;/code&gt; , 커서가 시작 부분에 있지 않으면 일치하는 시퀀스를 명령 줄에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="47994204741d29e8fba63c4defd897209f0ef532" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self-insert&lt;/code&gt;, inserts the matching sequence into the command line</source>
          <target state="translated">&lt;code&gt;self-insert&lt;/code&gt; , 일치하는 시퀀스를 명령 줄에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="7bc81f408553d427ee9413652a2f976a6b4c6dd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; manipulates &lt;a href=&quot;../index#variables&quot;&gt;shell variables&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 는 &lt;a href=&quot;../index#variables&quot;&gt;쉘 변수를&lt;/a&gt; 조작 합니다 .</target>
        </trans-unit>
        <trans-unit id="78965c3228dd7b50cac24fd22a4c3a8f0bdef2ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; manipulates &lt;a href=&quot;index#variables&quot;&gt;shell variables&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 은 &lt;a href=&quot;index#variables&quot;&gt;쉘 변수를&lt;/a&gt; 조작 합니다 .</target>
        </trans-unit>
        <trans-unit id="4f185cc7bb3302f1e1eb498766b8e2bd113f381a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; requires all options to come before any other arguments. For example, &lt;code&gt;set flags -l&lt;/code&gt; will have the effect of setting the value of the variable &lt;code&gt;flags&lt;/code&gt; to '-l', not making the variable local.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 은 모든 옵션이 다른 인수보다 먼저 나오도록 요구합니다. 예를 들어, &lt;code&gt;set flags -l&lt;/code&gt; 은 변수를 로컬로 만들지 않고 변수 &lt;code&gt;flags&lt;/code&gt; 의 값 을 '-l' 로 설정하는 효과가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9948f6276410fe2f9dcf81419917c9bdeb9052d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_color&lt;/code&gt; is used to control the color and styling of text in the terminal. &lt;code&gt;VALUE&lt;/code&gt; corresponds to a reserved color name such as &lt;em&gt;red&lt;/em&gt; or a RGB color value given as 3 or 6 hexadecimal digits. The &lt;em&gt;br&lt;/em&gt;-, as in 'bright', forms are full-brightness variants of the 8 standard-brightness colors on many terminals. &lt;em&gt;brblack&lt;/em&gt; has higher brightness than &lt;em&gt;black&lt;/em&gt; - towards gray. A special keyword &lt;em&gt;normal&lt;/em&gt; resets text formatting to terminal defaults.</source>
          <target state="translated">&lt;code&gt;set_color&lt;/code&gt; 는 터미널에서 텍스트의 색상 및 스타일을 제어하는 ​​데 사용됩니다. &lt;code&gt;VALUE&lt;/code&gt; 는 3 자리 또는 6 자리 16 진수로 지정된 &lt;em&gt;빨강&lt;/em&gt; 또는 RGB 색상 값 과 같은 예약 된 색상 이름에 해당합니다 . &lt;em&gt;BR은&lt;/em&gt; - '밝은'에서와 같이 형태가 전체 밝기가 많은 터미널에 8 표준 밝기 색상의 변종이다. &lt;em&gt;brblack&lt;/em&gt; 은 &lt;em&gt;검은 색&lt;/em&gt; 보다 회색 보다 높은 밝기를 갖습니다 . 특수 키워드 &lt;em&gt;normal은&lt;/em&gt; 텍스트 형식을 터미널 기본값으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="9a61b97a3a96f79739663fe1e066e0c4c4c00523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_color&lt;/code&gt; is used to control the color and styling of text in the terminal. &lt;code&gt;VALUE&lt;/code&gt; describes that styling. It's a reserved color name like &lt;em&gt;red&lt;/em&gt; or a RGB color value given as 3 or 6 hexadecimal digits (&quot;F27&quot; or &quot;FF2277&quot;). A special keyword &lt;em&gt;normal&lt;/em&gt; resets text formatting to terminal defaults.</source>
          <target state="translated">&lt;code&gt;set_color&lt;/code&gt; 는 터미널에서 텍스트의 색상과 스타일을 제어하는 ​​데 사용됩니다. &lt;code&gt;VALUE&lt;/code&gt; 는 해당 스타일을 설명합니다. &lt;em&gt;빨간색&lt;/em&gt; 과 같은 예약 된 색상 이름 이거나 3 자리 또는 6 자리 16 진수 ( &quot;F27&quot;또는 &quot;FF2277&quot;)로 제공된 RGB 색상 값입니다. 특수 키워드 &lt;em&gt;normal은&lt;/em&gt; 텍스트 형식을 터미널 기본값으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="ab26307dc8847048c91facf1a58ea82662da70fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_color&lt;/code&gt; works by printing sequences of characters to &lt;em&gt;stdout&lt;/em&gt;. If used in command substitution or a pipe, these characters will also be captured. This may or may not be desirable. Checking the exit code of &lt;code&gt;isatty stdout&lt;/code&gt; before using &lt;code&gt;set_color&lt;/code&gt; can be useful to decide not to colorize output in a script.</source>
          <target state="translated">&lt;code&gt;set_color&lt;/code&gt; 는 일련의 문자를 &lt;em&gt;stdout&lt;/em&gt; 에 인쇄하여 작동합니다 . 명령 대체 또는 파이프에 사용되는 경우 이러한 문자도 캡처됩니다. 이것은 바람직하거나 바람직하지 않을 수 있습니다. &lt;code&gt;set_color&lt;/code&gt; 를 사용하기 전에 &lt;code&gt;isatty stdout&lt;/code&gt; 의 종료 코드를 확인하면 스크립트에서 출력을 색상 화하지 않기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0edcbbfc0660173d1858fb94dc65feaa1949db9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_color&lt;/code&gt; works by printing sequences of characters to &lt;em&gt;stdout&lt;/em&gt;. If used in command substitution or a pipe, these characters will also be captured. This may or may not be desirable. Checking the exit status of &lt;code&gt;isatty stdout&lt;/code&gt; before using &lt;code&gt;set_color&lt;/code&gt; can be useful to decide not to colorize output in a script.</source>
          <target state="translated">&lt;code&gt;set_color&lt;/code&gt; 는 문자 시퀀스를 &lt;em&gt;stdout&lt;/em&gt; 에 인쇄하여 작동합니다 . 명령 대체 또는 파이프에 사용되는 경우 이러한 문자도 캡처됩니다. 이것은 바람직하거나 바람직하지 않을 수 있습니다. &lt;code&gt;set_color&lt;/code&gt; 를 사용하기 전에 &lt;code&gt;isatty stdout&lt;/code&gt; 의 종료 상태를 확인하는 것은 스크립트에서 출력을 색상 화하지 않도록 결정하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f8f7bb400593234e096f28a62980d44f3d7595d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source&lt;/code&gt; creates a new &lt;a href=&quot;../index#variables-scope&quot;&gt;local scope&lt;/a&gt;; &lt;code&gt;set --local&lt;/code&gt; within a sourced block will not affect variables in the enclosing scope.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 는 새 &lt;a href=&quot;../index#variables-scope&quot;&gt;로컬 범위를&lt;/a&gt; 만듭니다 . 소스 블록 내의 &lt;code&gt;set --local&lt;/code&gt; 은 둘러싸는 범위의 변수에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44bd12edd43e43a291874a613bddb397393e4363" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source&lt;/code&gt; evaluates the commands of the specified file in the current shell as a new block of code. This is different from starting a new process to perform the commands (i.e. &lt;code&gt;fish &amp;lt; FILENAME&lt;/code&gt;) since the commands will be evaluated by the current shell, which means that changes in shell variables will affect the current shell. If additional arguments are specified after the file name, they will be inserted into the &lt;code&gt;$argv&lt;/code&gt; variable. The &lt;code&gt;$argv&lt;/code&gt; variable will not include the name of the sourced file.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 는 현재 쉘에서 지정된 파일의 명령을 새 코드 블록으로 평가합니다. 이것은 명령을 수행하기 위해 새 프로세스를 시작하는 것과는 다릅니다 (예 : &lt;code&gt;fish &amp;lt; FILENAME&lt;/code&gt; ). 명령은 현재 쉘에 의해 평가되므로 쉘 변수의 변경이 현재 쉘에 영향을 미칩니다. 파일 이름 뒤에 추가 인수가 지정되면 &lt;code&gt;$argv&lt;/code&gt; 변수에 삽입됩니다 . &lt;code&gt;$argv&lt;/code&gt; 변수는 전래 파일의 이름을 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92cf10690e111961211954c672900c642fb4e17e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source&lt;/code&gt; evaluates the commands of the specified file in the current shell. This is different from starting a new process to perform the commands (i.e. &lt;code&gt;fish &amp;lt; FILENAME&lt;/code&gt;) since the commands will be evaluated by the current shell, which means that changes in shell variables will affect the current shell. If additional arguments are specified after the file name, they will be inserted into the &lt;code&gt;$argv&lt;/code&gt; variable. The &lt;code&gt;$argv&lt;/code&gt; variable will not include the name of the sourced file.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 는 현재 쉘에서 지정된 파일의 명령을 평가합니다. 현재 쉘에서 명령이 평가되므로 쉘 변수의 변경이 현재 쉘에 영향을 미치므로 명령을 수행하기 위해 새 프로세스를 시작하는 것과 다릅니다 (즉, &lt;code&gt;fish &amp;lt; FILENAME&lt;/code&gt; ). 파일 이름 뒤에 추가 인수가 지정되면 &lt;code&gt;$argv&lt;/code&gt; 변수에 삽입됩니다 . &lt;code&gt;$argv&lt;/code&gt; 변수는 전래 파일의 이름을 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b682c0f9f4fd30b611d91123367bf03905b468de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;split0&lt;/code&gt; has the important property that its output is not further split when used in a command substitution, allowing for the command substitution to produce elements containing newlines. This is most useful when used with Unix tools that produce zero bytes, such as &lt;code&gt;find -print0&lt;/code&gt; or &lt;code&gt;sort -z&lt;/code&gt;. See split0 examples below.</source>
          <target state="translated">&lt;code&gt;split0&lt;/code&gt; 은 명령 대체에 사용될 때 출력이 더 이상 분할되지 않는 중요한 특성을 가지므로 명령 대체가 개행을 포함하는 요소를 생성 할 수 있습니다. &lt;code&gt;find -print0&lt;/code&gt; 또는 &lt;code&gt;sort -z&lt;/code&gt; 와 같이 0 바이트를 생성하는 Unix 도구와 함께 사용할 때 가장 유용합니다 . 아래 split0 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b18d9d888505a6c0fddbe8b5ab5788ebfaae04f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stack-trace&lt;/code&gt; prints a stack trace of all function calls on the call stack. Also &lt;code&gt;print-stack-trace&lt;/code&gt;, &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--print-stack-trace&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stack-trace&lt;/code&gt; 는 호출 스택에서 모든 함수 호출의 스택 추적을 인쇄합니다. 또한 &lt;code&gt;print-stack-trace&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; 또는 &lt;code&gt;--print-stack-trace&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="67df8697fda987cf4b0f9d793cb1a365c353272b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt;, the &lt;a href=&quot;#variables-status&quot;&gt;exit status&lt;/a&gt; of the last foreground job to exit. If the job was terminated through a signal, the exit status will be 128 plus the signal number.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; , &lt;a href=&quot;#variables-status&quot;&gt;종료&lt;/a&gt; 할 마지막 포 그라운드 작업 의 종료 상태 . 신호를 통해 작업이 종료 된 경우 종료 상태는 128에 신호 번호를 더한 값입니다.</target>
        </trans-unit>
        <trans-unit id="85f1259baf47f016edcc07c02ff8cac3eb36ec8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string collect&lt;/code&gt; collects its input into a single output argument, without splitting the output when used in a command substitution. This is useful when trying to collect multiline output from another command into a variable. Exit status: 0 if any output argument is non-empty, or 1 otherwise.</source>
          <target state="translated">&lt;code&gt;string collect&lt;/code&gt; 는 명령 대체에 사용될 때 출력을 분할하지 않고 입력을 단일 출력 인수로 수집 합니다. 이것은 다른 명령의 여러 줄 출력을 변수로 수집하려고 할 때 유용합니다. 종료 상태 : 출력 인수가 비어 있지 않으면 0, 그렇지 않으면 1.</target>
        </trans-unit>
        <trans-unit id="47aeedf462897d3635e7a17a92b7bf0d2db0992d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string escape&lt;/code&gt; escapes each STRING in one of three ways. The first is &lt;code&gt;--style=script&lt;/code&gt;. This is the default. It alters the string such that it can be passed back to &lt;code&gt;eval&lt;/code&gt; to produce the original argument again. By default, all special characters are escaped, and quotes are used to simplify the output when possible. If &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;--no-quoted&lt;/code&gt; is given, the simplifying quoted format is not used. Exit status: 0 if at least one string was escaped, or 1 otherwise.</source>
          <target state="translated">&lt;code&gt;string escape&lt;/code&gt; 는 세 가지 방법 중 하나로 각 STRING을 이스케이프합니다. 첫 번째는 &lt;code&gt;--style=script&lt;/code&gt; 입니다. 이것이 기본값입니다. 원래 인수를 다시 생성하기 위해 문자열을 &lt;code&gt;eval&lt;/code&gt; 로 다시 전달할 수 있도록 문자열을 변경 합니다. 기본적으로 모든 특수 문자는 이스케이프되며 따옴표는 가능한 경우 출력을 단순화하는 데 사용됩니다. 경우 &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;--no-quoted&lt;/code&gt; 주어진다의 단순화 인용 형식이 사용되지 않습니다. 종료 상태 : 하나 이상의 문자열이 이스케이프 된 경우 0, 그렇지 않은 경우 1</target>
        </trans-unit>
        <trans-unit id="b4c7444a524aa0a5c6e14a9e5a8c764cdc56c7f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string join0&lt;/code&gt; joins its STRING arguments into a single string separated by the zero byte (NUL), and adds a trailing NUL. This is most useful in conjunction with tools that accept NUL-delimited input, such as &lt;code&gt;sort -z&lt;/code&gt;. Exit status: 0 if at least one join was performed, or 1 otherwise.</source>
          <target state="translated">&lt;code&gt;string join0&lt;/code&gt; 은 STRING 인수를 0 바이트 (NUL)로 구분 된 단일 문자열로 결합하고 후행 NUL을 추가합니다. 이는 &lt;code&gt;sort -z&lt;/code&gt; 와 같이 NUL로 구분 된 입력을 허용하는 도구와 함께 사용할 때 가장 유용합니다 . 종료 상태 : 하나 이상의 결합이 수행 된 경우 0, 그렇지 않은 경우 1</target>
        </trans-unit>
        <trans-unit id="d4c0633e8572c3f56e421d3e1415eb94bb2502dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string join&lt;/code&gt; joins its STRING arguments into a single string separated by SEP, which can be an empty string. Exit status: 0 if at least one join was performed, or 1 otherwise.</source>
          <target state="translated">&lt;code&gt;string join&lt;/code&gt; 은 STRING 인수를 SEP로 구분 된 단일 문자열로 결합 합니다 (빈 문자열 일 수 있음). 종료 상태 : 하나 이상의 결합이 수행 된 경우 0, 그렇지 않은 경우 1</target>
        </trans-unit>
        <trans-unit id="4ac8783d6c5b8669120457e3abfbead54a865de8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string join&lt;/code&gt; joins its STRING arguments into a single string separated by the zero byte (NUL), and adds a trailing NUL. This is most useful in conjunction with tools that accept NUL-delimited input, such as &lt;code&gt;sort -z&lt;/code&gt;. Exit status: 0 if at least one join was performed, or 1 otherwise.</source>
          <target state="translated">&lt;code&gt;string join&lt;/code&gt; 은 STRING 인수를 0 바이트 (NUL)로 구분 된 단일 문자열로 결합하고 후미 NUL을 추가합니다. 이는 &lt;code&gt;sort -z&lt;/code&gt; 와 같이 NUL 구분 입력을 허용하는 도구와 함께 사용하면 가장 유용합니다 . 종료 상태 : 하나 이상의 결합이 수행 된 경우 0, 그렇지 않은 경우 1</target>
        </trans-unit>
        <trans-unit id="31f0710b84864509b27d49251c16e09dbb8cd30c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string length&lt;/code&gt; reports the length of each string argument in characters. Exit status: 0 if at least one non-empty STRING was given, or 1 otherwise.</source>
          <target state="translated">&lt;code&gt;string length&lt;/code&gt; 는 각 문자열 인수의 길이를 문자로보고합니다. 종료 상태 : 비어 있지 않은 STRING이 하나 이상 있으면 0, 그렇지 않으면 1</target>
        </trans-unit>
        <trans-unit id="ca94e657994de04d0305dfa680bad3e53fc3ae46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string lower&lt;/code&gt; converts each string argument to lowercase. Exit status: 0 if at least one string was converted to lowercase, else 1. This means that in conjunction with the &lt;code&gt;-q&lt;/code&gt; flag you can readily test whether a string is already lowercase.</source>
          <target state="translated">&lt;code&gt;string lower&lt;/code&gt; 는 각 문자열 인수를 소문자로 변환합니다. 종료 상태 : 하나 이상의 문자열이 소문자로 변환 된 경우 0, 그렇지 않으면 1. &lt;code&gt;-q&lt;/code&gt; 플래그 와 함께 문자열이 이미 소문자인지 쉽게 테스트 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="333a78e8a7e90eb78cb032128941a70a0f45d451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string match&lt;/code&gt; tests each STRING against PATTERN and prints matching substrings. Only the first match for each STRING is reported unless &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--all&lt;/code&gt; is given, in which case all matches are reported.</source>
          <target state="translated">&lt;code&gt;string match&lt;/code&gt; 는 각 STRING을 패턴에 대해 테스트하고 일치하는 하위 문자열을 인쇄합니다. &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;--all&lt;/code&gt; 을 지정 하지 않으면 각 STRING의 첫 번째 일치 만보고 되며,이 경우 모든 일치가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="91089de95c70b9064ef9a4fecf2979a43632d7c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string repeat&lt;/code&gt; repeats the STRING &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;--count&lt;/code&gt; times. The &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;--max&lt;/code&gt; option will limit the number of outputted char (excluding the newline). This option can be used by itself or in conjunction with &lt;code&gt;--count&lt;/code&gt;. If both &lt;code&gt;--count&lt;/code&gt; and &lt;code&gt;--max&lt;/code&gt; are present, max char will be outputed unless the final repeated string size is less than max, in that case, the string will repeat until count has been reached. Both &lt;code&gt;--count&lt;/code&gt; and &lt;code&gt;--max&lt;/code&gt; will accept a number greater than or equal to zero, in the case of zero, nothing will be outputed. If &lt;code&gt;-N&lt;/code&gt; or &lt;code&gt;--no-newline&lt;/code&gt; is given, the output won't contain a newline character at the end. Exit status: 0 if yielded string is not empty, 1 otherwise.</source>
          <target state="translated">&lt;code&gt;string repeat&lt;/code&gt; 은 STRING &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;--count&lt;/code&gt; 횟수를 반복합니다 . &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;--max&lt;/code&gt; 옵션 (줄 바꿈 제외) 출력 문자의 수를 제한합니다. 이 옵션은 &lt;code&gt;--count&lt;/code&gt; 또는 --count 와 함께 사용할 수 있습니다 . &lt;code&gt;--count&lt;/code&gt; 와 &lt;code&gt;--max&lt;/code&gt; 가 모두있는 경우 최종 반복 문자열 크기가 max보다 작지 않으면 max char가 출력됩니다.이 경우 문자열은 count에 도달 할 때까지 반복됩니다. &lt;code&gt;--count&lt;/code&gt; 와 &lt;code&gt;--max&lt;/code&gt; 는 모두 0 이상의 숫자를 허용하며, 0의 경우 아무 것도 출력되지 않습니다. 만약 &lt;code&gt;-N&lt;/code&gt; 또는 &lt;code&gt;--no-newline&lt;/code&gt; 결과는 끝에 줄 바꿈 문자가 포함되지 않습니다. 종료 상태 : 생성 된 문자열이 비어 있지 않으면 0, 그렇지 않으면 1</target>
        </trans-unit>
        <trans-unit id="cd631213eafa5a59cc02430161fa5c4930279381" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string replace&lt;/code&gt; is similar to &lt;code&gt;string match&lt;/code&gt; but replaces non-overlapping matching substrings with a replacement string and prints the result. By default, PATTERN is treated as a literal substring to be matched.</source>
          <target state="translated">&lt;code&gt;string replace&lt;/code&gt; 는 &lt;code&gt;string match&lt;/code&gt; 와 유사 하지만 겹치지 않는 일치하는 하위 문자열을 대체 문자열로 바꾸고 결과를 인쇄합니다. 기본적으로 PATTERN은 일치 할 리터럴 하위 문자열로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b0a1126fe21f179855ec4e248020911f83cdef8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string split somedelimiter&lt;/code&gt; is a replacement for &lt;code&gt;tr somedelimiter \\n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string split somedelimiter&lt;/code&gt; 는 &lt;code&gt;tr somedelimiter \\n&lt;/code&gt; 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="8aa496c6349d03b4676c999aab50e066cb8b5aeb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string split0&lt;/code&gt; splits each STRING on the zero byte (NUL). Options are the same as &lt;code&gt;string split&lt;/code&gt; except that no separator is given.</source>
          <target state="translated">&lt;code&gt;string split0&lt;/code&gt; 은 각 STRING을 0 바이트 (NUL)로 분할합니다. 옵션은 구분자가 제공되지 않는다는 점을 제외하고 &lt;code&gt;string split&lt;/code&gt; 동일합니다.</target>
        </trans-unit>
        <trans-unit id="04bcff6b42bd8f1e79e01e4a6814e48e20fbe176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string split&lt;/code&gt; splits each STRING on the separator SEP, which can be an empty string. If &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;--max&lt;/code&gt; is specified, at most MAX splits are done on each STRING. If &lt;code&gt;-r&lt;/code&gt; or &lt;code&gt;--right&lt;/code&gt; is given, splitting is performed right-to-left. This is useful in combination with &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;--max&lt;/code&gt;. With &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;--no-empty&lt;/code&gt;, empty results are excluded from consideration (e.g. &lt;code&gt;hello\n\nworld&lt;/code&gt; would expand to two strings and not three). Exit status: 0 if at least one split was performed, or 1 otherwise.</source>
          <target state="translated">&lt;code&gt;string split&lt;/code&gt; 은 분리기 SEP에서 각 STRING을 분할하며 빈 스트링 일 수 있습니다. 만약 &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;--max&lt;/code&gt; 는 대부분의 MAX 분할은 각 STRING에 완료에, 지정됩니다. 경우 &lt;code&gt;-r&lt;/code&gt; 또는 &lt;code&gt;--right&lt;/code&gt; 이 주어집니다, 분할은 오른쪽에서 왼쪽으로 수행됩니다. &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;--max&lt;/code&gt; 와 함께 사용하면 유용합니다 . 함께 &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;--no-empty&lt;/code&gt; , 빈 결과는 고려 대상에서 제외됩니다 (예 : &lt;code&gt;hello\n\nworld&lt;/code&gt; 두 개의 문자열이 아니라 세 가지로 확장 것이다). 종료 상태 : 하나 이상의 분할이 수행 된 경우 0, 그렇지 않은 경우 1</target>
        </trans-unit>
        <trans-unit id="eb23e8e3b2836edf4562f76805e4e7dee2577723" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string sub&lt;/code&gt; prints a substring of each string argument. The start of the substring can be specified with &lt;code&gt;-s&lt;/code&gt; or &lt;code&gt;--start&lt;/code&gt; followed by a 1-based index value. Positive index values are relative to the start of the string and negative index values are relative to the end of the string. The default start value is 1. The length of the substring can be specified with &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;--length&lt;/code&gt;. If the length is not specified, the substring continues to the end of each STRING. Exit status: 0 if at least one substring operation was performed, 1 otherwise.</source>
          <target state="translated">&lt;code&gt;string sub&lt;/code&gt; 는 각 문자열 인수의 하위 문자열을 인쇄합니다. 하위 문자열의 시작은 &lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;--start&lt;/code&gt; 와 1 기반 색인 값 으로 지정할 수 있습니다 . 양수 색인 값은 문자열의 시작에 상대적이며 음수 색인 값은 문자열의 끝에 상대적입니다. 기본 시작 값은 1입니다. 하위 문자열의 길이는 &lt;code&gt;-l&lt;/code&gt; 또는 &lt;code&gt;--length&lt;/code&gt; 로 지정할 수 있습니다 . 길이를 지정하지 않으면 부분 문자열은 각 STRING의 끝까지 계속됩니다. 종료 상태 : 하나 이상의 하위 문자열 작업이 수행 된 경우 0, 그렇지 않으면 1</target>
        </trans-unit>
        <trans-unit id="2334b2142123bfb3db8760998428b33ddb48c83c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string trim&lt;/code&gt; removes leading and trailing whitespace from each STRING. If &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;--left&lt;/code&gt; is given, only leading whitespace is removed. If &lt;code&gt;-r&lt;/code&gt; or &lt;code&gt;--right&lt;/code&gt; is given, only trailing whitespace is trimmed. The &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--chars&lt;/code&gt; switch causes the characters in CHARS to be removed instead of whitespace. Exit status: 0 if at least one character was trimmed, or 1 otherwise.</source>
          <target state="translated">&lt;code&gt;string trim&lt;/code&gt; 은 각 STRING에서 선행 및 후행 공백을 제거합니다. 경우 &lt;code&gt;-l&lt;/code&gt; 또는 &lt;code&gt;--left&lt;/code&gt; 이 주어집니다 만 선두 공백이 제거됩니다. 경우 &lt;code&gt;-r&lt;/code&gt; 또는 &lt;code&gt;--right&lt;/code&gt; 이 주어집니다 만 후행 공백은 잘립니다. &lt;code&gt;-c&lt;/code&gt; 또는 &lt;code&gt;--chars&lt;/code&gt; 스위치는 CHARS의 문자 대신 공백의 제거됩니다. 종료 상태 : 하나 이상의 문자가 잘린 경우 0, 그렇지 않으면 1</target>
        </trans-unit>
        <trans-unit id="4af7b90b6c15aa5377e3c5f869a9e47d5e7c1034" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string unescape&lt;/code&gt; performs the inverse of the &lt;code&gt;string escape&lt;/code&gt; command. If the string to be unescaped is not properly formatted it is ignored. For example, doing &lt;code&gt;string unescape --style=var (string escape --style=var $str)&lt;/code&gt; will return the original string. There is no support for unescaping &lt;code&gt;--style=regex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string unescape&lt;/code&gt; 는 &lt;code&gt;string escape&lt;/code&gt; 명령 의 역을 수행합니다 . 이스케이프 처리 할 문자열이 올바르게 형식화되지 않으면 무시됩니다. 예를 들어, &lt;code&gt;string unescape --style=var (string escape --style=var $str)&lt;/code&gt; 를 수행하면 원래 문자열이 반환됩니다. &lt;code&gt;--style=regex&lt;/code&gt; 이스케이프 해제를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ec537040dfbcd46a1d8e30c2f47ec1a7a8765e12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string upper&lt;/code&gt; converts each string argument to uppercase. Exit status: 0 if at least one string was converted to uppercase, else 1. This means that in conjunction with the &lt;code&gt;-q&lt;/code&gt; flag you can readily test whether a string is already uppercase.</source>
          <target state="translated">&lt;code&gt;string upper&lt;/code&gt; 는 각 문자열 인수를 대문자로 변환합니다. 종료 상태 : 하나 이상의 문자열이 대문자로 변환 된 경우 0, 그렇지 않으면 1. &lt;code&gt;-q&lt;/code&gt; 플래그 와 함께 문자열이 이미 대문자인지 쉽게 테스트 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="661aff77ace918c530880cc3272bdbd7f29220e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; performs operations on strings.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 문자열 에 대한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2a88199c092063e7efbe0b5f39b511b67eb20c78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suppress-autosuggestion&lt;/code&gt;, remove the current autosuggestion</source>
          <target state="translated">&lt;code&gt;suppress-autosuggestion&lt;/code&gt; , 현재 자동 제안 제거</target>
        </trans-unit>
        <trans-unit id="83fb6c3713a11a13683e8334160327a537f8074f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suspend&lt;/code&gt; suspends execution of the current shell by sending it a SIGTSTP signal, returning to the controlling process. It can be resumed later by sending it a SIGCONT. In order to prevent suspending a shell that doesn't have a controlling process, it will not suspend the shell if it is a login shell. This requirement is bypassed if the &lt;code&gt;--force&lt;/code&gt; option is given or the shell is not interactive.</source>
          <target state="translated">&lt;code&gt;suspend&lt;/code&gt; 는 현재 쉘의 SIGTSTP 신호를 전송하여 제어 프로세스로 돌아가서 현재 쉘의 실행을 일시 중단합니다. 나중에 SIGCONT를 보내서 다시 시작할 수 있습니다. 제어 프로세스가없는 쉘을 일시 중단하지 않으려면 로그인 쉘인 경우 쉘을 일시 중단하지 않습니다. &lt;code&gt;--force&lt;/code&gt; 옵션이 제공되거나 쉘이 대화식이 아닌 경우이 요구 사항은 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="626f00d07a2e5e46b2688607ebff9eb8a60c9966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;swap-selection-start-stop&lt;/code&gt;, go to the other end of the highlighted text without changing the selection</source>
          <target state="translated">&lt;code&gt;swap-selection-start-stop&lt;/code&gt; , 선택을 변경하지 않고 강조 표시된 텍스트의 다른 끝으로 이동</target>
        </trans-unit>
        <trans-unit id="9156298ff90a429e917bf58c7cc5f06073a40cd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; executes one of several blocks of commands, depending on whether a specified value matches one of several values. &lt;code&gt;case&lt;/code&gt; is used together with the &lt;code&gt;switch&lt;/code&gt; statement in order to determine which block should be executed.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 는 지정된 값이 여러 값 중 하나와 일치하는지 여부에 따라 여러 명령 블록 중 하나를 실행합니다. &lt;code&gt;case&lt;/code&gt; 는 &lt;code&gt;switch&lt;/code&gt; 블록 과 함께 사용되어 어떤 블록을 실행해야하는지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="51522e2a7f62a39e69b057a1b4e46231f1a7ac4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; performs one of several blocks of commands, depending on whether a specified value equals one of several wildcarded values. &lt;code&gt;case&lt;/code&gt; is used together with the &lt;code&gt;switch&lt;/code&gt; statement in order to determine which block should be executed.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 는 지정된 값이 여러 와일드 카드 값 중 하나와 같은지 여부에 따라 여러 명령 블록 중 하나를 수행합니다. &lt;code&gt;case&lt;/code&gt; 는 &lt;code&gt;switch&lt;/code&gt; 블록 과 함께 사용되어 어떤 블록을 실행해야하는지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="83e86983927861a95c2a328128c72990861f2579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test-feature FEATURE&lt;/code&gt; returns 0 when FEATURE is enabled, 1 if it is disabled, and 2 if it is not recognized.</source>
          <target state="translated">&lt;code&gt;test-feature FEATURE&lt;/code&gt; FEATURE가 활성화되면 test-feature FEATURE 는 0을, 비활성화되어 있으면 1, 인식되지 않으면 2를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49dea13a8691319ba78e4d5ed5960d93da35d7d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test&lt;/code&gt; implements a subset of the &lt;a href=&quot;http://www.unix.com/man-page/POSIX/1/test/&quot;&gt;IEEE Std 1003.1-2008 (POSIX.1) standard&lt;/a&gt;. The following exceptions apply:</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 는 &lt;a href=&quot;http://www.unix.com/man-page/POSIX/1/test/&quot;&gt;IEEE Std 1003.1-2008 (POSIX.1) 표준&lt;/a&gt; 의 일부를 구현합니다 . 다음 예외가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b8c506bfcfd28dcdc9217de6bf1cde91ed842ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test&lt;/code&gt; implements a subset of the &lt;a href=&quot;https://www.unix.com/man-page/posix/1p/test/&quot;&gt;IEEE Std 1003.1-2008 (POSIX.1) standard&lt;/a&gt;. The following exceptions apply:</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 는 &lt;a href=&quot;https://www.unix.com/man-page/posix/1p/test/&quot;&gt;IEEE Std 1003.1-2008 (POSIX.1) 표준&lt;/a&gt; 의 하위 집합을 구현합니다 . 다음 예외가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a920b6047086d1231c7f5d7fa31e31bfaec3736" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;time&lt;/code&gt; causes fish to measure how long a command takes and print the results afterwards. The command can be a simple fish command or a block. The results can not currently be redirected.</source>
          <target state="translated">&lt;code&gt;time&lt;/code&gt; 은 물고기가 명령에 걸리는 시간 을 측정하고 나중에 결과를 인쇄하도록합니다. 명령은 간단한 물고기 명령 또는 블록 일 수 있습니다. 결과는 현재 리디렉션 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1560f147987dc48333613d49b888555f9bd4b99c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transpose-chars&lt;/code&gt;, transpose two characters to the left of the cursor</source>
          <target state="translated">&lt;code&gt;transpose-chars&lt;/code&gt; , 커서 왼쪽에 두 문자를 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="92b2de28003baeca135430a69cac3301df211dca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transpose-words&lt;/code&gt;, transpose two words to the left of the cursor</source>
          <target state="translated">&lt;code&gt;transpose-words&lt;/code&gt; , 커서 왼쪽에 두 단어를 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="373dbc4e9fdbf8eb3bea04bfb57dda742ec7cfea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trap&lt;/code&gt; is a wrapper around the fish event delivery framework. It exists for backwards compatibility with POSIX shells. For other uses, it is recommended to define an &lt;a href=&quot;../index#event&quot;&gt;event handler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;trap&lt;/code&gt; 은 물고기 이벤트 전달 프레임 워크를 둘러싼 래퍼입니다. POSIX 쉘과의 역 호환성을 위해 존재합니다. 다른 용도의 &lt;a href=&quot;../index#event&quot;&gt;경우 이벤트 핸들러&lt;/a&gt; 를 정의하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f5ca8c4e095ac239e34f8594ebb4ab87d097fe66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trap&lt;/code&gt; is a wrapper around the fish event delivery framework. It exists for backwards compatibility with POSIX shells. For other uses, it is recommended to define an &lt;a href=&quot;index#event&quot;&gt;event handler&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;trap&lt;/code&gt; 은 물고기 이벤트 전달 프레임 워크를 둘러싼 래퍼입니다. POSIX 쉘과의 호환성을 위해 존재합니다. 다른 용도로는 &lt;a href=&quot;index#event&quot;&gt;이벤트 핸들러&lt;/a&gt; 를 정의하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0744337fd5341ea7b8967ff13d484eb039621a85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; sets the exit status to 0.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 는 종료 상태를 0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2d6b937046bc04378a6f19f7580563228ae32462" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ulimit -Hs 64&lt;/code&gt; sets the hard stack size limit to 64 kB.</source>
          <target state="translated">&lt;code&gt;ulimit -Hs 64&lt;/code&gt; 는 하드 스택 크기 제한을 64kB로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="09823b46aa54108856d9cfe97a6e2d6654edeb51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ulimit&lt;/code&gt; also accepts the following switches that determine what type of limit to set:</source>
          <target state="translated">&lt;code&gt;ulimit&lt;/code&gt; 는 설정할 제한 유형을 결정하는 다음 스위치도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="27494793012a34dbc727255f14091cec8673cfbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ulimit&lt;/code&gt; builtin sets or outputs the resource usage limits of the shell and any processes spawned by it. If a new limit value is omitted, the current value of the limit of the resource is printed; otherwise, the specified limit is set to the new value.</source>
          <target state="translated">&lt;code&gt;ulimit&lt;/code&gt; 내장은 쉘 및 그로 인해 생성 된 프로세스의 자원 사용 한계를 설정하거나 출력합니다. 새 한계 값을 생략하면 자원 한계의 현재 값이 인쇄됩니다. 그렇지 않으면 지정된 제한이 새 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="914a332a706ed930f92dfa2f893c31d61f8829c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;umask 177&lt;/code&gt; or &lt;code&gt;umask u=rw&lt;/code&gt; sets the file creation mask to read and write for the owner and no permissions at all for any other users.</source>
          <target state="translated">&lt;code&gt;umask 177&lt;/code&gt; 또는 &lt;code&gt;umask u=rw&lt;/code&gt; 는 파일 작성 마스크를 설정하여 소유자가 읽고 쓸 수 있으며 다른 사용자에게는 전혀 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ea8bdfdd73550087a9e5f4d0d74f501ad65d8378" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;umask&lt;/code&gt; displays and manipulates the &quot;umask&quot;, or file creation mode mask, which is used to restrict the default access to files.</source>
          <target state="translated">&lt;code&gt;umask&lt;/code&gt; 는 파일에 대한 기본 액세스를 제한하는 데 사용되는 &quot;umask&quot;또는 파일 작성 모드 마스크를 표시하고 조작합니다.</target>
        </trans-unit>
        <trans-unit id="d5b91d0960d8706ccf917682f946da0ed42fef50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;umask&lt;/code&gt;, the current file creation mask. The preferred way to change the umask variable is through the &lt;a href=&quot;cmds/umask#cmd-umask&quot;&gt;umask&lt;/a&gt; function. An attempt to set umask to an invalid value will always fail.</source>
          <target state="translated">&lt;code&gt;umask&lt;/code&gt; , 현재 파일 생성 마스크. umask 변수를 변경하는 선호되는 방법은 &lt;a href=&quot;cmds/umask#cmd-umask&quot;&gt;umask&lt;/a&gt; 함수를 사용하는 것입니다. umask를 잘못된 값으로 설정하려는 시도는 항상 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7b47f786d139724d5a34193ba1786452223e8ac7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;umask&lt;/code&gt;, the current file creation mask. The preferred way to change the umask variable is through the &lt;a href=&quot;commands#umask&quot;&gt;umask function&lt;/a&gt;. An attempt to set umask to an invalid value will always fail.</source>
          <target state="translated">&lt;code&gt;umask&lt;/code&gt; 현재 파일 작성 마스크 인 umask umask 변수를 변경하는 기본 방법은 &lt;a href=&quot;commands#umask&quot;&gt;umask 함수를 사용하는 것&lt;/a&gt; 입니다. umask를 유효하지 않은 값으로 설정하려는 시도는 항상 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e11ddb9d62a747071c14ddc0257484f36e4d0db7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;up-line&lt;/code&gt;, move up one line</source>
          <target state="translated">&lt;code&gt;up-line&lt;/code&gt; , 한 줄 위로 이동</target>
        </trans-unit>
        <trans-unit id="67c1b87ec154fe2bec25c34f88af59a7fa3c8771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;upcase-word&lt;/code&gt;, make the current word uppercase</source>
          <target state="translated">&lt;code&gt;upcase-word&lt;/code&gt; , 현재 단어를 대문자로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="57ccf04032406001bdc11a8189ad69fca2fb8bd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vared PATH[3]&lt;/code&gt; edits the third element of the PATH array</source>
          <target state="translated">&lt;code&gt;vared PATH[3]&lt;/code&gt; 은 PATH 배열의 세 번째 요소를 편집합니다</target>
        </trans-unit>
        <trans-unit id="65486428e36108a03da6e3498a15ce370423fc29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vared PATH[3]&lt;/code&gt; edits the third element of the PATH list</source>
          <target state="translated">&lt;code&gt;vared PATH[3]&lt;/code&gt; 는 PATH 목록의 세 번째 요소를 편집합니다.</target>
        </trans-unit>
        <trans-unit id="88c39c66df63979d68b40cdf38c535e8336f488a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vared&lt;/code&gt; is used to interactively edit the value of an environment variable. Array variables as a whole can not be edited using &lt;code&gt;vared&lt;/code&gt;, but individual array elements can.</source>
          <target state="translated">&lt;code&gt;vared&lt;/code&gt; 는 환경 변수의 값을 대화식으로 편집하는 데 사용됩니다. &lt;code&gt;vared&lt;/code&gt; 를 사용하여 배열 변수를 전체적으로 편집 할 수는 없지만 개별 배열 요소는 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2ed2d545022b6b47095d8582bee9cbd898c7fb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vared&lt;/code&gt; is used to interactively edit the value of an environment variable. Array variables as a whole can not be edited using &lt;code&gt;vared&lt;/code&gt;, but individual list elements can.</source>
          <target state="translated">&lt;code&gt;vared&lt;/code&gt; 는 환경 변수의 값을 대화식으로 편집하는 데 사용됩니다. 배열 변수 전체는 &lt;code&gt;vared&lt;/code&gt; 를 사용하여 편집 할 수 없지만 개별 목록 요소는 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9862f5e93904059a6b32007b38450efce85a2073" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;version&lt;/code&gt;, the version of the currently running fish (also available as &lt;code&gt;FISH_VERSION&lt;/code&gt; for backward compatibility).</source>
          <target state="translated">&lt;code&gt;version&lt;/code&gt; , 현재 실행중인 물고기의 버전입니다 ( 이전 버전과의 호환성을 위해 &lt;code&gt;FISH_VERSION&lt;/code&gt; 으로 도 사용 가능).</target>
        </trans-unit>
        <trans-unit id="63fa20183bc82ef05dd53eaea0bdba2083b42311" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wait&lt;/code&gt; waits for child jobs to complete.</source>
          <target state="translated">&lt;code&gt;wait&lt;/code&gt; 하위 작업이 완료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="813fdc779468e7aa9ef0139c7dc0dcbe8dce7527" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; repeatedly executes &lt;code&gt;CONDITION&lt;/code&gt;, and if the exit status is 0, then executes &lt;code&gt;COMMANDS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; &lt;code&gt;CONDITION&lt;/code&gt; 을 실행 하고 종료 상태가 0이면 &lt;code&gt;COMMANDS&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="3777774e876be438277e734434a6c0c8157ad52c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x-&lt;/code&gt; is not valid since there is no long flag name and therefore the short flag, &lt;code&gt;-x&lt;/code&gt;, has to be usable.</source>
          <target state="translated">&lt;code&gt;x-&lt;/code&gt; 긴 플래그 이름이 없기 때문에 x- 는 유효하지 않으므로 짧은 플래그 &lt;code&gt;-x&lt;/code&gt; 를 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5fd5ec35b0142154e7c9e8643d553640b56bf3b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; means that only &lt;code&gt;-x&lt;/code&gt; is valid. It is a boolean can can be used more than once. If it is seen then &lt;code&gt;_flag_x&lt;/code&gt; will be set to the count of how many times the flag was seen.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;-x&lt;/code&gt; 만 유효 함을 의미 합니다. 부울은 두 번 이상 사용할 수 있습니다. 이것이 표시되면 &lt;code&gt;_flag_x&lt;/code&gt; 는 플래그가 표시된 횟수의 카운트로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3ee9d686d28ba49895201840c47e53da39de4e40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; means that only &lt;code&gt;-x&lt;/code&gt; is valid. It is a boolean that can be used more than once. If it is seen then &lt;code&gt;_flag_x&lt;/code&gt; will be set to the count of how many times the flag was seen.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;-x&lt;/code&gt; 만 유효 함을 의미 합니다. 두 번 이상 사용할 수있는 부울입니다. 만약 &lt;code&gt;_flag_x&lt;/code&gt; 는 플래그가 보이는 횟수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="21ede97712b0a6930815ab06e47ca99f9faf164c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x=&lt;/code&gt;, &lt;code&gt;x=?&lt;/code&gt;, and &lt;code&gt;x=+&lt;/code&gt; are similar to the n/name examples above but there is no long flag alternative to the short flag &lt;code&gt;-x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x=&lt;/code&gt; , &lt;code&gt;x=?&lt;/code&gt; , &lt;code&gt;x=+&lt;/code&gt; 는 위의 n / name 예제와 비슷하지만 short 플래그 &lt;code&gt;-x&lt;/code&gt; 에 대한 대체 플래그는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f0527623453636ac5982213b0815cf8b199abd43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yank-pop&lt;/code&gt;, rotate to the previous entry of the killring</source>
          <target state="translated">&lt;code&gt;yank-pop&lt;/code&gt; , 킬링의 이전 항목으로 회전</target>
        </trans-unit>
        <trans-unit id="6b2c2003ee77d278bc6a300e349540b9f1fcec50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yank&lt;/code&gt;, insert the latest entry of the killring into the buffer</source>
          <target state="translated">&lt;code&gt;yank&lt;/code&gt; , 킬링의 최신 항목을 버퍼에 삽입</target>
        </trans-unit>
        <trans-unit id="d38e08cea2004c22d96c7648bde8064ec9710a41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n,m}&lt;/code&gt; at least n, no more than m.</source>
          <target state="translated">&lt;code&gt;{n,m}&lt;/code&gt; 이상 , m 이하</target>
        </trans-unit>
        <trans-unit id="6754034e24ab614bfd421eac3a73529e0acbdf6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n,}&lt;/code&gt; n or more</source>
          <target state="translated">&lt;code&gt;{n,}&lt;/code&gt; n 이상</target>
        </trans-unit>
        <trans-unit id="a365c3492a087f6ec4c03c8376dcb30c6386fb2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n}&lt;/code&gt; to exactly n (where n is a number)</source>
          <target state="translated">&lt;code&gt;{n}&lt;/code&gt; 에서 정확히 n까지 (여기서 n은 숫자 임)</target>
        </trans-unit>
        <trans-unit id="707c3563364628d29b1994c70cf28e906025d3d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt; is &quot;alternation&quot;, i.e. the &quot;or&quot;.</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; &quot;대체&quot;, 즉 &quot;또는&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="df0f52ee032449bf7212b4c3984d956c6fa44267" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;SOME_VAR=1 command&lt;/code&gt; produces an error: &lt;code&gt;Unknown command &quot;SOME_VAR=1&quot;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;SOME_VAR=1 command&lt;/code&gt; 은 오류를 생성합니다. &lt;code&gt;Unknown command &quot;SOME_VAR=1&quot;&lt;/code&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0da3c08b202353af950bee5219ca327f11f72cd7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;larr;&lt;/b&gt; and &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;rarr;&lt;/b&gt; move the cursor one word left or right, or moves forward/backward in the directory history if the command line is empty. If the cursor is already at the end of the line, and an autosuggestion is available, &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;rarr;&lt;/b&gt; (or &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;F&lt;/b&gt;) accepts the first word in the suggestion.</source>
          <target state="translated">&lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;&amp;larr;&lt;/b&gt; 와 &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;&amp;rarr;는&lt;/b&gt; 명령 줄이 비어있는 경우 커서 한 단어 왼쪽이나 오른쪽으로 이동하거나 디렉토리 역사에서 뒤로 앞으로 이동 /. 커서가 줄의 끝에 이미, 그리고 자기 암시가 사용할 수있는 경우 &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;&amp;rarr;&lt;/b&gt; (또는 &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;F&lt;/b&gt; ) 제안의 첫 번째 단어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41668896a709e48d38407c24cdaae2f37bd2e2d0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;uarr;&lt;/b&gt; and &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;darr;&lt;/b&gt; search the command history for the previous/next token containing the token under the cursor before the search was started. If the commandline was not on a token when the search started, all tokens match. See the &lt;a href=&quot;#history&quot;&gt;history&lt;/a&gt; section for more information on history searching.</source>
          <target state="translated">&lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;&amp;uarr;&lt;/b&gt; 및 &lt;em&gt;Alt를&lt;/em&gt; - &lt;b&gt;&amp;darr;&lt;/b&gt; 에 대한 명령 기록을 검색 이전 / 다음 검색이 시작되기 전에 커서 아래에있는 토큰을 포함하는 토큰입니다. 검색이 시작될 때 명령 줄이 토큰에 없으면 모든 토큰이 일치합니다. 히스토리 검색에 대한 자세한 정보 는 &lt;a href=&quot;#history&quot;&gt;히스토리&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dd002a4a5d9f181df1139416f359b0c0b1982d4c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;uarr;&lt;/b&gt; recalls individual arguments, starting from the last argument in the last line executed. A single press replaces &quot;!$&quot;, later presses replace &quot;!!:4&quot; and the like.</source>
          <target state="translated">&lt;em&gt;Alt를&lt;/em&gt; - &lt;b&gt;&amp;uarr;&lt;/b&gt; 실행 된 마지막 행의 마지막 인수에서 시작하여, 개별 인수를 회상했다. 한 번의 누르기는 &quot;! $&quot;를 대체하고 나중에 누르는 것은 &quot;!! : 4&quot;등을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="31b5b5642ff4d16559c25c2eec15dc84d9c7c38a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;c&lt;/b&gt; capitalizes the current word.</source>
          <target state="translated">&lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;c&lt;/b&gt; 는 현재 단어를 대문자로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8c08d7cecc389da8fd667cb3de1b66142f66dbc0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;d&lt;/b&gt; moves the next word to the &lt;a href=&quot;#killring&quot;&gt;killring&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;d&lt;/b&gt; 는 다음 단어를 &lt;a href=&quot;#killring&quot;&gt;킬링으로&lt;/a&gt; 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="ba939795dc763dc37424d264df584c3dc1414201" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;e&lt;/b&gt; edit the current command line in an external editor. The editor is chosen from the first available of the &lt;code&gt;$VISUAL&lt;/code&gt; or &lt;code&gt;$EDITOR&lt;/code&gt; variables.</source>
          <target state="translated">&lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;e&lt;/b&gt; 외부 편집기에서 현재 명령 행을 편집합니다. 편집기는 &lt;code&gt;$VISUAL&lt;/code&gt; 또는 &lt;code&gt;$EDITOR&lt;/code&gt; 변수 중 사용 가능한 첫 번째 항목에서 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d19663ab96f42c66ebcd8b4711cc5775c0115de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;h&lt;/b&gt; (or &lt;b&gt;F1&lt;/b&gt;) shows the manual page for the current command, if one exists.</source>
          <target state="translated">&lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;h&lt;/b&gt; (또는 &lt;b&gt;F1&lt;/b&gt; )은 현재 명령에 대한 매뉴얼 페이지를 표시합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="6fe0d9f367a7b1fb62d59310e866cb7000917983" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;l&lt;/b&gt; lists the contents of the current directory, unless the cursor is over a directory argument, in which case the contents of that directory will be listed.</source>
          <target state="translated">&lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;l&lt;/b&gt; 은 커서가 디렉토리 인수 위에 있지 않으면 현재 디렉토리의 내용을 나열합니다.이 경우 해당 디렉토리의 내용이 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="ac4ab1e3b2a18333f6469ab62c6774ab20358dd6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;p&lt;/b&gt; adds the string '&lt;code&gt;| less;&lt;/code&gt;' to the end of the job under the cursor. The result is that the output of the command will be paged.</source>
          <target state="translated">&lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;p&lt;/b&gt; 는 ' &lt;code&gt;| less;&lt;/code&gt; 커서 아래에서 작업이 끝날 때까지 결과적으로 명령 출력이 페이징됩니다.</target>
        </trans-unit>
        <trans-unit id="136abcdd3926f6f6917e785f3c9b3de852a583e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;t&lt;/b&gt; transposes the last two words</source>
          <target state="translated">&lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;t&lt;/b&gt; 는 마지막 두 단어를 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="6b4f3c9f30c412c35376eb5c0b053bbecc930222" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;u&lt;/b&gt; makes the current word uppercase.</source>
          <target state="translated">&lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;u&lt;/b&gt; 는 현재 단어를 대문자로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f055c4fc1257b63bfc385501bfbaf929ca352490" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;v&lt;/b&gt; Same as &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;e&lt;/b&gt;.</source>
          <target state="translated">&lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;v &lt;/b&gt;&lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;e&lt;/b&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="5781eac00f106e823a16702f30c3a1c598e21b65" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;w&lt;/b&gt; prints a short description of the command under the cursor.</source>
          <target state="translated">&lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;w&lt;/b&gt; 는 커서 아래에 명령에 대한 간단한 설명을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="17e2f8a79bdc960577f4eeaedc12d0c21a945731" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;C&lt;/b&gt; cancels the entire line.</source>
          <target state="translated">&lt;em&gt;컨트롤&lt;/em&gt; - &lt;b&gt;C는&lt;/b&gt; 전체 라인을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="9333a2ffd2f21f466d57fc6d1e5b4d1a978b95a0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;D&lt;/b&gt; delete one character to the right of the cursor. If the command line is empty, &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;D&lt;/b&gt; will exit fish.</source>
          <target state="translated">&lt;em&gt;컨트롤&lt;/em&gt; - &lt;b&gt;D는&lt;/b&gt; 커서의 오른쪽으로 한 문자를 삭제합니다. 명령 행이 비어 있으면 &lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;D&lt;/b&gt; 는 물고기를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="bb14070b99b4a045f1889b39bfeae27b8794ec9e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;K&lt;/b&gt; moves contents from the cursor to the end of line to the &lt;a href=&quot;#killring&quot;&gt;killring&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;K&lt;/b&gt; 는 내용을 커서에서 줄 끝으로 &lt;a href=&quot;#killring&quot;&gt;킬링으로 이동&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="04ddb78416f34126599d6fdf7033f85b757d8ea0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;L&lt;/b&gt; clears and repaints the screen.</source>
          <target state="translated">&lt;em&gt;제어&lt;/em&gt; - &lt;b&gt;L의&lt;/b&gt; 투명 도료 페인트 다시 화면을.</target>
        </trans-unit>
        <trans-unit id="eec641fe659922171462b212fb4e12bfac800762" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;U&lt;/b&gt; moves contents from the beginning of line to the cursor to the &lt;a href=&quot;#killring&quot;&gt;killring&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;U&lt;/b&gt; 는 내용을 줄의 시작 부분에서 커서로 &lt;a href=&quot;#killring&quot;&gt;킬링으로&lt;/a&gt; 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="959eb883117dacfd136a241f1bf9b0d08b63da44" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;W&lt;/b&gt; moves the previous path component (everything up to the previous &quot;/&quot;) to the &lt;a href=&quot;#killring&quot;&gt;killring&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;W&lt;/b&gt; 는 이전 경로 구성 요소 (이전의 모든 &quot;/&quot;까지)를 &lt;a href=&quot;#killring&quot;&gt;킬링으로 이동&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4437b353083b50d06c142c5629d09aa0198b91c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;X&lt;/b&gt; copies the current buffer to the system's clipboard, &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;V&lt;/b&gt; inserts the clipboard contents.</source>
          <target state="translated">&lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;X&lt;/b&gt; 는 현재 버퍼를 시스템의 클립 보드에 복사하고 &lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;V&lt;/b&gt; 는 클립 보드 내용을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="5aed52702667fe63b8fc8764b7596443d6fa67f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;t&lt;/b&gt; transposes the last two characters</source>
          <target state="translated">&lt;em&gt;제어&lt;/em&gt; - &lt;b&gt;t는&lt;/b&gt; 마지막 두 글자 이항</target>
        </trans-unit>
        <trans-unit id="2a3529141c90e88bccb3cffb04eaf5e452963437" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Shift&lt;/em&gt;-&lt;b&gt;A&lt;/b&gt; enters &lt;a href=&quot;#vi-mode-insert&quot;&gt;insert mode&lt;/a&gt; at the end of the line.</source>
          <target state="translated">&lt;em&gt;Shift&lt;/em&gt; - &lt;b&gt;A&lt;/b&gt; 는 줄 끝에서 &lt;a href=&quot;#vi-mode-insert&quot;&gt;삽입 모드&lt;/a&gt; 로 들어갑니다 .</target>
        </trans-unit>
        <trans-unit id="848bb77d0284135b4b11d0def92f1a7b33558c29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Shift&lt;/em&gt;-&lt;b&gt;D&lt;/b&gt; deletes text after the current cursor position and moves it to the &lt;a href=&quot;#killring&quot;&gt;killring&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Shift&lt;/em&gt; - &lt;b&gt;D&lt;/b&gt; 는 현재 커서 위치 다음에있는 텍스트를 삭제하고 &lt;a href=&quot;#killring&quot;&gt;킬링으로&lt;/a&gt; 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="0aa350769e38ad587d4204af5750f62efcffd698" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;black&lt;/em&gt;, &lt;em&gt;red&lt;/em&gt;, &lt;em&gt;green&lt;/em&gt;, &lt;em&gt;yellow&lt;/em&gt;, &lt;em&gt;blue&lt;/em&gt;, &lt;em&gt;magenta&lt;/em&gt;, &lt;em&gt;cyan&lt;/em&gt;, &lt;em&gt;white&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;까맣고&lt;/em&gt; , &lt;em&gt;빨강&lt;/em&gt; , &lt;em&gt;녹색&lt;/em&gt; , &lt;em&gt;노랗고&lt;/em&gt; , &lt;em&gt;파랗고&lt;/em&gt; , &lt;em&gt;자홍색&lt;/em&gt; , &lt;em&gt;청록색&lt;/em&gt; , &lt;em&gt;백색&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f06a4164895f4acf75e4fc05849a9f1080eb613" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;brblack&lt;/em&gt;, &lt;em&gt;brred&lt;/em&gt;, &lt;em&gt;brgreen&lt;/em&gt;, &lt;em&gt;bryellow&lt;/em&gt;, &lt;em&gt;brblue&lt;/em&gt;, &lt;em&gt;brmagenta&lt;/em&gt;, &lt;em&gt;brcyan&lt;/em&gt;, &lt;em&gt;brwhite&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;brblack&lt;/em&gt; , &lt;em&gt;brred&lt;/em&gt; , &lt;em&gt;brgreen&lt;/em&gt; , &lt;em&gt;bryellow&lt;/em&gt; , &lt;em&gt;brblue&lt;/em&gt; , &lt;em&gt;brmagenta&lt;/em&gt; , &lt;em&gt;brcyan&lt;/em&gt; , &lt;em&gt;brwhite&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5aaf073a1b8f279587c77fcd145e5e12a28d0f7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Easy scripting&lt;/strong&gt;: new &lt;a href=&quot;#functions&quot;&gt;functions&lt;/a&gt; can be added on the fly. The syntax is easy to learn and use.</source>
          <target state="translated">&lt;strong&gt;간편한 스크립팅&lt;/strong&gt; : 새 &lt;a href=&quot;#functions&quot;&gt;기능&lt;/a&gt; 을 즉시 추가 할 수 있습니다. 구문은 배우고 사용하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="4df60123802c7d8d13f9b6713ff515d5434a37f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Extensive UI&lt;/strong&gt;: &lt;a href=&quot;#syntax-highlighting&quot;&gt;syntax highlighting&lt;/a&gt;, &lt;a href=&quot;#autosuggestions&quot;&gt;autosuggestions&lt;/a&gt;, &lt;a href=&quot;#tab-completion&quot;&gt;tab completion&lt;/a&gt; and selection lists that can be navigated and filtered.</source>
          <target state="translated">&lt;strong&gt;광범위한 UI&lt;/strong&gt; : 탐색 및 필터링 할 수있는 &lt;a href=&quot;#syntax-highlighting&quot;&gt;구문 강조 표시&lt;/a&gt; , &lt;a href=&quot;#autosuggestions&quot;&gt;자동 제안&lt;/a&gt; , &lt;a href=&quot;#tab-completion&quot;&gt;탭 완성&lt;/a&gt; 및 선택 목록.</target>
        </trans-unit>
        <trans-unit id="a4735f2bc1b1f6cc44fc36a9270fa8d0bebad687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;No configuration needed&lt;/strong&gt;: fish is designed to be ready to use immediately, without requiring extensive configuration.</source>
          <target state="translated">&lt;strong&gt;구성이 필요하지 않습니다&lt;/strong&gt; . 물고기는 광범위한 구성없이 즉시 사용할 수 있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="c1761f0b1ba5b43d7b93024d944cddd83977bbd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;argument&lt;/strong&gt; a parameter given to a command</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;명령에 주어진 매개 변수 &lt;strong&gt;인수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9abc342512c31331a993f0014b546a67fa5db37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;builtin&lt;/strong&gt; a command that is implemented in the shell. Builtins are commands that are so closely tied to the shell that it is impossible to implement them as external commands.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;쉘에서 구현되는 명령이 &lt;strong&gt;내장&lt;/strong&gt; 되어 있습니다. 내장 명령은 쉘에 너무 밀접하게 연결되어있어 외부 명령으로 구현할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f166fa76e55d41c05140d9c66e33482752388e40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;command&lt;/strong&gt; a program that the shell can run. In another sense also specifically an external command (i.e. neither a function or builtin).</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;쉘이 실행할 수있는 프로그램을 &lt;strong&gt;명령&lt;/strong&gt; 합니다. 또 다른 의미에서 특히 외부 명령 (즉, 함수도 내장 명령도 아님)입니다.</target>
        </trans-unit>
        <trans-unit id="b757809536a26ee5fe7cf05aa97874be3e9ec7f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;function&lt;/strong&gt; a block of commands that can be called as if they were a single command. By using functions, it is possible to string together multiple smaller commands into one more advanced command.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;단일 명령 인 것처럼 호출 할 수있는 명령 블록을 &lt;strong&gt;기능&lt;/strong&gt; 합니다. 함수를 사용하면 여러 개의 작은 명령을 하나의 고급 명령으로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60a92d1d7691db21d94fa52b5efe10f9c00a98a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;job&lt;/strong&gt; a running pipeline or command</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;실행중인 파이프 라인 또는 명령 &lt;strong&gt;작업&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="33e34e3f380b965910f59129f13ec1cc926b1a27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;pipeline&lt;/strong&gt; a set of commands stringed together so that the output of one command is the input of the next command</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;한 명령의 출력이 다음 명령의 입력이되도록 함께 연결된 명령 집합을 &lt;strong&gt;파이프 라인&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="44d28d2c07c14f9f63ac8b103318575395a8d8f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;redirection&lt;/strong&gt; an operation that changes one of the input/output streams associated with a job</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;작업과 관련된 입력 / 출력 스트림 중 하나를 변경하는 작업 &lt;strong&gt;리디렉션&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e94007d359708c28c1c1effb3bd68983f4f0862" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;switch&lt;/strong&gt; a special flag sent as an argument to a command that will alter the behavior of the command. A switch almost always begins with one or two hyphens.</source>
          <target state="translated">&lt;strong&gt;전환&lt;/strong&gt; 명령의 동작을 변경하는 명령에 대한 인수로 보낸 특별한 플래그를. 스위치는 거의 항상 하나 또는 두 개의 하이픈으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="58ef9d5fc414a372d364bba5d463086a74cd1e79" translate="yes" xml:space="preserve">
          <source>=&amp;gt; /private/</source>
          <target state="translated">=&amp;gt; / private /</target>
        </trans-unit>
        <trans-unit id="fba3fd4e3fd6608dd7f90bc1b5ab21add9a24490" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;/&lt;/code&gt; if the short flag can be used by someone invoking your command else &lt;code&gt;-&lt;/code&gt; if it should not be exposed as a valid short flag. If there is no long flag name these characters should be omitted. You can also specify a '#' to indicate the short and long flag names can be used and the value can be specified as an implicit int; i.e., a flag of the form &lt;code&gt;-NNN&lt;/code&gt;.</source>
          <target state="translated">A &lt;code&gt;/&lt;/code&gt; 다른 사람이 명령을 호출하여 짧은 플래그를 사용할 수있는 경우 &lt;code&gt;-&lt;/code&gt; 유효한 짧은 플래그로 노출되어서는 안됩니다. 긴 플래그 이름이 없으면이 문자를 생략해야합니다. 짧고 긴 플래그 이름을 사용할 수 있고 값을 암시 적 int로 지정할 수 있음을 나타 내기 위해 '#'을 지정할 수도 있습니다. 즉, &lt;code&gt;-NNN&lt;/code&gt; 형식의 플래그입니다 .</target>
        </trans-unit>
        <trans-unit id="7198b525f0714279660d3b850cc70c2393d6d32c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;fish&lt;/code&gt; function is a list of commands, which may optionally take arguments. Unlike other shells, arguments are not passed in &quot;numbered variables&quot; like &lt;code&gt;$1&lt;/code&gt;, but instead in a single list &lt;code&gt;$argv&lt;/code&gt;. To create a function, use the &lt;code&gt;function&lt;/code&gt; builtin:</source>
          <target state="translated">&lt;code&gt;fish&lt;/code&gt; 기능은 선택적 인수를 취할 수있다 명령의 목록입니다. 다른 쉘과 달리 인수는 &lt;code&gt;$1&lt;/code&gt; 과 같은 &quot;숫자 변수&quot;로 전달되지 않고 단일 목록 &lt;code&gt;$argv&lt;/code&gt; 됩니다. 함수를 만들려면 사용 &lt;code&gt;function&lt;/code&gt; 내장을 :</target>
        </trans-unit>
        <trans-unit id="19bcfbaa8447e6df7d2da91db70a782c0bf63572" translate="yes" xml:space="preserve">
          <source>A background job is executed simultaneously with fish, and does not have access to the keyboard. If no job is specified, the last job to be used is put in the background. If PID is specified, the jobs with the specified process group IDs are put in the background.</source>
          <target state="translated">백그라운드 작업은 물고기와 동시에 실행되며 키보드에 액세스 할 수 없습니다. 작업을 지정하지 않으면 마지막으로 사용 된 작업이 백그라운드에 배치됩니다. PID가 지정되면 지정된 프로세스 그룹 ID가있는 작업이 백그라운드에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="b46aed84b0ed848ddd07f44ad7751712530b525e" translate="yes" xml:space="preserve">
          <source>A bind mode name (e.g., &lt;code&gt;bind -m abc ...&lt;/code&gt;) is restricted to the rules for valid variable names.</source>
          <target state="translated">바인드 모드 이름 (예 : &lt;code&gt;bind -m abc ...&lt;/code&gt; )은 유효한 변수 이름의 규칙으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="9b580f7fbca87c3708e0299e0e01e7d18f311f8d" translate="yes" xml:space="preserve">
          <source>A block allows the introduction of a new variable scope, redirection of the input or output of a set of commands as a group, or to specify precedence when using the conditional commands like &lt;code&gt;and&lt;/code&gt;.</source>
          <target state="translated">블록을 사용하면 새 변수 범위를 도입하거나 명령 집합의 입력 또는 출력을 그룹으로 리디렉션하거나 &lt;code&gt;and&lt;/code&gt; 와 같은 조건부 명령을 사용할 때 우선 순위를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="221743bb3156c75a9da83c1a7dacbf3cffddec98" translate="yes" xml:space="preserve">
          <source>A comma separated list of characters enclosed in curly braces will be expanded so each element of the list becomes a new parameter.</source>
          <target state="translated">중괄호로 묶인 쉼표로 구분 된 문자 목록이 확장되어 목록의 각 요소가 새 매개 변수가됩니다.</target>
        </trans-unit>
        <trans-unit id="b1251b9c7f3a0ecfe4cfcd8762e368b829d54d22" translate="yes" xml:space="preserve">
          <source>A comma separated list of characters enclosed in curly braces will be expanded so each element of the list becomes a new parameter. This is useful to save on typing, and to separate a variable name from surrounding text.</source>
          <target state="translated">중괄호로 묶인 쉼표로 구분 된 문자 목록이 확장되어 목록의 각 요소가 새 매개 변수가됩니다. 이것은 타이핑을 절약하고 주변 텍스트에서 변수 이름을 분리하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="18819280931565e1e540c3948c1068287f296514" translate="yes" xml:space="preserve">
          <source>A command is executed by writing the name of the command followed by any arguments.</source>
          <target state="translated">명령 이름 뒤에 인수가 있으면 명령이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ef0596789e19cf7d157b82b21b7a04276de1271d" translate="yes" xml:space="preserve">
          <source>A command may be invalid because it does not exist, or refers to a file that you cannot execute. When the command becomes valid, it is shown in a different color:</source>
          <target state="translated">명령이 존재하지 않거나 실행할 수없는 파일을 참조하여 명령이 유효하지 않을 수 있습니다. 명령이 유효 해지면 다른 색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7889a1f8efa9424d9ad0d196f8208854866a152e" translate="yes" xml:space="preserve">
          <source>A common comparison is with $status:</source>
          <target state="translated">일반적인 비교는 $ status입니다.</target>
        </trans-unit>
        <trans-unit id="0ab1d9ac994221a7fc24fe83fee3534ae7e7edc9" translate="yes" xml:space="preserve">
          <source>A common idiom is to capture the output of a command in a variable:</source>
          <target state="translated">일반적인 관용구는 변수의 명령 출력을 캡처하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e5fc3140c2546b6e6a23e2f80c44a655ee78ea6c" translate="yes" xml:space="preserve">
          <source>A directory for end-users to keep their own completions, usually &lt;code&gt;~/.config/fish/completions&lt;/code&gt; (controlled by the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable);</source>
          <target state="translated">최종 사용자가 일반적으로 &lt;code&gt;~/.config/fish/completions&lt;/code&gt; ( &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 환경 변수로 제어)를 완료 하기위한 디렉토리입니다 .</target>
        </trans-unit>
        <trans-unit id="65baeff5e625e88bc63f2d15091644216f3ec2bb" translate="yes" xml:space="preserve">
          <source>A directory for end-users to keep their own functions, usually &lt;code&gt;~/.config/fish/functions&lt;/code&gt; (controlled by the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable).</source>
          <target state="translated">최종 사용자가 일반적으로 &lt;code&gt;~/.config/fish/functions&lt;/code&gt; ( &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 환경 변수로 제어) 기능을 유지하기위한 디렉토리입니다 .</target>
        </trans-unit>
        <trans-unit id="859d016958d7758044bcb3a91d192638e99bef83" translate="yes" xml:space="preserve">
          <source>A directory for systems administrators to install completions for all users on the system, usually &lt;code&gt;/etc/fish/completions&lt;/code&gt;;</source>
          <target state="translated">시스템 관리자가 시스템의 모든 사용자에 대해 완료를 설치하기위한 디렉토리 (일반적으로 &lt;code&gt;/etc/fish/completions&lt;/code&gt; ) ;</target>
        </trans-unit>
        <trans-unit id="108785695c3e86a9a6e52e8824798deb67cc4081" translate="yes" xml:space="preserve">
          <source>A directory for systems administrators to install functions for all users on the system, usually &lt;code&gt;/etc/fish/functions&lt;/code&gt; (really &lt;code&gt;$__fish_sysconfdir/functions&lt;/code&gt;).</source>
          <target state="translated">시스템 관리자가 시스템의 모든 사용자를위한 기능을 설치할 수있는 디렉토리, 일반적으로 &lt;code&gt;/etc/fish/functions&lt;/code&gt; (정말 &lt;code&gt;$__fish_sysconfdir/functions&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="641e45d215c27568a98d7ad513ca06236cc4ce30" translate="yes" xml:space="preserve">
          <source>A directory for systems administrators to install functions for all users on the system, usually &lt;code&gt;/etc/fish/functions&lt;/code&gt;.</source>
          <target state="translated">시스템 관리자가 시스템의 모든 사용자를 위해 일반적으로 &lt;code&gt;/etc/fish/functions&lt;/code&gt; 기능 을 설치하기위한 디렉토리입니다 .</target>
        </trans-unit>
        <trans-unit id="9f5e2984dcf6e5df1ad339573ada9e5723fb0b37" translate="yes" xml:space="preserve">
          <source>A directory for third-party software vendors to ship their own completions for their software, usually &lt;code&gt;/usr/share/fish/vendor_completions.d&lt;/code&gt;;</source>
          <target state="translated">타사 소프트웨어 공급 업체가 소프트웨어에 대한 완성품을 배송 할 수있는 디렉토리 (일반적으로 &lt;code&gt;/usr/share/fish/vendor_completions.d&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="5e8075c8426f4f6e374491e133779cfa809fd782" translate="yes" xml:space="preserve">
          <source>A directory for third-party software vendors to ship their own functions for their software, usually &lt;code&gt;/usr/share/fish/vendor_functions.d&lt;/code&gt;.</source>
          <target state="translated">타사 소프트웨어 공급 업체가 자체 소프트웨어 기능 (일반적으로 &lt;code&gt;/usr/share/fish/vendor_functions.d&lt;/code&gt; )을 제공하기위한 디렉토리입니다 .</target>
        </trans-unit>
        <trans-unit id="a44f52824482af64d09602d2bfcb5e4719f63ad2" translate="yes" xml:space="preserve">
          <source>A dollar sign followed by a string of characters is expanded into the value of the shell variable with the same name. For an introduction to the concept of shell variables, read the &lt;a href=&quot;#variables&quot;&gt;Shell variables&lt;/a&gt; section.</source>
          <target state="translated">달러 기호 다음에 문자열이 같은 이름을 가진 쉘 변수의 값으로 확장됩니다. 쉘 변수 개념에 대한 소개는 &lt;a href=&quot;#variables&quot;&gt;쉘 변수&lt;/a&gt; 섹션을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="ca6eed9ce238df03667fd3003cea2a936f38aa05" translate="yes" xml:space="preserve">
          <source>A dollar sign followed by a string of characters is expanded into the value of the shell variable with the same name. For more on shell variables, read the &lt;a href=&quot;#variables&quot;&gt;Shell variables&lt;/a&gt; section.</source>
          <target state="translated">문자열 뒤에 오는 달러 기호는 동일한 이름의 쉘 변수 값으로 확장됩니다. 셸 변수에 대한 자세한 내용은 &lt;a href=&quot;#variables&quot;&gt;셸 변수&lt;/a&gt; 섹션을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="a99436ba2e5d329112af2b584fd421fbf3f42c7d" translate="yes" xml:space="preserve">
          <source>A faster way is to modify the &lt;code&gt;$fish_user_paths&lt;/code&gt;&lt;a href=&quot;#tut-universal&quot;&gt;universal variable&lt;/a&gt;, which is automatically prepended to &lt;code&gt;$PATH&lt;/code&gt;. For example, to permanently add &lt;code&gt;/usr/local/bin&lt;/code&gt; to your &lt;code&gt;$PATH&lt;/code&gt;, you could write:</source>
          <target state="translated">더 빠른 방법은 자동으로 &lt;code&gt;$PATH&lt;/code&gt; 앞에 추가되는 &lt;code&gt;$fish_user_paths&lt;/code&gt; &lt;a href=&quot;#tut-universal&quot;&gt;범용 변수&lt;/a&gt; 를 수정하는 것 입니다. 예를 들어, &lt;code&gt;/usr/local/bin&lt;/code&gt; 을 &lt;code&gt;$PATH&lt;/code&gt; 에 영구적으로 추가 하려면 다음 과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2d19574b46bfc9315dc6a4268de0f13c74f87d0" translate="yes" xml:space="preserve">
          <source>A faster way is to modify the &lt;code&gt;$fish_user_paths&lt;/code&gt;&lt;a href=&quot;#tut_universal&quot;&gt;universal variable&lt;/a&gt;, which is automatically prepended to &lt;code&gt;$PATH&lt;/code&gt;. For example, to permanently add &lt;code&gt;/usr/local/bin&lt;/code&gt; to your &lt;code&gt;$PATH&lt;/code&gt;, you could write:</source>
          <target state="translated">더 빠른 방법은 &lt;code&gt;$fish_user_paths&lt;/code&gt; &lt;a href=&quot;#tut_universal&quot;&gt;범용 변수&lt;/a&gt; 를 수정하는 것입니다.이 변수 는 &lt;code&gt;$PATH&lt;/code&gt; 앞에 자동으로 추가됩니다 . 예를 들어 &lt;code&gt;$PATH&lt;/code&gt; 에 &lt;code&gt;/usr/local/bin&lt;/code&gt; 을 영구적으로 추가 하려면 다음 과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceec61da03fba72e62b6265e8da899ee3527c4d0" translate="yes" xml:space="preserve">
          <source>A filename. The output will be written to the specified file.</source>
          <target state="translated">파일 이름 출력은 지정된 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="3d33de98068774700d9110cea5dcb53a094ba7e7" translate="yes" xml:space="preserve">
          <source>A function is a list of commands that will be executed when the name of the function is given as a command.</source>
          <target state="translated">함수는 함수 이름이 명령으로 제공 될 때 실행될 명령 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7601c1858c241e3bd16046e3e56c915853d6505a" translate="yes" xml:space="preserve">
          <source>A function name cannot be empty. It may not begin with a hyphen (&quot;-&quot;) and may not contain a slash (&quot;/&quot;). All other characters, including a space, are valid.</source>
          <target state="translated">함수 이름은 비워 둘 수 없습니다. 하이픈 ( &quot;-&quot;)으로 시작하지 않고 슬래시 ( &quot;/&quot;)를 포함 할 수 없습니다. 공백을 포함한 다른 모든 문자는 유효합니다.</target>
        </trans-unit>
        <trans-unit id="f2876072ebbf01c7648d2358047842fa63f47f6c" translate="yes" xml:space="preserve">
          <source>A global variable of the same name already exists.</source>
          <target state="translated">같은 이름의 전역 변수가 이미 존재합니다.</target>
        </trans-unit>
        <trans-unit id="8b50d81adfb557d2a38d6b95df25f2d574c4f80c" translate="yes" xml:space="preserve">
          <source>A hard limit can only be decreased. Once it is set it cannot be increased; a soft limit may be increased up to the value of the hard limit. If neither -H nor -S is specified, both the soft and hard limits are updated when assigning a new limit value, and the soft limit is used when reporting the current value.</source>
          <target state="translated">하드 한계는 줄일 수 있습니다. 일단 설정되면 증가시킬 수 없습니다. 소프트 한계는 하드 한계의 값까지 증가 될 수있다. -H 또는 -S를 지정하지 않으면 새 한계 값을 지정할 때 소프트 한계와 하드 한계가 모두 업데이트되고 현재 값을보고 할 때 소프트 한계가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b23a7c576473abf4f67fa752f0d58982d9b4994d" translate="yes" xml:space="preserve">
          <source>A hard limit can only be decreased. Once it is set it cannot be increased; a soft limit may be increased up to the value of the hard limit. If neither &lt;code&gt;-H&lt;/code&gt; nor &lt;code&gt;-S&lt;/code&gt; is specified, both the soft and hard limits are updated when assigning a new limit value, and the soft limit is used when reporting the current value.</source>
          <target state="translated">하드 제한은 줄일 수만 있습니다. 일단 설정되면 증가 할 수 없습니다. 소프트 한계는 하드 한계 값까지 증가 할 수 있습니다. &lt;code&gt;-H&lt;/code&gt; 또는 &lt;code&gt;-S&lt;/code&gt; 를 지정 하지 않으면 새 제한 값을 할당 할 때 소프트 제한과 하드 제한이 모두 업데이트되고 현재 값을보고 할 때 소프트 제한이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec2f57dda8cd2b7d726afdc269175dec20de44df" translate="yes" xml:space="preserve">
          <source>A large number of variable starting with the prefixes &lt;code&gt;fish_color&lt;/code&gt; and &lt;code&gt;fish_pager_color.&lt;/code&gt; See &lt;a href=&quot;#variables-color&quot;&gt;Variables for changing highlighting colors&lt;/a&gt; for more information.</source>
          <target state="translated">접두사 &lt;code&gt;fish_color&lt;/code&gt; 및 &lt;code&gt;fish_pager_color.&lt;/code&gt; 시작하는 많은 변수 자세한 내용은 &lt;a href=&quot;#variables-color&quot;&gt;강조 색상 변경을위한 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b6b5c0631c6ec4d7569772ecd93c5f2a9ad8e07" translate="yes" xml:space="preserve">
          <source>A large number of variable starting with the prefixes &lt;code&gt;fish_color&lt;/code&gt; and &lt;code&gt;fish_pager_color&lt;/code&gt;. See &lt;a href=&quot;#variables-color&quot;&gt;Variables for changing highlighting colors&lt;/a&gt; for more information.</source>
          <target state="translated">접두사 &lt;code&gt;fish_color&lt;/code&gt; 및 &lt;code&gt;fish_pager_color&lt;/code&gt; 로 시작하는 많은 변수 . 자세한 내용은 &lt;a href=&quot;#variables-color&quot;&gt;강조 색상 변경을위한 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e5cf560f2e4f99636de6a450bd940ddafbd9847" translate="yes" xml:space="preserve">
          <source>A literal &quot;{}&quot; will not be used as a brace expansion:</source>
          <target state="translated">리터럴 &quot;{}&quot;은 중괄호 확장으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b73470b832856451e08f355e80a561c89bef4ab" translate="yes" xml:space="preserve">
          <source>A long flag name which is optional. If not present then only the short flag letter can be used.</source>
          <target state="translated">선택적인 긴 플래그 이름입니다. 존재하지 않으면 짧은 플래그 문자 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c289b8e2f3ba875ebca3ca04379eb21ac58c6d06" translate="yes" xml:space="preserve">
          <source>A number of variables control the symbol (&quot;display&quot;) and color (&quot;color&quot;) for the different status indicators:</source>
          <target state="translated">여러 변수가 다양한 상태 표시기에 대한 기호 ( &quot;디스플레이&quot;) 및 색상 ( &quot;색상&quot;)을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d7eb886434c2d98d1f604c3752317380a9843e6c" translate="yes" xml:space="preserve">
          <source>A number of variables set characters and color used as indicators. Many of these have a different default if used with informative status enabled, or &lt;code&gt;$__fish_git_prompt_use_informative_chars&lt;/code&gt; set. The usual default is given first, then the informative default (if it is different). If no default for the colors is given, they default to &lt;code&gt;$__fish_git_prompt_color&lt;/code&gt;.</source>
          <target state="translated">여러 변수가 표시기로 사용되는 문자와 색상을 설정합니다. 이들 중 대부분은 정보 상태를 활성화하거나 &lt;code&gt;$__fish_git_prompt_use_informative_chars&lt;/code&gt; 세트 와 함께 사용하는 경우 다른 기본값을 갖습니다 . 일반적인 기본값이 먼저 제공된 다음 정보 용 기본값 (다른 경우)이 제공됩니다. 색상에 대한 기본값이 제공되지 않으면 기본값은 &lt;code&gt;$__fish_git_prompt_color&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b7b8ab4ed67c762ac2d0fa14336c7a66f5b2e303" translate="yes" xml:space="preserve">
          <source>A range of indices can be specified, see &lt;a href=&quot;#expand-index-range&quot;&gt;index range expansion&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;#expand-index-range&quot;&gt;인덱스 범위를&lt;/a&gt; 지정할 수 있습니다 . 자세한 내용 은 인덱스 범위 확장 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5e298a31256356ac86c6d29914100defedf5fffe" translate="yes" xml:space="preserve">
          <source>A scripts written in &lt;code&gt;bash&lt;/code&gt; it would need a first line like this:</source>
          <target state="translated">&lt;code&gt;bash&lt;/code&gt; 로 작성된 스크립트는 다음 과 같은 첫 번째 줄이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8c3a0a6b90c1f5bc360ed70d0dd93ffe55365da5" translate="yes" xml:space="preserve">
          <source>A second color may be given as a desired fallback color. e.g. &lt;code&gt;set_color 124212 brblue&lt;/code&gt; will instruct set_color to use &lt;em&gt;brblue&lt;/em&gt; if a terminal is not capable of the exact shade of grey desired. This is very useful when an 8 or 16 color terminal might otherwise not use a color.</source>
          <target state="translated">두 번째 색상은 원하는 대체 색상으로 제공 될 수 있습니다. 예를 들어 &lt;code&gt;set_color 124212 brblue&lt;/code&gt; 는 터미널이 원하는 정확한 회색 음영 을 사용할 수 &lt;em&gt;없는&lt;/em&gt; 경우 set_color에 brblue를 사용하도록 지시 합니다. 이것은 8 또는 16 색상 터미널이 색상을 사용하지 않을 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3fcf13b497d0506afff3d618c0c36dfe5e1a068c" translate="yes" xml:space="preserve">
          <source>A shell is a program which helps you operate your computer by starting other programs. fish offers a command-line interface focused on usability and interactive use.</source>
          <target state="translated">쉘은 다른 프로그램을 시작하여 컴퓨터를 작동하는 데 도움이되는 프로그램입니다. fish는 유용성과 대화 형 사용에 초점을 맞춘 명령 줄 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fa2eb63a7d926840491eb53403e1e6e33347d750" translate="yes" xml:space="preserve">
          <source>A short flag letter (which is mandatory). It must be an alphanumeric or &quot;#&quot;. The &quot;#&quot; character is special and means that a flag of the form &lt;code&gt;-123&lt;/code&gt; is valid. The short flag &quot;#&quot; must be followed by &quot;-&quot; (since the short name isn't otherwise valid since &lt;code&gt;_flag_#&lt;/code&gt; is not a valid var name) and must be followed by a long flag name with no modifiers.</source>
          <target state="translated">짧은 플래그 문자 (필수). 영숫자 또는 &quot;#&quot;이어야합니다. &quot;#&quot;문자는 특별하며 &lt;code&gt;-123&lt;/code&gt; 형식의 플래그 가 유효 함을 의미 합니다. 짧은 플래그 &quot;#&quot;다음에 &quot;-&quot;가 와야합니다 ( &lt;code&gt;_flag_#&lt;/code&gt; 가 유효한 var 이름이 아니기 때문에 짧은 이름이 유효하지 않기 때문에 ). 뒤에 수정자가없는 긴 플래그 이름이 와야합니다.</target>
        </trans-unit>
        <trans-unit id="e585b4919dc0904a5ac8ff639290a7da0168ce72" translate="yes" xml:space="preserve">
          <source>A simple prompt that displays all known VCS info:</source>
          <target state="translated">알려진 모든 VCS 정보를 표시하는 간단한 프롬프트 :</target>
        </trans-unit>
        <trans-unit id="c44605d7cf5f66a5d454bc7f8b72acac0713b1cf" translate="yes" xml:space="preserve">
          <source>A simple prompt that displays git info:</source>
          <target state="translated">git 정보를 표시하는 간단한 프롬프트 :</target>
        </trans-unit>
        <trans-unit id="981d3d4dab4f4f8c0ceaf4c8bcfaaee7cef2a27b" translate="yes" xml:space="preserve">
          <source>A simple prompt that displays hg info:</source>
          <target state="translated">hg 정보를 표시하는 간단한 프롬프트 :</target>
        </trans-unit>
        <trans-unit id="87603fcaef9b30ff09e50b24e5fda2ce2fcd654c" translate="yes" xml:space="preserve">
          <source>A simple prompt that displays svn info:</source>
          <target state="translated">svn 정보를 표시하는 간단한 프롬프트 :</target>
        </trans-unit>
        <trans-unit id="610fac60f39f41e55d40e59429099ac45fcaf3c8" translate="yes" xml:space="preserve">
          <source>A simple prompt that is a simplified version of the default debugging prompt:</source>
          <target state="translated">기본 디버깅 프롬프트의 단순화 된 버전 인 간단한 프롬프트 :</target>
        </trans-unit>
        <trans-unit id="631761c6042b0b4defe6087674d679a446f769a6" translate="yes" xml:space="preserve">
          <source>A simple prompt:</source>
          <target state="translated">간단한 프롬프트 :</target>
        </trans-unit>
        <trans-unit id="a457232f4c851ca48444c8b22ce5d86f9157d153" translate="yes" xml:space="preserve">
          <source>A simple right prompt:</source>
          <target state="translated">간단한 올바른 프롬프트 :</target>
        </trans-unit>
        <trans-unit id="e87c54de638d95b5e6d226cc4b4479d88e8ad79d" translate="yes" xml:space="preserve">
          <source>A switch is a very common special type of argument. Switches almost always start with one or more hyphens '&lt;code&gt;-&lt;/code&gt;' and alter the way a command operates. For example, the '&lt;code&gt;ls&lt;/code&gt;' command usually lists all the files and directories in the current working directory, but by using the '&lt;code&gt;-l&lt;/code&gt;' switch, the behavior of '&lt;code&gt;ls&lt;/code&gt;' is changed to not only display the filename, but also the size, permissions, owner and modification time of each file.</source>
          <target state="translated">스위치는 매우 일반적인 특수 유형의 인수입니다. 스위치는 거의 항상 하나 이상의 하이픈 ' &lt;code&gt;-&lt;/code&gt; '으로 시작하고 명령 작동 방식을 변경합니다. 예를 들어, ' &lt;code&gt;ls&lt;/code&gt; '명령은 일반적으로 현재 작업 디렉토리의 모든 파일과 디렉토리를 나열하지만 ' &lt;code&gt;-l&lt;/code&gt; '스위치 를 사용하면 ' &lt;code&gt;ls&lt;/code&gt; ' 의 동작이 파일 이름뿐만 아니라 크기도 표시하도록 변경됩니다. , 권한, 소유자 및 각 파일의 수정 시간.</target>
        </trans-unit>
        <trans-unit id="dfb06de1c7a12f5632480c8ec95581dfbbdcf321" translate="yes" xml:space="preserve">
          <source>A universal variable is a variable whose value is shared across all instances of &lt;code&gt;fish&lt;/code&gt;, now and in the future &amp;ndash; even after a reboot. You can make a variable universal with &lt;code&gt;set -U&lt;/code&gt;:</source>
          <target state="translated">범용 변수는 재부팅 후에도 현재와 미래 의 모든 &lt;code&gt;fish&lt;/code&gt; 인스턴스에서 값을 공유하는 변수입니다 . &lt;code&gt;set -U&lt;/code&gt; 로 변수를 범용으로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b8d375ccbff689a61358d91a3d87c3b4c7bb526" translate="yes" xml:space="preserve">
          <source>A variable name cannot be empty. It can contain only letters, digits, and underscores. It may begin and end with any of those characters.</source>
          <target state="translated">변수 이름은 비워 둘 수 없습니다. 문자, 숫자 및 밑줄 만 포함 할 수 있습니다. 해당 문자로 시작하고 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a39ab99e2ea47c8c0e9d74827d866ecbba2cbde0" translate="yes" xml:space="preserve">
          <source>Access rights are explained in the manual page for the &lt;code&gt;chmod(1)&lt;/code&gt; program.</source>
          <target state="translated">액세스 권한은 &lt;code&gt;chmod(1)&lt;/code&gt; 프로그램 의 매뉴얼 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e139d85bd15795b0d3efa188c22e165c587928c5" translate="yes" xml:space="preserve">
          <source>Access rights are explained in the manual page for the &lt;code&gt;chmod&lt;/code&gt;(1) program.</source>
          <target state="translated">액세스 권한은 &lt;code&gt;chmod&lt;/code&gt; (1) 프로그램 의 매뉴얼 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf27f6010a1e75f4bb8d29911772c8214904203b" translate="yes" xml:space="preserve">
          <source>Add a new abbreviation where &lt;code&gt;gco&lt;/code&gt; will be replaced with &lt;code&gt;git checkout&lt;/code&gt; global to the current shell. This abbreviation will not be automatically visible to other shells unless the same command is run in those shells (such as when executing the commands in config.fish).</source>
          <target state="translated">&lt;code&gt;gco&lt;/code&gt; 가 현재 쉘에 대해 전역으로 &lt;code&gt;git checkout&lt;/code&gt; 으로 대체 되는 새로운 약어를 추가하십시오 . config.fish에서 명령을 실행할 때와 같이 해당 쉘에서 동일한 명령을 실행하지 않으면이 약어는 다른 쉘에 자동으로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e3c8915a2556d62c5b7d149b19924656f4d28db" translate="yes" xml:space="preserve">
          <source>Add a new abbreviation where &lt;code&gt;l&lt;/code&gt; will be replaced with &lt;code&gt;less&lt;/code&gt; universal so all shells. Note that you omit the &lt;code&gt;-U&lt;/code&gt; since it is the default.</source>
          <target state="translated">&lt;code&gt;l&lt;/code&gt; 이 &lt;code&gt;less&lt;/code&gt; 보편적이므로 모든 셸로 대체 되는 새로운 약어를 추가하십시오 . &lt;code&gt;-U&lt;/code&gt; 가 기본값이므로 생략합니다 .</target>
        </trans-unit>
        <trans-unit id="fb5d43a3f1c9755eef7928213dbee5eeaa42d36e" translate="yes" xml:space="preserve">
          <source>Add the fish shell &lt;code&gt;/usr/local/bin/fish&lt;/code&gt; to &lt;code&gt;/etc/shells&lt;/code&gt; with:</source>
          <target state="translated">다음을 사용하여 &lt;code&gt;/etc/shells&lt;/code&gt; 에 생선 껍질 &lt;code&gt;/usr/local/bin/fish&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f235c11a925e7b3330abed437c370548fb56ecc" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;blink&lt;/code&gt; can be added after each of the cursor shape parameters to set a blinking cursor in the specified shape.</source>
          <target state="translated">또한 &lt;code&gt;blink&lt;/code&gt; 지정된 형상으로 깜빡이는 커서를 설정 커서 형상 패러미터의 각 후에 첨가 될 수있다.</target>
        </trans-unit>
        <trans-unit id="fc74aa2568dbca49c63c7dc4f2b48adf6334bb72" translate="yes" xml:space="preserve">
          <source>Additionally, the following variables are available to change the highlighting in the completion pager:</source>
          <target state="translated">또한 완료 호출기에서 강조 표시를 변경하기 위해 다음 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dcf0bfda5eb37d5ad6d848b3b854d252bf95ed5" translate="yes" xml:space="preserve">
          <source>After a command has been entered, it is inserted at the end of a history list. Any duplicate history items are automatically removed. By pressing the up and down keys, the user can search forwards and backwards in the history. If the current command line is not empty when starting a history search, only the commands containing the string entered into the command line are shown.</source>
          <target state="translated">명령이 입력 된 후, 내역 목록의 끝에 삽입됩니다. 중복 기록 항목이 자동으로 제거됩니다. 위 / 아래 키를 누르면 히스토리에서 앞뒤로 검색 할 수 있습니다. 히스토리 검색을 시작할 때 현재 명령 행이 비어 있지 않으면 명령 행에 입력 된 문자열을 포함하는 명령 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a350de02e9b5ffd85be164d43398c5ad2155568f" translate="yes" xml:space="preserve">
          <source>After a variable has been set, you can use the value of a variable in the shell through &lt;a href=&quot;#expand-variable&quot;&gt;variable expansion&lt;/a&gt;.</source>
          <target state="translated">변수가 설정되면 &lt;a href=&quot;#expand-variable&quot;&gt;변수 확장을&lt;/a&gt; 통해 쉘에서 변수 값을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6629fd2d9ea9eaa222685dbc3f35af94810deb35" translate="yes" xml:space="preserve">
          <source>After parsing the arguments the &lt;code&gt;argv&lt;/code&gt; var is set with local scope to any values not already consumed during flag processing. If there are not unbound values the var is set but &lt;code&gt;count $argv&lt;/code&gt; will be zero.</source>
          <target state="translated">인수를 구문 분석 한 후 &lt;code&gt;argv&lt;/code&gt; var는 플래그 처리 중에 아직 소비되지 않은 값으로 로컬 범위로 설정됩니다. 바인딩되지 않은 값이 없으면 var가 설정되지만 &lt;code&gt;count $argv&lt;/code&gt; 는 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="c71ccb08a9461f3714b74f1bc1174cad1387e3e4" translate="yes" xml:space="preserve">
          <source>All arrays are one-dimensional and cannot contain other arrays, although it is possible to fake nested arrays using the dereferencing rules of &lt;a href=&quot;#expand-variable&quot;&gt;variable expansion&lt;/a&gt;.</source>
          <target state="translated">모든 배열은 1 차원이며 다른 배열을 포함 할 수 없지만 &lt;a href=&quot;#expand-variable&quot;&gt;변수 확장&lt;/a&gt; 의 역 참조 규칙을 사용하여 중첩 배열을 속일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95c98653dd35db2f0582bbcfb13f9d49a14d5a55" translate="yes" xml:space="preserve">
          <source>All lists are one-dimensional and cannot contain other lists, although it is possible to fake nested lists using the dereferencing rules of &lt;a href=&quot;#expand-variable&quot;&gt;variable expansion&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#expand-variable&quot;&gt;변수 확장&lt;/a&gt; 의 역 참조 규칙을 사용하여 중첩 된 목록을 위조 할 수 있지만 모든 목록은 1 차원이며 다른 목록을 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="66ffedcb95110c61b7f48b8dfe9b357e5be7aafb" translate="yes" xml:space="preserve">
          <source>All of the above expansions can be combined. If several expansions result in more than one parameter, all possible combinations are created.</source>
          <target state="translated">위의 모든 확장을 결합 할 수 있습니다. 여러 확장으로 인해 둘 이상의 매개 변수가 발생하면 가능한 모든 조합이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="828afdd065730919c157af1148a37aa2e6215eb2" translate="yes" xml:space="preserve">
          <source>All of the trigonometric functions use radians.</source>
          <target state="translated">모든 삼각 함수는 라디안을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="59d286363a981fa0af60a5ca572e501d6a1474e5" translate="yes" xml:space="preserve">
          <source>Almost all fish commands respond to the &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; options to display their relevant help, also accessible using the &lt;code&gt;help&lt;/code&gt; and &lt;code&gt;man&lt;/code&gt; commands, like so:</source>
          <target state="translated">거의 모든 피쉬 명령은 &lt;code&gt;-h&lt;/code&gt; 또는 &lt;code&gt;--help&lt;/code&gt; 옵션에 응답하여 관련 도움말을 표시하고 &lt;code&gt;help&lt;/code&gt; 및 &lt;code&gt;man&lt;/code&gt; 명령을 사용하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bda1d0385b54eba22fc83053a714334995ee2583" translate="yes" xml:space="preserve">
          <source>Also shortened as &quot;I/O&quot; or &quot;IO&quot;.</source>
          <target state="translated">또한 &quot;I / O&quot;또는 &quot;IO&quot;로 축약됩니다.</target>
        </trans-unit>
        <trans-unit id="517f3a2c8b9272ee95d59b7f36af89264fa4dbf8" translate="yes" xml:space="preserve">
          <source>Alt+&amp;darr;,Down</source>
          <target state="translated">Alt+&amp;darr;,Down</target>
        </trans-unit>
        <trans-unit id="5e9023ab706bd62faa0520004f30bc2ed999ef8c" translate="yes" xml:space="preserve">
          <source>Alt+&amp;larr;,Left</source>
          <target state="translated">Alt+&amp;larr;,Left</target>
        </trans-unit>
        <trans-unit id="36866486669ffcdfbef93f70b2122585d0689c65" translate="yes" xml:space="preserve">
          <source>Alt+&amp;rarr;</source>
          <target state="translated">Alt+&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="6b89c31e566539bfe03d67119b891ccbd78608fd" translate="yes" xml:space="preserve">
          <source>Alt+&amp;rarr;,Right</source>
          <target state="translated">Alt+&amp;rarr;,Right</target>
        </trans-unit>
        <trans-unit id="9a9d40973db0c2622dc620880dd806a2a7b074af" translate="yes" xml:space="preserve">
          <source>Alt+&amp;uarr;,Up</source>
          <target state="translated">Alt+&amp;uarr;,Up</target>
        </trans-unit>
        <trans-unit id="bfc455c2b3ba6cee557bc6d5bddcaae8ab6cd71e" translate="yes" xml:space="preserve">
          <source>Alt+.</source>
          <target state="translated">Alt+.</target>
        </trans-unit>
        <trans-unit id="3f1d49e2c9f7278fd80b98a77041a0c748cbc877" translate="yes" xml:space="preserve">
          <source>Alt+Backspace</source>
          <target state="translated">Alt+Backspace</target>
        </trans-unit>
        <trans-unit id="e03e0d826ab2903a1d279112bf254a834058b27f" translate="yes" xml:space="preserve">
          <source>Alt+D</source>
          <target state="translated">Alt+D</target>
        </trans-unit>
        <trans-unit id="abed54704141f2d3e51473ad15ab778fff8ad229" translate="yes" xml:space="preserve">
          <source>Alt+Enter</source>
          <target state="translated">Alt+Enter</target>
        </trans-unit>
        <trans-unit id="f71a3b249f291f22237bbbed38b8c6c692ef50ea" translate="yes" xml:space="preserve">
          <source>Alt+F</source>
          <target state="translated">Alt+F</target>
        </trans-unit>
        <trans-unit id="ef42947ea26232a62f96bc3b77c5d9938c972a74" translate="yes" xml:space="preserve">
          <source>Alt+Y</source>
          <target state="translated">Alt+Y</target>
        </trans-unit>
        <trans-unit id="42067d9d74bbc067847a30164e23954aca55ff0a" translate="yes" xml:space="preserve">
          <source>Alt+c</source>
          <target state="translated">Alt+c</target>
        </trans-unit>
        <trans-unit id="d73eff91bc5add0567a63c189cfc6a840240cc3a" translate="yes" xml:space="preserve">
          <source>Alt+d</source>
          <target state="translated">Alt+d</target>
        </trans-unit>
        <trans-unit id="356f2928c7cc628dc148ace42aaa5347a9043a00" translate="yes" xml:space="preserve">
          <source>Alt+e</source>
          <target state="translated">Alt+e</target>
        </trans-unit>
        <trans-unit id="a2008eaab718a2cbdba9a5b56cc0388211241a00" translate="yes" xml:space="preserve">
          <source>Alt+h</source>
          <target state="translated">Alt+h</target>
        </trans-unit>
        <trans-unit id="63b063c0b910fdda5527dc17ae1126ec12f233f4" translate="yes" xml:space="preserve">
          <source>Alt+l</source>
          <target state="translated">Alt+l</target>
        </trans-unit>
        <trans-unit id="412b6a19e71a5431a4a033717193f98cc5ab36f2" translate="yes" xml:space="preserve">
          <source>Alt+p</source>
          <target state="translated">Alt+p</target>
        </trans-unit>
        <trans-unit id="3f12597f24de2438c063ec57e52f94359d4653a6" translate="yes" xml:space="preserve">
          <source>Alt+s</source>
          <target state="translated">Alt+s</target>
        </trans-unit>
        <trans-unit id="7c8aea22d76a0fc0d599dcc9667d21c686685110" translate="yes" xml:space="preserve">
          <source>Alt+t</source>
          <target state="translated">Alt+t</target>
        </trans-unit>
        <trans-unit id="8d028f59d024b2c7c1586395af72b9b1deb565e4" translate="yes" xml:space="preserve">
          <source>Alt+u</source>
          <target state="translated">Alt+u</target>
        </trans-unit>
        <trans-unit id="cb3eeeb8ea5fb25aecee7d1b619b3e3d542195e4" translate="yes" xml:space="preserve">
          <source>Alt+v</source>
          <target state="translated">Alt+v</target>
        </trans-unit>
        <trans-unit id="f7d4868bcba598a1dee143a75725317cae61d6b2" translate="yes" xml:space="preserve">
          <source>Alt+w</source>
          <target state="translated">Alt+w</target>
        </trans-unit>
        <trans-unit id="91cf5d208f71238a675c3bfa07523a3c0bae8a90" translate="yes" xml:space="preserve">
          <source>Alternatively, use &lt;code&gt;test -n &quot;$var&quot;&lt;/code&gt;, but remember that &lt;strong&gt;the variable must be double-quoted&lt;/strong&gt;. For example, &lt;code&gt;if test -n &quot;$var&quot;; echo not empty; end&lt;/code&gt;. The &lt;code&gt;test&lt;/code&gt; command provides its own and (-a) and or (-o):</source>
          <target state="translated">또는 &lt;code&gt;test -n &quot;$var&quot;&lt;/code&gt; 을 사용하되 &lt;strong&gt;변수는 큰 따옴표로 묶어야&lt;/strong&gt; 합니다. 예를 들어, &lt;code&gt;if test -n &quot;$var&quot;; echo not empty; end&lt;/code&gt; . &lt;code&gt;test&lt;/code&gt; 명령을 제공하는 자사의 및 (-a) 및 또는 (-o) 자신의 :</target>
        </trans-unit>
        <trans-unit id="b83f5e1029e1f8968df11b5b3d40ca89fed19fcf" translate="yes" xml:space="preserve">
          <source>Always take care to add the &lt;code&gt;$argv&lt;/code&gt; variable to the list of parameters to the wrapped command. This makes sure that if the user specifies any additional parameters to the function, they are passed on to the underlying command.</source>
          <target state="translated">항상 &lt;code&gt;$argv&lt;/code&gt; 변수를 랩핑 된 명령의 매개 변수 목록에 추가하십시오 . 이를 통해 사용자가 함수에 추가 매개 변수를 지정하면 기본 명령으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f9ad26606a8f0efef47019531f3d0c942aac7413" translate="yes" xml:space="preserve">
          <source>An RGB value with three or six hex digits, such as A0FF33 or f2f can be used. &lt;code&gt;fish&lt;/code&gt; will choose the closest supported color. A three digit value is equivalent to specifying each digit twice; e.g., &lt;code&gt;set_color 2BC&lt;/code&gt; is the same as &lt;code&gt;set_color 22BBCC&lt;/code&gt;. Hexadecimal RGB values can be in lower or uppercase. Depending on the capabilities of your terminal (and the level of support &lt;code&gt;set_color&lt;/code&gt; has for it) the actual color may be approximated by a nearby matching reserved color name or &lt;code&gt;set_color&lt;/code&gt; may not have an effect on color.</source>
          <target state="translated">A0FF33 또는 f2f와 같이 3 자리 또는 6 자리 16 진수가있는 RGB 값을 사용할 수 있습니다. &lt;code&gt;fish&lt;/code&gt; 는 지원되는 가장 가까운 색상을 선택합니다. 3 자리 값은 각 숫자를 두 번 지정하는 것과 같습니다. 예를 들어 &lt;code&gt;set_color 2BC&lt;/code&gt; 는 &lt;code&gt;set_color 22BBCC&lt;/code&gt; 와 동일 합니다. 16 진수 RGB 값은 소문자 또는 대문자 일 수 있습니다. 터미널의 기능 (및 &lt;code&gt;set_color&lt;/code&gt; 에 대한 지원 수준 )에 따라 실제 색상은 근처에있는 일치하는 예약 된 색상 이름에 의해 근사화되거나 &lt;code&gt;set_color&lt;/code&gt; 가 색상에 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6698f2ed87e85285db0bd4dfe6d91201b04dda0" translate="yes" xml:space="preserve">
          <source>An RGB value with three or six hex digits, such as A0FF33 or f2f can be used. &lt;code&gt;fish&lt;/code&gt; will choose the closest supported color. A three digit value is equivalent to specifying each digit twice; e.g., &lt;code&gt;set_color 2BC&lt;/code&gt; is the same as &lt;code&gt;set_color 22BBCC&lt;/code&gt;. Hexadecimal RGB values can be in lower or uppercase. Depending on the capabilities of your terminal (and the level of support &lt;code&gt;set_color&lt;/code&gt; has for it) the actual color may be approximated by a nearby matching reserved color name or &lt;code&gt;set_color&lt;/code&gt; may not have an effect on color. A second color may be given as a desired fallback color. e.g. &lt;code&gt;set_color 124212&lt;/code&gt;&lt;em&gt;brblue&lt;/em&gt; will instruct set_color to use &lt;em&gt;brblue&lt;/em&gt; if a terminal is not capable of the exact shade of grey desired. This is very useful when an 8 or 16 color terminal might otherwise not use a color.</source>
          <target state="translated">A0FF33 또는 f2f와 같이 3 자리 또는 6 개의 16 진수가있는 RGB 값을 사용할 수 있습니다. &lt;code&gt;fish&lt;/code&gt; 는 가장 가까운 지원 색상을 선택합니다. 3 자리 숫자 값은 각 숫자를 두 번 지정하는 것과 같습니다. 예를 들어 &lt;code&gt;set_color 2BC&lt;/code&gt; 는 &lt;code&gt;set_color 22BBCC&lt;/code&gt; 와 동일 합니다. 16 진 RGB 값은 소문자 또는 대문자 일 수 있습니다. 터미널의 기능 (및 &lt;code&gt;set_color&lt;/code&gt; 의 지원 수준 )에 따라 실제 색상은 근처에 일치하는 예약 된 색상 이름에 의해 근사되거나 &lt;code&gt;set_color&lt;/code&gt; 는 색상에 영향을 미치지 않을 수 있습니다. 원하는 폴백 컬러로서 제 2 컬러가 주어질 수있다. 예 : &lt;code&gt;set_color 124212&lt;/code&gt; &lt;em&gt;brblue&lt;/em&gt; 는 set_color에 brblue를 사용하도록 &lt;em&gt;지시합니다.&lt;/em&gt;터미널이 원하는 정확한 회색 음영을 만들 수없는 경우 이것은 8 또는 16 색 터미널이 다른 색을 사용할 수 없을 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="42927afb9c7caf7b6c8ddab65a5441b4f933c6dc" translate="yes" xml:space="preserve">
          <source>An ampersand (&lt;code&gt;&amp;amp;&lt;/code&gt;) followed by the number of another file descriptor. The output will be written to that file descriptor instead.</source>
          <target state="translated">앰퍼샌드 ( &lt;code&gt;&amp;amp;&lt;/code&gt; ) 뒤에 다른 파일 설명자 번호가옵니다. 대신 출력이 해당 파일 설명자에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="f71943b897ee254dbdc1a97522da125ee417b99e" translate="yes" xml:space="preserve">
          <source>An ampersand followed by a minus sign (&lt;code&gt;&amp;amp;-&lt;/code&gt;). The file descriptor will be closed.</source>
          <target state="translated">앰퍼샌드 뒤에 빼기 부호 ( &lt;code&gt;&amp;amp;-&lt;/code&gt; )가 옵니다 . 파일 디스크립터가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="71cc88334bb3e92319c03d6549b247d60c760b50" translate="yes" xml:space="preserve">
          <source>An autoloaded function becomes available automatically to all running shells.</source>
          <target state="translated">자동로드 된 기능은 실행중인 모든 셸에서 자동으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feaaca65392fda02c163012d9378b2dddb326e82" translate="yes" xml:space="preserve">
          <source>An example of a file redirection is &lt;code&gt;echo hello &amp;gt; output.txt&lt;/code&gt;, which directs the output of the echo command to the file output.txt.</source>
          <target state="translated">파일 리디렉션의 예는 &lt;code&gt;echo hello &amp;gt; output.txt&lt;/code&gt; 이며 echo 명령의 출력을 output.txt 파일로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f69522f56e3535db80624669c313a99567b23650" translate="yes" xml:space="preserve">
          <source>And history too. Type a command once, and you can re-summon it by just typing a few letters</source>
          <target state="translated">그리고 역사도. 명령을 한 번 입력하면 몇 글자 만 입력하여 다시 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bcd9af34fdfabd4b79f9b66b86a1699d04abe42" translate="yes" xml:space="preserve">
          <source>And history too. Type a command once, and you can re-summon it by just typing a few letters:</source>
          <target state="translated">그리고 역사도. 명령을 한 번 입력하면 몇 글자 만 입력하면 다시 소환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b0fd5cdb40b4cfe992f552884b592eda469a0f9" translate="yes" xml:space="preserve">
          <source>And some other things:</source>
          <target state="translated">그리고 다른 것들 :</target>
        </trans-unit>
        <trans-unit id="561f19ae7fb03ebfc67b782db126853cbbf6f6cb" translate="yes" xml:space="preserve">
          <source>And these will exit non-zero:</source>
          <target state="translated">그리고 이들은 0이 아닌 것을 종료합니다 :</target>
        </trans-unit>
        <trans-unit id="b40c5f88db8dfb0b9bfe4851375485b84d5f21ba" translate="yes" xml:space="preserve">
          <source>And this will open a random picture from any of the subdirectories:</source>
          <target state="translated">그러면 하위 디렉토리에서 임의의 그림이 열립니다.</target>
        </trans-unit>
        <trans-unit id="362b56d716d77e953ca245a04fefe6fa04496b74" translate="yes" xml:space="preserve">
          <source>Any file descriptor can be directed to a different output than its default through a mechanism called a redirection.</source>
          <target state="translated">모든 파일 설명자는 리디렉션이라는 메커니즘을 통해 기본값과 다른 출력으로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8bcc5afa939d9420d0774b5e38828f941829c98" translate="yes" xml:space="preserve">
          <source>Any file descriptor can be directed to a different output than its default through a simple mechanism called a redirection.</source>
          <target state="translated">리디렉션이라고하는 간단한 메커니즘을 통해 모든 파일 설명자를 기본값과 다른 출력으로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2f3a230563fd5c0b1186bad49a4d25468f2d9d1" translate="yes" xml:space="preserve">
          <source>Any file descriptor can be redirected in an arbitrary way by prefixing the redirection with the file descriptor.</source>
          <target state="translated">모든 파일 디스크립터는 파일 디스크립터로 경로를 재지 정하여 임의의 방식으로 경로 재 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd5f97ddaa069aad021c1d2a9c338e699d7fb280" translate="yes" xml:space="preserve">
          <source>Any trailing newlines on the input are trimmed, just as with &lt;code&gt;&quot;$(cmd)&quot;&lt;/code&gt; substitution in sh. &lt;code&gt;--no-trim-newlines&lt;/code&gt; can be used to disable this behavior, which may be useful when running a command such as &lt;code&gt;set contents (cat filename | string collect -N)&lt;/code&gt;.</source>
          <target state="translated">sh의 &lt;code&gt;&quot;$(cmd)&quot;&lt;/code&gt; 대체 와 마찬가지로 입력의 모든 후행 줄 바꿈이 잘 립니다. &lt;code&gt;--no-trim-newlines&lt;/code&gt; 를 사용하여이 동작을 비활성화 할 수 있으며, 이는 &lt;code&gt;set contents (cat filename | string collect -N)&lt;/code&gt; 와 같은 명령을 실행할 때 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce2360486723d855cffc7d0ddbf62842f609b07" translate="yes" xml:space="preserve">
          <source>Arguments beginning with &lt;code&gt;-&lt;/code&gt; are normally interpreted as switches; &lt;code&gt;--&lt;/code&gt; causes the following arguments not to be treated as switches even if they begin with &lt;code&gt;-&lt;/code&gt;. Switches and required arguments are recognized only on the command line.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 로 시작하는 인수 는 일반적으로 스위치로 해석됩니다. &lt;code&gt;--&lt;/code&gt; 다음 인수가 &lt;code&gt;-&lt;/code&gt; 로 시작하더라도 스위치로 취급되지 않도록합니다 . 스위치와 필수 인수는 명령 줄에서만 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="043257e881ac5312780335efc43840ed60123921" translate="yes" xml:space="preserve">
          <source>As a convenience, the pipe &lt;code&gt;&amp;amp;|&lt;/code&gt; may be used to redirect both stdout and stderr to the same process. (Note this is different from bash, which uses &lt;code&gt;|&amp;amp;&lt;/code&gt;).</source>
          <target state="translated">편의상 파이프 &lt;code&gt;&amp;amp;|&lt;/code&gt; stdout과 stderr를 동일한 프로세스로 리디렉션하는 데 사용할 수 있습니다. (이것은 &lt;code&gt;|&amp;amp;&lt;/code&gt; 를 사용하는 bash와 다릅니다 ).</target>
        </trans-unit>
        <trans-unit id="65d7ac6db0a68a35b045c043f69d790c7693b8ae" translate="yes" xml:space="preserve">
          <source>As a convenience, the redirection &lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt; can be used to direct both stdout and stderr to the same file.</source>
          <target state="translated">편의상 리디렉션 &lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt; 를 사용하여 stdout과 stderr를 동일한 파일로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df3e5f4a2209f9a0c0df95a3cff184e572efda6a" translate="yes" xml:space="preserve">
          <source>As a more comprehensive example, here's a commented excerpt of the completions for systemd's &lt;code&gt;timedatectl&lt;/code&gt;:</source>
          <target state="translated">보다 포괄적 인 예로서, 여기 systemd의 &lt;code&gt;timedatectl&lt;/code&gt; 완료에 대한 주석 발췌 부분이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e5f5d858c5cb06f89afc2d8f5a2724a03bbce58" translate="yes" xml:space="preserve">
          <source>As a naming convention, exported variables are in uppercase and unexported variables are in lowercase.</source>
          <target state="translated">명명 규칙에 따라 내 보낸 변수는 대문자이고 내 보내지 않은 변수는 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="156a75280e065fb5a6b979a2a60062b81d648631" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;cd .&lt;/code&gt; is equivalent to &lt;code&gt;cd $PWD&lt;/code&gt;, which is useful in cases where a mountpoint has been recycled or a directory has been removed and recreated.</source>
          <target state="translated">특별한 경우 &lt;code&gt;cd .&lt;/code&gt; &lt;code&gt;cd $PWD&lt;/code&gt; 와 동일합니다 . 이는 마운트 포인트가 재활용되거나 디렉토리가 제거되어 재 작성된 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="473fe2640f48f2c3e356480b21727c05fe2a883f" translate="yes" xml:space="preserve">
          <source>As in any modern shell, the Up arrow,</source>
          <target state="translated">모든 현대 셸과 마찬가지로 위쪽 화살표,</target>
        </trans-unit>
        <trans-unit id="20487db156547ac9b0f8f6cda4758b76bf576cc9" translate="yes" xml:space="preserve">
          <source>As in any modern shell, the Up arrow, &lt;b&gt;&amp;uarr;&lt;/b&gt; recalls whole lines, starting from the last line executed. A single press replaces &quot;!!&quot;, later presses replace &quot;!-3&quot; and the like.</source>
          <target state="translated">현대 쉘에서와 같이 위쪽 화살표 ( &lt;b&gt;&amp;uarr;)&lt;/b&gt; 는 마지막 행부터 시작하여 전체 행을 &lt;b&gt;호출&lt;/b&gt; 합니다. 한 번의 누르기는 &quot;!!&quot;를 대체하고 나중에 누르는 것은 &quot;! -3&quot;등을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="67ab2336a0f60cb48a293dcf13625cec05689fb2" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;#tut_semicolon&quot;&gt;the section on the semicolon&lt;/a&gt;, this can also be written in multiple lines, like so:</source>
          <target state="translated">&lt;a href=&quot;#tut_semicolon&quot;&gt;세미콜론 섹션에서&lt;/a&gt; 언급했듯이 다음과 같이 여러 줄로 쓸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a52775e74dd1367202ccdfebc63ffe15c3fc2a94" translate="yes" xml:space="preserve">
          <source>Autoloading Functions</source>
          <target state="translated">자동 로딩 기능</target>
        </trans-unit>
        <trans-unit id="4824104c7854d679befc6d384e2b164a387c5851" translate="yes" xml:space="preserve">
          <source>Autoloading also won't work for &lt;a href=&quot;#event&quot;&gt;event handlers&lt;/a&gt;, since fish cannot know that a function is supposed to be executed when an event occurs when it hasn't yet loaded the function. See the &lt;a href=&quot;#event&quot;&gt;event handlers&lt;/a&gt; section for more information.</source>
          <target state="translated">이벤트가 아직 함수를로드하지 않았을 때 이벤트가 발생할 때 함수가 실행되어야한다는 것을 물고기가 알 수 없기 때문에 자동로드는 &lt;a href=&quot;#event&quot;&gt;이벤트 핸들러&lt;/a&gt; 에서도 작동 하지 않습니다. 자세한 정보는 &lt;a href=&quot;#event&quot;&gt;이벤트 핸들러&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="95c7d742338312cc72973984211afee4d64d688a" translate="yes" xml:space="preserve">
          <source>Autoloading functions</source>
          <target state="translated">자동 로딩 기능</target>
        </trans-unit>
        <trans-unit id="37ebd68a9ad79a75d4984b197d8be79759e981aa" translate="yes" xml:space="preserve">
          <source>Autoloading is not applicable to functions created by the &lt;code&gt;alias&lt;/code&gt; command. For functions simple enough that you prefer to use the &lt;code&gt;alias&lt;/code&gt; command to define them you'll need to put those commands in your &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt; script or some other script run when the shell starts.</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 명령으로 작성된 기능에는 자동 로딩을 적용 할 수 없습니다 . &lt;code&gt;alias&lt;/code&gt; 명령을 사용하여이를 정의하기 를 선호 할만큼 충분히 간단한 기능을 사용하려면 &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt; 스크립트 또는 쉘이 시작될 때 실행되는 다른 스크립트 에 해당 명령을 넣어야 합니다.</target>
        </trans-unit>
        <trans-unit id="220cc2eeb742925687ae3d99a850d4e272eba270" translate="yes" xml:space="preserve">
          <source>Autoloading isn't applicable to aliases. Since, by definition, the function is created at the time the alias command is executed. You cannot autoload aliases.</source>
          <target state="translated">자동로드는 별칭에 적용 할 수 없습니다. 정의에 따라 별명 명령이 실행될 때 함수가 작성되기 때문입니다. 별칭을 자동로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7833f645e87e9d8459033a17299c17f343cc6bd7" translate="yes" xml:space="preserve">
          <source>Automatically loaded functions cannot be removed using &lt;code&gt;functions -e&lt;/code&gt;. Either remove the definition file or change the $fish_function_path variable to remove autoloaded functions.</source>
          <target state="translated">&lt;code&gt;functions -e&lt;/code&gt; 사용하여 자동으로로드 된 기능을 제거 할 수 없습니다 . 정의 파일을 제거하거나 $ fish_function_path 변수를 변경하여 자동로드 된 기능을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="08b275b23c8db0abd0fd47a8278bb4a362d42dd2" translate="yes" xml:space="preserve">
          <source>Autosuggestions</source>
          <target state="translated">Autosuggestions</target>
        </trans-unit>
        <trans-unit id="a97c1fe699de2b5c57693a4ec6fbf5427cf3afca" translate="yes" xml:space="preserve">
          <source>Autosuggestions are a powerful way to quickly summon frequently entered commands, by typing the first few characters. They are also an efficient technique for navigating through directory hierarchies.</source>
          <target state="translated">자동 제안은 처음 몇 문자를 입력하여 자주 입력하는 명령을 빠르게 소환하는 강력한 방법입니다. 또한 디렉토리 계층 구조를 탐색하는 효율적인 기술입니다.</target>
        </trans-unit>
        <trans-unit id="efb359fec2a662dc1a33a02af7733ec339aa7947" translate="yes" xml:space="preserve">
          <source>Back to &lt;a href=&quot;index#toc-commands&quot;&gt;command index&lt;/a&gt;.</source>
          <target state="translated">위로 &lt;a href=&quot;index#toc-commands&quot;&gt;명령 인덱스&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6d421870c8ff86f5929b69f93de50dd0a6ad8a4" translate="yes" xml:space="preserve">
          <source>Background jobs</source>
          <target state="translated">백그라운드 작업</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="aef1ee8a9d6b03ca3f008e7820b03d1764d158f0" translate="yes" xml:space="preserve">
          <source>Be careful when you try to use braces to separate variable names from text. The problem shown above can be avoided by wrapping the variable in double quotes instead of braces (&lt;code&gt;echo &quot;$c&quot;word&lt;/code&gt;).</source>
          <target state="translated">중괄호를 사용하여 변수 이름을 텍스트와 구분하려고 할 때주의하십시오. 위에 표시된 문제는 변수를 중괄호 대신 큰 따옴표로 묶어 피할 수 있습니다 ( &lt;code&gt;echo &quot;$c&quot;word&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7feaea8ff9fd56c39af0c7242d19cfc491332827" translate="yes" xml:space="preserve">
          <source>Because history substitution is an awkward interface that was invented before interactive line editing was even possible. Fish drops it in favor of perfecting the interactive history recall interface. Switching requires a small change of habits: if you want to modify an old line/word, first recall it, then edit. E.g. don't type &quot;sudo !!&quot; - first press Up, then Home, then type &quot;sudo &quot;.</source>
          <target state="translated">히스토리 대체는 대화식 라인 편집이 가능하기 전에 발명 된 어색한 인터페이스이기 때문입니다. 물고기는 대화 형 기록 리콜 인터페이스를 완성하기 위해 그것을 떨어 뜨립니다. 전환하려면 약간의 습관이 필요합니다. 이전 줄 / 단어를 수정하려면 먼저 불러 온 후 편집하십시오. 예를 들어 &quot;sudo !!&quot;를 입력하지 마십시오 -먼저 위로를 누른 다음 홈을 누른 다음 &quot;sudo&quot;를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="6e2b48e7cf5a31dcb784896532986617c1886b80" translate="yes" xml:space="preserve">
          <source>Because this test is a shell builtin and not a standalone utility, using the -c flag on a special file descriptors like standard input and output may not return the same result when invoked from within a pipe as one would expect when invoking the &lt;code&gt;test&lt;/code&gt; utility in another shell.</source>
          <target state="translated">이 테스트는 독립형 유틸리티가 아닌 쉘 내장이기 때문에 표준 입력 및 출력과 같은 특수 파일 디스크립터에서 -c 플래그를 사용하면 파이프 내에서 호출 될 때 &lt;code&gt;test&lt;/code&gt; 유틸리티를 호출 할 때 예상하는 것과 동일한 결과를 리턴하지 않을 수 있습니다 . 다른 껍질.</target>
        </trans-unit>
        <trans-unit id="2c0a4626f95b4339163a76408544aca1706ad80a" translate="yes" xml:space="preserve">
          <source>Both command substitution and shell variable expansion support accessing only specific items by providing a set of indices in square brackets. It's often needed to access a sequence of elements. To do this, use the range operator '&lt;code&gt;..&lt;/code&gt;' for this. A range '&lt;code&gt;a..b&lt;/code&gt;', where range limits 'a' and 'b' are integer numbers, is expanded into a sequence of indices '&lt;code&gt;a a+1 a+2 ... b&lt;/code&gt;' or '&lt;code&gt;a a-1 a-2 ... b&lt;/code&gt;' depending on which of 'a' or 'b' is higher. The negative range limits are calculated from the end of the array or command substitution. Note that invalid indexes for either end are silently clamped to one or the size of the array as appropriate.</source>
          <target state="translated">명령 대체 및 쉘 변수 확장은 대괄호 안에 인덱스 세트를 제공하여 특정 항목에만 액세스 할 수 있도록 지원합니다. 일련의 요소에 액세스해야하는 경우가 종종 있습니다. 이렇게하려면 범위 연산자 ' &lt;code&gt;..&lt;/code&gt; '를 사용하십시오. 범위 한계 'a'와 'b'가 정수인 범위 ' &lt;code&gt;a..b&lt;/code&gt; '는 일련의 인덱스 ' &lt;code&gt;a a+1 a+2 ... b&lt;/code&gt; '또는 ' &lt;code&gt;a a-1 a-2 ... b&lt;/code&gt; '는'a '또는'b '중 더 높은 것에 따라 다릅니다. 음의 범위 한계는 배열의 끝 또는 명령 대체에서 계산됩니다. 한쪽 끝의 유효하지 않은 인덱스는 적절하게 배열의 크기 나 크기에 자동으로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="75ffa6a25ecf8db0b72541843389d9eaf8b53a19" translate="yes" xml:space="preserve">
          <source>Both integers and floating point numbers are supported.</source>
          <target state="translated">정수와 부동 소수점 숫자가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a427d5ed7ae29cac94543768854841dc58975513" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;replace&lt;/code&gt; subcommand support regular expressions when used with the &lt;code&gt;-r&lt;/code&gt; or &lt;code&gt;--regex&lt;/code&gt; option. The dialect is that of PCRE2.</source>
          <target state="translated">둘 다 &lt;code&gt;match&lt;/code&gt; 와 &lt;code&gt;replace&lt;/code&gt; 함께 사용하면 하위 명령 지원 정규 표현식을 &lt;code&gt;-r&lt;/code&gt; 또는 &lt;code&gt;--regex&lt;/code&gt; 옵션을 선택합니다. 방언은 PCRE2의 방언입니다.</target>
        </trans-unit>
        <trans-unit id="511cb46636e15b326ac52fc0e55d4fdd22eb3466" translate="yes" xml:space="preserve">
          <source>Brace expansion</source>
          <target state="translated">버팀대 확장</target>
        </trans-unit>
        <trans-unit id="b2b396ea7eca30ae26382239ecff257585cae7ee" translate="yes" xml:space="preserve">
          <source>Bracket expansion</source>
          <target state="translated">브래킷 확장</target>
        </trans-unit>
        <trans-unit id="b82bb93621eea3789efc2e789761d65a7d589377" translate="yes" xml:space="preserve">
          <source>Builtin commands</source>
          <target state="translated">내장 명령</target>
        </trans-unit>
        <trans-unit id="3d71f7e1b353d405d0ac11988a391e51c106c8d8" translate="yes" xml:space="preserve">
          <source>But this is not:</source>
          <target state="translated">그러나 이것은 아닙니다 :</target>
        </trans-unit>
        <trans-unit id="cde26bb231339705624e1a2606178650cfe6ce34" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;$fish_function_path&lt;/code&gt; contains the following:</source>
          <target state="translated">기본적으로 &lt;code&gt;$fish_function_path&lt;/code&gt; 에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="48c59a6753b3cfab58dea49a5311a9139ab88123" translate="yes" xml:space="preserve">
          <source>By default interactive commands are logged to &lt;code&gt;$XDG_DATA_HOME/fish/fish_history&lt;/code&gt; (typically &lt;code&gt;~/.local/share/fish/fish_history&lt;/code&gt;).</source>
          <target state="translated">기본적으로 대화식 명령은 &lt;code&gt;$XDG_DATA_HOME/fish/fish_history&lt;/code&gt; (일반적으로 &lt;code&gt;~/.local/share/fish/fish_history&lt;/code&gt; )에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="32d73806ca1d3aebeb76dd86671a3241e81f5c68" translate="yes" xml:space="preserve">
          <source>By default, Fish searches the following for completions, using the first available file that it finds:</source>
          <target state="translated">기본적으로 Fish는 찾은 첫 번째 사용 가능한 파일을 사용하여 다음을 완료합니다.</target>
        </trans-unit>
        <trans-unit id="0d8a923544fbc788e85068131f51c4e6a9993b6b" translate="yes" xml:space="preserve">
          <source>By default, Fish searches the following for functions, using the first available file that it finds:</source>
          <target state="translated">기본적으로 Fish는 사용 가능한 첫 번째 파일을 사용하여 다음 기능을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="59136d65df69881397a99de96dfa18d804e65129" translate="yes" xml:space="preserve">
          <source>By default, only the current branch is shown because &lt;code&gt;hg status&lt;/code&gt; can take be slow on large repository. You can enable a more informative prompt by setting the variable &lt;code&gt;$fish_prompt_hg_show_informative_status&lt;/code&gt;, for example:</source>
          <target state="translated">기본적 으로 큰 저장소 에서는 &lt;code&gt;hg status&lt;/code&gt; 가 느려질 수 있으므로 현재 분기 만 표시 됩니다. &lt;code&gt;$fish_prompt_hg_show_informative_status&lt;/code&gt; 변수를 설정하여 더 많은 정보를 제공하는 프롬프트를 활성화 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="315b1092a86cf296a40f2822b51753c337ac1521" translate="yes" xml:space="preserve">
          <source>By default, the output is as a float with trailing zeroes trimmed. To get a fixed representation, the &lt;code&gt;--scale&lt;/code&gt; option can be used, including &lt;code&gt;--scale=0&lt;/code&gt; for integer output.</source>
          <target state="translated">기본적으로 출력은 후행 0이 트림 된 부동 소수점입니다. 고정 표현을 얻으려면 정수 출력에 &lt;code&gt;--scale=0&lt;/code&gt; 을 포함 하여 &lt;code&gt;--scale&lt;/code&gt; 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72523c77472ad7835198f8fcd9e09a5badc11af9" translate="yes" xml:space="preserve">
          <source>By defining the &lt;code&gt;fish_breakpoint_prompt&lt;/code&gt; function, the user can choose a custom prompt when asking for input in response to a &lt;a href=&quot;breakpoint#cmd-breakpoint&quot;&gt;breakpoint&lt;/a&gt; command. The &lt;code&gt;fish_breakpoint_prompt&lt;/code&gt; function is executed when the prompt is to be shown, and the output is used as a prompt.</source>
          <target state="translated">&lt;code&gt;fish_breakpoint_prompt&lt;/code&gt; 함수 를 정의하면 사용자가 &lt;a href=&quot;breakpoint#cmd-breakpoint&quot;&gt;중단 점&lt;/a&gt; 명령 에 대한 응답으로 입력을 요청할 때 사용자 지정 프롬프트를 선택할 수 있습니다 . &lt;code&gt;fish_breakpoint_prompt&lt;/code&gt; 기능은 메시지가 표시 할 때 실행되고, 출력은 메시지로 사용된다.</target>
        </trans-unit>
        <trans-unit id="db7a1b873a6bb02030899acd0c28b71468ea0843" translate="yes" xml:space="preserve">
          <source>By defining the &lt;code&gt;fish_breakpoint_prompt&lt;/code&gt; function, the user can choose a custom prompt when asking for input in response to a &lt;code&gt;breakpoint&lt;/code&gt; command. The &lt;code&gt;fish_breakpoint_prompt&lt;/code&gt; function is executed when the prompt is to be shown, and the output is used as a prompt.</source>
          <target state="translated">&lt;code&gt;fish_breakpoint_prompt&lt;/code&gt; 함수 를 정의하여 사용자는 &lt;code&gt;breakpoint&lt;/code&gt; 명령 에 대한 응답으로 입력을 요청할 때 사용자 정의 프롬프트를 선택할 수 있습니다 . &lt;code&gt;fish_breakpoint_prompt&lt;/code&gt; 기능은 메시지가 표시 할 때 실행되고, 출력은 메시지로 사용된다.</target>
        </trans-unit>
        <trans-unit id="be6b595ea352dde32c38a4fa33c350b05d798766" translate="yes" xml:space="preserve">
          <source>By defining the &lt;code&gt;fish_prompt&lt;/code&gt; function, the user can choose a custom prompt. The &lt;code&gt;fish_prompt&lt;/code&gt; function is executed when the prompt is to be shown, and the output is used as a prompt.</source>
          <target state="translated">&lt;code&gt;fish_prompt&lt;/code&gt; 기능 을 정의하여 사용자는 사용자 정의 프롬프트를 선택할 수 있습니다. &lt;code&gt;fish_prompt&lt;/code&gt; 기능은 메시지가 표시 할 때 실행되고, 출력은 메시지로 사용된다.</target>
        </trans-unit>
        <trans-unit id="630303d4e2fa4b039b2b6a8e3e8b5957dc1783d2" translate="yes" xml:space="preserve">
          <source>By ending a command with the &lt;code&gt;&amp;amp;&lt;/code&gt; (ampersand) symbol, the user tells &lt;code&gt;fish&lt;/code&gt; to put the specified command into the background. A background process will be run simultaneous with &lt;code&gt;fish&lt;/code&gt;. &lt;code&gt;fish&lt;/code&gt; will retain control of the terminal, so the program will not be able to read from the keyboard.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; (앰퍼샌드) 기호 로 명령을 끝내면 사용자는 &lt;code&gt;fish&lt;/code&gt; 에게 지정된 명령을 백그라운드에 넣도록 지시합니다. 백그라운드 프로세스는 &lt;code&gt;fish&lt;/code&gt; 와 동시에 실행됩니다 . &lt;code&gt;fish&lt;/code&gt; 는 터미널의 제어권을 유지하므로 프로그램은 키보드에서 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3923f5578037b3542b2b19d15f49bde3629ec275" translate="yes" xml:space="preserve">
          <source>By inserting a backslash (&lt;code&gt;\&lt;/code&gt;) character before pressing the</source>
          <target state="translated">키를 누르기 전에 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 문자 를 삽입 하여</target>
        </trans-unit>
        <trans-unit id="02079690d5cebbe350c1aa5604a81e7a19265022" translate="yes" xml:space="preserve">
          <source>By inserting a backslash (&lt;code&gt;\&lt;/code&gt;) character before pressing the &lt;b&gt;Enter&lt;/b&gt; key, escaping the newline.</source>
          <target state="translated">&lt;b&gt;Enter&lt;/b&gt; 키 를 누르기 전에 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; ) 문자 를 삽입 하여 줄 바꿈을 피하십시오.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="82a4b7b090d106c959549d48fe03da459c91c544" translate="yes" xml:space="preserve">
          <source>By pressing</source>
          <target state="translated">눌러서</target>
        </trans-unit>
        <trans-unit id="5663475279a3c781c24c4811471a2f176e1db991" translate="yes" xml:space="preserve">
          <source>By pressing &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;uarr;&lt;/b&gt; and &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;darr;&lt;/b&gt;, a history search is also performed, but instead of searching for a complete commandline, each commandline is broken into separate elements just like it would be before execution, and the history is searched for an element matching that under the cursor.</source>
          <target state="translated">누르면 &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;&amp;uarr;&lt;/b&gt; 및 &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;&amp;darr;&lt;/b&gt; 이력 검색도으나 전체 커맨드를 검색의 수행을, 각각의 커맨드는 그 실행 전에 것처럼 별도의 요소로 분할되고, 기록이 소자 매칭 검색된 커서 아래에 있습니다.</target>
        </trans-unit>
        <trans-unit id="894ba850efc456224525f2c8a25b95199c183915" translate="yes" xml:space="preserve">
          <source>By pressing &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;Z&lt;/b&gt;, the user stops a currently running foreground program and returns control to &lt;code&gt;fish&lt;/code&gt;. Some programs do not support this feature, or remap it to another key. GNU Emacs uses &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;X&lt;/b&gt;&lt;b&gt;z&lt;/b&gt; to stop running.</source>
          <target state="translated">&lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;Z&lt;/b&gt; 를 누르면 사용자는 현재 실행중인 포 그라운드 프로그램을 중지하고 제어를 &lt;code&gt;fish&lt;/code&gt; 되돌 립니다. 일부 프로그램은이 기능을 지원하지 않거나 다른 키로 다시 매핑합니다. GNU Emacs는 &lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;X &lt;/b&gt;&lt;b&gt;z&lt;/b&gt; 를 사용 하여 실행을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="24eaf089af6a9daa271f7a6b0f06e6709ca1da8e" translate="yes" xml:space="preserve">
          <source>By using one of the event handler switches, a function can be made to run automatically at specific events. The user may generate new events using the &lt;a href=&quot;#emit&quot;&gt;emit&lt;/a&gt; builtin. Fish generates the following named events:</source>
          <target state="translated">이벤트 핸들러 스위치 중 하나를 사용하면 특정 이벤트에서 자동으로 기능을 실행할 수 있습니다. 사용자는 &lt;a href=&quot;#emit&quot;&gt;emit&lt;/a&gt; 내장 기능을 사용하여 새로운 이벤트를 생성 할 수 있습니다 . Fish는 다음과 같은 명명 된 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6a5c8721be6b4633186b4214510f8a5ef8c0f497" translate="yes" xml:space="preserve">
          <source>By using one of the event handler switches, a function can be made to run automatically at specific events. The user may generate new events using the &lt;a href=&quot;emit#cmd-emit&quot;&gt;emit&lt;/a&gt; builtin. Fish generates the following named events:</source>
          <target state="translated">이벤트 처리기 스위치 중 하나를 사용하여 특정 이벤트에서 자동으로 실행되도록 함수를 만들 수 있습니다. 사용자는 &lt;a href=&quot;emit#cmd-emit&quot;&gt;emit&lt;/a&gt; 내장을 사용하여 새로운 이벤트를 생성 할 수 있습니다 . Fish는 다음과 같은 명명 된 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="702f8fce2752414a6a80cd6a6df6d1f2e4852509" translate="yes" xml:space="preserve">
          <source>By using the &lt;a href=&quot;cmds/bg#cmd-bg&quot;&gt;bg&lt;/a&gt; and &lt;a href=&quot;cmds/fg#cmd-fg&quot;&gt;fg&lt;/a&gt; builtin commands, the user can send any currently running job into the foreground or background.</source>
          <target state="translated">사용하여 &lt;a href=&quot;cmds/bg#cmd-bg&quot;&gt;BG&lt;/a&gt; 와 &lt;a href=&quot;cmds/fg#cmd-fg&quot;&gt;FG&lt;/a&gt; 명령 내장을, 사용자는 전경 또는 배경으로 현재 실행중인 작업을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8da67926c227ce4e24b10b06e71944960277e706" translate="yes" xml:space="preserve">
          <source>By using the &lt;a href=&quot;commands#fg&quot;&gt;&lt;code&gt;fg&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;commands#bg&quot;&gt;&lt;code&gt;bg&lt;/code&gt;&lt;/a&gt; builtin commands, the user can send any currently running job into the foreground or background.</source>
          <target state="translated">&lt;a href=&quot;commands#fg&quot;&gt; &lt;code&gt;fg&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;commands#bg&quot;&gt; &lt;code&gt;bg&lt;/code&gt; &lt;/a&gt; 내장 명령 을 사용하면 현재 실행중인 작업을 포 그라운드 또는 백그라운드로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b6aff63c75bb0bffcdb7bfed5216e186365ff61" translate="yes" xml:space="preserve">
          <source>Cartesian Products</source>
          <target state="translated">직교 제품</target>
        </trans-unit>
        <trans-unit id="fcb3f81706967bbcb598dd0c3292965cf75b975f" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;fish&lt;/code&gt; to exit when</source>
          <target state="translated">다음과 같은 경우 &lt;code&gt;fish&lt;/code&gt; 가 빠져 나가게합니다.</target>
        </trans-unit>
        <trans-unit id="da6418309e4149798278c2a545077667f8bdc404" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;fish&lt;/code&gt; to exit when &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;D&lt;/b&gt; is pressed.</source>
          <target state="translated">원인 &lt;code&gt;fish&lt;/code&gt; 때 출구 &lt;em&gt;제어&lt;/em&gt; - &lt;b&gt;D를&lt;/b&gt; 누르면됩니다.</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="c8b1d49fdfd53112a6dec6dbd017336ac207e99e" translate="yes" xml:space="preserve">
          <source>Change the value of the variable &lt;code&gt;fish_greeting&lt;/code&gt; or create a &lt;code&gt;fish_greeting&lt;/code&gt; function. For example, to remove the greeting use:</source>
          <target state="translated">변수 &lt;code&gt;fish_greeting&lt;/code&gt; 의 값을 변경 하거나 &lt;code&gt;fish_greeting&lt;/code&gt; 함수를 작성하십시오 . 예를 들어 인사말을 제거하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f3de89fbff6985c921affb37ab3ad59fbe48b95c" translate="yes" xml:space="preserve">
          <source>Change your default shell to fish with:</source>
          <target state="translated">다음을 사용하여 기본 쉘을 생선으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="122ab61fb2390b34bf8bb07c44168363d5d992db" translate="yes" xml:space="preserve">
          <source>Character classes, some of the more important:</source>
          <target state="translated">캐릭터 클래스, 더 중요한 것 :</target>
        </trans-unit>
        <trans-unit id="837815e7e725405b61d99f890160135ef054c4ec" translate="yes" xml:space="preserve">
          <source>Colors used with &lt;code&gt;showcolorhints&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;showcolorhints&lt;/code&gt; 와 함께 사용되는 색상 :</target>
        </trans-unit>
        <trans-unit id="1aafc3262722e98fb6adb1e17c5cec1e303396d2" translate="yes" xml:space="preserve">
          <source>Combiners (And, Or, Not)</source>
          <target state="translated">결합기 (And, Or, Not)</target>
        </trans-unit>
        <trans-unit id="b6709a8adcdc85a8bf2a1db551231443bd8370ba" translate="yes" xml:space="preserve">
          <source>Combining different expansions</source>
          <target state="translated">다른 확장을 결합</target>
        </trans-unit>
        <trans-unit id="9625ac94507491a715e0ffe2602f1661a6b23708" translate="yes" xml:space="preserve">
          <source>Command Substitutions</source>
          <target state="translated">명령 대체</target>
        </trans-unit>
        <trans-unit id="83637571c7cadd0f3ed544a2316197ea7b780571" translate="yes" xml:space="preserve">
          <source>Command line editor</source>
          <target state="translated">명령 줄 편집기</target>
        </trans-unit>
        <trans-unit id="0bb0bf3bb5581e18abbaa7de52785c4cc0e3a748" translate="yes" xml:space="preserve">
          <source>Command mode</source>
          <target state="translated">명령 모드</target>
        </trans-unit>
        <trans-unit id="a2bd119306b51a92961511ebb58609c5dd727601" translate="yes" xml:space="preserve">
          <source>Command mode is also known as normal mode.</source>
          <target state="translated">명령 모드는 일반 모드라고도합니다.</target>
        </trans-unit>
        <trans-unit id="f0cab561b2d1b6a50046aaac51d5900407780ea5" translate="yes" xml:space="preserve">
          <source>Command reference</source>
          <target state="translated">명령 참조</target>
        </trans-unit>
        <trans-unit id="2bbdbfd618344aa7db88dfcb6076ec5fa368eb17" translate="yes" xml:space="preserve">
          <source>Command specific tab-completions in &lt;code&gt;fish&lt;/code&gt; are based on the notion of options and arguments. An option is a parameter which begins with a hyphen, such as '&lt;code&gt;-h&lt;/code&gt;', '&lt;code&gt;-help&lt;/code&gt;' or '&lt;code&gt;--help&lt;/code&gt;'. Arguments are parameters that do not begin with a hyphen. Fish recognizes three styles of options, the same styles as the GNU version of the getopt library. These styles are:</source>
          <target state="translated">&lt;code&gt;fish&lt;/code&gt; 명령 별 탭 완성 은 옵션과 인수의 개념을 기반으로합니다. 옵션은 ' &lt;code&gt;-h&lt;/code&gt; ', ' &lt;code&gt;-help&lt;/code&gt; '또는 ' &lt;code&gt;--help&lt;/code&gt; ' 와 같이 하이픈으로 시작하는 매개 변수입니다 . 인수는 하이픈으로 시작하지 않는 매개 변수입니다. Fish는 GNU 버전의 getopt 라이브러리와 동일한 스타일의 세 가지 옵션을 인식합니다. 이러한 스타일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="030d4685e9a5967e8a6f3c21ac5fdf12f5dd2ed5" translate="yes" xml:space="preserve">
          <source>Command substitution</source>
          <target state="translated">명령 대체</target>
        </trans-unit>
        <trans-unit id="530a1cffa7ec59af0b705c2ba3cd0b438869485e" translate="yes" xml:space="preserve">
          <source>Command substitutions</source>
          <target state="translated">명령 대체</target>
        </trans-unit>
        <trans-unit id="878863dedc3f406e3a65e48d9a354f6f067ef79a" translate="yes" xml:space="preserve">
          <source>Command substitutions are not expanded within quotes. Instead, you can temporarily close the quotes, add the command substitution, and reopen them, all in the same argument:</source>
          <target state="translated">명령 대체는 따옴표로 확장되지 않습니다. 대신, 따옴표를 임시로 닫고 명령 대체를 추가 한 후 다시 같은 인수로 다시 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71c192adcb09f8e5eb78adbae51c316308911f17" translate="yes" xml:space="preserve">
          <source>Command substitutions found in &lt;code&gt;OPTION_ARGUMENTS&lt;/code&gt; are not expected to return a space-separated list of arguments. Instead they must return a newline-separated list of arguments, and each argument may optionally have a tab character followed by the argument description. Any description provided in this way overrides a description given with &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;--description&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OPTION_ARGUMENTS&lt;/code&gt; 에 있는 명령 대체 는 공백으로 구분 된 인수 목록을 리턴하지 않습니다. 대신 개행으로 구분 된 인수 목록을 리턴해야하며, 각 인수는 선택적으로 탭 문자 뒤에 인수 설명이있을 수 있습니다. 이러한 방식으로 제공된 설명은 &lt;code&gt;-d&lt;/code&gt; 또는 &lt;code&gt;--description&lt;/code&gt; 과 함께 제공된 설명보다 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="874c75da73d00d89463a52a5b3bd6b12c296e9c3" translate="yes" xml:space="preserve">
          <source>Command substitutions use the output of one command as an argument to another. Unlike other shells, &lt;code&gt;fish&lt;/code&gt; does not use backticks ` for command substitutions. Instead, it uses parentheses:</source>
          <target state="translated">명령 대체는 한 명령의 출력을 다른 명령의 인수로 사용합니다. 다른 껍질과 달리 &lt;code&gt;fish&lt;/code&gt; 는 명령 대체에 백틱을 사용하지 않습니다. 대신 괄호를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a3571f5f1d40b027e13d061d92b54680b29bb7f2" translate="yes" xml:space="preserve">
          <source>Command substitutions use the output of one command as an argument to another. Unlike other shells, &lt;code&gt;fish&lt;/code&gt; does not use backticks `` for command substitutions. Instead, it uses parentheses:</source>
          <target state="translated">명령 대체는 한 명령의 출력을 다른 명령에 대한 인수로 사용합니다. 다른 셸과 달리 &lt;code&gt;fish&lt;/code&gt; 는 명령 대체에 백틱``을 사용하지 않습니다. 대신 괄호를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="45e5f3f72e961cb70134ba35f7a27a9620e515f7" translate="yes" xml:space="preserve">
          <source>Commands</source>
          <target state="translated">Commands</target>
        </trans-unit>
        <trans-unit id="bf9c7a7be3e1f3bbb8b332baec1b3308eba8941c" translate="yes" xml:space="preserve">
          <source>Commands and parameters are separated by the space character ' '. Every command ends with either a newline (i.e. by pressing the return key) or a semicolon '&lt;code&gt;;&lt;/code&gt;'. More than one command can be written on the same line by separating them with semicolons.</source>
          <target state="translated">명령과 매개 변수는 공백 문자 ''로 구분됩니다. 모든 명령은 개행 (즉, 리턴 키를 누름) 또는 세미콜론으로 끝나야합니다 &lt;code&gt;;&lt;/code&gt; '. 세미콜론으로 구분하여 같은 줄에 둘 이상의 명령을 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83546b9b7e63e4645609121c2d50d70ab2f8f27d" translate="yes" xml:space="preserve">
          <source>Commands and parameters are separated by the space character &lt;code&gt;' '&lt;/code&gt;. Every command ends with either a newline (i.e. by pressing the return key) or a semicolon '&lt;code&gt;;&lt;/code&gt;'. More than one command can be written on the same line by separating them with semicolons.</source>
          <target state="translated">명령과 매개 변수는 공백 문자 &lt;code&gt;' '&lt;/code&gt; 로 구분됩니다 . 모든 명령은 줄 바꿈 (즉, 리턴 키를 누름) 또는 세미콜론 ' &lt;code&gt;;&lt;/code&gt; '. 세미콜론으로 구분하여 동일한 행에 둘 이상의 명령을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c09ac3482bfc9b09262d71ce2a3754d63bdebcd" translate="yes" xml:space="preserve">
          <source>Commands can be chained with semicolons.</source>
          <target state="translated">세미콜론으로 명령을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7fc896ec27369aa3d8b46ed7bef7ce121078ca5" translate="yes" xml:space="preserve">
          <source>Comparison to other tools</source>
          <target state="translated">다른 도구와 비교</target>
        </trans-unit>
        <trans-unit id="7d648a6dff363974f754bb78876c2b10dadd8183" translate="yes" xml:space="preserve">
          <source>Compatibility notes</source>
          <target state="translated">호환성 노트</target>
        </trans-unit>
        <trans-unit id="af799f168326079cfa5fbcb1f17396cdcd478951" translate="yes" xml:space="preserve">
          <source>Completion of commands (builtins, functions and regular programs).</source>
          <target state="translated">명령 (내장, 기능 및 일반 프로그램) 완료</target>
        </trans-unit>
        <trans-unit id="e251e522a2899f0695ad97b7e9306c9baaf077df" translate="yes" xml:space="preserve">
          <source>Completion of filenames, even on strings with wildcards such as '&lt;code&gt;*&lt;/code&gt;' and '&lt;code&gt;**&lt;/code&gt;'.</source>
          <target state="translated">' &lt;code&gt;*&lt;/code&gt; '및 ' &lt;code&gt;**&lt;/code&gt; ' 와 같은 와일드 카드가있는 문자열에서도 파일 이름 완성 .</target>
        </trans-unit>
        <trans-unit id="3e42585f4a363d61f824319c2d4ccdcc434dd210" translate="yes" xml:space="preserve">
          <source>Completion of filenames, even on strings with wildcards such as '&lt;code&gt;*&lt;/code&gt;', '&lt;code&gt;**&lt;/code&gt;' and '&lt;code&gt;?&lt;/code&gt;'.</source>
          <target state="translated">' &lt;code&gt;*&lt;/code&gt; ', ' &lt;code&gt;**&lt;/code&gt; '및 ' 와 같은 와일드 카드가 포함 된 문자열에서도 파일 이름 완성 &lt;code&gt;?&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="9c40677954f135a6a56c9a9c3b9199834c1a73af" translate="yes" xml:space="preserve">
          <source>Completion of shell variable names.</source>
          <target state="translated">쉘 변수 이름 완성.</target>
        </trans-unit>
        <trans-unit id="15f1e262b91eabd8e311927699155dff284efc75" translate="yes" xml:space="preserve">
          <source>Completion of usernames for tilde expansion.</source>
          <target state="translated">물결표 확장을위한 사용자 이름 완성.</target>
        </trans-unit>
        <trans-unit id="8492522b516edbc0711ffad46d10e7abb03c888a" translate="yes" xml:space="preserve">
          <source>Completions automatically generated from the operating system's manual, usually stored in &lt;code&gt;~/.local/share/fish/generated_completions&lt;/code&gt;.</source>
          <target state="translated">운영 체제 설명서에서 자동으로 생성되며 일반적으로 &lt;code&gt;~/.local/share/fish/generated_completions&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e2bb22e8c63c3bc4092f861769d982ce94a1df7" translate="yes" xml:space="preserve">
          <source>Completions automatically generated from the operating system's manuals, usually stored in &lt;code&gt;~/.local/share/fish/generated_completions&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;~/.local/share/fish/generated_completions&lt;/code&gt; 에 저장되는 운영 체제 설명서에서 자동으로 생성 된 완성 입니다.</target>
        </trans-unit>
        <trans-unit id="77d31de015d4bc8d64c24ea654ff949d735a3c85" translate="yes" xml:space="preserve">
          <source>Completions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. Fish automatically searches through any directories in the array variable &lt;code&gt;$fish_complete_path&lt;/code&gt;, and any completions defined are automatically loaded when needed. A completion file must have a filename consisting of the name of the command to complete and the suffix '&lt;code&gt;.fish&lt;/code&gt;'.</source>
          <target state="translated">명령 줄이나 구성 파일에서 완료를 정의 할 수 있지만 자동으로로드 할 수도 있습니다. Fish는 배열 변수 &lt;code&gt;$fish_complete_path&lt;/code&gt; 의 디렉토리를 자동으로 검색하며 , 정의가 완료되면 필요할 때 자동으로로드됩니다. 완료 파일에는 완료 할 명령 이름과 접미사 ' &lt;code&gt;.fish&lt;/code&gt; ' 로 구성된 파일 이름이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e197b8e42b1affde93333b42e719ef94bc91d71d" translate="yes" xml:space="preserve">
          <source>Completions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. Fish automatically searches through any directories in the list variable &lt;code&gt;$fish_complete_path&lt;/code&gt;, and any completions defined are automatically loaded when needed. A completion file must have a filename consisting of the name of the command to complete and the suffix '&lt;code&gt;.fish&lt;/code&gt;'.</source>
          <target state="translated">완료는 명령 줄 또는 구성 파일에서 정의 할 수 있지만 자동으로로드 할 수도 있습니다. Fish는 목록 변수 &lt;code&gt;$fish_complete_path&lt;/code&gt; 의 모든 디렉토리를 자동으로 검색 하고 정의 된 모든 완료는 필요할 때 자동으로로드됩니다. 완료 파일에는 완료 할 명령의 이름과 접미사 ' &lt;code&gt;.fish&lt;/code&gt; ' 로 구성된 파일 이름이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7459a1dd314e140f10e2be4ec65979e72c902ac1" translate="yes" xml:space="preserve">
          <source>Conditional execution of code and flow control</source>
          <target state="translated">코드 및 흐름 제어의 조건부 실행</target>
        </trans-unit>
        <trans-unit id="0d5f4aeff7e3312bef6ba63f6a5b4ba1f78a94cb" translate="yes" xml:space="preserve">
          <source>Conditionals (If, Else, Switch)</source>
          <target state="translated">조건부 (If, Else, Switch)</target>
        </trans-unit>
        <trans-unit id="719fae22a2cd4fb971f775638bdd50f6e63161da" translate="yes" xml:space="preserve">
          <source>Configurable greeting</source>
          <target state="translated">구성 가능한 인사말</target>
        </trans-unit>
        <trans-unit id="f0b58e3b2ee0b9289c02bd1984243913025c6fa6" translate="yes" xml:space="preserve">
          <source>Configuration files are evaluated in the following order:</source>
          <target state="translated">구성 파일은 다음 순서로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="f4e0d62ab20b29e8432ac06936c92f52d1fc4b42" translate="yes" xml:space="preserve">
          <source>Configuration shipped with fish, which should not be edited, in &lt;code&gt;$__fish_data_dir/config.fish&lt;/code&gt; (usually &lt;code&gt;/usr/share/fish/config.fish&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;$__fish_data_dir/config.fish&lt;/code&gt; (보통 &lt;code&gt;/usr/share/fish/config.fish&lt;/code&gt; ) 에서 편집하지 말아야하는 fish와 함께 제공되는 구성 .</target>
        </trans-unit>
        <trans-unit id="22ff08f353e570d20e5a6366fd00500ccc60eb5a" translate="yes" xml:space="preserve">
          <source>Configuration snippets in files ending in &lt;code&gt;.fish&lt;/code&gt;, in the directories:</source>
          <target state="translated">디렉토리 에서 &lt;code&gt;.fish&lt;/code&gt; 로 끝나는 파일의 구성 스 니펫 :</target>
        </trans-unit>
        <trans-unit id="d916ac2852cd35aba927b6e5183496dfbb68f253" translate="yes" xml:space="preserve">
          <source>Consider, that &lt;code&gt;bash&lt;/code&gt; is also a command. With &lt;code&gt;man bash&lt;/code&gt; you can see that there are two ways to do this:</source>
          <target state="translated">&lt;code&gt;bash&lt;/code&gt; 도 명령 이라는 것을 고려하십시오 . &lt;code&gt;man bash&lt;/code&gt; 를 사용하면 이를 수행하는 두 가지 방법이 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="ff899dcd6f7ebd6a861299e03974633bfd5ad6eb" translate="yes" xml:space="preserve">
          <source>Control+A</source>
          <target state="translated">Control+A</target>
        </trans-unit>
        <trans-unit id="c9e55fac4bb2f73b8827737eba3f6fedb7f63ad3" translate="yes" xml:space="preserve">
          <source>Control+B</source>
          <target state="translated">Control+B</target>
        </trans-unit>
        <trans-unit id="e1e40212e505bb255ad247fb75a7c69252c1147c" translate="yes" xml:space="preserve">
          <source>Control+C</source>
          <target state="translated">Control+C</target>
        </trans-unit>
        <trans-unit id="7fad1011a56dea667e4e890b0f054b35b096ceac" translate="yes" xml:space="preserve">
          <source>Control+D</source>
          <target state="translated">Control+D</target>
        </trans-unit>
        <trans-unit id="8a337ce2c51c129c9e8bc692ea6dd78eba4574de" translate="yes" xml:space="preserve">
          <source>Control+E</source>
          <target state="translated">Control+E</target>
        </trans-unit>
        <trans-unit id="19d71b4677f714637e6947b67f44a1239e3ad114" translate="yes" xml:space="preserve">
          <source>Control+F</source>
          <target state="translated">Control+F</target>
        </trans-unit>
        <trans-unit id="de4ae039698d198c307859fcbedac2883a1d1f6c" translate="yes" xml:space="preserve">
          <source>Control+K</source>
          <target state="translated">Control+K</target>
        </trans-unit>
        <trans-unit id="b263435b368ba4e5650bd91db945e54b75f37e4b" translate="yes" xml:space="preserve">
          <source>Control+L</source>
          <target state="translated">Control+L</target>
        </trans-unit>
        <trans-unit id="d930468655a2e8de99ecf073632706dc9fd790c0" translate="yes" xml:space="preserve">
          <source>Control+N</source>
          <target state="translated">Control+N</target>
        </trans-unit>
        <trans-unit id="6f5e6052e453bf4cbc730651ad83bd4c9bf16d04" translate="yes" xml:space="preserve">
          <source>Control+P</source>
          <target state="translated">Control+P</target>
        </trans-unit>
        <trans-unit id="5d54970f5eafb4a1a71ec49ea17c31b605d918b7" translate="yes" xml:space="preserve">
          <source>Control+U</source>
          <target state="translated">Control+U</target>
        </trans-unit>
        <trans-unit id="f5ce6985615ea22bf239b5f5712adbd6c7392c11" translate="yes" xml:space="preserve">
          <source>Control+V</source>
          <target state="translated">Control+V</target>
        </trans-unit>
        <trans-unit id="1c73dbe8cbdd8b0d4324b844077a83d8b67ad535" translate="yes" xml:space="preserve">
          <source>Control+W</source>
          <target state="translated">Control+W</target>
        </trans-unit>
        <trans-unit id="c312ad573f898197b4f8b8123f1e8f824522fab2" translate="yes" xml:space="preserve">
          <source>Control+X</source>
          <target state="translated">Control+X</target>
        </trans-unit>
        <trans-unit id="232d7346f91b802a342b5f2452c2d1f067dcf48a" translate="yes" xml:space="preserve">
          <source>Control+Y</source>
          <target state="translated">Control+Y</target>
        </trans-unit>
        <trans-unit id="723f6bbc308bdf50335b19533e6f0eef28ea6810" translate="yes" xml:space="preserve">
          <source>Control+Z</source>
          <target state="translated">Control+Z</target>
        </trans-unit>
        <trans-unit id="6e141812a128e9ade7d8324a0d80b50782c0a03d" translate="yes" xml:space="preserve">
          <source>Control+t</source>
          <target state="translated">Control+t</target>
        </trans-unit>
        <trans-unit id="e3cc27f9da6f6edecf17e1636fab048c5c38faaf" translate="yes" xml:space="preserve">
          <source>Copy and paste (Kill Ring)</source>
          <target state="translated">복사하여 붙여 넣기 (킬 링)</target>
        </trans-unit>
        <trans-unit id="af4e866be52de67a1c27087ff82b1fd31d26bf20" translate="yes" xml:space="preserve">
          <source>Copy and paste from outside are also supported, both via the</source>
          <target state="translated">Copy and paste from outside are also supported, both via the</target>
        </trans-unit>
        <trans-unit id="26f56d23fbcc33866ced8719ced9441dcfe31145" translate="yes" xml:space="preserve">
          <source>Copy and paste from outside are also supported, both via the &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;X&lt;/b&gt; / &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;V&lt;/b&gt; bindings and via the terminal's paste function, for which fish enables &quot;Bracketed Paste Mode&quot;. When pasting inside single quotes, pasted single quotes and backslashes are automatically escaped so that the result can be used as a single token simply by closing the quote after.</source>
          <target state="translated">&lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;X&lt;/b&gt; / &lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;V&lt;/b&gt; 바인딩과 터미널의 붙여 넣기 기능을 통해 외부에서 복사 및 붙여 넣기가 지원되며, 물고기가 &quot;브래킷 붙여 넣기 모드&quot;를 활성화합니다. 작은 따옴표 안에 붙여 넣을 때 붙여 넣은 작은 따옴표와 백 슬래시는 자동으로 이스케이프되므로 나중에 따옴표를 닫아 결과를 단일 토큰으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f7dd81f0f257215aaa86927e90c28289f61b85c" translate="yes" xml:space="preserve">
          <source>Copying a function using &lt;code&gt;-c&lt;/code&gt; copies only the body of the function, and does not attach any event notifications from the original function.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 를 사용하여 함수를 복사하면 함수 의 본문 만 복사되고 원래 함수의 이벤트 알림은 첨부되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f31494e39f0bc5dcc83282298e8d3d31f1b25880" translate="yes" xml:space="preserve">
          <source>Customizing the name of the history file</source>
          <target state="translated">히스토리 파일 이름 사용자 정의</target>
        </trans-unit>
        <trans-unit id="362f967d51916d26cb3fb3386fd62a1f41da8b5f" translate="yes" xml:space="preserve">
          <source>Debugging fish scripts</source>
          <target state="translated">피쉬 스크립트 디버깅</target>
        </trans-unit>
        <trans-unit id="315274f3206d01a86dd78cefa7038f1b4d10af82" translate="yes" xml:space="preserve">
          <source>Default Shell</source>
          <target state="translated">Default Shell</target>
        </trans-unit>
        <trans-unit id="0d9b8d3822abc3f61828cee574cfdd15ad494e6d" translate="yes" xml:space="preserve">
          <source>Define a single option spec for the boolean help flag:</source>
          <target state="translated">부울 도움말 플래그에 대한 단일 옵션 스펙을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="e80de1e5ae488060e2716016f7f8aabdda0492f6" translate="yes" xml:space="preserve">
          <source>Defining aliases</source>
          <target state="translated">별칭 정의</target>
        </trans-unit>
        <trans-unit id="a248cf76417fc663be9470cb1f177b04a90df2b1" translate="yes" xml:space="preserve">
          <source>Defining an abbreviation with global scope is slightly faster than universal scope (which is the default). But in general you'll only want to use the global scope when defining abbreviations in a startup script like &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt; like this:</source>
          <target state="translated">전역 범위로 약어를 정의하는 것이 기본 범위 인 범용 범위보다 약간 빠릅니다. 그러나 일반적으로 &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt; 와 같은 시작 스크립트에서 약어를 정의 할 때 전역 범위 만 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="f6fdbe48dc54dd86f63097a03bd24094dedd713a" translate="yes" xml:space="preserve">
          <source>Delete</source>
          <target state="translated">Delete</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="59b035367211a9382930b2a4c13637dbc33c4f32" translate="yes" xml:space="preserve">
          <source>Design</source>
          <target state="translated">Design</target>
        </trans-unit>
        <trans-unit id="866bd39fb03e1e2606544d3942b36910500aff65" translate="yes" xml:space="preserve">
          <source>Detect support for italics, dim, reverse and other modes.</source>
          <target state="translated">Detect support for italics, dim, reverse and other modes.</target>
        </trans-unit>
        <trans-unit id="8d1bc9b98791a1beb71b16bbdb2e8e4cbe2fd1c7" translate="yes" xml:space="preserve">
          <source>Detected errors include:</source>
          <target state="translated">감지 된 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a6988a4d06cb28f2b88589d324d9330152ae8f40" translate="yes" xml:space="preserve">
          <source>Directories for third-party software vendors to ship their own completions for their software. Fish searches the directories in the &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; environment variable for a &lt;code&gt;fish/vendor_completions.d&lt;/code&gt; directory; if this variable is not defined, the default is usually to search &lt;code&gt;/usr/share/fish/vendor_completions.d&lt;/code&gt; and &lt;code&gt;/usr/local/share/fish/vendor_completions.d&lt;/code&gt;;</source>
          <target state="translated">Directories for third-party software vendors to ship their own completions for their software. Fish searches the directories in the &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; environment variable for a &lt;code&gt;fish/vendor_completions.d&lt;/code&gt; directory; if this variable is not defined, the default is usually to search &lt;code&gt;/usr/share/fish/vendor_completions.d&lt;/code&gt; and &lt;code&gt;/usr/local/share/fish/vendor_completions.d&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="aec9d653d04f24c3ef71638a5da336dde6f29983" translate="yes" xml:space="preserve">
          <source>Directories for third-party software vendors to ship their own configuration snippets for their software. Fish searches the directories in the &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; environment variable for a &lt;code&gt;fish/vendor_conf.d&lt;/code&gt; directory; if this variable is not defined, the default is usually to search &lt;code&gt;/usr/share/fish/vendor_conf.d&lt;/code&gt; and &lt;code&gt;/usr/local/share/fish/vendor_conf.d&lt;/code&gt;</source>
          <target state="translated">Directories for third-party software vendors to ship their own configuration snippets for their software. Fish searches the directories in the &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; environment variable for a &lt;code&gt;fish/vendor_conf.d&lt;/code&gt; directory; if this variable is not defined, the default is usually to search &lt;code&gt;/usr/share/fish/vendor_conf.d&lt;/code&gt; and &lt;code&gt;/usr/local/share/fish/vendor_conf.d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d75fce19d8009441f1839be94513635b011e4443" translate="yes" xml:space="preserve">
          <source>Directories for third-party software vendors to ship their own functions for their software. Fish searches the directories in the &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; environment variable for a &lt;code&gt;fish/vendor_functions.d&lt;/code&gt; directory; if this variable is not defined, the default is usually to search &lt;code&gt;/usr/share/fish/vendor_functions.d&lt;/code&gt; and &lt;code&gt;/usr/local/share/fish/vendor_functions.d&lt;/code&gt;.</source>
          <target state="translated">Directories for third-party software vendors to ship their own functions for their software. Fish searches the directories in the &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; environment variable for a &lt;code&gt;fish/vendor_functions.d&lt;/code&gt; directory; if this variable is not defined, the default is usually to search &lt;code&gt;/usr/share/fish/vendor_functions.d&lt;/code&gt; and &lt;code&gt;/usr/local/share/fish/vendor_functions.d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d9fcf2c0d627af5418ba7f9c21ee7f737ced69d" translate="yes" xml:space="preserve">
          <source>Do not append to universal variables in &lt;a href=&quot;#initialization&quot;&gt;config.fish&lt;/a&gt;, because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.</source>
          <target state="translated">Do not append to universal variables in &lt;a href=&quot;#initialization&quot;&gt;config.fish&lt;/a&gt;, because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.</target>
        </trans-unit>
        <trans-unit id="dee15571e38bfab40555f11f3b66434d50353195" translate="yes" xml:space="preserve">
          <source>Do not append to universal variables in &lt;a href=&quot;index#initialization&quot;&gt;config.fish&lt;/a&gt;, because these variables will then get longer with each new shell instance. Instead, simply set them once at the command line.</source>
          <target state="translated">&lt;a href=&quot;index#initialization&quot;&gt;config.fish의&lt;/a&gt; 범용 변수에는 추가하지 마십시오. 이러한 변수는 각각의 새 쉘 인스턴스마다 더 길어지기 때문입니다. 대신 명령 줄에서 한 번만 설정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="5fe4b6029ee0d921705a5109d21de883623ecfe4" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;case&lt;/code&gt; command is given one or more parameters. The first &lt;code&gt;case&lt;/code&gt; command with a parameter that matches the string specified in the switch command will be evaluated. &lt;code&gt;case&lt;/code&gt; parameters may contain wildcards. These need to be escaped or quoted in order to avoid regular wildcard expansion using filenames.</source>
          <target state="translated">각 &lt;code&gt;case&lt;/code&gt; 명령에는 하나 이상의 매개 변수가 제공됩니다. 첫번째 &lt;code&gt;case&lt;/code&gt; 스위치 명령에서 지정한 문자열과 일치 매개 변수를 가진 명령이 평가 될 것이다. &lt;code&gt;case&lt;/code&gt; 매개 변수에는 와일드 카드가 포함될 수 있습니다. 파일 이름을 사용하여 규칙적인 와일드 카드 확장을 피하려면 이스케이프 처리하거나 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="2376e9b5e9f26d5da46eadee722d0d85257f2173" translate="yes" xml:space="preserve">
          <source>Each OPTION_SPEC can be written in the domain specific language &lt;a href=&quot;#argparse-option-specs&quot;&gt;described below&lt;/a&gt; or created using the companion &lt;a href=&quot;#fish-opt&quot;&gt;&lt;code&gt;fish_opt&lt;/code&gt;&lt;/a&gt; command. All OPTION_SPECs must appear after any argparse flags and before the &lt;code&gt;--&lt;/code&gt; that separates them from the arguments to be parsed.</source>
          <target state="translated">각 OPTION_SPEC은 &lt;a href=&quot;#argparse-option-specs&quot;&gt;아래 설명 된&lt;/a&gt; 도메인 특정 언어로 작성되거나 동반 어 &lt;a href=&quot;#fish-opt&quot;&gt; &lt;code&gt;fish_opt&lt;/code&gt; &lt;/a&gt; 명령을 사용하여 작성할 수 있습니다 . 모든 OPTION_SPEC는 argparse 플래그 뒤에 그리고 구문 분석 할 인수와 구분 되는 &lt;code&gt;--&lt;/code&gt; 앞에 나타나야합니다 .</target>
        </trans-unit>
        <trans-unit id="ff6eefef0d522918fc2f6f5c0e0cbad0e9617574" translate="yes" xml:space="preserve">
          <source>Each abbreviation is stored in its own global or universal variable. The name consists of the prefix &lt;code&gt;_fish_abbr_&lt;/code&gt; followed by the WORD after being transformed by &lt;code&gt;string escape style=var&lt;/code&gt;. The WORD cannot contain a space but all other characters are legal.</source>
          <target state="translated">각 약어는 자체 전역 또는 범용 변수에 저장됩니다. 이름은 &lt;code&gt;string escape style=var&lt;/code&gt; 로 변환 된 후 접두사 &lt;code&gt;_fish_abbr_&lt;/code&gt; 와 WORD 로 구성됩니다 . WORD에는 공백이 포함될 수 없지만 다른 모든 문자는 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d74989fad97472ddc89cce17da864871ef77470f" translate="yes" xml:space="preserve">
          <source>Each option specification (&lt;code&gt;OPTION_SPEC&lt;/code&gt;) is written in the &lt;a href=&quot;#option-specifications&quot;&gt;domain specific language&lt;/a&gt; described below. All OPTION_SPECs must appear after any argparse flags and before the &lt;code&gt;--&lt;/code&gt; that separates them from the arguments to be parsed.</source>
          <target state="translated">Each option specification ( &lt;code&gt;OPTION_SPEC&lt;/code&gt; ) is written in the &lt;a href=&quot;#option-specifications&quot;&gt;domain specific language&lt;/a&gt; described below. All OPTION_SPECs must appear after any argparse flags and before the &lt;code&gt;--&lt;/code&gt; that separates them from the arguments to be parsed.</target>
        </trans-unit>
        <trans-unit id="0057637534d28604b43896d07253a1705495ce04" translate="yes" xml:space="preserve">
          <source>Each option specification is a string composed of</source>
          <target state="translated">각 옵션 사양은 다음과 같이 구성된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="6f81b2ad5664bf03465a7658ea6e8325e7d4da48" translate="yes" xml:space="preserve">
          <source>Each option that is seen in the ARG list will result in a var name of the form &lt;code&gt;_flag_X&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is the short flag letter and the long flag name. The OPTION_SPEC always requires a short flag even if it can't be used. So there will always be &lt;code&gt;_flag_X&lt;/code&gt; var set using the short flag letter if the corresponding short or long flag is seen. The long flag name var (e.g., &lt;code&gt;_flag_help&lt;/code&gt;) will only be defined, obviously, if the OPTION_SPEC includes a long flag name.</source>
          <target state="translated">ARG 목록에 표시되는 각 옵션은 &lt;code&gt;_flag_X&lt;/code&gt; 형식의 var 이름을 생성합니다 . 여기서 &lt;code&gt;X&lt;/code&gt; 는 짧은 플래그 문자 및 긴 플래그 이름입니다. OPTION_SPEC에는 사용할 수없는 경우에도 항상 짧은 플래그가 필요합니다. 따라서 해당 short 또는 long 플래그가 표시되면 short 플래그 문자를 사용하여 항상 &lt;code&gt;_flag_X&lt;/code&gt; var 세트가 있습니다. 긴 플래그 이름 var (예 : &lt;code&gt;_flag_help&lt;/code&gt; )는 OPTION_SPEC에 긴 플래그 이름이 포함 된 경우에만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="071ccbc08889857d3dcdf38731f768b6399d8db1" translate="yes" xml:space="preserve">
          <source>Edit the file &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt;, creating it if it does not exist (Note the leading period).</source>
          <target state="translated">&lt;code&gt;~/.config/fish/config.fish&lt;/code&gt; 파일을 편집하여 존재하지 않는 경우 파일을 작성하십시오 (선행 기간 참고).</target>
        </trans-unit>
        <trans-unit id="c2f792ffbea95a6ff2321be7a5cc814288648907" translate="yes" xml:space="preserve">
          <source>Emacs mode commands</source>
          <target state="translated">이맥스 모드 명령</target>
        </trans-unit>
        <trans-unit id="e37e0760e90e51eeb2c376daa6dc4d1540039d7b" translate="yes" xml:space="preserve">
          <source>Enable 24-bit (&quot;true-color&quot;) even if the $TERM entry only reports 256 colors. This includes modern xterm, VTE-based terminals like Gnome Terminal, Konsole and iTerm2.</source>
          <target state="translated">Enable 24-bit (&quot;true-color&quot;) even if the $TERM entry only reports 256 colors. This includes modern xterm, VTE-based terminals like Gnome Terminal, Konsole and iTerm2.</target>
        </trans-unit>
        <trans-unit id="f2e2f09ac368b8dd74db605df791dbefe19bfe80" translate="yes" xml:space="preserve">
          <source>Enable 256 colors if $TERM contains &quot;xterm&quot;, except for known exceptions (like MacOS 10.6 Terminal.app)</source>
          <target state="translated">Enable 256 colors if $TERM contains &quot;xterm&quot;, except for known exceptions (like MacOS 10.6 Terminal.app)</target>
        </trans-unit>
        <trans-unit id="a2bb9d34b8a1a79665858d354585cf147e0dee4e" translate="yes" xml:space="preserve">
          <source>End</source>
          <target state="translated">End</target>
        </trans-unit>
        <trans-unit id="2b9eceb7a86a9f577ef80586c5c1d7fde9ff493d" translate="yes" xml:space="preserve">
          <source>Enter</source>
          <target state="translated">Enter</target>
        </trans-unit>
        <trans-unit id="ec051ec1637eae870268ca59dd86fdb39e8d550c" translate="yes" xml:space="preserve">
          <source>Enter &lt;code&gt;exit&lt;/code&gt; to exit a fish shell:</source>
          <target state="translated">Enter &lt;code&gt;exit&lt;/code&gt; to exit a fish shell:</target>
        </trans-unit>
        <trans-unit id="7c9220e6e7b88faa6f56901c8353dec4b3544958" translate="yes" xml:space="preserve">
          <source>Enter &lt;code&gt;fish&lt;/code&gt; to start a fish shell:</source>
          <target state="translated">Enter &lt;code&gt;fish&lt;/code&gt; to start a fish shell:</target>
        </trans-unit>
        <trans-unit id="91cbf01f5e4c3a57e74bdd072bfdd05853b57d91" translate="yes" xml:space="preserve">
          <source>Environment variables such as &lt;code&gt;EDITOR&lt;/code&gt; or &lt;code&gt;TZ&lt;/code&gt; can be set universally using &lt;code&gt;set -Ux&lt;/code&gt;. However, if there is an environment variable already set before fish starts (such as by login scripts or system administrators), it is imported into fish as a global variable. The &lt;a href=&quot;index#variables-scope&quot;&gt;variable scopes&lt;/a&gt; are searched from the &quot;inside out&quot;, which means that local variables are checked first, followed by global variables, and finally universal variables.</source>
          <target state="translated">&lt;code&gt;EDITOR&lt;/code&gt; 또는 &lt;code&gt;TZ&lt;/code&gt; 와 같은 환경 변수 는 &lt;code&gt;set -Ux&lt;/code&gt; 를 사용하여 보편적으로 설정할 수 있습니다 . 그러나 물고기를 시작하기 전에 이미 설정 한 환경 변수가있는 경우 (예 : 로그인 스크립트 또는 시스템 관리자 등) 전역 변수로 물고기로 가져옵니다. &lt;a href=&quot;index#variables-scope&quot;&gt;변수 범위는&lt;/a&gt; 글로벌 변수, 마지막 변수 보편적이어서, 로컬 변수들이 먼저 선택되었는지 수단 &quot;뒤집어&quot;에서 검색한다.</target>
        </trans-unit>
        <trans-unit id="91fe509047635fbdbcb723577a02003cc2cfa678" translate="yes" xml:space="preserve">
          <source>Erase the &lt;code&gt;gco&lt;/code&gt; abbreviation.</source>
          <target state="translated">&lt;code&gt;gco&lt;/code&gt; 약어를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="3e13e2405c74a25265ee4e281ccf78feafc5234d" translate="yes" xml:space="preserve">
          <source>Escape Sequences</source>
          <target state="translated">이스케이프 시퀀스</target>
        </trans-unit>
        <trans-unit id="99b19a8ca89a3f1d945ac43f31bfc30845d9b033" translate="yes" xml:space="preserve">
          <source>Escaping characters</source>
          <target state="translated">이스케이프 문자</target>
        </trans-unit>
        <trans-unit id="b5df4081fbed4b9e32929d5db8ab7dee3db26c47" translate="yes" xml:space="preserve">
          <source>Especially powerful is the recursive wildcard ** which searches directories recursively:</source>
          <target state="translated">디렉토리를 재귀 적으로 검색하는 재귀 와일드 카드 **가 특히 강력합니다.</target>
        </trans-unit>
        <trans-unit id="23467b26d86b98db62af718c7193952aae1cc1d7" translate="yes" xml:space="preserve">
          <source>Event blocks should not be confused with code blocks, which are created with &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt;</source>
          <target state="translated">이벤트 블록을 코드 블록과 혼동해서는 안됩니다. 코드 블록은 &lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; 또는 &lt;code&gt;for&lt;/code&gt; 로 생성됩니다</target>
        </trans-unit>
        <trans-unit id="1d0a0bc46dabda5a6dbcf0a2f18e3e9acbc27ae7" translate="yes" xml:space="preserve">
          <source>Event handlers</source>
          <target state="translated">이벤트 핸들러</target>
        </trans-unit>
        <trans-unit id="f4b281b637c899622427e67191026015a7018908" translate="yes" xml:space="preserve">
          <source>Every program on your computer can be used as a command in &lt;code&gt;fish&lt;/code&gt;. If the program file is located in one of the directories in the &lt;a href=&quot;#path&quot;&gt;PATH&lt;/a&gt;, you can just use the name of the program to use it. Otherwise the whole filename, including the directory (like &lt;code&gt;/home/me/code/checkers/checkers&lt;/code&gt; or &lt;code&gt;../checkers&lt;/code&gt;) has to be used.</source>
          <target state="translated">Every program on your computer can be used as a command in &lt;code&gt;fish&lt;/code&gt; . If the program file is located in one of the directories in the &lt;a href=&quot;#path&quot;&gt;PATH&lt;/a&gt;, you can just use the name of the program to use it. Otherwise the whole filename, including the directory (like &lt;code&gt;/home/me/code/checkers/checkers&lt;/code&gt; or &lt;code&gt;../checkers&lt;/code&gt; ) has to be used.</target>
        </trans-unit>
        <trans-unit id="aa9019553b784d6ddae2179d0e63e658c8aaa8e2" translate="yes" xml:space="preserve">
          <source>Every program on your computer can be used as a command in &lt;code&gt;fish&lt;/code&gt;. If the program file is located in one of the directories in the &lt;a href=&quot;#variables-special&quot;&gt;&lt;code&gt;PATH&lt;/code&gt;&lt;/a&gt;, it is sufficient to type the name of the program to use it. Otherwise the whole filename, including the directory (like &lt;code&gt;/home/me/code/checkers/checkers&lt;/code&gt; or &lt;code&gt;../checkers&lt;/code&gt;) has to be used.</source>
          <target state="translated">컴퓨터의 모든 프로그램은 &lt;code&gt;fish&lt;/code&gt; 명령으로 사용할 수 있습니다 . 프로그램 파일이 &lt;a href=&quot;#variables-special&quot;&gt; &lt;code&gt;PATH&lt;/code&gt; &lt;/a&gt; 의 디렉토리 중 하나에있는 경우 , 사용하기 위해 프로그램 이름을 입력하면 충분합니다. 그렇지 않으면 디렉토리를 포함한 전체 파일 이름 (예 : &lt;code&gt;/home/me/code/checkers/checkers&lt;/code&gt; 또는 &lt;code&gt;../checkers&lt;/code&gt; )을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="0a06b9ff910c3b825724cca9441830ef76df9a35" translate="yes" xml:space="preserve">
          <source>Example OPTION_SPECs</source>
          <target state="translated">예 OPTION_SPEC</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="39080033040f19165a1f736af78b4c8c529fc254" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;echo Hello 2&amp;gt;output.stderr&lt;/code&gt; writes the standard error (file descriptor 2) of the target program to &lt;code&gt;output.stderr&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;echo Hello 2&amp;gt;output.stderr&lt;/code&gt; 상기 대상 프로그램의 표준 오차 (파일 기술자 2) 글 &lt;code&gt;output.stderr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="c8110d9d9732f81a1889221cf14a72d9940e55f1" translate="yes" xml:space="preserve">
          <source>Examples: The default &lt;code&gt;fish&lt;/code&gt; title is</source>
          <target state="translated">예 : 기본 &lt;code&gt;fish&lt;/code&gt; 제목은</target>
        </trans-unit>
        <trans-unit id="c5e62bdf9f1ee420f1e3180e55a6897fe87ce1fa" translate="yes" xml:space="preserve">
          <source>Examples: The default &lt;code&gt;fish&lt;/code&gt; title is:</source>
          <target state="translated">Examples: The default &lt;code&gt;fish&lt;/code&gt; title is:</target>
        </trans-unit>
        <trans-unit id="4bdd412ed55970d8c42f39658c01cd285bb57d07" translate="yes" xml:space="preserve">
          <source>Executing Bash</source>
          <target state="translated">Executing Bash</target>
        </trans-unit>
        <trans-unit id="6f147bbcdc2ea57f6c81bec669ec536b253dc54b" translate="yes" xml:space="preserve">
          <source>Exit Status</source>
          <target state="translated">종료 상태</target>
        </trans-unit>
        <trans-unit id="1065b589e5e0ae74c7584c46d689bcbb003ff11c" translate="yes" xml:space="preserve">
          <source>Exit status: 0 if at least one match was found, or 1 otherwise.</source>
          <target state="translated">종료 상태 : 일치하는 항목이 하나 이상 있으면 0, 그렇지 않으면 1</target>
        </trans-unit>
        <trans-unit id="b2909c6aa462276dc2976f4590aa354f4c57270d" translate="yes" xml:space="preserve">
          <source>Exit status: 0 if at least one replacement was performed, or 1 otherwise.</source>
          <target state="translated">종료 상태 : 하나 이상의 교체가 수행 된 경우 0, 그렇지 않은 경우 1</target>
        </trans-unit>
        <trans-unit id="f40c28bc81b3ac548eb788aebd329d84f2e392e8" translate="yes" xml:space="preserve">
          <source>Expansions are performed from right to left, nested bracket expansions are performed from the inside and out.</source>
          <target state="translated">확장은 오른쪽에서 왼쪽으로 수행되고 중첩 된 브래킷 확장은 내부 및 외부에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7c7f2508b14ff7696fb2b861af3336c89a128135" translate="yes" xml:space="preserve">
          <source>Exporting variables</source>
          <target state="translated">변수 내보내기</target>
        </trans-unit>
        <trans-unit id="0801a7e9fc76ea024d7fa1606839a9a450923131" translate="yes" xml:space="preserve">
          <source>Exports (Shell Variables)</source>
          <target state="translated">수출 (쉘 변수)</target>
        </trans-unit>
        <trans-unit id="38a8db4fbe3933a6a062a148af12ac9a1f3f9209" translate="yes" xml:space="preserve">
          <source>Expressions can be grouped using parentheses.</source>
          <target state="translated">괄호를 사용하여 표현식을 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50167d66b3a9cf84672e9543b5e003cb2f61fc18" translate="yes" xml:space="preserve">
          <source>Expressions can be inverted using the &lt;code&gt;!&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; 를 사용하여 식을 반전시킬 수 있습니다 . 운영자:</target>
        </trans-unit>
        <trans-unit id="88bfad9cfffeafd299a44d4daf979d57419a2621" translate="yes" xml:space="preserve">
          <source>F1</source>
          <target state="translated">F1</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="3c018849599639ed880ecf71dd0372a59354f058" translate="yes" xml:space="preserve">
          <source>Feature flags are how fish stages changes that might break scripts. Breaking changes are introduced as opt-in, in a few releases they become opt-out, and eventually the old behavior is removed.</source>
          <target state="translated">기능 플래그는 스크립트를 손상시킬 수있는 어류 단계 변경 방법입니다. 주요 변경 사항은 옵트 인 (opt-in)으로 도입되고, 일부 릴리스에서는 옵트 아웃 (opt-out)되고 결국 이전 동작이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="91eda957829d54470152a860d403a0c2ec63f6ad" translate="yes" xml:space="preserve">
          <source>Features will only be set on startup, so this variable will only take effect if it is universal or exported.</source>
          <target state="translated">Features will only be set on startup, so this variable will only take effect if it is universal or exported.</target>
        </trans-unit>
        <trans-unit id="6f3b1d58c2c3684624549238c3096df48948b49f" translate="yes" xml:space="preserve">
          <source>File names beginning with a dot are not considered when wildcarding unless a dot is specifically given as the first character of the file name.</source>
          <target state="translated">점이 파일 이름의 첫 문자로 특별히 지정되지 않으면 와일드 카드를 사용할 때 점으로 시작하는 파일 이름은 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af0ad57826714745555d33e260f6c852d7a62f1f" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;$fish_prompt_hg_status_order&lt;/code&gt;, which can be used to change the order the status symbols appear in. It defaults to &lt;code&gt;added modified copied deleted untracked unmerged&lt;/code&gt;.</source>
          <target state="translated">Finally, &lt;code&gt;$fish_prompt_hg_status_order&lt;/code&gt; , which can be used to change the order the status symbols appear in. It defaults to &lt;code&gt;added modified copied deleted untracked unmerged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3030e8ec7633ec1a524bb246aee7dbda6fb3e4bc" translate="yes" xml:space="preserve">
          <source>Fish</source>
          <target state="translated">Fish</target>
        </trans-unit>
        <trans-unit id="5909556c20378f696dc6b5d2bbc3049c7584a774" translate="yes" xml:space="preserve">
          <source>Fish 1.x and 2.x releases relied on the &lt;code&gt;bc&lt;/code&gt; command for handling &lt;code&gt;math&lt;/code&gt; expressions. Starting with fish 3.0.0 fish uses the tinyexpr library and evaluates the expression without the involvement of any external commands.</source>
          <target state="translated">Fish 1.x 및 2.x 릴리스는 &lt;code&gt;math&lt;/code&gt; 표현식 처리를 위해 &lt;code&gt;bc&lt;/code&gt; 명령을 사용했습니다 . fish 3.0.0부터 fish는 tinyexpr 라이브러리를 사용하고 외부 명령을 사용하지 않고 표현을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="d4a3ceecfb0465a0d21d2606941b69ac151cca20" translate="yes" xml:space="preserve">
          <source>Fish &lt;code&gt;ulimit&lt;/code&gt; does not support getting or setting multiple limits in one command, except reporting all values using the -a switch</source>
          <target state="translated">Fish &lt;code&gt;ulimit&lt;/code&gt; 는 -a 스위치를 사용하여 모든 값을보고하는 것을 제외하고 한 명령에서 여러 한계를 가져 오거나 설정하는 것을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6c6518383d134aea4779743a6d5eae0eb949f57" translate="yes" xml:space="preserve">
          <source>Fish &lt;code&gt;ulimit&lt;/code&gt; does not support getting or setting multiple limits in one command, except reporting all values using the &lt;code&gt;-a&lt;/code&gt; switch</source>
          <target state="translated">Fish &lt;code&gt;ulimit&lt;/code&gt; does not support getting or setting multiple limits in one command, except reporting all values using the &lt;code&gt;-a&lt;/code&gt; switch</target>
        </trans-unit>
        <trans-unit id="e7c76c63bac2f3a3dce3482676369a7bd163b6c4" translate="yes" xml:space="preserve">
          <source>Fish &lt;code&gt;ulimit&lt;/code&gt; does not support the &lt;code&gt;-p&lt;/code&gt; option for getting the pipe size. The bash implementation consists of a compile-time check that empirically guesses this number by writing to a pipe and waiting for SIGPIPE. Fish does not do this because it this method of determining pipe size is unreliable. Depending on bash version, there may also be further additional limits to set in bash that do not exist in fish.</source>
          <target state="translated">Fish &lt;code&gt;ulimit&lt;/code&gt; 는 파이프 크기를 얻기 위해 &lt;code&gt;-p&lt;/code&gt; 옵션을 지원하지 않습니다 . bash 구현은 파이프에 쓰고 SIGPIPE를 기다리면서이 숫자를 경험적으로 추측하는 컴파일 타임 검사로 구성됩니다. 물고기는 파이프 크기를 결정하는이 방법이 신뢰할 수 없기 때문에 이것을하지 않습니다. bash 버전에 따라 bash에 설정해야 할 추가 제한이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78c7f05d7bd695376d2e5d1faac7303134fd849d" translate="yes" xml:space="preserve">
          <source>Fish &lt;code&gt;ulimit&lt;/code&gt; supports GNU-style long options for all switches</source>
          <target state="translated">Fish &lt;code&gt;ulimit&lt;/code&gt; 는 모든 스위치에 대해 GNU 스타일의 긴 옵션을 지원합니다</target>
        </trans-unit>
        <trans-unit id="fc7af48505888290815037487d5b7785010a5982" translate="yes" xml:space="preserve">
          <source>Fish also ships a wrapper function around the builtin &lt;code&gt;cd&lt;/code&gt; that understands &lt;code&gt;cd -&lt;/code&gt; as changing to the previous directory. See also &lt;a href=&quot;commands#prevd&quot;&gt;&lt;code&gt;prevd&lt;/code&gt;&lt;/a&gt;. This wrapper function maintains a history of the 25 most recently visited directories in the &lt;code&gt;$dirprev&lt;/code&gt; and &lt;code&gt;$dirnext&lt;/code&gt; global variables. If you make those universal variables your &lt;code&gt;cd&lt;/code&gt; history is shared among all fish instances.</source>
          <target state="translated">내장의 래퍼 기능도 배를 물고기 &lt;code&gt;cd&lt;/code&gt; 이해 &lt;code&gt;cd -&lt;/code&gt; 이전 디렉토리로 변경한다. &lt;a href=&quot;commands#prevd&quot;&gt; &lt;code&gt;prevd&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 . 이 랩퍼 함수는 &lt;code&gt;$dirprev&lt;/code&gt; 및 &lt;code&gt;$dirnext&lt;/code&gt; 전역 변수 에서 가장 최근에 방문한 25 개의 디렉토리 히스토리를 유지 합니다. 이러한 범용 변수를 만들면 모든 기록에서 &lt;code&gt;cd&lt;/code&gt; 기록이 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="12b0ee984ffaac831e52ed6b850d4b525b13beed" translate="yes" xml:space="preserve">
          <source>Fish also ships a wrapper function around the builtin &lt;code&gt;cd&lt;/code&gt; that understands &lt;code&gt;cd -&lt;/code&gt; as changing to the previous directory. See also &lt;a href=&quot;prevd#cmd-prevd&quot;&gt;prevd&lt;/a&gt;. This wrapper function maintains a history of the 25 most recently visited directories in the &lt;code&gt;$dirprev&lt;/code&gt; and &lt;code&gt;$dirnext&lt;/code&gt; global variables. If you make those universal variables your &lt;code&gt;cd&lt;/code&gt; history is shared among all fish instances.</source>
          <target state="translated">Fish also ships a wrapper function around the builtin &lt;code&gt;cd&lt;/code&gt; that understands &lt;code&gt;cd -&lt;/code&gt; as changing to the previous directory. See also &lt;a href=&quot;prevd#cmd-prevd&quot;&gt;prevd&lt;/a&gt;. This wrapper function maintains a history of the 25 most recently visited directories in the &lt;code&gt;$dirprev&lt;/code&gt; and &lt;code&gt;$dirnext&lt;/code&gt; global variables. If you make those universal variables your &lt;code&gt;cd&lt;/code&gt; history is shared among all fish instances.</target>
        </trans-unit>
        <trans-unit id="8e7b1872333b58f5f95b5e7bec0c0e9e258507d3" translate="yes" xml:space="preserve">
          <source>Fish automatically searches through any directories in the array variable &lt;code&gt;$fish_function_path&lt;/code&gt;, and any functions defined are automatically loaded when needed. A function definition file must have a filename consisting of the name of the function plus the suffix '&lt;code&gt;.fish&lt;/code&gt;'.</source>
          <target state="translated">Fish는 배열 변수 &lt;code&gt;$fish_function_path&lt;/code&gt; 의 디렉토리를 자동으로 검색하며 , 정의 된 함수는 필요할 때 자동으로로드됩니다. 함수 정의 파일에는 함수 이름과 접미사 ' &lt;code&gt;.fish&lt;/code&gt; ' 로 구성된 파일 이름이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="fea3d198c56b137efabf4e3b3479e7ecb043e65b" translate="yes" xml:space="preserve">
          <source>Fish has a default limit of 10 MiB on the amount of data a command substitution can output. If the limit is exceeded the entire command, not just the substitution, is failed and &lt;code&gt;$status&lt;/code&gt; is set to 122. You can modify the limit by setting the &lt;code&gt;fish_read_limit&lt;/code&gt; variable at any time including in the environment before fish starts running. If you set it to zero then no limit is imposed. This is a safety mechanism to keep the shell from consuming too much memory if a command outputs an unreasonable amount of data. Note that this limit also affects how much data the &lt;code&gt;read&lt;/code&gt; command will process.</source>
          <target state="translated">피쉬는 명령 대체가 출력 할 수있는 데이터 양에 대해 기본 제한이 10MiB입니다. 한계가 대체뿐만 아니라 전체 명령을 초과하면 실패하고 &lt;code&gt;$status&lt;/code&gt; 는 122로 설정 됩니다. 물고기가 시작되기 전에 환경을 포함하여 언제든지 &lt;code&gt;fish_read_limit&lt;/code&gt; 변수를 설정하여 한계를 수정할 수 있습니다 . 0으로 설정하면 제한이 없습니다. 이것은 명령이 부당한 양의 데이터를 출력하는 경우 쉘이 너무 많은 메모리를 소비하지 않도록하는 안전 메커니즘입니다. 이 제한은 또한 &lt;code&gt;read&lt;/code&gt; 명령이 처리 할 데이터의 양에도 영향을 미칩니다 .</target>
        </trans-unit>
        <trans-unit id="54736c0f7b81ae71b6647b4c6a7582c080363c9c" translate="yes" xml:space="preserve">
          <source>Fish has a default limit of 100 MiB on the amount of data a command substitution can output. If the limit is exceeded the entire command, not just the substitution, is failed and &lt;code&gt;$status&lt;/code&gt; is set to 122. You can modify the limit by setting the &lt;code&gt;fish_read_limit&lt;/code&gt; variable at any time including in the environment before fish starts running. If you set it to zero then no limit is imposed. This is a safety mechanism to keep the shell from consuming too much memory if a command outputs an unreasonable amount of data, typically your operating system also has a limit, and it's often much lower. Note that this limit also affects how much data the &lt;code&gt;read&lt;/code&gt; command will process.</source>
          <target state="translated">Fish has a default limit of 100 MiB on the amount of data a command substitution can output. If the limit is exceeded the entire command, not just the substitution, is failed and &lt;code&gt;$status&lt;/code&gt; is set to 122. You can modify the limit by setting the &lt;code&gt;fish_read_limit&lt;/code&gt; variable at any time including in the environment before fish starts running. If you set it to zero then no limit is imposed. This is a safety mechanism to keep the shell from consuming too much memory if a command outputs an unreasonable amount of data, typically your operating system also has a limit, and it's often much lower. Note that this limit also affects how much data the &lt;code&gt;read&lt;/code&gt; command will process.</target>
        </trans-unit>
        <trans-unit id="7e69e47a187b17aecb51ad4dc34104e0787069fe" translate="yes" xml:space="preserve">
          <source>Fish history recall is very simple yet effective:</source>
          <target state="translated">물고기 이력 회상은 매우 간단하지만 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="edcb6e0e99c1d29dcec8762593402a5b7fe687c4" translate="yes" xml:space="preserve">
          <source>Fish includes a built in debugging facility. The debugger allows you to stop execution of a script at an arbitrary point. When this happens you are presented with an interactive prompt. At this prompt you can execute any fish command (there are no debug commands as such). For example, you can check or change the value of any variables using &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. As another example, you can run &lt;code&gt;status print-stack-trace&lt;/code&gt; to see how this breakpoint was reached. To resume normal execution of the script, simply type &lt;code&gt;exit&lt;/code&gt; or [ctrl-D].</source>
          <target state="translated">Fish에는 내장 된 디버깅 기능이 포함되어 있습니다. 디버거를 사용하면 임의의 시점에서 스크립트 실행을 중지 할 수 있습니다. 이 경우 대화식 프롬프트가 표시됩니다. 이 프롬프트에서 모든 피쉬 명령을 실행할 수 있습니다 (디버그 명령은 없습니다). 예를 들어, &lt;code&gt;printf&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 을 사용하여 변수 값을 확인하거나 변경할 수 있습니다 . 다른 예로, &lt;code&gt;status print-stack-trace&lt;/code&gt; 를 실행 하여이 중단 점에 도달 한 방법을 확인할 수 있습니다. 스크립트의 정상적인 실행을 재개하려면 &lt;code&gt;exit&lt;/code&gt; 또는 [ctrl-D]를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="c9861432c24cc69aa9bbe8d00780f47c35cceca6" translate="yes" xml:space="preserve">
          <source>Fish is trying to set the titlebar message of your terminal. While screen itself supports this feature, your terminal does not. Unfortunately, when the underlying terminal doesn't support setting the titlebar, screen simply passes through the escape codes and text to the underlying terminal instead of ignoring them. It is impossible to detect and resolve this problem from inside fish since fish has no way of knowing what the underlying terminal type is. For now, the only way to fix this is to unset the titlebar message, as suggested above.</source>
          <target state="translated">Fish가 터미널의 제목 표시 줄 메시지를 설정하려고합니다. 화면 자체는이 기능을 지원하지만 터미널은 지원하지 않습니다. 불행히도, 기본 터미널이 제목 표시 줄 설정을 지원하지 않는 경우, 화면은 단순히 이스케이프 코드와 텍스트를 무시하지 않고 기본 터미널로 전달합니다. 물고기는 기본 터미널 유형이 무엇인지 알 방법이 없기 때문에 물고기 내부에서이 문제를 감지하고 해결하는 것은 불가능합니다. 현재이 문제를 해결하는 유일한 방법은 위에서 제안한대로 제목 표시 줄 메시지를 설정 해제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="48abc65b03d1fc064fb747f8eca57f5ceb3027c8" translate="yes" xml:space="preserve">
          <source>Fish prides itself on being really nice to use interactively. That's down to a few features we'll explain in the next few sections.</source>
          <target state="translated">Fish prides itself on being really nice to use interactively. That's down to a few features we'll explain in the next few sections.</target>
        </trans-unit>
        <trans-unit id="3524f17824fc111784e6c17c1c783f4774ba70aa" translate="yes" xml:space="preserve">
          <source>Fish reserves the &lt;a href=&quot;http://www.unicode.org/faq/private_use.html&quot;&gt;Unicode private-use character range&lt;/a&gt; from U+F600 thru U+F73F for internal use. Any attempt to feed characters in that range to fish will result in them being replaced by the Unicode &quot;replacement character&quot; U+FFFD. This includes both interactive input as well as any file read by fish (but not programs run by fish).</source>
          <target state="translated">Fish 는 내부 용 U + F600부터 U + F73F까지 의 &lt;a href=&quot;http://www.unicode.org/faq/private_use.html&quot;&gt;유니 코드 개인용 문자 범위&lt;/a&gt; 를 예약합니다 . 해당 범위의 문자를 피쉬로 보내려고하면 유니 코드 &quot;대체 문자&quot;U + FFFD로 대체됩니다. 여기에는 대화 형 입력과 물고기가 읽는 파일이 포함됩니다 (물고기가 실행하는 프로그램은 아님).</target>
        </trans-unit>
        <trans-unit id="88f9fa16272ceb2f6496c15e10a64756c22612c9" translate="yes" xml:space="preserve">
          <source>Fish ships with a &lt;code&gt;_validate_int&lt;/code&gt; function that accepts a &lt;code&gt;--min&lt;/code&gt; and &lt;code&gt;--max&lt;/code&gt; flag. Let's say your command accepts a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;--max&lt;/code&gt; flag and the minimum allowable value is zero and the maximum is 5. You would define the option like this: &lt;code&gt;m/max=!_validate_int --min 0 --max 5&lt;/code&gt;. The default if you just call &lt;code&gt;_validate_int&lt;/code&gt; without those flags is to simply check that the value is a valid integer with no limits on the min or max value allowed.</source>
          <target state="translated">Fish 는 &lt;code&gt;--min&lt;/code&gt; 및 &lt;code&gt;--max&lt;/code&gt; 플래그 를 허용 하는 &lt;code&gt;_validate_int&lt;/code&gt; 함수 와 함께 제공됩니다 . 명령에 &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;--max&lt;/code&gt; 플래그를 허용하고 허용되는 최소값은 0이고 최대 값은 5입니다. &lt;code&gt;m/max=!_validate_int --min 0 --max 5&lt;/code&gt; 옵션을 정의합니다 . 이러한 플래그없이 &lt;code&gt;_validate_int&lt;/code&gt; 를 호출 하는 경우 기본값은 허용 된 최소값 또는 최대 값에 제한이없는 유효한 정수인지 간단히 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="da8d10a7f6f5ff6e0088c4b12f7c811ff075340b" translate="yes" xml:space="preserve">
          <source>Fish stores the exit status of the last process in the last job to exit in the &lt;code&gt;status&lt;/code&gt; variable.</source>
          <target state="translated">Fish는 마지막 작업의 마지막 프로세스 종료 상태를 &lt;code&gt;status&lt;/code&gt; 변수 에 종료 합니다.</target>
        </trans-unit>
        <trans-unit id="c7cac64314e5cd1f9679e120b4ee08809136ee30" translate="yes" xml:space="preserve">
          <source>Fish uses a heuristic to decide if a terminal supports the 256-color palette as opposed to the more limited 16 color palette of older terminals. Support can be forced on by setting &lt;code&gt;fish_term256&lt;/code&gt; to &lt;em&gt;1&lt;/em&gt;. If &lt;code&gt;$TERM&lt;/code&gt; contains &quot;256color&quot; (e.g., &lt;em&gt;xterm-256color&lt;/em&gt;), 256-color support is enabled. If &lt;code&gt;$TERM&lt;/code&gt; contains &lt;em&gt;xterm&lt;/em&gt;, 256 color support is enabled (except for MacOS: &lt;code&gt;$TERM_PROGRAM&lt;/code&gt; and &lt;code&gt;$TERM_PROGRAM_VERSION&lt;/code&gt; are used to detect Terminal.app from MacOS 10.6; support is disabled here it because it is known that it reports &lt;code&gt;xterm&lt;/code&gt; and only supports 16 colors.</source>
          <target state="translated">Fish는 휴리스틱을 사용하여 구형 터미널의 16 색 팔레트보다 제한된 256 색 팔레트를 지원하는지 여부를 결정합니다. &lt;code&gt;fish_term256&lt;/code&gt; 을 &lt;em&gt;1&lt;/em&gt; 로 설정하여 지원을 강제 할 수 있습니다 . &lt;code&gt;$TERM&lt;/code&gt; 에 &quot;256color&quot;가 포함 된 경우 (예 : &lt;em&gt;xterm-256color&lt;/em&gt; ) 256 색 지원이 활성화됩니다. &lt;code&gt;$TERM&lt;/code&gt; 에 &lt;em&gt;xterm이&lt;/em&gt; 포함 된 경우 256 색 지원이 활성화됩니다 (MacOS 제외 : &lt;code&gt;$TERM_PROGRAM&lt;/code&gt; 및 &lt;code&gt;$TERM_PROGRAM_VERSION&lt;/code&gt; 은 MacOS 10.6에서 Terminal.app을 감지하는 데 사용됨) &lt;code&gt;xterm&lt;/code&gt; 을보고 하고 16 색만 지원 한다는 것이 알려져 있기 때문에 지원이 비활성화됩니다. .</target>
        </trans-unit>
        <trans-unit id="c4a7c4e0f6011c5a6723f630fd3d21a3dda63de9" translate="yes" xml:space="preserve">
          <source>Fish uses some heuristics to determine what colors a terminal supports to avoid sending sequences that it won't understand.</source>
          <target state="translated">Fish uses some heuristics to determine what colors a terminal supports to avoid sending sequences that it won't understand.</target>
        </trans-unit>
        <trans-unit id="4a8a4a4f82444a104a993e27513d536247c816d1" translate="yes" xml:space="preserve">
          <source>Fish versions prior to 3.0 supported the syntax &lt;code&gt;set PATH[1] PATH[4] /bin /sbin&lt;/code&gt;, which worked like &lt;code&gt;set PATH[1 4] /bin /sbin&lt;/code&gt;. This syntax was not widely used, and was ambiguous and inconsistent.</source>
          <target state="translated">3.0 이전 버전 생선 구 지원 &lt;code&gt;set PATH[1] PATH[4] /bin /sbin&lt;/code&gt; 같이 일한 &lt;code&gt;set PATH[1 4] /bin /sbin&lt;/code&gt; . 이 구문은 널리 사용되지 않았으며 모호하고 일관성이 없었습니다.</target>
        </trans-unit>
        <trans-unit id="0d57bd5497ca26a92593094bf3e21c5097192fa3" translate="yes" xml:space="preserve">
          <source>Fisher</source>
          <target state="translated">Fisher</target>
        </trans-unit>
        <trans-unit id="cc39950b13a6699fa5b10206f558fe0ba567276b" translate="yes" xml:space="preserve">
          <source>Fisherman</source>
          <target state="translated">Fisherman</target>
        </trans-unit>
        <trans-unit id="cde1c030202177b2bb85ac304db8a66513736e41" translate="yes" xml:space="preserve">
          <source>Flag Value Validation</source>
          <target state="translated">플래그 값 검증</target>
        </trans-unit>
        <trans-unit id="536cf03606fa94ae7d859eed9d77e1d3116f6703" translate="yes" xml:space="preserve">
          <source>For a list of all builtins, functions and commands shipped with fish, see the &lt;a href=&quot;#toc-commands&quot;&gt;table of contents&lt;/a&gt;. The documentation is also available by using the &lt;code&gt;--help&lt;/code&gt; switch of the command.</source>
          <target state="translated">물고기와 함께 제공된 모든 내장, 기능 및 명령 목록 &lt;a href=&quot;#toc-commands&quot;&gt;은 목차를&lt;/a&gt; 참조하십시오 . 명령 의 &lt;code&gt;--help&lt;/code&gt; 스위치를 사용하여 설명서를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a673697effebecadd2ef2ada0c2ba216bf82e8c" translate="yes" xml:space="preserve">
          <source>For a list of all builtins, functions and commands shipped with fish, see the &lt;a href=&quot;https://fishshell.com/docs/3.1/commands.html#commands&quot;&gt;list of commands&lt;/a&gt;. The documentation is also available by using the &lt;code&gt;--help&lt;/code&gt; switch of the command.</source>
          <target state="translated">For a list of all builtins, functions and commands shipped with fish, see the &lt;a href=&quot;https://fishshell.com/docs/3.1/commands.html#commands&quot;&gt;list of commands&lt;/a&gt;. The documentation is also available by using the &lt;code&gt;--help&lt;/code&gt; switch of the command.</target>
        </trans-unit>
        <trans-unit id="9801e7760d7e9e8e7b2ff4da2f4e2bbcb3cd8d9c" translate="yes" xml:space="preserve">
          <source>For a script, written in another language, just replace the interpreter &lt;code&gt;/bin/bash&lt;/code&gt; with the language interpreter of that other language (for example &lt;code&gt;/bin/python&lt;/code&gt; for a &lt;code&gt;python&lt;/code&gt; script)</source>
          <target state="translated">For a script, written in another language, just replace the interpreter &lt;code&gt;/bin/bash&lt;/code&gt; with the language interpreter of that other language (for example &lt;code&gt;/bin/python&lt;/code&gt; for a &lt;code&gt;python&lt;/code&gt; script)</target>
        </trans-unit>
        <trans-unit id="3e1ee97cd1a141aa861292be516e6d2fafba3b56" translate="yes" xml:space="preserve">
          <source>For an introduction to specifying completions, see &lt;a href=&quot;../index#completion-own&quot;&gt;Writing your own completions&lt;/a&gt; in the fish manual.</source>
          <target state="translated">For an introduction to specifying completions, see &lt;a href=&quot;../index#completion-own&quot;&gt;Writing your own completions&lt;/a&gt; in the fish manual.</target>
        </trans-unit>
        <trans-unit id="aac657fdcd353fd4213af492e11d8fa1236e727e" translate="yes" xml:space="preserve">
          <source>For an introduction to specifying completions, see &lt;a href=&quot;index#completion-own&quot;&gt;Writing your own completions&lt;/a&gt; in the fish manual.</source>
          <target state="translated">완료를 지정하는 것에 대한 소개 는 물고기 매뉴얼에서 &lt;a href=&quot;index#completion-own&quot;&gt;자신의 완료 쓰기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97f70256424cd43141b91b58c2edd81b6e14a061" translate="yes" xml:space="preserve">
          <source>For backwards compatibility each subcommand can also be specified as a long or short option. For example, rather than &lt;code&gt;status is-login&lt;/code&gt; you can type &lt;code&gt;status --is-login&lt;/code&gt;. The flag forms are deprecated and may be removed in a future release (but not before fish 3.0).</source>
          <target state="translated">이전 버전과의 호환성을 위해 각 하위 명령을 길거나 짧은 옵션으로 지정할 수도 있습니다. 예를 들어 &lt;code&gt;status is-login&lt;/code&gt; 대신 &lt;code&gt;status --is-login&lt;/code&gt; 을 입력 할 수 있습니다 . 플래그 양식은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 수 있습니다 (물고기 3.0 이전은 아님).</target>
        </trans-unit>
        <trans-unit id="71cbfbc301ab062537c3b9d9149d9aa54102b0b9" translate="yes" xml:space="preserve">
          <source>For basic compatibility with POSIX &lt;code&gt;command&lt;/code&gt;, the &lt;code&gt;-v&lt;/code&gt; flag is recognized as an alias for &lt;code&gt;-s&lt;/code&gt;.</source>
          <target state="translated">POSIX &lt;code&gt;command&lt;/code&gt; 과의 기본 호환성을 위해 &lt;code&gt;-v&lt;/code&gt; 플래그는 &lt;code&gt;-s&lt;/code&gt; 의 별명으로 인식됩니다 .</target>
        </trans-unit>
        <trans-unit id="b73ea6d75946436551604661ce1b9a165a45dd07" translate="yes" xml:space="preserve">
          <source>For checking timing after a command has completed, check &lt;a href=&quot;../index#variables-special&quot;&gt;$CMD_DURATION&lt;/a&gt;.</source>
          <target state="translated">For checking timing after a command has completed, check &lt;a href=&quot;../index#variables-special&quot;&gt;$CMD_DURATION&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e40b055eb7098645342eba3f6a6c092eb71628f1" translate="yes" xml:space="preserve">
          <source>For compatibility with other shells and external commands, $PATH is a &lt;a href=&quot;index#variables-path&quot;&gt;path variable&lt;/a&gt;, and so will be joined with colons (not spaces) when you quote it:</source>
          <target state="translated">For compatibility with other shells and external commands, $PATH is a &lt;a href=&quot;index#variables-path&quot;&gt;path variable&lt;/a&gt;, and so will be joined with colons (not spaces) when you quote it:</target>
        </trans-unit>
        <trans-unit id="fa3cc4b28c62019a96ce74d02cd7c54d07452b42" translate="yes" xml:space="preserve">
          <source>For even more complex conditions, use &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; to group parts of them.</source>
          <target state="translated">더 복잡한 조건의 경우 &lt;code&gt;begin&lt;/code&gt; 과 &lt;code&gt;end&lt;/code&gt; 을 사용 하여 일부를 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="2ffbc75d40d5f17483c5a32a91dae37e401b6f2b" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;_flag_h&lt;/code&gt; and &lt;code&gt;_flag_help&lt;/code&gt; if &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; is seen. The var will be set with local scope (i.e., as if the script had done &lt;code&gt;set -l _flag_X&lt;/code&gt;). If the flag is a boolean (that is, does not have an associated value) the values are the short and long flags seen. If the option is not a boolean flag the values will be zero or more values corresponding to the values collected when the ARG list is processed. If the flag was not seen the flag var will not be set.</source>
          <target state="translated">예를 들어 , &lt;code&gt;-h&lt;/code&gt; 또는 &lt;code&gt;--help&lt;/code&gt; 가 표시 되면 &lt;code&gt;_flag_h&lt;/code&gt; 및 &lt;code&gt;_flag_help&lt;/code&gt; 입니다. var는 로컬 범위로 설정됩니다 (예 : 스크립트가 &lt;code&gt;set -l _flag_X&lt;/code&gt; 를 수행 한 것처럼 ). 플래그가 부울 인 경우 (즉, 연관된 값이없는 경우) 값은 짧고 긴 플래그입니다. 옵션이 부울 플래그가 아닌 경우 값은 ARG 목록이 처리 될 때 수집 된 값에 해당하는 0 이상의 값입니다. 플래그가 보이지 않으면 var 플래그가 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88a5cf27ff84d1f00030e64d1e499179b84cb53e" translate="yes" xml:space="preserve">
          <source>For example &lt;code&gt;_flag_h&lt;/code&gt; and &lt;code&gt;_flag_help&lt;/code&gt; if &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; is seen. The var will be set with local scope (i.e., as if the script had done &lt;code&gt;set -l _flag_X&lt;/code&gt;). If the flag is a boolean (that is, it just is passed or not, it doesn't have a value) the values are the short and long flags seen. If the option is not a boolean the values will be zero or more values corresponding to the values collected when the ARG list is processed. If the flag was not seen the flag var will not be set.</source>
          <target state="translated">For example &lt;code&gt;_flag_h&lt;/code&gt; and &lt;code&gt;_flag_help&lt;/code&gt; if &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; is seen. The var will be set with local scope (i.e., as if the script had done &lt;code&gt;set -l _flag_X&lt;/code&gt; ). If the flag is a boolean (that is, it just is passed or not, it doesn't have a value) the values are the short and long flags seen. If the option is not a boolean the values will be zero or more values corresponding to the values collected when the ARG list is processed. If the flag was not seen the flag var will not be set.</target>
        </trans-unit>
        <trans-unit id="160d44921b4e5cc1e46472871323748ab262c51c" translate="yes" xml:space="preserve">
          <source>For example, a frequently-run command like &lt;code&gt;git checkout&lt;/code&gt; can be abbreviated to &lt;code&gt;gco&lt;/code&gt;. After entering &lt;code&gt;gco&lt;/code&gt; and pressing</source>
          <target state="translated">For example, a frequently-run command like &lt;code&gt;git checkout&lt;/code&gt; can be abbreviated to &lt;code&gt;gco&lt;/code&gt; . After entering &lt;code&gt;gco&lt;/code&gt; and pressing</target>
        </trans-unit>
        <trans-unit id="38df69a183da9016b2103a1c9a7def1959322bfa" translate="yes" xml:space="preserve">
          <source>For example, a frequently-run command like &lt;code&gt;git checkout&lt;/code&gt; can be abbreviated to &lt;code&gt;gco&lt;/code&gt;. After entering &lt;code&gt;gco&lt;/code&gt; and pressing &lt;b&gt;Space&lt;/b&gt; or &lt;b&gt;Enter&lt;/b&gt;, the full text &lt;code&gt;git checkout&lt;/code&gt; will appear in the command line.</source>
          <target state="translated">예를 들어, &lt;code&gt;git checkout&lt;/code&gt; 과 같이 자주 실행되는 명령은 &lt;code&gt;gco&lt;/code&gt; 로 축약 될 수 있습니다 . &lt;code&gt;gco&lt;/code&gt; 를 입력 하고 &lt;b&gt;Space&lt;/b&gt; 또는 &lt;b&gt;Enter &lt;/b&gt;키 를 누르면 전체 텍스트 &lt;code&gt;git checkout&lt;/code&gt; 이 명령 행에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4f10862d2cb42eba3132cb49d2ba2a80e3864525" translate="yes" xml:space="preserve">
          <source>For example, if you wanted to have a function &lt;code&gt;ll&lt;/code&gt;, you would add a text file &lt;code&gt;ll.fish&lt;/code&gt; to &lt;code&gt;~/.config/fish/functions&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 함수 &lt;code&gt;ll&lt;/code&gt; 을 &lt;code&gt;ll.fish&lt;/code&gt; &lt;code&gt;~/.config/fish/functions&lt;/code&gt; 에 텍스트 파일 ll.fish 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="631584c9382e007cb93a95331a33fec25ea95d0e" translate="yes" xml:space="preserve">
          <source>For example, the following is a function definition that calls the command &lt;code&gt;ls&lt;/code&gt; with the argument '&lt;code&gt;-l&lt;/code&gt;' to print a detailed listing of the contents of the current directory:</source>
          <target state="translated">예를 들어, 다음은 ' &lt;code&gt;-l&lt;/code&gt; ' 인수와 함께 &lt;code&gt;ls&lt;/code&gt; 명령을 호출 하여 현재 디렉토리의 내용에 대한 자세한 목록을 인쇄하는 함수 정의입니다 .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b35e52823563d2df240637c363f5b52ee523904" translate="yes" xml:space="preserve">
          <source>For examples of how to write your own complex completions, study the completions in &lt;code&gt;/usr/share/fish/completions&lt;/code&gt;. (The exact path depends on your chosen installation prefix and may be slightly different)</source>
          <target state="translated">복잡한 완성을 작성하는 방법에 대한 예제는 &lt;code&gt;/usr/share/fish/completions&lt;/code&gt; 에서 완성을 연구하십시오 . (정확한 경로는 선택한 설치 접두사에 따라 다르며 약간 다를 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="29752c666ae89d90fd5950e78bb8db877998c7de" translate="yes" xml:space="preserve">
          <source>For for detailed instructions see &lt;a href=&quot;tutorial#switching-to-fish&quot;&gt;Switching to fish&lt;/a&gt;.</source>
          <target state="translated">For for detailed instructions see &lt;a href=&quot;tutorial#switching-to-fish&quot;&gt;Switching to fish&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="bbba6181daff6006d824b40726c5e1dc21c20696" translate="yes" xml:space="preserve">
          <source>For loops can be used to iterate over a list. For example, a list of files:</source>
          <target state="translated">For 루프를 사용하여 목록을 반복 할 수 있습니다. 예를 들어 파일 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb55b2efd75666ff0e0f22ca6189e759ca99212d" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;../index#debugging&quot;&gt;Debugging fish scripts&lt;/a&gt; in the &lt;code&gt;fish&lt;/code&gt; manual.</source>
          <target state="translated">For more details, see &lt;a href=&quot;../index#debugging&quot;&gt;Debugging fish scripts&lt;/a&gt; in the &lt;code&gt;fish&lt;/code&gt; manual.</target>
        </trans-unit>
        <trans-unit id="0d3b4b55cdd235f8a297cfd58fd2b4aaeb478949" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;index#debugging&quot;&gt;Debugging fish scripts&lt;/a&gt; in the &lt;code&gt;fish&lt;/code&gt; manual.</source>
          <target state="translated">자세한 내용 은 &lt;code&gt;fish&lt;/code&gt; 매뉴얼의 &lt;a href=&quot;index#debugging&quot;&gt;물고기 스크립트 디버깅을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20842f282aec1c4b50e206a47ffcf066ea5ca7ed" translate="yes" xml:space="preserve">
          <source>For more information on how to define new event handlers, see the documentation for the &lt;a href=&quot;cmds/function#cmd-function&quot;&gt;function&lt;/a&gt; command.</source>
          <target state="translated">For more information on how to define new event handlers, see the documentation for the &lt;a href=&quot;cmds/function#cmd-function&quot;&gt;function&lt;/a&gt; command.</target>
        </trans-unit>
        <trans-unit id="2fc141152e052520326e534bbd191caeb550504d" translate="yes" xml:space="preserve">
          <source>For more information on how to define new event handlers, see the documentation for the &lt;a href=&quot;commands#function&quot;&gt;function&lt;/a&gt; command.</source>
          <target state="translated">새 이벤트 핸들러를 정의하는 방법에 대한 자세한 내용은 &lt;a href=&quot;commands#function&quot;&gt;함수&lt;/a&gt; 명령 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6895247d91fcffa104e9a4003d47294a8b67a455" translate="yes" xml:space="preserve">
          <source>For more information, read the documentation for the block constructs, such as &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;.</source>
          <target state="translated">자세한 내용은, 예컨대, 블록 구조에 대한 문서를 읽을 &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; 및 &lt;code&gt;while&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="964a42e4fd350b97fcf46d3e0c75ca51851aa82c" translate="yes" xml:space="preserve">
          <source>For more information, see the documentation for each of the functions above.</source>
          <target state="translated">For more information, see the documentation for each of the functions above.</target>
        </trans-unit>
        <trans-unit id="b8d92b5c7148803c36e855152c078c15224a9486" translate="yes" xml:space="preserve">
          <source>For numbers, &lt;code&gt;.&lt;/code&gt; is always the radix character regardless of locale - &lt;code&gt;2.5&lt;/code&gt;, not &lt;code&gt;2,5&lt;/code&gt;. Scientific notation (&lt;code&gt;10e5&lt;/code&gt;) is also available.</source>
          <target state="translated">숫자의 경우 &lt;code&gt;.&lt;/code&gt; 로케일에 상관없이 항상 기수 문자 입니다. &lt;code&gt;2.5&lt;/code&gt; 는 아니고 &lt;code&gt;2,5&lt;/code&gt; 입니다. 과학적 표기법 ( &lt;code&gt;10e5&lt;/code&gt; )도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8e25112d09d08d00c25b607d90cd81a9a425781e" translate="yes" xml:space="preserve">
          <source>For uninstalling fish: see &lt;a href=&quot;faq#faq-uninstalling&quot;&gt;FAQ: Uninstalling fish&lt;/a&gt;.</source>
          <target state="translated">For uninstalling fish: see &lt;a href=&quot;faq#faq-uninstalling&quot;&gt;FAQ: Uninstalling fish&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="af90cef80988974dd76636b3adb5f472768f785d" translate="yes" xml:space="preserve">
          <source>Frequently asked questions</source>
          <target state="translated">자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="817a23516d79c9310b8cbcd3fbb553ae7f962425" translate="yes" xml:space="preserve">
          <source>From an interactive shell, the commands below exit with a return value of zero:</source>
          <target state="translated">대화식 쉘에서 아래 명령은 리턴 값 0으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="68add3d9773584e2619f672ebe5f9d4745e5e9ea" translate="yes" xml:space="preserve">
          <source>From now on, we'll pretend your prompt is just a '&lt;code&gt;&amp;gt;&lt;/code&gt;' to save space.</source>
          <target state="translated">이제부터는 공간을 절약하기 위해 프롬프트가 ' &lt;code&gt;&amp;gt;&lt;/code&gt; '인 것처럼 가장합니다 .</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="daf9c1f469f134e463969d3e8181e558bbde191a" translate="yes" xml:space="preserve">
          <source>Functions are programs written in the fish syntax. They group together one or more commands and their arguments using a single name. It can also be used to start a specific command with additional arguments.</source>
          <target state="translated">함수는 피쉬 구문으로 작성된 프로그램입니다. 단일 이름을 사용하여 하나 이상의 명령과 인수를 그룹화합니다. 추가 인수를 사용하여 특정 명령을 시작하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="89f90915711f79d63d40ae94fbe45e944677e599" translate="yes" xml:space="preserve">
          <source>Functions beginning with the string &lt;code&gt;__fish_print_&lt;/code&gt; print a newline separated list of strings. For example, &lt;code&gt;__fish_print_filesystems&lt;/code&gt; prints a list of all known file systems. Functions beginning with &lt;code&gt;__fish_complete_&lt;/code&gt; print out a newline separated list of completions with descriptions. The description is separated from the completion by a tab character.</source>
          <target state="translated">문자열 &lt;code&gt;__fish_print_&lt;/code&gt; 로 시작하는 함수 는 줄 바꿈으로 구분 된 문자열 목록을 인쇄합니다. 예를 들어 &lt;code&gt;__fish_print_filesystems&lt;/code&gt; 는 알려진 모든 파일 시스템의 목록을 인쇄합니다. &lt;code&gt;__fish_complete_&lt;/code&gt; 로 시작하는 함수 는 개행으로 구분 된 완료 목록을 설명과 함께 인쇄합니다. 설명은 완료와 탭 문자로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="db0f72339f2340e5e8b351628b140fc4b4a5095c" translate="yes" xml:space="preserve">
          <source>Functions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This has some advantages:</source>
          <target state="translated">Functions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This has some advantages:</target>
        </trans-unit>
        <trans-unit id="bfd6b853607d78b9cac90686ca5ac5f2f2bd0492" translate="yes" xml:space="preserve">
          <source>Functions can be defined on the commandline or in a configuration file, but they can also be automatically loaded. This method of defining functions has several advantages. An autoloaded function becomes available automatically to all running shells. If the function definition is changed, all running shells will automatically reload the altered version. Startup time and memory usage is improved, etc.</source>
          <target state="translated">명령 줄 또는 구성 파일에서 기능을 정의 할 수 있지만 자동으로로드 할 수도 있습니다. 이 함수 정의 방법에는 몇 가지 장점이 있습니다. 자동로드 기능은 실행중인 모든 쉘에서 자동으로 사용할 수있게됩니다. 함수 정의가 변경되면 실행중인 모든 셸이 변경된 버전을 자동으로 다시로드합니다. 시작 시간 및 메모리 사용량 등이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="45aaac446e8af8ab443ebb79de1921177d9fc9c4" translate="yes" xml:space="preserve">
          <source>Fundle</source>
          <target state="translated">Fundle</target>
        </trans-unit>
        <trans-unit id="1dbc937890de836b0044393faedad472b64f7496" translate="yes" xml:space="preserve">
          <source>Further help and development</source>
          <target state="translated">추가 도움 및 개발</target>
        </trans-unit>
        <trans-unit id="bcbbc69b089ac1c6106198168f95bbc56b4fa684" translate="yes" xml:space="preserve">
          <source>Future feature flags</source>
          <target state="translated">향후 기능 플래그</target>
        </trans-unit>
        <trans-unit id="3dc04827b1d89f032f341434dadfd4fcc6c503c2" translate="yes" xml:space="preserve">
          <source>GNU style long options, like '&lt;code&gt;--colors&lt;/code&gt;'. GNU style long options can be more than one character long, are preceded by two hyphens, and may not be grouped together. Option arguments may be specified in the following parameter ('&lt;code&gt;--quoting-style shell&lt;/code&gt;') or by appending the option with a '&lt;code&gt;=&lt;/code&gt;' and the value ('&lt;code&gt;--quoting-style=shell&lt;/code&gt;'). GNU style long options may be abbreviated so long as the abbreviation is unique ('&lt;code&gt;--h&lt;/code&gt;') is equivalent to '&lt;code&gt;--help&lt;/code&gt;' if help is the only long option beginning with an 'h').</source>
          <target state="translated">' &lt;code&gt;--colors&lt;/code&gt; ' 와 같은 GNU 스타일의 긴 옵션 . GNU 스타일의 long 옵션은 한 문자를 초과 할 수 있으며 앞에 두 개의 하이픈이 있으며 그룹화 할 수 없습니다. 옵션 인수는 다음 매개 변수 ( ' &lt;code&gt;--quoting-style shell&lt;/code&gt; ')에 지정하거나 옵션에 ' &lt;code&gt;=&lt;/code&gt; '및 값 ( ' &lt;code&gt;--quoting-style=shell&lt;/code&gt; ') 을 추가하여 지정할 수 있습니다. GNU 스타일의 긴 옵션은 약어가 고유 한 한 ( ' &lt;code&gt;--h&lt;/code&gt; ')가 'h'로 시작하는 유일한 긴 옵션 인 경우 ' &lt;code&gt;--help&lt;/code&gt; ' 와 동일 하다면 약어로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d19c496fc9fc5f17e29b156659c99fdebbdf355e" translate="yes" xml:space="preserve">
          <source>Get the length of a list with &lt;code&gt;count&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 가있는 목록의 길이를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9a0f73ca6aa746ede1e77153dd3bf5bb16e841ab" translate="yes" xml:space="preserve">
          <source>Getting Help</source>
          <target state="translated">도움을 받다</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="8eaa4a571cfa23b1046936adad07606e523f576d" translate="yes" xml:space="preserve">
          <source>Global variables are accessible to functions whether they are exported or not.</source>
          <target state="translated">Global variables are accessible to functions whether they are exported or not.</target>
        </trans-unit>
        <trans-unit id="14e54a9b9a49fb183045e69571e35c245eada9b8" translate="yes" xml:space="preserve">
          <source>Global variables are specific to the current fish session, but are not associated with any specific block scope, and will never be erased unless the user explicitly requests it using &lt;code&gt;set -e&lt;/code&gt;.</source>
          <target state="translated">Global variables are specific to the current fish session, but are not associated with any specific block scope, and will never be erased unless the user explicitly requests it using &lt;code&gt;set -e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="097b5d5320d0735796306d389e915b1392ea4a90" translate="yes" xml:space="preserve">
          <source>Groups:</source>
          <target state="translated">Groups:</target>
        </trans-unit>
        <trans-unit id="c47ae15370cfe1ed2781eedc1dc2547d12d9e972" translate="yes" xml:space="preserve">
          <source>Help</source>
          <target state="translated">Help</target>
        </trans-unit>
        <trans-unit id="0053f4880938c6ad45d9f6ae784ae7aa588de2e2" translate="yes" xml:space="preserve">
          <source>Help on a specific builtin can also be obtained with the &lt;code&gt;-h&lt;/code&gt; parameter. For instance, to obtain help on the &lt;code&gt;fg&lt;/code&gt; builtin, either type &lt;code&gt;fg -h&lt;/code&gt; or &lt;code&gt;help fg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-h&lt;/code&gt; 매개 변수 를 사용하여 특정 내장에 대한 도움말을 얻을 수도 있습니다 . 예를 들어 &lt;code&gt;fg&lt;/code&gt; 내장 에 대한 도움말을 보려면 &lt;code&gt;fg -h&lt;/code&gt; 또는 &lt;code&gt;help fg&lt;/code&gt; 를 입력 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f5d69f1e4fa9190f3df409c8af9094f4963c8a1" translate="yes" xml:space="preserve">
          <source>Here is a list of some useful commands:</source>
          <target state="translated">다음은 몇 가지 유용한 명령 목록입니다.</target>
        </trans-unit>
        <trans-unit id="59a0fbf9a4b62e6e15f7e7d04099ec292404a8c3" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;make&lt;/code&gt; is only executed if &lt;code&gt;./configure&lt;/code&gt; succeeds (returns 0), and &lt;code&gt;sudo make install&lt;/code&gt; is only executed if both &lt;code&gt;./configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; succeed.</source>
          <target state="translated">Here, &lt;code&gt;make&lt;/code&gt; is only executed if &lt;code&gt;./configure&lt;/code&gt; succeeds (returns 0), and &lt;code&gt;sudo make install&lt;/code&gt; is only executed if both &lt;code&gt;./configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; succeed.</target>
        </trans-unit>
        <trans-unit id="7a509c793438fa230f1278ed402f9c7e9018572d" translate="yes" xml:space="preserve">
          <source>History searches can be aborted by pressing the escape key.</source>
          <target state="translated">Esc 키를 눌러 기록 검색을 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67bc332b46b3f3dc1b8024a5e5cfdee70680168b" translate="yes" xml:space="preserve">
          <source>Hit tab again to cycle through the possibilities.</source>
          <target state="translated">가능성을 순환하려면 탭을 다시 누르십시오.</target>
        </trans-unit>
        <trans-unit id="8562520c74923aa47973021bf5a615a9d18fdbc2" translate="yes" xml:space="preserve">
          <source>Holding alt and something else also typically sends escape, for example holding alt+a will send an escape character and then an &quot;a&quot;.</source>
          <target state="translated">Holding alt and something else also typically sends escape, for example holding alt+a will send an escape character and then an &quot;a&quot;.</target>
        </trans-unit>
        <trans-unit id="70f8bb9a8a5393ef080507a89e4b98d139000d65" translate="yes" xml:space="preserve">
          <source>Home</source>
          <target state="translated">Home</target>
        </trans-unit>
        <trans-unit id="0fb159db1e28fce0aea599e71e51612c11b25f22" translate="yes" xml:space="preserve">
          <source>Home directory expansion</source>
          <target state="translated">홈 디렉토리 확장</target>
        </trans-unit>
        <trans-unit id="c5e4aaa97cc3ad7f579464354a2507b9c63dac85" translate="yes" xml:space="preserve">
          <source>How can I use &lt;code&gt;-&lt;/code&gt; as a shortcut for &lt;code&gt;cd -&lt;/code&gt;?</source>
          <target state="translated">How can I use &lt;code&gt;-&lt;/code&gt; as a shortcut for &lt;code&gt;cd -&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="d5208f2bd161f7ef9e4786ba2058053cc8cefa22" translate="yes" xml:space="preserve">
          <source>How can I use `-` as a shortcut for `cd -`?</source>
          <target state="translated">`-`를`cd -`의 단축키로 어떻게 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ba1155cc4fa464e6593f08ba2b8723aab74c8f1c" translate="yes" xml:space="preserve">
          <source>How do I change the greeting message?</source>
          <target state="translated">인사말 메시지를 어떻게 변경합니까?</target>
        </trans-unit>
        <trans-unit id="54e6d1ecb8003f23585cb7559d5800b568cc815b" translate="yes" xml:space="preserve">
          <source>How do I check whether a variable is defined?</source>
          <target state="translated">How do I check whether a variable is defined?</target>
        </trans-unit>
        <trans-unit id="c4d87fc5a8041267fdcd98e9deafc888b91c5523" translate="yes" xml:space="preserve">
          <source>How do I check whether a variable is not empty?</source>
          <target state="translated">How do I check whether a variable is not empty?</target>
        </trans-unit>
        <trans-unit id="13c4a91c9a86c9c981e277c7f5e4a2ed6189509e" translate="yes" xml:space="preserve">
          <source>How do I customize my syntax highlighting colors?</source>
          <target state="translated">구문 강조 색상을 어떻게 사용자 정의합니까?</target>
        </trans-unit>
        <trans-unit id="a694102af5424918d28a1f9662a1aa3950673c08" translate="yes" xml:space="preserve">
          <source>How do I get the exit status of a command?</source>
          <target state="translated">명령의 종료 상태를 얻으려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="0e58d9d321d50cf0c49be8ad0ed48955a88a6bce" translate="yes" xml:space="preserve">
          <source>How do I make fish my default shell?</source>
          <target state="translated">생선을 기본 껍질로 만들려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="402503e9f12a7c687d2a8e25d61d5d4c873e5c42" translate="yes" xml:space="preserve">
          <source>How do I run a command every login? What's fish's equivalent to .bashrc or .profile?</source>
          <target state="translated">How do I run a command every login? What's fish's equivalent to .bashrc or .profile?</target>
        </trans-unit>
        <trans-unit id="bc538e8432ebecf3f9f7a45d7ccb524d4da71c7d" translate="yes" xml:space="preserve">
          <source>How do I run a command every login? What's fish's equivalent to .bashrc?</source>
          <target state="translated">로그인 할 때마다 명령을 어떻게 실행합니까? 물고기는 .bashrc와 동일합니까?</target>
        </trans-unit>
        <trans-unit id="9d52246c1acb2dd2ad95298d27dac048384b6b2b" translate="yes" xml:space="preserve">
          <source>How do I run a command from history?</source>
          <target state="translated">기록에서 명령을 어떻게 실행합니까?</target>
        </trans-unit>
        <trans-unit id="7c2282706e5d5da05460852fe614e0ea089754e8" translate="yes" xml:space="preserve">
          <source>How do I run a subcommand? The backtick doesn't work!</source>
          <target state="translated">하위 명령을 어떻게 실행합니까? 백틱이 작동하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="240782fc9c5f0b5d6c4cc74b05803ec8fdfa4ffc" translate="yes" xml:space="preserve">
          <source>How do I set an environment variable for just one command?</source>
          <target state="translated">하나의 명령에 대해서만 환경 변수를 설정하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="cf01f8cfda8ac7fdc0ad1cfce27146791559db05" translate="yes" xml:space="preserve">
          <source>How do I set my prompt?</source>
          <target state="translated">프롬프트를 어떻게 설정합니까?</target>
        </trans-unit>
        <trans-unit id="a7f2b2fb54e2d471e8f341688e112fc1e1ce9d80" translate="yes" xml:space="preserve">
          <source>How do I set or clear an environment variable?</source>
          <target state="translated">환경 변수를 설정하거나 지우려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="1bbce1c02cef5225c09fe183c39555282f316dab" translate="yes" xml:space="preserve">
          <source>How do I update man page completions?</source>
          <target state="translated">매뉴얼 페이지 완성을 어떻게 업데이트합니까?</target>
        </trans-unit>
        <trans-unit id="8755f1ac4179b2490bfd8d3384a3c541bc0e9557" translate="yes" xml:space="preserve">
          <source>However sometimes, especially with &lt;code&gt;pkg-config&lt;/code&gt; and related tools, splitting on spaces is needed.</source>
          <target state="translated">그러나 때때로, 특히 &lt;code&gt;pkg-config&lt;/code&gt; 및 관련 도구의 경우 공간 분할이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="54bce717b6b4bc0facb17b1202d46c84a308e996" translate="yes" xml:space="preserve">
          <source>However using variables as indices for command substitution is currently not supported, so</source>
          <target state="translated">그러나 명령 대체를 위해 변수를 인덱스로 사용하는 것은 현재 지원되지 않으므로</target>
        </trans-unit>
        <trans-unit id="9c47b741a075c31ca3e2cd472a89d590bf7358b1" translate="yes" xml:space="preserve">
          <source>However using variables as indices for command substitution is currently not supported, so:</source>
          <target state="translated">However using variables as indices for command substitution is currently not supported, so:</target>
        </trans-unit>
        <trans-unit id="3ece1cae89b5ddaf2b419721f67d267e2d87fe0b" translate="yes" xml:space="preserve">
          <source>However, it is more common and efficient to use autoloading functions and universal variables.</source>
          <target state="translated">그러나 자동로드 기능과 범용 변수를 사용하는 것이 더 일반적이고 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="332860b83cabf222387565b3cbb3a4ca2b6a60c7" translate="yes" xml:space="preserve">
          <source>I accidentally entered a directory path and fish changed directory. What happened?</source>
          <target state="translated">실수로 디렉토리 경로를 입력하고 물고기가 디렉토리를 변경했습니다. 어떻게 된 거예요?</target>
        </trans-unit>
        <trans-unit id="077b540fd621e89ad74c3aa41ae8c6bb0c4148b1" translate="yes" xml:space="preserve">
          <source>I'm seeing weird output before each prompt when using screen. What's wrong?</source>
          <target state="translated">화면을 사용할 때 각 프롬프트 전에 이상한 출력이 나타납니다. 뭐가 문제 야?</target>
        </trans-unit>
        <trans-unit id="7884771064847db56c0b28c42a19e5f67be016fb" translate="yes" xml:space="preserve">
          <source>If $animals is a list of animals, the following will test if it contains a cat:</source>
          <target state="translated">$ animals가 동물 목록 인 경우 다음은 고양이가 포함되어 있는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="6288311089317cecbe49c2b077270e72c24f0c74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$animal&lt;/code&gt; was set to &quot;banana&quot;, it would print &quot;I have no idea what a banana is&quot;.</source>
          <target state="translated">경우 &lt;code&gt;$animal&lt;/code&gt; &quot;바나나&quot;로 설정, 그것은 &quot;나는 바나나가 무엇인지 전혀 모른다&quot;인쇄 할 것이다.</target>
        </trans-unit>
        <trans-unit id="6529dd48f4bbe7af35d8ee17e053a860dce8bc42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$argv&lt;/code&gt; is empty then there is nothing to parse and &lt;code&gt;argparse&lt;/code&gt; returns zero to indicate success. If &lt;code&gt;$argv&lt;/code&gt; is not empty then it is checked for flags &lt;code&gt;-h&lt;/code&gt;, &lt;code&gt;--help&lt;/code&gt;, &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;--name&lt;/code&gt;. If they are found they are removed from the arguments and local variables (more on this &lt;a href=&quot;argparse-local-variables&quot;&gt;below&lt;/a&gt;) are set so the script can determine which options were seen. Assuming &lt;code&gt;$argv&lt;/code&gt; doesn't have any errors, such as a missing mandatory value for an option, then &lt;code&gt;argparse&lt;/code&gt; exits with status zero. Otherwise it writes appropriate error messages to stderr and exits with a status of one.</source>
          <target state="translated">경우 &lt;code&gt;$argv&lt;/code&gt; 비어 다음이 구문 분석하는 것도없고 &lt;code&gt;argparse&lt;/code&gt; 반환 성공을 표시하는 제로. &lt;code&gt;$argv&lt;/code&gt; 가 비어 있지 않은 경우 &lt;code&gt;-h&lt;/code&gt; , &lt;code&gt;--help&lt;/code&gt; , &lt;code&gt;-n&lt;/code&gt; 및 &lt;code&gt;--name&lt;/code&gt; 플래그를 검사합니다 . 그것들이 발견되면 인수에서 제거되고 로컬 변수 ( &lt;a href=&quot;argparse-local-variables&quot;&gt;아래에&lt;/a&gt; 더 자세히 설명되어 있음 )가 설정되어 스크립트가 어떤 옵션을 볼 수 있는지 결정할 수 있습니다. &lt;code&gt;$argv&lt;/code&gt; 에 옵션의 필수 값 누락과 같은 오류가 없다고 가정하면 &lt;code&gt;argparse&lt;/code&gt; 는 상태 0으로 종료됩니다. 그렇지 않으면 적절한 오류 메시지를 stderr에 기록하고 상태 1로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="c0fbfd35fc6ed08657df1862ed0095c68b3987ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$argv&lt;/code&gt; is empty then there is nothing to parse and &lt;code&gt;argparse&lt;/code&gt; returns zero to indicate success. If &lt;code&gt;$argv&lt;/code&gt; is not empty then it is checked for flags &lt;code&gt;-h&lt;/code&gt;, &lt;code&gt;--help&lt;/code&gt;, &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;--name&lt;/code&gt;. If they are found they are removed from the arguments and local variables are set so the script can determine which options were seen. Assuming &lt;code&gt;$argv&lt;/code&gt; doesn't have any errors, such as a missing mandatory value for an option, then &lt;code&gt;argparse&lt;/code&gt; exits with status zero. Otherwise it writes appropriate error messages to stderr and exits with a status of one.</source>
          <target state="translated">If &lt;code&gt;$argv&lt;/code&gt; is empty then there is nothing to parse and &lt;code&gt;argparse&lt;/code&gt; returns zero to indicate success. If &lt;code&gt;$argv&lt;/code&gt; is not empty then it is checked for flags &lt;code&gt;-h&lt;/code&gt; , &lt;code&gt;--help&lt;/code&gt; , &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;--name&lt;/code&gt; . If they are found they are removed from the arguments and local variables are set so the script can determine which options were seen. Assuming &lt;code&gt;$argv&lt;/code&gt; doesn't have any errors, such as a missing mandatory value for an option, then &lt;code&gt;argparse&lt;/code&gt; exits with status zero. Otherwise it writes appropriate error messages to stderr and exits with a status of one.</target>
        </trans-unit>
        <trans-unit id="18c0231ee0546ad7aeb3f50a1a68cbc1c85d1797" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--index&lt;/code&gt; or &lt;code&gt;-n&lt;/code&gt; is given, each match is reported as a 1-based start position and a length. By default, PATTERN is interpreted as a glob pattern matched against each entire STRING argument. A glob pattern is only considered a valid match if it matches the entire STRING.</source>
          <target state="translated">경우 &lt;code&gt;--index&lt;/code&gt; 또는 &lt;code&gt;-n&lt;/code&gt; 을 주어, 각 경기는 1부터 시작 위치와 길이로보고됩니다. 기본적으로 PATTERN은 각 STRING 인수 전체와 일치하는 glob 패턴으로 해석됩니다. glob 패턴은 전체 STRING과 일치하는 경우에만 유효한 일치로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="dbf8f89e324b9e1f656b472c919d4c7a437efce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--invert&lt;/code&gt; or &lt;code&gt;-v&lt;/code&gt; is used the selected lines will be only those which do not match the given glob pattern or regular expression.</source>
          <target state="translated">경우 &lt;code&gt;--invert&lt;/code&gt; 또는 &lt;code&gt;-v&lt;/code&gt; 가 사용되는 선택된 라인 만 주어진 글로브 패턴 또는 정규 표현식과 일치하지 않는 사람이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="bca5e01e9673f9e6a815d4bc3b45775fa51fbbf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--regex&lt;/code&gt; or &lt;code&gt;-r&lt;/code&gt; is given, PATTERN is interpreted as a Perl-compatible regular expression, which does not have to match the entire STRING. For a regular expression containing capturing groups, multiple items will be reported for each match, one for the entire match and one for each capturing group. With this, only the matching part of the STRING will be reported, unless &lt;code&gt;--entire&lt;/code&gt; is given.</source>
          <target state="translated">경우 &lt;code&gt;--regex&lt;/code&gt; 또는 &lt;code&gt;-r&lt;/code&gt; 이 주어집니다, 패턴은 전체 문자열과 일치하지 않는 펄 호환 정규 표현식으로 해석됩니다. 캡처 그룹이 포함 된 정규식의 경우 각 일치 항목, 전체 일치 항목 및 캡처 그룹마다 여러 항목이보고됩니다. 이를 통해 &lt;code&gt;--entire&lt;/code&gt; 를 지정 하지 않으면 STRING의 일치하는 부분 만보고 됩니다.</target>
        </trans-unit>
        <trans-unit id="fcb2b97b9b74110a92108364c83d3b0d2cdf428f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--array&lt;/code&gt; is provided, only one variable name is allowed and the tokens are stored as a list in this variable.</source>
          <target state="translated">If &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--array&lt;/code&gt; is provided, only one variable name is allowed and the tokens are stored as a list in this variable.</target>
        </trans-unit>
        <trans-unit id="4e269b8b85f5f48b405e1f529c5cc1623456789e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--array&lt;/code&gt; is provided, only one variable name is allowed and the tokens are stored as an array in this variable.</source>
          <target state="translated">경우 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;--array&lt;/code&gt; 가 제공되고, 하나의 변수 이름이 허용되고,이 토큰은 변수 배열로 저장된다.</target>
        </trans-unit>
        <trans-unit id="a6dcb1b88668c5c41c70fbdad2157ee6171f60f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-e&lt;/code&gt; is used, the following sequences are recognized:</source>
          <target state="translated">경우 &lt;code&gt;-e&lt;/code&gt; 를 사용하는 경우, 다음 순서는 인식됩니다</target>
        </trans-unit>
        <trans-unit id="e5d5482f59147347f76e114d12618ff3d78fea80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-r&lt;/code&gt; or &lt;code&gt;--regex&lt;/code&gt; is given, PATTERN is interpreted as a Perl-compatible regular expression, and REPLACEMENT can contain C-style escape sequences like &lt;code&gt;\t&lt;/code&gt; as well as references to capturing groups by number or name as &lt;code&gt;$n&lt;/code&gt; or &lt;code&gt;${n}&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;-r&lt;/code&gt; 또는 &lt;code&gt;--regex&lt;/code&gt; , PATTERN은 펄 호환 정규 표현식으로 해석됩니다 부여 및 교체가 같은 C 스타일 이스케이프 시퀀스를 포함 할 수 있습니다 &lt;code&gt;\t&lt;/code&gt; 등의 번호 또는 이름으로 캡처 그룹에 대한 참조뿐만 아니라 &lt;code&gt;$n&lt;/code&gt; 또는 &lt;code&gt;${n}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="227584b023d6d2c7837f693e7e9b190c0c0b3bf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ARG&lt;/code&gt; and &lt;code&gt;REASON&lt;/code&gt; are both specified, &lt;code&gt;ARG&lt;/code&gt; is the command to be executed when the event specified by &lt;code&gt;REASON&lt;/code&gt; occurs (e.g., the signal is delivered).</source>
          <target state="translated">경우 &lt;code&gt;ARG&lt;/code&gt; 및 &lt;code&gt;REASON&lt;/code&gt; 가 모두 지정되어 &lt;code&gt;ARG&lt;/code&gt; 가 된 이벤트 때 실행되는 명령이다 &lt;code&gt;REASON&lt;/code&gt; 가 발생 (예는, 신호를 전달한다).</target>
        </trans-unit>
        <trans-unit id="d6a059f39530ea46f03b1a88f280774a9e1b7e4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ARG&lt;/code&gt; is absent (and there is a single REASON) or -, each specified signal is reset to its original disposition (the value it had upon entrance to the shell). If &lt;code&gt;ARG&lt;/code&gt; is the null string the signal specified by each &lt;code&gt;REASON&lt;/code&gt; is ignored by the shell and by the commands it invokes.</source>
          <target state="translated">경우 &lt;code&gt;ARG&lt;/code&gt; 이 없는 (그리고 하나가 REASON 임) 또는 - 지정된 각 신호는 원래의 배열 (이것은 쉘 입구에 있던 값)으로 리셋된다. 경우 &lt;code&gt;ARG&lt;/code&gt; 가 널 (null) 문자열을 각에 의해 지정된 신호 &lt;code&gt;REASON&lt;/code&gt; 쉘과는 호출 명령에 의해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0310897c6525d4c0a20301e5b59490367df8d786" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ARG&lt;/code&gt; is not present and &lt;code&gt;-p&lt;/code&gt; has been supplied, then the trap commands associated with each &lt;code&gt;REASON&lt;/code&gt; are displayed. If no arguments are supplied or if only &lt;code&gt;-p&lt;/code&gt; is given, &lt;code&gt;trap&lt;/code&gt; prints the list of commands associated with each signal.</source>
          <target state="translated">경우 &lt;code&gt;ARG&lt;/code&gt; 가 존재하지 않으며 &lt;code&gt;-p&lt;/code&gt; 가 공급 된 후, 각각에 관련된 트랩 명령 &lt;code&gt;REASON&lt;/code&gt; 가 표시된다. 인수가 제공되지 않거나 &lt;code&gt;-p&lt;/code&gt; 만 제공되면 &lt;code&gt;trap&lt;/code&gt; 은 각 신호와 연관된 명령 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="46f4e7706aaa7715626c2065fdf439e268266771" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DIRECTORY&lt;/code&gt; is a relative path, the paths found in the &lt;code&gt;CDPATH&lt;/code&gt; environment variable array will be tried as prefixes for the specified path.</source>
          <target state="translated">경우 &lt;code&gt;DIRECTORY&lt;/code&gt; 가 상대 경로는 상기 검색된 경로 &lt;code&gt;CDPATH&lt;/code&gt; 의 환경 변수 어레이는 지정된 경로에 대한 프리픽스로 시도한다.</target>
        </trans-unit>
        <trans-unit id="d8fdf9c081d12374165457176e730cf87d210ca2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DIRECTORY&lt;/code&gt; is a relative path, the paths found in the &lt;code&gt;CDPATH&lt;/code&gt; list will be tried as prefixes for the specified path, in addition to $PWD.</source>
          <target state="translated">If &lt;code&gt;DIRECTORY&lt;/code&gt; is a relative path, the paths found in the &lt;code&gt;CDPATH&lt;/code&gt; list will be tried as prefixes for the specified path, in addition to $PWD.</target>
        </trans-unit>
        <trans-unit id="6d211b5295328f27c5f4dda2c5b64e33b2d339ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DIRECTORY&lt;/code&gt; is supplied, it will become the new directory. If no parameter is given, the contents of the &lt;code&gt;HOME&lt;/code&gt; environment variable will be used.</source>
          <target state="translated">경우 &lt;code&gt;DIRECTORY&lt;/code&gt; 공급되고, 그것은 새 디렉토리가 될 것이다. 매개 변수를 지정하지 않으면 &lt;code&gt;HOME&lt;/code&gt; 환경 변수 의 내용 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee49ba74d2c75163466a92ec95757c32496b3231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;commandline&lt;/code&gt; is called during a call to complete a given string using &lt;code&gt;complete -C STRING&lt;/code&gt;, &lt;code&gt;commandline&lt;/code&gt; will consider the specified string to be the current contents of the command line.</source>
          <target state="translated">경우 &lt;code&gt;commandline&lt;/code&gt; 사용하여 주어진 문자열 완료하기 위해 통화 중이라 &lt;code&gt;complete -C STRING&lt;/code&gt; , &lt;code&gt;commandline&lt;/code&gt; 명령 행의 현재의 내용으로 지정된 문자열을 고려할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1145ddb3bdeee96521a717d934a15cc64d95077c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fish&lt;/code&gt; encounters a problem while executing a command, the status variable may also be set to a specific value:</source>
          <target state="translated">경우 &lt;code&gt;fish&lt;/code&gt; 명령을 실행하는 동안 문제가 발생하는 상태 변수는 특정 값으로 설정 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="f09fbf7f2a9a04bff01d5330effffef51795cab0" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SECTION&lt;/code&gt; is specified, the help for that command is shown.</source>
          <target state="translated">경우 &lt;code&gt;SECTION&lt;/code&gt; 지정되어, 해당 명령에 대한 도움말이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8d59528d17aca71e945c01c4f608cc07968fec9a" translate="yes" xml:space="preserve">
          <source>If a VCS isn't installed, the respective function does nothing.</source>
          <target state="translated">If a VCS isn't installed, the respective function does nothing.</target>
        </trans-unit>
        <trans-unit id="8ebee8483e83b06811ff3ba9ccc429433dce33cd" translate="yes" xml:space="preserve">
          <source>If a function named &lt;code&gt;fish_greeting&lt;/code&gt; exists, it will be run when entering interactive mode. Otherwise, if an environment variable named &lt;code&gt;fish_greeting&lt;/code&gt; exists, it will be printed.</source>
          <target state="translated">&lt;code&gt;fish_greeting&lt;/code&gt; 이라는 함수 가 존재하면 대화식 모드로 들어갈 때 실행됩니다. 그렇지 않으면 이름이 &lt;code&gt;fish_greeting&lt;/code&gt; 인 환경 변수 가 존재하면 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="236d9b2bfa9ffd703bff82e438702935d8f276d3" translate="yes" xml:space="preserve">
          <source>If a job is stopped, it is sent a signal to continue running, and a warning is printed. It is not possible to use the &lt;code&gt;bg&lt;/code&gt; builtin to continue a job once it has been disowned.</source>
          <target state="translated">작업이 중지되면 계속 실행하라는 신호가 전송되고 경고가 인쇄됩니다. 폐기 된 작업을 계속 하기 위해 &lt;code&gt;bg&lt;/code&gt; 내장 을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="60e2a752180a8997dd97af87732b5ed3a03f8d8f" translate="yes" xml:space="preserve">
          <source>If a numeric mask is specified as a parameter, the current shell's umask will be set to that value, and the rights specified by that mask will be removed from new files and directories by default.</source>
          <target state="translated">숫자 마스크가 매개 변수로 지정되면 현재 쉘의 umask가 해당 값으로 설정되고 해당 마스크에 의해 지정된 권한이 기본적으로 새 파일 및 디렉토리에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2dde9e658888f495cea69c0ad8b260a62416e91a" translate="yes" xml:space="preserve">
          <source>If a pid is specified, the command waits for the job that the process with the pid belongs to.</source>
          <target state="translated">pid가 지정되면 명령은 pid가있는 프로세스가 속한 작업을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="f851c83c3c3953c372c81382f02613c546f275f0" translate="yes" xml:space="preserve">
          <source>If a process exits through a signal, the exit status will be 128 plus the number of the signal.</source>
          <target state="translated">프로세스가 신호를 통해 종료되면 종료 상태는 128에 신호 수를 더한 값입니다.</target>
        </trans-unit>
        <trans-unit id="47cb47829c9383def1fb8361853c4c7dd09368a8" translate="yes" xml:space="preserve">
          <source>If a process name is specified, the command waits for the jobs that the matched processes belong to.</source>
          <target state="translated">프로세스 이름이 지정되면 명령은 일치하는 프로세스가 속한 작업을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="302f9ccffa6bb045e0895a185f5c9e50859c884f" translate="yes" xml:space="preserve">
          <source>If a script produces output, it should finish by calling &lt;code&gt;commandline -f repaint&lt;/code&gt; to tell fish that a repaint is in order.</source>
          <target state="translated">스크립트가 출력을 생성하는 경우, &lt;code&gt;commandline -f repaint&lt;/code&gt; 를 호출 하여 물고기에게 다시 그리기가 순서대로 이루어짐 으로써 완료해야합니다 .</target>
        </trans-unit>
        <trans-unit id="67026ba945428dc31827715c1565311d33b5af8d" translate="yes" xml:space="preserve">
          <source>If a star (&lt;code&gt;*&lt;/code&gt;) or a question mark (&lt;code&gt;?&lt;/code&gt;) is present in the parameter, &lt;code&gt;fish&lt;/code&gt; attempts to match the given parameter to any files in such a way that:</source>
          <target state="translated">별표 ( &lt;code&gt;*&lt;/code&gt; ) 또는 물음표 ( &lt;code&gt;?&lt;/code&gt; )가 매개 변수에 있으면 , &lt;code&gt;fish&lt;/code&gt; 는 다음과 같은 방식으로 주어진 매개 변수를 파일과 일치 시키려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="18a6fd00e4b1ddec496d39ba9f288b25c849a5d6" translate="yes" xml:space="preserve">
          <source>If a symbolic mask is specified, the desired permission bits, and not the inverse, should be specified. A symbolic mask is a comma separated list of rights. Each right consists of three parts:</source>
          <target state="translated">심볼릭 마스크가 지정된 경우에는 반대가 아닌 원하는 권한 비트를 지정해야합니다. 기호 마스크는 쉼표로 구분 된 권한 목록입니다. 각 권리는 세 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c3bd46787a5c6b92e6f20cfe4fbc883c75045f2a" translate="yes" xml:space="preserve">
          <source>If a variable has global scope, it is accessible read-write to functions whether it is exported or not.</source>
          <target state="translated">변수에 전역 범위가있는 경우 변수의 내보내기 여부에 관계없이 함수에 대한 읽기 / 쓰기가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="741d44bccaaf674b1d069d14a1bdb399e238d593" translate="yes" xml:space="preserve">
          <source>If a variable has local scope and is exported, any function called receives a &lt;em&gt;copy&lt;/em&gt; of it, so any changes it makes to the variable disappear once the function returns.</source>
          <target state="translated">변수에 로컬 범위가 있고 내보내지는 경우 호출 된 함수는 해당 &lt;em&gt;복사본&lt;/em&gt; 을 수신 하므로 함수가 반환되면 변수에 대한 변경 내용이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="b71ed16ea5a59eda60ec534a14bf2d103ba20ae9" translate="yes" xml:space="preserve">
          <source>If a variable has local scope and is exported, any function called receives a _copy_ of it, so any changes it makes to the variable disappear once the function returns.</source>
          <target state="translated">If a variable has local scope and is exported, any function called receives a _copy_ of it, so any changes it makes to the variable disappear once the function returns.</target>
        </trans-unit>
        <trans-unit id="96f0994fdaca0f9b1c269335d2df0f4e271c169d" translate="yes" xml:space="preserve">
          <source>If a variable is explicitly set to a scope (universal, global or local), that setting will be honored. If a variable of the same name exists in a different scope, that variable will not be changed.</source>
          <target state="translated">If a variable is explicitly set to a scope (universal, global or local), that setting will be honored. If a variable of the same name exists in a different scope, that variable will not be changed.</target>
        </trans-unit>
        <trans-unit id="2cbdc88f5e9bb2f3b40009d0379b55ab2352ae84" translate="yes" xml:space="preserve">
          <source>If a variable is explicitly set to either be exported or not exported, that setting will be honored.</source>
          <target state="translated">변수를 명시 적으로 내보내거나 내 보내지 않도록 설정하면 해당 설정이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce6484065868b4e9c43f6db14f55a84fe136a4bf" translate="yes" xml:space="preserve">
          <source>If a variable is explicitly set to either universal, global or local, that setting will be honored. If a variable of the same name exists in a different scope, that variable will not be changed.</source>
          <target state="translated">변수가 명시 적으로 범용, 전역 또는 로컬로 설정된 경우 해당 설정이 적용됩니다. 동일한 이름의 변수가 다른 범위에 존재하면 해당 변수는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7fd2961197b45dfc25c896ad23c85e1abfcf8519" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to a scope and has not been defined, the variable will be local to the currently executing function. Note that this is different from using the &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;--local&lt;/code&gt; flag. If one of those flags is used, the variable will be local to the most inner currently executing block, while without these the variable will be local to the function. If no function is executing, the variable will be global.</source>
          <target state="translated">If a variable is not explicitly set to a scope and has not been defined, the variable will be local to the currently executing function. Note that this is different from using the &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;--local&lt;/code&gt; flag. If one of those flags is used, the variable will be local to the most inner currently executing block, while without these the variable will be local to the function. If no function is executing, the variable will be global.</target>
        </trans-unit>
        <trans-unit id="6e687f439d700aaa30c67d0c1c2079a9950e1712" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to a scope, but has been previously defined, the variable scope is not changed.</source>
          <target state="translated">If a variable is not explicitly set to a scope, but has been previously defined, the variable scope is not changed.</target>
        </trans-unit>
        <trans-unit id="326eb232490e8df93b49fd2c3a89fde63906ed77" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to be either exported or not exported and has never before been defined, the variable will not be exported.</source>
          <target state="translated">변수가 명시 적으로 내보내 지거나 내 보내지 않도록 설정되지 않았으며 정의 된 적이없는 경우 변수가 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef107fe0701094bebbf7a6322c1155614a1be3ba" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to be either exported or unexported and has never before been defined, the variable will not be exported.</source>
          <target state="translated">변수가 명시 적으로 내보내거나 내 보내지 않도록 설정되지 않았으며 이전에 정의 된 적이없는 경우 변수가 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd6c17ea05cd6c81f352d96759e2622e4a16e84b" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to be either universal, global or local and has never before been defined, the variable will be local to the currently executing function. Note that this is different from using the &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;--local&lt;/code&gt; flag. If one of those flags is used, the variable will be local to the most inner currently executing block, while without these the variable will be local to the function. If no function is executing, the variable will be global.</source>
          <target state="translated">변수가 명시 적으로 범용, 전역 또는 로컬로 설정되지 않았으며 이전에 정의 된 적이없는 경우 변수는 현재 실행중인 기능에 대해 로컬입니다. 이것은 &lt;code&gt;-l&lt;/code&gt; 또는 &lt;code&gt;--local&lt;/code&gt; 플래그 를 사용하는 것과 다릅니다 . 이러한 플래그 중 하나가 사용되면 변수는 현재 실행중인 가장 내부 블록에 로컬 인 반면 변수가 없으면 함수에 로컬입니다. 함수가 실행되고 있지 않으면 변수는 전역입니다.</target>
        </trans-unit>
        <trans-unit id="8b2d1734ef9bdd7bd6d21bc623798a68378e6c8b" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to be either universal, global or local, but has been previously defined, the previous variable scope is used.</source>
          <target state="translated">변수가 명시 적으로 범용, 전역 또는 로컬로 설정되지 않았지만 이전에 정의 된 경우 이전 변수 범위가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ae5e31cb3d02690bd43a99dc6a823c8568d4b6e8" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to be either universal, global or local, but has been previously defined, the variable scope is not changed.</source>
          <target state="translated">변수가 명시 적으로 범용, 전역 또는 로컬로 설정되지 않았지만 이전에 정의 된 경우 변수 범위는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ccd9990afce6a9aaaa05eb9827a340fd925feb1" translate="yes" xml:space="preserve">
          <source>If a variable is not explicitly set to be exported or not exported, but has been previously defined, the previous exporting rule for the variable is kept.</source>
          <target state="translated">변수가 명시 적으로 내보내 지거나 내 보내지 않도록 설정되지 않았지만 이전에 정의 된 경우 변수에 대한 이전 내보내기 규칙이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ae603cd6be44b99d51c1566501087ce7b225183b" translate="yes" xml:space="preserve">
          <source>If a variable is set to more than one value, the variable will be a list with the specified elements. If a variable is set to zero elements, it will become a list with zero elements.</source>
          <target state="translated">If a variable is set to more than one value, the variable will be a list with the specified elements. If a variable is set to zero elements, it will become a list with zero elements.</target>
        </trans-unit>
        <trans-unit id="72e2106717a7a37128914da8765dc2c6c6697b14" translate="yes" xml:space="preserve">
          <source>If a variable is set to more than one value, the variable will be an array with the specified elements. If a variable is set to zero elements, it will become an array with zero elements.</source>
          <target state="translated">변수가 둘 이상의 값으로 설정되면 변수는 지정된 요소가있는 배열이됩니다. 변수가 0 요소로 설정되면 0 요소를 가진 배열이됩니다.</target>
        </trans-unit>
        <trans-unit id="a723f0fea3c45c67807883ef6059438866b12547" translate="yes" xml:space="preserve">
          <source>If after expansion there is nothing between the braces, the argument will be removed (see &lt;a href=&quot;#cartesian-product&quot;&gt;the cartesian product section&lt;/a&gt;):</source>
          <target state="translated">If after expansion there is nothing between the braces, the argument will be removed (see &lt;a href=&quot;#cartesian-product&quot;&gt;the cartesian product section&lt;/a&gt;):</target>
        </trans-unit>
        <trans-unit id="7f805483966bd1b92bb16fa0e48ac91c14f18567" translate="yes" xml:space="preserve">
          <source>If an error occurs during argparse processing it will exit with a non-zero status and print error messages to stderr.</source>
          <target state="translated">argparse 처리 중에 오류가 발생하면 0이 아닌 상태로 종료되고 stderr에 오류 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f3bb201c1119b5848ebfda84c47d1e1698174af5" translate="yes" xml:space="preserve">
          <source>If any non-option parameters are given, the definition of the specified functions are printed.</source>
          <target state="translated">비 옵션 매개 변수가 제공되면 지정된 기능의 정의가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="dcc764ad71040642c2ae2b7ce376987c8f357ee1" translate="yes" xml:space="preserve">
          <source>If exit is called while sourcing a file (using the &lt;a href=&quot;#source&quot;&gt;source&lt;/a&gt; builtin) the rest of the file will be skipped, but the shell itself will not exit.</source>
          <target state="translated">&lt;a href=&quot;#source&quot;&gt;소스 소스를&lt;/a&gt; 사용하여 파일을 소싱하는 동안 exit가 호출 되면 나머지 파일은 건너 뛰지 만 쉘 자체는 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ad30bb6821fad0de41f3c375fba71f6a9c37c25" translate="yes" xml:space="preserve">
          <source>If exit is called while sourcing a file (using the &lt;a href=&quot;source#cmd-source&quot;&gt;source&lt;/a&gt; builtin) the rest of the file will be skipped, but the shell itself will not exit.</source>
          <target state="translated">If exit is called while sourcing a file (using the &lt;a href=&quot;source#cmd-source&quot;&gt;source&lt;/a&gt; builtin) the rest of the file will be skipped, but the shell itself will not exit.</target>
        </trans-unit>
        <trans-unit id="3068ba7bd98e36689eab0ca26911e82ce1011087" translate="yes" xml:space="preserve">
          <source>If fish is unable to locate a command with a given name, and it starts with '&lt;code&gt;.&lt;/code&gt;', '&lt;code&gt;/&lt;/code&gt;' or '&lt;code&gt;~&lt;/code&gt;', fish will test if a directory of that name exists. If it does, it is implicitly assumed that you want to change working directory. For example, the fastest way to switch to your home directory is to simply press &lt;code&gt;~&lt;/code&gt; and enter.</source>
          <target state="translated">물고기가 주어진 이름으로 명령을 찾을 수 없으면 '로 시작합니다 &lt;code&gt;.&lt;/code&gt; ',' &lt;code&gt;/&lt;/code&gt; '또는' &lt;code&gt;~&lt;/code&gt; ', 물고기는 해당 이름의 디렉토리가 존재하는지 테스트합니다. 그렇다면 작업 디렉토리를 변경하려는 것으로 암시 적으로 가정합니다. 예를 들어, 홈 디렉토리로 전환하는 가장 빠른 방법은 &lt;code&gt;~&lt;/code&gt; 를 누르고 입력하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="08db4ab1c440a3e304e3453045348ee442c8b3f8" translate="yes" xml:space="preserve">
          <source>If fish is your default shell and you want to copy commands from the internet that are written in a different shell language, bash for example, you can proceed in the following way:</source>
          <target state="translated">If fish is your default shell and you want to copy commands from the internet that are written in a different shell language, bash for example, you can proceed in the following way:</target>
        </trans-unit>
        <trans-unit id="779713b50e0b6db32e410c35dd906b7eab469c0a" translate="yes" xml:space="preserve">
          <source>If invoked with multiple arguments instead of input, &lt;code&gt;string collect&lt;/code&gt; preserves each argument separately, where the number of output arguments is equal to the number of arguments given to &lt;code&gt;string collect&lt;/code&gt;.</source>
          <target state="translated">If invoked with multiple arguments instead of input, &lt;code&gt;string collect&lt;/code&gt; preserves each argument separately, where the number of output arguments is equal to the number of arguments given to &lt;code&gt;string collect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd1e21aed552d458b2c10cb3ad02fe6a085212c8" translate="yes" xml:space="preserve">
          <source>If limit is given, it is the new value of the specified resource. If no option is given, then &lt;code&gt;-f&lt;/code&gt; is assumed. Values are in kilobytes, except for &lt;code&gt;-t&lt;/code&gt;, which is in seconds and &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-u&lt;/code&gt;, which are unscaled values. The exit status is 0 unless an invalid option or argument is supplied, or an error occurs while setting a new limit.</source>
          <target state="translated">If limit is given, it is the new value of the specified resource. If no option is given, then &lt;code&gt;-f&lt;/code&gt; is assumed. Values are in kilobytes, except for &lt;code&gt;-t&lt;/code&gt; , which is in seconds and &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-u&lt;/code&gt; , which are unscaled values. The exit status is 0 unless an invalid option or argument is supplied, or an error occurs while setting a new limit.</target>
        </trans-unit>
        <trans-unit id="9365afaebdcba814bae204eaa9cb6846f923618b" translate="yes" xml:space="preserve">
          <source>If limit is given, it is the new value of the specified resource. If no option is given, then &lt;code&gt;-f&lt;/code&gt; is assumed. Values are in kilobytes, except for &lt;code&gt;-t&lt;/code&gt;, which is in seconds and &lt;code&gt;-n&lt;/code&gt; and &lt;code&gt;-u&lt;/code&gt;, which are unscaled values. The return status is 0 unless an invalid option or argument is supplied, or an error occurs while setting a new limit.</source>
          <target state="translated">제한이 지정된 경우 지정된 자원의 새로운 값입니다. 옵션이 제공되지 않으면 &lt;code&gt;-f&lt;/code&gt; 로 가정됩니다. 값은 초 단위 인 &lt;code&gt;-t&lt;/code&gt; 및 스케일링되지 않은 값인 &lt;code&gt;-n&lt;/code&gt; 및 &lt;code&gt;-u&lt;/code&gt; 를 제외하고 킬로바이트 단위 입니다. 유효하지 않은 옵션이나 인수가 제공되지 않거나 새 한계를 설정하는 동안 오류가 발생하지 않으면 리턴 상태는 0입니다.</target>
        </trans-unit>
        <trans-unit id="ca3ffe9826b96a93254e7258c40cd2d913b9941e" translate="yes" xml:space="preserve">
          <source>If neither a pid nor a process name is specified, the command waits for all background jobs.</source>
          <target state="translated">pid 나 프로세스 이름을 지정하지 않으면 명령은 모든 백그라운드 작업을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="6620b792aa7c50700f6a7c83a134de00e5936216" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;SEQUENCE&lt;/code&gt; is provided, all bindings (or just the bindings in the specified &lt;code&gt;MODE&lt;/code&gt;) are printed. If &lt;code&gt;SEQUENCE&lt;/code&gt; is provided without &lt;code&gt;COMMAND&lt;/code&gt;, just the binding matching that sequence is printed.</source>
          <target state="translated">&lt;code&gt;SEQUENCE&lt;/code&gt; 가 제공 되지 않으면 모든 바인딩 (또는 지정된 &lt;code&gt;MODE&lt;/code&gt; 의 바인딩 만 )이 인쇄됩니다. &lt;code&gt;COMMAND&lt;/code&gt; 없이 &lt;code&gt;SEQUENCE&lt;/code&gt; 가 제공 되면 해당 시퀀스와 일치하는 바인딩 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="319b10cf51c7aaf0a0ad28a0d4b4f6c772504c25" translate="yes" xml:space="preserve">
          <source>If no file is specified and stdin is not the terminal, or if the file name '&lt;code&gt;-&lt;/code&gt;' is used, stdin will be read.</source>
          <target state="translated">파일을 지정하지 않고 stdin이 터미널이 아니거나 파일 이름 ' &lt;code&gt;-&lt;/code&gt; '가 사용되면 stdin을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="193caf7005f5652feb5a621fdb872e8d40cb588f" translate="yes" xml:space="preserve">
          <source>If no option to determine how to split like &lt;code&gt;--delimiter&lt;/code&gt;, &lt;code&gt;--line&lt;/code&gt; or &lt;code&gt;--tokenize&lt;/code&gt; is given, the variable &lt;code&gt;IFS&lt;/code&gt; is used as a list of characters to split on. Relying on the use of &lt;code&gt;IFS&lt;/code&gt; is deprecated and this behaviour will be removed in future versions. The default value of &lt;code&gt;IFS&lt;/code&gt; contains space, tab and newline characters. As a special case, if &lt;code&gt;IFS&lt;/code&gt; is set to the empty string, each character of the input is considered a separate token.</source>
          <target state="translated">If no option to determine how to split like &lt;code&gt;--delimiter&lt;/code&gt; , &lt;code&gt;--line&lt;/code&gt; or &lt;code&gt;--tokenize&lt;/code&gt; is given, the variable &lt;code&gt;IFS&lt;/code&gt; is used as a list of characters to split on. Relying on the use of &lt;code&gt;IFS&lt;/code&gt; is deprecated and this behaviour will be removed in future versions. The default value of &lt;code&gt;IFS&lt;/code&gt; contains space, tab and newline characters. As a special case, if &lt;code&gt;IFS&lt;/code&gt; is set to the empty string, each character of the input is considered a separate token.</target>
        </trans-unit>
        <trans-unit id="e05e6aafbb793ade9f477fd1403ff37aea85d34f" translate="yes" xml:space="preserve">
          <source>If no piping or other compound shell constructs are required, variable-expansion-as-command, as in &lt;code&gt;set cmd ls -la; $cmd&lt;/code&gt;, is also an option.</source>
          <target state="translated">If no piping or other compound shell constructs are required, variable-expansion-as-command, as in &lt;code&gt;set cmd ls -la; $cmd&lt;/code&gt; , is also an option.</target>
        </trans-unit>
        <trans-unit id="dcfe8801c42ff77994dd55c54562f05ad1157dea" translate="yes" xml:space="preserve">
          <source>If no process is specified, the most recently-used job is removed (like &lt;a href=&quot;bg#cmd-bg&quot;&gt;bg&lt;/a&gt; and &lt;a href=&quot;fg#cmd-fg&quot;&gt;fg&lt;/a&gt;). If one or more PIDs are specified, jobs with the specified process IDs are removed from the job list. Invalid jobs are ignored and a warning is printed.</source>
          <target state="translated">If no process is specified, the most recently-used job is removed (like &lt;a href=&quot;bg#cmd-bg&quot;&gt;bg&lt;/a&gt; and &lt;a href=&quot;fg#cmd-fg&quot;&gt;fg&lt;/a&gt;). If one or more PIDs are specified, jobs with the specified process IDs are removed from the job list. Invalid jobs are ignored and a warning is printed.</target>
        </trans-unit>
        <trans-unit id="536986c9ac77b0a65c848619315ad13a2f046d5c" translate="yes" xml:space="preserve">
          <source>If no process is specified, the most recently-used job is removed (like &lt;code&gt;bg&lt;/code&gt; and &lt;code&gt;fg&lt;/code&gt;). If one or more &lt;code&gt;PID&lt;/code&gt;s are specified, jobs with the specified process IDs are removed from the job list. Invalid jobs are ignored and a warning is printed.</source>
          <target state="translated">프로세스를 지정하지 않으면 가장 최근에 사용한 작업 (예 : &lt;code&gt;bg&lt;/code&gt; 및 &lt;code&gt;fg&lt;/code&gt; ) 이 제거됩니다 . 하나 이상의 &lt;code&gt;PID&lt;/code&gt; 가 지정되면 지정된 프로세스 ID를 가진 작업이 작업 목록에서 제거됩니다. 유효하지 않은 작업은 무시되고 경고가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="713bf8682430a51e2b7af1a6d836f8e75fd1bdaa" translate="yes" xml:space="preserve">
          <source>If no variable names are provided, &lt;code&gt;read&lt;/code&gt; enters a special case that simply provides redirection from standard input to standard output, useful for command substitution. For instance, the fish shell command below can be used to read data that should be provided via a command line argument from the console instead of hardcoding it in the command itself, allowing the command to both be reused as-is in various contexts with different input values and preventing possibly sensitive text from being included in the shell history:</source>
          <target state="translated">변수 이름이 제공되지 않으면 &lt;code&gt;read&lt;/code&gt; 는 표준 입력에서 표준 출력으로의 경로 재 지정을 제공하는 특수한 경우를 입력하여 명령 대체에 유용합니다. 예를 들어, 아래의 피쉬 쉘 명령을 사용하면 명령 자체에서 하드 코딩하는 대신 콘솔에서 명령 행 인수를 통해 제공해야하는 데이터를 읽을 수 있습니다. 쉘 히스토리에 입력 값 및 민감한 텍스트가 포함되지 않도록 방지 :</target>
        </trans-unit>
        <trans-unit id="f6b617c0f8612fdf2ea16aba5ec62984acf5c44a" translate="yes" xml:space="preserve">
          <source>If only 123 and 789 exist, it will still background them and print an error about 456.</source>
          <target state="translated">123 및 789 만 존재하는 경우 여전히 백그라운드에서 456에 대한 오류를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="e5b23704e06de8e7cf41b466203c3d1a05734047" translate="yes" xml:space="preserve">
          <source>If set is called with no arguments, the names and values of all shell variables are printed in sorted order. If some of the scope or export flags have been given, only the variables matching the specified scope are printed.</source>
          <target state="translated">인수없이 set을 호출하면 모든 쉘 변수의 이름과 값이 정렬 된 순서로 인쇄됩니다. 일부 범위 또는 내보내기 플래그가 제공된 경우 지정된 범위와 일치하는 변수 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c9d5f4fcbf5a20e0012582eafdf56b977cf064da" translate="yes" xml:space="preserve">
          <source>If terminfo reports 256 color support for a terminal, 256 color support will always be enabled.</source>
          <target state="translated">If terminfo reports 256 color support for a terminal, 256 color support will always be enabled.</target>
        </trans-unit>
        <trans-unit id="302a7adb7b2bb424535b98eb0c4ef6539ea7cb20" translate="yes" xml:space="preserve">
          <source>If terminfo reports 256 color support for a terminal, support will always be enabled. To debug color palette problems, &lt;code&gt;tput colors&lt;/code&gt; may be useful to see the number of colors in terminfo for a terminal. Fish launched as &lt;code&gt;fish -d2&lt;/code&gt; will include diagnostic messages that indicate the color support mode in use.</source>
          <target state="translated">terminfo가 터미널에 대해 256 색 지원을보고하면 항상 지원이 활성화됩니다. 디버그 컬러 팔레트의 문제로 &lt;code&gt;tput colors&lt;/code&gt; 유용 할 수있는 터미널의 terminfo의 색상 수를 볼 수 있습니다. &lt;code&gt;fish -d2&lt;/code&gt; 로 시작된 물고기 에는 사용중인 색상 지원 모드를 나타내는 진단 메시지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4d30c96739992df19433df0a6e1c59dfb95af762" translate="yes" xml:space="preserve">
          <source>If that directory traversal is taking a long time, you can</source>
          <target state="translated">If that directory traversal is taking a long time, you can</target>
        </trans-unit>
        <trans-unit id="34986c35bab0e2df661c76619902534fb332f46c" translate="yes" xml:space="preserve">
          <source>If that directory traversal is taking a long time, you can &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;C&lt;/b&gt; out of it.</source>
          <target state="translated">해당 디렉토리 탐색에 시간이 오래 걸리면 &lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;C&lt;/b&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ffef75da37c5f07daa061c4afec5f2616551ca39" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$VISUAL&lt;/code&gt; environment variable is set, it will be used as the program to edit the function. If &lt;code&gt;$VISUAL&lt;/code&gt; is unset but &lt;code&gt;$EDITOR&lt;/code&gt; is set, that will be used. Otherwise, a built-in editor will be used. Note that to enter a literal newline using the built-in editor you should press</source>
          <target state="translated">If the &lt;code&gt;$VISUAL&lt;/code&gt; environment variable is set, it will be used as the program to edit the function. If &lt;code&gt;$VISUAL&lt;/code&gt; is unset but &lt;code&gt;$EDITOR&lt;/code&gt; is set, that will be used. Otherwise, a built-in editor will be used. Note that to enter a literal newline using the built-in editor you should press</target>
        </trans-unit>
        <trans-unit id="e3d023db5ee6df47941a2ca566209f059001722c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$VISUAL&lt;/code&gt; environment variable is set, it will be used as the program to edit the function. If &lt;code&gt;$VISUAL&lt;/code&gt; is unset but &lt;code&gt;$EDITOR&lt;/code&gt; is set, that will be used. Otherwise, a built-in editor will be used. Note that to enter a literal newline using the built-in editor you should press &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;Enter&lt;/b&gt;. Pressing &lt;b&gt;Enter&lt;/b&gt; signals that you are done editing the function. This does not apply to an external editor like emacs or vim.</source>
          <target state="translated">는 IF &lt;code&gt;$VISUAL&lt;/code&gt; 환경 변수가 설정되어, 그것은 편집에 프로그램 기능으로 사용됩니다. 경우 &lt;code&gt;$VISUAL&lt;/code&gt; 설정되지하지만 &lt;code&gt;$EDITOR&lt;/code&gt; 설정, 즉 사용됩니다. 그렇지 않으면 내장 편집기가 사용됩니다. 내장 편집기를 사용하여 리터럴 개행을 입력하려면 &lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;Enter를 눌러야&lt;/b&gt; 합니다. &lt;b&gt;Enter를&lt;/b&gt; 누르면 기능 편집이 완료되었음을 알립니다. emacs 또는 vim과 같은 외부 편집기에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8fb943c750f92e3917384bc05f81b775bd8db88" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--delimiter&lt;/code&gt; argument is not given, the variable &lt;code&gt;IFS&lt;/code&gt; is used as a list of characters to split on. Relying on the use of &lt;code&gt;IFS&lt;/code&gt; is deprecated and this behaviour will be removed in future versions. The default value of &lt;code&gt;IFS&lt;/code&gt; contains space, tab and newline characters. As a special case, if &lt;code&gt;IFS&lt;/code&gt; is set to the empty string, each character of the input is considered a separate token.</source>
          <target state="translated">경우 &lt;code&gt;--delimiter&lt;/code&gt; 인수가 주어지지, 변수 &lt;code&gt;IFS&lt;/code&gt; 는 에 분할하는 문자 목록으로 사용됩니다. &lt;code&gt;IFS&lt;/code&gt; 사용에 의존하는 것은 더 이상 사용되지 않으며이 기능 은 향후 버전에서 제거 될 것입니다. &lt;code&gt;IFS&lt;/code&gt; 의 기본값 은 공백, 탭 및 줄 바꾸기 문자를 포함합니다. 특별한 경우, &lt;code&gt;IFS&lt;/code&gt; 가 빈 문자열로 설정되면 입력의 각 문자는 별도의 토큰으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b9a1bc2ff2f56d3990f495529faa7ba44ead0455" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-k&lt;/code&gt; switch is used, the name of the key (such as 'down', 'up' or 'backspace') is used instead of a sequence. The names used are the same as the corresponding curses variables, but without the 'key_' prefix. (See &lt;code&gt;terminfo(5)&lt;/code&gt; for more information, or use &lt;code&gt;bind --key-names&lt;/code&gt; for a list of all available named keys.) If used in conjunction with the &lt;code&gt;-s&lt;/code&gt; switch, &lt;code&gt;bind&lt;/code&gt; will silently ignore bindings to named keys that are not found in termcap for the current &lt;code&gt;$TERMINAL&lt;/code&gt;, otherwise a warning is emitted.</source>
          <target state="translated">경우] &lt;code&gt;-k&lt;/code&gt; 스위치가 사용된다 (예 : '아래', '업'또는 '백 스페이스 키')를 키 이름 대신 시퀀스로 사용된다. 사용 된 이름은 해당 curses 변수와 동일하지만 'key_'접두사가 없습니다. (자세한 내용은 &lt;code&gt;terminfo(5)&lt;/code&gt; 를 참조하거나 사용 가능한 모든 명명 된 키 목록을 보려면 &lt;code&gt;bind --key-names&lt;/code&gt; 를 사용하십시오.) &lt;code&gt;-s&lt;/code&gt; 스위치 와 함께 사용하면 &lt;code&gt;bind&lt;/code&gt; 는 발견되지 않은 명명 된 키에 대한 바인딩을 자동으로 무시합니다. 현재 &lt;code&gt;$TERMINAL&lt;/code&gt; 의 경우 termcap 에서 그렇지 않으면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1d7b9b3be6cec368c8849bf11af8487da853a633" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;--list&lt;/code&gt; flag is specified, the current directory history is also displayed.</source>
          <target state="translated">는 IF &lt;code&gt;-l&lt;/code&gt; 또는 &lt;code&gt;--list&lt;/code&gt; 플래그가 지정되어, 현재 디렉토리의 역사도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4cfc35a3a98ed01dd389efdde71deb0bf3c6669a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;--list&lt;/code&gt; flag is specified, the current history is also displayed.</source>
          <target state="translated">는 IF &lt;code&gt;-l&lt;/code&gt; 또는 &lt;code&gt;--list&lt;/code&gt; 플래그가 지정되어, 현재의 역사도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="492a67bd7712dda8e66c7c5fc44c0836f4b18f3a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-n&lt;/code&gt; / &lt;code&gt;--any&lt;/code&gt; flag is provided, the command returns as soon as the first job completes. If it is not provided, it returns after all jobs complete.</source>
          <target state="translated">경우 &lt;code&gt;-n&lt;/code&gt; / &lt;code&gt;--any&lt;/code&gt; 플래그는 곧 첫 번째 작업이 완료로 명령 수익을 제공한다. 제공되지 않으면 모든 작업이 완료된 후 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="63b9207ee5d979afeb85211115a3c6ffa7012a71" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/tmp&lt;/code&gt; directory exists, copy the &lt;code&gt;/etc/motd&lt;/code&gt; file to it:</source>
          <target state="translated">는 IF &lt;code&gt;/tmp&lt;/code&gt; 를 디렉토리가 존재, 복사 &lt;code&gt;/etc/motd&lt;/code&gt; 그것에 파일 :</target>
        </trans-unit>
        <trans-unit id="c3b856c7f49407f5bd18390ec22c0a975e0942a6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;BROWSER&lt;/code&gt; environment variable is set, it will be used as the name of the web browser to open instead of the system default.</source>
          <target state="translated">경우 &lt;code&gt;BROWSER&lt;/code&gt; 의 환경 변수가 설정되고, 그 대신 시스템 기본으로 열려면 웹 브라우저의 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3debf54dad8f4dc6d939e041eacf2dbfc04ad3d0" translate="yes" xml:space="preserve">
          <source>If the BROWSER environment variable is set, it will be used to display the documentation. Otherwise, fish will search for a suitable browser.</source>
          <target state="translated">BROWSER 환경 변수가 설정된 경우 문서를 표시하는 데 사용됩니다. 그렇지 않으면 물고기는 적합한 브라우저를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="aa6fc1ea4246a9f77c10ddff36e9849dd9022bcd" translate="yes" xml:space="preserve">
          <source>If the above code was run with &lt;code&gt;$animal&lt;/code&gt; set to &lt;code&gt;whale&lt;/code&gt;, the output would be &lt;code&gt;mammal&lt;/code&gt;.</source>
          <target state="translated">위의 코드가 &lt;code&gt;$animal&lt;/code&gt; 을 &lt;code&gt;whale&lt;/code&gt; 로 설정하여 실행 하면 결과는 &lt;code&gt;mammal&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d75d0af6becad51e324987bba4dbf96c51e8300a" translate="yes" xml:space="preserve">
          <source>If the alias has the same name as the aliased command, it is necessary to prefix the call to the program with &lt;code&gt;command&lt;/code&gt; in order to tell fish that the function should not call itself, but rather a command with the same name. Failing to do so will cause infinite recursion bugs.</source>
          <target state="translated">별명이 별명 명령과 동일한 이름을 갖는 경우, 함수가 자신을 호출하지 말고 동일한 이름을 가진 명령을 피쉬에게 알리기 위해 &lt;code&gt;command&lt;/code&gt; 에 프로그램 호출을 접두어로 붙여야합니다 . 그렇지 않으면 무한 재귀 버그가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="49ebc34132e7660866a77bb4bd002951a641b8a0" translate="yes" xml:space="preserve">
          <source>If the alias has the same name as the aliased command, you need to prefix the call to the program with &lt;code&gt;command&lt;/code&gt; to tell fish that the function should not call itself, but rather a command with the same name. If you forget to do so, the function would call itself until the end of time. Usually fish is smart enough to figure this out and will refrain from doing so (which is hopefully in your interest).</source>
          <target state="translated">If the alias has the same name as the aliased command, you need to prefix the call to the program with &lt;code&gt;command&lt;/code&gt; to tell fish that the function should not call itself, but rather a command with the same name. If you forget to do so, the function would call itself until the end of time. Usually fish is smart enough to figure this out and will refrain from doing so (which is hopefully in your interest).</target>
        </trans-unit>
        <trans-unit id="e5185e556f9b263d1410cf1a894fc4a29463388d" translate="yes" xml:space="preserve">
          <source>If the argument you want is far back in history (e.g. 2 lines back - that's a lot of words!), type any part of it and then press</source>
          <target state="translated">If the argument you want is far back in history (e.g. 2 lines back - that's a lot of words!), type any part of it and then press</target>
        </trans-unit>
        <trans-unit id="ad3ed0aa46a2e24462a85265faa22a817cd5bf4f" translate="yes" xml:space="preserve">
          <source>If the argument you want is far back in history (e.g. 2 lines back - that's a lot of words!), type any part of it and then press &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;uarr;&lt;/b&gt;. This will show only arguments containing that part and you will get what you want much faster. Try it out, this is very convenient!</source>
          <target state="translated">당신이 원하는 인수가 멀리 다시 역사의 경우 (예를 들어 다시 2 선! - 단어의 많은입니다), 어떤의 일부를 누른 다음를 누릅니다의 입력 &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;&amp;uarr;&lt;/b&gt; . 여기에는 해당 부분이 포함 된 인수 만 표시되며 원하는 것을 훨씬 빨리 얻을 수 있습니다. 사용해보십시오, 이것은 매우 편리합니다!</target>
        </trans-unit>
        <trans-unit id="8b1303483eab8a0aafe5607e65c79febb8c3aca1" translate="yes" xml:space="preserve">
          <source>If the commandline contains</source>
          <target state="translated">명령 줄에</target>
        </trans-unit>
        <trans-unit id="e3f1eb54148bd5719468d4632589d32c09c11b49" translate="yes" xml:space="preserve">
          <source>If the commandline reads &lt;code&gt;cd m&lt;/code&gt;, place the cursor over the &lt;code&gt;m&lt;/code&gt; character and press</source>
          <target state="translated">If the commandline reads &lt;code&gt;cd m&lt;/code&gt; , place the cursor over the &lt;code&gt;m&lt;/code&gt; character and press</target>
        </trans-unit>
        <trans-unit id="4b1c190c6ad0436a0fd3fb383f1281a2e816bf89" translate="yes" xml:space="preserve">
          <source>If the commandline reads &lt;code&gt;cd m&lt;/code&gt;, place the cursor over the &lt;code&gt;m&lt;/code&gt; character and press &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;&amp;uarr;&lt;/b&gt; to search for previously typed words containing 'm'.</source>
          <target state="translated">명령 줄 읽기 경우 &lt;code&gt;cd m&lt;/code&gt; 의 위에 커서를 올려 &lt;code&gt;m&lt;/code&gt; 의 문자를 눌러 &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;&amp;uarr;&lt;/b&gt; 'm'을 포함하는 이전에 입력 된 단어를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec97b1cdbedc052d45f0ca8a3886ba07331192c" translate="yes" xml:space="preserve">
          <source>If the current directory contains the files 'foo' and 'bar', the command &lt;code&gt;echo a(ls){1,2,3}&lt;/code&gt; will output 'abar1 abar2 abar3 afoo1 afoo2 afoo3'.</source>
          <target state="translated">현재 디렉토리에 'foo'및 'bar'파일이 포함 된 경우 &lt;code&gt;echo a(ls){1,2,3}&lt;/code&gt; 명령 은 'abar1 abar2 abar3 afoo1 afoo2 afoo3'을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="3b9446dcdf384793d9dbf8ed3d708bf58cbc9557" translate="yes" xml:space="preserve">
          <source>If the current directory contains the files 'foo' and 'bar', the command &lt;code&gt;echo a(ls){1,2,3}&lt;/code&gt; will output &lt;code&gt;abar1 abar2 abar3 afoo1 afoo2 afoo3&lt;/code&gt;.</source>
          <target state="translated">If the current directory contains the files 'foo' and 'bar', the command &lt;code&gt;echo a(ls){1,2,3}&lt;/code&gt; will output &lt;code&gt;abar1 abar2 abar3 afoo1 afoo2 afoo3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea966f7daecf90f40c09560ec0ace32a38679be8" translate="yes" xml:space="preserve">
          <source>If the end is smaller than the start, or the start is larger than the end, range expansion will go in reverse. This is unless exactly one of the given indices is negative, so the direction doesn't change if the list has fewer elements than expected.</source>
          <target state="translated">If the end is smaller than the start, or the start is larger than the end, range expansion will go in reverse. This is unless exactly one of the given indices is negative, so the direction doesn't change if the list has fewer elements than expected.</target>
        </trans-unit>
        <trans-unit id="9ac01aa8bdf61c4705d1b573ca6b14e107487f86" translate="yes" xml:space="preserve">
          <source>If the expression is successfully evaluated and doesn't over/underflow or return NaN the return &lt;code&gt;status&lt;/code&gt; is zero (success) else one.</source>
          <target state="translated">식이 성공적으로 평가되고 오버플로 / 언더 플로 또는 NaN을 반환하지 않으면 반환 &lt;code&gt;status&lt;/code&gt; 는 0 (성공)입니다.</target>
        </trans-unit>
        <trans-unit id="5cfff00b5bb7a05a9b5b06be91a9cc46be32a1f7" translate="yes" xml:space="preserve">
          <source>If the first and second parts are skipped, they are assumed to be &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt;, respectively. As an example, &lt;code&gt;r,u+w&lt;/code&gt; means all users should have read access and the file owner should also have write access.</source>
          <target state="translated">첫 번째 부분과 두 번째 부분을 건너 뛰면 각각 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;=&lt;/code&gt; 로 간주됩니다 . 예를 들어, &lt;code&gt;r,u+w&lt;/code&gt; 는 모든 사용자에게 읽기 권한이 있어야하고 파일 소유자에게도 쓰기 권한이 있어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="51826fa22bf5b5c7586ce652a67a6e4318f4ac64" translate="yes" xml:space="preserve">
          <source>If the function definition is changed, all running shells will automatically reload the altered version.</source>
          <target state="translated">If the function definition is changed, all running shells will automatically reload the altered version.</target>
        </trans-unit>
        <trans-unit id="154cdf4f784ed79e1fcb74335c0c901b6cf4ac90" translate="yes" xml:space="preserve">
          <source>If the line you want is far back in the history, type any part of the line and then press Up one or more times. This will constrain the recall to lines that include this text, and you will get to the line you want much faster. This replaces &quot;!vi&quot;, &quot;!?bar.c&quot; and the like.</source>
          <target state="translated">원하는 줄이 기록에서 훨씬 뒤로 돌아 오면 줄의 일부를 입력 한 다음 위로를 한 번 이상 누릅니다. 이렇게하면이 텍스트를 포함하는 줄로 리콜을 제한 할 수 있으며 원하는 줄로 훨씬 빨리 갈 수 있습니다. 이것은 &quot;! vi&quot;, &quot;!? bar.c&quot;등을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="70006a59c6935a4438f9d0040be162c8ee9ec5a8" translate="yes" xml:space="preserve">
          <source>If the list is visible, pressing control-S (or the &lt;code&gt;pager-toggle-search&lt;/code&gt; binding) will allow filtering the list. Shift-tab (or the &lt;code&gt;complete-and-search&lt;/code&gt; binding) will trigger completion with the search field immediately visible.</source>
          <target state="translated">목록이 표시되면 control-S (또는 &lt;code&gt;pager-toggle-search&lt;/code&gt; 바인딩)를 누르면 목록을 필터링 할 수 있습니다. Shift- 탭 (또는 &lt;code&gt;complete-and-search&lt;/code&gt; 바인딩)은 검색 필드가 즉시 보이는 상태에서 완료를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="d76a8116548a88ed416d142b0ea322f0ccb59543" translate="yes" xml:space="preserve">
          <source>If the list is visible, pressing control-S (or the &lt;code&gt;pager-toggle-search&lt;/code&gt; binding) will allow filtering the list. Shift-tab (or the &lt;code&gt;complete-and-search&lt;/code&gt; binding) will trigger completion with the search field immediately visible. These are the general purpose tab completions that &lt;code&gt;fish&lt;/code&gt; provides:</source>
          <target state="translated">If the list is visible, pressing control-S (or the &lt;code&gt;pager-toggle-search&lt;/code&gt; binding) will allow filtering the list. Shift-tab (or the &lt;code&gt;complete-and-search&lt;/code&gt; binding) will trigger completion with the search field immediately visible. These are the general purpose tab completions that &lt;code&gt;fish&lt;/code&gt; provides:</target>
        </trans-unit>
        <trans-unit id="275b4b014bd30e8806c2588d2da955cb7daf020a" translate="yes" xml:space="preserve">
          <source>If the operation fails, an error will be reported.</source>
          <target state="translated">If the operation fails, an error will be reported.</target>
        </trans-unit>
        <trans-unit id="29df263ac386a0b20ba5f9a3e6fe000d33b8c6f2" translate="yes" xml:space="preserve">
          <source>If the output is piped to &lt;a href=&quot;cmds/string#cmd-string-split&quot;&gt;string split or string split0&lt;/a&gt; as the last step, those splits are used as they appear and no additional splitting on newlines takes place.</source>
          <target state="translated">If the output is piped to &lt;a href=&quot;cmds/string#cmd-string-split&quot;&gt;string split or string split0&lt;/a&gt; as the last step, those splits are used as they appear and no additional splitting on newlines takes place.</target>
        </trans-unit>
        <trans-unit id="e4c01f00f1709a1d845be8af766e2896516906fa" translate="yes" xml:space="preserve">
          <source>If the path is invalid no translated path will be written to stdout and an error will be reported.</source>
          <target state="translated">경로가 유효하지 않으면 변환 된 경로가 stdout에 기록되지 않고 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="e1e2f0cd5d9c3189924438eab165e537469221dd" translate="yes" xml:space="preserve">
          <source>If the specified file descriptor is a terminal device, the exit status of the command is zero. Otherwise, the exit status is non-zero. No messages are printed to standard error.</source>
          <target state="translated">If the specified file descriptor is a terminal device, the exit status of the command is zero. Otherwise, the exit status is non-zero. No messages are printed to standard error.</target>
        </trans-unit>
        <trans-unit id="e907fd3510899683ab1ac3f96d2aac1979d9258b" translate="yes" xml:space="preserve">
          <source>If the specified file descriptor is a tty, the exit status of the command is zero. Otherwise, the exit status is non-zero. No messages are printed to standard error.</source>
          <target state="translated">지정된 파일 설명자가 tty 인 경우 명령의 종료 상태는 0입니다. 그렇지 않으면 종료 상태는 0이 아닙니다. 표준 오류로 인쇄 된 메시지가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe06c7e257d873be32fd7989f5055c27083aeab6" translate="yes" xml:space="preserve">
          <source>If the user enters any additional arguments after the function, they are inserted into the environment &lt;a href=&quot;../index#variables-lists&quot;&gt;variable list&lt;/a&gt;&lt;code&gt;$argv&lt;/code&gt;. If the &lt;code&gt;--argument-names&lt;/code&gt; option is provided, the arguments are also assigned to names specified in that option.</source>
          <target state="translated">If the user enters any additional arguments after the function, they are inserted into the environment &lt;a href=&quot;../index#variables-lists&quot;&gt;variable list&lt;/a&gt; &lt;code&gt;$argv&lt;/code&gt; . If the &lt;code&gt;--argument-names&lt;/code&gt; option is provided, the arguments are also assigned to names specified in that option.</target>
        </trans-unit>
        <trans-unit id="bd0e2ed527cbeaac8bf34e5481dc729ba00211c1" translate="yes" xml:space="preserve">
          <source>If the user enters any additional arguments after the function, they are inserted into the environment &lt;a href=&quot;index#variables-arrays&quot;&gt;variable array&lt;/a&gt;&lt;code&gt;$argv&lt;/code&gt;. If the &lt;code&gt;--argument-names&lt;/code&gt; option is provided, the arguments are also assigned to names specified in that option.</source>
          <target state="translated">사용자가 함수 뒤에 추가 인수를 입력하면 환경 &lt;a href=&quot;index#variables-arrays&quot;&gt;변수 배열 &lt;/a&gt; &lt;code&gt;$argv&lt;/code&gt; 삽입됩니다 . 는 IF &lt;code&gt;--argument-names&lt;/code&gt; 옵션이 제공되며, 인수는 그 옵션에 지정된 이름에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="89093e95575f5c91e69c231cc514a5f888c355b9" translate="yes" xml:space="preserve">
          <source>If the variable $animal contains the name of an animal, the following code would attempt to classify it:</source>
          <target state="translated">변수 $ animal에 동물의 이름이 포함되어 있으면 다음 코드는이를 분류하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="081ef0f3bbeaf93e50b97aca197ba4dab7103ab9" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;MANPATH&lt;/code&gt; is defined and not empty, print the contents. (If &lt;code&gt;MANPATH&lt;/code&gt; is not defined, then it will expand to zero arguments, unless quoted.)</source>
          <target state="translated">변수 &lt;code&gt;MANPATH&lt;/code&gt; 가 정의되어 있고 비어 있지 않은 경우 내용을 인쇄하십시오. ( &lt;code&gt;MANPATH&lt;/code&gt; 가 정의되어 있지 않으면 인용되지 않는 한 인수가 0으로 확장됩니다.)</target>
        </trans-unit>
        <trans-unit id="b85b340b71b7dd9ea477da93a9f45e28372572db" translate="yes" xml:space="preserve">
          <source>If the variable name is one or more array elements, such as &lt;code&gt;PATH[1 3 7]&lt;/code&gt;, only those array elements specified will be changed. If you specify a negative index when expanding or assigning to an array variable, the index will be calculated from the end of the array. For example, the index -1 means the last index of an array.</source>
          <target state="translated">변수 이름이 하나 이상의 배열 요소 (예 : &lt;code&gt;PATH[1 3 7]&lt;/code&gt; 이면 지정된 배열 요소 만 변경됩니다. 배열 변수를 확장하거나 할당 할 때 음수 인덱스를 지정하면 배열 끝에서 인덱스가 계산됩니다. 예를 들어, 인덱스 -1은 배열의 마지막 인덱스를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2711332599fb67538cfe4343e904027c558ff897" translate="yes" xml:space="preserve">
          <source>If the variable name is one or more list elements, such as &lt;code&gt;PATH[1 3 7]&lt;/code&gt;, only those list elements specified will be changed. If you specify a negative index when expanding or assigning to a list variable, the index will be calculated from the end of the list. For example, the index -1 means the last index of a list.</source>
          <target state="translated">If the variable name is one or more list elements, such as &lt;code&gt;PATH[1 3 7]&lt;/code&gt; , only those list elements specified will be changed. If you specify a negative index when expanding or assigning to a list variable, the index will be calculated from the end of the list. For example, the index -1 means the last index of a list.</target>
        </trans-unit>
        <trans-unit id="788fcc2dc7b9ec9c743aa985b73d706a1c941ace" translate="yes" xml:space="preserve">
          <source>If there are multiple files with the same name in these directories, only the first will be executed. They are executed in order of their filename, sorted (like globs) in a natural order (i.e. &quot;01&quot; sorts before &quot;2&quot;).</source>
          <target state="translated">이 디렉토리에 이름이 같은 파일이 여러 개 있으면 첫 번째 파일 만 실행됩니다. 파일 이름 순서대로 실행되며 (예 : glob와 같이) 자연 순서로 정렬됩니다 (예 : &quot;01&quot;은 &quot;2&quot;이전에 정렬).</target>
        </trans-unit>
        <trans-unit id="37b3f6c1d9e2443aab8662a7a439797d66881a18" translate="yes" xml:space="preserve">
          <source>If there is no function called &lt;code&gt;NAME&lt;/code&gt; a new function will be created with the specified name</source>
          <target state="translated">&lt;code&gt;NAME&lt;/code&gt; 이라는 함수가 없으면 지정된 이름으로 새 함수가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6d5cfe09681412194f4ba98b5cd9ee3fb9a19be4" translate="yes" xml:space="preserve">
          <source>If there is nothing between a brace and a comma or two commas, it's interpreted as an empty element.</source>
          <target state="translated">중괄호와 쉼표 또는 두 개의 쉼표 사이에 아무 것도 없으면 빈 요소로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="bda5467f9834c7878e79dd21cd4d2f3d7dd7c4a6" translate="yes" xml:space="preserve">
          <source>If there is nothing between a brace and a comma or two commas, it's interpreted as an empty element:</source>
          <target state="translated">If there is nothing between a brace and a comma or two commas, it's interpreted as an empty element:</target>
        </trans-unit>
        <trans-unit id="24adce4068128d584888031a1553f03853a858ae" translate="yes" xml:space="preserve">
          <source>If there's more than one possibility, it will list them</source>
          <target state="translated">If there's more than one possibility, it will list them</target>
        </trans-unit>
        <trans-unit id="afe6214497e3e493ce7fed66861473c8f9d5c2d3" translate="yes" xml:space="preserve">
          <source>If there's more than one possibility, it will list them:</source>
          <target state="translated">둘 이상의 가능성이있는 경우 다음이 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="463c7b41266bb02e7be790b635471da72331d8c9" translate="yes" xml:space="preserve">
          <source>If two braces do not contain a &quot;,&quot; or a variable expansion, they will not be expanded in this manner:</source>
          <target state="translated">If two braces do not contain a &quot;,&quot; or a variable expansion, they will not be expanded in this manner:</target>
        </trans-unit>
        <trans-unit id="1b4ecf432926bdf9219384030390dce4a62ae339" translate="yes" xml:space="preserve">
          <source>If you are developing another program and would like to ship completions with your program, install them to the &quot;vendor&quot; completions directory. As this path may vary from system to system, the &lt;code&gt;pkgconfig&lt;/code&gt; framework should be used to discover this path with the output of &lt;code&gt;pkg-config --variable completionsdir fish&lt;/code&gt;.</source>
          <target state="translated">다른 프로그램을 개발 중이고 프로그램과 함께 완성품을 배송하려면 &quot;공급 업체&quot;완성 디렉토리에 설치하십시오. 이 경로는 시스템마다 다를 수 있으므로 &lt;code&gt;pkgconfig&lt;/code&gt; 프레임 워크를 사용하여 &lt;code&gt;pkg-config --variable completionsdir fish&lt;/code&gt; 의 출력으로이 경로를 발견해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f3b96ff834aa659d4dcfe109c2f08409908bba2c" translate="yes" xml:space="preserve">
          <source>If you are developing another program and would like to ship completions with your program, install them to the &quot;vendor&quot; completions directory. As this path may vary from system to system, the pkgconfig framework should be used to discover this path with the output of &lt;code&gt;pkg-config --variable completionsdir fish&lt;/code&gt;. Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.</source>
          <target state="translated">If you are developing another program and would like to ship completions with your program, install them to the &quot;vendor&quot; completions directory. As this path may vary from system to system, the pkgconfig framework should be used to discover this path with the output of &lt;code&gt;pkg-config --variable completionsdir fish&lt;/code&gt; . Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.</target>
        </trans-unit>
        <trans-unit id="a2e3bcc2c86a34d726c99da6041e118aebc6aab5" translate="yes" xml:space="preserve">
          <source>If you are developing another program, you may wish to install configuration which is run for all users of the fish shell on a system. This is discouraged; if not carefully written, they may have side-effects or slow the startup of the shell. Additionally, users of other shells will not benefit from the Fish-specific configuration. However, if they are absolutely required, you may install them to the &quot;vendor&quot; configuration directory. As this path may vary from system to system, the &lt;code&gt;pkgconfig&lt;/code&gt; framework should be used to discover this path with the output of &lt;code&gt;pkg-config --variable confdir fish&lt;/code&gt;.</source>
          <target state="translated">다른 프로그램을 개발하는 경우 시스템에서 모든 피쉬 쉘 사용자에게 실행되는 구성을 설치하려고 할 수 있습니다. 이것은 권장되지 않습니다. 주의해서 쓰지 않으면 부작용이 있거나 쉘의 시작 속도가 느려질 수 있습니다. 또한 다른 쉘 사용자는 물고기 별 구성의 이점을 얻지 못합니다. 그러나 반드시 필요한 경우 &quot;공급 업체&quot;구성 디렉토리에 설치할 수 있습니다. 이 경로는 시스템마다 다를 수 있으므로 &lt;code&gt;pkgconfig&lt;/code&gt; 프레임 워크를 사용하여 &lt;code&gt;pkg-config --variable confdir fish&lt;/code&gt; 출력으로이 경로를 검색해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4916db32b6aa8cbf9c1ffbb01d73d5df4a8870cc" translate="yes" xml:space="preserve">
          <source>If you are developing another program, you may wish to install functions which are available for all users of the fish shell on a system. They can be installed to the &quot;vendor&quot; functions directory. As this path may vary from system to system, the &lt;code&gt;pkgconfig&lt;/code&gt; framework should be used to discover this path with the output of &lt;code&gt;pkg-config --variable functionsdir fish&lt;/code&gt;.</source>
          <target state="translated">다른 프로그램을 개발하는 경우 시스템에서 모든 피쉬 쉘 사용자가 사용할 수있는 기능을 설치할 수 있습니다. &quot;공급 업체&quot;기능 디렉토리에 설치할 수 있습니다. 이 경로는 시스템마다 다를 수 있으므로 &lt;code&gt;pkgconfig&lt;/code&gt; 프레임 워크를 사용하여 &lt;code&gt;pkg-config --variable functionsdir fish&lt;/code&gt; 의 출력으로이 경로를 발견해야합니다 .</target>
        </trans-unit>
        <trans-unit id="24d577aff02c57ccc535834fabc2b9ff18d8c605" translate="yes" xml:space="preserve">
          <source>If you are developing another program, you may wish to install functions which are available for all users of the fish shell on a system. They can be installed to the &quot;vendor&quot; functions directory. As this path may vary from system to system, the &lt;code&gt;pkgconfig&lt;/code&gt; framework should be used to discover this path with the output of &lt;code&gt;pkg-config --variable functionsdir fish&lt;/code&gt;. Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.</source>
          <target state="translated">If you are developing another program, you may wish to install functions which are available for all users of the fish shell on a system. They can be installed to the &quot;vendor&quot; functions directory. As this path may vary from system to system, the &lt;code&gt;pkgconfig&lt;/code&gt; framework should be used to discover this path with the output of &lt;code&gt;pkg-config --variable functionsdir fish&lt;/code&gt; . Your installation system should support a custom path to override the pkgconfig path, as other distributors may need to alter it easily.</target>
        </trans-unit>
        <trans-unit id="423e276545b7dd53d72e587423056db3d40ae703" translate="yes" xml:space="preserve">
          <source>If you are familiar with these, it is useful to know how &lt;code&gt;string&lt;/code&gt; differs from them.</source>
          <target state="translated">If you are familiar with these, it is useful to know how &lt;code&gt;string&lt;/code&gt; differs from them.</target>
        </trans-unit>
        <trans-unit id="2c8709afb8c37b08fcb75856aca6d9778e8772cd" translate="yes" xml:space="preserve">
          <source>If you are just interested in success or failure, you can run the command directly as the if-condition:</source>
          <target state="translated">성공 또는 실패에 관심이있는 경우 if 조건으로 명령을 직접 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b4679db7ed1ee15be09b7a815eb852cdada744e" translate="yes" xml:space="preserve">
          <source>If you do not use any brackets, all the elements of the array will be written as separate items. This means you can easily iterate over an array using this syntax:</source>
          <target state="translated">대괄호를 사용하지 않으면 배열의 모든 요소가 별도의 항목으로 작성됩니다. 이는 다음 구문을 사용하여 배열을 쉽게 반복 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="80a3062c14429e2bf432a524df5b36623d385389" translate="yes" xml:space="preserve">
          <source>If you do not use any brackets, all the elements of the list will be written as separate items. This means you can easily iterate over a list using this syntax:</source>
          <target state="translated">If you do not use any brackets, all the elements of the list will be written as separate items. This means you can easily iterate over a list using this syntax:</target>
        </trans-unit>
        <trans-unit id="21121c72874a1f506d3167db9734fb72635e8aba" translate="yes" xml:space="preserve">
          <source>If you do this via a function it should be defined with the &lt;code&gt;--no-scope-shadowing&lt;/code&gt; flag. Otherwise it won't have access to those variables.</source>
          <target state="translated">함수를 통해이를 수행하는 경우 &lt;code&gt;--no-scope-shadowing&lt;/code&gt; 플래그 로 정의해야합니다 . 그렇지 않으면 해당 변수에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf34bb52e96a3b222773c87c97bf5316f69250b8" translate="yes" xml:space="preserve">
          <source>If you enabled the informative status, there are numerous customization options, which can be controlled with fish variables.</source>
          <target state="translated">If you enabled the informative status, there are numerous customization options, which can be controlled with fish variables.</target>
        </trans-unit>
        <trans-unit id="76fc284188c8102e752b1bddb9f0226a85c1fbff" translate="yes" xml:space="preserve">
          <source>If you have a question not answered by this documentation, there are several avenues for help:</source>
          <target state="translated">이 문서에서 질문에 대한 답변을 얻지 못한 경우 몇 가지 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5d69fd8cf3faf8da11aa1c87838469a40522c72" translate="yes" xml:space="preserve">
          <source>If you have a strong understanding of other shells, and want to know what &lt;code&gt;fish&lt;/code&gt; does differently, search for the magic phrase &lt;em&gt;unlike other shells&lt;/em&gt;, which is used to call out important differences.</source>
          <target state="translated">다른 껍질에 대해 잘 알고 있고 &lt;code&gt;fish&lt;/code&gt; 가 어떻게 다른지 알고 싶다면 &lt;em&gt;다른 껍질과 달리&lt;/em&gt; 마법의 문구를 검색하십시오.이 문구 &lt;em&gt;는&lt;/em&gt; 중요한 차이점을 불러내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d94e356f3d06bfc0847471bd8ac63c7fdd35e968" translate="yes" xml:space="preserve">
          <source>If you have an improvement for fish, you can submit it via the mailing list or the GitHub page.</source>
          <target state="translated">생선이 개선 된 경우 메일 링리스트 또는 GitHub 페이지를 통해 생선을 제출할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c91aaa3641347d6b92a729c32a7d96c010b6da2" translate="yes" xml:space="preserve">
          <source>If you have written new completions for a common Unix command, please consider sharing your work by submitting it via the instructions in &lt;a href=&quot;#more-help&quot;&gt;Further help and development&lt;/a&gt;.</source>
          <target state="translated">공통 Unix 명령에 대한 새로운 완성을 작성했다면 &lt;a href=&quot;#more-help&quot;&gt;추가 도움말 및 개발&lt;/a&gt; 의 지시 사항을 통해 작업을 제출하여 공유를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="801a4bfeff44c78289adc6da559907889b10b7ff" translate="yes" xml:space="preserve">
          <source>If you installed a prepackaged version of fish, the package manager should have already done this for you.</source>
          <target state="translated">사전 패키지 버전의 물고기를 설치 한 경우 패키지 관리자가 이미이 작업을 수행 했어야합니다.</target>
        </trans-unit>
        <trans-unit id="bacc9cf3f5b8aece5e2cb795329bd9e98f414229" translate="yes" xml:space="preserve">
          <source>If you installed fish manually (e.g. by compiling it, not by using a package manager), you first need to add fish to the list of shells by executing the following command (assuming you installed fish in /usr/local):</source>
          <target state="translated">물고기를 수동으로 설치 한 경우 (예 : 패키지 관리자를 사용하지 않고 컴파일하여), / usr / local에 물고기를 설치했다고 가정하면 먼저 다음 명령을 실행하여 조개 목록에 물고기를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="cec1a3f92a8c27f32a8f6e6cb86da5cd7afb4270" translate="yes" xml:space="preserve">
          <source>If you instead want to put a suspended job into the background, use the &lt;a href=&quot;cmds/bg#cmd-bg&quot;&gt;bg&lt;/a&gt; command.</source>
          <target state="translated">If you instead want to put a suspended job into the background, use the &lt;a href=&quot;cmds/bg#cmd-bg&quot;&gt;bg&lt;/a&gt; command.</target>
        </trans-unit>
        <trans-unit id="24dbcaa65ea45136e4556660a86f87890a258184" translate="yes" xml:space="preserve">
          <source>If you instead want to put a suspended job into the background, use the &lt;a href=&quot;commands#bg&quot;&gt;&lt;code&gt;bg&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">대신 일시 중단 된 작업을 백그라운드에 배치하려면 &lt;a href=&quot;commands#bg&quot;&gt; &lt;code&gt;bg&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d15c732f3a561ab865f45eb2b69dbf51b681f71" translate="yes" xml:space="preserve">
          <source>If you prefer to use a different browser (other than as described above) for fish help, you can set the fish_help_browser variable. This variable may be set as a list, where the first element is the browser command and the rest are browser options.</source>
          <target state="translated">If you prefer to use a different browser (other than as described above) for fish help, you can set the fish_help_browser variable. This variable may be set as a list, where the first element is the browser command and the rest are browser options.</target>
        </trans-unit>
        <trans-unit id="76575622923fc6960275a0372650f7e641f7d23c" translate="yes" xml:space="preserve">
          <source>If you prefer to use a different browser (other than as described above) for fish help, you can set the fish_help_browser variable. This variable may be set as an array, where the first element is the browser command and the rest are browser options.</source>
          <target state="translated">물고기 도움말에 다른 브라우저 (위에서 설명한 것 이외의)를 사용하려면 fish_help_browser 변수를 설정할 수 있습니다. 이 변수는 배열로 설정 될 수 있습니다. 여기서 첫 번째 요소는 브라우저 명령이고 나머지는 브라우저 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="e98db4a9618c4e99c4cfeeb47be4e315b3159f68" translate="yes" xml:space="preserve">
          <source>If you specify a negative index when expanding or assigning to a list variable, the index will be calculated from the end of the list. For example, the index -1 means the last index of a list.</source>
          <target state="translated">If you specify a negative index when expanding or assigning to a list variable, the index will be calculated from the end of the list. For example, the index -1 means the last index of a list.</target>
        </trans-unit>
        <trans-unit id="6b10dc2d52b83a3f3bcbb9eafde410131a7638e1" translate="yes" xml:space="preserve">
          <source>If you specify a negative index when expanding or assigning to an array variable, the index will be calculated from the end of the array. For example, the index -1 means the last index of an array.</source>
          <target state="translated">배열 변수를 확장하거나 할당 할 때 음수 인덱스를 지정하면 인덱스가 배열 끝에서 계산됩니다. 예를 들어, 인덱스 -1은 배열의 마지막 인덱스를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bef2a5da408bc0ccc604bb6e7c2ada1e1e368d28" translate="yes" xml:space="preserve">
          <source>If you specify both &lt;code&gt;--prefix&lt;/code&gt; and &lt;code&gt;--contains&lt;/code&gt; the last flag seen is used.</source>
          <target state="translated">&lt;code&gt;--prefix&lt;/code&gt; 와 &lt;code&gt;--contains&lt;/code&gt; 를 모두 지정 하면 마지막으로 본 플래그가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cfeb5cfbb4d7330298cd9ae2e7db448aa2300961" translate="yes" xml:space="preserve">
          <source>If you specify the &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;--entire&lt;/code&gt; then each matching string is printed including any prefix or suffix not matched by the pattern (equivalent to &lt;code&gt;grep&lt;/code&gt; without the &lt;code&gt;-o&lt;/code&gt; flag). You can, obviously, achieve the same result by prepending and appending &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;.*&lt;/code&gt; depending on whether or not you have specified the &lt;code&gt;--regex&lt;/code&gt; flag. The &lt;code&gt;--entire&lt;/code&gt; flag is simply a way to avoid having to complicate the pattern in that fashion and make the intent of the &lt;code&gt;string match&lt;/code&gt; clearer. Without &lt;code&gt;--entire&lt;/code&gt; and &lt;code&gt;--regex&lt;/code&gt;, a PATTERN will need to match the entire STRING before it will be reported.</source>
          <target state="translated">&lt;code&gt;-e&lt;/code&gt; 또는 &lt;code&gt;--entire&lt;/code&gt; 를 지정하면 패턴과 일치하지 않는 접 두부 또는 접미 부를 포함하여 각 일치하는 문자열이 인쇄됩니다 ( &lt;code&gt;-o&lt;/code&gt; 플래그 없이 &lt;code&gt;grep&lt;/code&gt; 과 동일 ). &lt;code&gt;--regex&lt;/code&gt; 플래그를 지정했는지 여부에 따라 &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;.*&lt;/code&gt; 를 앞에 추가하고 추가하여 동일한 결과를 얻을 수 있습니다 . &lt;code&gt;--entire&lt;/code&gt; 플래그는 단순히 패션의 패턴을 복잡하게하고의 의도 할 필요가 없도록하는 방법입니다 &lt;code&gt;string match&lt;/code&gt; 명확. &lt;code&gt;--entire&lt;/code&gt; 및 &lt;code&gt;--regex&lt;/code&gt; 가 없으면 PATTERN이 (가)보고되기 전에 전체 STRING과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="22a9feadf64d822a318f10f2b4793d1a2316c159" translate="yes" xml:space="preserve">
          <source>If you specify the &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--filter&lt;/code&gt; flag then each input string is printed only if a replacement was done. This is useful where you would otherwise use this idiom: &lt;code&gt;a_cmd | string match pattern | string replace pattern new_pattern&lt;/code&gt;. You can instead just write &lt;code&gt;a_cmd | string replace --filter pattern new_pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--filter&lt;/code&gt; 플래그를 지정하면 교체가 완료된 경우에만 각 입력 문자열이 인쇄됩니다. 이 관용구를 다르게 사용하는 경우에 유용합니다. &lt;code&gt;a_cmd | string match pattern | string replace pattern new_pattern&lt;/code&gt; . 대신 &lt;code&gt;a_cmd | string replace --filter pattern new_pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8e54ae0a24762829d8f55a86df97428a46a48f0" translate="yes" xml:space="preserve">
          <source>If you want to add the directory &lt;code&gt;~/linux/bin&lt;/code&gt; to your PATH variable when using a login shell, add the following to your &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt; file:</source>
          <target state="translated">로그인 쉘을 사용할 때 &lt;code&gt;~/linux/bin&lt;/code&gt; 디렉토리 를 PATH 변수에 추가하려면 &lt;code&gt;~/.config/fish/config.fish&lt;/code&gt; 파일에 다음을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="3226bbbfea92d52214a04066c17b75561d8b1dfd" translate="yes" xml:space="preserve">
          <source>If you want to find out more about the echo command used above, read the manual page for the echo command by writing: &lt;code&gt;man echo&lt;/code&gt;</source>
          <target state="translated">위에서 사용한 echo 명령에 대한 자세한 내용을 보려면 다음을 작성하여 echo 명령 매뉴얼 페이지를 읽으십시오. &lt;code&gt;man echo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf2181e509bdee84b390ead8fe1261883f65f450" translate="yes" xml:space="preserve">
          <source>If you want to know if a variable has &lt;em&gt;no elements&lt;/em&gt;, use &lt;code&gt;set -q var[1]&lt;/code&gt;.</source>
          <target state="translated">If you want to know if a variable has &lt;em&gt;no elements&lt;/em&gt;, use &lt;code&gt;set -q var[1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6b8934a463057ab4cbebc293cbcc2bde13fda93" translate="yes" xml:space="preserve">
          <source>If you want to learn more about fish, there is &lt;a href=&quot;index&quot;&gt;lots of detailed documentation&lt;/a&gt;, an &lt;a href=&quot;https://lists.sourceforge.net/lists/listinfo/fish-users&quot;&gt;official mailing list&lt;/a&gt;, the IRC channel #fish on &lt;code&gt;irc.oftc.net&lt;/code&gt;, and the &lt;a href=&quot;https://github.com/fish-shell/fish-shell/&quot;&gt;github page&lt;/a&gt;.</source>
          <target state="translated">당신이 물고기에 대한 자세한 내용을 원한다면,이 &lt;a href=&quot;index&quot;&gt;자세한 설명서를 많이&lt;/a&gt; , &lt;a href=&quot;https://lists.sourceforge.net/lists/listinfo/fish-users&quot;&gt;공식 메일 링리스트&lt;/a&gt; ,에 IRC 채널 #fish &lt;code&gt;irc.oftc.net&lt;/code&gt; 및 &lt;a href=&quot;https://github.com/fish-shell/fish-shell/&quot;&gt;GitHub의 페이지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa7777db3b385617c9905b1bb85dce8643e34e91" translate="yes" xml:space="preserve">
          <source>If you want to learn more about fish, there is &lt;a href=&quot;index#intro&quot;&gt;lots of detailed documentation&lt;/a&gt;, the &lt;a href=&quot;https://gitter.im/fish-shell/fish-shell&quot;&gt;official gitter channel&lt;/a&gt;, an &lt;a href=&quot;https://lists.sourceforge.net/lists/listinfo/fish-users&quot;&gt;official mailing list&lt;/a&gt;, and the &lt;a href=&quot;https://github.com/fish-shell/fish-shell/&quot;&gt;github page&lt;/a&gt;.</source>
          <target state="translated">If you want to learn more about fish, there is &lt;a href=&quot;index#intro&quot;&gt;lots of detailed documentation&lt;/a&gt;, the &lt;a href=&quot;https://gitter.im/fish-shell/fish-shell&quot;&gt;official gitter channel&lt;/a&gt;, an &lt;a href=&quot;https://lists.sourceforge.net/lists/listinfo/fish-users&quot;&gt;official mailing list&lt;/a&gt;, and the &lt;a href=&quot;https://github.com/fish-shell/fish-shell/&quot;&gt;github page&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="19d1a8c24236cf7d05190b1115ef30aaad303cfb" translate="yes" xml:space="preserve">
          <source>If you want to make your command line more productive, more useful, and more fun, without learning a bunch of arcane syntax and configuration options, then &lt;code&gt;fish&lt;/code&gt; might be just what you're looking for!</source>
          <target state="translated">여러 가지 구문과 구성 옵션을 배우지 않고 명령 줄을보다 생산적이고 유용하고 재미있게 만들고 싶다면 &lt;code&gt;fish&lt;/code&gt; 가 원하는 것일 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="240e39aa619c5f139c2593362dec95cdca1dfa27" translate="yes" xml:space="preserve">
          <source>If you want to organize your configuration, fish also reads commands in .fish files in &lt;code&gt;~/.config/fish/conf.d/&lt;/code&gt;. See &lt;a href=&quot;index#initialization&quot;&gt;initialization&lt;/a&gt; for the details.</source>
          <target state="translated">If you want to organize your configuration, fish also reads commands in .fish files in &lt;code&gt;~/.config/fish/conf.d/&lt;/code&gt; . See &lt;a href=&quot;index#initialization&quot;&gt;initialization&lt;/a&gt; for the details.</target>
        </trans-unit>
        <trans-unit id="57bb991addeaec34e0d2e4ff1072fa3e66d59b28" translate="yes" xml:space="preserve">
          <source>If you want to override a variable for a single command, you can use &quot;var=val&quot; statements before the command:</source>
          <target state="translated">If you want to override a variable for a single command, you can use &quot;var=val&quot; statements before the command:</target>
        </trans-unit>
        <trans-unit id="b010bfc3d915896fa771aef1b796169616d992f5" translate="yes" xml:space="preserve">
          <source>If you want to reuse several arguments from the same line (&quot;!!:3*&quot; and the like), consider recalling the whole line and removing what you don't need (</source>
          <target state="translated">If you want to reuse several arguments from the same line (&quot;!!:3*&quot; and the like), consider recalling the whole line and removing what you don't need (</target>
        </trans-unit>
        <trans-unit id="817bbc583c325d82f70d5e4e389c9fb588a7021e" translate="yes" xml:space="preserve">
          <source>If you want to reuse several arguments from the same line (&quot;!!:3*&quot; and the like), consider recalling the whole line and removing what you don't need (&lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;D&lt;/b&gt; and &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;Backspace&lt;/b&gt; are your friends).</source>
          <target state="translated">같은 라인에서 여러 인수를 재사용 할 경우 ( &quot;! : 3 *&quot;등), 전체 라인을 리콜하고 필요없는 것을 제거하십시오 ( &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;D&lt;/b&gt; 와 &lt;em&gt;Alt 키&lt;/em&gt; - &lt;b&gt;백 스페이스&lt;/b&gt; 당신의 친구를).</target>
        </trans-unit>
        <trans-unit id="17b2c50714eca6eb3a1c4f418309af6c45fec63f" translate="yes" xml:space="preserve">
          <source>If you want to run a set of commands when &lt;code&gt;fish&lt;/code&gt; exits, use an &lt;a href=&quot;#event&quot;&gt;event handler&lt;/a&gt; that is triggered by the exit of the shell:</source>
          <target state="translated">&lt;code&gt;fish&lt;/code&gt; 종료 될 때 일련의 명령을 실행 하려면 쉘 종료에 의해 트리거되는 &lt;a href=&quot;#event&quot;&gt;이벤트 핸들러&lt;/a&gt; 를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="840dcfc4db83e11261bb160a1f0912d853943c4b" translate="yes" xml:space="preserve">
          <source>If you wish to use fish (or any other shell) as your default shell, you need to enter your new shell's executable &lt;code&gt;/usr/local/bin/fish&lt;/code&gt; in two places:</source>
          <target state="translated">피쉬 (또는 다른 쉘)를 기본 쉘로 사용하려면 새 쉘의 실행 파일 &lt;code&gt;/usr/local/bin/fish&lt;/code&gt; 를 다음 두 곳에 입력해야 합니다.</target>
        </trans-unit>
        <trans-unit id="115e2c44e689956437e718e0ec0032e55b5f7fed" translate="yes" xml:space="preserve">
          <source>If you wish to use fish (or any other shell) as your default shell, you need to enter your new shell's executable &lt;code&gt;/usr/local/bin/fish&lt;/code&gt; in two places: - add &lt;code&gt;/usr/local/bin/fish&lt;/code&gt; to &lt;code&gt;/etc/shells&lt;/code&gt; - change your default shell with &lt;code&gt;chsh -s /usr/local/bin/fish&lt;/code&gt;</source>
          <target state="translated">If you wish to use fish (or any other shell) as your default shell, you need to enter your new shell's executable &lt;code&gt;/usr/local/bin/fish&lt;/code&gt; in two places: - add &lt;code&gt;/usr/local/bin/fish&lt;/code&gt; to &lt;code&gt;/etc/shells&lt;/code&gt; - change your default shell with &lt;code&gt;chsh -s /usr/local/bin/fish&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a88aaa448eb4ccc5d7c16b222b1aaafa2e3553e" translate="yes" xml:space="preserve">
          <source>If your command does not need access to stdin, consider using &lt;code&gt;source&lt;/code&gt; instead.</source>
          <target state="translated">명령에 stdin에 액세스 할 필요가 없으면 대신 &lt;code&gt;source&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a0edd7289f911011f3a35d834f1f941473e2b0a8" translate="yes" xml:space="preserve">
          <source>If, in the example above, $WORD is undefined or an empty list, the &quot;s&quot; is not printed. However, it is printed if $WORD is the empty string (like after &lt;code&gt;set WORD &quot;&quot;&lt;/code&gt;).</source>
          <target state="translated">If, in the example above, $WORD is undefined or an empty list, the &quot;s&quot; is not printed. However, it is printed if $WORD is the empty string (like after &lt;code&gt;set WORD &quot;&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="20b7e02e5dced2f235b74397e5dd8fd6678ecaa1" translate="yes" xml:space="preserve">
          <source>If, in the example above, $WORD is undefined or an empty list, the &quot;s&quot; is not printed. However, it is printed, if $WORD is the empty string.</source>
          <target state="translated">위의 예에서 $ WORD가 정의되지 않았거나 빈 목록이면 &quot;s&quot;가 인쇄되지 않습니다. 그러나 $ WORD가 빈 문자열이면 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="cd4f982a2dfbfb7a494a0fcc11edc18044fd3ee7" translate="yes" xml:space="preserve">
          <source>Import the abbreviations defined on another_host over SSH.</source>
          <target state="translated">SSH를 통해 another_host에 정의 된 약어를 ​​가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="99b7d1b47f67f33906cafe0ea45bb9a7ae9de792" translate="yes" xml:space="preserve">
          <source>In addition, when adding abbreviations:</source>
          <target state="translated">또한 약어를 추가 할 때 :</target>
        </trans-unit>
        <trans-unit id="8214b19376f922281d94350c39e691ba4c55ab07" translate="yes" xml:space="preserve">
          <source>In addition, when adding or renaming abbreviations:</source>
          <target state="translated">In addition, when adding or renaming abbreviations:</target>
        </trans-unit>
        <trans-unit id="b11dd25d3b50e779c52a3bed6755a9de86e7cc31" translate="yes" xml:space="preserve">
          <source>In assignment mode, &lt;code&gt;set&lt;/code&gt; does not modify the exit status. This allows simultaneous capture of the output and exit status of a subcommand, e.g. &lt;code&gt;if set output (command)&lt;/code&gt;. In query mode, the exit status is the number of variables that were not found. In erase mode, &lt;code&gt;set&lt;/code&gt; exits with a zero exit status in case of success, with a non-zero exit status if the commandline was invalid, if the variable was write-protected or if the variable did not exist.</source>
          <target state="translated">할당 모드에서 &lt;code&gt;set&lt;/code&gt; 은 종료 상태를 수정하지 않습니다. 예를 들어 &lt;code&gt;if set output (command)&lt;/code&gt; 과 같은 하위 명령의 출력 및 종료 상태를 동시에 캡처 할 수 있습니다 . 쿼리 모드에서 종료 상태는 찾을 수없는 변수의 수입니다. 삭제 모드에서 &lt;code&gt;set&lt;/code&gt; 변수가 존재하지 않은 경우 변수가 쓰기 금지했다 경우 또는 0이 아닌 종료 상태 성공의 경우 제로 (0) 종료 상태로 종료는 명령 줄은 유효합니다.</target>
        </trans-unit>
        <trans-unit id="997bbb76e726398decafa893aef44209d89a5923" translate="yes" xml:space="preserve">
          <source>In bash, this would have created two directories &quot;Mister&quot; and &quot;Noodle&quot;. In &lt;code&gt;fish&lt;/code&gt;, it created only one: the variable had the value &quot;Mister Noodle&quot;, so that is the argument that was passed to &lt;code&gt;mkdir&lt;/code&gt;, spaces and all. Other shells use the term &quot;arrays&quot;, rather than lists.</source>
          <target state="translated">bash에서 이것은 &quot;Mister&quot;와 &quot;Noodle&quot;이라는 두 디렉토리를 만들었을 것이다. 에서 &lt;code&gt;fish&lt;/code&gt; , 그것은 단지 하나 만들어 : 그에게 전달 된 인수 그래서 변수가 값 &quot;미스터 국수&quot;를했다 &lt;code&gt;mkdir&lt;/code&gt; , 공간과 모든. 다른 쉘은 목록이 아닌 &quot;배열&quot;이라는 용어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="febdce18a02406c3f663a8114d7d2b52f9d2f956" translate="yes" xml:space="preserve">
          <source>In cases such as this, one can use &lt;code&gt;command&lt;/code&gt;&lt;code&gt;test&lt;/code&gt; to explicitly use the system's standalone &lt;code&gt;test&lt;/code&gt; rather than this &lt;code&gt;builtin&lt;/code&gt;&lt;code&gt;test&lt;/code&gt;.</source>
          <target state="translated">이와 같은 경우, &lt;code&gt;builtin&lt;/code&gt; &lt;code&gt;test&lt;/code&gt; 대신 시스템의 독립형 &lt;code&gt;test&lt;/code&gt; 를 명시 적으로 사용하기 위해 &lt;code&gt;command&lt;/code&gt; &lt;code&gt;test&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4f2d284a1e65e7867199a2469dd5dff1c9b6cd8" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;s &lt;code&gt;match&lt;/code&gt; defaults to glob-mode, while &lt;code&gt;replace&lt;/code&gt; defaults to literal matching. If set to regex-mode, they use PCRE regular expressions, which is comparable to &lt;code&gt;grep&lt;/code&gt;s &lt;code&gt;-P&lt;/code&gt; option. &lt;code&gt;match&lt;/code&gt; defaults to printing just the match, which is like &lt;code&gt;grep&lt;/code&gt; with &lt;code&gt;-o&lt;/code&gt; (use &lt;code&gt;--entire&lt;/code&gt; to enable grep-like behavior).</source>
          <target state="translated">In contrast to &lt;code&gt;grep&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; s &lt;code&gt;match&lt;/code&gt; defaults to glob-mode, while &lt;code&gt;replace&lt;/code&gt; defaults to literal matching. If set to regex-mode, they use PCRE regular expressions, which is comparable to &lt;code&gt;grep&lt;/code&gt; s &lt;code&gt;-P&lt;/code&gt; option. &lt;code&gt;match&lt;/code&gt; defaults to printing just the match, which is like &lt;code&gt;grep&lt;/code&gt; with &lt;code&gt;-o&lt;/code&gt; (use &lt;code&gt;--entire&lt;/code&gt; to enable grep-like behavior).</target>
        </trans-unit>
        <trans-unit id="50308010771463782c1b1049f298eeb910eb8cb2" translate="yes" xml:space="preserve">
          <source>In contrast to these classics, &lt;code&gt;string&lt;/code&gt; reads input either from stdin or as arguments. &lt;code&gt;string&lt;/code&gt; also does not deal with files, so it requires redirections to be used with them.</source>
          <target state="translated">In contrast to these classics, &lt;code&gt;string&lt;/code&gt; reads input either from stdin or as arguments. &lt;code&gt;string&lt;/code&gt; also does not deal with files, so it requires redirections to be used with them.</target>
        </trans-unit>
        <trans-unit id="8150d5ade4961a7346cfe9d6f7af40451a0e9eba" translate="yes" xml:space="preserve">
          <source>In erase mode, if variable indices are specified, only the specified slices of the array variable will be erased.</source>
          <target state="translated">소거 모드에서 변수 인덱스가 지정되면 지정된 배열 변수 슬라이스 만 지워집니다.</target>
        </trans-unit>
        <trans-unit id="ea9ced13df63c29343d5b0a4c89e208d759dd99a" translate="yes" xml:space="preserve">
          <source>In erase mode, if variable indices are specified, only the specified slices of the list variable will be erased.</source>
          <target state="translated">In erase mode, if variable indices are specified, only the specified slices of the list variable will be erased.</target>
        </trans-unit>
        <trans-unit id="d285383bee7174093582f84311886d8e77b2597e" translate="yes" xml:space="preserve">
          <source>In fish versions prior to 2.3.0 the &lt;code&gt;$argv&lt;/code&gt; variable would have a single element (the name of the sourced file) if no arguments are present. Otherwise it would contain arguments without the name of the sourced file. That behavior was very confusing and unlike other shells such as bash and zsh.</source>
          <target state="translated">2.3.0 이전의 피쉬 버전에서 &lt;code&gt;$argv&lt;/code&gt; 변수는 인수가 없으면 단일 요소 (소스 파일의 이름)를 갖습니다. 그렇지 않으면 소스 파일 이름이없는 인수가 포함됩니다. 이 동작은 매우 혼란스럽고 bash 및 zsh와 같은 다른 쉘과는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9b6a0ae9d083c309f889a5d39f65825be86a357a" translate="yes" xml:space="preserve">
          <source>In fish versions prior to 2.3.0, the &lt;code&gt;$argv&lt;/code&gt; variable would have a single element (the name of the sourced file) if no arguments are present. Otherwise, it would contain arguments without the name of the sourced file. That behavior was very confusing and unlike other shells such as bash and zsh.</source>
          <target state="translated">In fish versions prior to 2.3.0, the &lt;code&gt;$argv&lt;/code&gt; variable would have a single element (the name of the sourced file) if no arguments are present. Otherwise, it would contain arguments without the name of the sourced file. That behavior was very confusing and unlike other shells such as bash and zsh.</target>
        </trans-unit>
        <trans-unit id="b6167c9c2e21f8c5d664cda565772acda6aa5a44" translate="yes" xml:space="preserve">
          <source>In fish versions prior to 2.5.0 it was possible to create a function named &lt;code&gt;-&lt;/code&gt; that would do &lt;code&gt;cd -&lt;/code&gt;. Changes in the 2.5.0 release included several bug fixes that enforce the rule that a bare hyphen is not a valid function (or variable) name. However, you can achieve the same effect via an abbreviation:</source>
          <target state="translated">2.5.0 이전의 어류 버전에서 &lt;code&gt;cd -&lt;/code&gt; 수행하는 &lt;code&gt;-&lt;/code&gt; 라는 함수를 작성할 수있었습니다 . 2.5.0 릴리스의 변경 사항에는 베어 하이픈이 유효한 함수 (또는 변수) 이름이 아닌 규칙을 시행하는 몇 가지 버그 수정이 포함되었습니다. 그러나 약어를 통해 동일한 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82580c4fc0344cd7e4b4c3bbc7ac9db12a80d91" translate="yes" xml:space="preserve">
          <source>In functions, &lt;code&gt;block&lt;/code&gt; can be useful while performing work that should not be interrupted by the shell.</source>
          <target state="translated">함수에서 &lt;code&gt;block&lt;/code&gt; 은 쉘에 의해 중단되지 않아야하는 작업을 수행하는 동안 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89ff03b555073b2736f671e958968657fb6eb4ed" translate="yes" xml:space="preserve">
          <source>In general, special characters are special by default, so &lt;code&gt;a+&lt;/code&gt; matches one or more &quot;a&quot;s, while &lt;code&gt;a\+&lt;/code&gt; matches an &quot;a&quot; and then a &quot;+&quot;. &lt;code&gt;(a+)&lt;/code&gt; matches one or more &quot;a&quot;s in a capturing group (&lt;code&gt;(?:XXXX)&lt;/code&gt; denotes a non-capturing group). For the replacement parameter of &lt;code&gt;replace&lt;/code&gt;, &lt;code&gt;$n&lt;/code&gt; refers to the n-th group of the match. In the match parameter, &lt;code&gt;\n&lt;/code&gt; (e.g. &lt;code&gt;\1&lt;/code&gt;) refers back to groups.</source>
          <target state="translated">일반적으로 특수 문자는 기본적으로 특수하므로 &lt;code&gt;a+&lt;/code&gt; 는 하나 이상의 &quot;a&quot; 와 일치하고 &lt;code&gt;a\+&lt;/code&gt; 는 &quot;a&quot;와 &quot;+&quot;와 일치합니다. &lt;code&gt;(a+)&lt;/code&gt; 는 캡처 그룹에서 하나 이상의 &quot;a&quot;와 일치합니다 ( &lt;code&gt;(?:XXXX)&lt;/code&gt; 는 캡처하지 않은 그룹을 나타냅니다). &lt;code&gt;replace&lt;/code&gt; 의 교체 매개 변수 에서 &lt;code&gt;$n&lt;/code&gt; 은 일치하는 n 번째 그룹을 나타냅니다. 일치 매개 변수에서 &lt;code&gt;\n&lt;/code&gt; (예 : &lt;code&gt;\1&lt;/code&gt; )은 그룹을 다시 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="52f151afd8c58f05083781d29e38adf8acc285ad" translate="yes" xml:space="preserve">
          <source>In order to change your default shell, type:</source>
          <target state="translated">기본 쉘을 변경하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="7744f887d10f15ca76ae2472bb145fdd5fdbdb57" translate="yes" xml:space="preserve">
          <source>In order to protect the shell from consuming too many system resources, &lt;code&gt;read&lt;/code&gt; will only consume a maximum of 10 MiB (1048576 bytes); if the terminator is not reached before this limit then VARIABLE is set to empty and the exit status is set to 122. This limit can be altered with the &lt;code&gt;fish_read_limit&lt;/code&gt; variable. If set to 0 (zero), the limit is removed.</source>
          <target state="translated">쉘이 너무 많은 시스템 자원을 사용하지 않도록 보호하기 위해 &lt;code&gt;read&lt;/code&gt; 는 최대 10MiB (1048576 바이트) 만 소비합니다. 이 한계 이전에 종결자가 도달하지 않으면 VARIABLE은 비어 있으며 종료 상태는 122로 설정됩니다.이 한계는 &lt;code&gt;fish_read_limit&lt;/code&gt; 변수를 사용하여 변경할 수 있습니다 . 0으로 설정하면 한계가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="10c1bbb71199c4bba1fc0fbd3600f1a2a6187c25" translate="yes" xml:space="preserve">
          <source>In order to protect the shell from consuming too many system resources, &lt;code&gt;read&lt;/code&gt; will only consume a maximum of 100 MiB (104857600 bytes); if the terminator is not reached before this limit then VARIABLE is set to empty and the exit status is set to 122. This limit can be altered with the &lt;code&gt;fish_read_limit&lt;/code&gt; variable. If set to 0 (zero), the limit is removed.</source>
          <target state="translated">In order to protect the shell from consuming too many system resources, &lt;code&gt;read&lt;/code&gt; will only consume a maximum of 100 MiB (104857600 bytes); if the terminator is not reached before this limit then VARIABLE is set to empty and the exit status is set to 122. This limit can be altered with the &lt;code&gt;fish_read_limit&lt;/code&gt; variable. If set to 0 (zero), the limit is removed.</target>
        </trans-unit>
        <trans-unit id="ccb466b6200e27a0e4799833112a3b42e6de23b3" translate="yes" xml:space="preserve">
          <source>In particular it will:</source>
          <target state="translated">특히 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfb4b17946050d9f509c4bdb763f770ebb06687a" translate="yes" xml:space="preserve">
          <source>In query mode, the scope to be examined can be specified.</source>
          <target state="translated">쿼리 모드에서 검사 할 범위를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89d4f28841a1759ddcc1b8894ac4045a23593691" translate="yes" xml:space="preserve">
          <source>In the following code, all output is redirected to the file out.html.</source>
          <target state="translated">다음 코드에서 모든 출력은 out.html 파일로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="67bf59485bd852b33bf0045b83854687c5fd2923" translate="yes" xml:space="preserve">
          <source>In the following examples if a flag is not seen when parsing the arguments then the corresponding _flag_X var(s) will not be set.</source>
          <target state="translated">다음 예제에서 인수를 구문 분석 할 때 플래그가 표시되지 않으면 해당 _flag_X var (s)가 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b18679bb485a969aa3729a892fbc342e477da1e5" translate="yes" xml:space="preserve">
          <source>In the overwhelming majority of cases, splitting on spaces is unwanted, so this is an improvement.</source>
          <target state="translated">압도적 인 대다수의 경우 공간 분할은 바람직하지 않으므로 개선입니다.</target>
        </trans-unit>
        <trans-unit id="40d4bef31048f07adb0a3c1f574c30c70992f0e5" translate="yes" xml:space="preserve">
          <source>In these cases use &lt;code&gt;string split &quot; &quot;&lt;/code&gt; like:</source>
          <target state="translated">이 경우 다음 과 같이 &lt;code&gt;string split &quot; &quot;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e86e38a4028df2e1d281758cf65343b3a55357c4" translate="yes" xml:space="preserve">
          <source>In these cases, the expansion eliminates the string, as a result of the implicit &lt;a href=&quot;#cartesian-product&quot;&gt;cartesian product&lt;/a&gt;.</source>
          <target state="translated">이러한 경우 확장은 암시 적 &lt;a href=&quot;#cartesian-product&quot;&gt;카티 전 곱&lt;/a&gt; 의 결과로 문자열을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="a96781a5a37dbe8375812a63f70f63e6201fe8ae" translate="yes" xml:space="preserve">
          <source>Incorrect use of output redirects</source>
          <target state="translated">출력 리디렉션의 잘못된 사용</target>
        </trans-unit>
        <trans-unit id="00039aeb76d249d44e4bf3ba01d88ffc368e8bd4" translate="yes" xml:space="preserve">
          <source>Index range expansion</source>
          <target state="translated">인덱스 범위 확장</target>
        </trans-unit>
        <trans-unit id="6fb7f6ce1f52c7d40f5bab615e431e3f8551d458" translate="yes" xml:space="preserve">
          <source>Initialization files</source>
          <target state="translated">초기화 파일</target>
        </trans-unit>
        <trans-unit id="2a06266a915eac92808f8af015840d61f777058b" translate="yes" xml:space="preserve">
          <source>Input/Output (IO) redirection</source>
          <target state="translated">입출력 (IO) 리디렉션</target>
        </trans-unit>
        <trans-unit id="d06fb6a26a0cdbfbe971938c779ba1d8847a636e" translate="yes" xml:space="preserve">
          <source>Input/Output Redirection</source>
          <target state="translated">입력 / 출력 리디렉션</target>
        </trans-unit>
        <trans-unit id="cc03501ba8e2728a6aa8f006cb5c7941d732153b" translate="yes" xml:space="preserve">
          <source>Insert mode</source>
          <target state="translated">삽입 모드</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="56c7ddbfeb574a673d5b721d96a9d20284b9212a" translate="yes" xml:space="preserve">
          <source>Installation and Start</source>
          <target state="translated">설치 및 시작</target>
        </trans-unit>
        <trans-unit id="fb0ea93fbb85b738df0bd31fcf1bc9eb5468d22b" translate="yes" xml:space="preserve">
          <source>Interactive use</source>
          <target state="translated">대화식 사용</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="c62c2864f20a2be4aa0393bfb86357685145de0e" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;complete&lt;/code&gt; multiple times for the same command adds the new definitions on top of any existing completions defined for the command.</source>
          <target state="translated">동일한 명령에 대해 여러 번 &lt;code&gt;complete&lt;/code&gt; 호출하면 명령에 대해 정의 된 기존 완료 위에 새 정의가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="60085e96c04073bb488214d0f08662dbfb4f6528" translate="yes" xml:space="preserve">
          <source>It calls out to VCS-specific functions. The currently supported systems are:</source>
          <target state="translated">VCS 특정 기능을 호출합니다. 현재 지원되는 시스템은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd08cedcb39096700407dcb2ed27cc0a4d9655b5" translate="yes" xml:space="preserve">
          <source>It can also be unexported with &lt;code&gt;--unexport&lt;/code&gt; or &lt;code&gt;-u&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--unexport&lt;/code&gt; 또는 &lt;code&gt;-u&lt;/code&gt; 를 사용 하여 내보내기 를 취소 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83c3b240dba13d15ae7f53c1a501f0c631e4c4fe" translate="yes" xml:space="preserve">
          <source>It is also possible to add all emacs-mode bindings to vi-mode by using something like</source>
          <target state="translated">다음과 같은 것을 사용하여 모든 emacs 모드 바인딩을 vi 모드에 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec8325ed194e0bd115e6eac2314eb9c5b93bc6c7" translate="yes" xml:space="preserve">
          <source>It is also possible to add all emacs-mode bindings to vi-mode by using something like:</source>
          <target state="translated">다음과 같은 것을 사용하여 모든 emacs-mode 바인딩을 vi-mode에 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="88b3a0222511e2204a83e1bd65b24a52023e46f7" translate="yes" xml:space="preserve">
          <source>It is also possible to set or erase individual elements of a list:</source>
          <target state="translated">목록의 개별 요소를 설정하거나 지울 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ab84d80263900ba9d5b235b1f2ea80519e28b73" translate="yes" xml:space="preserve">
          <source>It is also possible to set or erase individual elements of an array:</source>
          <target state="translated">배열의 개별 요소를 설정하거나 지울 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d526954a8bce879648c1f8388f9dcd5c2cf78df" translate="yes" xml:space="preserve">
          <source>It is common to want to validate the the value provided for an option satisfies some criteria. For example, that it is a valid integer within a specific range. You can always do this after &lt;code&gt;argparse&lt;/code&gt; returns but you can also request that &lt;code&gt;argparse&lt;/code&gt; perform the validation by executing arbitrary fish script. To do so simply append an &lt;code&gt;!&lt;/code&gt; (exclamation-mark) then the fish script to be run. When that code is executed three vars will be defined:</source>
          <target state="translated">옵션에 제공된 값이 일부 기준을 만족시키는 지 확인하는 것이 일반적입니다. 예를 들어 특정 범위 내에서 유효한 정수입니다. &lt;code&gt;argparse&lt;/code&gt; 가 반환 된 후에는 항상이 작업을 수행 할 수 있지만 임의의 fish 스크립트를 실행하여 &lt;code&gt;argparse&lt;/code&gt; 가 유효성 검사를 수행하도록 요청할 수도 있습니다 . 그렇게하려면 간단히 &lt;code&gt;!&lt;/code&gt; (느낌표)를 입력 한 다음 fish 스크립트를 실행하십시오. 해당 코드가 실행될 때 세 가지 변수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a71bcd2264c669eb00c671521098fb03d224a747" translate="yes" xml:space="preserve">
          <source>It is possible to directly create functions and variables in &lt;code&gt;config.fish&lt;/code&gt; file, using the commands shown above. For example:</source>
          <target state="translated">위에 표시된 명령을 사용하여 &lt;code&gt;config.fish&lt;/code&gt; 파일 에서 함수 및 변수를 직접 작성할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="83c56d7ebd2ae7a42fad58d3fe21565a95290624" translate="yes" xml:space="preserve">
          <source>It is usually added inside of a conditional block such as an &lt;a href=&quot;#if&quot;&gt;if&lt;/a&gt; statement or a &lt;a href=&quot;#switch&quot;&gt;switch&lt;/a&gt; statement to conditionally stop the executing function and return to the caller, but it can also be used to specify the exit status of a function.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#if&quot;&gt;if&lt;/a&gt; 문 또는 &lt;a href=&quot;#switch&quot;&gt;switch&lt;/a&gt; 문과 같은 조건부 블록 안에 추가되어 실행 기능을 조건부로 중지하고 호출자에게 반환하지만 함수의 종료 상태를 지정하는 데에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f4a9521ff238cfd8c93799d8d5f98df72dc4a0c" translate="yes" xml:space="preserve">
          <source>It is usually added inside of a conditional block such as an &lt;a href=&quot;if#cmd-if&quot;&gt;if&lt;/a&gt; statement or a &lt;a href=&quot;switch#cmd-switch&quot;&gt;switch&lt;/a&gt; statement to conditionally stop the executing function and return to the caller, but it can also be used to specify the exit status of a function.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;if#cmd-if&quot;&gt;if&lt;/a&gt; 문 또는 &lt;a href=&quot;switch#cmd-switch&quot;&gt;switch&lt;/a&gt; 문과 같은 조건 블록 내부에 추가되어 실행중인 함수를 조건부로 중지하고 호출자에게 반환하지만 함수의 종료 상태를 지정하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cefa92c853442bbe4dd3a6ef0bacadea8c59bfbd" translate="yes" xml:space="preserve">
          <source>It is very important that function definition files only contain the definition for the specified function and nothing else. Otherwise, it is possible that autoloading a function files requires that the function already be loaded, which creates a circular dependency.</source>
          <target state="translated">함수 정의 파일은 지정된 함수에 대한 정의 만 포함하고 다른 것은 포함하지 않는 것이 매우 중요합니다. 그렇지 않으면 함수 파일을 자동로드하려면 함수가 이미로드되어 순환 종속성이 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee7deea0a6c7d1bf1f12282d8e4f2d33d9fa574c" translate="yes" xml:space="preserve">
          <source>It knows about paths and options</source>
          <target state="translated">경로와 옵션에 대해 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="13749347248c90340a66276ab0e48e071806f943" translate="yes" xml:space="preserve">
          <source>It knows about paths and options:</source>
          <target state="translated">경로와 옵션에 대해 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="09881db18dec90e0ba8f4c151dbc729afee1f020" translate="yes" xml:space="preserve">
          <source>It will print &lt;code&gt;xa b c x&lt;/code&gt;, because the &quot;a b c &quot; is used in one piece. But if you do</source>
          <target state="translated">&quot;abc&quot;가 한 조각으로 사용되기 때문에 &lt;code&gt;xa b c x&lt;/code&gt; 를 인쇄 합니다. 하지만 만약 당신이</target>
        </trans-unit>
        <trans-unit id="f51b747a62fc1665fa16726f0cc05a908bd9ced6" translate="yes" xml:space="preserve">
          <source>It will print &lt;code&gt;xa b c x&lt;/code&gt;. But if you do</source>
          <target state="translated">&lt;code&gt;xa b c x&lt;/code&gt; 를 인쇄 합니다. 그러나 만약 당신이</target>
        </trans-unit>
        <trans-unit id="784cf5b2d3ebe2dbad48daf3fd3356b85327650b" translate="yes" xml:space="preserve">
          <source>Iterating over a list of numbers can be done with &lt;code&gt;seq&lt;/code&gt;:</source>
          <target state="translated">숫자 목록을 반복하는 것은 &lt;code&gt;seq&lt;/code&gt; 로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c2654e77c8a1d66520f0e811b49f2ee16ec66ef" translate="yes" xml:space="preserve">
          <source>Job control</source>
          <target state="translated">직무 관리</target>
        </trans-unit>
        <trans-unit id="090e4272d6cb5283367e3c64d3f84a1ce2fa8aee" translate="yes" xml:space="preserve">
          <source>Jobs in the list of jobs are sent a hang-up signal when fish terminates, which usually causes the job to terminate; &lt;code&gt;disown&lt;/code&gt; allows these processes to continue regardless.</source>
          <target state="translated">작업 목록에있는 작업은 물고기가 종료 될 때 끊기 신호를 보내므로 일반적으로 작업이 종료됩니다. &lt;code&gt;disown&lt;/code&gt; 은 이러한 프로세스가 관계없이 계속 진행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="544b65b506a2ffb69625eb6e4d7541dde083f7c6" translate="yes" xml:space="preserve">
          <source>Keep in mind that a defined variabled could also be empty, either by having no elements (if set like &lt;code&gt;set var&lt;/code&gt;) or only empty elements (if set like &lt;code&gt;set var &quot;&quot;&lt;/code&gt;). Read on for how to deal with those.</source>
          <target state="translated">정의 된 변수는 요소가 없거나 ( &lt;code&gt;set var&lt;/code&gt; 과 같이 설정된 경우 ) 빈 요소 만 ( &lt;code&gt;set var &quot;&quot;&lt;/code&gt; 과 같이 설정된 경우) 비어있을 수도 있습니다 . 그것들을 다루는 방법에 대해서는 계속 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="32881a56b33d045dddcff4e97bad3c9a0cec51b4" translate="yes" xml:space="preserve">
          <source>Keep in mind that parameter expansion takes before expressions are evaluated. This can be very useful in order to perform calculations involving shell variables or the output of command substitutions, but it also means that parenthesis (&lt;code&gt;()&lt;/code&gt;) and the asterisk (&lt;code&gt;*&lt;/code&gt;) glob character have to be escaped or quoted. &lt;code&gt;x&lt;/code&gt; can also be used to denote multiplication, but it needs to be followed by whitespace to distinguish it from hexadecimal numbers.</source>
          <target state="translated">매개 변수 확장은 표현식이 평가되기 전에 걸립니다. 이것은 쉘 변수 또는 명령 대체 출력과 관련된 계산을 수행하는 데 매우 유용 할 수 있지만 괄호 ( &lt;code&gt;()&lt;/code&gt; ) 및 별표 ( &lt;code&gt;*&lt;/code&gt; ) 글롭 문자를 이스케이프하거나 따옴표로 묶어야 함을 의미합니다. &lt;code&gt;x&lt;/code&gt; 는 곱셈을 나타내는 데 사용할 수도 있지만 16 진수와 구별하기 위해 뒤에 공백이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="946c99cee0972cba5b6dec7f34cb20b94d3a2715" translate="yes" xml:space="preserve">
          <source>Keep in mind that parameter expansion takes before expressions are evaluated. This can be very useful in order to perform calculations involving shell variables or the output of command substitutions, but it also means that parenthesis and the asterisk glob character have to be escaped or quoted.</source>
          <target state="translated">표현식을 평가하기 전에 매개 변수 확장이 필요하다는 점에 유의하십시오. 이것은 쉘 변수 또는 명령 대체의 출력과 관련된 계산을 수행하는 데 매우 유용 할 수 있지만 괄호와 별표 글로브 문자를 이스케이프하거나 인용해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="573891be377321acc4815f0519173b9b072d48fa" translate="yes" xml:space="preserve">
          <source>Key bindings may use &quot;modes&quot;, which mimics Vi's modal input behavior. The default mode is &quot;default&quot;, and every bind applies to a single mode. The mode can be viewed/changed with the &lt;code&gt;$fish_bind_mode&lt;/code&gt; variable.</source>
          <target state="translated">키 바인딩은 Vi의 모달 입력 동작을 모방 한 &quot;모드&quot;를 사용할 수 있습니다. 기본 모드는 &quot;default&quot;이며 모든 바인드는 단일 모드에 적용됩니다. &lt;code&gt;$fish_bind_mode&lt;/code&gt; 변수를 사용하여 모드를 보거나 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b562f1a6d0c5684ca96b09426bc1669506a7f803" translate="yes" xml:space="preserve">
          <source>Learning fish</source>
          <target state="translated">학습 물고기</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="b5cf98d60edf53bb04a75b49fe8d89b334867632" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU General Public License, version 2.</source>
          <target state="translated">GNU General Public License, 버전 2에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="c93725e0a0f010017ca3b484abe1192273219e4e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;sed&lt;/code&gt;s &lt;code&gt;s/&lt;/code&gt; command, &lt;code&gt;string replace&lt;/code&gt; still prints strings that don't match. &lt;code&gt;sed&lt;/code&gt;s &lt;code&gt;-n&lt;/code&gt; in combination with a &lt;code&gt;/p&lt;/code&gt; modifier or command is like &lt;code&gt;string replace -f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sed&lt;/code&gt; s &lt;code&gt;s/&lt;/code&gt; 명령 과 마찬가지로 &lt;code&gt;string replace&lt;/code&gt; 는 여전히 일치하지 않는 문자열을 인쇄합니다. &lt;code&gt;sed&lt;/code&gt; s &lt;code&gt;-n&lt;/code&gt; 을 &lt;code&gt;/p&lt;/code&gt; 수정 자 또는 명령 과 함께 사용하면 &lt;code&gt;string replace -f&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f063dbdbbc3586964fed3651ab53c12631bbacd5" translate="yes" xml:space="preserve">
          <source>Like other shells, a dollar sign performs variable substitution:</source>
          <target state="translated">다른 쉘과 마찬가지로 달러 기호는 변수 대체를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1c10e83fba90f8ed8fbb793d35b29d018d6a8897" translate="yes" xml:space="preserve">
          <source>Like other shells, fish allows multiple commands either on separate lines or the same line.</source>
          <target state="translated">다른 쉘과 마찬가지로 피쉬는 별도의 줄이나 같은 줄에 여러 명령을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="a51da1d245e2b299170419f02a7283c1cf86ec93" translate="yes" xml:space="preserve">
          <source>Lists adjacent to other lists or strings are expanded as &lt;a href=&quot;index#cartesian-product&quot;&gt;cartesian products&lt;/a&gt; unless quoted (see &lt;a href=&quot;index#expand-variable&quot;&gt;Variable expansion&lt;/a&gt;):</source>
          <target state="translated">다른 목록이나 문자열에 인접한 목록은 인용하지 않는 한 &lt;a href=&quot;index#cartesian-product&quot;&gt;데카르트 곱&lt;/a&gt; 으로 확장됩니다 ( &lt;a href=&quot;index#expand-variable&quot;&gt;변수 확장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e550372c446deb80cb7097a6530c7895ce489c98" translate="yes" xml:space="preserve">
          <source>Lists adjacent to other lists or strings are expanded as cartesian products:</source>
          <target state="translated">다른 목록이나 문자열에 인접한 목록은 데카르트 제품으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="d036c0ec2ab378b452b8d2cead3a3ffcc191575a" translate="yes" xml:space="preserve">
          <source>Lists cannot contain other lists: there is no recursion. A variable is a list of strings, full stop.</source>
          <target state="translated">리스트는 다른리스트를 포함 할 수 없습니다 : 재귀는 없습니다. 변수는 문자열 목록, 완전 정지입니다.</target>
        </trans-unit>
        <trans-unit id="fd5bfe87f1fde5105869e708324f805855fff5fa" translate="yes" xml:space="preserve">
          <source>Local variables are specific to the current fish session, and associated with a specific block of commands, and is automatically erased when a specific block goes out of scope. A block of commands is a series of commands that begins with one of the commands &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;switch&lt;/code&gt;, and ends with the command &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">로컬 변수는 현재 물고기 세션에 고유하며 특정 명령 블록과 연관되며 특정 블록이 범위를 벗어나면 자동으로 지워집니다. 명령 블록은 하나의 명령으로 시작하는 일련의 명령이다 &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;function&lt;/code&gt; , &lt;code&gt;begin&lt;/code&gt; 또는 &lt;code&gt;switch&lt;/code&gt; , 및 명령과 말단 &lt;code&gt;end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8172703ebdf7bfc5b44da606bf9f833637212ffc" translate="yes" xml:space="preserve">
          <source>Locale variables</source>
          <target state="translated">로케일 변수</target>
        </trans-unit>
        <trans-unit id="02720f9d38bf4f35e84ed5228689898bee176418" translate="yes" xml:space="preserve">
          <source>Loops</source>
          <target state="translated">Loops</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="f5f695dcfd95e469044fda4ad8dda41439800142" translate="yes" xml:space="preserve">
          <source>Many other shells have a large library of builtin commands. Most of these commands are also available as standalone commands, but have been implemented in the shell anyway. To avoid code duplication, and to avoid the confusion of subtly differing versions of the same command, &lt;code&gt;fish&lt;/code&gt; generally only implements builtins for actions which cannot be performed by a regular command.</source>
          <target state="translated">다른 많은 쉘에는 큰 내장 명령 라이브러리가 있습니다. 이러한 명령의 대부분은 독립형 명령으로도 사용할 수 있지만 어쨌든 셸에서 구현되었습니다. 코드 중복을 피하고 동일한 명령의 미묘하게 다른 버전의 혼동을 피하기 위해 &lt;code&gt;fish&lt;/code&gt; 일반적으로 일반 명령으로는 수행 할 수없는 동작에 대해 내장 기능 만 구현합니다.</target>
        </trans-unit>
        <trans-unit id="508666f7961e41b7a23a46d49b1c68da21e0ab6e" translate="yes" xml:space="preserve">
          <source>Many terminals support 24-bit (i.e., true-color) color escape sequences. This includes modern xterm, Gnome Terminal, Konsole, and iTerm2. Fish attempts to detect such terminals through various means in &lt;code&gt;config.fish&lt;/code&gt; You can explicitly force that support via &lt;code&gt;set fish_term24bit 1&lt;/code&gt;.</source>
          <target state="translated">많은 터미널이 24 비트 (즉, 트루 컬러) 색상 이스케이프 시퀀스를 지원합니다. 여기에는 최신 xterm, Gnome Terminal, Konsole 및 iTerm2가 포함됩니다. 물고기는 &lt;code&gt;config.fish&lt;/code&gt; 의 다양한 수단을 통해 이러한 터미널을 감지하려고 시도합니다 . &lt;code&gt;set fish_term24bit 1&lt;/code&gt; 을 통해 명시 적으로 해당 지원을 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee9b4890d50f0c6b762d298b81c92845215e8616" translate="yes" xml:space="preserve">
          <source>Match Glob Examples</source>
          <target state="translated">일치하는 세계 예</target>
        </trans-unit>
        <trans-unit id="5d635a6434318430e0640768784677cf44ef96c2" translate="yes" xml:space="preserve">
          <source>Match Regex Examples</source>
          <target state="translated">정규 표현식 예 일치</target>
        </trans-unit>
        <trans-unit id="282c4c424c8c8f802f09ed9069046a66c3e0e2df" translate="yes" xml:space="preserve">
          <source>Matching can be made case-insensitive with &lt;code&gt;--ignore-case&lt;/code&gt; or &lt;code&gt;-i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--ignore-case&lt;/code&gt; 또는 &lt;code&gt;-i&lt;/code&gt; 로 대소 문자를 구분하지 않고 일치시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfe39636b572a032956990221bea7522894ca013" translate="yes" xml:space="preserve">
          <source>Mismatched parenthesis</source>
          <target state="translated">일치하지 않는 괄호</target>
        </trans-unit>
        <trans-unit id="7d99cf687fc07cadeb9c71efe74a35ddac5120de" translate="yes" xml:space="preserve">
          <source>More on universal variables</source>
          <target state="translated">범용 변수에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="021eea9c0dd8f610dc9e4cc089ecb63b53b1ea84" translate="yes" xml:space="preserve">
          <source>Most operations &lt;code&gt;string&lt;/code&gt; supports can also be done by external tools. Some of these include &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;cut&lt;/code&gt;.</source>
          <target state="translated">대부분의 작업 &lt;code&gt;string&lt;/code&gt; 지원은 외부 도구로도 수행 할 수 있습니다. 이들 중 일부에는 &lt;code&gt;grep&lt;/code&gt; , &lt;code&gt;sed&lt;/code&gt; 및 &lt;code&gt;cut&lt;/code&gt; 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="58541b1a51075d09123179aa5f9cebf36d81b9ff" translate="yes" xml:space="preserve">
          <source>Most programs allow you to suspend the program's execution and return control to &lt;code&gt;fish&lt;/code&gt; by pressing</source>
          <target state="translated">대부분의 프로그램은 당신에게 프로그램의 실행 및 반환 제어 정지 할 수 있도록 &lt;code&gt;fish&lt;/code&gt; 눌러</target>
        </trans-unit>
        <trans-unit id="a6722727e636d961891415cd8a8813e266709c00" translate="yes" xml:space="preserve">
          <source>Most programs allow you to suspend the program's execution and return control to &lt;code&gt;fish&lt;/code&gt; by pressing &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;Z&lt;/b&gt; (also referred to as &lt;code&gt;^Z&lt;/code&gt;). Once back at the &lt;code&gt;fish&lt;/code&gt; commandline, you can start other programs and do anything you want. If you then want you can go back to the suspended command by using the &lt;a href=&quot;commands#fg&quot;&gt;&lt;code&gt;fg&lt;/code&gt;&lt;/a&gt; (foreground) command.</source>
          <target state="translated">대부분의 프로그램에서는 &lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;Z&lt;/b&gt; ( &lt;code&gt;^Z&lt;/code&gt; 라고도 함)를 눌러 프로그램 실행을 일시 중단하고 &lt;code&gt;fish&lt;/code&gt; 로 제어를 되돌릴 수 있습니다. &lt;code&gt;fish&lt;/code&gt; 명령 줄로 돌아 오면 다른 프로그램을 시작하고 원하는 작업을 수행 할 수 있습니다. 원하는 경우 &lt;a href=&quot;commands#fg&quot;&gt; &lt;code&gt;fg&lt;/code&gt; &lt;/a&gt; (전경) 명령 을 사용하여 일시 중단 된 명령으로 돌아갈 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e36a3163fcb5b2ce91e7e62b6620c694486a5106" translate="yes" xml:space="preserve">
          <source>Most programs use three input/output (IO) streams, each represented by a number called a file descriptor (FD). These are:</source>
          <target state="translated">대부분의 프로그램은 3 개의 입 / 출력 (IO) 스트림을 사용하며 각 스트림은 파일 디스크립터 (FD)라는 숫자로 표시됩니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="c20818da60d954d40a5d602d6db10493b1f04e88" translate="yes" xml:space="preserve">
          <source>Most programs use three input/output &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; streams, each represented by a number called a file descriptor (FD). These are:</source>
          <target state="translated">대부분의 프로그램은 3 개의 입력 / 출력 &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 스트림을 사용하며, 각 스트림은 파일 설명자 (FD)라고하는 숫자로 표시됩니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="fbfe945f56b2d1285935393b0ba01a8e6e9fb533" translate="yes" xml:space="preserve">
          <source>Most subcommands accept a &lt;code&gt;-q&lt;/code&gt; or &lt;code&gt;--quiet&lt;/code&gt; switch, which suppresses the usual output but exits with the documented status.</source>
          <target state="translated">대부분의 부속 명령은 &lt;code&gt;-q&lt;/code&gt; 또는 &lt;code&gt;--quiet&lt;/code&gt; 스위치를 사용하여 일반적인 출력을 억제하지만 문서화 된 상태로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="9e4b95e5fe05cdb2e32c0be4dc38dcb8444a090a" translate="yes" xml:space="preserve">
          <source>Multiline editing</source>
          <target state="translated">여러 줄 편집</target>
        </trans-unit>
        <trans-unit id="afac76fbf7acd07151be5bf2f1d66efbab839d8c" translate="yes" xml:space="preserve">
          <source>Multiple elements can be given in a &lt;a href=&quot;#expand-brace&quot;&gt;brace expansion&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#expand-brace&quot;&gt;중괄호 확장&lt;/a&gt; 에 여러 요소를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="284d6c5f151a78ee571b877c91d2822cf913407f" translate="yes" xml:space="preserve">
          <source>Multiple lines are OK. Colors can be set via &lt;code&gt;set_color&lt;/code&gt;, passing it named ANSI colors, or hex RGB values:</source>
          <target state="translated">여러 줄이 정상입니다. &lt;code&gt;set_color&lt;/code&gt; 를 통해 색상을 ANSI 색상 또는 16 진 RGB 값으로 전달 하여 색상을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9313e4afc7e7087f2691f5390743aa11cb2045a" translate="yes" xml:space="preserve">
          <source>Multiple lines are not supported in &lt;code&gt;fish_right_prompt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fish_right_prompt&lt;/code&gt; 에서 여러 줄이 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2ddaeb8bc8e45a0d0bc521306478830db49c61a1" translate="yes" xml:space="preserve">
          <source>My command (pkg-config) gives its output as a single long string?</source>
          <target state="translated">내 명령 (pkg-config)은 출력을 하나의 긴 문자열로 제공합니까?</target>
        </trans-unit>
        <trans-unit id="f9c6fa94b0cdb85c962b8db6aabb5f0166f8183a" translate="yes" xml:space="preserve">
          <source>NUL Delimited Examples</source>
          <target state="translated">NUL 구분 예</target>
        </trans-unit>
        <trans-unit id="2bcd7736113c6b4efdb7226bbeffaacd2a34dab2" translate="yes" xml:space="preserve">
          <source>Next, do the following (assuming fish was installed to /usr/local):</source>
          <target state="translated">다음으로 다음을 수행하십시오 (물고기가 / usr / local에 설치되었다고 가정).</target>
        </trans-unit>
        <trans-unit id="e1c89d68ecad2be53a8cf7ccdf90c12f59e35a10" translate="yes" xml:space="preserve">
          <source>Non existing commands.</source>
          <target state="translated">기존 명령이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="76f3e65e8538fb0ceb8d456aa90c5d4ef9931a07" translate="yes" xml:space="preserve">
          <source>Normally when &lt;code&gt;fish&lt;/code&gt; starts a program, this program will be put in the foreground, meaning it will take control of the terminal and &lt;code&gt;fish&lt;/code&gt; will be stopped until the program finishes. Sometimes this is not desirable. For example, you may wish to start an application with a graphical user interface from the terminal, and then be able to continue using the shell. In such cases, there are several ways in which the user can change fish's behavior.</source>
          <target state="translated">일반적으로 &lt;code&gt;fish&lt;/code&gt; 가 프로그램을 시작할 때이 프로그램은 포 그라운드에 배치됩니다. 즉, 터미널을 제어 하고 프로그램이 끝날 때까지 &lt;code&gt;fish&lt;/code&gt; 가 중지됩니다. 때때로 이것은 바람직하지 않습니다. 예를 들어, 터미널에서 그래픽 사용자 인터페이스로 응용 프로그램을 시작한 다음 셸을 계속 사용할 수 있습니다. 이 경우 사용자가 물고기의 행동을 바꿀 수있는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="08c5c1ef76ceaf50dd2d8b6a05425f76eaec2b83" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;case&lt;/code&gt; does not fall through, and can accept multiple arguments or (quoted) wildcards.</source>
          <target state="translated">주의 &lt;code&gt;case&lt;/code&gt; 를 통해 해당하지 않으며, 여러 인수 또는 (인용) 와일드 카드를 받아 들일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ade5bb175b9c01fc56dcd04dfd8820b5d87cfdc6" translate="yes" xml:space="preserve">
          <source>Note that all colors can also have a corresponding &lt;code&gt;_done&lt;/code&gt; color. For example, the contents of &lt;code&gt;$__fish_git_prompt_color_upstream_done&lt;/code&gt; is printed right _after_ the upstream.</source>
          <target state="translated">모든 색상은 해당 &lt;code&gt;_done&lt;/code&gt; 색상을 가질 수도 있습니다 . 예를 들어 &lt;code&gt;$__fish_git_prompt_color_upstream_done&lt;/code&gt; 의 내용은 업스트림 _after_ 오른쪽에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="daafcf66550c6e75c5e67349c16e61c50e7a4d2f" translate="yes" xml:space="preserve">
          <source>Note that array indices start at 1 in &lt;code&gt;fish&lt;/code&gt;, not 0, as is more common in other languages. This is because many common Unix tools like &lt;code&gt;seq&lt;/code&gt; are more suited to such use. An invalid index is silently ignored resulting in no value being substituted (not an empty string).</source>
          <target state="translated">배열 인덱스 는 다른 언어에서보다 일반적으로 0이 아닌 &lt;code&gt;fish&lt;/code&gt; 에서 1부터 시작 합니다. &lt;code&gt;seq&lt;/code&gt; 와 같은 많은 일반적인 유닉스 도구 가 이러한 용도에 더 적합하기 때문입니다. 유효하지 않은 색인은 자동으로 무시되어 값이 대체되지 않습니다 (빈 문자열이 아님).</target>
        </trans-unit>
        <trans-unit id="75e8dbe710958336c22801c9b7351ebb45c4f694" translate="yes" xml:space="preserve">
          <source>Note that because fish loads functions on-demand, saved functions will not function as &lt;a href=&quot;../index#event&quot;&gt;event handlers&lt;/a&gt; until they are run or sourced otherwise. To activate an event handler for every new shell, add the function to your &lt;a href=&quot;../index#initialization&quot;&gt;shell initialization file&lt;/a&gt; instead of using &lt;code&gt;funcsave&lt;/code&gt;.</source>
          <target state="translated">fish는 온 디맨드로 함수를로드하기 때문에 저장된 함수 는 실행되거나 소싱 될 때까지 &lt;a href=&quot;../index#event&quot;&gt;이벤트 핸들러&lt;/a&gt; 로 작동하지 않습니다 . 모든 새 셸에 대한 이벤트 핸들러를 활성화하려면 &lt;code&gt;funcsave&lt;/code&gt; 를 사용하는 대신 &lt;a href=&quot;../index#initialization&quot;&gt;셸 초기화 파일에&lt;/a&gt; 함수를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="a0707e5e6cd48555094dd0ce06f95a929ab9ee48" translate="yes" xml:space="preserve">
          <source>Note that because fish loads functions on-demand, saved functions will not function as &lt;a href=&quot;index#event&quot;&gt;event handlers&lt;/a&gt; until they are run or sourced otherwise. To activate an event handler for every new shell, add the function to your &lt;a href=&quot;index#initialization&quot;&gt;shell initialization file&lt;/a&gt; instead of using &lt;code&gt;funcsave&lt;/code&gt;.</source>
          <target state="translated">생선은 주문형 기능을로드하기 때문에 저장된 기능은 달리 실행되거나 소싱 될 때까지 &lt;a href=&quot;index#event&quot;&gt;이벤트 핸들러&lt;/a&gt; 로 작동하지 않습니다 . 모든 새 쉘에 대해 이벤트 핸들러를 활성화하려면 &lt;code&gt;funcsave&lt;/code&gt; 대신 &lt;a href=&quot;index#initialization&quot;&gt;쉘 초기화 파일에&lt;/a&gt; 함수를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d05600b5a2c4216ed0373e93b0ae5b8dde601d3a" translate="yes" xml:space="preserve">
          <source>Note that command substitutions in a case statement will be evaluated even if its body is not taken. All substitutions, including command substitutions, must be performed before the value can be compared against the parameter.</source>
          <target state="translated">case 문에서 명령 대체는 본문을 가져 가지 않더라도 평가됩니다. 값을 매개 변수와 비교하기 전에 명령 대체를 포함한 모든 대체를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="27acedfb629019bcb72c1aaa58829703ce6d6432" translate="yes" xml:space="preserve">
          <source>Note that conversion may fail, e.g. &quot;102.234&quot; will not losslessly convert to an integer, causing printf to print an error.</source>
          <target state="translated">변환이 실패 할 수 있습니다. 예를 들어 &quot;102.234&quot;는 손실없이 정수로 변환되지 않으므로 printf가 오류를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="8107914840367cc99db95db5e903f636fb93ac38" translate="yes" xml:space="preserve">
          <source>Note that events are only received from the current fish process as there is no way to send events from one fish process to another.</source>
          <target state="translated">한 물고기 프로세스에서 다른 물고기 프로세스로 이벤트를 보낼 수있는 방법이 없으므로 이벤트는 현재 물고기 프로세스에서만 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="b604d17300bf8871e1df935d8ccab61e77f2c2e6" translate="yes" xml:space="preserve">
          <source>Note that events are only sent to the current fish process as there is no way to send events from one fish process to another.</source>
          <target state="translated">한 물고기 프로세스에서 다른 물고기 프로세스로 이벤트를 보낼 수있는 방법이 없으므로 이벤트는 현재 물고기 프로세스로만 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="1816c418ab7796b893d641bb9d4e996647340b50" translate="yes" xml:space="preserve">
          <source>Note that fish does not fall through on case statements. Only the first matching case is executed.</source>
          <target state="translated">사례 진술에 물고기는 쓰러지지 않습니다. 첫 번째 일치 사례 만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="dea20fe7204b37a954eb8c5b71576a69b5e9c5a0" translate="yes" xml:space="preserve">
          <source>Note that fish has a default titlebar message, which will be used if the fish_title function is undefined. So simply unsetting the fish_title function will not work.</source>
          <target state="translated">fish에는 기본 제목 표시 줄 메시지가 있으며, fish_title 함수가 정의되지 않은 경우에 사용됩니다. 따라서 단순히 fish_title 함수를 설정 해제하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="216dd486d99355c7f2e848a5066c6390232ae830" translate="yes" xml:space="preserve">
          <source>Note that for backwards compatibility each subcommand can also be specified as a long option. For example, rather than &lt;code&gt;history search&lt;/code&gt; you can type &lt;code&gt;history --search&lt;/code&gt;. Those long options are deprecated and will be removed in a future release.</source>
          <target state="translated">이전 버전과의 호환성을 위해 각 하위 명령을 긴 옵션으로 지정할 수도 있습니다. 예를 들어 &lt;code&gt;history search&lt;/code&gt; 대신 &lt;code&gt;history --search&lt;/code&gt; 를 입력 할 수 있습니다 . 이러한 긴 옵션은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="3b22090df2d664d4741cb8fa8f02ce46c5b511d7" translate="yes" xml:space="preserve">
          <source>Note that for most commands, if any wildcard fails to expand, the command is not executed, &lt;a href=&quot;#variables-status&quot;&gt;$status&lt;/a&gt; is set to nonzero, and a warning is printed. This behavior is consistent with setting &lt;code&gt;shopt -s failglob&lt;/code&gt; in bash. There are exactly 4 exceptions, namely &lt;a href=&quot;cmds/set#cmd-set&quot;&gt;set&lt;/a&gt;, overriding variables in &lt;a href=&quot;#variables-override&quot;&gt;overrides&lt;/a&gt;, &lt;a href=&quot;cmds/count#cmd-count&quot;&gt;count&lt;/a&gt; and &lt;a href=&quot;cmds/for#cmd-for&quot;&gt;for&lt;/a&gt;. Their globs are permitted to expand to zero arguments, as with &lt;code&gt;shopt -s nullglob&lt;/code&gt; in bash.</source>
          <target state="translated">대부분의 명령에서 와일드 카드가 확장되지 않으면 명령이 실행되지 않고 &lt;a href=&quot;#variables-status&quot;&gt;$ status&lt;/a&gt; 가 0이 아닌 값으로 설정되며 경고가 인쇄됩니다. 이 동작은 bash에서 &lt;code&gt;shopt -s failglob&lt;/code&gt; 설정과 일치합니다 . 정확히 4 개의 예외, 즉 &lt;a href=&quot;cmds/set#cmd-set&quot;&gt;set&lt;/a&gt; , &lt;a href=&quot;#variables-override&quot;&gt;overrides&lt;/a&gt; , &lt;a href=&quot;cmds/count#cmd-count&quot;&gt;count&lt;/a&gt; 및 &lt;a href=&quot;cmds/for#cmd-for&quot;&gt;for&lt;/a&gt; 에서 변수를 재정의 합니다 . 그들의 glob은 bash의 &lt;code&gt;shopt -s nullglob&lt;/code&gt; 과 마찬가지로 0 인수로 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c97f265eeb04a552b0a053d1fe6fd39164111e41" translate="yes" xml:space="preserve">
          <source>Note that for most commands, if any wildcard fails to expand, the command is not executed, &lt;a href=&quot;#variables-status&quot;&gt;&lt;code&gt;$status&lt;/code&gt;&lt;/a&gt; is set to nonzero, and a warning is printed. This behavior is consistent with setting &lt;code&gt;shopt -s failglob&lt;/code&gt; in bash. There are exactly 3 exceptions, namely &lt;a href=&quot;commands#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;commands#count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;commands#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt;. Their globs are permitted to expand to zero arguments, as with &lt;code&gt;shopt -s nullglob&lt;/code&gt; in bash.</source>
          <target state="translated">대부분의 명령에서 와일드 카드 확장에 실패하면 명령이 실행되지 않고 &lt;a href=&quot;#variables-status&quot;&gt; &lt;code&gt;$status&lt;/code&gt; &lt;/a&gt; 가 0이 아닌 값으로 설정되고 경고가 인쇄됩니다. 이 동작은 bash에서 &lt;code&gt;shopt -s failglob&lt;/code&gt; 설정과 일치합니다 . 정확히 세 가지 예외, 즉 &lt;a href=&quot;commands#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;commands#count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;commands#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; 가&lt;/a&gt; 있습니다. bash에서 &lt;code&gt;shopt -s nullglob&lt;/code&gt; 와 같이, globs는 0 개의 인수로 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="179b535385e9bcd6de7a6f886e309b106b43e8dd" translate="yes" xml:space="preserve">
          <source>Note that functions cannot be started in the background. Functions that are stopped and then restarted in the background using the &lt;code&gt;bg&lt;/code&gt; command will not execute correctly.</source>
          <target state="translated">백그라운드에서 기능을 시작할 수 없습니다. &lt;code&gt;bg&lt;/code&gt; 명령을 사용하여 백그라운드 에서 중지했다가 다시 시작된 기능은 올바르게 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0299abe7df714002513b6c5ca5f854adee2c02d" translate="yes" xml:space="preserve">
          <source>Note that list indices start at 1 in &lt;code&gt;fish&lt;/code&gt;, not 0, as is more common in other languages. This is because many common Unix tools like &lt;code&gt;seq&lt;/code&gt; are more suited to such use. An invalid index is silently ignored resulting in no value being substituted (not an empty string).</source>
          <target state="translated">목록 색인 은 다른 언어에서 더 일반적으로 사용되는 것처럼 0이 아닌 &lt;code&gt;fish&lt;/code&gt; 에서 1에서 시작 합니다. 이는 &lt;code&gt;seq&lt;/code&gt; 와 같은 많은 일반적인 Unix 도구 가 이러한 용도에 더 적합하기 때문입니다. 잘못된 인덱스는 자동으로 무시되어 값이 대체되지 않습니다 (빈 문자열이 아님).</target>
        </trans-unit>
        <trans-unit id="56578f519a03e2785432ffc83f432b088789cd11" translate="yes" xml:space="preserve">
          <source>Note that most builtin commands display their help in the terminal when given the &lt;code&gt;--help&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;--help&lt;/code&gt; 옵션이 주어지면 대부분의 내장 명령이 터미널에 도움말을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="052c493b4f8ae8b6935593bcf58c5ec984ab99f3" translate="yes" xml:space="preserve">
          <source>Note that not all these limits are available in all operating systems.</source>
          <target state="translated">모든 운영 체제에서 이러한 제한을 모두 사용할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fd0759c196f448d14f3c2205ba14675a88db1daf" translate="yes" xml:space="preserve">
          <source>Note that parentheses will usually require escaping with &lt;code&gt;\(&lt;/code&gt; to avoid being interpreted as a command substitution.</source>
          <target state="translated">괄호는 일반적으로 명령 대체로 해석되지 않도록 &lt;code&gt;\(&lt;/code&gt; 이스케이프 처리를 요구합니다 .</target>
        </trans-unit>
        <trans-unit id="188395866987d29873c39e6fea9524d72368f195" translate="yes" xml:space="preserve">
          <source>Note that seeding the engine will NOT give the same result across different systems.</source>
          <target state="translated">엔진 시딩은 다른 시스템에서 동일한 결과를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b65cb077ea76993a41de3fb713b42e0fed91a42b" translate="yes" xml:space="preserve">
          <source>Note that symbolic masks currently do not work as intended.</source>
          <target state="translated">기호 마스크는 현재 의도 한대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bef2f79c5ca0fefc2538b283ecde5e201f174c69" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;cd&lt;/code&gt; command limits directory history to the 25 most recently visited directories. The history is stored in the &lt;code&gt;$dirprev&lt;/code&gt; and &lt;code&gt;$dirnext&lt;/code&gt; variables which this command manipulates.</source>
          <target state="translated">참고 것을 &lt;code&gt;cd&lt;/code&gt; 명령은 25 가장 최근에 방문한 디렉토리에 대한 디렉토리 역사를 제한합니다. 히스토리는 이 명령이 조작 하는 &lt;code&gt;$dirprev&lt;/code&gt; 및 &lt;code&gt;$dirnext&lt;/code&gt; 변수에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="10a8eb5ef4bfcbb0fbb38b2c1dbc89e74a6c7106" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;cd&lt;/code&gt; command limits directory history to the 25 most recently visited directories. The history is stored in the &lt;code&gt;$dirprev&lt;/code&gt; and &lt;code&gt;$dirnext&lt;/code&gt; variables which this command manipulates. If you make those universal variables your &lt;code&gt;cd&lt;/code&gt; history is shared among all fish instances.</source>
          <target state="translated">참고 것을 &lt;code&gt;cd&lt;/code&gt; 명령은 25 가장 최근에 방문한 디렉토리에 대한 디렉토리 역사를 제한합니다. 히스토리는 이 명령이 조작 하는 &lt;code&gt;$dirprev&lt;/code&gt; 및 &lt;code&gt;$dirnext&lt;/code&gt; 변수에 저장됩니다 . 이러한 범용 변수를 만들면 모든 기록에서 &lt;code&gt;cd&lt;/code&gt; 기록이 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="9b4bda95d407194baa99d73ed10ab09fd4118640" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;cd&lt;/code&gt; command limits directory history to the 25 most recently visited directories. The history is stored in the &lt;code&gt;$dirprev&lt;/code&gt; and &lt;code&gt;$dirnext&lt;/code&gt; variables.</source>
          <target state="translated">참고 것을 &lt;code&gt;cd&lt;/code&gt; 명령은 25 가장 최근에 방문한 디렉토리에 대한 디렉토리 역사를 제한합니다. 히스토리는 &lt;code&gt;$dirprev&lt;/code&gt; 및 &lt;code&gt;$dirnext&lt;/code&gt; 변수에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="468f475ce4540aa6d4ffc053e8efd0e42aba5839" translate="yes" xml:space="preserve">
          <source>Note that the shell will attempt to change directory without requiring &lt;code&gt;cd&lt;/code&gt; if the name of a directory is provided (starting with &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;~&lt;/code&gt;, or ending with &lt;code&gt;/&lt;/code&gt;).</source>
          <target state="translated">디렉토리 이름이 제공 되면 ( &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;~&lt;/code&gt; 로 시작 하거나 &lt;code&gt;/&lt;/code&gt; 로 끝나는 경우) 쉘은 &lt;code&gt;cd&lt;/code&gt; 를 요구하지 않고 디렉토리를 변경하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="4a1ad39e7a025d924c676894892c33d43f516843" translate="yes" xml:space="preserve">
          <source>Note that there are three environment variables that are automatically split on colons to become lists when fish starts running: &lt;code&gt;PATH&lt;/code&gt;, &lt;code&gt;CDPATH&lt;/code&gt;, &lt;code&gt;MANPATH&lt;/code&gt;. Conversely, they are joined on colons when exported to subcommands. All other environment variables (e.g., &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;) which have similar semantics are treated as simple strings.</source>
          <target state="translated">물고기가 시작될 때 콜론에서 자동으로 분할되어 목록이되기위한 세 가지 환경 변수 ( &lt;code&gt;PATH&lt;/code&gt; , &lt;code&gt;CDPATH&lt;/code&gt; , &lt;code&gt;MANPATH&lt;/code&gt; )가 있습니다. 반대로 하위 명령으로 내보낼 때 콜론에서 결합됩니다. 의미가 비슷한 다른 모든 환경 변수 (예 : &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; )는 간단한 문자열로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bf45589c3e3c3f4d264bc9f93c56158f4afde11c" translate="yes" xml:space="preserve">
          <source>Note that this function will not be used if a command by this name exists (which is the case on macOS or Haiku).</source>
          <target state="translated">이 이름의 명령이있는 경우 (macOS 또는 Haiku의 경우)이 기능은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bf381b343429f3c3b6b07cc6b6f0a80c7987163" translate="yes" xml:space="preserve">
          <source>Note that without the quotes or braces, fish will try to expand a variable called &lt;code&gt;$WORDs&lt;/code&gt;, which may not exist.</source>
          <target state="translated">따옴표 나 괄호가 없으면 fish는 존재하지 않을 수있는 &lt;code&gt;$WORDs&lt;/code&gt; 라는 변수를 확장하려고 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="655206648d0dc7faa21d15bc23b20c851a2e5079" translate="yes" xml:space="preserve">
          <source>Note that ~/.config/fish/config.fish is sourced &lt;em&gt;after&lt;/em&gt; the snippets. This is so users can copy snippets and override some of their behavior.</source>
          <target state="translated">~ /의 .config / 생선 / config.fish가 공급되는 주 &lt;em&gt;후&lt;/em&gt; 코드 조각. 사용자가 스 니펫을 복사하고 일부 동작을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce33996fd64092e1167cf6f8d31deb6827e1e03e" translate="yes" xml:space="preserve">
          <source>Note that ~/.config/fish/config.fish is sourced _after_ the snippets. This is so users can copy snippets and override some of their behavior.</source>
          <target state="translated">~ / .config / fish / config.fish는 스 니펫 _after_ 소스입니다. 이는 사용자가 스 니펫을 복사하고 일부 동작을 재정의 할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e4d54cdd421c0c07715137d8eb13776063e53178" translate="yes" xml:space="preserve">
          <source>Note that, like &lt;code&gt;wc -l&lt;/code&gt;, reading from stdin counts newlines, so &lt;code&gt;echo -n foo | count&lt;/code&gt; will print 0.</source>
          <target state="translated">&lt;code&gt;wc -l&lt;/code&gt; 처럼 stdin에서 읽는 것은 개행을 계산하므로 &lt;code&gt;echo -n foo | count&lt;/code&gt; 는 0을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="e2ce3cf51c29175bd1e3054b41cb66e679925023" translate="yes" xml:space="preserve">
          <source>Note that, like GNU tools and most of fish's builtins, &lt;code&gt;contains&lt;/code&gt; interprets all arguments starting with a &lt;code&gt;-&lt;/code&gt; as options to contains, until it reaches an argument that is &lt;code&gt;--&lt;/code&gt; (two dashes). See the examples below.</source>
          <target state="translated">GNU 도구처럼, 그 주와 생선의 내장 매크로의 대부분은 &lt;code&gt;contains&lt;/code&gt; 모든 인수가 함께 시작하는 해석 &lt;code&gt;-&lt;/code&gt; 그것이 인수에 도달 할 때까지, 포함에 옵션으로를 &lt;code&gt;--&lt;/code&gt; (두 개의 대시를). 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6acc4ccc246684cfa1057fb20ffd8a8f35f63d65" translate="yes" xml:space="preserve">
          <source>Note that, unlike other shells, fish will first set the variable and then perform other expansions on the line, so:</source>
          <target state="translated">다른 셸과 달리 물고기는 먼저 변수를 설정 한 다음 줄에서 다른 확장을 수행하므로 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="9cd1c04aa664d29ef9d4114fed80a20478f9f7c6" translate="yes" xml:space="preserve">
          <source>Note: At the moment the debug prompt is identical to your normal fish prompt. This can make it hard to recognize that you've entered a debug session. Issue 1310 is open to improve this.</source>
          <target state="translated">참고 : 현재 디버그 프롬프트는 일반 물고기 프롬프트와 동일합니다. 이로 인해 디버그 세션에 들어갔다는 것을 인식하기가 어려울 수 있습니다. 이를 개선하기 위해 이슈 1310이 공개되었습니다.</target>
        </trans-unit>
        <trans-unit id="2acd9175970aa8fc3b9936ce32e6e5f5129257b5" translate="yes" xml:space="preserve">
          <source>Note: This event will be emitted even if the command is invalid. The commandline parameter includes the entire commandline verbatim, and may potentially include newlines.</source>
          <target state="translated">참고 :이 이벤트는 명령이 유효하지 않은 경우에도 생성됩니다. commandline 매개 변수는 전체 명령 행 그대로 포함되며 잠재적으로 개행을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a71ed28fa070fd5d0f2ba5d9d8b94e51646208b" translate="yes" xml:space="preserve">
          <source>Note: fish 2.2.0 and earlier used a default of 10 milliseconds, and provided no way to configure it. That effectively made it impossible to use escape as a meta key.</source>
          <target state="translated">참고 : fish 2.2.0 및 이전 버전은 기본값 10 밀리 초를 사용했으며이를 구성 할 방법을 제공하지 않았습니다. 이로 인해 이스케이프를 메타 키로 사용할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="03c757f6b7891744a49627d17ec9ed791ed69d26" translate="yes" xml:space="preserve">
          <source>Nothing if the flag is a boolean that takes no argument or is an implicit int flag, else</source>
          <target state="translated">플래그가 인수를 취하지 않거나 묵시적 int 플래그 인 부울 인 경우에는 아무것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e9e91cddb4e1bbe3d96c5cfb7bcf12796b0c7e0" translate="yes" xml:space="preserve">
          <source>Now hub inherits all of the completions from git. Note this can also be specified in a function declaration.</source>
          <target state="translated">이제 허브는 git의 모든 완성을 상속합니다. 이것은 함수 선언에서도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="377c6369b04b17877206baabd99b8340d2c1712d" translate="yes" xml:space="preserve">
          <source>Now in another shell:</source>
          <target state="translated">이제 다른 쉘에서 :</target>
        </trans-unit>
        <trans-unit id="d5aead3c087eb1218d9c5de157a34a40ad6e6161" translate="yes" xml:space="preserve">
          <source>Numerical comparisons will simply fail if one of the operands is not a number:</source>
          <target state="translated">피연산자 중 하나가 숫자가 아닌 경우 숫자 비교는 단순히 실패합니다.</target>
        </trans-unit>
        <trans-unit id="aeeb9e7d5766fc544e9c4260b0a26961443229c2" translate="yes" xml:space="preserve">
          <source>Oh My Fish</source>
          <target state="translated">오 마이 피쉬</target>
        </trans-unit>
        <trans-unit id="c168b84a253f1a9380f35914e43b4459d37046ec" translate="yes" xml:space="preserve">
          <source>Old style long options, like '&lt;code&gt;-Wall&lt;/code&gt;'. Old style long options can be more than one character long, are preceded by a single hyphen and may not be grouped together. Option arguments are specified in the following parameter ('&lt;code&gt;-ao null&lt;/code&gt;').</source>
          <target state="translated">' &lt;code&gt;-Wall&lt;/code&gt; ' 과 같은 오래된 스타일의 긴 옵션 . 이전 스타일의 긴 옵션은 하나 이상의 문자 길이를 가질 수 있으며 앞에 하이픈이 붙어 그룹화되지 않을 수 있습니다. 옵션 인수는 다음 매개 변수 ( ' &lt;code&gt;-ao null&lt;/code&gt; ')에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="b9e42bb3078b6143675803071b50a1f886f1fddf" translate="yes" xml:space="preserve">
          <source>On startup, Fish evaluates a number of configuration files, which can be used to control the behavior of the shell. The location of these configuration variables is controlled by a number of environment variables, and their default or usual location is given below.</source>
          <target state="translated">시작시 Fish는 여러 가지 구성 파일을 평가하여 셸의 동작을 제어하는 ​​데 사용할 수 있습니다. 이러한 구성 변수의 위치는 여러 환경 변수에 의해 제어되며 기본 또는 일반적인 위치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24b148830736c9caeaaf006e4d059c7b395c5a53" translate="yes" xml:space="preserve">
          <source>On startup, Fish evaluates a number of configuration files, which can be used to control the behavior of the shell. The location of these is controlled by a number of environment variables, and their default or usual location is given below.</source>
          <target state="translated">시작시 Fish는 셸의 동작을 제어하는 ​​데 사용할 수있는 여러 구성 파일을 평가합니다. 이들의 위치는 여러 환경 변수에 의해 제어되며 기본 또는 일반적인 위치는 아래에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="53732b6ec19e859a0b3473ce5240c51bbdc7db63" translate="yes" xml:space="preserve">
          <source>On systems that supports this feature, jobs will print the CPU usage of each job since the last command was executed. The CPU usage is expressed as a percentage of full CPU activity. Note that on multiprocessor systems, the total activity may be more than 100%.</source>
          <target state="translated">이 기능을 지원하는 시스템에서 작업은 마지막 명령이 실행 된 이후 각 작업의 CPU 사용량을 인쇄합니다. CPU 사용량은 전체 CPU 활동의 백분율로 표시됩니다. 다중 프로세서 시스템에서 총 활동은 100 % 이상일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b94b1b00f4f9d7408bbdbe697afeca3ea6a2231" translate="yes" xml:space="preserve">
          <source>Once fish has been installed, open a terminal. If fish is not the default shell:</source>
          <target state="translated">물고기가 설치되면 터미널을 엽니 다. 물고기가 기본 쉘이 아닌 경우 :</target>
        </trans-unit>
        <trans-unit id="18125968ef24a12c2f2c9db564d4fb936f8a352f" translate="yes" xml:space="preserve">
          <source>Once installed, just type in &lt;code&gt;fish&lt;/code&gt; into your current shell to try it out!</source>
          <target state="translated">설치가 완료되면 현재 껍질 에 &lt;code&gt;fish&lt;/code&gt; 을 입력 하여 사용해보십시오!</target>
        </trans-unit>
        <trans-unit id="f9801d214429ef9429f41d9ccbf53d1f50cc2cf7" translate="yes" xml:space="preserve">
          <source>One of the most common uses for functions is to slightly alter the behavior of an already existing command. For example, one might want to redefine the &lt;code&gt;ls&lt;/code&gt; command to display colors. The switch for turning on colors on GNU systems is '&lt;code&gt;--color=auto&lt;/code&gt;'. An alias, or wrapper, around &lt;code&gt;ls&lt;/code&gt; might look like this:</source>
          <target state="translated">함수의 가장 일반적인 용도 중 하나는 기존 명령의 동작을 약간 변경하는 것입니다. 예를 들어 &lt;code&gt;ls&lt;/code&gt; 명령을 재정 의하여 색상을 표시 할 수 있습니다. GNU 시스템에서 색상을 켜기위한 스위치는 ' &lt;code&gt;--color=auto&lt;/code&gt; '입니다. &lt;code&gt;ls&lt;/code&gt; 주위의 별명 또는 랩퍼 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6ed72e8734163b3555d72a22a65213a63ac427a" translate="yes" xml:space="preserve">
          <source>Only one function's description can be changed in a single invocation of &lt;code&gt;functions -d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;functions -d&lt;/code&gt; 의 단일 호출에서 하나의 함수 설명 만 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="744f6b1ea6029a4d03e486aa51d71e6cdfe3a24a" translate="yes" xml:space="preserve">
          <source>Only part of the output can be used, see &lt;a href=&quot;#expand-index-range&quot;&gt;index range expansion&lt;/a&gt; for details.</source>
          <target state="translated">출력의 일부만 사용할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;#expand-index-range&quot;&gt;인덱스 범위 확장&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="e52f4d4c344dadad003e702bffb9e5e28cdc4a21" translate="yes" xml:space="preserve">
          <source>Operators for files and directories</source>
          <target state="translated">파일과 디렉토리를위한 연산자</target>
        </trans-unit>
        <trans-unit id="f27bb0ff136bb8c7c7f1daaac32275d53bfd219d" translate="yes" xml:space="preserve">
          <source>Operators for text strings</source>
          <target state="translated">텍스트 문자열의 연산자</target>
        </trans-unit>
        <trans-unit id="a47a505eb7af733ce0bd8e9777ac0dd7490e55d7" translate="yes" xml:space="preserve">
          <source>Operators to combine expressions</source>
          <target state="translated">표현식을 결합하는 연산자</target>
        </trans-unit>
        <trans-unit id="7fa47fe3927b334a484c669114b525abc6a94112" translate="yes" xml:space="preserve">
          <source>Operators to compare and examine numbers</source>
          <target state="translated">숫자를 비교하고 조사하는 연산자</target>
        </trans-unit>
        <trans-unit id="d4829f651a76eb5aa9c3d27e3534a7c418cd1fc9" translate="yes" xml:space="preserve">
          <source>Option Specifications</source>
          <target state="translated">옵션 사양</target>
        </trans-unit>
        <trans-unit id="7a482cf8fb70076ae04055b4c030c65bed8421d9" translate="yes" xml:space="preserve">
          <source>Optionally a &lt;code&gt;!&lt;/code&gt; followed by fish script to validate the value. Typically this will be a function to run. If the exit status is zero the value for the flag is valid. If non-zero the value is invalid. Any error messages should be written to stdout (not stderr). See the section on &lt;a href=&quot;#flag-value-validation&quot;&gt;Flag Value Validation&lt;/a&gt; for more information.</source>
          <target state="translated">선택적으로 &lt;code&gt;!&lt;/code&gt; 값을 확인하기 위해 물고기 스크립트가 뒤 따릅니다. 일반적으로 이것은 실행할 함수입니다. 종료 상태가 0이면 플래그 값이 유효합니다. 0이 아니면 값이 유효하지 않습니다. 모든 오류 메시지는 stdout (stderr 아님)에 기록해야합니다. 자세한 내용은 &lt;a href=&quot;#flag-value-validation&quot;&gt;플래그 값 유효성 검사&lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6f38993c6d0d5cf791252a01f84f61ce28090cdc" translate="yes" xml:space="preserve">
          <source>Optionally a &lt;code&gt;!&lt;/code&gt; followed by fish script to validate the value. Typically this will be a function to run. If the return status is zero the value for the flag is valid. If non-zero the value is invalid. Any error messages should be written to stdout (not stderr). See the section on &lt;a href=&quot;#arparse-validation&quot;&gt;Flag Value Validation&lt;/a&gt; for more information.</source>
          <target state="translated">선택적으로 &lt;code&gt;!&lt;/code&gt; 값을 확인하기 위해 피쉬 스크립트가 이어집니다. 일반적으로 이것은 실행하는 기능입니다. 리턴 상태가 0이면 플래그의 값이 유효합니다. 0이 아닌 값은 유효하지 않습니다. 모든 오류 메시지는 stderout이 아닌 stdout에 작성해야합니다. 자세한 내용은 &lt;a href=&quot;#arparse-validation&quot;&gt;플래그 값 유효성 검사&lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="3b7277ba5f0f20e70f1f91d410bbc35500c732a7" translate="yes" xml:space="preserve">
          <source>Or if you just want to do one command in case the first succeeded or failed, use &lt;code&gt;and&lt;/code&gt; or &lt;code&gt;or&lt;/code&gt;:</source>
          <target state="translated">또는 첫 번째 명령이 성공하거나 실패한 경우 하나의 명령 만 수행하려면 &lt;code&gt;and&lt;/code&gt; 또는 &lt;code&gt;or&lt;/code&gt; 다음을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="14be7a9cc678ff8d2acac3f8d22e39b9c8a4df32" translate="yes" xml:space="preserve">
          <source>Other features</source>
          <target state="translated">다른 기능들</target>
        </trans-unit>
        <trans-unit id="853554e3756e54eab25e2cb9c5b84f13d2534ef7" translate="yes" xml:space="preserve">
          <source>Other help pages</source>
          <target state="translated">기타 도움말 페이지</target>
        </trans-unit>
        <trans-unit id="8064e7b7ad17f0248f35efb48f0f1d68ee39d15e" translate="yes" xml:space="preserve">
          <source>Other shells such as bash and zsh use a variable named &lt;code&gt;HISTFILE&lt;/code&gt; for a similar purpose. Fish uses a different name to avoid conflicts and signal that the behavior is different (session name instead of a file path). Also, if you set the var to anything other than &lt;code&gt;fish&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; it will inhibit importing the bash history. That's because the most common use case for this feature is to avoid leaking private or sensitive history when giving a presentation.</source>
          <target state="translated">bash 및 zsh와 같은 다른 쉘 은 유사한 목적으로 &lt;code&gt;HISTFILE&lt;/code&gt; 이라는 변수를 사용합니다 . Fish는 다른 이름을 사용하여 충돌을 피하고 동작이 다르다는 것을 나타냅니다 (파일 경로 대신 세션 이름). 또한 var를 &lt;code&gt;fish&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; 이외의 것으로 설정 하면 bash 기록 가져 오기가 금지됩니다. 이 기능의 가장 일반적인 사용 사례는 프레젠테이션을 할 때 개인 또는 민감한 기록이 유출되지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ca76df4fa26ca40f2ebdbbcc9b7ac947b4b17597" translate="yes" xml:space="preserve">
          <source>Other shells, such as zsh, provide a rich glob syntax for restricting the files matched by globs. For example, &lt;code&gt;**(.)&lt;/code&gt;, to only match regular files. Fish prefers to defer such features to programs, such as &lt;code&gt;find&lt;/code&gt;, rather than reinventing the wheel. Thus, if you want to limit the wildcard expansion to just regular files the fish approach is to define and use a function. For example,</source>
          <target state="translated">zsh와 같은 다른 쉘은 glob과 일치하는 파일을 제한하기위한 풍부한 glob 구문을 제공합니다. 예를 들어 &lt;code&gt;**(.)&lt;/code&gt; 는 일반 파일과 만 일치합니다. 물고기는 바퀴를 재발견하기보다는 &lt;code&gt;find&lt;/code&gt; 와 같은 프로그램에 이러한 기능을 연기하는 것을 선호합니다 . 따라서 와일드 카드 확장을 일반 파일로만 제한하려면 피쉬 접근 방식은 함수를 정의하고 사용하는 것입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="14a838bcf64937317892425e5ab22ef3642359f4" translate="yes" xml:space="preserve">
          <source>Other variables, like &lt;code&gt;$PATH&lt;/code&gt;, really do have multiple values. During variable expansion, the variable expands to become multiple arguments:</source>
          <target state="translated">&lt;code&gt;$PATH&lt;/code&gt; 와 같은 다른 변수에는 실제로 여러 값이 있습니다. 변수 확장 중에 변수는 여러 인수가되도록 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="b5d3d0ee6275d093a0cfd5679e24b1abd3556dc6" translate="yes" xml:space="preserve">
          <source>Otherwise, by default, the variable will not be exported.</source>
          <target state="translated">그렇지 않으면 기본적으로 변수가 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="adcbabbfd6290e1df478b0d2b37c0beb20ff4767" translate="yes" xml:space="preserve">
          <source>Outputting multiple lines is not supported in &lt;code&gt;fish_mode_prompt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fish_mode_prompt&lt;/code&gt; 에서는 여러 줄을 출력 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5b8012177cdea50be6a01e8c45312b388ccc9c7a" translate="yes" xml:space="preserve">
          <source>Outside of double quotes, variables will expand to as many arguments as they have elements. That means an empty list will expand to nothing, a variable with one element will expand to that element, and a variable with multiple elements will expand to each of those elements separately.</source>
          <target state="translated">큰 따옴표 이외의 변수는 요소가있는만큼 많은 인수로 확장됩니다. 즉, 빈 목록은 아무 것도 확장하지 않고 하나의 요소가있는 변수는 해당 요소로 확장되며 여러 요소가있는 변수는 각 요소로 개별적으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="701d31f2af951617e24913040bb289cccf377776" translate="yes" xml:space="preserve">
          <source>Overriding variables for a single command</source>
          <target state="translated">단일 명령에 대한 변수 재정의</target>
        </trans-unit>
        <trans-unit id="b7cda6a843d651b6992452486c962d590a3cb164" translate="yes" xml:space="preserve">
          <source>PATH variables</source>
          <target state="translated">PATH 변수</target>
        </trans-unit>
        <trans-unit id="404b5a722c514f9f99c58c8b9832dbdc15c84e14" translate="yes" xml:space="preserve">
          <source>PATH variables act as normal arrays, except they are are implicitly joined and split on colons.</source>
          <target state="translated">PATH 변수는 암시 적으로 결합되고 콜론으로 분할되는 것을 제외하고 일반 배열로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b66696987075bafb7f873ca41d609e5877999e68" translate="yes" xml:space="preserve">
          <source>PATH variables act as normal lists, except they are are implicitly joined and split on colons.</source>
          <target state="translated">PATH 변수는 암시 적으로 조인되고 콜론으로 분할된다는 점을 제외하고는 일반 목록으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5c77b5722c41b6f199f92efb5977aba4430b61c9" translate="yes" xml:space="preserve">
          <source>Page Up</source>
          <target state="translated">페이지 위로</target>
        </trans-unit>
        <trans-unit id="6b76530ae6668a37f97a682d440c45d138de6409" translate="yes" xml:space="preserve">
          <source>Parameter expansion (Globbing)</source>
          <target state="translated">파라미터 확장 (글 로빙)</target>
        </trans-unit>
        <trans-unit id="0fdb3f75d27167ce5697671dbec55e14ed3744ea" translate="yes" xml:space="preserve">
          <source>Parentheses and the &lt;code&gt;-o&lt;/code&gt; and &lt;code&gt;-a&lt;/code&gt; operators can be combined to produce more complicated expressions. In this example, success is printed if there is a &lt;code&gt;/foo&lt;/code&gt; or &lt;code&gt;/bar&lt;/code&gt; file as well as a &lt;code&gt;/baz&lt;/code&gt; or &lt;code&gt;/bat&lt;/code&gt; file.</source>
          <target state="translated">괄호와 &lt;code&gt;-o&lt;/code&gt; 및 &lt;code&gt;-a&lt;/code&gt; 연산자를 결합하여보다 복잡한 표현을 만들 수 있습니다. 이 예에서 &lt;code&gt;/foo&lt;/code&gt; 또는 &lt;code&gt;/bar&lt;/code&gt; 파일과 &lt;code&gt;/baz&lt;/code&gt; 또는 &lt;code&gt;/bat&lt;/code&gt; 파일 이 있으면 성공이 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0efa09d094aec052590bdd703ecb253fb17eb1e" translate="yes" xml:space="preserve">
          <source>Path variables are a special kind of variable used to support colon-delimited path lists including PATH, CDPATH, MANPATH, PYTHONPATH, etc. All variables that end in &lt;code&gt;PATH&lt;/code&gt; (case-sensitive) become PATH variables.</source>
          <target state="translated">경로 변수는 PATH, CDPATH, MANPATH, PYTHONPATH 등을 포함하여 콜론으로 구분 된 경로 목록을 지원하는 데 사용되는 특수한 종류의 변수입니다. &lt;code&gt;PATH&lt;/code&gt; (대소 문자 구분)로 끝나는 모든 변수는 PATH 변수가됩니다.</target>
        </trans-unit>
        <trans-unit id="db92c54d01dcbf9ce9147cf302fcbe0e8290138e" translate="yes" xml:space="preserve">
          <source>Performs a history search when the</source>
          <target state="translated">이력 검색을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="acdeb27738adfec3e214f14b0bc5ac319dee18bf" translate="yes" xml:space="preserve">
          <source>Performs a history search when the &lt;b&gt;Page Up&lt;/b&gt; key is pressed.</source>
          <target state="translated">&lt;b&gt;Page Up&lt;/b&gt; 키를 누를 때 히스토리 검색을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="b07e355a3677aa688ad89bddfe79ee5b312d7645" translate="yes" xml:space="preserve">
          <source>Pipes and Redirections</source>
          <target state="translated">파이프 및 리디렉션</target>
        </trans-unit>
        <trans-unit id="109d28af6c9d51926601f8d9e60546da74487021" translate="yes" xml:space="preserve">
          <source>Pipes usually connect file descriptor 1 (standard output) of the first process to file descriptor 0 (standard input) of the second process. It is possible to use a different output file descriptor by prepending the desired FD number and then output redirect symbol to the pipe. For example:</source>
          <target state="translated">파이프는 일반적으로 첫 번째 프로세스의 파일 설명자 1 (표준 출력)을 두 번째 프로세스의 파일 설명자 0 (표준 입력)에 연결합니다. 원하는 FD 번호를 앞에 붙여 다른 출력 파일 디스크립터를 사용하고 파이프에 리디렉션 경로를 출력 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3247b493bc40b8745523a27d8c525cd0dc056fd5" translate="yes" xml:space="preserve">
          <source>Piping</source>
          <target state="translated">Piping</target>
        </trans-unit>
        <trans-unit id="36298b88737bbda60ad0697ed9af7787bf89ea37" translate="yes" xml:space="preserve">
          <source>Please note that event handlers only become active when a function is loaded, which means you might need to otherwise &lt;a href=&quot;cmds/source#cmd-source&quot;&gt;source&lt;/a&gt; or execute a function instead of relying on &lt;a href=&quot;#syntax-function-autoloading&quot;&gt;autoloading&lt;/a&gt;. One approach is to put it into your &lt;a href=&quot;#initialization&quot;&gt;initialization file&lt;/a&gt;.</source>
          <target state="translated">이벤트 핸들러는 함수가로드 될 때만 활성화됩니다. 즉, &lt;a href=&quot;#syntax-function-autoloading&quot;&gt;자동로드&lt;/a&gt; 에 의존하는 대신 함수를 &lt;a href=&quot;cmds/source#cmd-source&quot;&gt;소싱&lt;/a&gt; 하거나 실행 해야 할 수도 있습니다 . 한 가지 방법은이를 &lt;a href=&quot;#initialization&quot;&gt;초기화 파일&lt;/a&gt; 에 넣는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="484a02744408ea850ed69df5530d98aa375e29f4" translate="yes" xml:space="preserve">
          <source>Please note that event handlers only become active when a function is loaded, which means you might need to otherwise &lt;a href=&quot;commands#source&quot;&gt;source&lt;/a&gt; or execute a function instead of relying on &lt;a href=&quot;#syntax-function-autoloading&quot;&gt;autoloading&lt;/a&gt;. One approach is to put it into your &lt;a href=&quot;index#initialization&quot;&gt;initialization file&lt;/a&gt;.</source>
          <target state="translated">이벤트 핸들러는 함수가로드 될 때만 활성화되므로 &lt;a href=&quot;#syntax-function-autoloading&quot;&gt;자동로드&lt;/a&gt; 에 의존하는 대신 함수를 &lt;a href=&quot;commands#source&quot;&gt;소싱&lt;/a&gt; 하거나 실행 해야 할 수도 있습니다 . 한 가지 방법은 &lt;a href=&quot;index#initialization&quot;&gt;초기화 파일&lt;/a&gt; 에 넣는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0e1a82c707f23d09169b7a07b352752535b796b2" translate="yes" xml:space="preserve">
          <source>Prefixing a feature with &lt;code&gt;no-&lt;/code&gt; turns it off instead. .. _other:</source>
          <target state="translated">기능 앞에 &lt;code&gt;no-&lt;/code&gt; 를 붙이면 대신 꺼집니다. .. _ 기타 :</target>
        </trans-unit>
        <trans-unit id="d9da79a093b23650535a151c09a73e3fee5ee4ae" translate="yes" xml:space="preserve">
          <source>Prefixing the commandline with a space will prevent the entire line from being stored in the history.</source>
          <target state="translated">명령 행 앞에 공백이 있으면 전체 행이 히스토리에 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae87eccf04345730f74111e3854e8d88c3f15602" translate="yes" xml:space="preserve">
          <source>Prepends &lt;code&gt;sudo&lt;/code&gt; to the current commandline.</source>
          <target state="translated">현재 명령 줄 앞에 &lt;code&gt;sudo&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="ea683ad616063b7347bdddeee7203a82e1a3805b" translate="yes" xml:space="preserve">
          <source>Press</source>
          <target state="translated">Press</target>
        </trans-unit>
        <trans-unit id="fe2ed6ea3216d06709445e2c3ce6b00041d037ed" translate="yes" xml:space="preserve">
          <source>Press &lt;b&gt;Tab&lt;/b&gt;, and &lt;code&gt;fish&lt;/code&gt; will attempt to complete the command, argument, or path:</source>
          <target state="translated">를 눌러 &lt;b&gt;탭&lt;/b&gt; , 그리고 &lt;code&gt;fish&lt;/code&gt; 명령, 인수, 또는 경로를 완료하려고 시도합니다 :</target>
        </trans-unit>
        <trans-unit id="7ec470886283f4bfbbc71ce123f5602a60ae342e" translate="yes" xml:space="preserve">
          <source>Pressing</source>
          <target state="translated">Pressing</target>
        </trans-unit>
        <trans-unit id="09c712c74db06b262e6e04d6f0d9c7fa02c47733" translate="yes" xml:space="preserve">
          <source>Pressing &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;Enter&lt;/b&gt; instead of pressing the &lt;b&gt;Enter&lt;/b&gt; key.</source>
          <target state="translated">누르면 &lt;em&gt;Alt 키를&lt;/em&gt; - &lt;b&gt;입력&lt;/b&gt; 대신 눌러의 &lt;b&gt;입력&lt;/b&gt; 키를 누릅니다.</target>
        </trans-unit>
        <trans-unit id="18a079610776709bdf0e5127ade329eadec0eaa4" translate="yes" xml:space="preserve">
          <source>Pressing the</source>
          <target state="translated">누르면</target>
        </trans-unit>
        <trans-unit id="27bf58510d3b20325eed84381a6d30434da9e2ca" translate="yes" xml:space="preserve">
          <source>Pressing the &lt;b&gt;Enter&lt;/b&gt; key while a block of commands is unclosed, such as when one or more block commands such as &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt; or &lt;code&gt;if&lt;/code&gt; do not have a corresponding &lt;code&gt;end&lt;/code&gt; command.</source>
          <target state="translated">(가)를 누르면 &lt;b&gt;입력&lt;/b&gt; 하나 이상의 블록과 같은 명령 때와 같이 명령 블록이 닫히지 않은 상태에서 키를 &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;begin&lt;/code&gt; 또는 &lt;code&gt;if&lt;/code&gt; 해당이없는 &lt;code&gt;end&lt;/code&gt; 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="68f9e196a99ef7c54610b77d7819c1536c7dc380" translate="yes" xml:space="preserve">
          <source>Previous versions of fish also allowed spelling this as &lt;code&gt;^DESTINATION&lt;/code&gt;, but that made another character special so it was deprecated and will be removed in future.</source>
          <target state="translated">이전 버전의 fish는 또한 이것을 &lt;code&gt;^DESTINATION&lt;/code&gt; 로 철자를 허용 했지만 다른 문자를 특별하게 만들었으므로 더 이상 사용되지 않으며 향후 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="27493f631ba000f95a572539cafcbb594a951944" translate="yes" xml:space="preserve">
          <source>Print Top and Bottom on separate lines, using an escape sequence</source>
          <target state="translated">이스케이프 시퀀스를 사용하여 별도의 줄에 위쪽과 아래쪽을 인쇄</target>
        </trans-unit>
        <trans-unit id="84c34db7a924b44d0ab81ef51631e488d755a55a" translate="yes" xml:space="preserve">
          <source>Print hello world to stdout</source>
          <target state="translated">안녕하세요 세계를 stdout에 인쇄</target>
        </trans-unit>
        <trans-unit id="ad29dcc16fea024e7e41818ab9d4740b264b782b" translate="yes" xml:space="preserve">
          <source>Prior to the addition of this builtin command in the 2.7.0 release there were two main ways to parse the arguments passed to a fish script or function. One way was to use the OS provided &lt;code&gt;getopt&lt;/code&gt; command. The problem with that is that the GNU and BSD implementations are not compatible. Which makes using that external command difficult other than in trivial situations. The other way is to iterate over &lt;code&gt;$argv&lt;/code&gt; and use the fish &lt;code&gt;switch&lt;/code&gt; statement to decide how to handle the argument. That, however, involves a huge amount of boilerplate code. It is also borderline impossible to implement the same behavior as builtin commands.</source>
          <target state="translated">2.7.0 릴리스에서이 기본 제공 명령을 추가하기 전에 피쉬 스크립트 또는 함수에 전달 된 인수를 구문 분석하는 두 가지 주요 방법이있었습니다. 한 가지 방법은 OS에서 제공 한 &lt;code&gt;getopt&lt;/code&gt; 명령 을 사용하는 것 입니다. 문제는 GNU와 BSD 구현이 호환되지 않는다는 것입니다. 사소한 상황이 아닌 다른 외부 명령을 사용하기가 어렵습니다. 다른 방법은 &lt;code&gt;$argv&lt;/code&gt; 를 반복 하고 fish &lt;code&gt;switch&lt;/code&gt; 문을 사용하여 인수를 처리하는 방법을 결정하는 것입니다. 그러나 많은 양의 상용구 코드가 필요합니다. 내장 명령과 동일한 동작을 구현하는 것도 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="e14c52a6b5ed7f130784534e792abd7951342686" translate="yes" xml:space="preserve">
          <source>Private mode</source>
          <target state="translated">개인 모드</target>
        </trans-unit>
        <trans-unit id="7d03d42c737cd08e3c616e333f7637225318bb7d" translate="yes" xml:space="preserve">
          <source>Problem solved!</source>
          <target state="translated">문제 해결됨!</target>
        </trans-unit>
        <trans-unit id="27fee3438e0d28b1f5e56d2013e82bcf5b441945" translate="yes" xml:space="preserve">
          <source>Programmable prompt</source>
          <target state="translated">프로그래밍 가능한 프롬프트</target>
        </trans-unit>
        <trans-unit id="4eae5ed9e86eb92ca41dd75ef52fb9a0a53af761" translate="yes" xml:space="preserve">
          <source>Programmable title</source>
          <target state="translated">프로그래밍 가능한 제목</target>
        </trans-unit>
        <trans-unit id="a817d7eb8e0f1dab755ab5203a082e5c3c094fce" translate="yes" xml:space="preserve">
          <source>Prompt</source>
          <target state="translated">Prompt</target>
        </trans-unit>
        <trans-unit id="0495187c978ea883d19171649639e1c756060adb" translate="yes" xml:space="preserve">
          <source>Quick answer:</source>
          <target state="translated">빠른 답변 :</target>
        </trans-unit>
        <trans-unit id="7b0257ce75add65485cb879a8ababbebc2270b68" translate="yes" xml:space="preserve">
          <source>Quotes</source>
          <target state="translated">Quotes</target>
        </trans-unit>
        <trans-unit id="a5ab0c393626e6b25924176a035ebd63722dc7ec" translate="yes" xml:space="preserve">
          <source>Range expansion will go in reverse if the end element is earlier in the list than the start and forward if the end is later than the start, unless exactly one of the given indices is negative. This is to enable clamping without changing direction if the list has fewer elements than expected.</source>
          <target state="translated">주어진 인덱스 중 정확히 하나가 음수가 아닌 한, 끝 요소가 시작보다 목록의 앞쪽에 있으면 범위 확장은 반대로되고 끝이 시작보다 늦으면 앞쪽으로 확장됩니다. 이는 목록에 예상보다 적은 요소가있는 경우 방향을 변경하지 않고 클램핑을 활성화하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b16d80967d06f9706108437bd28e6a8d5175e9a0" translate="yes" xml:space="preserve">
          <source>Reading from or appending to a non existing file.</source>
          <target state="translated">존재하지 않는 파일에서 읽거나 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3e22373b8f4786a11fc3f5247c24bd1cd140127f" translate="yes" xml:space="preserve">
          <source>Ready for more?</source>
          <target state="translated">더 준비가 되셨습니까?</target>
        </trans-unit>
        <trans-unit id="ab140354a34bd045ff52d42f722acc1c4ffada22" translate="yes" xml:space="preserve">
          <source>Regular Expressions</source>
          <target state="translated">정규식</target>
        </trans-unit>
        <trans-unit id="5c8c7c6ececfc7a4858b06b4968629df633fe974" translate="yes" xml:space="preserve">
          <source>Renames an existing abbreviation from &lt;code&gt;gco&lt;/code&gt; to &lt;code&gt;gch&lt;/code&gt;.</source>
          <target state="translated">에서 기존의 약어 이름을 변경 &lt;code&gt;gco&lt;/code&gt; 에 &lt;code&gt;gch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dc79b3cd9563c59f1fd2d978861f14b1270090f" translate="yes" xml:space="preserve">
          <source>Repeat Examples</source>
          <target state="translated">예제 반복</target>
        </trans-unit>
        <trans-unit id="a879640933d6c8936ca4cc6a02a55f8cc4408041" translate="yes" xml:space="preserve">
          <source>Replace Literal Examples</source>
          <target state="translated">리터럴 예제 교체</target>
        </trans-unit>
        <trans-unit id="13b05ad41dc01c7c29077cca05d8339a7a6429b9" translate="yes" xml:space="preserve">
          <source>Replace Regex Examples</source>
          <target state="translated">정규식 예제 바꾸기</target>
        </trans-unit>
        <trans-unit id="4c85d59c181a8bdfec393789d72d1942cf54846f" translate="yes" xml:space="preserve">
          <source>Return Values</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="27ca7249b11e61ac7f3b63efe842130af63f97b8" translate="yes" xml:space="preserve">
          <source>Run the following command in fish:</source>
          <target state="translated">물고기에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ddd9c246e03e2789458ae8bb429c9d694195cb17" translate="yes" xml:space="preserve">
          <source>Running Commands</source>
          <target state="translated">명령 실행</target>
        </trans-unit>
        <trans-unit id="5c5cc33a225b06807a45544c8793a5276a15976d" translate="yes" xml:space="preserve">
          <source>Running multiple programs</source>
          <target state="translated">여러 프로그램 실행</target>
        </trans-unit>
        <trans-unit id="b6ee539e25ba9fe37112f3eead73eaed680c02a5" translate="yes" xml:space="preserve">
          <source>SEQUENCE is the character sequence to bind to. These should be written as &lt;a href=&quot;../index#escapes&quot;&gt;fish escape sequences&lt;/a&gt;. For example, because pressing the Alt key and another character sends that character prefixed with an escape character, Alt-based key bindings can be written using the &lt;code&gt;\e&lt;/code&gt; escape. For example,</source>
          <target state="translated">SEQUENCE는 바인딩 할 문자 시퀀스입니다. 이것들은 &lt;a href=&quot;../index#escapes&quot;&gt;물고기 이스케이프 시퀀스&lt;/a&gt; 로 작성되어야합니다 . 예를 들어 Alt 키와 다른 문자를 누르면 이스케이프 문자가 접두사로 붙은 해당 문자가 전송되므로 &lt;code&gt;\e&lt;/code&gt; 이스케이프를 사용하여 Alt 기반 키 바인딩을 작성할 수 있습니다 . 예를 들면</target>
        </trans-unit>
        <trans-unit id="b3fe37f1b337c360725965146e94ffa93a9708da" translate="yes" xml:space="preserve">
          <source>SEQUENCE is the character sequence to bind to. These should be written as &lt;a href=&quot;index#escapes&quot;&gt;fish escape sequences&lt;/a&gt;. For example, because pressing the Alt key and another character sends that character prefixed with an escape character, Alt-based key bindings can be written using the &lt;code&gt;\e&lt;/code&gt; escape. For example, &lt;em&gt;Alt&lt;/em&gt;-&lt;b&gt;w&lt;/b&gt; can be written as &lt;code&gt;\ew&lt;/code&gt;. The control character can be written in much the same way using the &lt;code&gt;\c&lt;/code&gt; escape, for example &lt;em&gt;Control&lt;/em&gt;-&lt;b&gt;X&lt;/b&gt; (^X) can be written as &lt;code&gt;\cx&lt;/code&gt;. Note that Alt-based key bindings are case sensitive and Control-based key bindings are not. This is a constraint of text-based terminals, not &lt;code&gt;fish&lt;/code&gt;.</source>
          <target state="translated">SEQUENCE는 바인딩 할 문자 시퀀스입니다. 이것은 &lt;a href=&quot;index#escapes&quot;&gt;물고기 탈출 순서&lt;/a&gt; 로 작성되어야합니다 . 예를 들어 Alt 키와 다른 문자를 누르면 해당 문자가 이스케이프 문자로 시작되므로 &lt;code&gt;\e&lt;/code&gt; 이스케이프를 사용하여 Alt 기반 키 바인딩을 작성할 수 있습니다 . 예를 들어 &lt;em&gt;Alt&lt;/em&gt; - &lt;b&gt;w&lt;/b&gt; 는 &lt;code&gt;\ew&lt;/code&gt; 로 쓸 수 있습니다 . 제어 문자는 &lt;code&gt;\c&lt;/code&gt; 이스케이프를 사용하여 거의 같은 방식으로 쓸 수 있습니다. 예를 들어 &lt;em&gt;Control&lt;/em&gt; - &lt;b&gt;X&lt;/b&gt; (^ X)는 &lt;code&gt;\cx&lt;/code&gt; 로 쓸 수 있습니다 . Alt 기반 키 바인딩은 대소 문자를 구분하며 Control 기반 키 바인딩은 대소 문자를 구분하지 않습니다. 이것은 &lt;code&gt;fish&lt;/code&gt; 아닌 텍스트 기반 터미널의 제약입니다..</target>
        </trans-unit>
        <trans-unit id="769ee8ba6c10d0fc5cc5d5931ff5950b069f7631" translate="yes" xml:space="preserve">
          <source>STRING arguments are taken from the command line unless standard input is connected to a pipe or a file, in which case they are read from standard input, one STRING per line. It is an error to supply STRING arguments on the command line and on standard input.</source>
          <target state="translated">표준 입력이 파이프 또는 파일에 연결되어 있지 않으면 명령 행에서 STRING 인수를 가져옵니다.이 경우 표준 입력에서 한 줄에 하나씩 STRING을 읽습니다. 명령 행 및 표준 입력에서 STRING 인수를 제공하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="4e1a6674d38590faffffeb4695d9d452b5339baa" translate="yes" xml:space="preserve">
          <source>Same as</source>
          <target state="translated">와 동일</target>
        </trans-unit>
        <trans-unit id="3e9759d5f8593842e337c74b9202035585d520b2" translate="yes" xml:space="preserve">
          <source>Same as above but with a second flag that requires a value:</source>
          <target state="translated">위와 동일하지만 값이 필요한 두 번째 플래그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d562a361adfcc4bd04396673622d38c2c23c4a3b" translate="yes" xml:space="preserve">
          <source>Same as above but with a third flag that can be given multiple times saving the value of each instance seen and only the long flag name (&lt;code&gt;--token&lt;/code&gt;) can be used:</source>
          <target state="translated">위와 동일하지만 보이는 각 인스턴스의 값을 여러 번 저장할 수있는 세 번째 플래그가 있으며 긴 플래그 이름 ( &lt;code&gt;--token&lt;/code&gt; ) 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c902e77d44ee1a72851bdd66a8039b7289e5469e" translate="yes" xml:space="preserve">
          <source>Say $animal contains the name of an animal. Then this code would classify it:</source>
          <target state="translated">$ animal에 동물의 이름이 있다고합시다. 그런 다음이 코드는 분류합니다.</target>
        </trans-unit>
        <trans-unit id="2e406da000ac4099abeb149121071ece020d3907" translate="yes" xml:space="preserve">
          <source>Searchable history</source>
          <target state="translated">검색 가능한 기록</target>
        </trans-unit>
        <trans-unit id="b445d35ecc1c55f9e1ceba18d794fb79d964e899" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;index#editor&quot;&gt;documentation&lt;/a&gt; for more details about line editing in fish.</source>
          <target state="translated">참조 &lt;a href=&quot;index#editor&quot;&gt;문서&lt;/a&gt; 물고기 라인 편집에 대한 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="49221a7350c523a8e1009128e69d530a8c75a22a" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;dirs#cmd-dirs&quot;&gt;dirs&lt;/a&gt; to print the stack and &lt;code&gt;dirs -c&lt;/code&gt; to clear it.</source>
          <target state="translated">참조 &lt;a href=&quot;dirs#cmd-dirs&quot;&gt;DIRS을&lt;/a&gt; 스택 및 인쇄 &lt;code&gt;dirs -c&lt;/code&gt; 을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77543101f6f627a4f89275ca4aa34557b8a135ef" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;fish_vcs_prompt#cmd-fish-vcs-prompt&quot;&gt;fish_vcs_prompt&lt;/a&gt;, which will call all supported version control prompt functions, including git, Mercurial and Subversion.</source>
          <target state="translated">git, Mercurial 및 Subversion을 포함하여 지원되는 모든 버전 제어 프롬프트 기능을 호출하는 &lt;a href=&quot;fish_vcs_prompt#cmd-fish-vcs-prompt&quot;&gt;fish_vcs_prompt&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="67035298680ddb09dd248da78e915fd9c9627f01" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;dirs&lt;/code&gt; and &lt;code&gt;dirs -c&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dirs&lt;/code&gt; 및 &lt;code&gt;dirs -c&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a3b31765df862a7d9c4531c872152ad402c53f3" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;read --delimiter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;read --delimiter&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5324b1f4d638d16895e396283d6222620e56d716" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;cdh#cmd-cdh&quot;&gt;cdh&lt;/a&gt; command for changing to a recently visited directory.</source>
          <target state="translated">최근에 방문한 디렉토리로 변경 하려면 &lt;a href=&quot;cdh#cmd-cdh&quot;&gt;cdh&lt;/a&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7238893c67063d93ae05263dd71a5ccfc50d90c7" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;commands#cdh&quot;&gt;&lt;code&gt;cdh&lt;/code&gt;&lt;/a&gt; command for changing to a recently visited directory.</source>
          <target state="translated">최근에 방문한 디렉토리로 변경 하려면 &lt;a href=&quot;commands#cdh&quot;&gt; &lt;code&gt;cdh&lt;/code&gt; &lt;/a&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01cfa9314baef15cf1a7d7383228c6d181370cb2" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;commands#prevd&quot;&gt;&lt;code&gt;prevd&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;commands#pushd&quot;&gt;&lt;code&gt;pushd&lt;/code&gt;&lt;/a&gt; commands which also work with the recent &lt;code&gt;cd&lt;/code&gt; history and are provided for compatibility with other shells.</source>
          <target state="translated">최신 &lt;code&gt;cd&lt;/code&gt; 기록과 함께 작동 하며 다른 쉘과의 호환성을 위해 제공 되는 &lt;a href=&quot;commands#prevd&quot;&gt; &lt;code&gt;prevd&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;commands#pushd&quot;&gt; &lt;code&gt;pushd&lt;/code&gt; &lt;/a&gt; 명령 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a276f1ec5f60e2df52ed4c479379eca5a14e0acb" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;prevd#cmd-prevd&quot;&gt;prevd&lt;/a&gt; and &lt;a href=&quot;pushd#cmd-pushd&quot;&gt;pushd&lt;/a&gt; commands which also work with the recent &lt;code&gt;cd&lt;/code&gt; history and are provided for compatibility with other shells.</source>
          <target state="translated">최근 &lt;code&gt;cd&lt;/code&gt; 히스토리와 함께 작동 하고 다른 쉘과의 호환성을 위해 제공 되는 &lt;a href=&quot;prevd#cmd-prevd&quot;&gt;prevd&lt;/a&gt; 및 &lt;a href=&quot;pushd#cmd-pushd&quot;&gt;pushd&lt;/a&gt; 명령 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c59959e6168e702c87aad6497074fc87974da46d" translate="yes" xml:space="preserve">
          <source>See the &quot;Internals&quot; section for more on them.</source>
          <target state="translated">자세한 내용은 &quot;내부&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c6e5f5869c0d557646211d7b722a3358667dc217" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;#fish-opt&quot;&gt;&lt;code&gt;fish_opt&lt;/code&gt;&lt;/a&gt; command for a friendlier but more verbose way to create option specifications.</source>
          <target state="translated">옵션 사양을 작성하는 더 친숙하지만 더 자세한 방법 은 &lt;a href=&quot;#fish-opt&quot;&gt; &lt;code&gt;fish_opt&lt;/code&gt; &lt;/a&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="762e36367184253ec997bd0b9511dad76a9722aa" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;cmds/history#cmd-history&quot;&gt;history&lt;/a&gt; command for other manipulations.</source>
          <target state="translated">다른 조작 은 &lt;a href=&quot;cmds/history#cmd-history&quot;&gt;history&lt;/a&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c014ad7ef4dcc4632ad4cb9226ca38ced50624d9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;fish_opt#cmd-fish-opt&quot;&gt;fish_opt&lt;/a&gt; command for a friendlier but more verbose way to create option specifications.</source>
          <target state="translated">옵션 사양을 만드는 더 친숙하지만 더 자세한 방법 은 &lt;a href=&quot;fish_opt#cmd-fish-opt&quot;&gt;fish_opt&lt;/a&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f689ba7f1bf5e057a3d971021477d48085ed9ad9" translate="yes" xml:space="preserve">
          <source>See the documentation for &lt;a href=&quot;cmds/funced#cmd-funced&quot;&gt;funced&lt;/a&gt; and &lt;a href=&quot;cmds/funcsave#cmd-funcsave&quot;&gt;funcsave&lt;/a&gt; for ways to create these files automatically, and &lt;a href=&quot;index#syntax-function-autoloading&quot;&gt;$fish_function_path&lt;/a&gt; to control their location.</source>
          <target state="translated">이러한 파일을 자동으로 생성하는 방법 은 &lt;a href=&quot;cmds/funced#cmd-funced&quot;&gt;funced&lt;/a&gt; 및 &lt;a href=&quot;cmds/funcsave#cmd-funcsave&quot;&gt;funcsave에&lt;/a&gt; 대한 설명서를 참조 하고 위치를 제어하려면 &lt;a href=&quot;index#syntax-function-autoloading&quot;&gt;$ fish_function_path&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9d34ee1f18350527bff51e963b54e3ce46a24e48" translate="yes" xml:space="preserve">
          <source>See the documentation for &lt;a href=&quot;cmds/test#cmd-test&quot;&gt;test&lt;/a&gt; and &lt;a href=&quot;cmds/if#cmd-if&quot;&gt;if&lt;/a&gt; for more information.</source>
          <target state="translated">에 대한 설명서를 참조하십시오 &lt;a href=&quot;cmds/test#cmd-test&quot;&gt;테스트를&lt;/a&gt; 하고 &lt;a href=&quot;cmds/if#cmd-if&quot;&gt;있는 경우&lt;/a&gt; 더 많은 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ac7646fb3e869bb56303fbe3fca839b0d38f1d8" translate="yes" xml:space="preserve">
          <source>See the documentation for &lt;a href=&quot;commands#funced&quot;&gt;funced&lt;/a&gt; and &lt;a href=&quot;commands#funcsave&quot;&gt;funcsave&lt;/a&gt; for ways to create these files automatically.</source>
          <target state="translated">이러한 파일을 자동으로 생성하는 방법 은 &lt;a href=&quot;commands#funced&quot;&gt;funced&lt;/a&gt; 및 &lt;a href=&quot;commands#funcsave&quot;&gt;funcsave&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb216107606bc95b848f93fc29c67e8fe68c93ea" translate="yes" xml:space="preserve">
          <source>See the documentation for &lt;a href=&quot;commands#test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;commands#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">에 대한 설명서를 참조하십시오 &lt;a href=&quot;commands#test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;commands#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 더 많은 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9299a43e63898a7efcae7a83cc40f247242085fc" translate="yes" xml:space="preserve">
          <source>See the documentation for &lt;code&gt;set&lt;/code&gt; for more details on the scoping rules for variables.</source>
          <target state="translated">에 대한 설명서를 참조하십시오 &lt;code&gt;set&lt;/code&gt; 변수의 범위 지정 규칙에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="f325a391b2afa8d45fd9b05b9b133df7d497fc47" translate="yes" xml:space="preserve">
          <source>Separating Commands (Semicolon)</source>
          <target state="translated">명령 분리 (세미콜론)</target>
        </trans-unit>
        <trans-unit id="0ffd1469dee865172080d29fd56f5825f24fc441" translate="yes" xml:space="preserve">
          <source>Sequences of elements can be written with the range operator '&lt;code&gt;..&lt;/code&gt;'. A range '&lt;code&gt;a..b&lt;/code&gt;' ('a' and 'b' being integers) is expanded into a sequence of indices '&lt;code&gt;a a+1 a+2 ... b&lt;/code&gt;' or '&lt;code&gt;a a-1 a-2 ... b&lt;/code&gt;' depending on which of 'a' or 'b' is higher. Negative range limits are calculated from the end of the list. If an index is too large or small it's silently clamped to one or the size of the list as appropriate.</source>
          <target state="translated">범위 연산자 ' &lt;code&gt;..&lt;/code&gt; '를 사용하여 요소 시퀀스를 작성할 수 있습니다 . 범위 ' &lt;code&gt;a..b&lt;/code&gt; '( 'a'및 'b'는 정수임)는 일련의 인덱스 ' &lt;code&gt;a a+1 a+2 ... b&lt;/code&gt; '또는 ' &lt;code&gt;a a-1 a-2 ... b&lt;/code&gt; '는'a '또는'b '중 어느 것이 더 높은지에 따라 다릅니다. 음수 범위 제한은 목록 끝에서 계산됩니다. 인덱스가 너무 크거나 작 으면 하나 또는 목록의 크기로 적절하게 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="cafea76301da663d6e72c8dd0182bf1a08fe0c7b" translate="yes" xml:space="preserve">
          <source>Setting the background color only affects subsequently written characters. Fish provides no way to set the background color for the entire terminal window. Configuring the window background color (and other attributes such as its opacity) has to be done using whatever mechanisms the terminal provides.</source>
          <target state="translated">배경색을 설정하면 이후에 작성된 문자에만 영향을줍니다. Fish는 전체 터미널 창의 배경색을 설정하는 방법을 제공하지 않습니다. 터미널이 제공하는 메커니즘을 사용하여 창 배경색 (및 불투명도와 같은 다른 속성)을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7ac25be64a83552cee11d2c2c101281899b7d94" translate="yes" xml:space="preserve">
          <source>Setting the background color only affects subsequently written characters. Fish provides no way to set the background color for the entire terminal window. Configuring the window background color (and other attributes such as its opacity) has to be done using whatever mechanisms the terminal provides. Look for a config option.</source>
          <target state="translated">배경색을 설정하면 이후에 쓰여지는 문자에만 영향을줍니다. Fish는 전체 터미널 창의 배경색을 설정하는 방법을 제공하지 않습니다. 창 배경색 (및 불투명도와 같은 기타 속성) 구성은 터미널이 제공하는 메커니즘을 사용하여 수행해야합니다. 구성 옵션을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="0c0750f1643a764b440d30cec12896d4e2f3c4f4" translate="yes" xml:space="preserve">
          <source>Shared bindings</source>
          <target state="translated">공유 바인딩</target>
        </trans-unit>
        <trans-unit id="02a6cc27a3e125fbed4ff93ba00ddc32ff248036" translate="yes" xml:space="preserve">
          <source>Shebang Line</source>
          <target state="translated">Shebang 라인</target>
        </trans-unit>
        <trans-unit id="61e5ec8aae4e834701135d3867ab63125d131c5e" translate="yes" xml:space="preserve">
          <source>Shell variable and function names</source>
          <target state="translated">쉘 변수 및 함수 이름</target>
        </trans-unit>
        <trans-unit id="e91aede6defa8d430f67e550004d49863d3e2e5b" translate="yes" xml:space="preserve">
          <source>Shell variables</source>
          <target state="translated">쉘 변수</target>
        </trans-unit>
        <trans-unit id="0f86f7ae2195716edf4d3ac75b6ae230d7060ba1" translate="yes" xml:space="preserve">
          <source>Shell variables are named pieces of data, which can be created, deleted and their values changed and used by the user. Variables may optionally be &quot;exported&quot;, so that a copy of the variable is available to any subprocesses the shell creates. An exported variable is referred to as an &quot;environment variable&quot;.</source>
          <target state="translated">쉘 변수는 이름이 지정된 데이터 조각으로, 사용자가 작성, 삭제 및 값을 변경하고 사용할 수 있습니다. 변수는 선택적으로 &quot;내보내기&quot;될 수 있으므로 변수의 사본이 쉘이 작성하는 모든 서브 프로세스에 사용 가능합니다. 내 보낸 변수를 &quot;환경 변수&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="9ba5016166d5ba5cee4a99a1b1e6e1f5fe3f8efe" translate="yes" xml:space="preserve">
          <source>Shells like fish are used by giving them commands. Every &lt;code&gt;fish&lt;/code&gt; command follows the same basic syntax.</source>
          <target state="translated">물고기와 같은 조개는 그들에게 명령을 내림으로써 사용됩니다. 모든 &lt;code&gt;fish&lt;/code&gt; 명령은 동일한 기본 구문을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e122d1fcfbe4d2952329855d2c90efb389777230" translate="yes" xml:space="preserve">
          <source>Shells like fish are used by giving them commands. Every &lt;code&gt;fish&lt;/code&gt; command follows the same simple syntax.</source>
          <target state="translated">물고기와 같은 조개는 명령을 내림으로써 사용됩니다. 모든 &lt;code&gt;fish&lt;/code&gt; 명령은 동일한 간단한 구문을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="c89673d426f813c79fba3be3ad53403494aea9ae" translate="yes" xml:space="preserve">
          <source>Shift, Tab</source>
          <target state="translated">Shift, Tab</target>
        </trans-unit>
        <trans-unit id="f44347ef7035824e74312bda85a5c1f33acab5d3" translate="yes" xml:space="preserve">
          <source>Shift,&amp;larr;,Left</source>
          <target state="translated">Shift,&amp;larr;,Left</target>
        </trans-unit>
        <trans-unit id="389f8e25d83e1e1c83d311028f205dfb3a8af791" translate="yes" xml:space="preserve">
          <source>Shift,&amp;rarr;,Right</source>
          <target state="translated">Shift,&amp;rarr;,Right</target>
        </trans-unit>
        <trans-unit id="794fe0e411bbf424857358cfb3699f0985ef9bee" translate="yes" xml:space="preserve">
          <source>Shift,A</source>
          <target state="translated">Shift,A</target>
        </trans-unit>
        <trans-unit id="a4f7b08e9c36efe6a08eae925c49ef2f720086e4" translate="yes" xml:space="preserve">
          <source>Shift,D</source>
          <target state="translated">Shift,D</target>
        </trans-unit>
        <trans-unit id="42414c807cd9c1ab64d204f7113345e9c5f0a85a" translate="yes" xml:space="preserve">
          <source>Short options, like '&lt;code&gt;-a&lt;/code&gt;'. Short options are a single character long, are preceded by a single hyphen and may be grouped together (like '&lt;code&gt;-la&lt;/code&gt;', which is equivalent to '&lt;code&gt;-l -a&lt;/code&gt;'). Option arguments may be specified in the following parameter ('&lt;code&gt;-w 32&lt;/code&gt;') or by appending the option with the value ('&lt;code&gt;-w32&lt;/code&gt;').</source>
          <target state="translated">' &lt;code&gt;-a&lt;/code&gt; ' 와 같은 짧은 옵션 . 짧은 옵션은 단일 문자 길이이며 앞에 하이픈이오고, 그룹화 될 수 있습니다 (예 : ' &lt;code&gt;-l -a&lt;/code&gt; ' 와 같은 ' &lt;code&gt;-la&lt;/code&gt; '). 옵션 인수는 다음 매개 변수 ( ' &lt;code&gt;-w 32&lt;/code&gt; ')에 지정하거나 옵션에 값 ( ' &lt;code&gt;-w32&lt;/code&gt; ') 을 추가하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="214c488d368da8c81796e48eb7f6963ef7a93bff" translate="yes" xml:space="preserve">
          <source>Should you wish to uninstall fish, first ensure fish is not set as your shell. Run &lt;code&gt;chsh -s /bin/bash&lt;/code&gt; if you are not sure.</source>
          <target state="translated">물고기를 제거하려면 먼저 물고기가 껍질로 설정되어 있지 않은지 확인하십시오. 확실하지 않으면 &lt;code&gt;chsh -s /bin/bash&lt;/code&gt; 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="d5a22b01fc547f4aefabc8c7a496313159dfc74d" translate="yes" xml:space="preserve">
          <source>Signal names are case insensitive and the &lt;code&gt;SIG&lt;/code&gt; prefix is optional.</source>
          <target state="translated">신호 이름은 대소 문자를 구분하지 않으며 &lt;code&gt;SIG&lt;/code&gt; 접두사는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="2339b49e18e4fa7fa63c25097d1c3cb05b3abf7a" translate="yes" xml:space="preserve">
          <source>Similar to bash, fish has Emacs and Vi editing modes. The default editing mode is Emacs. You can switch to Vi mode with &lt;code&gt;fish_vi_key_bindings&lt;/code&gt; and switch back with &lt;code&gt;fish_default_key_bindings&lt;/code&gt;. You can also make your own key bindings by creating a function and setting $fish_key_bindings to its name. For example:</source>
          <target state="translated">bash와 마찬가지로 fish에는 Emacs 및 Vi 편집 모드가 있습니다. 기본 편집 모드는 Emacs입니다. 당신과 바이 모드로 전환 할 수 있습니다 &lt;code&gt;fish_vi_key_bindings&lt;/code&gt; 과 함께 다시 전환 &lt;code&gt;fish_default_key_bindings&lt;/code&gt; . 함수를 만들고 $ fish_key_bindings를 이름으로 설정하여 고유 한 키 바인딩을 만들 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="841cba81f949103d830192d933a434ce626dfca6" translate="yes" xml:space="preserve">
          <source>Since fish 3.1 you can set an environment variable for just one command using the &lt;code&gt;key=value some command&lt;/code&gt; syntax, like in other shells. The two lines below behave identically - unlike other shells, fish will output &lt;code&gt;value&lt;/code&gt; both times:</source>
          <target state="translated">fish 3.1부터는 다른 셸 에서처럼 &lt;code&gt;key=value some command&lt;/code&gt; 구문을 사용하여 하나의 명령에 대한 환경 변수를 설정할 수 있습니다 . 아래 두 줄은 동일하게 작동합니다. 다른 껍데기와 달리 물고기는 두 번 모두 &lt;code&gt;value&lt;/code&gt; 을 출력 합니다 .</target>
        </trans-unit>
        <trans-unit id="7ae81f7020b13f6dbc6ef9ce845da695c08f53b8" translate="yes" xml:space="preserve">
          <source>Since scripts for shell commands can be written in many different languages, they need to carry information about what interpreter is needed to execute them: For this they are expected to have a first line, the shebang line, which names an executable for this purpose:</source>
          <target state="translated">쉘 명령에 대한 스크립트는 다양한 언어로 작성 될 수 있기 때문에 실행에 필요한 인터프리터에 대한 정보를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="530fce1c2ad1ce0277a5df96933c6fbf422dc856" translate="yes" xml:space="preserve">
          <source>Some OPTION_SPEC examples:</source>
          <target state="translated">일부 OPTION_SPEC 예 :</target>
        </trans-unit>
        <trans-unit id="4d6baccd4c71912ba57043465594b0cf17749be7" translate="yes" xml:space="preserve">
          <source>Some bindings are shared between emacs- and vi-mode because they aren't text editing bindings or because what Vi/Vim does for a particular key doesn't make sense for a shell.</source>
          <target state="translated">일부 바인딩은 텍스트 편집 바인딩이 아니거나 특정 키에 대한 Vi / Vim이 쉘에 적합하지 않기 때문에 emacs 및 vi 모드간에 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="425593164f34a70e7fd63371baa3a373bc2ecb38" translate="yes" xml:space="preserve">
          <source>Some characters can not be written directly on the command line. For these characters, so called escape sequences are provided. These are:</source>
          <target state="translated">일부 문자는 명령 행에 직접 쓸 수 없습니다. 이러한 문자에는 소위 이스케이프 시퀀스가 ​​제공됩니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="a528e343afc3809db9c1142fa89d7ee4b8aa846e" translate="yes" xml:space="preserve">
          <source>Some colors for status symbols:</source>
          <target state="translated">상태 기호의 일부 색상 :</target>
        </trans-unit>
        <trans-unit id="6dd3509b210643ba6eefaffcdf24924a6a2790a7" translate="yes" xml:space="preserve">
          <source>Some common words</source>
          <target state="translated">일반적인 단어</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="9a67d5493118a559656027def8dc4fcd0cc3974f" translate="yes" xml:space="preserve">
          <source>Some features include repetitions:</source>
          <target state="translated">일부 기능에는 반복이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4ded8c2bc928f23aa366efb17837e70948b9a888" translate="yes" xml:space="preserve">
          <source>Some of the special features of fish are:</source>
          <target state="translated">물고기의 특별한 특징은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d39624c87b3e78e02ed8dde71f696712e0710389" translate="yes" xml:space="preserve">
          <source>Some shells (e.g., ksh, bash) feature a syntax that is a mix between command substitution and piping, called process substitution. It is used to send the output of a command into the calling command, much like command substitution, but with the difference that the output is not sent through commandline arguments but through a named pipe, with the filename of the named pipe sent as an argument to the calling program. &lt;code&gt;psub&lt;/code&gt; combined with a regular command substitution provides the same functionality.</source>
          <target state="translated">일부 쉘 (예 : ksh, bash)에는 프로세스 대체라고하는 명령 대체와 파이핑이 혼합 된 구문이 있습니다. 명령 대체와 매우 유사하게 명령 출력을 호출 명령으로 전송하는 데 사용되지만, 출력이 명령 행 인수를 통해 전송되는 것이 아니라 명명 된 파이프를 통해 전송되며, 명명 된 파이프의 파일 이름이 인수로 전송된다는 차이점이 있습니다. 호출 프로그램에. 일반 명령 대체와 결합 된 &lt;code&gt;psub&lt;/code&gt; 는 동일한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="28861f1ca2bfa4eb42bfb98ba18be09e02df8f97" translate="yes" xml:space="preserve">
          <source>Some terminals use the &lt;code&gt;--bold&lt;/code&gt; escape sequence to switch to a brighter color set rather than increasing the weight of text.</source>
          <target state="translated">일부 터미널은 &lt;code&gt;--bold&lt;/code&gt; escape 시퀀스를 사용하여 텍스트 무게를 늘리지 않고 더 밝은 색상 세트로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="81e4919181b85ff99cd6f65bd27d07c5ffe80e11" translate="yes" xml:space="preserve">
          <source>Some variables are only used in some modes, like when informative status is enabled:</source>
          <target state="translated">일부 변수는 정보 상태가 활성화 된 경우와 같이 일부 모드에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c4dd50f777b9a845d16edeb5ac29fc4998e7e176" translate="yes" xml:space="preserve">
          <source>Some variables, like &lt;code&gt;$PWD&lt;/code&gt;, only have one value. By convention, we talk about that variable's value, but we really mean its first (and only) value.</source>
          <target state="translated">&lt;code&gt;$PWD&lt;/code&gt; 와 같은 일부 변수 에는 하나의 값만 있습니다. 관례 적으로, 우리는 그 변수의 값에 대해 이야기하지만 실제로 첫 번째 (그리고 유일한) 값을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8709ff84c2c20f30aea0078b8e4ce461f5bca70c" translate="yes" xml:space="preserve">
          <source>Sometimes features such as &lt;a href=&quot;#expand&quot;&gt;parameter expansion&lt;/a&gt; and &lt;a href=&quot;#escapes&quot;&gt;character escapes&lt;/a&gt; get in the way. When that happens, the user can write a parameter within quotes, either &amp;lsquo;&amp;rsquo;&lt;code&gt;(single quote) or&lt;/code&gt;&quot;&lt;code&gt;(double quote). There is one important difference between single quoted and double quoted strings: When using double quoted string, &amp;lt;a href=&quot;#expand-variable&quot;&amp;gt;variable expansion&amp;lt;/a&amp;gt; still takes place. Other than that, no other kind of expansion (including &amp;lt;a href=&quot;#expand-brace&quot;&amp;gt;brace expansion&amp;lt;/a&amp;gt; and parameter expansion) will take place, the parameter may contain spaces, and escape sequences are ignored. The only backslash escape accepted within single quotes is&lt;/code&gt;\'&lt;code&gt;, which escapes a single quote and&lt;/code&gt;\`, which escapes the backslash symbol. The only backslash escapes accepted within double quotes are &lt;code&gt;\&quot;&lt;/code&gt;, which escapes a double quote, &lt;code&gt;\$&lt;/code&gt;, which escapes a dollar character, &lt;code&gt;\&lt;/code&gt; followed by a newline, which deletes the backslash and the newline, and lastly &lt;code&gt;\\&lt;/code&gt;, which escapes the backslash symbol. Single quotes have no special meaning within double quotes and vice versa.</source>
          <target state="translated">때로는 &lt;a href=&quot;#expand&quot;&gt;매개 변수 확장&lt;/a&gt; 및 &lt;a href=&quot;#escapes&quot;&gt;문자 이스케이프&lt;/a&gt; 와 같은 기능 이 방해를받습니다. 이 경우 사용자는 '' &lt;code&gt;(single quote) or&lt;/code&gt; &quot; &lt;code&gt;(double quote). There is one important difference between single quoted and double quoted strings: When using double quoted string, &amp;lt;a href=&quot;#expand-variable&quot;&amp;gt;variable expansion&amp;lt;/a&amp;gt; still takes place. Other than that, no other kind of expansion (including &amp;lt;a href=&quot;#expand-brace&quot;&amp;gt;brace expansion&amp;lt;/a&amp;gt; and parameter expansion) will take place, the parameter may contain spaces, and escape sequences are ignored. The only backslash escape accepted within single quotes is&lt;/code&gt; 중 하나를 따옴표로 묶을 수 있습니다 . 작은 따옴표로 묶은 문자열과 큰 따옴표로 묶인 문자열 사이에는 한 가지 중요한 차이점이 있습니다. 큰 따옴표로 묶인 문자열을 사용하는 경우 &amp;lt;a href = &quot;# expand-variable&quot;&amp;gt; 가변 확장 &amp;lt;/a&amp;gt;이 여전히 발생합니다. 그 외에는 다른 확장 (예 : &amp;lt;a href=&quot;#expand-brace&quot;&amp;gt; 중괄 확장 &amp;lt;/a&amp;gt; 및 매개 변수 확장 포함)이 없습니다. 작은 따옴표 안에 허용되는 유일한 백 슬래시 이스케이프는 \ ' &lt;code&gt;, which escapes a single quote and&lt;/code&gt; 백 슬래시 기호를 이스케이프합니다. 따옴표로 인정 유일한 백 슬래시 이스케이프는 &lt;code&gt;\&quot;&lt;/code&gt; , 이중 인용 부호를 탈출하는 &lt;code&gt;\$&lt;/code&gt; 달러 문자를 이스케이프 이는, &lt;code&gt;\&lt;/code&gt; 마지막으로 백 슬래시 및 줄 바꿈 등을 삭제하는 줄 바꿈, 다음 &lt;code&gt;\\&lt;/code&gt; 백 슬래시를 탈출, 작은 따옴표는 큰 따옴표 안에 특별한 의미가 없으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="1c2aa93843ddd26ec4e00cb7588c5d09f093b293" translate="yes" xml:space="preserve">
          <source>Sometimes features such as &lt;a href=&quot;#expand&quot;&gt;parameter expansion&lt;/a&gt; and &lt;a href=&quot;#escapes&quot;&gt;character escapes&lt;/a&gt; get in the way. When that happens, the user can write a parameter within quotes, either &lt;code&gt;'&lt;/code&gt; (single quote) or &lt;code&gt;&quot;&lt;/code&gt; (double quote). There is one important difference between single quoted and double quoted strings: When using double quoted string, &lt;a href=&quot;#expand-variable&quot;&gt;variable expansion&lt;/a&gt; still takes place. Other than that, no other kind of expansion (including &lt;a href=&quot;#expand-brace&quot;&gt;brace expansion&lt;/a&gt; and parameter expansion) will take place, the parameter may contain spaces, and escape sequences are ignored.</source>
          <target state="translated">&lt;a href=&quot;#expand&quot;&gt;매개 변수 확장&lt;/a&gt; 및 &lt;a href=&quot;#escapes&quot;&gt;문자 이스케이프&lt;/a&gt; 와 같은 기능 이 방해가되는 경우가 있습니다. 이 경우 사용자는 &lt;code&gt;'&lt;/code&gt; (작은 따옴표) 또는 &lt;code&gt;&quot;&lt;/code&gt; (큰 따옴표) 중 하나 의 따옴표 안에 매개 변수를 작성할 수 있습니다 . 작은 따옴표와 큰 따옴표 사이에는 중요한 차이점이 있습니다. 큰 따옴표를 사용하는 경우 에도 &lt;a href=&quot;#expand-variable&quot;&gt;변수 확장&lt;/a&gt; 이 발생합니다. 그 외에는 다른 종류의 확장 ( &lt;a href=&quot;#expand-brace&quot;&gt;중괄호 확장&lt;/a&gt; 및 매개 변수 확장 포함)이 발생하지 않으며 매개 변수에 공백이 포함될 수 있으며 이스케이프 시퀀스는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bbef0a968c656b4a5b1d7f9e05d2b88ddbbced0c" translate="yes" xml:space="preserve">
          <source>Sometimes it's necessary to access only some of the elements of a list, or some of the lines a command substitution outputs. Both allow this by providing a set of indices in square brackets.</source>
          <target state="translated">때로는 목록의 일부 요소 또는 명령 대체가 출력하는 일부 행에만 액세스해야하는 경우가 있습니다. 둘 다 대괄호 안에 인덱스 세트를 제공하여이를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="757ebf561cb13f732876f1ea411a1e9e3f80de54" translate="yes" xml:space="preserve">
          <source>Sometimes you need to have a variable available to an external command, often as a setting. For example many programs like &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;man&lt;/code&gt; read the &lt;code&gt;$PAGER&lt;/code&gt; variable to figure out your preferred pager (the program that lets you scroll text). Other variables used like this include &lt;code&gt;$BROWSER&lt;/code&gt;, &lt;code&gt;$LANG&lt;/code&gt; (to configure your language) and &lt;code&gt;$PATH&lt;/code&gt;. You'll note these are written in ALLCAPS, but that's just a convention.</source>
          <target state="translated">때로는 설정으로 외부 명령에 사용할 수있는 변수가 필요합니다. 예를 들어 &lt;code&gt;git&lt;/code&gt; 또는 &lt;code&gt;man&lt;/code&gt; 과 같은 많은 프로그램 은 &lt;code&gt;$PAGER&lt;/code&gt; 변수를 읽고 선호하는 페이저 (텍스트를 스크롤 할 수있는 프로그램)를 알아냅니다. 이와 같이 사용되는 다른 변수로는 &lt;code&gt;$BROWSER&lt;/code&gt; , &lt;code&gt;$LANG&lt;/code&gt; (언어 구성 용) 및 &lt;code&gt;$PATH&lt;/code&gt; 있습니다. 이것들은 ALLCAPS로 작성되었지만 그것은 단지 관례 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="eebf6318c30de678887503010959c6f407c73301" translate="yes" xml:space="preserve">
          <source>Sometimes you need to validate the option values. For example, that it is a valid integer within a specific range, or an ip address, or something entirely different. You can always do this after &lt;code&gt;argparse&lt;/code&gt; returns but you can also request that &lt;code&gt;argparse&lt;/code&gt; perform the validation by executing arbitrary fish script. To do so simply append an &lt;code&gt;!&lt;/code&gt; (exclamation-mark) then the fish script to be run. When that code is executed three vars will be defined:</source>
          <target state="translated">때때로 옵션 값의 유효성을 검사해야합니다. 예를 들어, 특정 범위 내에서 유효한 정수, IP 주소 또는 완전히 다른 것입니다. &lt;code&gt;argparse&lt;/code&gt; 가 반환 된 후에 항상이 작업을 수행 할 수 있지만 임의의 fish 스크립트를 실행하여 &lt;code&gt;argparse&lt;/code&gt; 가 유효성 검사를 수행하도록 요청할 수도 있습니다 . 그렇게하려면 간단히 &lt;code&gt;!&lt;/code&gt; (느낌표) 그런 다음 실행할 피쉬 스크립트. 해당 코드가 실행되면 세 가지 변수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6d8c9b124d521027647b4f270cb2872798f9264e" translate="yes" xml:space="preserve">
          <source>Space</source>
          <target state="translated">Space</target>
        </trans-unit>
        <trans-unit id="5773d504847f59d4f28606344c751b42fcadfb09" translate="yes" xml:space="preserve">
          <source>Special Case: The escape Character</source>
          <target state="translated">특수 사례 : 탈출 캐릭터</target>
        </trans-unit>
        <trans-unit id="28dc52fcfc9145786fed85cff73226269b82a2c9" translate="yes" xml:space="preserve">
          <source>Special input functions</source>
          <target state="translated">특수 입력 기능</target>
        </trans-unit>
        <trans-unit id="a6c32b7763c1deccd93080cf33efdb324072a965" translate="yes" xml:space="preserve">
          <source>Special variables</source>
          <target state="translated">특수 변수</target>
        </trans-unit>
        <trans-unit id="a0a234701d3553b3ee0fce9d93e7f64fadef5cac" translate="yes" xml:space="preserve">
          <source>Specifying your own completions is not difficult. To specify a completion, use the &lt;code&gt;complete&lt;/code&gt; command. &lt;code&gt;complete&lt;/code&gt; takes as a parameter the name of the command to specify a completion for. For example, to add a completion for the program &lt;code&gt;myprog&lt;/code&gt;, one would start the completion command with &lt;code&gt;complete -c myprog ...&lt;/code&gt;</source>
          <target state="translated">자신의 완성을 지정하는 것은 어렵지 않습니다. 완료를 지정하려면 &lt;code&gt;complete&lt;/code&gt; 명령을 사용하십시오 . &lt;code&gt;complete&lt;/code&gt; 는 완료 를 지정할 명령의 이름을 매개 변수로 사용합니다. 예를 들어, &lt;code&gt;myprog&lt;/code&gt; 프로그램에 완료를 추가 하려면 &lt;code&gt;complete -c myprog ...&lt;/code&gt; 로 완료 명령을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="1ac6973627e50b5b3feef24cc873cca39ec65518" translate="yes" xml:space="preserve">
          <source>Standard error, FD 2, for writing errors and warnings, defaults to writing to the screen.</source>
          <target state="translated">오류 및 경고를 쓰는 표준 오류 FD 2는 기본적으로 화면에 쓰는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8116e8803b0b4ccfe612ba1239d0a4c13eb0c484" translate="yes" xml:space="preserve">
          <source>Standard input, FD 0, for reading, defaults to reading from the keyboard.</source>
          <target state="translated">읽기 용 표준 입력 FD 0은 기본적으로 키보드를 통한 읽기입니다.</target>
        </trans-unit>
        <trans-unit id="fd08166eefe7793a02e0886b87576b866f11ba8d" translate="yes" xml:space="preserve">
          <source>Standard output, FD 1, for writing, defaults to writing to the screen.</source>
          <target state="translated">쓰기 용 표준 출력 FD 1은 기본적으로 화면에 쓰기로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b3883f88eaf74aa505b11f01894c4909220af6a1" translate="yes" xml:space="preserve">
          <source>Standards</source>
          <target state="translated">Standards</target>
        </trans-unit>
        <trans-unit id="8f0c324bc7ae0630cb203b31d62e67e8a3bc6740" translate="yes" xml:space="preserve">
          <source>Starting and Exiting</source>
          <target state="translated">시작 및 종료</target>
        </trans-unit>
        <trans-unit id="806c8aeb75c45b416dcfcd215f384af2b2abda22" translate="yes" xml:space="preserve">
          <source>Startup (Where's .bashrc?)</source>
          <target state="translated">시작 (.bashrc는 어디에 있습니까?)</target>
        </trans-unit>
        <trans-unit id="d9d8d313fdc1a560ea8caf500b990c2077839155" translate="yes" xml:space="preserve">
          <source>Startup time and memory usage is improved, etc.</source>
          <target state="translated">시작 시간 및 메모리 사용량 등이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="b3cfed68ddc06bae90fd47f85fdeed65b5766e4e" translate="yes" xml:space="preserve">
          <source>Support for italics, dim, reverse, and other modes is not guaranteed in all terminal emulators. Fish attempts to determine if the terminal supports these modes even if the terminfo database may not be up-to-date.</source>
          <target state="translated">기울임 꼴, 희미한, 반전 및 기타 모드에 대한 지원이 모든 터미널 에뮬레이터에서 보장되는 것은 아닙니다. fish는 terminfo 데이터베이스가 최신이 아닌 경우에도 터미널이 이러한 모드를 지원하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d269dff6a5e6def876fa34f03bd1eb013ca33acd" translate="yes" xml:space="preserve">
          <source>Switches differ between commands and are documented in the manual page for each command. Some switches are common to most command though, for example '&lt;code&gt;--help&lt;/code&gt;' will usually display a help text, '&lt;code&gt;-i&lt;/code&gt;' will often turn on interactive prompting before taking action, while '&lt;code&gt;-f&lt;/code&gt;' will turn it off.</source>
          <target state="translated">스위치는 명령마다 다르며 각 명령에 대한 설명서 페이지에 설명되어 있습니다. 예를 들어 ' &lt;code&gt;--help&lt;/code&gt; '는 일반적으로 도움말 텍스트를 표시하고 ' &lt;code&gt;-i&lt;/code&gt; '는 종종 대화 형 프롬프트를 표시하고 ' &lt;code&gt;-f&lt;/code&gt; '는 해제합니다.</target>
        </trans-unit>
        <trans-unit id="b5eb6066faf764d428231e3c214c4d783bbf5bcc" translate="yes" xml:space="preserve">
          <source>Switching to fish?</source>
          <target state="translated">물고기로 전환?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
