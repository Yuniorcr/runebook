<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="09af74812a9060b648ff5292103d113c603a82ef" translate="yes" xml:space="preserve">
          <source>The index-based overloads (1-4) fail to compile if the index &lt;code&gt;I&lt;/code&gt; is neither 0 nor 1.</source>
          <target state="translated">인덱스 &lt;code&gt;I&lt;/code&gt; 이 0 또는 1이 아닌 경우 인덱스 기반 오버로드 (1-4)가 컴파일 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46437bdc4c7e2e85424bc222273ad44e53f18e36" translate="yes" xml:space="preserve">
          <source>The indicated operator can be applied to type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">표시된 연산자는 유형 &lt;code&gt;T&lt;/code&gt; 에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7846514f422b5378fb77af4cf9b31d07acbbdb16" translate="yes" xml:space="preserve">
          <source>The indirection and member operators are overloaded by many iterators and smart pointer classes.</source>
          <target state="translated">간접 및 멤버 연산자는 많은 반복자와 스마트 포인터 클래스에 의해 오버로드됩니다.</target>
        </trans-unit>
        <trans-unit id="8129cebea0ce621764c93ae2762d3f9a991933ef" translate="yes" xml:space="preserve">
          <source>The indirection operator expressions have the form.</source>
          <target state="translated">간접 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f172228ef4f13bff865c966d96876715b4f88e1" translate="yes" xml:space="preserve">
          <source>The information provided by this function is usually also provided as a byproduct of directory iteration, and may be obtained by the member functions of &lt;code&gt;&lt;a href=&quot;directory_entry&quot;&gt;directory_entry&lt;/a&gt;&lt;/code&gt;. During directory iteration, calling &lt;code&gt;status&lt;/code&gt; again is unnecessary.</source>
          <target state="translated">이 기능에 의해 제공되는 정보는 일반적으로 또한 디렉토리 반복의 부산물로서 제공되고, 그리고 멤버 함수에 의해 획득 될 수있다 &lt;code&gt;&lt;a href=&quot;directory_entry&quot;&gt;directory_entry&lt;/a&gt;&lt;/code&gt; . 디렉토리 반복 중에는 &lt;code&gt;status&lt;/code&gt; 다시 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0116c386923508482ffe7b197c85ac890bdc4bf4" translate="yes" xml:space="preserve">
          <source>The information provided by this function is usually also provided as a byproduct of directory iteration. During directory iteration, calling &lt;code&gt;exists(*iterator)&lt;/code&gt; is less efficient than &lt;code&gt;exists(iterator-&amp;gt;status())&lt;/code&gt;.</source>
          <target state="translated">이 기능이 제공하는 정보는 일반적으로 디렉토리 반복의 부산물로도 제공됩니다. 디렉토리 반복 중에 exist &lt;code&gt;exists(*iterator)&lt;/code&gt; 호출 은 &lt;code&gt;exists(iterator-&amp;gt;status())&lt;/code&gt; 보다 덜 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="a8eeab648787f5a49f075a54a3ff963c76b7abfc" translate="yes" xml:space="preserve">
          <source>The inherited constructors are equivalent to user-defined constructors with an empty body and with a &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; consisting of a single nested-name-specifier, which forwards all of its arguments to the base class constructor.</source>
          <target state="translated">상속 된 생성자는 빈 본문과 하나의 nested-name-specifier로 구성된 &lt;a href=&quot;constructor&quot;&gt;멤버 이니셜 라이저 목록&lt;/a&gt; 이있는 사용자 정의 생성자와 동일하며 , 모든 인수를 기본 클래스 생성자로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="d9039e574ac657d6dcb969a83965e5c07901ebe3" translate="yes" xml:space="preserve">
          <source>The initial value may be provided in the initializer section of a &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; or a &lt;a href=&quot;new&quot;&gt;new expression&lt;/a&gt;. It also takes place during function calls: function parameters and the function return values are also initialized.</source>
          <target state="translated">초기 값은 &lt;a href=&quot;declarations&quot;&gt;선언자&lt;/a&gt; 의 초기화 섹션 또는 &lt;a href=&quot;new&quot;&gt;새로운 표현식에&lt;/a&gt; 제공 될 수 있습니다 . 함수 호출 중에도 발생합니다. 함수 매개 변수 및 함수 반환 값도 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="dca3507cd72234d2aa0fdea51eb1cebb2b9753f0" translate="yes" xml:space="preserve">
          <source>The initializers where class-or-identifier names a &lt;a href=&quot;derived_class&quot;&gt;virtual base class&lt;/a&gt; are ignored during execution of constructors of any class that is not the most derived class of the object that's being constructed.</source>
          <target state="translated">클래스 또는 식별자가 &lt;a href=&quot;derived_class&quot;&gt;가상 기본 클래스&lt;/a&gt; 로 이름 지정된 이니셜 라이저 는 생성되는 객체의 가장 파생 된 클래스가 아닌 클래스의 생성자를 실행하는 동안 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="51f3e6edc128bfcb0be013fd2d1ae1da69f60e07" translate="yes" xml:space="preserve">
          <source>The injected-class-name is the name of a class within the scope of said class.</source>
          <target state="translated">injection-class-name은 상기 클래스의 범위 내에서 클래스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="606b29738683260e78646411c4bd2990a0c81802" translate="yes" xml:space="preserve">
          <source>The injected-class-name of a class template or class template specialization can be used either as a template-name or a type-name wherever it is in scope.</source>
          <target state="translated">클래스 템플릿 또는 클래스 템플릿 전문화의 주입 된 클래스 이름은 범위 내에서 템플릿 이름 또는 유형 이름으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="588b0a23a80aa452a55821a2b55a11188b48a689" translate="yes" xml:space="preserve">
          <source>The inline specifier cannot be used with a function or variable(since C++17) declaration at block scope (inside another function).</source>
          <target state="translated">인라인 지정자는 블록 범위 (다른 함수 내부)에서 함수 또는 변수 (C ++ 17부터) 선언과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="11abde87d1d2ac1bfae6d03e1fd645c8d719bd0d" translate="yes" xml:space="preserve">
          <source>The inline specifier cannot re-declare a function or variable(since C++17) that was already defined in the translation unit as non-inline.</source>
          <target state="translated">인라인 지정자는 변환 단위에서 이미 인라인이 아닌 것으로 정의 된 함수 또는 변수 (C ++ 17부터)를 다시 선언 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5dbd088428b0bac15f8a60242c8b9596e62e2450" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; with the conversion specifier selected in Stage 1</source>
          <target state="translated">입력은 1 단계에서 선택한 변환 지정자를 사용하여 &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; 의해 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="e89c213728057cbded885c2e82d2eb3ce4460233" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; for signed integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; for unsigned integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;float&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;double&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;long double&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">입력에 의해 것처럼 구문 분석 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; 정수 서명을위한 &lt;code&gt;v&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; 부호없는 정수에 대한 &lt;code&gt;v&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;float&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;double&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; 에 대한 &lt;code&gt;long double&lt;/code&gt; &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41603f2c61d6937ed51388a6bc806662aaa244d7" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; for signed integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; for unsigned integer &lt;code&gt;v&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; for floating-point &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">입력에 의해 것처럼 구문 분석 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; 정수 서명을위한 &lt;code&gt;v&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; 부호없는 정수에 대한 &lt;code&gt;v&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; 부동 소수점에 대한 &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1eae9126bfe2845e4a7f3d75fa1de5c6799e7530" translate="yes" xml:space="preserve">
          <source>The inputs to an expression consist of its operands.</source>
          <target state="translated">표현식의 입력은 피연산자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="607e5d93133cf024a79ee0801db268525f2aa983" translate="yes" xml:space="preserve">
          <source>The insertion operation in &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; 의 삽입 작업 은 &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction으로&lt;/a&gt; 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e7c7b3ed830ddfb4f12cf5eaf80d05dfaf6783a2" translate="yes" xml:space="preserve">
          <source>The instantiation of a</source>
          <target state="translated">의 인스턴스화</target>
        </trans-unit>
        <trans-unit id="e91461402009e482fb1a78f2f939226ff4aded6b" translate="yes" xml:space="preserve">
          <source>The integer value that is stored together with the callback is typically an index obtained from &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">콜백과 함께 저장된 정수 값은 일반적으로 &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; 에서 얻은 인덱스 입니다.</target>
        </trans-unit>
        <trans-unit id="e754c5d2f0c37f77dbd459373feccfde0264f302" translate="yes" xml:space="preserve">
          <source>The integral type generated by the engine. Results are undefined if this is not an unsigned integral type.</source>
          <target state="translated">엔진에 의해 생성 된 정수 유형입니다. 부호없는 정수 유형이 아닌 경우 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40c53aad3caa79b07c6f8ca53ea06f1869a292cc" translate="yes" xml:space="preserve">
          <source>The intent of concepts is to model semantic categories (Number, Range, RegularFunction) rather than syntactic restrictions (HasPlus, Array). According to &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t20-avoid-concepts-without-meaningful-semantics&quot;&gt;ISO C++ core guideline T.20&lt;/a&gt;, &quot;The ability to specify a meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint.&quot;</source>
          <target state="translated">개념의 목적은 구문 제한 (HasPlus, Array)이 아닌 의미 범주 (Number, Range, RegularFunction)를 모델링하는 것입니다. &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t20-avoid-concepts-without-meaningful-semantics&quot;&gt;ISO C ++ 핵심 가이드 라인 T.20&lt;/a&gt; 에 따르면 , &quot;의미있는 의미론을 지정하는 기능은 구문 제약과 반대되는 진정한 개념의 특성을 정의하는 것입니다.&quot;</target>
        </trans-unit>
        <trans-unit id="619a8685fc9309dd7fa35fcbb4dc104bf7401e8a" translate="yes" xml:space="preserve">
          <source>The intent of this function is to allow &lt;a href=&quot;../../language/range-for&quot;&gt;range for loops&lt;/a&gt; to work with valarrays, not to provide container semantics.</source>
          <target state="translated">이 기능의 목적은 컨테이너 시맨틱을 제공하지 않고 &lt;a href=&quot;../../language/range-for&quot;&gt;루프 범위&lt;/a&gt; 가 valarray와 함께 작동하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8413f561941f9afa4883b6089ece4689223790be" translate="yes" xml:space="preserve">
          <source>The intent of this requirement is to preserve binary compatibility between the C++ library complex number types and the &lt;a href=&quot;http://en.cppreference.com/w/c/language/arithmetic_types.html#Complex_floating_types&quot;&gt;C language complex number types&lt;/a&gt; (and arrays thereof), which have an identical object representation requirement.</source>
          <target state="translated">이 요구 사항의 목적은 동일한 객체 표현 요구 사항을 갖는 C ++ 라이브러리 복소수 유형과 &lt;a href=&quot;http://en.cppreference.com/w/c/language/arithmetic_types.html#Complex_floating_types&quot;&gt;C 언어 복소수 유형&lt;/a&gt; (및 그 배열) 간의 이진 호환성을 유지 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8f653c0dd9ae48a2397aac170d1b0f16776c082f" translate="yes" xml:space="preserve">
          <source>The interface of C++ standard library is defined by the following collection of headers.</source>
          <target state="translated">C ++ 표준 라이브러리의 인터페이스는 다음 헤더 모음으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6b2570d1e40f42d32deec64488687b81c00f5106" translate="yes" xml:space="preserve">
          <source>The internal pathname in generic pathname format, converted to specified string type.</source>
          <target state="translated">일반 경로 이름 형식의 내부 경로 이름으로, 지정된 문자열 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="9e600bbfc64aa5e497181bbfbd63f0f68de6a8dc" translate="yes" xml:space="preserve">
          <source>The internal pathname in native pathname format, converted to specified string type.</source>
          <target state="translated">기본 경로 이름 형식의 내부 경로 이름으로, 지정된 문자열 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="004ca417b1356b06ecce1a0eded3b5b9c702a405" translate="yes" xml:space="preserve">
          <source>The inverse of the referenced bit.</source>
          <target state="translated">참조 된 비트의 역수.</target>
        </trans-unit>
        <trans-unit id="94b5c297f476b2d4707fabdba8af9c74ed678810" translate="yes" xml:space="preserve">
          <source>The invocation of &lt;code&gt;setjmp&lt;/code&gt; must appear only in one of the following contexts:</source>
          <target state="translated">&lt;code&gt;setjmp&lt;/code&gt; 의 호출은 다음 컨텍스트 중 하나에 만 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="e9cf86ded4e35142c7778644f54d0174bfb84173" translate="yes" xml:space="preserve">
          <source>The iteration order of this container is not required to be stable (so, for example, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; cannot be used to compare two &lt;code&gt;std::unordered_multimap&lt;/code&gt;s), except that every group of elements whose keys compare</source>
          <target state="translated">이 컨테이너의 반복 순서는 안정적 일 필요는 없습니다 (예를 들어, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; 은 두 &lt;code&gt;std::unordered_multimap&lt;/code&gt; 을 비교하는 데 사용할 수 없습니다 ).</target>
        </trans-unit>
        <trans-unit id="97c9b700924b706247c8bc9808f1bc7725c3a1aa" translate="yes" xml:space="preserve">
          <source>The iteration order of this container is not required to be stable (so, for example, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; cannot be used to compare two &lt;code&gt;std::unordered_multiset&lt;/code&gt;s), except that every group of elements whose keys compare</source>
          <target state="translated">이 컨테이너의 반복 순서는 안정적 일 필요는 없습니다 (예를 들어, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; 은 두 &lt;code&gt;std::unordered_multiset&lt;/code&gt; 를 비교하는 데 사용할 수 없습니다 ).</target>
        </trans-unit>
        <trans-unit id="1863ed213c7ef5f7feaa4f2890c2f01f674b7ab4" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;first&lt;/code&gt; does not need to be dereferenceable if &lt;code&gt;first==last&lt;/code&gt;: erasing an empty range is a no-op.</source>
          <target state="translated">&lt;code&gt;first==last&lt;/code&gt; : 빈 범위를 지우는 것이 no-op 인 경우 반복자는 &lt;code&gt;first&lt;/code&gt; 역 참조 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="416bf9a217d579e782b2dcb1f169937401418ec1" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;pos&lt;/code&gt; must be valid and dereferenceable. Thus the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator (which is valid, but is not dereferencable) cannot be used as a value for &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">반복자 &lt;code&gt;pos&lt;/code&gt; 는 유효하고 역 참조 가능해야합니다. 따라서 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 반복자 (유효하지만 참조 할 수 없음)는 &lt;code&gt;pos&lt;/code&gt; 의 값으로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b61e02fbf920d53ad39bacd79891eb0d1792824a" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;pos&lt;/code&gt; must be valid and dereferenceable. Thus the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator (which is valid, but is not dereferenceable) cannot be used as a value for &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">반복자 &lt;code&gt;pos&lt;/code&gt; 는 유효하고 역 참조 가능해야합니다. 따라서 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 반복자 (유효하지만 역 참조 할 수 없음)는 &lt;code&gt;pos&lt;/code&gt; 의 값으로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2eb90b5d51c71efded43df27cab17311bc850303" translate="yes" xml:space="preserve">
          <source>The iterator equal to &lt;code&gt;first + (last - n_first)&lt;/code&gt;.</source>
          <target state="translated">반복자는 &lt;code&gt;first + (last - n_first)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abfb235c9222b9db1250ee25ae21c35e487f8f38" translate="yes" xml:space="preserve">
          <source>The iterator library provides definitions for five(until C++17)six(since C++17) kinds of iterators as well as iterator traits, adaptors, and utility functions.</source>
          <target state="translated">반복자 라이브러리는 반복자 특성, 어댑터 및 유틸리티 함수뿐만 아니라 5 가지 (C ++ 17 이후) 6 가지 반복자에 대한 정의를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="196d09b17633c1d18330b9904d4f41189e178366" translate="yes" xml:space="preserve">
          <source>The iterator obtained from this function is invalidated when the member function &lt;code&gt;resize()&lt;/code&gt; is called on the array &lt;code&gt;v&lt;/code&gt; or when the lifetime of &lt;code&gt;v&lt;/code&gt; ends, whichever comes first.</source>
          <target state="translated">멤버 함수 때이 함수로부터 얻어지는 반복자 무효화 &lt;code&gt;resize()&lt;/code&gt; 배열에서 호출 &lt;code&gt;v&lt;/code&gt; 또는시의 수명 &lt;code&gt;v&lt;/code&gt; 중 먼저 종료.</target>
        </trans-unit>
        <trans-unit id="05de9016d2fdcc550169519b30085812eef58929" translate="yes" xml:space="preserve">
          <source>The iterator obtained from this function template is invalidated when the member function &lt;a href=&quot;resize&quot;&gt;&lt;code&gt;resize()&lt;/code&gt;&lt;/a&gt; is called on the array &lt;code&gt;v&lt;/code&gt; or when the lifetime of &lt;code&gt;v&lt;/code&gt; ends, whichever comes first.</source>
          <target state="translated">멤버 함수 때이 함수 템플릿으로부터 얻어진 반복자 무효화 &lt;a href=&quot;resize&quot;&gt; &lt;code&gt;resize()&lt;/code&gt; &lt;/a&gt; 배열에서 호출 &lt;code&gt;v&lt;/code&gt; 또는시의 수명 &lt;code&gt;v&lt;/code&gt; 중 먼저 종료.</target>
        </trans-unit>
        <trans-unit id="6f533c17b31181fda7a7478422455fda0c5a1103" translate="yes" xml:space="preserve">
          <source>The iterator past the end of the first partition within &lt;code&gt;[first, last)&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; if all elements satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">반복자는 &lt;code&gt;[first, last)&lt;/code&gt; 내의 첫 번째 파티션 끝을지나 거나 모든 요소가 &lt;code&gt;p&lt;/code&gt; 를 만족하는 경우 &lt;code&gt;last&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="476e11b985ea98b293af90f225eabcc6be286b5e" translate="yes" xml:space="preserve">
          <source>The key comparison function object.</source>
          <target state="translated">키 비교 함수 객체</target>
        </trans-unit>
        <trans-unit id="de179c257b2f3167c894faa5512c2c228fcea52f" translate="yes" xml:space="preserve">
          <source>The key comparison function.</source>
          <target state="translated">키 비교 기능.</target>
        </trans-unit>
        <trans-unit id="4c74d4bbf1c90d9364823e4f3ebbd85ffbb952ff" translate="yes" xml:space="preserve">
          <source>The keyword &lt;a href=&quot;../keyword/template&quot;&gt;&lt;code&gt;template&lt;/code&gt;&lt;/a&gt; may appear in qualified identifiers as necessary to disambiguate &lt;a href=&quot;dependent_name&quot;&gt;dependent template names&lt;/a&gt;.</source>
          <target state="translated">키워드 &lt;a href=&quot;../keyword/template&quot;&gt; &lt;code&gt;template&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;dependent_name&quot;&gt;종속 템플릿 이름&lt;/a&gt; 을 명확하게하기 위해 필요한 경우 규정 된 식별자로 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49c5ea1550a8c0099418f191e52d2190bdb35cb8" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;nullptr&lt;/code&gt; denotes the pointer literal. It is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;. There exist &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt; from &lt;code&gt;nullptr&lt;/code&gt; to null pointer value of any pointer type and any pointer to member type. Similar conversions exist for any null pointer constant, which includes values of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; as well as the macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">키워드 &lt;code&gt;nullptr&lt;/code&gt; 은 포인터 리터럴을 나타냅니다. 그것은이다 &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; 형의 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; . 이 존재하는 &lt;a href=&quot;implicit_cast&quot;&gt;암시 적 변환&lt;/a&gt; 에서 &lt;code&gt;nullptr&lt;/code&gt; 어떤 포인터 타입과 멤버 유형에 대한 포인터의 널 포인터 값은. 널 포인터 상수에 대해 유사한 변환이 존재하는데, 여기에는 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 유형의 값과 매크로 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc50291017180e4feb23c15b01028337ea026e19" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;requires&lt;/code&gt; is also used to begin a</source>
          <target state="translated">키워드는 &lt;code&gt;requires&lt;/code&gt; 도를 시작하는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="38ca54bb4a4020554bc23191438cf8b9378a16b3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;requires&lt;/code&gt; is used to introduce a</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; 키워드 는</target>
        </trans-unit>
        <trans-unit id="0f400e14a3942078db12d200e17dbee2a1ed3dcd" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;template&lt;/code&gt; may only be used in this way after operators &lt;code&gt;::&lt;/code&gt; (scope resolution), &lt;code&gt;-&amp;gt;&lt;/code&gt; (member access through pointer), and &lt;code&gt;.&lt;/code&gt; (member access), the following are all valid examples:</source>
          <target state="translated">키워드 &lt;code&gt;template&lt;/code&gt; 은 연산자 &lt;code&gt;::&lt;/code&gt; ( 범위 해상도), &lt;code&gt;-&amp;gt;&lt;/code&gt; (포인터를 통한 멤버 액세스) 및 &lt;code&gt;.&lt;/code&gt; (회원 액세스) 다음은 모두 유효한 예입니다.</target>
        </trans-unit>
        <trans-unit id="13bd0f41e6a40479c82db81587bd210c9975f65f" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;this&lt;/code&gt; is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;&lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; whose value is the address of the object, on which the member function is being called. It can appear in the following contexts:</source>
          <target state="translated">키워드 &lt;code&gt;this&lt;/code&gt; 는 값이 멤버 함수가 호출되는 오브젝트의 주소 인 &lt;a href=&quot;value_category&quot;&gt;prvalue &lt;/a&gt;&lt;a href=&quot;expressions&quot;&gt;표현식&lt;/a&gt; 입니다. 다음과 같은 상황에서 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fb21cb06e25fb3ea23dccf8da1e5fef70f7615d" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; can be used even outside of templates.</source>
          <target state="translated">키워드 &lt;code&gt;typename&lt;/code&gt; 은 템플릿 외부에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78b1b9af4e7e3fe2a278d800536b1dea324a61db" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; may only be used in this way before qualified names (e.g. &lt;code&gt;T::x&lt;/code&gt;), but the names need not be dependent.</source>
          <target state="translated">키워드 &lt;code&gt;typename&lt;/code&gt; 은 규정 된 이름 (예 : &lt;code&gt;T::x&lt;/code&gt; ) 이전에만 이러한 방식으로 사용될 수 있지만 이름이 종속 될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="79655a71967b64b901ff64e9dbeb497972506960" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; must only be used in template declarations and definitions and only in contexts in which dependent names can be used. This excludes explicit specialization declarations and explicit instantiation declarations.</source>
          <target state="translated">키워드 &lt;code&gt;typename&lt;/code&gt; 은 템플리트 선언 및 정의 및 종속 이름을 사용할 수있는 컨텍스트에서만 사용해야합니다. 여기에는 명시 적 특수화 선언 및 명시 적 인스턴스화 선언이 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="95a190feaf53fdb99612657d6559e66695dae193" translate="yes" xml:space="preserve">
          <source>The keyword is unused and reserved.</source>
          <target state="translated">키워드가 사용되지 않고 예약되었습니다.</target>
        </trans-unit>
        <trans-unit id="58bf644951168b25add914fb2af57f56e1426658" translate="yes" xml:space="preserve">
          <source>The keyword-like forms (&lt;code&gt;and&lt;/code&gt;,&lt;code&gt;or&lt;/code&gt;,&lt;code&gt;not&lt;/code&gt;) and the symbol-like forms (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;,&lt;code&gt;||&lt;/code&gt;,&lt;code&gt;!&lt;/code&gt;) can be used interchangeably (See &lt;a href=&quot;operator_alternative&quot;&gt;alternative representations&lt;/a&gt;)</source>
          <target state="translated">키워드와 같은 형태 ( &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; ) 및 기호와 같은 형태 ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;||&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; ) 같은 의미로 사용 할 수 있습니다 ( &lt;a href=&quot;operator_alternative&quot;&gt;다른 표현&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="8387e8b5a34e9a813a529166973aeadc61823549" translate="yes" xml:space="preserve">
          <source>The lambda expression is a prvalue expression of unique unnamed non-union non-aggregate class type, known as</source>
          <target state="translated">람다 식은 고유 한 명명되지 않은 비 조합 비 집합 클래스 유형의 prvalue 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="1dc3cef4c1069bfe1bc8a146544fa3fcdd7f2326" translate="yes" xml:space="preserve">
          <source>The largest allocation size that is required to be fulfilled using the pooling mechanism. Attempts to allocate a single block larger than this threshold will be allocated directly from the upstream &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;largest_required_pool_block&lt;/code&gt; is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose a pass-through threshold larger than specified in this field.</source>
          <target state="translated">풀링 메커니즘을 사용하여 이행해야하는 최대 할당 크기입니다. 이 임계 값보다 큰 단일 블록을 할당하려고하면 업스트림 &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; 에서 직접 할당됩니다 . 경우 &lt;code&gt;largest_required_pool_block&lt;/code&gt; 은 0이거나 한계가 사용되고있는 것을 구현 정의 된 한계보다 더 크다. 구현시이 필드에 지정된 것보다 큰 통과 임계 값을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f76fd3117478f278b8a26d22cae6980cc3dc7bc" translate="yes" xml:space="preserve">
          <source>The largest block size and maximum chunk size may be tuned by passing a &lt;code&gt;&lt;a href=&quot;pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; struct to its constructor.</source>
          <target state="translated">가장 큰 블록 크기 및 최대 청크 크기는 &lt;code&gt;&lt;a href=&quot;pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; 구조체를 생성자 에 전달하여 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a4ed139500fd5d555f2f6faa85fd84cfda82ebd" translate="yes" xml:space="preserve">
          <source>The largest possible number of char-like objects that can be referred to by a &lt;code&gt;basic_string_view&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;basic_string_view&lt;/code&gt; 로 참조 할 수있는 가장 많은 수의 문자와 유사한 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="a8c1d33c39832e1576d640ab855b96a2c40bccb6" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::nearbyint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">표현할 수있는 가장 큰 부동 소수점 값은 모든 표준 부동 소수점 형식의 정확한 정수이므로 &lt;code&gt;std::nearbyint&lt;/code&gt; 자체가 오버플로하지 않습니다. 그러나 정수 변수에 저장하면 모든 정수 유형 ( &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 포함)이 오버플로 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e0e71108205254bc43c1052dde67ff6846b625e" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::rint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">표현할 수있는 가장 큰 부동 소수점 값은 모든 표준 부동 소수점 형식의 정확한 정수이므로 &lt;code&gt;std::rint&lt;/code&gt; 절대로 오버플로되지 않습니다. 그러나 정수 변수에 저장하면 모든 정수 유형 ( &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 포함)이 오버플로 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdc448092c1ae5b510cac2bc24fecc523a9a01e6" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::round&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">표현할 수있는 가장 큰 부동 소수점 값은 모든 표준 부동 소수점 형식의 정확한 정수이므로 &lt;code&gt;std::round&lt;/code&gt; 자체가 오버플로되지 않습니다. 그러나 정수 변수에 저장하면 모든 정수 유형 ( &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 포함)이 오버플로 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="149a06b50d59b602c5dedd71bc2f5b4d4782a259" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">표현할 수있는 가장 큰 부동 소수점 값은 모든 표준 부동 소수점 형식의 정확한 정수이므로이 함수는 절대 오버플로되지 않습니다. 그러나 정수 변수에 저장하면 모든 정수 유형 ( &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 포함)이 오버플로 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccc3bae22c3039b6aa4ddd26ffed5dd3a3801a47" translate="yes" xml:space="preserve">
          <source>The last character in</source>
          <target state="translated">마지막 문자</target>
        </trans-unit>
        <trans-unit id="d97f60f8595e3388c7571dd07273229e64ab3160" translate="yes" xml:space="preserve">
          <source>The last modification time for the referred-to filesystem object.</source>
          <target state="translated">참조 된 파일 시스템 객체의 마지막 수정 시간입니다.</target>
        </trans-unit>
        <trans-unit id="003204e389b9da8284fc1fb45f6c42edd43b43df" translate="yes" xml:space="preserve">
          <source>The latin &lt;a href=&quot;https://en.wikipedia.org/wiki/Long_s&quot;&gt;letter 'ſ' (U+017F)&lt;/a&gt; is the alternative lowercase form of 'S' (U+0053).</source>
          <target state="translated">라틴 &lt;a href=&quot;https://en.wikipedia.org/wiki/Long_s&quot;&gt;문자 'ſ'(U + 017F)&lt;/a&gt; 은 대체 소문자 형태 인 'S'(U + 0053)입니다.</target>
        </trans-unit>
        <trans-unit id="7e8b919f2dc439db08daff4c3a4bb57cb3581675" translate="yes" xml:space="preserve">
          <source>The leading zero generated by the conversion specification &lt;code&gt;#o&lt;/code&gt; (resulting from the combination of &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/manip/hex&quot;&gt;std::oct&lt;/a&gt;&lt;/code&gt; for example) is not counted as a padding character.</source>
          <target state="translated">변환 사양 &lt;code&gt;#o&lt;/code&gt; ( 예 &lt;code&gt;&lt;a href=&quot;../../io/manip/hex&quot;&gt;std::oct&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; 와 std :: oct 의 조합으로 생성)에서 생성 된 선행 0 은 패딩 문자로 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bae67611e59a74badd8c128046df5c4dafdb9b1d" translate="yes" xml:space="preserve">
          <source>The length of character sequence pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 가리키는 문자 시퀀스의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="198958162200c69daf435147f9c229df71f282ff" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">바이트 문자열에서 &lt;code&gt;src&lt;/code&gt; 가 가리키는 문자 만 포함하는 최대 초기 세그먼트의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="63de454d6ebc822ff35b5de2988085c7a2c0e23c" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from wide string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 넓은 문자열의 문자 만 포함하는 최대 초기 세그먼트의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="83dc1b81260e13a56926b8fcc5b2fc9652de1176" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 바이트 문자열에서 찾을 수없는 문자 만 포함하는 최대 초기 세그먼트의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="5f772a2bec6f10a883f7267bd67367b712ef3954" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the character string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 문자열에서 찾을 수없는 문자 만 포함하는 최대 초기 세그먼트의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="8fe0dd8d74988395bb6129f5a7e4490356eb2a0b" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated character string.</source>
          <target state="translated">널 종료 문자열의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="c0686acb8c60390ca16c8404e742b7a9caf518b0" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">널 종료 문자열 &lt;code&gt;str&lt;/code&gt; 의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="70aa39cc3ba65fdf92c15438e02fd88c74004295" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated wide string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">널로 끝나는 넓은 문자열 &lt;code&gt;str&lt;/code&gt; 의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="569fe0bc480cb2d8fd1b576d50ac246394b981a8" translate="yes" xml:space="preserve">
          <source>The length of the specified match or sub-match.</source>
          <target state="translated">지정된 일치 또는 하위 일치의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="593d216bcb63cbce0afb160433d1ab015cf4835d" translate="yes" xml:space="preserve">
          <source>The length of the transformed string, not including the terminating null-character.</source>
          <target state="translated">종료 널 문자를 포함하지 않는 변환 된 문자열의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="e3b3ec34feef4d29ba71c02ffc289279c3d65e7e" translate="yes" xml:space="preserve">
          <source>The length of the transformed wide string, not including the terminating null-character.</source>
          <target state="translated">종료 널 문자를 포함하지 않고 변환 된 넓은 문자열의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="ed8baa6719cd710e95a7b3c07ae38fff0961e9d8" translate="yes" xml:space="preserve">
          <source>The level of support for the open modes other than &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; varies among implementations. C++11 explicitly specifies the support for &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; and in this constructor, but &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::app&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::trunc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::binary&lt;/a&gt;&lt;/code&gt; have different effects on different implementations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; 이외의 열린 모드에 대한 지원 수준은 구현마다 다릅니다. C ++ 11 은 &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 및이 생성자 에서 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt;&lt;/code&gt; 에 대한 지원을 명시 적으로 지정 하지만 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::app&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::trunc&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::binary&lt;/a&gt;&lt;/code&gt; 구현마다 다른 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="557e0b119e086c3a7c5bcdd2f05ba46d098531ff" translate="yes" xml:space="preserve">
          <source>The library provides overloads for all signed and unsigned integer types and &lt;code&gt;char&lt;/code&gt; as the referenced type of the parameter &lt;code&gt;value&lt;/code&gt;. 2-4) Floating-point parsers: Expects the pattern identical to the one used by &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; in the default (&quot;C&quot;) locale, except that</source>
          <target state="translated">라이브러리는 모든 부호있는 정수 및 부호없는 정수 유형과 &lt;code&gt;char&lt;/code&gt; 를 매개 변수 &lt;code&gt;value&lt;/code&gt; 의 참조 된 유형으로 과부하를 제공 합니다 . 2-4) 부동 소수점 파서 : 기본 ( &quot;C&quot;) 로케일에서 &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; 에 사용 된 것과 동일한 패턴을 예상합니다.</target>
        </trans-unit>
        <trans-unit id="0c00bda8553a4155113db78626e8f2751d276761" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../new/operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt; 의 라이브러리 버전</target>
        </trans-unit>
        <trans-unit id="8ed95002f088794bbcb4dda6067ef23523590d14" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;a href=&quot;operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;strong&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; 및 &lt;strong&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/strong&gt; 의 라이브러리 버전&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be0df0b3b3695421bdf2d17b88a03ae80713339f" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;strong&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/strong&gt; and &lt;a href=&quot;operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/strong&gt; 및 &lt;a href=&quot;operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt; 의 라이브러리 버전</target>
        </trans-unit>
        <trans-unit id="9a277b5aee4eef17b2deb4d6d21114b2a958a7d0" translate="yes" xml:space="preserve">
          <source>The lifetime of a &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; begins when its initialization is complete and ends as if it were a scalar object.</source>
          <target state="translated">&lt;a href=&quot;reference&quot;&gt;참조&lt;/a&gt; 의 수명은 초기화가 완료 될 때 시작되어 마치 스칼라 객체 인 것처럼 끝납니다.</target>
        </trans-unit>
        <trans-unit id="89060782836e6f22829eef94ab23da8fa518fbc4" translate="yes" xml:space="preserve">
          <source>The lifetime of a temporary object created when evaluating the default arguments of a default constructor used to initialize an element of an array ends before the next element of the array begins initialization.</source>
          <target state="translated">배열의 요소를 초기화하는 데 사용되는 기본 생성자의 기본 인수를 평가할 때 생성 된 임시 객체의 수명은 배열의 다음 요소가 초기화를 시작하기 전에 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d83f5d7c17e682f051804ccec8769174402ff049" translate="yes" xml:space="preserve">
          <source>The lifetime of a temporary object may be extended by binding to a const lvalue reference or to an rvalue reference(since C++11), see &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;reference initialization&lt;/a&gt; for details.</source>
          <target state="translated">임시 객체의 수명은 const lvalue 참조 또는 rvalue 참조 (C ++ 11부터)에 바인딩하여 확장 할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;참조 초기화&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="076f84edd8eb9b71ed85703e28397b69b08f0333" translate="yes" xml:space="preserve">
          <source>The lifetime of an object must exceed the lifetime of all &lt;code&gt;atomic_ref&lt;/code&gt;s that references the object. While any &lt;code&gt;atomic_ref&lt;/code&gt; instances referencing an object exists, the object must be exclusively accessed through these &lt;code&gt;atomic_ref&lt;/code&gt; instances. No subobject of an object referenced by an &lt;code&gt;atomic_ref&lt;/code&gt; object may be concurrently referenced by any other &lt;code&gt;atomic_ref&lt;/code&gt; object.</source>
          <target state="translated">객체의 수명은 객체 를 참조하는 모든 &lt;code&gt;atomic_ref&lt;/code&gt; 의 수명을 초과해야 합니다. 객체를 참조하는 &lt;code&gt;atomic_ref&lt;/code&gt; 인스턴스가 존재 하지만 이러한 &lt;code&gt;atomic_ref&lt;/code&gt; 인스턴스를 통해 객체에 독점적으로 액세스해야합니다 . &lt;code&gt;atomic_ref&lt;/code&gt; 객체가 참조하는 객체의 하위 객체는 다른 &lt;code&gt;atomic_ref&lt;/code&gt; 객체 가 동시에 참조 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a71cb474b6739261f5b46ecfbc97690fb132e551" translate="yes" xml:space="preserve">
          <source>The lifetime of the array pointed to by the returned pointer is not specified, but in practice it persist as long as the RTTI data structure for the given type exists, which has application lifetime unless loaded from a dynamic library (that can be unloaded).</source>
          <target state="translated">리턴 된 포인터가 가리키는 배열의 수명은 지정되지 않았지만 실제로는 주어진 유형에 대한 RTTI 데이터 구조가 존재하는 한 동적 라이브러리에서로드되지 않은 (언로드 될 수없는) 애플리케이션 수명을 갖는 한 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="f43e95e8be78827b0fca16403fd5210ff788dde7" translate="yes" xml:space="preserve">
          <source>The lifetime of the coroutine state is strictly nested within the lifetime of the caller, and</source>
          <target state="translated">코 루틴 상태의 수명은 호출자의 수명 내에 엄격하게 중첩되며</target>
        </trans-unit>
        <trans-unit id="5a0b7c168044f4f8abc53a10a8fba540177660d1" translate="yes" xml:space="preserve">
          <source>The list of base classes is provided in the base-clause of the &lt;a href=&quot;class&quot;&gt;class declaration syntax&lt;/a&gt;. The base-clause consists of the character &lt;code&gt;:&lt;/code&gt; followed by a comma-separated list of one or more base-specifiers.</source>
          <target state="translated">기본 클래스 목록은 &lt;a href=&quot;class&quot;&gt;클래스 선언 구문&lt;/a&gt; 의 기본 절에 제공됩니다 . 기본 절은 문자 &lt;code&gt;:&lt;/code&gt; 쉼표로 구분 된 하나 이상의 기본 지정자 목록으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e8509d637336c6e1606720db4e003e047c2a510a" translate="yes" xml:space="preserve">
          <source>The list of exceptions in a &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt; may also be a pack expansion.</source>
          <target state="translated">&lt;a href=&quot;except_spec&quot;&gt;동적 예외 사양&lt;/a&gt; 의 예외 목록은 팩 확장 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d2a38cb5249a278425f59d24c4f0053fd48d52a" translate="yes" xml:space="preserve">
          <source>The list of parameters, as in &lt;a href=&quot;function&quot;&gt;named functions&lt;/a&gt;, except that &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; are not allowed(until C++14). If &lt;code&gt;auto&lt;/code&gt; is used as a type of a parameter, the lambda is a</source>
          <target state="translated">&lt;a href=&quot;default_arguments&quot;&gt;기본 인수&lt;/a&gt; 가 허용되지 않는 것을 제외하고 &lt;a href=&quot;function&quot;&gt;명명 된 함수&lt;/a&gt; 에서와 같이 매개 변수 목록 (C ++ 14까지). &lt;code&gt;auto&lt;/code&gt; 가 매개 변수의 유형으로 사용되는 경우 람다는</target>
        </trans-unit>
        <trans-unit id="56ba40ec75d4e586507c6a313f3b68e7ecfe238c" translate="yes" xml:space="preserve">
          <source>The locale before the call to this function. Effectively returns the result of expression &lt;code&gt;traits_i.imbue(loc)&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출하기 전의 로캘입니다. 표현식 &lt;code&gt;traits_i.imbue(loc)&lt;/code&gt; 의 결과를 효과적으로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5a529ceb5bbb923af9b086a8c649b5e092235f98" translate="yes" xml:space="preserve">
          <source>The locale facility includes internationalization support for character classification and string collation, numeric, monetary, and date/time formatting and parsing, and message retrieval. Locale settings control the behavior of stream I/O, regular expression library, and other components of the C++ standard library.</source>
          <target state="translated">로케일 기능에는 문자 분류 및 문자열 조합, 숫자, 통화, 날짜 / 시간 형식화 및 구문 분석, 메시지 검색에 대한 국제화 지원이 포함됩니다. 로캘 설정은 스트림 I / O, 정규식 라이브러리 및 C ++ 표준 라이브러리의 기타 구성 요소의 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="6a18c5b3999c487308a7e91b96715e80aeb807b2" translate="yes" xml:space="preserve">
          <source>The locale object, associated with the stream before the operation.</source>
          <target state="translated">작업 전의 스트림과 관련된 로캘 개체입니다.</target>
        </trans-unit>
        <trans-unit id="634778b18ec9739eca32858af18b0dca1f0f0da1" translate="yes" xml:space="preserve">
          <source>The locale used for localized behavior in the regular expression. Must be &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">정규식에서 지역화 된 동작에 사용되는 로캘입니다. &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 이어야합니다</target>
        </trans-unit>
        <trans-unit id="8def683f0d8be3b6186d5dfddb9cf73b5969d06c" translate="yes" xml:space="preserve">
          <source>The logic operator expressions have the form.</source>
          <target state="translated">논리 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3300cacfe4a9fc0c17331372ee202459b693b68" translate="yes" xml:space="preserve">
          <source>The logical complement of the result of calling &lt;code&gt;pred(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pred(x)&lt;/code&gt; 호출 결과의 논리적 보완 .</target>
        </trans-unit>
        <trans-unit id="cba68059335b1355e50f5ebe51cc201e645ee88a" translate="yes" xml:space="preserve">
          <source>The logical complement of the result of calling &lt;code&gt;pred(x, y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pred(x, y)&lt;/code&gt; 호출 결과의 논리적 보완 .</target>
        </trans-unit>
        <trans-unit id="8fdd4b0ecee0c4aa58c8a23319359361fe1a2339" translate="yes" xml:space="preserve">
          <source>The lognormal_distribution random number distribution produces random numbers x &amp;gt; 0 according to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Log-normal_distribution&quot;&gt;log-normal distribution&lt;/a&gt;:  f(x; m,s) =</source>
          <target state="translated">lognormal_distribution 난수 분포는에 따른 난수 x&amp;gt; 0을 생성 &lt;a href=&quot;https://en.wikipedia.org/wiki/Log-normal_distribution&quot;&gt;로그 정규 분포&lt;/a&gt; : F (X, m, S) =을</target>
        </trans-unit>
        <trans-unit id="c212e644a85dc2243b9b6984f045c993a30403ee" translate="yes" xml:space="preserve">
          <source>The lookup for member &lt;code&gt;get&lt;/code&gt; ignores accessibility as usual and also ignores the exact type of the non-type template parameter. A private &lt;code&gt;template&amp;lt;char*&amp;gt; void get();&lt;/code&gt; member will cause the member interpretation to be used, even though it is ill-formed.</source>
          <target state="translated">회원에 대한 조회 &lt;code&gt;get&lt;/code&gt; 평소와 같이 접근성을 무시하고 또한 비 형 템플릿 매개 변수의 정확한 유형을 무시합니다. 개인 &lt;code&gt;template&amp;lt;char*&amp;gt; void get();&lt;/code&gt; 멤버는 형식이 잘못된 경우에도 멤버 해석을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="25f8094c991911b431b2e09c25ab9f0d486ffb8e" translate="yes" xml:space="preserve">
          <source>The lookup for the identifier &lt;code&gt;swap&lt;/code&gt; in the exception specification finds this function template in addition to anything found by the usual lookup rules, making the exception specification equivalent to C++17 &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예외 사양에서 식별자 &lt;code&gt;swap&lt;/code&gt; 을 조회하면 일반적인 조회 규칙에서 &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; 함수 템플릿이 발견되어 예외 사양이 C ++ 17 std :: is_nothrow_swappable 과 동일하게됩니다 .</target>
        </trans-unit>
        <trans-unit id="d22abe7f13a33e5aaa7ba9fe7d2fe4cac70e1316" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; may be used to determine the offset of any member from the beginning of a standard-layout class.</source>
          <target state="translated">매크로 &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; ㄱ 표준 레이아웃 클래스의 선두로부터 어느 부재의 오프셋을 결정하는데 이용 될 수있다.</target>
        </trans-unit>
        <trans-unit id="c041240d72efe54a8080b43aef6a5e9d20fb0e98" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;&lt;a href=&quot;offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; can only be used with standard-layout classes.</source>
          <target state="translated">매크로 &lt;code&gt;&lt;a href=&quot;offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; 은 표준 레이아웃 클래스에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a80e1699fb25e0be7eaf64d7cde6fed39109e343" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NAN&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to a quiet not-a-number (QNaN) value. If the implementation does not support QNaNs, this macro constant is not defined.</source>
          <target state="translated">매크로 &lt;code&gt;NAN&lt;/code&gt; 은 &lt;code&gt;float&lt;/code&gt; 형식의 상수 표현으로 확장되어 조용한 비 숫자 (QNaN) 값으로 평가됩니다. 구현이 QNaN을 지원하지 않는 경우이 매크로 상수는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="511bc44ac64af1c05b670d54015e303e4e44b53b" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NULL&lt;/code&gt; is an implementation-defined null pointer constant, which may be.</source>
          <target state="translated">매크로 &lt;code&gt;NULL&lt;/code&gt; 은 구현-정의 된 널 포인터 상수 일 수있다.</target>
        </trans-unit>
        <trans-unit id="e7a478300d3bf8ff1fa598a5f4a3701de66a2d50" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;offsetof&lt;/code&gt; expands to an integral constant expression of type &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.</source>
          <target state="translated">매크로 &lt;code&gt;offsetof&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 유형의 정수 상수 표현식으로 확장되며 , 값은 지정된 유형의 오브젝트 시작에서 지정된 멤버 (있는 경우)를 포함하여 지정된 멤버까지의 오프셋 (바이트 단위)입니다.</target>
        </trans-unit>
        <trans-unit id="a5a472a05b4e53b9216f7fc0c3e059710e59c4a4" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;, which expands to the bitwise OR of all other &lt;code&gt;FE_*&lt;/code&gt;, is always defined and is zero if floating-point exceptions are not supported by the implementation.</source>
          <target state="translated">다른 모든 &lt;code&gt;FE_*&lt;/code&gt; 의 비트 단위 OR로 확장되는 매크로 상수 &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; 는 항상 정의되며 구현에서 부동 소수점 예외가 지원되지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="44aac1c9879022e9fba891603df04ea9ca8e044a" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_DFL_ENV&lt;/code&gt; expands to an expression of type &lt;code&gt;const std::fenv_t*&lt;/code&gt;, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.</source>
          <target state="translated">매크로 상수 &lt;code&gt;FE_DFL_ENV&lt;/code&gt; 는 &lt;code&gt;const std::fenv_t*&lt;/code&gt; 유형의 표현식으로 확장되어 기본 부동 소수점 환경의 전체 사본, 즉 프로그램 시작시로드 된 환경을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="4e6484c8cfd3a1b8d998f588b04075f3f3fb6a9f" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;math_errhandling&lt;/code&gt; expands to an expression of type &lt;code&gt;int&lt;/code&gt; that is either equal to &lt;code&gt;MATH_ERRNO&lt;/code&gt;, or equal to &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt;, or equal to their bitwise OR (&lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt;).</source>
          <target state="translated">매크로 상수 &lt;code&gt;math_errhandling&lt;/code&gt; 은 &lt;code&gt;MATH_ERRNO&lt;/code&gt; 와 같거나 &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt; 와 같거나 비트 OR ( &lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt; ) 인 &lt;code&gt;int&lt;/code&gt; 유형의 표현식으로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d50b82bba3614372048e0562a743464334498a2" translate="yes" xml:space="preserve">
          <source>The manipulators that are invoked with arguments (e.g. &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/setw&quot;&gt;std::setw&lt;/a&gt;(10);&lt;/code&gt;) are implemented as functions returning objects of unspecified type. These manipulators define their own &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; which perform the requested manipulation.</source>
          <target state="translated">인수로 호출 된 조작기 (예 : &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/setw&quot;&gt;std::setw&lt;/a&gt;(10);&lt;/code&gt; )는 지정되지 않은 유형의 객체를 반환하는 함수로 구현됩니다. 이러한 조작 자는 요청 된 조작을 수행하는 고유 한 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 또는 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="016c7618765bc086feb76ffa7317750d2349efbd" translate="yes" xml:space="preserve">
          <source>The manipulators that are invoked without arguments (e.g. &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; &lt;a href=&quot;manip/hex&quot;&gt;std::hex&lt;/a&gt;;&lt;/code&gt;) are implemented as functions that take a reference to a stream as their only argument. The special overloads of &lt;a href=&quot;basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; accept pointers to these functions. These functions (or instantiations of function templates) are the only &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std#Addressable_functions&quot;&gt;addressable functions&lt;/a&gt; in the standard library.(since C++20).</source>
          <target state="translated">인수없이 호출 된 조작기 (예 : &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; &lt;a href=&quot;manip/hex&quot;&gt;std::hex&lt;/a&gt;;&lt;/code&gt; )는 스트림에 대한 참조를 유일한 인수로 사용하는 함수로 구현됩니다. &lt;a href=&quot;basic_ostream/operator_ltlt&quot;&gt; &lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 특수 과부하는 이러한 함수에 대한 포인터를 허용합니다. 이러한 함수 (또는 함수 템플릿의 인스턴스화)는 표준 라이브러리에서 유일하게 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std#Addressable_functions&quot;&gt;주소 지정 가능한 함수&lt;/a&gt; 입니다 (C ++ 20부터).</target>
        </trans-unit>
        <trans-unit id="0acdda7356c347f1e3a711be9e894cc6cb8fd66c" translate="yes" xml:space="preserve">
          <source>The manner in which &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; is made space efficient (as well as whether it is optimized at all) is implementation defined. One potential optimization involves coalescing vector elements such that each element occupies a single bit instead of &lt;code&gt;sizeof(bool)&lt;/code&gt; bytes.</source>
          <target state="translated">어느 방식 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 만든 공간 효율적 (뿐만 여부로 전혀 최적화)된다 구현 정의된다. 하나의 잠재적 인 최적화는 각 요소가 &lt;code&gt;sizeof(bool)&lt;/code&gt; 바이트 대신 단일 비트를 차지하도록 벡터 요소를 병합하는 것과 관련 됩니다.</target>
        </trans-unit>
        <trans-unit id="08f5f3a85d25f2d17a7f4389b37fef34e9befb11" translate="yes" xml:space="preserve">
          <source>The manner in which the arguments given at the OS command line are converted into the multibyte character arrays referenced by &lt;code&gt;argv&lt;/code&gt; may involve implementation-defined processing:</source>
          <target state="translated">OS 명령 행에 제공된 인수가 &lt;code&gt;argv&lt;/code&gt; 가 참조하는 멀티 바이트 문자 배열로 변환되는 방식에는 구현 정의 처리가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58a4e89b5d75599c18d4cf2463da2bc790d5e376" translate="yes" xml:space="preserve">
          <source>The mapped value of &lt;code&gt;ch&lt;/code&gt; using the mapping identified by &lt;code&gt;desc&lt;/code&gt; in LC_CTYPE facet of the current C locale.</source>
          <target state="translated">현재 C 로케일의 LC_CTYPE 패싯에서 &lt;code&gt;desc&lt;/code&gt; 로 식별 된 맵핑을 사용한 &lt;code&gt;ch&lt;/code&gt; 의 맵핑 된 값입니다 .</target>
        </trans-unit>
        <trans-unit id="8da49c2641d38472ced25e1d078a923e49026a41" translate="yes" xml:space="preserve">
          <source>The materialization of a temporary object is generally delayed as long as possible in order to avoid creating unnecessary temporary object: see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">불필요한 임시 객체 생성을 피하기 위해 임시 객체의 구체화는 일반적으로 가능한 한 지연됩니다 . &lt;a href=&quot;copy_elision&quot;&gt;복사 제거를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="030e1db264f4cf63958d4ac7eff5a182391b9628" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of arc sine is asin z = -</source>
          <target state="translated">아크 사인의 주요 값의 수학적 정의는 다음과 같습니다. asin z =-</target>
        </trans-unit>
        <trans-unit id="97d3912b761a5766d76f8e019b7647d3c28a58a9" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic cosine is acosh z = ln(z + &amp;radic;z+1&amp;radic;z-1)  For any z, acosh(z) =</source>
          <target state="translated">역 쌍곡 코사인의 주요 값의 수학적 정의는 acosh z = ln (z + &amp;radic;z + 1&amp;radic;z-1)입니다. z에 대해 acosh (z) =</target>
        </trans-unit>
        <trans-unit id="2ee0c302057514ba3aa0f5c20f8146065a6d4cf3" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic sine is asinh z = ln(z + &amp;radic;1+z2</source>
          <target state="translated">역 쌍곡 사인의 주요 값의 수학적 정의는 asinh z = ln (z + &amp;radic;1 + z2</target>
        </trans-unit>
        <trans-unit id="e0ab357d29d58615b6db4b151ccaf98654e0e8b9" translate="yes" xml:space="preserve">
          <source>The mathematical functions in the standard library components do not throw this exception (mathematical functions report range errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 라이브러리 구성 요소의 수학 함수는이 예외를 발생시키지 않습니다 (수학 함수는 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 에 지정된 범위 오류를보고합니다 ).</target>
        </trans-unit>
        <trans-unit id="58113db72a97ac5e55ee3d47627cc11fbb811664" translate="yes" xml:space="preserve">
          <source>The mathematical functions of the standard library components do not throw this exception (mathematical functions report overflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::overflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">표준 라이브러리 구성 요소의 수학 함수는이 예외를 발생시키지 않습니다 (수학 함수는 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 에 지정된 오버 플로우 오류를보고합니다 ). 그러나 타사 라이브러리는이를 사용합니다. 예를 들어, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math가&lt;/a&gt; 발생 &lt;code&gt;std::overflow_error&lt;/code&gt; 경우 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; 활성화 (기본 설정).</target>
        </trans-unit>
        <trans-unit id="b1ce23e380db1867330cee83f35a43a3c26b63df" translate="yes" xml:space="preserve">
          <source>The maximum allocation size for OuterAlloc.</source>
          <target state="translated">OuterAlloc의 최대 할당 크기입니다.</target>
        </trans-unit>
        <trans-unit id="e6a66616954e988ad69d8232b96f5ad75ebaeb3d" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;code&gt;ExternT&lt;/code&gt; characters that could be consumed if converted by &lt;code&gt;&lt;a href=&quot;in&quot;&gt;in()&lt;/a&gt;&lt;/code&gt; to produce one &lt;code&gt;InternT&lt;/code&gt; character.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;in&quot;&gt;in()&lt;/a&gt;&lt;/code&gt; 으로 변환 하여 하나의 &lt;code&gt;InternT&lt;/code&gt; 문자 를 생성 할 때 소비 될 수있는 최대 &lt;code&gt;ExternT&lt;/code&gt; 문자 수입니다 .</target>
        </trans-unit>
        <trans-unit id="c5d2605f57cf7a516878f1456bacc8bf68ff240d" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks that will be allocated at once from the upstream &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; to replenish the pool. If the value of &lt;code&gt;max_blocks_per_chunk&lt;/code&gt; is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose to use a smaller value than is specified in this field and may use different values for different pools.</source>
          <target state="translated">풀을 보충하기 위해 업스트림 &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; 에서 한 번에 할당 할 최대 블록 수입니다 . &lt;code&gt;max_blocks_per_chunk&lt;/code&gt; 의 값 이 0이거나 구현 정의 한계보다 큰 경우 해당 한계가 대신 사용됩니다. 구현시이 필드에 지정된 것보다 작은 값을 사용하도록 선택할 수 있으며 풀마다 다른 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef98d6b10d2a64071a19841e541af22baf6b008a" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">최대 소유권 수준은 지정되어 있지 않습니다. 이 숫자를 초과하면 &lt;code&gt;try_lock&lt;/code&gt; 을 호출하면 &lt;code&gt;false&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="bf578a55e820eb222bfd9c3060644e38bddddff9" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock_for&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">최대 소유권 수준은 지정되어 있지 않습니다. 이 숫자를 초과하면 &lt;code&gt;try_lock_for&lt;/code&gt; 를 호출하면 &lt;code&gt;false&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="7496f6de330e88cd441a674882cf192e5823a0c2" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock_until&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">최대 소유권 수준은 지정되어 있지 않습니다. 이 숫자를 초과하면 &lt;code&gt;try_lock_until&lt;/code&gt; 을 호출하면 &lt;code&gt;false&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="516d0ea27a06242455894ddf3d9021aca322b598" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. An exception of type &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; will be thrown if this number is exceeded.</source>
          <target state="translated">최대 소유권 수준은 지정되어 있지 않습니다. 이 수를 초과하면 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 유형의 예외 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3f7c181bde374eeb6452476ff6b3a7543371ba08" translate="yes" xml:space="preserve">
          <source>The maximum number of times that a &lt;code&gt;recursive_mutex&lt;/code&gt; may be locked is unspecified, but after that number is reached, calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; will throw &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; and calls to &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;recursive_mutex&lt;/code&gt; 가 잠길 수있는 최대 횟수 는 지정되지 않지만,이 수에 도달하면 &lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 호출 은 &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 를 발생 &lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; 호출 은 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="a24b749dcce9aa560cb6a3f3aa6c86777a9e5381" translate="yes" xml:space="preserve">
          <source>The maximum of the elements.</source>
          <target state="translated">요소의 최대 값</target>
        </trans-unit>
        <trans-unit id="2d061d5c7925797cceba9d91fa06eb294531985d" translate="yes" xml:space="preserve">
          <source>The maximum potentially generated value.</source>
          <target state="translated">잠재적으로 생성되는 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="69a097b71a9a8b372efe8c272aa3e609c3c54fe8" translate="yes" xml:space="preserve">
          <source>The maximum supported allocation size.</source>
          <target state="translated">지원되는 최대 할당 크기입니다.</target>
        </trans-unit>
        <trans-unit id="8c16c9cf3f818c29edfdff221593b78944e7d444" translate="yes" xml:space="preserve">
          <source>The maximum value potentially generated by the distribution.</source>
          <target state="translated">분포에서 잠재적으로 생성 된 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="f173db7218831b033970ba26eec47af5157e549e" translate="yes" xml:space="preserve">
          <source>The meaning and the type of the result of this function is implementation-defined. On a POSIX system, this may be a value of type &lt;code&gt;pthread_cond_t*&lt;/code&gt;. On a Windows system, this may be a &lt;code&gt;PCONDITION_VARIABLE&lt;/code&gt;.</source>
          <target state="translated">이 함수의 결과의 의미와 유형은 구현에 따라 정의됩니다. POSIX 시스템에서 이는 &lt;code&gt;pthread_cond_t*&lt;/code&gt; 유형의 값일 수 있습니다 . Windows 시스템에서는 &lt;code&gt;PCONDITION_VARIABLE&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8b50f9c9a68f338aee12b4deb4d472419d36c02" translate="yes" xml:space="preserve">
          <source>The meaning of the format specifiers are:</source>
          <target state="translated">형식 지정자의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c2b2f950c575d77dea5f7dca516f87942977025" translate="yes" xml:space="preserve">
          <source>The mechanism for selecting the build level is implementation-defined. Combining translation units that were translated at different build levels is conditionally-supported.</source>
          <target state="translated">빌드 레벨을 선택하는 메커니즘은 구현에 따라 다릅니다. 다른 빌드 레벨에서 번역 된 번역 단위를 결합하면 조건부 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="69ef650d47f1d92c2572bf80d049412bb1aad754" translate="yes" xml:space="preserve">
          <source>The member &lt;code&gt;operator()&lt;/code&gt; effectively returns the same value as &lt;code&gt;&lt;a href=&quot;hash_code&quot;&gt;hash_code()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">멤버 &lt;code&gt;operator()&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;hash_code&quot;&gt;hash_code()&lt;/a&gt;&lt;/code&gt; 와 동일한 값을 효과적으로 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="68d7297c4dbfb9ca93d5a11a625ec7d05314ebfc" translate="yes" xml:space="preserve">
          <source>The member access operator expressions have the form.</source>
          <target state="translated">멤버 액세스 연산자 표현식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ac4e03045a811db7fdf9a33fae47eaa532e51b8" translate="yes" xml:space="preserve">
          <source>The member access operator expressions through pointers to members have the form.</source>
          <target state="translated">멤버에 대한 포인터를 통한 멤버 액세스 연산자 표현식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1f68969edf8b53ae807e1ece64ebe13ea9b9298" translate="yes" xml:space="preserve">
          <source>The member access through pointer to member &lt;code&gt;operator-&amp;gt;*&lt;/code&gt;. There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of &lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;smart pointer interface&lt;/a&gt;, and in fact is used in that capacity by actors in &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenix&lt;/a&gt;. It is more common in EDSLs such as &lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;cpp.react&lt;/a&gt;.</source>
          <target state="translated">멤버 &lt;code&gt;operator-&amp;gt;*&lt;/code&gt; 대한 포인터를 통해 멤버 액세스 -&amp;gt; * . 이 연산자의 오버로드에 대한 특정 단점은 없지만 실제로는 거의 사용되지 않습니다. &lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;스마트 포인터 인터페이스의&lt;/a&gt; 일부가 될 수 있다고 제안 되었으며 실제로 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenix의&lt;/a&gt; 액터 가이 용량에 사용됩니다 . cpp.react와 같은 &lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;EDSL&lt;/a&gt; 에서 더 일반적입니다. .</target>
        </trans-unit>
        <trans-unit id="239a9f71d3cf420873e0877dbfed19f440ad8974" translate="yes" xml:space="preserve">
          <source>The member character sequence in a buffer open for writing can be over-allocated for efficiency purposes. In that case, only the</source>
          <target state="translated">쓰기를 위해 열린 버퍼의 멤버 문자 시퀀스는 효율성을 위해 과도하게 할당 될 수 있습니다. 이 경우</target>
        </trans-unit>
        <trans-unit id="05e762769a30065e204bb28bf51cb0273777e561" translate="yes" xml:space="preserve">
          <source>The member constants in &lt;code&gt;basic_regex&lt;/code&gt; are duplicates of the &lt;a href=&quot;syntax_option_type&quot;&gt;syntax_option_type&lt;/a&gt; constants defined in the namespace &lt;code&gt;std::regex_constants&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;basic_regex&lt;/code&gt; 의 멤버 상수 는 네임 스페이스 &lt;code&gt;std::regex_constants&lt;/code&gt; 정의 된 &lt;a href=&quot;syntax_option_type&quot;&gt;syntax_option_type&lt;/a&gt; 상수의 복제본입니다. .</target>
        </trans-unit>
        <trans-unit id="15df05692a271ee845f25f3cb5b040794f20a534" translate="yes" xml:space="preserve">
          <source>The member function &lt;code&gt;&lt;a href=&quot;optional/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">멤버 함수 &lt;code&gt;&lt;a href=&quot;optional/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="efb92cc5bc9ac09558948d91fa6f04f3671a172b" translate="yes" xml:space="preserve">
          <source>The member function called by the Searcher overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; to perform a search with this searcher.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; 의 검색기 과부하로 호출되는 멤버 함수이 검색기로 을 수행하기 위해 입니다.</target>
        </trans-unit>
        <trans-unit id="02d35ef45a2be736ac5d48567bf5243bd00060f5" translate="yes" xml:space="preserve">
          <source>The member function called by the Searcher overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; to perform a search with this searcher. &lt;code&gt;RandomIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">이 검색기로 &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; 을 수행하기 위해 std :: search 의 검색기 과부하로 호출 된 멤버 함수 입니다. &lt;code&gt;RandomIt2&lt;/code&gt; 은 의 요구 사항을 충족해야합니다 &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d5b7b86f4cef7432fea2b9bc1aebd9323994e41" translate="yes" xml:space="preserve">
          <source>The member functions introduced by a using-declaration into a derived class are considered to be members of the derived class for the purpose of defining the type of the</source>
          <target state="translated">using-declaration에 의해 파생 클래스에 도입 된 멤버 함수는 클래스의 유형을 정의 할 목적으로 파생 클래스의 멤버로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="764b4e1ee289e17bad4f60ec0a9d42691689afe9" translate="yes" xml:space="preserve">
          <source>The member functions of &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;std::initializer_list&lt;/code&gt; overloads of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">의 멤버 함수 &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;std::initializer_list&lt;/code&gt; 의 과부하 &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc2f6b335fdc83b3a9f3feda6af5eaac09524b21" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept because the hash of the underlying type might throw.</source>
          <target state="translated">이 전문화의 멤버 함수는 기본 유형의 해시가 발생할 수 있으므로 예외가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ef67f3b96aad3f43ceefc11f4c679e1c0ac92843" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept because the pointer may be a fancy pointer and its hash might throw.</source>
          <target state="translated">이 전문화의 멤버 함수는 포인터가 멋진 포인터 일 수 있고 해시가 발생할 수 있으므로 예외가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="833dfb1c2bf2f506172d76aae796695e09f833e7" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept.</source>
          <target state="translated">이 전문 분야의 회원 기능은 예외가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5e5711660055f235ace0e4ed3873cb22e451c3b1" translate="yes" xml:space="preserve">
          <source>The member functions return defined default values unless the &lt;code&gt;matched&lt;/code&gt; member is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;matched&lt;/code&gt; 멤버가 &lt;code&gt;true&lt;/code&gt; 가 아니면 멤버 함수는 정의 된 기본값을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="b48a3030fca44418386968b5abfc5df76aac60a3" translate="yes" xml:space="preserve">
          <source>The member interpretation is used if the range type has a member named &lt;code&gt;begin&lt;/code&gt; and a member named &lt;code&gt;end&lt;/code&gt;. This is done regardless of whether the member is a type, data member, function, or enumerator, and regardless of its accessibility. Thus a class like &lt;code&gt;class meow { enum { begin = 1, end = 2}; /* rest of class */ };&lt;/code&gt; cannot be used with the range-based for loop even if the namespace-scope begin/end functions are present.</source>
          <target state="translated">범위 유형에 &lt;code&gt;begin&lt;/code&gt; 이라는 멤버와 &lt;code&gt;end&lt;/code&gt; 라는 멤버가있는 경우 멤버 해석이 사용됩니다 . 멤버가 형식, 데이터 멤버, 함수 또는 열거 자인지 여부와 액세스 가능성에 관계없이 수행됩니다. 따라서 &lt;code&gt;class meow { enum { begin = 1, end = 2}; /* rest of class */ };&lt;/code&gt; 와 같은 클래스; / * 나머지 클래스 * /}; 네임 스페이스 범위 시작 / 종료 기능이 있어도 범위 기반 for 루프와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d02cf71c651a6bbe450e9796516bdcd13d4f27a6" translate="yes" xml:space="preserve">
          <source>The member names of the</source>
          <target state="translated">의 회원 이름</target>
        </trans-unit>
        <trans-unit id="b6068893a255d37e81d9aa5432b3ceed4971bdcc" translate="yes" xml:space="preserve">
          <source>The member names of the base class, other than &lt;code&gt;conjunction&lt;/code&gt; and &lt;code&gt;operator=&lt;/code&gt;, are not hidden and are unambiguously available in &lt;code&gt;conjunction&lt;/code&gt;.</source>
          <target state="translated">이외의 기본 클래스의 멤버 이름, &lt;code&gt;conjunction&lt;/code&gt; 및 &lt;code&gt;operator=&lt;/code&gt; 숨김 및하지에 명백하게 가능 &lt;code&gt;conjunction&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab1bc84edd2dcc31d9c428be3ac37ab55ba141eb" translate="yes" xml:space="preserve">
          <source>The member names of the base class, other than &lt;code&gt;disjunction&lt;/code&gt; and &lt;code&gt;operator=&lt;/code&gt;, are not hidden and are unambiguously available in &lt;code&gt;disjunction&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;disjunction&lt;/code&gt; 및 &lt;code&gt;operator=&lt;/code&gt; 이외의 기본 클래스의 멤버 이름은 숨겨져 있지 않으며 명확하게 &lt;code&gt;disjunction&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88413da3549b10a5d3c5e5a05a9f77dbd30567cc" translate="yes" xml:space="preserve">
          <source>The member operator() is noexcept if the &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; expression it calls is noexcept (in other words, it preserves the exception specification of the underlying call operator).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; 하는 std :: invoke 표현식 이 noexcept 인 경우 멤버 operator ()는 noexcept입니다 (즉, 기본 호출 연산자의 예외 스펙을 유지함).</target>
        </trans-unit>
        <trans-unit id="99180f77f5a8ca80c11eb2a7965cbabfd4d9c9cc" translate="yes" xml:space="preserve">
          <source>The member specification, or the</source>
          <target state="translated">멤버 사양 또는</target>
        </trans-unit>
        <trans-unit id="6247f710bbdb924881ced1b35c970d774f909927" translate="yes" xml:space="preserve">
          <source>The member template class &lt;code&gt;rebind&lt;/code&gt; provides a way to obtain an allocator for a different type. For example,</source>
          <target state="translated">멤버 템플리트 클래스 &lt;code&gt;rebind&lt;/code&gt; 는 다른 유형의 할당자를 확보하는 방법을 제공합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="03f1ae3b478686fb238fb267920a6735d4e1a474" translate="yes" xml:space="preserve">
          <source>The member type &lt;code&gt;X::pointer&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">멤버 타입 &lt;code&gt;X::pointer&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2a0ec56c51738314ed8d919d00be55a70b110d4" translate="yes" xml:space="preserve">
          <source>The member type &lt;code&gt;is_transparent&lt;/code&gt; indicates to the caller that this function object is a</source>
          <target state="translated">멤버 유형 &lt;code&gt;is_transparent&lt;/code&gt; 는 호출자에게이 함수 객체가</target>
        </trans-unit>
        <trans-unit id="97d1ac879c7a04ed1084ddb26ee5600ac333f1dc" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;X::iterator&lt;/code&gt; and &lt;code&gt;X::const_iterator&lt;/code&gt; are &lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIterators&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;X::iterator&lt;/code&gt; 및 &lt;code&gt;X::const_iterator&lt;/code&gt; 멤버 유형 은 &lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIterators입니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="189eb458b5906253d856798d17eff7858e326e0c" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;X::pointer&lt;/code&gt;, &lt;code&gt;X::const_pointer&lt;/code&gt;, &lt;code&gt;X::void_pointer&lt;/code&gt; and &lt;code&gt;X::const_void_pointer&lt;/code&gt; of every &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">모든 &lt;a href=&quot;allocator&quot;&gt;할당 자&lt;/a&gt; 유형 &lt;code&gt;X&lt;/code&gt; 의 멤버 유형 &lt;code&gt;X::pointer&lt;/code&gt; , &lt;code&gt;X::const_pointer&lt;/code&gt; , &lt;code&gt;X::void_pointer&lt;/code&gt; 및 &lt;code&gt;X::const_void_pointer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="743df5645d4509941f7715864c429844824ed55b" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; may be aliases to the same type. Since &lt;code&gt;iterator&lt;/code&gt; is convertible to &lt;code&gt;const_iterator&lt;/code&gt;, &lt;code&gt;const_iterator&lt;/code&gt; should be used in function parameter lists to avoid violations of the One Definition Rule.</source>
          <target state="translated">멤버 타입 &lt;code&gt;iterator&lt;/code&gt; 와 &lt;code&gt;const_iterator&lt;/code&gt; 는 같은 타입의 별칭 일 수 있습니다. 때문에 &lt;code&gt;iterator&lt;/code&gt; 로 변환입니다 &lt;code&gt;const_iterator&lt;/code&gt; 를 , &lt;code&gt;const_iterator&lt;/code&gt; 를이 하나의 정의 규칙의 위반을 피하기 위해 함수 매개 변수 목록에 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="4efe6ec44ec82b96dea5c4b0710d2c28b043d1ac" translate="yes" xml:space="preserve">
          <source>The members have the following meaning:</source>
          <target state="translated">멤버는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e6dadd198818909e166ec932a678a2a940461078" translate="yes" xml:space="preserve">
          <source>The memory available to a C++ program is one or more contiguous sequences of</source>
          <target state="translated">C ++ 프로그램에 사용 가능한 메모리는 하나 이상의 연속 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="037dde83ce079503b4e08f9c73501e2afb83137e" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; respectively. The (1-2) versions use &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; by default.</source>
          <target state="translated">읽기-수정-쓰기 및로드 작업을위한 메모리 모델은 각각 &lt;code&gt;succ&lt;/code&gt; 및 &lt;code&gt;fail&lt;/code&gt; 입니다. (1-2) 버전 은 기본적으로 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5a1f66f39bcd63450604a4fcb472208a00fc0663" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; respectively. In the (2) and (4) versions &lt;code&gt;order&lt;/code&gt; is used for both read-modify-write and load operations, except that &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; are used for the load operation if &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">읽기-수정-쓰기 및로드 작업을위한 메모리 모델은 각각 &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;failure&lt;/code&gt; 입니다. (2) 및 (4) 버전 &lt;code&gt;order&lt;/code&gt; &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../memory_order&quot;&gt;std :: memory_order_acq_rel&lt;/a&gt; 인 경우 &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; 조작에 사용되는 것을 제외하고 읽기-수정-쓰기 및로드 조작에 순서 가 사용됩니다 . 또는 &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1aed46d8db03878f84ce9975ff764e9083e6702c" translate="yes" xml:space="preserve">
          <source>The memory resource pointer used by this polymorphic allocator.</source>
          <target state="translated">이 다형성 할당자가 사용하는 메모리 리소스 포인터.</target>
        </trans-unit>
        <trans-unit id="6f83b6ed70462af18ce1b14250e467f4f95844bf" translate="yes" xml:space="preserve">
          <source>The memory-writing conversion specifier &lt;code&gt;%n&lt;/code&gt; is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked &lt;code&gt;printf_s&lt;/code&gt; family of functions.</source>
          <target state="translated">메모리 쓰기 변환 지정자 &lt;code&gt;%n&lt;/code&gt; 은 형식 문자열이 사용자 입력에 의존하고 경계 확인 &lt;code&gt;printf_s&lt;/code&gt; 함수 계열에서 지원되지 않는 보안 악용의 일반적인 대상입니다 .</target>
        </trans-unit>
        <trans-unit id="f9bdd1c45276cceff72dd22eaf8b65416fc4d7fe" translate="yes" xml:space="preserve">
          <source>The message from the catalog or a copy of &lt;code&gt;dfault&lt;/code&gt; if none was found.</source>
          <target state="translated">카탈로그의 메시지 또는 &lt;code&gt;dfault&lt;/code&gt; 사본이 없는 경우 사본입니다 .</target>
        </trans-unit>
        <trans-unit id="9d90f0cf5503392d1c2a08fa622e0683a067c582" translate="yes" xml:space="preserve">
          <source>The minimum of the elements.</source>
          <target state="translated">요소의 최소값</target>
        </trans-unit>
        <trans-unit id="c57eecd663caaf3065c20e7f0d66aee57b9dc3f2" translate="yes" xml:space="preserve">
          <source>The minimum potentially generated value.</source>
          <target state="translated">잠재적으로 생성되는 최소값.</target>
        </trans-unit>
        <trans-unit id="537c9aead08e9763da9b55897fd3bfcdaaa4e86a" translate="yes" xml:space="preserve">
          <source>The minimum value potentially generated by the distribution.</source>
          <target state="translated">분포에서 잠재적으로 생성 된 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="b3bcade615775889eac9bb5e7a58de484f254bd4" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EC&lt;/code&gt; writes the locale's alternative representation of the century.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%EC&lt;/code&gt; 는 로케일의 대체 세기 표현을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="75f0dc4bd53f64c06e6fa0ff392db719eabb0f3d" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EX&lt;/code&gt; interprets the locale's alternate time representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%EX&lt;/code&gt; 는 로캘의 대체 시간 표현을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="8bec27fca38ee75b95e3d0eaf504b8384963b028" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EX&lt;/code&gt; writes the locale's alternate time representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%EX&lt;/code&gt; 는 로캘의 대체 시간 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="ee3cd7f7d1a25a1212fb29ddd03a9ef8472c165d" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EY&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%EY&lt;/code&gt; 는 로케일의 대체 표현을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="1c68da4605fcc44c21d173eb10055c069c70b906" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ec&lt;/code&gt; interprets the locale's alternative date and time representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Ec&lt;/code&gt; 는 로케일의 대체 날짜 및 시간 표시를 해석합니다.</target>
        </trans-unit>
        <trans-unit id="a9a1950a1c24f9659bd1e5f981ceb85d050b8767" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ec&lt;/code&gt; writes the locale's alternative date and time representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Ec&lt;/code&gt; 는 로캘의 대체 날짜 및 시간 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="e5775f2037b71dc38628c3500d791bc260bbebcb" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ex&lt;/code&gt; interprets the locale's alternate date representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Ex&lt;/code&gt; 는 로캘의 대체 날짜 표현을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="bb64ab15333504747771454a51c8294973e64441" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ex&lt;/code&gt; produces the locale's alternate date representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Ex&lt;/code&gt; 는 로캘의 대체 날짜 표현을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="14f6995f41f4a2d2134344889d2b79f5bfd0bf66" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OH&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%OH&lt;/code&gt; 은 로캘의 대체 표현을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="da00c4361910133feb2655f2790d2c1bb35c3217" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OH&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%OH&lt;/code&gt; 는 로캘의 대체 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="02e1996d6f854882e96f32146e024df272f3e789" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OI&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%OI&lt;/code&gt; 는 로캘의 대체 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="283ff3b42755095dc2a58cb25631e8f808fd7dc4" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OM&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%OM&lt;/code&gt; 은 로캘의 대체 표현을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="2256cc6eb2ce9c6dcb14d9932189e3173fe6fb7b" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OM&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%OM&lt;/code&gt; 은 로캘의 대체 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="e18d9132406fc6f5671d9b0f4de1913dbd9ea54c" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OS&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%OS&lt;/code&gt; 는 로케일의 대체 표현을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="735aa83ce9d55484119953184990a8a3c5ef2bf3" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OS&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%OS&lt;/code&gt; 는 로캘의 대체 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="8dc1c917e7b33d49bec0f32a6ee8ce91fe3898be" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OU&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%OU&lt;/code&gt; 는 로캘의 대체 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="fed0585fe25d67debd6eae7991bab2b8338b1306" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OV&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%OV&lt;/code&gt; 는 로캘의 대체 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="39e0e2ebc4225fd4de3a9212027bfa57ba77c5c1" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OW&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%OW&lt;/code&gt; 는 로캘의 대체 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="b8c0342bc98a8d9ac901f7fa48dc3728088a24cf" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Od&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Od&lt;/code&gt; 는 로캘의 대체 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="23a1adfc45649b52f8d2f79649429566f6756cd0" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Oe&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Oe&lt;/code&gt; 는 로캘의 대체 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="3f211113e01d87804b53bf0839dc4545235c21b5" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Om&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Om&lt;/code&gt; 은 로캘의 대체 표현을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="6bfc0f055c1fd26cc9dfcc3dd3e7269715d8fbdd" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Om&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Om&lt;/code&gt; 은 로캘의 대체 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="4738bf4fa0770676817bc173268ec85ebdefcba5" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ou&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Ou&lt;/code&gt; 는 로캘의 대체 표현을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="28885626f1f9a4c0bc54a2f829547cf0075f8fc0" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ou&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Ou&lt;/code&gt; 는 로캘의 대체 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="46f001b91727d0cd13635e13519f0c94ccb1c799" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ow&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Ow&lt;/code&gt; 는 로캘의 대체 표현을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="116f6b00825f4347d9b3ad162c904523d7a741ec" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ow&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Ow&lt;/code&gt; 는 로캘의 대체 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="eeffbf82acb0112a4308b4adc0a39d3f2e8cd8e8" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%EC&lt;/code&gt; and &lt;code&gt;%OC&lt;/code&gt; interpret the locale's alternative representation of the century.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%EC&lt;/code&gt; 및 &lt;code&gt;%OC&lt;/code&gt; 는 로케일의 다른 세기 표현을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="1f8b1cf22bf3b662efdfa9705f03b9deebed9290" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ed&lt;/code&gt; and &lt;code&gt;%Ee&lt;/code&gt; interpret the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Ed&lt;/code&gt; 및 &lt;code&gt;%Ee&lt;/code&gt; 는 로캘의 대체 표현을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="3d9c4fc10338b78eb69266a4a35ef3927badf16c" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ey&lt;/code&gt; and &lt;code&gt;%Oy&lt;/code&gt; interpret the locale's alternative representation.</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Ey&lt;/code&gt; 및 &lt;code&gt;%Oy&lt;/code&gt; 는 로케일의 대체 표현을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="c680b13d4cfe115916d50f79a4e761597d1ce5f8" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ez&lt;/code&gt; and &lt;code&gt;%Oz&lt;/code&gt; insert a &lt;code&gt;:&lt;/code&gt; between the hours and minutes (e.g., &lt;code&gt;-04:30&lt;/code&gt;).</source>
          <target state="translated">수정 명령 &lt;code&gt;%Ez&lt;/code&gt; 및 &lt;code&gt;%Oz&lt;/code&gt; 삽입 &lt;code&gt;:&lt;/code&gt; 시간과 분 사이 (예 &lt;code&gt;-04:30&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="967e201acaf95797b9f2a6182b751263d355c430" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ez&lt;/code&gt; and &lt;code&gt;%Oz&lt;/code&gt; parses the format &lt;code&gt;[+|-]h[h][:mm]&lt;/code&gt; (i.e., requiring a &lt;code&gt;:&lt;/code&gt; between the hours and minutes and making the leading zero for hour optional).</source>
          <target state="translated">수정 된 명령 &lt;code&gt;%Ez&lt;/code&gt; 및 &lt;code&gt;%Oz&lt;/code&gt; 는 &lt;code&gt;[+|-]h[h][:mm]&lt;/code&gt; 형식을 구문 분석합니다 (즉, 시간과 분 사이 에 &lt;code&gt;:&lt;/code&gt; 가 필요 하고 시간에 선행 0을 선택 사항으로 설정).</target>
        </trans-unit>
        <trans-unit id="b675bd758d57655fae835bb898a51c3bcb35971b" translate="yes" xml:space="preserve">
          <source>The monetary format is an array of four &lt;code&gt;char&lt;/code&gt;s convertible to &lt;code&gt;std::money_base::part&lt;/code&gt;. In that sequence, each of &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;sign&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; appears exactly once, and either &lt;code&gt;space&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt; appears in the remaining position. The value &lt;code&gt;none&lt;/code&gt;, if present, is not first; the value &lt;code&gt;space&lt;/code&gt;, if present, is neither first nor last.</source>
          <target state="translated">화폐 형식은 &lt;code&gt;std::money_base::part&lt;/code&gt; 로 변환 할 수있는 4 개의 &lt;code&gt;char&lt;/code&gt; 배열입니다 . 이 순서에서 &lt;code&gt;symbol&lt;/code&gt; , &lt;code&gt;sign&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 각각은 정확히 한 번 표시되며 &lt;code&gt;space&lt;/code&gt; 또는 &lt;code&gt;none&lt;/code&gt; 이 나머지 위치에 나타납니다. &lt;code&gt;none&lt;/code&gt; 값 은 존재하는 경우 첫 번째가 아닙니다. 존재하는 경우 값 &lt;code&gt;space&lt;/code&gt; 은 처음도 아니고 마지막도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="57df9eb0b96a23c853c95f72ee4e1aa61512a265" translate="yes" xml:space="preserve">
          <source>The month value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 저장된 월 값 입니다.</target>
        </trans-unit>
        <trans-unit id="e90e2ca09851d3473823a48772a0e35e7c3866b3" translate="yes" xml:space="preserve">
          <source>The most-derived type of &lt;code&gt;other&lt;/code&gt; may not match the most derived type of &lt;code&gt;*this&lt;/code&gt;. A derived class implementation therefore must typically check whether the most derived types of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; match using &lt;code&gt;dynamic_cast&lt;/code&gt;, and immediately return &lt;code&gt;false&lt;/code&gt; if the cast fails.</source>
          <target state="translated">가장 많이 파생 된 &lt;code&gt;other&lt;/code&gt; 유형은 가장 많이 파생 된 &lt;code&gt;*this&lt;/code&gt; 유형과 일치하지 않을 수 있습니다 . 그러므로 파생 클래스 구현은 일반적으로 가장 많이 파생 된 &lt;code&gt;*this&lt;/code&gt; 유형 과 &lt;code&gt;dynamic_cast&lt;/code&gt; 를 사용하여 &lt;code&gt;other&lt;/code&gt; 유형 이 일치 하는지 확인하고 캐스트가 실패하면 즉시 &lt;code&gt;false&lt;/code&gt; 를 리턴 해야합니다.</target>
        </trans-unit>
        <trans-unit id="16d05d9f68ef63dd77ebb7c2b2b018270c08172b" translate="yes" xml:space="preserve">
          <source>The motivation behind &lt;code&gt;std::result_of&lt;/code&gt; is to determine the result of invoking a &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;, in particular if that result type is different for different sets of arguments.</source>
          <target state="translated">&lt;code&gt;std::result_of&lt;/code&gt; 의 동기 는 &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; 호출 결과를 판별하는 것입니다 . 특히 결과 유형이 다른 인수 세트에 대해 다른 경우 호출 가능.</target>
        </trans-unit>
        <trans-unit id="be939183f398e144c5a9f5a26339a5ff2df358bf" translate="yes" xml:space="preserve">
          <source>The move assignment operator for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">다음 사항이 모두 해당되는 경우 클래스 &lt;code&gt;T&lt;/code&gt; 에 대한 이동 할당 연산자 는 간단합니다.</target>
        </trans-unit>
        <trans-unit id="913a05bd12f57d4991f4c434437ba8fdc8ca96af" translate="yes" xml:space="preserve">
          <source>The move assignment operator is called whenever it is selected by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, e.g. when an object appears on the left-hand side of an assignment expression, where the right-hand side is an rvalue of the same or implicitly convertible type.</source>
          <target state="translated">이동 할당 연산자는 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결에&lt;/a&gt; 의해 선택 될 때마다 , 예를 들어 객체가 할당 표현식의 왼쪽에 나타날 때 호출됩니다. 여기서 오른쪽은 동일하거나 암시 적으로 변환 가능한 유형의 rvalue입니다.</target>
        </trans-unit>
        <trans-unit id="964822bbec02f38193fe2598cdea03b6e1354a55" translate="yes" xml:space="preserve">
          <source>The move constructor for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">다음 사항이 모두 해당되면 클래스 &lt;code&gt;T&lt;/code&gt; 의 이동 생성자 는 사소한 것입니다.</target>
        </trans-unit>
        <trans-unit id="43ecab829b4442770406c7743a4c24f8d39184e8" translate="yes" xml:space="preserve">
          <source>The move constructor is typically called when an object is &lt;a href=&quot;initialization&quot;&gt;initialized&lt;/a&gt; (by &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; or &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt;) from &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; (xvalue or prvalue)(until C++17)xvalue(since C++17) of the same type, including.</source>
          <target state="translated">이동 생성자는 일반적으로 객체가 동일한 유형의 &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; (xvalue 또는 prvalue) (C ++ 17) xvalue (C ++ 17 이후)에서 rinit (xvalue 또는 prvalue) 에서 &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; ( &lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 또는 &lt;a href=&quot;copy_initialization&quot;&gt;복사 초기화&lt;/a&gt; ) 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6c57480f2676fa3a3bf78ec56583003322efec68" translate="yes" xml:space="preserve">
          <source>The multibyte encoding used by this function is specified by the currently active C locale.</source>
          <target state="translated">이 함수가 사용하는 멀티 바이트 인코딩은 현재 활성화 된 C 로케일로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="3934767ca9f156dfb707eb56bde26fbae9cf9bf0" translate="yes" xml:space="preserve">
          <source>The multibyte null character was converted and stored.</source>
          <target state="translated">멀티 바이트 널 문자가 변환되어 저장되었습니다.</target>
        </trans-unit>
        <trans-unit id="a13f36d11d813ad1aa81620c3624a0829c3d680e" translate="yes" xml:space="preserve">
          <source>The multibyte null character was converted and stored. &lt;code&gt;src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">멀티 바이트 널 문자가 변환되어 저장되었습니다. &lt;code&gt;src&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 로 설정 되며 &lt;code&gt;*ps&lt;/code&gt; 는 초기 시프트 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="afaeafb6cba6f4e054dc4876689069feee1d4951" translate="yes" xml:space="preserve">
          <source>The mutex must be locked by the current thread of execution in shared mode, otherwise, the behavior is undefined.</source>
          <target state="translated">뮤텍스는 공유 모드에서 현재 실행 스레드에 의해 잠겨 있어야합니다. 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9efc369f87fb8cd445bfe13d9edeb971e0837953" translate="yes" xml:space="preserve">
          <source>The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.</source>
          <target state="translated">뮤텍스는 현재 실행 스레드에 의해 잠겨 있어야합니다. 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c6d8525b20aacdba1419fafc3fc7f5ae08bc2dd" translate="yes" xml:space="preserve">
          <source>The n distribution parameter.</source>
          <target state="translated">n 분포 모수.</target>
        </trans-unit>
        <trans-unit id="96123ca150593776b8703cdefba85a9b3570e940" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;array::elems&lt;/code&gt; is only for exposition, it's not part of the interface.</source>
          <target state="translated">&lt;code&gt;array::elems&lt;/code&gt; 이름 은 박람회 전용이며 인터페이스의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="db9a37193da19fc9dd60f45b310779d49a73e6a1" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;posix&lt;/code&gt; is reserved for a future top-level namespace. The behavior is undefined if a program declares or defines anything in that namespace.</source>
          <target state="translated">&lt;code&gt;posix&lt;/code&gt; 라는 이름 은 향후 최상위 네임 스페이스를 위해 예약되어 있습니다. 프로그램이 해당 네임 스페이스에서 무언가를 선언하거나 정의하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3705e1c5df92bb63d55f69679ede335b0b4b0b65" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;proxy&lt;/code&gt; is for exposition only.</source>
          <target state="translated">이름 &lt;code&gt;proxy&lt;/code&gt; 는 박람회 전용입니다.</target>
        </trans-unit>
        <trans-unit id="fc982d2e54ad63316d942020cd2cc954f5238174" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;ranges::swap&lt;/code&gt; denotes a</source>
          <target state="translated">이름 &lt;code&gt;ranges::swap&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="2aed87bc0a44df46c92723b411bf691a391dd142" translate="yes" xml:space="preserve">
          <source>The name of a non-static data member or a non-static member function can only appear in the following three situations:</source>
          <target state="translated">비 정적 데이터 멤버 또는 비 정적 멤버 함수의 이름은 다음 세 가지 상황에서만 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89cb222de00d870b7103bfa145f09bcde84c1415" translate="yes" xml:space="preserve">
          <source>The name of an enumerator introduced in a &lt;a href=&quot;enum&quot;&gt;scoped enumeration&lt;/a&gt; begins at the point of declaration and ends at the end of the enum specifier (in contrast, unscoped enumerators are in scope after the end of the enum specifier).</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt;범위&lt;/a&gt; 가 지정된 열거 형에 도입 된 열거 자의 이름은 선언 시점에서 시작하여 열거 자 지정자 끝에서 끝납니다 (반대, 범위가 지정되지 않은 열거자는 열거 자 지정자 끝 이후에 범위에 있음).</target>
        </trans-unit>
        <trans-unit id="10cae2ebd2504e13706f02700ec469c53921536e" translate="yes" xml:space="preserve">
          <source>The name of an unscoped enumeration may be omitted: such declaration only introduces the enumerators into the enclosing scope:</source>
          <target state="translated">범위가 지정되지 않은 열거의 이름은 생략 할 수 있습니다. 이러한 선언은 열거자를 둘러싸는 범위로만 소개합니다.</target>
        </trans-unit>
        <trans-unit id="814dfe2ccc46c197be3bf6a8df03805774f01aa8" translate="yes" xml:space="preserve">
          <source>The name of every &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt; member (static, non-static, function, type, etc) has an associated &quot;member access&quot;. When a name of the member is used anywhere a program, its access is checked, and if it does not satisfy the access rules, the program does not compile:</source>
          <target state="translated">모든 &lt;a href=&quot;class&quot;&gt;클래스&lt;/a&gt; 멤버 의 이름 (정적, 비 정적, 함수, 유형 등)에는 연관된 &quot;멤버 액세스&quot;가 있습니다. 멤버 이름이 프로그램 어디에서나 사용되면 액세스가 점검되고 액세스 규칙을 충족하지 않으면 프로그램이 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59568709b5ee764a18b13d2df686742954820331" translate="yes" xml:space="preserve">
          <source>The name of the associated &lt;code&gt;type_info&lt;/code&gt; object.</source>
          <target state="translated">연관된 &lt;code&gt;type_info&lt;/code&gt; 객체 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="ccf301417aa7c5ce4d3a1d2609e3c2ea16a28b7f" translate="yes" xml:space="preserve">
          <source>The name of the locale or &quot;*&quot; if unnamed.</source>
          <target state="translated">로케일의 이름 또는 이름이없는 경우 &quot;*&quot;</target>
        </trans-unit>
        <trans-unit id="ab62ba490e7db4c1ba2cce1f51033276d065dbc5" translate="yes" xml:space="preserve">
          <source>The name of the nested class exists in the scope of the enclosing class, and name lookup from a member function of a nested class visits the scope of the enclosing class after examining the scope of the nested class. Like any member of its enclosing class, the nested class has access to all names (private, protected, etc) to which the enclosing class has access, but it is otherwise independent and has no special access to the &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer of the enclosing class.</source>
          <target state="translated">중첩 클래스의 이름은 포함 클래스의 범위에 있으며 중첩 클래스의 멤버 함수에서 이름을 조회하면 중첩 클래스의 범위를 검사 한 후 포함 클래스의 범위를 방문합니다. 둘러싸는 클래스의 다른 멤버와 마찬가지로 중첩 클래스는 둘러싸는 클래스가 액세스하는 모든 이름 (개인, 보호 등)에 액세스 할 수 있지만 그렇지 않으면 독립적이며 둘러싸는 클래스 &lt;a href=&quot;this&quot;&gt;의이&lt;/a&gt; 포인터에 대한 특별한 액세스는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8748ab247c13f054caf5ac6393ba32b0c81004a9" translate="yes" xml:space="preserve">
          <source>The name of the parameter is optional:</source>
          <target state="translated">매개 변수 이름은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="5fef32c68362194a9310ccea4c204a96d5f83c27" translate="yes" xml:space="preserve">
          <source>The name of the required language linkage</source>
          <target state="translated">필요한 언어 연결의 이름</target>
        </trans-unit>
        <trans-unit id="6a22edb52d9ca8d339db6db0919c173b04d7cfae" translate="yes" xml:space="preserve">
          <source>The name of this function can have one of the two forms:</source>
          <target state="translated">이 함수의 이름은 다음 두 가지 형식 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e85a699586442a78b31c18e7ca7ed56aace9084" translate="yes" xml:space="preserve">
          <source>The name of this function stands for &quot;stream: how many characters?&quot;, so it is pronounced &quot;S how many C&quot;, rather than &quot;show many C&quot;</source>
          <target state="translated">이 함수의 이름은 &quot;stream : how many characters?&quot;를 나타내므로 &quot;show many C&quot;가 아니라 &quot;S how many C&quot;로 발음됩니다.</target>
        </trans-unit>
        <trans-unit id="4177d34d388a7f7f015fd91e4b891be839e0252a" translate="yes" xml:space="preserve">
          <source>The name of this time zone (e.g., &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt;).</source>
          <target state="translated">이 시간대의 이름입니다 (예 : &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b1f3d7cdd9264d99f9f78cc280cd57b23e748c7e" translate="yes" xml:space="preserve">
          <source>The name stands for &quot;string pointer break&quot;, because it returns a pointer to the first of the separator (&quot;break&quot;) characters.</source>
          <target state="translated">이름은 &quot;문자열 포인터 나누기&quot;를 나타내며, 첫 번째 구분 기호 ( &quot;break&quot;) 문자에 대한 포인터를 반환하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1ee1404e6d3d16d932267176149d19223296bb12" translate="yes" xml:space="preserve">
          <source>The names &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; are arbitrary, as well as the representation of the types of the parameters: &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; is equally valid.</source>
          <target state="translated">&lt;code&gt;argc&lt;/code&gt; 와 &lt;code&gt;argv&lt;/code&gt; 라는 이름 은 임의적이며 매개 변수 유형의 표현입니다. &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; 도 똑같이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="15246282307805d7fde541df72df9de56fc0168b" translate="yes" xml:space="preserve">
          <source>The names used in the default arguments are looked up, checked for &lt;a href=&quot;access&quot;&gt;accessibility&lt;/a&gt;, and bound at the point of declaration, but are executed at the point of the function call:</source>
          <target state="translated">기본 인수에 사용 된 이름은 조회, &lt;a href=&quot;access&quot;&gt;접근성&lt;/a&gt; 검사 및 선언 시점에서 바인딩되지만 함수 호출 시점에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="dc8c0c1bca9964f296fb879c9e2285406fd9815a" translate="yes" xml:space="preserve">
          <source>The namespace &lt;a href=&quot;../utility/rel_ops/operator_cmp&quot;&gt;rel_ops&lt;/a&gt; provides generic operators &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt;</source>
          <target state="translated">네임 스페이스 &lt;a href=&quot;../utility/rel_ops/operator_cmp&quot;&gt;rel_ops&lt;/a&gt; 는 일반 연산자 &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="747b64b0884ce26c6ee214fc6fa900b44b84b929" translate="yes" xml:space="preserve">
          <source>The namespace &lt;code&gt;std&lt;/code&gt; is used to place names of the standard C++ library. See &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;Extending namespace std&lt;/a&gt; for the rules about adding names to it.</source>
          <target state="translated">네임 스페이스 &lt;code&gt;std&lt;/code&gt; 는 표준 C ++ 라이브러리의 이름을 배치하는 데 사용됩니다. 이름 추가에 대한 규칙은 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;네임 스페이스 std 확장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="029adc599436884611e1679c479ef261e73420f2" translate="yes" xml:space="preserve">
          <source>The namespace alias &lt;code&gt;std::view&lt;/code&gt; is provided as a shorthand for &lt;code&gt;std::ranges::view&lt;/code&gt;.</source>
          <target state="translated">네임 스페이스 별명 &lt;code&gt;std::view&lt;/code&gt; 는 &lt;code&gt;std::ranges::view&lt;/code&gt; 의 약어로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="a00a6ec7f2538958f4971dfcb23715d488c7aa23" translate="yes" xml:space="preserve">
          <source>The namespace-body defines a &lt;a href=&quot;scope&quot;&gt;namespace scope&lt;/a&gt;, which affects &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;.</source>
          <target state="translated">namespace-body는 &lt;a href=&quot;scope&quot;&gt;네임 스페이스 범위를&lt;/a&gt; 정의하며 이는 &lt;a href=&quot;lookup&quot;&gt;이름 조회에&lt;/a&gt; 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="44461e8e669298aaabf78d64c5cf761c5b270b21" translate="yes" xml:space="preserve">
          <source>The native handle of this condition variable.</source>
          <target state="translated">이 조건 변수의 기본 핸들.</target>
        </trans-unit>
        <trans-unit id="0fd9941f111f60c6088fd13f324a4124b6730d22" translate="yes" xml:space="preserve">
          <source>The native string representation of the pathname, using native syntax, native character type, and native character encoding. This string is suitable for use with OS APIs.</source>
          <target state="translated">기본 구문, 기본 문자 유형 및 기본 문자 인코딩을 사용하여 경로 이름의 기본 문자열 표시. 이 문자열은 OS API와 함께 사용하기에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="da3734864c7a6f4ae8da4b63030befa1148f5321" translate="yes" xml:space="preserve">
          <source>The natural logarithm of a complex number z with polar coordinate components (r,&amp;theta;) equals ln r + i(&amp;theta;+2n&amp;pi;), with the principal value ln r + i&amp;theta;</source>
          <target state="translated">극좌표 성분 (r, &amp;theta;)을 갖는 복소수 z의 자연 로그는 ln r + i (&amp;theta; + 2n&amp;pi;)이며, 주값은 ln r + i&amp;theta;입니다.</target>
        </trans-unit>
        <trans-unit id="3e1f12a369d7befe692c93f44687eb7110ca778a" translate="yes" xml:space="preserve">
          <source>The nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">&lt;a href=&quot;../fenv/fe_round&quot;&gt;현재 반올림 모드&lt;/a&gt; 에 따라 &lt;code&gt;arg&lt;/code&gt; 에 가장 가까운 정수 값 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a00868e0a58251c056ae90a3de93adcb746a8300" translate="yes" xml:space="preserve">
          <source>The new alias alias_name provides an alternate method of accessing ns_name.</source>
          <target state="translated">새로운 alias alias_name은 ns_name에 액세스하는 대체 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="429783cbe5a2b5c7d1031e7777e0e7ddc7639a9d" translate="yes" xml:space="preserve">
          <source>The new expression looks for appropriate allocation function's name firstly in the class scope, and after that in the global scope. Note, that as per &lt;a href=&quot;../../language/lookup&quot;&gt;name lookup rules&lt;/a&gt;, any allocation functions declared in class scope hides all global allocation functions for the new-expressions that attempt to allocate objects of this class.</source>
          <target state="translated">새 표현식은 클래스 범위에서 먼저 적절한 할당 함수의 이름을 찾은 후 글로벌 범위에서 찾습니다. 참고 따라 것을 &lt;a href=&quot;../../language/lookup&quot;&gt;이름 조회 규칙&lt;/a&gt; 어떤 할당 함수는이 클래스의 객체를 할당하려고 새로운-표현에 대한 모든 글로벌 할당 함수 클래스 범위의 가죽에 선언했다.</target>
        </trans-unit>
        <trans-unit id="b4f387edefbb790808ceeca9099abd48faba678a" translate="yes" xml:space="preserve">
          <source>The new string can be one of:</source>
          <target state="translated">새 문자열은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9828879c32005d467860b7e9f5f3d8c58eb5420" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;rv&lt;/code&gt; is unspecified.</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; 의 새로운 값 은 지정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d39b572de7e7c5941b91ef76f32e21e73a603a2" translate="yes" xml:space="preserve">
          <source>The new, nameless, locale.</source>
          <target state="translated">이름없는 새로운 로케일</target>
        </trans-unit>
        <trans-unit id="da2f7bd8f4e5182cfeb3ed50ce6c838f6be3f42c" translate="yes" xml:space="preserve">
          <source>The new-expression allocates storage by calling the appropriate &lt;a href=&quot;../memory/new/operator_new&quot;&gt; allocation function&lt;/a&gt;. If &lt;code&gt;type&lt;/code&gt; is a non-array type, the name of the function is &lt;code&gt;operator new&lt;/code&gt;. If &lt;code&gt;type&lt;/code&gt; is an array type, the name of the function is &lt;code&gt;operator new[]&lt;/code&gt;.</source>
          <target state="translated">new-expression은 적절한 &lt;a href=&quot;../memory/new/operator_new&quot;&gt;할당 함수를&lt;/a&gt; 호출하여 스토리지를 할당합니다 . 경우 &lt;code&gt;type&lt;/code&gt; 비 어레이 형이고, 함수 이름은 &lt;code&gt;operator new&lt;/code&gt; . 경우 &lt;code&gt;type&lt;/code&gt; 배열 형태는, 함수의 이름이다 &lt;code&gt;operator new[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f81c62ecf75f1df624cbf52969b5f6fcc7a10310" translate="yes" xml:space="preserve">
          <source>The new-line character &lt;code&gt;\n&lt;/code&gt; has special meaning when used in &lt;a href=&quot;../io/c&quot;&gt;text mode I/O&lt;/a&gt;: it is converted to the OS-specific newline representation, usually a byte or byte sequence. Some systems mark their lines with length fields instead.</source>
          <target state="translated">개행 문자 &lt;code&gt;\n&lt;/code&gt; 은 &lt;a href=&quot;../io/c&quot;&gt;텍스트 모드 I / O&lt;/a&gt; 에서 사용될 때 특별한 의미를 갖습니다 . 일반적으로 바이트 또는 바이트 순서로 OS 특정 개행 표시로 변환됩니다. 일부 시스템은 대신 길이 필드로 선을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5004a5f082175ce95c41ab6d7df587cd32a7942b" translate="yes" xml:space="preserve">
          <source>The newly-created object of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 새로 작성된 오브젝트입니다 .</target>
        </trans-unit>
        <trans-unit id="6a3ab198cc816c45e12af507dd340aff4fdc62a4" translate="yes" xml:space="preserve">
          <source>The next character in the get area, &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; on success, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">get 영역의 다음 문자 &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; 성공시 부호없는 char) (* gptr ()) , 실패시 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b97d648e7c3b9a6a63758b3451bbdb0486f22240" translate="yes" xml:space="preserve">
          <source>The next character is extracted from &lt;code&gt;in&lt;/code&gt; as if by &lt;code&gt;char_type ct = *in;&lt;/code&gt;</source>
          <target state="translated">다음 문자가 추출되어 &lt;code&gt;in&lt;/code&gt; 경우와 같이 &lt;code&gt;char_type ct = *in;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4680ffa8ce226ac6776cedbea3e5f170c27a198" translate="yes" xml:space="preserve">
          <source>The next multibyte character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">저장 될 다음 멀티 바이트 문자는 &lt;code&gt;len&lt;/code&gt; 을 초과 합니다.</target>
        </trans-unit>
        <trans-unit id="ceaab5e3743ebc5e67758c93a0ae4928508e66de" translate="yes" xml:space="preserve">
          <source>The next wide character from the stream or &lt;code&gt;WEOF&lt;/code&gt; if an error has occurred or the end of file has been reached. If an encoding error occurred, &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;EILSEQ&lt;/code&gt;.</source>
          <target state="translated">오류가 발생했거나 파일 끝에 도달 한 경우 스트림 또는 &lt;code&gt;WEOF&lt;/code&gt; 에서 다음 와이드 문자입니다 . 인코딩 오류가 발생하면 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;EILSEQ&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e768a510933a94e869abc7fbe11cfe3c7af6736" translate="yes" xml:space="preserve">
          <source>The next wide character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">저장 될 다음 와이드 문자는 &lt;code&gt;len&lt;/code&gt; 을 초과 합니다.</target>
        </trans-unit>
        <trans-unit id="01a927ab9df8533e7f8f33e9f6abfb695cfb7e25" translate="yes" xml:space="preserve">
          <source>The noexcept-specification is a part of the function type and may appear as part of any &lt;a href=&quot;function&quot;&gt;function declarator&lt;/a&gt;.</source>
          <target state="translated">noexcept-specification은 함수 유형의 일부이며 &lt;a href=&quot;function&quot;&gt;함수 선언자의&lt;/a&gt; 일부로 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e8e2aa7b768b907757e4c37f13e697b69a77fae" translate="yes" xml:space="preserve">
          <source>The noexcept-specification is not a part of the function type (just like &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;) and can only appear as a part of a &lt;a href=&quot;lambda&quot;&gt;lambda declarator&lt;/a&gt; or a top-level &lt;a href=&quot;function&quot;&gt;function declarator&lt;/a&gt; when declaring functions, variables, non-static data members of type function, pointer to function, reference to function, or pointer to member function, and also when declaring a parameter or a return type in one of those declarations that in turn happens to be a pointer or reference to function. It cannot appear in a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; or &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt; declaration.</source>
          <target state="translated">noexcept-specification은 함수 유형의 일부가 아니며 ( &lt;a href=&quot;except_spec&quot;&gt;동적 예외 사양&lt;/a&gt; 과 동일) 함수, 변수, 정적이 아닌 데이터 유형 유형을 &lt;a href=&quot;function&quot;&gt;선언&lt;/a&gt; 할 때 &lt;a href=&quot;lambda&quot;&gt;람다 선언자&lt;/a&gt; 또는 최상위 함수 선언자 의 일부로 만 표시 될 수 있습니다. 함수, 함수에 대한 포인터, 함수에 대한 참조 또는 멤버 함수에 대한 포인터, 그리고 선언 또는 함수에 대한 참조가되는 선언 중 하나에서 매개 변수 또는 리턴 유형을 선언 할 때도 사용됩니다. &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 또는 &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt; 선언 에는 나타날 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="91d5dbc9bc5e94a5126d0bce53badf87576b47e0" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; always returns &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">비 변환 특수화 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 항상 &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dc09343d894c712f42534e3a3a7a2e71d277a115" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">비 변환 특수화 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3181f2172f64e8c18c66b621b97fc46888a027ba" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(max, from_end-from)&lt;/code&gt;.</source>
          <target state="translated">비 변환 특수화 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(max, from_end-from)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a64105f39486401f5acc80b055bc1c3fc01a2fb5" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">비 변환 특수화 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="e57a9aa4e3c88808abdb8487b916a663a9f0cec4" translate="yes" xml:space="preserve">
          <source>The non-negative value of type &lt;code&gt;catalog&lt;/code&gt; that can be used with &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;. Returns a negative value if the catalog could not be opened.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 와 함께 사용할 수있는 &lt;code&gt;catalog&lt;/code&gt; 유형의 음이 아닌 값입니다 . 카탈로그를 열 수없는 경우 음수 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="02e334d13769a2c905eebc3be84f4142a27bd649" translate="yes" xml:space="preserve">
          <source>The non-throwing overload has no special action on error.</source>
          <target state="translated">비투과 과부하에는 오류에 대한 특별한 조치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="34e36164ec9a95125dc49a45834357890507b833" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;-1&lt;/code&gt; on errors.</source>
          <target state="translated">비투과 과부하는 오류시 &lt;code&gt;-1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="aa28e66303348738c761475c96ff70e7788d369b" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;false&lt;/code&gt; on errors.</source>
          <target state="translated">비투과 과부하는 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="919ace58ca21119d988f2559255ddff1ca1db7ec" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; on errors.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; 과부하는 오류 발생시 static_cast &amp;lt;uintmax_t&amp;gt; (-1) 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="998e79778beab53392bc4f00d5142904ec8702e3" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns an empty path on errors.</source>
          <target state="translated">비투과 과부하는 오류시 빈 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="afb768fa11ed8a7e400ee259f3f1ed7b0405bd1e" translate="yes" xml:space="preserve">
          <source>The non-throwing overload sets all members to &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; 과부하는 모든 멤버를 오류시 static_cast &amp;lt;uintmax_t&amp;gt; (-1)로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="fa9c9a7d355030087b9f4a3bf568048262b6a45c" translate="yes" xml:space="preserve">
          <source>The norm calculated by this function is also known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Field_norm&quot;&gt;field norm&lt;/a&gt; or &lt;a href=&quot;http://mathworld.wolfram.com/AbsoluteSquare.html&quot;&gt;absolute square&lt;/a&gt;.</source>
          <target state="translated">이 함수에 의해 계산 된 표준은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Field_norm&quot;&gt;필드 표준&lt;/a&gt; 또는 &lt;a href=&quot;http://mathworld.wolfram.com/AbsoluteSquare.html&quot;&gt;절대 제곱&lt;/a&gt; 이라고도 합니다 .</target>
        </trans-unit>
        <trans-unit id="7e486b6025e3738e962c61297301601872036ad5" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;(E)&lt;/code&gt; is the normal form of &lt;code&gt;E&lt;/code&gt;;</source>
          <target state="translated">정규식 &lt;code&gt;(E)&lt;/code&gt; 은 정규형 &lt;code&gt;E&lt;/code&gt; 이며;</target>
        </trans-unit>
        <trans-unit id="9bddf9d40a32b5e00d57e01971707d640e804497" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;C&amp;lt;A1, A2, ... , AN&amp;gt;&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; names a concept, is the normal form of the constraint expression of &lt;code&gt;C&lt;/code&gt;, after substituting A1, A2, ... , AN for &lt;code&gt;C&lt;/code&gt;'s respective template parameters in the parameter mappings of each atomic constraint of C. If any such substitution into the parameter mappings results in an invalid type or expression, the program is ill-formed, no diagnostic required.</source>
          <target state="translated">발현의 정상적인 형태 &lt;code&gt;C&amp;lt;A1, A2, ... , AN&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;C&lt;/code&gt; 의 명칭 개념이의 제약 식의 일반적인 형태 &lt;code&gt;C&lt;/code&gt; 로 치환 한 후, A1, A2, ..., 대한 &lt;code&gt;C&lt;/code&gt; ' C의 각 원자 제한 조건의 매개 변수 맵핑에있는 각각의 템플리트 매개 변수. 매개 변수 맵핑으로의 이러한 대체로 인해 유효하지 않은 유형 또는 표현식이 발생하면 프로그램이 잘못 구성되고 진단이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5086c57862725f37980d863e1b8836e88a15cef7" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;E1 &amp;amp;&amp;amp; E2&lt;/code&gt; is the conjunction of the normal forms of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;.</source>
          <target state="translated">정규식 &lt;code&gt;E1 &amp;amp;&amp;amp; E2&lt;/code&gt; 는 정규형 &lt;code&gt;E1&lt;/code&gt; 과 &lt;code&gt;E2&lt;/code&gt; 의 결합입니다 .</target>
        </trans-unit>
        <trans-unit id="218bd31f9dfc47e61adeda7a1fae8d05c1d9c91a" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;E1 || E2&lt;/code&gt; is the disjunction of the normal forms of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;.</source>
          <target state="translated">정규식 &lt;code&gt;E1 || E2&lt;/code&gt; 는 일반적인 형태의 &lt;code&gt;E1&lt;/code&gt; 및 &lt;code&gt;E2&lt;/code&gt; 의 분리입니다 .</target>
        </trans-unit>
        <trans-unit id="3cfc995fd9a247d5a41e7c2c9e5f1255a95384b9" translate="yes" xml:space="preserve">
          <source>The normal form of any other expression &lt;code&gt;E&lt;/code&gt; is the atomic constraint whose expression is &lt;code&gt;E&lt;/code&gt; and whose parameter mapping is the identity mapping. This includes all &lt;a href=&quot;fold&quot;&gt;fold expressions&lt;/a&gt;, even those folding over the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; operators.</source>
          <target state="translated">다른 표현식 &lt;code&gt;E&lt;/code&gt; 의 일반 형식은 표현식이 &lt;code&gt;E&lt;/code&gt; 이고 매개 변수 맵핑이 ID 맵핑 인 원자 제한 조건입니다 . 여기에는 모든 &lt;a href=&quot;fold&quot;&gt;접기 표현식&lt;/a&gt; 이 포함 되며, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;||&lt;/code&gt; 연산자.</target>
        </trans-unit>
        <trans-unit id="fe2c62a2f9883108b9601f6b362958e238efecab" translate="yes" xml:space="preserve">
          <source>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock.</source>
          <target state="translated">통지 스레드는 대기 스레드가 보유한 것과 동일한 뮤텍스에 잠금을 유지할 필요가 없습니다. 통지 된 스레드가 즉시 다시 차단하고 통지 스레드가 잠금을 해제하기를 기다리므로 실제로 그렇게하는 것은 비관 화입니다.</target>
        </trans-unit>
        <trans-unit id="74b817b062ef6088a10c131453eb749d4d9679d7" translate="yes" xml:space="preserve">
          <source>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock. However, some implementations (in particular many implementations of pthreads) recognize this situation and avoid this &quot;hurry up and wait&quot; scenario by transferring the waiting thread from the condition variable's queue directly to the queue of the mutex within the notify call, without waking it up.</source>
          <target state="translated">통지 스레드는 대기 스레드가 보유한 것과 동일한 뮤텍스에 잠금을 유지할 필요가 없습니다. 통지 된 스레드가 즉시 다시 차단하고 통지 스레드가 잠금을 해제하기를 기다리므로 실제로 그렇게하는 것은 비관 화입니다. 그러나 일부 구현 (특히 pthreads의 많은 구현)은 이러한 상황을 인식하고 대기 스레드를 조건 호출의 대기열에서 알림 호출 내의 뮤텍스의 대기열로 직접 깨우지 않고 전송함으로써 이러한 &quot;서둘러 대기&quot;시나리오를 피합니다. 쪽으로.</target>
        </trans-unit>
        <trans-unit id="d72947b7a5e5177d55e7da50e671e2cfaa9b935b" translate="yes" xml:space="preserve">
          <source>The null character (&lt;code&gt;'\0'&lt;/code&gt;, &lt;code&gt;L'\0'&lt;/code&gt;, &lt;code&gt;char16_t()&lt;/code&gt;, etc) is always appended to the string literal: thus, a string literal &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; is a &lt;code&gt;const char[6]&lt;/code&gt; holding the characters &lt;code&gt;'H'&lt;/code&gt;, &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'o'&lt;/code&gt;, and &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">널 문자 ( &lt;code&gt;'\0'&lt;/code&gt; , &lt;code&gt;L'\0'&lt;/code&gt; , &lt;code&gt;char16_t()&lt;/code&gt; 등)는 항상 문자열 리터럴에 추가됩니다. 따라서 문자열 리터럴 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; 는 문자 &lt;code&gt;'H'&lt;/code&gt; 를 보유 하는 &lt;code&gt;const char[6]&lt;/code&gt; , &lt;code&gt;'e'&lt;/code&gt; , &lt;code&gt;'l'&lt;/code&gt; , &lt;code&gt;'l'&lt;/code&gt; , &lt;code&gt;'o'&lt;/code&gt; 및 &lt;code&gt;'\0'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="faf4539050f33260142e5e1942efa29dd4846fe8" translate="yes" xml:space="preserve">
          <source>The null character was converted and stored.</source>
          <target state="translated">널 문자가 변환되어 저장되었습니다.</target>
        </trans-unit>
        <trans-unit id="248246a3944930a0737208d795018f3412610899" translate="yes" xml:space="preserve">
          <source>The null character was converted and stored. &lt;code&gt;src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">널 문자가 변환되어 저장되었습니다. &lt;code&gt;src&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 로 설정 되며 &lt;code&gt;*ps&lt;/code&gt; 는 초기 시프트 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c07d16928e24253bdda00754b26c48658241a00d" translate="yes" xml:space="preserve">
          <source>The null directive (&lt;code&gt;#&lt;/code&gt; followed by a line break) is allowed and has no effect.</source>
          <target state="translated">널 지시문 ( &lt;code&gt;#&lt;/code&gt; 뒤에 줄 바꿈)이 허용되며 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="025c68351e84ef6a409e2a0b3cccd1343af71a32" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CharT&lt;/code&gt; elements in the string.</source>
          <target state="translated">문자열 의 &lt;code&gt;CharT&lt;/code&gt; 요소 수</target>
        </trans-unit>
        <trans-unit id="ed5405dde434342736b19ab060ea61207493342f" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CharT&lt;/code&gt; elements in the view.</source>
          <target state="translated">뷰 의 &lt;code&gt;CharT&lt;/code&gt; 요소 수입니다 .</target>
        </trans-unit>
        <trans-unit id="e56138bf523de60c8f035f5f12250f1f8ed8ee0d" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;externT&lt;/code&gt; characters that would be consumed if converted by &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; until either all &lt;code&gt;from_end-from&lt;/code&gt; characters were consumed or &lt;code&gt;max&lt;/code&gt;&lt;code&gt;internT&lt;/code&gt; characters were produced, or a conversion error occurred.</source>
          <target state="translated">모든 &lt;code&gt;from_end-from&lt;/code&gt; 문자가 소비되거나 &lt;code&gt;max&lt;/code&gt; &lt;code&gt;internT&lt;/code&gt; 문자가 생성되거나 변환 오류가 발생할 때까지 &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; 의해 변환 될 때 소비 될 &lt;code&gt;externT&lt;/code&gt; 문자 수입니다 .</target>
        </trans-unit>
        <trans-unit id="7563f8961703d5358be5cd18a6c7fd7caeb16313" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;shared_ptr&lt;/code&gt; instances sharing the ownership of the managed object at the instant of the call.</source>
          <target state="translated">호출 즉시 관리 객체의 소유권을 공유하는 &lt;code&gt;shared_ptr&lt;/code&gt; 인스턴스 의 수입니다 .</target>
        </trans-unit>
        <trans-unit id="69061d2f8b406eee14a4cb45eba7155a2d754383" translate="yes" xml:space="preserve">
          <source>The number of bits in a bit field sets the limit to the range of values it can hold:</source>
          <target state="translated">비트 필드의 비트 수는 제한을 보유 할 수있는 값 범위로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3f9099e3c7d873d70b362e3a89df1f5709452578" translate="yes" xml:space="preserve">
          <source>The number of buckets in the container.</source>
          <target state="translated">컨테이너의 버킷 수입니다.</target>
        </trans-unit>
        <trans-unit id="c785090a06b869af10617d403684a6661945ed63" translate="yes" xml:space="preserve">
          <source>The number of bytes (between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;) that complete a valid multibyte character.</source>
          <target state="translated">유효한 멀티 바이트 문자를 완료하는 바이트 수 ( &lt;code&gt;1&lt;/code&gt; ~ &lt;code&gt;n&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="4be8b408517c6e0f5de03175a85f9c74465aa587" translate="yes" xml:space="preserve">
          <source>The number of bytes stored in the array object (including any shift sequences). This may be zero when &lt;code&gt;c8&lt;/code&gt; is not the final code unit in the UTF-8 representation of a code point.</source>
          <target state="translated">배열 객체에 저장된 바이트 수 (모든 쉬프트 시퀀스 포함). &lt;code&gt;c8&lt;/code&gt; 이 코드 포인트의 UTF-8 표현에서 최종 코드 단위가 아닌 경우에는 0 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b02eec6dc83ccdd83bcea1a56eb671b42ec3a69" translate="yes" xml:space="preserve">
          <source>The number of bytes written into the character array pointed to by &lt;code&gt;str&lt;/code&gt; not including the terminating &lt;code&gt;'\0'&lt;/code&gt; on success. If &lt;code&gt;count&lt;/code&gt; was reached before the entire string could be stored, &lt;code&gt;​0​&lt;/code&gt; is returned and the contents are undefined.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 문자 배열에 쓰여진 바이트 수는 성공시 종료 &lt;code&gt;'\0'&lt;/code&gt; 을 포함하지 않습니다 . 경우 &lt;code&gt;count&lt;/code&gt; 전체 문자열이 저장되기 전에 도달 한, &lt;code&gt;​0​&lt;/code&gt; 반환되고 내용이 정의되지 않은 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8967c57de8e646af979d9e3d24efce148b0348b" translate="yes" xml:space="preserve">
          <source>The number of characters actually extracted.</source>
          <target state="translated">실제로 추출 된 문자 수입니다.</target>
        </trans-unit>
        <trans-unit id="a55f46f0cba247803d518fc84899892627e6d13a" translate="yes" xml:space="preserve">
          <source>The number of characters available for non-blocking read (either the size of the get area or the number of characters ready for reading from the associated character sequence), or &lt;code&gt;-1&lt;/code&gt; if no characters are available in the associated sequence as far as &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; can tell.</source>
          <target state="translated">비 차단 읽기에 사용할 수있는 문자 수 (가져 오기 영역의 크기 또는 연관된 문자 순서에서 읽을 준비가 된 문자 수) 또는 &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; 까지 연관된 순서에서 문자를 사용할 수없는 경우 &lt;code&gt;-1&lt;/code&gt; ) ) 가 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ec083d621e3f753125e182fe5084fd848f34df3" translate="yes" xml:space="preserve">
          <source>The number of characters available for reading from the file, or &lt;code&gt;-1&lt;/code&gt; if the end of file was reached.</source>
          <target state="translated">파일에서 읽을 수있는 문자 수 또는 파일 끝에 도달 한 경우 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="daf9eb1b235764a22547b341d3cc6ad96b107014" translate="yes" xml:space="preserve">
          <source>The number of characters consumed by the most recent conversion operation.</source>
          <target state="translated">가장 최근의 변환 작업에서 사용한 문자 수입니다.</target>
        </trans-unit>
        <trans-unit id="31a745112d734fafc43f6e526f229e8cc0817594" translate="yes" xml:space="preserve">
          <source>The number of characters extracted by the last unformatted input operation.</source>
          <target state="translated">형식화되지 않은 마지막 입력 조작으로 추출 된 문자 수입니다.</target>
        </trans-unit>
        <trans-unit id="025f13559fc4a76405d90651c0e5de33b6d88a9a" translate="yes" xml:space="preserve">
          <source>The number of characters in the put area, or zero if nothing was output.</source>
          <target state="translated">넣기 영역의 문자 수 또는 아무것도 출력되지 않은 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="b36a0d1d6266f14401ce912fa34b84443739b9ed" translate="yes" xml:space="preserve">
          <source>The number of characters successfully read. If it is less than &lt;code&gt;count&lt;/code&gt; the input sequence has reached the end.</source>
          <target state="translated">읽은 문자 수 &lt;code&gt;count&lt;/code&gt; 보다 작 으면 입력 시퀀스가 ​​끝에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="755b4ee802930b67c7f96314436110b4b1007db7" translate="yes" xml:space="preserve">
          <source>The number of characters successfully written.</source>
          <target state="translated">성공적으로 쓴 문자 수입니다.</target>
        </trans-unit>
        <trans-unit id="0424ddfc94d33a5b039d2cf4e4fb1ccac4396955" translate="yes" xml:space="preserve">
          <source>The number of characters that are certainly available in the associated character sequence, or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;showmanyc&lt;/code&gt; can determine, without blocking, that no characters are available. If &lt;code&gt;showmanyc&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; will definitely return &lt;code&gt;Traits::eof&lt;/code&gt; or throw.</source>
          <target state="translated">연관된 문자 순서에서 확실히 사용 가능한 문자 수 또는 &lt;code&gt;showmanyc&lt;/code&gt; 가 문자를 사용할 수없는 것으로 차단하지 않고 결정할 수있는 경우 &lt;code&gt;-1&lt;/code&gt; 입니다. 만약 &lt;code&gt;showmanyc&lt;/code&gt; 반환 &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; 확실히 돌아갑니다 &lt;code&gt;Traits::eof&lt;/code&gt; 나 던져.</target>
        </trans-unit>
        <trans-unit id="572abc135ef958490a79fa0e1af5c7c67e142749" translate="yes" xml:space="preserve">
          <source>The number of characters written to the put area.</source>
          <target state="translated">넣기 영역에 쓴 문자 수입니다.</target>
        </trans-unit>
        <trans-unit id="be9d72f9b5ea67854905c61a719c823300aee734" translate="yes" xml:space="preserve">
          <source>The number of comparisons performed is logarithmic in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; (At most 2 * log</source>
          <target state="translated">수행 된 비교 횟수는 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 사이의 거리에서 로그입니다 (최대 2 * 로그).</target>
        </trans-unit>
        <trans-unit id="d7d13597f2fd284fd58cd626f0e7ce58b0a1966e" translate="yes" xml:space="preserve">
          <source>The number of comparisons performed is logarithmic in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; (At most log</source>
          <target state="translated">수행 된 비교의 수는 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 사이의 거리에서 로그입니다 (대부분의 로그에서)</target>
        </trans-unit>
        <trans-unit id="91c8ac1c75a7c617f2a0ac89cd3799820e4457ed" translate="yes" xml:space="preserve">
          <source>The number of digits between the &lt;code&gt;thousand-sep&lt;/code&gt;s (maximum size of &lt;code&gt;digits&lt;/code&gt;) is specified by the result of &lt;code&gt;&lt;a href=&quot;numpunct/grouping&quot;&gt;grouping()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;thousand-sep&lt;/code&gt; 사이의 자릿수 (최대 &lt;code&gt;digits&lt;/code&gt; )는 &lt;code&gt;&lt;a href=&quot;numpunct/grouping&quot;&gt;grouping()&lt;/a&gt;&lt;/code&gt; 의 결과에 의해 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f0b350cad560ae534bf63d3c358b99770cd98ec" translate="yes" xml:space="preserve">
          <source>The number of digits to be displayed after the decimal point. In common U.S. locales, this is the value &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">소수점 뒤에 표시 할 자릿수입니다. 일반적인 미국 로케일에서이 값은 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c33eec86884077ae614b5177f47626b4225aee87" translate="yes" xml:space="preserve">
          <source>The number of elements in &lt;code&gt;Ints&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ints&lt;/code&gt; 의 요소 수입니다 .</target>
        </trans-unit>
        <trans-unit id="8b450587ddfddf28cae24e2b30442386956861df" translate="yes" xml:space="preserve">
          <source>The number of elements in the bucket &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">버킷 &lt;code&gt;n&lt;/code&gt; 의 요소 수입니다 .</target>
        </trans-unit>
        <trans-unit id="fa1ca4d47e01f9e18e5e6074af9cfd49cb03a9d8" translate="yes" xml:space="preserve">
          <source>The number of elements in the container.</source>
          <target state="translated">컨테이너의 요소 수</target>
        </trans-unit>
        <trans-unit id="68853860c0d5a8f06c3b286e4f1020c334bca256" translate="yes" xml:space="preserve">
          <source>The number of elements in the span.</source>
          <target state="translated">범위에있는 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="20396f56c8e3a0c13e5e36b7f2622f3b64ae5d64" translate="yes" xml:space="preserve">
          <source>The number of elements removed.</source>
          <target state="translated">제거 된 요소 수</target>
        </trans-unit>
        <trans-unit id="57b03f33847e8f2cd5650b62940211a1dd591b64" translate="yes" xml:space="preserve">
          <source>The number of hard links for &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 에 대한 하드 링크 수입니다 .</target>
        </trans-unit>
        <trans-unit id="cce184fd3e4e941c3606117950b45af922d77f66" translate="yes" xml:space="preserve">
          <source>The number of hard links for the referred-to filesystem object.</source>
          <target state="translated">참조 된 파일 시스템 객체에 대한 하드 링크 수입니다.</target>
        </trans-unit>
        <trans-unit id="61f0b12e8e21833dacb834088dec03bd1d45a5bc" translate="yes" xml:space="preserve">
          <source>The number of increments needed to go from &lt;code&gt;first&lt;/code&gt; to &lt;code&gt;last&lt;/code&gt;. The value may be negative if random-access iterators are used and &lt;code&gt;first&lt;/code&gt; is reachable from &lt;code&gt;last&lt;/code&gt;(since C++11).</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 부터 &lt;code&gt;last&lt;/code&gt; 으로 증가하는 데 필요한 증분 수입니다 . 랜덤 액세스 반복기를 사용하고있는 경우이 값은 음수 일 수있다 &lt;code&gt;first&lt;/code&gt; 부터 도달 &lt;code&gt;last&lt;/code&gt; (11 ++ C입니다).</target>
        </trans-unit>
        <trans-unit id="50988967f711f6f1b94fadc8faa1c4123b2c14c3" translate="yes" xml:space="preserve">
          <source>The number of marked sub-expressions within the regular expression.</source>
          <target state="translated">정규 표현식 내에서 표시된 하위 표현식의 수입니다.</target>
        </trans-unit>
        <trans-unit id="c70fa04485fef696ceac1a34cbd7f1b495aed9ee" translate="yes" xml:space="preserve">
          <source>The number of submatches.</source>
          <target state="translated">부분 일치 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="d956e6449331c6b04b931088c9ef0870fa076aa0" translate="yes" xml:space="preserve">
          <source>The number of ticks for this duration.</source>
          <target state="translated">이 기간 동안의 틱 수입니다.</target>
        </trans-unit>
        <trans-unit id="d4eed26281a1ccba1c3fbe30a41dad631fb16096" translate="yes" xml:space="preserve">
          <source>The numbers that are supported by &lt;code&gt;std::numpunct&lt;/code&gt; have the format described below. Here &lt;code&gt;digit&lt;/code&gt; represents the radix set specified by the &lt;code&gt;fmtflags&lt;/code&gt; argument value, &lt;code&gt;thousands-sep&lt;/code&gt; and &lt;code&gt;decimal-point&lt;/code&gt; are the results of &lt;code&gt;&lt;a href=&quot;numpunct/thousands_sep&quot;&gt;thousands_sep()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numpunct/decimal_point&quot;&gt;decimal_point()&lt;/a&gt;&lt;/code&gt; functions respectively. The format of integer values is as follows:</source>
          <target state="translated">&lt;code&gt;std::numpunct&lt;/code&gt; 가 지원하는 숫자 는 아래 설명 된 형식을 갖습니다. 여기에서 &lt;code&gt;digit&lt;/code&gt; 는 &lt;code&gt;fmtflags&lt;/code&gt; 인수 값에 의해 지정된 기수 세트를 나타내며 , &lt;code&gt;thousands-sep&lt;/code&gt; -sep 및 &lt;code&gt;decimal-point&lt;/code&gt; 는 각각 bytes_sep &lt;code&gt;&lt;a href=&quot;numpunct/thousands_sep&quot;&gt;thousands_sep()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;numpunct/decimal_point&quot;&gt;decimal_point()&lt;/a&gt;&lt;/code&gt; 함수 의 결과입니다 . 정수 값의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9bab7274b85a85fa328c276ae190e2933c1da232" translate="yes" xml:space="preserve">
          <source>The numeric input overloads of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; if the end of the stream was encountered while reading the next character, on Stage 2 of &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;num_get::get&lt;/code&gt;&lt;/a&gt; processing. Depending on the parsing state, &lt;code&gt;failbit&lt;/code&gt; may or may not be set at the same time: for example, &lt;code&gt;int n; istringstream buf(&quot;1&quot;); buf &amp;gt;&amp;gt; n;&lt;/code&gt; sets &lt;code&gt;eofbit&lt;/code&gt;, but not &lt;code&gt;failbit&lt;/code&gt;: the integer &lt;code&gt;1&lt;/code&gt; was successfully parsed and stored in &lt;code&gt;n&lt;/code&gt;. On the other hand, &lt;code&gt;bool b; istringstream buf(&quot;tr&quot;); buf &amp;gt;&amp;gt; boolalpha &amp;gt;&amp;gt; b;&lt;/code&gt; sets both &lt;code&gt;eofbit&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt;: there was not enough characters to complete the parsing of the boolean &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;num_get::get&lt;/code&gt; &lt;/a&gt; 처리의 2 단계에서 다음 문자를 읽는 동안 스트림의 끝에 도달 한 경우 &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 숫자 입력 과부하 . 구문 분석 상태에 따라 &lt;code&gt;failbit&lt;/code&gt; 가 동시에 설정되거나 설정되지 않을 수 있습니다. 예를 들어, &lt;code&gt;int n; istringstream buf(&quot;1&quot;); buf &amp;gt;&amp;gt; n;&lt;/code&gt; &lt;code&gt;eofbit&lt;/code&gt; 을 설정 하지만 &lt;code&gt;failbit&lt;/code&gt; 는 설정 하지 않음 : 정수 &lt;code&gt;1&lt;/code&gt; 이 구문 분석되고 &lt;code&gt;n&lt;/code&gt; 에 저장되었습니다 . 한편, &lt;code&gt;bool b; istringstream buf(&quot;tr&quot;); buf &amp;gt;&amp;gt; boolalpha &amp;gt;&amp;gt; b;&lt;/code&gt; &lt;code&gt;eofbit&lt;/code&gt; 와 &lt;code&gt;failbit&lt;/code&gt; 를 모두 설정: 부울 &lt;code&gt;true&lt;/code&gt; 의 구문 분석을 완료 할 수있는 문자가 충분하지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="1d4dfe124ae3866d608f524aa57220b740c6faaa" translate="yes" xml:space="preserve">
          <source>The numeric value if &lt;code&gt;ch&lt;/code&gt; indeed represents a digit in the currently imbued locale that is valid for the numeric base &lt;code&gt;radix&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 가 참으로 숫자 값 은 현재 기본이 적용된 로케일에서 숫자 기본 &lt;code&gt;radix&lt;/code&gt; 유효한 숫자 이거나 오류시 &lt;code&gt;-1&lt;/code&gt; 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cea1f54bd02da8f425b152ab8d2a7f0fbeca2475" translate="yes" xml:space="preserve">
          <source>The numeric, pointer, and boolean input overloads of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; (technically, the overloads of &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;num_get::get&lt;/code&gt;&lt;/a&gt; they call), if the input cannot be parsed as a valid value or if the value parsed does not fit in the destination type.</source>
          <target state="translated">의 숫자, 포인터, 및 부울 입력 과부하 &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; (기술적의 과부하 &lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;num_get::get&lt;/code&gt; &lt;/a&gt; 들이 호출), 입력은 올바른 값으로 또는 경우에 해석 할 수없는 경우에 맞지 않는 분석 값 대상 유형.</target>
        </trans-unit>
        <trans-unit id="0220d8c40333a0093943bf969db90f89079c2dd9" translate="yes" xml:space="preserve">
          <source>The object</source>
          <target state="translated">목적</target>
        </trans-unit>
        <trans-unit id="984c0e6a80490ef643982434d691b02d8e724169" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;u&lt;/code&gt; is &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialized&lt;/a&gt;</source>
          <target state="translated">객체 &lt;code&gt;u&lt;/code&gt; 는 &lt;a href=&quot;../language/default_initialization&quot;&gt;기본적으로 초기화됩니다&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60fdf35addca2d2e61228bbe293b020ce2b060c9" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;u&lt;/code&gt; is &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; or &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">객체 &lt;code&gt;u&lt;/code&gt; 는 &lt;a href=&quot;../language/value_initialization&quot;&gt;값이 초기화&lt;/a&gt; 되거나 &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;집계가 초기화&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="d66e0c5c8edf403a2575eab1d9bd1a5f03140bf4" translate="yes" xml:space="preserve">
          <source>The object created by a new-expression is initialized according to the following rules:</source>
          <target state="translated">새 표현식으로 작성된 오브젝트는 다음 규칙에 따라 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="6a3691e4261c0727fb8c31da0443f64d25b8f791" translate="yes" xml:space="preserve">
          <source>The object denoted by the glvalue is not accessed if:</source>
          <target state="translated">다음과 같은 경우 glvalue로 표시된 객체에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25231b05a1580da27ff890c7619a820a11b0eb7b" translate="yes" xml:space="preserve">
          <source>The object is default-initialized.</source>
          <target state="translated">개체는 기본적으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="43048e7b920911676623be86d837ae144bd2a9c0" translate="yes" xml:space="preserve">
          <source>The object is destroyed using &lt;a href=&quot;../language/delete&quot;&gt;&lt;code&gt;delete-expression&lt;/code&gt;&lt;/a&gt; or a custom deleter that is supplied to &lt;code&gt;shared_ptr&lt;/code&gt; during construction.</source>
          <target state="translated">생성 중에 delete_expression 또는 &lt;code&gt;shared_ptr&lt;/code&gt; 에 제공되는 사용자 정의 &lt;a href=&quot;../language/delete&quot;&gt; &lt;code&gt;delete-expression&lt;/code&gt; &lt;/a&gt; 기를 사용하여 오브젝트가 삭제 됩니다.</target>
        </trans-unit>
        <trans-unit id="ff26c6e45a2e565960b0a55f98032b59b34935b9" translate="yes" xml:space="preserve">
          <source>The object is disposed of using a potentially user-supplied deleter by calling &lt;code&gt;get_deleter()(ptr)&lt;/code&gt;. The default deleter uses the &lt;code&gt;delete&lt;/code&gt; operator, which destroys the object and deallocates the memory.</source>
          <target state="translated">객체는 &lt;code&gt;get_deleter()(ptr)&lt;/code&gt; 호출하여 잠재적으로 사용자 제공 삭제기를 사용하여 폐기 됩니다. 기본 &lt;code&gt;delete&lt;/code&gt; 기는 객체를 삭제하고 메모리 할당을 해제하는 delete 연산자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3d70e838df487033e13d3e82fefeabf6dda9f65a" translate="yes" xml:space="preserve">
          <source>The object is disposed of using the associated deleter when either of the following happens:</source>
          <target state="translated">객체는 다음 중 하나가 발생할 때 관련 삭제기를 사용하여 폐기됩니다.</target>
        </trans-unit>
        <trans-unit id="6079965a1e8cbec0fa1c764e9dc6325a1f66300d" translate="yes" xml:space="preserve">
          <source>The object is initialized with/assigned from a value of type &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;optional&lt;/code&gt; object that</source>
          <target state="translated">오브젝트가 초기화 / 유형의 값에서 할당하는 것은 &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;optional&lt;/code&gt; 오브젝트 그</target>
        </trans-unit>
        <trans-unit id="2eb07629fc5eb59fd1eeea479f34c50d51c4b7cf" translate="yes" xml:space="preserve">
          <source>The object is initialized with/assigned from a value of type &lt;code&gt;T&lt;/code&gt; or another &lt;code&gt;optional&lt;/code&gt; that</source>
          <target state="translated">오브젝트가 초기화되는 / 타입의 값으로부터 할당 &lt;code&gt;T&lt;/code&gt; 또는 다른 &lt;code&gt;optional&lt;/code&gt; 이</target>
        </trans-unit>
        <trans-unit id="106e7472fad2690d4a66e2210e0161c76f0e3d6c" translate="yes" xml:space="preserve">
          <source>The object of type &lt;a href=&quot;../money_base&quot;&gt;&lt;code&gt;std::money_base::format&lt;/code&gt;&lt;/a&gt; describing the formatting used by this locale.</source>
          <target state="translated">이 로케일이 사용하는 &lt;a href=&quot;../money_base&quot;&gt; &lt;code&gt;std::money_base::format&lt;/code&gt; &lt;/a&gt; 설명하는 std :: money_base :: format 유형의 오브젝트입니다 .</target>
        </trans-unit>
        <trans-unit id="a2654facce30fa17d2f2a6f53431efdc1fad3b19" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; holding the groups. The standard specializations of &lt;code&gt;std::moneypunct&lt;/code&gt; return an empty string, indicating no grouping. Typical groupings (e.g. the &lt;code&gt;en_US&lt;/code&gt; locale) return &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">그룹을 보유하는 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 유형의 오브젝트입니다 . &lt;code&gt;std::moneypunct&lt;/code&gt; 의 표준 전문화는 그룹화가 없음을 나타내는 빈 문자열을 리턴합니다. 일반적인 그룹화 (예 : &lt;code&gt;en_US&lt;/code&gt; 로캘)는 &lt;code&gt;&quot;\003&quot;&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2953e9f8be35412309323e09c4560896f13bada8" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; holding the groups. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return an empty string, indicating no grouping. Typical groupings (e.g. the &lt;code&gt;en_US&lt;/code&gt; locale) return &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">그룹을 보유하는 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 유형의 오브젝트입니다 . &lt;code&gt;std::numpunct&lt;/code&gt; 의 표준 특수화는 그룹화가 없음을 나타내는 빈 문자열을 반환합니다. 일반적인 그룹화 (예 : &lt;code&gt;en_US&lt;/code&gt; 로캘)는 &lt;code&gt;&quot;\003&quot;&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9f2911ed4a3e7e4e904c59b8350c8e9466228f6c" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;CharT&lt;/code&gt; holding the decimal point character.</source>
          <target state="translated">소수점 문자를 포함하는 &lt;code&gt;CharT&lt;/code&gt; 유형의 오브젝트입니다 .</target>
        </trans-unit>
        <trans-unit id="4f95c2c5399637a34a9ee8645410f77e300b41a0" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;char_type&lt;/code&gt; to use as the thousands separator. In common U.S. locales, this is &lt;code&gt;','&lt;/code&gt; or &lt;code&gt;L','&lt;/code&gt;.</source>
          <target state="translated">천 단위 구분 기호로 사용할 &lt;code&gt;char_type&lt;/code&gt; 유형의 개체입니다 . 일반적인 미국 로케일에서 이는 &lt;code&gt;','&lt;/code&gt; 또는 &lt;code&gt;L','&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="80bb88b1b4433caf62a715152b1b50f8ad2b9e79" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;char_type&lt;/code&gt; to use as the thousands separator. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;','&lt;/code&gt; and &lt;code&gt;L','&lt;/code&gt;.</source>
          <target state="translated">천 단위 구분 기호로 사용할 &lt;code&gt;char_type&lt;/code&gt; 유형의 개체입니다 . &lt;code&gt;std::numpunct&lt;/code&gt; 의 표준 전문화는 &lt;code&gt;','&lt;/code&gt; 및 &lt;code&gt;L','&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a260dce16a0baabc887328041b098cae9e79f602" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;string_type&lt;/code&gt; holding the currency symbol or code.</source>
          <target state="translated">통화 기호 또는 코드를 포함하는 &lt;code&gt;string_type&lt;/code&gt; 유형의 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="16c53b267fd0abe28bee8b120878e85d544083a4" translate="yes" xml:space="preserve">
          <source>The object or the type declared by such a declaration will have its &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirement&lt;/a&gt; equal to the strictest (largest) non-zero expression of all &lt;code&gt;alignas&lt;/code&gt; specifiers used in the declaration, unless it would weaken the natural alignment of the type.</source>
          <target state="translated">이러한 선언에 의해 선언 된 객체 또는 형식은 형식 의 자연적인 정렬을 약화시키지 않는 한 선언에 사용 된 모든 &lt;code&gt;alignas&lt;/code&gt; 지정자 의 가장 엄격한 (가장 큰) 0이 아닌 표현과 동일한 &lt;a href=&quot;objects#Alignment&quot;&gt;정렬 요구 사항을&lt;/a&gt; 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="50b34d11b1100c8ed664baedbf8283fc21bb891d" translate="yes" xml:space="preserve">
          <source>The objects are locked by an unspecified series of calls to &lt;code&gt;lock&lt;/code&gt;, &lt;code&gt;try_lock&lt;/code&gt;, and &lt;code&gt;unlock&lt;/code&gt;. If a call to &lt;code&gt;lock&lt;/code&gt; or &lt;code&gt;unlock&lt;/code&gt; results in an exception, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects before rethrowing.</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; , &lt;code&gt;try_lock&lt;/code&gt; 및 &lt;code&gt;unlock&lt;/code&gt; 에 대한 지정되지 않은 일련의 호출로 객체가 잠 깁니다 . &lt;code&gt;lock&lt;/code&gt; 또는 &lt;code&gt;unlock&lt;/code&gt; 호출로 인해 예외가 발생하면 다시 던지기 전에 잠긴 오브젝트에 대해 &lt;code&gt;unlock&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="833b82da6caa8dd8aeb20cf9477fe5f85be57f81" translate="yes" xml:space="preserve">
          <source>The objects created by new-expressions (objects with dynamic storage duration) persist until the pointer returned by the new-expression is used in a matching &lt;a href=&quot;delete&quot;&gt;delete-expression&lt;/a&gt;. If the original value of pointer is lost, the object becomes unreachable and cannot be deallocated: a</source>
          <target state="translated">new-expression으로 생성 된 객체 (동적 저장 기간이있는 객체)는 new-expression에서 반환 한 포인터가 일치하는 &lt;a href=&quot;delete&quot;&gt;delete-expression에&lt;/a&gt; 사용될 때까지 지속됩니다 . 포인터의 원래 값이 손실되면 객체에 도달 할 수없고 할당을 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2967e2fb3ae07f3f5e3a1fec435ab589fa1f55b" translate="yes" xml:space="preserve">
          <source>The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">객체는 겹칠 수 있습니다. 문자가 임시 문자 배열로 복사 된 다음 문자가 배열에서 &lt;code&gt;dest&lt;/code&gt; 로 복사 된 것처럼 복사가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a17a553ce0d57587be0e8416824c075ef07c922" translate="yes" xml:space="preserve">
          <source>The obtained character on success or &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">성공시 획득 한 문자 또는 실패시 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04be47c26eb26c26238109edcd20d6d4d1bb0dc8" translate="yes" xml:space="preserve">
          <source>The obtained wide character or &lt;code&gt;WEOF&lt;/code&gt; if an error has occurred or the end of file reached.</source>
          <target state="translated">오류가 발생했거나 파일 끝에 도달하면 넓은 문자 또는 &lt;code&gt;WEOF&lt;/code&gt; 를 얻 습니다.</target>
        </trans-unit>
        <trans-unit id="2110df2bf8befabdd98eb59b3910b478af8f2dcc" translate="yes" xml:space="preserve">
          <source>The official document on Feature Test Recommendations</source>
          <target state="translated">기능 테스트 권장 사항에 대한 공식 문서</target>
        </trans-unit>
        <trans-unit id="f708415e16cfe9e7bf1990f786292e4c9e381ac6" translate="yes" xml:space="preserve">
          <source>The offset of the first member of a standard-layout type is always zero (&lt;a href=&quot;../language/ebo&quot;&gt;empty-base optimization&lt;/a&gt; is mandatory).</source>
          <target state="translated">표준 레이아웃 유형의 첫 번째 멤버의 오프셋은 항상 0입니다 ( &lt;a href=&quot;../language/ebo&quot;&gt;빈베이스 최적화&lt;/a&gt; 는 필수 임).</target>
        </trans-unit>
        <trans-unit id="607857504a9e70bca8a47464af6277ec197d69cc" translate="yes" xml:space="preserve">
          <source>The old value of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 의 이전 값 .</target>
        </trans-unit>
        <trans-unit id="3d886bb54edd589fbd6ce35fc4f8d5d2fed63519" translate="yes" xml:space="preserve">
          <source>The only data stored in a &lt;code&gt;duration&lt;/code&gt; is a tick count of type &lt;code&gt;Rep&lt;/code&gt;. If &lt;code&gt;Rep&lt;/code&gt; is floating point, then the &lt;code&gt;duration&lt;/code&gt; can represent fractions of ticks. &lt;code&gt;Period&lt;/code&gt; is included as part of the duration's type, and is only used when converting between different durations.</source>
          <target state="translated">&lt;code&gt;duration&lt;/code&gt; 저장된 유일한 데이터 는 &lt;code&gt;Rep&lt;/code&gt; 유형의 틱 수입니다 . 경우 &lt;code&gt;Rep&lt;/code&gt; 부동 소수점 인, 그 &lt;code&gt;duration&lt;/code&gt; 진드기의 분수를 나타낼 수 있습니다. &lt;code&gt;Period&lt;/code&gt; 은 기간 유형의 일부로 포함되며 다른 기간간에 변환 할 때만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b2218d6760efda73de78e40ceb5f652b71248a9b" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;std::nearbyint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;std::nearbyint&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::nearbyint&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; 의 유일한 차이점은 std :: nearbyint 가 결코 &lt;code&gt;std::nearbyint&lt;/code&gt; 시키지 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="50d45e1a42306e63fbd2dd995b7cef21bbf82264" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;std::rint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::rint&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; 의 유일한 차이점은 std :: nearbyint 가 결코 &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; 시키지 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb56d0a76a6c53bff26b5b866f1ad038bed2665b" translate="yes" xml:space="preserve">
          <source>The only exceptions are that non-type template parameters of</source>
          <target state="translated">유일한 예외는 비 유형 템플릿 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="f6e8829ff8f2f1e7710d51780b5775f091279131" translate="yes" xml:space="preserve">
          <source>The only specifier that is allowed to appear twice in a decl-specifier-seq is &lt;code&gt;long&lt;/code&gt; (which can appear twice). All other repeats, such as &lt;code&gt;const static const&lt;/code&gt;, or &lt;code&gt;virtual inline virtual&lt;/code&gt; are errors.</source>
          <target state="translated">decl-specifier-seq에 두 번 나타날 수있는 유일한 지정자는 &lt;code&gt;long&lt;/code&gt; (두 번 나타날 수 있음). &lt;code&gt;const static const&lt;/code&gt; 또는 &lt;code&gt;virtual inline virtual&lt;/code&gt; 과 같은 다른 모든 반복 은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="776dd59d6ff8d1a9ef4d3f03ca55cae7469eb4a0" translate="yes" xml:space="preserve">
          <source>The only specifiers allowed in the decl-specifier-seq of a constructor declaration are &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt;, &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;, &lt;code&gt;explicit&lt;/code&gt; and &lt;code&gt;constexpr&lt;/code&gt; (in particular, no return type is allowed). Note that &lt;a href=&quot;member_functions&quot;&gt;cv- and ref-qualifiers&lt;/a&gt; are not allowed either; const and volatile semantics of an object under construction don't kick in until the most-derived constructor completes.</source>
          <target state="translated">생성자 선언의 decl-specifier-seq에 허용되는 유일한 지정자는 &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; , &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; , &lt;code&gt;explicit&lt;/code&gt; 및 &lt;code&gt;constexpr&lt;/code&gt; 입니다 (특히 반환 유형은 허용되지 않음). 참고 &lt;a href=&quot;member_functions&quot;&gt;cv- 및 REF-예선이&lt;/a&gt; 중 하나를 사용할 수 없습니다; 생성중인 객체의 const 및 휘발성 의미는 가장 파생 된 생성자가 완료 될 때까지 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d61491cad2b2617e213366873d893b816a75646e" translate="yes" xml:space="preserve">
          <source>The only standard &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; member constant &lt;code&gt;is_always_lock_free&lt;/code&gt; is also provided by this specialization.</source>
          <target state="translated">이 표준에서는 유일한 표준 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 멤버 상수 &lt;code&gt;is_always_lock_free&lt;/code&gt; 도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b892e85a0c7fdd49003290d933695bc0a6e29fec" translate="yes" xml:space="preserve">
          <source>The only standard library components that throw this exception are &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/from_bytes&quot;&gt;std::wstring_convert::from_bytes&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/to_bytes&quot;&gt;std::wstring_convert::to_bytes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예외를 발생시키는 유일한 표준 라이브러리 구성 요소는 &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/from_bytes&quot;&gt;std::wstring_convert::from_bytes&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/to_bytes&quot;&gt;std::wstring_convert::to_bytes&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c2e814e1afd8365ad73dca6904c0b4c6f214183c" translate="yes" xml:space="preserve">
          <source>The only standard library components that throw this exception are &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ulong&quot;&gt;std::bitset::to_ulong&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ullong&quot;&gt;std::bitset::to_ullong&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예외를 발생시키는 유일한 표준 라이브러리 구성 요소는 &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ulong&quot;&gt;std::bitset::to_ulong&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ullong&quot;&gt;std::bitset::to_ullong&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3648d0d11e1d50129adc447f795d03447db5902" translate="yes" xml:space="preserve">
          <source>The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly const-qualified, but not volatile-qualified).</source>
          <target state="translated">사소하게 복사 가능한 유일한 유형은 스칼라 유형, 사소하게 복사 가능한 클래스 및 이러한 유형 / 클래스의 배열입니다 (아마도 const로 한정되었지만 휘발성으로 한정되지는 않음).</target>
        </trans-unit>
        <trans-unit id="b25a51f5e3f4b6ece2ce4ed04dda4a2b91159629" translate="yes" xml:space="preserve">
          <source>The only valid use of &lt;code&gt;operator*&lt;/code&gt; with an output iterator is on the left of an assignment: &lt;code&gt;operator*&lt;/code&gt; may return a proxy object, which defines a member &lt;code&gt;operator=&lt;/code&gt; (which may be a template).</source>
          <target state="translated">출력 반복자와 함께 &lt;code&gt;operator*&lt;/code&gt; 를 유일하게 사용 하는 것은 할당의 왼쪽에 있습니다. &lt;code&gt;operator*&lt;/code&gt; 는 멤버 &lt;code&gt;operator=&lt;/code&gt; (템플릿 일 수 있음) 를 정의하는 프록시 객체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9566ed81642e87a223297fba2ea3d2e3900b558" translate="yes" xml:space="preserve">
          <source>The only way to replace an allocator is copy-assignment, move-assignment, and swap:</source>
          <target state="translated">할당자를 교체하는 유일한 방법은 복사 할당, 이동 할당 및 스왑입니다.</target>
        </trans-unit>
        <trans-unit id="d1f3d8e5a7c4ed4c1fad80ee519fc4a484fdc734" translate="yes" xml:space="preserve">
          <source>The operand expr of a built-in postfix increment or decrement operator must be a modifiable (non-const) &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; of non-boolean arithmetic type or pointer to complete &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt;. The result is &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; copy of the original value of the operand. As a side-effect, for non-boolean operands, the expression &lt;code&gt;x++&lt;/code&gt; modifies the value of its operand as if by evaluating &lt;code&gt;x += 1&lt;/code&gt;, and the expression &lt;code&gt;x--&lt;/code&gt; modifies the value of its operand as if by evaluating &lt;code&gt;x -= 1&lt;/code&gt;. All arithmetic conversion rules and pointer arithmetic rules defined for &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; apply and determine the implicit conversion (if any) applied to the operand as well as the return type of the expression.</source>
          <target state="translated">내장 된 postfix 증가 또는 감소 연산자의 피연산자 expr은 수정 가능한 ( &lt;a href=&quot;value_category&quot;&gt;부정적&lt;/a&gt; 이지 않은 ) 비 부울 산술 유형의 값이거나 완전한 &lt;a href=&quot;type-id&quot;&gt;객체 유형에 대한&lt;/a&gt; 포인터 여야합니다 . 결과는 피연산자의 원래 값에 대한 &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; 사본입니다. 부울이 아닌 피연산자의 부작용으로, &lt;code&gt;x++&lt;/code&gt; 표현식 은 &lt;code&gt;x += 1&lt;/code&gt; 을 평가하는 것처럼 피연산자의 값을 수정하고 &lt;code&gt;x--&lt;/code&gt; 표현식은 x- &lt;code&gt;x -= 1&lt;/code&gt; 을 평가하는 것처럼 피연산자의 값을 수정합니다. . &lt;a href=&quot;operator_arithmetic&quot;&gt;산술 연산자에&lt;/a&gt; 대해 정의 된 모든 산술 변환 규칙 및 포인터 산술 규칙 피연산자에 적용된 암시 적 변환 (있는 경우)과 식의 반환 유형을 적용하고 결정합니다.</target>
        </trans-unit>
        <trans-unit id="46362931546b6ab532aa0058b79c1a3e9f6e3d4e" translate="yes" xml:space="preserve">
          <source>The operand expr of a built-in prefix increment or decrement operator must be a modifiable (non-const) &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; of non-boolean arithmetic type or pointer to complete &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt;. For non-boolean operands, the expression &lt;code&gt;++x&lt;/code&gt; is exactly equivalent to &lt;code&gt;x += 1&lt;/code&gt;, and the expression &lt;code&gt;--x&lt;/code&gt; is exactly equivalent to &lt;code&gt;x -= 1&lt;/code&gt;, that is, the prefix increment or decrement is an lvalue expression that identifies the modified operand. All arithmetic conversion rules and pointer arithmetic rules defined for &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; apply and determine the implicit conversion (if any) applied to the operand as well as the return type of the expression.</source>
          <target state="translated">내장 된 접두사 증분 또는 감소 연산자의 피연산자 expr은 수정 가능한 ( &lt;a href=&quot;value_category&quot;&gt;부정적&lt;/a&gt; 이지 않은 ) 비 부울 산술 유형의 값이거나 완전한 &lt;a href=&quot;type-id&quot;&gt;객체 유형에 대한&lt;/a&gt; 포인터 여야합니다 . 부울이 아닌 피연산자의 경우, &lt;code&gt;++x&lt;/code&gt; 표현식 은 &lt;code&gt;x += 1&lt;/code&gt; 과 정확히 동일하며 &lt;code&gt;--x&lt;/code&gt; 표현식 은 &lt;code&gt;x -= 1&lt;/code&gt; 과 정확히 동일합니다 . 즉, 접두사 증가 또는 감소는 lvalue 표현식입니다. 수정 된 피연산자 &lt;a href=&quot;operator_arithmetic&quot;&gt;산술 연산자에&lt;/a&gt; 대해 정의 된 모든 산술 변환 규칙 및 포인터 산술 규칙 은 피연산자에 적용된 암시 적 변환 (있는 경우)과 식의 반환 유형을 적용하고 결정합니다.</target>
        </trans-unit>
        <trans-unit id="87d402fbb54b3649a9536c28ce47e12a587d6550" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;sizeof&lt;/code&gt; can't be a C-style type cast: the expression &lt;code&gt;sizeof (int) * p&lt;/code&gt; is unambiguously interpreted as &lt;code&gt;(sizeof(int)) * p&lt;/code&gt;, but not &lt;code&gt;sizeof((int)*p)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; 의 피연산자는 C 스타일 유형 캐스트 ​​일 수 없습니다. 표현식 &lt;code&gt;sizeof (int) * p&lt;/code&gt; 는 명확하게 &lt;code&gt;(sizeof(int)) * p&lt;/code&gt; 로 해석 되지만 &lt;code&gt;sizeof((int)*p)&lt;/code&gt; 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="085c6a701b7e7a71f8bd49b79840a23c53c15e50" translate="yes" xml:space="preserve">
          <source>The operand of the built-in indirection operator must be pointer to object or a pointer to function, and the result is the lvalue referring to the pointer or function to which expr points.</source>
          <target state="translated">내장 된 간접 연산자의 피연산자는 객체에 대한 포인터이거나 함수에 대한 포인터 여야하며 결과는 expr이 가리키는 포인터 또는 함수를 참조하는 lvalue입니다.</target>
        </trans-unit>
        <trans-unit id="a41ba177e9a175366d24e342abbe5cb594a72284" translate="yes" xml:space="preserve">
          <source>The operands of any operator may be other expressions or primary expressions (e.g. in &lt;code&gt;1+2*3&lt;/code&gt;, the operands of operator+ are the subexpression &lt;code&gt;2*3&lt;/code&gt; and the primary expression &lt;code&gt;1&lt;/code&gt;).</source>
          <target state="translated">임의의 연산자의 피연산자는 다른 표현식 또는 기본 표현식 일 수 있습니다 (예 : &lt;code&gt;1+2*3&lt;/code&gt; 에서 operator +의 피연산자는 하위 표현식 &lt;code&gt;2*3&lt;/code&gt; 및 기본 표현식 &lt;code&gt;1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d012c764a34c8f374b29407cde1eb1fdbb47c2a6" translate="yes" xml:space="preserve">
          <source>The operands of the operators &lt;a href=&quot;typeid&quot;&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;sizeof&quot;&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;noexcept&quot;&gt;&lt;code&gt;noexcept&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;decltype&quot;&gt;&lt;code&gt;decltype&lt;/code&gt;&lt;/a&gt;(since C++11) are expressions that are not evaluated (unless they are polymorphic glvalues and are the operands of &lt;code&gt;typeid&lt;/code&gt;), since these operators only query the compile-time properties of their operands. Thus, &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 42);&lt;/code&gt; does not perform console output.</source>
          <target state="translated">연산자 &lt;a href=&quot;typeid&quot;&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;sizeof&quot;&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;noexcept&quot;&gt; &lt;code&gt;noexcept&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;decltype&quot;&gt; &lt;code&gt;decltype&lt;/code&gt; &lt;/a&gt; (C ++ 11부터)의 피연산자는 평가되지 않는 표현식입니다 (다형성 glvalue이고 &lt;code&gt;typeid&lt;/code&gt; 의 피연산자가 아닌 한 ).이 연산자는 컴파일 타임 속성 만 쿼리하므로 피연산자의. 따라서 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 42);&lt;/code&gt; 콘솔 출력을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85054a8ab24569b5d580787ed8730ffc9c0905a7" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;set_exception_at_thread_exit&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">작업은 &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;set_exception_at_thread_exit&lt;/code&gt; 가 promise 객체를 업데이트하는 동안 promise 객체와 관련된 단일 뮤텍스를 획득하는 것처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="ff918beb1f805c40357e0f6201e33f727cf409ae" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;set_value_at_thread_exit&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">작업은 &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;set_value_at_thread_exit&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; 가 promise 객체를 업데이트하는 동안 promise 객체와 관련된 단일 뮤텍스를 획득하는 것처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="0dc1d1f6cd97262d10d4163c6f4669641d9589c9" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;set_exception&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">작업은 &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;set_exception&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; 가 promise 객체를 업데이트하는 동안 promise 객체와 관련된 단일 뮤텍스를 획득하는 것처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="894be649e20a0f667a76b29adef6436e4b7cbd04" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;set_value&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">작업은 &lt;code&gt;set_value&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; 가 promise 객체를 업데이트하는 동안 promise 객체와 관련된 단일 뮤텍스를 획득하는 것처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="ada6c00780096e7ea571132eafd7f86af9d8f166" translate="yes" xml:space="preserve">
          <source>The operation is performed as if the following is executed:</source>
          <target state="translated">다음과 같이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9c665cf102b9a36a3c0f45e7d1968e4deab591b0" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;operator!&lt;/code&gt; is commonly overloaded by the user-defined classes that are intended to be used in boolean contexts. Such classes also provide a user-defined conversion function &lt;code&gt;explicit operator bool()&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; for the standard library example), and the expected behavior of &lt;code&gt;operator!&lt;/code&gt; is to return the value opposite of &lt;code&gt;operator bool&lt;/code&gt;.</source>
          <target state="translated">운영자 &lt;code&gt;operator!&lt;/code&gt; 부울 컨텍스트에서 사용되도록 사용자 정의 클래스에 의해 일반적으로 오버로드됩니다. 이러한 클래스는 또한 사용자 정의 변환 함수 &lt;code&gt;explicit operator bool()&lt;/code&gt; ( 표준 라이브러리 예는 &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; 참조 )과 &lt;code&gt;operator!&lt;/code&gt; 의 예상 동작을 제공합니다 ! &lt;code&gt;operator bool&lt;/code&gt; 과 반대되는 값을 반환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f80c851a7fa156f63455e4364c3b3e9685929eb0" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;::&lt;/code&gt; (scope resolution), &lt;code&gt;.&lt;/code&gt; (member access), &lt;code&gt;.*&lt;/code&gt; (member access through pointer to member), and &lt;code&gt;?:&lt;/code&gt; (ternary conditional) cannot be overloaded.</source>
          <target state="translated">운영자 &lt;code&gt;::&lt;/code&gt; (범위 해상도) &lt;code&gt;.&lt;/code&gt; (멤버 액세스) &lt;code&gt;.*&lt;/code&gt; (멤버에 대한 포인터를 통한 멤버 액세스) 및 &lt;code&gt;?:&lt;/code&gt; 삼항 조건부)를 오버로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aac712726a5efd650938a3acaadc33f6fc3919ae" translate="yes" xml:space="preserve">
          <source>The order of destruction of non-local variables is described in &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">로컬이 아닌 변수의 제거 순서는 &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="35758388f82a3ab09aa2cb82071589277664456d" translate="yes" xml:space="preserve">
          <source>The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range &lt;code&gt;[middle, last)&lt;/code&gt; is unspecified.</source>
          <target state="translated">동일한 요소의 순서는 유지되지 않습니다. &lt;code&gt;[middle, last)&lt;/code&gt; 범위에있는 나머지 요소의 순서 는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b4e996418f65beaf879b200f677d977522bbc6c" translate="yes" xml:space="preserve">
          <source>The order of member initializers in the list is irrelevant: the actual order of initialization is as follows:</source>
          <target state="translated">목록의 멤버 이니셜 라이저 순서는 관련이 없습니다. 실제 초기화 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ee2462340320dfffdb2356e18adfc9d73dab60f" translate="yes" xml:space="preserve">
          <source>The order of the elements that are not erased is preserved. (This makes it possible to erase individual elements while iterating through the container.).</source>
          <target state="translated">지워지지 않은 요소의 순서는 유지됩니다. 이렇게하면 컨테이너를 반복하면서 개별 요소를 지울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45de463a3e1e66d3a48db307eb7e59ab651dcd8a" translate="yes" xml:space="preserve">
          <source>The order of the elements that compare equivalent is the order of insertion and does not change. (since C++11).</source>
          <target state="translated">동등한 것을 비교하는 요소의 순서는 삽입 순서이며 변경되지 않습니다. (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="abd27fd7960ecb4b3cee9ed3bc8fa827648946bf" translate="yes" xml:space="preserve">
          <source>The order of the key-value pairs whose keys compare equivalent is the order of insertion and does not change. (since C++11).</source>
          <target state="translated">키가 동등한 것을 비교하는 키-값 쌍의 순서는 삽입 순서이며 변경되지 않습니다. (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="a9ef10d36f3c0c975aa40ae381346f09fe5d7ab9" translate="yes" xml:space="preserve">
          <source>The ordering comparisons are done lexicographically -- the comparison is performed by a function equivalent to &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">순서 비교는 사전 식으로 수행됩니다. 비교는 &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt; 와 동등한 함수로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0966d7161405c174477a1237dbe2bf1df99477d" translate="yes" xml:space="preserve">
          <source>The ordering is strict weak ordering relation.</source>
          <target state="translated">주문은 엄격한 약한 주문 관계입니다.</target>
        </trans-unit>
        <trans-unit id="1f12ff5d7e6a675fd2031dd36912c9789309ddc9" translate="yes" xml:space="preserve">
          <source>The original intent of the &lt;code&gt;inline&lt;/code&gt; keyword was to serve as an indicator to the optimizer that &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_expansion&quot;&gt;inline substitution of a function&lt;/a&gt; is preferred over function call, that is, instead of executing the function call CPU instruction to transfer control to the function body, a copy of the function body is executed without generating the call. This avoids overhead created by the function call (passing the arguments and retrieving the result) but it may result in a larger executable as the code for the function has to be repeated multiple times.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 키워드 의 원래 의도는 &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_expansion&quot;&gt;함수의 인라인 대체가&lt;/a&gt; 함수 호출보다 우선 함 을 나타내는 옵티 마이저에 대한 표시기 역할을하는 것이 었습니다. 함수 본문은 호출을 생성하지 않고 실행됩니다. 이렇게하면 함수 호출에 의해 생성 된 오버 헤드가 발생하지 않으며 (인수를 전달하고 결과를 검색) 함수 코드를 여러 번 반복해야하므로 실행 파일이 더 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="083eed7b2639f184e8f8cd016a58c77c340553d1" translate="yes" xml:space="preserve">
          <source>The output iterator &lt;code&gt;std::raw_storage_iterator&lt;/code&gt; makes it possible for standard algorithms to store results in uninitialized memory. Whenever the algorithm writes an object of type &lt;code&gt;T&lt;/code&gt; to the dereferenced iterator, the object is copy-constructed into the location in the uninitialized storage pointed to by the iterator. The template parameter &lt;code&gt;OutputIt&lt;/code&gt; is any type that meets the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; and has &lt;code&gt;operator*&lt;/code&gt; defined to return an object, for which &lt;code&gt;operator&amp;amp;&lt;/code&gt; returns an object of type &lt;code&gt;T*&lt;/code&gt;. Usually, the type &lt;code&gt;T*&lt;/code&gt; is used as &lt;code&gt;OutputIt&lt;/code&gt;.</source>
          <target state="translated">출력 반복자 &lt;code&gt;std::raw_storage_iterator&lt;/code&gt; 사용하면 표준 알고리즘이 초기화되지 않은 메모리에 결과를 저장할 수 있습니다. 알고리즘이 &lt;code&gt;T&lt;/code&gt; 유형의 객체를 역 참조 된 반복기에 쓸 때마다 객체는 반복자가 가리키는 초기화되지 않은 저장소의 위치에 복사 구성됩니다. 파라미터 템플릿 &lt;code&gt;OutputIt&lt;/code&gt; 가 요건에 맞는 임의의 유형 &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator을&lt;/a&gt; 하고 보유 &lt;code&gt;operator*&lt;/code&gt; 객체를 반환하도록 정의되는 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 복귀 형의 목적 &lt;code&gt;T*&lt;/code&gt; . 일반적으로 &lt;code&gt;T*&lt;/code&gt; 유형 은 &lt;code&gt;OutputIt&lt;/code&gt; 으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e482ce31b119d64121012b0392dad700a664ac70" translate="yes" xml:space="preserve">
          <source>The outputs of an expression consist of its result and all operands modified by the expression (if any).</source>
          <target state="translated">표현식의 출력은 결과와 표현식에 의해 수정 된 모든 피연산자 (있는 경우)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9c85e268da67030ad87455310612ee6e33a42e99" translate="yes" xml:space="preserve">
          <source>The overload (3) only participates in overload resolution if &lt;code&gt;Sseq&lt;/code&gt; qualifies as a &lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;. In particular, it is excluded from the set of candidate functions if &lt;code&gt;Sseq&lt;/code&gt; is convertible to &lt;code&gt;result_type&lt;/code&gt;.</source>
          <target state="translated">경우 과부하 (3) 만 과부하 해상도에 참여 &lt;code&gt;Sseq&lt;/code&gt; 는 A와 자격 &lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt; . 특히 &lt;code&gt;Sseq&lt;/code&gt; 가 &lt;code&gt;result_type&lt;/code&gt; 으로 변환 가능한 경우 후보 함수 세트에서 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="06bb537d779118fbd7f2e14985ef313bb0e992d7" translate="yes" xml:space="preserve">
          <source>The overload (3) zeroes out elements of non-class types such as &lt;code&gt;int&lt;/code&gt;, which is different from the behavior of &lt;a href=&quot;../../language/new&quot;&gt;&lt;code&gt;new[]&lt;/code&gt;&lt;/a&gt;, which leaves them uninitialized. To match the behavior of &lt;code&gt;new[]&lt;/code&gt;, a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt; can be provided which leaves such elements uninitialized.</source>
          <target state="translated">오버로드 (3)는 &lt;code&gt;int&lt;/code&gt; 와 같은 비 클래스 유형의 요소를 0으로 만듭니다. 이는 &lt;a href=&quot;../../language/new&quot;&gt; &lt;code&gt;new[]&lt;/code&gt; &lt;/a&gt; 의 동작과 다르므로 초기화되지 않습니다. 의 동작을 일치 시키려면 &lt;code&gt;new[]&lt;/code&gt; 하는 &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;사용자 정의 할당 자 : 구조가&lt;/a&gt; 같은 요소가 초기화되지 않은 어떤 잎을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bf1e7ebfe0e6d90d794292aee13cc0558b63e2d" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns a pointer to the first element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;initializer_list&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; 의 과부하 는 &lt;code&gt;il&lt;/code&gt; 의 첫 번째 요소에 대한 포인터를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="038f0a2e5a071bb2843d1c518dc177b71222920c" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;valarray&lt;/code&gt; returns an iterator of unspecified type referring to the first element in the numeric array.</source>
          <target state="translated">&lt;code&gt;valarray&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; 의 과부하 는 숫자 형 배열의 첫 번째 요소를 참조하여 지정되지 않은 유형의 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="84c575ea93991f4dfe1b4bf2acfc46b67a8cd82c" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns a pointer to one past the last element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;initializer_list&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; 의 과부하 는 &lt;code&gt;il&lt;/code&gt; 의 마지막 요소를 지나서 포인터를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e3e880f9ab6d60647899982795a8dda9c2944720" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;valarray&lt;/code&gt; returns an iterator of unspecified type referring to the one past the last element in the numeric array.</source>
          <target state="translated">&lt;code&gt;valarray&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; 의 오버로드 는 숫자 배열의 마지막 요소를 지나는 것을 참조하여 지정되지 않은 유형의 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc73911917476c7646928434557b596727d6486b" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns an &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; pointing at the last element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;initializer_list&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; 의 과부하 는 &lt;code&gt;il&lt;/code&gt; 의 마지막 요소를 가리키는 &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ce6318ab93622dbaf9e7b41535ac8be907e21159" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns an &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; pointing at the first element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;initializer_list&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; 의 과부하 는 &lt;code&gt;il&lt;/code&gt; 의 첫 번째 요소를 가리키는 &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0c43a69d1f5e72f32062b0ff1de3c8b0d1df1068" translate="yes" xml:space="preserve">
          <source>The overload of operator &lt;code&gt;-&amp;gt;&lt;/code&gt; must either return a raw pointer, or return an object (by reference or by value) for which operator &lt;code&gt;-&amp;gt;&lt;/code&gt; is in turn overloaded.</source>
          <target state="translated">연산자의 과부하 &lt;code&gt;-&amp;gt;&lt;/code&gt; 중 원시 포인터를 리턴하거나 (참조 또는 값)하는 오퍼레이터 객체를 반환한다 &lt;code&gt;-&amp;gt;&lt;/code&gt; 차례로 과부하.</target>
        </trans-unit>
        <trans-unit id="59c7e08ff39317162bda21db4d04832d07f05332" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;../filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 과부하 는 첫 번째 경로 인수 로 &lt;code&gt;p&lt;/code&gt; 를 오류 코드 인수로 OS 오류 코드로 구성된 기본 OS API 오류에서 &lt;a href=&quot;../filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다 . &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; &amp;amp; 매개 변수 를 사용하는 과부하 는 OS API 호출이 실패하면이를 OS API 오류 코드로 설정하고 오류가 발생하지 않으면 &lt;code&gt;ec.clear()&lt;/code&gt; 실행 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68156db91adc064f5a1b3f123b0b56bb2aa82cf8" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;../filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 과부하 는 OS 오류 코드를 오류 코드 인수로 구성하여 기본 OS API 오류에서 &lt;a href=&quot;../filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다. 과부하 복용 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 는 OS API 호출이 실패하면이를 OS API 오류 코드로 설정하고 오류가 발생하지 않으면 &lt;code&gt;ec.clear()&lt;/code&gt; 실행 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a24af84b98cf1ff1037189e681754591d35e0d1f" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;from&lt;/code&gt; as the first path argument, &lt;code&gt;to&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">테이크하지 않습니다 과부하 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수가 발생 &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 로 구성 기본 OS의 API의 오류에 대한을 &lt;code&gt;from&lt;/code&gt; 첫 번째 경로 인수로 &lt;code&gt;to&lt;/code&gt; 두 번째 경로 인수 및 오류 코드 인수로 OS 오류 코드로. &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하는 과부하 는 OS API 호출이 실패하면이를 OS API 오류 코드로 설정하고 오류가 발생하지 않으면 &lt;code&gt;ec.clear()&lt;/code&gt; 실행 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c99e4f6d242cae156fe8c53c180077d5056a8e5" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;old_p&lt;/code&gt; as the first path argument, &lt;code&gt;new_p&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 과부하는 기본 OS API 오류에서 &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생 &lt;code&gt;old_p&lt;/code&gt; 를 첫 번째 경로 인수로, &lt;code&gt;new_p&lt;/code&gt; 를 두 번째 경로 인수로, OS 오류 코드를 오류 코드 인수로 구성합니다. OS API 호출이 실패하면 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하는 과부하가 이를 OS API 오류 코드로 설정하고 실행합니다. &lt;code&gt;ec.clear()&lt;/code&gt; 오류가 발생하지 않으면 ec.clear ()를 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0951321ca4ae56851938cae8c8021bfe0924467" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p1&lt;/code&gt; as the first path argument, &lt;code&gt;p2&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 과부하 는 첫 번째 경로 인수 로 &lt;code&gt;p1&lt;/code&gt; , 두 번째 경로 인수로 &lt;code&gt;p2&lt;/code&gt; 및 오류 코드 인수로 OS 오류 코드로 구성된 기본 OS API 오류에서 &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다 . &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; &amp;amp; 매개 변수 를 사용하는 과부하 는 OS API 호출이 실패하면이를 OS API 오류 코드로 설정하고 오류가 발생하지 않으면 &lt;code&gt;ec.clear()&lt;/code&gt; 실행 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="097925b28af9c725f044eb3f3ff1a0803fb41ab3" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 과부하 는 첫 번째 경로 인수 로 &lt;code&gt;p&lt;/code&gt; 를 오류 코드 인수로 OS 오류 코드로 구성된 기본 OS API 오류에서 &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다 . &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; &amp;amp; 매개 변수 를 사용하는 과부하 는 OS API 호출이 실패하면이를 OS API 오류 코드로 설정하고 오류가 발생하지 않으면 &lt;code&gt;ec.clear()&lt;/code&gt; 실행 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2743dce817550a96f75513fc032ccf30bdcdc608" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument, &lt;code&gt;base&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 과부하 는 첫 번째 경로 인수 로 &lt;code&gt;p&lt;/code&gt; , 두 번째 경로 인수로 &lt;code&gt;base&lt;/code&gt; 및 오류 코드 인수로 OS 오류 코드로 구성된 기본 OS API 오류에서 &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다 . &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; &amp;amp; 매개 변수 를 사용하는 과부하 는 OS API 호출이 실패하면이를 OS API 오류 코드로 설정하고 오류가 발생하지 않으면 &lt;code&gt;ec.clear()&lt;/code&gt; 실행 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45cad57e74ff3ba3f508e070185a6b0faa062d9c" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;path to be returned&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 과부하는 기본 OS API 오류에서 &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다. &lt;code&gt;path to be returned&lt;/code&gt; 는 첫 번째 경로 인수 로 리턴 되고 OS 오류 코드는 오류 코드 인수 로 리턴 됩니다. &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하는 과부하 는 OS API 호출이 실패하면이를 OS API 오류 코드로 설정하고 오류가 발생하지 않으면 &lt;code&gt;ec.clear()&lt;/code&gt; 실행 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63b27ca41e532a5a7a9cbe39b5246376a55b9912" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;target&lt;/code&gt; as the first path argument, &lt;code&gt;link&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 과부하는 기본 OS API 오류에서 &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다. &lt;code&gt;target&lt;/code&gt; 은 첫 번째 경로 인수로, &lt;code&gt;link&lt;/code&gt; 는 두 번째 경로 인수로, OS 오류 코드는 오류 코드 인수로 구성됩니다. OS API 호출이 실패하면 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하는 과부하가 이를 OS API 오류 코드로 설정하고 실행합니다. &lt;code&gt;ec.clear()&lt;/code&gt; 오류가 발생하지 않으면 ec.clear ()를 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b44057a826fb8d870cd4cdd23aeed9b3f71f525" translate="yes" xml:space="preserve">
          <source>The overload with a template parameter named &lt;code&gt;ExecutionPolicy&lt;/code&gt; reports errors as follows:</source>
          <target state="translated">&lt;code&gt;ExecutionPolicy&lt;/code&gt; 라는 템플릿 매개 변수를 사용하는 오버로드 는 다음과 같이 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="be64bc9e876275165a0c7eba9eb5ad84ea913bf6" translate="yes" xml:space="preserve">
          <source>The overloads (2-6) provide allocator propagation into &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;, which supports neither leading-allocator nor trailing-allocator calling conventions (unlike, e.g. &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, which uses leading-allocator convention).</source>
          <target state="translated">과부하 (2-6)는 할당 기 전파를 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; , 지원도 최고의-할당하거나 후행-할당 (예와는 달리 호출 규칙을 &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; , 어떤 용도 주요-할당 규칙을).</target>
        </trans-unit>
        <trans-unit id="684f3f556fb197adb926e01a526a9556d8043a2d" translate="yes" xml:space="preserve">
          <source>The overloads (5,6) are often implemented as a loop that calls the overload (3) with &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; as the hint; they are optimized for appending a sorted sequence (such as another set) whose smallest element is greater than the last element in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">과부하 (5,6)는 종종 과부하 (3)를 호출하는 루프로 구현됩니다. &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 를 힌트로. 가장 작은 요소가 &lt;code&gt;*this&lt;/code&gt; 의 마지막 요소보다 큰 정렬 된 시퀀스 (예 : 다른 세트)를 추가하도록 최적화되어있습니다.</target>
        </trans-unit>
        <trans-unit id="70d94f85af425ede81ffbbe7061489408578ee30" translate="yes" xml:space="preserve">
          <source>The overloads are marked as &lt;code&gt;constexpr&lt;/code&gt; since C++14.</source>
          <target state="translated">과부하는 C ++ 14 이후 &lt;code&gt;constexpr&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="44fe9b19e02fae03d565fc0de302ad3d97db79e7" translate="yes" xml:space="preserve">
          <source>The overloads not taking &lt;code&gt;opts&lt;/code&gt; as a parameter uses a default constructed instance of &lt;a href=&quot;../pool_options&quot;&gt;&lt;code&gt;pool_options&lt;/code&gt;&lt;/a&gt; as the options. The overloads not taking &lt;code&gt;upstream&lt;/code&gt; as a parameter uses the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; as the upstream memory resource.</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; 를 매개 변수로 사용 하지 않는 과부하 는 기본 생성 된 &lt;a href=&quot;../pool_options&quot;&gt; &lt;code&gt;pool_options&lt;/code&gt; &lt;/a&gt; 인스턴스를 옵션으로 사용합니다. 매개 변수로 &lt;code&gt;upstream&lt;/code&gt; 을 사용 하지 않는 과부하 는 &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; 업스트림 메모리 리소스로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5088ac896f932a6a0d4f549d22b00102f8ee7619" translate="yes" xml:space="preserve">
          <source>The overloads not taking &lt;code&gt;opts&lt;/code&gt; as a parameter uses a default constructed instance of &lt;a href=&quot;../pool_options&quot;&gt;&lt;code&gt;pool_options&lt;/code&gt;&lt;/a&gt; as the options. The overloads not taking &lt;code&gt;upstream&lt;/code&gt; as a parameter uses the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;&lt;/code&gt; as the upstream memory resource.</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; 를 매개 변수로 사용 하지 않는 과부하 는 기본 생성 된 &lt;a href=&quot;../pool_options&quot;&gt; &lt;code&gt;pool_options&lt;/code&gt; &lt;/a&gt; 인스턴스를 옵션으로 사용합니다. 오버로드는 복용하지 &lt;code&gt;upstream&lt;/code&gt; 을 매개 변수로 사용 는 &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;&lt;/code&gt; 의 반환 값을 업스트림 메모리 리소스로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8126e43884394c17d3457633c0894495b6f29864" translate="yes" xml:space="preserve">
          <source>The overloads of &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; that take a &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&amp;amp;&lt;/code&gt; as the left hand argument are known as insertion and extraction operators. Since they take the user-defined type as the right argument (&lt;code&gt;b&lt;/code&gt; in a@b), they must be implemented as non-members.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&amp;amp;&lt;/code&gt; &amp;amp; 또는 &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&amp;amp;&lt;/code&gt; 을 사용하는 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 의 과부하 &amp;amp; 을 왼쪽 인수로 삽입 및 추출 연산자라고합니다. 사용자 정의 유형을 올바른 인수 ( &lt;code&gt;b&lt;/code&gt; @ b에서 b)로 사용하므로 비 멤버로 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="435446cb476ebaebe355f8cf48105e0dddc8213e" translate="yes" xml:space="preserve">
          <source>The overloads of operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; lose short-circuit evaluation.</source>
          <target state="translated">연산자 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 의 과부하 및 &lt;code&gt;||&lt;/code&gt; 단락 평가를 잃습니다.</target>
        </trans-unit>
        <trans-unit id="c77c38e018a2a03f4663ee8fdfa0fd3a61518b4d" translate="yes" xml:space="preserve">
          <source>The overloads taking parameters named &lt;code&gt;pos1&lt;/code&gt; or &lt;code&gt;pos2&lt;/code&gt; throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if the argument is out of range.</source>
          <target state="translated">&lt;code&gt;pos1&lt;/code&gt; 또는 &lt;code&gt;pos2&lt;/code&gt; throw 라는 매개 변수를 사용하는 과부하 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 인수가 범위를 벗어난 경우입니다.</target>
        </trans-unit>
        <trans-unit id="15de6f30385481ec7a64ac4f54a04bf7a70486ea" translate="yes" xml:space="preserve">
          <source>The overloads that do not use &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; assume that each tuple argument becomes the element of a pair. The overloads that use &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; assume that each tuple argument is used to construct, piecewise, a new object of specified type, which will become the element of the pair.</source>
          <target state="translated">&lt;code&gt;std::piecewise_construct_t&lt;/code&gt; 사용하지 않는 과부하 각 튜플 인수가 쌍의 요소가된다고 가정합니다. &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; 를 사용하는 과부하는 각 튜플 인수가 지정된 유형의 새 객체를 구성하는 데 사용되며 쌍의 요소가 될 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b7bdb96b9c09362e092f33a4cbae2fe72c83f4e2" translate="yes" xml:space="preserve">
          <source>The overloads with a template parameter named &lt;code&gt;ExecutionPolicy&lt;/code&gt; report errors as follows:</source>
          <target state="translated">템플릿 매개 변수가있는 과부하 &lt;code&gt;ExecutionPolicy&lt;/code&gt; 는 다음과 같이 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="a864b224232c408c9511f10f7feafcbf33889a52" translate="yes" xml:space="preserve">
          <source>The override for the virtual member function &lt;code&gt;what()&lt;/code&gt; may by provided, but is not required.</source>
          <target state="translated">가상 멤버 함수에 대한 재정의 &lt;code&gt;what()&lt;/code&gt; 제공 될 수 있지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8d89be08f6f6c31578200be6591584e87d1fdf78" translate="yes" xml:space="preserve">
          <source>The overriders of &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt; functions do not acquire the default arguments from the base class declarations, and when the virtual function call is made, the default arguments are decided based on the static type of the object (note: this can be avoided with &lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;non-virtual interface&lt;/a&gt; pattern).</source>
          <target state="translated">&lt;a href=&quot;virtual&quot;&gt;가상&lt;/a&gt; 의 재정 의자 함수 자는 기본 클래스 선언에서 기본 인수를 얻지 않으며 가상 함수 호출이 수행 될 때 기본 인수는 객체의 정적 유형에 따라 결정됩니다 (참고 : &lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;가상&lt;/a&gt; 이 아닌 경우 피할 수 있음) 인터페이스 패턴).</target>
        </trans-unit>
        <trans-unit id="c2ff4997fdc8d657823adaf82ddae1edd807b428" translate="yes" xml:space="preserve">
          <source>The ownership of an object can only be shared with another &lt;code&gt;shared_ptr&lt;/code&gt; by copy constructing or copy assigning its value to another &lt;code&gt;shared_ptr&lt;/code&gt;. Constructing a new &lt;code&gt;shared_ptr&lt;/code&gt; using the raw underlying pointer owned by another &lt;code&gt;shared_ptr&lt;/code&gt; leads to undefined behavior.</source>
          <target state="translated">객체의 소유권은 값을 다른 &lt;code&gt;shared_ptr&lt;/code&gt; 에 복사 구성 또는 복사 할당하여 다른 &lt;code&gt;shared_ptr&lt;/code&gt; 과만 공유 할 수 있습니다 . 다른 사람이 소유 한 원시 기본 포인터를 사용하여 새로운 &lt;code&gt;shared_ptr&lt;/code&gt; 생성 &lt;code&gt;shared_ptr&lt;/code&gt; 이 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fa11b27c4386988848a8387d60af610e8a21c655" translate="yes" xml:space="preserve">
          <source>The paragraph defining the strict aliasing rule in the standard contains two additional bullets partially inherited from C:</source>
          <target state="translated">표준에서 엄격한 앨리어싱 규칙을 정의하는 단락에는 C에서 부분적으로 상속 된 두 개의 추가 글 머리 기호가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d946d0089157a6f8805e15b4ad51c2da0943b9d" translate="yes" xml:space="preserve">
          <source>The parallelizable version of this algorithm, &lt;code&gt;&lt;a href=&quot;transform_reduce&quot;&gt;std::transform_reduce&lt;/a&gt;&lt;/code&gt;, requires &lt;code&gt;op1&lt;/code&gt; and &lt;code&gt;op2&lt;/code&gt; to be commutative and associative, but &lt;code&gt;std::inner_product&lt;/code&gt; makes no such requirement, and always performs the operations in the order given.</source>
          <target state="translated">이 알고리즘의 병렬화 가능한 버전 인 &lt;code&gt;&lt;a href=&quot;transform_reduce&quot;&gt;std::transform_reduce&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;op1&lt;/code&gt; 및 &lt;code&gt;op2&lt;/code&gt; 가 정식 및 연관성이 있어야하지만 &lt;code&gt;std::inner_product&lt;/code&gt; 는 이러한 요구 사항을 요구하지 않으며 항상 주어진 순서대로 조작을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="88022664eeccd42a9c9975d465fba66ce4506250" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;P&lt;/code&gt; is obtained as follows: in &lt;code&gt;T&lt;/code&gt;, the declared type of the variable that includes &lt;code&gt;auto&lt;/code&gt;, every occurrence of &lt;code&gt;auto&lt;/code&gt; is replaced with an imaginary type template parameter &lt;code&gt;U&lt;/code&gt; or, if the initialization is copy-list-initialization, with &lt;code&gt;std::initializer_list&amp;lt;U&amp;gt;&lt;/code&gt;. The argument &lt;code&gt;A&lt;/code&gt; is the initializer expression. After deduction of &lt;code&gt;U&lt;/code&gt; from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; following the rules described above, the deduced &lt;code&gt;U&lt;/code&gt; is substituted into &lt;code&gt;P&lt;/code&gt; to get the actual variable type:</source>
          <target state="translated">파라미터 &lt;code&gt;P&lt;/code&gt; 는 다음과 같이 얻어진다에서 &lt;code&gt;T&lt;/code&gt; 포함 변수의 선언 형 &lt;code&gt;auto&lt;/code&gt; , 발생할 때마다 &lt;code&gt;auto&lt;/code&gt; 파라미터 허수 형식 템플릿으로 대체된다 &lt;code&gt;U&lt;/code&gt; 초기화 복사리스트 초기화와, 경우, 혹은 &lt;code&gt;std::initializer_list&amp;lt;U&amp;gt;&lt;/code&gt; 입니다. 인수 &lt;code&gt;A&lt;/code&gt; 는 이니셜 라이저 표현식입니다. 공제 한 후 &lt;code&gt;U&lt;/code&gt; 에서 &lt;code&gt;P&lt;/code&gt; 및 규칙 상술 다음, 도출 된 &lt;code&gt;U&lt;/code&gt; 는 대입 &lt;code&gt;P&lt;/code&gt; 실제 변수 타입을 얻을 : &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ced868183336be7e9556ada04c5529aea418503e" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;i&lt;/code&gt; shall be less than the number of elements in the array; otherwise, the behavior is undefined.</source>
          <target state="translated">매개 변수 &lt;code&gt;i&lt;/code&gt; 는 배열의 요소 수보다 작아야합니다. 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="399902f69cf10a83ab53fc5cc2b8d7444ca7d8d2" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;init&lt;/code&gt; appears last, differing from &lt;code&gt;&lt;a href=&quot;transform_exclusive_scan&quot;&gt;std::transform_exclusive_scan&lt;/a&gt;&lt;/code&gt;, because it is optional for this function.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 매개 변수 는 &lt;code&gt;&lt;a href=&quot;transform_exclusive_scan&quot;&gt;std::transform_exclusive_scan&lt;/a&gt;&lt;/code&gt; 과는 다르게 마지막에 나타납니다 .이 함수의 경우 선택 사항이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="309510cf9024b1695506845548ff6ef69f7b6db0" translate="yes" xml:space="preserve">
          <source>The parameter is passed by value and is subject to slicing.</source>
          <target state="translated">매개 변수는 값으로 전달되며 슬라이싱이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f622764221043c46158533031680f20b679054a" translate="yes" xml:space="preserve">
          <source>The parameter types and the return type of the function must match the target exactly, no implicit conversions are considered (e.g. a function returning a pointer to derived won't get selected when initializing a pointer to function returning a pointer to base).</source>
          <target state="translated">함수의 매개 변수 유형과 반환 유형은 대상과 정확히 일치해야합니다. 암시 적 변환은 고려되지 않습니다 (예 : 파생 포인터를 반환하는 함수는 포인터를 밑으로 반환하는 함수에 대한 포인터를 초기화 할 때 선택되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="04103a3447a63b6cf20e5c231a8fc7a4ccdc71ac" translate="yes" xml:space="preserve">
          <source>The parameter types, as well as the return type of a function cannot be &lt;a href=&quot;incomplete_type&quot;&gt;incomplete&lt;/a&gt;&lt;a href=&quot;class&quot;&gt;class types&lt;/a&gt;, except for deleted functions(since C++11). The completeness check is made in the context of the function</source>
          <target state="translated">함수의 리턴 유형뿐만 아니라 매개 변수 유형 은 삭제 된 함수 (C ++ 11 이후)를 제외하고는 &lt;a href=&quot;incomplete_type&quot;&gt;불완전한 &lt;/a&gt;&lt;a href=&quot;class&quot;&gt;클래스 유형일&lt;/a&gt; 수 없습니다 . 완전성 점검은 기능의 맥락에서 이루어집니다</target>
        </trans-unit>
        <trans-unit id="72593e2e10e937d3bd8a9e45b5e7630cd1c55e97" translate="yes" xml:space="preserve">
          <source>The parameters declared in the declarator of a function definition are &lt;a href=&quot;scope&quot;&gt;in scope&lt;/a&gt; within the body. If a parameter is not used in the function body, it does not need to be named (it's sufficient to use an abstract declarator).</source>
          <target state="translated">함수 정의의 선언자에서 선언 된 파라미터는 &lt;a href=&quot;scope&quot;&gt;범위&lt;/a&gt; 체내. 함수 본문에서 매개 변수를 사용하지 않으면 이름을 지정할 필요가 없습니다 (추상 선언자를 사용하면 충분합니다).</target>
        </trans-unit>
        <trans-unit id="d233ef2eab4dce31ee515ec28dc0e9bc316caee3" translate="yes" xml:space="preserve">
          <source>The parameters m and s are, respectively, the mean and standard deviation of the natural logarithm of x.</source>
          <target state="translated">파라미터 m 및 s는 각각 x의 자연 로그의 평균 및 표준 편차이다.</target>
        </trans-unit>
        <trans-unit id="cef460ed950b6b80761f1b32499ca34a65c8b52d" translate="yes" xml:space="preserve">
          <source>The parameters of a distribution object may be changed either permanently, by using &lt;code&gt;d.param(p)&lt;/code&gt; or just for the duration of a single operator() call, by using &lt;code&gt;d(g,p)&lt;/code&gt;.</source>
          <target state="translated">배포 객체의 매개 변수는 &lt;code&gt;d.param(p)&lt;/code&gt; 를 사용하여 영구적으로 변경하거나 &lt;code&gt;d(g,p)&lt;/code&gt; 사용하여 단일 operator () 호출 기간 동안 만 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2936a021e331baf2a03da363a001e002fbef98a" translate="yes" xml:space="preserve">
          <source>The parameters of the slice -- start, size and stride respectively.</source>
          <target state="translated">슬라이스의 매개 변수는 각각 시작, 크기 및 보폭입니다.</target>
        </trans-unit>
        <trans-unit id="0269c7638cb516f0a5e4f2122a21b168b3bc2795" translate="yes" xml:space="preserve">
          <source>The parameters of the slice -- start, sizes and strides respectively.</source>
          <target state="translated">슬라이스의 매개 변수는 각각 시작, 크기 및 보폭입니다.</target>
        </trans-unit>
        <trans-unit id="467dc40c372e73f0c2c12405d62c7e8ef32d3367" translate="yes" xml:space="preserve">
          <source>The parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as</source>
          <target state="translated">main 함수의 두 매개 변수 형식의 매개 변수를 사용하면 임의의 멀티 바이트 문자열을 실행 환경에서 전달할 수 있습니다 (일반적으로</target>
        </trans-unit>
        <trans-unit id="3c5a1d2074edfc3d26b83a970525326f7df017be" translate="yes" xml:space="preserve">
          <source>The parsed date is stored in the corresponding fields of the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure pointed to by the argument &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">구문 분석 된 날짜는 인수 &lt;code&gt;t&lt;/code&gt; 가 가리키는 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 구조 의 해당 필드에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f535b74a20fe9252e07e454d87e684ef404bcaa" translate="yes" xml:space="preserve">
          <source>The parsed month is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; field &lt;code&gt;t-&amp;gt;tm_mon&lt;/code&gt;.</source>
          <target state="translated">구문 분석 된 월은 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 필드 &lt;code&gt;t-&amp;gt;tm_mon&lt;/code&gt; 에 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="d5c30cfbbbd6f7927a29d7fcfe63ecd32a351360" translate="yes" xml:space="preserve">
          <source>The parsed time is stored in the corresponding fields of the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure pointed to by the argument &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">구문 분석 된 시간은 인수 &lt;code&gt;t&lt;/code&gt; 가 가리키는 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 구조 의 해당 필드에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="14f5b5d4d2f8aed5cb8f99bcda8328dda074ac91" translate="yes" xml:space="preserve">
          <source>The parsed weekday is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; field &lt;code&gt;t-&amp;gt;tm_wday&lt;/code&gt;.</source>
          <target state="translated">구문 분석 된 요일은 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 필드 &lt;code&gt;t-&amp;gt;tm_wday&lt;/code&gt; 에 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="0cdf3188b56cdad85a77a2a64d2b697625de2a7b" translate="yes" xml:space="preserve">
          <source>The parsed year is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure field &lt;code&gt;t-&amp;gt;tm_year&lt;/code&gt;.</source>
          <target state="translated">구문 분석 된 연도는 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 구조 필드 &lt;code&gt;t-&amp;gt;tm_year&lt;/code&gt; 에 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="c55bd34e7cff3055dc08d70fe226b40f2972b1b5" translate="yes" xml:space="preserve">
          <source>The partial specialization (5) only exists if &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;Rep&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep, Period&amp;gt;&lt;/code&gt; is not convertible to &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">부분 특수화 (5)는 &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;Rep&amp;gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep, Period&amp;gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt; 로 변환 할 수없는 경우에만 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="23f549c7dd61d901fe54500a09da11aa34be717c" translate="yes" xml:space="preserve">
          <source>The partial specialization of &lt;code&gt;&lt;a href=&quot;../tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&lt;/code&gt; for pairs provides a compile-time way to obtain the number of elements in a pair, which is always 2, using tuple-like syntax.</source>
          <target state="translated">쌍에 대한 &lt;code&gt;&lt;a href=&quot;../tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&lt;/code&gt; 의 부분 특수화는 튜플과 유사한 구문을 사용하여 쌍의 요소 수를 항상 2로 얻는 컴파일 타임 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c5221fc4cfc2057c802611cbc8029455768b8710" translate="yes" xml:space="preserve">
          <source>The partial specializations of &lt;code&gt;&lt;a href=&quot;../tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&lt;/code&gt; for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if &lt;code&gt;I &amp;gt;= 2&lt;/code&gt;.</source>
          <target state="translated">쌍에 대한 &lt;code&gt;&lt;a href=&quot;../tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&lt;/code&gt; 의 부분 특수화는 튜플과 같은 구문을 사용하여 쌍의 요소 유형에 대한 컴파일 타임 액세스를 제공합니다. &lt;code&gt;I &amp;gt;= 2&lt;/code&gt; 경우 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9182a1c88da6a522cf7ab9faaecc8994e994260" translate="yes" xml:space="preserve">
          <source>The partial template specialization of &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to manipulate shared_ptr objects atomically.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; &amp;lt;T&amp;gt;에 대한 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 의 부분 템플리트 전문화를 통해 사용자는 shared_ptr 오브젝트를 원자 적으로 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb0acd7ca55c8a975ce7a1790dcea9fa121ca3b5" translate="yes" xml:space="preserve">
          <source>The partial template specialization of &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to manipulate weak_ptr objects atomically.</source>
          <target state="translated">부분 템플릿 전문화 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 대한 std :: atomic통해 사용자는 weak_ptr 오브젝트를 원자 적으로 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b413e1a3d2902ad2bd6f7353c7ed24fbd704a4c" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator deserves particular mention. In general this iterator is invalidated as though it were a normal iterator to a non-erased element. So &lt;code&gt;&lt;a href=&quot;container/set/end&quot;&gt;std::set::end&lt;/a&gt;&lt;/code&gt; is never invalidated, &lt;code&gt;&lt;a href=&quot;container/unordered_set/end&quot;&gt;std::unordered_set::end&lt;/a&gt;&lt;/code&gt; is invalidated only on rehash, &lt;code&gt;&lt;a href=&quot;container/vector/end&quot;&gt;std::vector::end&lt;/a&gt;&lt;/code&gt; is always invalidated (since it is always after the modified elements), and so on.</source>
          <target state="translated">과거의 이터레이터에는 특별한 언급이 필요합니다. 일반적으로이 반복기는 지우지 않은 요소에 대한 일반 반복자 인 것처럼 무효화됩니다. 따라서 &lt;code&gt;&lt;a href=&quot;container/set/end&quot;&gt;std::set::end&lt;/a&gt;&lt;/code&gt; 는 무효화되지 않습니다. &lt;code&gt;&lt;a href=&quot;container/unordered_set/end&quot;&gt;std::unordered_set::end&lt;/a&gt;&lt;/code&gt; 는 리해시에서만 무효화되고 &lt;code&gt;&lt;a href=&quot;container/vector/end&quot;&gt;std::vector::end&lt;/a&gt;&lt;/code&gt; 는 항상 무효화됩니다 (항상 수정 된 요소 뒤에 있기 때문에).</target>
        </trans-unit>
        <trans-unit id="4b284ed6473a51bd21fc130bcb9ebaf961cac342" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator is also invalidated unless the erased elements are at the beginning of the container and the last element is not erased.</source>
          <target state="translated">지워진 요소가 컨테이너의 시작 부분에 있고 마지막 요소가 지워지지 않는 한, 과거의 반복자도 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="b0677f6c9e33d408c8fc74dad13a28a32a573cdb" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator may be invalidated (implementation defined)</source>
          <target state="translated">과거의 반복자가 무효화 될 수있다 (구현이 정의되어있다)</target>
        </trans-unit>
        <trans-unit id="3b5524c20e358d594b020e8bdb5b108f709ab7d9" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator.</source>
          <target state="translated">과거의 반복자.</target>
        </trans-unit>
        <trans-unit id="5e5a668c57f23b6460fdf63ef2455241134daf73" translate="yes" xml:space="preserve">
          <source>The path &lt;code&gt;&quot;/&quot;&lt;/code&gt; is absolute on a POSIX OS, but is relative on Windows.</source>
          <target state="translated">&lt;code&gt;&quot;/&quot;&lt;/code&gt; 경로 는 POSIX OS에서는 절대적이지만 Windows에서는 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="82f5c6939e80a9a4b63791641284d31cb36ab963" translate="yes" xml:space="preserve">
          <source>The path can be traversed element-wise via iterators returned by the &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; functions, which views the path in generic format and iterates over root name, root directory, and the subsequent file name elements (directory separators are skipped except the one that identifies the root directory). If the very last element in the path is a directory separator, the last iterator will dereference to an empty element.</source>
          <target state="translated">경로는 &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 함수에 의해 반환 된 반복자를 통해 요소 단위로 순회 할 수 있습니다.이 함수는 일반 형식으로 경로를보고 루트 이름, 루트 디렉토리 및 후속 파일 이름 요소를 반복합니다 (디렉토리 구분 기호는 제외) 루트 디렉토리를 식별하는 것). 경로의 마지막 요소가 디렉토리 구분 기호 인 경우 마지막 반복기는 빈 요소를 역 참조합니다.</target>
        </trans-unit>
        <trans-unit id="1e16e300f585e54bf938d0439911d56726dd815b" translate="yes" xml:space="preserve">
          <source>The path constructed from the input string after conversion from UTF-8 to the filesystem's native character encoding.</source>
          <target state="translated">UTF-8에서 파일 시스템의 기본 문자 인코딩으로 변환 한 후 입력 문자열에서 구성된 경로입니다.</target>
        </trans-unit>
        <trans-unit id="6e603cf030e4d0195d580420c1da816f92ceb1c9" translate="yes" xml:space="preserve">
          <source>The path name has the following syntax:</source>
          <target state="translated">경로 이름은 다음과 같은 구문을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e8eb701045d3a46c2ebb72285abb0e82f58fd37e" translate="yes" xml:space="preserve">
          <source>The path to the parent directory.</source>
          <target state="translated">부모 디렉토리의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="1ceffb6cd0e4fed5091cf63b5f6b9f72943aad5c" translate="yes" xml:space="preserve">
          <source>The perimeter of an ellipse with eccentricity &lt;code&gt;k&lt;/code&gt; and semimajor axis a equals 4aE(k), where E is &lt;code&gt;std::comp_ellint_2&lt;/code&gt;. When eccentricity equals 0, the ellipse degenerates to a circle with radius a and the perimeter equals 2&amp;pi;a, so E(0) = &amp;pi;/2. When eccentricity equals 1, the ellipse degenerates to a line of length 2a, whose perimeter is 4a, so E(1) = 1.</source>
          <target state="translated">편심 &lt;code&gt;k&lt;/code&gt; 및 반장 축 a 를 갖는 타원의 둘레는 4aE (k)와 같습니다. 여기서 E는 &lt;code&gt;std::comp_ellint_2&lt;/code&gt; 입니다. 편심이 0과 같으면 타원은 반지름이 a 인 원으로 변하고 둘레는 2&amp;pi;a이므로 E (0) = &amp;pi; / 2입니다. 편심이 1과 같으면 타원은 길이가 2a 인 선으로 변하고 그 길이는 4a이므로 E (1) = 1입니다.</target>
        </trans-unit>
        <trans-unit id="e4b5a30aa03db848f6592cd57db56eefa2e1e7f9" translate="yes" xml:space="preserve">
          <source>The period of the resulting duration is the greatest common divisor of &lt;code&gt;Period1&lt;/code&gt; and &lt;code&gt;Period2&lt;/code&gt;.</source>
          <target state="translated">결과 지속 기간은 &lt;code&gt;Period1&lt;/code&gt; 과 &lt;code&gt;Period2&lt;/code&gt; 의 최대 공약수입니다 .</target>
        </trans-unit>
        <trans-unit id="6b1ecc6341dad0825427d240ecf259972a63f062" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; can be used in conversion-type-id, indicating a &lt;a href=&quot;function#Return_type_deduction&quot;&gt;deduced return type&lt;/a&gt;:</source>
          <target state="translated">플레이스 홀더 &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; 는 conversion-type-id에 사용될 수 있으며 &lt;a href=&quot;function#Return_type_deduction&quot;&gt;추론 된 리턴 유형을&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="11988032bccc6150348612dc3dc97330efc38f94" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;code&gt;auto&lt;/code&gt; may be accompanied by modifiers, such as &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, which will participate in the type deduction. The placeholder &lt;code&gt;decltype(auto)&lt;/code&gt; must be the the sole constituent of the declared type.(since C++14).</source>
          <target state="translated">자리 표시 자 &lt;code&gt;auto&lt;/code&gt; 에는 형식 공제에 참여할 &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;&lt;/code&gt; 같은 수정자가 수반 될 수 있습니다 . 자리 표시 자 &lt;code&gt;decltype(auto)&lt;/code&gt; 은 선언 된 형식의 유일한 구성 요소 여야합니다 (C ++ 14부터).</target>
        </trans-unit>
        <trans-unit id="8188f0beadbdc9f67fbcab0cca288be6624dd85d" translate="yes" xml:space="preserve">
          <source>The placement form &lt;code&gt;void* operator new(std::size_t, std::size_t)&lt;/code&gt; is not allowed because the matching signature of the deallocation function, &lt;code&gt;void operator delete(void*, std::size_t)&lt;/code&gt;, is a usual (not placement) deallocation function.</source>
          <target state="translated">할당 취소 함수의 일치 서명 &lt;code&gt;void operator delete(void*, std::size_t)&lt;/code&gt; 서명이 일반적이므로 (배치 아님) 배치 양식 &lt;code&gt;void* operator new(std::size_t, std::size_t)&lt;/code&gt; 는 허용되지 않습니다. 할당 해제 기능.</target>
        </trans-unit>
        <trans-unit id="5912c23fdb49cda02bccb62c7fc1895dae110adc" translate="yes" xml:space="preserve">
          <source>The platform-dependent error value.</source>
          <target state="translated">플랫폼 별 오류 값입니다.</target>
        </trans-unit>
        <trans-unit id="22e0322c3fe2739912f4200c9d7cc04be3a7791f" translate="yes" xml:space="preserve">
          <source>The point of declaration for an &lt;a href=&quot;injected-class-name&quot;&gt;injected-class-name&lt;/a&gt; is immediately following the opening brace of its class (or class template) definition.</source>
          <target state="translated">&lt;a href=&quot;injected-class-name&quot;&gt;주입 된 클래스 이름&lt;/a&gt; 의 선언 지점은 클래스 (또는 클래스 템플리트) 정의의 여는 중괄호 바로 다음에옵니다.</target>
        </trans-unit>
        <trans-unit id="0cc6d0e2bd00875eb3b647ab691eaf3a40b734e4" translate="yes" xml:space="preserve">
          <source>The point of declaration of a &lt;a href=&quot;structured_binding&quot;&gt;structured binding&lt;/a&gt; is immediately after the identifier-list of the structured binding declaration, but structured binding initializers are prohibited from referring to any of the names being introduced.</source>
          <target state="translated">&lt;a href=&quot;structured_binding&quot;&gt;구조적 바인딩&lt;/a&gt; 의 선언 지점은 구조적 바인딩 선언의 식별자 목록 바로 뒤에 있지만 구조적 바인딩 초기화 프로그램은 도입 된 이름을 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d2eaa3ef9aed1f964e68ecd40fdb0b4090b12a22" translate="yes" xml:space="preserve">
          <source>The point of declaration of a &lt;a href=&quot;type_alias&quot;&gt;type alias or alias template&lt;/a&gt; is immediately after the type-id to which the alias refers:</source>
          <target state="translated">&lt;a href=&quot;type_alias&quot;&gt;유형 별명 또는 별명 템플리트&lt;/a&gt; 의 선언 지점은 별명이 참조하는 type-id 바로 다음에 있습니다.</target>
        </trans-unit>
        <trans-unit id="fead0939c1b9750ab484b917a8bc503ed969f8da" translate="yes" xml:space="preserve">
          <source>The point of declaration of a class or template is immediately after the identifier that names the class (or the &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; that names the template specialization) appears in its &lt;a href=&quot;classes&quot;&gt;class-head&lt;/a&gt;, and is already in scope in the list of the base classes:</source>
          <target state="translated">클래스 또는 템플리트의 선언 지점은 클래스의 이름을 지정하는 식별자 (또는 템플리트 특수화의 이름을 지정하는 템플리트 &lt;a href=&quot;templates#template-id&quot;&gt;ID&lt;/a&gt; )가 &lt;a href=&quot;classes&quot;&gt;class-head에&lt;/a&gt; 나타나고 기본 클래스 목록의 범위에 이미 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f0644324f7e4cf1aefd74a5866f04764d1f1056" translate="yes" xml:space="preserve">
          <source>The point of declaration of an enumeration is immediately after the identifier that names it appears in the &lt;a href=&quot;enum&quot;&gt;enum specifier&lt;/a&gt; or opaque enum declaration, whichever is used first:</source>
          <target state="translated">열거의 선언 지점은 &lt;a href=&quot;enum&quot;&gt;열거 자 지정자&lt;/a&gt; 또는 불투명 한 열거 선언에 표시되는 식별자 바로 뒤에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="47421c40dd3c8897ae17db10f6de7045e0604b49" translate="yes" xml:space="preserve">
          <source>The point of declaration of an enumerator is immediately after its definition (not before the initializer as it is for variables):</source>
          <target state="translated">열거 자의 선언 지점은 정의 직후에 있습니다 (변수에 대한 초기화 프로그램 이전이 아님).</target>
        </trans-unit>
        <trans-unit id="82b67920a9148c6fc228fb43bc313b703cc12c0e" translate="yes" xml:space="preserve">
          <source>The pointed-to type of a pointer-to-member may be a pointer-to-member itself: pointers to members can be multilevel, and can be cv-qualifed differently at every level. Mixed multi-level combinations of pointers and pointers-to-members are also allowed:</source>
          <target state="translated">포인터 대 멤버의 뾰족한 유형은 포인터 대 멤버 자체 일 수 있습니다. 멤버에 대한 포인터는 다중 레벨 일 수 있으며 모든 레벨에서 다르게 cv-qualifed 될 수 있습니다. 포인터와 포인터 대 멤버의 혼합 된 다중 레벨 조합도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="857df6b1a996ed03a792d5426b8be017166c9590" translate="yes" xml:space="preserve">
          <source>The pointer held by &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 가 보유한 포인터 .</target>
        </trans-unit>
        <trans-unit id="1a569ae03f99a2e029c35053360ec402ea8825c3" translate="yes" xml:space="preserve">
          <source>The pointer held by the &lt;code&gt;shared_ptr&lt;/code&gt; directly is the one returned by &lt;code&gt;&lt;a href=&quot;shared_ptr/get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt;, while the pointer/object held by the control block is the one that will be deleted when the number of shared owners reaches zero. These pointers are not necessarily equal.</source>
          <target state="translated">&lt;code&gt;shared_ptr&lt;/code&gt; 이 직접 보유한 포인터 는 &lt;code&gt;&lt;a href=&quot;shared_ptr/get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; 리턴 한 포인터이고 제어 블록이 보유한 포인터 / 개체는 공유 소유자 수가 0에 도달 할 때 삭제되는 포인터입니다. 이 포인터가 반드시 같은 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0b9194591fdc314a0ecc3f4298cf510d1793c0b0" translate="yes" xml:space="preserve">
          <source>The pointer is such that the range &lt;code&gt;[c_str(); c_str() + size()]&lt;/code&gt; is valid and the values in it correspond to the values stored in the string with an additional null character after the last position.</source>
          <target state="translated">포인터는 &lt;code&gt;[c_str(); c_str() + size()]&lt;/code&gt; 는 유효하며 그 값은 마지막 위치 뒤에 추가 널 문자가있는 문자열에 저장된 값에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="bc4de43f158ae279800dabe183ad787c290be28c" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;c_str()&lt;/code&gt; may be invalidated by:</source>
          <target state="translated">&lt;code&gt;c_str()&lt;/code&gt; 에서 얻은 포인터 는 다음과 같이 무효화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25f266f248c76589a2ccd4234acbb0c2d4e4eacd" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;c_str()&lt;/code&gt; may only be treated as a pointer to a null-terminated character string if the string object does not contain other null characters.</source>
          <target state="translated">문자열 객체에 다른 null 문자가 포함되지 않은 경우 &lt;code&gt;c_str()&lt;/code&gt; 에서 얻은 포인터는 null로 끝나는 문자열에 대한 포인터로만 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83480f14010d5cb1f67d2563b68adf44bf7bc56e" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;data()&lt;/code&gt; may be invalidated by:</source>
          <target state="translated">&lt;code&gt;data()&lt;/code&gt; 에서 얻은 포인터 는 다음에 의해 무효화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8a783b19ce6451ba52b4dc182db830ef0e17f42" translate="yes" xml:space="preserve">
          <source>The pointer returned by the call to &lt;code&gt;a.allocate(n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a.allocate(n)&lt;/code&gt; 호출에 의해 리턴 된 포인터 .</target>
        </trans-unit>
        <trans-unit id="62efe07fde27af3eb6cd42fa101df3a460a161fb" translate="yes" xml:space="preserve">
          <source>The pointer safety used by this implementation.</source>
          <target state="translated">이 구현에서 사용되는 포인터 안전성.</target>
        </trans-unit>
        <trans-unit id="cdcc993eb7230b5cf2a0e319e9141223d606af16" translate="yes" xml:space="preserve">
          <source>The pointer to convert</source>
          <target state="translated">변환 할 포인터</target>
        </trans-unit>
        <trans-unit id="3616897fc4a7fb62d60e2791e6f3b00f4006b358" translate="yes" xml:space="preserve">
          <source>The pointer to the allocated storage.</source>
          <target state="translated">할당 된 스토리지에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="3c8844a746827bb53e8a970ddaf5df27d6244fac" translate="yes" xml:space="preserve">
          <source>The pointer to the block of storage to be reclaimed is passed to the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; that was selected by the process above as the first argument. The size of the block is passed as the optional &lt;code&gt;std::size_t&lt;/code&gt; argument. The alignment requirement is passed as the optional &lt;code&gt;std::align_val_t&lt;/code&gt; argument.(since C++17).</source>
          <target state="translated">교정 할 스토리지 블록에 대한 포인터는 위의 프로세스에서 첫 번째 인수로 선택한 &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;할당 해제 기능으로&lt;/a&gt; 전달됩니다 . 블록의 크기는 선택적 &lt;code&gt;std::size_t&lt;/code&gt; 인수 로 전달됩니다 . 정렬 요구 사항은 선택적 &lt;code&gt;std::align_val_t&lt;/code&gt; 인수로 전달됩니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="2f9790c4ee1ba3e3c2d585a13b1c938331446c70" translate="yes" xml:space="preserve">
          <source>The popular Edsger W. Dijkstra essay, &lt;a href=&quot;http://david.tribble.com/text/goto.html&quot;&gt;&amp;ldquo;Goto Considered Harmful&amp;rdquo;&lt;/a&gt;, presents a survey of the many subtle problems the careless use of this keyword can introduce.</source>
          <target state="translated">인기있는 Edsger W. Dijkstra의 에세이 인 &lt;a href=&quot;http://david.tribble.com/text/goto.html&quot;&gt;&amp;ldquo;Goto&lt;/a&gt; Thoughed Harmful&amp;rdquo; 은이 키워드를 부주의하게 사용하여 얻을 수있는 많은 미묘한 문제에 대한 조사를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3db1aee0e463b1a7e37a693db9028dc4dd6c01b3" translate="yes" xml:space="preserve">
          <source>The portion of the declaration preceding &lt;code&gt;[&lt;/code&gt; applies to the hidden variable &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt;, not to the introduced identifiers.</source>
          <target state="translated">앞의 선언 부분 &lt;code&gt;[&lt;/code&gt; 도입 된 식별자가 아닌 숨겨진 변수 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; 에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="63e5a10c38c160db27db345693a402cc1e1242ee" translate="yes" xml:space="preserve">
          <source>The position of the first character of the specified match or sub-match.</source>
          <target state="translated">지정된 일치 또는 하위 일치의 첫 번째 문자의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="28cd458ec55f909805d8bb05b742449475997ff5" translate="yes" xml:space="preserve">
          <source>The possible values for this type (&lt;code&gt;icase&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt;, etc.) are duplicated inside &lt;a href=&quot;basic_regex/constants&quot;&gt;std::basic_regex&lt;/a&gt;.</source>
          <target state="translated">이 유형의 가능한 값 ( &lt;code&gt;icase&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; 등)은 &lt;a href=&quot;basic_regex/constants&quot;&gt;std :: basic_regex&lt;/a&gt; 안에 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="f158078e6b12f488989a09d27a17236fe92bc958" translate="yes" xml:space="preserve">
          <source>The possible values of FLT_ROUNDS match the possible values of &lt;code&gt;&lt;a href=&quot;../numeric_limits/float_round_style&quot;&gt;std::float_round_style&lt;/a&gt;&lt;/code&gt;, returned by &lt;code&gt;&lt;a href=&quot;../numeric_limits/round_style&quot;&gt;std::numeric_limits::round_style&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FLT_ROUNDS의 가능한 값은 &lt;code&gt;&lt;a href=&quot;../numeric_limits/float_round_style&quot;&gt;std::float_round_style&lt;/a&gt;&lt;/code&gt; 의 가능한 값과 일치하며 &lt;code&gt;&lt;a href=&quot;../numeric_limits/round_style&quot;&gt;std::numeric_limits::round_style&lt;/a&gt;&lt;/code&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb1f284e6c90d25d80dca04b6d988a3435fc3bfd" translate="yes" xml:space="preserve">
          <source>The postconditions are as follows:</source>
          <target state="translated">사후 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61121624309d02b453ed84455806314e9c9e17f9" translate="yes" xml:space="preserve">
          <source>The postfix increment and decrement expressions have the form.</source>
          <target state="translated">접미사 증가 및 감소 식의 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bb958d510683e21b0e77aaa67075c099774e223" translate="yes" xml:space="preserve">
          <source>The potential scope of a function parameter (including parameters of a lambda expression) or of a function-local predefined variable begins at its point of declaration.</source>
          <target state="translated">함수 매개 변수 (람다 표현식의 매개 변수 포함) 또는 함수 로컬 사전 정의 변수의 잠재적 인 범위는 선언 시점에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="f221d1f923c37987bf0e3c89da004e995c3dde61" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in a &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt; begins at the point of declaration and includes the rest of the class body and all function bodies (even if defined outside the class definition or before the declaration of the name), default arguments, exception specifications, in-class brace-or-equal initializers, &lt;a href=&quot;attributes/contract&quot;&gt;contract conditions&lt;/a&gt;(since C++20), and all these things in nested classes, recursively.</source>
          <target state="translated">&lt;a href=&quot;class&quot;&gt;클래스에&lt;/a&gt; 선언 된 이름의 잠재적 인 범위는 선언 시점에서 시작하며 클래스 본문의 나머지 부분과 모든 함수 본문 (클래스 정의 외부 또는 이름 선언 전에 정의 된 경우에도), 기본 인수, 예외 사양을 포함합니다. , 클래스 내 괄호 또는 동일 이니셜 라이저, &lt;a href=&quot;attributes/contract&quot;&gt;계약 조건&lt;/a&gt; (C ++ 20 이후) 및 중첩 클래스의 모든 것들을 재귀 적으로.</target>
        </trans-unit>
        <trans-unit id="2d5497083d21c504b3ed59ade0ed30f3ffbb92bc" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in an exception handler begins at the point of declaration and ends when the exception handler ends, and is not in scope in another exception handler or in the enclosing block.</source>
          <target state="translated">예외 핸들러에 선언 된 이름의 잠재적 범위는 선언 시점에서 시작하여 예외 핸들러가 종료 될 때 종료되며 다른 예외 핸들러 또는 엔 클로징 블록의 범위에 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86aa2a90d28cbbde1fb0589dd802c3a11b1e29f7" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in the</source>
          <target state="translated">에 선언 된 이름의 잠재적 범위</target>
        </trans-unit>
        <trans-unit id="a17d45e1f219a3300a9f28b3d08fce8f429503aa" translate="yes" xml:space="preserve">
          <source>The potential scope of a template parameter name begins immediately at the point of declaration and continues to the end of the smallest template declaration in which it was introduced. In particular, a template parameter can be used in the declarations of subsequent template parameters and in the specifications of base classes, but can't be used in the declarations of the preceding template parameters.</source>
          <target state="translated">템플릿 매개 변수 이름의 잠재적 인 범위는 선언 시점에서 즉시 시작되어 도입 된 가장 작은 템플릿 선언의 끝까지 계속됩니다. 특히 템플릿 매개 변수는 후속 템플릿 매개 변수 선언 및 기본 클래스 사양에 사용할 수 있지만 이전 템플릿 매개 변수 선언에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="32a82cbca985e3e0dfa23c0dbaf5a6027c95d501" translate="yes" xml:space="preserve">
          <source>The potential scope of a variable introduced by a declaration in a &lt;a href=&quot;statements#Compound_statements&quot;&gt;block (compound statement)&lt;/a&gt; begins at the point of declaration and ends at the end of the block. Actual scope is the same as potential scope unless there is a nested block with a declaration that introduces identical name (in which case, the entire potential scope of the nested declaration is excluded from the scope of the outer declaration).</source>
          <target state="translated">&lt;a href=&quot;statements#Compound_statements&quot;&gt;블록&lt;/a&gt; 에서 선언에 의해 도입 된 변수의 잠재적 인 범위 (복합 문) 는 선언 지점에서 시작하여 블록의 끝에서 끝납니다. 실제 이름은 이름이 같은 선언이 포함 된 중첩 블록이없는 경우 잠재적 범위와 같습니다 (이 경우 중첩 선언의 전체 잠재적 범위가 외부 선언의 범위에서 제외됨).</target>
        </trans-unit>
        <trans-unit id="3ba3386f44571d8f14970c593d609182dd9626af" translate="yes" xml:space="preserve">
          <source>The potential scope of any entity declared in a &lt;a href=&quot;namespace&quot;&gt;namespace&lt;/a&gt; begins at the declaration and consists of the concatenation of all namespace definitions for the same namespace name that follow, plus, for any &lt;a href=&quot;namespace&quot;&gt;using-directive&lt;/a&gt; that introduced this name or its entire namespace into another scope, the rest of that scope.</source>
          <target state="translated">&lt;a href=&quot;namespace&quot;&gt;네임 스페이스에&lt;/a&gt; 선언 된 엔터티의 잠재적 범위는 선언에서 시작하며 뒤에 나오는 동일한 네임 스페이스 이름에 대한 모든 네임 스페이스 정의의 연결 과이 이름 또는 전체 네임 스페이스를 다른 범위에 도입 한 &lt;a href=&quot;namespace&quot;&gt;using 지시문&lt;/a&gt; 으로 구성됩니다. 그 범위의 나머지.</target>
        </trans-unit>
        <trans-unit id="4ae5d318818acfe339b9d375cb9ce2cfc0456829" translate="yes" xml:space="preserve">
          <source>The potential scope of the name of the parameter of a template template parameter is the smallest template parameter list in which that name appears.</source>
          <target state="translated">템플릿 템플릿 매개 변수 매개 변수 이름의 잠재적 범위는 해당 이름이 나타나는 가장 작은 템플릿 매개 변수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="124da4714b4bf54af7be4c07efe71d32136057e5" translate="yes" xml:space="preserve">
          <source>The precision of the result is at least &lt;code&gt;std::chrono::seconds&lt;/code&gt;, and will be finer if the argument has finer precision.</source>
          <target state="translated">결과의 정밀도는 최소한 &lt;code&gt;std::chrono::seconds&lt;/code&gt; 이며 인수의 정밀도가 더 좋으면 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a20b15248f8c5353561f8b4cb6be91d86d20e646" translate="yes" xml:space="preserve">
          <source>The predicate of a contract condition has the same semantic restrictions as if it appeared as the first &lt;a href=&quot;../statements#Expression_statements&quot;&gt;expression statement&lt;/a&gt; in the body of the function it applies to.</source>
          <target state="translated">계약 조건의 술어는 그것이 적용되는 함수의 본문에서 첫 번째 &lt;a href=&quot;../statements#Expression_statements&quot;&gt;표현 문&lt;/a&gt; 처럼 나타나는 의미 론적 제한 사항을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="e2463bc948c065d9d75e509585a1ee11887f0dca" translate="yes" xml:space="preserve">
          <source>The prefix increment and decrement expressions have the form.</source>
          <target state="translated">접두사 증가 및 감소 식의 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="05a52076d2dc5c8b894927a5e244dc4ac56fe7ce" translate="yes" xml:space="preserve">
          <source>The preprocessing directives control the behavior of the preprocessor. Each directive occupies one line and has the following format:</source>
          <target state="translated">전처리 지시문은 전 처리기의 동작을 제어합니다. 각 지시문은 한 줄을 차지하며 다음 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="cb413a6249ff3f9ad8dd052d27dcc328f60aee81" translate="yes" xml:space="preserve">
          <source>The preprocessor has the source file translation capabilities:</source>
          <target state="translated">전처리기에는 소스 파일 변환 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aa350ea11bb9c5aa25e6e5ec9306cca0035172c" translate="yes" xml:space="preserve">
          <source>The preprocessor is executed at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 4&lt;/a&gt;, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler.</source>
          <target state="translated">프리 프로세서는 컴파일 &lt;a href=&quot;language/translation_phases&quot;&gt;단계 4의 변환 단계&lt;/a&gt; 에서 실행됩니다 . 전처리 결과는 단일 파일이며 실제 컴파일러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e2bdd9572501029c63f84fab6d94f93d8f91603f" translate="yes" xml:space="preserve">
          <source>The preprocessor supports conditional compilation of parts of source file. This behavior is controlled by &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt;, &lt;code&gt;#ifndef&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt; directives.</source>
          <target state="translated">전처리 기는 소스 파일의 일부에 대한 조건부 컴파일을 지원합니다. 이 동작은 &lt;code&gt;#if&lt;/code&gt; , &lt;code&gt;#else&lt;/code&gt; , &lt;code&gt;#elif&lt;/code&gt; , &lt;code&gt;#ifdef&lt;/code&gt; , &lt;code&gt;#ifndef&lt;/code&gt; 및 &lt;code&gt;#endif&lt;/code&gt; 지시문에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="d389a7945641ac5522e189cd36aef892dd202d1a" translate="yes" xml:space="preserve">
          <source>The preprocessor supports text macro replacement. Function-like text macro replacement is also supported.</source>
          <target state="translated">전처리 기는 텍스트 매크로 교체를 지원합니다. 기능과 유사한 텍스트 매크로 교체도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0e2ac736e4b9518fd1201761b13af480e31f9a2e" translate="yes" xml:space="preserve">
          <source>The previous locale, as returned by &lt;code&gt;ios_base::imbue(loc)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ios_base::imbue(loc)&lt;/code&gt; 반환 한 이전 로캘 입니다.</target>
        </trans-unit>
        <trans-unit id="4e848927c4ddc2faed727fdcad88567a9f851617" translate="yes" xml:space="preserve">
          <source>The previous value of the global C++ locale.</source>
          <target state="translated">글로벌 C ++ 로케일의 이전 값.</target>
        </trans-unit>
        <trans-unit id="cf70cdf040bccb32e02858713f2da17f9c793063" translate="yes" xml:space="preserve">
          <source>The previously-installed new handler, or a null pointer value if none was installed.</source>
          <target state="translated">이전에 설치된 새 처리기 또는 아무것도 설치되지 않은 경우 null 포인터 값</target>
        </trans-unit>
        <trans-unit id="a35f0efbfe83164488e9c67a5958dce490abc58e" translate="yes" xml:space="preserve">
          <source>The previously-installed terminate handler, or a null pointer value if none was installed.</source>
          <target state="translated">이전에 설치된 종료 핸들러 또는 설치되지 않은 경우 널 포인터 값</target>
        </trans-unit>
        <trans-unit id="d1f9375683ee644e852554818b0e7f65b024d681" translate="yes" xml:space="preserve">
          <source>The previously-installed unexpected handler, or a null pointer value if none was installed.</source>
          <target state="translated">이전에 설치된 예상치 못한 처리기 또는 아무것도 설치되지 않은 경우 null 포인터 값입니다.</target>
        </trans-unit>
        <trans-unit id="9af84654120543bdc403c77640e19172f575072a" translate="yes" xml:space="preserve">
          <source>The primary &lt;code&gt;std::atomic&lt;/code&gt; template may be instantiated with any &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt; satisfying both &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;. The program is ill-formed if any of following values is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">기본 &lt;code&gt;std::atomic&lt;/code&gt; 템플리트는 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 및 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 모두를 만족 하는 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; 유형 &lt;code&gt;T&lt;/code&gt; 로 인스턴스화 될 수 있습니다 . 다음 값 중 하나라도 &lt;code&gt;false&lt;/code&gt; 이면 프로그램이 잘못 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="175466bae183473a68237507d57dfae6c15d71d1" translate="yes" xml:space="preserve">
          <source>The primary &lt;code&gt;std::atomic_ref&lt;/code&gt; template may be instantiated with any &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt; (including &lt;code&gt;bool&lt;/code&gt;):</source>
          <target state="translated">기본 &lt;code&gt;std::atomic_ref&lt;/code&gt; 템플릿은 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; 유형 &lt;code&gt;T&lt;/code&gt; ( &lt;code&gt;bool&lt;/code&gt; 포함 ) 로 인스턴스화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b6fd84220d2a0c86df329eafb7ba3556e2d99b3" translate="yes" xml:space="preserve">
          <source>The primary purpose of function-try-blocks is to respond to an exception thrown from the member initializer list in a constructor by logging and rethrowing, modifying the exception object and rethrowing, throwing a different exception instead, or terminating the program. They are rarely used with destructors or with regular functions.</source>
          <target state="translated">function-try-blocks의 주요 목적은 로깅 및 다시 던지기, 예외 개체 수정 및 다시 던지기, 다른 예외 던지기 또는 프로그램 종료를 통해 생성자의 멤버 이니셜 라이저 목록에서 발생한 예외에 응답하는 것입니다. 소멸 자나 정규 함수와 함께 사용되는 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f7bdf2c45988d2e398ec47fc464d9bf36ad8ecc" translate="yes" xml:space="preserve">
          <source>The primary sort key for the character sequence &lt;code&gt;[first, last)&lt;/code&gt; in the currently imbued locale, ignoring case, variant, diacritics, etc.</source>
          <target state="translated">현재 삽입 된 로케일, 대소 문자, 변형, 분음 부호 등을 무시하고 문자 순서 &lt;code&gt;[first, last)&lt;/code&gt; 의 기본 정렬 키입니다 .</target>
        </trans-unit>
        <trans-unit id="f9b3c50b7c4e0adf0fa987d32fbfaf6e0639923e" translate="yes" xml:space="preserve">
          <source>The primary template (1) is not defined; four specializations are provided to handle four different levels of precision.</source>
          <target state="translated">기본 템플릿 (1)이 정의되어 있지 않습니다. 네 가지 다른 수준의 정밀도를 처리하기 위해 네 가지 전문화가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4f13817f1998ddc17a9521a91f34ffa2754e64b4" translate="yes" xml:space="preserve">
          <source>The primary template is an empty struct. The standard defines the following specializations:</source>
          <target state="translated">기본 템플릿은 빈 구조체입니다. 이 표준은 다음과 같은 전문 분야를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="32aa772a60f7448e2e58e9b419a72a7e62908590" translate="yes" xml:space="preserve">
          <source>The primary template is empty. A specialization is provided for &lt;code&gt;const &lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt;, the default time zone pointer type.</source>
          <target state="translated">기본 템플릿이 비어 있습니다. 기본 표준 시간대 포인터 유형 인 &lt;code&gt;const &lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt; 대한 전문화가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="5795dc517124b691e8ea332cfeb4ab8696d76a2b" translate="yes" xml:space="preserve">
          <source>The primary use of &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; is to provide an l-value that can be returned from &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; 의 기본 용도는 &lt;code&gt;operator[]&lt;/code&gt; 에서 리턴 할 수있는 l 값을 제공하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="895b09aec5064e185b6472594b973b52d8ec16a6" translate="yes" xml:space="preserve">
          <source>The primary use of &lt;code&gt;std::bitset::reference&lt;/code&gt; is to provide an l-value that can be returned from &lt;a href=&quot;operator_at&quot;&gt;&lt;code&gt;operator[]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::bitset::reference&lt;/code&gt; 의 주요 용도는 &lt;a href=&quot;operator_at&quot;&gt; &lt;code&gt;operator[]&lt;/code&gt; &lt;/a&gt; 에서 리턴 할 수있는 l 값을 제공하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="44ca87a7b0da64f5b77109af8b1bf5da6aee13a7" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; member is not affected by this assignment operator.</source>
          <target state="translated">개인 &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 멤버는이 지정 연산자의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b15b5ef90ed5ddcf44be29f564148c6afcb6afcc" translate="yes" xml:space="preserve">
          <source>The probability of &lt;code&gt;h(a)==h(b)&lt;/code&gt; for &lt;code&gt;a!=b&lt;/code&gt; should approach &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a!=b&lt;/code&gt; 에 대한 &lt;code&gt;h(a)==h(b)&lt;/code&gt; 의 확률은 &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt; &lt;a href=&quot;../types/numeric_limits&quot;&gt;std :: numeric_limits&lt;/a&gt; &amp;lt; &lt;a href=&quot;../types/size_t&quot;&gt;std :: size_t&lt;/a&gt; &amp;gt; :: max ()에 접근해야합니다 .</target>
        </trans-unit>
        <trans-unit id="95fdc02e0f2a75a69ee3b45caa87c045c455c0be" translate="yes" xml:space="preserve">
          <source>The program is ill-formed</source>
          <target state="translated">프로그램이 잘못 구성되었습니다</target>
        </trans-unit>
        <trans-unit id="f17c9446e3d0891d6f0a550093638571c34482fa" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;(std::is_same_v&amp;lt;T, U&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; is not true.</source>
          <target state="translated">&lt;code&gt;(std::is_same_v&amp;lt;T, U&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; 가 true가 아닌 경우 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="80681cb4437f6410dadbaf99fd1bc0640c36b450" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;Duration&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Duration&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 의 전문화가 아닌 경우 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba17539f8936e17a1b0aee08e3a960ba67a68e62" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;N&lt;/code&gt; is negative. If &lt;code&gt;N&lt;/code&gt; is zero, the indicated type is &lt;code&gt;integer_sequence&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 이 음수 이면 프로그램이 잘못 구성됩니다 . 경우 &lt;code&gt;N&lt;/code&gt; 이 제로이며, 지정된 타입이 &lt;code&gt;integer_sequence&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5a8f5795052236111eac68e22aa48d3e329cc1b" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;N&lt;/code&gt; is not a power of 2. The behavior is undefined if &lt;code&gt;ptr&lt;/code&gt; does not point to an object of type &lt;code&gt;T&lt;/code&gt; (ignoring cv-qualification at every level), or if the object's alignment is not at least &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 이 2의 거듭 제곱이 아닌 경우 프로그램이 잘못 작성 됩니다. &lt;code&gt;ptr&lt;/code&gt; 이 &lt;code&gt;T&lt;/code&gt; 유형의 오브젝트를 가리 키지 않거나 (모든 레벨에서 cv 규정 무시) 오브젝트의 정렬이 &lt;code&gt;N&lt;/code&gt; 이상이 아닌 경우 동작이 정의 되지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="67bdd1bd8f7bc35a5850d5aff836099617861a78" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is a function type or (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 함수 유형이거나 (가능하면 cv-qualified) &lt;code&gt;void&lt;/code&gt; 인 경우 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="965acd7bfed42ab433acdc02bbf59b653e8dc291" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if an explicit or partial specialization of &lt;code&gt;std::initializer_list&lt;/code&gt; is declared.</source>
          <target state="translated">&lt;code&gt;std::initializer_list&lt;/code&gt; 의 명시 적 또는 부분 특수화 가 선언 되면 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a07725707756ca1bff455b3ddbe27d61f7822a9f" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if any of the following is not &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">다음 중 하나라도 해당되지 않으면 프로그램이 잘못 작성된 것 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0c2c540025d21052bca08f15510071c65acf1a0" translate="yes" xml:space="preserve">
          <source>The program is well-formed (compiles) only if there exists one unambiguous</source>
          <target state="translated">모호하지 않은 프로그램이있는 경우에만 프로그램이 제대로 구성 (컴파일)됩니다.</target>
        </trans-unit>
        <trans-unit id="86e09b8d70231ec8b200a5fc3393b854ca51d06f" translate="yes" xml:space="preserve">
          <source>The programmer must ensure that no threads attempt to wait on &lt;code&gt;*this&lt;/code&gt; once the destructor has been started, especially when the waiting threads are calling the wait functions in a loop or are using the overloads of the wait functions that take a predicate.</source>
          <target state="translated">프로그래머는 스레드가 &lt;code&gt;*this&lt;/code&gt; 소멸자가 시작된 후, 특히 대기 스레드가 루프에서 대기 함수를 호출하거나 술어를 취하는 대기 함수의 과부하를 사용하는 경우 대기하지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="74ef69212c8f3a8d15110cc0d0e198f7faccc793" translate="yes" xml:space="preserve">
          <source>The programming language &lt;a href=&quot;https://en.wikipedia.org/wiki/CPL_(programming_language)&quot;&gt;CPL&lt;/a&gt; was first to introduce value categories for expressions: all CPL expressions can be evaluated in &quot;right-hand mode&quot;, but only certain kinds of expression are meaningful in &quot;left-hand mode&quot;. When evaluated in right-hand mode, an expression is regarded as being a rule for the computation of a value (the right-hand value, or</source>
          <target state="translated">프로그래밍 언어 &lt;a href=&quot;https://en.wikipedia.org/wiki/CPL_(programming_language)&quot;&gt;CPL&lt;/a&gt; 은 먼저 표현식의 값 범주를 도입했습니다. 모든 CPL 표현식은 &quot;오른손 모드&quot;에서 평가할 수 있지만 &quot;왼손 모드&quot;에서는 특정 종류의 식만 의미가 있습니다. 오른쪽 모드에서 평가할 때 식은 값 (오른쪽 값 또는</target>
        </trans-unit>
        <trans-unit id="67ad89355eacc86b3d6314eddebeebee7f14036d" translate="yes" xml:space="preserve">
          <source>The promise is the &quot;push&quot; end of the promise-future communication channel: the operation that stores a value in the shared state</source>
          <target state="translated">약속은 약속 미래 통신 채널의 &quot;푸시&quot;끝입니다. 공유 상태에 값을 저장하는 작업</target>
        </trans-unit>
        <trans-unit id="3f2caa469d3c691e3afe5b09718f95bd2b49a72b" translate="yes" xml:space="preserve">
          <source>The public functions of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; call this function only if &lt;code&gt;gptr() == nullptr&lt;/code&gt; or &lt;code&gt;gptr() &amp;gt;= egptr()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; 의 공개 함수는 &lt;code&gt;gptr() == nullptr&lt;/code&gt; 또는 &lt;code&gt;gptr() &amp;gt;= egptr()&lt;/code&gt; 경우에만이 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="775a778b55294eaa175c0471abd743cb50326787" translate="yes" xml:space="preserve">
          <source>The purpose of strict aliasing and related rules is to enable type-based alias analysis, which would be decimated if a program can validly create a situation where two pointers to unrelated types (e.g., an &lt;code&gt;int*&lt;/code&gt; and a &lt;code&gt;float*&lt;/code&gt;) could simultaneously exist and both can be used to load or store the same memory (see &lt;a href=&quot;http://www.open-std.org/pipermail/ub/2016-February/000565.html&quot;&gt;this email on SG12 reflector&lt;/a&gt;). Thus, any technique that is seemingly capable of creating such a situation necessarily invokes undefined behavior.</source>
          <target state="translated">엄격한 앨리어싱 및 관련 규칙의 목적은 유형 기반 별명 분석을 활성화하는 것입니다. 이는 프로그램이 관련없는 유형 (예 : &lt;code&gt;int*&lt;/code&gt; 및 &lt;code&gt;float*&lt;/code&gt; )에 대한 두 개의 포인터 가 동시에 존재할 수 있는 상황을 올바르게 만들 수있는 경우에 소멸됩니다. 둘 다 동일한 메모리를로드하거나 저장하는 데 사용될 수 있습니다 ( &lt;a href=&quot;http://www.open-std.org/pipermail/ub/2016-February/000565.html&quot;&gt;SG12 리플렉터에서이 이메일&lt;/a&gt; 참조 ). 따라서 이러한 상황을 만들 수있는 것으로 보이는 기술은 반드시 정의되지 않은 동작을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="537f9c0125fb3b536c8c2bddb97b517098935b00" translate="yes" xml:space="preserve">
          <source>The purpose of this adaptor is to correctly initialize stateful allocators in nested containers, such as when all levels of a nested container must be placed in the same shared memory segment. The adaptor's constructor takes the arguments for all allocators in the list, and each nested container obtains its allocator's state from the adaptor as needed.</source>
          <target state="translated">이 어댑터의 목적은 중첩 컨테이너의 모든 레벨을 동일한 공유 메모리 세그먼트에 배치해야하는 경우와 같이 중첩 컨테이너에서 상태 저장 할당자를 올바르게 초기화하는 것입니다. 어댑터의 생성자는 목록의 모든 할당 자에 대한 인수를 가져오고 중첩 된 각 컨테이너는 필요에 따라 어댑터에서 할당 자의 상태를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7c2a811b6c5574010f60bbd62805b17f3c0731ed" translate="yes" xml:space="preserve">
          <source>The purpose of this exception type is similar to the error condition &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; (thrown in &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; from member functions of &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;) and the related errno constant &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;EINVAL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예외 유형의 목적은 오류 조건 &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 의 멤버 함수 에서 &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 에서 발생 ) 및 관련 errno 상수 &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;EINVAL&lt;/a&gt;&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="1e645b45a5ffa08db62d4e0d26bad721f50ada62" translate="yes" xml:space="preserve">
          <source>The purpose of this rule is to help guard against violations of the &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;ODR&lt;/a&gt; for template instantiations:</source>
          <target state="translated">이 규칙의 목적은 템플릿 인스턴스화 에 대한 &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;ODR&lt;/a&gt; 위반을 방지하는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="e80a3e01ac05bea47ec62aef3af475352cd5d29f" translate="yes" xml:space="preserve">
          <source>The question mark escape sequence &lt;code&gt;\?&lt;/code&gt; is used to prevent &lt;a href=&quot;operator_alternative&quot;&gt;trigraphs&lt;/a&gt; from being interpreted inside string literals: a string such as &lt;code&gt;&quot;??/&quot;&lt;/code&gt; is compiled as &lt;code&gt;&quot;\&quot;&lt;/code&gt;, but if the second question mark is escaped, as in &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt;, it becomes &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</source>
          <target state="translated">물음표 이스케이프 시퀀스 &lt;code&gt;\?&lt;/code&gt; 방지하기 위해 사용 &lt;a href=&quot;operator_alternative&quot;&gt;trigraph를&lt;/a&gt; 문자열 리터럴 내에서 해석되는 것을을 : 같은 문자열 &lt;code&gt;&quot;??/&quot;&lt;/code&gt; 같은 컴파일 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 두 번째 질문 마크가 탈출되는 경우, 그러나 같이 &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt; , 그것은된다 &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20eb771689c7638596c471df8669135309db406f" translate="yes" xml:space="preserve">
          <source>The quiet NaN value that corresponds to the identifying string &lt;code&gt;arg&lt;/code&gt; or zero if the implementation does not support quiet NaNs.</source>
          <target state="translated">식별 문자열 &lt;code&gt;arg&lt;/code&gt; 에 해당하는 자동 NaN 값 또는 구현에서 자동 NaN을 지원하지 않는 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="eeac3ad06c66b3de50e5a83b3d29765e5993887a" translate="yes" xml:space="preserve">
          <source>The quotient is rounded in implementation-defined direction.</source>
          <target state="translated">몫은 구현 정의 방향으로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="ee33d1b33c8c2f838818ad7eab65d1c620ffa44b" translate="yes" xml:space="preserve">
          <source>The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that &lt;code&gt;quot * y + rem == x&lt;/code&gt;.</source>
          <target state="translated">몫은 소수 부분을 버린 대수 몫입니다 (0쪽으로 잘림). 나머지는 &lt;code&gt;quot * y + rem == x&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="501288be26edd4ded7871c5498abfbb8d63a43ff" translate="yes" xml:space="preserve">
          <source>The quotient is the result of the expression &lt;code&gt;x/y&lt;/code&gt;. The remainder is the result of the expression &lt;code&gt;x%y&lt;/code&gt;.</source>
          <target state="translated">몫은 표현식 &lt;code&gt;x/y&lt;/code&gt; 의 결과입니다 . 나머지는 표현식 &lt;code&gt;x%y&lt;/code&gt; 의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="0fcb33188a4836ac6fb56038cd09dd6ed5942b11" translate="yes" xml:space="preserve">
          <source>The quotient is truncated towards zero (fractional part is discarded).</source>
          <target state="translated">몫은 0쪽으로 잘립니다 (분수 부분은 버림).</target>
        </trans-unit>
        <trans-unit id="9dadf256e2d94d3cccaced5125b0d93a91578c9e" translate="yes" xml:space="preserve">
          <source>The random number library provides classes that generate random and pseudo-random numbers. These classes include:</source>
          <target state="translated">난수 라이브러리는 난수 및 의사 난수를 생성하는 클래스를 제공합니다. 이 수업에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b2af36c522baaa6141e4d68a47e9b38cf32d1814" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be at least partially ordered with respect to &lt;code&gt;value&lt;/code&gt;, i.e. it must satisfy all of the following requirements:</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위 는 &lt;code&gt;value&lt;/code&gt; 와 관련하여 적어도 부분적으로 정렬 되어야합니다. 즉, 다음 요구 사항을 모두 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc9d0a4e1c6b28a575aa6a4d6fa56412715ff389" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be partitioned with respect to the expression &lt;code&gt;!(value &amp;lt; element)&lt;/code&gt; or &lt;code&gt;!comp(value, element)&lt;/code&gt;, i.e., all elements for which the expression is &lt;code&gt;true&lt;/code&gt; must precede all elements for which the expression is &lt;code&gt;false&lt;/code&gt;. A fully-sorted range meets this criterion.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위 는 표현식 &lt;code&gt;!(value &amp;lt; element)&lt;/code&gt; 또는 &lt;code&gt;!comp(value, element)&lt;/code&gt; 와 관련하여 분할되어야합니다 . 즉, 표현식이 &lt;code&gt;true&lt;/code&gt; 인 모든 요소는 표현식이 &lt;code&gt;false&lt;/code&gt; 인 모든 요소 앞에 와야합니다. . 완전히 분류 된 범위가이 기준을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="531a6257f348bdfa0bffcab8f3aeb4dc7a540c17" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be partitioned with respect to the expression &lt;code&gt;element &amp;lt; value&lt;/code&gt; or &lt;code&gt;comp(element, value)&lt;/code&gt;, i.e., all elements for which the expression is &lt;code&gt;true&lt;/code&gt; must precede all elements for which the expression is &lt;code&gt;false&lt;/code&gt;. A fully-sorted range meets this criterion.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위 는 expression &lt;code&gt;element &amp;lt; value&lt;/code&gt; 또는 &lt;code&gt;comp(element, value)&lt;/code&gt; 와 관련하여 분할되어야합니다 . 즉, 표현식이 &lt;code&gt;true&lt;/code&gt; 인 모든 요소는 표현식이 &lt;code&gt;false&lt;/code&gt; 인 모든 요소 앞에 와야합니다 . 완전히 분류 된 범위가이 기준을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="17dad5b9e23c675ce64ce4c16ba529098428b325" translate="yes" xml:space="preserve">
          <source>The ranges library provides components for dealing with ranges of elements, including a variety of view adapters.</source>
          <target state="translated">범위 라이브러리는 다양한보기 어댑터를 포함하여 다양한 요소를 처리하기위한 구성 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bce2ca348110e7ef080f1a3a0d8246186d739693" translate="yes" xml:space="preserve">
          <source>The rank of the standard conversion sequence is the worst of the ranks of the standard conversions it holds (there may be up to &lt;a href=&quot;implicit_cast&quot;&gt;three conversions&lt;/a&gt;).</source>
          <target state="translated">표준 변환 순서의 순위는 표준 변환 순서 중 최악입니다 (최대 &lt;a href=&quot;implicit_cast&quot;&gt;3 개의 변환&lt;/a&gt; 이있을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="ebf3fa4c200bf79dc188b73503ec27a644a93938" translate="yes" xml:space="preserve">
          <source>The raw pointer overloads assume ownership of the pointed-to object. Therefore, constructing a &lt;code&gt;shared_ptr&lt;/code&gt; using the raw pointer overload for an object that is already managed by a &lt;code&gt;shared_ptr&lt;/code&gt;, such as by &lt;code&gt;shared_ptr(ptr.get())&lt;/code&gt; is likely to lead to undefined behavior, even if the object is of a type derived from &lt;code&gt;&lt;a href=&quot;../enable_shared_from_this&quot;&gt;std::enable_shared_from_this&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">원시 포인터 오버로드는 지정된 객체의 소유권을 가정합니다. 따라서 &lt;code&gt;shared_ptr(ptr.get())&lt;/code&gt; 과 같이 &lt;code&gt;shared_ptr&lt;/code&gt; 로 이미 관리되는 오브젝트에 대해 원시 포인터 과부하를 사용하여 &lt;code&gt;shared_ptr&lt;/code&gt; 을 구성 하면 오브젝트가 파생 된 유형 인 경우에도 정의되지 않은 동작이 발생할 수 있습니다 &lt;code&gt;&lt;a href=&quot;../enable_shared_from_this&quot;&gt;std::enable_shared_from_this&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad324bd2c8bc22b00758a73ea2fd6b6e48382778" translate="yes" xml:space="preserve">
          <source>The reallocation is done by either:</source>
          <target state="translated">재 할당은 다음 중 하나에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="cb5dae53afd6af85ce084febad2ae76f3864e626" translate="yes" xml:space="preserve">
          <source>The rebind member template alias makes it possible, given a pointer-like type that points to T, to obtain the same pointer-like type that points to U. For example,</source>
          <target state="translated">리 바인드 멤버 템플리트 별명을 사용하면 T를 가리키는 포인터와 같은 유형이 주어지면 U를 가리키는 동일한 포인터와 같은 유형을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a46abffdd1369d6dca8a8856866579f7f37a7e3" translate="yes" xml:space="preserve">
          <source>The recognized byte order marks are:</source>
          <target state="translated">인식되는 바이트 순서 표시는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39e0ee2810678b74b9059ddc4c64426403f4f32c" translate="yes" xml:space="preserve">
          <source>The reference may be invalidated by any operation on this &lt;code&gt;ios_base&lt;/code&gt; object, including another call to &lt;code&gt;iword()&lt;/code&gt;, but the stored values are retained, so that reading from &lt;code&gt;iword(index)&lt;/code&gt; with the same index later will produce the same value (until the next call to &lt;code&gt;&lt;a href=&quot;../basic_ios/copyfmt&quot;&gt;std::basic_ios::copyfmt()&lt;/a&gt;&lt;/code&gt;). The value can be used for any purpose. The index of the element must be obtained by a previous call to &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;, otherwise the behavior is undefined. New elements are initialized to &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iword()&lt;/code&gt; 다른 호출을 포함 하여이 &lt;code&gt;ios_base&lt;/code&gt; 객체 에 대한 작업으로 참조가 무효화 될 수 있지만 저장된 값이 유지되므로 나중에 동일한 인덱스를 가진 &lt;code&gt;iword(index)&lt;/code&gt; 에서 읽는 경우 동일한 값을 생성합니다 에 전화 &lt;code&gt;&lt;a href=&quot;../basic_ios/copyfmt&quot;&gt;std::basic_ios::copyfmt()&lt;/a&gt;&lt;/code&gt; ). 이 값은 어떤 목적으로도 사용될 수 있습니다. 이전에 &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; 호출하여 요소의 인덱스를 가져와야 합니다. 그렇지 않으면 동작이 정의되지 않습니다. 새로운 요소는 초기화됩니다 &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ac5c33641fd17dd4dcc39d735304c205b8e343f" translate="yes" xml:space="preserve">
          <source>The reference may be invalidated by any operation on this &lt;code&gt;ios_base&lt;/code&gt; object, including another call to &lt;code&gt;pword()&lt;/code&gt;, but the stored values are retained, so that reading from &lt;code&gt;pword(index)&lt;/code&gt; with the same index later will produce the same value (until the next call to &lt;code&gt;copyfmt()&lt;/code&gt;). The value can be used for any purpose. The index of the element must be obtained by &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;, otherwise the behavior is undefined. New elements are initialized to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pword()&lt;/code&gt; 다른 호출을 포함 하여이 &lt;code&gt;ios_base&lt;/code&gt; 객체 에 대한 작업으로 참조가 무효화 될 수 있지만 저장된 값이 유지되므로 나중에 동일한 인덱스를 가진 &lt;code&gt;pword(index)&lt;/code&gt; 에서 읽는 경우 동일한 값을 생성합니다 &lt;code&gt;copyfmt()&lt;/code&gt; 호출하십시오 . 이 값은 어떤 목적으로도 사용될 수 있습니다. 요소의 인덱스는 &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; 의해 얻어야합니다 . 그렇지 않으면 동작이 정의되지 않습니다. 새로운 요소는 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 로 초기화 됩니다 .</target>
        </trans-unit>
        <trans-unit id="f727f18de8aecc68a97ca4d05e8709c96ae21252" translate="yes" xml:space="preserve">
          <source>The referenced bit.</source>
          <target state="translated">참조 된 비트.</target>
        </trans-unit>
        <trans-unit id="01bad1a5bcb168d5223121e0f4bf36c7d217674b" translate="yes" xml:space="preserve">
          <source>The regex iterators are used to traverse the entire set of regular expression matches found within a sequence.</source>
          <target state="translated">정규식 반복자는 시퀀스 내에서 발견 된 전체 정규식 일치 세트를 순회하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="743f5a5a38b3f31dca5dec3dbda309eac3fee182" translate="yes" xml:space="preserve">
          <source>The regex library uses this trait to match characters against equivalence classes. For example, the regex &lt;code&gt;[[=a=]]&lt;/code&gt; is equivalent to the character &lt;code&gt;c1&lt;/code&gt; if &lt;code&gt;traits.transform_primary(c1)&lt;/code&gt; is equivalent to &lt;code&gt;traits.transform_primary(&quot;a&quot;)&lt;/code&gt; (which is true for any &lt;code&gt;c1&lt;/code&gt; from &lt;code&gt;&quot;A&amp;Agrave;&amp;Aacute;&amp;Acirc;&amp;Atilde;&amp;Auml;&amp;Aring;a&amp;agrave;&amp;aacute;&amp;acirc;&amp;atilde;&amp;auml;&amp;aring;&quot;&lt;/code&gt; in the U.S. English locale). Note that &lt;code&gt;transform_primary()&lt;/code&gt; takes a character sequence argument because equivalence classes may be multicharacter, such as &lt;code&gt;[[=ch=]]&lt;/code&gt; in Czech or &lt;code&gt;[[=dzs=]]&lt;/code&gt; in Hungarian.</source>
          <target state="translated">정규식 라이브러리는이 특성을 사용하여 문자를 등가 클래스와 일치시킵니다. 예를 들면, 정규식 &lt;code&gt;[[=a=]]&lt;/code&gt; 문자 동등 &lt;code&gt;c1&lt;/code&gt; 경우 &lt;code&gt;traits.transform_primary(c1)&lt;/code&gt; 동등 &lt;code&gt;traits.transform_primary(&quot;a&quot;)&lt;/code&gt; (모든 마찬가지이다 &lt;code&gt;c1&lt;/code&gt; 에서 &lt;code&gt;&quot;A&amp;Agrave;&amp;Aacute;&amp;Acirc;&amp;Atilde;&amp;Auml;&amp;Aring;a&amp;agrave;&amp;aacute;&amp;acirc;&amp;atilde;&amp;auml;&amp;aring;&quot;&lt;/code&gt; 미국 영어 로케일). 참고 &lt;code&gt;transform_primary()&lt;/code&gt; 등가 클래스를 위해 다중 수 있기 때문에 같은 문자 시퀀스 인수를 &lt;code&gt;[[=ch=]]&lt;/code&gt; 체코 또는 &lt;code&gt;[[=dzs=]]&lt;/code&gt; 헝가리어있다.</target>
        </trans-unit>
        <trans-unit id="9f22234d3d01dbb3d192f98f1564dcc90f3845ce" translate="yes" xml:space="preserve">
          <source>The regex traits class is used to encapsulate the localizable aspects of a regex.</source>
          <target state="translated">정규식 특성 클래스는 정규식의 지역화 가능한 측면을 캡슐화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8e02428e99c6a674a0fa0458c46a3675989e16b2" translate="yes" xml:space="preserve">
          <source>The registered functions will not be called on &lt;a href=&quot;exit&quot;&gt;normal program termination&lt;/a&gt;. If a function need to be called in that case, &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; must be used.</source>
          <target state="translated">등록 된 기능은 &lt;a href=&quot;exit&quot;&gt;정상적인 프로그램 종료시&lt;/a&gt; 호출되지 않습니다 . 이 경우 함수를 호출해야하는 경우 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f472a11dda174644bf194c3cc7207153d73cf754" translate="yes" xml:space="preserve">
          <source>The regular expressions library provides a class that represents &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expressions&lt;/a&gt;, which are a kind of mini-language used to perform pattern matching within strings. Almost all operations with regexes can be characterized by operating on several of the following objects:</source>
          <target state="translated">정규 표현식 라이브러리를 나타내는 클래스 제공하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;정규 표현식&lt;/a&gt; 문자열 내에서 패턴 매칭을 수행하는 데 사용 미니 언어의 일종이다. 정규 표현식을 사용하는 거의 모든 작업은 다음과 같은 여러 개체에서 작동하여 특성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e11489a7a30fc1b23c96dca40b2ff8e966f4c67" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="translated">관련 POSIX 함수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; 은 &lt;code&gt;command&lt;/code&gt; 생성 된 출력 을 호출자가 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="315f5ac4df7e6df130a13d2b962900690dfeac97" translate="yes" xml:space="preserve">
          <source>The related function &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;std::puts&lt;/a&gt;&lt;/code&gt; appends a newline character to the output, while &lt;code&gt;std::fputs&lt;/code&gt; writes the string unmodified.</source>
          <target state="translated">관련 함수 &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;std::puts&lt;/a&gt;&lt;/code&gt; 는 개행 문자를 출력 에 추가하는 반면 &lt;code&gt;std::fputs&lt;/code&gt; 는 수정되지 않은 문자열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="d291a968b1bde0de4066d9697100b3323d6aed59" translate="yes" xml:space="preserve">
          <source>The removal of the top-level cv-qualifiers does not affect the type of the parameter as it appears within the function:</source>
          <target state="translated">최상위 cv 한정자를 제거해도 함수 내에 나타나는 매개 변수 유형에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f57795c7e42d94ba6cd16bf8ded7489abce05bb" translate="yes" xml:space="preserve">
          <source>The replaceable deallocation functions (1-10) are implicitly declared in each translation unit even if the &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; header is not included. These functions are</source>
          <target state="translated">교체 가능한 할당 해제 기능 (1-10)은 &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; 헤더가 포함되지 않은 경우에도 각 변환 단위에 암시 적으로 선언 됩니다. 이 기능들은</target>
        </trans-unit>
        <trans-unit id="757b1dc67e0f36307d54e167b8d8bfa8908ff42c" translate="yes" xml:space="preserve">
          <source>The representation of the named collating element as a character string.</source>
          <target state="translated">명명 된 배열 요소를 문자열로 표현</target>
        </trans-unit>
        <trans-unit id="b55071f5f9ba9ea7bf92c82884c22a3d16d81678" translate="yes" xml:space="preserve">
          <source>The representation type of &lt;code&gt;C1::duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;C1::duration&lt;/code&gt; 의 표시 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="1064d717e4d3fd4142b0aa2898a18bce9888f7d4" translate="yes" xml:space="preserve">
          <source>The requested subspan &lt;code&gt;r&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() + Offset&lt;/code&gt;. If &lt;code&gt;Count&lt;/code&gt; is &lt;code&gt;std::dynamic_extent&lt;/code&gt;, &lt;code&gt;r.size() == this-&amp;gt;size() - Offset&lt;/code&gt;; otherwise &lt;code&gt;r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">요청 서브 스팬 &lt;code&gt;r&lt;/code&gt; ,되도록 &lt;code&gt;r.data() == this-&amp;gt;data() + Offset&lt;/code&gt; . 경우 &lt;code&gt;Count&lt;/code&gt; 입니다 &lt;code&gt;std::dynamic_extent&lt;/code&gt; , &lt;code&gt;r.size() == this-&amp;gt;size() - Offset&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;r.size() == Count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe5a8c15412cf1fce3c28473df37a2f3d1062165" translate="yes" xml:space="preserve">
          <source>The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;, but many member functions impose stricter requirements.</source>
          <target state="translated">요소에 부과되는 요구 사항은 컨테이너에서 수행되는 실제 작업에 따라 다릅니다. 일반적으로 요소 유형은 완전한 유형이어야하며 &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt; 의 요구 사항을 충족해야 하지만 많은 멤버 함수는보다 엄격한 요구 사항을 부과합니다.</target>
        </trans-unit>
        <trans-unit id="f623316ac29c804d31fa0890dce0da472d8e6d58" translate="yes" xml:space="preserve">
          <source>The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;allocator completeness requirements&lt;/a&gt;.</source>
          <target state="translated">요소에 부과되는 요구 사항은 컨테이너에서 수행되는 실제 작업에 따라 다릅니다. 일반적으로 요소 유형은 &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt; 의 요구 사항을 충족해야 하지만 많은 멤버 함수는 더 엄격한 요구 사항을 부과합니다. &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;할당자가 할당 자 완전성 요구 사항을&lt;/a&gt; 충족하면이 컨테이너 (구성원은 아님)를 불완전한 요소 유형으로 인스턴스화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e9510a237cd6950e335a276b93cd34d804cbc1a" translate="yes" xml:space="preserve">
          <source>The result is</source>
          <target state="translated">결과는</target>
        </trans-unit>
        <trans-unit id="c3b6b8e653050978d1c05509c50d363265c5437e" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;false&lt;/code&gt; if the expression contains at least one of the following potentially evaluated constructs:</source>
          <target state="translated">표현식에 잠재적으로 평가 된 다음 구성 중 하나 이상이 포함 된 경우 결과는 &lt;code&gt;false&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="d1a4aaa48d46c71750bcb89a022288521d191ab7" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if the set of &lt;a href=&quot;except_spec&quot;&gt;&lt;i&gt;potential exceptions&lt;/i&gt;&lt;/a&gt; of the expression is empty, and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">식 의 &lt;a href=&quot;except_spec&quot;&gt;&lt;i&gt;잠재적 예외&lt;/i&gt;&lt;/a&gt; 집합 이 비어 있으면 결과가 &lt;code&gt;true&lt;/code&gt; 이고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="be94375a32ef05e8f88fd30d56ae6e5233b9d27e" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den + R2::num * R1::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 전문화 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;Num == R1::num * R2::den + R2::num * R1::den&lt;/code&gt; 및 &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (산술 오버 플로우없이 계산 됨), &lt;code&gt;U&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 이고 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2524aa66759b404de95e3dd437f92ac60fcc7942" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den - R2::num * R1::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 전문화 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; 이며 &lt;code&gt;Num == R1::num * R2::den - R2::num * R1::den&lt;/code&gt; 및 &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (산술 오버 플로우없이 계산 됨), &lt;code&gt;U&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 이고 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="acb3b2cb8d2a5ff6feda727827cb87392d9546ad" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::num&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 전문화 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;Num == R1::num * R2::den&lt;/code&gt; 및 &lt;code&gt;Denom == R1::den * R2::num&lt;/code&gt; (없이 계산 된) 산술 오버플로), &lt;code&gt;U&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 이고 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f389c36e6b41ab6b3fdb4d5ce8f967c0c0ccebe" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::num&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 전문화 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;Num == R1::num * R2::num&lt;/code&gt; 및 &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (없이 계산 된) 산술 오버플로), &lt;code&gt;U&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 이고 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e68dbec571d137df08d9f883c38ccb0b5e7b5985" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;bool&lt;/code&gt; prvalue.</source>
          <target state="translated">결과는 &lt;code&gt;bool&lt;/code&gt; prvalue입니다.</target>
        </trans-unit>
        <trans-unit id="e2c4bb4518db49d6f285ab22da7870886f0081c4" translate="yes" xml:space="preserve">
          <source>The result is ready</source>
          <target state="translated">결과는 준비되었습니다</target>
        </trans-unit>
        <trans-unit id="580dbf951c94723d3af7b9d08b23514681e24e3d" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from the enum's underlying type to the destination type.</source>
          <target state="translated">결과는 열거 형의 기본 유형에서 대상 유형 으로의 &lt;a href=&quot;implicit_cast&quot;&gt;암시 적 변환&lt;/a&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="cbbaf37dfe4267e58c22583ee6fab6ad33d0d8fd" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;a href=&quot;implicit_cast#Floating.E2.80.93integral_conversions&quot;&gt;converting&lt;/a&gt; the original value first to the underlying type of the enumeration, and then to the enumeration type.</source>
          <target state="translated">결과는 원래 값을 먼저 열거의 기본 유형 으로 &lt;a href=&quot;implicit_cast#Floating.E2.80.93integral_conversions&quot;&gt;변환&lt;/a&gt; 한 다음 열거 유형 으로 변환 하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a957f8ea1f391e7935ddb74dad2e1448951ecef7" translate="yes" xml:space="preserve">
          <source>The result may have little or no significance if the magnitude of &lt;code&gt;arg&lt;/code&gt; is large.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 의 크기 가 크면 결과에 유의성이 없거나 거의 없을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="870fcd3df093829aaa26fd2db3dbce5ac0e9700e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;!arg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!arg&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="e6e1af8324720028e132b94fe61c4514f56e4941" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;-arg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-arg&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="3a411985e21ab920e38a5852e204b8af0e20a27e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) == &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) == &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80ec200a207a639219d15d9ccfe372f86eab6036" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) | &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) | &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e64ce1e5aed1c40811afecb3dc7fbb9b0c9b98a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) || &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) || &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee0825f237fb1718d9a9117588e0d38939c42fd3" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;(0, 0)&lt;/code&gt; is implementation-defined.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;(0, 0)&lt;/code&gt; 의 결과 는 구현 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="acf2c3f21b47e9f1630796369e072a4335640eda" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs != rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs != rhs&lt;/code&gt; 의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="4e6e472de88efa439e4f8ac01ef503fb42158a44" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs % rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs % rhs&lt;/code&gt; 의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="d4c5e47c305ac62f9aa59e69771dddcae5c999a2" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;amp; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;amp; rhs&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="e95d02148bc8a4f7ae12814dcba7c7fe81fbedaf" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;amp;&amp;amp; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;amp;&amp;amp; rhs&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="fa6dd6207a762f8224d24ca1b87c1fcc621652fa" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="9f4b083947ef6aa836be0e4780f07e0aadcf1e43" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;gt;= rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;gt;= rhs&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="e8f2b531e796e45b234ba714ef92019621ac8f1b" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="d3e99c51790273d3fd02297fcb57fd200d05fec1" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;lt;= rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;lt;= rhs&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="e05f6b812268f1065a685db8b9a51d0ed85af871" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs * rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs * rhs&lt;/code&gt; 의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="fa8335ddae097460592407def0f6f7f6531b4bde" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs + rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs + rhs&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="632ae131fa96ce384c426b305a35eb2730ac7e17" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs - rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs - rhs&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="914a5eae959d8077c3946fcd30325aab12d6c2f1" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs / rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs / rhs&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="1542bda1bc0df08cd4e2da32ce9c1c4158ea1b29" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs ^ rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs ^ rhs&lt;/code&gt; 의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="f829b25d22cfb56ef72ca8c031ffcc768468e0a2" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs | rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs | rhs&lt;/code&gt; 의 결과 | rhs .</target>
        </trans-unit>
        <trans-unit id="c15c8b1e6d71bff19e0100cd1bb43d0aaf22d25a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs || rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs || rhs&lt;/code&gt; 의 결과 || rhs .</target>
        </trans-unit>
        <trans-unit id="8a2cfe39bb4bca238a75c100d57a8e16e49b74ab" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;operator*&lt;/code&gt; or &lt;code&gt;operator-&amp;gt;&lt;/code&gt; on the end iterator is undefined behavior.</source>
          <target state="translated">엔드 반복자 의 &lt;code&gt;operator*&lt;/code&gt; 또는 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 결과 는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="006f10ce7b3c5cdf0abdf83cfb46f3ea491450f3" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;sizeof&lt;/code&gt; is always nonzero, even if applied to an empty class type.</source>
          <target state="translated">빈 클래스 유형에 적용 되더라도 &lt;code&gt;sizeof&lt;/code&gt; 의 결과 는 항상 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="cff04ad9446c1f408f431157236a6d0631af546f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;~arg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;~arg&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="e9685a2aebbafc6d384174b50e75064f891cc1ef" translate="yes" xml:space="preserve">
          <source>The result of attempting to determine the size of a directory (as well as any other file that is not a regular file or a symlink) is implementation-defined.</source>
          <target state="translated">디렉토리 (정규 파일 또는 심볼릭 링크가 아닌 다른 파일)의 크기를 결정한 결과는 구현에 따라 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="247e8d93cf388f43a2c1c6cc6c4100ee34ada80f" translate="yes" xml:space="preserve">
          <source>The result of calling most member functions of the match_results object that is not</source>
          <target state="translated">match_results 객체의 대부분의 멤버 함수를 호출 한 결과</target>
        </trans-unit>
        <trans-unit id="21e3ce4be4c110e9cc76bfe73bc7a78e82910174" translate="yes" xml:space="preserve">
          <source>The result of comparing two pointers to members (after conversions) is defined as follows:</source>
          <target state="translated">두 포인터를 멤버와 비교 한 결과 (변환 후)는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="32f37ca48793604634e4bf49c6103814193272fa" translate="yes" xml:space="preserve">
          <source>The result of comparing two pointers to objects (after conversions) is defined as follows:</source>
          <target state="translated">두 개의 포인터를 객체와 비교 한 결과 (변환 후)는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0290b3221f34a8546049c1fe37f0a1d16a5a5bef" translate="yes" xml:space="preserve">
          <source>The result of converting a negative number string into an unsigned integer was specified to produce zero until C++17, although some implementations followed the protocol of &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; which negates in the target type, giving &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&quot;-1&quot;&lt;/code&gt;, and so produce the largest value of the target type instead. As of C++17, strictly following &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; is the correct behavior.</source>
          <target state="translated">음수 문자열을 부호없는 정수로 변환 한 결과는 C ++ 17까지 0을 생성하도록 지정되었지만 일부 구현 은 대상 유형에서 무효화되는 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; 프로토콜 을 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;&quot;-1&quot;&lt;/code&gt; 을 제공합니다 . 대신 대상 유형의 가장 큰 값을 생성하십시오. C ++ 17부터 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; 엄격하게 따르는 것이 올바른 동작입니다.</target>
        </trans-unit>
        <trans-unit id="dd0729a11dfb5de4b72c38a2205cbf06dfb22a46" translate="yes" xml:space="preserve">
          <source>The result of equality comparison of two pointers (after conversions) is defined as follows:</source>
          <target state="translated">변환 후 두 포인터의 동등 비교 결과는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="47a73f53b39aa715441c99e5f455152b99e4705b" translate="yes" xml:space="preserve">
          <source>The result of operator~ is the bitwise NOT (one's complement) value of the argument (after promotion). The result of operator&amp;amp; is the bitwise AND value of the operands (after usual arithmetic conversions). The result of operator| is the bitwise OR value of the operands (after usual arithmetic conversions). The result of operator^ is the bitwise XOR value of the operands (after usual arithmetic conversions).</source>
          <target state="translated">operator ~의 결과는 인수의 승격 후 비트 NOT (1의 보수) 값입니다. operator &amp;amp;의 결과는 피연산자의 비트 AND 값입니다 (일반적인 산술 변환 후). 운영자의 결과 | 피연산자의 비트 단위 OR 값입니다 (일반 산술 변환 후). operator ^의 결과는 피연산자의 비트 XOR 값입니다 (일반적인 산술 변환 후).</target>
        </trans-unit>
        <trans-unit id="e0eb608d51cf5832fadd72c5babd7a6e03e98a43" translate="yes" xml:space="preserve">
          <source>The result of path concatenation.</source>
          <target state="translated">경로 연결의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="4f62a6ed94a5ad3247f5fc515a6a3e14d480ed26" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;month&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::months&lt;/code&gt;. That duration unit represents the length of the average Gregorian month, and the resulting duration bears no relationship to the number of days in the particular months represented by the operands. For example, &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt; - &lt;a href=&quot;../month&quot;&gt;std::chrono::March&lt;/a&gt;)&lt;/code&gt; is not the number of seconds in March (&lt;code&gt;2678400s&lt;/code&gt;), but &lt;code&gt;2629746s&lt;/code&gt; (30.436875 days).</source>
          <target state="translated">두 &lt;code&gt;month&lt;/code&gt; 값 을 뺀 결과는 &lt;code&gt;std::chrono::months&lt;/code&gt; 유형의 지속 시간입니다. . 이 기간 단위는 평균 그레고리력 월의 길이를 나타내며 결과 기간은 피연산자가 나타내는 특정 월의 일 수와 관련이 없습니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt; - &lt;a href=&quot;../month&quot;&gt;std::chrono::March&lt;/a&gt;)&lt;/code&gt; 는 3 월 ( &lt;code&gt;2678400s&lt;/code&gt; ) 의 초 수가 아니라 &lt;code&gt;2629746s&lt;/code&gt; (30.436875 일)입니다.</target>
        </trans-unit>
        <trans-unit id="17172fd81702e28b82e8d13798f7b61c7c8f7b83" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;year&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::years&lt;/code&gt;. This duration unit represents the length of the average Gregorian year, and the resulting duration bears no relationship to the number of days in the particular years represented by the operands. For example, the result of &lt;code&gt;2018y - 2017y&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(1)&lt;/code&gt;, which represents 365.2425 days, not 365 days.</source>
          <target state="translated">2 &lt;code&gt;year&lt;/code&gt; 값 을 뺀 결과는 &lt;code&gt;std::chrono::years&lt;/code&gt; 유형의 기간입니다 . 이 기간 단위는 평균 그레고리력 연도의 길이를 나타내며 결과 기간은 피연산자가 나타내는 특정 연도의 일 수와 관련이 없습니다. 예를 들어 &lt;code&gt;2018y - 2017y&lt;/code&gt; 의 결과 는 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(1)&lt;/code&gt; 이며 365 일이 아닌 365.2425 일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="36c4afa551c41832fffe70e348da9af50d440abe" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;year_month&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::months&lt;/code&gt;. This duration unit represents the length of the average Gregorian month (30.436875 days), and the resulting duration bears no relationship to the actual number of days in the time period at issue. For example, the result of &lt;code&gt;2017y/3 - 2017y/2&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(1)&lt;/code&gt;, even though February 2017 only contains 28 days.</source>
          <target state="translated">2를 뺀 결과 &lt;code&gt;year_month&lt;/code&gt; 값 &lt;code&gt;std::chrono::months&lt;/code&gt; 유형의 지속 기간입니다 . 이 기간 단위는 평균 그레고리력 월 (30.436875 일)의 길이를 나타내며 결과 기간은 문제가 발생한 기간의 실제 일수와 관련이 없습니다. 예를 들어 &lt;code&gt;2017y/3 - 2017y/2&lt;/code&gt; 의 결과 는 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(1)&lt;/code&gt; 이지만 2017 년 2 월에는 28 일만 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3315b545d55c361d494aaf334e4af2659a2548d" translate="yes" xml:space="preserve">
          <source>The result of the comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*obj&lt;/code&gt; was equal to &lt;code&gt;*expected&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">비교 결과 : &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;*obj&lt;/code&gt; 가 동일했다가합니다 &lt;code&gt;*expected&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="e25c0d3525dfeb8bfa6ff74fcf703d161b32cfb4" translate="yes" xml:space="preserve">
          <source>The result of the conversion as described above:</source>
          <target state="translated">위에서 설명한 변환 ​​결과 :</target>
        </trans-unit>
        <trans-unit id="3870571eecc090d22dc21a8b93d45f1df9a1dda1" translate="yes" xml:space="preserve">
          <source>The result of the conversion, determined as described above.</source>
          <target state="translated">전술 한 바와 같이 결정된 변환 결과.</target>
        </trans-unit>
        <trans-unit id="5cfae012b116826024fbc12ba5aac5a29cc79ff0" translate="yes" xml:space="preserve">
          <source>The result of the expression always has type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">표현식의 결과는 항상 &lt;code&gt;void&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="d11a68b7fc68b552ec64c618e13fe680bd75b63e" translate="yes" xml:space="preserve">
          <source>The result type generated by the generator. The effect is undefined if this is not one of &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">생성기에 의해 생성 된 결과 유형입니다. 이것이 &lt;code&gt;float&lt;/code&gt; 중 하나가 아닌 경우 효과는 정의되지 않습니다 . &lt;code&gt;double&lt;/code&gt; 또는 &lt;code&gt;long double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e80eecc0596c35730188bd9f4d1c551f3febc94" translate="yes" xml:space="preserve">
          <source>The result type generated by the generator. The effect is undefined if this is not one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, or &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">생성기에 의해 생성 된 결과 유형입니다. &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; , &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; 중 하나가 아닌 경우 효과가 정의되지 않습니다. . &lt;code&gt;unsigned long&lt;/code&gt; 또는 &lt;code&gt;unsigned long long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5521797ee22c876e97965af0d7522808846e3d59" translate="yes" xml:space="preserve">
          <source>The result value can be unambiguously converted to &lt;code&gt;T&lt;/code&gt; (1-3) or &lt;code&gt;bool&lt;/code&gt; (4).</source>
          <target state="translated">결과 값을 명확하게 변환 할 수 있습니다 &lt;code&gt;T&lt;/code&gt; (1-3) 또는 &lt;code&gt;bool&lt;/code&gt; (4) .</target>
        </trans-unit>
        <trans-unit id="f6bb786c46da806f276663a0a370a0140bec8af4" translate="yes" xml:space="preserve">
          <source>The result value can be unambiguously converted to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">결과 값을 분명하게 &lt;code&gt;bool&lt;/code&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43655266ec179e649b00784deeb0b1a3c97d236d" translate="yes" xml:space="preserve">
          <source>The resultant offset converted to &lt;code&gt;pos_type&lt;/code&gt; on success or &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure.</source>
          <target state="translated">결과 오프셋을 &lt;code&gt;pos_type&lt;/code&gt; 으로 변환성공시 으로 되거나 &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; , 실패 하면 pos_type (off_type (-1)) 으로 .</target>
        </trans-unit>
        <trans-unit id="ef23966d370102deb412213da03cdcdb6c680d1f" translate="yes" xml:space="preserve">
          <source>The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">결과 범위는 입력 범위 중 하나와 겹칠 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="29d5035de2621e71a90038d6802a888a677db3c5" translate="yes" xml:space="preserve">
          <source>The resulting range is also sorted. Equivalent elements are treated individually, that is, if some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, it will be copied to &lt;code&gt;d_first&lt;/code&gt; exactly &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(m-n, 0)&lt;/code&gt; times. The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">결과 범위도 정렬됩니다. 상응하는 요소는 어떤 요소가 발견 된 경우, 즉, 개별적으로 취급된다 &lt;code&gt;m&lt;/code&gt; 의 시간 &lt;code&gt;[first1, last1)&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 의 시간 &lt;code&gt;[first2, last2)&lt;/code&gt; 이를 위해 복사 될 &lt;code&gt;d_first&lt;/code&gt; 정확하게 &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(m-n, 0)&lt;/code&gt; 시간. 결과 범위는 입력 범위 중 하나와 겹칠 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aaddb0a6756a877f4864ff06a8fc5e72ffd2f6e1" translate="yes" xml:space="preserve">
          <source>The resulting string contains &lt;code&gt;N&lt;/code&gt; characters with the first character corresponds to the last (&lt;code&gt;N-1&lt;/code&gt;th) bit and the last character corresponding to the first bit.</source>
          <target state="translated">결과 문자열에는 &lt;code&gt;N&lt;/code&gt; 이 포함됩니다. 마지막으로 첫 번째 문자의 대응과 문자 ( &lt;code&gt;N-1&lt;/code&gt; 번째) 비트에 해당하고 첫 번째 비트에 해당하는 마지막 문자 됩니다.</target>
        </trans-unit>
        <trans-unit id="b17d4cd7b0868b24196c899cf5191cb1faa7ed25" translate="yes" xml:space="preserve">
          <source>The resulting valarray with circularly shifted elements.</source>
          <target state="translated">원형으로 이동 된 요소가있는 결과적인 valarray.</target>
        </trans-unit>
        <trans-unit id="7458cef4d81e04aca531157faaf437f90b8b5f76" translate="yes" xml:space="preserve">
          <source>The resulting valarray with shifted elements.</source>
          <target state="translated">요소가 바뀐 결과 valarray.</target>
        </trans-unit>
        <trans-unit id="83ad9cb498edc1aa4891b4efbe63cabce32603fe" translate="yes" xml:space="preserve">
          <source>The resulting valarray with values acquired by applying function &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;func&lt;/code&gt; 를 적용하여 얻은 값을 가진 결과 valarray .</target>
        </trans-unit>
        <trans-unit id="4e5c65b16e68930d61a611b38a71296f2506a4cf" translate="yes" xml:space="preserve">
          <source>The resulting value (that is, the result of applying the corresponding binary operator to the value immediately preceding the effects of the corresponding member function in the &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*this&lt;/code&gt;).</source>
          <target state="translated">결과 값 (즉, 해당 이항 연산자를 해당 멤버 함수의 효과 바로 앞에있는 값 에 &lt;code&gt;*this&lt;/code&gt; 의 &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;수정 순서&lt;/a&gt; 로 적용한 결과) ).</target>
        </trans-unit>
        <trans-unit id="e814d10c5d370f3f42c2fca47efc512b44b14a3c" translate="yes" xml:space="preserve">
          <source>The resulting value (that is, the result of applying the corresponding binary operator to the value immediately preceding the effects of the corresponding member function).</source>
          <target state="translated">결과 값 (즉, 해당 2 진 연산자를 해당 멤버 함수의 효과 직전 값에 적용한 결과).</target>
        </trans-unit>
        <trans-unit id="3389100e45b720cf6eb81e6827f7706cb90c9259" translate="yes" xml:space="preserve">
          <source>The return from the</source>
          <target state="translated">에서 반환</target>
        </trans-unit>
        <trans-unit id="53209406292002d9313d7e4939097156f31cc15e" translate="yes" xml:space="preserve">
          <source>The return statements in a discarded statement do not participate in function return type deduction:</source>
          <target state="translated">폐기 된 명령문의 리턴 문은 함수 리턴 유형 공제에 참여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ed22644873dd55c750986fea93019dbd3388a1d" translate="yes" xml:space="preserve">
          <source>The return type does not add more than two levels of template nesting over the most deeply-nested argument type.</source>
          <target state="translated">반환 유형은 가장 깊이 중첩 된 인수 유형에 대해 템플릿 중첩 수준을 두 개 이상 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7613f3aef88eece4db1f4660060fab1d18285727" translate="yes" xml:space="preserve">
          <source>The return type is &lt;code&gt;void*&lt;/code&gt; (rather than, e.g., &lt;code&gt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&lt;/code&gt;) to support conversion to an arbitrary pointer type &lt;code&gt;U*&lt;/code&gt; by &lt;code&gt;static_cast&amp;lt;U*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;U*&amp;gt;&lt;/code&gt; 의한 임의의 포인터 유형 &lt;code&gt;U*&lt;/code&gt; 로의 변환을 지원하기 위해 리턴 유형은 &lt;code&gt;void*&lt;/code&gt; (예 : &lt;code&gt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&lt;/code&gt; ) 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="4d5d71418aa972f29b239eb90d69468e90bb0941" translate="yes" xml:space="preserve">
          <source>The return type is the type of the left operand after integral promotions.</source>
          <target state="translated">리턴 유형은 적분 승격 후 왼쪽 피연산자의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4fa9717f5967413803e02aa6bb2883c955d4365a" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../numeric/valarray/begin2&quot;&gt;&lt;code&gt;begin(valarray)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../numeric/valarray/end2&quot;&gt;&lt;code&gt;end(valarray)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../numeric/valarray/begin2&quot;&gt; &lt;code&gt;begin(valarray)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../numeric/valarray/end2&quot;&gt; &lt;code&gt;end(valarray)&lt;/code&gt; &lt;/a&gt; 의 반환 유형</target>
        </trans-unit>
        <trans-unit id="4b467b24eb3e95658db04cc2efccee281ce62fa6" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a function. Otherwise, not defined</source>
          <target state="translated">의 반환 형식 &lt;code&gt;T&lt;/code&gt; 의 경우 &lt;code&gt;T&lt;/code&gt; 는 기능입니다. 그렇지 않으면 정의되지 않은</target>
        </trans-unit>
        <trans-unit id="fc619118262950fb869b5d544147bd07c7f92619" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;filter_view::begin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter_view::begin&lt;/code&gt; 의 반환 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="8a173a812528e6c04c2d8704d2f8d1773cc20a31" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;filter_view::end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter_view::end&lt;/code&gt; 의 반환 유형 .</target>
        </trans-unit>
        <trans-unit id="7f8cc94f3fe57edcbe4e00cf3aaac26990fe1598" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;iota_view::begin&lt;/code&gt;.</source>
          <target state="translated">반환 유형은 &lt;code&gt;iota_view::begin&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7eef554336055de8435461fe71844804d344403e" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;iota_view::end&lt;/code&gt;.</source>
          <target state="translated">반환 유형은 &lt;code&gt;iota_view::end&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7d16c75ab67ddd9e46691a2a894ba5baeac787d8" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind&lt;/code&gt; holds a member object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;, and one object per each of &lt;code&gt;args...&lt;/code&gt;, of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Arg_i&amp;gt;::type&lt;/code&gt;, similarly constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Arg_i&amp;gt;(arg_i)&lt;/code&gt;.</source>
          <target state="translated">의 리턴 타입 &lt;code&gt;std::bind&lt;/code&gt; 형식의 부재 객체 보유 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; 으로 구성 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; 및 각각 하나씩 객체 &lt;code&gt;args...&lt;/code&gt; , 유형을 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Arg_i&amp;gt;::type&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Arg_i&amp;gt;(arg_i)&lt;/code&gt; &amp;lt;Arg_i&amp;gt; (arg_i) 와 유사하게 구성 .</target>
        </trans-unit>
        <trans-unit id="fde0844a0606e7893f2ea00fd18105a16696460c" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; if all of its member objects (specified above) are CopyConstructible, and is &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; otherwise. The type defines the following members:</source>
          <target state="translated">의 반환 형식 &lt;code&gt;std::bind&lt;/code&gt; 입니다 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; (이상 지정)의 구성원 개체의 모든 CopyConstructible (복사 가능 생성자)를하는 경우,이고 &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; 달리. 유형은 다음 멤버를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6c0953e38415f15fb34763f7446d0d031ca5c65a" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind_front&lt;/code&gt; behaves as if its copy/move constructors perform a memberwise copy/move. It is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; if all of its member objects (specified above) are CopyConstructible, and is &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;std::bind_front&lt;/code&gt; 의 반환 유형은 복사 / 이동 생성자가 멤버 별 복사 / 이동을 수행하는 것처럼 동작합니다. 그것은 인 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; (상기 지정) 산하의 모든 객체가 CopyConstructible (복사 가능 생성자)를하는 경우이며 &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible는&lt;/a&gt; 달리.</target>
        </trans-unit>
        <trans-unit id="f29ace211ba147bca17300e0f5b8c1b51fd281da" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::not_fn&lt;/code&gt; holds a member object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::not_fn&lt;/code&gt; 의 리턴 유형은 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; &amp;lt;F&amp;gt; 유형의 멤버 오브젝트를 보유합니다. .</target>
        </trans-unit>
        <trans-unit id="313e4bd0b86dc792bb66113e7c07635c9c275b3f" translate="yes" xml:space="preserve">
          <source>The return type of a conditional operator is also accessible as the binary type trait &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">조건부 연산자의 반환 유형은 이진 유형 특성 &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; 액세스 할 수도 있습니다. .</target>
        </trans-unit>
        <trans-unit id="76f32cdf7dc810987e937f22df27363914ee508e" translate="yes" xml:space="preserve">
          <source>The return type of a function call expression is the return type of the chosen function, decided using static binding (ignoring the &lt;code&gt;virtual&lt;/code&gt; keyword), even if the overriding function that's actually called returns a different type. This allows the overriding functions to return pointers or references to classes that are derived from the return type returned by the base function, i.e. C++ supports &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariant_return_type&quot;&gt;covariant return types&lt;/a&gt;. If &lt;code&gt;E&lt;/code&gt; specifies a destructor, the return type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">함수 호출 표현식의 리턴 유형은 실제로 호출되는 대체 함수가 다른 유형을 리턴하더라도 정적 바인딩을 사용하여 결정된 ( &lt;code&gt;virtual&lt;/code&gt; 키워드 무시) 선택한 함수 의 리턴 유형입니다. 이를 통해 재정의 함수는 기본 함수에 의해 반환 된 반환 형식에서 파생 된 클래스에 대한 포인터 또는 참조를 &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariant_return_type&quot;&gt;반환 할 수 있습니다&lt;/a&gt; . 즉 C ++은 공변량 반환 형식을 지원합니다 . 경우 &lt;code&gt;E&lt;/code&gt; 가 소멸자를 지정, 반환 형식은 &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6bd94bee25a2724e9aec02300daa9aa8d7ac730" translate="yes" xml:space="preserve">
          <source>The return type of a function cannot be a function type or an array type (but can be a pointer or reference to those).</source>
          <target state="translated">함수의 반환 유형은 함수 유형이나 배열 유형이 될 수 없습니다 (단, 포인터 나 참조는 될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="a43d728e1df955f1a8f98c6da37b2ab9a5744ca1" translate="yes" xml:space="preserve">
          <source>The return value may differ significantly from what &lt;code&gt;std::cout&lt;/code&gt; prints by default, see the example.</source>
          <target state="translated">반환 값은 &lt;code&gt;std::cout&lt;/code&gt; 과 크게 다를 수 있습니다. 기본적으로 인쇄하는 예 참조).</target>
        </trans-unit>
        <trans-unit id="39db23f7094ebdbb293d88cb43a6cdf8f30e157e" translate="yes" xml:space="preserve">
          <source>The return value of the called function.</source>
          <target state="translated">호출 된 함수의 반환 값</target>
        </trans-unit>
        <trans-unit id="181f5da030f77aa6d4d1c3eb608e9f1004e2dfd0" translate="yes" xml:space="preserve">
          <source>The return value of the function call operation applied to an object of a type satisfying Compare, when &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually converted&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;, yields &lt;code&gt;true&lt;/code&gt; if the first argument of the call appears before the second in the</source>
          <target state="translated">때, 함수 호출 오퍼레이션의 반환 값이 유형의 객체에 적용 비교 만족 &lt;a href=&quot;../language/implicit_cast&quot;&gt;문맥 전환&lt;/a&gt; 에 &lt;code&gt;bool&lt;/code&gt; 수율 &lt;code&gt;true&lt;/code&gt; 호출의 첫번째 인자는 두 번째 전에 나타나면</target>
        </trans-unit>
        <trans-unit id="f9d8bf866400df7265b9950e52989553174c0d39" translate="yes" xml:space="preserve">
          <source>The returned array is not required to be null-terminated.</source>
          <target state="translated">반환 된 배열은 null로 끝나지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="ee570e1ba2b43205f25df937e0cf18a3c9775dfe" translate="yes" xml:space="preserve">
          <source>The returned array is null-terminated, that is, &lt;code&gt;data()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;c_str&quot;&gt;c_str()&lt;/a&gt;&lt;/code&gt; perform the same function.</source>
          <target state="translated">반환 된 배열은 null로 종료됩니다. 즉, &lt;code&gt;data()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;c_str&quot;&gt;c_str()&lt;/a&gt;&lt;/code&gt; 은 동일한 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="15def1750d934cba236118e97433bceee9bb7467" translate="yes" xml:space="preserve">
          <source>The returned object (call wrapper) has the following properties:</source>
          <target state="translated">반환 된 객체 (콜 래퍼)에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="be9a9d8ae5b68cc7ac697a304429ef14785fc160" translate="yes" xml:space="preserve">
          <source>The returned object behaves as if it holds a member object &lt;code&gt;fd&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;, and an &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; object &lt;code&gt;tup&lt;/code&gt; constructed with &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; (this unwraps any &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;s), except that the returned object's assignment behavior is unspecified and the names are for exposition only.</source>
          <target state="translated">반환 된 객체 는 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; &amp;lt;F&amp;gt; (f)로 구성된 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; &amp;lt;F&amp;gt; 유형 의 멤버 객체 &lt;code&gt;fd&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; ( &lt;a href=&quot;../forward&quot;&gt;std로&lt;/a&gt; 구성된 &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 객체 &lt;code&gt;tup&lt;/code&gt; 을 보유하는 것처럼 동작 합니다. :: for &amp;lt;Args&amp;gt; (args) ...) (이것은 모든 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; 풀어줍니다. 반환 된 객체의 할당 동작이 지정되어 있지 않고 이름이 박람회 전용 인 경우를 제외하고 ).</target>
        </trans-unit>
        <trans-unit id="0b9ca1ed6de835f3a54269685f7c58a1fccb4f90" translate="yes" xml:space="preserve">
          <source>The returned pointer may outlive the last &lt;code&gt;shared_ptr&lt;/code&gt; if, for example, &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;s remain and the implementation doesn't destroy the deleter until the entire control block is destroyed.</source>
          <target state="translated">예를 들어 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 같이 반환 된 포인터는 마지막 &lt;code&gt;shared_ptr&lt;/code&gt; 보다 오래 지속될 수 있습니다. 가 남아 있고 전체 제어 블록이 파괴 될 때까지 구현이 삭제 파괴하지 않으면 .</target>
        </trans-unit>
        <trans-unit id="db84c45c9a8b4735697eb1edd0bf4e4888aff852" translate="yes" xml:space="preserve">
          <source>The returned range is defined by two iterators, one pointing to the first element that is</source>
          <target state="translated">반환되는 범위는 두 개의 반복자 (하나는 첫 번째 요소를 가리키는 반복자)에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="fe922ac7f6db254043abd336f6ccd992ca241559" translate="yes" xml:space="preserve">
          <source>The returned string is constructed as if by &lt;code&gt;basic_string(data()+pos, count)&lt;/code&gt;, which implies that the returned string's allocator will be default-constructed &amp;mdash; the new allocator will</source>
          <target state="translated">반환 된 문자열은 &lt;code&gt;basic_string(data()+pos, count)&lt;/code&gt; 의해 구성된 것처럼 반환됩니다 . 이는 반환 된 문자열의 할당자가 기본으로 구성됨을 의미합니다. 새 할당자는</target>
        </trans-unit>
        <trans-unit id="be7ba042cf486f9205da2c739695a1dd6890e1f2" translate="yes" xml:space="preserve">
          <source>The returned string must not be modified by the program, but may be overwritten by a subsequent call to the &lt;code&gt;strerror&lt;/code&gt; function. &lt;code&gt;strerror&lt;/code&gt; is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.</source>
          <target state="translated">반환 된 문자열은 프로그램에서 수정해서는 &lt;code&gt;strerror&lt;/code&gt; 이후에 strerror 함수를 호출하면 덮어 쓸 수 있습니다 . &lt;code&gt;strerror&lt;/code&gt; 는 스레드로부터 안전하지 않아도됩니다. 구현시 정적 읽기 전용 문자열 리터럴에 대한 다른 포인터를 반환하거나 strerror가 문자열을 배치하는 정적 버퍼를 가리키는 동일한 포인터를 반복해서 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d5cdc0268f97ea1271d25f2faca49793842f74b" translate="yes" xml:space="preserve">
          <source>The returned value has the same sign as &lt;code&gt;x&lt;/code&gt; and is less than &lt;code&gt;y&lt;/code&gt; in magnitude.</source>
          <target state="translated">반환 된 값은 &lt;code&gt;x&lt;/code&gt; 와 같은 부호를 가지며 크기 가 &lt;code&gt;y&lt;/code&gt; 보다 작습니다 .</target>
        </trans-unit>
        <trans-unit id="d9cdb2a3429ed04aaceb9e604669e39a56f8c661" translate="yes" xml:space="preserve">
          <source>The returned value is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and independent of the current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt;.</source>
          <target state="translated">반환 된 값은 정확하고 ( &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 는 발생하지 않음) 현재 &lt;a href=&quot;../fenv/fe_round&quot;&gt;반올림 모드&lt;/a&gt; 와 무관 합니다 .</target>
        </trans-unit>
        <trans-unit id="724b8307d3008dac328f6b273599dff3480427e3" translate="yes" xml:space="preserve">
          <source>The returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">반환 된 값이 정확 &lt;a href=&quot;../fenv/fe_round&quot;&gt;하고 현재 반올림 모드&lt;/a&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f67fd770b1a87fd05c53e4a98601aa49812e9bb3" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: two objects of &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type with different object representations may represent the same value. For example, multiple floating-point bit patterns represent the same special value &lt;a href=&quot;../numeric/math/nan&quot;&gt;NaN&lt;/a&gt;. More commonly, some bits of the object representation may not participate in the value representation at all; such bits may be padding introduced to satisfy &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirements&lt;/a&gt;, &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; sizes, etc.</source>
          <target state="translated">반대의 경우도 마찬가지입니다. 다른 객체 표현을 가진 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; 유형 의 두 객체 는 동일한 값을 나타낼 수 있습니다. 예를 들어, 여러 부동 소수점 비트 패턴은 동일한 특수 값 &lt;a href=&quot;../numeric/math/nan&quot;&gt;NaN을&lt;/a&gt; 나타냅니다 . 더 일반적으로, 객체 표현의 일부 비트는 값 표현에 전혀 참여하지 않을 수 있습니다. 이러한 비트는 &lt;a href=&quot;objects#Alignment&quot;&gt;정렬 요구 사항&lt;/a&gt; , &lt;a href=&quot;bit_field&quot;&gt;비트 필드&lt;/a&gt; 크기 등 을 만족시키기 위해 패딩이 도입 될 수있다 .</target>
        </trans-unit>
        <trans-unit id="4612adf8349954cddb8de34f362396a471ea78cb" translate="yes" xml:space="preserve">
          <source>The root directory of the path.</source>
          <target state="translated">경로의 루트 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="48c9793d32d94f49061760abdfca8adc649ed9d7" translate="yes" xml:space="preserve">
          <source>The root name of the path.</source>
          <target state="translated">경로의 루트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6a021f552f47982e6c4bf64045a925f56bdd2012" translate="yes" xml:space="preserve">
          <source>The root path of the path.</source>
          <target state="translated">경로의 루트 경로입니다.</target>
        </trans-unit>
        <trans-unit id="744a04bfacb0b83210251e4e038c93877d0b3385" translate="yes" xml:space="preserve">
          <source>The rounding mode can be changed with &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;FLT_ROUNDS&lt;/code&gt; reflects that change.</source>
          <target state="translated">반올림 모드를 변경할 수 있습니다 &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;FLT_ROUNDS&lt;/code&gt; 는 그 변화를 반영한다.</target>
        </trans-unit>
        <trans-unit id="cfa7f1285b2f2a30572b8c02c0ae8fcae8230942" translate="yes" xml:space="preserve">
          <source>The rule about &quot;more efficient implementations&quot; permits bulk I/O without intermediate buffering: that's how &lt;code&gt;&lt;a href=&quot;../basic_istream/read&quot;&gt;std::ifstream::read&lt;/a&gt;&lt;/code&gt; simply passes the pointer to the POSIX &lt;code&gt;read()&lt;/code&gt; system call in some implementations of iostreams.</source>
          <target state="translated">&quot;보다 효율적인 구현&quot;에 대한 규칙은 중간 버퍼링없이 대량 I / O를 허용합니다. 이는 &lt;code&gt;&lt;a href=&quot;../basic_istream/read&quot;&gt;std::ifstream::read&lt;/a&gt;&lt;/code&gt; 가 일부 iostream 구현에서 POSIX &lt;code&gt;read()&lt;/code&gt; 시스템 호출에 포인터를 전달하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="f0e4bed8bfc25aa394d951bf5cd88212770eda2b" translate="yes" xml:space="preserve">
          <source>The rule of three/five/zero</source>
          <target state="translated">3/5의 규칙</target>
        </trans-unit>
        <trans-unit id="d764d84251b9e1e79eaf8ddf3fa38a07d394b2ff" translate="yes" xml:space="preserve">
          <source>The safe bool problem</source>
          <target state="translated">안전한 부울 문제</target>
        </trans-unit>
        <trans-unit id="f2d334ca41df29ef25e36114b826d7adfb1af5ef" translate="yes" xml:space="preserve">
          <source>The same applies to the constructors of the next class in the I/O hierarchy, &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt;. Further-derived classes (&lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt;) are always constructed with a concrete streambuffer object and call &lt;a href=&quot;../basic_ios/init&quot;&gt;&lt;code&gt;basic_ios::init()&lt;/code&gt;&lt;/a&gt;, possibly more than once, to complete initialization of their virtual base.</source>
          <target state="translated">I / O 계층 구조에서 다음 클래스의 생성자 인 &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; 에도 동일하게 적용됩니다 . 추가로 파생 된 클래스 ( &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; )는 항상 콘크리트 &lt;a href=&quot;../basic_ios/init&quot;&gt; &lt;code&gt;basic_ios::init()&lt;/code&gt; &lt;/a&gt; 객체로 구성되며 가상베이스의 초기화를 완료하기 위해 가능하면 한 번 이상 basic_ios :: init ()를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="49089319d0e011162dc486f0fa5c79c193f99bb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;S(il.begin(), il.end())&lt;/code&gt;</source>
          <target state="translated">동일한 &lt;code&gt;S(il.begin(), il.end())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1208e3c0bd83fd14a6cdf867c21125c8a325392a" translate="yes" xml:space="preserve">
          <source>The same function may be registered more than once.</source>
          <target state="translated">동일한 기능이 두 번 이상 등록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cb1515f8feac0bd625cac49b53fdf5bc0c4a06a" translate="yes" xml:space="preserve">
          <source>The same value is returned every time this function is called.</source>
          <target state="translated">이 함수가 호출 될 때마다 동일한 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="16a9673c83d6b7f5a89950887b3ffafe04e2f9d5" translate="yes" xml:space="preserve">
          <source>The same words are defined in the C programming language in the include file &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; as macros. Because in C++ these are built into the language, the C++ version of &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;, as well as &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;, does not define anything.</source>
          <target state="translated">포함 단어 &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; 의 C 프로그래밍 언어에서 동일한 단어가 매크로로 정의됩니다. C ++에서이 언어에 내장되어 있기 때문에, C ++의 버전 &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; 뿐만 아니라 &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt; 는 , 아무것도 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73fcd6a6bc40829dafc0c35e7f085fcf47650726" translate="yes" xml:space="preserve">
          <source>The scope of an entity declared in an unnamed namespace or in an inline namespace includes the enclosing namespace;</source>
          <target state="translated">명명되지 않은 네임 스페이스 또는 인라인 네임 스페이스에 선언 된 엔터티의 범위에는 엔 클로징 네임 스페이스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3bae590b6111c1b60bedc945d731d9c449dedcba" translate="yes" xml:space="preserve">
          <source>The scope of the name introduced by condition, if it is a declaration, is the combined scope of both statements' bodies:</source>
          <target state="translated">조건에 의해 도입 된 이름의 범위는 선언 인 경우 두 문장의 본문의 결합 된 범위입니다.</target>
        </trans-unit>
        <trans-unit id="3e817d7c9bc7bbed9e0982e173160a7e98299780" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;choose&lt;/code&gt; can be passed to certain member functions of &lt;code&gt;std::chrono::time_zone&lt;/code&gt; and &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; to control how ambiguous or nonexistent local times should be resolved. Passing &lt;code&gt;choose::earliest&lt;/code&gt; causes the earlier time point to be returned, while passing &lt;code&gt;choose::latest&lt;/code&gt; causes the later time point to be returned. (For nonexistent local times, these two time points are identical.).</source>
          <target state="translated">범위가 지정된 열거 &lt;code&gt;choose&lt;/code&gt; 은 &lt;code&gt;std::chrono::time_zone&lt;/code&gt; 및 &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; 의 특정 멤버 함수로 전달되어 모호하거나 존재하지 않는 로컬 시간을 해결하는 방법을 제어 할 수 있습니다. &lt;code&gt;choose::earliest&lt;/code&gt; 전달 하면 이전 시점이 리턴되고 &lt;code&gt;choose::latest&lt;/code&gt; 를 전달 하면 이후 시점이 리턴됩니다. 존재하지 않는 현지 시간의 경우이 두 시점은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="840423b9be273862a9c8be4dd758424980f72802" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::cv_status&lt;/code&gt; describes whether a timed wait returned because of timeout or not.</source>
          <target state="translated">범위가 지정된 &lt;code&gt;std::cv_status&lt;/code&gt; 는 시간 초과로 인해 시간 초과 대기가 반환되었는지 여부를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a95fd75e62cf2bde9aca6a6e4779c05a5b287de7" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::errc&lt;/code&gt; defines the values of portable error conditions that correspond to the POSIX error codes.</source>
          <target state="translated">범위가 지정된 &lt;code&gt;std::errc&lt;/code&gt; 는 POSIX 오류 코드에 해당하는 이식 가능한 오류 조건의 값을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0ef7ce4c4de2f78554ef3fcfe42b9b69c424fdff" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::future_errc&lt;/code&gt; defines the error codes reported by &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; and related classes in &lt;code&gt;&lt;a href=&quot;future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; exception objects. Only four error codes are required, although the implementation may define additional error codes. Because the appropriate specialization of &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; is provided, values of type &lt;code&gt;std::future_errc&lt;/code&gt; are implicitly convertible to &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">범위가 지정된 열거 형 &lt;code&gt;std::future_errc&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; 예외 객체의 &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 및 관련 클래스 가보고 한 오류 코드를 정의 합니다. 구현시 추가 오류 코드를 정의 할 수 있지만 4 개의 오류 코드 만 필요합니다. &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; 의 적절한 특수화 가 제공되므로 &lt;code&gt;std::future_errc&lt;/code&gt; 유형의 값 은 암시 적으로 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca50a2fc4180751cf2b50c765d0d95358b35a4a9" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::io_errc&lt;/code&gt; defines the error codes reported by I/O streams in &lt;code&gt;&lt;a href=&quot;ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; exception objects. Only one error code (&lt;code&gt;std::io_errc::stream&lt;/code&gt;) is required, although the implementation may define additional error codes. Because the appropriate specialization of &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; is provided, values of type &lt;code&gt;std::io_errc&lt;/code&gt; are implicitly convertible to &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">범위가 지정된 &lt;code&gt;std::io_errc&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 예외 개체의 I / O 스트림에 의해보고 된 오류 코드를 정의 합니다. 구현시 추가 오류 코드를 정의 할 수 있지만 하나의 오류 코드 ( &lt;code&gt;std::io_errc::stream&lt;/code&gt; ) 만 필요합니다. &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; 의 적절한 특수화 가 제공되므로 &lt;code&gt;std::io_errc&lt;/code&gt; 유형의 값 은 암시 적으로 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf90aead8c2a5530e7c352d89f0a4c787a4c9dca" translate="yes" xml:space="preserve">
          <source>The scoped enumeration type &lt;code&gt;pointer_safety&lt;/code&gt; lists the pointer safety modes supported by C++</source>
          <target state="translated">범위가 지정된 열거 유형 인 &lt;code&gt;pointer_safety&lt;/code&gt; 는 C ++에서 지원하는 포인터 안전 모드를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="2dc9a7f6fd0f7a91a7650300695af1e539734973" translate="yes" xml:space="preserve">
          <source>The second operand of both operators is a name of (formally, an &lt;a href=&quot;name#In_expressions&quot;&gt;id-expression&lt;/a&gt; that names) a data member or member function of &lt;code&gt;T&lt;/code&gt; or of an unambiguous and accessible base class &lt;code&gt;B&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt; (e.g. &lt;code&gt;E1.E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;E2&lt;/code&gt;), optionally &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified&lt;/a&gt; (e.g. &lt;code&gt;E1.B::E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;B::E2&lt;/code&gt;), optionally using &lt;a href=&quot;dependent_name&quot;&gt;template disambiguator&lt;/a&gt; (e.g. &lt;code&gt;E1.template E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;template E2&lt;/code&gt;).</source>
          <target state="translated">두 사업자 번째 오퍼랜드의 이름 (공식적이다 &lt;a href=&quot;name#In_expressions&quot;&gt;ID 발현&lt;/a&gt; 이름 해당)의 데이터 멤버 또는 멤버 함수 &lt;code&gt;T&lt;/code&gt; 또는 명백한 접근 기본 클래스의 &lt;code&gt;B&lt;/code&gt; 의 &lt;code&gt;T&lt;/code&gt; (예 &lt;code&gt;E1.E2&lt;/code&gt; 또는 &lt;code&gt;E1-&amp;gt;E2&lt;/code&gt; ) 선택적으로 &lt;a href=&quot;dependent_name&quot;&gt;템플릿 명확화 기&lt;/a&gt; (예 : &lt;code&gt;E1.template E2&lt;/code&gt; 또는 &lt;code&gt;E1-&amp;gt;template E2&lt;/code&gt; )를 사용하여 &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;정규화 됨&lt;/a&gt; (예 : &lt;code&gt;E1.B::E2&lt;/code&gt; 또는 &lt;code&gt;E1-&amp;gt;B::E2&lt;/code&gt; E2 ).</target>
        </trans-unit>
        <trans-unit id="19215a02c420276aa98badc49ffb9d2736ab482c" translate="yes" xml:space="preserve">
          <source>The second operand of both operators is an expression of type pointer to member ( &lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;data&lt;/a&gt; or &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;function&lt;/a&gt;) of &lt;code&gt;T&lt;/code&gt; or pointer to member of an unambiguous and accessible base class &lt;code&gt;B&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">두 사업자 번째 피연산자 부재 (에 입력 포인터의 표현이다 &lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;데이터&lt;/a&gt; 또는 &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;함수&lt;/a&gt; )의 &lt;code&gt;T&lt;/code&gt; 명백한 접근 기본 클래스의 멤버에 대한 포인터 또는 &lt;code&gt;B&lt;/code&gt; 의 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c55eea87a0f8d8889265157fbe6787960184823" translate="yes" xml:space="preserve">
          <source>The second overload contains a separate template parameter for the head of the arguments and a parameter pack, this allows the recursive call to pass only the tail of the parameters until it becomes empty.</source>
          <target state="translated">두 번째 오버로드에는 인수 헤드와 매개 변수 팩에 대한 별도의 템플릿 매개 변수가 포함되어 있으므로 재귀 호출이 비워 질 때까지 매개 변수의 꼬리 만 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be075fc3b764cc15641e30da0af7956f238d21f0" translate="yes" xml:space="preserve">
          <source>The second pass through the callbacks may be used to deep-copy the user-defined objects pointed to by the pointers in &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">콜백을 통한 두 번째 패스는 &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt; 의 포인터가 가리키는 사용자 정의 객체를 딥 카피하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0a5b7b985ce580725fc7689da25a9594bd797ad" translate="yes" xml:space="preserve">
          <source>The second signature behaves as if called with &lt;code&gt;opts&lt;/code&gt; set to &lt;code&gt;perm_options::replace&lt;/code&gt;.</source>
          <target state="translated">두 번째 서명은 &lt;code&gt;opts&lt;/code&gt; 가 &lt;code&gt;perm_options::replace&lt;/code&gt; 설정된 상태에서 호출 된 것처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="2748b8b2515518309d2bd896dc6dc045638385c8" translate="yes" xml:space="preserve">
          <source>The selected elements must exist.</source>
          <target state="translated">선택된 요소가 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="da6776cef8700dee0f22e58931e5d3627bef7c47" translate="yes" xml:space="preserve">
          <source>The semantics of inheriting constructors were retroactively changed by a &lt;a href=&quot;using_declaration#Defect_reports&quot;&gt;defect report against C++11&lt;/a&gt;. Previously, an inheriting constructor declaration caused a set of synthesized constructor declarations to be injected into the derived class, which caused redundant argument copies/moves, had problematic interactions with some forms of SFINAE, and in some cases can be unimplementable on major ABIs. Older compilers may still implement the previous semantics.</source>
          <target state="translated">상속 생성자의 시맨틱은 &lt;a href=&quot;using_declaration#Defect_reports&quot;&gt;C ++ 11&lt;/a&gt; 에 대한 결함 보고서에 의해 소급하여 변경되었습니다 . 이전에는 상속 생성자 선언이 파생 된 클래스에 합성 생성자 선언 세트를 삽입하여 중복 인수 복사 / 이동을 유발했으며 일부 SFINAE 형식과의 상호 작용에 문제가 있었으며 일부 경우 주요 ABI에서 구현할 수 없었습니다. 이전 컴파일러는 여전히 이전 시맨틱을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfeb9ddde9efbc3c0ab3714a0a6e7a8a3efc2e2c" translate="yes" xml:space="preserve">
          <source>The semantics of the member functions are defined are as follows.</source>
          <target state="translated">멤버 함수의 의미는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="276fbc8f397db984b2189ed81138a185a9b8f9c5" translate="yes" xml:space="preserve">
          <source>The semantics of this function are intended to be consistent with the C function &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/clog.html&quot;&gt;&lt;code&gt;clog&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수의 의미는 C 함수 &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/clog.html&quot;&gt; &lt;code&gt;clog&lt;/code&gt; &lt;/a&gt; 와 일치하도록 만들어졌습니다 .</target>
        </trans-unit>
        <trans-unit id="630a0686e90df2d1198d4a4bff7aa262b9655ed1" translate="yes" xml:space="preserve">
          <source>The semantics of this function are intended to be consistent with the C function &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/csqrt.html&quot;&gt;&lt;code&gt;csqrt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수의 의미는 C 함수 &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/csqrt.html&quot;&gt; &lt;code&gt;csqrt&lt;/code&gt; &lt;/a&gt; 와 일치하도록 고안되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f09342387ba1e64c32080173dab4604297f52ab0" translate="yes" xml:space="preserve">
          <source>The sequence denoted by this pair of iterators consists of the following:</source>
          <target state="translated">이 반복자 쌍으로 표시되는 순서는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8cf1423eae846ac729f66d139e28a402cef688fa" translate="yes" xml:space="preserve">
          <source>The sequence of &lt;code&gt;char&lt;/code&gt;s accumulated in Stage 2 is converted to a numeric value</source>
          <target state="translated">2 단계에서 누적 된 &lt;code&gt;char&lt;/code&gt; 시퀀스 는 숫자 값으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="61ab9fb3fc586d17241f33750480c6a753617cad" translate="yes" xml:space="preserve">
          <source>The sequence of numbers returned by successive invocations of this call with the same &lt;code&gt;g&lt;/code&gt; are randomly distributed according to the distribution parametrized by &lt;code&gt;d.param()&lt;/code&gt;</source>
          <target state="translated">동일한 &lt;code&gt;g&lt;/code&gt; 를 가진이 호출의 연속적인 호출에 의해 리턴 된 일련의 숫자는 &lt;code&gt;d.param()&lt;/code&gt; 의해 매개 변수화 된 분포에 따라 무작위로 분배됩니다.</target>
        </trans-unit>
        <trans-unit id="8ad57e0d60c4213ba3be7acf41e0955df808546a" translate="yes" xml:space="preserve">
          <source>The sequence of numbers returned by successive invocations of this call with the same &lt;code&gt;g&lt;/code&gt; are randomly distributed according to the distribution parametrized by &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">동일한 &lt;code&gt;g&lt;/code&gt; 를 가진이 호출의 연속적인 호출에 의해 리턴 된 일련의 숫자는 &lt;code&gt;p&lt;/code&gt; 에 의해 매개 변수화 된 분포에 따라 무작위로 분배됩니다.</target>
        </trans-unit>
        <trans-unit id="326be078a4bda5f44b21dfc8b70dd484a2be09be" translate="yes" xml:space="preserve">
          <source>The set of candidate functions and the list of arguments is prepared in a unique way for each of the contexts where overload resolution is used:</source>
          <target state="translated">후보 함수 세트와 인수 목록은 과부하 해결이 사용되는 각 컨텍스트에 대해 고유 한 방식으로 준비됩니다.</target>
        </trans-unit>
        <trans-unit id="5fc5fc4fdccda5729ebc678de9b6bf863450c8f5" translate="yes" xml:space="preserve">
          <source>The set of candidate functions to be submitted for overload resolution is a union of the sets above. The argument list for the purpose of overload resolution consists of the operands of the operator except for &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, where the second operand is not an argument for the function call (see &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member access operator&lt;/a&gt;).</source>
          <target state="translated">과부하 해결을 위해 제출 될 후보 함수 세트는 위의 세트의 조합입니다. 과부하 해결을위한 인수 목록은 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 를 제외하고 연산자의 피연산자로 구성 되며, 두 번째 피연산자는 함수 호출의 인수가 아닙니다 ( &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;멤버 액세스 연산자&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a1904e66df24bc3e43e3c61d84a3ad2129497a05" translate="yes" xml:space="preserve">
          <source>The set of declarations found by ordinary &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt; and the set of declarations found in all elements of the associated set produced by ADL, are merged, with the following special rules.</source>
          <target state="translated">&lt;a href=&quot;lookup&quot;&gt;정규화되지 않은&lt;/a&gt; 정규 조회 에서 발견 된 선언 세트와 ADL에서 생성 한 관련 세트의 모든 요소에서 발견 된 선언 세트는 다음 특수 규칙과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="633b59c91cf4f999e02e8403d839498119457c8d" translate="yes" xml:space="preserve">
          <source>The set of interval boundaries b</source>
          <target state="translated">구간 경계 세트 b</target>
        </trans-unit>
        <trans-unit id="e3b735a300b426d2245b4cf296a3150fc21a63b1" translate="yes" xml:space="preserve">
          <source>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is &lt;code&gt;{0,1&lt;/code&gt;}, for base-3 integers is &lt;code&gt;{0,1,2&lt;/code&gt;}, and so on. For bases larger than &lt;code&gt;10&lt;/code&gt;, valid digits include alphabetic characters, starting from &lt;code&gt;Aa&lt;/code&gt; for base-11 integer, to &lt;code&gt;Zz&lt;/code&gt; for base-36 integer. The case of the characters is ignored.</source>
          <target state="translated">base에 유효한 값 세트는 {0,2,3, ..., 36}입니다. 기수 -2 정수의 유효한 자릿수는 &lt;code&gt;{0,1&lt;/code&gt; }이고 기수 -3 정수의 경우 &lt;code&gt;{0,1,2&lt;/code&gt; } 등입니다. &lt;code&gt;10&lt;/code&gt; 보다 큰 밑수의 경우 유효한 숫자에는 11 진수의 경우 &lt;code&gt;Aa&lt;/code&gt; 에서 36 자리의 정수의 경우 &lt;code&gt;Zz&lt;/code&gt; 까지의 알파벳 문자가 포함됩니다 . 문자의 경우는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="54f77766bc9f988f0c109a0b9a274a2d62a58aff" translate="yes" xml:space="preserve">
          <source>The shared state already stores a value or exception. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;promise_already_satisfied&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">공유 상태는 이미 값 또는 예외를 저장합니다. 오류 범주는 &lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;promise_already_satisfied&lt;/code&gt; &lt;/a&gt; 로 설정되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd74c3ed26047fa14c5abbda7f8120251339635c" translate="yes" xml:space="preserve">
          <source>The shared state has already been retrieved via a call to &lt;code&gt;get_future&lt;/code&gt;. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;future_already_retrieved&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;get_future&lt;/code&gt; 호출을 통해 공유 상태가 이미 검색되었습니다 . 오류 범주는 &lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;future_already_retrieved&lt;/code&gt; &lt;/a&gt; 로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="817c4cd2132343bd97c84575fd05e4ae8b2ee89e" translate="yes" xml:space="preserve">
          <source>The shared state is only made ready after the current thread exits and all objects of</source>
          <target state="translated">공유 상태는 현재 스레드가 종료되고 모든 객체가 준비된 후에 만 ​​준비됩니다.</target>
        </trans-unit>
        <trans-unit id="6e13e04bbcf515d86b1c971f508fc8ad239fb065" translate="yes" xml:space="preserve">
          <source>The short-circuit instantiation differentiates &lt;code&gt;conjunction&lt;/code&gt; from fold expressions: a fold expression like &lt;code&gt;(... &amp;amp;&amp;amp; Bs::value)&lt;/code&gt; instantiates every &lt;code&gt;B&lt;/code&gt; in &lt;code&gt;Bs&lt;/code&gt;, while &lt;code&gt;std::conjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; stops instantiation once the value can be determined. This is particularly useful if the later type is expensive to instantiate or can cause a hard error when instantiated with the wrong type.</source>
          <target state="translated">단락 인스턴스화 차별화를 &lt;code&gt;conjunction&lt;/code&gt; 스크롤 표현식에서 : 같은 스크롤 식 &lt;code&gt;(... &amp;amp;&amp;amp; Bs::value)&lt;/code&gt; 마다 인스턴스화 &lt;code&gt;B&lt;/code&gt; 의 &lt;code&gt;Bs&lt;/code&gt; 동안 &lt;code&gt;std::conjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; 인스턴스화 값이 결정될 수있다 중지되면 . 이는 후자의 유형이 인스턴스화하는 데 비용이 많이 들거나 잘못된 유형으로 인스턴스화 될 때 심각한 오류가 발생할 수있는 경우에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4b6b7f6a466d865c0d71c17ba70598d418424cc5" translate="yes" xml:space="preserve">
          <source>The short-circuit instantiation differentiates &lt;code&gt;disjunction&lt;/code&gt; from fold expressions: a fold expression like &lt;code&gt;(... || Bs::value)&lt;/code&gt; instantiates every &lt;code&gt;B&lt;/code&gt; in &lt;code&gt;Bs&lt;/code&gt;, while &lt;code&gt;std::disjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; stops instantiation once the value can be determined. This is particularly useful if the later type is expensive to instantiate or can cause a hard error when instantiated with the wrong type.</source>
          <target state="translated">단락 인스턴스화 차별화 된 &lt;code&gt;disjunction&lt;/code&gt; 배 표현식에서 : 같은 배 표현식 &lt;code&gt;(... || Bs::value)&lt;/code&gt; 마다 인스턴스화 &lt;code&gt;B&lt;/code&gt; 의 &lt;code&gt;Bs&lt;/code&gt; 동안 &lt;code&gt;std::disjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; 값이 될 수있다 일단 인스턴스화 정지 단호한. 이는 후자의 유형이 인스턴스화하는 데 비용이 많이 들거나 잘못된 유형으로 인스턴스화 될 때 심각한 오류가 발생할 수있는 경우에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a6fb9e43d23dc62112f027d6321e004ed3458fa2" translate="yes" xml:space="preserve">
          <source>The side-effect A on a scalar M (a write) is</source>
          <target state="translated">스칼라 M (쓰기)의 부작용 A는</target>
        </trans-unit>
        <trans-unit id="35d03624f1f46c34b182260c7be6e91d340366f1" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the objects being compared.</source>
          <target state="translated">결과의 부호는 비교되는 객체가 다른 첫 번째 바이트 쌍 ( &lt;code&gt;unsigned char&lt;/code&gt; 로 해석 됨 ) 의 값 차이의 부호입니다 .</target>
        </trans-unit>
        <trans-unit id="e97cc12d1f3f2487de1b90ed0cc2090797374f8e" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the strings being compared.</source>
          <target state="translated">결과의 부호는 비교되는 문자열이 다른 첫 번째 문자 쌍 ( &lt;code&gt;unsigned char&lt;/code&gt; 로 해석 됨 ) 의 값 차이의 부호입니다 .</target>
        </trans-unit>
        <trans-unit id="cde6f3dc011075607068991f0904ec95fd72723b" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.</source>
          <target state="translated">결과의 부호는 비교할 배열이 다른 첫 번째 넓은 문자 쌍의 값 사이의 차이의 부호입니다.</target>
        </trans-unit>
        <trans-unit id="f67aeb4832459c9bfc7aeb9f457a87aa921f1247" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</source>
          <target state="translated">결과의 부호는 비교되는 문자열이 다른 첫 번째 넓은 문자 쌍의 값 차이의 부호입니다.</target>
        </trans-unit>
        <trans-unit id="7c011cc304f5801ea8e7fc6376c1a87eaf494c1e" translate="yes" xml:space="preserve">
          <source>The signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;.</source>
          <target state="translated">서명에는 &lt;code&gt;const &amp;amp;&lt;/code&gt; 가 없어도 됩니다.</target>
        </trans-unit>
        <trans-unit id="4d5cf620ffd0c069fb09e6109069ba28e165d978" translate="yes" xml:space="preserve">
          <source>The signature of the comparison function should be equivalent to the following:</source>
          <target state="translated">비교 함수의 서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="a6eece811de82334f897e04a0286d22b8a1880ad" translate="yes" xml:space="preserve">
          <source>The signature of the function should be equivalent to the following:</source>
          <target state="translated">함수의 서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="e16d376fc732d9fd890a8e68862e00b90427d089" translate="yes" xml:space="preserve">
          <source>The signature of the predicate function should be equivalent to the following:</source>
          <target state="translated">술어 함수의 서명은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="5471ac941bf0f0fd4abf99ed5f3d659518a0c817" translate="yes" xml:space="preserve">
          <source>The similarly-named container member functions &lt;a href=&quot;../container/list/remove&quot;&gt;&lt;code&gt;list::remove&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../container/list/remove&quot;&gt;&lt;code&gt;list::remove_if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../container/forward_list/remove&quot;&gt;&lt;code&gt;forward_list::remove&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../container/forward_list/remove&quot;&gt;&lt;code&gt;forward_list::remove_if&lt;/code&gt;&lt;/a&gt; erase the removed elements.</source>
          <target state="translated">비슷한 이름의 컨테이너 멤버 함수 &lt;a href=&quot;../container/list/remove&quot;&gt; &lt;code&gt;list::remove&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../container/list/remove&quot;&gt; &lt;code&gt;list::remove_if&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../container/forward_list/remove&quot;&gt; &lt;code&gt;forward_list::remove&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../container/forward_list/remove&quot;&gt; &lt;code&gt;forward_list::remove_if&lt;/code&gt; &lt;/a&gt; 가 제거 된 요소를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="d18977a380068b230c78baa2354437eff8114c95" translate="yes" xml:space="preserve">
          <source>The sine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the sine is sin z =</source>
          <target state="translated">사인은 복잡한 평면에서 전체 기능이며 분기 컷이 없습니다. 사인의 수학적 정의는 sin z =</target>
        </trans-unit>
        <trans-unit id="b269c185388406409d66b389ee290905aa3250c2" translate="yes" xml:space="preserve">
          <source>The single total order might not be consistent with</source>
          <target state="translated">단일 총 주문과 일치하지 않을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a1e4ac9052c7611ed3e612ed7782e64fa0ddd565" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;A&lt;/code&gt;'s state is no less than the size of &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">크기 의 상태의 크기보다 더 적은 없다 &lt;code&gt;b&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffa4ef58b6f217f15dfbc54c8b0b3fa97f978e5a" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 또는 &lt;code&gt;array&lt;/code&gt; 의 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="1a42f803c92acdfd49c509a1473d94317255f86f" translate="yes" xml:space="preserve">
          <source>The size of any &lt;a href=&quot;objects&quot;&gt;object&lt;/a&gt; or member subobject (unless &lt;code&gt;[[no_unique_address]]&lt;/code&gt; -- see below)(since C++20) is required to be at least 1 even if the type is an empty &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; (that is, a class or struct that has no non-static data members), in order to be able to guarantee that the addresses of distinct objects of the same type are always distinct.</source>
          <target state="translated">&lt;a href=&quot;objects&quot;&gt;객체&lt;/a&gt; 또는 멤버 하위 객체 의 크기 ( &lt;code&gt;[[no_unique_address]]&lt;/code&gt; -아래 참조)를 제외하고 (C ++ 20부터) 유형이 빈 &lt;a href=&quot;class&quot;&gt;클래스 유형&lt;/a&gt; (즉, 클래스 또는 동일한 유형의 개별 객체의 주소가 항상 고유하다는 것을 보장하기 위해 비 정적 데이터 멤버가없는 구조체).</target>
        </trans-unit>
        <trans-unit id="60fb803f3af93287267581b597b353fbed331445" translate="yes" xml:space="preserve">
          <source>The size of the file, in bytes.</source>
          <target state="translated">파일 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="fdc6fa0a097f223b138fc7c44f70083d5b4bcb5a" translate="yes" xml:space="preserve">
          <source>The size of the private container that was populated at construction time.</source>
          <target state="translated">시공 시점에 채워진 개인 컨테이너의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="3facb159d302e57398e2b32d50c748002ccee995" translate="yes" xml:space="preserve">
          <source>The size of the pushback buffer varies in practice from 4k (Linux, MacOS) to as little as 4 (Solaris) or the guaranteed minimum 1 (HPUX, AIX).</source>
          <target state="translated">푸시 백 버퍼의 크기는 실제로 4k (Linux, MacOS)에서 최소 4 (Solaris) 또는 보장 된 최소 1 (HPUX, AIX)까지 다양합니다.</target>
        </trans-unit>
        <trans-unit id="c2459bce198cb000b381177d5cc738c181699405" translate="yes" xml:space="preserve">
          <source>The size of the referred-to filesystem object.</source>
          <target state="translated">참조 된 파일 시스템 객체의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="2a786a72bf82ea447c9d87b5be65ed00ac14cb03" translate="yes" xml:space="preserve">
          <source>The size of the sequence in bytes, i.e., &lt;code&gt;size() * sizeof(element_type)&lt;/code&gt;.</source>
          <target state="translated">바이트 단위의 시퀀스 &lt;code&gt;size() * sizeof(element_type)&lt;/code&gt; 예 : size () * sizeof (element_type)) .</target>
        </trans-unit>
        <trans-unit id="66997ef04e230b1f79e491df0b1540977ef30033" translate="yes" xml:space="preserve">
          <source>The sizeof... operator</source>
          <target state="translated">sizeof ... 연산자</target>
        </trans-unit>
        <trans-unit id="e03ce5e1c2c2d6a504f6be8da7e802aa894a2643" translate="yes" xml:space="preserve">
          <source>The smallest &lt;code&gt;q&lt;/code&gt; in &lt;code&gt;[p,p+n)&lt;/code&gt; such that &lt;code&gt;X​::​eq(*q, c)&lt;/code&gt; is true</source>
          <target state="translated">작은 &lt;code&gt;q&lt;/code&gt; 에 &lt;code&gt;[p,p+n)&lt;/code&gt; 등이 그 &lt;code&gt;X​::​eq(*q, c)&lt;/code&gt; 참일</target>
        </trans-unit>
        <trans-unit id="164a8a1e2ed3ac9211701d99d6d1f9abf5da92d6" translate="yes" xml:space="preserve">
          <source>The smallest integral power of two that is not smaller than &lt;code&gt;x&lt;/code&gt;, or an unspecified value if the result cannot be represented in &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 보다 작지 않은 2의 최소 적분 제곱 또는 결과를 &lt;code&gt;T&lt;/code&gt; 로 표현할 수없는 경우 지정되지 않은 값 .</target>
        </trans-unit>
        <trans-unit id="6019aa352c36bf78f73a83e660e2da74f2e4c2ce" translate="yes" xml:space="preserve">
          <source>The socket is not connected</source>
          <target state="translated">소켓이 연결되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="c1a77c31870ff87a240876e0120da8708b5e5e1e" translate="yes" xml:space="preserve">
          <source>The sole exceptions to the maximal munch rule are:</source>
          <target state="translated">최대 뭉크 규칙에 대한 유일한 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="023ae07779bac9c8efdef6a9eb724121da731b80" translate="yes" xml:space="preserve">
          <source>The source of the messages is implementation-defined.</source>
          <target state="translated">메시지의 소스는 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="be9039b113cba4c87f833cb8a33bdd196413e28b" translate="yes" xml:space="preserve">
          <source>The span must have static extent (i.e., &lt;code&gt;N != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;I&lt;/code&gt; must be an integer value in range &lt;code&gt;[0, N)&lt;/code&gt;. This is enforced at compile time as opposed to &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">스팬 범위가 고정한다 (즉, &lt;code&gt;N != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt; ) 및 &lt;code&gt;I&lt;/code&gt; 는 범위 내의 정수 값이어야 &lt;code&gt;[0, N)&lt;/code&gt; . 이것은 &lt;code&gt;operator[]&lt;/code&gt; 와 반대로 컴파일 타임에 시행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e5608fbdb3aeacdd6ea3d40e4a18d5358477dba" translate="yes" xml:space="preserve">
          <source>The special pathname dot (&lt;code&gt;&quot;.&quot;&lt;/code&gt;) is a hard link to its parent directory. The special pathname dot-dot &lt;code&gt;&quot;..&quot;&lt;/code&gt; is a hard link to the directory that is the parent of its parent.</source>
          <target state="translated">특수 경로 이름 점 ( &lt;code&gt;&quot;.&quot;&lt;/code&gt; )은 상위 디렉토리에 대한 하드 링크입니다. 특수한 경로 이름 점 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 은 부모의 부모 디렉토리에 대한 하드 링크입니다.</target>
        </trans-unit>
        <trans-unit id="d5b3112d1aecd8e0bc024d6e95c5b21d74c58b9f" translate="yes" xml:space="preserve">
          <source>The special pathnames dot and dot-dot are skipped.</source>
          <target state="translated">특수 경로 이름 점과 점은 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="3fec246ae7b3831f5d777421b3527ac038580e09" translate="yes" xml:space="preserve">
          <source>The special unnamed bit field of size zero can be forced to break up padding. It specifies that the next bit field begins at the beginning of its allocation unit:</source>
          <target state="translated">크기가 0 인 특수한 명명되지 않은 비트 필드는 패딩을 강제로 해제 할 수 있습니다. 다음 비트 필드가 할당 단위의 시작 부분에서 시작하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="05614a0a97be351dbad65c4504f830ce86618f1b" translate="yes" xml:space="preserve">
          <source>The specialization &lt;a href=&quot;../vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; did not have &lt;code&gt;emplace()&lt;/code&gt; member until C++14.</source>
          <target state="translated">전문화 &lt;a href=&quot;../vector_bool&quot;&gt;표준 : : 벡터 &amp;lt;부울&amp;gt;&lt;/a&gt; 이 없었다 &lt;code&gt;emplace()&lt;/code&gt; C ++ 14 일까지 회원.</target>
        </trans-unit>
        <trans-unit id="c0c58597769cd63f71580480f8d3215395bbf758" translate="yes" xml:space="preserve">
          <source>The specialization &lt;a href=&quot;../vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; did not have &lt;code&gt;emplace_back()&lt;/code&gt; member until C++14.</source>
          <target state="translated">전문화 &lt;a href=&quot;../vector_bool&quot;&gt;표준 : : 벡터 &amp;lt;부울&amp;gt;&lt;/a&gt; 이 없었다 &lt;code&gt;emplace_back()&lt;/code&gt; 멤버 C ++ 14까지.</target>
        </trans-unit>
        <trans-unit id="8bec2e9d713031b66c24ef679d2b78ee8bb1782e" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::conjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; has a public and unambiguous base that is.</source>
          <target state="translated">전문화 &lt;code&gt;std::conjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; 은 공개적이고 명확한 기반을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d5cf9884b92e823e93ea4f01a9bf287d1156634" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::disjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; has a public and unambiguous base that is.</source>
          <target state="translated">&lt;code&gt;std::disjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; 전문화 는 공개적이고 명확한 기반을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="186f2d291b8a6a9a42e951016f0b61a5ce492295" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;optional&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">&lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 가 활성화되면 &lt;code&gt;std::hash&amp;lt;optional&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 특수화 가 활성화되고 ( &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 참조 ) 그렇지 않으면 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="600411d4c48669f0d407c466842e7104a0cdd005" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;lt;T,D&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if &lt;code&gt;std::hash&amp;lt;typename std::unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">&lt;code&gt;std::hash&amp;lt;typename std::unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;&lt;/code&gt; 가 활성화되면 &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;lt;T,D&amp;gt;&amp;gt;&lt;/code&gt; 특수화 가 활성화됩니다 ( &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 참조 ). 그렇지 않으면 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="42f1297302612956b663a74e0024532e227a782e" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;std::variant&amp;lt;Types...&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if every specialization in &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;Types&amp;gt;&amp;gt;...&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">전문화 &lt;code&gt;std::hash&amp;lt;std::variant&amp;lt;Types...&amp;gt;&amp;gt;&lt;/code&gt; (참조 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; )의 경우 모든 전문 &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;Types&amp;gt;&amp;gt;...&lt;/code&gt; 활성화, 그렇지 않으면 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="2c76460cbd0b8d4d937dbc5c694d6c7635ce71fd" translate="yes" xml:space="preserve">
          <source>The specializations &lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt;, &lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt; are &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypes&lt;/a&gt; for representing and manipulating &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex numbers&lt;/a&gt;.</source>
          <target state="translated">전문 분야는 &lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt; , &lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt; , 그리고 &lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt; 입니다 &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypes&lt;/a&gt; 표현하고 조작하기위한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;복잡한 번호&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86590d0709c4e9c53d7a3642895c8ee4ba57e923" translate="yes" xml:space="preserve">
          <source>The specification of release-consume ordering is being revised, and the use of &lt;code&gt;memory_order_consume&lt;/code&gt; is temporarily discouraged.</source>
          <target state="translated">릴리스 소비 순서 지정이 개정되고 있으며 &lt;code&gt;memory_order_consume&lt;/code&gt; 사용 은 일시적으로 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29817af7f9fc3c9588fba123d6e7dc6efdcdd019" translate="yes" xml:space="preserve">
          <source>The specified non-type arguments must either match the types of the corresponding non-type template parameters, or be &lt;a href=&quot;template_parameters#Template_non-type_arguments&quot;&gt;convertible to them&lt;/a&gt;.</source>
          <target state="translated">지정된 비 유형 인수는 해당 비 유형 템플릿 매개 변수의 유형과 일치하거나 이들로 &lt;a href=&quot;template_parameters#Template_non-type_arguments&quot;&gt;변환 할 수 있어야합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd71ab6119537a05f604ee514973d18be587dd3" translate="yes" xml:space="preserve">
          <source>The specified template arguments must match the template parameters in kind (i.e., type for type, non-type for non-type, and template for template). There cannot be more arguments than there are parameters (unless one parameter is a parameter pack, in which case there has to be an argument for each non-pack parameter).</source>
          <target state="translated">지정된 템플릿 인수는 종류의 템플릿 매개 변수와 일치해야합니다 (예 : 유형 유형, 유형이 아닌 유형 및 템플릿의 템플릿). 매개 변수보다 많은 인수가있을 수 없습니다 (하나의 매개 변수가 매개 변수 팩이 아닌 경우 각 비팩 매개 변수에 대한 인수가 있어야 함).</target>
        </trans-unit>
        <trans-unit id="f0a5a1232f69709176b03e5e2f09bcf1138b3d55" translate="yes" xml:space="preserve">
          <source>The standard 32-bit IEEE 754 floating-point type has a 24 bit fractional part (23 bits written, one implied), which may suggest that it can represent 7 digit decimals (&lt;code&gt;24 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; is 7.22), but relative rounding errors are non-uniform and some floating-point values with 7 decimal digits do not survive conversion to 32-bit float and back: the smallest positive example is &lt;code&gt;8.589973e9&lt;/code&gt;, which becomes &lt;code&gt;8.589974e9&lt;/code&gt; after the roundtrip. These rounding errors cannot exceed one bit in the representation, and &lt;code&gt;digits10&lt;/code&gt; is calculated as &lt;code&gt;(24-1)*&lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt;, which is 6.92. Rounding down results in the value 6.</source>
          <target state="translated">표준 32 비트 IEEE 754 부동 소수점 유형은 24 비트 소수 부분 (23 비트 기록, 하나는 암시 적)을 가지므로 7 자리 10 진수 ( &lt;code&gt;24 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; 는 7.22 임)를 나타낼 수 있습니다 . 그러나 상대 반올림 오류는 균일하지 않으며 소수 자릿수가 7 인 일부 부동 소수점 값은 32 비트 부동 소수점 및 그 &lt;code&gt;8.589973e9&lt;/code&gt; 변환되지 않습니다. 가장 작은 양수 예제는 8.589973e9 이며 , 왕복 후 &lt;code&gt;8.589974e9&lt;/code&gt; 가됩니다 . 이 반올림 오류는 표현에서 1 비트를 초과 할 수 없으며 &lt;code&gt;digits10&lt;/code&gt; 은 &lt;code&gt;(24-1)*&lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; 로 계산되며 6.92입니다. 반올림하면 값 6이됩니다.</target>
        </trans-unit>
        <trans-unit id="73e09cdf1b741ad1b3350d5372e33ae3558bb73f" translate="yes" xml:space="preserve">
          <source>The standard C streams are the following: &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">표준 C 스트림은 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0bc3d7739fd70319e077ff236f69aa7397545b58" translate="yes" xml:space="preserve">
          <source>The standard C++ streams are the following: &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::clog&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::wcin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::wcout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::wclog&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">표준 C ++ 스트림은 &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::clog&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::wcin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::wcout&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::wclog&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e1559238f4f96f1308a43f7cac736eb900505d58" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfy these requirements.</source>
          <target state="translated">표준 컨테이너 &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 는 이러한 요구 사항을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="9b92ff236d7217d097c5d77ce3d7b6e24187e96b" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; satisfy these requirements.</source>
          <target state="translated">표준 컨테이너 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 는 이러한 요구 사항을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="3348805983e91545ed6f0183b3ad7d17819a000e" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfy these requirements. By default, if no container class is specified for a particular stack class instantiation, the standard container &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">표준 컨테이너 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 는 이러한 요구 사항을 충족합니다. 기본적으로 특정 스택 클래스 인스턴스화에 컨테이너 클래스가 지정되지 않은 경우 표준 컨테이너 &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da4c870ff1fa0a006bae378b114850461217f6df" translate="yes" xml:space="preserve">
          <source>The standard defines a set of &lt;a href=&quot;preprocessor/replace&quot;&gt;preprocessor macros&lt;/a&gt; corresponding to C++ language and library features introduced in C++11 or later. They are intended as a simple and portable way to detect the presence of said features.</source>
          <target state="translated">이 표준은 C ++ 11 이상에서 도입 된 C ++ 언어 및 라이브러리 기능에 해당하는 &lt;a href=&quot;preprocessor/replace&quot;&gt;전 처리기 매크로&lt;/a&gt; 세트를 정의합니다 . 그것들은 상기 특징들의 존재를 탐지하는 간단하고 휴대 가능한 방법으로 의도되었다.</target>
        </trans-unit>
        <trans-unit id="7a975074992a026641c667980782c267b65820dd" translate="yes" xml:space="preserve">
          <source>The standard does not define any behavior for this function except that &lt;code&gt;setbuf(0, 0)&lt;/code&gt; called before any I/O has taken place is required to set unbuffered output.</source>
          <target state="translated">표준은 버퍼링되지 않은 출력을 설정하기 위해 I / O가 발생하기 전에 호출 된 &lt;code&gt;setbuf(0, 0)&lt;/code&gt; 제외하고는이 함수에 대한 동작을 정의하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="11c9f11d649487cf00471f2a0a3ced302b1b169d" translate="yes" xml:space="preserve">
          <source>The standard encourages, but doesn't require that the main thread and the threads started by &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; offer concurrent forward progress guarantee.</source>
          <target state="translated">표준은 기본 스레드와 &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 의해 시작된 스레드 가 동시 순방향 진행을 보장 하도록 권장하지만 요구하지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3769b4f39ad7629c09afe04cb807040c01f86974" translate="yes" xml:space="preserve">
          <source>The standard error condition &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; typically indicates the condition where the result, rather than the input, is out of range, and is more closely related to &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">표준 오류 조건 &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; 일반적으로 입력이 아닌 결과가 범위를 벗어난 상태를 나타내며 &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; 와 더 밀접한 관련이있는 조건을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="6ea76ab6562da741fc1f1f80fa940f195cc6f7f0" translate="yes" xml:space="preserve">
          <source>The standard itself doesn't specify precedence levels. They are derived from the grammar.</source>
          <target state="translated">표준 자체는 우선 순위 수준을 지정하지 않습니다. 그것들은 문법에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="464d44c8fa9af2bc062b88f7cb6e09d51921375c" translate="yes" xml:space="preserve">
          <source>The standard library</source>
          <target state="translated">표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="501d2fd270600c1ad4722fe615b8c6d60795a8cf" translate="yes" xml:space="preserve">
          <source>The standard library also defines a function template &lt;a href=&quot;../../algorithm/remove&quot;&gt;&lt;code&gt;std::remove&lt;/code&gt;&lt;/a&gt; taking a pair of iterators and a value, this overload is one of the standard &lt;a href=&quot;../../algorithm&quot;&gt;algorithms&lt;/a&gt;.</source>
          <target state="translated">표준 라이브러리는 함수 템플릿 &lt;a href=&quot;../../algorithm/remove&quot;&gt; &lt;code&gt;std::remove&lt;/code&gt; &lt;/a&gt; 를 정의하여 반복자와 값을 가져옵니다 . 이 과부하는 표준 &lt;a href=&quot;../../algorithm&quot;&gt;알고리즘&lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="6f9befce5f0ccf765011ba595f540e481507757b" translate="yes" xml:space="preserve">
          <source>The standard library also defines an overload of &lt;code&gt;std::remove&lt;/code&gt; taking &lt;code&gt;const char*&lt;/code&gt;, used to delete files: &lt;a href=&quot;../io/c/remove&quot;&gt;&lt;code&gt;std::remove&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">표준 라이브러리는 또한 과부하 정의 &lt;code&gt;std::remove&lt;/code&gt; 복용 &lt;code&gt;const char*&lt;/code&gt; : 삭제 파일을 사용, &lt;a href=&quot;../io/c/remove&quot;&gt; &lt;code&gt;std::remove&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0eb84bf9201f6099169c60c1dc16401b24988119" translate="yes" xml:space="preserve">
          <source>The standard library also provides a number of pre-defined &lt;a href=&quot;../utility/functional&quot;&gt;function object templates&lt;/a&gt; as well as the methods to compose new ones (including &lt;code&gt;&lt;a href=&quot;../utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 라이브러리는 또한 미리 정의 된 여러 &lt;a href=&quot;../utility/functional&quot;&gt;함수 객체 템플릿&lt;/a&gt; 과 새로운 템플릿 을 작성하는 방법 ( &lt;code&gt;&lt;a href=&quot;../utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; )을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b555b9bc9fd6124abd76d1e9d57fcd86813932ea" translate="yes" xml:space="preserve">
          <source>The standard library component &lt;code&gt;&lt;a href=&quot;../types/enable_if&quot;&gt;std::enable_if&lt;/a&gt;&lt;/code&gt; allows for creating a substitution failure in order to enable or disable particular overloads based on a condition evaluated at compile time.</source>
          <target state="translated">표준 라이브러리 구성 요소 &lt;code&gt;&lt;a href=&quot;../types/enable_if&quot;&gt;std::enable_if&lt;/a&gt;&lt;/code&gt; 사용하면 컴파일 타임에 평가 된 조건에 따라 특정 과부하를 활성화하거나 비활성화하기 위해 대체 실패를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fdaf88b78e9440c1d7c4b829cd2c20de63b3687" translate="yes" xml:space="preserve">
          <source>The standard library component &lt;code&gt;&lt;a href=&quot;../types/void_t&quot;&gt;std::void_t&lt;/a&gt;&lt;/code&gt; is another utility metafunction that simplifies SFINAE applications.</source>
          <target state="translated">표준 라이브러리 구성 요소 &lt;code&gt;&lt;a href=&quot;../types/void_t&quot;&gt;std::void_t&lt;/a&gt;&lt;/code&gt; 는 SFINAE 응용 프로그램을 단순화하는 또 다른 유틸리티 메타 기능입니다.</target>
        </trans-unit>
        <trans-unit id="90d7e9c58cdd097e6e1be1842b8c59bbecc70529" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report domain errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::domain_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">표준 라이브러리 구성 요소는이 예외를 발생시키지 않습니다 (수학 함수는 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 에 지정된 도메인 오류를보고합니다 ). 그러나 타사 라이브러리는이를 사용합니다. 예를 들어, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math가&lt;/a&gt; 발생 &lt;code&gt;std::domain_error&lt;/code&gt; 경우 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; 활성화 (기본 설정).</target>
        </trans-unit>
        <trans-unit id="46dcc8a3d08bda1ff1e95e9b8404ca3dc28f1aeb" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report underflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::underflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">표준 라이브러리 구성 요소는이 예외를 발생시키지 않습니다 (수학 함수는 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 에 지정된 언더 플로우 오류를보고합니다 ). 그러나 타사 라이브러리는이를 사용합니다. 예를 들어, &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math가&lt;/a&gt; 발생 &lt;code&gt;std::underflow_error&lt;/code&gt; 경우 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; 활성화 (기본 설정).</target>
        </trans-unit>
        <trans-unit id="45b5eeaea89ac1fd73a4e45ba45af272f555ab4a" translate="yes" xml:space="preserve">
          <source>The standard library defines two trivial awaitables: &lt;code&gt;std::suspend_always&lt;/code&gt; and &lt;code&gt;std::suspend_never&lt;/code&gt;.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;std::suspend_always&lt;/code&gt; 및 &lt;code&gt;std::suspend_never&lt;/code&gt; 두 가지 간단한 대기를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="131ce88470ae44f681ca4c49d07e5f0002f442b1" translate="yes" xml:space="preserve">
          <source>The standard library implementations of the nothrow versions (5-8) directly calls the corresponding throwing versions (1-4). The standard library implementation of the throwing array versions (2,4) directly calls the corresponding single-object version (1,3). Thus, replacing the throwing single object allocation functions is sufficient to handle all allocations.</source>
          <target state="translated">nothrow 버전 (5-8)의 표준 라이브러리 구현은 해당 던지기 버전 (1-4)을 직접 호출합니다. 투사 배열 버전 (2,4)의 표준 라이브러리 구현은 해당 단일 객체 버전 (1,3)을 직접 호출합니다. 따라서 던지는 단일 객체 할당 함수를 교체하면 모든 할당을 처리하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="987bfd8dffed15aac50d7b564b0338f3cfc187ca" translate="yes" xml:space="preserve">
          <source>The standard library implementations of the nothrow versions (9,10) directly call the corresponding throwing versions (1,2). The standard library implementations of the size-aware deallocation functions (5-8) directly call the corresponding size-unaware deallocation functions (1-4). The standard library implementations of size-unaware throwing array forms (2,4) directly calls the corresponding single-object forms (1,3).</source>
          <target state="translated">nothrow 버전 (9,10)의 표준 라이브러리 구현은 해당 throwing 버전 (1,2)을 직접 호출합니다. 크기 인식 할당 해제 함수 (5-8)의 표준 라이브러리 구현은 해당 크기 인식 해제 할당 함수 (1-4)를 직접 호출합니다. size-unware throwing array form (2,4)의 표준 라이브러리 구현은 해당 단일 객체 양식 (1,3)을 직접 호출합니다.</target>
        </trans-unit>
        <trans-unit id="6f67e8db943a7e5f11fa3e591652be01e6c72c81" translate="yes" xml:space="preserve">
          <source>The standard library placement forms of operator delete (13,14) cannot be replaced and can only be customized if the placement new-expression did not use the &lt;code&gt;::new&lt;/code&gt; syntax, by providing a class-specific placement delete (25,26) with matching signature: &lt;code&gt;void T::operator delete(void*, void*)&lt;/code&gt; or &lt;code&gt;void T::operator delete[](void*, void*)&lt;/code&gt;.</source>
          <target state="translated">연산자 삭제 (13,14)의 표준 라이브러리 배치 형식은 대체 할 수 없으며, 배치 새 표현식이 &lt;code&gt;::new&lt;/code&gt; 구문을 사용하지 않은 경우에만 클래스 별 배치 삭제 (25,26)를 제공하여 사용자 정의 할 수 있습니다. 일치하는 서명 : &lt;code&gt;void T::operator delete(void*, void*)&lt;/code&gt; 또는 &lt;code&gt;void T::operator delete[](void*, void*)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f331f596fff7bf452e9368230c890e4ad858b73" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_and&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리의 전문성을 제공하는 &lt;code&gt;std::bit_and&lt;/code&gt; 때 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은, 어떤 잎 매개 변수 유형 및 반환 유형을 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51b8639942df5edd3c966b0d456710b62ece3289" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_not&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::bit_not&lt;/code&gt; 의 특수화를 제공 하므로 매개 변수 유형 및 리턴 유형이 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="3f85f5fb8d6b87c4f54a098871a34860fd38598a" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_or&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::bit_or&lt;/code&gt; 의 특수화를 제공 하여 매개 변수 유형 및 리턴 유형을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="0cf5638980a6e182479f5dbc4a0b88370ff66486" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_xor&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::bit_xor&lt;/code&gt; 의 특수화를 제공 하므로 매개 변수 유형 및 리턴 유형이 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="b457595199deea57bcd493866c929556b33e76c3" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::divides&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::divides&lt;/code&gt; 의 특수화를 제공 하므로 매개 변수 유형 및 리턴 유형이 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="424b00c8e42201af9548ab0448e6ee7a2e60cfef" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::equal_to&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::equal_to&lt;/code&gt; 의 특수화를 제공 하므로 매개 변수 유형 및 리턴 유형이 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="445dfbf3571b7bf4a2bdaa8ee7d29b4668dc155f" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::greater&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::greater&lt;/code&gt; 의 특수화를 제공 하여 매개 변수 유형 및 리턴 유형을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="2e57796087a77aba47733fc29c950505cf26b1be" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::greater_equal&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::greater_equal&lt;/code&gt; 의 특수화를 제공 하므로 매개 변수 유형 및 리턴 유형이 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="d03ee57547fa44cc25d3f2cc6819498bf61e5b4f" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::less&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::less&lt;/code&gt; 의 특수화를 제공 하여 매개 변수 유형 및 리턴 유형을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="1df3c94ad21dfdfe9d3b7d094b740848f19b97b6" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::less_equal&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::less_equal&lt;/code&gt; 의 특수화를 제공 하므로 매개 변수 유형 및 리턴 유형이 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="c43777e85f59e5d1bbafcf4b62e738707fc73cc8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_and&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리의 전문성을 제공하는 &lt;code&gt;std::logical_and&lt;/code&gt; 때 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은, 어떤 잎 매개 변수 유형 및 반환 유형을 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22cce0c9b0e471c051bc216994974900fed662a5" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_not&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::logical_not&lt;/code&gt; 의 특수화를 제공 하여 매개 변수 유형 및 리턴 유형을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="b18a6f7d7f176eaa205b868246f5b1e0eaa0fbbe" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_or&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리의 전문성을 제공하는 &lt;code&gt;std::logical_or&lt;/code&gt; 때 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은, 어떤 잎 매개 변수 유형 및 반환 유형을 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a1acb46cad97b294ab7069cf7f2c49e0f7cf8b1" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::minus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::minus&lt;/code&gt; 의 특수화를 제공 하여 매개 변수 유형 및 리턴 유형을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="6416b0b039efddd187d08d4923fac1b5ea6b2919" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::modulus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::modulus&lt;/code&gt; 의 특수화를 제공 하므로 매개 변수 유형 및 리턴 유형이 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="9e894075f88d07cc0fe2281d2c4c9b7877d9b39c" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::multiplies&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::multiplies&lt;/code&gt; 의 특수화를 제공 하여 매개 변수 유형 및 리턴 유형을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="f5aca230aea77b0bd8892a57f74c1c692d9e92c8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::negate&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::negate&lt;/code&gt; 전문화 하여 매개 변수 유형 및 리턴 유형을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="3a6ba7f3f95659a4fcbc1e1535d8d51d3f4d4522" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::not_equal_to&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::not_equal_to&lt;/code&gt; 의 특수화를 제공 하여 매개 변수 유형 및 리턴 유형을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="b5b5790ca4e3a36f7013249f817e8e9a00cbb0f8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::owner_less&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified. In this case, the parameter types are deduced from the arguments (each of which must still be either a &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::owner_less&lt;/code&gt; 의 전문화를 제공 합니다. 이 경우 매개 변수 유형은 인수에서 추론됩니다 (각각 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 이어야 함 ).</target>
        </trans-unit>
        <trans-unit id="120610675bef9d2af7c4846670094bb75886286b" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::plus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;T&lt;/code&gt; 가 지정되지 않은 경우 &lt;code&gt;std::plus&lt;/code&gt; 의 특수화를 제공 하여 매개 변수 유형 및 리턴 유형을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="e47ae8777ca4465b596890ef95a90b212d5b7e1a" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::vector&lt;/code&gt; for the type &lt;code&gt;bool&lt;/code&gt;, which may be optimized for space efficiency.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;bool&lt;/code&gt; 유형 에 &lt;code&gt;std::vector&lt;/code&gt; 의 특수화를 제공하며 공간 효율성에 최적화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fefa50e2fa7d26d5c3b1a75d91a4ce66ae1e5fa" translate="yes" xml:space="preserve">
          <source>The standard library provides facilities to obtain values that are returned and to catch exceptions that are thrown by asynchronous tasks (i.e. functions launched in separate threads). These values are communicated in a</source>
          <target state="translated">표준 라이브러리는 반환 된 값을 얻고 비동기 작업 (예 : 별도의 스레드에서 시작된 함수)에 의해 발생하는 예외를 포착하는 기능을 제공합니다. 이 값들은</target>
        </trans-unit>
        <trans-unit id="093ef8202a6c5dfcd0f104f718c58b45c3a78863" translate="yes" xml:space="preserve">
          <source>The standard library provides partial specializations of the &lt;code&gt;std::atomic&lt;/code&gt; template for the following types with additional properties that the primary template does not have:</source>
          <target state="translated">표준 라이브러리는 기본 템플릿에없는 추가 속성과 함께 다음 유형에 대한 &lt;code&gt;std::atomic&lt;/code&gt; 템플릿 의 부분 특수화를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="228f6a886c12bbc3f7a888fe93cf312d114dba7e" translate="yes" xml:space="preserve">
          <source>The standard library provides partial specializations of the &lt;code&gt;std::atomic_ref&lt;/code&gt; template for for all pointer types. In addition to the operations provided for all atomic types, these specializations additionally support atomic arithmetic operations appropriate to pointer types, such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">표준 라이브러리는 모든 포인터 유형에 대해 &lt;code&gt;std::atomic_ref&lt;/code&gt; 템플리트 의 부분 특수화를 제공합니다 . 모든 원자 유형에 제공되는 연산 외에도 이러한 전문화는 &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; 와 같은 포인터 유형에 적합한 원자 산술 연산을 추가로 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="ad36dcf418bbed48c178ac3a02f2b5e9c8c7da73" translate="yes" xml:space="preserve">
          <source>The standard library provides the following searchers:</source>
          <target state="translated">표준 라이브러리는 다음 검색자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3b2efd68490dfb7a4918757f6cf2c4bb0801f472" translate="yes" xml:space="preserve">
          <source>The standard library types that are aliases of arithmetic types (such as &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&lt;/code&gt;) may also be examined with the &lt;code&gt;std::numeric_limits&lt;/code&gt; type traits.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&lt;/code&gt; 와 같은 산술 유형의 별명 인 표준 라이브러리 유형 도 &lt;code&gt;std::numeric_limits&lt;/code&gt; 유형 특성 으로 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ffd7a9f649b4d9408cc4e3d1e7589d2c8b29d694" translate="yes" xml:space="preserve">
          <source>The standard library's non-allocating placement forms of operator new (9-10) cannot be replaced and can only be customized if the placement new-expression did not use the &lt;code&gt;::new&lt;/code&gt; syntax, by providing a class-specific placement new (19,20) with matching signature: &lt;code&gt;void* T::operator new(size_t, void*)&lt;/code&gt; or &lt;code&gt;void* T::operator new[](size_t, void*)&lt;/code&gt;.</source>
          <target state="translated">표준 라이브러리의 비 할당 배치 연산자 new (9-10)는 대체 할 수 없으며 클래스 new 배치를 제공하여 new-expression이 &lt;code&gt;::new&lt;/code&gt; 구문을 사용하지 않은 경우에만 사용자 정의 할 수 있습니다 20) 일치하는 서명 : &lt;code&gt;void* T::operator new(size_t, void*)&lt;/code&gt; 또는 &lt;code&gt;void* T::operator new[](size_t, void*)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4981b4624e460e124e89bf34f4ff3f0393f76006" translate="yes" xml:space="preserve">
          <source>The standard output objects &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; have their &lt;code&gt;unitbuf&lt;/code&gt; bit set by default.</source>
          <target state="translated">표준 출력 객체 &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; 에는 기본적으로 &lt;code&gt;unitbuf&lt;/code&gt; 비트가 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e153cc38ba0d2871317e848fbb767c71742cdb1" translate="yes" xml:space="preserve">
          <source>The standard recommends that a &lt;a href=&quot;../../chrono/steady_clock&quot;&gt;&lt;code&gt;steady_clock&lt;/code&gt;&lt;/a&gt; is used to measure the duration. If an implementation uses a &lt;a href=&quot;../../chrono/system_clock&quot;&gt;&lt;code&gt;system_clock&lt;/code&gt;&lt;/a&gt; instead, the wait time may also be sensitive to clock adjustments.</source>
          <target state="translated">표준에서는 &lt;a href=&quot;../../chrono/steady_clock&quot;&gt; &lt;code&gt;steady_clock&lt;/code&gt; &lt;/a&gt; 을 사용하여 지속 시간을 측정하는 것이 좋습니다 . 구현에서 &lt;a href=&quot;../../chrono/system_clock&quot;&gt; &lt;code&gt;system_clock&lt;/code&gt; 을&lt;/a&gt; 대신 사용하는 경우 대기 시간도 클록 조정에 민감 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4670d79858faa026fd927ad092884ff7288c02f9" translate="yes" xml:space="preserve">
          <source>The standard recommends that a steady clock is used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments.</source>
          <target state="translated">표준에서는 지속 시간을 측정하기 위해 꾸준한 시계를 사용하는 것이 좋습니다. 구현에서 시스템 클럭을 대신 사용하는 경우 대기 시간도 클럭 조정에 민감 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e741a6a70c81c69a623d13af6d5fd11444c21c7" translate="yes" xml:space="preserve">
          <source>The standard signed integer types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt;;</source>
          <target state="translated">표준 부호있는 정수 유형 : &lt;code&gt;signed char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; 및 &lt;code&gt;long long&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="f7faa7d4edc03214148f1c3967ed705a6e4cf33e" translate="yes" xml:space="preserve">
          <source>The standard specializations of &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; return the pattern &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; 의 표준 전문화는 &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt; 패턴을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="297a7545b93be6b8ae2bf103d5942d598d8acf23" translate="yes" xml:space="preserve">
          <source>The standard unsigned integer types: &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, and &lt;code&gt;unsigned long long&lt;/code&gt;;</source>
          <target state="translated">표준 부호없는 정수 유형 : &lt;code&gt;unsigned char&lt;/code&gt; , &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; 및 &lt;code&gt;unsigned long long&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="b3faee826fe7d429ac217f2296c04e167f193a78" translate="yes" xml:space="preserve">
          <source>The start of the get area, for all writeable &lt;code&gt;std::strstreambuf&lt;/code&gt; objects constructed through the interface provided by &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;, is also the start of the put area.</source>
          <target state="translated">모든 쓰기에 대한 GET 영역의 시작, &lt;code&gt;std::strstreambuf&lt;/code&gt; 에서 제공하는 인터페이스를 통해 구성 객체 &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; , 또한 풋 영역의 시작이다.</target>
        </trans-unit>
        <trans-unit id="29e1675652ac7f6393431e47f0ec2642d6a47e2b" translate="yes" xml:space="preserve">
          <source>The starting directory has depth of 0, its subdirectories have depth 1, etc.</source>
          <target state="translated">시작 디렉토리의 깊이는 0이고, 서브 디렉토리의 깊이는 1입니다.</target>
        </trans-unit>
        <trans-unit id="9c4774217cf581390531d456216df78cfba88d58" translate="yes" xml:space="preserve">
          <source>The state of &lt;code&gt;A&lt;/code&gt; includes the state of &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">상태 &lt;code&gt;A&lt;/code&gt; 는 상태 포함 &lt;code&gt;B&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="bf3c2fc8c65fee8f63cb40617161a425c9833d2a" translate="yes" xml:space="preserve">
          <source>The statement that begins with &lt;code&gt;if constexpr&lt;/code&gt; is known as the</source>
          <target state="translated">&lt;code&gt;if constexpr&lt;/code&gt; 이 다음으로 알려진 경우로 시작하는 명령문</target>
        </trans-unit>
        <trans-unit id="8d7a45218be20de00c71ea80e61b6068a9ec7bbd" translate="yes" xml:space="preserve">
          <source>The static data members &lt;code&gt;nom&lt;/code&gt; and &lt;code&gt;den&lt;/code&gt; representing the numerator and denominator are calculated by dividing &lt;code&gt;Num&lt;/code&gt; and &lt;code&gt;Denom&lt;/code&gt; by their greatest common divisor. However, two &lt;code&gt;std::ratio&lt;/code&gt; with different &lt;code&gt;Num&lt;/code&gt; or &lt;code&gt;Denom&lt;/code&gt; are distinct types even if they represent the same rational number (after reduction). A &lt;code&gt;ratio&lt;/code&gt; type can be reduced to the lowest terms via its &lt;code&gt;type&lt;/code&gt; member: &lt;code&gt;std::ratio&amp;lt;3, 6&amp;gt;::type&lt;/code&gt; is &lt;code&gt;std::ratio&amp;lt;1, 2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">분자 및 분모를 나타내는 정적 데이터 멤버 &lt;code&gt;nom&lt;/code&gt; 및 &lt;code&gt;den&lt;/code&gt; 은 &lt;code&gt;Num&lt;/code&gt; 과 &lt;code&gt;Denom&lt;/code&gt; 을 최대 공약수 로 나누어 계산합니다 . 그러나 &lt;code&gt;Num&lt;/code&gt; 또는 &lt;code&gt;Denom&lt;/code&gt; 이 다른 두 &lt;code&gt;std::ratio&lt;/code&gt; 가 동일한 합리적인 수를 나타내더라도 (감소 후) 고유 한 유형입니다. &lt;code&gt;ratio&lt;/code&gt; 형이 낮은 조건을 통해 감소 될 수있다 &lt;code&gt;type&lt;/code&gt; 부재 : &lt;code&gt;std::ratio&amp;lt;3, 6&amp;gt;::type&lt;/code&gt; 인 &lt;code&gt;std::ratio&amp;lt;1, 2&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0f731b0d49e9b2f3318f0fcd7bbe6ca8c907339" translate="yes" xml:space="preserve">
          <source>The status of the file referred to by the entry.</source>
          <target state="translated">항목이 참조한 파일의 상태입니다.</target>
        </trans-unit>
        <trans-unit id="6e3ebc55efb178a42fb9d7d48d59cf130b8a23d3" translate="yes" xml:space="preserve">
          <source>The status of the pending recursion flag can be queried with &lt;a href=&quot;recursion_pending&quot;&gt;&lt;code&gt;recursion_pending()&lt;/code&gt;&lt;/a&gt;, which is &lt;code&gt;false&lt;/code&gt; after this call. It is reset back to &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;increment&quot;&gt;&lt;code&gt;increment&lt;/code&gt;&lt;/a&gt;, and its initial value is also &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">보류중인 재귀 플래그의 상태로 조회 할 수 있습니다 &lt;a href=&quot;recursion_pending&quot;&gt; &lt;code&gt;recursion_pending()&lt;/code&gt; &lt;/a&gt; 인 &lt;code&gt;false&lt;/code&gt; 이 호출 후. &lt;a href=&quot;increment&quot;&gt; &lt;code&gt;increment&lt;/code&gt; &lt;/a&gt; 후 다시 &lt;code&gt;true&lt;/code&gt; 로 재설정 되고 초기 값도 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0cb43bc5c74e77ae80142a18f784fbac3e0c33b7" translate="yes" xml:space="preserve">
          <source>The stem of the filename identified by the path (i.e. the filename without the final extension).</source>
          <target state="translated">경로로 식별되는 파일 이름의 줄기 (즉, 최종 확장자가없는 파일 이름)</target>
        </trans-unit>
        <trans-unit id="11590b2e7256668527e3216f99ac4fd9c7a4d00b" translate="yes" xml:space="preserve">
          <source>The storage class specifiers are a part of the decl-specifier-seq of a name's &lt;a href=&quot;declarations&quot;&gt;declaration syntax&lt;/a&gt;. Together with the &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; of the name, they control two independent properties of the name: its</source>
          <target state="translated">스토리지 클래스 지정자는 이름 &lt;a href=&quot;declarations&quot;&gt;선언 구문&lt;/a&gt; 의 decl-specifier-seq의 일부입니다 . 이름 의 &lt;a href=&quot;scope&quot;&gt;범위&lt;/a&gt; 와 함께 이름의 두 가지 독립적 인 속성을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="2f39d087c3a629b33b3a42976145e493b6fa58f5" translate="yes" xml:space="preserve">
          <source>The storage of a deque is automatically expanded and contracted as needed. Expansion of a deque is cheaper than the expansion of a &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; because it does not involve copying of the existing elements to a new memory location. On the other hand, deques typically have large minimal memory cost; a deque holding just one element has to allocate its full internal array (e.g. 8 times the object size on 64-bit libstdc++; 16 times the object size or 4096 bytes, whichever is larger, on 64-bit libc++).</source>
          <target state="translated">데크 저장소는 필요에 따라 자동으로 확장 및 축소됩니다. deque의 확장은 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 의 확장보다 저렴 합니다. 기존 요소를 새 메모리 위치에 복사하지 않기 때문입니다. 반면, deque는 일반적으로 최소의 메모리 비용이 큽니다. 하나의 요소 만 보유한 deque는 전체 내부 배열을 할당해야합니다 (예 : 64 비트 libstdc ++에서 객체 크기의 8 배, 64 비트 libc ++에서 객체 크기의 16 배 또는 4096 바이트 중 큰 것).</target>
        </trans-unit>
        <trans-unit id="b072292a5a1e2322c8e92bfdf268810f5282c203" translate="yes" xml:space="preserve">
          <source>The storage of the vector is handled automatically, being expanded and contracted as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using &lt;code&gt;&lt;a href=&quot;vector/capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; function.  Extra memory can be returned to the system via a call to &lt;code&gt;&lt;a href=&quot;vector/shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt;.(since C++11).</source>
          <target state="translated">벡터의 저장은 자동으로 처리되어 필요에 따라 확장 및 축소됩니다. 향후 증가를 처리하기 위해 더 많은 메모리가 할당되므로 벡터는 일반적으로 정적 배열보다 더 많은 공간을 차지합니다. 이 방법으로 요소를 삽입 할 때마다 벡터를 재 할당 할 필요는 없지만 추가 메모리가 소진 된 경우에만 가능합니다. &lt;code&gt;&lt;a href=&quot;vector/capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 할당 된 총 메모리 양을 쿼리 할 수 ​​있습니다 . &lt;code&gt;&lt;a href=&quot;vector/shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; 호출하여 추가 메모리를 시스템에 반환 할 수 있습니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="5892901fc4af7c4daeffcdff331dcbef5c156bb6" translate="yes" xml:space="preserve">
          <source>The stored callable object is called the</source>
          <target state="translated">저장된 호출 가능 객체를</target>
        </trans-unit>
        <trans-unit id="80952d2ca5513e2ab7bc4e81a28581ccd51f605f" translate="yes" xml:space="preserve">
          <source>The stored deleter object.</source>
          <target state="translated">저장된 삭제 객체.</target>
        </trans-unit>
        <trans-unit id="17b16ef531268271e85ec6f43ec173d4f90c59ff" translate="yes" xml:space="preserve">
          <source>The stored duration.</source>
          <target state="translated">저장된 기간.</target>
        </trans-unit>
        <trans-unit id="09a69b97d4bafa467ed76343a615b25a40c0cb70" translate="yes" xml:space="preserve">
          <source>The stored error category.</source>
          <target state="translated">저장된 오류 범주</target>
        </trans-unit>
        <trans-unit id="2281cefb9cf8d901883c448695a82804629a024b" translate="yes" xml:space="preserve">
          <source>The stored error code.</source>
          <target state="translated">저장된 오류 코드</target>
        </trans-unit>
        <trans-unit id="8af42892a4e54ba3e506e55de93429bf0536f70e" translate="yes" xml:space="preserve">
          <source>The stored pointer.</source>
          <target state="translated">저장된 포인터.</target>
        </trans-unit>
        <trans-unit id="433b5f42f978f29dcfd09128154cee8fea3f71e9" translate="yes" xml:space="preserve">
          <source>The stored reference.</source>
          <target state="translated">저장된 참조입니다.</target>
        </trans-unit>
        <trans-unit id="6c6f751d334cb9f8c0297588312a1852b3d27541" translate="yes" xml:space="preserve">
          <source>The stored task has already been invoked. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;promise_already_satisfied&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">저장된 작업이 이미 호출되었습니다. 오류 범주는 &lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;promise_already_satisfied&lt;/code&gt; &lt;/a&gt; 로 설정되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4df572d2c0e354b7f394388b3d124d21e95f48d8" translate="yes" xml:space="preserve">
          <source>The stored task has already been invoked. The error category is set to &lt;code&gt;promise_already_satisfied&lt;/code&gt;.</source>
          <target state="translated">저장된 작업이 이미 호출되었습니다. 오류 범주는 &lt;code&gt;promise_already_satisfied&lt;/code&gt; 로 설정되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="657cc28deb3f80f24e72e3ed2e272bb85d039858" translate="yes" xml:space="preserve">
          <source>The stream-based I/O library uses &lt;a href=&quot;io/manip&quot;&gt; I/O manipulators&lt;/a&gt; (e.g. &lt;code&gt;&lt;a href=&quot;io/manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/manip/hex&quot;&gt;std::hex&lt;/a&gt;&lt;/code&gt;, etc.) to control how streams behave.</source>
          <target state="translated">스트림 기반 I / O 라이브러리는 &lt;a href=&quot;io/manip&quot;&gt;I / O 조작기&lt;/a&gt; (예 : &lt;code&gt;&lt;a href=&quot;io/manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io/manip/hex&quot;&gt;std::hex&lt;/a&gt;&lt;/code&gt; 등)를 사용하여 스트림의 동작 방식을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="f1f8e1bf31666f17d818c7fb3629dbe63dce8038" translate="yes" xml:space="preserve">
          <source>The stream-based input/output library is organized around abstract input/output devices. These abstract devices allow the same code to handle input/output to files, memory streams, or custom adaptor devices that perform arbitrary operations (e.g. compression) on the fly.</source>
          <target state="translated">스트림 기반 입 / 출력 라이브러리는 추상 입 / 출력 장치를 중심으로 구성됩니다. 이러한 추상 장치는 동일한 코드가 파일, 메모리 스트림 또는 임의의 작업 (예 : 압축)을 즉시 수행하는 사용자 정의 어댑터 장치에 대한 입 / 출력을 처리 할 수 ​​있도록합니다.</target>
        </trans-unit>
        <trans-unit id="685e0728588ef7b354ca6ae06a3e39b651660d7d" translate="yes" xml:space="preserve">
          <source>The streambuf overload of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; if the streambuf argument is a null pointer or if no characters were inserted into the streambuf.</source>
          <target state="translated">streambuf 인수가 널 포인터이거나 streambuf에 문자가 삽입되지 않은 경우 &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; 의 streambuf 과부하입니다 .</target>
        </trans-unit>
        <trans-unit id="2d18ba3c4f605fc8501feb5b3351b46aa1577fcc" translate="yes" xml:space="preserve">
          <source>The streambuf overload of &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; if the function inserts no characters.</source>
          <target state="translated">함수가 문자를 삽입하지 않으면 &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt; &lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; 의 streambuf 과부하</target>
        </trans-unit>
        <trans-unit id="1ef23ffa702914245f81e5026dac9d4ebc2e587a" translate="yes" xml:space="preserve">
          <source>The string converted to the specified floating point type.</source>
          <target state="translated">지정된 부동 소수점 유형으로 변환 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="47c093236b31b3a204fe8f923fb21ca46aefe47b" translate="yes" xml:space="preserve">
          <source>The string converted to the specified signed integer type.</source>
          <target state="translated">지정된 부호있는 정수 유형으로 변환 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ce8f7eeb006b0c3d2b2b94eccb0b5ba0bb13623e" translate="yes" xml:space="preserve">
          <source>The string converted to the specified unsigned integer type.</source>
          <target state="translated">지정된 부호없는 정수 유형으로 변환 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="90cd8c741b9656548cd7c47ccb8f4e7b236d4d51" translate="yes" xml:space="preserve">
          <source>The string input function &lt;code&gt;&lt;a href=&quot;../../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;&lt;/code&gt; if it completes by reaching the end of the stream, as opposed to reaching the specified terminating character.</source>
          <target state="translated">지정된 종료 문자에 도달하는 대신 스트림 끝에 도달하면 문자열 입력 함수 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;&lt;/code&gt; 이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="fe144c3255daec881252d2a4f155b9abf0e72d73" translate="yes" xml:space="preserve">
          <source>The string library also provides class template &lt;code&gt;&lt;a href=&quot;string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; that defines types and functions for &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;(since C++17). The following specializations are defined:</source>
          <target state="translated">문자열 라이브러리는 &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; (C ++ 17부터)의 유형 및 함수를 정의 하는 클래스 템플리트 &lt;code&gt;&lt;a href=&quot;string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; 도 제공합니다 . 다음과 같은 전문 분야가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7a1c4ed4b5630d5ddaa1db0afbceba65c0447876" translate="yes" xml:space="preserve">
          <source>The string literal.</source>
          <target state="translated">문자열 리터럴.</target>
        </trans-unit>
        <trans-unit id="fe351b72d36bc72e8b0524c53861ac272e34795a" translate="yes" xml:space="preserve">
          <source>The string of type &lt;code&gt;string_type&lt;/code&gt; holding the characters to be used as positive or negative sign.</source>
          <target state="translated">양수 또는 음수 부호로 사용될 문자를 보유하는 &lt;code&gt;string_type&lt;/code&gt; 유형의 문자열 .</target>
        </trans-unit>
        <trans-unit id="645bada75f5704a14a70ee6b3ad9c4dbbc4a0cd1" translate="yes" xml:space="preserve">
          <source>The string transformed so that lexicographic comparison of the transformed strings may be used instead of collating of the originals. In the &quot;C&quot; locale, the returned string is the exact copy of &lt;code&gt;[low, high)&lt;/code&gt;. In other locales, the contents of the returned string are implementation-defined, and the size may be considerably longer.</source>
          <target state="translated">변환 된 문자열의 사전 비교를 사용하여 원본을 조합하는 대신 문자열을 변환 할 수 있습니다. &quot;C&quot;로케일에서 리턴 된 문자열은 &lt;code&gt;[low, high)&lt;/code&gt; 의 정확한 사본입니다 . 다른 로케일에서 리턴 된 문자열의 컨텐츠는 구현 정의되며 크기가 상당히 길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bed8f4fdf0727af913eee7d7f8de3facf8e379a9" translate="yes" xml:space="preserve">
          <source>The string_literal is typically a short program written in assembly language, which is executed whenever this declaration is executed. Different C++ compilers have wildly varying rules for asm-declarations, and different conventions for the interaction with the surrounding C++ code.</source>
          <target state="translated">string_literal은 일반적으로 어셈블리 언어로 작성된 짧은 프로그램으로,이 선언이 실행될 때마다 실행됩니다. C ++ 컴파일러마다 asm 선언에 대한 규칙이 다양하고 주변 C ++ 코드와의 상호 작용에 대한 규칙이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f3fd3bc3bb5bbc2174bee8f5c8d22f3d7dbcda9d" translate="yes" xml:space="preserve">
          <source>The string_view literal.</source>
          <target state="translated">string_view 리터럴</target>
        </trans-unit>
        <trans-unit id="9ed1cae434c8ab95486c8c0f6cf75e8ebd7662a2" translate="yes" xml:space="preserve">
          <source>The struct combines the performance and accessibility of a C-style array with the benefits of a standard container, such as knowing its own size, supporting assignment, random access iterators, etc.</source>
          <target state="translated">이 구조체는 C 스타일 배열의 성능과 접근성을 자체 크기 파악, 할당 지원, 임의 액세스 반복자 등과 같은 표준 컨테이너의 이점과 결합합니다.</target>
        </trans-unit>
        <trans-unit id="771b48d395936f4ddd7641ad97ebda6634abdf95" translate="yes" xml:space="preserve">
          <source>The subscript operator expressions have the form.</source>
          <target state="translated">아래 첨자 연산자 식의 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ee3ffed03585e5f9ff776a096eb8348d437e9c7" translate="yes" xml:space="preserve">
          <source>The substitution of template arguments into a requires-expression used in a declaration of a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt; may result in the formation of invalid types or expressions in its requirements, or the violation of semantic constraints of those requirements. In such cases, the requires-expression evaluates to &lt;code&gt;false&lt;/code&gt; and does not cause the program to be ill-formed. The substitution and semantic constraint checking proceeds in lexical order and stops when a condition that determines the result of the requires-expression is encountered. If substitution (if any) and semantic constraint checking succeed, the requires-expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">템플릿 인수를 &lt;a href=&quot;templates#Templated_entity&quot;&gt;템플릿 엔티티&lt;/a&gt; 선언에 사용 된 require-expression으로 대체 하면 요구 사항에 유효하지 않은 유형 또는 표현식이 형성되거나 해당 요구 사항의 의미 적 제한을 위반할 수 있습니다. 이러한 경우 require-expression은 &lt;code&gt;false&lt;/code&gt; 로 평가되며 프로그램이 잘못 작성되지 않습니다. 대체 및 의미 제한 조건 점검은 어휘 순서로 진행되며 require-expression의 결과를 판별하는 조건이 발생하면 중지됩니다. 대체 (있는 경우) 및 의미 제약 조건 검사가 성공하면 needs-expression이 &lt;code&gt;true&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="2246f7cf19b24f35ba44d7128f9f00cdf8cea437" translate="yes" xml:space="preserve">
          <source>The sum of the elements.</source>
          <target state="translated">요소의 합.</target>
        </trans-unit>
        <trans-unit id="89d93f088c99aca77c5be8b564b1d94b144b5b67" translate="yes" xml:space="preserve">
          <source>The sum of the returned value and the value stored in &lt;code&gt;*iptr&lt;/code&gt; gives &lt;code&gt;x&lt;/code&gt; (allowing for rounding).</source>
          <target state="translated">리턴 된 값과 &lt;code&gt;*iptr&lt;/code&gt; 에 저장된 값의 합 은 &lt;code&gt;x&lt;/code&gt; (반올림 허용)를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ff4ca6cf4d2e109c127290c18455fd2a7491a92c" translate="yes" xml:space="preserve">
          <source>The supplied lock &lt;code&gt;lk&lt;/code&gt; is held until the thread exits. Once this function has been called, no more threads may acquire the same lock in order to wait on &lt;code&gt;cond&lt;/code&gt;. If some thread is waiting on this condition variable, it should not attempt to release and reacquire the lock when it wakes up spuriously.</source>
          <target state="translated">나사산이 나올 때까지 제공된 잠금 장치 &lt;code&gt;lk&lt;/code&gt; 가 유지됩니다. 이 함수가 호출되면 &lt;code&gt;cond&lt;/code&gt; 를 대기하기 위해 더 이상 스레드가 동일한 잠금을 획득 할 수 없습니다 . 일부 스레드가이 조건 변수를 기다리고있는 경우, 스퓨리어스로 깨어날 때 잠금 해제 및 재 취득을 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e9ad164a9bae7d10fe5fec949515a05485fa2d71" translate="yes" xml:space="preserve">
          <source>The supplied version of the header &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; shall declare at least the functions &lt;code&gt;&lt;a href=&quot;utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;utility/program/quick_exit&quot;&gt;std::quick_exit&lt;/a&gt;&lt;/code&gt;(since C++11).</source>
          <target state="translated">&lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; 헤더의 제공된 버전은 최소한 &lt;code&gt;&lt;a href=&quot;utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/program/at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;utility/program/quick_exit&quot;&gt;std::quick_exit&lt;/a&gt;&lt;/code&gt; 함수를 선언해야합니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="5b99d0c2b824af433d36c158441c754d3faf4148" translate="yes" xml:space="preserve">
          <source>The swap functions do not invalidate any of the iterators inside the container, but they do invalidate the iterator marking the end of the swap region.</source>
          <target state="translated">스왑 함수는 컨테이너 내부의 반복자를 무효화하지 않지만 스왑 영역의 끝을 표시하는 반복자를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="21c84344f10b85ba83941112b65c0b80df28cba9" translate="yes" xml:space="preserve">
          <source>The synchronization is established only between the threads</source>
          <target state="translated">스레드간에 만 동기화가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="af5a157ab893f882387e99debe5b0576aec5458b" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;T object();&lt;/code&gt; does not initialize an object; it declares a function that takes no arguments and returns &lt;code&gt;T&lt;/code&gt;. The way to value-initialize a named variable before C++11 was &lt;code&gt;T object = T();&lt;/code&gt;, which value-initializes a temporary and then copy-initializes the object: most compilers &lt;a href=&quot;copy_elision&quot;&gt;optimize out the copy&lt;/a&gt; in this case.</source>
          <target state="translated">구문 &lt;code&gt;T object();&lt;/code&gt; 객체를 초기화하지 않습니다. 인수를 취하지 않고 &lt;code&gt;T&lt;/code&gt; 를 반환하는 함수를 선언합니다 . C ++ 11 이전에 명명 된 변수를 값으로 초기화하는 방법은 &lt;code&gt;T object = T();&lt;/code&gt; 임시 값을 초기화 한 다음 객체를 복사 초기화합니다. 대부분의 컴파일러 는이 경우 &lt;a href=&quot;copy_elision&quot;&gt;복사본&lt;/a&gt; 을 최적화합니다 .</target>
        </trans-unit>
        <trans-unit id="ae224bb840d8d7b9d78b650bc1b03492b672c0b6" translate="yes" xml:space="preserve">
          <source>The syntax forms (3,4) are known as designated initializers: each designator must name a direct non-static data members of T, and all designators used in the expression must appear in the same order as the data members of T.</source>
          <target state="translated">구문 형식 (3,4)은 지정된 이니셜 라이저로 알려져 있습니다. 각 지정자는 T의 직접 비 정적 데이터 멤버의 이름을 지정해야하며 표현식에 사용 된 모든 지정자는 T의 데이터 멤버와 동일한 순서로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="f00bfbaecf20babfadbc5e22b52d48a548c5a848" translate="yes" xml:space="preserve">
          <source>The syntax of</source>
          <target state="translated">문법</target>
        </trans-unit>
        <trans-unit id="6f89d606c1975f38aa5544527e8e97e16b6bb96a" translate="yes" xml:space="preserve">
          <source>The syntax of a function-like macro invocation is similar to the syntax of a function call: each instance of the macro name followed by a &lt;code&gt;(&lt;/code&gt; as the next preprocessing token introduces the sequence of tokens that is replaced by the replacement-list. The sequence is terminated by the matching &lt;code&gt;)&lt;/code&gt; token, skipping intervening matched pairs of left and right parentheses.</source>
          <target state="translated">함수와 유사한 매크로 호출의 구문은 함수 호출의 구문과 유사합니다. 매크로 이름의 각 인스턴스 뒤에 &lt;code&gt;(&lt;/code&gt; 다음 전처리 토큰이 대체 목록으로 대체되는 토큰 시퀀스를 소개하므로) 일치하는 &lt;code&gt;)&lt;/code&gt; 토큰으로 종료되고 일치하는 왼쪽 및 오른쪽 괄호 쌍을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="9bcf66af5c16c1977a2766c06868ed208b549d02" translate="yes" xml:space="preserve">
          <source>The syntax of a user-defined deduction guide is the syntax of a function declaration with a trailing return type, except that it uses the name of a class template as the function name:</source>
          <target state="translated">사용자 정의 추론 안내서의 구문은 클래스 템플릿의 이름을 함수 이름으로 사용한다는 점을 제외하고 후행 반환 유형의 함수 선언 구문입니다.</target>
        </trans-unit>
        <trans-unit id="de7f5913c9173da622b172081363583fac269c9b" translate="yes" xml:space="preserve">
          <source>The syntax of an individual capture in captures is.</source>
          <target state="translated">캡처에서 개별 캡처의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="702f4bc2e64078809bb1b5388513237231aab2e6" translate="yes" xml:space="preserve">
          <source>The system-supplied locales normally do not collate two strings as equivalent (&lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; does not return &lt;code&gt;​0​&lt;/code&gt;) if &lt;a href=&quot;../../string/basic_string/operator_cmp&quot;&gt;&lt;code&gt;basic_string::operator==&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;, but a user-installed &lt;code&gt;&lt;a href=&quot;../collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet may provide different collation rules, for example, it may treat strings as equivalent if they have the same Unicode normalized form.</source>
          <target state="translated">시스템 제공 로케일은 일반적으로 (동등하지 부씩 두 개의 문자열을 &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; 반환하지 않습니다 &lt;code&gt;​0​&lt;/code&gt; ) 경우 &lt;a href=&quot;../../string/basic_string/operator_cmp&quot;&gt; &lt;code&gt;basic_string::operator==&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;false&lt;/code&gt; 하지만 사용자가 설치 한 &lt;code&gt;&lt;a href=&quot;../collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; ,면 다른 조합 규칙을 제공 할 수있다 예를 들어, 동일한 유니 코드 정규화 형식을 가진 문자열을 동등한 것으로 취급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48237f3ec26215b3606e67c0e6d68687b01822f6" translate="yes" xml:space="preserve">
          <source>The target of the symlink (which may not necessarily exist).</source>
          <target state="translated">심볼릭 링크의 대상 (필수하지 않을 수도 있음)</target>
        </trans-unit>
        <trans-unit id="676256b3d34d8447f5998ce9c718f12a262b3700" translate="yes" xml:space="preserve">
          <source>The template argument that can be used with a non-type template parameter can be any &lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of the type of the template parameter.</source>
          <target state="translated">비 유형 템플릿 매개 변수와 함께 사용할 수있는 템플릿 인수는 템플릿 매개 변수 유형의 &lt;a href=&quot;constant_expression&quot;&gt;변환 된 상수 식일&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50cbc99825f7a6c9a124b9687858d33d44b2131c" translate="yes" xml:space="preserve">
          <source>The template can be specialized for user-defined iterators so that the information about the iterator can be retrieved even if the type does not provide the usual typedefs.</source>
          <target state="translated">유형이 일반적인 typedef를 제공하지 않더라도 반복자에 대한 정보를 검색 할 수 있도록 템플리트를 사용자 정의 반복기에 특화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="557201976e8a00a9ece65cd2feec4760fa0f5cd2" translate="yes" xml:space="preserve">
          <source>The template function &lt;code&gt;async&lt;/code&gt; runs the function &lt;code&gt;f&lt;/code&gt; asynchronously (potentially in a separate thread which may be part of a thread pool) and returns a &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; that will eventually hold the result of that function call.</source>
          <target state="translated">템플릿 함수 &lt;code&gt;async&lt;/code&gt; 는 함수 &lt;code&gt;f&lt;/code&gt; 를 비동기식으로 (잠재적으로 스레드 풀의 일부일 수있는 별도의 스레드에서) 실행하고 결국 해당 함수 호출의 결과를 보유 할 &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eff5e7944f6337f3549b2f87230ec73fcb57ba24" translate="yes" xml:space="preserve">
          <source>The template may be specialized for any user-defined &lt;code&gt;T&lt;/code&gt; type: the specialization must satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">템플릿은 사용자 정의에 대한 전문 될 수 있습니다 &lt;code&gt;T&lt;/code&gt; 의 유형 : 전문화가 만족해야 &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait을&lt;/a&gt; 함께</target>
        </trans-unit>
        <trans-unit id="57234bb7a67c620ea3f65bd79181da8581f11c93" translate="yes" xml:space="preserve">
          <source>The template parameter &lt;code&gt;TimeZonePtr&lt;/code&gt; allows users to supply their own time zone pointer types and further customize the behavior of &lt;code&gt;zoned_time&lt;/code&gt; via &lt;code&gt;std::chrono::zoned_traits&lt;/code&gt;. Custom time zone types need not support all the operations supported by &lt;code&gt;std::chrono::time_zone&lt;/code&gt;, only those used by the functions actually called on the &lt;code&gt;zoned_time&lt;/code&gt;.</source>
          <target state="translated">템플릿 매개 변수 &lt;code&gt;TimeZonePtr&lt;/code&gt; 을 사용하면 사용자가 고유 한 시간대 포인터 유형을 제공하고 &lt;code&gt;std::chrono::zoned_traits&lt;/code&gt; 를 통해 &lt;code&gt;zoned_time&lt;/code&gt; 의 동작을 추가로 사용자 정의 할 수 있습니다 . 사용자 정의 시간대 유형은 &lt;code&gt;std::chrono::time_zone&lt;/code&gt; 에서 지원하는 모든 조작을 지원할 필요는 없으며 &lt;code&gt;zoned_time&lt;/code&gt; 에서 실제로 호출 된 함수에서만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="976e95956188ddd1cc5dc013bb47e40cd53b4619" translate="yes" xml:space="preserve">
          <source>The template parameter list and the template argument list of a member of a partial specialization must match the parameter list and the argument list of the partial specialization.</source>
          <target state="translated">부분 특수화 구성원의 템플리트 매개 변수 목록 및 템플리트 인수 목록은 매개 변수 목록 및 부분 특수화의 인수 목록과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="35c19ab099f7c63eddf13b79738caebc5d6c5994" translate="yes" xml:space="preserve">
          <source>The template parameter list may be followed by an optional &lt;a href=&quot;constraints#Requires_clauses&quot;&gt;requires-clause&lt;/a&gt; that specifies the &lt;a href=&quot;constraints&quot;&gt;constraints&lt;/a&gt; on the template arguments.</source>
          <target state="translated">템플리트 매개 변수 목록 다음에 는 템플리트 인수에 대한 &lt;a href=&quot;constraints&quot;&gt;제한 조건&lt;/a&gt; 을 지정 하는 선택적 &lt;a href=&quot;constraints#Requires_clauses&quot;&gt;require-clause&lt;/a&gt; 가 올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e09d82796b1385db8c4e7f7eb0aae7cb58e1066" translate="yes" xml:space="preserve">
          <source>The template parameter lists of template template parameters can have their own default arguments, which are only in effect where the template template parameter itself is in scope:</source>
          <target state="translated">템플리트 템플리트 매개 변수의 템플리트 매개 변수 목록에는 고유 한 기본 인수가있을 수 있으며 이는 템플리트 템플리트 매개 변수 자체가 범위 내에있는 경우에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b6ab43de318de05ac5e805e82ee83900637e335" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; class allows users to obtain hashes of the identifiers of threads.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; 클래스에 대한 &lt;code&gt;&lt;a href=&quot;../../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 스레드 식별자의 해시를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1617c98734849159498d6d58c8ee6130545cbbf2" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5b98ae6aa533d3d486ad6a1f3c3dd5a2a2cc3c3" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="189f220de4b5df21be91fb36e6e09506d95caaf2" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; &amp;lt;T&amp;gt;에 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; &amp;lt;T&amp;gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fa82fede24ddf383b749f64c40120c7a6b969fc" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e08e96dcabc0ff66b712bd52aab0a0c10bbb4f5" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; &amp;lt;T, Deleter&amp;gt;에 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; &amp;lt;T, Deleter&amp;gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c9f3d1ec6cfcd95caae7ac3bda8cf8e03255245" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; &amp;lt;bool&amp;gt;에 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 특수화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; &amp;lt;bool&amp;gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d968cfa6e1f3e875e46aac917073ba195240e6bb" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; &amp;lt;N&amp;gt;에 대한 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; &amp;lt;N&amp;gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce7952ddebf3c0d01e620facea4a820fd43fa101" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; class allows users to obtain hashes of the values contained in &lt;code&gt;optional&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; 클래스에 대한 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 특수화를 통해 사용자는 &lt;code&gt;optional&lt;/code&gt; 오브젝트에 포함 된 값의 해시를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db5007b65d07bfed77b8824218281a413afda965" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; template allows users to obtain hashes of &lt;code&gt;variant&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; 템플릿에 대한 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플릿 전문화를 통해 &lt;code&gt;variant&lt;/code&gt; 객체의 해시를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ddcabf8bbccc8b0c948a37b70ba7a9f9c022693" translate="yes" xml:space="preserve">
          <source>The template specializations of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the various string classes allow users to obtain hashes of strings.</source>
          <target state="translated">다양한 문자열 클래스에 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플릿 전문화를 통해 사용자는 문자열 해시를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="584921a66a2cf4fe71de6a59a91614782dd86242" translate="yes" xml:space="preserve">
          <source>The template version of this assignment operator in the specialization for arrays, &lt;code&gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt; behaves the same as in the primary template, except that will only participate in overload resolution if all of the following is true:</source>
          <target state="translated">배열 전문 &lt;code&gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt; 에서이 대입 연산자의 템플릿 버전은 기본 템플릿과 동일하게 동작하지만 다음 사항이 모두 참일 경우에만 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="0ac5be2688655da010f5c804e64763bf5f3459f9" translate="yes" xml:space="preserve">
          <source>The template version of this assignment operator only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not an array type and &lt;code&gt;unique_ptr&amp;lt;U,E&amp;gt;::pointer&lt;/code&gt; is implicitly convertible to &lt;code&gt;pointer&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;Deleter&amp;amp;, E&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;(since C++17).</source>
          <target state="translated">경우이 할당 연산자의 템플릿 버전은 오버로드 확인에 참여 &lt;code&gt;U&lt;/code&gt; 가 배열 형과 아닌 &lt;code&gt;unique_ptr&amp;lt;U,E&amp;gt;::pointer&lt;/code&gt; 로 암시 적으로 변환 가능한 &lt;code&gt;pointer&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;Deleter&amp;amp;, E&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; ( C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="22030dbd3e1d3908354d7549e8f30d9f71beae72" translate="yes" xml:space="preserve">
          <source>The templated class &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; generalizes how sequences of characters are manipulated and stored. String creation, manipulation, and destruction are all handled by a convenient set of class methods and related functions.</source>
          <target state="translated">템플릿 클래스 &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 은 일련의 문자를 조작하고 저장하는 방법을 일반화합니다. 문자열 생성, 조작 및 소멸은 모두 편리한 클래스 메소드 및 관련 함수 세트로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ae2a3669d2ccc3c953612c7002da0c5821d0cf01" translate="yes" xml:space="preserve">
          <source>The templated class &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; provides a lightweight object that offers read-only access to a string or a part of a string using an interface similar to the interface of &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">템플릿 기반 클래스는 &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; 이벤트의 인터페이스와 유사한 인터페이스를 사용하여 문자열 또는 문자열의 일부에 대한 읽기 전용 액세스하는 경량 객체 제공하는 &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5938eb91acf69026cdeecae1d1a114be0e7c8cbb" translate="yes" xml:space="preserve">
          <source>The temporary object is constructed from the function argument or return value, respectively, and the function's parameter or return object is initialized as if by using the non-deleted trivial constructor to copy the temporary (even if that constructor is inaccessible or would not be selected by overload resolution to perform a copy or move of the object).</source>
          <target state="translated">임시 객체는 각각 함수 인수 또는 반환 값으로 구성되며, 삭제되지 않은 간단한 생성자를 사용하여 임시를 복사하는 것처럼 (해당 생성자가 액세스 할 수 없거나 선택되지 않은 경우에도) 함수의 매개 변수 또는 반환 객체가 초기화됩니다. 오버로드 해상도로 복사 또는 개체 이동).</target>
        </trans-unit>
        <trans-unit id="d35cf85afe81dba05bfcd30078a13ec4b61a6248" translate="yes" xml:space="preserve">
          <source>The terminating null character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 의 종료 널 문자 는 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b502a26934eaa1380b44846902030ef133c5174" translate="yes" xml:space="preserve">
          <source>The terminating null character is considered to be a part of the string and can be found if searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">종료 널 문자는 문자열의 일부로 간주되며 &lt;code&gt;'\0'&lt;/code&gt; 검색하면 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e942509d6816ccf9d123b1cf1595fd4cb7dbdb4" translate="yes" xml:space="preserve">
          <source>The terminating null wide character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 의 종료 널 와이드 문자 는 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f64c2cf450c071f73e284e57290f6f2917e30baf" translate="yes" xml:space="preserve">
          <source>The test &lt;code&gt;ptr-&amp;gt;weak_this.expired()&lt;/code&gt; in the exposition code above makes sure that &lt;code&gt;weak_this&lt;/code&gt; is not reassigned if it already indicates an owner. This test is required as of C++17.</source>
          <target state="translated">위의 박람회 코드에서 테스트 &lt;code&gt;ptr-&amp;gt;weak_this.expired()&lt;/code&gt; 는 &lt;code&gt;weak_this&lt;/code&gt; 가 이미 소유자를 나타내는 경우 재 할당되지 않도록합니다 . 이 테스트는 C ++ 17부터 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a76ffdb1119a59ee47d50b27acec60df78d37530" translate="yes" xml:space="preserve">
          <source>The textual representation is written with &lt;code&gt;os.fmtflags&lt;/code&gt; set to &lt;code&gt;ios_base::dec&lt;/code&gt;|&lt;code&gt;ios_base::left&lt;/code&gt; and the fill character set to the space character. The textual representation of the engine's internal state is a set of decimal numbers separated by spaces.</source>
          <target state="translated">텍스트 표현은 &lt;code&gt;os.fmtflags&lt;/code&gt; 를 &lt;code&gt;ios_base::dec&lt;/code&gt; | &lt;code&gt;ios_base::left&lt;/code&gt; 및 채우기 문자는 공백 문자로 설정됩니다. 엔진 내부 상태의 텍스트 표현은 공백으로 구분 된 십진수 세트입니다.</target>
        </trans-unit>
        <trans-unit id="a79d1b4a44870cfcd4b53d3f95a0c8fcc074b16b" translate="yes" xml:space="preserve">
          <source>The textual representation of &lt;code&gt;A&lt;/code&gt; includes the textual representation of &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">의 텍스트 표현 &lt;code&gt;A&lt;/code&gt; 는 의 텍스트 표현을 포함하는 &lt;code&gt;B&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="484f772cf54bb66a16db5954b6b4e3c3d93ea751" translate="yes" xml:space="preserve">
          <source>The thread that intends to modify the variable has to.</source>
          <target state="translated">변수를 수정하려는 스레드가해야합니다.</target>
        </trans-unit>
        <trans-unit id="e07534c510b6011cf58e1ef843a07565960e50d4" translate="yes" xml:space="preserve">
          <source>The three-way comparison operator expressions have the form.</source>
          <target state="translated">3 방향 비교 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab243e4025d54ef42cc354407fff2484190465e4" translate="yes" xml:space="preserve">
          <source>The throw-expression &lt;code&gt;throw &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;;&lt;/code&gt; is not guaranteed to be matched by a pointer catch clause, because the exception object type may be &lt;code&gt;int&lt;/code&gt;, but &lt;code&gt;throw nullptr;&lt;/code&gt; is assuredly matched by any pointer or pointer-to-member catch clause.</source>
          <target state="translated">throw-expression &lt;code&gt;throw &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;;&lt;/code&gt; 예외 객체 유형이 &lt;code&gt;int&lt;/code&gt; 일 수 있지만 &lt;code&gt;throw nullptr;&lt;/code&gt; 때문에 포인터 catch 절과 일치한다고 보장되지 않습니다 . 모든 포인터 또는 포인터 대 구성원 catch 절과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7ac8ab79b96ed80e6fe4f38b7019eb38273067c1" translate="yes" xml:space="preserve">
          <source>The throw-expression is classified as &lt;a href=&quot;value_category&quot;&gt;prvalue expression&lt;/a&gt; of type &lt;code&gt;void&lt;/code&gt;. Like any other expression, it may be a sub-expression in another expression, most commonly in the &lt;a href=&quot;operator_other#Conditional_operator&quot;&gt;conditional operator&lt;/a&gt;:</source>
          <target state="translated">throw-expression은 &lt;code&gt;void&lt;/code&gt; 유형의 &lt;a href=&quot;value_category&quot;&gt;prvalue expression&lt;/a&gt; 으로 분류됩니다 . 다른 표현식과 마찬가지로 다른 표현식의 하위 표현식 일 수 있습니다. 가장 일반적으로 &lt;a href=&quot;operator_other#Conditional_operator&quot;&gt;조건부 연산자에서는&lt;/a&gt; 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f868d34253cbb949d0014de0f9071a9627d84ee5" translate="yes" xml:space="preserve">
          <source>The throwing overload is additionally specified to throw &lt;code&gt;&lt;a href=&quot;filesystem_error&quot;&gt;std::filesystem::filesystem_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;status(p)&lt;/code&gt; would throw.</source>
          <target state="translated">&lt;code&gt;status(p)&lt;/code&gt; 가 발생하면 &lt;code&gt;&lt;a href=&quot;filesystem_error&quot;&gt;std::filesystem::filesystem_error&lt;/a&gt;&lt;/code&gt; 발생 시키도록 발생하는 과부하가 추가로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc934bec30518ea798c5b7ac6343fa0fedd9880c" translate="yes" xml:space="preserve">
          <source>The tick period of the clock in seconds.</source>
          <target state="translated">시계의 틱 기간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="2af4361db95a4cd97928b9e845816898c3e9820b" translate="yes" xml:space="preserve">
          <source>The tied stream, or a null pointer if there was no tied stream.</source>
          <target state="translated">연결된 스트림 또는 연결된 스트림이없는 경우 null 포인터.</target>
        </trans-unit>
        <trans-unit id="a5636311e3a8dbe661c517df9ff905b4bc0cff87" translate="yes" xml:space="preserve">
          <source>The time input manipulator &lt;code&gt;&lt;a href=&quot;../manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; (technically, &lt;a href=&quot;../../locale/time_get/get&quot;&gt;&lt;code&gt;time_get::get&lt;/code&gt;&lt;/a&gt; it calls), if the input cannot be unambiguously parsed as a time value according to the given format string.</source>
          <target state="translated">입력 을 주어진 형식 문자열에 따라 시간 값으로 명확하게 구문 분석 할 수없는 경우 시간 입력 조작기 &lt;code&gt;&lt;a href=&quot;../manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; (기술적으로 &lt;a href=&quot;../../locale/time_get/get&quot;&gt; &lt;code&gt;time_get::get&lt;/code&gt; &lt;/a&gt; 호출)입니다.</target>
        </trans-unit>
        <trans-unit id="9fa1c3ac8a91c2dbb258d7d0b1ca35724a76b047" translate="yes" xml:space="preserve">
          <source>The timeout has expired</source>
          <target state="translated">시간 초과가 만료되었습니다</target>
        </trans-unit>
        <trans-unit id="cda93e07e16d4fa1f6f842ae631aef263d983dc5" translate="yes" xml:space="preserve">
          <source>The top-level scope of a translation unit (&quot;file scope&quot; or &quot;global scope&quot;) is also a namespace and is properly called &quot;global namespace scope&quot;. The potential scope of any entity declared in the global namespace scope begins at the declaration and continues to the end of the translation unit.</source>
          <target state="translated">번역 단위의 최상위 범위 ( &quot;파일 범위&quot;또는 &quot;전역 범위&quot;)도 네임 스페이스이며 &quot;글로벌 네임 스페이스 범위&quot;라고합니다. 글로벌 네임 스페이스 범위에 선언 된 엔터티의 잠재적 범위는 선언에서 시작하여 번역 단위의 끝까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b95d9b7d4331d266dae2fa32fe8fccb817c35a" translate="yes" xml:space="preserve">
          <source>The trait &lt;code&gt;std::is_copy_assignable&lt;/code&gt; is less strict than &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; because it does not check the type of the result of the assignment (which, for a &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; type, must be an lvalue of type &lt;code&gt;T&lt;/code&gt;) and does not check the semantic requirement that the argument expression remains unchanged. It also does not check that &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, which is required of all &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; types.</source>
          <target state="translated">특성 &lt;code&gt;std::is_copy_assignable&lt;/code&gt; 은 할당 결과의 유형을 검사하지 않으므로 ( &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 유형의 경우 &lt;code&gt;T&lt;/code&gt; 유형의 lvalue 여야 함 ) 인수가 의미하는 의미 요구 사항을 검사하지 않기 때문에 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 보다 덜 엄격 합니다. 표현은 변하지 않습니다. 또한 &lt;code&gt;T&lt;/code&gt; 가 모든 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 유형에 필요한 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable을&lt;/a&gt; 충족 하는지 확인하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="31f748256061c85c5babfc77d3f3bd56ed39666b" translate="yes" xml:space="preserve">
          <source>The trait &lt;code&gt;std::is_move_assignable&lt;/code&gt; is less strict than &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; because it does not check the type of the result of the assignment (which, for a &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; type, must be &lt;code&gt;T&amp;amp;&lt;/code&gt;), nor the semantic requirement that the target's value after the assignment is equivalent to the source's value before the assignment.</source>
          <target state="translated">&lt;code&gt;std::is_move_assignable&lt;/code&gt; 특성 은 할당 결과의 유형 ( &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 유형의 경우 &lt;code&gt;T&amp;amp;&lt;/code&gt; 이어야 함 ) 또는 할당 후 대상 값이 동일한 의미 론적 요구 사항을 확인하지 않기 때문에 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 보다 덜 엄격 합니다. 할당 전에 소스 값으로.</target>
        </trans-unit>
        <trans-unit id="c13322dcd5d602786d0d4da2697757a492c38ddc" translate="yes" xml:space="preserve">
          <source>The transformed type is a publicly accessible nested type named &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">변환 된 유형은 공개적으로 액세스 가능한 중첩 유형 인 &lt;code&gt;type&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd0c6a8d80fefbf063a7c6fc4d41e35477e554e0" translate="yes" xml:space="preserve">
          <source>The transition algorithm of the LCG function is x</source>
          <target state="translated">LCG 함수의 전이 알고리즘은 x입니다.</target>
        </trans-unit>
        <trans-unit id="ed030a839d21fbb758c903e3966139f3e58ea684" translate="yes" xml:space="preserve">
          <source>The tuple need not be &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, and instead may be anything that supports &lt;code&gt;std::get&lt;/code&gt; and &lt;code&gt;std::tuple_size&lt;/code&gt;; in particular, &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">튜플은 &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 일 필요는 없으며 대신 &lt;code&gt;std::get&lt;/code&gt; 및 &lt;code&gt;std::tuple_size&lt;/code&gt; 를 지원하는 것이 될 수 있습니다 . 특히, &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 가 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faab3655bae1576862bf3243d78b803053240daa" translate="yes" xml:space="preserve">
          <source>The tuple-like interpretation is always used if &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; is a complete type, even if that would cause the program to be ill-formed:</source>
          <target state="translated">튜플과 같은 해석은 &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; 가 완전한 유형 인 경우 프로그램이 잘못 구성 되더라도 항상 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="280f7270ad4976a06da0f10d73ed8109ee8c86a2" translate="yes" xml:space="preserve">
          <source>The two overloads are distinct because the types of the parameter &lt;code&gt;func&lt;/code&gt; are distinct (&lt;a href=&quot;../../language/language_linkage&quot;&gt;language linkage&lt;/a&gt; is part of its type).</source>
          <target state="translated">매개 변수 &lt;code&gt;func&lt;/code&gt; 의 유형이 다르기 때문에 두 개의 과부하가 서로 다릅니다 ( &lt;a href=&quot;../../language/language_linkage&quot;&gt;언어 연결&lt;/a&gt; 은 해당 유형의 일부 임).</target>
        </trans-unit>
        <trans-unit id="ced307005cb72698444581ef51d2ce693acf63e2" translate="yes" xml:space="preserve">
          <source>The two overloads provided by the C++ standard library are distinct because the types of the parameter &lt;code&gt;comp&lt;/code&gt; are distinct (&lt;a href=&quot;../language/language_linkage&quot;&gt;language linkage&lt;/a&gt; is part of its type).</source>
          <target state="translated">매개 변수 &lt;code&gt;comp&lt;/code&gt; 의 유형이 다르기 때문에 C ++ 표준 라이브러리에서 제공하는 두 개의 오버 로드 는 서로 다릅니다 ( &lt;a href=&quot;../language/language_linkage&quot;&gt;언어 연결&lt;/a&gt; 은 해당 유형의 일부 임).</target>
        </trans-unit>
        <trans-unit id="7e0c402d18cba21bbc3c62ac427b669b87db8687" translate="yes" xml:space="preserve">
          <source>The two-way comparison operator expressions have the form.</source>
          <target state="translated">양방향 비교 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b32340d0d14dfd5d1c51dde23771404f36595788" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="e3e4f9ee4f9a6dc679b68e252ddbe4d829628a2f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;D&lt;/code&gt; satisfies RandomNumberDistribution if.</source>
          <target state="translated">유형 &lt;code&gt;D&lt;/code&gt; 는 다음 경우 RandomNumberDistribution을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="9d9d3aa5279931f61ae09ea879f4c70a82c6ceaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;G&lt;/code&gt; satisfies UniformRandomBitGenerator if.</source>
          <target state="translated">유형 &lt;code&gt;G&lt;/code&gt; 는 UniformRandomBitGenerator를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="c21b37c97960f36e90434bac25ddcd2dc1e68569" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; 만족 &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2dca3e5d709f32f44d0ddfe5eab719ca4892184c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, and</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable을&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="23ab122f56da738cdd552f61aadec9d1cd833ab0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, and</source>
          <target state="translated">형식 &lt;code&gt;It&lt;/code&gt; &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible을&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="b6b3d6cdd7d4f3c9acce01cee40f271ece634a18" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; 만족 &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252d2ffb66f7d81557faa1f7f4f4ea09867d93b2" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; &lt;a href=&quot;destructible&quot;&gt;Destructible을&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="4b8f1bcfc4815dc189422b13e3981c0b3806ab7c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; 만족 &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable로&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7e27b1e0bc61deba4ad72e16345b7759b232775" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;It&lt;/code&gt; &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator를&lt;/a&gt; 만족시키는 유형</target>
        </trans-unit>
        <trans-unit id="8e98de10f38832410717d032044fe5876aae1620" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;It&lt;/code&gt; &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator를&lt;/a&gt; 만족시키는 유형</target>
        </trans-unit>
        <trans-unit id="19b959ec118b4fc4e346a0c4b3066583c69eb391" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; 만족 &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e6b1f70b5515f9b7f9ece951c8b0565a4faeae3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies ConstexprIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; ConstexprIterator를 충족시키는 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="99ec40230a473cc7e644a50a1f568278d332cce3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyBidirectionalIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; LegacyBidirectionalIterator를 충족시키는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="fb470c2619e1df677c704caef889c4118fc3151e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyContiguousIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; LegacyContiguousIterator를 충족시키는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="630cbbc2820c720d8b04165d105e0a9744bea443" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyForwardIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; LegacyForwardIterator를 충족시키는 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="0ffbcd885e9525a21db6be67dd85f4aff0c605f1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyInputIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; LegacyInputIterator를 충족시키는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="98c67370e8cebdd88c142031ae165afb773d121a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; LegacyIterator를 충족시키는 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="685b9ef2517672d40d4de466c9757d30ae0a366e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyRandomAccessIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; LegacyRandomAccessIterator를 충족시키는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="c0271171a00bcc035de12ccb951df5f4eb58be30" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies some iterator requirements MeowIterator</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; 만족 일부 반복자 요구 사항을 MeowIterator</target>
        </trans-unit>
        <trans-unit id="3fa432a57da4f847b5c070a3bfc7c01c5763011a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">타입 &lt;code&gt;Ret&lt;/code&gt; 타입의 객체되도록 있어야 &lt;code&gt;ForwardIt&lt;/code&gt; 는 역 참조와 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3a1ebcc723e658952997b5498f82af157e85e51" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">유형 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체되도록 있어야 &lt;code&gt;OutputIt&lt;/code&gt; 는 역 참조와 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="949b21cde2cc2392d063407c9e220c78be2ec5c8" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;CopyInsertable&lt;/strong&gt; into the container &lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; into &lt;code&gt;X&lt;/code&gt;, and, given.</source>
          <target state="translated">타입 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;strong&gt;CopyInsertable&lt;/strong&gt; 용기에 &lt;code&gt;X&lt;/code&gt; 누구 &lt;code&gt;value_type&lt;/code&gt; 동일 &lt;code&gt;T&lt;/code&gt; 경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;a href=&quot;moveinsertable&quot;&gt;MoveInsertable를&lt;/a&gt; 로 &lt;code&gt;X&lt;/code&gt; 및 주어진.</target>
        </trans-unit>
        <trans-unit id="3d96c921cf6324f16eef56dd97bb17fac1318864" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;DefaultInsertable&lt;/strong&gt; into the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">타입 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;strong&gt;DefaultInsertable&lt;/strong&gt; 에 &lt;a href=&quot;container&quot;&gt;컨테이너 &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; &lt;code&gt;value_type&lt;/code&gt; 동일 &lt;code&gt;T&lt;/code&gt; 주어진 경우.</target>
        </trans-unit>
        <trans-unit id="4a2192b55df7721f52fc4a376a8910667373086e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;EmplaceConstructible&lt;/strong&gt; into the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; (whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt;) from the arguments &lt;code&gt;args&lt;/code&gt; if, given.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 주어진 경우 인수 &lt;code&gt;args&lt;/code&gt; 에서 &lt;a href=&quot;container&quot;&gt;컨테이너 &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; 에 대한 &lt;strong&gt;EmplaceConstructible입니다&lt;/strong&gt; ( &lt;code&gt;value_type&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 와 동일 ) .</target>
        </trans-unit>
        <trans-unit id="5237f2595087683918faff0e0fb827167c77ec98" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;Erasable&lt;/strong&gt; from the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">타입 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;strong&gt;소거&lt;/strong&gt; 로부터 &lt;a href=&quot;container&quot;&gt;컨테이너 &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; 그의 &lt;code&gt;value_type&lt;/code&gt; 동일 &lt;code&gt;T&lt;/code&gt; 주어진 경우.</target>
        </trans-unit>
        <trans-unit id="7c4f49cd45501a79870e1b3afa64d91ff0308500" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;MoveInsertable&lt;/strong&gt; into the container &lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 주어진 경우 &lt;code&gt;value_type&lt;/code&gt; 이 &lt;code&gt;T&lt;/code&gt; 와 동일한 컨테이너 &lt;code&gt;X&lt;/code&gt; 로 &lt;strong&gt;MoveInsertable&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e41120cbb6ece4723895cfa12eeda9a968c6032" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is not allowed to be an &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, even if the size or internal structure of &lt;code&gt;T&lt;/code&gt; is never used, as in &lt;code&gt;&amp;amp;x[0]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;x[0]&lt;/code&gt; 에서처럼 &lt;code&gt;T&lt;/code&gt; 의 크기 또는 내부 구조를 사용하지 않은 경우에도 &lt;code&gt;T&lt;/code&gt; 유형 은 &lt;a href=&quot;incomplete_type&quot;&gt;불완전한 유형&lt;/a&gt; 이 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="94188845ce20ed55f2a876e3342aa84bc7330295" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt;, and</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형 은 &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate를&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="4d4404ddfa538ff7555e67eecb1dbcc3ff5cdc1a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt;, &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형 은 &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt; , &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt; 및</target>
        </trans-unit>
        <trans-unit id="0db4b9570ecd95be9606704e9f21eff1149143a0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, and</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형 은 &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable을&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="6647adc652b8dbbc01016470d35eed7d2fe7e630" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;, and</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형 은 &lt;a href=&quot;moveconstructible&quot;&gt;MoveConstructible을&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="4262127f8a223198cec9f54e58d1717c6a50c453" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;code&gt;&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object&lt;/a&gt;&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형 은 &lt;code&gt;&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object&lt;/a&gt;&lt;/code&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="3f046e47e7505811e9555f3b245d7d20697f7a3e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Callable if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 호출 가능 if를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="49e6eff2866df130bb7fd318296a16096d51e92f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Compare if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 비교 경우를 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="66ff21aa578ecf4f62632269d8614fbe18a110bb" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies CopyAssignable if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 다음과 같은 경우 CopyAssignable을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="0ad2a77779033cb383bdf5ceddef00240ba13b76" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies CopyConstructible if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 다음과 같은 경우 CopyConstructible을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="2e05ec58d3dab38ca771379d16b2fe5adee88104" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies DefaultConstructible if.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형 은 DefaultConstructible if를 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="cc55fbe4fbf6e0f85ba467734b5b915583f84e1b" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Destructible if.</source>
          <target state="translated">타입 &lt;code&gt;T&lt;/code&gt; 는 파괴 가능한 경우를 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="dfe96628803d13e4d50a5465ce9ed6a67992a048" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies EqualityComparable if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 EqualityComparable if를 충족합니다.</target>
        </trans-unit>
        <trans-unit id="41ee5c2d1ddb0009a5b5ac10f88ce89d5cc10e9a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies FunctionObject if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 다음 경우에 FunctionObject를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="3ae67a347ab32c589872346530c83699208f4eaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Hash if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 해시를 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="9d2af4bf93a9ceba9a70379149efdadf03a56bc7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies LessThanComparable if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 LessThanComparable if를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="52a749029f41bfcab44646101c78f08a559bdcdd" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies MoveAssignable if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 MoveAssignable을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="aaf38d3e0ca9bb3163280eb3190656f5f78d0b7e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies MoveConstructible if.</source>
          <target state="translated">타입 &lt;code&gt;T&lt;/code&gt; 는 MoveConstructible if를 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="3c095863553c4d9f9528e17b876f6565ea71dc1e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;TC::time_point::clock&lt;/code&gt; meets the TrivialClock requirements, recursively.</source>
          <target state="translated">&lt;code&gt;TC::time_point::clock&lt;/code&gt; 유형 은 재귀 적으로 TrivialClock 요구 사항을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="8c5bdf5c0ebdfaea70c628010c98d8c02bdb6a1e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">타입 &lt;code&gt;Type1&lt;/code&gt; 타입의 객체 있도록해야합니다 &lt;code&gt;ForwardIt&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type1&lt;/code&gt; . 유형 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야 &lt;code&gt;T&lt;/code&gt; 는 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76589c2d20456a54480cd63abef696cc4671a0d0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">타입 &lt;code&gt;Type1&lt;/code&gt; 유형의 객체 있도록해야 &lt;code&gt;T&lt;/code&gt; 는 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type1&lt;/code&gt; . 유형 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야합니다 &lt;code&gt;ForwardIt&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e15c34b8b5699cfcccd67dddcde261f5330e1e3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">타입 &lt;code&gt;Type1&lt;/code&gt; 유형의 객체 있도록해야 &lt;code&gt;T&lt;/code&gt; 는 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type1&lt;/code&gt; . 유형 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야합니다 &lt;code&gt;InputIt&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type2&lt;/code&gt; . 유형 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체되도록 있어야 &lt;code&gt;T&lt;/code&gt; 이 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c7c828977f3aee5181d50399292252dea34b2f7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">타입 &lt;code&gt;Type1&lt;/code&gt; 형식의 개체가되도록해야합니다 &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type1&lt;/code&gt; . 유형 &lt;code&gt;Type2&lt;/code&gt; 형식의 개체 있도록해야합니다 &lt;code&gt;InputIt&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type2&lt;/code&gt; . 유형 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체가되도록 있어야 &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="446f611669a83b2fef5ed0fe51541c392716bba5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">유형의 &lt;code&gt;Type&lt;/code&gt; 유형의 객체 있도록해야합니다 &lt;code&gt;InputIt&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a83e5bd1fdfaaf9d85e03162ceb874df7fc25ab" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">유형의 &lt;code&gt;Type&lt;/code&gt; 유형의 객체 있도록해야합니다 &lt;code&gt;InputIt&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type&lt;/code&gt; . 유형 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체되도록 있어야 &lt;code&gt;OutputIt&lt;/code&gt; 는 역 참조와 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f2ee2c7e39e16c2fc94f6e2cd419b938a6ba925" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;double&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;double&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">유형의 &lt;code&gt;Type&lt;/code&gt; 유형의 객체가되도록해야합니다 &lt;code&gt;double&lt;/code&gt; 역 참조 할 수 다음 암시 적 변환 &lt;code&gt;Type&lt;/code&gt; . 유형 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체되도록 있어야 &lt;code&gt;double&lt;/code&gt; 역 참조와 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b435ca7efbcb7d3a69a4c425c8166ae1ecf9b3b8" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 타입 은 &lt;a href=&quot;container&quot;&gt;컨테이너를&lt;/a&gt; 만족합니다</target>
        </trans-unit>
        <trans-unit id="51c4cd0302a38d9ca2d378e53146319f03ed2267" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;, and</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 유형 은 &lt;a href=&quot;container&quot;&gt;Container를&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="6607d21d863fd1139823f255f3616f78582f1b99" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 유형 은 &lt;a href=&quot;iterator&quot;&gt;LegacyIterator를&lt;/a&gt; 충족합니다</target>
        </trans-unit>
        <trans-unit id="fd2220d4e7d2be0a6e2436dc20ed5fc81f925717" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies ContiguousContainer if.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 유형 은 ContiguousContainer를 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="9c59f17268ae0799c6c9ad4a2f510730b7974007" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies LegacyOutputIterator if.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 유형 은 다음 경우에 LegacyOutputIterator를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="4ce304e60343f172de9a358f8aec0594d119616e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies SequenceContainer if.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 유형 은 SequenceContainer를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="0b0a4238d5b55da548fec0c52f2f145ef62aca2f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; supports &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 유형 은 &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators를&lt;/a&gt; 지원합니다</target>
        </trans-unit>
        <trans-unit id="9c91c4098ab4ce6057b1eb103c2691ca5d989b78" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt; must be exactly</source>
          <target state="translated">유형의 &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt; 정확하게해야합니다</target>
        </trans-unit>
        <trans-unit id="3d90dab02f7f3b6e43e81a90b17cf46259c35fe4" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::negation&amp;lt;B&amp;gt;&lt;/code&gt; is a &lt;a href=&quot;../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with a BaseCharacteristic of &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::bool_constant&lt;/a&gt;&amp;lt;!bool(B::value)&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::negation&amp;lt;B&amp;gt;&lt;/code&gt; 유형 은 &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::bool_constant&lt;/a&gt;&amp;lt;!bool(B::value)&amp;gt;&lt;/code&gt; &amp;lt;! bool (B :: value)&amp;gt; 의 &lt;a href=&quot;../named_req/unarytypetrait&quot;&gt;BaseCharacteristic&lt;/a&gt; 을 가진 UnaryTypeTrait입니다 .</target>
        </trans-unit>
        <trans-unit id="83883f03d07c1a12ee9dfb5e67e0fc6f4a49f177" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::partial_ordering&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">&lt;code&gt;std::partial_ordering&lt;/code&gt; 유형 에는 네 가지 유효한 값이 있으며 해당 유형의 const 정적 데이터 멤버로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="baf068b5f9f0a2f3a687379dab87c44a84ac79f2" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::streamoff&lt;/code&gt; is a signed integral type of sufficient size to represent the maximum possible file size supported by the operating system. Typically, this is a typedef to &lt;code&gt;long long&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;std::streamoff&lt;/code&gt; 운영 체제에서 지원 가능한 최대 파일 크기를 표현하기에 충분한 크기의 서명 필수 유형입니다. 일반적으로 &lt;code&gt;long long&lt;/code&gt; 에 대한 typedef 입니다 .</target>
        </trans-unit>
        <trans-unit id="081a86b87857472711ceb628824320cbad10918c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::streamsize&lt;/code&gt; is a signed integral type used to represent the number of characters transferred in an I/O operation or the size of an I/O buffer. It is used as a signed counterpart of &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, similar to the POSIX type &lt;code&gt;ssize_t&lt;/code&gt;.</source>
          <target state="translated">타입 &lt;code&gt;std::streamsize&lt;/code&gt; 의 I / O 동작에 전송 문자 수 또는 I / O 버퍼의 크기를 나타내는 데 사용되는 서명 일체형이다. POSIX 유형 &lt;code&gt;ssize_t&lt;/code&gt; 와 유사하게 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 의 서명 된 대응 물로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="35bd4cec907f3b6ac35655e3dc99fe6dc74b2c63" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::strong_equality&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">&lt;code&gt;std::strong_equality&lt;/code&gt; 유형 에는 4 개의 유효한 값이 있으며 해당 유형의 const 정적 데이터 멤버로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="d1fa9bb7b57f78a76b739de735267fbd796b77b7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::strong_ordering&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">&lt;code&gt;std::strong_ordering&lt;/code&gt; 유형 에는 다음 유형의 const 정적 데이터 멤버로 구현 된 4 개의 유효한 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="caaff90770bed5d2d4f0c217a33a582a915365ac" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::weak_equality&lt;/code&gt; has only two valid values, implemented as const static data members of its type: &lt;code&gt;std::weak_equality::equivalent&lt;/code&gt; and &lt;code&gt;std::weak_equality::nonequivalent&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;std::weak_equality&lt;/code&gt; 유형 에는 두 개의 유효한 값만 있으며 해당 유형의 const 정적 데이터 멤버로 구현됩니다. &lt;code&gt;std::weak_equality::equivalent&lt;/code&gt; 및 &lt;code&gt;std::weak_equality::nonequivalent&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5b1a20430a83aa89500e66ebd1c9900c5d380b9b" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::weak_ordering&lt;/code&gt; has three valid values, implemented as const static data members of its type:</source>
          <target state="translated">&lt;code&gt;std::weak_ordering&lt;/code&gt; 유형 에는 세 가지 유효한 값이 있으며 해당 유형의 const 정적 데이터 멤버로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="eea5d0d3527e4ae7b88635106c278af003375133" translate="yes" xml:space="preserve">
          <source>The type T may be an incomplete type.</source>
          <target state="translated">유형 T는 불완전한 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47e3c39ad9f26d80f148e942aab053b6361ba66e" translate="yes" xml:space="preserve">
          <source>The type allows subnormal values</source>
          <target state="translated">이 유형은 비정규 값을 허용합니다</target>
        </trans-unit>
        <trans-unit id="89d3d7da193a1958b43f17239e6e96abc49dd3f5" translate="yes" xml:space="preserve">
          <source>The type and value category of the conditional expression &lt;code&gt;E1 ? E2 : E3&lt;/code&gt; are determined according to the following rules:</source>
          <target state="translated">조건식 &lt;code&gt;E1 ? E2 : E3&lt;/code&gt; 의 유형 및 값 범주 ? E2 : E3 는 다음 규칙에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="b0032656c660ab91cfc9f1912ec36a11287348d7" translate="yes" xml:space="preserve">
          <source>The type deduced by these deduction guides may change in a later standard revision (in particular, this might happen if &lt;code&gt;noexcept&lt;/code&gt; support is added to &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; in a later standard).</source>
          <target state="translated">이러한 추론 가이드에 의해 추론 된 유형은 이후 표준 개정에서 변경 될 수 있습니다 (특히, 이후 표준에서 &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 에 지원을 추가 하지 &lt;code&gt;noexcept&lt;/code&gt; 경우 발생할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="8dcc1ea760f892b4e6eddb08b2acf9f9c879aeb1" translate="yes" xml:space="preserve">
          <source>The type defined by &lt;code&gt;std::aligned_storage&amp;lt;&amp;gt;::type&lt;/code&gt; can be used to create uninitialized memory blocks suitable to hold the objects of given type, optionally aligned stricter than their natural alignment requirement, for example on a cache or page boundary.</source>
          <target state="translated">&lt;code&gt;std::aligned_storage&amp;lt;&amp;gt;::type&lt;/code&gt; 의해 정의 된 유형 은 주어진 유형의 오브젝트를 보유하기에 적합한 초기화되지 않은 메모리 블록을 작성하는 데 사용될 수 있으며, 선택적으로 캐시 또는 페이지 경계에서 자연 정렬 요구 사항보다 엄격하게 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="015fb8d559015f4868df42502a384ec989660bc6" translate="yes" xml:space="preserve">
          <source>The type does not have to implement &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operator&lt;/a&gt; in order to satisfy this type requirement: a &lt;a href=&quot;../language/as_operator&quot;&gt;copy assignment operator&lt;/a&gt; that takes its parameter by value or as a &lt;code&gt;const Type&amp;amp;&lt;/code&gt;, will bind to rvalue argument.</source>
          <target state="translated">유형은 이 유형 요구 사항을 충족시키기 위해 &lt;a href=&quot;../language/move_operator&quot;&gt;이동 할당 연산자&lt;/a&gt; 를 구현할 필요가 없습니다 . 매개 변수를 값으로 또는 &lt;code&gt;const Type&amp;amp;&lt;/code&gt; 로 취하는 &lt;a href=&quot;../language/as_operator&quot;&gt;복사 할당 연산자&lt;/a&gt; 는 rvalue 인수에 바인드됩니다.</target>
        </trans-unit>
        <trans-unit id="4ee6bc4a29e09101e3ca894cf68274fb41416543" translate="yes" xml:space="preserve">
          <source>The type does not have to implement a &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operator&lt;/a&gt; in order to satisfy this trait; see &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; for details.</source>
          <target state="translated">유형은 이 특성을 만족시키기 위해 &lt;a href=&quot;../language/move_operator&quot;&gt;이동 할당 연산자&lt;/a&gt; 를 구현할 필요는 없습니다 . 자세한 내용은 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="71c7ef3196579896dbcb86da29f6c58aaeef4821" translate="yes" xml:space="preserve">
          <source>The type does not support subnormal values</source>
          <target state="translated">유형이 비정규 값을 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="c0aefe5f52f0c91ab7dcca87fc13463e2b84f15b" translate="yes" xml:space="preserve">
          <source>The type mbstate_t is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. Zero-initialized value of &lt;code&gt;mbstate_t&lt;/code&gt; represents the initial conversion state, although other values of &lt;code&gt;mbstate_t&lt;/code&gt; may exist that also represent the initial conversion state.</source>
          <target state="translated">mbstate_t 유형은 구현 정의 된 지원되는 멀티 바이트 문자 인코딩 규칙 세트에서 발생할 수있는 변환 상태를 나타낼 수있는 간단한 비 배열 유형입니다. &lt;code&gt;mbstate_t&lt;/code&gt; 의 0으로 초기화 된 값은 초기 변환 상태를 나타내지 만, &lt;code&gt;mbstate_t&lt;/code&gt; 의 다른 값은 초기 변환 상태를 나타내기도합니다.</target>
        </trans-unit>
        <trans-unit id="ee6f31452577bc5b29d1b96501ba9c9ead4fd373" translate="yes" xml:space="preserve">
          <source>The type must meet &lt;a href=&quot;clock&quot;&gt;Clock&lt;/a&gt; requirements.</source>
          <target state="translated">유형은 &lt;a href=&quot;clock&quot;&gt;시계&lt;/a&gt; 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="417fa810ac7b429d2e715174963cd48512430822" translate="yes" xml:space="preserve">
          <source>The type must meet all of the following requirements:</source>
          <target state="translated">유형은 다음 요구 사항을 모두 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="5fe47f690f454a471c8cf3ffe3e0c793213ba10d" translate="yes" xml:space="preserve">
          <source>The type must satisfy the following additional expressions, given two values &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; that are of the type, and that &lt;code&gt;np&lt;/code&gt; is a value of &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; type (possibly &lt;code&gt;const&lt;/code&gt; qualified):</source>
          <target state="translated">유형은 두 개의 값 &lt;code&gt;p&lt;/code&gt; 와 &lt;code&gt;q&lt;/code&gt; 가 있고, &lt;code&gt;np&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 유형 의 값 ( &lt;code&gt;const&lt;/code&gt; 한정) 일 경우, 다음 추가 표현식을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="369901cace11f8d9f2b85e35e2783ef729d22cb1" translate="yes" xml:space="preserve">
          <source>The type must work with &amp;lt; operator and the result should have standard semantics.</source>
          <target state="translated">형식은 &amp;lt;연산자와 함께 작동해야하며 결과에는 표준 의미가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8ccea44fbb2fd126230d043404a673c987073e90" translate="yes" xml:space="preserve">
          <source>The type must work with == operator and the result should have standard semantics.</source>
          <target state="translated">형식은 == 연산자와 함께 작동해야하며 결과에는 표준 의미가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a401af7b772905929e6c578148662943f7e9b5a8" translate="yes" xml:space="preserve">
          <source>The type need not be &lt;a href=&quot;incomplete_type&quot;&gt;complete&lt;/a&gt; or have an available &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;, and can be &lt;a href=&quot;abstract_class&quot;&gt;abstract&lt;/a&gt;. This rule doesn't apply to sub-expressions: in &lt;code&gt;decltype(f(g()))&lt;/code&gt;, &lt;code&gt;g()&lt;/code&gt; must have a complete type, but &lt;code&gt;f()&lt;/code&gt; need not.</source>
          <target state="translated">타입이 &lt;a href=&quot;incomplete_type&quot;&gt;완전&lt;/a&gt; 하거나 사용 가능한 &lt;a href=&quot;destructor&quot;&gt;소멸자를&lt;/a&gt; 가질 필요 는 없으며 &lt;a href=&quot;abstract_class&quot;&gt;추상적&lt;/a&gt; 일 수 있습니다 . 이 규칙은 하위 표현식에는 적용되지 않습니다. &lt;code&gt;decltype(f(g()))&lt;/code&gt; 에서 &lt;code&gt;g()&lt;/code&gt; 는 완전한 유형을 가져야하지만 &lt;code&gt;f()&lt;/code&gt; 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c83f8d22479920f797dda997ec4470602b5cb196" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;E&lt;/code&gt; after substitution must be exactly &lt;code&gt;bool&lt;/code&gt;. No conversion is permitted:</source>
          <target state="translated">치환 후 &lt;code&gt;E&lt;/code&gt; 유형은 정확히 &lt;code&gt;bool&lt;/code&gt; 이어야합니다 . 전환이 허용되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="092bcee309aef84863a0a22c05df0ff5cc2306f8" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;N&lt;/code&gt; in the type &lt;code&gt;T[N]&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T[N]&lt;/code&gt; 유형의 &lt;code&gt;N&lt;/code&gt; 유형 은 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e00aa691520243fc7bb95963a65a42850ff0ee2d" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;replacement&lt;/code&gt; is &lt;code&gt;std::filesystem::path&lt;/code&gt; even though it is not intended to represent an object on the file system in order to correctly account for the filesystem character encoding.</source>
          <target state="translated">의 유형 &lt;code&gt;replacement&lt;/code&gt; 입니다 &lt;code&gt;std::filesystem::path&lt;/code&gt; 올바르게 파일 시스템의 문자 인코딩을 설명하기 위해 파일 시스템에서 개체를 나타 내기위한되지 않더라도.</target>
        </trans-unit>
        <trans-unit id="73ef25a9616ca1a936ee4e3bf75aad3a667fbb50" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;this&lt;/code&gt; in a member function of class &lt;code&gt;X&lt;/code&gt; is &lt;code&gt;X*&lt;/code&gt; (pointer to X). If the member function is &lt;a href=&quot;member_functions&quot;&gt;cv-qualified&lt;/a&gt;, the type of &lt;code&gt;this&lt;/code&gt; is &lt;code&gt;cv X*&lt;/code&gt; (pointer to identically cv-qualified X). Since constructors and destructors cannot be cv-qualified, the type of &lt;code&gt;this&lt;/code&gt; in them is always &lt;code&gt;X*&lt;/code&gt;, even when constructing or destroying a const object.</source>
          <target state="translated">클래스 &lt;code&gt;X&lt;/code&gt; 의 멤버 함수 &lt;code&gt;this&lt;/code&gt; 유형 은 &lt;code&gt;X*&lt;/code&gt; (X에 대한 포인터)입니다. 멤버 함수가 &lt;a href=&quot;member_functions&quot;&gt;cv-qualified&lt;/a&gt; 인 &lt;code&gt;this&lt;/code&gt; 유형 은 &lt;code&gt;cv X*&lt;/code&gt; (동일하게 cv-qualified X를 가리키는 포인터)입니다. 생성자와 소멸자는 이력서 자격이 될 수 없기 때문에, 유형 &lt;code&gt;this&lt;/code&gt; 그들은 항상 &lt;code&gt;X*&lt;/code&gt; 건설 또는 CONST 오브젝트를 파괴해도.</target>
        </trans-unit>
        <trans-unit id="4a3330b556852ca71717541f2c81d240e408418f" translate="yes" xml:space="preserve">
          <source>The type of a &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; appearing in an alias template declaration is different between instantiations of that template, even when the lambda expression is not dependent.</source>
          <target state="translated">별칭 템플릿 선언에 나타나는 &lt;a href=&quot;lambda&quot;&gt;람다 식&lt;/a&gt; 의 유형은 람다식이 종속되지 않은 경우에도 해당 템플릿의 인스턴스화마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1c03df0e9a6c3883eefceaf776f001998a556f7d" translate="yes" xml:space="preserve">
          <source>The type of a bit field can only be integral or enumeration type.</source>
          <target state="translated">비트 필드의 유형은 정수 또는 열거 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e828f47acdf8dd1be944f104aebcd681e249b7b" translate="yes" xml:space="preserve">
          <source>The type of a non-type template parameter may be deduced if it includes a placeholder type (&lt;code&gt;auto&lt;/code&gt;, a placeholder for a deduced class type(since C++20), or &lt;code&gt;decltype(auto)&lt;/code&gt;). The deduction is performed as if by deducing the type of the variable &lt;code&gt;x&lt;/code&gt; in the invented declaration &lt;code&gt;T x = template-argument;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the declared type of the template parameter. If the deduced type is not permitted for a non-type template parameter, the program is ill-formed.</source>
          <target state="translated">비 유형 템플릿 매개 변수의 유형은 자리 표시 자 유형 ( &lt;code&gt;auto&lt;/code&gt; , 추론 된 클래스 유형의 자리 표시 자 (C ++ 20 이후) 또는 &lt;code&gt;decltype(auto)&lt;/code&gt; )을 포함하는 경우 추론 될 수 있습니다 . 추론 은 발명 된 선언에서 변수 &lt;code&gt;x&lt;/code&gt; 의 유형을 추론하는 것처럼 수행된다. &lt;code&gt;T x = template-argument;&lt;/code&gt; 여기서 &lt;code&gt;T&lt;/code&gt; 는 템플릿 매개 변수의 선언 된 유형입니다. 비 유형 템플릿 매개 변수에 추론 된 유형이 허용되지 않으면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9f077ca46cbdc83666da091d5f4c5c63b8be8535" translate="yes" xml:space="preserve">
          <source>The type of a pointer to array of unknown bound, or of a type defined by a &lt;code&gt;typedef&lt;/code&gt; declaration to be an array of unknown bound, cannot be completed.</source>
          <target state="translated">알 수없는 바운드의 배열에 대한 포인터 유형 또는 알 수없는 바운드의 배열로 &lt;code&gt;typedef&lt;/code&gt; 선언으로 정의 된 유형의 유형을 완료 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e1654f0998b812161591ecd53f879aa981b5cfa6" translate="yes" xml:space="preserve">
          <source>The type of an expression that results from the compile-time analysis of the program is known as the</source>
          <target state="translated">프로그램의 컴파일 타임 분석 결과 식의 유형은</target>
        </trans-unit>
        <trans-unit id="dc3ab407bca97dd7b2182e8d6089591cbf78c0f6" translate="yes" xml:space="preserve">
          <source>The type of each data member is the type of the corresponding captured entity, except if the entity has reference type (in that case, references to functions are captured as lvalue references to the referenced functions, and references to objects are captured as copies of the referenced objects).</source>
          <target state="translated">각 데이터 멤버의 유형은 엔티티에 참조 유형이있는 경우를 제외하고 해당 캡처 된 엔티티의 유형입니다 (이 경우 함수에 대한 참조는 참조 된 함수에 대한 lvalue 참조로 캡처되고 오브젝트에 대한 참조는 참조 된 개체).</target>
        </trans-unit>
        <trans-unit id="85801fe2a975f6f74abeb5935ecc5a8cbc8a24c1" translate="yes" xml:space="preserve">
          <source>The type of each function parameter in the parameter list is determined according to the following rules:</source>
          <target state="translated">매개 변수 목록의 각 기능 매개 변수 유형은 다음 규칙에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="14480ff70d6d9671051d3a3bebfef0ffda9aa55c" translate="yes" xml:space="preserve">
          <source>The type of function callbacks that can be registered using &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; to be called on specific events.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; 을 사용하여 등록 하여 특정 이벤트에서 호출 할 수있는 함수 콜백 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="16e7bff806ed1fa4ab8073e5ade6ccec0c8f929f" translate="yes" xml:space="preserve">
          <source>The type of the</source>
          <target state="translated">의 유형</target>
        </trans-unit>
        <trans-unit id="b1b79e1851bb8cd4e0abe53b7badea94acb8b63a" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array must be a &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">배열 요소의 유형은 &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt; 이어야합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a440bce9393578dcc59e67d819369eb6fff9dc5" translate="yes" xml:space="preserve">
          <source>The type of the elements.</source>
          <target state="translated">요소의 유형</target>
        </trans-unit>
        <trans-unit id="39cb107adf449bbc790a8800f9b0f24f9bbe1ba6" translate="yes" xml:space="preserve">
          <source>The type of the function being declared is composed from the</source>
          <target state="translated">선언되는 함수의 유형은</target>
        </trans-unit>
        <trans-unit id="9bbb6b4e7d477a9cc16a3aa9d6f2075047c3171b" translate="yes" xml:space="preserve">
          <source>The type of the integer literal is the first type in which the value can fit, from the list of types which depends on which numeric base and which integer-suffix was used.</source>
          <target state="translated">정수 리터럴의 유형은 사용 된 숫자 기수와 정수 접미사에 따라 유형 목록에서 값이 들어갈 수있는 첫 번째 유형입니다.</target>
        </trans-unit>
        <trans-unit id="68e06d906da63b0e924e6b7c9ec59a39e6b3cb3e" translate="yes" xml:space="preserve">
          <source>The type of the literal</source>
          <target state="translated">리터럴의 유형</target>
        </trans-unit>
        <trans-unit id="66d91e0faa820f737700bea3d6d88e6c67abbd4b" translate="yes" xml:space="preserve">
          <source>The type of the stored elements. The behavior is undefined if &lt;code&gt;T&lt;/code&gt; is not the same type as &lt;code&gt;Container::value_type&lt;/code&gt;.(since C++17)</source>
          <target state="translated">저장된 요소의 유형입니다. &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Container::value_type&lt;/code&gt; 과 동일한 유형이 아닌 경우 동작이 정의되지 않습니다 (C ++ 17부터).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
