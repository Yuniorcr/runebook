<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="e9473bce26df240bf7fc3c05c82131b0eac3181d" translate="yes" xml:space="preserve">
          <source>Transforms the range &lt;code&gt;[first, last)&lt;/code&gt; into the next permutation from the set of all permutations that are lexicographically ordered with respect to &lt;code&gt;operator&amp;lt;&lt;/code&gt; or &lt;code&gt;comp&lt;/code&gt;. Returns &lt;code&gt;true&lt;/code&gt; if such permutation exists, otherwise transforms the range into the first permutation (as if by &lt;code&gt;std::sort(first, last)&lt;/code&gt;) and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator&amp;lt;&lt;/code&gt; 또는 &lt;code&gt;comp&lt;/code&gt; 와 관련하여 사전 순으로 정렬 된 모든 순열 집합에서 &lt;code&gt;[first, last)&lt;/code&gt; 범위를 다음 순열로 변환합니다 . 이러한 순열이 존재하면 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 , 그렇지 않으면 범위를 첫 번째 순열로 변환하고 ( &lt;code&gt;std::sort(first, last)&lt;/code&gt; )와 같이) &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fb941d77364b3c591f0e4eb102ebc186c04f6079" translate="yes" xml:space="preserve">
          <source>Transforms the range &lt;code&gt;[first, last)&lt;/code&gt; into the previous permutation from the set of all permutations that are lexicographically ordered with respect to &lt;code&gt;operator&amp;lt;&lt;/code&gt; or &lt;code&gt;comp&lt;/code&gt;. Returns &lt;code&gt;true&lt;/code&gt; if such permutation exists, otherwise transforms the range into the last permutation (as if by &lt;code&gt;std::sort(first, last); std::reverse(first, last);&lt;/code&gt;) and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator&amp;lt;&lt;/code&gt; 또는 &lt;code&gt;comp&lt;/code&gt; 와 관련하여 사전 순으로 정렬 된 모든 순열 집합에서 &lt;code&gt;[first, last)&lt;/code&gt; 범위를 이전 순열로 변환합니다 . 이러한 순열이 존재하면 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 , 그렇지 않으면 범위를 마지막 순열로 변환합니다 ( &lt;code&gt;std::sort(first, last); std::reverse(first, last);&lt;/code&gt; ) ). &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5c2ca105c8eba32a022ebfb50e700557700476d5" translate="yes" xml:space="preserve">
          <source>Translation units, instantiation units, and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment.</source>
          <target state="translated">외부 참조를 충족시키는 데 필요한 변환 단위, 인스턴스화 단위 및 라이브러리 구성 요소는 실행 환경에서 실행하는 데 필요한 정보가 포함 된 프로그램 이미지로 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="7d38d008dd097b51dab00ca0d0265de5ece13e59" translate="yes" xml:space="preserve">
          <source>Transparent operator functors (&lt;code&gt;std::less&amp;lt;&amp;gt;&lt;/code&gt; et al)</source>
          <target state="translated">투명한 연산자 펑터 ( &lt;code&gt;std::less&amp;lt;&amp;gt;&lt;/code&gt; et al)</target>
        </trans-unit>
        <trans-unit id="f559c0b6272ddc2453ea357e3fd076a9c199929c" translate="yes" xml:space="preserve">
          <source>Tries to lock each of the given &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; objects &lt;code&gt;lock1&lt;/code&gt;, &lt;code&gt;lock2&lt;/code&gt;, &lt;code&gt;...&lt;/code&gt;, &lt;code&gt;lockn&lt;/code&gt; by calling &lt;code&gt;try_lock&lt;/code&gt; in order beginning with the first.</source>
          <target state="translated">주어진 각 &lt;a href=&quot;../named_req/lockable&quot;&gt;잠금 가능&lt;/a&gt; 오브젝트 &lt;code&gt;lock1&lt;/code&gt; , &lt;code&gt;lock2&lt;/code&gt; , &lt;code&gt;...&lt;/code&gt; 을 &lt;code&gt;lockn&lt;/code&gt; 합니다 . 첫 번째로 시작하여 try_lock 을 호출하여 &lt;code&gt;try_lock&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4193e3be0c6f62e0de2fa977aca25d7c84cd476" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex in shared mode without blocking. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt;.</source>
          <target state="translated">차단하지 않고 공유 모드에서 연관된 뮤텍스를 잠그려고 시도합니다. 효과적으로 &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="445a39a47a50a54d92796a9b19a41f46bc55486e" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex in shared mode. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt;.</source>
          <target state="translated">공유 모드에서 연관된 뮤텍스를 잠그려고 시도합니다. 지정된 &lt;code&gt;timeout_duration&lt;/code&gt; 이 경과하거나 잠금이 획득 될 때까지 차단합니다 . 잠금 획득에 성공하면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 . 효과적으로 &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5d62e4c34ffec7ca2a5475cc557db13010bc5bb6" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex in shared mode. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. May block for longer than until &lt;code&gt;timeout_time&lt;/code&gt; has been reached.</source>
          <target state="translated">공유 모드에서 연관된 뮤텍스를 잠그려고 시도합니다. 지정된 &lt;code&gt;timeout_time&lt;/code&gt; 에 도달하거나 잠금이 획득 될 때까지 차단합니다 . 잠금 획득에 성공하면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 . &lt;code&gt;timeout_time&lt;/code&gt; 에 도달 할 때까지 더 오래 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04ec6c6d28a28396ea8160dff620c7f0dfdc1cb4" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex without blocking. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt;.</source>
          <target state="translated">차단하지 않고 연관된 뮤텍스를 잠그려고 시도합니다. 효과적으로 &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="6391979884d59018323155d5442d884835e91f04" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt;.</source>
          <target state="translated">관련 뮤텍스를 잠그려고합니다. 지정된 &lt;code&gt;timeout_duration&lt;/code&gt; 이 경과하거나 잠금이 획득 될 때까지 차단합니다 . 잠금 획득에 성공하면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 . 효과적으로 &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9a394eb5a6a96eb4cd0cc26ea32b6b9f1cd9d182" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. May block for longer than until &lt;code&gt;timeout_time&lt;/code&gt; has been reached.</source>
          <target state="translated">관련 뮤텍스를 잠그려고합니다. 지정된 &lt;code&gt;timeout_time&lt;/code&gt; 에 도달하거나 잠금이 획득 될 때까지 차단합니다 . 잠금 획득에 성공하면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 . &lt;code&gt;timeout_time&lt;/code&gt; 에 도달 할 때까지 더 오래 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72f71ef27869580f57937ef46f54e56b64d5c90b" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex in shared mode. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the shared lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">공유 모드에서 뮤텍스를 잠그려고 시도합니다. 지정된 &lt;code&gt;timeout_duration&lt;/code&gt; 이 경과하거나 공유 잠금이 획득 될 때까지 차단합니다 . 잠금 획득에 성공하면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="df7a6fe3b4499e718fdf154332580ad7e0556935" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex in shared mode. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">공유 모드에서 뮤텍스를 잠그려고 시도합니다. 지정된 &lt;code&gt;timeout_time&lt;/code&gt; 에 도달하거나 잠금이 획득 될 때까지 차단합니다 . 잠금 획득에 성공하면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b6575b72289c55a38b072b5941884cdd93486461" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex in shared mode. Returns immediately. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">공유 모드에서 뮤텍스를 잠그려고 시도합니다. 즉시 반환합니다. 잠금 획득에 성공하면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="aaf4054705ad98c056fff4ec6d5fb719dbed8bab" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">뮤텍스를 잠그려고 시도합니다. 지정된 &lt;code&gt;timeout_duration&lt;/code&gt; 이 경과하거나 잠금이 획득 될 때까지 차단합니다 . 잠금 획득에 성공하면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2674b35e9268fb4c504fe5e2d2bb178899b976f5" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">뮤텍스를 잠그려고 시도합니다. 지정된 &lt;code&gt;timeout_time&lt;/code&gt; 에 도달하거나 잠금이 획득 될 때까지 차단합니다 . 잠금 획득에 성공하면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e62eb4cb137d58a9975627d408c2d834c1eb07b2" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex. Returns immediately. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">뮤텍스를 잠그려고 시도합니다. 즉시 반환합니다. 잠금 획득에 성공하면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">삼각 함수</target>
        </trans-unit>
        <trans-unit id="e719a16c184c9946c83f511d812044089e2e21c9" translate="yes" xml:space="preserve">
          <source>Trigraph</source>
          <target state="translated">Trigraph</target>
        </trans-unit>
        <trans-unit id="624b7d0a9acb19117360ca1ff7b46aba679ee393" translate="yes" xml:space="preserve">
          <source>Trigraphs (removed in C++17)</source>
          <target state="translated">3 부작 (C ++ 17에서 제거됨)</target>
        </trans-unit>
        <trans-unit id="69f8428973485177159d95cfc6a7d68111da93c3" translate="yes" xml:space="preserve">
          <source>Trivial copy assignment operator</source>
          <target state="translated">사소한 사본 할당 연산자</target>
        </trans-unit>
        <trans-unit id="16966819b78d2f2d7ddd3b34badb4de1f0eb65b0" translate="yes" xml:space="preserve">
          <source>Trivial copy constructor</source>
          <target state="translated">간단한 복사 생성자</target>
        </trans-unit>
        <trans-unit id="488ca1baf6cc68b8aa948384e1e53809bfb207a8" translate="yes" xml:space="preserve">
          <source>Trivial default constructor</source>
          <target state="translated">간단한 기본 생성자</target>
        </trans-unit>
        <trans-unit id="1418411e56b71fbadd57e0c387a8ef7df89b350e" translate="yes" xml:space="preserve">
          <source>Trivial destructor</source>
          <target state="translated">사소한 소멸자</target>
        </trans-unit>
        <trans-unit id="763ea1f3e981b84a927acd942aec71e9eacc4358" translate="yes" xml:space="preserve">
          <source>Trivial move assignment operator</source>
          <target state="translated">사소한 이동 할당 연산자</target>
        </trans-unit>
        <trans-unit id="3f57a92cdd79d69c213d32b4b4bd7fbcb0c55720" translate="yes" xml:space="preserve">
          <source>Trivial move constructor</source>
          <target state="translated">사소한 이동 생성자</target>
        </trans-unit>
        <trans-unit id="80e20b4c9b75f288215983370eace6b3830f2454" translate="yes" xml:space="preserve">
          <source>TrivialClock</source>
          <target state="translated">TrivialClock</target>
        </trans-unit>
        <trans-unit id="ca5b69f8f16141b8ecbd3e5d55417b7f08e4df66" translate="yes" xml:space="preserve">
          <source>TrivialType</source>
          <target state="translated">TrivialType</target>
        </trans-unit>
        <trans-unit id="739bada034f0d62036e7eca3d1c171b7fb2990b4" translate="yes" xml:space="preserve">
          <source>TriviallyCopyable</source>
          <target state="translated">TriviallyCopyable</target>
        </trans-unit>
        <trans-unit id="2c34bab22f35dd84ab5cbfaaab89a66cdb64744f" translate="yes" xml:space="preserve">
          <source>Try blocks</source>
          <target state="translated">블록을 시도</target>
        </trans-unit>
        <trans-unit id="ac5f250a73945a1c4524cddeb6862a489849434a" translate="yes" xml:space="preserve">
          <source>Try blocks provide the ability to catch exceptions thrown when executing other statements.</source>
          <target state="translated">try 블록은 다른 명령문을 실행할 때 발생하는 예외를 포착 할 수있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="44a77a68bb962e7ff3fb9dc11c9de3319527edbe" translate="yes" xml:space="preserve">
          <source>Tt&lt;code&gt;=&lt;/code&gt;&lt;code&gt;{} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tt &lt;code&gt;=&lt;/code&gt; &lt;code&gt;{} &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc53d2c6ca548777a6fc9b944e807c006a2c9d96" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;match_results&lt;/code&gt; are equal if the following conditions are met:</source>
          <target state="translated">다음 조건이 충족되면 두 개의 &lt;code&gt;match_results&lt;/code&gt; 가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d1e05e300f7cf45c9afa0f4cbce3042b969f9a51" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;memory_resource&lt;/code&gt;s compare equal if and only if memory allocated from one &lt;code&gt;memory_resource&lt;/code&gt; can be deallocated from the other and vice versa.</source>
          <target state="translated">하나의 &lt;code&gt;memory_resource&lt;/code&gt; 에서 할당 된 메모리가 다른 memory_resource 에서 할당 해제 될 수 있고 그 반대의 경우에만 두 &lt;code&gt;memory_resource&lt;/code&gt; 가 동일하게 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="18e2cfdfc01b97bd020c553267d7b3079b8d27e3" translate="yes" xml:space="preserve">
          <source>Two accesses to the same object of type &lt;code&gt;volatile &lt;a href=&quot;sig_atomic_t&quot;&gt;std::sig_atomic_t&lt;/a&gt;&lt;/code&gt; do not result in a data race if both occur in the same thread, even if one or more occurs in a signal handler. For each signal handler invocation, evaluations performed by the thread invoking a signal handler can be divided into two groups A and B, such that no evaluations in B</source>
          <target state="translated">&lt;code&gt;volatile &lt;a href=&quot;sig_atomic_t&quot;&gt;std::sig_atomic_t&lt;/a&gt;&lt;/code&gt; 유형의 동일한 오브젝트에 두 번 액세스 하면 둘 다 동일한 스레드에서 발생하더라도 신호 핸들러에서 하나 이상이 발생하더라도 데이터 경쟁이 발생하지 않습니다. 각 신호 처리기 호출에 대해 신호 처리기를 호출하는 스레드에 의해 수행 된 평가는 두 그룹 A와 B로 나눌 수 있으므로 B에서 평가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af211090fdec69c271770be6c158a8a93a7a9156" translate="yes" xml:space="preserve">
          <source>Two atomic constraints are considered</source>
          <target state="translated">두 가지 원자 제약 조건이 고려됩니다</target>
        </trans-unit>
        <trans-unit id="281cdcd9fceacdd0a42e26b288d042b3cef41c39" translate="yes" xml:space="preserve">
          <source>Two consecutive left square bracket tokens (&lt;code&gt;[[&lt;/code&gt;) may only appear when introducing an attribute-specifier or inside an attribute argument.</source>
          <target state="translated">두 개의 연속 된 왼쪽 대괄호 토큰 ( &lt;code&gt;[[&lt;/code&gt; )은 속성 지정자를 소개하거나 속성 인수 안에 만 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60290606d4c62d76f3da7e32e693534176b08979" translate="yes" xml:space="preserve">
          <source>Two convenience typedefs are provided by the standard library.</source>
          <target state="translated">표준 라이브러리에는 두 개의 편리한 typedef가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7aa31cc07dd369014ec64e33766626d690657b52" translate="yes" xml:space="preserve">
          <source>Two empty ranges are lexicographically</source>
          <target state="translated">두 개의 빈 범위는 사전 식으로</target>
        </trans-unit>
        <trans-unit id="6b78b90a2edac1ec50aec2ddead8be1711dcb40b" translate="yes" xml:space="preserve">
          <source>Two expressions involving template parameters are called</source>
          <target state="translated">템플릿 매개 변수를 포함하는 두 가지 표현식을 호출</target>
        </trans-unit>
        <trans-unit id="401bc70a8b4f3d2ca441828fbf93f9236de2257b" translate="yes" xml:space="preserve">
          <source>Two function templates are considered</source>
          <target state="translated">두 가지 기능 템플릿이 고려됩니다</target>
        </trans-unit>
        <trans-unit id="9a61fe0c1252c74ede2b7eafa0a43c49b8412afe" translate="yes" xml:space="preserve">
          <source>Two functions with the same name and the same parameter list in the same namespace cannot have two different language linkages (note, however, that linkage of a parameter may permit such overloading, as in the case of &lt;code&gt;&lt;a href=&quot;../algorithm/qsort&quot;&gt;std::qsort&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../algorithm/bsearch&quot;&gt;std::bsearch&lt;/a&gt;&lt;/code&gt;). Likewise, two variables in the same namespace cannot have two different language linkages.</source>
          <target state="translated">동일한 네임 스페이스에서 동일한 이름과 동일한 매개 변수 목록을 가진 두 함수는 서로 다른 언어 링크를 가질 수 없습니다 (그러나 매개 변수의 링크는 &lt;code&gt;&lt;a href=&quot;../algorithm/qsort&quot;&gt;std::qsort&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../algorithm/bsearch&quot;&gt;std::bsearch&lt;/a&gt;&lt;/code&gt; 의 경우와 같이 오버로드를 허용 할 수 있습니다) ). 마찬가지로, 동일한 네임 스페이스에있는 두 변수는 서로 다른 언어 링크를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4eb187c84dda2874b690bed58603b32136278ed1" translate="yes" xml:space="preserve">
          <source>Two global basic_istream objects are provided by the standard library.</source>
          <target state="translated">표준 라이브러리는 2 개의 전역 basic_istream 객체를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c90f6f3b7bfcc952e158fda77bf6551f5a0e53dd" translate="yes" xml:space="preserve">
          <source>Two instances of &lt;code&gt;std::exception_ptr&lt;/code&gt; compare equal only if they are both null or both point at the same exception object.</source>
          <target state="translated">&lt;code&gt;std::exception_ptr&lt;/code&gt; 의 두 인스턴스 는 모두 동일한 예외 오브젝트에서 널이거나 둘 다인 경우에만 동일하게 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="88171adec9acfe4a9d538ee2177a7d8b88253347" translate="yes" xml:space="preserve">
          <source>Two lists of contract conditions are the same if they contain the same contract conditions in the same order. Two contract conditions are the same if they are the same kind of contract condition and have the same contract-level and the same predicate. Two predicates are the same if they would satisfy the &lt;a href=&quot;../definition#One_Definition_Rule&quot;&gt;one-definition rule&lt;/a&gt; were they to appear in function definitions, except for the renaming of function and template parameters and return value identifiers (if any).</source>
          <target state="translated">동일한 계약 조건을 동일한 순서로 포함하는 경우 두 계약 조건 목록이 동일합니다. 계약 조건이 동일하고 계약 레벨 및 술어가 동일한 경우 두 계약 조건은 동일합니다. 함수 및 템플리트 매개 변수 이름 바꾸기 및 리턴 값 ID (있는 경우)를 제외하고 함수 정의에 표시되는 &lt;a href=&quot;../definition#One_Definition_Rule&quot;&gt;1- 정의 규칙&lt;/a&gt; 을 만족하는 경우 두 술어는 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0977497139bae8229d1cacd7b1fe5a5dee1adc52" translate="yes" xml:space="preserve">
          <source>Two objects</source>
          <target state="translated">두 개체</target>
        </trans-unit>
        <trans-unit id="86ee35dfa9a139a871795ed018153e9a56ec14e3" translate="yes" xml:space="preserve">
          <source>Two objects of this type can be dereferenced and the resulting values can be swapped using unqualified function call &lt;code&gt;swap()&lt;/code&gt; in the context where both &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; and the user-defined &lt;code&gt;swap()&lt;/code&gt;s are visible.</source>
          <target state="translated">이 유형의 두 객체는 ​​역 참조 될 수 있으며 &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 과 사용자 정의 &lt;code&gt;swap()&lt;/code&gt; 이 모두 표시 되는 컨텍스트에서 규정되지 않은 함수 호출 &lt;code&gt;swap()&lt;/code&gt; 을 사용하여 결과 값을 교환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1ee0382cebdb37edb5b66d39ad57ccf190aa34e" translate="yes" xml:space="preserve">
          <source>Two paths are considered to resolve to the same file system entity if the two candidate entities the paths resolve to are located on the same device at the same location. For POSIX, this means that the &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_ino&lt;/code&gt; members of their POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;stat structure&lt;/a&gt;, obtained as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt;, are equal.</source>
          <target state="translated">경로가 해결되는 두 후보 엔터티가 동일한 위치의 동일한 장치에있는 경우 두 파일 경로는 동일한 파일 시스템 엔터티로 해석되는 것으로 간주됩니다. POSIX의 경우 이는 POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; 에서 와 같이 얻은 POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;stat 구조&lt;/a&gt; 의 &lt;code&gt;st_dev&lt;/code&gt; 및 &lt;code&gt;st_ino&lt;/code&gt; 멤버 가 동일 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5faa0b6f23ce01fd992c53114575196b62f5d7fe" translate="yes" xml:space="preserve">
          <source>Two paths are considered to resolve to the same file system entity if the two candidate entities the paths resolve to are located on the same device at the same location. For POSIX, this means that the &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_ino&lt;/code&gt; members of their POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;stat structure&lt;/a&gt;, obtained as if by POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt;, are equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437b76b7571ce600be5aa3f3e921a20de1e39123" translate="yes" xml:space="preserve">
          <source>Two ranges are compared element by element.</source>
          <target state="translated">두 가지 범위가 요소별로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="8ec06cfed5aca5636f6337ef590ec50fe665f57a" translate="yes" xml:space="preserve">
          <source>Two ranges are considered equal if they have the same number of elements and, for every iterator &lt;code&gt;i&lt;/code&gt; in the range &lt;code&gt;[first1,last1)&lt;/code&gt;, &lt;code&gt;*i&lt;/code&gt; equals &lt;code&gt;*(first2 + (i - first1))&lt;/code&gt;. The overloads (1,2,5,6) use &lt;code&gt;operator==&lt;/code&gt; to determine if two elements are equal, whereas overloads (3,4,7,8) use the given binary predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">모든 두 반복기 범위는, 동수의 요소가있는 경우와 동일한 것으로 간주되고, &lt;code&gt;i&lt;/code&gt; 범위 &lt;code&gt;[first1,last1)&lt;/code&gt; , &lt;code&gt;*i&lt;/code&gt; 같음 &lt;code&gt;*(first2 + (i - first1))&lt;/code&gt; . 오버로드 (1,2,5,6)는 &lt;code&gt;operator==&lt;/code&gt; 를 사용 하여 두 요소가 같은지 확인하고, 오버로드 (3,4,7,8)는 주어진 이진 술어 &lt;code&gt;p&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="1f3d6e085b1a690a184f8a241caaace1cd422427" translate="yes" xml:space="preserve">
          <source>Two specializations are provided by the standard library.</source>
          <target state="translated">표준 라이브러리에서 두 가지 전문화가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9ea29714490f77c2342f60db455484af8982a069" translate="yes" xml:space="preserve">
          <source>Two specializations for common character types are also defined:</source>
          <target state="translated">공통 문자 유형에 대한 두 가지 전문화도 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="395a556fd3ef9112d9577c9ebc5df6fd4309e718" translate="yes" xml:space="preserve">
          <source>Two specializations for common character types are also provided:</source>
          <target state="translated">일반적인 문자 유형에 대한 두 가지 전문화도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="abc68b66bf994ad49ab50a82c81510a0ae793170" translate="yes" xml:space="preserve">
          <source>Two specializations for common character types are defined:</source>
          <target state="translated">일반적인 문자 유형에 대한 두 가지 전문화가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="644226c6c6857e7526a3f749326009205374c9cd" translate="yes" xml:space="preserve">
          <source>Two specializations of &lt;code&gt;&lt;a href=&quot;types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&lt;/code&gt; for the type &lt;code&gt;bool&lt;/code&gt; are provided:</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 유형에 대한 &lt;code&gt;&lt;a href=&quot;types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&lt;/code&gt; 의 두 가지 전문화 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="38cc0b6c98f9bf0b6f230727bb0b37ccdc3ce423" translate="yes" xml:space="preserve">
          <source>Two specializations of &lt;code&gt;std::regex_traits&lt;/code&gt; are defined by the standard library:</source>
          <target state="translated">&lt;code&gt;std::regex_traits&lt;/code&gt; 의 두 가지 전문화 는 표준 라이브러리에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1c45317442511240ca7c73c4b544304cf52c5c50" translate="yes" xml:space="preserve">
          <source>Two standalone (locale-independent) full specializations and two partial specializations are provided by the standard library:</source>
          <target state="translated">표준 라이브러리는 2 개의 독립형 (로케일 독립적) 전체 전문화와 2 개의 부분 전문화가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f02ffd61fc180d1f64496b8d587f3d5cce7df2b7" translate="yes" xml:space="preserve">
          <source>Two standalone (locale-independent) specializations are provided by the standard library:</source>
          <target state="translated">표준 라이브러리는 두 개의 독립형 (로케일 독립적) 전문화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2cf5b83a88ef7188b905ff555b89323fdaa04f77" translate="yes" xml:space="preserve">
          <source>Two standard-layout non-union class types are called</source>
          <target state="translated">두 개의 표준 레이아웃 비 유니언 클래스 유형이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1b0ea8abccf06468ba7e2e711860c3d383b65c96" translate="yes" xml:space="preserve">
          <source>Two standard-layout non-union class types may have a</source>
          <target state="translated">두 개의 표준 레이아웃 비 유니언 클래스 유형에는</target>
        </trans-unit>
        <trans-unit id="2034537c92fce35c44c1810a5621d0a63f6246c5" translate="yes" xml:space="preserve">
          <source>Two standard-layout unions are called</source>
          <target state="translated">두 개의 표준 레이아웃 조합이 호출됩니다</target>
        </trans-unit>
        <trans-unit id="cb0d34718d67d002a55c599c7fb017311e7a205d" translate="yes" xml:space="preserve">
          <source>Two strings are equal if both the size of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal and each character in &lt;code&gt;lhs&lt;/code&gt; has equivalent character in &lt;code&gt;rhs&lt;/code&gt; at the same position.</source>
          <target state="translated">크기의 경우 두 개의 스트링이 동일한 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 동일하고 각 문자 &lt;code&gt;lhs&lt;/code&gt; 동등한 문자 갖는다 &lt;code&gt;rhs&lt;/code&gt; 동일한 위치에있다.</target>
        </trans-unit>
        <trans-unit id="d818143c3e7668e852c1ed4b1bfcf0387a3c91b0" translate="yes" xml:space="preserve">
          <source>Two typedefs for the common case where &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; are provided:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;bool&lt;/code&gt; 인 일반적인 경우에 대한 두 가지 typedef 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ab704f0a65282b62f2101424e6b2f0abfc336948" translate="yes" xml:space="preserve">
          <source>Two views are equal if both the size of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal and each character in &lt;code&gt;lhs&lt;/code&gt; has an equivalent character in &lt;code&gt;rhs&lt;/code&gt; at the same position.</source>
          <target state="translated">크기의 경우 두 개의 뷰 동일 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 동일하고 각 문자 &lt;code&gt;lhs&lt;/code&gt; 에 상응하는 문자 갖는다 &lt;code&gt;rhs&lt;/code&gt; 동일한 위치에있다.</target>
        </trans-unit>
        <trans-unit id="e4adb4f5d7d971d5f33d8bf32d6573b59f4c2c1c" translate="yes" xml:space="preserve">
          <source>Two-way comparison</source>
          <target state="translated">양방향 비교</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="7d5b0442ddd6e6a3b47c1fb7cfdb53626e952034" translate="yes" xml:space="preserve">
          <source>Type SFINAE</source>
          <target state="translated">SFINAE 타입</target>
        </trans-unit>
        <trans-unit id="c78ea93e5901f3567162bc1f5cabf9c0cb321ce8" translate="yes" xml:space="preserve">
          <source>Type U is swappable with type T if, for any object u of type U and any object t of type T,</source>
          <target state="translated">유형 U는 유형 U의 오브젝트 u와 유형 T의 오브젝트 t에 대해 유형 T와 교환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba8b607d229159b7de176502ebe44f1a8317de01" translate="yes" xml:space="preserve">
          <source>Type alias</source>
          <target state="translated">유형 별명</target>
        </trans-unit>
        <trans-unit id="5e72885576f31f0e1d9c64866f5a1621945f1d64" translate="yes" xml:space="preserve">
          <source>Type alias is a name that refers to a previously defined type (similar to &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;).</source>
          <target state="translated">유형 별명은 이전에 정의 된 유형 ( &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; 와 유사)을 나타내는 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="1722c89a494d0f4cd3e0c044b1bcfcd056571bad" translate="yes" xml:space="preserve">
          <source>Type alias, alias template (since C++11)</source>
          <target state="translated">유형 별명, 별명 템플리트 (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="translated">타입 별칭</target>
        </trans-unit>
        <trans-unit id="cd126df756f5f399b0ed73a4824b22f02643ea98" translate="yes" xml:space="preserve">
          <source>Type aliases are provided for &lt;code&gt;bool&lt;/code&gt; and all integral types listed above, as follows:</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 및 위에 나열된 모든 정수 유형에 대해 다음과 같이 유형 별명이 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="0621d5c6fbe8bcf7d94a8aeaee4b8e9171cf0f16" translate="yes" xml:space="preserve">
          <source>Type aliasing</source>
          <target state="translated">타입 앨리어싱</target>
        </trans-unit>
        <trans-unit id="6c1aa9cebe6e183271d6415c7410657e8ccc6473" translate="yes" xml:space="preserve">
          <source>Type classification</source>
          <target state="translated">타입 분류</target>
        </trans-unit>
        <trans-unit id="faebe1b53837fa610eefb9f421b0013abc2c2ee3" translate="yes" xml:space="preserve">
          <source>Type deduction does not consider implicit conversions (other than type adjustments listed above): that's the job for &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, which happens later.</source>
          <target state="translated">타입 추론은 위에서 언급 한 타입 조정 이외의 암시 적 변환을 고려하지 않습니다 : 그것은 나중에 일어나는 &lt;a href=&quot;overload_resolution&quot;&gt;오버로드 해결&lt;/a&gt; 작업입니다 .</target>
        </trans-unit>
        <trans-unit id="6b6c1979aa63474d39a31dd947373aa3f5876803" translate="yes" xml:space="preserve">
          <source>Type identification</source>
          <target state="translated">타입 식별</target>
        </trans-unit>
        <trans-unit id="8e2511e093ef713b765be9963ac67a42b99f36a7" translate="yes" xml:space="preserve">
          <source>Type modification templates create new type definitions by applying modifications on a template parameter. The resulting type can then be accessed through &lt;code&gt;type&lt;/code&gt; member typedef.</source>
          <target state="translated">유형 수정 템플릿은 템플릿 매개 변수에 수정 사항을 적용하여 새로운 유형 정의를 만듭니다. 생성 된 형태는 다음을 통해 액세스 할 수있는 &lt;code&gt;type&lt;/code&gt; 부재의 typedef.</target>
        </trans-unit>
        <trans-unit id="077701eb2407963fce08e9b207dd8581a8385722" translate="yes" xml:space="preserve">
          <source>Type modifications</source>
          <target state="translated">타입 수정</target>
        </trans-unit>
        <trans-unit id="476a2ca549c0288e513cdd3a95b50bf4cb76b469" translate="yes" xml:space="preserve">
          <source>Type naming</source>
          <target state="translated">타입 네이밍</target>
        </trans-unit>
        <trans-unit id="2885fa4c886876dbf27aa8c6e61e019d3364b3e1" translate="yes" xml:space="preserve">
          <source>Type operations</source>
          <target state="translated">타입 조작</target>
        </trans-unit>
        <trans-unit id="d05a5058829543344892b6ea903ebf7acc0cbacb" translate="yes" xml:space="preserve">
          <source>Type properties</source>
          <target state="translated">유형 속성</target>
        </trans-unit>
        <trans-unit id="712780a85df08fbd996eeeec1c3d3e6e3b629d3c" translate="yes" xml:space="preserve">
          <source>Type relationships</source>
          <target state="translated">타입 관계</target>
        </trans-unit>
        <trans-unit id="c4153f3895b73933a5c58c3f766c82d580c4d612" translate="yes" xml:space="preserve">
          <source>Type requirements</source>
          <target state="translated">유형 요구 사항</target>
        </trans-unit>
        <trans-unit id="5c3dec20e8df5a43918b8faf39633e46723561db" translate="yes" xml:space="preserve">
          <source>Type specifier</source>
          <target state="translated">타입 지정자</target>
        </trans-unit>
        <trans-unit id="ebdbe0be2297808a43109ed1cd29e12d3786ec7d" translate="yes" xml:space="preserve">
          <source>Type support</source>
          <target state="translated">타입 지원</target>
        </trans-unit>
        <trans-unit id="d99c924b5e5c496d209cd1138d79fd4d82ae89bd" translate="yes" xml:space="preserve">
          <source>Type support (basic types, RTTI, type traits)</source>
          <target state="translated">유형 지원 (기본 유형, RTTI, 유형 특성)</target>
        </trans-unit>
        <trans-unit id="86913cb67681548c98606e442d98428c1ae65742" translate="yes" xml:space="preserve">
          <source>Type template parameter</source>
          <target state="translated">유형 템플릿 매개 변수</target>
        </trans-unit>
        <trans-unit id="4a285087e3a01a1f61420542eebe3d7ad0cbe7d5" translate="yes" xml:space="preserve">
          <source>Type template parameter cannot be deduced from the type of a function default argument:</source>
          <target state="translated">유형 템플릿 매개 변수는 함수 기본 인수의 유형에서 추론 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3802db54ebe40c4f9d8e147e5ec66e48e2b252c" translate="yes" xml:space="preserve">
          <source>Type traits</source>
          <target state="translated">유형 특성</target>
        </trans-unit>
        <trans-unit id="2824df384c0d515b0957ced6c76365b01bfeb9fa" translate="yes" xml:space="preserve">
          <source>Type traits (since C++11)</source>
          <target state="translated">유형 특성 (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="fb365f218572167960956b20fa3e4a8fab51cd73" translate="yes" xml:space="preserve">
          <source>Type traits defines a compile-time template-based interface to query or modify the properties of types.</source>
          <target state="translated">유형 특성은 유형의 속성을 쿼리하거나 수정하기위한 컴파일 타임 템플릿 기반 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d26fb74bad254a05310c922f3a48638fd66d9e0c" translate="yes" xml:space="preserve">
          <source>Type traits variable templates (&lt;code&gt;&lt;a href=&quot;types/is_void&quot;&gt;std::is_void_v&lt;/a&gt;&lt;/code&gt;, etc)</source>
          <target state="translated">유형 특성 변수 템플릿 ( &lt;code&gt;&lt;a href=&quot;types/is_void&quot;&gt;std::is_void_v&lt;/a&gt;&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="1ce3ad96399788f64f133fb490b5f7a722f3d935" translate="yes" xml:space="preserve">
          <source>Type-dependent expressions</source>
          <target state="translated">타입 의존적 표현</target>
        </trans-unit>
        <trans-unit id="9923b968817bae672aedebaea069d1e0f05c3d5f" translate="yes" xml:space="preserve">
          <source>Type-id</source>
          <target state="translated">Type-id</target>
        </trans-unit>
        <trans-unit id="ca804ab74bf9fa2667ceb8c95926b696eb69be50" translate="yes" xml:space="preserve">
          <source>Typedefs</source>
          <target state="translated">Typedefs</target>
        </trans-unit>
        <trans-unit id="6b028941a936328652669d0fdcfadace96df8cb3" translate="yes" xml:space="preserve">
          <source>Typedefs and specializations</source>
          <target state="translated">타입 정의 및 전문화</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="14a6b912930173876d4ddc87ab0ee1e78929d71f" translate="yes" xml:space="preserve">
          <source>Types allowed for integer literals</source>
          <target state="translated">정수 리터럴에 허용되는 유형</target>
        </trans-unit>
        <trans-unit id="0aebd15ac247c772915a487e8beaa6ae702bbaf4" translate="yes" xml:space="preserve">
          <source>Types are grouped in various categories based on their properties:</source>
          <target state="translated">유형은 속성에 따라 다양한 범주로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="432f7a9995f3c47c26ea06ac5e31bfbd1ce7f343" translate="yes" xml:space="preserve">
          <source>Types defined in all function definitions are also the same in all translation units.</source>
          <target state="translated">모든 함수 정의에 정의 된 유형도 모든 변환 단위에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f4721af617a03c18f8008b522a45437293348f79" translate="yes" xml:space="preserve">
          <source>Types of lookup</source>
          <target state="translated">조회 유형</target>
        </trans-unit>
        <trans-unit id="7b0613fc7fabdfb018b52d357936b837a2cab911" translate="yes" xml:space="preserve">
          <source>Types that do not have names often need to be referred to in C++ programs; the syntax for that is known as</source>
          <target state="translated">이름이없는 유형은 종종 C ++ 프로그램에서 참조해야합니다. 그 구문은</target>
        </trans-unit>
        <trans-unit id="b2566175d7363d465c10ed984db01277b4e1b9cf" translate="yes" xml:space="preserve">
          <source>Types without a move constructor, but with a copy constructor that accepts &lt;code&gt;const T&amp;amp;&lt;/code&gt; arguments, satisfy &lt;code&gt;std::is_move_constructible&lt;/code&gt;.</source>
          <target state="translated">이동 생성자가 없지만 &lt;code&gt;const T&amp;amp;&lt;/code&gt; 인수 를 허용하는 복사 생성자가있는 유형은 &lt;code&gt;std::is_move_constructible&lt;/code&gt; 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="70739c5bd846379403ad7504d3db0427e14c707a" translate="yes" xml:space="preserve">
          <source>Types...</source>
          <target state="translated">Types...</target>
        </trans-unit>
        <trans-unit id="fbbef98f2687c637a775659b0dc25c3eaf7a67c3" translate="yes" xml:space="preserve">
          <source>Typical declaration of a copy assignment operator when &lt;a href=&quot;operators#Assignment_operator&quot;&gt;copy-and-swap idiom&lt;/a&gt; can be used.</source>
          <target state="translated">&lt;a href=&quot;operators#Assignment_operator&quot;&gt;복사 및 스왑 이디엄을&lt;/a&gt; 사용할 수있는 경우 복사 할당 연산자의 일반적인 선언 .</target>
        </trans-unit>
        <trans-unit id="918b3549bbd396e01bbb7e6f14e565a830f15731" translate="yes" xml:space="preserve">
          <source>Typical declaration of a copy assignment operator when copy-and-swap idiom cannot be used (non-swappable type or degraded performance).</source>
          <target state="translated">복사 및 스왑 이디엄을 사용할 수없는 경우 (스왑 불가능 유형 또는 성능 저하) 복사 할당 연산자의 일반적인 선언.</target>
        </trans-unit>
        <trans-unit id="f8ce748f05c8c5befc02b9aebb0d8d634d05750d" translate="yes" xml:space="preserve">
          <source>Typical declaration of a copy constructor.</source>
          <target state="translated">복사 생성자의 일반적인 선언.</target>
        </trans-unit>
        <trans-unit id="73cd36e771bfce67068d8e880baa5998fadf8c14" translate="yes" xml:space="preserve">
          <source>Typical declaration of a move assignment operator.</source>
          <target state="translated">이동 할당 연산자의 일반적인 선언.</target>
        </trans-unit>
        <trans-unit id="21fff4e24aeaedc99f5d443b9c3e1bb3e8fe60f0" translate="yes" xml:space="preserve">
          <source>Typical declaration of a move constructor.</source>
          <target state="translated">이동 생성자의 일반적인 선언.</target>
        </trans-unit>
        <trans-unit id="d37091da1e22a1f61c981f61d556e4bc6ba5eecd" translate="yes" xml:space="preserve">
          <source>Typical implementation holds an instance of a &lt;code&gt;std::scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; as a member object.</source>
          <target state="translated">일반적인 구현은 &lt;code&gt;std::scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; 의 인스턴스를 멤버 객체로 보유합니다.</target>
        </trans-unit>
        <trans-unit id="06d4cc727848bd1fdf903e8119b98940ee7e586c" translate="yes" xml:space="preserve">
          <source>Typical implementation holds member constants corresponding to all values of fmtflags, iostate, openmode, and seekdir shown below, member variables to maintain current precision, width, and formatting flags, the exception mask, the buffer error state, a resizeable container holding the callbacks, the currently imbued locale, the private storage, and a static integer variable for xalloc().</source>
          <target state="translated">일반적인 구현에는 아래에 표시된 fmtflags, iostate, openmode 및 seekdir의 모든 값에 해당하는 멤버 상수, 현재 정밀도, 너비 및 서식 플래그를 유지하는 멤버 변수, 예외 마스크, 버퍼 오류 상태, 콜백을 보유한 크기 조정 가능한 컨테이너, 현재 imbeed 로케일, 개인용 스토리지 및 xalloc ()에 대한 정적 정수 변수</target>
        </trans-unit>
        <trans-unit id="588a768f54b40d99ef1543297e7072645cb90743" translate="yes" xml:space="preserve">
          <source>Typical implementation of &lt;code&gt;std::basic_osyncstream&lt;/code&gt; holds only one member: the wrapped &lt;code&gt;std::basic_syncbuf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_osyncstream&lt;/code&gt; 의 일반적인 구현 에는 래핑 된 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 한 멤버 만 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="a9aa2b00209f5ddcdf5c18ed5a9a504d20d2daca" translate="yes" xml:space="preserve">
          <source>Typical implementation of &lt;code&gt;std::basic_syncbuf&lt;/code&gt; holds a pointer to the wrapped &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;, a boolean flag indicating whether the buffer will transmit its contents to the wrapped buffer on sync (flush), a boolean flag indicating a pending flush when the policy is to not emit on sync, an internal buffer that uses &lt;code&gt;Allocator&lt;/code&gt; (such as std::string), and a pointer to a mutex used to synchronize emit between multiple threads accessing the same wrapped stream buffer (these mutexes may be in a hash map with pointers to basic_streambuf objects used as keys).</source>
          <target state="translated">&lt;code&gt;std::basic_syncbuf&lt;/code&gt; 의 일반적인 구현 에는 래핑 된 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 대한 포인터가 있습니다.이 플래그는 버퍼가 동기화시 캐시 된 버퍼로 내용을 전송할지 여부를 나타내는 부울 플래그 (플러시), 정책이있을 때 보류중인 플러시를 나타내는 부울 플래그 동기화시 방출하지 않기 위해, std :: string과 같은 &lt;code&gt;Allocator&lt;/code&gt; 를 사용하는 내부 버퍼 및 동일한 랩핑 된 스트림 버퍼에 액세스하는 여러 스레드 사이에서 방출을 동기화하는 데 사용되는 뮤텍스에 대한 포인터 (이러한 뮤텍스는 키로 사용되는 basic_streambuf 객체에 대한 포인터).</target>
        </trans-unit>
        <trans-unit id="7250127c92df894b58e56d580f5f517195bd7d5f" translate="yes" xml:space="preserve">
          <source>Typical implementation of a &lt;code&gt;std::strstreambuf&lt;/code&gt; holds four private data members:</source>
          <target state="translated">&lt;code&gt;std::strstreambuf&lt;/code&gt; 의 일반적인 구현 에는 4 개의 개인 데이터 멤버가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef6d40404da26e1e6eadc90e2e0a92c1349c9710" translate="yes" xml:space="preserve">
          <source>Typical implementation of the &lt;code&gt;std::basic_streambuf&lt;/code&gt; base class holds only the six &lt;code&gt;CharT*&lt;/code&gt; pointers and a copy of &lt;code&gt;&lt;a href=&quot;../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; as data members. In addition, implementations may keep cached copies of locale facets, which are invalidated whenever &lt;code&gt;imbue()&lt;/code&gt; is called. The concrete buffers such as &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;std::basic_streambuf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_streambuf&lt;/code&gt; 기본 클래스 의 일반적인 구현은 6 개의 &lt;code&gt;CharT*&lt;/code&gt; 포인터와 &lt;code&gt;&lt;a href=&quot;../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; 의 사본 만 데이터 멤버로 보유합니다. 또한 구현시 캐시 된 로케일 패싯 사본을 유지할 수 있으며, 이는 &lt;code&gt;imbue()&lt;/code&gt; 가 호출 될 때마다 무효화 됩니다. 콘크리트는 다음과 같은 버퍼 &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; 에서 파생 된 &lt;code&gt;std::basic_streambuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cd7cae1a881bd65509f3fc54f4e619c9e90350a" translate="yes" xml:space="preserve">
          <source>Typical implementations either.</source>
          <target state="translated">전형적인 구현들.</target>
        </trans-unit>
        <trans-unit id="9e133aef83ccff0d4f3491a9890dd2084b61042d" translate="yes" xml:space="preserve">
          <source>Typical implementations of &lt;code&gt;std::basic_stringbuf&lt;/code&gt; hold an object of type &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; or equivalent resizeable sequence container directly as a data member and use it as both the controlled character sequence (the array where the six pointers of &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; are pointing to) and as the associated character sequence (the source of characters for all input operations and the target for the output).</source>
          <target state="translated">전형적인 구현 &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 유형의 객체 길게 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 직접 데이터 부재 또는 상응하는 크기를 재조정 시퀀스 컨테이너 및 (제어 문자 시퀀스 모두 같은 여섯 포인터 배열을 사용하여 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 가리키는됩니다 ) 및 관련 문자 시퀀스 (모든 입력 작업의 문자 소스 및 출력의 대상)로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="68f2d8f77480725b5e25bbfbe1250bd18f26ff6c" translate="yes" xml:space="preserve">
          <source>Typical implementations use hardware transactional memory where supported and to the limits that it is available (e.g. until the changeset is saturated) and fall back to software transactional memory, usually implemented with optimistic concurrency: if another transaction updated some of the variables used by a transaction, it is silently retried. For that reason, retriable transactions (&quot;atomic blocks&quot;) can only call transaction-safe functions.</source>
          <target state="translated">일반적인 구현에서는 지원되는 하드웨어 트랜잭션 메모리와 사용 가능한 한계 (예 : 변경 세트가 포화 될 때까지)를 사용하고 일반적으로 낙관적 동시성으로 구현되는 소프트웨어 트랜잭션 메모리로 대체됩니다. 다른 트랜잭션이 트랜잭션에서 사용하는 일부 변수를 업데이트 한 경우 , 그것은 조용히 재 시도됩니다. 따라서 재시도 가능한 트랜잭션 ( &quot;원자 블록&quot;)은 트랜잭션 안전 기능 만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b555741394ae9339e15f18c3b6d7121a3052b4c" translate="yes" xml:space="preserve">
          <source>Typical use cases for this ordering involve read access to rarely written concurrent data structures (routing tables, configuration, security policies, firewall rules, etc) and publisher-subscriber situations with pointer-mediated publication, that is, when the producer publishes a pointer through which the consumer can access information: there is no need to make everything else the producer wrote to memory visible to the consumer (which may be an expensive operation on weakly-ordered architectures). An example of such scenario is &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-copy-update&quot;&gt;rcu_dereference&lt;/a&gt;.</source>
          <target state="translated">이 순서의 일반적인 사용 사례에는 거의 작성되지 않은 동시 데이터 구조 (라우팅 테이블, 구성, 보안 정책, 방화벽 규칙 등)에 대한 읽기 액세스와 포인터가 중재 된 게시, 즉 생산자가 포인터를 통해 게시하는 게시자-구독자 상황이 포함됩니다. 소비자가 정보에 액세스 할 수 있음 : 생산자가 메모리에 작성한 다른 모든 것을 소비자가 볼 수 있도록 할 필요는 없습니다 (약한 순서의 아키텍처에서는 값 비싼 작업 일 수 있음). 이러한 시나리오의 예는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-copy-update&quot;&gt;rcu_dereference&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dcc9e60517620bd3f403ef0a6408dee8d18e7887" translate="yes" xml:space="preserve">
          <source>Typical use for relaxed memory ordering is incrementing counters, such as the reference counters of &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;, since this only requires atomicity, but not ordering or synchronization (note that decrementing the shared_ptr counters requires acquire-release synchronization with the destructor).</source>
          <target state="translated">완화 된 메모리 순서 지정에 일반적으로 사용되는 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 카운터는 std :: shared_ptr 의 참조 카운터와 같습니다. 이는 원 자성 만 필요하지만 순서 나 동기화는 필요하지 않기 때문에 (공유 _ptr 카운터를 줄이면 소멸자와의 획득-릴리스 동기화가 필요합니다).</target>
        </trans-unit>
        <trans-unit id="d1c41b285173ad8718230a87a1a5d2d17b3b7903" translate="yes" xml:space="preserve">
          <source>Typical use of iword storage is to pass information (e.g. custom formatting flags) from user-defined I/O manipulators to user-defined &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; or to user-defined formatting facets imbued into standard streams.</source>
          <target state="translated">iword 스토리지의 일반적인 사용은 사용자 정의 I / O 조작기에서 사용자 정의 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 또는 표준 스트림에 삽입 된 사용자 정의 형식 패싯에 정보 (예 : 사용자 정의 형식 플래그)를 전달 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0c7297f2b0ebce4780a49bd855246e6cc47d6d3" translate="yes" xml:space="preserve">
          <source>Typical uses of &lt;code&gt;std::launder&lt;/code&gt; include:</source>
          <target state="translated">&lt;code&gt;std::launder&lt;/code&gt; 의 일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f88c003eb42b9ea1375635c3ec171fc7d9d436f1" translate="yes" xml:space="preserve">
          <source>Typically called by the appropriate constructors of &lt;code&gt;std::basic_osyncstream&lt;/code&gt;.</source>
          <target state="translated">일반적으로 적절한 &lt;code&gt;std::basic_osyncstream&lt;/code&gt; 생성자가 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b96ee3f3e487127e3b6fea8c21cfa2b830940d4d" translate="yes" xml:space="preserve">
          <source>Typically called by the constructor of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 의 생성자가 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="47bd33f18f5f8634e7375df48b7f7fb6bccdec60" translate="yes" xml:space="preserve">
          <source>Typically called by the constructor of &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; 의 생성자가 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3d635d5eec3d8618476f770fe4d864ab867b778b" translate="yes" xml:space="preserve">
          <source>Typically called by the destructor of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 의 소멸자가 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f750e5d2112c892940c039aca52de35a7711eef8" translate="yes" xml:space="preserve">
          <source>Typically, once &lt;code&gt;operator&amp;lt;&lt;/code&gt; is provided, the other relational operators are implemented in terms of &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 가 제공되면 다른 관계형 연산자는 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="41f3db6f3ed64eb215d6838b5f2754196444b79e" translate="yes" xml:space="preserve">
          <source>U+00A8</source>
          <target state="translated">U+00A8</target>
        </trans-unit>
        <trans-unit id="853cbdaa93204f86fe9e28c7fa4f0cdff4d3b9bc" translate="yes" xml:space="preserve">
          <source>U+00AA</source>
          <target state="translated">U+00AA</target>
        </trans-unit>
        <trans-unit id="dd5c9cc4b863c82bc928546a1f85d66803a8211b" translate="yes" xml:space="preserve">
          <source>U+00AD</source>
          <target state="translated">U+00AD</target>
        </trans-unit>
        <trans-unit id="5b12a6b1423f6d50cbadc422ccde7e82e285061a" translate="yes" xml:space="preserve">
          <source>U+00AF</source>
          <target state="translated">U+00AF</target>
        </trans-unit>
        <trans-unit id="7b152417fcfe4c5eb703ff0a0c4980c4a5bdcc7f" translate="yes" xml:space="preserve">
          <source>U+00B2 - U+00B5</source>
          <target state="translated">U + 00B2-U + 00B5</target>
        </trans-unit>
        <trans-unit id="a000abf8eda220f3b5a2485e895780d87238cc05" translate="yes" xml:space="preserve">
          <source>U+00B7 - U+00BA</source>
          <target state="translated">U + 00B7-U + 00BA</target>
        </trans-unit>
        <trans-unit id="3e0f991583121de4997412ddc791f2cce64673ed" translate="yes" xml:space="preserve">
          <source>U+00BC - U+00BE</source>
          <target state="translated">U + 00BC-U + 00BE</target>
        </trans-unit>
        <trans-unit id="8da270e5988e53f6a16cfbbffdc343231a853e7f" translate="yes" xml:space="preserve">
          <source>U+00C0 - U+00D6</source>
          <target state="translated">U + 00C0-U + 00D6</target>
        </trans-unit>
        <trans-unit id="21a7086c2d62117c31f8128dd2f55f8f6e915e24" translate="yes" xml:space="preserve">
          <source>U+00D8 - U+00F6</source>
          <target state="translated">U + 00D8-U + 00F6</target>
        </trans-unit>
        <trans-unit id="bf28cde9daefd91ebc927ccb81f1551b46c4d078" translate="yes" xml:space="preserve">
          <source>U+00F8 - U+167F</source>
          <target state="translated">U + 00F8-U + 167F</target>
        </trans-unit>
        <trans-unit id="a317fb85190fd3c7b724d3aedb81fe25713813f0" translate="yes" xml:space="preserve">
          <source>U+0300 - U+036F</source>
          <target state="translated">U + 0300-U + 036F</target>
        </trans-unit>
        <trans-unit id="820e59791c5dbc98084a89fd4c68a5caddd9a3e8" translate="yes" xml:space="preserve">
          <source>U+10000 - U+1FFFD</source>
          <target state="translated">U + 10000-U + 1FFFD</target>
        </trans-unit>
        <trans-unit id="172792565a185595c59af72f4ae5f6a9a6e9ad8f" translate="yes" xml:space="preserve">
          <source>U+1681 - U+180D</source>
          <target state="translated">U + 1681-U + 180D</target>
        </trans-unit>
        <trans-unit id="d84a34f5a6d7a409f7d9c6df8ad6471fbc79b9b0" translate="yes" xml:space="preserve">
          <source>U+180F - U+1FFF</source>
          <target state="translated">U + 180F-U + 1FFF</target>
        </trans-unit>
        <trans-unit id="f3c3d44148796e35a5035d711e351a1697c2759f" translate="yes" xml:space="preserve">
          <source>U+1DC0 - U+1DFF</source>
          <target state="translated">U + 1DC0-U + 1DFF</target>
        </trans-unit>
        <trans-unit id="330cb234316d66348fc89aff6e84b6015dadcf43" translate="yes" xml:space="preserve">
          <source>U+20000 - U+2FFFD</source>
          <target state="translated">U + 20000-U + 2FFFD</target>
        </trans-unit>
        <trans-unit id="5b3b9b21095522acbe168717fae555c1cfa7a1f4" translate="yes" xml:space="preserve">
          <source>U+200B - U+200D</source>
          <target state="translated">U + 200B-U + 200D</target>
        </trans-unit>
        <trans-unit id="3214f797fec510b86bf1cbf6434d683974a2248a" translate="yes" xml:space="preserve">
          <source>U+202A - U+202E</source>
          <target state="translated">U + 202A-U + 202E</target>
        </trans-unit>
        <trans-unit id="e97d49eff3295448f03d9e228444cd7f9a6734e9" translate="yes" xml:space="preserve">
          <source>U+203F - U+2040</source>
          <target state="translated">U + 203F-U + 2040</target>
        </trans-unit>
        <trans-unit id="0c09a7a1795e4fec0be94dc7e91b80a0bf26947f" translate="yes" xml:space="preserve">
          <source>U+2054</source>
          <target state="translated">U+2054</target>
        </trans-unit>
        <trans-unit id="cdc2d82bb3995d9b19eb2ac346b26a7a77b2e28c" translate="yes" xml:space="preserve">
          <source>U+2060 - U+218F</source>
          <target state="translated">U + 2060-U + 218F</target>
        </trans-unit>
        <trans-unit id="dc13f074c0cd31a6bc8af3c06df64a92b1be84c7" translate="yes" xml:space="preserve">
          <source>U+20D0 - U+20FF</source>
          <target state="translated">U + 20D0-U + 20FF</target>
        </trans-unit>
        <trans-unit id="46981b50f5cdfcf424f38b4b3c8b461b58872a28" translate="yes" xml:space="preserve">
          <source>U+2460 - U+24FF</source>
          <target state="translated">U + 2460-U + 24FF</target>
        </trans-unit>
        <trans-unit id="8e2adfcb84ba00df4ef947391a6eab237e18db97" translate="yes" xml:space="preserve">
          <source>U+2776 - U+2793</source>
          <target state="translated">U + 2776-U + 2793</target>
        </trans-unit>
        <trans-unit id="0ef4d0c6e728306dc714d1b3534d9c4ee993dccf" translate="yes" xml:space="preserve">
          <source>U+2C00 - U+2DFF</source>
          <target state="translated">U + 2C00-U + 2DFF</target>
        </trans-unit>
        <trans-unit id="acd49fd22f227c59f753777c2766efc982471a9a" translate="yes" xml:space="preserve">
          <source>U+2E80 - U+2FFF</source>
          <target state="translated">U + 2E80-U + 2FFF</target>
        </trans-unit>
        <trans-unit id="e220b857ae2172b856a1a2e9b7ea31ff3edb4b96" translate="yes" xml:space="preserve">
          <source>U+30000 - U+3FFFD</source>
          <target state="translated">U + 30000-U + 3FFFD</target>
        </trans-unit>
        <trans-unit id="311cc5830e93c014a42f3cfe3f333942cdff5c89" translate="yes" xml:space="preserve">
          <source>U+3004 - U+3007</source>
          <target state="translated">U + 3004-U + 3007</target>
        </trans-unit>
        <trans-unit id="3518418be013a416f360fbc05bd7961da58adcba" translate="yes" xml:space="preserve">
          <source>U+3021 - U+302F</source>
          <target state="translated">U + 3021-U + 302F</target>
        </trans-unit>
        <trans-unit id="22bc0729fee97afe351038d4206a56bdf37b8cc5" translate="yes" xml:space="preserve">
          <source>U+3031 - U+D7FF</source>
          <target state="translated">U + 3031-U + D7FF</target>
        </trans-unit>
        <trans-unit id="75623274217241111dd8aadc0414c3684e3527d1" translate="yes" xml:space="preserve">
          <source>U+40000 - U+4FFFD</source>
          <target state="translated">U + 40000-U + 4FFFD</target>
        </trans-unit>
        <trans-unit id="ad684b1e2d51f2021e6096ff323c755de9835267" translate="yes" xml:space="preserve">
          <source>U+50000 - U+5FFFD</source>
          <target state="translated">U + 50000-U + 5FFFD</target>
        </trans-unit>
        <trans-unit id="f48e64f1d20e3e1aa5cf849c51bec6aec208261d" translate="yes" xml:space="preserve">
          <source>U+60000 - U+6FFFD</source>
          <target state="translated">U + 60000-U + 6FFFD</target>
        </trans-unit>
        <trans-unit id="27a70a77fa9d62033c98d2e43a4e257bfcba0a32" translate="yes" xml:space="preserve">
          <source>U+70000 - U+7FFFD</source>
          <target state="translated">U + 70000-U + 7FFFD</target>
        </trans-unit>
        <trans-unit id="e47ee2f5ce5c5823a3427abfdcb793008f1f9afa" translate="yes" xml:space="preserve">
          <source>U+80000 - U+8FFFD</source>
          <target state="translated">U + 80000-U + 8FFFD</target>
        </trans-unit>
        <trans-unit id="ae42c9725173d1af60cd9ee4fec2a5e915a289c9" translate="yes" xml:space="preserve">
          <source>U+90000 - U+9FFFD</source>
          <target state="translated">U + 90000-U + 9FFFD</target>
        </trans-unit>
        <trans-unit id="a29e4d5dbda0a54f8aba629dfae926d4d31c7fa4" translate="yes" xml:space="preserve">
          <source>U+A0000 - U+AFFFD</source>
          <target state="translated">U + A0000-U + AFFFD</target>
        </trans-unit>
        <trans-unit id="42d66c9df47506c2bbd054315689658beb84bc9e" translate="yes" xml:space="preserve">
          <source>U+B0000 - U+BFFFD</source>
          <target state="translated">U + B0000-U + BFFFD</target>
        </trans-unit>
        <trans-unit id="cdba1c6047783563972c12317b4d72868b21fd76" translate="yes" xml:space="preserve">
          <source>U+C0000 - U+CFFFD</source>
          <target state="translated">U + C0000-U + CFFFD</target>
        </trans-unit>
        <trans-unit id="010072229c529f3ca79fb579b3df7190d32934a1" translate="yes" xml:space="preserve">
          <source>U+D0000 - U+DFFFD</source>
          <target state="translated">U + D0000-U + DFFFD</target>
        </trans-unit>
        <trans-unit id="ce5b442ae1391ac6f3397af8e6e2ed8bbfa37b7f" translate="yes" xml:space="preserve">
          <source>U+E0000 - U+EFFFD</source>
          <target state="translated">U + E0000-U + EFFFD</target>
        </trans-unit>
        <trans-unit id="520d6df0bba5aba46938723a37a68ea22f05a23c" translate="yes" xml:space="preserve">
          <source>U+F900 - U+FD3D</source>
          <target state="translated">U + F900-U + FD3D</target>
        </trans-unit>
        <trans-unit id="163422b76168f04b02797dee7a00db38f358ee53" translate="yes" xml:space="preserve">
          <source>U+FD40 - U+FDCF</source>
          <target state="translated">U + FD40-U + FDCF</target>
        </trans-unit>
        <trans-unit id="fb7bec8d977e924e7257c5655dae76a42823e7a8" translate="yes" xml:space="preserve">
          <source>U+FDF0 - U+FE44</source>
          <target state="translated">U + FDF0-U + FE44</target>
        </trans-unit>
        <trans-unit id="04089c7fc7f2ca3bf063171c8d318a9d6ea6bbde" translate="yes" xml:space="preserve">
          <source>U+FE20 - U+FE2F</source>
          <target state="translated">U + FE20-U + FE2F</target>
        </trans-unit>
        <trans-unit id="f56e67971694a5871856f55e8563ac4dbbcaec84" translate="yes" xml:space="preserve">
          <source>U+FE47 - U+FFFD</source>
          <target state="translated">U + FE47-U + FFFD</target>
        </trans-unit>
        <trans-unit id="270912477818594d05da0936d300cdd48568315a" translate="yes" xml:space="preserve">
          <source>U&lt;code&gt;( { &lt;/code&gt;arg1, arg2, ...&lt;code&gt;} )&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;( { &lt;/code&gt; arg1, arg2, ... &lt;code&gt;} )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="931d496adbd3f197940b61b27f25bcf6e5ce6062" translate="yes" xml:space="preserve">
          <source>UB</source>
          <target state="translated">UB</target>
        </trans-unit>
        <trans-unit id="02625f3ba5ef5ecc340624e8cdbc7bbea1792597" translate="yes" xml:space="preserve">
          <source>UB and optimization</source>
          <target state="translated">UB 및 최적화</target>
        </trans-unit>
        <trans-unit id="fc4cea3d19213a9f2ad0bf9e1d25fcd42a13416e" translate="yes" xml:space="preserve">
          <source>UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</source>
          <target state="translated">UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</target>
        </trans-unit>
        <trans-unit id="2cfb9dd16496ce85eff96d27557f7b42dd5f480d" translate="yes" xml:space="preserve">
          <source>UCS2</source>
          <target state="translated">UCS2</target>
        </trans-unit>
        <trans-unit id="cc245ae082a0221ea07ed3630dd9a406b15ac831" translate="yes" xml:space="preserve">
          <source>UCS2(Windows)</source>
          <target state="translated">UCS2(Windows)</target>
        </trans-unit>
        <trans-unit id="fb192521136df48247e2057851a45e670921483e" translate="yes" xml:space="preserve">
          <source>UDL</source>
          <target state="translated">UDL</target>
        </trans-unit>
        <trans-unit id="b326c17ee1a8eb3c225550246d3d3c78e82f8b2f" translate="yes" xml:space="preserve">
          <source>UINT8_CUINT16_CUINT32_CUINT64_C</source>
          <target state="translated">UINT8_CUINT16_CUINT32_CUINT64_C</target>
        </trans-unit>
        <trans-unit id="6fc76eff0c2b7cb02126a9c106ac3442a9727995" translate="yes" xml:space="preserve">
          <source>UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</source>
          <target state="translated">UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</target>
        </trans-unit>
        <trans-unit id="9ba6e74bce3dda604b2bb3467dd7e8066580c7b5" translate="yes" xml:space="preserve">
          <source>UINTMAX_C</source>
          <target state="translated">UINTMAX_C</target>
        </trans-unit>
        <trans-unit id="5b83709ee00794f8873850a1d8ed0fb42b4fb169" translate="yes" xml:space="preserve">
          <source>UINTMAX_MAX</source>
          <target state="translated">UINTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="ce620a4e99af76df2964e767b6f8444400deb8ca" translate="yes" xml:space="preserve">
          <source>UINTPTR_MAX</source>
          <target state="translated">UINTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="bfda17e335d33e8db92bdb55c45171d922a6859c" translate="yes" xml:space="preserve">
          <source>UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</source>
          <target state="translated">UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="ad74c7ce12e14f74c8c414a0ec98ea6351f500a5" translate="yes" xml:space="preserve">
          <source>UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</source>
          <target state="translated">UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="4196b39d1eebc6a19e223c4aac2d97a9aacf8120" translate="yes" xml:space="preserve">
          <source>UIntType</source>
          <target state="translated">UIntType</target>
        </trans-unit>
        <trans-unit id="469dc1d6169a7065a141b529a6260202a1c8ab1a" translate="yes" xml:space="preserve">
          <source>UNDERTIE - CHARACTER TIE</source>
          <target state="translated">UNDERTIE-캐릭터 넥타이</target>
        </trans-unit>
        <trans-unit id="505551a88f566bb8fb83e0abedb58180312ddfab" translate="yes" xml:space="preserve">
          <source>URBGs and distributions are designed to be used together to produce random values. All of the random number engines may be specifically seeded, serialized, and deserialized for use with repeatable simulators.</source>
          <target state="translated">URBG와 분포는 임의의 값을 생성하기 위해 함께 사용되도록 설계되었습니다. 모든 난수 엔진은 반복 가능한 시뮬레이터와 함께 사용하기 위해 구체적으로 시딩, 직렬화 및 역 직렬화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a9da893be5fd5fae314bea8dcdeeee12beeec4b" translate="yes" xml:space="preserve">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>
        </trans-unit>
        <trans-unit id="2b2540046f34663d3e4a6d43e9cf9715c955300b" translate="yes" xml:space="preserve">
          <source>UTF-16 big-endian</source>
          <target state="translated">UTF-16 빅 엔디안</target>
        </trans-unit>
        <trans-unit id="3e0f2acffc4ed45f148e707196e35bf9de816b83" translate="yes" xml:space="preserve">
          <source>UTF-16 little-endian</source>
          <target state="translated">UTF-16 리틀 엔디안</target>
        </trans-unit>
        <trans-unit id="9d90671c2d02729e29282121f3418c32309d8132" translate="yes" xml:space="preserve">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>
        </trans-unit>
        <trans-unit id="627eba919968fb21d35e780ba4de3a0334bac3b5" translate="yes" xml:space="preserve">
          <source>UTF-32(non-Windows)</source>
          <target state="translated">UTF-32(non-Windows)</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="a2cdcc963eb83efa7c23e1cb852551ce54343476" translate="yes" xml:space="preserve">
          <source>UTF-8 (no effect on endianness)</source>
          <target state="translated">UTF-8 (엔디안에 영향을 미치지 않음)</target>
        </trans-unit>
        <trans-unit id="e6f9cf72db2d174ebd905a64df572642f988ef15" translate="yes" xml:space="preserve">
          <source>Unary &lt;a href=&quot;operator_arithmetic#Unary_arithmetic_operators&quot;&gt;plus and minus&lt;/a&gt;</source>
          <target state="translated">단항 &lt;a href=&quot;operator_arithmetic#Unary_arithmetic_operators&quot;&gt;더하기 및 빼기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5a792933066b9a9e2ac32f6f06b8c7c9b9c310a" translate="yes" xml:space="preserve">
          <source>Unary arithmetic operators</source>
          <target state="translated">단항 산술 연산자</target>
        </trans-unit>
        <trans-unit id="3b2a4a75a6716bd612609078150c84a2711d8a91" translate="yes" xml:space="preserve">
          <source>UnaryTypeTrait</source>
          <target state="translated">UnaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="487d4ab7256ac0a9d6c0537cc67b1af3240a7a6a" translate="yes" xml:space="preserve">
          <source>Unblocks all threads currently waiting for &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;*this&lt;/code&gt; 를 기다리는 모든 스레드를 차단 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="a36f6dfc5a6d8e565414aa5eb95d57c3673c1b95" translate="yes" xml:space="preserve">
          <source>Undefined Behavior</source>
          <target state="translated">정의되지 않은 행동</target>
        </trans-unit>
        <trans-unit id="ae22d7da41718d2107d501afa593d0dc097c049a" translate="yes" xml:space="preserve">
          <source>Undefined Behavior and Fermat&amp;rsquo;s Last Theorem</source>
          <target state="translated">정의되지 않은 행동과 페르마의 마지막 정리</target>
        </trans-unit>
        <trans-unit id="ebb35fed37a359f87ca6b9131bfd7b210eb81cd6" translate="yes" xml:space="preserve">
          <source>Undefined behavior</source>
          <target state="translated">정의되지 않은 동작</target>
        </trans-unit>
        <trans-unit id="675cd8702b8351b311d54416e35e1e88d24ddc83" translate="yes" xml:space="preserve">
          <source>Undefined behavior can result in time travel (among other things, but time travel is the funkiest)</source>
          <target state="translated">정의되지 않은 동작으로 인해 시간 여행이 발생할 수 있습니다 (다른 것들 중에서도 시간 여행이 가장 재미 있습니다)</target>
        </trans-unit>
        <trans-unit id="148339d92ffb0ef43ac5c644f243daf7596715dc" translate="yes" xml:space="preserve">
          <source>Under a</source>
          <target state="translated">아래</target>
        </trans-unit>
        <trans-unit id="9b9209c5de57506f2fda8e822d2a3ad3f311f55e" translate="yes" xml:space="preserve">
          <source>Under the following circumstances, the compilers are permitted, but not required to omit the copy and move(since C++11) construction of class objects even if the copy/move(since C++11) constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to. This is an optimization: even when it takes place and the copy/move(since C++11) constructor is not called, it still must be present and accessible (as if no optimization happened at all), otherwise the program is ill-formed:</source>
          <target state="translated">다음과 같은 상황에서는 컴파일러가 허용되지만 C ++ 11 이후의 copy / move 생성자와 소멸자가 관찰 가능한 측면을 가지고 있어도 클래스 객체의 copy and move (C ++ 11 이후) 생성을 생략 할 필요는 없습니다. 효과. 오브젝트는 스토리지에 직접 구성되며 그렇지 않은 경우 복사 / 이동할 수 있습니다. 이것은 최적화입니다. C ++ 11 이후 복사 / 이동 생성자가 호출되지 않더라도 여전히 존재하고 액세스 할 수 있어야합니다 (최적화가 전혀없는 것처럼). 그렇지 않으면 프로그램이 잘못됩니다. 형성 :</target>
        </trans-unit>
        <trans-unit id="3bea3f4316b2cc744d56328e836cf72a7190a46d" translate="yes" xml:space="preserve">
          <source>Under the following circumstances, the compilers are required to omit the copy and move construction of class objects, even if the copy/move constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to. The copy/move constructors need not be present or accessible, as the language rules ensure that no copy/move operation takes place, even conceptually:</source>
          <target state="translated">다음과 같은 상황에서 컴파일러는 복사 / 이동 생성자와 소멸자가 부작용을 관찰 할 수있는 경우에도 클래스 객체의 복사 및 이동 구성을 생략해야합니다. 오브젝트는 스토리지에 직접 구성되며 그렇지 않은 경우 복사 / 이동됩니다. 언어 규칙에 따라 개념적으로도 복사 / 이동 작업이 수행되지 않으므로 복사 / 이동 생성자가 존재하거나 액세스 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c33868b413394e75c10c66bbcac09ee4be1866f" translate="yes" xml:space="preserve">
          <source>Under these conditions, it can be shown that &lt;code&gt;e&lt;/code&gt; is an equivalence relation, and &lt;code&gt;r&lt;/code&gt; induces a strict total ordering on the equivalence classes determined by &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">이러한 조건 하에서, &lt;code&gt;e&lt;/code&gt; 는 동등성 관계이며 &lt;code&gt;r&lt;/code&gt; 은 &lt;code&gt;e&lt;/code&gt; 에 의해 결정된 동등성 클래스에 대한 엄격한 총 정렬을 유도합니다 .</target>
        </trans-unit>
        <trans-unit id="b828bc3cb0b877121715201877f23784c033074d" translate="yes" xml:space="preserve">
          <source>Underflow is guaranteed if &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/climits&quot;&gt;DBL_MIN&lt;/a&gt;*(sqrt(&amp;pi;)/2)&lt;/code&gt;  erf(</source>
          <target state="translated">언더 플로가있는 경우 보장 &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/climits&quot;&gt;DBL_MIN&lt;/a&gt;*(sqrt(&amp;pi;)/2)&lt;/code&gt; erf (</target>
        </trans-unit>
        <trans-unit id="5b4fe0953f656d5c3e07304963135e1851f6e5c7" translate="yes" xml:space="preserve">
          <source>Understanding Integer Overflow in C/C++</source>
          <target state="translated">C / C ++의 정수 오버플로 이해</target>
        </trans-unit>
        <trans-unit id="5e6066d0264c25a17abb92da4543d5a1bb3137db" translate="yes" xml:space="preserve">
          <source>Unevaluated expressions</source>
          <target state="translated">평가되지 않은 표현</target>
        </trans-unit>
        <trans-unit id="28df9f930dfb483b42b3b26d6ba0e60a90d200c5" translate="yes" xml:space="preserve">
          <source>Unformatted input</source>
          <target state="translated">형식화되지 않은 입력</target>
        </trans-unit>
        <trans-unit id="123f1fcb3edd17ce760e7f03ab6319443c344106" translate="yes" xml:space="preserve">
          <source>Unformatted input/output</source>
          <target state="translated">형식화되지 않은 입력 / 출력</target>
        </trans-unit>
        <trans-unit id="b123c392cb4c8cf5311ee23670ea9ec4b71c524c" translate="yes" xml:space="preserve">
          <source>Unformatted output</source>
          <target state="translated">형식화되지 않은 출력</target>
        </trans-unit>
        <trans-unit id="1103a0808298976db7d8e2eb535bd8a9ef0b0697" translate="yes" xml:space="preserve">
          <source>UnformattedInputFunction</source>
          <target state="translated">UnformattedInputFunction</target>
        </trans-unit>
        <trans-unit id="57c86519dc947e7a7668db91684400955bbea92e" translate="yes" xml:space="preserve">
          <source>UnformattedOutputFunction</source>
          <target state="translated">UnformattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="746515815dbd70aa366c5c8ded38ceac411af5b5" translate="yes" xml:space="preserve">
          <source>Unicode characters in identifiers</source>
          <target state="translated">식별자의 유니 코드 문자</target>
        </trans-unit>
        <trans-unit id="54c4cd3614eda1ec572a80ea2561789d6ec07f9a" translate="yes" xml:space="preserve">
          <source>Unicode conversion facilities</source>
          <target state="translated">유니 코드 변환 기능</target>
        </trans-unit>
        <trans-unit id="518945c57eea6f988b28705fe9a73ae61f28aad7" translate="yes" xml:space="preserve">
          <source>Unicode string literals</source>
          <target state="translated">유니 코드 문자열 리터럴</target>
        </trans-unit>
        <trans-unit id="1d88fe66c0582c456f5ec5c8716a0f875d9594aa" translate="yes" xml:space="preserve">
          <source>Uniform container erasure</source>
          <target state="translated">균일 한 용기 소거</target>
        </trans-unit>
        <trans-unit id="2d5f1d913211ede3bdf584eacf2d1f866d30dd39" translate="yes" xml:space="preserve">
          <source>Uniform distributions</source>
          <target state="translated">균일 분포</target>
        </trans-unit>
        <trans-unit id="ebaf278dff4a479e5c381e2d14da13ed28569d5b" translate="yes" xml:space="preserve">
          <source>Uniform random bit generator requirements</source>
          <target state="translated">균일 한 랜덤 비트 생성기 요구 사항</target>
        </trans-unit>
        <trans-unit id="43fc79a87964e43367c8f806ef4c1bc6c3c17e50" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators</source>
          <target state="translated">균일 한 랜덤 비트 생성기</target>
        </trans-unit>
        <trans-unit id="304d61b117a4be33152a4987bccb311ec8786d3d" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators (URBGs), which include both random number engines, which are pseudo-random number generators that generate integer sequences with a uniform distribution, and true random number generators if available;</source>
          <target state="translated">균일 분포로 정수 시퀀스를 생성하는 의사 난수 생성기 인 난수 엔진과 사용 가능한 경우 실제 난수 생성기 인 난수 엔진을 포함하는 URI (Uniform Random Bit Generators);</target>
        </trans-unit>
        <trans-unit id="9961b884b0d41e9f96e9b47f18701458382481af" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators are not intended to be used as random number generators: they are used as the source of random bits (generated in bulk, for efficiency). Any uniform random bit generator may be plugged into any &lt;a href=&quot;../numeric/random&quot;&gt;random number distribution&lt;/a&gt; in order to obtain a random number (formally, a random variate).</source>
          <target state="translated">균일 한 랜덤 비트 생성기는 난수 생성기로 사용하기위한 것이 아닙니다. 이들은 랜덤 비트의 소스 (효율적으로 대량 생성)로 사용됩니다. 임의의 균일 한 랜덤 비트 생성기는 임의의 &lt;a href=&quot;../numeric/random&quot;&gt;난수 분포 (random number distribution)&lt;/a&gt; 에 플러그되어 임의의 수 (공식적으로 임의의 변이)를 획득 할 수있다.</target>
        </trans-unit>
        <trans-unit id="274ada2867567ab3047cbbf8de81549c088960b3" translate="yes" xml:space="preserve">
          <source>UniformRandomBitGenerator</source>
          <target state="translated">UniformRandomBitGenerator</target>
        </trans-unit>
        <trans-unit id="a1a52383b2bc722ac899de02954f212432e3b35b" translate="yes" xml:space="preserve">
          <source>Uninitialized scalar</source>
          <target state="translated">초기화되지 않은 스칼라</target>
        </trans-unit>
        <trans-unit id="78a4eb44ac157ac9e3cfb278647cea168bf4035b" translate="yes" xml:space="preserve">
          <source>Uninitialized storage</source>
          <target state="translated">초기화되지 않은 스토리지</target>
        </trans-unit>
        <trans-unit id="669a8f132f6da5ef9c5ce154e361c127d5e3b34d" translate="yes" xml:space="preserve">
          <source>Union declaration</source>
          <target state="translated">연합 선언</target>
        </trans-unit>
        <trans-unit id="8b963a92c98e754dacda8255ebe746d63728ca26" translate="yes" xml:space="preserve">
          <source>Union-like classes</source>
          <target state="translated">유니 언급 수업</target>
        </trans-unit>
        <trans-unit id="3c64374ae8a1f69718dd9c2a053e7f58d07b77ab" translate="yes" xml:space="preserve">
          <source>Union-like classes can be used to implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;tagged unions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;공용체&lt;/a&gt; 같은 클래스를 사용하여 태그 된 공용체 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b88a7a2c81e25c95a2b907495a6fc73639f9b55f" translate="yes" xml:space="preserve">
          <source>Unions cannot contain a non-static data member with a non-trivial special member function (&lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, &lt;a href=&quot;as_operator&quot;&gt;copy-assignment&lt;/a&gt; operator, or &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;).</source>
          <target state="translated">유니언은 사소한 특수 멤버 함수 ( &lt;a href=&quot;copy_constructor&quot;&gt;복사 생성자&lt;/a&gt; , &lt;a href=&quot;as_operator&quot;&gt;복사 할당&lt;/a&gt; 연산자 또는 &lt;a href=&quot;destructor&quot;&gt;소멸자&lt;/a&gt; ) 를 가진 비 정적 데이터 멤버를 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bfa43e96dbedcb883a94acbaaea9cf15eba0504f" translate="yes" xml:space="preserve">
          <source>Unique integer for use as pword/iword index.</source>
          <target state="translated">pword / iword 색인으로 사용하기위한 고유 정수.</target>
        </trans-unit>
        <trans-unit id="d66a64b1da303d5c4d195ea302bf616e42aaa173" translate="yes" xml:space="preserve">
          <source>Unit type intended for use as a well-behaved empty alternative in &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt;. In particular, a variant of non-default-constructible types may list &lt;code&gt;std::monostate&lt;/code&gt; as its first alternative: this makes the variant itself default-constructible.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; 에서 잘 작동하는 빈 대안으로 사용하기위한 단위 유형입니다 . 특히, 기본 구성 불가능 유형의 변형은 &lt;code&gt;std::monostate&lt;/code&gt; 를 첫 번째 대안으로 나열 할 수 있습니다 . 이렇게하면 변형 자체가 기본 구성 가능합니다.</target>
        </trans-unit>
        <trans-unit id="43b3c1af3450df3cd0e1ac52c9b04b756ccd01b6" translate="yes" xml:space="preserve">
          <source>Unix and Unix-like systems (Linux, Mac OS X)</source>
          <target state="translated">유닉스 및 유닉스 계열 시스템 (Linux, Mac OS X)</target>
        </trans-unit>
        <trans-unit id="efec0246344a5eba097c63d394ab6c8738a45789" translate="yes" xml:space="preserve">
          <source>Unknown permissions (e.g. when &lt;a href=&quot;file_status&quot;&gt;file_status&lt;/a&gt; is created without permissions)</source>
          <target state="translated">알 수없는 권한 (예 : 권한 없이 &lt;a href=&quot;file_status&quot;&gt;file_status&lt;/a&gt; 가 생성 된 경우 )</target>
        </trans-unit>
        <trans-unit id="689c51725b427087666b6048cec59bcb29fcbece" translate="yes" xml:space="preserve">
          <source>Unknown specializations</source>
          <target state="translated">알 수없는 전문화</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="2103e6143f9ffb325540052fdb6e95f6374d7553" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt;&lt;/a&gt; is supported and set to &lt;code&gt;OFF&lt;/code&gt;, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is, optimizations that omit rounding errors and floating-point exceptions are allowed. For example, C++ allows the implementation of &lt;code&gt;(x*y) + z&lt;/code&gt; with a single fused multiply-add CPU instruction or optimization of &lt;code&gt;a = x*x*x*x;&lt;/code&gt; as &lt;code&gt;tmp = x *x; a = tmp*tmp&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt; &lt;/a&gt; 가 지원되고 &lt;code&gt;OFF&lt;/code&gt; 로 설정되어 있지 않으면 중간 결과에 무한 범위 및 정밀도가있는 것처럼 모든 부동 소수점 산술이 수행 될 수 있습니다. 즉, 반올림 오류 및 부동 소수점 예외를 생략하는 최적화가 허용됩니다. 예를 들어, C ++를 사용하면 단일 융합 다중 추가 CPU 명령어 로 &lt;code&gt;(x*y) + z&lt;/code&gt; 를 구현 하거나 &lt;code&gt;a = x*x*x*x;&lt;/code&gt; 최적화 할 수 있습니다. 같은 &lt;code&gt;tmp = x *x; a = tmp*tmp&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07db20d2d23583077e6ea6e7dac4ed0dbdee1a6b" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted input.</source>
          <target state="translated">하지 않는 한 &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; 발행되어, 동시에 모두 형식과 포맷되지 않은 입력을위한 여러 스레드에서이 개체에 액세스하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="24cf8fcc45f1c3c9991d569649560b6a524615c5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted output.</source>
          <target state="translated">하지 않는 한 &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; 발행되어, 동시에 모두 형식과 포맷되지 않은 출력을위한 여러 스레드에서이 개체에 액세스하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="ffb634a2a2ce0ccfeec2cc3fe27d921270b24978" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">범위 오류가 발생하지 않으면 &lt;a href=&quot;../fenv/fe_round&quot;&gt;현재 반올림 모드&lt;/a&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b15a066b3b603647166b0b65f64183254893ada5" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised (the result is exact)</source>
          <target state="translated">범위 오류가 발생하지 않으면 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 가 발생 하지 않습니다 (결과는 정확함 )</target>
        </trans-unit>
        <trans-unit id="7a8fedd6b20728353d81d9da733470bcfcd14b54" translate="yes" xml:space="preserve">
          <source>Unless a variable template was &lt;a href=&quot;template_specialization&quot;&gt;explicitly specialized&lt;/a&gt; or explicitly instantiated, it is implicitly instantiated when a specialization of the variable template is used.</source>
          <target state="translated">변수 템플릿이 &lt;a href=&quot;template_specialization&quot;&gt;명시 적으로 특수화&lt;/a&gt; 되거나 명시 적으로 인스턴스화 되지 않은 경우 변수 템플릿 의 특수화가 사용될 때 암시 적으로 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="73ad983fb74c97b086aa0802f13da903aa886831" translate="yes" xml:space="preserve">
          <source>Unless noted otherwise, every expression used in a</source>
          <target state="translated">달리 언급되지 않는 한, 모든 표현은</target>
        </trans-unit>
        <trans-unit id="0e8d48b8c7d263f43322d50666aca5a3f152bb21" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, all standard library objects that have been moved from are placed in a valid but unspecified state. That is, only the functions without preconditions, such as the assignment operator, can be safely used on the object after it was moved from:</source>
          <target state="translated">달리 지정하지 않으면, 이동 된 모든 표준 라이브러리 객체는 유효하지만 지정되지 않은 상태가됩니다. 즉, 할당 연산자와 같은 전제 조건이없는 기능 만 오브젝트에서 이동 한 후에 오브젝트에서 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50f2a51822d2bc1f7472ad730cc910af100ceb07" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../optional/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt;&lt;/a&gt;, hash of a variant does not typically equal the hash of the contained value; this makes it possible to distinguish &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; holding the same value as different alternatives.</source>
          <target state="translated">&lt;a href=&quot;../optional/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 달리 변형의 해시는 일반적으로 포함 된 값의 해시와 같지 않습니다. 이것은 다른 대안과 동일한 값을 갖는 &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; 를 구별하는 것을 가능하게합니다 .</target>
        </trans-unit>
        <trans-unit id="338f8ce75fb81cb04c2ab9cbb733a6def87c3d13" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, it can be used in multipass algorithms.</source>
          <target state="translated">&lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; 및 &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; 와 달리 멀티 패스 알고리즘에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="612a7e68b15f6d911dae610df0e6c53ee095c272" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; or &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, these functions do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types, such as &lt;code&gt;std::map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt;. In addition, &lt;code&gt;try_emplace&lt;/code&gt; treats the key and the arguments to the &lt;code&gt;mapped_type&lt;/code&gt; separately, unlike &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, which requires the arguments to construct a &lt;code&gt;value_type&lt;/code&gt; (that is, a &lt;code&gt;std::pair&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; 또는 &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; 와 달리 , 삽입이 발생하지 않으면 이러한 함수는 rvalue 인수에서 이동하지 않으므로 &lt;code&gt;std::map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt; 와 같이 값이 이동 전용 유형 인 맵을 쉽게 조작 할 수 있습니다. unique_ptr &amp;lt;foo &amp;gt;&amp;gt; . 또한, &lt;code&gt;try_emplace&lt;/code&gt; 의 취급 키와의 인수 &lt;code&gt;mapped_type&lt;/code&gt; 별도로 달리 &lt;a href=&quot;emplace&quot;&gt;설치하다&lt;/a&gt; 구성체의 인자가 필요 &lt;code&gt;value_type&lt;/code&gt; (a이라고 &lt;code&gt;std::pair&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6875db19fce8401ca9aebbb20205b26bb728d1fd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; or &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, these functions do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types, such as &lt;code&gt;std::unordered_map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt;. In addition, &lt;code&gt;try_emplace&lt;/code&gt; treats the key and the arguments to the &lt;code&gt;mapped_type&lt;/code&gt; separately, unlike &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, which requires the arguments to construct a &lt;code&gt;value_type&lt;/code&gt; (that is, a &lt;code&gt;std::pair&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; 또는 &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; 와 달리 , 삽입이 발생하지 않으면 이러한 함수는 rvalue 인수에서 이동하지 않으므로 &lt;code&gt;std::unordered_map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt; 와 같이 값이 이동 전용 유형 인 맵을 쉽게 조작 할 수 있습니다. unique_ptr &amp;lt;foo &amp;gt;&amp;gt; . 또한, &lt;code&gt;try_emplace&lt;/code&gt; 의 취급 키와의 인수 &lt;code&gt;mapped_type&lt;/code&gt; 별도로 달리 &lt;a href=&quot;emplace&quot;&gt;설치하다&lt;/a&gt; 구성체의 인자가 필요 &lt;code&gt;value_type&lt;/code&gt; (a이라고 &lt;code&gt;std::pair&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2de29ed23c34ba831619b83b8554947943971200" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../basic_string/data&quot;&gt;std::basic_string::data()&lt;/a&gt;&lt;/code&gt; and string literals, &lt;code&gt;data()&lt;/code&gt; may return a pointer to a buffer that is not null-terminated. Therefore it is typically a mistake to pass &lt;code&gt;data()&lt;/code&gt; to a routine that takes just a &lt;code&gt;const CharT*&lt;/code&gt; and expects a null-terminated string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_string/data&quot;&gt;std::basic_string::data()&lt;/a&gt;&lt;/code&gt; 및 문자열 리터럴 과 달리 &lt;code&gt;data()&lt;/code&gt; 는 null로 끝나지 않은 버퍼에 대한 포인터를 반환 할 수 있습니다. 따라서 일반적으로 &lt;code&gt;const CharT*&lt;/code&gt; 만 사용 하고 null로 끝나는 문자열을 기대하는 루틴에 &lt;code&gt;data()&lt;/code&gt; 를 전달하는 것은 실수 입니다.</target>
        </trans-unit>
        <trans-unit id="b42b73288e226f5ad79616019df229c7343f10e7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../basic_string/operator_at&quot;&gt;std::basic_string::operator[]&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::basic_string_view::operator[](size())&lt;/code&gt; has undefined behavior instead of returning &lt;code&gt;CharT()&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;../basic_string/operator_at&quot;&gt;std::basic_string::operator[]&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::basic_string_view::operator[](size())&lt;/code&gt; 대신 복귀 정의되지 않은 동작 갖는 &lt;code&gt;CharT()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82cf3dbf0c22a41175cd7995812ae5e616d63672" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;std::strtok&lt;/a&gt;&lt;/code&gt;, this function does not update static storage: it stores the parser state in the user-provided location.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;std::strtok&lt;/a&gt;&lt;/code&gt; 과 달리이 함수는 정적 스토리지를 업데이트하지 않습니다. 파서 상태를 사용자 제공 위치에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="4887cd4b1d808c0fb500939d898308b30c68c620" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::greater&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;gt;&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;../greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ranges::greater&lt;/code&gt; 여섯 비교 연산자 필요 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; 와 &lt;code&gt;!=&lt;/code&gt; (비아 유효 &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; 의&lt;/a&gt; 제한) 및 전체의 관점에서 정의된다 &lt;code&gt;std::ranges::less&lt;/code&gt; . 그러나 이러한 개념은 비교 연산자의 결과가 일관되어야하므로 구현시 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 를 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76b2faafc9a3dbd22464e63c0ec0383467b9c99f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::greater_equal&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;gt;=&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;../greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ranges::greater_equal&lt;/code&gt; 여섯 비교 연산자 필요 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; 와 &lt;code&gt;!=&lt;/code&gt; (비아 유효 &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; 의&lt;/a&gt; 제한) 및 전체의 관점에서 정의된다 &lt;code&gt;std::ranges::less&lt;/code&gt; . 그러나 이러한 개념은 비교 연산자의 결과가 일관되어야하므로 구현시 &lt;code&gt;operator&amp;gt;=&lt;/code&gt; 를 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78dbcad5e4fbe558a33518be37657107f091659c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::less_equal&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;lt;=&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;../less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ranges::less_equal&lt;/code&gt; 여섯 비교 연산자 필요 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; 와 &lt;code&gt;!=&lt;/code&gt; (비아 유효 &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; 의&lt;/a&gt; 제한) 및 전체의 측면에서 정의 &lt;code&gt;std::ranges::less&lt;/code&gt; . 그러나 이러한 개념은 비교 연산자의 결과가 일관되어야하기 때문에 구현시 &lt;code&gt;operator&amp;lt;=&lt;/code&gt; 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98c9c16f2e98cd689703db22c46385c7c82dbbfc" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../map/operator_at&quot;&gt;std::map::operator[]&lt;/a&gt;&lt;/code&gt;, this operator never inserts a new element into the container.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../map/operator_at&quot;&gt;std::map::operator[]&lt;/a&gt;&lt;/code&gt; 와 달리이 연산자는 컨테이너에 새 요소를 삽입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83c22ec940642abd3fc1b2b3f91bda4fefd9187c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::not_equal_to&lt;/code&gt; requires both &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/equalitycomparable&quot;&gt;&lt;code&gt;EqualityComparableWith&lt;/code&gt;&lt;/a&gt; constraint), and is entirely defined in terms of &lt;code&gt;std::ranges::equal_to&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator!=&lt;/code&gt; directly, because those concepts require the results of &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be consistent.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;../not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ranges::not_equal_to&lt;/code&gt; 모두 필요 &lt;code&gt;==&lt;/code&gt; 와 &lt;code&gt;!=&lt;/code&gt; (비아 유효 &lt;a href=&quot;../../../concepts/equalitycomparable&quot;&gt; &lt;code&gt;EqualityComparableWith&lt;/code&gt; 의&lt;/a&gt; 제한) 및 전체의 관점에서 정의 된 &lt;code&gt;std::ranges::equal_to&lt;/code&gt; . 그러나 이러한 개념에서는 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 의 결과 가 일관되어야 하므로 구현시 &lt;code&gt;operator!=&lt;/code&gt; 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a93ac31e396db5acf4776ae92718a031c6e2a35d" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; (which has &lt;code&gt;&lt;a href=&quot;../shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;std::make_unique&lt;/code&gt; does not have an allocator-aware counterpart. A hypothetical &lt;code&gt;allocate_unique&lt;/code&gt; would be required to invent the deleter type &lt;code&gt;D&lt;/code&gt; for the &lt;code&gt;unique_ptr&amp;lt;T,D&amp;gt;&lt;/code&gt; it returns which would contain an allocator object and invoke both &lt;code&gt;destroy&lt;/code&gt; and &lt;code&gt;deallocate&lt;/code&gt; in its &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; (시킨 &lt;code&gt;&lt;a href=&quot;../shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt; ) &lt;code&gt;std::make_unique&lt;/code&gt; 할당 자 인식 대응이 없습니다. 가설 &lt;code&gt;allocate_unique&lt;/code&gt; 은 Deleter가 타입 발명해야 할 &lt;code&gt;D&lt;/code&gt; 를 위한 &lt;code&gt;unique_ptr&amp;lt;T,D&amp;gt;&lt;/code&gt; 할당 자 객체를 포함하고있는 invoke 것 모두 그것을 반환 &lt;code&gt;destroy&lt;/code&gt; 및 &lt;code&gt;deallocate&lt;/code&gt; 그것의 &lt;code&gt;operator()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfa95d30700702ce194a65101a9f73a0be8c3e37" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, the deleter of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; is invoked even if the managed pointer is null.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 의 Deleter가 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 관리되는 포인터가 null의 경우에도 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bcc84ea13a79573b43e6585e6b696a907d0811f1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt;, this manipulator does not flush the stream.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; 과 달리이 조작기는 스트림을 플러시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efa45df35e365dacc26b0c10d8f1d5381eb5b951" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt;, performs a bounds check and throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos&lt;/code&gt; does not correspond to a valid position in the bitset.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt; 와 달리 , 범위 검사를 수행하고 &lt;code&gt;pos&lt;/code&gt; 가 비트 세트의 유효한 위치에 해당하지 않으면 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f987fe2de50e7bdc36ad5bea121ee3e9648279c4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::forward_list::remove&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erase&lt;/code&gt; accepts heterogenous types and does not force a conversion to the container's value type before invoking the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::forward_list::remove&lt;/a&gt;&lt;/code&gt; 와 달리 , &lt;code&gt;erase&lt;/code&gt; 는 이기종 유형을 허용하며 &lt;code&gt;==&lt;/code&gt; 연산자 를 호출하기 전에 컨테이너의 값 유형으로 강제 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="173b793fffeab067a076675a0bbf0ba3c09de869" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::list::remove&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erase&lt;/code&gt; accepts heterogenous types and does not force a conversion to the container's value type before invoking the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::list::remove&lt;/a&gt;&lt;/code&gt; 와 달리 , &lt;code&gt;erase&lt;/code&gt; 는 이기종 유형을 허용하며 &lt;code&gt;==&lt;/code&gt; 연산자 를 호출하기 전에 컨테이너의 값 유형으로 강제 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4c977d4a7c4e43375bfbd8db6568cbdff01d3089" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::unique_ptr&lt;/code&gt; may manage an object through any custom handle type that satisfies &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt;. This allows, for example, managing objects located in shared memory, by supplying a &lt;code&gt;Deleter&lt;/code&gt; that defines &lt;code&gt;typedef &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost::offset_ptr&lt;/a&gt; pointer;&lt;/code&gt; or another &lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;fancy pointer&lt;/a&gt;.</source>
          <target state="translated">달리 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::unique_ptr&lt;/code&gt; 사용자 정의 핸들 타입의 만족을 통해 객체를 관리 할 수 있습니다 &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt; . 예를 들어 &lt;code&gt;typedef &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost::offset_ptr&lt;/a&gt; pointer;&lt;/code&gt; &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost :: offset_ptr&lt;/a&gt; pointer; 를 정의 하는 &lt;code&gt;Deleter&lt;/code&gt; 를 제공하여 공유 메모리에있는 객체를 관리 할 수 ​​있습니다 . 또는 다른 &lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;멋진 포인터&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89fdf70ecbdde3e278dffffd100b54f51a75a774" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::unique_ptr&lt;/code&gt; may manage an object through any custom handle type that satisfies &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt;. This allows, for example, managing objects located in shared memory, by supplying a &lt;code&gt;Deleter&lt;/code&gt; that defines &lt;code&gt;typedef &lt;a href=&quot;https://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost::offset_ptr&lt;/a&gt; pointer;&lt;/code&gt; or another &lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;fancy pointer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1573c755f58e9c4746c81740477c0b3b24dac236" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;test&quot;&gt;test()&lt;/a&gt;&lt;/code&gt;, does not throw exceptions: the behavior is undefined if &lt;code&gt;pos&lt;/code&gt; is out of bounds.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;test&quot;&gt;test()&lt;/a&gt;&lt;/code&gt; 와 달리 예외를 throw하지 않습니다 . &lt;code&gt;pos&lt;/code&gt; 가 범위를 벗어나 면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6eba30f9f21127f9176b2a660cfad2f04c8b9efb" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;static_cast&lt;/code&gt;, but like &lt;code&gt;const_cast&lt;/code&gt;, the &lt;code&gt;reinterpret_cast&lt;/code&gt; expression does not compile to any CPU instructions (except when converting between integers and pointers or on obscure architectures where pointer representation depends on its type). It is purely a compile-time directive which instructs the compiler to treat expression as if it had the type new_type.</source>
          <target state="translated">달리 &lt;code&gt;static_cast&lt;/code&gt; 하지만 같은 &lt;code&gt;const_cast&lt;/code&gt; 의 &lt;code&gt;reinterpret_cast&lt;/code&gt; 의 (포인터 표현의 종류에 따라 다릅니다 곳 정수와 포인터 사이 또는 모호한 아키텍처를 변환 할 때를 제외하고) 표현은 CPU의 지시에 컴파일되지 않습니다. 이는 컴파일러가 new_type 유형을 갖는 것처럼 식을 처리하도록 지시하는 컴파일 타임 지시문입니다.</target>
        </trans-unit>
        <trans-unit id="f39585865906a9f2075869fd7919be30089c3370" translate="yes" xml:space="preserve">
          <source>Unlike Rule of Three, failing to provide move constructor and move assignment is usually not an error, but a missed optimization opportunity.</source>
          <target state="translated">Rule of Three와 달리 이동 생성자 및 이동 할당을 제공하지 않으면 일반적으로 오류가 아니라 최적화 기회가 누락됩니다.</target>
        </trans-unit>
        <trans-unit id="57237dac9eb413318550844e3881a717ec402781" translate="yes" xml:space="preserve">
          <source>Unlike explicit constructors, which are only considered during &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt; (which includes &lt;a href=&quot;explicit_cast&quot;&gt;explicit conversions&lt;/a&gt; such as &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt;), converting constructors are also considered during &lt;a href=&quot;copy_initialization&quot;&gt;copy initialization&lt;/a&gt;, as part of &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequence&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 중에 만 고려되는 명시 적 생성자 ( &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt; 와 같은 &lt;a href=&quot;explicit_cast&quot;&gt;명시 적 변환&lt;/a&gt; 포함) 와 달리 변환 생성자는 &lt;a href=&quot;implicit_cast&quot;&gt;사용자 정의 변환 순서의&lt;/a&gt; 일부로 &lt;a href=&quot;copy_initialization&quot;&gt;복사 초기화&lt;/a&gt; 중에도 고려 됩니다 .</target>
        </trans-unit>
        <trans-unit id="0519031d106f159f57ffffbcb3c189318dbf95d8" translate="yes" xml:space="preserve">
          <source>Unlike for &lt;code&gt;&lt;a href=&quot;../../container/vector/clear&quot;&gt;std::vector::clear&lt;/a&gt;&lt;/code&gt;, the C++ standard does not explicitly require that &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt; is unchanged by this function, but existing implementations do not change capacity. This means that they do not release the allocated memory (see also &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../container/vector/clear&quot;&gt;std::vector::clear&lt;/a&gt;&lt;/code&gt; 와 달리 C ++ 표준에서는 이 함수가 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt; 을 변경 하지 않아도되도록 명시 적으로 요구하지 않지만 기존 구현에서는 용량을 변경하지 않습니다. 이는 할당 된 메모리를 해제하지 않음을 의미합니다 ( &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit&lt;/a&gt;&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="005bffdc5ce748f5fa7ecab037e6b4ba23fd3f4c" translate="yes" xml:space="preserve">
          <source>Unlike formatted output functions, this function does not set the &lt;code&gt;failbit&lt;/code&gt; if the output fails.</source>
          <target state="translated">형식이 지정된 출력 기능과 달리이 기능은 출력이 실패해도 &lt;code&gt;failbit&lt;/code&gt; 설정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c11ef1e4f5cbd932283bfef60dfc1f2ad7da6484" translate="yes" xml:space="preserve">
          <source>Unlike functions or references to functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, etc.</source>
          <target state="translated">함수 또는 함수에 대한 참조와 달리 함수에 대한 포인터는 객체이므로 배열에 저장, 복사, 할당 등을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc1a9b3bf127389b70df7d40bbc2018c53338a0" translate="yes" xml:space="preserve">
          <source>Unlike header guards, this pragma makes it impossible to erroneously use the same macro name in more than one file. On the other hand, since with &lt;code&gt;#pragma once&lt;/code&gt; files are excluded based on their filesystem-level identity, this can't protect against including a header twice if it exists in more than one location in a project.</source>
          <target state="translated">헤더 보호와 달리이 pragma를 사용하면 둘 이상의 파일에서 동일한 매크로 이름을 잘못 사용할 수 없습니다. 반면, &lt;code&gt;#pragma once&lt;/code&gt; 파일 시스템 수준의 ID를 기반으로 파일이 제외되면 프로젝트에서 둘 이상의 위치에 존재하는 경우 헤더를 두 번 포함하는 것을 방지 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ee79da911cfc98f59e02246e9625087f966f6ee4" translate="yes" xml:space="preserve">
          <source>Unlike many related functions, this function is</source>
          <target state="translated">많은 관련 기능과 달리이 기능은</target>
        </trans-unit>
        <trans-unit id="c7ea1f99bf46737fd3a9eb5569bcdb5f3547a949" translate="yes" xml:space="preserve">
          <source>Unlike most assignment operators, the assignment operator for &lt;code&gt;atomic_ref&lt;/code&gt; does not return a reference to its left-hand argument. It returns a copy of the stored value instead.</source>
          <target state="translated">대부분의 대입 연산자와 달리 &lt;code&gt;atomic_ref&lt;/code&gt; 의 대입 연산자 는 왼쪽 인수에 대한 참조를 반환하지 않습니다. 대신 저장된 값의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1a4db73f4f2b5f3d23685150e26ab0e326ffc436" translate="yes" xml:space="preserve">
          <source>Unlike most assignment operators, the assignment operators for atomic types do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">대부분의 대입 연산자와 달리 원자 유형의 대입 연산자는 왼쪽 인수에 대한 참조를 반환하지 않습니다. 대신 저장된 값의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3697fcced78a8dc2e1dd58511d1675942ea9902d" translate="yes" xml:space="preserve">
          <source>Unlike most compound assignment operators, the compound assignment operators for &lt;code&gt;atomic_ref&lt;/code&gt; do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">대부분의 복합 할당 연산자와 달리 &lt;code&gt;atomic_ref&lt;/code&gt; 에 대한 복합 할당 연산자는 왼쪽 인수에 대한 참조를 반환하지 않습니다. 대신 저장된 값의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="139203564aef61dc9e502ac41ea33308504a0622" translate="yes" xml:space="preserve">
          <source>Unlike most compound assignment operators, the compound assignment operators for atomic types do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">대부분의 복합 할당 연산자와 달리 원자 유형에 대한 복합 할당 연산자는 왼쪽 인수에 대한 참조를 반환하지 않습니다. 대신 저장된 값의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dda22864e1900bb6a87e878513e661e3ee5d8ee4" translate="yes" xml:space="preserve">
          <source>Unlike most mathematical operations, the conversion of a floating-point value to text and back is</source>
          <target state="translated">대부분의 수학 연산과 달리 부동 소수점 값을 텍스트로 변환하는 것은</target>
        </trans-unit>
        <trans-unit id="76a29065db67fecaafea29ca64388623baf0bcbc" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;std::wcstok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">대부분의 다른 토크 나이저와 달리 &lt;code&gt;std::wcstok&lt;/code&gt; 의 구분 기호는 각 후속 토큰마다 다를 수 있으며 이전 토큰의 내용에 따라 달라질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c348ec3650d4d97ed9bc09e83c2572c81d376d68" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;strtok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">대부분의 다른 토크 나이저와 달리 &lt;code&gt;strtok&lt;/code&gt; 의 구분 기호는 각 후속 토큰마다 다를 수 있으며 이전 토큰의 내용에 따라 달라질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e499b26c05a23f391924b25bade94974b21959a1" translate="yes" xml:space="preserve">
          <source>Unlike most pre-increment and pre-decrement operators, the pre-increment and pre-decrement operators for &lt;code&gt;atomic_ref&lt;/code&gt; do not return a reference to the modified object. They return a copy of the stored value instead.</source>
          <target state="translated">대부분의 사전 증분 및 사전 감소 연산자와 달리 &lt;code&gt;atomic_ref&lt;/code&gt; 의 사전 증분 및 사전 감소 연산자 는 수정 된 객체에 대한 참조를 반환하지 않습니다. 대신 저장된 값의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="247d65607595333e4901228f7023c088dbe9e552" translate="yes" xml:space="preserve">
          <source>Unlike most pre-increment and pre-decrement operators, the pre-increment and pre-decrement operators for atomic types do not return a reference to the modified object. They return a copy of the stored value instead.</source>
          <target state="translated">대부분의 사전 증분 및 사전 감소 연산자와 달리 원자 유형에 대한 사전 증분 및 사전 감소 연산자는 수정 된 객체에 대한 참조를 반환하지 않습니다. 대신 저장된 값의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="536f52cdb9582b6792ddf498c21f83ff3bc9d9a5" translate="yes" xml:space="preserve">
          <source>Unlike other formatting functions in C++ and C libraries, &lt;code&gt;std::to_chars&lt;/code&gt; is locale-independent, non-allocating, and non-throwing. Only a small subset of formatting policies used by other libraries (such as &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::sprintf&lt;/a&gt;&lt;/code&gt;) is provided. This is intended to allow the fastest possible implementation that is useful in common high-throughput contexts such as text-based interchange (JSON or XML).</source>
          <target state="translated">C ++ 및 C 라이브러리의 다른 형식화 ​​함수와 달리 &lt;code&gt;std::to_chars&lt;/code&gt; 는 로케일 독립적, 비 할당 및 비 투사입니다. 다른 라이브러리 ( &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::sprintf&lt;/a&gt;&lt;/code&gt; 와 같은)에서 사용하는 형식화 정책의 작은 서브 세트 만 제공됩니다. 이는 텍스트 기반 교환 (JSON 또는 XML)과 같은 일반적인 처리량이 많은 상황에서 유용한 가장 빠른 구현을 가능하게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="960cf91e24a03ae762e9fec6a351793c82e6e03d" translate="yes" xml:space="preserve">
          <source>Unlike other functions that take &lt;code&gt;std::valarray&lt;/code&gt; arguments, &lt;code&gt;begin()&lt;/code&gt; cannot accept the replacement types (such as the types produced by expression templates) that may be returned from expressions involving valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(v1 + v2)&lt;/code&gt; is not portable, &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; has to be used instead.</source>
          <target state="translated">&lt;code&gt;std::valarray&lt;/code&gt; 인수를 사용 하는 다른 함수와 달리 &lt;code&gt;begin()&lt;/code&gt; 은 valarray를 포함하는 표현식에서 리턴 될 수있는 대체 유형 (예 : 표현식 템플리트에서 생성 된 유형 ) 을 승인 할 수 없습니다. &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(v1 + v2)&lt;/code&gt; 는 이식 가능하지 않습니다 대신 &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="07020cc0a6112afa1a94ca2a985fb8992ea81c5d" translate="yes" xml:space="preserve">
          <source>Unlike other functions that take &lt;code&gt;std::valarray&lt;/code&gt; arguments, &lt;code&gt;end()&lt;/code&gt; cannot accept the replacement types (such as the types produced by expression templates) that may be returned from expressions involving valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(v1 + v2)&lt;/code&gt; is not portable, &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; has to be used instead.</source>
          <target state="translated">&lt;code&gt;std::valarray&lt;/code&gt; 인수를 사용 하는 다른 함수와 달리 &lt;code&gt;end()&lt;/code&gt; 는 valarray를 포함하는 표현식에서 리턴 될 수있는 대체 유형 (예 : 표현식 템플리트에서 생성 된 유형 ) 을 승인 할 수 없습니다. &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(v1 + v2)&lt;/code&gt; 는 이식 가능하지 않습니다 대신 &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="82b08c1bafac008cc3356484b3bea8b8da199f4c" translate="yes" xml:space="preserve">
          <source>Unlike other parsing functions in C++ and C libraries, &lt;code&gt;std::from_chars&lt;/code&gt; is locale-independent, non-allocating, and non-throwing. Only a small subset of parsing policies used by other libraries (such as &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::sscanf&lt;/a&gt;&lt;/code&gt;) is provided. This is intended to allow the fastest possible implementation that is useful in common high-throughput contexts such as text-based interchange (JSON or XML).</source>
          <target state="translated">C ++ 및 C 라이브러리의 다른 구문 분석 함수와 달리 &lt;code&gt;std::from_chars&lt;/code&gt; 는 로케일 독립적, 비 할당 및 비 투사입니다. 다른 라이브러리 ( &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::sscanf&lt;/a&gt;&lt;/code&gt; 와 같은)에서 사용하는 구문 분석 정책의 작은 서브 세트 만 제공됩니다. 이는 텍스트 기반 교환 (JSON 또는 XML)과 같은 일반적인 처리량이 많은 상황에서 유용한 가장 빠른 구현을 가능하게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="bc22867a4de3145dca568d4e66ffa742bf46b614" translate="yes" xml:space="preserve">
          <source>Unlike other temporary objects, the exception object is considered to be an lvalue argument when initializing the catch clause parameters, so it can be caught by lvalue reference, modified, and rethrown.</source>
          <target state="translated">다른 임시 객체와 달리 예외 객체는 catch 절 매개 변수를 초기화 할 때 lvalue 인수로 간주되므로 lvalue 참조, 수정 및 다시 throw에 의해 포착 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40e4049da792f251c064108725448595e7fb81c8" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; named requirement, &lt;code&gt;std::Destructible&lt;/code&gt; requires the destructor to be &lt;code&gt;noexcept(true)&lt;/code&gt;, not merely non-throwing when invoked, and allows reference types and array types.</source>
          <target state="translated">&lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; 명명 된 요구 사항 과 달리 &lt;code&gt;std::Destructible&lt;/code&gt; 은 소멸 시 호출되지 않을뿐 아니라 소멸자가 &lt;code&gt;noexcept(true)&lt;/code&gt; 하며 참조 유형 및 배열 유형을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f2ff26def44fad2ae044095e7f187e2f9c03b39d" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; constructors, &lt;code&gt;std::make_shared&lt;/code&gt; does not allow a custom deleter.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 생성자 와 달리 &lt;code&gt;std::make_shared&lt;/code&gt; 는 사용자 정의 삭제기를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c6f8d4294a5e322f2430ee23bff35686e775144" translate="yes" xml:space="preserve">
          <source>Unlike the primary template &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt;, this specialization does not perform a virtual function call when classifying characters. To customize the behavior, a derived class may provide a non-default classification table to the base class constructor.</source>
          <target state="translated">기본 템플릿 &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 과 달리이 특수화는 문자를 분류 할 때 가상 함수 호출을 수행하지 않습니다. 동작을 사용자 정의하기 위해 파생 클래스는 기본 클래스 생성자에게 기본이 아닌 분류 테이블을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a3c250893800a21b88186ef185aadaf831d7992" translate="yes" xml:space="preserve">
          <source>Unlike the promotions, numeric conversions may change the values, with potential loss of precision.</source>
          <target state="translated">승격과 달리 숫자 변환으로 인해 정밀도가 손실 될 수 있으므로 값이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cf90c59183d16b061b44fcdd59d790f2d00de63" translate="yes" xml:space="preserve">
          <source>Unlike the rest of the algorithms, for_each is not allowed to make copies of the elements in the sequence even if they are trivially copyable.</source>
          <target state="translated">나머지 알고리즘과 달리 for_each는 사소한 복사가 가능하더라도 시퀀스에서 요소의 복사본을 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="db1ac6c9a5b777adb044dcf5cc2c8e1d9362ebb5" translate="yes" xml:space="preserve">
          <source>Unlike the std::shared_ptr constructors, std::allocate_shared does not accept a separate custom deleter: the supplied allocator is used for destruction of the control block and the &lt;code&gt;T&lt;/code&gt; object, and for deallocation of their shared memory block.</source>
          <target state="translated">std :: shared_ptr 생성자와 달리 std :: allocate_shared는 별도의 사용자 정의 삭제기를 허용하지 않습니다. 제공된 할당자는 제어 블록 및 &lt;code&gt;T&lt;/code&gt; 오브젝트를 삭제하고 공유 메모리 블록을 할당 해제하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="66abfa107dcdc9f5699b86a1259047a6420b2c52" translate="yes" xml:space="preserve">
          <source>Unlike type template parameter declaration, template template parameter declaration can only use the keyword &lt;code&gt;class&lt;/code&gt; and not &lt;code&gt;typename&lt;/code&gt;.</source>
          <target state="translated">유형 템플리트 매개 변수 선언과 달리, 템플리트 템플리트 매개 변수 선언은 &lt;code&gt;typename&lt;/code&gt; 이 아닌 키워드 &lt;code&gt;class&lt;/code&gt; 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d675911d340ea7fe2bddf254d2a266f734dde906" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;code&gt;&lt;a href=&quot;append&quot;&gt;append()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;append&quot;&gt;operator/=&lt;/a&gt;&lt;/code&gt;, additional directory separators are never introduced.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;append&quot;&gt;append()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;append&quot;&gt;operator/=&lt;/a&gt;&lt;/code&gt; 와는 달리 추가 디렉토리 구분 기호는 소개되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9795510ddaf8f7b584f9cfa5390b07d1db4d7240" translate="yes" xml:space="preserve">
          <source>Unlocks the associated mutex and releases ownership.</source>
          <target state="translated">연관된 뮤텍스를 잠금 해제하고 소유권을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="f433ee5a4f5ef551015f8cbf8189774e6d42e0da" translate="yes" xml:space="preserve">
          <source>Unlocks the associated mutex from shared mode. Effectively calls &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt;.</source>
          <target state="translated">공유 모드에서 연관된 뮤텍스를 잠금 해제합니다. 효과적으로 &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="961e1771431741648b7410afa7f25aec8f8bb6ba" translate="yes" xml:space="preserve">
          <source>Unlocks the mutex if its level of ownership is &lt;code&gt;1&lt;/code&gt; (there was exactly one more call to &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; than there were calls to &lt;code&gt;unlock()&lt;/code&gt; made by this thread), reduces the level of ownership by 1 otherwise.</source>
          <target state="translated">소유권 수준이 &lt;code&gt;1&lt;/code&gt; 인 경우 뮤텍스 를 &lt;code&gt;unlock()&lt;/code&gt; 이 스레드에서 만든 unlock ()에 대한 호출보다 &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 대한 호출이 정확히 하나 더 있음 ). 그렇지 않으면 소유권 수준을 1만큼 줄입니다.</target>
        </trans-unit>
        <trans-unit id="3292cba2e9fa684816c3433f5e680ff1211985aa" translate="yes" xml:space="preserve">
          <source>Unlocks the mutex.</source>
          <target state="translated">뮤텍스를 잠금 해제합니다.</target>
        </trans-unit>
        <trans-unit id="e5ecb1ac5a3284b964b98f95170550776c6f7221" translate="yes" xml:space="preserve">
          <source>Unnamed functions can be generated by &lt;a href=&quot;lambda&quot;&gt;lambda-expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lambda&quot;&gt;람다 식으로&lt;/a&gt; 이름없는 함수를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4abed0ca00f10480f822ed4f5c54c15d912133a" translate="yes" xml:space="preserve">
          <source>Unnamed namespaces</source>
          <target state="translated">이름이없는 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="ce07e4c5885039551bddbc7d0f27189dfc040aaa" translate="yes" xml:space="preserve">
          <source>Unnamed namespaces as well as all namespaces declared directly or indirectly within an unnamed namespace have &lt;a href=&quot;storage_duration#Linkage&quot;&gt;internal linkage&lt;/a&gt;, which means that any name that is declared within an unnamed namespace has internal linkage.</source>
          <target state="translated">명명되지 않은 네임 스페이스와 이름이없는 네임 스페이스 내에서 직접 또는 간접적으로 선언 된 모든 네임 스페이스는 이름이없는 네임 스페이스 내에 선언 된 이름에 &lt;a href=&quot;storage_duration#Linkage&quot;&gt;내부 연결&lt;/a&gt; 이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="55c746743e689c2f62e5b9408423fdd2d1439715" translate="yes" xml:space="preserve">
          <source>Unordered associative containers</source>
          <target state="translated">정렬되지 않은 연관 컨테이너</target>
        </trans-unit>
        <trans-unit id="67512286f8974c10c046fc1f0f6675019780544f" translate="yes" xml:space="preserve">
          <source>Unordered associative containers are &lt;a href=&quot;container&quot;&gt;Containers&lt;/a&gt; that provide fast lookup of objects based on keys. Worst case complexity is linear but on average much faster for most of the operations.</source>
          <target state="translated">정렬되지 않은 연관 컨테이너는 키를 기반으로 객체를 빠르게 조회 할 수 있는 &lt;a href=&quot;container&quot;&gt;컨테이너&lt;/a&gt; 입니다. 최악의 복잡성은 선형이지만 대부분의 작업에서 평균적으로 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="5721c8ff7733bb174444b2a6b021b024c56a1897" translate="yes" xml:space="preserve">
          <source>Unordered associative containers are parametrized by &lt;code&gt;Key&lt;/code&gt;; &lt;code&gt;Hash&lt;/code&gt;, a &lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt; function object which acts as hash function on &lt;code&gt;Key&lt;/code&gt;; and &lt;code&gt;Pred&lt;/code&gt;, a &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; evaluating equivalence between &lt;code&gt;Key&lt;/code&gt;s. &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; also have a mapped type &lt;code&gt;T&lt;/code&gt; associated with the &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">정렬되지 않은 연관 컨테이너는 &lt;code&gt;Key&lt;/code&gt; 로 매개 변수화됩니다 . &lt;code&gt;Hash&lt;/code&gt; , &lt;code&gt;Key&lt;/code&gt; 에서 해시 함수 역할을 하는 &lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt; 함수 객체 ; 그리고 &lt;code&gt;Key&lt;/code&gt; 사이 의 동등성을 평가 하는 &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate 인 &lt;/a&gt; &lt;code&gt;Pred&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; 에는 &lt;code&gt;Key&lt;/code&gt; 와 연관된 맵핑 된 유형 &lt;code&gt;T&lt;/code&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27d0b13503ae28a6d2a746765f82094c67a9edd8" translate="yes" xml:space="preserve">
          <source>Unordered associative containers implement unsorted (hashed) data structures that can be quickly searched (O(1) amortized, O(n) worst-case complexity).</source>
          <target state="translated">정렬되지 않은 연관 컨테이너는 신속하게 검색 할 수있는 분류되지 않은 (해시 된) 데이터 구조를 구현합니다 (O (1) 할부 상환, O (n) 최악의 경우 복잡성).</target>
        </trans-unit>
        <trans-unit id="b3e4ddc4a7977312b5ea810e7307eb4d25f9ced4" translate="yes" xml:space="preserve">
          <source>Unordered associative containers in the standard library</source>
          <target state="translated">표준 라이브러리에서 정렬되지 않은 연관 컨테이너</target>
        </trans-unit>
        <trans-unit id="9cbf323cb4f143925595576784d5b591b9699888" translate="yes" xml:space="preserve">
          <source>Unordered associative containers meet the requirements of &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;. For &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; the requirements of &lt;code&gt;value_type&lt;/code&gt; in &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; apply to &lt;code&gt;key_type&lt;/code&gt; and &lt;code&gt;mapped_type&lt;/code&gt; (not to &lt;code&gt;value_type&lt;/code&gt;).</source>
          <target state="translated">정렬되지 않은 연관 컨테이너는 &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; 의 요구 사항을 충족합니다 . 에 대한 &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; 의 요구 사항 &lt;code&gt;value_type&lt;/code&gt; 에 &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer이&lt;/a&gt; 적용 &lt;code&gt;key_type&lt;/code&gt; 및 &lt;code&gt;mapped_type&lt;/code&gt; (하지에 &lt;code&gt;value_type&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c05e882164dc6c352b2a91db5033a7f29679961d" translate="yes" xml:space="preserve">
          <source>Unordered dynamic initialization</source>
          <target state="translated">정렬되지 않은 동적 초기화</target>
        </trans-unit>
        <trans-unit id="6f584009e4c537a97fa6a23c2a4e0d998b8f9266" translate="yes" xml:space="preserve">
          <source>Unordered map is an associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity.</source>
          <target state="translated">정렬되지 않은 맵은 고유 키와 키-값 쌍을 포함하는 연관 컨테이너입니다. 요소의 검색, 삽입 및 제거에는 평균 상수 시간이 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="a040e6bfa2ff6a84c4d4e54ec666b82a142217ba" translate="yes" xml:space="preserve">
          <source>Unordered multimap is an unordered associative container that supports equivalent keys (an unordered_multimap may contain multiple copies of each key value) and that associates values of another type with the keys. The unordered_multimap class supports forward iterators. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">정렬되지 않은 멀티 맵은 동등한 키를 지원하고 (정렬되지 않은 멀티 맵에는 각 키 값의 여러 사본이 포함될 수 있음) 다른 유형의 값을 키와 연관시키는 정렬되지 않은 연관 컨테이너입니다. unorder_multimap 클래스는 순방향 반복자를 지원합니다. 검색, 삽입 및 제거에는 평균 상수 시간이 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="781e73a9d10b79ea8423bbe4c282e042b203ed02" translate="yes" xml:space="preserve">
          <source>Unordered multiset is an associative container that contains set of possibly non-unique objects of type Key. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">정렬되지 않은 멀티 세트는 Key 유형의 고유하지 않은 개체 세트를 포함하는 연관 컨테이너입니다. 검색, 삽입 및 제거에는 평균 상수 시간이 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="6c35c1e1852ab51c8cfda8139fbce10f60da69d7" translate="yes" xml:space="preserve">
          <source>Unordered set is an associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">비 순차 세트는 키 유형의 고유 한 오브젝트 세트를 포함하는 연관 컨테이너입니다. 검색, 삽입 및 제거에는 평균 상수 시간이 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="20ec84b0a684780da8ecd14376ab54e3d64c049a" translate="yes" xml:space="preserve">
          <source>UnorderedAssociativeContainer</source>
          <target state="translated">UnorderedAssociativeContainer</target>
        </trans-unit>
        <trans-unit id="5ed38d76cf76e990be50933f309543cd72253e57" translate="yes" xml:space="preserve">
          <source>Unqualified and qualified name lookup rules for class members are detailed in &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;.</source>
          <target state="translated">클래스 멤버에 대한 규정되지 않은 규정 된 이름 조회 규칙은 &lt;a href=&quot;lookup&quot;&gt;이름 조회에&lt;/a&gt; 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a712c79b38b9542c96589abf3e1dda8d1042e2a4" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;abs&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;std::abs&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;abs&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수 없으면 인수 종속 조회로 인해 &lt;code&gt;std::abs&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc119a198d533d4b0bbb7710d68460cff957292e" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;acos&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/acos&quot;&gt;std::acos&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;acos&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수없는 경우 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/acos&quot;&gt;std::acos&lt;/a&gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f215557e10fbc19791a7df65c388833c1a7dd11c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;asin&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;std::asin&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;asin&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수 없으면 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;std::asin&lt;/a&gt;&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9f3c5a7de17deb7da848c19ab6e3fce9f64dca13" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;atan2&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;std::atan2&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;atan2&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수없는 경우 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;std::atan2&lt;/a&gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa3a701b0983c693521c1ddd5947f77acceaace8" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;atan&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;std::atan&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;atan&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수없는 경우 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;std::atan&lt;/a&gt;&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="39d51e27856339476f1d01bf7073fed7dc2b3dbb" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;cos&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;std::cos&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;cos&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수 없으면 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;std::cos&lt;/a&gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dbf3b6db25b09f0814d7e5a7fef391df5875da2a" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;cosh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;std::cosh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;cosh&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수없는 경우 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;std::cosh&lt;/a&gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e8abb5dd0c771afacf6766178d00da2ba065a2ec" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;exp&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;exp&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수 없으면 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd8575417503ea5be7c9d78fb49d54a74a502a5c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;log10&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/log10&quot;&gt;std::log10&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;log10&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수 없으면 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/log10&quot;&gt;std::log10&lt;/a&gt;&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="42fd42135c1c4e85d3b6e8229754e9d9e009486f" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;log&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;log&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수 없으면 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a8f42595543cd910c448cec8e9b024326f375da5" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;pow&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;pow&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수 없으면 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b45579c9b454c00347186dba4b670a1612acd28" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sin&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;sin&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수 없으면 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="609a5411e92bb2e442b9695a0c7f1a35b0bcda38" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sinh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;std::sinh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;sinh&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수 없으면 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;std::sinh&lt;/a&gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c0b2457b178abb1fbcd11ec0b12722a8184da253" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sqrt&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;sqrt&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수 없으면 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa91ca5ff514fc595bf3f51f24fdd9e313d69b9c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;tan&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;std::tan&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;tan&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수 없으면 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;std::tan&lt;/a&gt;&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d2d13c70f9b62f9ac241cafdef0b167740b73e83" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;tanh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;std::tanh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">규정되지 않은 함수 ( &lt;code&gt;tanh&lt;/code&gt; )가 계산을 수행하는 데 사용됩니다. 이러한 기능을 사용할 수없는 경우 인수 종속 조회로 인해 &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;std::tanh&lt;/a&gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e538cf96d743b1733d4cf064e3d13d77d3aa646" translate="yes" xml:space="preserve">
          <source>Unqualified identifiers</source>
          <target state="translated">규정되지 않은 식별자</target>
        </trans-unit>
        <trans-unit id="30683cf405f082292810a7676e96130ea1ebbac6" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup</source>
          <target state="translated">정규화되지 않은 이름 조회</target>
        </trans-unit>
        <trans-unit id="42e9848a70274fa4e3ee76d98636ebc5974dc7bd" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup of the name used to the left of the function-call operator (and, equivalently, operator in an expression) is described in &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;.</source>
          <target state="translated">함수 호출 연산자 (및 표현식의 연산자)의 왼쪽에 사용 된 이름의 규정되지 않은 이름 조회는 &lt;a href=&quot;adl&quot;&gt;인수 종속 조회에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="79648146553ba52f72840dfe58fd2d9c089e5fda" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup that finds static members of &lt;code&gt;B&lt;/code&gt;, nested types of &lt;code&gt;B&lt;/code&gt;, and enumerators declared in &lt;code&gt;B&lt;/code&gt; is unambiguous even if there are multiple non-virtual base subobjects of type &lt;code&gt;B&lt;/code&gt; in the inheritance tree of the class being examined:</source>
          <target state="translated">검사중인 클래스의 상속 트리에 &lt;code&gt;B&lt;/code&gt; 유형의 가상이 아닌 기본 하위 오브젝트가 여러 개 있더라도 &lt;code&gt;B&lt;/code&gt; 의 정적 멤버 , 중첩 된 &lt;code&gt;B&lt;/code&gt; 유형 및 &lt;code&gt;B&lt;/code&gt; 에 선언 된 열거자를 찾는 규정되지 않은 이름 조회 는 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="f0214ce4cc35b4369eeab0b471b29274746a99bb" translate="yes" xml:space="preserve">
          <source>Unregisters a range earlier registered with &lt;code&gt;&lt;a href=&quot;declare_no_pointers&quot;&gt;std::declare_no_pointers&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">이전에 &lt;code&gt;&lt;a href=&quot;declare_no_pointers&quot;&gt;std::declare_no_pointers&lt;/a&gt;()&lt;/code&gt; 등록 된 범위를 등록 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="866d0de5757a1581405e841976c7443463cb9f92" translate="yes" xml:space="preserve">
          <source>Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">계약과 관련이없는 부동 소수점 산술의 중간 결과는 해당 유형으로 표시된 것과 다른 범위와 정밀도를 가질 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="c38c9bea005b30ba6a290df566acf1664518f308" translate="yes" xml:space="preserve">
          <source>Unscoped enumeration</source>
          <target state="translated">범위가없는 열거</target>
        </trans-unit>
        <trans-unit id="6222e920759d4ffc44da225d807dad755988a0aa" translate="yes" xml:space="preserve">
          <source>Unscoped enumeration type</source>
          <target state="translated">범위가없는 열거 형</target>
        </trans-unit>
        <trans-unit id="326065904fc6d55f14165c03f41503850d0a81df" translate="yes" xml:space="preserve">
          <source>Unsequenced execution policies are the only case where function calls are</source>
          <target state="translated">순서없는 실행 정책은 함수 호출이 유일한 경우입니다</target>
        </trans-unit>
        <trans-unit id="001f5aa9e95578bdbf624cdd233afcd23b9e1b0b" translate="yes" xml:space="preserve">
          <source>Unsets the formatting flags identified by &lt;code&gt;flags&lt;/code&gt;.</source>
          <target state="translated">에 의해 식별 된 서식 플래그를 해제합니다 &lt;code&gt;flags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e58bf16bb4075ebd2ecdad4cd86deb15d7942bb7" translate="yes" xml:space="preserve">
          <source>Unsigned integer arithmetic is always performed modulo 2n</source>
          <target state="translated">부호없는 정수 산술은 항상 모듈로 2n을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="73db4e2949bacc582e416479a510daae92386ab7" translate="yes" xml:space="preserve">
          <source>Unsigned integer of at least 32 bits</source>
          <target state="translated">32 비트 이상의 부호없는 정수</target>
        </trans-unit>
        <trans-unit id="4e7bbf9fbab3d07bb38581701f9d99705350278e" translate="yes" xml:space="preserve">
          <source>Unsigned integer type (usually &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">부호없는 정수 유형 (일반적으로 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1569ce9087643318f5b374c7177d610cac24614f" translate="yes" xml:space="preserve">
          <source>Unsigned integers : maximum value</source>
          <target state="translated">부호없는 정수 : 최대 값</target>
        </trans-unit>
        <trans-unit id="6fe5f2a61d9b8437ce58885d4aebe34e13639a40" translate="yes" xml:space="preserve">
          <source>UnsignedIntegral</source>
          <target state="translated">UnsignedIntegral</target>
        </trans-unit>
        <trans-unit id="5097984a5f9238c911d1b186817d23c6f3bcfe68" translate="yes" xml:space="preserve">
          <source>Unspecified order</source>
          <target state="translated">지정되지 않은 주문</target>
        </trans-unit>
        <trans-unit id="d37821663cc5797b1388ccb9821c1c66f6dc7be6" translate="yes" xml:space="preserve">
          <source>Unspecified.</source>
          <target state="translated">Unspecified.</target>
        </trans-unit>
        <trans-unit id="42bff37b51ec7b1fccab4a5d361519fa088bb006" translate="yes" xml:space="preserve">
          <source>Unsupported C headers</source>
          <target state="translated">지원되지 않는 C 헤더</target>
        </trans-unit>
        <trans-unit id="3910cc8152231b6ede905978fe57cac1a0d03d97" translate="yes" xml:space="preserve">
          <source>Until &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558&quot;&gt;CWG 1558&lt;/a&gt; (a C++14 defect), unused parameters in &lt;a href=&quot;../language/type_alias&quot;&gt;alias templates&lt;/a&gt; were not guaranteed to ensure SFINAE and could be ignored, so earlier compilers require a more complex definition of &lt;code&gt;void_t&lt;/code&gt;, such as.</source>
          <target state="translated">까지 &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558&quot;&gt;CWG 1558&lt;/a&gt; (A C ++ 14 결함)에서 사용되지 않는 매개 변수 &lt;a href=&quot;../language/type_alias&quot;&gt;별칭 템플릿은&lt;/a&gt; 그래서 이전 컴파일러의 더 복잡한 정의가 필요 SFINAE을 보장하기 위해 보장되지 않은 무시 될 수 &lt;code&gt;void_t&lt;/code&gt; 을 같은.</target>
        </trans-unit>
        <trans-unit id="f7718ae633302ee609828ca76d3c8d3d51cfea89" translate="yes" xml:space="preserve">
          <source>Until C++11, &lt;code&gt;auto&lt;/code&gt; had the semantic of a &lt;a href=&quot;storage_duration&quot;&gt;storage duration specifier&lt;/a&gt;.</source>
          <target state="translated">C ++ 11까지 &lt;code&gt;auto&lt;/code&gt; 는 &lt;a href=&quot;storage_duration&quot;&gt;저장 기간 지정자&lt;/a&gt; 의 의미를 가졌습니다 .</target>
        </trans-unit>
        <trans-unit id="965548c423c2af9ebf773d28ec036a9f63c4b83f" translate="yes" xml:space="preserve">
          <source>Until C++11, aggregate initialization could not be used in a constructor initializer list due to syntax restrictions.</source>
          <target state="translated">C ++ 11까지는 구문 제한으로 인해 생성자 이니셜 라이저 목록에서 집계 초기화를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9f555151d6b7d5f7a9ff7843af6a57a54b0a5819" translate="yes" xml:space="preserve">
          <source>Until C++11, classes that overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt; were not CopyConstructible and thus weren't usable in the standard library containers. As of C++11, the standard library uses &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; whenever the address of an object is needed.</source>
          <target state="translated">C ++ 11까지, &lt;code&gt;operator&amp;amp;&lt;/code&gt; 에 오버로드 된 클래스는 CopyConstructible이 아니므로 표준 라이브러리 컨테이너에서 사용할 수 없었습니다. C ++ 11부터 표준 라이브러리는 객체의 주소가 필요할 때마다 &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="9f5f5ea9e92fa642a1d809852878c2987d57848b" translate="yes" xml:space="preserve">
          <source>Until C++11, it was unspecified whether &lt;code&gt;basic_streambuf&lt;/code&gt; or any of its derived classes is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421&quot;&gt;LWG issue 421&lt;/a&gt;), and different C++ library implementations provided different options.</source>
          <target state="translated">C ++ 11까지는 &lt;code&gt;basic_streambuf&lt;/code&gt; 또는 파생 클래스 중 하나가 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; ( &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421&quot;&gt;LWG issue 421&lt;/a&gt; ) 인지 여부를 지정 하지 않았 으며 다른 C ++ 라이브러리 구현이 다른 옵션을 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="328855c59d216dad3422e6e98a3125cd6d816dcf" translate="yes" xml:space="preserve">
          <source>Until C++11, narrowing conversions were permitted in aggregate initialization, but they are no longer allowed, except that, as of C++20, they are allowed when aggregate initialization uses round parentheses.</source>
          <target state="translated">C ++ 11까지는 집계 초기화에서 축소 변환이 허용되었지만 C ++ 20에서 집계 초기화가 둥근 괄호를 사용할 때 허용되는 것을 제외하고는 더 이상 변환이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e17e7cb9fc8a5970b94833c26c3d5625cb274e1" translate="yes" xml:space="preserve">
          <source>Until C++11, the rounding direction of the quotient and the sign of the remainder in the &lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;built-in division and remainder operators&lt;/a&gt; was implementation-defined if either of the operands was negative, but it was well-defined in &lt;code&gt;std::div&lt;/code&gt;.</source>
          <target state="translated">C ++ 11까지는 &lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;내장 분할 및 나머지 연산자에서&lt;/a&gt; 몫의 반올림 방향과 나머지의 부호가 피연산자 중 하나가 음수 인 경우 구현 정의되었지만 &lt;code&gt;std::div&lt;/code&gt; 에 잘 정의되어 있습니다. .</target>
        </trans-unit>
        <trans-unit id="2dd75578b3cf163fd9cdf707fa3febbd8933afe1" translate="yes" xml:space="preserve">
          <source>Until C++11, which introduced &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_signal_fence&quot;&gt;std::atomic_signal_fence&lt;/a&gt;&lt;/code&gt;, about the only thing a strictly conforming program could do in a signal handler was to assign a value to a &lt;code&gt;volatile static std::sig_atomic_t&lt;/code&gt; variable and promptly return.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_signal_fence&quot;&gt;std::atomic_signal_fence&lt;/a&gt;&lt;/code&gt; 를 도입 한 C ++ 11까지 신호 처리기에서 엄격하게 준수하는 프로그램이 할 수있는 유일한 일은 &lt;code&gt;volatile static std::sig_atomic_t&lt;/code&gt; 변수에 값을 할당 하고 즉시 리턴하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4d3ae3907e74b1b45f48b10e1e68c5b46d8f4619" translate="yes" xml:space="preserve">
          <source>Until C++14, the direct-initialization form &lt;code&gt;T a {args..}&lt;/code&gt; did not permit brace elision.</source>
          <target state="translated">C ++ 14까지, 직접 초기화 형식 &lt;code&gt;T a {args..}&lt;/code&gt; 는 중괄호 제거를 허용하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7f752f60fcef0ea971b808f8f6eaf483ad584079" translate="yes" xml:space="preserve">
          <source>Until C++17, a function could not return a tuple using list-initialization:</source>
          <target state="translated">C ++ 17까지는 함수가리스트 초기화를 사용하여 튜플을 반환 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="58fb383e77b7fb0335ad97e0f3c210c1e1d6f098" translate="yes" xml:space="preserve">
          <source>Until the introduction of explicit conversion functions in C++11, designing a class that should be usable in boolean contexts (e.g. &lt;code&gt;if(obj) { ... }&lt;/code&gt;) presented a problem: given a user-defined conversion function, such as &lt;code&gt;T::operator bool() const;&lt;/code&gt;, the implicit conversion sequence allowed one additional standard conversion sequence after that function call, which means the resultant &lt;code&gt;bool&lt;/code&gt; could be converted to &lt;code&gt;int&lt;/code&gt;, allowing such code as &lt;code&gt;obj &amp;lt;&amp;lt; 1;&lt;/code&gt; or &lt;code&gt;int i = obj;&lt;/code&gt;.</source>
          <target state="translated">C ++ 11에 명시 적 변환 함수가 도입 될 때까지 부울 컨텍스트 (예 : &lt;code&gt;if(obj) { ... }&lt;/code&gt; ) 에서 사용할 수있는 클래스를 설계하면 &lt;code&gt;T::operator bool() const;&lt;/code&gt; 와 같은 사용자 정의 변환 함수가 제공되면 문제가 발생했습니다. :: 연산자 bool () const; , 암시 적 변환 시퀀스는 해당 함수 호출 후에 하나의 추가 표준 변환 시퀀스를 허용합니다. 이는 결과 &lt;code&gt;bool&lt;/code&gt; 이 &lt;code&gt;int&lt;/code&gt; 로 변환 되어 &lt;code&gt;obj &amp;lt;&amp;lt; 1;&lt;/code&gt; 과 같은 코드를 허용 함을 의미합니다 . 또는 &lt;code&gt;int i = obj;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b46999a4d771dcf596a583d2c8bf0dbc1bb017bc" translate="yes" xml:space="preserve">
          <source>Until variable templates were introduced in C++14, parametrized variables were typically implemented as either static data members of class templates or as constexpr function templates returning the desired values.</source>
          <target state="translated">변수 템플릿이 C ++ 14에 도입 될 때까지 매개 변수화 된 변수는 일반적으로 클래스 템플릿의 정적 데이터 멤버 또는 원하는 값을 반환하는 constexpr 함수 템플릿으로 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="c65bb8e4818155db56e2464c0be89b93b4aa7fb0" translate="yes" xml:space="preserve">
          <source>Upon return to the scope of &lt;code&gt;setjmp&lt;/code&gt;, all accessible objects, floating-point status flags, and other components of the abstract machine have the same values as they had when &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; was executed, except for the non-&lt;a href=&quot;../../language/cv&quot;&gt;volatile&lt;/a&gt; local variables in &lt;code&gt;setjmp&lt;/code&gt;'s scope, whose values are indeterminate if they have been changed since the setjmp invocation.</source>
          <target state="translated">의 범위에 반환에 &lt;code&gt;setjmp&lt;/code&gt; 는 그들이 때 한대로, 모든 사용자 보조 기능을 구현하는 객체는, 부동 소수점 상태 플래그와 추상 기계의 다른 구성 요소는 같은 값을 &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; 실행 된, 비를 제외하고 &lt;a href=&quot;../../language/cv&quot;&gt;휘발성&lt;/a&gt; 에서 지역 변수 &lt;code&gt;setjmp&lt;/code&gt; 는 setjmp 호출 이후에 값이 변경된 경우 값이 결정되지 않는의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="30e91e701960bb8a2f2ddc9e70cec3e0f356f152" translate="yes" xml:space="preserve">
          <source>Uppercase version of &lt;code&gt;ch&lt;/code&gt; or unmodified &lt;code&gt;ch&lt;/code&gt; if no uppercase version is listed in the current C locale.</source>
          <target state="translated">의 대문자 버전 &lt;code&gt;ch&lt;/code&gt; 또는 수정되지 않은 &lt;code&gt;ch&lt;/code&gt; 더 대문자 버전은 현재 C 로케일에 표시되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="e2fa3e294a40d353ff7bd0279d846fe85eb6a460" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;mem_fn&lt;/code&gt; to store and execute a member function and a member object:</source>
          <target state="translated">&lt;code&gt;mem_fn&lt;/code&gt; 을 사용 하여 멤버 함수 및 멤버 오브젝트를 저장하고 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ccd4cdfea5815983783eb398f954b34dd3308ca2" translate="yes" xml:space="preserve">
          <source>Use ECMAScript rules to construct strings in &lt;code&gt;&lt;a href=&quot;regex_replace&quot;&gt;std::regex_replace&lt;/a&gt;&lt;/code&gt; (&lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-15.5.4.11&quot;&gt;syntax documentation&lt;/a&gt;)</source>
          <target state="translated">ECMAScript 규칙을 사용하여 &lt;code&gt;&lt;a href=&quot;regex_replace&quot;&gt;std::regex_replace&lt;/a&gt;&lt;/code&gt; 에서 문자열을 구성하십시오 ( &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-15.5.4.11&quot;&gt;구문 문서&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="815aa29e99f1766294548e7008c913f3fc5336f4" translate="yes" xml:space="preserve">
          <source>Use ECMAScript rules to construct strings in &lt;code&gt;&lt;a href=&quot;regex_replace&quot;&gt;std::regex_replace&lt;/a&gt;&lt;/code&gt; (&lt;a href=&quot;https://ecma-international.org/ecma-262/5.1/#sec-15.5.4.11&quot;&gt;syntax documentation&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2ca269005572f7dcc4f93975b5006fe75b32fe" translate="yes" xml:space="preserve">
          <source>Use POSIX</source>
          <target state="translated">POSIX 사용</target>
        </trans-unit>
        <trans-unit id="59088c12cff257aabcfd96c2bff5eb6d63196ace" translate="yes" xml:space="preserve">
          <source>Use of an indeterminate value obtained by default-initializing a non-class variable of any type is &lt;a href=&quot;ub&quot;&gt;undefined behavior&lt;/a&gt; (in particular, it may be a &lt;a href=&quot;objects#Object_representation_and_value_representation&quot;&gt;trap representation&lt;/a&gt;), except in the following cases:</source>
          <target state="translated">다음과 같은 경우를 제외하고 모든 유형의 비 클래스 변수를 기본 초기화하여 얻은 불확실한 값의 사용은 &lt;a href=&quot;ub&quot;&gt;정의되지 않은 동작&lt;/a&gt; (특히 &lt;a href=&quot;objects#Object_representation_and_value_representation&quot;&gt;트랩 표현&lt;/a&gt; 일 수 있음 )입니다.</target>
        </trans-unit>
        <trans-unit id="1343357d8857f07ed216045e4630d2360702830a" translate="yes" xml:space="preserve">
          <source>Use of pImpl requires a dedicated translation unit (a header-only library cannot use pImpl), introduces an additional class, a set of forwarding functions, and, if allocators are used, exposes the implementation detail of allocator use in the public interface.</source>
          <target state="translated">pImpl을 사용하려면 전용 변환 장치 (헤더 전용 라이브러리는 pImpl을 사용할 수 없음)가 필요하고 추가 클래스, 전달 함수 세트가 도입되며 할당자를 사용하는 경우 공용 인터페이스에서 할당 기 사용의 구현 세부 사항이 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="5c95344b6a2f2f118527f061626aec54628cfeac" translate="yes" xml:space="preserve">
          <source>Use of this invalid value as an argument to any &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; member taking a value of this type is undefined behaviour</source>
          <target state="translated">이 유형의 값을 취하는 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; 멤버에 대한 인수로이 유효하지 않은 값을 사용하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="6eb61fe88f9155e92fd5505231d51581c0a1f378" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript&quot;&gt;Modified ECMAScript regular expression grammar&lt;/a&gt;</source>
          <target state="translated">사용 &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript&quot;&gt;수정 ECMAScript를 정규 표현식 문법을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b59f8d4a6e7623991a4148e772aefe99cb9c959" translate="yes" xml:space="preserve">
          <source>Use the basic POSIX regular expression grammar (&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03&quot;&gt;grammar documentation&lt;/a&gt;).</source>
          <target state="translated">기본 POSIX 정규식 문법 ( &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03&quot;&gt;문법 문서&lt;/a&gt; )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f0e8ac3c56654030efe86b4a33ae6ba71c0945c6" translate="yes" xml:space="preserve">
          <source>Use the basic POSIX regular expression grammar (&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03&quot;&gt;grammar documentation&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4032118ad7e10c8a56fe81c51513bcd0f4198612" translate="yes" xml:space="preserve">
          <source>Use the extended POSIX regular expression grammar (&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04&quot;&gt;grammar documentation&lt;/a&gt;).</source>
          <target state="translated">확장 POSIX 정규식 문법을 사용하십시오 ( &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04&quot;&gt;문법 문서&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0650df99458dcb574ee84ae2dbe24ef7ac04fc27" translate="yes" xml:space="preserve">
          <source>Use the extended POSIX regular expression grammar (&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04&quot;&gt;grammar documentation&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdfc5f80485169681a19ba23803d6f84ff4e293" translate="yes" xml:space="preserve">
          <source>Use the regular expression grammar used by the</source>
          <target state="translated">에서 사용하는 정규식 문법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6f72b04e0e8a80cecbd0a1176096ac1763ecf62" translate="yes" xml:space="preserve">
          <source>Used as a more readable equivalent to the traditional &lt;a href=&quot;for&quot;&gt; for loop&lt;/a&gt; operating over a range of values, such as all elements in a container.</source>
          <target state="translated">컨테이너의 모든 요소와 같이 다양한 범위의 값 에 대해 전통적인 &lt;a href=&quot;for&quot;&gt;for 루프&lt;/a&gt; 작동에 비해 읽기 쉬운 것으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5a1c568d8c824c8779a7fbd4ddf0353bf241da96" translate="yes" xml:space="preserve">
          <source>Used fields</source>
          <target state="translated">중고 필드</target>
        </trans-unit>
        <trans-unit id="df4ac21ba90d03bbec4f8d92680ff358bb022c1a" translate="yes" xml:space="preserve">
          <source>Used to mark a &lt;a href=&quot;../language/class_template&quot;&gt;template definition&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../language/class_template&quot;&gt;템플릿 정의&lt;/a&gt; 를 표시하는 데 사용</target>
        </trans-unit>
        <trans-unit id="af59dbcc1c5fb76dabc78981244f1492f92bd30a" translate="yes" xml:space="preserve">
          <source>Used to refer to the character type</source>
          <target state="translated">문자 유형을 나타내는 데 사용</target>
        </trans-unit>
        <trans-unit id="452240ee9951387e7059a7bfdc9cc878fb58e6e5" translate="yes" xml:space="preserve">
          <source>Used to refer to the character type.</source>
          <target state="translated">문자 유형을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0411cff330fe1f926e098add76bac8d23f3a24cd" translate="yes" xml:space="preserve">
          <source>Used when actual size of the object must be known.</source>
          <target state="translated">객체의 실제 크기를 알아야 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cd3a7677f14605e188f81a1607ce0b998a59e8fc" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to ignore the remaining portion of the loop using conditional statements.</source>
          <target state="translated">조건문을 사용하여 루프의 나머지 부분을 무시하는 것이 어색한 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73641814b8ae560f3493eb824a0db1bde1f528d6" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to terminate the loop using the condition expression and conditional statements.</source>
          <target state="translated">조건 표현식과 조건문을 사용하여 루프를 종료하는 것이 어색한 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e80aa66e106a415e8288da7170c66b3a43f1b6c5" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise impossible to transfer control to the desired location using other statements.</source>
          <target state="translated">다른 설명을 사용하여 원하는 위치로 제어를 이전 할 수없는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7062a1fb9e1b49180bc64e78c1788d8e78b97581" translate="yes" xml:space="preserve">
          <source>Used where code needs to be executed based on a run-time or compile-time condition.</source>
          <target state="translated">런타임 또는 컴파일 시간 조건에 따라 코드를 실행해야하는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bf16483f532d4a8853cf1010caa2cb57d0f33c2f" translate="yes" xml:space="preserve">
          <source>Used where the &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;dynamic type&lt;/a&gt; of a &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic object&lt;/a&gt; must be known and for static type identification.</source>
          <target state="translated">&lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;다형성 객체&lt;/a&gt; 의 &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;동적 유형&lt;/a&gt; 을 알아야하고 정적 유형을 식별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="42d90e90aadfee8047aec9690cf0574d0347d7d2" translate="yes" xml:space="preserve">
          <source>User code should usually use &lt;code&gt;std::chrono::clock_cast&lt;/code&gt;, which provides a generic interface to convert time points between clocks, rather than call these functions directly.</source>
          <target state="translated">사용자 코드는 일반적으로 &lt;code&gt;std::chrono::clock_cast&lt;/code&gt; 합니다.이 함수는 이러한 함수를 직접 호출하지 않고 클럭간에 시점을 변환하는 일반 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="22f079a53befe874a015e16af5dac8a9dbe1d7c3" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../new/operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">글로벌 &lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt; 의 사용자 교체 버전</target>
        </trans-unit>
        <trans-unit id="beecf2d4915648f8f0efab35c62b4b57d5f5b1df" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;a href=&quot;operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;strong&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">글로벌 &lt;a href=&quot;operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; 및 &lt;strong&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/strong&gt; 의 사용자 교체 버전&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36a2cff95d451b8ddda6e6fad777fc4eedb46043" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;strong&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/strong&gt; and &lt;a href=&quot;operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">글로벌 &lt;strong&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/strong&gt; 및 &lt;a href=&quot;operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt; 의 사용자 교체 버전</target>
        </trans-unit>
        <trans-unit id="f9aac68f1811d0c886372a7b6aa12dfd47145f36" translate="yes" xml:space="preserve">
          <source>User specializations may define the member type &lt;code&gt;iterator_concept&lt;/code&gt; to one of &lt;a href=&quot;iterator_tags&quot;&gt;iterator category tags&lt;/a&gt;, to indicate conformance to the iterator concepts.</source>
          <target state="translated">사용자 특수화는 &lt;code&gt;iterator_concept&lt;/code&gt; 멤버 유형 을 &lt;a href=&quot;iterator_tags&quot;&gt;iterator 카테고리 태그&lt;/a&gt; 중 하나에 정의 하여 iterator 개념 준수를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="691620a9d9530e81a0d5cd25eb278071f62c4739" translate="yes" xml:space="preserve">
          <source>User-Defined Literals</source>
          <target state="translated">사용자 정의 리터럴</target>
        </trans-unit>
        <trans-unit id="d55e108d604fa5cfa1e00711a9ffe9ad9af9acb8" translate="yes" xml:space="preserve">
          <source>User-defined Literals for std::complex</source>
          <target state="translated">std :: complex에 대한 사용자 정의 리터럴</target>
        </trans-unit>
        <trans-unit id="66b100ca6f92096c7cc2adfb8fd94dcf564c734d" translate="yes" xml:space="preserve">
          <source>User-defined character traits may be used to provide &lt;a href=&quot;http://www.gotw.ca/gotw/029.htm&quot;&gt;case-insensitive comparison&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.gotw.ca/gotw/029.htm&quot;&gt;대소 문자를 구분하지 않는 비교&lt;/a&gt; 를 제공하기 위해 사용자 정의 문자 특성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="521384c0aef8e04b593ebebfeb20da581eaab716" translate="yes" xml:space="preserve">
          <source>User-defined classes and enumerations that implement the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; are required to overload the bitwise arithmetic operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt;, and may optionally overload the shift operators &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;operator&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;operator&amp;lt;&amp;lt;=&lt;/code&gt;. The canonical implementations usually follow the pattern for binary arithmetic operators described above.</source>
          <target state="translated">비트 단위 산술 연산자를 오버로드하려면 &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; 의 요구 사항을 구현하는 사용자 정의 클래스 및 열거 가 필요합니다. &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;operator|&lt;/code&gt; , &lt;code&gt;operator^&lt;/code&gt; , &lt;code&gt;operator~&lt;/code&gt; , &lt;code&gt;operator&amp;amp;=&lt;/code&gt; , &lt;code&gt;operator|=&lt;/code&gt; 및 &lt;code&gt;operator^=&lt;/code&gt; 이며, 선택적으로 시프트 연산자 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;operator&amp;gt;&amp;gt;=&lt;/code&gt; 및 &lt;code&gt;operator&amp;lt;&amp;lt;=&lt;/code&gt; 오버로드 할 수 있습니다 . 표준 구현은 일반적으로 위에서 설명한 이진 산술 연산자의 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="41ab182df7e7de75a62a46e254284df8495915ff" translate="yes" xml:space="preserve">
          <source>User-defined classes that provide array-like access that allows both reading and writing typically define two overloads for &lt;code&gt;operator[]&lt;/code&gt;: const and non-const variants:</source>
          <target state="translated">읽기와 쓰기를 허용하는 배열과 같은 액세스를 제공하는 사용자 정의 클래스는 일반적으로 &lt;code&gt;operator[]&lt;/code&gt; 대해 두 가지 오버로드를 정의합니다 . const 및 non-const 변형 :</target>
        </trans-unit>
        <trans-unit id="9759d0c809ae6bc40bb8a39c15779393d91b25b2" translate="yes" xml:space="preserve">
          <source>User-defined conversion function is invoked on the second stage of the &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt;, which consists of zero or one &lt;a href=&quot;converting_constructor&quot;&gt;converting constructor&lt;/a&gt; or zero or one user-defined conversion function.</source>
          <target state="translated">사용자 정의 변환 함수는 &lt;a href=&quot;implicit_cast&quot;&gt;암시 적 변환&lt;/a&gt; 의 두 번째 단계에서 호출 되는데, 이는 0 또는 1 개의 &lt;a href=&quot;converting_constructor&quot;&gt;변환 생성자&lt;/a&gt; 또는 0 또는 1 개의 사용자 정의 변환 함수로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="43fb76a0004d3479d12ac1d1092e34daa13fde1a" translate="yes" xml:space="preserve">
          <source>User-defined conversions (both converting constructors and user-defined conversion functions) are prohibited from taking part in implicit conversion sequence where it would make it possible to apply more than one user-defined conversion. Specifically, they are not considered if the target of the conversion is the first parameter of a constructor or the implicit object parameter of a user-defined conversion function, and that constructor/user-defined conversion is a candidate for.</source>
          <target state="translated">사용자 정의 변환 (변환 생성자와 사용자 정의 변환 함수 모두)은 둘 이상의 사용자 정의 변환을 적용 할 수있는 암시 적 변환 순서에 참여할 수 없습니다. 특히 변환 대상이 생성자의 첫 번째 매개 변수이거나 사용자 정의 변환 함수의 암시 적 개체 매개 변수이고 해당 생성자 / 사용자 정의 변환이 후보인지 여부는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8869104cf44d820cb55c49ce74b8353880870a6" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides</source>
          <target state="translated">사용자 정의 추론 가이드</target>
        </trans-unit>
        <trans-unit id="ef26f7121e5a45ae6e617a4103dcbb63ab5dc3ab" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides do not have to be templates:</source>
          <target state="translated">사용자 정의 추론 가이드는 템플릿 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ada924d219c774c38ebbaa26b6b0ac7bd8284f27" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides must name a class template and must be introduced within the same semantic scope of the class template (which could be namespace or enclosing class) and, for a member class template, must have the same access, but deduction guides do not become members of that scope.</source>
          <target state="translated">사용자 정의 추론 안내서는 클래스 템플리트의 이름을 지정해야하며 클래스 템플리트의 동일한 시맨틱 범위 (네임 스페이스 또는 포함 클래스 일 수 있음) 내에 도입되어야하며 멤버 클래스 템플리트의 경우 동일한 액세스 권한을 가져야하지만 추론 안내서는 해당 범위의 구성원이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f7140ad8b86562edf1af76c7b4d2ecd3daf0a05" translate="yes" xml:space="preserve">
          <source>User-defined literals</source>
          <target state="translated">사용자 정의 리터럴</target>
        </trans-unit>
        <trans-unit id="27875895c12b2d250978e1e13877f06ad81a62ef" translate="yes" xml:space="preserve">
          <source>User-defined literals (since C++11)</source>
          <target state="translated">사용자 정의 리터럴 (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="f9e1a4e3fe3d8c4879519e8d07a0503e9a4c9e72" translate="yes" xml:space="preserve">
          <source>User-defined literals for string types</source>
          <target state="translated">문자열 유형에 대한 사용자 정의 리터럴</target>
        </trans-unit>
        <trans-unit id="d0490dae080d561474031e5c0e2c4ef6347ced31" translate="yes" xml:space="preserve">
          <source>User-defined literals for time types</source>
          <target state="translated">시간 유형에 대한 사용자 정의 리터럴</target>
        </trans-unit>
        <trans-unit id="fc5e25714db01eb56b2bf86b5e7921777fc9f4c1" translate="yes" xml:space="preserve">
          <source>User-defined overloads</source>
          <target state="translated">사용자 정의 과부하</target>
        </trans-unit>
        <trans-unit id="33745b553a69e48bb26d5d43ad7a22124cb88491" translate="yes" xml:space="preserve">
          <source>User-defined overloads of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; have no effect on constraint normalization.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;||&lt;/code&gt; 의 사용자 정의 과부하 구속 조건 정규화에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d6ddc3c3044ee87f524355e003d05e7748d65d0" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;leap&lt;/code&gt; objects except by copying from existing &lt;code&gt;leap&lt;/code&gt; objects. The library implementation creates &lt;code&gt;leap&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">사용자는 기존 &lt;code&gt;leap&lt;/code&gt; 객체 에서 복사 하지 않고는 &lt;code&gt;leap&lt;/code&gt; 객체를 구성 할 수 없습니다 . 라이브러리 구현은 표준 시간대 데이터베이스를 초기화 할 때 &lt;code&gt;leap&lt;/code&gt; 객체를 생성 하고 이러한 객체에 대한 &lt;code&gt;const&lt;/code&gt; 액세스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="f9e764d8a62224f28652f9477d145424640947d7" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;link&lt;/code&gt; objects. The library implementation creates &lt;code&gt;link&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">사용자는 &lt;code&gt;link&lt;/code&gt; 객체를 생성 할 수 없습니다 . 라이브러리 구현은 시간대 데이터베이스를 초기화 할 때 &lt;code&gt;link&lt;/code&gt; 오브젝트를 작성하고 해당 오브젝트에 대한 &lt;code&gt;const&lt;/code&gt; 액세스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="af2f54042c747b54c3093610083361c67a39fbfd" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;time_zone&lt;/code&gt; objects. The library implementation creates &lt;code&gt;time_zone&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">사용자는 &lt;code&gt;time_zone&lt;/code&gt; 객체를 생성 할 수 없습니다 . 라이브러리 구현은 시간대 데이터베이스를 초기화 할 때 &lt;code&gt;time_zone&lt;/code&gt; 오브젝트를 작성 하고 이러한 오브젝트에 대한 &lt;code&gt;const&lt;/code&gt; 액세스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="946304840b5dd2cc7ea35261e0218a4ed1cc1b01" translate="yes" xml:space="preserve">
          <source>Users may derive from &lt;code&gt;view_base&lt;/code&gt; or specialize &lt;code&gt;enable_view&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; for types which model &lt;code&gt;View&lt;/code&gt;, and specialize &lt;code&gt;enable_view&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for types which do not.</source>
          <target state="translated">사용자로부터 유도 할 수있다 &lt;code&gt;view_base&lt;/code&gt; 또는 구체화 &lt;code&gt;enable_view&lt;/code&gt; 에 &lt;code&gt;true&lt;/code&gt; 타입 모델 &lt;code&gt;View&lt;/code&gt; 및 전문 &lt;code&gt;enable_view&lt;/code&gt; 에 &lt;code&gt;false&lt;/code&gt; 하지 않는 유형.</target>
        </trans-unit>
        <trans-unit id="d77619d2d2aeedbc5912e54a11fc69314fc4b9b4" translate="yes" xml:space="preserve">
          <source>Users may specialize &lt;code&gt;common_type&lt;/code&gt; for types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; if.</source>
          <target state="translated">사용자는 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 유형에 대해 &lt;code&gt;common_type&lt;/code&gt; 을 특수화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44312d9b5ba550e3bf714285fd931d65780211eb" translate="yes" xml:space="preserve">
          <source>Uses base class pword storage for runtime type identification of derived stream objects.</source>
          <target state="translated">파생 스트림 객체의 런타임 유형 식별을 위해 기본 클래스 pword 스토리지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="435dd26a3c29e79ab39283f08d206249de9658d9" translate="yes" xml:space="preserve">
          <source>Uses native_handle to enable realtime scheduling of C++ threads on a POSIX system.</source>
          <target state="translated">native_handle을 사용하여 POSIX 시스템에서 C ++ 스레드의 실시간 스케줄링을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="47d9c5030129b909d30f38ba61ff22e289ed4dc7" translate="yes" xml:space="preserve">
          <source>Uses the allocator &lt;code&gt;a&lt;/code&gt; to allocate &lt;code&gt;n*sizeof(Alloc::value_type)&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="translated">할당 자 &lt;code&gt;a&lt;/code&gt; 를 사용하여 초기화되지 않은 스토리지의 &lt;code&gt;n*sizeof(Alloc::value_type)&lt;/code&gt; 바이트 를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="5774066b9e43fa4c8cddba29af3f1729deeb9d50" translate="yes" xml:space="preserve">
          <source>Uses the allocator &lt;code&gt;a&lt;/code&gt; to deallocate the storage referenced by &lt;code&gt;p&lt;/code&gt;, by calling &lt;code&gt;a.deallocate(p, n)&lt;/code&gt;.</source>
          <target state="translated">할당 자 &lt;code&gt;a&lt;/code&gt; 를 사용하여 &lt;code&gt;a.deallocate(p, n)&lt;/code&gt; 을 호출 하여 &lt;code&gt;p&lt;/code&gt; 가 참조하는 스토리지를 할당 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="1ba97051617e132658e923e2cd0500400c48654b" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to allocate uninitialized storage.</source>
          <target state="translated">외부 할당자를 사용하여 초기화되지 않은 스토리지를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="b3f5f74569dd5173607ac926d852b70e7c657155" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to call the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;, by calling.</source>
          <target state="translated">외부 할당자를 사용하여 &lt;code&gt;p&lt;/code&gt; 로 지정된 객체의 소멸자를 호출하여 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1233805d22778d94a1a1092f4fdeffec6effe4da" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to deallocate the storage referenced by &lt;code&gt;p&lt;/code&gt;, by calling &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::deallocate(outer_allocator(), p, n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::deallocate(outer_allocator(), p, n)&lt;/code&gt; &amp;lt;OuterAlloc&amp;gt; :: deallocate (outer_allocator (), p, n) 을 호출 하여 외부 할당자를 사용하여 &lt;code&gt;p&lt;/code&gt; 가 참조하는 스토리지를 할당 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="9d6bd96d2b4bc007cec5dbc13bffdb43818c467e" translate="yes" xml:space="preserve">
          <source>Uses-allocator construction</source>
          <target state="translated">사용 할당 자 구성</target>
        </trans-unit>
        <trans-unit id="e8ccfd79bce11a76a3f0a27cd61f22c4be4a0529" translate="yes" xml:space="preserve">
          <source>Using a member typedef or alias template in a constructor or constructor template's parameter list does not, by itself, render the corresponding parameter of the implicitly generated guide a non-deduced context.</source>
          <target state="translated">생성자 또는 생성자 템플리트의 매개 변수 목록에서 멤버 typedef 또는 별명 템플리트를 사용한다고해서 내재적으로 생성 된 안내서의 해당 매개 변수가 제거되지 않은 컨텍스트로 렌더링되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3973ba3748f277f1b1247e46879f1a5b0ff12c85" translate="yes" xml:space="preserve">
          <source>Using this library may require additional compiler/linker options. GNU implementation requires linking with &lt;code&gt;-lstdc++fs&lt;/code&gt; and LLVM implementation requires linking with &lt;code&gt;-lc++fs&lt;/code&gt;.</source>
          <target state="translated">이 라이브러리를 사용하려면 추가 컴파일러 / 링커 옵션이 필요할 수 있습니다. GNU 구현에는 &lt;code&gt;-lstdc++fs&lt;/code&gt; 와의 링크가 필요 하고 LLVM 구현에는 &lt;code&gt;-lc++fs&lt;/code&gt; 와의 링크가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="478f8e8f8e40a23e1335aa300d9b135f2ed07fd9" translate="yes" xml:space="preserve">
          <source>Using-declaration</source>
          <target state="translated">Using-declaration</target>
        </trans-unit>
        <trans-unit id="e192f9ebd97a059b8b3818089ff571a2768e5ba3" translate="yes" xml:space="preserve">
          <source>Using-declaration introduces a member of a base class into the derived class definition, such as to expose a protected member of base as public member of derived. In this case, nested-name-specifier must name a base class of the one being defined. If the name is the name of an overloaded member function of the base class, all base class member functions with that name are introduced. If the derived class already has a member with the same name, parameter list, and qualifications, the derived class member hides or overrides (doesn't conflict with) the member that is introduced from the base class.</source>
          <target state="translated">사용 선언은 기본 클래스의 멤버를 파생 클래스 정의에 도입하여 보호 된 기본 멤버를 파생의 공용 멤버로 노출시킵니다. 이 경우 중첩 이름 지정자는 정의중인 기본 클래스의 이름을 지정해야합니다. 이름이 기본 클래스의 오버로드 된 멤버 함수의 이름 인 경우 해당 이름의 모든 기본 클래스 멤버 함수가 도입됩니다. 파생 클래스에 이미 이름, 매개 변수 목록 및 자격이 같은 멤버가있는 경우 파생 클래스 멤버는 기본 클래스에서 소개 된 멤버를 숨기거나 무시합니다 (충돌하지 않음).</target>
        </trans-unit>
        <trans-unit id="647139d11b1988510ebdf137fbaac198034c6a6b" translate="yes" xml:space="preserve">
          <source>Using-declaration introduces a member of another namespace into current namespace or block scope.</source>
          <target state="translated">사용 선언은 다른 네임 스페이스의 멤버를 현재 네임 스페이스 또는 블록 범위에 도입합니다.</target>
        </trans-unit>
        <trans-unit id="96ab3f618e4bb79ceae244afaf56510df88fbaa8" translate="yes" xml:space="preserve">
          <source>Using-declarations</source>
          <target state="translated">Using-declarations</target>
        </trans-unit>
        <trans-unit id="89ce2da2bf0809daefed3588888e71ab6c4b17a5" translate="yes" xml:space="preserve">
          <source>Using-declarations can be used to introduce namespace members into other namespaces and block scopes, or to introduce base class members into derived class definitions.</source>
          <target state="translated">사용 선언은 네임 스페이스 멤버를 다른 네임 스페이스 및 블록 범위에 도입하거나 기본 클래스 멤버를 파생 클래스 정의에 도입하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1afd86105bb6b7eae3d1c2ff8ebac8080cc93c0b" translate="yes" xml:space="preserve">
          <source>Using-declarations cannot name &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt;, namespace, or a scoped enumerator. Each declarator in a using-declaration introduces one and only one name, for example using-declaration for an &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; does not introduce any of its enumerators.</source>
          <target state="translated">사용 선언은 &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; , 네임 스페이스 또는 범위가 지정된 열거 자의 이름을 지정할 수 없습니다 . using-declaration의 각 선언자는 하나의 이름 만 도입합니다. 예를 들어 &lt;a href=&quot;enum&quot;&gt;열거에&lt;/a&gt; 대한 using-declaration은 열거자를 소개하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="243bb7e4adba8af291f9b9518cc9a875ccf74e65" translate="yes" xml:space="preserve">
          <source>Using-declarations in derived classes cannot refer to specializations of template conversion functions from base classes.</source>
          <target state="translated">파생 클래스에서 선언을 사용하면 기본 클래스의 템플릿 변환 함수를 특수화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="890b0e8bf12e6e2f8622f4d2164034f01e35b67b" translate="yes" xml:space="preserve">
          <source>Using-directive does not add any names to the declarative region in which it appears (unlike the using-declaration), and thus does not prevent identical names from being declared.</source>
          <target state="translated">Using-directive는 이름이 나타나는 선언 영역에 이름을 추가하지 않으므로 (사용 선언과 달리) 동일한 이름이 선언되는 것을 막지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9267f4ac5eb849d97bac3ea55d519f3646d7511f" translate="yes" xml:space="preserve">
          <source>Using-directives</source>
          <target state="translated">Using-directives</target>
        </trans-unit>
        <trans-unit id="e478a805aae96b5ada7799a77a72b64e59439220" translate="yes" xml:space="preserve">
          <source>Using-directives are allowed only in namespace &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; and in block scope. From the point of view of unqualified &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; of any name after a using-directive and until the end of the scope in which it appears, every name from namespace-name is visible as if it were declared in the nearest enclosing namespace which contains both the using-directive and namespace-name.</source>
          <target state="translated">사용 지시문은 네임 스페이스 &lt;a href=&quot;scope&quot;&gt;범위&lt;/a&gt; 및 블록 범위 에서만 허용됩니다 . using 지시문 이후의 모든 이름에 대한 규정되지 않은 &lt;a href=&quot;lookup&quot;&gt;이름 조회&lt;/a&gt; 의 관점에서 이름 이 표시되는 범위의 끝까지 namespace-name의 모든 이름은 두 이름을 모두 포함하는 가장 가까운 엔 클로징 네임 스페이스에 선언 된 것처럼 보입니다. using-directive 및 namespace-name</target>
        </trans-unit>
        <trans-unit id="fe20c085207b808c419801ec01c3f2d69d1e53a9" translate="yes" xml:space="preserve">
          <source>Using-directives are transitive for the purposes of &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt;: if a scope contains a using-directive that nominates a namespace-name, which itself contains using-directive for some namespace-name-2, the effect is as if the using directives from the second namespace appear within the first. The order in which these transitive namespaces occur does not influence name lookup.</source>
          <target state="translated">Using-directives는 &lt;a href=&quot;lookup&quot;&gt;규정되지 않은 조회&lt;/a&gt; 의 목적으로 전 이적입니다. 범위에 namespace-name을 지정하는 using-directive가 포함되어 있고 자체적으로 일부 namespace-name-2에 대한 using-directive를 포함하는 경우, 결과는 using 지시문이 두 번째 네임 스페이스는 첫 번째 네임 스페이스 내에 나타납니다. 이러한 전이 네임 스페이스가 발생하는 순서는 이름 조회에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90e771e57dbe271295562deb5815544ce47acec2" translate="yes" xml:space="preserve">
          <source>Usual &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name lookup&lt;/a&gt; is used for the identifier prefixed by &lt;code&gt;typename&lt;/code&gt;. Unlike the case with &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;, the lookup rules do not change despite the qualifier:</source>
          <target state="translated">평소 &lt;a href=&quot;qualified_lookup&quot;&gt;규정 된 이름 조회는&lt;/a&gt; 접두사 식별자에 사용되는 &lt;code&gt;typename&lt;/code&gt; . &lt;a href=&quot;elaborated_type_specifier&quot;&gt;정교한 유형 지정자&lt;/a&gt; 의 경우와 달리, 조회 규칙은 규정 자에도 불구하고 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="72c1f2942e6c2f59eb16eb2f336358c3428f04e8" translate="yes" xml:space="preserve">
          <source>Utilities library</source>
          <target state="translated">유틸리티 라이브러리</target>
        </trans-unit>
        <trans-unit id="c238357565249d5db64377b7321a861ff74e6a3d" translate="yes" xml:space="preserve">
          <source>Utility components</source>
          <target state="translated">유틸리티 구성 요소</target>
        </trans-unit>
        <trans-unit id="69be11f41a3c37842e99473568839d6e6c14c854" translate="yes" xml:space="preserve">
          <source>Utility library</source>
          <target state="translated">유틸리티 라이브러리</target>
        </trans-unit>
        <trans-unit id="6c204fbda83dad99b4764ac479029ca8981e718e" translate="yes" xml:space="preserve">
          <source>Utility metafunction that maps a sequence of any types to the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">모든 유형의 시퀀스를 &lt;code&gt;void&lt;/code&gt; 유형으로 맵핑하는 유틸리티 메타 함수 .</target>
        </trans-unit>
        <trans-unit id="b0d7fadc1640d7f4704fe07fafd860ef56a6519b" translate="yes" xml:space="preserve">
          <source>VERTICAL KANA REPEAT MARK - HANGUL JONGSEONG PHIEUPH-THIEUTH</source>
          <target state="translated">수직 가나 반복 마크-한종 종성 피 에투 티유</target>
        </trans-unit>
        <trans-unit id="5a815286d91c46561b98d7d910a0542f7fa603a7" translate="yes" xml:space="preserve">
          <source>VULGAR FRACTION ONE QUARTER - VULGAR FRACTION THREE QUARTERS</source>
          <target state="translated">불가리아 마찰 1 쿼터-불가리아 마찰 3 쿼터</target>
        </trans-unit>
        <trans-unit id="2a85014316c857fc68366f2d4cfeef4ccca44072" translate="yes" xml:space="preserve">
          <source>Valid non-zero alignments that are weaker than another &lt;code&gt;alignas&lt;/code&gt; on the same declaration are ignored.</source>
          <target state="translated">다른 것보다 약한 유효 비제로 정렬 &lt;code&gt;alignas&lt;/code&gt; 같은 선언에 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="f00df19eab61f9bc6b193ebf7f79f580e312b435" translate="yes" xml:space="preserve">
          <source>Value (hex)</source>
          <target state="translated">값 (16 진수)</target>
        </trans-unit>
        <trans-unit id="6ccf81011273d24c106e237774966bec5a3f3d04" translate="yes" xml:space="preserve">
          <source>Value (octal)</source>
          <target state="translated">가치 (8 진수)</target>
        </trans-unit>
        <trans-unit id="842d5c71fd285df07d76b3a931200aef4027bbe5" translate="yes" xml:space="preserve">
          <source>Value array containing</source>
          <target state="translated">포함하는 값 배열</target>
        </trans-unit>
        <trans-unit id="8f9d98449ec4c8f79f22636316b3a0e923c947ef" translate="yes" xml:space="preserve">
          <source>Value array containing absolute values of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 값의 절대 값을 포함하는 값 배열 .</target>
        </trans-unit>
        <trans-unit id="bba712cfd9f7651aa772da136f89a61149be2ac1" translate="yes" xml:space="preserve">
          <source>Value array containing arc cosines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 값의 아크 코사인을 포함하는 값 배열 .</target>
        </trans-unit>
        <trans-unit id="918e7d00363d34ea17b81a2896797c2d5407de29" translate="yes" xml:space="preserve">
          <source>Value array containing arc sines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 값의 아크 사인을 포함하는 값 배열 .</target>
        </trans-unit>
        <trans-unit id="7dd43aa4756d43fc4b8be056b5da614e7ae17fe0" translate="yes" xml:space="preserve">
          <source>Value array containing arc tangents of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 값의 아크 탄젠트를 포함하는 값 배열 .</target>
        </trans-unit>
        <trans-unit id="7a16b1209abeda990f5a71b8d2e227e0b6c93b82" translate="yes" xml:space="preserve">
          <source>Value array containing common logarithms of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 값에 대한 공통 로그를 포함하는 값 배열 .</target>
        </trans-unit>
        <trans-unit id="a311ab5baa8093138875ac8a94b0cea46530bc77" translate="yes" xml:space="preserve">
          <source>Value array containing cosines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 값의 코사인을 포함하는 값 배열 .</target>
        </trans-unit>
        <trans-unit id="67e25f3a01cf3ed1b997a81a0d9b1d557b7e592b" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic cosine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 값의 쌍곡 코사인을 포함하는 값 배열 .</target>
        </trans-unit>
        <trans-unit id="9d4fd3ea31174e2ad27a712e67ef9575efad3f21" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic sine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 값의 쌍곡 사인을 포함하는 값 배열 .</target>
        </trans-unit>
        <trans-unit id="2a5794dbb6788174721a7201fba5775845755af6" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic tangent of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 값의 쌍곡 탄젠트를 포함하는 값 배열 .</target>
        </trans-unit>
        <trans-unit id="788503847d55a0b843da66ecc9eb7e909c8e81ea" translate="yes" xml:space="preserve">
          <source>Value array containing natural logarithms of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 값의 자연 로그를 포함하는 값 배열 .</target>
        </trans-unit>
        <trans-unit id="8d94e0b0bb891cd281312eef3d7cafb82f9093c2" translate="yes" xml:space="preserve">
          <source>Value array containing sine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 값의 사인을 포함하는 값 배열 .</target>
        </trans-unit>
        <trans-unit id="4bcd496b550ea36f6a6a5da52708746dfc984226" translate="yes" xml:space="preserve">
          <source>Value array containing square roots of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 값의 제곱근을 포함하는 값 배열 .</target>
        </trans-unit>
        <trans-unit id="acec93cb24e8ed07513e328851e06115700eaed0" translate="yes" xml:space="preserve">
          <source>Value array containing tangents of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;va&lt;/code&gt; 의 값의 탄젠트를 포함하는 값 배열 .</target>
        </trans-unit>
        <trans-unit id="de0430a56abae1a9c8cca4fd7a8b8906769e0636" translate="yes" xml:space="preserve">
          <source>Value categories</source>
          <target state="translated">가치 범주</target>
        </trans-unit>
        <trans-unit id="82a222afd8aa1f50591d47af3a1da440d1b6c1c9" translate="yes" xml:space="preserve">
          <source>Value initialization is performed in these situations:</source>
          <target state="translated">다음과 같은 상황에서 값 초기화가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="44ee88d7a37283ed3f2e5c6bb77a69fd4b4ff443" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 의 가치</target>
        </trans-unit>
        <trans-unit id="f316bf9562d1f2536d1f98b558dad75f56bae376" translate="yes" xml:space="preserve">
          <source>Value of a floating-point or &lt;a href=&quot;../../types/is_integral&quot;&gt;Integral type&lt;/a&gt;</source>
          <target state="translated">부동 소수점 또는 &lt;a href=&quot;../../types/is_integral&quot;&gt;정수 유형의 값&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8868e91c4a5c3eea6c88793879068066054670cd" translate="yes" xml:space="preserve">
          <source>Value of a type &lt;code&gt;Y&lt;/code&gt; whose &lt;a href=&quot;../container/node_handle&quot;&gt;node handles&lt;/a&gt; are compatible with X</source>
          <target state="translated">&lt;a href=&quot;../container/node_handle&quot;&gt;노드 핸들&lt;/a&gt; 이 X와 호환 되는 유형 &lt;code&gt;Y&lt;/code&gt; 의 값</target>
        </trans-unit>
        <trans-unit id="a6d7a9a5f8f421d8d8d1289caa1073e525a68c0c" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X::size_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X::size_type&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="a3076d857f6bafe8bc4b757157d8b7e92030d350" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="bdc99e4fc02f27b3e7f0e86f72aae50003652dc4" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; supports multiple keys</source>
          <target state="translated">형의 값 &lt;code&gt;X&lt;/code&gt; 이 때 &lt;code&gt;X&lt;/code&gt; 는 여러 개의 키를 지원</target>
        </trans-unit>
        <trans-unit id="d88b2ce84fd44f3d069f80a1cad885599a530444" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; supports unique keys</source>
          <target state="translated">형의 값 &lt;code&gt;X&lt;/code&gt; 이 때 &lt;code&gt;X&lt;/code&gt; 는 고유의 키를 지원합니다</target>
        </trans-unit>
        <trans-unit id="b2e637fb234b0c6b9d295e0383f8ac972d2e9be2" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="1c7cea36bd22384e74ce5693b3a96747824e4406" translate="yes" xml:space="preserve">
          <source>Value range</source>
          <target state="translated">가치 범위</target>
        </trans-unit>
        <trans-unit id="51127d011c590cc06c1287343706272a08f0dc2d" translate="yes" xml:space="preserve">
          <source>Value too large to be stored in data type</source>
          <target state="translated">데이터 유형에 저장하기에 너무 큰 값</target>
        </trans-unit>
        <trans-unit id="af99e0d3d72b238f81c500119ae328f4acda13dc" translate="yes" xml:space="preserve">
          <source>Value transformations</source>
          <target state="translated">가치 변환</target>
        </trans-unit>
        <trans-unit id="60a41a8af03cf015b251f42ec4877faede44cfa3" translate="yes" xml:space="preserve">
          <source>Value transformations are conversions that change the &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of an expression. They take place whenever an expression appears as an operand of an operator that expects an expression of a different value category.</source>
          <target state="translated">값 변환은 식 의 &lt;a href=&quot;value_category&quot;&gt;값 범주&lt;/a&gt; 를 변경하는 변환입니다 . 표현식이 다른 값 범주의 표현식을 기대하는 연산자의 피연산자로 나타날 때마다 발생합니다.</target>
        </trans-unit>
        <trans-unit id="912f89db75340dd536695f5900751cb79605c44e" translate="yes" xml:space="preserve">
          <source>Value-dependent expressions</source>
          <target state="translated">가치 의존적 표현</target>
        </trans-unit>
        <trans-unit id="1c83d35b39b8a1674f047686e39badc8092fea73" translate="yes" xml:space="preserve">
          <source>ValueSwappable</source>
          <target state="translated">ValueSwappable</target>
        </trans-unit>
        <trans-unit id="5cfdbdef621053e4c2adb3e5800cfd3510d6d549" translate="yes" xml:space="preserve">
          <source>ValueType</source>
          <target state="translated">ValueType</target>
        </trans-unit>
        <trans-unit id="e3d8fb1ed748d78b39416572c15d6566892835be" translate="yes" xml:space="preserve">
          <source>Values of &lt;code&gt;base&lt;/code&gt; other than 8, 10, or 16 reset &lt;code&gt;basefield&lt;/code&gt; to zero, which corresponds to decimal output and prefix-dependent input.</source>
          <target state="translated">8, 10 또는 16 이외 의 &lt;code&gt;base&lt;/code&gt; 값은 &lt;code&gt;basefield&lt;/code&gt; 를 0으로 재설정 합니다. 이는 10 진수 출력 및 접두사 종속 입력에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="699b7fde74d4bad2ed32bf4fdac5cb581d05b675" translate="yes" xml:space="preserve">
          <source>Values of integer, floating-point, and enumeration types can be converted by &lt;a href=&quot;static_cast&quot;&gt;&lt;code&gt;static_cast&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;explicit_cast&quot;&gt;explicit cast&lt;/a&gt;, to any enumeration type. If the underlying type is not fixed, the result is unspecified(until C++17)undefined behavior(since C++17) if the source value (first converted to the enumeration's underlying type if floating-point) is out of range (the range is all values possible for the smallest bit field large enough to hold all enumerators of the target enumeration). Otherwise, the result is the same as the result of &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; to the underlying type.</source>
          <target state="translated">정수, 부동 소수점 및 열거 유형의 값은 &lt;a href=&quot;static_cast&quot;&gt; &lt;code&gt;static_cast&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;explicit_cast&quot;&gt;explicit cast에&lt;/a&gt; 의해 임의의 열거 유형 으로 변환 될 수 있습니다 . 기본 유형이 고정되지 않은 경우 소스 값 (부동 소수점 일 경우 열거 형 기본 유형으로 먼저 변환 됨)이 범위를 벗어나면 (C ++ 17 이후) 정의되지 않은 동작 (C ++ 17까지) 결과가 지정되지 않습니다 ( 범위는 대상 열거의 모든 열거자를 보유 할 수있을 정도로 큰 가장 작은 비트 필드에 대해 가능한 모든 값입니다). 그렇지 않으면 결과는 기본 형식으로 의 &lt;a href=&quot;implicit_cast&quot;&gt;암시 적 변환&lt;/a&gt; 결과와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="622c99b5f957359968fbce43706c282c2086981e" translate="yes" xml:space="preserve">
          <source>Values of unscoped enumeration type are &lt;a href=&quot;implicit_cast&quot;&gt;implicitly-convertible&lt;/a&gt; to integral types. If the underlying type is not fixed, the value is convertible to the first type from the following list able to hold their entire value range: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, or &lt;code&gt;unsigned long long&lt;/code&gt;. If the underlying type is fixed, the values can be converted to their promoted underlying type.</source>
          <target state="translated">범위가 지정되지 않은 열거 유형의 값은 &lt;a href=&quot;implicit_cast&quot;&gt;암시 적&lt;/a&gt; 으로 정수 유형 으로 변환 할 수 있습니다. 기본 유형이 고정되지 않은 경우 값은 전체 값 범위를 보유 할 수있는 다음 목록에서 첫 번째 유형으로 변환 할 수 있습니다. &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; 또는 &lt;code&gt;unsigned long long&lt;/code&gt; . 기본 유형이 고정 된 경우 값을 승격 된 기본 유형으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8df93af76ffcc18fdab0d35c919d46adda08d0a" translate="yes" xml:space="preserve">
          <source>Values of zero will be replaced with implementation-specified defaults;</source>
          <target state="translated">0 값은 구현 지정 기본값으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="052336d34e395136fdc7b0ea68de9e6ce0735430" translate="yes" xml:space="preserve">
          <source>Values returned from &lt;code&gt;lookup_classname&lt;/code&gt; can be bitwise or'ed together; the resulting value represents membership in either of the corresponding character classes</source>
          <target state="translated">&lt;code&gt;lookup_classname&lt;/code&gt; 에서 리턴 된 값은 비트 단위 이거나 함께 사용될 수 있습니다. 결과 값은 해당 문자 클래스 중 하나의 멤버쉽을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="df08eb1d25241fdec3135b3385380633b3feb713" translate="yes" xml:space="preserve">
          <source>Variable template(since C++14)</source>
          <target state="translated">변수 템플릿 (C ++ 14부터)</target>
        </trans-unit>
        <trans-unit id="07e0c173abb12ff926e54a677500672fc6b6b986" translate="yes" xml:space="preserve">
          <source>Variable templates</source>
          <target state="translated">변수 템플릿</target>
        </trans-unit>
        <trans-unit id="bb8bc60fbcd37b30cc10bb1c4aefe4bd77138258" translate="yes" xml:space="preserve">
          <source>Variable templates cannot be used as &lt;a href=&quot;template_parameters#Template_template_arguments&quot;&gt;template template arguments&lt;/a&gt;.</source>
          <target state="translated">변수 템플릿은 &lt;a href=&quot;template_parameters#Template_template_arguments&quot;&gt;템플릿 템플릿 인수&lt;/a&gt; 로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bf60c912c256eebe5d2b8b031ec6bed1e0afbc9c" translate="yes" xml:space="preserve">
          <source>Variable templates for type traits</source>
          <target state="translated">유형 특성에 대한 변수 템플릿</target>
        </trans-unit>
        <trans-unit id="d41def7a6d8846ea38dabfb67345e2e0a09f52e7" translate="yes" xml:space="preserve">
          <source>Variables declared at block scope with the specifier &lt;code&gt;static&lt;/code&gt; have static storage duration but are initialized the first time control passes through their declaration (unless their initialization is &lt;a href=&quot;zero_initialization&quot;&gt;zero-&lt;/a&gt; or &lt;a href=&quot;constant_initialization&quot;&gt;constant-initialization&lt;/a&gt;, which can be performed before the block is first entered). On all further calls, the declaration is skipped.</source>
          <target state="translated">지정자가 &lt;code&gt;static&lt;/code&gt; 인 블록 범위에서 선언 된 변수 는 정적 저장 기간을 갖지만 처음으로 제어가 선언을 통과 할 때 초기화됩니다 (초기화가 &lt;a href=&quot;zero_initialization&quot;&gt;0&lt;/a&gt; 또는 &lt;a href=&quot;constant_initialization&quot;&gt;상수&lt;/a&gt; 초기화가 아닌 한 , 블록을 처음 입력하기 전에 수행 할 수있는 경우 제외 ). 모든 추가 호출에서 선언은 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="56198fe808c824ddba06784c100164faedd427c3" translate="yes" xml:space="preserve">
          <source>Variadic &lt;code&gt;&lt;a href=&quot;thread/lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;std::scoped_lock&lt;/code&gt;)</source>
          <target state="translated">Variadic &lt;code&gt;&lt;a href=&quot;thread/lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;std::scoped_lock&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a8548e5a783f6964c2b71215ac2f1cf031c3e8a0" translate="yes" xml:space="preserve">
          <source>Variadic arguments</source>
          <target state="translated">잡색의 주장</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">다양한 기능</target>
        </trans-unit>
        <trans-unit id="04c44e45105b6cf53a83ce33f663f4af86c9d0a7" translate="yes" xml:space="preserve">
          <source>Variadic functions are functions (e.g. &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt;) which take a &lt;a href=&quot;../language/variadic_arguments&quot;&gt;variable number of arguments&lt;/a&gt;.</source>
          <target state="translated">가변 함수는 &lt;a href=&quot;../language/variadic_arguments&quot;&gt;가변 개수의 인수&lt;/a&gt; 를 취하는 함수 (예 : &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; )입니다 .</target>
        </trans-unit>
        <trans-unit id="8a308087e2905028e7ad5d2c240717d97448c333" translate="yes" xml:space="preserve">
          <source>Variadic templates</source>
          <target state="translated">다양한 템플릿</target>
        </trans-unit>
        <trans-unit id="40aa5342cc8cddbbe71fe77cdf48f02a16642a52" translate="yes" xml:space="preserve">
          <source>Various &lt;a href=&quot;utility&quot;&gt; utility components&lt;/a&gt;</source>
          <target state="translated">다양한 &lt;a href=&quot;utility&quot;&gt;유틸리티 구성 요소&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43dfbbdcd916a0c6741ae6b7703f2bf5dd8096c3" translate="yes" xml:space="preserve">
          <source>Vector capacity is never reduced when resizing to smaller size because that would invalidate all iterators, rather than only the ones that would be invalidated by the equivalent sequence of pop_back() calls.</source>
          <target state="translated">더 작은 크기로 크기를 조정할 때 벡터 용량은 축소되지 않으므로 동일한 반복 시퀀스의 pop_back () 호출로 무효화되는 반복 자만이 아니라 모든 반복자가 무효화되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5519001c19e39db626b1e56d5b3636ed5b38cb6f" translate="yes" xml:space="preserve">
          <source>Version (2) of the &lt;code&gt;#define&lt;/code&gt; directive defines a simple function-like macro.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 지시문 의 버전 (2) 는 간단한 함수형 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ae3376f429640ab77c59ef69b6eeee356493fa80" translate="yes" xml:space="preserve">
          <source>Version (3) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments. The additional arguments (called</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 지시문 의 버전 (3)은 가변 개수의 인수로 함수형 매크로를 정의합니다. 추가 인수 (</target>
        </trans-unit>
        <trans-unit id="3243986759cbfdbcf8f3fe70af12570a24f20c76" translate="yes" xml:space="preserve">
          <source>Version (4) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments, but no regular arguments. The arguments (called</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 지시문 의 버전 (4)는 가변 개수의 인수를 사용하지만 정규 인수는없는 함수형 매크로를 정의합니다. 인수 (</target>
        </trans-unit>
        <trans-unit id="1c26c7d8a48f6ecef280cf0b203307778072892d" translate="yes" xml:space="preserve">
          <source>Viable functions</source>
          <target state="translated">실행 가능한 기능</target>
        </trans-unit>
        <trans-unit id="69bd4ef9fbd0894a22759c3766b859defbdedbc8" translate="yes" xml:space="preserve">
          <source>View</source>
          <target state="translated">View</target>
        </trans-unit>
        <trans-unit id="57dde08ae7e4931bf4b1d9d8203c8fb2aa6c4ddb" translate="yes" xml:space="preserve">
          <source>View of the substring &lt;code&gt;[pos, pos + rcount)&lt;/code&gt;.</source>
          <target state="translated">부분 문자열보기 &lt;code&gt;[pos, pos + rcount)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08776128bd18b59c55542f61081a01440f41b01c" translate="yes" xml:space="preserve">
          <source>ViewableRange</source>
          <target state="translated">ViewableRange</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="c911ee9da5495317a3fd2048e2a77408d0f7651d" translate="yes" xml:space="preserve">
          <source>Violations of constraints are detected at compile time, early in the template instantiation process, which leads to easy to follow error messages.</source>
          <target state="translated">템플릿 인스턴스화 프로세스 초기에 컴파일 타임에 제약 조건 위반이 감지되어 오류 메시지를 쉽게 따라갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b18a97a2fd2836708868d06e1ce4ef84d86615c" translate="yes" xml:space="preserve">
          <source>Virtual and pure virtual functions</source>
          <target state="translated">가상 및 순수 가상 기능</target>
        </trans-unit>
        <trans-unit id="f68e04bd9e3e62f1affa5f5cd95daed9e7141704" translate="yes" xml:space="preserve">
          <source>Virtual base classes</source>
          <target state="translated">가상 기본 클래스</target>
        </trans-unit>
        <trans-unit id="bb2875a5baa367827268a607eb3795f455c6012e" translate="yes" xml:space="preserve">
          <source>Virtual destructor</source>
          <target state="translated">가상 소멸자</target>
        </trans-unit>
        <trans-unit id="5066038f5f1b55b5a2bc0bc13c582fae42181817" translate="yes" xml:space="preserve">
          <source>Virtual destructors</source>
          <target state="translated">가상 소멸자</target>
        </trans-unit>
        <trans-unit id="f6fe3c659ed8077db8d0b5920aa4b5764bff62d6" translate="yes" xml:space="preserve">
          <source>Virtual functions (whether declared virtual or overriding one) cannot have any associated constraints.</source>
          <target state="translated">가상 함수 (가상 선언 또는 재정의 여부)는 연관된 제한 조건을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f5fcb0f75cbb4813db427832ef8357c8c51c72a" translate="yes" xml:space="preserve">
          <source>Virtual functions are member functions whose behavior can be overridden in derived classes. As opposed to non-virtual functions, the overridden behavior is preserved even if there is no compile-time information about the actual type of the class. If a derived class is handled using pointer or reference to the base class, a call to an overridden virtual function would invoke the behavior defined in the derived class. This behavior is suppressed if the function is selected using &lt;a href=&quot;lookup&quot;&gt;qualified name lookup&lt;/a&gt; (that is, if the function's name appears to the right of the scope resolution operator &lt;code&gt;::&lt;/code&gt;).</source>
          <target state="translated">가상 함수는 파생 클래스에서 동작을 재정의 할 수있는 멤버 함수입니다. 비가 상 함수와 달리 클래스의 실제 유형에 대한 컴파일 타임 정보가 없어도 재정의 된 동작이 유지됩니다. 파생 클래스가 포인터 또는 기본 클래스에 대한 참조를 사용하여 처리되는 경우 재정의 된 가상 함수를 호출하면 파생 클래스에 정의 된 동작이 호출됩니다. &lt;a href=&quot;lookup&quot;&gt;정규화 된 이름 조회를&lt;/a&gt; 사용하여 함수를 선택한 경우 (즉, 함수 이름이 범위 확인 연산자 &lt;code&gt;::&lt;/code&gt; 오른쪽에 나타나는 경우)이 동작이 억제됩니다 .</target>
        </trans-unit>
        <trans-unit id="d022c012c3444ee6f002dccdfcd5905c70efa42e" translate="yes" xml:space="preserve">
          <source>Visible side-effects</source>
          <target state="translated">눈에 보이는 부작용</target>
        </trans-unit>
        <trans-unit id="30c3d8194815052f5f9f54a1fac519295b84ad3f" translate="yes" xml:space="preserve">
          <source>Visual Studio 2010</source>
          <target state="translated">Visual Studio 2010</target>
        </trans-unit>
        <trans-unit id="a50605af7e7015b16739f3db40248d1a64076a37" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 Inline Assembler</source>
          <target state="translated">Visual Studio 2013 인라인 어셈블러</target>
        </trans-unit>
        <trans-unit id="359a03f62e49986ef991446210499529db3fc418" translate="yes" xml:space="preserve">
          <source>Void expressions</source>
          <target state="translated">공허한 표현</target>
        </trans-unit>
        <trans-unit id="f135b48d956f6ca097c1656d0a1863579947c9fb" translate="yes" xml:space="preserve">
          <source>Void expressions have no</source>
          <target state="translated">공허한 표현에는</target>
        </trans-unit>
        <trans-unit id="e8f5359cab08d3573121923f7436c0f33fc92629" translate="yes" xml:space="preserve">
          <source>Void type</source>
          <target state="translated">공허 유형</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="c0bc38123ad63ab545d3b75627acdac77e9b79a6" translate="yes" xml:space="preserve">
          <source>WCHAR_MAX</source>
          <target state="translated">WCHAR_MAX</target>
        </trans-unit>
        <trans-unit id="04ea5fdfa0eae316269a47c7f10e8316337146a4" translate="yes" xml:space="preserve">
          <source>WCHAR_MIN</source>
          <target state="translated">WCHAR_MIN</target>
        </trans-unit>
        <trans-unit id="c37a74a6f2d73286ec534a439a5c059b13230ec6" translate="yes" xml:space="preserve">
          <source>WEOF</source>
          <target state="translated">WEOF</target>
        </trans-unit>
        <trans-unit id="8d070188c9052ddde44bc280e3aced3c983ed8c7" translate="yes" xml:space="preserve">
          <source>WINT_MAX</source>
          <target state="translated">WINT_MAX</target>
        </trans-unit>
        <trans-unit id="cb08e31a881a0bd7697665afb678cdce175c2f59" translate="yes" xml:space="preserve">
          <source>WINT_MIN</source>
          <target state="translated">WINT_MIN</target>
        </trans-unit>
        <trans-unit id="d7d72e040861a1f86b9b248b64986ff2db87de0a" translate="yes" xml:space="preserve">
          <source>WORD JOINER - TURNED DIGIT THREE</source>
          <target state="translated">단어 JOINER-회전식 3 자리</target>
        </trans-unit>
        <trans-unit id="33d30632848d3fd0ed2340adbd7be3e3e8e61010" translate="yes" xml:space="preserve">
          <source>Waiting</source>
          <target state="translated">Waiting</target>
        </trans-unit>
        <trans-unit id="8c8066383629449e748934ef44df8baa244ceb3f" translate="yes" xml:space="preserve">
          <source>Waits for the result to become available. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the result becomes available, whichever comes first. Returns value identifies the state of the result.</source>
          <target state="translated">결과가 나오기를 기다립니다. 지정된 &lt;code&gt;timeout_duration&lt;/code&gt; 이 경과하거나 결과를 사용할 수 있을 때까지 차단합니다 . 반환 값은 결과의 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="128348550537d17215c4e4e19183a94c6cae96fb" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; to denote the type of the expression &lt;code&gt;e&lt;/code&gt;. (In other words, &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is the equivalent of &lt;code&gt;&lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype((e))&amp;gt;&lt;/code&gt;.).</source>
          <target state="translated">식 &lt;code&gt;e&lt;/code&gt; 의 유형을 나타 내기 위해 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 를 사용합니다 . 즉, &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype((e))&amp;gt;&lt;/code&gt; &amp;lt;decltype ((e))&amp;gt;와 같습니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="ff2d0e12c8d86e48e138480e627a03522625fd5b" translate="yes" xml:space="preserve">
          <source>Weak equality</source>
          <target state="translated">약한 평등</target>
        </trans-unit>
        <trans-unit id="cc0eeac220c48abd1f4d8a9066580d68089b7e2a" translate="yes" xml:space="preserve">
          <source>Weak ordering</source>
          <target state="translated">약한 주문</target>
        </trans-unit>
        <trans-unit id="5f9aead2f88dbe4721a67660c3e46cd95c9d01ce" translate="yes" xml:space="preserve">
          <source>Weakly parallel forward progress</source>
          <target state="translated">약한 병렬 진행</target>
        </trans-unit>
        <trans-unit id="32d5d9f2881f15e8163749d6edac5a8dd285e442" translate="yes" xml:space="preserve">
          <source>WeaklyIncrementable</source>
          <target state="translated">WeaklyIncrementable</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="1d901e38ea200c08db624662589c69e315e01ff1" translate="yes" xml:space="preserve">
          <source>Week/day of the year</source>
          <target state="translated">연중 주 / 일</target>
        </trans-unit>
        <trans-unit id="17a74d187c8a04abdcb5c0a680b6e9d660e85fba" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #1/3</source>
          <target state="translated">정의되지 않은 행동 # 1 / 3에 대해 모든 C 프로그래머가 알아야 할 사항</target>
        </trans-unit>
        <trans-unit id="8b7904dfab491b34141248cdfa81f76b99500ce8" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #2/3</source>
          <target state="translated">정의되지 않은 행동 # 2 / 3에 대해 모든 C 프로그래머가 알아야 할 사항</target>
        </trans-unit>
        <trans-unit id="faec1f8b604ae7cb007c3f28c6244f78ba75f633" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #3/3</source>
          <target state="translated">정의되지 않은 행동 # 3 / 3에 대해 모든 C 프로그래머가 알아야 할 사항</target>
        </trans-unit>
        <trans-unit id="5345ef8ed5a57eddad0fc38e73e7287b6270366c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, or &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; satisfies the LegacyOutputIterator requirements in addition to its own requirements, it is described as &lt;b&gt;mutable&lt;/b&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; 또는 &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator가&lt;/a&gt; 만족 자체 요건 이외에 LegacyOutputIterator 요구, 그것으로 설명 &lt;b&gt;가변&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="cc0170dca8716eb24882edf591a81dee83e562ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;#&lt;/code&gt; appears before &lt;code&gt;__VA_ARGS__&lt;/code&gt;, the entire expanded __VA_ARGS__ is enclosed in quotes:</source>
          <target state="translated">시 &lt;code&gt;#&lt;/code&gt; 이 나타납니다 전에 &lt;code&gt;__VA_ARGS__&lt;/code&gt; , 전체 확장 __VA_ARGS__은 따옴표로 묶여 :</target>
        </trans-unit>
        <trans-unit id="046623a30719eaa626e9121030272ea2805083f6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is a (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, it is unspecified whether function (1) is declared.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 (아마도 CV 정규화)는 &lt;code&gt;void&lt;/code&gt; , 그 기능 (1) 선언 여부 불특정이다.</target>
        </trans-unit>
        <trans-unit id="bf6dcc3dc3f6b7e5ebe9923c510cc70615782d54" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is an array type, it is unspecified whether these member functions are declared, and if they are, what their return type is, except that the declaration (not necessarily the definition) of these functions is well-formed.</source>
          <target state="translated">때 &lt;code&gt;T&lt;/code&gt; 가 배열 유형이, 이러한 멤버 함수가 선언 여부를 지정하고, 만약 그들이, 그들의 반환 형식이 무엇인지,이 함수의 선언 (반드시 정의)이 잘 형성되는 것을 제외하고.</target>
        </trans-unit>
        <trans-unit id="97a2afc24ba5f22063e77c7d297d40d35897008d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is not an array type, it is unspecified whether this function is declared. If the function is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal.</source>
          <target state="translated">때 &lt;code&gt;T&lt;/code&gt; 가 어레이 형태가 아닌,이 기능이 선언되는지 여부를 지정한다. 함수가 선언 된 경우 함수의 선언 (정의 일 필요는 없지만)이 합법적임을 보증하는 것을 제외하고는 반환 유형이 무엇인지 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="841913a7a092250d0d74debefdc20a6387cf98d1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is not an array type, the overloads (3), (4), and (6) enable &lt;code&gt;shared_from_this&lt;/code&gt; with &lt;code&gt;ptr&lt;/code&gt;, and the overload (13) enables &lt;code&gt;shared_from_this&lt;/code&gt; with the pointer returned by &lt;code&gt;r.release()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 어레이 타입의 오버로드 (3), (4), (6) 아니다 에이블 &lt;code&gt;shared_from_this&lt;/code&gt; 와 &lt;code&gt;ptr&lt;/code&gt; 하고, 과부하 (13) 사용 &lt;code&gt;shared_from_this&lt;/code&gt; 를 의해 리턴 포인터 &lt;code&gt;r.release()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="933697ca9b43c7b723b629859ce79b9ed2a3265c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isfinite(a) &amp;amp;&amp;amp; isfinite(b)&lt;/code&gt;, the following properties are guaranteed:</source>
          <target state="translated">때 &lt;code&gt;isfinite(a) &amp;amp;&amp;amp; isfinite(b)&lt;/code&gt; , 다음과 같은 속성이 보장됩니다</target>
        </trans-unit>
        <trans-unit id="57eacd6a7d9600dd8cd2e42c3f2ae19d11ad628e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;shared_ptr&lt;/code&gt; is created by calling &lt;code&gt;&lt;a href=&quot;shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt;, the memory for both the control block and the managed object is created with a single allocation. The managed object is constructed in-place in a data member of the control block. When &lt;code&gt;shared_ptr&lt;/code&gt; is created via one of the &lt;code&gt;shared_ptr&lt;/code&gt; constructors, the managed object and the control block must be allocated separately. In this case, the control block stores a pointer to the managed object.</source>
          <target state="translated">경우 &lt;code&gt;shared_ptr&lt;/code&gt; 을이 전화에 의해 만들어진 &lt;code&gt;&lt;a href=&quot;shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt; 제어 블록 및 관리 개체 모두에 대한 메모리는 하나의 할당을 생성한다. 관리 대상 개체는 제어 블록의 데이터 멤버에 적절하게 구성됩니다. &lt;code&gt;shared_ptr&lt;/code&gt; 이 &lt;code&gt;shared_ptr&lt;/code&gt; 생성자 중 하나를 통해 작성 되면 관리 오브젝트와 제어 블록을 별도로 할당해야합니다. 이 경우 제어 블록은 관리 대상 개체에 대한 포인터를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="4833d1b8e7740b741eed936468b06c1d2f60499d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;t&lt;/code&gt; is a &lt;a href=&quot;../language/reference#Forwarding_references&quot;&gt;forwarding reference&lt;/a&gt; (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt; it had when passed to the calling function.</source>
          <target state="translated">경우 &lt;code&gt;t&lt;/code&gt; 는 A는 &lt;a href=&quot;../language/reference#Forwarding_references&quot;&gt;전송 기준&lt;/a&gt; (a CV-비정규 함수 템플릿 파라미터에 r- 수치 기준으로 선언 함수 인수) 전달이에 과부하와 다른 함수의 인수 &lt;a href=&quot;../language/value_category&quot;&gt;값 카테고리&lt;/a&gt; 발신 기능에 전달할 때했다가.</target>
        </trans-unit>
        <trans-unit id="f05559f6187d0eff998ef174b497dd5f9e035c58" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;lock_guard&lt;/code&gt; object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the &lt;code&gt;lock_guard&lt;/code&gt; object was created, the &lt;code&gt;lock_guard&lt;/code&gt; is destructed and the mutex is released.</source>
          <target state="translated">때 &lt;code&gt;lock_guard&lt;/code&gt; 의 객체가 생성, 그것이이 주어진 뮤텍스의 소유권을 시도합니다. 제어가 &lt;code&gt;lock_guard&lt;/code&gt; 오브젝트가 작성된 범위를 벗어나 면 &lt;code&gt;lock_guard&lt;/code&gt; 가 제거되고 뮤텍스가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="e69de8ba0616baddc63eba743d4447e24a787005" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;scoped_lock&lt;/code&gt; object is created, it attempts to take ownership of the mutexes it is given. When control leaves the scope in which the &lt;code&gt;scoped_lock&lt;/code&gt; object was created, the &lt;code&gt;scoped_lock&lt;/code&gt; is destructed and the mutexes are released, in reverse order. If several mutexes are given, deadlock avoidance algorithm is used as if by &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;std::lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;scoped_lock&lt;/code&gt; 의 객체가 생성, 그것이 주어진 뮤텍스의 소유권을 시도합니다. 제어가 &lt;code&gt;scoped_lock&lt;/code&gt; 오브젝트가 작성된 범위를 벗어나 면 &lt;code&gt;scoped_lock&lt;/code&gt; 이 제거되고 뮤텍스가 역순으로 해제됩니다. 여러 개의 뮤텍스가 제공되면 교착 상태 방지 알고리즘은 &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;std::lock&lt;/a&gt;&lt;/code&gt; 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="303d35d938cb833eac9338017dabe149a1c1712f" translate="yes" xml:space="preserve">
          <source>When a base class is intended for polymorphic use, its destructor may have to be declared public and virtual. This blocks implicit moves (and deprecates implicit copies), and so the special member functions have to be declared as defaulted&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;rule_of_three#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">기본 클래스가 다형성 용도로 사용되는 경우 소멸자는 공용 및 가상으로 선언해야 할 수 있습니다. 이것은 암시 적 이동을 차단하고 암시 적 복사본을 더 이상 사용하지 않으므로 특수 멤버 함수는 기본값으로 선언해야합니다 &lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;rule_of_three#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a38cdff86c855a9f5b8dafef92329da17987f83a" translate="yes" xml:space="preserve">
          <source>When a block declaration appears &lt;a href=&quot;statements#Compound_statements&quot;&gt;inside a block&lt;/a&gt;, and an identifier introduced by a declaration was previously declared in an outer block, the &lt;a href=&quot;scope&quot;&gt;outer declaration is hidden&lt;/a&gt; for the remainder of the block.</source>
          <target state="translated">블록 선언이 블록 &lt;a href=&quot;statements#Compound_statements&quot;&gt;안에&lt;/a&gt; 나타나고 선언에 의해 도입 된 식별자가 외부 블록에 이미 선언 된 경우, &lt;a href=&quot;scope&quot;&gt;외부 선언은&lt;/a&gt; 블록의 나머지 부분에 대해 숨겨집니다 .</target>
        </trans-unit>
        <trans-unit id="da9117b375eefc957e65150185d8008bdc45763a" translate="yes" xml:space="preserve">
          <source>When a class or variable(since C++14) template is instantiated, and there are partial specializations available, the compiler has to decide if the primary template is going to be used or one of its partial specializations.</source>
          <target state="translated">클래스 또는 변수 (C ++ 14 이후) 템플리트가 인스턴스화되고 사용 가능한 부분 특수화가있는 경우 컴파일러는 기본 템플리트를 사용할지 또는 부분 특수화 중 하나를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fea65df3178fced8b0ade7c9ce2a6ba4bc611c76" translate="yes" xml:space="preserve">
          <source>When a class template specialization is referenced in context that requires a complete object type, or when a function template specialization is referenced in context that requires a function definition to exist, the template is</source>
          <target state="translated">완전한 오브젝트 유형이 필요한 컨텍스트에서 클래스 템플리트 전문화가 참조되거나 함수 정의가 필요한 컨텍스트에서 함수 템플리트 전문화가 참조되는 경우 템플리트는</target>
        </trans-unit>
        <trans-unit id="5769c7acaf1d2335b2ca90b0ec55efa0d236a336" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;private&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public and protected members of the base class are accessible as private members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">클래스가 &lt;code&gt;private&lt;/code&gt; &lt;a href=&quot;access&quot;&gt;구성원 액세스 지정자&lt;/a&gt; 를 사용하여 기본에서 파생되는 경우 기본 클래스의 모든 공용 및 보호 된 구성원은 파생 클래스의 개인 구성원으로 액세스 할 수 있습니다 (기본의 개인 구성원은 친구가 아닌 한 액세스 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="2fcd782f662cbfb240e5bd78fca278b024889cc7" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;protected&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public and protected members of the base class are accessible as protected members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">클래스가 &lt;code&gt;protected&lt;/code&gt; &lt;a href=&quot;access&quot;&gt;멤버 액세스 지정자&lt;/a&gt; 를 사용하여 기본에서 파생되는 경우 기본 클래스의 모든 공용 및 보호 된 멤버는 파생 클래스의 보호 된 멤버로 액세스 할 수 있습니다 (기본의 개인 멤버는 친구가 아닌 한 액세스 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="774bfe4108db2bde44499cb4a6ab68ddca8b923c" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;public&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public members of the base class are accessible as public members of the derived class and all protected members of the base class are accessible as protected members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">클래스가 &lt;code&gt;public&lt;/code&gt; &lt;a href=&quot;access&quot;&gt;멤버 액세스 지정자&lt;/a&gt; 를 사용하여 기본에서 파생되는 경우 기본 클래스의 모든 공개 멤버는 파생 클래스의 공개 멤버로 액세스 할 수 있고 기본 클래스의 모든 보호 멤버는 파생 클래스의 보호 멤버로 액세스 할 수 있습니다 (개인 멤버) 친구가 아닌 이상 기지의 접근이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="731c55e17d6e6e68ab60a46f9b70a72e60e6dd67" translate="yes" xml:space="preserve">
          <source>When a complete line of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">완전한 출력 라인을 플러시해야하는 경우 &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; 조작기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c302c1bc7c6fed86bcea489bc973092937f86e79" translate="yes" xml:space="preserve">
          <source>When a coroutine begins execution, it performs the following:</source>
          <target state="translated">코 루틴이 실행을 시작하면 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f150d08af5c8d72aecd740bc32ce2f1f91de3c2d" translate="yes" xml:space="preserve">
          <source>When a coroutine reaches a suspension point.</source>
          <target state="translated">코 루틴이 서스펜션 지점에 도달 할 때.</target>
        </trans-unit>
        <trans-unit id="0c56a2828a8dc079acafa0f6578250d1ca9ad491" translate="yes" xml:space="preserve">
          <source>When a coroutine reaches the &lt;code&gt;co_return&lt;/code&gt; statement, it performs the following:</source>
          <target state="translated">코 루틴이 &lt;code&gt;co_return&lt;/code&gt; 문에 도달 하면 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="cf467bf3385d5e1232a7b50fd987d1bda1eb5b07" translate="yes" xml:space="preserve">
          <source>When a feature changes significantly, the macro will be updated accordingly.</source>
          <target state="translated">기능이 크게 변경되면 그에 따라 매크로가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a1204ab37d3f0482e454433db039fd14f2d10599" translate="yes" xml:space="preserve">
          <source>When a file is included, it is processed by &lt;a href=&quot;../language/translation_phases&quot;&gt;translation phases&lt;/a&gt; 1-4, which may include, recursively, expansion of the nested &lt;code&gt;#include&lt;/code&gt; directives. To avoid repeated inclusion of the same file and endless recursion when a file includes itself, perhaps transitively,</source>
          <target state="translated">파일이 포함되면 &lt;a href=&quot;../language/translation_phases&quot;&gt;변환 단계&lt;/a&gt; 1 ~ 4에 의해 처리되며 중첩 단계 &lt;code&gt;#include&lt;/code&gt; 지시문의 확장을 재귀 적으로 포함 할 수 있습니다 . 파일이 포함 된 경우 동일한 파일이 반복적으로 포함되지 않고 재귀가 반복되지 않도록하려면</target>
        </trans-unit>
        <trans-unit id="0f6ee751ce2ae6f2e1fe4fc82e2efbe71ee15f4f" translate="yes" xml:space="preserve">
          <source>When a friend declaration refers to a full specialization of a function template, the keyword &lt;code&gt;inline&lt;/code&gt; and default arguments cannot be used.</source>
          <target state="translated">친구 선언이 함수 템플리트의 전체 전문화를 참조하는 경우 키워드 &lt;code&gt;inline&lt;/code&gt; 및 기본 인수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd03b884a832ad273a2adbacad6fb75f476bfdf0" translate="yes" xml:space="preserve">
          <source>When a function is invoked, e.g. in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function-call expression&lt;/a&gt;, the parameters are initialized from the arguments (either provided at the place of call or &lt;a href=&quot;default_arguments&quot;&gt;defaulted&lt;/a&gt;) and the statements in the function body are executed.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;함수 호출 표현식&lt;/a&gt; 에서 함수가 호출되면 매개 변수가 인수에서 초기화되고 (호출 위치에서 제공되거나 &lt;a href=&quot;default_arguments&quot;&gt;기본값으로 설정 됨&lt;/a&gt; ) 함수 본문의 명령문이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="056da6db0024a8fc9e2178af3caa77a54e3aa303" translate="yes" xml:space="preserve">
          <source>When a function's return type is lvalue reference, the function call expression becomes an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt;:</source>
          <target state="translated">함수의 반환 유형이 lvalue 참조 인 경우 함수 호출 표현식은 &lt;a href=&quot;value_category&quot;&gt;lvalue 표현식이됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4616bf2b5d98e8563f41341866c844e7ac6e8d1f" translate="yes" xml:space="preserve">
          <source>When a function-style cast or declaration of a variable uses the name of a primary class template &lt;code&gt;C&lt;/code&gt; without an argument list as the type specifier, deduction will proceed as follows:</source>
          <target state="translated">함수 스타일 캐스트 또는 변수 선언 에서 인수 목록이없는 기본 클래스 템플릿 &lt;code&gt;C&lt;/code&gt; 의 이름을 형식 지정자로 사용하면 다음과 같이 추론이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="703e91dee14a5d41272ff0618515064124c5ca74" translate="yes" xml:space="preserve">
          <source>When a lambda captures a member using implicit by-copy capture, it does not make a copy of that member variable: the use of a member variable &lt;code&gt;m&lt;/code&gt; is treated as an expression &lt;code&gt;(*this).m&lt;/code&gt;, and &lt;code&gt;*this&lt;/code&gt; is always implicitly captured by reference:</source>
          <target state="translated">람다는 암시 적 바이 카피 캡처를 사용하여 멤버를 캡처 할 때 해당 멤버 변수의 사본을 만들지 않습니다. 멤버 변수 &lt;code&gt;m&lt;/code&gt; 의 사용은 표현식 &lt;code&gt;(*this).m&lt;/code&gt; 으로 취급되며 &lt;code&gt;*this&lt;/code&gt; 항상 암시 적으로 캡처됩니다 참조로 :</target>
        </trans-unit>
        <trans-unit id="3ea6ad3dcd073f66ca30ba43dbc0f20952f4603c" translate="yes" xml:space="preserve">
          <source>When a local class declares an unqualified function or class as a friend, only functions and classes in the innermost non-class scope are &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt;, not the global functions:</source>
          <target state="translated">로컬 클래스가 규정되지 않은 함수 또는 클래스를 친구로 선언 하면 전역 함수 가 아닌 가장 안쪽의 비 클래스 범위의 함수 및 클래스 만 &lt;a href=&quot;lookup&quot;&gt;조회&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8b46570618f5daf88923faf7d12da8873e3be80a" translate="yes" xml:space="preserve">
          <source>When a member is redeclared within the same class, it must do so under the same member access:</source>
          <target state="translated">같은 클래스 내에서 멤버를 다시 선언하면 동일한 멤버 액세스하에 다시 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="f224ac0d371f052e58a2217d4de98b1976737b0e" translate="yes" xml:space="preserve">
          <source>When a non-static class member is used in any of the contexts where the &lt;code&gt;this&lt;/code&gt; keyword is allowed (non-static member function bodies, member initializer lists, default member initializers), the implicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; is automatically added before the name, resulting in a member access expression (which, if the member is a virtual member function, results in a virtual function call).</source>
          <target state="translated">정적이 아닌 클래스 멤버가 &lt;code&gt;this&lt;/code&gt; 키워드가 허용되는 컨텍스트 (정적이 아닌 멤버 함수 본문, 멤버 이니셜 라이저 목록, 기본 멤버 이니셜 라이저)에서 사용되면 암시 적 &lt;code&gt;this-&amp;gt;&lt;/code&gt; 가 이름 앞에 자동으로 추가되어 결과적으로 멤버 액세스 표현식에서 (멤버가 가상 멤버 함수 인 경우 가상 함수 호출이 발생 함).</target>
        </trans-unit>
        <trans-unit id="c996fe1da1454bb286aadf030b85cfad7cae8fed" translate="yes" xml:space="preserve">
          <source>When a pointer to a protected member is formed, it must use a derived class in its declaration:</source>
          <target state="translated">보호 된 멤버에 대한 포인터가 형성되면 선언에서 파생 클래스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7fe22ece7b8d4604836b61b68f07304156388fd8" translate="yes" xml:space="preserve">
          <source>When a qualified name is used as a &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;, then &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified lookup&lt;/a&gt; of the names used in the same declarator that follow that qualified name, but not the names that precede it, is performed in the scope of the member's class or namespace:</source>
          <target state="translated">자격을 갖춘 이름이로 사용하는 경우 &lt;a href=&quot;declarations&quot;&gt;선언자&lt;/a&gt; , 다음 &lt;a href=&quot;unqualified_lookup&quot;&gt;비정규 조회&lt;/a&gt; 그 자격을 갖춘 이름을 따라 같은 선언자에 사용되는 이름,하지만 그것을 앞에 이름의는 회원의 클래스 또는 네임 스페이스의 범위에서 수행한다 :</target>
        </trans-unit>
        <trans-unit id="7128500ddb4a19baad89fa94da4a6a51b2aa2144" translate="yes" xml:space="preserve">
          <source>When a signaling NaN is used as an argument to an arithmetic expression, the appropriate floating-point exception may be raised and the NaN is &quot;quieted&quot;, that is, the expression returns a quiet NaN.</source>
          <target state="translated">시그널링 NaN이 산술 표현식에 대한 인수로 사용될 때, 적절한 부동 소수점 예외가 발생하고 NaN이 &quot;quieted&quot;입니다. 즉, 표현식은 조용한 NaN을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7f3acde83607f5ff6b438f0d494f026c16dc4d51" translate="yes" xml:space="preserve">
          <source>When a thread owns a &lt;code&gt;mutex&lt;/code&gt;, all other threads will block (for calls to &lt;a href=&quot;mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;) or receive a &lt;code&gt;false&lt;/code&gt; return value (for &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;) if they attempt to claim ownership of the &lt;code&gt;mutex&lt;/code&gt;.</source>
          <target state="translated">스레드가 &lt;code&gt;mutex&lt;/code&gt; 소유 한 경우 , 다른 모든 스레드는 &lt;code&gt;mutex&lt;/code&gt; 소유권을 주장하려고 시도하는 경우 ( &lt;a href=&quot;mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 호출의 경우) 차단 하거나 &lt;code&gt;false&lt;/code&gt; 반환 값 ( &lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; 의&lt;/a&gt; 경우) 을 받습니다 .</target>
        </trans-unit>
        <trans-unit id="48235a61557c038c024774d3984da66f889dd511" translate="yes" xml:space="preserve">
          <source>When a thread owns a &lt;code&gt;recursive_mutex&lt;/code&gt;, all other threads will block (for calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;) or receive a &lt;code&gt;false&lt;/code&gt; return value (for &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;) if they attempt to claim ownership of the &lt;code&gt;recursive_mutex&lt;/code&gt;.</source>
          <target state="translated">스레드가 &lt;code&gt;recursive_mutex&lt;/code&gt; 를 소유 한 경우 , 다른 모든 스레드는 &lt;code&gt;recursive_mutex&lt;/code&gt; 의 소유권을 주장하려고 시도 할 경우 ( &lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; 호출의 경우) 차단 하거나 &lt;code&gt;false&lt;/code&gt; 반환 값 ( &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; 의&lt;/a&gt; 경우) 을 받습니다 .</target>
        </trans-unit>
        <trans-unit id="78d07a1734d460127f218d90a8985eff2cc5268d" translate="yes" xml:space="preserve">
          <source>When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; for details on the order in which writes made from threads become visible to other threads.</source>
          <target state="translated">스레드가 메모리 위치에서 값을 읽으면 초기 값, 동일한 스레드에 기록 된 값 또는 다른 스레드에 기록 된 값을 볼 수 있습니다. 스레드에서 &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; 쓰기가 다른 스레드에 표시되는 순서에 대한 자세한 내용 은 std :: memory_order 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35914adcda38d9bc606dedbc8e87f226f4c33d60" translate="yes" xml:space="preserve">
          <source>When a unary fold is used with a pack expansion of length zero, only the following operators are allowed:</source>
          <target state="translated">길이가 0 인 팩 확장과 함께 단항 접기를 사용하는 경우 다음 연산자 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a5725eb8b03373883cd17dd14b578f1aefe9ae18" translate="yes" xml:space="preserve">
          <source>When a union is initialized by aggregate initialization, only its first non-static data member is initialized.</source>
          <target state="translated">집계 초기화로 공용체를 초기화하면 첫 번째 비 정적 데이터 멤버 만 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="75156726fb61b37daeae849a8c23a8d3e99ac431" translate="yes" xml:space="preserve">
          <source>When a user-defined class overloads the function call operator, &lt;code&gt;operator()&lt;/code&gt;, it becomes a &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; type. Many standard algorithms, from &lt;code&gt;&lt;a href=&quot;../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../algorithm/accumulate&quot;&gt;std::accumulate&lt;/a&gt;&lt;/code&gt; accept objects of such types to customize behavior. There are no particularly notable canonical forms of &lt;code&gt;operator()&lt;/code&gt;, but to illustrate the usage.</source>
          <target state="translated">사용자 정의 된 클래스 함수 호출 연산자 과부하시 &lt;code&gt;operator()&lt;/code&gt; , 그것은된다 &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObject의&lt;/a&gt; 유형. &lt;code&gt;&lt;a href=&quot;../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../algorithm/accumulate&quot;&gt;std::accumulate&lt;/a&gt;&lt;/code&gt; 이르는 많은 표준 알고리즘 은 이러한 유형의 객체를 수용하여 동작을 사용자 정의합니다. 특히 눈에 띄는 표준 형식의 &lt;code&gt;operator()&lt;/code&gt; 는 없지만 사용법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="48f53b62820f7fe3746951152075f1cdb1ddd004" translate="yes" xml:space="preserve">
          <source>When a variadic function is called, after lvalue-to-rvalue, array-to-pointer, and function-to-pointer &lt;a href=&quot;implicit_cast#Lvalue_transformations&quot;&gt;conversions&lt;/a&gt;, each argument that is a part of the variable argument list undergoes additional conversions known as</source>
          <target state="translated">lvalue-to-rvalue, array-to-pointer 및 function-to-pointer &lt;a href=&quot;implicit_cast#Lvalue_transformations&quot;&gt;conversions&lt;/a&gt; 후 variadic 함수가 호출되면 변수 인수 목록의 일부인 각 인수는 다음과 같은 추가 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4fc2bc7f5954311ab6cd53cf773a77f33b1fad76" translate="yes" xml:space="preserve">
          <source>When a virtual function call is made, the type returned by the final overrider is &lt;a href=&quot;implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to the return type of the overridden function that was called:</source>
          <target state="translated">가상 함수 호출이 수행되면 최종 재정의자가 반환 한 형식은 다음과 같이 재정의 된 재정의 된 함수의 반환 형식으로 &lt;a href=&quot;implicit_cast&quot;&gt;암시 적으로 변환&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="93489141e89c6d227a8966329ac45e5e0c099d81" translate="yes" xml:space="preserve">
          <source>When a virtual function is called directly or indirectly from a constructor or from a destructor (including during the construction or destruction of the class&amp;rsquo;s non-static data members, e.g. in a member &lt;a href=&quot;constructor&quot;&gt;initializer list&lt;/a&gt;), and the object to which the call applies is the object under construction or destruction, the function called is the final overrider in the constructor&amp;rsquo;s or destructor&amp;rsquo;s class and not one overriding it in a more-derived class. In other words, during construction or destruction, the more-derived classes do not exist.</source>
          <target state="translated">가상 함수가 생성자 또는 소멸자에서 직접 또는 간접적으로 호출되는 경우 (예 : 멤버 &lt;a href=&quot;constructor&quot;&gt;초기화 목록&lt;/a&gt; 에서 클래스의 비 정적 데이터 멤버의 구성 또는 파괴 중에 포함 ) 호출이 적용되는 오브젝트는 생성 또는 파괴중인 객체에서 호출되는 함수는 생성자 또는 소멸자 클래스의 최종 재정 의자이며 파생 클래스에서 재정의하는 것이 아닙니다. 다시 말해서, 건설 또는 파괴 중에는 더 많은 파생 클래스가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c93bab45e9c1d0dfc9ec2e952c16e1c1852bb4fb" translate="yes" xml:space="preserve">
          <source>When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable unless the object representation of &lt;code&gt;T&lt;/code&gt; may include padding bits,(until C++20) trap bits, or offers multiple object representations for the same value (e.g. floating-point NaN). In those cases, weak compare-and-exchange typically works because it quickly converges on some stable object representation.</source>
          <target state="translated">약한 비교 및 ​​교환에 루프가 필요하고 강한 루프가 필요하지 않은 경우 &lt;code&gt;T&lt;/code&gt; 의 객체 표현이 패딩 비트를 포함하거나 (C ++ 20까지) 트랩 비트를 포함하거나 여러 객체 표현을 제공 하지 않는 한 강한 것이 바람직 합니다. 동일한 값 (예 : 부동 소수점 NaN) 이 경우 약한 비교 및 ​​교환은 일반적으로 안정적인 객체 표현에 빠르게 수렴되기 때문에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b549d145a45bd55485a97603e36455b405b7f9e4" translate="yes" xml:space="preserve">
          <source>When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable unless the object representation of &lt;code&gt;T&lt;/code&gt; may include trap bits, or offers multiple object representations for the same value (e.g. floating-point NaN). In those cases, weak compare-and-exchange typically works because it quickly converges on some stable object representation.</source>
          <target state="translated">약한 비교 및 ​​교환에 루프가 필요하고 강한 루프가 필요하지 않은 경우, &lt;code&gt;T&lt;/code&gt; 의 객체 표현이 트랩 비트를 포함하거나 동일한 값 (예 : 부동 소수점 NaN)에 대해 여러 객체 표현을 제공 하지 않는 한 강한 것이 바람직 합니다 ). 이 경우 약한 비교 및 ​​교환은 일반적으로 안정적인 객체 표현에 빠르게 수렴되기 때문에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3267a8eb3fe0cea3cd97459c2f9b3b8e6692761b" translate="yes" xml:space="preserve">
          <source>When active member of a union is switched by an assignment expression of the form &lt;code&gt;E1 = E2&lt;/code&gt; that uses either the built-in assignment operator or a trivial assignment operator, for each union member X that appears in the member access and array subscript subexpressions of &lt;code&gt;E1&lt;/code&gt; that is not a class with non-trivial or deleted default constructors, if modification of X would have undefined behavior under type aliasing rules, an object of the type of X is implicitly created in the nominated storage; no initialization is performed and the beginning of its lifetime is sequenced after the value computation of the left and right operands and before the assignment.</source>
          <target state="translated">조합의 활성 부재 형태의 할당 식으로 전환되면 &lt;code&gt;E1 = E2&lt;/code&gt; 것을 사용하거나 내장 된 각 조합 부재 X에 대한 할당 연산자 또는 사소한 할당 연산자, 그 회원 접속 배열 첨자 표현식에 나타나는 &lt;code&gt;E1&lt;/code&gt; 즉, 단순하지 않거나 삭제 된 기본 생성자가있는 클래스가 아닙니다. X의 수정이 유형 앨리어싱 규칙에 따라 정의되지 않은 동작을하는 경우 X 유형의 개체가 지정된 저장소에 내재적으로 만들어집니다. 초기화는 수행되지 않으며 수명의 시작은 왼쪽과 오른쪽 피연산자의 값 계산 후와 할당 전에 순서화됩니다.</target>
        </trans-unit>
        <trans-unit id="d56d5c0d1a9783bd328d5ceefac5e3f1fa5681a7" translate="yes" xml:space="preserve">
          <source>When all template arguments have been specified, deduced or obtained from default template arguments, every use of a template parameter in the function parameter list is replaced with the corresponding template arguments.</source>
          <target state="translated">모든 템플릿 인수가 기본 템플릿 인수에서 지정, 추론 또는 얻어지면 함수 매개 변수 목록에서 템플릿 매개 변수를 사용할 때마다 해당 템플릿 인수로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="b6e6698c4323b10a60e0746ae78192f4bab23b17" translate="yes" xml:space="preserve">
          <source>When allocating an object whose alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; or an array of such objects, the new-expression passes the alignment requirement (wrapped in &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) as the second argument for the allocation function (for placement forms, &lt;code&gt;placement_params&lt;/code&gt; appear after the alignment, as the third, fourth, etc arguments). If overload resolution fails (which happens when a class-specific allocation function is defined with a different signature, since it hides the globals), overload resolution is attempted a second time, without alignment in the argument list. This allows alignment-unaware class-specific allocation functions to take precedence over the global alignment-aware allocation functions.</source>
          <target state="translated">정렬 방식 요구 초과 객체 할당 할 때 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 또는 오브젝트의 배열을 상기 새로운 식 (래핑 정렬 요구 통과 &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt; 배치 형태에 대한 할당 함수 (위한 두번째 인수)를 &lt;code&gt;placement_params&lt;/code&gt; 는 얼라인먼트 후에 나타나는 , 세 번째, 네 번째 등의 인수로). 오버로드 확인에 실패하면 (글로벌을 숨기므로 클래스 별 할당 함수가 다른 서명으로 정의 된 경우 발생) 인수 목록에서 정렬하지 않고 두 번째로 오버로드 확인이 시도됩니다. 이를 통해 정렬 비 인식 클래스 별 할당 함수가 전역 정렬 인식 할당 함수보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="32f253fd06f69fca2aca9bf86ab82833c3ab166b" translate="yes" xml:space="preserve">
          <source>When allocating objects and arrays of objects whose alignment exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, overload resolution for placement forms is performed twice just as for regular forms: first, for alignment-aware function signatures, then for alignment-unaware function signatures.</source>
          <target state="translated">정렬이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하는 객체 및 객체 배열을 할당 할 때 배치 양식에 대한 오버로드 확인은 일반 양식에서와 같이 두 번 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fc6458ca664e9adb25872544f8c6cbc1b8d2ef56" translate="yes" xml:space="preserve">
          <source>When allocating objects and arrays of objects whose alignment exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, overload resolution is performed twice: first, for alignment-aware function signatures, then for alignment-unaware function signatures. This means that if a class with extended alignment has an alignment-unaware class-specific allocation function, it is the function that will be called, not the global alignment-aware allocation function. This is intentional: the class member is expected to know best how to handle that class.</source>
          <target state="translated">정렬이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하는 객체 및 객체의 배열을 할당 할 때 , 오버로드 확인이 두 번 수행됩니다 : 먼저 정렬 인식 함수 서명, 정렬 인식 불가 함수 서명. 이것은 확장 된 정렬을 가진 클래스가 정렬을 인식하지 못하는 클래스 특정 할당 함수를 갖는 경우, 이는 글로벌 정렬 인식 할당 함수가 아니라 호출 될 함수라는 것을 의미합니다. 이것은 의도적입니다. 반원은 해당 반을 처리하는 방법을 가장 잘 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dbe54944a43bccf5cf205c899d78217a14037efa" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;eval_order&quot;&gt;evaluation&lt;/a&gt; of an expression writes to a memory location and another evaluation reads or modifies the same memory location, the expressions are said to</source>
          <target state="translated">표현식 의 &lt;a href=&quot;eval_order&quot;&gt;평가&lt;/a&gt; 가 메모리 위치에 쓰고 다른 평가가 동일한 메모리 위치를 읽거나 수정하는 경우 표현식은</target>
        </trans-unit>
        <trans-unit id="f54b782cb8a2443df3f24c71942278de560d6c94" translate="yes" xml:space="preserve">
          <source>When an exception of type &lt;code&gt;E&lt;/code&gt; is thrown by any statement in compound-statement, it is matched against the types of the formal parameters &lt;code&gt;T&lt;/code&gt; of each catch-clause in handler-seq, in the order in which the catch clauses are listed. The exception is a match if any of the following is true:</source>
          <target state="translated">compound-statement의 명령문에 의해 &lt;code&gt;E&lt;/code&gt; 유형의 예외 가 발생하면 handler-seq에있는 각 catch-clause 의 형식 매개 변수 &lt;code&gt;T&lt;/code&gt; 유형과 catch 절이 나열된 순서대로 일치합니다 . 다음 중 하나라도 해당되는 경우 예외입니다.</target>
        </trans-unit>
        <trans-unit id="141971b19d6009b0db3fb823a2039b332a4e6a99" translate="yes" xml:space="preserve">
          <source>When an explicit instantiation names a class template specialization, it serves as an explicit instantiation of the same kind (declaration or definition) of each of its non-inherited non-template members that has not been previously explicitly specialized in the translation unit. If this explicit instantiation is a definition, it is also an explicit instantiation definition only for the members that have been defined at this point.</source>
          <target state="translated">명시 적 인스턴스화에서 클래스 템플릿 전문화의 이름을 지정하면 이전에 번역 단위에서 명시 적으로 전문화되지 않은 각 상속되지 않은 비 템플릿 멤버의 동일한 종류 (선언 또는 정의)의 명시 적 인스턴스화 역할을합니다. 이 명시 적 인스턴스화가 정의이면이 시점에서 정의 된 멤버에 대한 명시 적 인스턴스화 정의이기도합니다.</target>
        </trans-unit>
        <trans-unit id="2e3df706304532f1fafe99d11c7b971952d33cd6" translate="yes" xml:space="preserve">
          <source>When an expression that uses type or non-type template parameters appears in the function parameter list or in the return type, that expression remains a part of the function template signature for the purpose of overloading:</source>
          <target state="translated">유형 또는 유형이 아닌 템플리트 매개 변수를 사용하는 표현식이 함수 매개 변수 목록 또는 리턴 유형에 표시되면 해당 표현식은 오버로드를 위해 함수 템플리트 서명의 일부로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6a2958786f5f2e3f6b231cd1ab5ade2e4415a58" translate="yes" xml:space="preserve">
          <source>When an incomplete line of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;flush&quot;&gt;std::flush&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">불완전한 출력 라인을 플러시해야하는 경우 &lt;code&gt;&lt;a href=&quot;flush&quot;&gt;std::flush&lt;/a&gt;&lt;/code&gt; 조작기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddca8d5dd1fab756efa48fbbb7d3a9d39e978269" translate="yes" xml:space="preserve">
          <source>When an object is first created, the cv-qualifiers used (which could be part of decl-specifier-seq or part of a declarator in a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;, or part of type-id in a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;) determine the constness or volatility of the object, as follows:</source>
          <target state="translated">객체가 처음 생성 될 때 사용 된 cv 한정자 (declar-specifier-seq의 일부 또는 선언의 &lt;a href=&quot;declarations&quot;&gt;선언자&lt;/a&gt; 또는 &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; 의 type-id 의 일부일 수 있음)는 다음과 같이 객체 :</target>
        </trans-unit>
        <trans-unit id="d130a7fb0dc18dd843e992986efede0bda37daa7" translate="yes" xml:space="preserve">
          <source>When an object of class type X is passed to or returned from a function, if each copy constructor, move constructor, and destructor of X is either trivial or deleted, and X has at least one non-deleted copy or move constructor, implementations are permitted to create a temporary object to hold the function parameter or result object.</source>
          <target state="translated">클래스 유형 X의 객체가 함수로 전달되거나 함수에서 반환 될 때 X의 각 복사 생성자, 이동 생성자 및 소멸자가 단순하거나 삭제되고 X에 삭제되지 않은 복사 또는 이동 생성자가 하나 이상 있으면 구현은 다음과 같습니다. 함수 매개 변수 또는 결과 오브젝트를 보유 할 임시 오브젝트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01dd171c098fe6b55329621a15cc7367dee5f1d4" translate="yes" xml:space="preserve">
          <source>When an object of class type is &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt; outside a &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; context, the candidate functions are all constructors of the class being initialized. The argument list is the expression list of the initializer.</source>
          <target state="translated">클래스 유형의 객체가 &lt;a href=&quot;copy_initialization&quot;&gt;복사 초기화&lt;/a&gt; 컨텍스트 외부에서 &lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 되거나 &lt;a href=&quot;default_initialization&quot;&gt;기본 초기화&lt;/a&gt; 되면 후보 함수는 모두 초기화되는 클래스의 생성자입니다. 인수 목록은 이니셜 라이저의 표현식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b112f8307a878b858abe15c415401e098531c633" translate="yes" xml:space="preserve">
          <source>When an object of class type is copy-initialized from an object of the same or derived class type, or default-initialized in a copy-initialization context, the candidate functions are all &lt;a href=&quot;converting_constructor&quot;&gt;converting constructors&lt;/a&gt; of the class being initialized. The argument list is the expression of the initializer.</source>
          <target state="translated">클래스 유형의 오브젝트가 동일하거나 파생 된 클래스 유형의 오브젝트에서 복사 초기화되거나 복사 초기화 컨텍스트에서 기본 초기화되면 후보 함수는 모두 초기화중인 클래스의 &lt;a href=&quot;converting_constructor&quot;&gt;생성자&lt;/a&gt; 를 변환 합니다. 인수 목록은 이니셜 라이저의 표현입니다.</target>
        </trans-unit>
        <trans-unit id="6c417ae51346e00b8f2e04143715b97da243d164" translate="yes" xml:space="preserve">
          <source>When an object of non-aggregate class type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt;, two-phase overload resolution takes place.</source>
          <target state="translated">집계되지 않은 클래스 유형 &lt;code&gt;T&lt;/code&gt; 의 객체 가 &lt;a href=&quot;list_initialization&quot;&gt;목록 초기화&lt;/a&gt; 되면 2 단계 과부하 해결이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ae6288b4e0c89ad0ee91c5bb7ab0d2b10cfef5c7" translate="yes" xml:space="preserve">
          <source>When an object of some class &lt;code&gt;C&lt;/code&gt; is created, each non-static data member of non-reference type is allocated in some part of the object representation of &lt;code&gt;C&lt;/code&gt;. Whether reference members occupy any storage is implementation-defined, but their &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; is the same as that of the object in which they are members.</source>
          <target state="translated">일부 클래스 &lt;code&gt;C&lt;/code&gt; 의 오브젝트 가 작성되면 비 참조 유형의 각 비 정적 데이터 멤버가 &lt;code&gt;C&lt;/code&gt; 의 오브젝트 표시의 일부에 할당됩니다 . 참조 멤버가 스토리지를 차지하는지 여부는 구현 정의이지만 &lt;a href=&quot;storage_duration&quot;&gt;스토리지 지속 시간&lt;/a&gt; 은 멤버 인 오브젝트의 지속 시간 과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="63af81fffbdf1a90668b23768fdc0980bed3770a" translate="yes" xml:space="preserve">
          <source>When an object of type optional&amp;lt;T&amp;gt; is &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually converted to bool&lt;/a&gt;, the conversion returns &lt;code&gt;true&lt;/code&gt; if the object</source>
          <target state="translated">optional &amp;lt;T&amp;gt; 유형의 객체가 &lt;a href=&quot;../language/implicit_cast&quot;&gt;문맥 상으로 bool&lt;/a&gt; 로 변환 될 때 객체 가 변환 되면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1564a3bf1abdab4804c3b45d781d0743bc25fc6d" translate="yes" xml:space="preserve">
          <source>When an operator appears in an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt;, and at least one of its operands has a &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; or an &lt;a href=&quot;enum&quot;&gt;enumeration type&lt;/a&gt;, then &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; is used to determine the user-defined function to be called among all the functions whose signatures match the following:</source>
          <target state="translated">연산자가 &lt;a href=&quot;expressions&quot;&gt;표현식에&lt;/a&gt; 나타나고 피연산자 중 하나 이상에 &lt;a href=&quot;class&quot;&gt;클래스 유형&lt;/a&gt; 또는 &lt;a href=&quot;enum&quot;&gt;열거 유형&lt;/a&gt; 이있는 경우 &lt;a href=&quot;overload_resolution&quot;&gt;오버로드 확인&lt;/a&gt; 을 사용하여 서명이 다음과 일치하는 모든 함수 중에서 호출 할 사용자 정의 함수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="fb0096bc731b7218f872e304d201c5d20ef5e918" translate="yes" xml:space="preserve">
          <source>When an unscoped enumeration is a class member, its enumerators may be accessed using class member access operators &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">범위가 지정되지 않은 열거가 클래스 멤버 인 경우 클래스 멤버 액세스 연산자를 사용하여 열거 자에 액세스 할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 및 &lt;code&gt;-&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6f67767f1271f59038f6527a10110416f4a16657" translate="yes" xml:space="preserve">
          <source>When applied to a class type, the result is the size of an object of that class plus any additional padding required to place such object in an array.</source>
          <target state="translated">클래스 유형에 적용하면 결과는 해당 클래스의 객체 크기와 해당 객체를 배열에 배치하는 데 필요한 추가 패딩입니다.</target>
        </trans-unit>
        <trans-unit id="ad0c1d3f6453f804c34d81d7a95f3f37e5786005" translate="yes" xml:space="preserve">
          <source>When applied to a class, the identifier &lt;code&gt;final&lt;/code&gt; appears at the beginning of the class definition, immediately after the name of the class.</source>
          <target state="translated">클래스에 적용될 때 클래스 &lt;code&gt;final&lt;/code&gt; 에 클래스 이름 바로 뒤에 식별자 final이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ebcafd6f66dd47f9f7ba53777289ab2dbc04fbca" translate="yes" xml:space="preserve">
          <source>When applied to a member function, the identifier &lt;code&gt;final&lt;/code&gt; appears immediately after the &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; in the syntax of a member function declaration or a member function definition inside a class definition.</source>
          <target state="translated">멤버 함수에 적용될 때, 식별자 &lt;code&gt;final&lt;/code&gt; 은 멤버 함수 선언의 구문 또는 클래스 정의 내의 멤버 함수 정의 에서 &lt;a href=&quot;function&quot;&gt;선언자&lt;/a&gt; 바로 뒤에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="64935cc54ab77b2b7e3b4674a370a21df9f2ba1a" translate="yes" xml:space="preserve">
          <source>When applied to a pointer, the subscript expression is always an lvalue.</source>
          <target state="translated">포인터에 적용될 때 아래 첨자 표현식은 항상 lvalue입니다.</target>
        </trans-unit>
        <trans-unit id="3fa5cb2eff44efae521c7cddc759eb971197f991" translate="yes" xml:space="preserve">
          <source>When applied to a reference type, the result is the size of the referenced type.</source>
          <target state="translated">참조 유형에 적용하면 결과는 참조 유형의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f4ae2ed79afdeb8f6c2a098503944e0bac2fe877" translate="yes" xml:space="preserve">
          <source>When applied to an array, the subscript expression is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; if the array is an lvalue, and an &lt;a href=&quot;value_category&quot;&gt;xvalue&lt;/a&gt; if it isn't(since C++11).</source>
          <target state="translated">배열에 적용될 때 배열이 &lt;a href=&quot;value_category&quot;&gt;lvalue 인&lt;/a&gt; 경우 아래 첨자 표현식은 lvalue이고 &lt;a href=&quot;value_category&quot;&gt;그렇지&lt;/a&gt; 않은 경우 xvalue 입니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="b3759c1c966a143bdfd4814a06fb7b793ddc31c8" translate="yes" xml:space="preserve">
          <source>When applied to an expression of polymorphic type, evaluation of a typeid expression may involve runtime overhead (a virtual table lookup), otherwise typeid expression is resolved at compile time.</source>
          <target state="translated">다형성 형식의 식에 적용 할 때 형식 식의 평가에는 런타임 오버 헤드 (가상 테이블 조회)가 포함될 수 있으며 그렇지 않으면 컴파일시 형식식이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="e5ed37890741158bbf054cf52a8ebbc0e73b98c9" translate="yes" xml:space="preserve">
          <source>When applied to an expression, &lt;code&gt;sizeof&lt;/code&gt; does &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;not evaluate the expression&lt;/a&gt;, and even if the expression designates a polymorphic object, the result is the size of the static type of the expression. Lvalue-to-rvalue, array-to-pointer, or function-to-pointer conversions are not performed. &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;Temporary materialization&lt;/a&gt;, however, is (formally) performed for prvalue arguments: sizeof determines the size of the result object.(since C++17).</source>
          <target state="translated">표현식에 적용될 때 &lt;code&gt;sizeof&lt;/code&gt; 는 &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;표현식을 평가&lt;/a&gt; 하지 않으며 표현식이 다형성 객체를 지정하더라도 결과는 정적 유형의 표현식 크기입니다. Lvalue-to-rvalue, 배열-포인터 또는 함수-포인터 변환은 수행되지 않습니다. 그러나 &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;임시 구체화&lt;/a&gt; 는 prvalue 인수에 대해 (공식적으로) 수행됩니다. sizeof는 결과 객체의 크기를 결정합니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="902efcbdae8639c2479afc412e93c5b16435e58a" translate="yes" xml:space="preserve">
          <source>When calling the allocation function, the new-expression passes the number of bytes requested as the first argument, of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, which is exactly &lt;code&gt;sizeof(T)&lt;/code&gt; for non-array &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">할당 함수를 호출 할 때, 새로운 표현 형식의 첫 번째 인수로서 요청 된 바이트 수 전달 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , 정확하게 &lt;code&gt;sizeof(T)&lt;/code&gt; 이외의 배열을 위해 &lt;code&gt;T&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="7aab9cd14cb0a3097419a3a095e5a8499afb16ff" translate="yes" xml:space="preserve">
          <source>When code refers to a function in context that requires the function definition to exist, and this particular function has not been explicitly instantiated, implicit instantiation occurs. The list of template arguments does not have to be supplied if it can be &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced&lt;/a&gt; from context.</source>
          <target state="translated">코드가 함수 정의가 있어야하는 컨텍스트의 함수를 참조하고이 특정 함수가 명시 적으로 인스턴스화되지 않은 경우 암시 적 인스턴스화가 발생합니다. 컨텍스트에서 &lt;a href=&quot;template_argument_deduction&quot;&gt;추론&lt;/a&gt; 할 수있는 경우 템플리트 인수 목록을 제공 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2f3a994250d478ff5309a561ec4f4f714968e84d" translate="yes" xml:space="preserve">
          <source>When code refers to a template in context that requires a completely defined type, or when the completeness of the type affects the code, and this particular type has not been explicitly instantiated, implicit instantiation occurs. For example, when an object of this type is constructed, but not when a pointer to this type is constructed.</source>
          <target state="translated">코드가 컨텍스트에서 완전히 정의 된 형식을 요구하거나 형식의 완성이 코드에 영향을 미치고이 특정 형식이 명시 적으로 인스턴스화되지 않은 템플릿을 참조하는 경우 암시 적 인스턴스화가 발생합니다. 예를 들어,이 유형의 오브젝트가 구성되었지만이 유형에 대한 포인터가 구성 될 때는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e579a073bc59e27215b96008dac2e50df4bb57db" translate="yes" xml:space="preserve">
          <source>When comparing entire containers for equality, &lt;code&gt;operator==&lt;/code&gt; for the corresponding container are usually preferred.</source>
          <target state="translated">전체 컨테이너가 동일한 지 비교할 때 해당 컨테이너에 대한 &lt;code&gt;operator==&lt;/code&gt; 가 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="47745284a6ed97288740ca09ddbb9f643055ef39" translate="yes" xml:space="preserve">
          <source>When considering the argument to a constructor or to a user-defined conversion function, only one standard conversion sequence is allowed (otherwise user-defined conversions could be effectively chained). When converting from one built-in type to another built-in type, only one standard conversion sequence is allowed.</source>
          <target state="translated">생성자 또는 사용자 정의 변환 함수에 대한 인수를 고려할 때 하나의 표준 변환 시퀀스 만 허용됩니다 (그렇지 않으면 사용자 정의 변환을 효과적으로 연결). 하나의 내장 유형에서 다른 내장 유형으로 변환 할 때는 하나의 표준 변환 시퀀스 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="553ce681044a1dac36f2a3c93df19f57a9078616" translate="yes" xml:space="preserve">
          <source>When constructing a complex class with multiple branches, within a constructor that belongs to one branch, polymorphism is restricted to that class and its bases: if it obtains a pointer or reference to a base subobject outside this subhierarchy, and attempts to invoke a virtual function call (e.g. using explicit member access), the behavior is undefined:</source>
          <target state="translated">하나의 브랜치에 속하는 생성자 내에서 여러 개의 브랜치를 가진 복잡한 클래스를 구성 할 때, 다형성은 해당 클래스와 그 기본으로 제한됩니다. 호출 (예 : 명시 적 멤버 액세스 사용) 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aed446bf94f330e6e0b55d02da8f34b88ffea9e7" translate="yes" xml:space="preserve">
          <source>When copy elision occurs, the implementation treats the source and target of the omitted copy/move(since C++11) operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization (except that, if the parameter of the selected constructor is an rvalue reference to object type, the destruction occurs when the target would have been destroyed)(since C++17).</source>
          <target state="translated">복사 제거가 발생하면 구현에서 생략 된 복사 / 이동 (C ++ 11 이후) 조작의 소스 및 대상을 동일한 오브젝트를 참조하는 두 가지 다른 방법으로 취급하고 해당 오브젝트의 파괴는 나중에 발생합니다. 선택한 생성자의 매개 변수가 객체 유형에 대한 rvalue 참조 인 경우를 제외하고 두 객체가 최적화없이 파괴 된 시간 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="2dc86f028e3cfb1147dc7e004b4c16749351361e" translate="yes" xml:space="preserve">
          <source>When copying overlapping ranges, &lt;code&gt;std::copy&lt;/code&gt; is appropriate when copying to the left (beginning of the destination range is outside the source range) while &lt;code&gt;std::copy_backward&lt;/code&gt; is appropriate when copying to the right (end of the destination range is outside the source range).</source>
          <target state="translated">겹치는 범위를 복사 할 때 &lt;code&gt;std::copy&lt;/code&gt; 는 왼쪽으로 복사 할 때 적합하고 (대상 범위의 시작이 소스 범위를 &lt;code&gt;std::copy_backward&lt;/code&gt; ), std :: copy_backward 는 오른쪽으로 복사 할 때 적합합니다 (대상 범위의 끝이 소스를 벗어남 ) 범위).</target>
        </trans-unit>
        <trans-unit id="63771776b0fe78c4297c086089bcc7b025dc8ded" translate="yes" xml:space="preserve">
          <source>When declaring a function, &lt;a href=&quot;except_spec&quot;&gt; exception specifications&lt;/a&gt; and &lt;a href=&quot;noexcept_spec&quot;&gt; noexcept specifiers&lt;/a&gt; may be provided to limit the types of the exceptions a function may throw.</source>
          <target state="translated">함수를 선언 할 때, &lt;a href=&quot;except_spec&quot;&gt;예외 스펙&lt;/a&gt; 과 &lt;a href=&quot;noexcept_spec&quot;&gt;noexcept 지정자가&lt;/a&gt; 제공되어 함수가 던질 수있는 예외 유형을 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a46821f25349d54835cd348827a97ba1db7215ad" translate="yes" xml:space="preserve">
          <source>When defining a member of an explicitly specialized class template outside the body of the class, the syntax &lt;code&gt;template &amp;lt;&amp;gt;&lt;/code&gt; is not used, except if it's a member of an explicitly specialized member class template, which is specialized as a class template, because otherwise, the syntax would require such definition to begin with &lt;code&gt;template&amp;lt;parameters&amp;gt;&lt;/code&gt; required by the nested template.</source>
          <target state="translated">클래스 본문 외부에서 명시 적으로 특수화 된 클래스 템플리트의 멤버를 정의 할 때 구문 &lt;code&gt;template &amp;lt;&amp;gt;&lt;/code&gt; 는 클래스 템플리트로 특수화 된 명시 적으로 특수화 된 멤버 클래스 템플리트의 멤버 인 경우를 제외하고 사용되지 않습니다. 구문은 그러한 정의가 중첩 된 템플리트에 필요한 &lt;code&gt;template&amp;lt;parameters&amp;gt;&lt;/code&gt; 로 시작 해야합니다.</target>
        </trans-unit>
        <trans-unit id="80a330b63ba0a84c45e73880291aa572a3efa1e6" translate="yes" xml:space="preserve">
          <source>When determining if two &lt;a href=&quot;dependent_name&quot;&gt;dependent expressions&lt;/a&gt; are equivalent, only the dependent names involved are considered, not the results of name lookup. If multiple declarations of the same template differ in the result of name lookup, the first such declaration is used:</source>
          <target state="translated">두 개의 &lt;a href=&quot;dependent_name&quot;&gt;종속 표현식&lt;/a&gt; 이 동일한 지 판별 할 때 이름 검색 결과가 아니라 관련된 종속 이름 만 고려됩니다. 동일한 템플릿에 대한 여러 선언이 이름 조회 결과에서 다른 경우 첫 번째 선언이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ef9fbc568a29fc667929a02fb6d63098b804ede" translate="yes" xml:space="preserve">
          <source>When directly used as the condition of &lt;a href=&quot;../language/static_assert&quot;&gt;&lt;code&gt;static_assert&lt;/code&gt; declaration&lt;/a&gt; or &lt;a href=&quot;../language/if#constexpr_if&quot;&gt;constexpr if statement&lt;/a&gt;, &lt;code&gt;std::is_constant_evaluated()&lt;/code&gt; always returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">직접의 조건으로 사용하는 경우 &lt;a href=&quot;../language/static_assert&quot;&gt; &lt;code&gt;static_assert&lt;/code&gt; 선언&lt;/a&gt; 또는 &lt;a href=&quot;../language/if#constexpr_if&quot;&gt;constexpr 문 경우&lt;/a&gt; , &lt;code&gt;std::is_constant_evaluated()&lt;/code&gt; 항상 반환 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18b778058d4f47bf64716da2bbf948a1a5fb94a5" translate="yes" xml:space="preserve">
          <source>When earlier tiebreakers, including partial ordering, failed to distinguish between two candidate function templates, the following rules apply:</source>
          <target state="translated">부분 순서를 포함한 초기 순위 결정이 두 후보 기능 템플리트를 구별하지 못한 경우 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c5dfcd38376374c25b198c54aa21d3fdad95c984" translate="yes" xml:space="preserve">
          <source>When enabled, for an object &lt;code&gt;o&lt;/code&gt; of type &lt;code&gt;std::optional&amp;lt;T&amp;gt;&lt;/code&gt; that contains a value, &lt;code&gt;std::hash&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;()(o)&lt;/code&gt; evaluates to the same value as &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;()(*o)&lt;/code&gt;. For an optional that does not contain a value, the hash is unspecified.</source>
          <target state="translated">사용 가능한 경우, 값이 포함 된 &lt;code&gt;std::optional&amp;lt;T&amp;gt;&lt;/code&gt; 유형 의 오브젝트 &lt;code&gt;o&lt;/code&gt; 에 대해 &lt;code&gt;std::hash&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;()(o)&lt;/code&gt; 는 &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;()(*o)&lt;/code&gt; 와 동일한 값으로 평가됩니다. std :: remove_const_t &amp;lt;T &amp;gt;&amp;gt; () (* o) . 값을 포함하지 않는 옵션의 경우 해시는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="903d975e1994ac3a37b90733c8025f08ecf31a3c" translate="yes" xml:space="preserve">
          <source>When enabled,(since C++17) for a given &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt; p&lt;/code&gt;, this specialization ensures that &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;&amp;gt;()(p) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;typename &lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;::pointer&amp;gt;()(p.get())&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt; p&lt;/code&gt; 대해 (C ++ 17부터) 활성화되면 이 전문화는 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;&amp;gt;()(p) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;typename &lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;::pointer&amp;gt;()(p.get())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19ae5f22223dec57ebaf47feb7ebf7c7e201fce6" translate="yes" xml:space="preserve">
          <source>When entering a catch clause, if its formal parameter is a base class of the exception type, it is &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialized&lt;/a&gt; from the base class subobject of the exception object. Otherwise, it is copy-initialized from the exception object (this copy is subject to &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;).</source>
          <target state="translated">catch 절을 입력 할 때 형식 매개 변수가 예외 유형 의 기본 클래스 인 경우 예외 오브젝트의 기본 클래스 서브 오브젝트에서 &lt;a href=&quot;copy_initialization&quot;&gt;복사 초기화&lt;/a&gt; 됩니다. 그렇지 않으면 (이 사본을받습니다 예외 객체에서 복사 초기화 &lt;a href=&quot;copy_elision&quot;&gt;복사 생략&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="16fd800e4f4545dc8c54147c76bdffd06523fe14" translate="yes" xml:space="preserve">
          <source>When erasing at either end of the deque, references to non-erased elements are not invalidated by &lt;code&gt;&lt;a href=&quot;deque/erase&quot;&gt;erase&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;deque/pop_front&quot;&gt;pop_front&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque/pop_back&quot;&gt;pop_back&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">deque의 한쪽 끝에서 지울 때 지워지지 않은 요소에 대한 참조는 &lt;code&gt;&lt;a href=&quot;deque/erase&quot;&gt;erase&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;deque/pop_front&quot;&gt;pop_front&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;deque/pop_back&quot;&gt;pop_back&lt;/a&gt;&lt;/code&gt; 로 무효화되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3e154c534821f10918bbd1a0adb594ebb17181d9" translate="yes" xml:space="preserve">
          <source>When every character of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">모든 출력 문자를 플러시해야 할 경우 &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; 조작기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a9eae4e1a206e51541973ab38f172716a809f23" translate="yes" xml:space="preserve">
          <source>When every output operation needs to be flushed, the &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">모든 출력 작업을 플러시해야 할 경우 &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; 조작기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de9fb1f75fc610360e59b80abf945bf3f980c7f7" translate="yes" xml:space="preserve">
          <source>When formatting a floating point value as hexfloat (i.e., when &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt;), the stream's precision is not used; instead, the number is always printed with enough precision to exactly represent the value.</source>
          <target state="translated">부동 소수점 값을 16 진 부동으로 형식화 할 때 (즉, &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt; ) 스트림의 정밀도는 사용되지 않습니다. 대신, 숫자는 항상 값을 정확하게 나타내기에 충분한 정밀도로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="a40d58e1eae50e8055be19035d8b5887a01317a2" translate="yes" xml:space="preserve">
          <source>When given reference types, &lt;code&gt;common_reference&lt;/code&gt; attempts to find a reference type to which the supplied reference types can all be bound, but may return a non-reference type if it cannot find such a reference type.</source>
          <target state="translated">참조 유형이 제공되면 &lt;code&gt;common_reference&lt;/code&gt; 는 제공된 참조 유형을 모두 바인드 할 수있는 참조 유형을 찾으려고하지만 해당 참조 유형을 찾을 수없는 경우 비 참조 유형을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd4bc57db1751ca1bef7fa50506950271e3c5d18" translate="yes" xml:space="preserve">
          <source>When indexing C++ containers, such as &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, etc, the appropriate type is the member typedef &lt;code&gt;size_type&lt;/code&gt; provided by such containers. It is usually defined as a synonym for &lt;code&gt;std::size_t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 등과 같은 C ++ 컨테이너를 색인 할 때 적절한 유형은 해당 컨테이너가 제공 하는 멤버 typedef &lt;code&gt;size_type&lt;/code&gt; 입니다. 일반적으로 &lt;code&gt;std::size_t&lt;/code&gt; 의 동의어로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ac68fbcc8bc1efc6049dde60f0e30093d3a91f7" translate="yes" xml:space="preserve">
          <source>When initialization of an object of non-class type cv1 &lt;code&gt;T&lt;/code&gt; requires a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; to convert from an initializer expression of class type cv &lt;code&gt;S&lt;/code&gt;, the following functions are candidates:</source>
          <target state="translated">비 클래스 유형 cv1 &lt;code&gt;T&lt;/code&gt; 의 오브젝트 초기화에 클래스 유형 cv &lt;code&gt;S&lt;/code&gt; 의 이니셜 라이저 표현식에서 &lt;a href=&quot;cast_operator&quot;&gt;변환&lt;/a&gt; 하기 위해 사용자 정의 변환 함수 가 필요한 경우 다음 함수가 후보입니다.</target>
        </trans-unit>
        <trans-unit id="f2f9ef8bbb329e61c10d08ae998e3ab7e71030d3" translate="yes" xml:space="preserve">
          <source>When initializing from a single argument of a type that is a specialization of the class template at issue, copying deduction is generally preferred over wrapping by default:</source>
          <target state="translated">문제가되는 클래스 템플릿을 전문으로하는 형식의 단일 인수에서 초기화하는 경우 일반적으로 기본적으로 줄 바꿈보다 복사 공제를 선호합니다.</target>
        </trans-unit>
        <trans-unit id="d46960739a911c065792d3eb6a771bd67fb54134" translate="yes" xml:space="preserve">
          <source>When inserting a range, the range version of &lt;code&gt;&lt;a href=&quot;insert&quot;&gt;insert()&lt;/a&gt;&lt;/code&gt; is generally preferable as it preserves the correct capacity growth behavior, unlike &lt;code&gt;reserve()&lt;/code&gt; followed by a series of &lt;code&gt;&lt;a href=&quot;push_back&quot;&gt;push_back()&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">범위를 삽입 할 때, &lt;code&gt;&lt;a href=&quot;insert&quot;&gt;insert()&lt;/a&gt;&lt;/code&gt; 의 범위 버전은 &lt;code&gt;reserve()&lt;/code&gt; 뒤에 일련의 &lt;code&gt;&lt;a href=&quot;push_back&quot;&gt;push_back()&lt;/a&gt;&lt;/code&gt; 과 달리 올바른 용량 증가 동작을 유지하므로 일반적으로 바람직합니다 .</target>
        </trans-unit>
        <trans-unit id="906401050b55fc9b72b5d2421e9144fbb190452a" translate="yes" xml:space="preserve">
          <source>When inserting at either end of the deque, references are not invalidated by &lt;code&gt;&lt;a href=&quot;deque/insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque/emplace&quot;&gt;emplace&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">deque의 양쪽 끝에 삽입 할 때 &lt;code&gt;&lt;a href=&quot;deque/insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;deque/emplace&quot;&gt;emplace&lt;/a&gt;&lt;/code&gt; 로 참조가 무효화되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d58dc4a9c1d64bc2047ee755578c50f3b966be84" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the floating-point types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;std::atomic&lt;/code&gt; provides additional atomic operations appropriate to floating-point types such as &lt;a href=&quot;atomic/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;atomic/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형이 부동 소수점 중 하나를 인스턴스화 할 때 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , 그리고 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;std::atomic&lt;/code&gt; 추가 원자 작업과 같은 부동 소수점 유형에 적절한 제공 &lt;a href=&quot;atomic/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;atomic/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="552f6dfa495a4acb2aa66f36a0ba5bf21b95fae5" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the floating-point types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;std::atomic_ref&lt;/code&gt; provides additional atomic operations appropriate to floating-point types such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형이 부동 소수점 중 하나를 인스턴스화 할 때 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , 그리고 &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;std::atomic_ref&lt;/code&gt; 추가 원자 작업과 같은 부동 소수점 유형에 적절한 제공 &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bac602845c57306b8db9e963ef0dfc1cad72696" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the following integral types, &lt;code&gt;std::atomic&lt;/code&gt; provides additional atomic operations appropriate to integral types such as &lt;a href=&quot;atomic/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_and&quot;&gt;&lt;code&gt;fetch_and&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_or&quot;&gt;&lt;code&gt;fetch_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_xor&quot;&gt;&lt;code&gt;fetch_xor&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음 정수 유형 중 하나로 인스턴스화되면 &lt;code&gt;std::atomic&lt;/code&gt; 은 &lt;a href=&quot;atomic/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic/fetch_and&quot;&gt; &lt;code&gt;fetch_and&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic/fetch_or&quot;&gt; &lt;code&gt;fetch_or&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic/fetch_xor&quot;&gt; &lt;code&gt;fetch_xor&lt;/code&gt; &lt;/a&gt; 와 같은 정수 유형에 적합한 추가 원자 연산을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="baa8ebba32798819cb5a6086f1e8129674336cd6" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the following integral types, &lt;code&gt;std::atomic_ref&lt;/code&gt; provides additional atomic operations appropriate to integral types such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_and&quot;&gt;&lt;code&gt;fetch_and&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_or&quot;&gt;&lt;code&gt;fetch_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_xor&quot;&gt;&lt;code&gt;fetch_xor&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음 정수 유형 중 하나로 인스턴스화되면 &lt;code&gt;std::atomic_ref&lt;/code&gt; 는 &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_and&quot;&gt; &lt;code&gt;fetch_and&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_or&quot;&gt; &lt;code&gt;fetch_or&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_xor&quot;&gt; &lt;code&gt;fetch_xor&lt;/code&gt; &lt;/a&gt; 와 같은 정수 유형에 적합한 추가 원자 연산을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="503d40b06333e935efd323a580b4acbb78349e5a" translate="yes" xml:space="preserve">
          <source>When it is needed to interpret the bytes of an object as a value of a different type, &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt;or &lt;a href=&quot;../numeric/bit_cast&quot;&gt;&lt;code&gt;std::bit_cast&lt;/code&gt;&lt;/a&gt;(since C++20)can be used:</source>
          <target state="translated">객체의 바이트를 다른 유형의 값으로 해석해야하는 경우 &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; 또는 &lt;a href=&quot;../numeric/bit_cast&quot;&gt; &lt;code&gt;std::bit_cast&lt;/code&gt; &lt;/a&gt; (C ++ 20부터)를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5281af908beb7c5eb475c7aeb21afb60dcc9c864" translate="yes" xml:space="preserve">
          <source>When language specifications nest, the innermost specification is the one that is in effect.</source>
          <target state="translated">언어 사양이 중첩되면 가장 안쪽 사양이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="016122add2c9877f6072526697f450c52a1f6394" translate="yes" xml:space="preserve">
          <source>When making an explicit call to the conversion function, the type-id is greedy: it is the longest possible sequence of tokens that is a valid type id (including attributes, if any):</source>
          <target state="translated">변환 함수를 명시 적으로 호출 할 때 type-id는 욕심입니다. 유효한 type id (있는 경우 속성 포함) 인 가장 긴 토큰 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="c7b5147658508bc213c62aa761a47793df025adb" translate="yes" xml:space="preserve">
          <source>When moving overlapping ranges, &lt;code&gt;std::move&lt;/code&gt; is appropriate when moving to the left (beginning of the destination range is outside the source range) while &lt;code&gt;std::move_backward&lt;/code&gt; is appropriate when moving to the right (end of the destination range is outside the source range).</source>
          <target state="translated">겹치는 범위를 &lt;code&gt;std::move&lt;/code&gt; 때 std :: move 는 왼쪽으로 이동할 때 적합하고 (대상 범위의 시작은 소스 범위를 &lt;code&gt;std::move_backward&lt;/code&gt; ) std :: move_backward 는 오른쪽으로 이동할 때 적합합니다 (대상 범위의 끝은 소스 밖에 있음) 범위).</target>
        </trans-unit>
        <trans-unit id="bcc9e1f7b6bbebc1441b5e338721e2a64a3a6fc2" translate="yes" xml:space="preserve">
          <source>When no more matches are found, copies the remaining non-matched characters to &lt;code&gt;out&lt;/code&gt; as if by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(last_m.suffix().first, last_m.suffix().second, out)&lt;/code&gt; where &lt;code&gt;last_m&lt;/code&gt; is a copy of the last match found.</source>
          <target state="translated">더 이상 일치하는 항목이 없으면 &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(last_m.suffix().first, last_m.suffix().second, out)&lt;/code&gt; &lt;a href=&quot;../algorithm/copy&quot;&gt;std :: copy&lt;/a&gt; (last_m.suffix (). first, last_m.suffix (). second, out) 와 같이 나머지 일치하지 않는 문자를 &lt;code&gt;out&lt;/code&gt; 으로 복사 합니다. 여기서 &lt;code&gt;last_m&lt;/code&gt; 은 마지막으로 찾은 일치</target>
        </trans-unit>
        <trans-unit id="a989818254cf8030ca8ff78fd514d37b03472368" translate="yes" xml:space="preserve">
          <source>When one of them is found by &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;normal unqualified lookup&lt;/a&gt; for the name to the left of the function-call operator, it inhibits &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt;.</source>
          <target state="translated">함수 호출 연산자 왼쪽의 이름에 대한 &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;정규화되지 않은 정규 조회&lt;/a&gt; 에서 이들 중 하나가 발견되면 &lt;a href=&quot;../../language/adl&quot;&gt;인수 종속 조회를&lt;/a&gt; 금지 합니다.</target>
        </trans-unit>
        <trans-unit id="1514e0d97ec7c21ec7cdc4fc2229658217c2a1d3" translate="yes" xml:space="preserve">
          <source>When one or more lock-free atomic functions run concurrently, at least one of them is guaranteed to complete (all standard library lock-free operations are &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom&quot;&gt;lock-free&lt;/a&gt; -- it is the job of the implementation to ensure they cannot be live-locked indefinitely by other threads, such as by continuously stealing the cache line).</source>
          <target state="translated">하나 이상의 잠금없는 원자 함수가 동시에 실행될 때, 그 중 하나 이상이 완료되도록 보장됩니다 (모든 표준 라이브러리 잠금없는 조작은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom&quot;&gt;잠금이 없음&lt;/a&gt; -라이브 잠금이되지 않도록하는 것은 구현의 일입니다) 캐시 라인을 지속적으로 훔치는 것과 같은 다른 스레드에 의해 무기한으로).</target>
        </trans-unit>
        <trans-unit id="c525266500bfb2286ded86306e069bde3c22c32c" translate="yes" xml:space="preserve">
          <source>When one statement is expected, but multiple statements need to be executed in sequence (for example, in an &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; statement or a loop), a compound statement may be used:</source>
          <target state="translated">하나의 명령문이 예상되지만 여러 명령문을 순서대로 실행해야하는 &lt;a href=&quot;if&quot;&gt;경우&lt;/a&gt; (예 : if 문 또는 루프) 복합 명령문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99ceddfac8288288bcf4a468dfcdde568e2b94f6" translate="yes" xml:space="preserve">
          <source>When only one thread that is not blocked in a standard library function executes an &lt;a href=&quot;../atomic&quot;&gt;atomic function&lt;/a&gt; that is lock-free, that execution is guaranteed to complete (all standard library lock-free operations are &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom&quot;&gt;obstruction-free&lt;/a&gt;).</source>
          <target state="translated">표준 라이브러리 함수에서 차단되지 않은 하나의 스레드 만 잠금이없는 &lt;a href=&quot;../atomic&quot;&gt;원자 함수&lt;/a&gt; 를 실행하면 해당 실행이 완료됩니다 (모든 표준 라이브러리 잠금이없는 작업은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom&quot;&gt;방해가 없습니다&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="be17634a4507a825d9841a9ec6ecaee80238b41e" translate="yes" xml:space="preserve">
          <source>When parsing an expression, an operator which is listed on some row of the table above with a precedence will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it with a lower precedence. For example, the expressions &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a &amp;amp; b&lt;/code&gt; and &lt;code&gt;*p++&lt;/code&gt; are parsed as &lt;code&gt;(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a) &amp;amp; b&lt;/code&gt; and &lt;code&gt;*(p++)&lt;/code&gt;, and not as &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; (a &amp;amp; b)&lt;/code&gt; or &lt;code&gt;(*p)++&lt;/code&gt;.</source>
          <target state="translated">표현식을 구문 분석 할 때, 우선 순위가있는 위 표의 일부 행에 나열된 연산자는 우선 순위가 낮은 행 아래에있는 연산자보다 괄호로 묶인 것처럼 인수에 더 밀접하게 바인딩됩니다. 예를 들어, 표현은 &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a &amp;amp; b&lt;/code&gt; 및 &lt;code&gt;*p++&lt;/code&gt; 로 구문 분석 &lt;code&gt;(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a) &amp;amp; b&lt;/code&gt; 및 &lt;code&gt;*(p++)&lt;/code&gt; 과하지 &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; (a &amp;amp; b)&lt;/code&gt; 또는 &lt;code&gt;(*p)++&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f8b48f697df0e524fccfbe77ccb0c6aefdae765c" translate="yes" xml:space="preserve">
          <source>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing &lt;code&gt;&quot;100er&quot;&lt;/code&gt; with the conversion specifier &lt;code&gt;%f&lt;/code&gt;, the sequence &lt;code&gt;&quot;100e&quot;&lt;/code&gt; (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with &lt;code&gt;&quot;r&quot;&lt;/code&gt; remaining. Some existing implementations do not follow this rule and roll back to consume only &lt;code&gt;&quot;100&quot;&lt;/code&gt;, leaving &lt;code&gt;&quot;er&quot;&lt;/code&gt;, e.g. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;glibc bug 1765&lt;/a&gt;.</source>
          <target state="translated">변환 지정자 &lt;code&gt;%f&lt;/code&gt; &lt;code&gt;&quot;100er&quot;&lt;/code&gt; 구문 분석과 같이 숫자없이 지수로 끝나는 불완전한 부동 소수점 값을 구문 분석 할 때 &lt;code&gt;&quot;100e&quot;&lt;/code&gt; 시퀀스 (유효한 부동 소수점 숫자의 가장 긴 접 두부)가 사용됩니다. &lt;code&gt;&quot;r&quot;&lt;/code&gt; 이 남아 있으면 일치하는 오류 (소비 된 시퀀스를 부동 소수점 숫자로 변환 할 수 없음)가 발생합니다 . 일부 기존 구현은이 규칙을 따르지 않고 &lt;code&gt;&quot;100&quot;&lt;/code&gt; 만 소비하도록 롤백 하여 &lt;code&gt;&quot;er&quot;&lt;/code&gt; (예 : &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;glibc 버그 1765)를&lt;/a&gt; 남겨 둡니다 .</target>
        </trans-unit>
        <trans-unit id="f862fd02527b95bbe0a34ac38eb69a8e6f210d9f" translate="yes" xml:space="preserve">
          <source>When performing N:M conversions, this function may return &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::partial&lt;/a&gt;&lt;/code&gt; after consuming all source characters (&lt;code&gt;from_next == from_end&lt;/code&gt;). This means that another internal character is needed to complete the conversion (e.g. when converting UTF-16 to UTF-8, if the last character in the source buffer is a high surrogate).</source>
          <target state="translated">N : M 변환을 수행 할 때이 함수는 모든 소스 문자 ( &lt;code&gt;from_next == from_end&lt;/code&gt; )를 사용한 후 &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::partial&lt;/a&gt;&lt;/code&gt; 을 리턴 할 수 있습니다 . 이는 변환을 완료하기 위해 다른 내부 문자가 필요함을 의미합니다 (예 : 소스 버퍼의 마지막 문자가 높은 대리 문자 인 경우 UTF-16을 UTF-8로 변환 할 때).</target>
        </trans-unit>
        <trans-unit id="73238300a6abe634b092cd3c78bfa124e710c17c" translate="yes" xml:space="preserve">
          <source>When performing matches, all marked sub-expressions &lt;code&gt;(expr)&lt;/code&gt; are treated as non-marking sub-expressions &lt;code&gt;(?:expr)&lt;/code&gt;. No matches are stored in the supplied &lt;code&gt;&lt;a href=&quot;../regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; structure and &lt;code&gt;mark_count()&lt;/code&gt; is zero</source>
          <target state="translated">일치를 수행 할 때 표시된 모든 하위 표현식 &lt;code&gt;(expr)&lt;/code&gt; 은 비 마킹 하위 표현식 &lt;code&gt;(?:expr)&lt;/code&gt; 으로 처리 됩니다. 제공된 &lt;code&gt;&lt;a href=&quot;../regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; 구조 에 일치하는 항목이 없고 &lt;code&gt;mark_count()&lt;/code&gt; 가 0입니다.</target>
        </trans-unit>
        <trans-unit id="c20cd38801efcb855e60aac217866665e1148ddd" translate="yes" xml:space="preserve">
          <source>When performing matches, all marked sub-expressions &lt;code&gt;(expr)&lt;/code&gt; are treated as non-marking sub-expressions &lt;code&gt;(?:expr)&lt;/code&gt;. No matches are stored in the supplied &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; structure and &lt;code&gt;mark_count()&lt;/code&gt; is zero</source>
          <target state="translated">일치를 수행 할 때 표시된 모든 하위 표현식 &lt;code&gt;(expr)&lt;/code&gt; 은 비 마킹 하위 표현식 &lt;code&gt;(?:expr)&lt;/code&gt; 으로 처리 됩니다. 제공된 &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; 구조 에 일치하는 항목이 없고 &lt;code&gt;mark_count()&lt;/code&gt; 가 0입니다.</target>
        </trans-unit>
        <trans-unit id="f4f7d6dbe3d540b5d3f8d4a7ca45e962b95c0edb" translate="yes" xml:space="preserve">
          <source>When placeholder types (either &lt;code&gt;auto&lt;/code&gt; or &lt;a href=&quot;../concepts&quot;&gt;Concept auto&lt;/a&gt;) appear in the parameter list of a function declaration or of a function template declaration, the declaration declares a function template, and one invented template parameter for each placeholder is appended to the template parameter list.</source>
          <target state="translated">자리 표시 자 유형 ( &lt;code&gt;auto&lt;/code&gt; 또는 &lt;a href=&quot;../concepts&quot;&gt;Concept auto&lt;/a&gt; )이 함수 선언 또는 함수 템플릿 선언의 매개 변수 목록에 나타나면 선언에서 함수 템플릿을 선언하고 각 자리 표시 자에 대해 하나의 발명 된 템플릿 매개 변수가 템플릿 매개 변수 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="641c7fd3577d0edc6efac99f2f76379fc6931592" translate="yes" xml:space="preserve">
          <source>When reading characters, &lt;code&gt;std::istream_iterator&lt;/code&gt; skips whitespace by default (unless disabled with &lt;code&gt;&lt;a href=&quot;../io/manip/skipws&quot;&gt;std::noskipws&lt;/a&gt;&lt;/code&gt; or equivalent), while &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; does not. In addition, &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.</source>
          <target state="translated">문자를 읽을 때 &lt;code&gt;std::istream_iterator&lt;/code&gt; 는 기본적으로 공백을 건너 뛰고 ( &lt;code&gt;&lt;a href=&quot;../io/manip/skipws&quot;&gt;std::noskipws&lt;/a&gt;&lt;/code&gt; 또는 이와 동등한 기능으로 비활성화하지 않는 한 ) &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; 는 그렇지 않습니다. 또한 &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; 는 문자 당 한 번 센트리 객체를 구성하고 파괴하는 오버 헤드를 피하기 때문에보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="1ab1d2134a41c9628e2098e71305ab92b1cd2216" translate="yes" xml:space="preserve">
          <source>When rethrowing exceptions, the second form must be used to avoid object slicing in the (typical) case where exception objects use inheritance:</source>
          <target state="translated">예외를 다시 던질 때 두 번째 형식은 예외 개체가 상속을 사용하는 (일반적인) 경우에 개체 슬라이스를 피하기 위해 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f9fb914caea510cf6dfabbb484a007b28ab4e8a3" translate="yes" xml:space="preserve">
          <source>When signal handler is set to a function and a signal occurs, it is implementation defined whether &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; will be executed immediately before the start of signal handler. Also, the implementation can prevent some implementation-defined set of signals from occurring while the signal handler runs.</source>
          <target state="translated">신호 처리기가 함수로 설정되고 신호가 발생하면 신호 처리기가 시작되기 직전에 &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; 을 실행 할지 여부가 정의 된 구현 입니다. 또한, 구현은 신호 핸들러가 실행되는 동안 구현 정의 된 신호 세트가 발생하는 것을 막을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a82c7324d6d1f526ac5299ac166aafff69e4a350" translate="yes" xml:space="preserve">
          <source>When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined: it may wrap around according to the rules of the representation (typically 2's complement), it may trap on some platforms or due to compiler options (e.g. &lt;code&gt;-ftrapv&lt;/code&gt; in GCC and Clang), or may be completely &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;optimized out by the compiler&lt;/a&gt;.</source>
          <target state="translated">부호있는 정수 산술 연산이 오버플로되면 (결과가 결과 유형에 맞지 않음) 동작이 정의되지 않습니다. 표현 규칙 (일반적으로 2의 보수)에 따라 줄 바꿈 될 수 있으며 일부 플랫폼에서 또는 컴파일러로 인해 트랩 될 수 있습니다. 옵션 (예 &lt;code&gt;-ftrapv&lt;/code&gt; GCC와 연타)에, 또는 완전히 될 수도 &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;컴파일러에 의해 최적화&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9deeffc3f0edffbc9e7bf40fc167f8af90637021" translate="yes" xml:space="preserve">
          <source>When some &lt;a href=&quot;../algorithm/ranges&quot;&gt;constrain algorithms&lt;/a&gt; that usually return an iterator or a subrange of a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; take a particular rvalue &lt;code&gt;Range&lt;/code&gt; argument that does not models exposition-only concept &lt;a href=&quot;range&quot;&gt;&lt;code&gt;__ForwardingRange&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;dangling&lt;/code&gt; will be returned instead to avoid returning potentially dangling results.</source>
          <target state="translated">어떤 경우에는 &lt;a href=&quot;../algorithm/ranges&quot;&gt;구속 알고리즘&lt;/a&gt; 일반적으로 반복자 또는의 부분 범위 반환 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 특정를 rvalue 걸릴 &lt;code&gt;Range&lt;/code&gt; 되지 모델 박람회 전용 개념 않습니다 인수 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;__ForwardingRange&lt;/code&gt; 를&lt;/a&gt; , &lt;code&gt;dangling&lt;/code&gt; 잠재적으로 매달려 결과를 반환하지 않도록하는 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8b1e13bc5e72c1d99187d326eff8cc95c6a2ce2a" translate="yes" xml:space="preserve">
          <source>When specializing a function template, its template arguments can be omitted if &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; can provide them from the function arguments:</source>
          <target state="translated">함수 템플릿을 특수화 할 때 &lt;a href=&quot;template_argument_deduction&quot;&gt;템플릿 인수 공제&lt;/a&gt; 가 함수 인수에서 제공 할 수있는 경우 해당 템플릿 인수를 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca2cbab4c43c7973149386ddec137d524c3e9fe8" translate="yes" xml:space="preserve">
          <source>When string literal concatenation takes place in &lt;a href=&quot;translation_phases&quot;&gt;translation phase 6&lt;/a&gt;, user-defined string literals are concatenated as well, and their ud-suffixes are ignored for the purpose of concatenation, except that only one suffix may appear on all concatenated literals:</source>
          <target state="translated">문자열 리터럴 연결이 &lt;a href=&quot;translation_phases&quot;&gt;변환 단계 6에서 발생&lt;/a&gt; 하면 사용자 정의 문자열 리터럴도 연결되며 연결 목적으로 접미사 ud- 접미어는 무시됩니다. 단, 접미사 하나만 접미사 하나만 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1799979c98bbbebaef89ed6f1828299ab2b6a5e5" translate="yes" xml:space="preserve">
          <source>When such member function is declared in class X, it performs conversion from X to conversion-type-id:</source>
          <target state="translated">이러한 멤버 함수가 클래스 X에서 선언되면 X에서 conversion-type-id 로의 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1b9fe1265be0c139fe6cde0ba421b142a03ada23" translate="yes" xml:space="preserve">
          <source>When template arguments are provided, or, for &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;function&lt;/a&gt; and &lt;a href=&quot;deduction_guide&quot;&gt;class&lt;/a&gt;(since C++17) templates only, deduced, they are substituted for the template parameters to obtain a</source>
          <target state="translated">템플릿 인수가 제공되거나 &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;함수&lt;/a&gt; 및 &lt;a href=&quot;deduction_guide&quot;&gt;클래스&lt;/a&gt; (C ++ 17 이후) 템플릿에 대해서만 추론되는 경우 템플릿 인수는 템플릿 매개 변수로 대체되어</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">때</target>
        </trans-unit>
        <trans-unit id="aa5703929047ae870cd9bedc4f9eebb911b80493" translate="yes" xml:space="preserve">
          <source>When the argument is a class template, only the primary template is considered when matching the parameter. The partial specializations, if any, are only considered when a specialization based on this template template parameter happens to be instantiated.</source>
          <target state="translated">인수가 클래스 템플리트 인 경우 매개 변수를 일치시킬 때 기본 템플리트 만 고려됩니다. 부분 특수화 (있는 경우)는이 템플리트 템플리트 매개 변수를 기반으로 한 특수화가 인스턴스화 될 때만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="657c97ad1dccca00440cdc8eb7bd687219c46fbe" translate="yes" xml:space="preserve">
          <source>When the asynchronous operation is ready to send a result to the creator, it can do so by modifying</source>
          <target state="translated">비동기 작업이 결과를 작성자에게 보낼 준비가되면 수정하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3e1fc309740231aa065058d4a26e16a2e51f547" translate="yes" xml:space="preserve">
          <source>When the compiler encounters a user-defined literal with ud-suffix&lt;code&gt;X&lt;/code&gt;, it performs &lt;a href=&quot;lookup#Unqualified_name_lookup&quot;&gt;unqualified name lookup&lt;/a&gt;, looking for a function with the name &lt;code&gt;operator &quot;&quot; X&lt;/code&gt;. If the lookup does not find a declaration, the program is ill-formed. Otherwise,</source>
          <target state="translated">컴파일러에서 ud-suffix &lt;code&gt;X&lt;/code&gt; 로 사용자 정의 리터럴을 발견하면 &lt;a href=&quot;lookup#Unqualified_name_lookup&quot;&gt;정규화되지 않은 이름 조회를&lt;/a&gt; 수행 하여 이름 &lt;code&gt;operator &quot;&quot; X&lt;/code&gt; 있는 함수를 찾습니다 . 조회에서 선언을 찾지 못하면 프로그램이 잘못 구성됩니다. 그렇지 않으면,</target>
        </trans-unit>
        <trans-unit id="a6e3ba42f8de770e69687876d93e30231038db0e" translate="yes" xml:space="preserve">
          <source>When the compiler encounters an unknown name in a program, it associates it with the declaration that introduced the name by means of &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, except for the &lt;a href=&quot;dependent_name&quot;&gt;dependent names&lt;/a&gt; in template declarations and definitions (for those names, the compiler determines whether they name a type, a template, or some other entity, which may require &lt;a href=&quot;dependent_name&quot;&gt;explicit disambiguation&lt;/a&gt;).</source>
          <target state="translated">컴파일러가 프로그램에서 알 수없는 이름을 발견하면 템플릿 선언 및 정의 의 &lt;a href=&quot;dependent_name&quot;&gt;종속 이름&lt;/a&gt; 을 제외하고 &lt;a href=&quot;lookup&quot;&gt;이름 조회를&lt;/a&gt; 통해 이름을 도입 한 선언과 이름을 연관시킵니다 (해당 이름의 경우 컴파일러는 유형의 이름 지정 여부를 판별 함). , 템플릿 또는 다른 엔티티 ( &lt;a href=&quot;dependent_name&quot;&gt;명확한 명확성을&lt;/a&gt; 요구할 수 있음 )</target>
        </trans-unit>
        <trans-unit id="3ffc67b2c989f365607047bd77316e5ecdadcda9" translate="yes" xml:space="preserve">
          <source>When the condition variable is notified, a timeout expires, or a &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious_wakeup&quot;&gt;spurious wakeup&lt;/a&gt; occurs, the thread is awakened, and the mutex is atomically reacquired. The thread should then check the condition and resume waiting if the wake up was spurious.</source>
          <target state="translated">조건 변수가 통지되거나, 시간 종료가 만료되거나, &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious_wakeup&quot;&gt;가짜 웨이크 업이&lt;/a&gt; 발생하면 스레드가 깨어나고 뮤텍스가 원자 적으로 다시 획득됩니다. 그런 다음 스레드는 상태를 확인하고 웨이크 업이 의심스러운 경우 대기를 재개해야합니다.</target>
        </trans-unit>
        <trans-unit id="16dd5023449c37e3ee571367f3544e6dbf21123f" translate="yes" xml:space="preserve">
          <source>When the coroutine state is destroyed either because it terminated via co_return or uncaught exception, or because it was destroyed via its handle, it does the following:</source>
          <target state="translated">코 루틴 상태가 co_return 또는 catch되지 않은 예외를 통해 종료되었거나 핸들을 통해 파괴 되었기 때문에 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d296094acb938c3d5a36e0feef5bea491289a47a" translate="yes" xml:space="preserve">
          <source>When the default allocator is used, this results in the key being copy constructed from &lt;code&gt;key&lt;/code&gt; and the mapped value being &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">디폴트 할당이 사용되는 경우, 키 존재이 결과로부터 구성된 복사 &lt;code&gt;key&lt;/code&gt; 와 맵핑 된 값이되는 &lt;a href=&quot;../../language/value_initialization&quot;&gt;값으로 초기화&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9fddcbdad59ebcc2389e29ab9d251d255ff093b" translate="yes" xml:space="preserve">
          <source>When the default allocator is used, this results in the key being move constructed from &lt;code&gt;key&lt;/code&gt; and the mapped value being &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">디폴트 할당이 사용되는 경우, 키 존재 이동이 결과로부터 구성된 &lt;code&gt;key&lt;/code&gt; 와 맵핑 된 값이되는 &lt;a href=&quot;../../language/value_initialization&quot;&gt;값으로 초기화&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31f633e1dfad19457b495484c1fbe0072bbb264f" translate="yes" xml:space="preserve">
          <source>When the default semantics are not suitable, such as when the members must be compared out of order, or must use a comparison that's different from their natural comparison, then the programmer can write &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; and let the compiler generate the appropriate relational operators. The kind of relational operators generated depends on the return type of the user-defined &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">멤버가 비 순차적으로 비교되거나 자연 비교와 다른 비교를 사용해야하는 경우와 같이 기본 의미가 적합하지 않은 경우 프로그래머는 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 작성 하고 컴파일러가 적절한 관계형 연산자를 생성 할 수 있습니다. . 생성되는 관계 연산자의 종류는 사용자 정의 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 의 반환 유형에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="5f0cf9abe0b614f53329302ad0d6b53be9c5214c" translate="yes" xml:space="preserve">
          <source>When the element type of an array is another array, it is said that the array is multidimensional:</source>
          <target state="translated">배열의 요소 유형이 다른 배열 인 경우 배열이 다차원이라고합니다.</target>
        </trans-unit>
        <trans-unit id="8371d69254feffac85782c93e2437f4715cd1cb6" translate="yes" xml:space="preserve">
          <source>When the initializer is a prvalue, the move constructor call is often optimized out(until C++17)never made(since C++17), see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">이니셜 라이저가 prvalue 인 경우 이동 생성자 호출은 종종 C ++ 17 이후로 만들어지지 않을 때까지 최적화됩니다 (C ++ 17 이후) . &lt;a href=&quot;copy_elision&quot;&gt;복사 제거를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="10770c6e57727da2d2faacfcf5bbaf211dbc1a9b" translate="yes" xml:space="preserve">
          <source>When the left operand has reference type, the assignment operator modifies the referred-to object.</source>
          <target state="translated">왼쪽 피연산자에 참조 유형이 있으면 대입 연산자는 참조 된 오브젝트를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="0d0dbe17faf8b2da57c150cba1c216b9daf8702b" translate="yes" xml:space="preserve">
          <source>When the member type &lt;code&gt;pointer&lt;/code&gt; is not a raw pointer type, it is commonly referred to as a &quot;fancy pointer&quot;. Such pointers were introduced to support segmented memory architectures and are used today to access objects allocated in address spaces that differ from the homogeneous virtual address space that is accessed by raw pointers. An example of a fancy pointer is the mapping address-independent pointer &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;boost::interprocess::offset_ptr&lt;/a&gt;, which makes it possible to allocate node-based data structures such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; in shared memory and memory mapped files mapped in different addresses in every process. Fancy pointers can be used independently of the allocator that provided them, through the class template &lt;code&gt;&lt;a href=&quot;../memory/pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">멤버 유형 &lt;code&gt;pointer&lt;/code&gt; 가 원시 포인터 유형이 아닌 경우 일반적으로 &quot;팬시 포인터&quot;라고합니다. 이러한 포인터는 세그먼트 화 된 메모리 아키텍처를 지원하기 위해 도입되었으며 오늘날 원시 포인터가 액세스하는 동종 가상 주소 공간과 다른 주소 공간에 할당 된 객체에 액세스하는 데 사용됩니다. 멋진 포인터의 예는 매핑 주소 독립적 포인터 &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;boost :: interprocess :: offset_ptr&lt;/a&gt; 이며, 이는 공유 메모리의 &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; 및 다른 주소에 매핑 된 메모리 매핑 된 파일과 같은 노드 기반 데이터 구조를 할당 할 수있게 합니다. 모든 과정. 멋진 포인터는 &lt;code&gt;&lt;a href=&quot;../memory/pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; 클래스 템플릿을 통해 제공 한 할당 자에 독립적으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5274fa05e554f295c79e7685559fdf8aca77d5a3" translate="yes" xml:space="preserve">
          <source>When the member type &lt;code&gt;pointer&lt;/code&gt; is not a raw pointer type, it is commonly referred to as a &quot;fancy pointer&quot;. Such pointers were introduced to support segmented memory architectures and are used today to access objects allocated in address spaces that differ from the homogeneous virtual address space that is accessed by raw pointers. An example of a fancy pointer is the mapping address-independent pointer &lt;a href=&quot;https://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;boost::interprocess::offset_ptr&lt;/a&gt;, which makes it possible to allocate node-based data structures such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; in shared memory and memory mapped files mapped in different addresses in every process. Fancy pointers can be used independently of the allocator that provided them, through the class template &lt;code&gt;&lt;a href=&quot;../memory/pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e345263d3c16be0359604e2c7e37e80d322c6999" translate="yes" xml:space="preserve">
          <source>When the name of a non-type template parameter is used in an expression within the body of the class template, it is an unmodifiable &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; unless its type was an lvalue reference type, or unless its type is a class type(since C++20).</source>
          <target state="translated">유형이 아닌 템플릿 매개 변수의 이름이 클래스 템플릿의 본문에있는 식에 사용되면 해당 유형이 lvalue 참조 유형이 아니거나 유형이 클래스 유형이 아닌 경우 &lt;a href=&quot;value_category&quot;&gt;수정할 수&lt;/a&gt; 없는 prvalue입니다 (C ++ 이후) 20).</target>
        </trans-unit>
        <trans-unit id="0dd4c2cd3956549ff3cdd1f8a7caf6b32e2cea01" translate="yes" xml:space="preserve">
          <source>When the noexcept-specification of a function template specialization is</source>
          <target state="translated">함수 템플릿 전문화의 noexcept-specification이</target>
        </trans-unit>
        <trans-unit id="cc159284033553cbafc104d522a5cf1ae76e1549" translate="yes" xml:space="preserve">
          <source>When the number of variants is zero or one, the invocation of the callable object is implemented in constant time, i.e. it does not depend on &lt;code&gt;sizeof...(Types)&lt;/code&gt;.</source>
          <target state="translated">변형의 수가 0 또는 1 인 경우, 호출 가능한 객체의 호출은 일정한 시간에 구현됩니다. 즉, &lt;code&gt;sizeof...(Types)&lt;/code&gt; 에 의존하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b8b02aaeadad3d163b0d5be165966951d5f6a133" translate="yes" xml:space="preserve">
          <source>When the parameter-list is not empty, an optional comma may precede a &lt;code&gt;...&lt;/code&gt; signifying a variadic function. This provides compatibility with C (which added a requirement for a comma when it adopted function prototypes from C++).</source>
          <target state="translated">parameter-list가 비어 있지 않은 경우, 선택적 쉼표가 가변 변수를 나타내는 &lt;code&gt;...&lt;/code&gt; 앞에 올 수 있습니다. 이는 C와의 호환성을 제공합니다 (C ++에서 함수 프로토 타입을 채택 할 때 쉼표가 필요함).</target>
        </trans-unit>
        <trans-unit id="eadbea007ec076285100c5cbd07b8a2dc8928700" translate="yes" xml:space="preserve">
          <source>When the parser encounters the character sequence &lt;code&gt;&amp;lt;::&lt;/code&gt; and the subsequent character is neither &lt;code&gt;:&lt;/code&gt; nor &lt;code&gt;&amp;gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;&lt;/code&gt; is treated as a preprocessing token by itself and not as the first character of the alternative token &lt;code&gt;&amp;lt;:&lt;/code&gt;. Thus &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;::&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; won't be wrongly treated as &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;[:&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">파서가 문자 시퀀스 &lt;code&gt;&amp;lt;::&lt;/code&gt; 를 만나고 후속 문자가 &lt;code&gt;:&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&lt;/code&gt; 가 아닌 경우 &lt;code&gt;&amp;lt;&lt;/code&gt; 는 대체 토큰 &lt;code&gt;&amp;lt;:&lt;/code&gt; 의 첫 번째 문자가 아니라 전처리 토큰으로 처리됩니다 . 따라서 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;::&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;[:&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; 으로 잘못 취급되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8cc2032d32ca7885f140b25a96dcbee6c5397ce4" translate="yes" xml:space="preserve">
          <source>When the postfix increment and decrement appear in an expression, the corresponding user-defined function (&lt;code&gt;operator++&lt;/code&gt; or &lt;code&gt;operator--&lt;/code&gt;) is called with an integer argument &lt;code&gt;0&lt;/code&gt;. Typically, it is implemented as &lt;code&gt;T operator++(int)&lt;/code&gt;, where the argument is ignored. The postfix increment and decrement operator is usually implemented in terms of the prefix version:</source>
          <target state="translated">접미사 증가 및 감소가 표현식에 나타나면 해당 사용자 정의 함수 ( &lt;code&gt;operator++&lt;/code&gt; 또는 &lt;code&gt;operator--&lt;/code&gt; )가 정수 인수 &lt;code&gt;0&lt;/code&gt; 으로 호출됩니다 . 일반적으로 인수는 무시되는 &lt;code&gt;T operator++(int)&lt;/code&gt; 로 구현됩니다 . 접미사 증분 및 감소 연산자는 일반적으로 접두사 버전으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="fd043f49a212d5450703bb9a052e4fa639f20396" translate="yes" xml:space="preserve">
          <source>When the regex library needs to match two characters &lt;code&gt;c1&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt; and the flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it executes &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate(c1) == regex_traits&amp;lt;&amp;gt;::translate(c2)&lt;/code&gt;.</source>
          <target state="translated">정규식 라이브러리가 두 문자 &lt;code&gt;c1&lt;/code&gt; 및 &lt;code&gt;c2&lt;/code&gt; 와 일치 하고 &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; 플래그 가 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate(c1) == regex_traits&amp;lt;&amp;gt;::translate(c2)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a73f957522574e9d880fc3def8f3dd16383a3e89" translate="yes" xml:space="preserve">
          <source>When the regex library needs to match two characters &lt;code&gt;c1&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt; and the flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it executes &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate_nocase(c1) == regex_traits&amp;lt;&amp;gt;::translate_nocase(c2)&lt;/code&gt;.</source>
          <target state="translated">정규식 라이브러리 요구는 두 개의 문자가 일치하는 경우 &lt;code&gt;c1&lt;/code&gt; 과 &lt;code&gt;c2&lt;/code&gt; 와 플래그 &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; 것입니다 &lt;code&gt;true&lt;/code&gt; , 그것을 실행하는 &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate_nocase(c1) == regex_traits&amp;lt;&amp;gt;::translate_nocase(c2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59285875d0142d5e8a1eb450e8a3f9927249ea97" translate="yes" xml:space="preserve">
          <source>When the result of specializing an alias template is a dependent &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt;, subsequent substitutions apply to that template-id:</source>
          <target state="translated">별명 템플리트를 전문화 한 결과가 종속 &lt;a href=&quot;templates#template-id&quot;&gt;template-id 인&lt;/a&gt; 경우 후속 대체가 해당 template-id에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7e5e471d5aa433ec3a110b9d7e72faf3a90a04a9" translate="yes" xml:space="preserve">
          <source>When the same function template specialization matches more than one overloaded function template (this often results from &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;),</source>
          <target state="translated">동일한 함수 템플리트 전문화가 둘 이상의 오버로드 된 함수 템플리트와 일치하는 경우 (종종 &lt;a href=&quot;template_argument_deduction&quot;&gt;템플리트 인수 공제에서 발생&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b2ff5fd15b40403883483bc89510d97f14914365" translate="yes" xml:space="preserve">
          <source>When the target type is</source>
          <target state="translated">대상 유형이</target>
        </trans-unit>
        <trans-unit id="511cb27754af79d62f22a1bf71b871d3d288ebcd" translate="yes" xml:space="preserve">
          <source>When the template-name of a simple-template-id names a constrained non-function template or a constrained template template-parameter, but not a member template that is a member of an unknown specialization, and all template-arguments in the simple-template-id are non-dependent, the associated constraints of the constrained template must be satisfied:</source>
          <target state="translated">simple-template-id의 template-name이 제한된 비 기능 템플릿 또는 제한된 템플릿 template-parameter의 이름을 지정할 때 알 수없는 전문화 영역의 멤버 인 멤버 템플릿이 아닌 단순 템플릿의 모든 템플릿 인수는 template-id는 종속적이지 않으므로 제한된 템플릿의 관련 제약 조건을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="adb827bd0954ef807560ec125638e405788fa858" translate="yes" xml:space="preserve">
          <source>When the value of the argument corresponding to a non-type template parameter P that is declared with a dependent type is deduced from an expression, the template parameters in the type of P are deduced from the type of the value.</source>
          <target state="translated">종속 형식으로 선언 된 비 유형 템플릿 매개 변수 P에 해당하는 인수 값이 식에서 추론되면 P 형식의 템플릿 매개 변수가 값 형식에서 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="a1b257f783065293c124a619280ef8e578d72775" translate="yes" xml:space="preserve">
          <source>When this is the case, member functions &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, and &lt;code&gt;equal_range&lt;/code&gt; accept arguments of types other than &lt;code&gt;Key&lt;/code&gt; and expect that &lt;code&gt;Hash&lt;/code&gt; is callable with values of those types, and that &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; is a transparent comparison function such as &lt;code&gt;std::equal_to&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 경우 멤버 함수 &lt;code&gt;find&lt;/code&gt; , &lt;code&gt;contains&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; 및 &lt;code&gt;equal_range&lt;/code&gt; 는 &lt;code&gt;Key&lt;/code&gt; 이외의 유형의 인수를 승인 하고 해당 유형의 값으로 &lt;code&gt;Hash&lt;/code&gt; 를 호출 할 수 있으며 &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; 은 &lt;code&gt;std::equal_to&amp;lt;&amp;gt;&lt;/code&gt; 와 같은 투명한 비교 함수입니다 . : equal_to &amp;lt;&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="22fbcacb8ea8a01e09177002c1cd6a745c7d8006" translate="yes" xml:space="preserve">
          <source>When three-way comparison (such as &lt;code&gt;&lt;a href=&quot;../string/byte/memcmp&quot;&gt;std::memcmp&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/basic_string/compare&quot;&gt;std::string::compare&lt;/a&gt;&lt;/code&gt;) is provided, all six relational operators may be expressed through that:</source>
          <target state="translated">3 방향 비교 (예 : &lt;code&gt;&lt;a href=&quot;../string/byte/memcmp&quot;&gt;std::memcmp&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../string/basic_string/compare&quot;&gt;std::string::compare&lt;/a&gt;&lt;/code&gt; )가 제공되면 6 개의 관계 연산자가 다음을 통해 표현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f2f2e919801487fefca6150ecd5b3b80daddef7" translate="yes" xml:space="preserve">
          <source>When three-way comparison is not required (such as when providing a &lt;code&gt;Compare&lt;/code&gt; argument to standard algorithms such as &lt;code&gt;&lt;a href=&quot;../../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt;), &lt;a href=&quot;../locale/operator()&quot;&gt;&lt;code&gt;std::locale::operator()&lt;/code&gt;&lt;/a&gt; may be more appropriate.</source>
          <target state="translated">표준 &lt;code&gt;Compare&lt;/code&gt; 예 : &lt;code&gt;&lt;a href=&quot;../../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; )에 비교 인수를 제공 할 때와 같이 3 방향 비교가 필요하지 않은 경우 &lt;a href=&quot;../locale/operator()&quot;&gt; &lt;code&gt;std::locale::operator()&lt;/code&gt; &lt;/a&gt; 가 더 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b2aec7feac4af597a17debffe4c87be12d0ecab" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;template_parameters#Template_arguments&quot;&gt;template argument&lt;/a&gt;, &lt;code&gt;class T&lt;/code&gt; is a type template parameter named &lt;code&gt;T&lt;/code&gt;, not an unnamed non-type parameter whose type &lt;code&gt;T&lt;/code&gt; is introduced by elaborated type specifier.</source>
          <target state="translated">A와 사용하는 경우 &lt;a href=&quot;template_parameters#Template_arguments&quot;&gt;템플릿 인수&lt;/a&gt; , &lt;code&gt;class T&lt;/code&gt; 이름의 유형 템플릿 매개 변수 &lt;code&gt;T&lt;/code&gt; 가 아닌 유형이 익명의 비 형식 매개 변수 &lt;code&gt;T&lt;/code&gt; 정교 형식 지정자에 의해 소개된다.</target>
        </trans-unit>
        <trans-unit id="a89f99191dc9016965a45193765f04ce9fd16336" translate="yes" xml:space="preserve">
          <source>When used as a function argument and when &lt;a href=&quot;overload_resolution&quot;&gt;two overloads&lt;/a&gt; of the function are available, one taking rvalue reference parameter and the other taking lvalue reference to const parameter, an rvalue binds to the rvalue reference overload (thus, if both copy and move constructors are available, an rvalue argument invokes the &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt;, and likewise with copy and move assignment operators).</source>
          <target state="translated">함수 인수로 사용하고 함수의 &lt;a href=&quot;overload_resolution&quot;&gt;두 과부하&lt;/a&gt; 가 사용 가능한 경우 (하나는 rvalue 참조 매개 변수를 사용하고 다른 하나는 lvalue 참조를 const 매개 변수에 사용하는 경우) rvalue는 rvalue 참조 과부하에 바인드됩니다 (따라서 복사 및 이동 생성자가 모두 사용 가능한 경우) rvalue 인수는 &lt;a href=&quot;move_constructor&quot;&gt;이동 생성자를&lt;/a&gt; 호출 하고 마찬가지로 복사 및 이동 할당 연산자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f8ea00edd25f46b83546909c33b9f68661ba3e16" translate="yes" xml:space="preserve">
          <source>When used as an argument in a &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; expression, the placeholder objects are stored in the generated function object, and when that function object is invoked with unbound arguments, each placeholder &lt;code&gt;_N&lt;/code&gt; is replaced by the corresponding Nth unbound argument.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 표현식 에서 인수로 사용될 때 플레이스 홀더 오브젝트는 생성 된 함수 오브젝트에 저장되며 해당 함수 오브젝트가 바인드되지 않은 인수와 함께 호출되면 각 플레이스 홀더 &lt;code&gt;_N&lt;/code&gt; 은 해당하는 N 번째 언 바운드 인수로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="4c90e24b8efd2362ba00ffddb7c37e312b7e82c3" translate="yes" xml:space="preserve">
          <source>When used at class scope, variable template declares a static data member template.</source>
          <target state="translated">클래스 범위에서 사용될 때 변수 템플릿은 정적 데이터 멤버 템플릿을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="d3e7747ab6e5ee83d7abf31291a18569eac0496f" translate="yes" xml:space="preserve">
          <source>When used immediately after whitespace-delimited input, e.g. after &lt;code&gt;int n; &lt;a href=&quot;../../io/cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; n;&lt;/code&gt;, &lt;code&gt;getline&lt;/code&gt; consumes the endline character left on the input stream by &lt;a href=&quot;../../io/basic_istream/operator_gtgt&quot;&gt;operator&amp;gt;&amp;gt;&lt;/a&gt;, and returns immediately. A common solution is to ignore all leftover characters on the line of input with &lt;code&gt;cin.ignore(&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max(), '\n');&lt;/code&gt; before switching to line-oriented input.</source>
          <target state="translated">공백으로 구분 된 입력 직후, 예를 들어 &lt;code&gt;int n; &lt;a href=&quot;../../io/cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; n;&lt;/code&gt; 이후에 사용될 때 ; std :: cin &amp;gt;&amp;gt; n; , &lt;code&gt;getline&lt;/code&gt; endline에 의해, 입력 스트림에 남아있는 문자 소모 &lt;a href=&quot;../../io/basic_istream/operator_gtgt&quot;&gt;연산자 &amp;gt;&amp;gt;&lt;/a&gt; 즉시 반환한다. 일반적인 해결책은 &lt;code&gt;cin.ignore(&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max(), '\n');&lt;/code&gt; 라인 지향 입력으로 전환하기 전에.</target>
        </trans-unit>
        <trans-unit id="810ee96ebb349b821e1635ff4d35660a0d38207d" translate="yes" xml:space="preserve">
          <source>When used in a class definition, &lt;code&gt;final&lt;/code&gt; specifies that this class may not appear in the base-specifier-list of another class definition (in other words, cannot be derived from). The program is ill-formed (a compile-time error is generated) otherwise. &lt;code&gt;final&lt;/code&gt; can also be used with a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; definition, in which case it has no effect (other than on the outcome of &lt;code&gt;&lt;a href=&quot;../types/is_final&quot;&gt;std::is_final&lt;/a&gt;&lt;/code&gt;), since unions cannot be derived from).</source>
          <target state="translated">클래스 정의에서 사용될 때 &lt;code&gt;final&lt;/code&gt; 은이 클래스가 다른 클래스 정의의 기본 지정자 목록에 나타나지 않을 수 있음을 지정합니다 (즉, 파생 될 수 없음). 그렇지 않으면 프로그램이 잘못 구성됩니다 (컴파일 타임 오류가 생성됨). &lt;code&gt;final&lt;/code&gt; 은 또한 &lt;a href=&quot;union&quot;&gt;Union&lt;/a&gt; 정의 와 함께 사용할 수 있으며 ,이 경우 &lt;code&gt;&lt;a href=&quot;../types/is_final&quot;&gt;std::is_final&lt;/a&gt;&lt;/code&gt; 의 결과를 제외하고는 효과가 없습니다 ( union을 파생시킬 수 없으므로).</target>
        </trans-unit>
        <trans-unit id="9305de135bb255cca457fdbece5abb6dd9a1674a" translate="yes" xml:space="preserve">
          <source>When used in a controlling expression of &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/c/preprocessor/conditional.html&quot;&gt;#elif&lt;/a&gt;, all signed integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; and all unsigned integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintmax_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; 또는 &lt;a href=&quot;http://en.cppreference.com/w/c/preprocessor/conditional.html&quot;&gt;#elif&lt;/a&gt; 의 제어 표현식에 사용될 때 모든 부호있는 정수 상수는 &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 유형 인 것처럼 작동하고 부호없는 모든 정수 상수는 &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintmax_t&lt;/a&gt;&lt;/code&gt; 유형 인 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="8b903d2e014bf8406262e3731d09165f67923eb1" translate="yes" xml:space="preserve">
          <source>When used in a virtual function declaration or definition, &lt;code&gt;final&lt;/code&gt; ensures that the function is virtual and specifies that it may not be overridden by derived classes. The program is ill-formed (a compile-time error is generated) otherwise.</source>
          <target state="translated">가상 함수 선언 또는 정의에 사용될 경우 &lt;code&gt;final&lt;/code&gt; 은 함수가 가상인지 확인하고 파생 클래스가이를 무시하지 않도록 지정합니다. 그렇지 않으면 프로그램이 잘못 구성됩니다 (컴파일 타임 오류가 생성됨).</target>
        </trans-unit>
        <trans-unit id="1a6b7e3d85e506288364ecfff9f25bf551cd3185" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;in &amp;gt;&amp;gt; get_money(mon, intl)&lt;/code&gt;, parses the character input as a monetary value, as specified by the &lt;code&gt;&lt;a href=&quot;../../locale/money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in &lt;code&gt;in&lt;/code&gt;, and stores the value in &lt;code&gt;mon&lt;/code&gt;.</source>
          <target state="translated">표현식에서 사용될 때 &lt;code&gt;in &amp;gt;&amp;gt; get_money(mon, intl)&lt;/code&gt; 상기 지정된대로, 통화 값으로 문자 입력을 분석 &lt;code&gt;&lt;a href=&quot;../../locale/money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; 최신 스며 패싯 로케일 &lt;code&gt;in&lt;/code&gt; 의 값, 저장 &lt;code&gt;mon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dba580a9fb7386ece9bcb9047821c34efdbd2cc6" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;in &amp;gt;&amp;gt; get_time(tmb, fmt)&lt;/code&gt;, parses the character input as a date/time value according to format string &lt;code&gt;fmt&lt;/code&gt; according to the &lt;code&gt;&lt;a href=&quot;../../locale/time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in the input stream &lt;code&gt;in&lt;/code&gt;. The resultant value is stored in a &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object pointed to by &lt;code&gt;tmb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;in &amp;gt;&amp;gt; get_time(tmb, fmt)&lt;/code&gt; 의 표현식 에서 사용될 때 의 입력 스트림 &lt;code&gt;in&lt;/code&gt; 현재 삽입 된 로케일 의 &lt;code&gt;&lt;a href=&quot;../../locale/time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; 패싯 에 따라 형식 문자열 &lt;code&gt;fmt&lt;/code&gt; 에 따라 문자 입력을 날짜 / 시간 값으로 구문 분석합니다 . 결과 값은 &lt;code&gt;tmb&lt;/code&gt; 가 가리키는 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 오브젝트에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f6b6002a8d5ee59f8db2c3ad5177196e34c65dc" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt;, converts the monetary value &lt;code&gt;mon&lt;/code&gt; to its character representation as specified by the &lt;code&gt;&lt;a href=&quot;../../locale/money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; 표현식에서 사용될 때 , 화폐 가치 &lt;code&gt;mon&lt;/code&gt; 은 현재 &lt;code&gt;out&lt;/code&gt; 에 포함 된 로케일 의 &lt;code&gt;&lt;a href=&quot;../../locale/money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; 패싯에 지정된대로 문자 표현으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="cf45d63014365fd6dcec8ecebade756fbe4b1751" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; put_time(tmb, fmt)&lt;/code&gt;, converts the date and time information from a given calendar time &lt;code&gt;tmb&lt;/code&gt; to a character string according to format string &lt;code&gt;fmt&lt;/code&gt;, as if by calling &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../chrono/c/wcsftime&quot;&gt;std::wcsftime&lt;/a&gt;&lt;/code&gt;, or analog (depending on &lt;code&gt;CharT&lt;/code&gt;), according to the &lt;code&gt;&lt;a href=&quot;../../locale/time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in the output stream &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;out &amp;lt;&amp;lt; put_time(tmb, fmt)&lt;/code&gt; 표현식에서 사용될 경우, &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../chrono/c/wcsftime&quot;&gt;std::wcsftime&lt;/a&gt;&lt;/code&gt; 을 호출하는 것처럼 날짜 및 시간 정보를 지정된 달력 시간 &lt;code&gt;tmb&lt;/code&gt; 에서 형식 문자열 &lt;code&gt;fmt&lt;/code&gt; 에 따라 문자열 로 변환합니다 또는 아날로그 (에 따라 &lt;code&gt;CharT&lt;/code&gt; )에 따른 &lt;code&gt;&lt;a href=&quot;../../locale/time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; 패싯 현재 출력 스트림에 스며 로케일 &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b7fe6253074e6b867e1474688d0f2693a1f7d0" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; quoted(s, delim, escape)&lt;/code&gt;, where &lt;code&gt;out&lt;/code&gt; is an output stream with &lt;code&gt;char_type&lt;/code&gt; equal to &lt;code&gt;CharT&lt;/code&gt; and, for overloads 2-4, &lt;code&gt;traits_type&lt;/code&gt; equal to &lt;code&gt;Traits&lt;/code&gt;, behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;, which inserts into &lt;code&gt;out&lt;/code&gt; a sequence of characters &lt;code&gt;seq&lt;/code&gt; constructed as follows:</source>
          <target state="translated">표현식에서 사용되는 경우, &lt;code&gt;out &amp;lt;&amp;lt; quoted(s, delim, escape)&lt;/code&gt; , &lt;code&gt;out&lt;/code&gt; 갖는 출력 스트림 &lt;code&gt;char_type&lt;/code&gt; 이 동일 &lt;code&gt;CharT&lt;/code&gt; 과부하 2-4, 및, &lt;code&gt;traits_type&lt;/code&gt; 는 동일한 &lt;code&gt;Traits&lt;/code&gt; A와하게 동작 &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt; , 인서트로 &lt;code&gt;out&lt;/code&gt; 다음과 같이 구성된 문자 시퀀스 &lt;code&gt;seq&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d8ac1ad4097229286f1a455e696150cbe6d78fe1" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; resetiosflags(mask)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; resetiosflags(mask)&lt;/code&gt;, clears all format flags of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; as specified by the &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">표현식에서 사용될 때 &lt;code&gt;out &amp;lt;&amp;lt; resetiosflags(mask)&lt;/code&gt; 또는 &lt;code&gt;in &amp;gt;&amp;gt; resetiosflags(mask)&lt;/code&gt; , 스트림의 모든 형식 플래그 클리어 &lt;code&gt;out&lt;/code&gt; 또는 &lt;code&gt;in&lt;/code&gt; 의해 지정된 &lt;code&gt;mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="921ff88652686f85b631d9ceb7c724eb668d404a" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setfill(c)&lt;/code&gt; sets the fill character of the stream &lt;code&gt;out&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">표현식에서 사용되는 경우, &lt;code&gt;out &amp;lt;&amp;lt; setfill(c)&lt;/code&gt; 스트림의 채움 문자 세트 &lt;code&gt;out&lt;/code&gt; 행 &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cb9f3afac80724df521c61b025e7c53651f4eb2" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setiosflags(mask)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setiosflags(mask)&lt;/code&gt;, sets all format flags of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; as specified by the &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">표현식에서 사용될 때 &lt;code&gt;out &amp;lt;&amp;lt; setiosflags(mask)&lt;/code&gt; 또는 &lt;code&gt;in &amp;gt;&amp;gt; setiosflags(mask)&lt;/code&gt; , 스트림의 모든 형식 플래그 설정 &lt;code&gt;out&lt;/code&gt; 또는 &lt;code&gt;in&lt;/code&gt; 의해 지정된 &lt;code&gt;mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a87b307fde755e230f472b8260a494dc64a86904" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setprecision(n)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setprecision(n)&lt;/code&gt;, sets the &lt;code&gt;precision&lt;/code&gt; parameter of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; to exactly &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">표현식에서 사용되는 경우, &lt;code&gt;out &amp;lt;&amp;lt; setprecision(n)&lt;/code&gt; 또는 &lt;code&gt;in &amp;gt;&amp;gt; setprecision(n)&lt;/code&gt; 의 설정 &lt;code&gt;precision&lt;/code&gt; 스트림의 파라미터 &lt;code&gt;out&lt;/code&gt; 또는 &lt;code&gt;in&lt;/code&gt; 정확히에 &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6a94f6a0cf9d3d1d83f0c666f4d933e3aa6770f" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setw(n)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setw(n)&lt;/code&gt;, sets the &lt;code&gt;width&lt;/code&gt; parameter of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; to exactly &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">표현식에서 사용되는 경우, &lt;code&gt;out &amp;lt;&amp;lt; setw(n)&lt;/code&gt; 또는 &lt;code&gt;in &amp;gt;&amp;gt; setw(n)&lt;/code&gt; 의 설정 &lt;code&gt;width&lt;/code&gt; 스트림의 파라미터 &lt;code&gt;out&lt;/code&gt; 또는 &lt;code&gt;in&lt;/code&gt; 정확하게에 &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="101375a819be934deee54d8762c9258b209a7717" translate="yes" xml:space="preserve">
          <source>When used with &lt;a href=&quot;new&quot;&gt;new[]-expression&lt;/a&gt;, the size of an array may be zero; such an array has no elements:</source>
          <target state="translated">&lt;a href=&quot;new&quot;&gt;new []&lt;/a&gt; -expression과 함께 사용 하면 배열의 크기가 0 일 수 있습니다. 이러한 배열에는 요소가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b5d2f5c5efbba3505a9a104fbd815a3de55bb31d" translate="yes" xml:space="preserve">
          <source>When used with a (non-const) object that has copy-on-write semantics, the range-based for loop may trigger a deep copy by (implicitly) calling the non-const &lt;code&gt;begin()&lt;/code&gt; member function. If that is undesirable (for instance because the loop is not actually modifying the object), &lt;code&gt;&lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;&lt;/code&gt; can be used:</source>
          <target state="translated">쓰기시 복사 시맨틱이있는 (비 콘스탄트) 오브젝트와 함께 사용될 경우, 범위 기반 for 루프는 비 암호적인 &lt;code&gt;begin()&lt;/code&gt; 멤버 함수 를 (암시 적으로) 호출하여 딥 카피를 트리거 할 수 있습니다 . 루프가 실제로 객체를 수정하지 않기 때문에 바람직하지 않은 경우 &lt;code&gt;&lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf6c1868cc765347d09cc64a36b7be944f8dd8fb" translate="yes" xml:space="preserve">
          <source>When using a non-converting locale (the default locale is non-converting), the overrider of this function in &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; may be optimized for zero-copy bulk I/O (by means of overriding &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetn&quot;&gt;std::streambuf::xsgetn&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">비 변환 로케일을 사용하는 경우 (기본 로케일은 비 변환 임) &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; 에서이 함수의 대체는 0 사본 벌크 I / O에 최적화 될 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetn&quot;&gt;std::streambuf::xsgetn&lt;/a&gt;&lt;/code&gt; 을 대체 함) ).</target>
        </trans-unit>
        <trans-unit id="0986776c60c5c2e2615f44185f446f8dc94a3805" translate="yes" xml:space="preserve">
          <source>When using a non-converting locale (the default locale is non-converting), the overrider of this function in &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; may be optimized for zero-copy bulk I/O (by means of overriding &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sputn&quot;&gt;std::streambuf::xsputn&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">비 변환 로케일을 사용하는 경우 (기본 로케일은 비 변환 임) &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 에서이 함수의 대체는 0 사본 벌크 I / O에 대해 최적화 될 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sputn&quot;&gt;std::streambuf::xsputn&lt;/a&gt;&lt;/code&gt; 을 대체 함) ).</target>
        </trans-unit>
        <trans-unit id="cbe8e117435e8afed934a7b78bf92466217654af" translate="yes" xml:space="preserve">
          <source>When using parallel execution policy, it is the programmer's responsibility to avoid data races and deadlocks:</source>
          <target state="translated">병렬 실행 정책을 사용할 때 데이터 경쟁과 교착 상태를 피하는 것은 프로그래머의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="7dd97b15bcdd677ac393fd1531f4ab0a23cce05d" translate="yes" xml:space="preserve">
          <source>When working with the C++ container library, the proper type for the difference between iterators is the member typedef &lt;code&gt;difference_type&lt;/code&gt;, which is often synonymous with &lt;code&gt;std::ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">C ++ 컨테이너 라이브러리로 작업 할 때 반복자의 차이점에 적합한 유형은 typedef &lt;code&gt;difference_type&lt;/code&gt; 멤버 이며, 종종 &lt;code&gt;std::ptrdiff_t&lt;/code&gt; 와 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="744601d71e0a622aae7e049c96112c98fceb410b" translate="yes" xml:space="preserve">
          <source>When writing characters, &lt;code&gt;&lt;a href=&quot;ostreambuf_iterator&quot;&gt;std::ostreambuf_iterator&lt;/a&gt;&lt;/code&gt; is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.</source>
          <target state="translated">문자를 작성할 때 &lt;code&gt;&lt;a href=&quot;ostreambuf_iterator&quot;&gt;std::ostreambuf_iterator&lt;/a&gt;&lt;/code&gt; 는 문자 당 한 번 센트리 오브젝트를 구성하고 파괴하는 오버 헤드를 피하기 때문에보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="6d6a0d2f37c6465daaf393a9cbcafd860707692e" translate="yes" xml:space="preserve">
          <source>Whenever a reference is bound to a temporary or to a subobject thereof, the lifetime of the temporary is extended to match the lifetime of the reference, with the following exceptions:</source>
          <target state="translated">참조가 임시 또는 하위 오브젝트에 바인드 될 때마다 다음 예외를 제외하고 임시의 수명이 참조의 수명과 일치하도록 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="a47ec6b9ae119d13c79d3ecadb3d357577c88006" translate="yes" xml:space="preserve">
          <source>Whenever an attempt is made to read or modify the stored value of an object of type &lt;code&gt;DynamicType&lt;/code&gt; through a glvalue of type &lt;code&gt;AliasedType&lt;/code&gt;, the behavior is undefined unless one of the following is true:</source>
          <target state="translated">시도 읽거나 형의 객체의 저장된 값 변경하려고 할 때마다 &lt;code&gt;DynamicType&lt;/code&gt; 을 형의 glvalue을 통해 &lt;code&gt;AliasedType&lt;/code&gt; 다음 중 하나에 해당하는 경우를 제외하고, 행동은 정의되지 않는다 :</target>
        </trans-unit>
        <trans-unit id="9101581b76be4f749934d75b25f2b3f56089760f" translate="yes" xml:space="preserve">
          <source>Whenever the arguments are some C++ basic types, there are no ADL-associated namespaces. Hence, those scenarios are identical with the non-ADL examples above.</source>
          <target state="translated">인수가 C ++ 기본 유형일 때마다 ADL 관련 네임 스페이스가 없습니다. 따라서 이러한 시나리오는 위의 비 ADL 예제와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="77eef7bb821cc1a1b8c9c6ab0b0e1de54272ecdc" translate="yes" xml:space="preserve">
          <source>Where &lt;a href=&quot;../../language/objects#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; prohibits examining the same memory as values of two different types, &lt;code&gt;std::memcpy&lt;/code&gt; may be used to convert the values.</source>
          <target state="translated">어디 &lt;a href=&quot;../../language/objects#Strict_aliasing&quot;&gt;엄격한 앨리어싱이&lt;/a&gt; 두 가지 유형의 값이 같은 메모리를 검사 금지 &lt;code&gt;std::memcpy&lt;/code&gt; 값을 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c53cccdafaba481597a722fa2959cf7a851c2ce1" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;weak_this&lt;/code&gt; is the hidden mutable &lt;code&gt;std::weak_ptr&lt;/code&gt; member of &lt;code&gt;std::shared_from_this&lt;/code&gt;. The assignment to the &lt;code&gt;weak_this&lt;/code&gt; member is not atomic and conflicts with any potentially concurrent access to the same object. This ensures that future calls to &lt;a href=&quot;../enable_shared_from_this/shared_from_this&quot;&gt;&lt;code&gt;shared_from_this()&lt;/code&gt;&lt;/a&gt; would share ownership with the &lt;code&gt;shared_ptr&lt;/code&gt; created by this raw pointer constructor.</source>
          <target state="translated">어디 &lt;code&gt;weak_this&lt;/code&gt; 숨겨진 변경 가능한 &lt;code&gt;std::weak_ptr&lt;/code&gt; 회원 &lt;code&gt;std::shared_from_this&lt;/code&gt; . &lt;code&gt;weak_this&lt;/code&gt; 멤버에 대한 지정 은 원자 적이 지 않으며 동일한 오브젝트에 대한 잠재적 동시 액세스와 충돌합니다. 이것은 향후 &lt;a href=&quot;../enable_shared_from_this/shared_from_this&quot;&gt; &lt;code&gt;shared_from_this()&lt;/code&gt; &lt;/a&gt; 호출 이이 원시 포인터 생성자에 의해 작성된 &lt;code&gt;shared_ptr&lt;/code&gt; 과 소유권을 공유하게합니다 .</target>
        </trans-unit>
        <trans-unit id="328d7d83b15b53db0928e0b402874f758e429540" translate="yes" xml:space="preserve">
          <source>Where R is the ordering category type defined above.</source>
          <target state="translated">여기서 R은 위에서 정의한 주문 카테고리 유형입니다.</target>
        </trans-unit>
        <trans-unit id="582de0628906c31348c3039934a0f8563d8361ee" translate="yes" xml:space="preserve">
          <source>Where a constant expression is grammatically required, including:</source>
          <target state="translated">다음을 포함하여 문법적으로 문법적으로 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="a8ebf782644f9429bc1fc6810b05c7e9c3c03635" translate="yes" xml:space="preserve">
          <source>Where applicable, &lt;a href=&quot;../iterator/iterator_tags#Example&quot;&gt;tag dispatch&lt;/a&gt;, &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt;, and, if available, &lt;a href=&quot;constraints&quot;&gt;concepts&lt;/a&gt;, are usually preferred over direct use of SFINAE.</source>
          <target state="translated">적용 가능한 경우, SFDispatch를 직접 사용하는 것보다 &lt;a href=&quot;../iterator/iterator_tags#Example&quot;&gt;tag dispatch&lt;/a&gt; , &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; 및 가능한 경우 &lt;a href=&quot;constraints&quot;&gt;concepts&lt;/a&gt; 이 일반적으로 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="c16c807394bc564276f7b672bb496e133719e00a" translate="yes" xml:space="preserve">
          <source>Where built-in operators return &lt;code&gt;bool&lt;/code&gt;, most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;bool&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">내장 연산자가 &lt;code&gt;bool&lt;/code&gt; 을 반환하는 경우 대부분의 &lt;a href=&quot;operators&quot;&gt;사용자 정의 오버로드&lt;/a&gt; 도 &lt;code&gt;bool&lt;/code&gt; 을 반환 하므로 사용자 정의 연산자를 내장과 동일한 방식으로 사용할 수 있습니다. 그러나 사용자 정의 연산자 과부하에서는 모든 유형을 리턴 유형 ( &lt;code&gt;void&lt;/code&gt; 포함 ) 으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1889e8caa29d75a1818f0a931ca52b8fe1415229" translate="yes" xml:space="preserve">
          <source>Where class-name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.</source>
          <target state="translated">class-name은 현재 클래스 (또는 클래스 템플릿의 현재 인스턴스화)의 이름을 지정해야하거나 네임 스페이스 범위 또는 친구 선언에서 선언 된 경우 정규화 된 클래스 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="03f3df53bc82d8371ebdee50da2998db2016a301" translate="yes" xml:space="preserve">
          <source>Where class_name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.</source>
          <target state="translated">여기서 class_name은 현재 클래스 (또는 클래스 템플릿의 현재 인스턴스화)의 이름을 지정하거나 네임 스페이스 범위 또는 친구 선언에서 선언 될 때 정규화 된 클래스 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d7ad86ffa9afba91a0ed8ad0042113ba1987e71e" translate="yes" xml:space="preserve">
          <source>Where direct access to the elements of the container is not wanted or not possible or distinguishing between lvalue &lt;code&gt;c[i] = v;&lt;/code&gt; and rvalue &lt;code&gt;v = c[i];&lt;/code&gt; usage, operator[] may return a proxy. see for example &lt;code&gt;&lt;a href=&quot;../utility/bitset/operator_at&quot;&gt;std::bitset::operator[]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">용기의 요소에 직접 접근하는 것이 바람직하지 않거나 불가능하거나 lvalue &lt;code&gt;c[i] = v;&lt;/code&gt; 그리고 rvalue &lt;code&gt;v = c[i];&lt;/code&gt; 사용법, operator []는 프록시를 리턴 할 수 있습니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;../utility/bitset/operator_at&quot;&gt;std::bitset::operator[]&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7544bd14fb0127b9e675324fe322b59d1667847a" translate="yes" xml:space="preserve">
          <source>Where necessary, the compiler may implicitly define the &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt;, &lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt;, &lt;a href=&quot;as_operator&quot;&gt;copy assignment operator&lt;/a&gt;, &lt;a href=&quot;move_operator&quot;&gt;move assignment operator&lt;/a&gt;, and the &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;.</source>
          <target state="translated">필요한 경우 컴파일러는 &lt;a href=&quot;default_constructor&quot;&gt;기본 생성자&lt;/a&gt; , &lt;a href=&quot;copy_constructor&quot;&gt;복사 생성자&lt;/a&gt; , &lt;a href=&quot;move_constructor&quot;&gt;이동 생성자&lt;/a&gt; , &lt;a href=&quot;as_operator&quot;&gt;복사 할당 연산자&lt;/a&gt; , &lt;a href=&quot;move_operator&quot;&gt;이동 할당 연산자&lt;/a&gt; 및 &lt;a href=&quot;destructor&quot;&gt;소멸자를&lt;/a&gt; 암시 적으로 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d39fc5aa0a8a0218582cd66f3e979536d5af157" translate="yes" xml:space="preserve">
          <source>Where the input for &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;imaginary&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.  If an error occurs calls &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt;.</source>
          <target state="translated">어디의 입력 &lt;code&gt;real&lt;/code&gt; 와 &lt;code&gt;imaginary&lt;/code&gt; 필수가로 변환 할 수 &lt;code&gt;T&lt;/code&gt; . 오류가 발생하면 &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f939b6cebddd88e076c47ab7052d80f4f9691f8f" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is raised by the mathematical library functions is unspecified in general, but may be explicitly specified in the description of the function (e.g. &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">수학 라이브러리 함수에 의해 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 가 발생 하는지 여부 는 일반적으로 지정되지 않지만 함수 설명에 명시 적으로 지정 될 수 있습니다 (예 : &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b0ef570637f0306b69eab32021437454f7aeaff6" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt; bit fields that aren't explicitly &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt; are signed or unsigned.</source>
          <target state="translated">여부 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , 그리고 &lt;code&gt;long long&lt;/code&gt; 명시되지 않은 필드 비트 &lt;code&gt;signed&lt;/code&gt; 또는 &lt;code&gt;unsigned&lt;/code&gt; 서명 또는 서명되지 않은됩니다.</target>
        </trans-unit>
        <trans-unit id="21520e7d3c4c9457f0b61f7da5be4c28fb0b2934" translate="yes" xml:space="preserve">
          <source>Whether implemented or not, this function is normally called by &lt;code&gt;std::basic_streambuf::in_avail&lt;/code&gt; if the get area is empty.</source>
          <target state="translated">구현 여부에 관계 &lt;code&gt;std::basic_streambuf::in_avail&lt;/code&gt; 함수는 일반적으로 get 영역이 비어 있으면 std :: basic_streambuf :: in_avail에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="be104b12a99ce4ffaccf474c68581deb485380ae" translate="yes" xml:space="preserve">
          <source>Whether or not the operation succeeds, the stream is no longer associated with a file, and the buffer allocated by &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt;, if any, is also disassociated and deallocated if automatic allocation was used.</source>
          <target state="translated">작업이 성공했는지 여부에 관계없이 스트림은 더 이상 파일과 연결되지 않으며 &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; 의해 할당 된 버퍼 도 자동 할당이 사용 된 경우 연결 해제되고 할당 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="d46a08839feaec08adbd051313d8939dc9b21b97" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;../money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; uses pos_format for formatting positive values and neg_format for formatting negative values, &lt;code&gt;&lt;a href=&quot;../money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; uses neg_format for parsing all monetary values: it assumes that neg_format is compatible with pos_format.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; 은 양수 값을 형식화하기 위해 pos_format을 사용하고 음수 값을 형식화하기 위해 neg_format을 사용 하는 반면 std :: money_get 은 모든 통화 값을 구문 분석하기 위해 &lt;code&gt;&lt;a href=&quot;../money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; 사용합니다. neg_format이 pos_format과 호환되는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4882bae700593de48c423f4a185a6a87fc8e0168" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;codecvt&lt;/code&gt; supports N:M conversions (e.g. UTF-16 to UTF-8, where two internal characters may be necessary to decide what external characters to output), &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; can only use &lt;code&gt;codecvt&lt;/code&gt; facets that define a 1:N conversion, that is it must be able to process one internal character at a time when writing to a file.</source>
          <target state="translated">하지만 &lt;code&gt;codecvt&lt;/code&gt; 가 N 지원 : M 변환 (예 : UTF-16 UTF-8, 두 개의 내부 문자가 무엇인지 출력의 외부에 문자를 결정할 필요가있을 수 있습니다), &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 만 사용할 수 있습니다 &lt;code&gt;codecvt&lt;/code&gt; 의 1 정의 측면 : N 변환을, 즉, 파일에 쓸 때 한 번에 하나의 내부 문자를 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ce692aaa12dee04f1b7857662f9696d7b39d104a" translate="yes" xml:space="preserve">
          <source>While all fundamental types &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact==true&lt;/code&gt; are integer types, a library may define exact types that aren't integers, e.g. a rational arithmetics type representing fractions.</source>
          <target state="translated">모든 기본 타입 동안 &lt;code&gt;T&lt;/code&gt; 되는 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact==true&lt;/code&gt; 유형의 정수, 도서관 합리적인를 arithmetics 분수를 나타내는 입력 예 : 정수하지 않은 정확한 유형을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c6831ef0dd5db6345bc002124c0babc32834531" translate="yes" xml:space="preserve">
          <source>While in C++, the scope of the init-statement and the scope of statement are one and the same, in C the scope of statement is nested within the scope of init-statement:</source>
          <target state="translated">C ++에서 init-statement의 범위와 명령문의 범위는 동일하고 C에서 statement의 범위는 init-statement의 범위 내에 중첩됩니다.</target>
        </trans-unit>
        <trans-unit id="f6a198ae06795de880db0e81ff4942b69fa0d198" translate="yes" xml:space="preserve">
          <source>While it's not true for fundamental C++ floating-point types, a third-party floating-point type &lt;code&gt;T&lt;/code&gt; may exist such that &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::lowest() != -&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">기본 C ++ 부동 소수점 유형에는 해당되지 않지만 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::lowest() != -&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; &amp;lt;T&amp;gt; :: lowest ()! = &lt;a href=&quot;../numeric_limits&quot;&gt;-std :: numeric_limits&lt;/a&gt; &amp;lt;T&amp;gt; :: max 와 같은 타사 부동 소수점 유형 &lt;code&gt;T&lt;/code&gt; 가 존재할 수 있습니다 . () .</target>
        </trans-unit>
        <trans-unit id="bdb7f0b47137662d6f73c67c92fda0e6b0d6c3b8" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;std::snprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings, and in order to determine the buffer size, the program may need to call &lt;code&gt;std::swprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">좁은 문자열을 제공하지만 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;std::snprintf&lt;/a&gt;&lt;/code&gt; 가능 필요한 출력 버퍼 크기를 결정하게, 와이드 문자열에 대한 등가가되지 않고, 버퍼 크기를 결정하기 위해, 프로그램을 호출 할 수도 &lt;code&gt;std::swprintf&lt;/code&gt; 체크 결과 값을 지정하고 더 큰 버퍼를 재 할당하여 성공할 때까지 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="2aad7bc15a2badfcfdc2770354ab9bdb48f5b39a" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;std::vsnprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings, and in order to determine the buffer size, the program may need to call &lt;code&gt;std::vswprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">좁은 문자열을 제공하지만 &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;std::vsnprintf&lt;/a&gt;&lt;/code&gt; 가능 필요한 출력 버퍼 크기를 결정하게, 와이드 문자열에 대한 등가가되지 않고, 버퍼 크기를 결정하기 위해, 프로그램을 호출 할 수도 &lt;code&gt;std::vswprintf&lt;/code&gt; 체크 결과 값을 지정하고 더 큰 버퍼를 재 할당하여 성공할 때까지 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="3d1b9b2d47483d07a008f2f3460cb714ec262b09" translate="yes" xml:space="preserve">
          <source>While objects of any complete type and cv pointers to void may be thrown as exception objects, all standard library functions throw anonymous temporary objects by value, and the types of those objects are derived (directly or indirectly) from &lt;code&gt;&lt;a href=&quot;../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt;. User-defined exceptions usually follow this pattern.&lt;sup id=&quot;cite_ref-7&quot;&gt;&lt;a href=&quot;exceptions#cite_note-7&quot;&gt;[7]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-8&quot;&gt;&lt;a href=&quot;exceptions#cite_note-8&quot;&gt;[8]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-9&quot;&gt;&lt;a href=&quot;exceptions#cite_note-9&quot;&gt;[9]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">모든 완전한 유형의 객체와 void에 대한 cv 포인터는 예외 객체로 발생 될 수 있지만 모든 표준 라이브러리 함수는 익명 임시 객체를 값으로 throw하며 해당 객체의 유형은 &lt;code&gt;&lt;a href=&quot;../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; 에서 (직접 또는 간접적으로) 파생됩니다 . 사용자 정의 예외는 일반적으로이 패턴을 따릅니다. &lt;sup id=&quot;cite_ref-7&quot;&gt;&lt;a href=&quot;exceptions#cite_note-7&quot;&gt;[7] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-8&quot;&gt;&lt;a href=&quot;exceptions#cite_note-8&quot;&gt;[8] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-9&quot;&gt;&lt;a href=&quot;exceptions#cite_note-9&quot;&gt;[9]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="dd014792b0e30b26904af64ce06af14ab14dade5" translate="yes" xml:space="preserve">
          <source>While the names &quot;gptr&quot; and &quot;egptr&quot; refer to the get area, the name &quot;eback&quot; refers to the end of the putback area: stepping backwards from gptr, characters can be put back until eback.</source>
          <target state="translated">&quot;gptr&quot;과 &quot;egptr&quot;이라는 이름은 get 영역을 나타내지 만 &quot;eback&quot;이라는 이름은 putback 영역의 끝을 나타냅니다. gptr에서 뒤로 밟으면 eback까지 문자를 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6aed0f8bf11c0e2ccb4abb52781539645453846" translate="yes" xml:space="preserve">
          <source>While the signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; regardless of &lt;a href=&quot;../../language/value_category&quot;&gt;value category&lt;/a&gt; (thus, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; is not allowed, nor is &lt;code&gt;Type1&lt;/code&gt; unless for &lt;code&gt;Type1&lt;/code&gt; a move is equivalent to a copy(since C++11)).</source>
          <target state="translated">서명에는 &lt;code&gt;const &amp;amp;&lt;/code&gt; 가 없어도되지만, 함수는 전달 된 객체를 수정해서는 안되며 &lt;a href=&quot;../../language/value_category&quot;&gt;값 범주에&lt;/a&gt; 관계없이 &lt;code&gt;Type1&lt;/code&gt; 및 &lt;code&gt;Type2&lt;/code&gt; 유형의 모든 값을 수용 할 수 있어야합니다 (따라서 &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; 은 허용되지 않습니다) 않으며 인 &lt;code&gt;Type1&lt;/code&gt; 위해하지 않는 &lt;code&gt;Type1&lt;/code&gt; 이동 사본 동등 (사람 C ++ 11)).</target>
        </trans-unit>
        <trans-unit id="b82e35d8b86e026d1b1ef3ee87feedc4e74f5048" translate="yes" xml:space="preserve">
          <source>While the signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; regardless of &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt; (thus, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; is not allowed, nor is &lt;code&gt;Type1&lt;/code&gt; unless for &lt;code&gt;Type1&lt;/code&gt; a move is equivalent to a copy(since C++11)).</source>
          <target state="translated">서명에는 &lt;code&gt;const &amp;amp;&lt;/code&gt; 가 없어도되지만, 함수는 전달 된 객체를 수정해서는 안되며 &lt;a href=&quot;../language/value_category&quot;&gt;값 범주에&lt;/a&gt; 관계없이 &lt;code&gt;Type1&lt;/code&gt; 및 &lt;code&gt;Type2&lt;/code&gt; 유형의 모든 값을 수용 할 수 있어야합니다 (따라서 &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; 은 허용되지 않습니다) 않으며 인 &lt;code&gt;Type1&lt;/code&gt; 위해하지 않는 &lt;code&gt;Type1&lt;/code&gt; 이동 사본 동등 (사람 C ++ 11)).</target>
        </trans-unit>
        <trans-unit id="90970ed5fc36e4c5fcc7d19dbc8d5693453a089b" translate="yes" xml:space="preserve">
          <source>While the stream is frozen, &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; will not reallocate the buffer and the &lt;code&gt;destructor&lt;/code&gt; will not deallocate the buffer (thereby causing a memory leak).</source>
          <target state="translated">스트림이 고정되어있는 동안 &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 는 버퍼를 재할 당하지 않으며 &lt;code&gt;destructor&lt;/code&gt; 는 버퍼를 할당 해제하지 않으므로 메모리 누수가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="51e02d156ab35053fbad0f57e42b76301b58ea18" translate="yes" xml:space="preserve">
          <source>While the variable declared in the range_declaration is usually used in the loop_statement, doing so is not required.</source>
          <target state="translated">range_declaration에 선언 된 변수는 일반적으로 loop_statement에 사용되지만 그렇게 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c5f647e812d8ac720bd9936607ee574df0ff21f" translate="yes" xml:space="preserve">
          <source>While throw-expression can be used to transfer control to an arbitrary block of code up the execution stack, for arbitrary reasons (similar to &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt;), its intended usage is error handling.</source>
          <target state="translated">throw-expression을 사용하여 실행 스택에서 임의의 코드 블록으로 제어를 전달할 수 있지만 ( &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; 와 유사한) 임의의 이유로 의도 된 사용법은 오류 처리입니다.</target>
        </trans-unit>
        <trans-unit id="721c1b250c710b24bfafaf9daadc9fa8642ecac8" translate="yes" xml:space="preserve">
          <source>While with &lt;code&gt;copy_options::recursive&lt;/code&gt;, the subdirectories are also copied, with their content, recursively.</source>
          <target state="translated">&lt;code&gt;copy_options::recursive&lt;/code&gt; 와 함께 하위 디렉토리도 컨텐츠와 함께 재귀 적으로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="b7402781ffeb31aaf9f29177f61c8ff4a0f44050" translate="yes" xml:space="preserve">
          <source>Wide character</source>
          <target state="translated">넓은 캐릭터</target>
        </trans-unit>
        <trans-unit id="1fb55327ce03b4f2af732e3d187f25baf551cf61" translate="yes" xml:space="preserve">
          <source>Wide character array manipulation</source>
          <target state="translated">넓은 문자 배열 조작</target>
        </trans-unit>
        <trans-unit id="6808058d5dd776d7c4d9454174f9c39df21f19c7" translate="yes" xml:space="preserve">
          <source>Wide character representation of &lt;code&gt;c&lt;/code&gt; if &lt;code&gt;(unsigned char)c&lt;/code&gt; is a valid single-byte character in the initial shift state, &lt;code&gt;WEOF&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; if &lt;code&gt;(unsigned char)c&lt;/code&gt; 가 초기 시프트 상태에서 유효한 1 바이트 문자 이면 넓은 문자 표시 , 그렇지 않으면 &lt;code&gt;WEOF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab38913ae786de6e808a7c7241557b1856fc368e" translate="yes" xml:space="preserve">
          <source>Wide string manipulation</source>
          <target state="translated">넓은 문자열 조작</target>
        </trans-unit>
        <trans-unit id="e56ba2339bc3a2c7efd4a4f1ffa763681a4e7ccb" translate="yes" xml:space="preserve">
          <source>Widening always returns a wide character, but only the characters from the basic source character set (latin letters, digits, and punctuations required to write a C++ program) are guaranteed to have a unique, well-defined, widening transformation, which is also guaranteed to be reversible (by &lt;code&gt;&lt;a href=&quot;narrow&quot;&gt;narrow()&lt;/a&gt;&lt;/code&gt;). In practice, all characters whose multibyte representation is a single byte are usually widened to their wide character counterparts, and the rest of the possible single-byte values are usually mapped into the same placeholder value, typically &lt;code&gt;CharT(-1)&lt;/code&gt;.</source>
          <target state="translated">확장은 항상 넓은 문자를 반환하지만 기본 소스 문자 세트의 문자 (라틴 문자, 숫자 및 문장 부호는 C ++ 프로그램을 작성하는 데 필요한 문자) 만 고유하고 잘 정의 된 확장 변환을 보장합니다. 가역적입니다 ( &lt;code&gt;&lt;a href=&quot;narrow&quot;&gt;narrow()&lt;/a&gt;&lt;/code&gt; ). 실제로, 멀티 바이트 표현이 단일 바이트 인 모든 문자는 일반적으로 넓은 문자 대응 문자로 확장되고 나머지 가능한 단일 바이트 값은 일반적으로 동일한 자리 표시 자 값 (일반적으로 &lt;code&gt;CharT(-1)&lt;/code&gt; 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="15d388cfaf360c5681944037eaaad4926f0761c9" translate="yes" xml:space="preserve">
          <source>Widening, if successful, preserves all character classification categories known to &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">확장하면 &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt; 알려진 모든 문자 분류 범주가 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e27d3de30e21293ff54a527696fb3dc557516fd" translate="yes" xml:space="preserve">
          <source>Widens a single-byte character &lt;code&gt;c&lt;/code&gt; to its wide character equivalent.</source>
          <target state="translated">1 바이트 문자 &lt;code&gt;c&lt;/code&gt; 를 넓은 문자로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="3cf16972858ec6c71abfb6fa6d539bdbe451dbf6" translate="yes" xml:space="preserve">
          <source>Width in bits by data model</source>
          <target state="translated">데이터 모델 별 비트 폭</target>
        </trans-unit>
        <trans-unit id="0352671572d548b1b50beb4586216b4e3764d488" translate="yes" xml:space="preserve">
          <source>Win16 API</source>
          <target state="translated">Win16 API</target>
        </trans-unit>
        <trans-unit id="ae7fc6d8171e0e405ed2e200f1d2b5056d479b80" translate="yes" xml:space="preserve">
          <source>Win32 API</source>
          <target state="translated">Win32 API</target>
        </trans-unit>
        <trans-unit id="50f72286ea0c96bccbea595ccc66e3982412d267" translate="yes" xml:space="preserve">
          <source>Win64 API</source>
          <target state="translated">Win64 API</target>
        </trans-unit>
        <trans-unit id="84a4a9dac26edeb0330a247c9af1446aecf202e8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;#pragma once&lt;/code&gt;, the same header appears as.</source>
          <target state="translated">으로 &lt;code&gt;#pragma once&lt;/code&gt; 같은 헤더로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1d949445faea1f549e171010cf3291f2a325074c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;N = l - f&lt;/code&gt;, for all &lt;code&gt;0 &amp;lt; i &amp;lt; N&lt;/code&gt;, &lt;code&gt;f[floor(&lt;table&gt;
&lt;tr&gt;&lt;td&gt;i-1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;)]&lt;/code&gt; does not compare less than &lt;code&gt;f[i]&lt;/code&gt;.</source>
          <target state="translated">함께 &lt;code&gt;N = l - f&lt;/code&gt; , 모두 &lt;code&gt;0 &amp;lt; i &amp;lt; N&lt;/code&gt; , &lt;code&gt;f[floor(&lt;table&gt; &lt;tr&gt;&lt;td&gt;i-1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;)]&lt;/code&gt; 는 &lt;code&gt;f[i]&lt;/code&gt; 보다 작지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b0d81a9b5de91fa98a2d0ef9f4c7f4ecf47988e3" translate="yes" xml:space="preserve">
          <source>With \n instead of endl, the output would be the same, but may not appear in real time.</source>
          <target state="translated">endl 대신 \ n을 사용하면 출력은 동일하지만 실시간으로 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47777a8b463cd5f1e3501816b2ffaa3ea107991e" translate="yes" xml:space="preserve">
          <source>With floating point types &lt;code&gt;std::to_string&lt;/code&gt; may yield unexpected results as the number of significant digits in the returned string can be zero, see the example.</source>
          <target state="translated">부동 소수점 유형의 경우 &lt;code&gt;std::to_string&lt;/code&gt; 은 반환 된 문자열의 유효 자릿수가 0 일 수 있으므로 예기치 않은 결과가 발생할 수 있습니다 (예 참조).</target>
        </trans-unit>
        <trans-unit id="884b3b619e3ef18e83dc71855fd6e34d05de7659" translate="yes" xml:space="preserve">
          <source>With operands of arithmetic or enumeration type, the result of binary plus is the sum of the operands (after usual arithmetic conversions), and the result of the binary minus operator is the result of subtracting the second operand from the first (after usual arithmetic conversions), except that, if the type supports IEEE floating-point arithmetic (see &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt;),</source>
          <target state="translated">산술 또는 열거 유형의 피연산자에서 이진수 더하기의 결과는 피연산자의 합 (일반 산술 변환 후)이고 이진 빼기 연산자의 결과는 첫 번째 (보통 산술 변환 후)에서 두 번째 피연산자를 뺀 결과입니다. ), 유형이 IEEE 부동 소수점 산술을 지원하는 경우 ( &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="fa16b9931c1f17c4f80ec1a246f1cc250c5dd37a" translate="yes" xml:space="preserve">
          <source>With the default allocator, this requirement is equivalent to the validity of &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt;, which accepts class types with accessible destructors and all scalar types, but rejects array types, function types, reference types, and void.</source>
          <target state="translated">기본 할당 자에서이 요구 사항은 &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt; 의 유효성과 동일합니다. p-&amp;gt; ~ T () 는 액세스 가능한 소멸자와 모든 스칼라 형식이있는 클래스 형식은 허용하지만 배열 형식, 함수 형식, 참조 형식 및 void는 거부합니다.</target>
        </trans-unit>
        <trans-unit id="b4fea2c438a60cf674bf6a42d287a393b3f62920" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;complex.h&lt;/code&gt; , each &lt;code&gt;xxx.h&lt;/code&gt; header included in the C++ standard library places in the global namespace each name that the corresponding &lt;code&gt;cxxx&lt;/code&gt; header would have placed in the &lt;code&gt;std&lt;/code&gt; namespace.</source>
          <target state="translated">&lt;code&gt;complex.h&lt;/code&gt; 를 제외 하고 C ++ 표준 라이브러리에 포함 된 각 &lt;code&gt;xxx.h&lt;/code&gt; 헤더는 글로벌 네임 스페이스에 해당 &lt;code&gt;cxxx&lt;/code&gt; 헤더가 &lt;code&gt;std&lt;/code&gt; 네임 스페이스에 배치 한 각 이름을 배치 합니다.</target>
        </trans-unit>
        <trans-unit id="5d30f232b7061443bee920972c5d82807b94d345" translate="yes" xml:space="preserve">
          <source>With the introduction of move semantics in C++11, value categories were redefined to characterize two independent properties of expressions&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;value_category#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;:</source>
          <target state="translated">C ++ 11에 이동 의미론이 도입되면서 식의 두 가지 독립적 인 특성을 특성화하기 위해 값 범주가 재정의되었습니다 &lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;value_category#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="d7eedc43562dbda358e0af8f66b618c9779da2ba" translate="yes" xml:space="preserve">
          <source>Within a catch-clause, &lt;code&gt;&lt;a href=&quot;../error/current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; can be used to capture the exception in an &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../error/throw_with_nested&quot;&gt;std::throw_with_nested&lt;/a&gt;&lt;/code&gt; may be used to build nested exceptions.</source>
          <target state="translated">포괄 절 내에서 &lt;code&gt;&lt;a href=&quot;../error/current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; 에서 예외를 캡처하는 데 사용할 수있는 &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 하고, &lt;code&gt;&lt;a href=&quot;../error/throw_with_nested&quot;&gt;std::throw_with_nested&lt;/a&gt;&lt;/code&gt; 중첩 된 예외를 구축하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="245bc5b44f72c46518d49f6231bcdddbab7bc492" translate="yes" xml:space="preserve">
          <source>Within a class template definition (including its member functions and nested classes) some names may be deduced to refer to the</source>
          <target state="translated">클래스 템플릿 정의 (멤버 함수 및 중첩 클래스 포함) 내에서 일부 이름은</target>
        </trans-unit>
        <trans-unit id="bc89bf6548ea7d54b0a391d0d3c8b9447ce5c361" translate="yes" xml:space="preserve">
          <source>Within a scope, &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt; can be used to associate the name with its declaration.</source>
          <target state="translated">범위 내에서 &lt;a href=&quot;lookup&quot;&gt;규정되지 않은 이름 조회&lt;/a&gt; 를 사용하여 이름을 선언과 연관시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00817315634a43af97703fb51abe4ea2bd10d529" translate="yes" xml:space="preserve">
          <source>Within a template definition, certain names are deduced to belong to an</source>
          <target state="translated">템플릿 정의 내에서 특정 이름은</target>
        </trans-unit>
        <trans-unit id="7119f9b6e9a5c41a2215c5c5ab587c351e88a0e6" translate="yes" xml:space="preserve">
          <source>Within a thread of execution, accesses (reads and writes) through &lt;a href=&quot;../language/cv&quot;&gt;volatile glvalues&lt;/a&gt; cannot be reordered past observable side-effects (including other volatile accesses) that are</source>
          <target state="translated">실행 스레드 내에서 &lt;a href=&quot;../language/cv&quot;&gt;휘발성 glvalue를&lt;/a&gt; 통한 액세스 (읽기 및 쓰기)는 다음과 같은 관찰 가능한 부작용 (기타 휘발성 액세스 포함)을 지나서 다시 정렬 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6eda1a3a6846d50df7adc54351dedaf50fda69c3" translate="yes" xml:space="preserve">
          <source>Within the body of a function that uses variadic arguments, the values of these arguments may be accessed using the &lt;a href=&quot;../utility/variadic&quot;&gt;&amp;lt;cstdarg&amp;gt; library facilities&lt;/a&gt;:</source>
          <target state="translated">variadic 인수를 사용하는 함수 본문에서 이러한 인수의 값은 &lt;a href=&quot;../utility/variadic&quot;&gt;&amp;lt;cstdarg&amp;gt; 라이브러리 기능을&lt;/a&gt; 사용하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af7aded55b08b8ee429002640a601104c0c3e5cf" translate="yes" xml:space="preserve">
          <source>Within the body of a lambda, any use of &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; on any variable with automatic storage duration is as if it were captured and odr-used, even though decltype itself isn't an odr-use and no actual capture takes place:</source>
          <target state="translated">람다 본문 내에서 자동 저장 기간이있는 변수 에서 &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; 을 사용하는 것은 decltype 자체가 odr 용도가 아니고 실제 캡처가 수행되지 않더라도 마치 캡처 및 odr 사용되는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="078ca0cc0ac40495d119f9a3fdddbbaaae3dc64d" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt;, each identifier that names a non-static member is implicitly transformed to a class member access expression &lt;code&gt;this-&amp;gt;member&lt;/code&gt;.</source>
          <target state="translated">비 정적 &lt;a href=&quot;member_functions&quot;&gt;멤버 함수&lt;/a&gt; 의 본문 내에서 비 ​​정적 멤버의 이름을 지정하는 각 식별자는 암시 적으로 클래스 멤버 액세스 식 &lt;code&gt;this-&amp;gt;member&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="79f7c80c73c316c30ac1674843481cc4326e1a44" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static member function of X, any &lt;a href=&quot;expressions&quot;&gt;id-expression&lt;/a&gt; E (e.g. an identifier) that resolves to a non-type non-static member of X or of a base class of X, is transformed to a member access expression &lt;code&gt;(*this).E&lt;/code&gt; (unless it's already a part of a member access expression). This does not occur in template definition context, so a name may have to be prefixed with &lt;code&gt;this-&amp;gt;&lt;/code&gt; explicitly to become &lt;a href=&quot;dependent_name&quot;&gt;dependent&lt;/a&gt;.</source>
          <target state="translated">X의 비 정적 멤버 함수 본문 내에서 X 의 비정형 비 정적 멤버 또는 X의 기본 클래스로 해석되는 모든 &lt;a href=&quot;expressions&quot;&gt;id- 표현식&lt;/a&gt; E (예 : 식별자)가 멤버 액세스로 변환됩니다. expression &lt;code&gt;(*this).E&lt;/code&gt; (이미 멤버 액세스 표현식의 일부가 아닌 경우). 이것은 템플리트 정의 컨텍스트에서 발생하지 않으므로 &lt;a href=&quot;dependent_name&quot;&gt;종속&lt;/a&gt; 되기 위해 이름 앞에 &lt;code&gt;this-&amp;gt;&lt;/code&gt; 를 명시 적으로 붙여야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff9fb1990c434e938a6a0e2d84512b173b30aeb8" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static member function of X, any unqualified-id that resolves to a static member, an enumerator or a nested type of X or of a base class of X, is transformed to the corresponding qualified-id.</source>
          <target state="translated">X의 비 정적 멤버 함수 본문 내에서 정적 멤버, 열거 자 또는 중첩 유형 X 또는 기본 클래스 X로 해석되는 규정되지 않은 ID는 해당 규정 된 ID로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5ba9b5ad1328d649ca86d8f4a5d41ae2a5633cf1" translate="yes" xml:space="preserve">
          <source>Within the function body, the function-local predefined variable &lt;code&gt;__func__&lt;/code&gt; is defined as if by.</source>
          <target state="translated">함수 본문 내에서 함수 로컬 미리 정의 된 변수 &lt;code&gt;__func__&lt;/code&gt; 는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f89ece3e05e483d8d6633832e929cb8220c8daba" translate="yes" xml:space="preserve">
          <source>Within the same thread, evaluation A may be</source>
          <target state="translated">동일한 스레드 내에서 평가 A는</target>
        </trans-unit>
        <trans-unit id="c72f89b6f5d83e25d732495d891540e02b9e90aa" translate="yes" xml:space="preserve">
          <source>Within the same thread, evaluation A that is</source>
          <target state="translated">동일한 스레드 내에서 평가 A</target>
        </trans-unit>
        <trans-unit id="25258e5219c6e5baefb975484506b38b6aa8362b" translate="yes" xml:space="preserve">
          <source>Within the scope of a class template specialization or partial specialization, when the injected-class-name is used as a type-name, it is equivalent to the template-name followed by the template-arguments of the class template specialization or partial specialization enclosed in &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">클래스 템플리트 전문화 또는 부분 특수화의 범위 내에서, 주입 된 클래스 이름이 유형 이름으로 사용되는 경우, 이는 템플리트 이름 다음에 클래스 템플리트 전문화의 템플리트 인수 또는 동봉 된 부분 특수화와 같습니다. 에서 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce2fab5742c8b33bc0537c80ea3b8dcc2cc835e1" translate="yes" xml:space="preserve">
          <source>Within the scope of a class template, the name of the template without a parameter list is an injected class name, and can be used as a type. In that case, class argument deduction does not happen and template parameters must be supplied explicitly:</source>
          <target state="translated">클래스 템플릿 범위 내에서 매개 변수 목록이없는 템플릿 이름은 삽입 된 클래스 이름이며 유형으로 사용할 수 있습니다. 이 경우 클래스 인수 공제가 발생하지 않으며 템플릿 매개 변수를 명시 적으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="05619ddfa2c0d81e8a6ead6a708344745a722242" translate="yes" xml:space="preserve">
          <source>Without std::flush, the output would be the same, but may not appear in real time.</source>
          <target state="translated">std :: flush가 없으면 출력은 동일하지만 실시간으로 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f55a4102a27df1431160445b96e34d20fd4f3d" translate="yes" xml:space="preserve">
          <source>Without std::unitbuf or another explicit flush, the output is the same, but does not appear in real time.</source>
          <target state="translated">std :: unitbuf 또는 다른 명시 적 플러시가 없으면 출력은 동일하지만 실시간으로 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="682b37a0a9239f633eb0a18ad35c5e23fe316950" translate="yes" xml:space="preserve">
          <source>Working with a &lt;code&gt;priority_queue&lt;/code&gt; is similar to managing a &lt;a href=&quot;../algorithm/make_heap&quot;&gt; heap&lt;/a&gt; in some random access container, with the benefit of not being able to accidentally invalidate the heap.</source>
          <target state="translated">&lt;code&gt;priority_queue&lt;/code&gt; 로 작업하는 것은 일부 임의 액세스 컨테이너에서 &lt;a href=&quot;../algorithm/make_heap&quot;&gt;힙&lt;/a&gt; 을 관리하는 것과 유사하지만 실수로 힙을 무효화 할 수 없다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8065f27e56565b08250cf2bdf011c92725655e0d" translate="yes" xml:space="preserve">
          <source>Wrapper around a member function pointer. The class instance whose member function to call is passed as a pointer to the &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">멤버 함수 포인터 주위를 래퍼합니다. 호출 할 멤버 함수가있는 클래스 인스턴스는 &lt;code&gt;operator()&lt;/code&gt; 대한 포인터로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="a56128931adfe376f6d1c4233b2aee9d4414fed0" translate="yes" xml:space="preserve">
          <source>Wrapper around a member function pointer. The class instance whose member function to call is passed as a reference to the &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">멤버 함수 포인터 주위를 래퍼합니다. 호출 할 멤버 함수가있는 클래스 인스턴스는 &lt;code&gt;operator()&lt;/code&gt; 대한 참조로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd35487a2eb7da40332f7fc41452378d92a72445" translate="yes" xml:space="preserve">
          <source>Writable</source>
          <target state="translated">Writable</target>
        </trans-unit>
        <trans-unit id="a9b6a4bb633bad2e9e1e0bcdbb56726b9e0e6146" translate="yes" xml:space="preserve">
          <source>Write to end</source>
          <target state="translated">끝까지 쓰기</target>
        </trans-unit>
        <trans-unit id="e87fd10313099f92edd69106267a002d4e8466a1" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;. Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="translated">문자 &lt;code&gt;ch&lt;/code&gt; 를 &lt;code&gt;stdout&lt;/code&gt; 에 씁니다 . 내부적으로 문자는 쓰기 직전 에 &lt;code&gt;unsigned char&lt;/code&gt; 문자로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="a96b7df507ca67492643e29e1db1884cf6663933" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">지정된 출력 스트림 &lt;code&gt;stream&lt;/code&gt; 문자 &lt;code&gt;ch&lt;/code&gt; 를 기입 합니다 .</target>
        </trans-unit>
        <trans-unit id="001712686d4b96e8257e062bf8257f5854fb0c91" translate="yes" xml:space="preserve">
          <source>Writes a horizontal tab character.</source>
          <target state="translated">가로 탭 문자를 씁니다.</target>
        </trans-unit>
        <trans-unit id="b8a7060cb09fe871077059dd6f46ca33bbda1f49" translate="yes" xml:space="preserve">
          <source>Writes a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">리터럴 &lt;code&gt;%&lt;/code&gt; 문자를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="cb18b1353d53796c65bfab0bce5e3151631b33c0" translate="yes" xml:space="preserve">
          <source>Writes a newline character.</source>
          <target state="translated">개행 문자를 씁니다.</target>
        </trans-unit>
        <trans-unit id="6924072c304541be0f3e71e77883f2ec6c6a9d14" translate="yes" xml:space="preserve">
          <source>Writes a textual representation of a thread identifier &lt;code&gt;id&lt;/code&gt; to the output stream &lt;code&gt;ost&lt;/code&gt;.</source>
          <target state="translated">스레드 식별자 &lt;code&gt;id&lt;/code&gt; 의 텍스트 표현을 출력 스트림 &lt;code&gt;ost&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="767a6e009054da5918825851e61b1c02bbbf738a" translate="yes" xml:space="preserve">
          <source>Writes a textual representation of the distribution parameters and internal state to &lt;code&gt;os&lt;/code&gt;. The formatting flags and fill character of &lt;code&gt;os&lt;/code&gt; are unchanged.</source>
          <target state="translated">분포 매개 변수 및 내부 상태의 텍스트 표현을 &lt;code&gt;os&lt;/code&gt; 에 씁니다 . &lt;code&gt;os&lt;/code&gt; 의 포맷 플래그와 채우기 문자 는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="628a432848d3d2a0f439ca52671452d1eec4d9ff" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">넓은 문자 &lt;code&gt;ch&lt;/code&gt; 를 &lt;code&gt;stdout&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="a61cc5af43d9f51fcd06a3cacfeb3348c1595940" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;. &lt;code&gt;putwc()&lt;/code&gt; may be implemented as a macro and may evaluate &lt;code&gt;stream&lt;/code&gt; more than once.</source>
          <target state="translated">지정된 출력 스트림에 와이드 문자 &lt;code&gt;ch&lt;/code&gt; 를 기입 &lt;code&gt;stream&lt;/code&gt; . &lt;code&gt;putwc()&lt;/code&gt; 는 매크로로 구현 될 수 있으며 &lt;code&gt;stream&lt;/code&gt; 두 번 이상 평가할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb34f2576c279e7725c583723fccb0fc6a3511eb" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; and one additional newline character &lt;code&gt;'\n'&lt;/code&gt; to the output stream &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; 반복적으로 실행하는 것처럼 null로 끝나는 문자열 &lt;code&gt;str&lt;/code&gt; 에서 하나의 추가 줄 바꿈 문자 &lt;code&gt;'\n'&lt;/code&gt; 을 출력 스트림 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="5a503bcd94956c4103d38ea588d00af71b7d3a70" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; 반복적으로 실행하는 것처럼 널 종료 문자열 &lt;code&gt;str&lt;/code&gt; 에서 출력 스트림 &lt;code&gt;stream&lt;/code&gt; 으로 모든 문자를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="83ab79edfcdea5e94d3e192eb9d45b8f6bebd9bf" translate="yes" xml:space="preserve">
          <source>Writes every wide character from the null-terminated wide string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;std::fputwc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;std::fputwc&lt;/a&gt;&lt;/code&gt; 반복적으로 실행하는 것처럼 널 종료 와이드 문자열 &lt;code&gt;str&lt;/code&gt; 에서 출력 스트림 &lt;code&gt;stream&lt;/code&gt; 에 모든 와이드 문자를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="a9b88a484ae89e6d4131f01f0c94c90cbf9dc18c" translate="yes" xml:space="preserve">
          <source>Writes one character to the output sequence.</source>
          <target state="translated">하나의 문자를 출력 순서에 씁니다.</target>
        </trans-unit>
        <trans-unit id="3aeb20d4e3a246faca11563fb03064671edc3f42" translate="yes" xml:space="preserve">
          <source>Writes some data from the put area to the associated character sequence (to the file).</source>
          <target state="translated">넣기 영역의 일부 데이터를 관련 문자 시퀀스 (파일)에 씁니다.</target>
        </trans-unit>
        <trans-unit id="74f04ede6f753ddec049a69f229f7dc13079d99c" translate="yes" xml:space="preserve">
          <source>Writes the ISO 8601 week of the year as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">연중 ISO 8601 주를 10 진수로 씁니다. 결과가 한 자리이면 앞에 0이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="f7d029ddd98ce63f15114123e69a3596edcb4ab0" translate="yes" xml:space="preserve">
          <source>Writes the ISO 8601 week-based year as a decimal number. If the result is less than four digits it is left-padded with 0 to four digits.</source>
          <target state="translated">ISO 8601 주 기반 연도를 10 진수로 씁니다. 결과가 4 자리 미만인 경우 왼쪽에 0-4 자리가 채워집니다.</target>
        </trans-unit>
        <trans-unit id="0cc1164d46d9e7c267ced7895e6152ab0b695562" translate="yes" xml:space="preserve">
          <source>Writes the ISO weekday as a decimal number (1-7), where Monday is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">ISO 평일을 10 진수 (1-7)로 씁니다 . 여기서 Monday는 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="71166ded75b14ffa703a04ab3f28950a6779e502" translate="yes" xml:space="preserve">
          <source>Writes the day of month as a decimal number. If the result is a single decimal digit, it is prefixed with 0.</source>
          <target state="translated">월의 일을 10 진수로 씁니다. 결과가 10 진수 한 자리이면 접두사 0이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="b0f7893ae9d8e28cab469762cfa8b52ab87190ba" translate="yes" xml:space="preserve">
          <source>Writes the day of month as a decimal number. If the result is a single decimal digit, it is prefixed with a space.</source>
          <target state="translated">월의 일을 10 진수로 씁니다. 결과가 10 진수 한 자리 인 경우 공백이 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="1626fbac11740992d51707eebf9b1bc3e70c4e3f" translate="yes" xml:space="preserve">
          <source>Writes the day of the year as a decimal number (January 1 is &lt;code&gt;001&lt;/code&gt;). If the result is less than three digits, it is left-padded with 0 to three digits.</source>
          <target state="translated">일을 10 진수로 씁니다 (1 월 1은 &lt;code&gt;001&lt;/code&gt; ). 결과가 3 자리 미만인 경우 왼쪽에 0 ~ 3 자리가 채워집니다.</target>
        </trans-unit>
        <trans-unit id="c029d304cd7d0c5128b916f1b7935a6092ee6d60" translate="yes" xml:space="preserve">
          <source>Writes the hour (12-hour clock) as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">시간 (12 시간제)을 10 진수로 씁니다. 결과가 한 자리이면 앞에 0이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="d586ae48a03fbce6cab63eb6156b184051a469fd" translate="yes" xml:space="preserve">
          <source>Writes the hour (24-hour clock) as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">시간 (24 시간제)을 10 진수로 씁니다. 결과가 한 자리이면 앞에 0이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="67151c9d086e78a6b607bc1d8cdeea642b931db1" translate="yes" xml:space="preserve">
          <source>Writes the last two decimal digits of the ISO 8601 week-based year. If the result is a single digit it is prefixed by 0.</source>
          <target state="translated">ISO 8601 주 기반 연도의 마지막 두 자리를 씁니다. 결과가 한 자리이면 앞에 0이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="9ff9a700dc66f1c252bd7007b0facde18742ff7d" translate="yes" xml:space="preserve">
          <source>Writes the last two decimal digits of the year. If the result is a single digit it is prefixed by 0.</source>
          <target state="translated">연도의 마지막 두 자리를 씁니다. 결과가 한 자리이면 앞에 0이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="30b48d91697b9f629d02ce9d83e7a421c921e234" translate="yes" xml:space="preserve">
          <source>Writes the locale's 12-hour clock time.</source>
          <target state="translated">로캘의 12 시간 시계 시간을 씁니다.</target>
        </trans-unit>
        <trans-unit id="a971b059080c39ac822e661aea1c87ec25348313" translate="yes" xml:space="preserve">
          <source>Writes the locale's abbreviated month name.</source>
          <target state="translated">로캘의 약식 월 이름을 씁니다.</target>
        </trans-unit>
        <trans-unit id="f672aa4e85699374012ee1a535ef52d6be86123e" translate="yes" xml:space="preserve">
          <source>Writes the locale's abbreviated weekday name.</source>
          <target state="translated">로케일의 약식 요일 이름을 씁니다.</target>
        </trans-unit>
        <trans-unit id="a93c6febd8287cd73094f5c7fa21ffc07a57cd24" translate="yes" xml:space="preserve">
          <source>Writes the locale's date and time representation.</source>
          <target state="translated">로캘의 날짜 및 시간 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="8990ab22cb03b6694ce6cb909d61b54ae50e921c" translate="yes" xml:space="preserve">
          <source>Writes the locale's date representation.</source>
          <target state="translated">로캘의 날짜 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="1dec9978ca81332b5e90610cec498718c6ecefef" translate="yes" xml:space="preserve">
          <source>Writes the locale's equivalent of the AM/PM designations associated with a 12-hour clock.</source>
          <target state="translated">12 시간 시계와 관련된 로케일의 AM / PM 지정을 씁니다.</target>
        </trans-unit>
        <trans-unit id="4bd0b778c0ca16103f3037347259706f50406b6f" translate="yes" xml:space="preserve">
          <source>Writes the locale's full month name.</source>
          <target state="translated">로케일의 전체 월 이름을 씁니다.</target>
        </trans-unit>
        <trans-unit id="dbcf68702a0a2c1386e6fd13ec2cac6f00c12942" translate="yes" xml:space="preserve">
          <source>Writes the locale's full weekday name.</source>
          <target state="translated">로케일의 전체 요일 이름을 씁니다.</target>
        </trans-unit>
        <trans-unit id="ba5f45187c6fabe4410c47f297770de07e96243b" translate="yes" xml:space="preserve">
          <source>Writes the locale's time representation.</source>
          <target state="translated">로캘의 시간 표현을 씁니다.</target>
        </trans-unit>
        <trans-unit id="fc68d043b917adc440f4f576ac7e4b54287ebed4" translate="yes" xml:space="preserve">
          <source>Writes the minute as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">분을 10 진수로 씁니다. 결과가 한 자리이면 앞에 0이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="c30fe76679f32dcce8e852b50af05cbd5aefe9f6" translate="yes" xml:space="preserve">
          <source>Writes the month as a decimal number (January is &lt;code&gt;01&lt;/code&gt;). If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">월을 10 진수로 씁니다 (1 월은 &lt;code&gt;01&lt;/code&gt; ). 결과가 한 자리이면 앞에 0이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="8032e3a64c8132ccb6ad44a63e27ef9ad4339e8a" translate="yes" xml:space="preserve">
          <source>Writes the offset from UTC in the ISO 8601 format. For example &lt;code&gt;-0430&lt;/code&gt; refers to 4 hours 30 minutes behind UTC. If the offset is zero, &lt;code&gt;+0000&lt;/code&gt; is used.</source>
          <target state="translated">UTC에서 오프셋을 ISO 8601 형식으로 씁니다. 예를 들어 &lt;code&gt;-0430&lt;/code&gt; 은 UTC보다 4 시간 30 분 뒤입니다. 오프셋이 0이면 &lt;code&gt;+0000&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d76d87840d6936192aee3cda5289202c38d7018" translate="yes" xml:space="preserve">
          <source>Writes the representation of the matched subsequence &lt;code&gt;m&lt;/code&gt; to the output stream &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">일치하는 서브 순서 &lt;code&gt;m&lt;/code&gt; 의 표현을 출력 스트림 &lt;code&gt;os&lt;/code&gt; 에 기입합니다 .</target>
        </trans-unit>
        <trans-unit id="17feef3d0503048639900d16af24c9e6fe4685c7" translate="yes" xml:space="preserve">
          <source>Writes the second as a decimal number. If the number of seconds is less than 10, the result is prefixed with 0.</source>
          <target state="translated">초를 10 진수로 씁니다. 초 수가 10보다 작은 경우 결과 앞에 0이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="1a73b5e51c193b1deccbfaf669b4db12b0a55d6d" translate="yes" xml:space="preserve">
          <source>Writes the time zone abbreviation.</source>
          <target state="translated">시간대 약어를 씁니다.</target>
        </trans-unit>
        <trans-unit id="1d8938025c2761da9ede064d18f5ef84dcf58261" translate="yes" xml:space="preserve">
          <source>Writes the week number of the year as a decimal number. The first Monday of the year is the first day of week 01. Days of the same year prior to that are in week 00. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">연도의 주 번호를 10 진수로 씁니다. 연도의 첫 번째 월요일은 주 1의 첫 번째 요일입니다. 그 전날의 동일한 요일은 00 주입니다. 결과가 한 자리이면 0이 접두어로 붙습니다.</target>
        </trans-unit>
        <trans-unit id="370c8fdb39d9f2b4190c27cb6e07474705f3c637" translate="yes" xml:space="preserve">
          <source>Writes the week number of the year as a decimal number. The first Sunday of the year is the first day of week 01. Days of the same year prior to that are in week 00. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">연도의 주 번호를 10 진수로 씁니다. 연도의 첫 번째 일요일은 주 1의 첫 번째 날입니다. 그 전날의 동일한 요일은 00 주입니다. 결과가 한 자릿수이면 앞에 0이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="dbdae9db0bd7c298a373f28a7cd0509bbbb5b272" translate="yes" xml:space="preserve">
          <source>Writes the weekday as a decimal number (0-6), where Sunday is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">요일을 10 진수 (0-6)로 씁니다 . 여기서 일요일은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb21ea8cdea47573e1038fbae721d5dca3fb901b" translate="yes" xml:space="preserve">
          <source>Writes the year as a decimal number. If the result is less than four digits it is left-padded with 0 to four digits.</source>
          <target state="translated">연도를 10 진수로 씁니다. 결과가 4 자리 미만인 경우 왼쪽에 0-4 자리가 채워집니다.</target>
        </trans-unit>
        <trans-unit id="26249ba8d699dd0df931793d3da64b00c7c31d1d" translate="yes" xml:space="preserve">
          <source>Writes the year divided by 100 using floored division. If the result is a single decimal digit, it is prefixed with 0.</source>
          <target state="translated">층 나누기를 사용하여 연도를 100으로 나눕니다. 결과가 10 진수 한 자리이면 접두사 0이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="a77785063b2874f1bbee1b042250317d98d6b33a" translate="yes" xml:space="preserve">
          <source>Writes to &lt;code&gt;os&lt;/code&gt; the textual representation of &lt;code&gt;x&lt;/code&gt;'s current state. In the output, adjacent numbers are separated by one or more space characters. If &lt;code&gt;os&lt;/code&gt;'s fmtflags are not set to &lt;code&gt;ios_base::dec|ios_base::left&lt;/code&gt;, the behavior may be undefined.</source>
          <target state="translated">에 기록 &lt;code&gt;os&lt;/code&gt; 의 텍스트 표현 &lt;code&gt;x&lt;/code&gt; 의 현재 상태입니다. 출력에서 인접한 숫자는 하나 이상의 공백 문자로 구분됩니다. 경우 &lt;code&gt;os&lt;/code&gt; 의 fmtflags로 설정되지 않은 &lt;code&gt;ios_base::dec|ios_base::left&lt;/code&gt; 의 동작은 정의되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d621d908346c0bfe11eb811537d53c64ce8ec02" translate="yes" xml:space="preserve">
          <source>Writes to fields</source>
          <target state="translated">필드에 쓴다</target>
        </trans-unit>
        <trans-unit id="00c192b84cfa44d2bd75c59846c86d17a1e44b25" translate="yes" xml:space="preserve">
          <source>Writes uncommitted changes to the underlying output sequence.</source>
          <target state="translated">커밋되지 않은 변경 사항을 기본 출력 시퀀스에 씁니다.</target>
        </trans-unit>
        <trans-unit id="15ec5b51c4d780460bc9101843d2786a8b364326" translate="yes" xml:space="preserve">
          <source>Writes up to &lt;code&gt;count&lt;/code&gt; binary objects from the given array &lt;code&gt;buffer&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;. The objects are written as if by reinterpreting each object as an array of &lt;code&gt;unsigned char&lt;/code&gt; and calling &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; times for each object to write those &lt;code&gt;unsigned char&lt;/code&gt;s into &lt;code&gt;stream&lt;/code&gt;, in order. The file position indicator for the stream is advanced by the number of characters written.</source>
          <target state="translated">주어진 배열 &lt;code&gt;buffer&lt;/code&gt; 에서 출력 스트림 &lt;code&gt;stream&lt;/code&gt; 이진 객체 를 &lt;code&gt;count&lt;/code&gt; 합니다 . 객체는 배열로 각 오브젝트를 재 해석하여 마치 작성된 &lt;code&gt;unsigned char&lt;/code&gt; 및 호출 &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;size&lt;/code&gt; 이들 물품 각 개체 회 &lt;code&gt;unsigned char&lt;/code&gt; 로들 &lt;code&gt;stream&lt;/code&gt; 순서. 스트림의 파일 위치 표시기는 쓴 문자 수만큼 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="c8447596ae9170966e015adf6c315155e2268bda" translate="yes" xml:space="preserve">
          <source>Writing to the character array accessed through &lt;code&gt;c_str()&lt;/code&gt; is undefined behavior.</source>
          <target state="translated">&lt;code&gt;c_str()&lt;/code&gt; 통해 액세스 한 문자 배열에 쓰는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="93cad4f773cccfbb33c80bc8546680efa75c09a4" translate="yes" xml:space="preserve">
          <source>X and X</source>
          <target state="translated">X와 X</target>
        </trans-unit>
        <trans-unit id="d60cdb3a38da8a130cf91abef198ed0c8df65943" translate="yes" xml:space="preserve">
          <source>X and X appears before B in the Single Total Order</source>
          <target state="translated">단일 총 주문에서 X와 X가 B 앞에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2f3f27dde1e0deeab004667545a65bef35394ab9" translate="yes" xml:space="preserve">
          <source>X argument</source>
          <target state="translated">X 논쟁</target>
        </trans-unit>
        <trans-unit id="4ca65c470ec6016fed78ab6aef93dd257702b23f" translate="yes" xml:space="preserve">
          <source>X, X</source>
          <target state="translated">X, X</target>
        </trans-unit>
        <trans-unit id="6db6535836e6c904498ebb911985cfb1ab6cbadf" translate="yes" xml:space="preserve">
          <source>X, Y is</source>
          <target state="translated">X, Y는</target>
        </trans-unit>
        <trans-unit id="9ea35756029154e9210bcca0b65c206107747ec2" translate="yes" xml:space="preserve">
          <source>X, and X</source>
          <target state="translated">X와 X</target>
        </trans-unit>
        <trans-unit id="565e6a618c216015d885283111a97727e2c3f173" translate="yes" xml:space="preserve">
          <source>X, and X is</source>
          <target state="translated">X는 X</target>
        </trans-unit>
        <trans-unit id="6ba655c53b7c6f7ad109ea6e30e446c19a1740b7" translate="yes" xml:space="preserve">
          <source>Y argument</source>
          <target state="translated">Y 논쟁</target>
        </trans-unit>
        <trans-unit id="ba12622aee8e1cee306fb2ae1705d34dc28d369e" translate="yes" xml:space="preserve">
          <source>Y is sequenced-before F in thread B</source>
          <target state="translated">스레드 B에서 F보다 먼저 Y가 순서화 됨</target>
        </trans-unit>
        <trans-unit id="ed1a905ea4a6fcc0ca7ba73cce1620307e6d6ffa" translate="yes" xml:space="preserve">
          <source>Y is sequenced-before FB in thread B</source>
          <target state="translated">스레드 B에서 FB 이전에 Y가 순서화 됨</target>
        </trans-unit>
        <trans-unit id="3850869b7a202e66b87556b87c42f6e3bad33150" translate="yes" xml:space="preserve">
          <source>Y reads the value written by X (or by the &lt;a href=&quot;memory_order&quot;&gt;release sequence headed by X&lt;/a&gt;)</source>
          <target state="translated">Y는 X가 쓴 값을 읽습니다 (또는 &lt;a href=&quot;memory_order&quot;&gt;X가 이끄는 릴리즈 순서&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1038aa0966244ed387fbcfee4940af4843ba1a40" translate="yes" xml:space="preserve">
          <source>Y reads the value written by X (or the value would be written by &lt;a href=&quot;memory_order&quot;&gt;release sequence headed by X&lt;/a&gt; if X were a release operation)</source>
          <target state="translated">Y는 X가 쓴 값을 읽습니다 (또는 X가 해제 작업 인 경우 X가 &lt;a href=&quot;memory_order&quot;&gt;이끄는 릴리스 순서로&lt;/a&gt; 값이 기록됨 )</target>
        </trans-unit>
        <trans-unit id="4d77689f2569037f676a633b110bf28151defd7c" translate="yes" xml:space="preserve">
          <source>Y, and Y is</source>
          <target state="translated">Y, Y는</target>
        </trans-unit>
        <trans-unit id="879e32326c5217968ac8e3a14e4a8a5214957264" translate="yes" xml:space="preserve">
          <source>Year</source>
          <target state="translated">Year</target>
        </trans-unit>
        <trans-unit id="869ef4891ca6fa4509dc520e3f6640c9b0cfae4a" translate="yes" xml:space="preserve">
          <source>Year, day, month</source>
          <target state="translated">년, 일, 월</target>
        </trans-unit>
        <trans-unit id="915f26f629fd3d6f51a4b7d5990e0b50d4471157" translate="yes" xml:space="preserve">
          <source>Year, month, day</source>
          <target state="translated">년, 월, 일</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="f1e34b1b0b0addb32d44f2528bede851abf77e03" translate="yes" xml:space="preserve">
          <source>Yes, except erased element(s)</source>
          <target state="translated">예, 지워진 요소를 제외하고</target>
        </trans-unit>
        <trans-unit id="7ed1f0e98f8b97a0cbc079098f9b970f72dbe20e" translate="yes" xml:space="preserve">
          <source>Yield-expression returns a value to the caller and suspends the current coroutine: it is the common building block of resumable generator functions.</source>
          <target state="translated">Yield-expression은 호출자에게 값을 반환하고 현재 코 루틴을 일시 중단합니다. 재개 가능한 생성기 함수의 공통 빌딩 블록입니다.</target>
        </trans-unit>
        <trans-unit id="1791a81aeb4f78d0ab4f9096c83089810fc43595" translate="yes" xml:space="preserve">
          <source>Yields &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; if for some &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;e == X::to_int_type(c)&lt;/code&gt; and &lt;code&gt;f == X::to_int_type(d)&lt;/code&gt;</source>
          <target state="translated">수율 &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; 일부 경우, &lt;code&gt;c&lt;/code&gt; 및 &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;e == X::to_int_type(c)&lt;/code&gt; 및 &lt;code&gt;f == X::to_int_type(d)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="729d384e3fcd3d72644a0c1418ba7a729b79ac57" translate="yes" xml:space="preserve">
          <source>ZERO WIDTH SPACE - ZERO WIDTH JOINER</source>
          <target state="translated">제로 폭 공간-제로 폭 조이너</target>
        </trans-unit>
        <trans-unit id="51c939bb7f5f0758dd76abfc0b3c05c623bebff7" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; compare equal.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 동일한 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="917c36f59225ed77c40603a32141411ab5f9fea6" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;x&lt;/code&gt; is zero; otherwise, one plus the base-2 logarithm of &lt;code&gt;x&lt;/code&gt;, with any fractional part discarded.</source>
          <target state="translated">영점 &lt;code&gt;x&lt;/code&gt; 는 제로이고; 그렇지 않으면, 소수 부분은 버리고 &lt;code&gt;x&lt;/code&gt; 의 밑이 2 인 로그 x .</target>
        </trans-unit>
        <trans-unit id="0f17813fad92e667b30a4557d41d38bf185f1f8c" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;x&lt;/code&gt; is zero; otherwise, the largest integral power of two that is not greater than &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">영점 &lt;code&gt;x&lt;/code&gt; 는 제로이고; 그렇지 않으면 &lt;code&gt;x&lt;/code&gt; 보다 크지 않은 2의 최대 적분 전력 .</target>
        </trans-unit>
        <trans-unit id="405ae0fba6c1904278eb371bc24b47d81b1d7d3c" translate="yes" xml:space="preserve">
          <source>Zero initialization is performed in the following situations:</source>
          <target state="translated">다음과 같은 상황에서는 초기화가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1be729d580f443d76655de63a066d43b5c754d5" translate="yes" xml:space="preserve">
          <source>Zero or more of the following:</source>
          <target state="translated">다음 중 0 이상 :</target>
        </trans-unit>
        <trans-unit id="d00bedfb8c02a9e78a0c8655d079c8a74339369e" translate="yes" xml:space="preserve">
          <source>Zero otherwise</source>
          <target state="translated">그렇지 않으면 제로</target>
        </trans-unit>
        <trans-unit id="ca77598d8983f14f3898f59c121fdcf1e9e18087" translate="yes" xml:space="preserve">
          <source>[-]d.ddd</source>
          <target state="translated">[-]d.ddd</target>
        </trans-unit>
        <trans-unit id="913e7afee46c7a822906ed5749ddbb4805cee7d2" translate="yes" xml:space="preserve">
          <source>[-]ddd.ddd</source>
          <target state="translated">[-]ddd.ddd</target>
        </trans-unit>
        <trans-unit id="8c2b29412829eefb22455e55f53e2c249d24e11a" translate="yes" xml:space="preserve">
          <source>[-]dddd</source>
          <target state="translated">[-]dddd</target>
        </trans-unit>
        <trans-unit id="c1734847a74561b4543b119ae934914f50b4cfb4" translate="yes" xml:space="preserve">
          <source>[-x3</source>
          <target state="translated">[-x3</target>
        </trans-unit>
        <trans-unit id="d750010a709171aa3f400cbe019efe556b93b506" translate="yes" xml:space="preserve">
          <source>[0,</source>
          <target state="translated">[0,</target>
        </trans-unit>
        <trans-unit id="e61dea886117af6d2ec7f9dcb7bd9a3411c6e61f" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;ranges::begin(E)&lt;/code&gt;, &lt;code&gt;ranges::end(E)&lt;/code&gt;) denotes a range, and</source>
          <target state="translated">[ &lt;code&gt;ranges::begin(E)&lt;/code&gt; , &lt;code&gt;ranges::end(E)&lt;/code&gt; )는 범위를 나타내며</target>
        </trans-unit>
        <trans-unit id="228f7d207920fb84335fac5b2b06ed7b472ece9e" translate="yes" xml:space="preserve">
          <source>[deleted]</source>
          <target state="translated">[deleted]</target>
        </trans-unit>
        <trans-unit id="73a877ccfe464539ac89cb8083cf71234db18da5" translate="yes" xml:space="preserve">
          <source>[first,first)</source>
          <target state="translated">[first,first)</target>
        </trans-unit>
        <trans-unit id="7231a3611aa5bad8f818b0f7bb419a3d1200483d" translate="yes" xml:space="preserve">
          <source>[first,last)</source>
          <target state="translated">[first,last)</target>
        </trans-unit>
        <trans-unit id="2855c5627ea838aafc570baf3e8f5ddda039170b" translate="yes" xml:space="preserve">
          <source>[last,last)</source>
          <target state="translated">[last,last)</target>
        </trans-unit>
        <trans-unit id="51f320773f671463a4338fa2cd7489e0a7d0a19d" translate="yes" xml:space="preserve">
          <source>[nothrow-]swappable traits</source>
          <target state="translated">[콧 구멍] 교환 특성</target>
        </trans-unit>
        <trans-unit id="2706c6dc283ec831e2ea7c5771adc61d0195a5e5" translate="yes" xml:space="preserve">
          <source>[static]</source>
          <target state="translated">[static]</target>
        </trans-unit>
        <trans-unit id="44fed6b6252fc5fda7cc744792424bdd0b7b1020" translate="yes" xml:space="preserve">
          <source>[static](C++11)</source>
          <target state="translated">[static](C++11)</target>
        </trans-unit>
        <trans-unit id="e4b4e5b6ec02f085b66944f0e3a63cac3c002038" translate="yes" xml:space="preserve">
          <source>[static](C++17)</source>
          <target state="translated">[static](C++17)</target>
        </trans-unit>
        <trans-unit id="0352562c44ca57a96c86a8ce2c63b508390a988b" translate="yes" xml:space="preserve">
          <source>[static](C++20)</source>
          <target state="translated">[static](C++20)</target>
        </trans-unit>
        <trans-unit id="85894ee8b74956e4f1ad040534bebb4a92408ba9" translate="yes" xml:space="preserve">
          <source>[static](optional)</source>
          <target state="translated">[static](optional)</target>
        </trans-unit>
        <trans-unit id="e621ceda2c534b69cb910cae3059eb9ff125986d" translate="yes" xml:space="preserve">
          <source>[virtual]</source>
          <target state="translated">[virtual]</target>
        </trans-unit>
        <trans-unit id="986bbf2f9f0c3cbbc6546d685166748b60c20798" translate="yes" xml:space="preserve">
          <source>[virtual](C++11)</source>
          <target state="translated">[virtual](C++11)</target>
        </trans-unit>
        <trans-unit id="8af4f9130ab9142006b068ed0c1ed35271abd3b0" translate="yes" xml:space="preserve">
          <source>[virtual](implicitly declared)</source>
          <target state="translated">[가상] ​​(암시 적으로 선언 됨)</target>
        </trans-unit>
        <trans-unit id="a80e5ea0695ed7f04f7f2926fafe2f96aa4dcb23" translate="yes" xml:space="preserve">
          <source>[x2</source>
          <target state="translated">[x2</target>
        </trans-unit>
        <trans-unit id="36886f5ee53771548cf5c86e4853a8dcf06d3e14" translate="yes" xml:space="preserve">
          <source>] radians, is returned.</source>
          <target state="translated">] 라디안이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="12ec352745ee599586db13a925319fe87a988295" translate="yes" xml:space="preserve">
          <source>], is returned.</source>
          <target state="translated">]가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="056353e23af4506e74d7003cb38640abbea6a449" translate="yes" xml:space="preserve">
          <source>]1/2</source>
          <target state="translated">]1/2</target>
        </trans-unit>
        <trans-unit id="2543ff7b78f94174e33e9adeb84f297edc54fffa" translate="yes" xml:space="preserve">
          <source>_1, _2, _3, _4, ...</source>
          <target state="translated">_1, _2, _3, _4, ...</target>
        </trans-unit>
        <trans-unit id="5903c0497b4b6110dd3051a9b31ef948bae78c64" translate="yes" xml:space="preserve">
          <source>_Exit</source>
          <target state="translated">_Exit</target>
        </trans-unit>
        <trans-unit id="a86d3649d1b2b72954d70aa40f94f98858c527ba" translate="yes" xml:space="preserve">
          <source>_IOFBF_IOLBF_IONBF</source>
          <target state="translated">_IOFBF_IOLBF_IONBF</target>
        </trans-unit>
        <trans-unit id="1b22c1d687dc7c54339d14d0aa2284796291aec8" translate="yes" xml:space="preserve">
          <source>__DATE__</source>
          <target state="translated">__DATE__</target>
        </trans-unit>
        <trans-unit id="9d5d8995523b8b8951428baa81ea663ff0bd2c77" translate="yes" xml:space="preserve">
          <source>__FILE__</source>
          <target state="translated">__FILE__</target>
        </trans-unit>
        <trans-unit id="a51b95694c81c92580bff6f580f8e200ecf86661" translate="yes" xml:space="preserve">
          <source>__LINE__</source>
          <target state="translated">__LINE__</target>
        </trans-unit>
        <trans-unit id="ce0bc0efbd8965b4d82a11aa07f4fab94777d3af" translate="yes" xml:space="preserve">
          <source>__STDCPP_DEFAULT_NEW_ALIGNMENT__</source>
          <target state="translated">__STDCPP_DEFAULT_NEW_ALIGNMENT__</target>
        </trans-unit>
        <trans-unit id="db9a3eaebbc58b7b2dff63e6d1078194a02871a4" translate="yes" xml:space="preserve">
          <source>__STDCPP_STRICT_POINTER_SAFETY__</source>
          <target state="translated">__STDCPP_STRICT_POINTER_SAFETY__</target>
        </trans-unit>
        <trans-unit id="950ee9617b60ace35791cfba67c4eda35d86e1d5" translate="yes" xml:space="preserve">
          <source>__STDCPP_THREADS__</source>
          <target state="translated">__STDCPP_THREADS__</target>
        </trans-unit>
        <trans-unit id="51f3c9479afc9737ac0812162dcb10cc18fbbd51" translate="yes" xml:space="preserve">
          <source>__STDC_HOSTED__</source>
          <target state="translated">__STDC_HOSTED__</target>
        </trans-unit>
        <trans-unit id="aa16038a596c275e6fffc69644dbad7ec1a3ceb3" translate="yes" xml:space="preserve">
          <source>__STDC_ISO_10646__</source>
          <target state="translated">__STDC_ISO_10646__</target>
        </trans-unit>
        <trans-unit id="230648d096a182990dad2c93fa8e616a0bed8465" translate="yes" xml:space="preserve">
          <source>__STDC_MB_MIGHT_NEQ_WC__</source>
          <target state="translated">__STDC_MB_MIGHT_NEQ_WC__</target>
        </trans-unit>
        <trans-unit id="aec164fb4da1e304eadad72b50ba5910b1144c03" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_16__</source>
          <target state="translated">__STDC_UTF_16__</target>
        </trans-unit>
        <trans-unit id="92432151980d707704b3ddfa392fde3ab589eb6c" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_32__</source>
          <target state="translated">__STDC_UTF_32__</target>
        </trans-unit>
        <trans-unit id="04202f9ce8c923e1e74ba2bfa78f2696041116d2" translate="yes" xml:space="preserve">
          <source>__STDC_VERSION__</source>
          <target state="translated">__STDC_VERSION__</target>
        </trans-unit>
        <trans-unit id="e7fe05e43de55659e13d860cf51adc28583a4875" translate="yes" xml:space="preserve">
          <source>__STDC__</source>
          <target state="translated">__STDC__</target>
        </trans-unit>
        <trans-unit id="cf716a68ef036dac529946b2640a330f562725fe" translate="yes" xml:space="preserve">
          <source>__TIME__</source>
          <target state="translated">__TIME__</target>
        </trans-unit>
        <trans-unit id="9c3e29639fd2bfaa4db627da53f4d56eac9f0ec0" translate="yes" xml:space="preserve">
          <source>__alignas_is_defined</source>
          <target state="translated">__alignas_is_defined</target>
        </trans-unit>
        <trans-unit id="d950e8ee18472fe83432e8178dd5392fac322513" translate="yes" xml:space="preserve">
          <source>__bool_true_false_are_defined</source>
          <target state="translated">__bool_true_false_are_defined</target>
        </trans-unit>
        <trans-unit id="a6268e3a2fc1725738e330bb09c9305b72ece231" translate="yes" xml:space="preserve">
          <source>__cplusplus</source>
          <target state="translated">__cplusplus</target>
        </trans-unit>
        <trans-unit id="e03702be2b6d9f308bc474cdb111403f31d2ea87" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_bases</source>
          <target state="translated">__cpp_aggregate_bases</target>
        </trans-unit>
        <trans-unit id="78f7eebcfee8baee7f506621f7ceff180ebb38c2" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_nsdmi</source>
          <target state="translated">__cpp_aggregate_nsdmi</target>
        </trans-unit>
        <trans-unit id="aecf58d673edcb66d050d3e2e7eba5a0afe4185c" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_paren_init</source>
          <target state="translated">__cpp_aggregate_paren_init</target>
        </trans-unit>
        <trans-unit id="4db17205b03376efcf08532704df0a94b80ff2e1" translate="yes" xml:space="preserve">
          <source>__cpp_alias_templates</source>
          <target state="translated">__cpp_alias_templates</target>
        </trans-unit>
        <trans-unit id="1b50ffd26242db4d6bb36e8a073d57b42af92dbe" translate="yes" xml:space="preserve">
          <source>__cpp_aligned_new</source>
          <target state="translated">__cpp_aligned_new</target>
        </trans-unit>
        <trans-unit id="27d2797bf877b1368535c5fbc7789bf8e7a43d75" translate="yes" xml:space="preserve">
          <source>__cpp_attributes</source>
          <target state="translated">__cpp_attributes</target>
        </trans-unit>
        <trans-unit id="fa07d30cba0187822a54da7812f67ef73fb0b29b" translate="yes" xml:space="preserve">
          <source>__cpp_binary_literals</source>
          <target state="translated">__cpp_binary_literals</target>
        </trans-unit>
        <trans-unit id="9233221aaacde95fdd55b38eb0f389324843a986" translate="yes" xml:space="preserve">
          <source>__cpp_capture_star_this</source>
          <target state="translated">__cpp_capture_star_this</target>
        </trans-unit>
        <trans-unit id="fbff2a2d3bc0732868b008428dd2e17daf86c9d1" translate="yes" xml:space="preserve">
          <source>__cpp_char8_t</source>
          <target state="translated">__cpp_char8_t</target>
        </trans-unit>
        <trans-unit id="35879cf6edddadc7f07576b594f812ccd01e0e28" translate="yes" xml:space="preserve">
          <source>__cpp_conditional_explicit</source>
          <target state="translated">__cpp_conditional_explicit</target>
        </trans-unit>
        <trans-unit id="6554a18ee88c8522382d28ab36f8ebd7e175fe13" translate="yes" xml:space="preserve">
          <source>__cpp_constexpr</source>
          <target state="translated">__cpp_constexpr</target>
        </trans-unit>
        <trans-unit id="e1c9cd84aa5ce04eef2027ea160ca3290b7ad000" translate="yes" xml:space="preserve">
          <source>__cpp_coroutines</source>
          <target state="translated">__cpp_coroutines</target>
        </trans-unit>
        <trans-unit id="1a2e5b6980d3ec352ab8610b6aebe0331f7c85de" translate="yes" xml:space="preserve">
          <source>__cpp_decltype</source>
          <target state="translated">__cpp_decltype</target>
        </trans-unit>
        <trans-unit id="30e058b311be2115aab20cb7ab797af4bf73322c" translate="yes" xml:space="preserve">
          <source>__cpp_decltype_auto</source>
          <target state="translated">__cpp_decltype_auto</target>
        </trans-unit>
        <trans-unit id="242a749b73f040bf68fa933b9175781fd85d21c1" translate="yes" xml:space="preserve">
          <source>__cpp_deduction_guides</source>
          <target state="translated">__cpp_deduction_guides</target>
        </trans-unit>
        <trans-unit id="3a8bdd7fb017e4f5b12dd8b2fab50c0f9a716657" translate="yes" xml:space="preserve">
          <source>__cpp_delegating_constructors</source>
          <target state="translated">__cpp_delegating_constructors</target>
        </trans-unit>
        <trans-unit id="975250ed39319bc10f0e4f6ba32b904cf175257c" translate="yes" xml:space="preserve">
          <source>__cpp_enumerator_attributes</source>
          <target state="translated">__cpp_enumerator_attributes</target>
        </trans-unit>
        <trans-unit id="3b5c1d2ec9a03cdd0631a101d55a030f176f3d74" translate="yes" xml:space="preserve">
          <source>__cpp_fold_expressions</source>
          <target state="translated">__cpp_fold_expressions</target>
        </trans-unit>
        <trans-unit id="dd54e558a55e90a31a278a30b8a17bd0470a27e5" translate="yes" xml:space="preserve">
          <source>__cpp_generic_lambdas</source>
          <target state="translated">__cpp_generic_lambdas</target>
        </trans-unit>
        <trans-unit id="5851aabfab46bf1cf3f38d2a662260f69f39fefc" translate="yes" xml:space="preserve">
          <source>__cpp_guaranteed_copy_elision</source>
          <target state="translated">__cpp_guaranteed_copy_elision</target>
        </trans-unit>
        <trans-unit id="64dc522012e8e37b94c68ea1e95e711e0d899c02" translate="yes" xml:space="preserve">
          <source>__cpp_hex_float</source>
          <target state="translated">__cpp_hex_float</target>
        </trans-unit>
        <trans-unit id="3817658cc0a09b582191a5b7ff9d3c12fb638b2d" translate="yes" xml:space="preserve">
          <source>__cpp_if_constexpr</source>
          <target state="translated">__cpp_if_constexpr</target>
        </trans-unit>
        <trans-unit id="01e50fa24457c5e9436a8e8e470f75ec87f89e94" translate="yes" xml:space="preserve">
          <source>__cpp_impl_destroying_delete</source>
          <target state="translated">__cpp_impl_destroying_delete</target>
        </trans-unit>
        <trans-unit id="10f562ee8727c9aeeefccee7e22065b234af8837" translate="yes" xml:space="preserve">
          <source>__cpp_impl_three_way_comparison</source>
          <target state="translated">__cpp_impl_three_way_comparison</target>
        </trans-unit>
        <trans-unit id="8372b211ab7aa3d2db5ef6dbe4bf9e84d46edd52" translate="yes" xml:space="preserve">
          <source>__cpp_inheriting_constructors</source>
          <target state="translated">__cpp_inheriting_constructors</target>
        </trans-unit>
        <trans-unit id="8db78a428ed6164ef434f29d445b397d48025bd3" translate="yes" xml:space="preserve">
          <source>__cpp_init_captures</source>
          <target state="translated">__cpp_init_captures</target>
        </trans-unit>
        <trans-unit id="3331bad3edb7735ec64c6916056cfc10590dcf69" translate="yes" xml:space="preserve">
          <source>__cpp_initializer_lists</source>
          <target state="translated">__cpp_initializer_lists</target>
        </trans-unit>
        <trans-unit id="81e37cead058df9398dca1e6d13208a976c4012c" translate="yes" xml:space="preserve">
          <source>__cpp_inline_variables</source>
          <target state="translated">__cpp_inline_variables</target>
        </trans-unit>
        <trans-unit id="3c68286ccf869158575094937b8b2a98ffb48599" translate="yes" xml:space="preserve">
          <source>__cpp_lambdas</source>
          <target state="translated">__cpp_lambdas</target>
        </trans-unit>
        <trans-unit id="2590a0ceb1649ffba013a25521809a21cd1284de" translate="yes" xml:space="preserve">
          <source>__cpp_namespace_attributes</source>
          <target state="translated">__cpp_namespace_attributes</target>
        </trans-unit>
        <trans-unit id="30cc60a82cc1d4477a2e07c1fa7a6a64cc1023c3" translate="yes" xml:space="preserve">
          <source>__cpp_noexcept_function_type</source>
          <target state="translated">__cpp_noexcept_function_type</target>
        </trans-unit>
        <trans-unit id="2593d2642e9db46e71f999b1bc148024d6d0b831" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_args</source>
          <target state="translated">__cpp_nontype_template_args</target>
        </trans-unit>
        <trans-unit id="1892415e299d418abcb2ce3608af04f19ac199e1" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_parameter_auto</source>
          <target state="translated">__cpp_nontype_template_parameter_auto</target>
        </trans-unit>
        <trans-unit id="8e2497a317030abf3388ed8fcdc0f581460fd74b" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_parameter_class</source>
          <target state="translated">__cpp_nontype_template_parameter_class</target>
        </trans-unit>
        <trans-unit id="6f298ec98a281e895e57730ee42e4b685bf1d6e1" translate="yes" xml:space="preserve">
          <source>__cpp_nsdmi</source>
          <target state="translated">__cpp_nsdmi</target>
        </trans-unit>
        <trans-unit id="7844fe22ff8583f864600cf24c8acf071a07a268" translate="yes" xml:space="preserve">
          <source>__cpp_range_based_for</source>
          <target state="translated">__cpp_range_based_for</target>
        </trans-unit>
        <trans-unit id="e94a403428d4ea97b6f263dbcb0874c541f05fc8" translate="yes" xml:space="preserve">
          <source>__cpp_raw_strings</source>
          <target state="translated">__cpp_raw_strings</target>
        </trans-unit>
        <trans-unit id="2a807128a5985f4aedc323c209f0b26cf031ddc5" translate="yes" xml:space="preserve">
          <source>__cpp_ref_qualifiers</source>
          <target state="translated">__cpp_ref_qualifiers</target>
        </trans-unit>
        <trans-unit id="ec7f8108d8bd7c3189219118c4b92ebae110f376" translate="yes" xml:space="preserve">
          <source>__cpp_return_type_deduction</source>
          <target state="translated">__cpp_return_type_deduction</target>
        </trans-unit>
        <trans-unit id="a27448bb794e05840712bcbb343a4cbf12fadae2" translate="yes" xml:space="preserve">
          <source>__cpp_rvalue_references</source>
          <target state="translated">__cpp_rvalue_references</target>
        </trans-unit>
        <trans-unit id="28d6e14e6e0b8b130a165866cca9649aa7e9d864" translate="yes" xml:space="preserve">
          <source>__cpp_sized_deallocation</source>
          <target state="translated">__cpp_sized_deallocation</target>
        </trans-unit>
        <trans-unit id="d77473f1a619fc342dfc9123063a318297214d20" translate="yes" xml:space="preserve">
          <source>__cpp_static_assert</source>
          <target state="translated">__cpp_static_assert</target>
        </trans-unit>
        <trans-unit id="af80adf8b09bcfceb7e7134decd3d99ebd88c373" translate="yes" xml:space="preserve">
          <source>__cpp_structured_bindings</source>
          <target state="translated">__cpp_structured_bindings</target>
        </trans-unit>
        <trans-unit id="5456a2323fecac083d969b4421be5b3b5e785149" translate="yes" xml:space="preserve">
          <source>__cpp_template_template_args</source>
          <target state="translated">__cpp_template_template_args</target>
        </trans-unit>
        <trans-unit id="ddc5e77386a83826283ed12a4b5d3455f2275f1a" translate="yes" xml:space="preserve">
          <source>__cpp_threadsafe_static_init</source>
          <target state="translated">__cpp_threadsafe_static_init</target>
        </trans-unit>
        <trans-unit id="a51600d8c1a1f10a16f1e43b746d8821a1ba5bff" translate="yes" xml:space="preserve">
          <source>__cpp_unicode_characters</source>
          <target state="translated">__cpp_unicode_characters</target>
        </trans-unit>
        <trans-unit id="696ac6453d6507dd7871ba65e03fe52e19383ef5" translate="yes" xml:space="preserve">
          <source>__cpp_unicode_literals</source>
          <target state="translated">__cpp_unicode_literals</target>
        </trans-unit>
        <trans-unit id="fcfb6a809b1f0636cfdcac8dcaf0a56faf741fe9" translate="yes" xml:space="preserve">
          <source>__cpp_user_defined_literals</source>
          <target state="translated">__cpp_user_defined_literals</target>
        </trans-unit>
        <trans-unit id="793fd52dc655ccacc0d8fa1b3bf368e5266577b4" translate="yes" xml:space="preserve">
          <source>__cpp_variable_templates</source>
          <target state="translated">__cpp_variable_templates</target>
        </trans-unit>
        <trans-unit id="b2c1a1181d35bf405e3ead748a7662168e324024" translate="yes" xml:space="preserve">
          <source>__cpp_variadic_templates</source>
          <target state="translated">__cpp_variadic_templates</target>
        </trans-unit>
        <trans-unit id="423eb61df1fcdbb8fb8c6511db90aa6fb0318eaf" translate="yes" xml:space="preserve">
          <source>__cpp_variadic_using</source>
          <target state="translated">__cpp_variadic_using</target>
        </trans-unit>
        <trans-unit id="d8db95cc58ad2925bc93429910aec8cf2d80ad01" translate="yes" xml:space="preserve">
          <source>__func__</source>
          <target state="translated">__func__</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="d66612ccc3a3c60bbf9be396b2e583b9ad6f732e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../language/dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt; expression</source>
          <target state="translated">&lt;a href=&quot;../../language/dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; 는의&lt;/a&gt; 표현</target>
        </trans-unit>
        <trans-unit id="578b0d09cf884cabb2256541be565e3232f4a2d1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../language/throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; expression</source>
          <target state="translated">&lt;a href=&quot;../../language/throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt; 표현</target>
        </trans-unit>
        <trans-unit id="0c35fd85853bd90c9dea0e943c9e3e345e596a8c" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; that accepts every possible alternative from every variant</source>
          <target state="translated">모든 변형에서 가능한 모든 대안을 받아들이 는 &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f547d6f47fe102ed4af5089aaf331e46cb4bd5e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../language/lambda&quot;&gt;closure&lt;/a&gt; type</source>
          <target state="translated">&lt;a href=&quot;../language/lambda&quot;&gt;폐쇄&lt;/a&gt; 형</target>
        </trans-unit>
        <trans-unit id="e0406f8e858cd057dce3f1a1bd186c9b49e3cd51" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../language/operator_member_access#Built-in_member_access_operators&quot;&gt;pseudo-destructor call&lt;/a&gt; (if &lt;code&gt;It&lt;/code&gt; is a scalar type)</source>
          <target state="translated">&lt;a href=&quot;../language/operator_member_access#Built-in_member_access_operators&quot;&gt;의사 소멸자 호출&lt;/a&gt; (경우에 &lt;code&gt;It&lt;/code&gt; 스칼라 타입입니다)</target>
        </trans-unit>
        <trans-unit id="2f2aa4051bfd7ae365b4f4b11cedb58bbfd66b3e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; whose result type is convertible to &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt&amp;gt;::difference_type&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; 그 결과 형태로 변환 가능한 &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt&amp;gt;::difference_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f35df8d2006030e7d4d979822b8a81b4761ea9f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of a sequence generated by repeatedly incrementing an initial value</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; 반복 초기 값을 증가함으로써 생성되는 서열로 이루어지는</target>
        </trans-unit>
        <trans-unit id="f1b66b4d9a0ae57bf6f377005ad0ae6842f473ed" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the first N elements of another &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; 다른 제 N의 원소로 이루어진 &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae981f6c70dcb78f089b85eeb651ce9e721b682b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the sequence obtained from flattening a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;s&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; 평탄화에서 얻은 순서로 구성 &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; 들&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e20442d4936a5775a6caf427d491901e50216ebf" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of a sequence that applies a transformation function to each element</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; 각 요소 변환 함수를 적용 시퀀스</target>
        </trans-unit>
        <trans-unit id="289a5f74d80c8aa744c90c4ee3868ed8609c9f49" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of the elements of some other &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다른 &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 의 요소에 대한 &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a94750304f2970083f4213aac2cf32daebafda1d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; over the subranges obtained from splitting another &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; using a delimiter</source>
          <target state="translated">구분자를 사용하여 다른 &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; 를 분할하여 얻은 하위 범위에 대한 &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a4653cdeeb9369cc880c44c330b4bacc547ec37" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that consists of the elements of a &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; that satisfies a predicate</source>
          <target state="translated">&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; a의 요소로 구성 &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 를 만족 술어 그</target>
        </trans-unit>
        <trans-unit id="6c2fbed5ca96d4b2858696b97f8e59367cd9ca66" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that contains a single element of a specified value</source>
          <target state="translated">지정된 값의 단일 요소를 포함 하는 &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c7f3a3db304dcf5be7bc978bb2552c12c8bc06fb" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of a &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; 의&lt;/a&gt; 모든 요소를 ​​포함 하는 &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af11d84750e4dccfceeeab50c1f40114755c03a1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that iterates over the elements of another bidirectional view in reverse order</source>
          <target state="translated">다른 양방향 뷰의 요소를 역순으로 반복 하는 &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e8c8ad0f2aa5b2688c79e49a80f74556ff5bb1c3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../types/is_scalar&quot;&gt;scalar type&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;../types/is_scalar&quot;&gt;스칼라 유형&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="c5f1f7ebf1a60286c3263705f1ff2699892ba31a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; that establishes an ordering relation</source>
          <target state="translated">&lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; 순서화 관계를 확립</target>
        </trans-unit>
        <trans-unit id="b54276a912036a81a33307973d33e286dfbef1ac" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;bit_field&quot;&gt;&lt;i&gt;bit field&lt;/i&gt;&lt;/a&gt; type can be converted to &lt;code&gt;int&lt;/code&gt; if it can represent entire value range of the bit field, otherwise to &lt;code&gt;unsigned int&lt;/code&gt; if it can represent entire value range of the bit field, otherwise no integral promotions apply;</source>
          <target state="translated">&lt;a href=&quot;bit_field&quot;&gt;&lt;i&gt;비트 필드&lt;/i&gt;&lt;/a&gt; 유형으로 변환 할 수 &lt;code&gt;int&lt;/code&gt; 는로, 그렇지 않으면 비트 필드의 전체 값의 범위를 나타낼 수 있으면 &lt;code&gt;unsigned int&lt;/code&gt; 는 비트 필드의 전체 값의 범위를 나타낼 수 있는지 그렇지 않으면 일체 프로모션이 적용되지 않는다;</target>
        </trans-unit>
        <trans-unit id="04be27008e83afb2d331f92d72c2fab2182c7c06" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; name, such as &lt;code&gt;operator bool&lt;/code&gt;;</source>
          <target state="translated">&lt;a href=&quot;cast_operator&quot;&gt;사용자 정의 변환 함수&lt;/a&gt; 와 같은 이름, &lt;code&gt;operator bool&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="842b9bb73f31c7a70a7a8e8933647e7f312f7d30" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;class&quot;&gt;class declaration&lt;/a&gt;. The class name declared becomes a template name.</source>
          <target state="translated">&lt;a href=&quot;class&quot;&gt;클래스 선언&lt;/a&gt; . 선언 된 클래스 이름은 템플릿 이름이됩니다.</target>
        </trans-unit>
        <trans-unit id="58329cef5c48b9dd6d75ade29a0076bc7230f05a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;class#Member_specification&quot;&gt;class member declaration&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;class#Member_specification&quot;&gt;클래스 멤버 선언&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="197dcdb99acb57525f9c2a6fe89a245471fd8142" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;contextually converted constant expression of type &lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형 의 문맥 상으로 변환 된 상수 표현식</target>
        </trans-unit>
        <trans-unit id="b40006546d705539bc635f3175ea4d35431ac2da" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints&quot;&gt;constraint expression&lt;/a&gt; which restricts the template parameters accepted by this function template</source>
          <target state="translated">이 함수 템플릿이 허용하는 템플릿 매개 변수를 제한 하는 &lt;a href=&quot;constraints&quot;&gt;제약 조건 식&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dbc4d6e8690db53ad192b32cd88e3433f51c72d3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints&quot;&gt;requires-expression&lt;/a&gt;, such as &lt;code&gt;requires (T i) { typename T::type; }&lt;/code&gt;;</source>
          <target state="translated">A는 &lt;a href=&quot;constraints&quot;&gt;필요 표현을&lt;/a&gt; , 예컨대 &lt;code&gt;requires (T i) { typename T::type; }&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="6a7178c89e852f09b520cb3d8d0a0704888c1d34" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints#Concepts&quot;&gt;concept&lt;/a&gt; name, optionally qualified, optionally followed by a template argument list enclosed in &amp;lt;&amp;gt;</source>
          <target state="translated">&lt;a href=&quot;constraints#Concepts&quot;&gt;개념&lt;/a&gt; 이름을 임의로 규정 임의로 &amp;lt;&amp;gt;로 둘러싸인 템플릿 인수 목록 뒤에</target>
        </trans-unit>
        <trans-unit id="e54b0edc591fc30ea27121f4b241249a88d6dd05" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a named variable, whose type is the type of the element of the sequence represented by range_expression, or a reference to that type. Often uses the &lt;a href=&quot;auto&quot;&gt;auto specifier&lt;/a&gt; for automatic type deduction</source>
          <target state="translated">명명 된 변수 의 &lt;a href=&quot;declarations&quot;&gt;선언.&lt;/a&gt; 유형이 range_expression으로 표시되는 시퀀스 요소의 유형이거나 해당 유형에 대한 참조 종종 자동 유형 공제에 &lt;a href=&quot;auto&quot;&gt;자동 지정자&lt;/a&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="feba1f8215a9e5044f736d79557f6d6af77814ce" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a single variable with a brace-or-equals &lt;a href=&quot;initialization&quot;&gt;initializer&lt;/a&gt;. the initializer is evaluated before each iteration, and if the value of the declared variable converts to &lt;code&gt;false&lt;/code&gt;, the loop is exited.</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 기호가있는 하나의 변수의 중괄호 또는-동일 &lt;a href=&quot;initialization&quot;&gt;초기화&lt;/a&gt; . 이니셜 라이저는 각 반복 전에 평가되며 선언 된 변수의 값이 &lt;code&gt;false&lt;/code&gt; 로 변환 되면 루프가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9b8e7399060c9f5d9013f6aa031f2daeaf247245" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a variable. The declared variable name becomes a template name.</source>
          <target state="translated">&lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 변수. 선언 된 변수 이름은 템플릿 이름이됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
