<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="b2bd7d3deca1dfde9d0e77745248dd3241e3fb2f" translate="yes" xml:space="preserve">
          <source>Hardware could require that an object to be referenced by an &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; have stricter alignment than other &lt;code&gt;T&lt;/code&gt; objects, and whether operations on an &lt;code&gt;atomic_ref&lt;/code&gt; are lock-free can depend on the alignment of the referenced object.</source>
          <target state="translated">하드웨어는 &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; 가 참조 할 오브젝트 가 다른 &lt;code&gt;T&lt;/code&gt; 오브젝트 보다 더 엄격한 정렬을 &lt;code&gt;atomic_ref&lt;/code&gt; 있으며 atomic_ref의 조작 이 잠금이 없는지 여부 는 참조 된 오브젝트의 정렬에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50278ca49d19fb7161c9b6156704c44ac84f382e" translate="yes" xml:space="preserve">
          <source>Has all non-static data members and bit-fields declared in the same class (either all in the derived or all in some base)</source>
          <target state="translated">정적이 아닌 데이터 멤버와 비트 필드가 모두 같은 클래스에서 선언되었습니다 (모두 파생되었거나 일부 기본에 모두).</target>
        </trans-unit>
        <trans-unit id="132088df73d03b2b991fee16006dc96529cc0d11" translate="yes" xml:space="preserve">
          <source>Has no base classes of the same type as the first non-static data member (see &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;)</source>
          <target state="translated">첫 번째 비 정적 데이터 멤버와 동일한 유형의 기본 클래스가 없습니다 ( &lt;a href=&quot;../language/ebo&quot;&gt;빈 기본 최적화&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3282080bc3a2066760485abf22d4931cd7cf3786" translate="yes" xml:space="preserve">
          <source>Has no non-static data members of reference type</source>
          <target state="translated">참조 유형의 비 정적 데이터 멤버가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4b0a2efb77a438bdd71e13e8a4b27ab2c2ef90e" translate="yes" xml:space="preserve">
          <source>Has no two (possibly indirect) base class subobjects of the same type</source>
          <target state="translated">동일한 유형의 기본 클래스 하위 오브젝트가 두 개 (간접적으로있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="e78a6eedfa1171855e11a7dd558ba1ee29f9b975" translate="yes" xml:space="preserve">
          <source>Has no virtual functions or virtual base classes</source>
          <target state="translated">가상 함수 또는 가상 기본 클래스가 없습니다</target>
        </trans-unit>
        <trans-unit id="07ad7632b84dfe67303c7a8f028a0886800e4870" translate="yes" xml:space="preserve">
          <source>Has one or more &lt;a href=&quot;../language/default_constructor&quot;&gt;default constructors&lt;/a&gt;, all of which are either &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial&lt;/a&gt; or deleted, and at least one of which is not deleted.</source>
          <target state="translated">하나 이상의 &lt;a href=&quot;../language/default_constructor&quot;&gt;기본 생성자가 있습니다.이 생성자&lt;/a&gt; 는 모두 &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;사소&lt;/a&gt; 하거나 삭제되었으며 적어도 하나는 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="cc87e65725671e76b83dd75a39435552efd495a6" translate="yes" xml:space="preserve">
          <source>Hash functions are only required to produce the same result for the same input within a single execution of a program; this allows salted hashes that prevent collision denial-of-service attacks.</source>
          <target state="translated">해시 함수는 프로그램의 단일 실행 내에서 동일한 입력에 대해 동일한 결과를 생성하는 데만 필요합니다. 이를 통해 충돌 서비스 거부 공격을 방지하는 솔트 해시가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4cd57ebbbfb5b1908d66fa1e003e1ce14e29637e" translate="yes" xml:space="preserve">
          <source>Hash functions should not throw exceptions.</source>
          <target state="translated">해시 함수는 예외를 발생시키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="7250b05d4111b3b36a49cda927210c8e3d368f6a" translate="yes" xml:space="preserve">
          <source>Hash policy</source>
          <target state="translated">해시 정책</target>
        </trans-unit>
        <trans-unit id="b807d317600ff4b338e846d561ee4e0b84f0360a" translate="yes" xml:space="preserve">
          <source>Hash support</source>
          <target state="translated">해시 지원</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="31341c6f0c7af677ffb8fadcb92038e8ac2b6193" translate="yes" xml:space="preserve">
          <source>Header</source>
          <target state="translated">Header</target>
        </trans-unit>
        <trans-unit id="f123fa3f00736262aa136563dd12c3a430fa1bf8" translate="yes" xml:space="preserve">
          <source>Header name preprocessing tokens are only formed within a &lt;code&gt;#include&lt;/code&gt; directive.</source>
          <target state="translated">헤더 이름 사전 처리 토큰은 &lt;code&gt;#include&lt;/code&gt; 지시문 내에서만 형성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a9eca02fd1369c5ba18c271ae9822e684c6bc3d" translate="yes" xml:space="preserve">
          <source>Headers required for a</source>
          <target state="translated">에 필요한 헤더</target>
        </trans-unit>
        <trans-unit id="8cd5e50ec159eebcf43e109ff007519db94c87f5" translate="yes" xml:space="preserve">
          <source>Heap allocation</source>
          <target state="translated">힙 할당</target>
        </trans-unit>
        <trans-unit id="adcf91c671cec8bebaf87ee37c2421ff5ebb56fd" translate="yes" xml:space="preserve">
          <source>Heap operations</source>
          <target state="translated">힙 작업</target>
        </trans-unit>
        <trans-unit id="43a1b94a7a6895d855248fbccdd91510cfbd3ac0" translate="yes" xml:space="preserve">
          <source>Helper Classes</source>
          <target state="translated">헬퍼 클래스</target>
        </trans-unit>
        <trans-unit id="035f96a8918459049a59bec0947605cd2a64fdef" translate="yes" xml:space="preserve">
          <source>Helper classes</source>
          <target state="translated">도우미 클래스</target>
        </trans-unit>
        <trans-unit id="7612db9ee91cb4487af96f647ff4f3cd2038be3a" translate="yes" xml:space="preserve">
          <source>Helper concepts</source>
          <target state="translated">헬퍼 개념</target>
        </trans-unit>
        <trans-unit id="058d2ea713d8ed40ef598fece850d00d28cef415" translate="yes" xml:space="preserve">
          <source>Helper functions &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; are often used to generate &lt;code&gt;std::reference_wrapper&lt;/code&gt; objects.</source>
          <target state="translated">도우미 함수 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; 는 종종 &lt;code&gt;std::reference_wrapper&lt;/code&gt; 객체 를 생성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9564c40bd71a52a2d2792a274dcd71ecab83247" translate="yes" xml:space="preserve">
          <source>Helper functions to control the format of input and output</source>
          <target state="translated">입력 및 출력 형식을 제어하는 ​​도우미 기능</target>
        </trans-unit>
        <trans-unit id="24355834da4c51ce8fa25dadf7ca038baf516e2f" translate="yes" xml:space="preserve">
          <source>Helper objects</source>
          <target state="translated">헬퍼 객체</target>
        </trans-unit>
        <trans-unit id="bbca939563aab0002ed11e9e60251643d9e2435c" translate="yes" xml:space="preserve">
          <source>Helper template</source>
          <target state="translated">도우미 템플릿</target>
        </trans-unit>
        <trans-unit id="26e4565205fc729962b9119b4035fad3d08ea499" translate="yes" xml:space="preserve">
          <source>Helper template alias</source>
          <target state="translated">헬퍼 템플릿 별명</target>
        </trans-unit>
        <trans-unit id="62f3bc8fedb9c00e4b9d3da1c58627fb9c932c3e" translate="yes" xml:space="preserve">
          <source>Helper templates</source>
          <target state="translated">도우미 템플릿</target>
        </trans-unit>
        <trans-unit id="58208feff4ae33c36603b46c3dceaa24f222cc8d" translate="yes" xml:space="preserve">
          <source>Helper types</source>
          <target state="translated">도우미 유형</target>
        </trans-unit>
        <trans-unit id="0b456005f09a660089e455709c3792d427e45f64" translate="yes" xml:space="preserve">
          <source>Helper variable template</source>
          <target state="translated">헬퍼 변수 템플릿</target>
        </trans-unit>
        <trans-unit id="777d2c2c6fac9bb59d841ec60aa0bce62ce73ffb" translate="yes" xml:space="preserve">
          <source>Helper variable templates</source>
          <target state="translated">도우미 변수 템플릿</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="7023d54552e06b34cfb338ed903ce5341dc89c1a" translate="yes" xml:space="preserve">
          <source>Here &amp;mu; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;mean&lt;/a&gt; and &amp;sigma; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; (</source>
          <target state="translated">여기서 &amp;mu;는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;평균&lt;/a&gt; 이고 &amp;sigma;는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;표준 편차입니다&lt;/a&gt; (</target>
        </trans-unit>
        <trans-unit id="de582de9c63661c059dbbb7442ed40762e356594" translate="yes" xml:space="preserve">
          <source>Here the sequence &lt;code&gt;= 0&lt;/code&gt; is known as pure-specifier, and appears either immediately after the declarator or after the optional virt-specifier (&lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; or &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;).</source>
          <target state="translated">여기서 시퀀스 &lt;code&gt;= 0&lt;/code&gt; 은 순수 지정자로 알려져 있으며 선언자 바로 뒤에 또는 선택적 virt 지정자 뒤에 &lt;a href=&quot;override&quot;&gt;있습니다&lt;/a&gt; ( override 또는 &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4d46b65d1ca1962518c48c70d9aa7c8452f90c5" translate="yes" xml:space="preserve">
          <source>Here, &lt;b&gt;insertion&lt;/b&gt; refers to any method which adds one or more elements to the container and &lt;b&gt;erasure&lt;/b&gt; refers to any method which removes one or more elements from the container.</source>
          <target state="translated">여기서, &lt;b&gt;삽입&lt;/b&gt; 은 컨테이너에 하나 이상의 요소를 추가하는 임의의 방법을 말하며 , &lt;b&gt;삭제&lt;/b&gt; 는 컨테이너에서 하나 이상의 요소를 제거하는 임의의 방법을 지칭한다.</target>
        </trans-unit>
        <trans-unit id="b19a132f13926967d1824a2efe39a0ee64381eb2" translate="yes" xml:space="preserve">
          <source>Hermite polynomials</source>
          <target state="translated">은자 다항식</target>
        </trans-unit>
        <trans-unit id="2dc4f9ad06827dbb0f947199ccb4b57ddbc18030" translate="yes" xml:space="preserve">
          <source>Hexadecimal escape sequences have no length limit and terminate at the first character that is not a valid hexadecimal digit. If the value represented by a single hexadecimal escape sequence does not fit the range of values represented by the character type used in this string literal (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, or &lt;code&gt;wchar_t&lt;/code&gt;), the result is unspecified.</source>
          <target state="translated">16 진 이스케이프 시퀀스에는 길이 제한이 없으며 유효한 16 진 숫자가 아닌 첫 번째 문자에서 종료됩니다. 단일 16 진 이스케이프 시퀀스로 표시되는 값이이 문자열 리터럴 ( &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; 또는 &lt;code&gt;wchar_t&lt;/code&gt; )에 사용 된 문자 유형으로 표시되는 값 범위에 맞지 않으면 결과가 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29f4576900e04b4bdfd8b4fe7f982605474c3863" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating literals</source>
          <target state="translated">16 진 부동 리터럴</target>
        </trans-unit>
        <trans-unit id="fcb2d1955da83c672014766fe096b6618bd4cc33" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point formatting ignores the stream precision specification, as required by the specification of &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">16 진 부동 소수점 형식화는 &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt; 스펙에 필요한대로 스트림 정밀도 스펙을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="903711dad7d075316de1f7c8c822711821173306" translate="yes" xml:space="preserve">
          <source>Higher level memory management utilities</source>
          <target state="translated">더 높은 수준의 메모리 관리 유틸리티</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="0201fd3572c6260109888327f99b40b98e8c814b" translate="yes" xml:space="preserve">
          <source>History of C++</source>
          <target state="translated">C ++의 역사</target>
        </trans-unit>
        <trans-unit id="9c025e64c93f51353b31decb167c0c14635a6990" translate="yes" xml:space="preserve">
          <source>Host is unreachable</source>
          <target state="translated">호스트에 연결할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="96e08c08807a48c02c8a25b2e222a3aa87859604" translate="yes" xml:space="preserve">
          <source>Hour, minute, second</source>
          <target state="translated">시, 분, 초</target>
        </trans-unit>
        <trans-unit id="a84d5827435e6eaee2628507f60c486924602e72" translate="yes" xml:space="preserve">
          <source>However if &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; no applications of the predicate are made.</source>
          <target state="translated">그러나 &lt;code&gt;ForwardIt1&lt;/code&gt; 및 &lt;code&gt;ForwardIt2&lt;/code&gt; 가 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 및 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; 의 요구 사항을 충족하는 경우 술어를 적용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06e6faa2b0497056bfffbc66aaba9ed450e5ff3a" translate="yes" xml:space="preserve">
          <source>However, all C++ compilers use &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;two's complement&lt;/a&gt; representation, and as of C++20, it is the only representation allowed by the standard, with the guaranteed range from -2N-1</source>
          <target state="translated">그러나 모든 C ++ 컴파일러는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;2의 보수&lt;/a&gt; 표현을 사용 하며 C ++ 20부터는 표준에서 허용되는 유일한 표현이며 -2N-1 범위를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="a5298c4b4732ec5cdb50753f0b7bff99ff4504e8" translate="yes" xml:space="preserve">
          <source>However, base class subobjects are not so constrained, and can be completely optimized out from the object layout:</source>
          <target state="translated">그러나 기본 클래스 하위 오브젝트는 그렇게 제한되지 않으며 오브젝트 레이아웃에서 완전히 최적화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0474028c83ae02e6c1719cbd200f19338eb23c2e" translate="yes" xml:space="preserve">
          <source>However, for non-&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;, the number of iterator increments is O(N).</source>
          <target state="translated">그러나 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt; 가 아닌 경우 반복기 증분 수는 O (N)입니다.</target>
        </trans-unit>
        <trans-unit id="a7074ce423985ae2c548c5817d3af2b722ab809a" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;BidirIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">그러나 &lt;code&gt;BidirIt&lt;/code&gt; 는 별도로 요건 충족 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator를&lt;/a&gt; 복잡성은 일정하다.</target>
        </trans-unit>
        <trans-unit id="c130fc889986236f01e7bd0a7491d9e506116625" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; then no applications of the predicate are made (size mismatch is detected without looking at any elements).</source>
          <target state="translated">그러나 &lt;code&gt;InputIt1&lt;/code&gt; 및 &lt;code&gt;InputIt2&lt;/code&gt; 가 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 및 &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; 의 요구 사항을 충족시키는 경우 술어를 적용하지 않습니다 (요소를 보지 않고 크기 불일치가 감지 됨).</target>
        </trans-unit>
        <trans-unit id="d4de2084e6a7ba7c4a9702f5d91188f9754f96a6" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">그러나 &lt;code&gt;InputIt&lt;/code&gt; 이 추가로 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 의 요구 사항을 충족시키는 경우 복잡성은 일정합니다.</target>
        </trans-unit>
        <trans-unit id="923af777ec78d98d0a47fdd5e9f0c732405eb150" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; or &lt;code&gt;ForwardIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">그러나 &lt;code&gt;InputIt&lt;/code&gt; 또는 &lt;code&gt;ForwardIt&lt;/code&gt; 이 추가로 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 의 요구 사항을 충족시키는 경우 복잡성은 일정합니다.</target>
        </trans-unit>
        <trans-unit id="789aa7b03048a6d89e55166c2876d111a76287b2" translate="yes" xml:space="preserve">
          <source>However, if deduction succeeds for all parameters that participate in template argument deduction, and all template arguments that aren't deduced are explicitly specified or defaulted, then the remaining function parameters are compared with the corresponding function arguments. For each remaining parameter &lt;code&gt;P&lt;/code&gt; with a type that was non-dependent before substitution of any explicitly-specified template arguments, if the corresponding argument &lt;code&gt;A&lt;/code&gt; cannot be implicitly converted to &lt;code&gt;P&lt;/code&gt;, deduction fails.</source>
          <target state="translated">그러나 템플리트 인수 추론에 참여하는 모든 매개 변수에 대해 추론이 성공하고 추론되지 않은 모든 템플리트 인수가 명시 적으로 지정되거나 기본값 인 경우 나머지 함수 매개 변수는 해당 함수 인수와 비교됩니다. 명시 적으로 지정된 템플리트 인수를 대체하기 전에 종속적이지 않은 유형의 각 나머지 매개 변수 &lt;code&gt;P&lt;/code&gt; 에 대해 해당 인수 &lt;code&gt;A&lt;/code&gt; 를 내재적으로 &lt;code&gt;P&lt;/code&gt; 로 변환 할 수 없으면 공제가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d3ec3f026f2aba3bad033eb828adf9c63839692d" translate="yes" xml:space="preserve">
          <source>However, if the declaration uses &lt;a href=&quot;constexpr&quot;&gt;&lt;code&gt;constexpr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;inline&quot;&gt;&lt;code&gt;inline&lt;/code&gt;&lt;/a&gt;(since C++17) specifier, the member must be declared to have complete type.</source>
          <target state="translated">그러나 선언에서 &lt;a href=&quot;constexpr&quot;&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;inline&quot;&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/a&gt; (C ++ 17 이후) 지정자를 사용하는 경우 멤버는 완전한 유형을 갖도록 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="9217191a146bae3519a7a8c89cf7f10d4b0ff050" translate="yes" xml:space="preserve">
          <source>However, one implementation (libc++) is known to construct the &lt;code&gt;key_type&lt;/code&gt; and &lt;code&gt;mapped_type&lt;/code&gt; objects via two separate allocator &lt;code&gt;construct()&lt;/code&gt; calls, as arguably required by the standards as published, rather than emplacing a &lt;code&gt;value_type&lt;/code&gt; object.</source>
          <target state="translated">그러나 하나의 구현 (libc ++)은 &lt;code&gt;value_type&lt;/code&gt; 객체를 대체하는 것이 아니라 공개 된 표준에 의해 요구 &lt;code&gt;mapped_type&lt;/code&gt; 두 개의 개별 할당 자 &lt;code&gt;construct()&lt;/code&gt; 호출을 통해 &lt;code&gt;key_type&lt;/code&gt; 및 map_type 객체를 구성하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b2db98636723bfe7992740aadfd807719cd51f4" translate="yes" xml:space="preserve">
          <source>However, the attributes that appear after the declarator (in the syntax above), apply to the type of the function, not to the function itself.</source>
          <target state="translated">그러나 선언자 다음에 나타나는 속성 (위 구문에서)은 함수 자체가 아니라 함수 유형에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dff18122d5fc3679e0217a5ccca9f25c585e46ac" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">쌍곡 코사인은 복잡한 평면에서 전체 기능이며 분기 컷이 없습니다. 가상 성분에 대해서는주기가 2&amp;pi;i 인주기입니다.</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">쌍곡선 함수</target>
        </trans-unit>
        <trans-unit id="a05dc25b96449633c73f65c5aa0e18f13e31788b" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">쌍곡 사인은 복잡한 평면에서 전체 기능이며 브랜치 컷이 없습니다. 가상 성분에 대해서는주기가 2&amp;pi;i 인주기입니다.</target>
        </trans-unit>
        <trans-unit id="c6a249eb7c58320fe1bb3e19e6e61f7ae663bb92" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the imaginary component, with period &amp;pi;i, and has poles of the first order along the imaginary line, at coordinates (0, &amp;pi;(1/2 + n)). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">쌍곡 탄젠트는 복잡한 평원에 대한 분석 함수이며 가지 절단이 없습니다. 그것은 &amp;pi;i의 가상 성분에 대하여 주기적이며, 좌표 (0, &amp;pi; (1/2 + n))에서 가상의 선을 따라 1 차 극을 갖는다. 그러나 일반적인 부동 소수점 표현은 &amp;pi; / 2를 정확하게 표현할 수 없으므로 극 오차가 발생하는 인수의 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="6b58ece8e2eb85355e743b6e1a72cb6eb0c30006" translate="yes" xml:space="preserve">
          <source>I/O Manipulators</source>
          <target state="translated">I / O 조작기</target>
        </trans-unit>
        <trans-unit id="0676b814ab2a9d403059287e94b18b3f3ed5e63c" translate="yes" xml:space="preserve">
          <source>I/O error</source>
          <target state="translated">입출력 오류</target>
        </trans-unit>
        <trans-unit id="3fd6cee6dbc10d47db1d5e293da18cd3279cfd34" translate="yes" xml:space="preserve">
          <source>I/O format flags are obtained, as if by</source>
          <target state="translated">다음과 같이 I / O 형식 플래그를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="00a1147221fe28724b5d852d3cc11debd18ea881" translate="yes" xml:space="preserve">
          <source>IBM XL C/C++ Inline Assembly</source>
          <target state="translated">IBM XL C / C ++ 인라인 어셈블리</target>
        </trans-unit>
        <trans-unit id="97e6907b70a51197746c7a59244053494e95092c" translate="yes" xml:space="preserve">
          <source>ICE</source>
          <target state="translated">ICE</target>
        </trans-unit>
        <trans-unit id="2eb6372a578be72d248c4e343e8fc7a5d78b9a77" translate="yes" xml:space="preserve">
          <source>IEC 60559 recommends that &lt;code&gt;from&lt;/code&gt; is returned whenever &lt;code&gt;from==to&lt;/code&gt;. These functions return &lt;code&gt;to&lt;/code&gt; instead, which makes the behavior around zero consistent: &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; returns &lt;code&gt;+0.0&lt;/code&gt; and &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; returns &lt;code&gt;&amp;ndash;0.0&lt;/code&gt;.</source>
          <target state="translated">IEC 60559는 것이 좋습니다 &lt;code&gt;from&lt;/code&gt; 때마다 반환 &lt;code&gt;from==to&lt;/code&gt; . 이러한 함수 &lt;code&gt;to&lt;/code&gt; 대신 0으로 돌아가 동작을 일관되게 만듭니다. &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; 은 &lt;code&gt;+0.0&lt;/code&gt; 을 반환 하고 &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; 은 &lt;code&gt;&amp;ndash;0.0&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7d95a8939f16c4020223847e17e36720cebf2bb9" translate="yes" xml:space="preserve">
          <source>IEEE-754</source>
          <target state="translated">IEEE-754</target>
        </trans-unit>
        <trans-unit id="42d5d0fd7522f477e6c48c8cc234d0d9ab04dea9" translate="yes" xml:space="preserve">
          <source>ILP32</source>
          <target state="translated">ILP32</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="0c47ba7d876463299943e6f3c404bf80428ff851" translate="yes" xml:space="preserve">
          <source>INT8_CINT16_CINT32_CINT64_C</source>
          <target state="translated">INT8_CINT16_CINT32_CINT64_C</target>
        </trans-unit>
        <trans-unit id="9ea288f9428eb0424cc8044a5b63c8eac0420d9a" translate="yes" xml:space="preserve">
          <source>INT8_MAXINT16_MAXINT32_MAXINT64_MAX</source>
          <target state="translated">INT8_MAXINT16_MAXINT32_MAXINT64_MAX</target>
        </trans-unit>
        <trans-unit id="bc5a628cd596773389eaaf98a83bf94ceac150f9" translate="yes" xml:space="preserve">
          <source>INT8_MININT16_MININT32_MININT64_MIN</source>
          <target state="translated">INT8_MININT16_MININT32_MININT64_MIN</target>
        </trans-unit>
        <trans-unit id="f9102afc9b1d8d90bfec23471f9597ad0cf050e9" translate="yes" xml:space="preserve">
          <source>INTMAX_C</source>
          <target state="translated">INTMAX_C</target>
        </trans-unit>
        <trans-unit id="aefed58e7c3b20f7462bf747350723518bd7f3f5" translate="yes" xml:space="preserve">
          <source>INTMAX_MAX</source>
          <target state="translated">INTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="a349d125102eeb5388d505c737ca6ccb840fc470" translate="yes" xml:space="preserve">
          <source>INTMAX_MIN</source>
          <target state="translated">INTMAX_MIN</target>
        </trans-unit>
        <trans-unit id="a8b82d9c693483b9795a47d286279f7fe077830a" translate="yes" xml:space="preserve">
          <source>INTPTR_MAX</source>
          <target state="translated">INTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="ea1e73a8ba1358e9d441c380ac5a64aadd6313f9" translate="yes" xml:space="preserve">
          <source>INTPTR_MIN</source>
          <target state="translated">INTPTR_MIN</target>
        </trans-unit>
        <trans-unit id="cb3002d9d4b8d1bb4ad6b3fb3f8ee0eb1cd9e1b9" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</source>
          <target state="translated">INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="5c002bd42be6d97da6ee9fd6a8de846f49b7760c" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</source>
          <target state="translated">INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</target>
        </trans-unit>
        <trans-unit id="81b4c2799073b036b71feb59eff38c668d0be8e4" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</source>
          <target state="translated">INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="303ab3b780f2f436597e803172a659d338cb695a" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</source>
          <target state="translated">INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</target>
        </trans-unit>
        <trans-unit id="47a57f6b8f5e7dac870d669f2d10489423c2c097" translate="yes" xml:space="preserve">
          <source>INVERTED UNDERTIE</source>
          <target state="translated">거꾸로 한 UNDERTIE</target>
        </trans-unit>
        <trans-unit id="6f332e7bc9fb4c964cc115b4bb4e0c9c81b651a9" translate="yes" xml:space="preserve">
          <source>INVOKE</source>
          <target state="translated">INVOKE</target>
        </trans-unit>
        <trans-unit id="bfa0e3fd8d2d6bf8a03a66ca3906291682906b88" translate="yes" xml:space="preserve">
          <source>INVOKE&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)</source>
          <target state="translated">인보 크 (f, t1, t2, ..., tN)</target>
        </trans-unit>
        <trans-unit id="381dd7d678830c863bcf610275aa82caf553b63a" translate="yes" xml:space="preserve">
          <source>INVOKE(f, t1, t2, ..., tN)</source>
          <target state="translated">인보 케 (f, t1, t2, ..., tN)</target>
        </trans-unit>
        <trans-unit id="b7d04a533ba2785a0158159ad98ad6ef6b754b06" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX control characters as Unicode characters U+0000..U+001F, U+007F..U+009F, U+2028, and U+2029 (Unicode classes Cc, Zl, and Zp).</source>
          <target state="translated">ISO 30112는 POSIX 제어 문자를 유니 코드 문자 U + 0000..U + 001F, U + 007F..U + 009F, U + 2028 및 U + 2029 (유니 코드 클래스 Cc, Zl 및 Zp)로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="fff375c325eb5a33dd2e39fc8434af17d533adb3" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX space characters as Unicode characters U+0009..U+000D, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+2028, U+2029, U+205F, and U+3000.</source>
          <target state="translated">ISO 30112는 POSIX 공백 문자를 유니 코드 문자 U + 0009..U + 000D, U + 0020, U + 1680, U + 180E, U + 2000..U + 2006, U + 2008..U + 200A, U +로 정의합니다. 2028, U + 2029, U + 205F 및 U + 3000.</target>
        </trans-unit>
        <trans-unit id="83c8d536c17446dc8d23f11cf08547ab6f0ceaef" translate="yes" xml:space="preserve">
          <source>ISO 8601 week-based year</source>
          <target state="translated">ISO 8601 주별 연도</target>
        </trans-unit>
        <trans-unit id="660c1f28ee4e6a1155a4515d1d3d38f625034fe8" translate="yes" xml:space="preserve">
          <source>ISO C language standard requires that C compilers support the following three pragmas, and some C++ compiler vendors support them, to varying degrees, in their C++ frontends:</source>
          <target state="translated">ISO C 언어 표준을 사용하려면 C 컴파일러가 다음 세 가지 pragma를 지원해야하며 일부 C ++ 컴파일러 공급 업체는 C ++ 프론트 엔드에서 다양한 정도를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f0de3ffcac31393cdc320a257a71c6856ecd9b41" translate="yes" xml:space="preserve">
          <source>Identical to the complexity of &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Container::emplace_back&lt;/code&gt; 의 복잡성과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="7c1a745105ff9b6c357cf50bdd91090ffef6ae55" translate="yes" xml:space="preserve">
          <source>Identifier removed</source>
          <target state="translated">식별자 제거</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="8967e7083aa7ece41be13822051695a635bff07e" translate="yes" xml:space="preserve">
          <source>If &amp;nu;&amp;gt;=128, the behavior is implementation-defined</source>
          <target state="translated">&amp;nu;&amp;gt; = 128 인 경우 동작은 구현에 따라 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c861ca152a1a5790f61fc9a7ad6bc1a92ae258c8" translate="yes" xml:space="preserve">
          <source>If (and only if) reallocation takes place, all pointers, references, and iterators are invalidated.</source>
          <target state="translated">재 할당이 발생하면 모든 포인터, 참조 및 반복자가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="98c199ab16ab809f486bbb3423d179f029c19b26" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is supported and set to &lt;code&gt;ON&lt;/code&gt;, all floating-point arithmetic operators obey the current floating-point &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; and report floating-point arithmetic errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt; unless part of a &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;static initializer&lt;/a&gt; (in which case floating-point exceptions are not raised and the rounding mode is to nearest).</source>
          <target state="translated">경우 &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt; 지원하도록 설정되어 &lt;code&gt;ON&lt;/code&gt; , 모든 부동 소수점 연산기는 현재 부동 소수점 순종 &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;방향 라운딩&lt;/a&gt; 에 지정된 리포트 부동 소수점 산술 오류 &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt; &lt;code&gt;math_errhandling&lt;/code&gt; &lt;/a&gt; (A)의 일부를 제외하고 &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;초기화 정적&lt;/a&gt; (이 경우, 부동 소수점 예외는 발생하지 않으며 반올림 모드는 가장 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="7bb02eee6cd1dc516434df27056595be6a6b00a7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; of an object of class type requires that a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; is called to convert the initializer expression of type cv &lt;code&gt;S&lt;/code&gt; to the type cv &lt;code&gt;T&lt;/code&gt; of the object being initialized, the following functions are candidate functions:</source>
          <target state="translated">경우 &lt;a href=&quot;copy_initialization&quot;&gt;복사 초기화&lt;/a&gt; 클래스 형의 객체가 있어야 &lt;a href=&quot;cast_operator&quot;&gt;사용자 정의 변환 기능&lt;/a&gt; 형 이력서의 이니셜 표현으로 변환하기 위해 호출되는 &lt;code&gt;S&lt;/code&gt; 를 유형의 이력서에 &lt;code&gt;T&lt;/code&gt; 초기화되는 객체의 다음과 같은 기능이 후보 함수입니다 :</target>
        </trans-unit>
        <trans-unit id="cc788d4e3b334778f8f385fbf8f9f00b88dbcecf" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; is used to exit a try-block and if any of the destructors of block-scoped automatic variables that are executed by the &lt;code&gt;goto&lt;/code&gt; throw exceptions, those exceptions are caught by the try blocks in which the variables are defined:</source>
          <target state="translated">경우 &lt;a href=&quot;goto&quot;&gt;고토가&lt;/a&gt; 시도 블록을 종료하는 데 사용되는에 의해 실행되는 블록 범위의 자동 변수의 소멸자의 경우 &lt;code&gt;goto&lt;/code&gt; 던져 예외가 그 예외가 변수가 정의되는 시도 블록에 걸려 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ad02ee6de1557c2cab77c2034cb247d4122fb981" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt; is true, does nothing. Otherwise, destroys the currently contained value.</source>
          <target state="translated">경우 &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception는&lt;/a&gt; 사실, 아무것도하지 않습니다. 그렇지 않으면 현재 포함 된 값을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="22e67fa78b1a05182b627ae99ffd3c2b45940a22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!m.ok()&lt;/code&gt;, equivalent to &lt;code&gt;os &amp;lt;&amp;lt; unsigned(m) &amp;lt;&amp;lt; &quot; is not a valid month&quot;;&lt;/code&gt;. Otherwise, forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the abbreviated month name for the month represented by &lt;code&gt;m&lt;/code&gt;, determined using the locale associated with &lt;code&gt;os&lt;/code&gt;, and inserts &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!m.ok()&lt;/code&gt; 인 경우 &lt;code&gt;os &amp;lt;&amp;lt; unsigned(m) &amp;lt;&amp;lt; &quot; is not a valid month&quot;;&lt;/code&gt; 와 동일한 월은 유효한 월이 아닙니다&quot;; . 그렇지 않으면 형성 &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 의 나타내는 월에 대한 축약 월 이름 이루어지는 &lt;code&gt;m&lt;/code&gt; 과 관련하여 결정 로케일 &lt;code&gt;os&lt;/code&gt; 및 인서트 &lt;code&gt;s&lt;/code&gt; 에 &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1a70707db6a348980443d56c9ab0c52464c252f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%g&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;!uppercase&lt;/code&gt; , 지정 변환을 사용합니다 &lt;code&gt;%g&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f6dfc884c101654edafd48a800532bba66066cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!wd.ok()&lt;/code&gt;, equivalent to &lt;code&gt;os &amp;lt;&amp;lt; unsigned(wd) &amp;lt;&amp;lt; &quot; is not a valid weekday&quot;;&lt;/code&gt;. Otherwise, forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the abbreviated weekday name for the weekday represented by &lt;code&gt;wd&lt;/code&gt;, determined using the locale associated with &lt;code&gt;os&lt;/code&gt;, and inserts &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!wd.ok()&lt;/code&gt; 인 경우 &lt;code&gt;os &amp;lt;&amp;lt; unsigned(wd) &amp;lt;&amp;lt; &quot; is not a valid weekday&quot;;&lt;/code&gt; 와 동일 하며 유효한 요일이 아닙니다&quot;; . 그렇지 않으면 형성 &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 의 요일에 의해 표현 약칭 요일 이름 이루어진 &lt;code&gt;wd&lt;/code&gt; 와 관련하여 결정 로케일 &lt;code&gt;os&lt;/code&gt; 및 인서트 &lt;code&gt;s&lt;/code&gt; 에 &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc136d5ecc5ffd29fb88143ae3ce7ad3bfccb312" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;Types&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the destructor of &lt;code&gt;tuple&lt;/code&gt; is trivial.</source>
          <target state="translated">만약 &lt;code&gt;(&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;Types&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 의 소멸자 &lt;code&gt;tuple&lt;/code&gt; 간단하다.</target>
        </trans-unit>
        <trans-unit id="da8cff62887e613aba67b865a9e6d73a9a0208c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(os.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;) &amp;amp;&amp;amp; !&lt;a href=&quot;../../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;() &amp;amp;&amp;amp; os.good())&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, calls &lt;code&gt;os.rdbuf()-&amp;gt;pubsync()&lt;/code&gt;. If that function returns &lt;code&gt;-1&lt;/code&gt;, sets &lt;code&gt;badbit&lt;/code&gt; in &lt;code&gt;os.rdstate()&lt;/code&gt; without propagating an exception.</source>
          <target state="translated">만약 &lt;code&gt;(os.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;) &amp;amp;&amp;amp; !&lt;a href=&quot;../../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;() &amp;amp;&amp;amp; os.good())&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이면 &lt;code&gt;os.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; 호출합니다 . 그 함수가 리턴하는 경우 &lt;code&gt;-1&lt;/code&gt; , 세트 &lt;code&gt;badbit&lt;/code&gt; 에 &lt;code&gt;os.rdstate()&lt;/code&gt; 예외없이 전파.</target>
        </trans-unit>
        <trans-unit id="cd5e11e3cc0c402b0e9be870090813113d4c62f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(unsigned char)c &amp;gt;= &lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt;, then an implementation-defined value is substituted instead of &lt;code&gt;table()[(unsigned char)c]&lt;/code&gt;, possibly different for different values of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;(unsigned char)c &amp;gt;= &lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; 다음 구현 정의 된 값 대신에 치환 &lt;code&gt;table()[(unsigned char)c]&lt;/code&gt; 의 서로 다른 값에 대한 가능성이 다른 &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92961dd363bdfb6c745602ae238d61a26e00ce3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; refer to the same object, then &lt;code&gt;a&lt;/code&gt; == &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;*a&lt;/code&gt; 및 &lt;code&gt;*b&lt;/code&gt; 동일한 객체, 다음을 참조 ==의 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d8fc3988020f52aa4cd322d347c93e64ecb80c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; already owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, and &lt;code&gt;r&lt;/code&gt; is not the same as &lt;code&gt;*this&lt;/code&gt;, the object is destroyed through the owned deleter.</source>
          <target state="translated">경우 &lt;code&gt;*this&lt;/code&gt; 이미 객체를 소유하고는 마지막 &lt;code&gt;shared_ptr&lt;/code&gt; 의 를 소유하고, &lt;code&gt;r&lt;/code&gt; 동일하지 않습니다 &lt;code&gt;*this&lt;/code&gt; 개체가 소유 Deleter가 통해 파괴된다.</target>
        </trans-unit>
        <trans-unit id="d91b74584f1eaef50da01b154cf35ae1c060bd65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; already owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, the object is destroyed through the owned deleter.</source>
          <target state="translated">경우 &lt;code&gt;*this&lt;/code&gt; 이미 객체를 소유하고는 마지막 &lt;code&gt;shared_ptr&lt;/code&gt; 의 그것을 소유 개체가 소유 Deleter가 통해 파괴된다.</target>
        </trans-unit>
        <trans-unit id="9547dd884045b3da73d2308453755944edbbda07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; both have dynamic type &lt;code&gt;std::exception&lt;/code&gt; then &lt;code&gt;&lt;a href=&quot;../../string/byte/strcmp&quot;&gt;std::strcmp&lt;/a&gt;(what(), other.what()) == 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 둘 다 동적 유형 &lt;code&gt;std::exception&lt;/code&gt; 을 가지고 있다면 &lt;code&gt;&lt;a href=&quot;../../string/byte/strcmp&quot;&gt;std::strcmp&lt;/a&gt;(what(), other.what()) == 0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9d03bcb4418c0282af6a72fecf7a440fdb5debe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, but &lt;code&gt;other&lt;/code&gt; does not, then the contained value is destroyed by calling its destructor. &lt;code&gt;*this&lt;/code&gt; does not contain a value after the call.</source>
          <target state="translated">만약 &lt;code&gt;*this&lt;/code&gt; 값을 포함하고 있지만, &lt;code&gt;other&lt;/code&gt; , 다음 포함 된 값이 소멸자를 호출하여 파괴하지 않습니다. &lt;code&gt;*this&lt;/code&gt; 통화 후 값 이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7a277ddff2e8e400ab7cc6265a8854405fc6aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, destroy that value as if by &lt;code&gt;value().T::~T()&lt;/code&gt;. Otherwise, there are no effects.</source>
          <target state="translated">경우 &lt;code&gt;*this&lt;/code&gt; 값을 포함하고, 그 가치를 파괴했을 경우와 같은 &lt;code&gt;value().T::~T()&lt;/code&gt; . 그렇지 않으면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f2f61fd72ae5e884e1a574bf73169287b72c489" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, returns a reference to the contained value.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 값 이 있으면 포함 된 값에 대한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c59d16b11cfaa885be1c6ecd9266546a41ca8652" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; has an associated mutex ((&lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; returns a non-null pointer) and has acquired ownership of it (&lt;code&gt;owns()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;), the mutex is unlocked by calling &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;*this&lt;/code&gt; 연관된 뮤텍스 ((가 &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; 널이 아닌 포인터를 반환)과 (의 소유권을 인수했다 &lt;code&gt;owns()&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; ), 뮤텍스는 호출하여 잠금 해제 &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0082e088403160e49ff73354c8b162b48a36a42a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; has an associated thread (&lt;code&gt;joinable() == true&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 연관된 스레드가있는 경우 ( &lt;code&gt;joinable() == true&lt;/code&gt; ) &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9144affce378c4381a07accbbe9c5b400c516453" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; is a suffix iterator, sets &lt;code&gt;*this&lt;/code&gt; to an end-of-sequence iterator.</source>
          <target state="translated">하면 &lt;code&gt;*this&lt;/code&gt; 첨자 반복기이다 세트 &lt;code&gt;*this&lt;/code&gt; 최종의 시퀀스 반복기.</target>
        </trans-unit>
        <trans-unit id="d1c58d5d72435da6477abb6fcff62548ec0974a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; is the last object referring to the shared state, destroys the shared state. Otherwise does nothing.</source>
          <target state="translated">경우 &lt;code&gt;*this&lt;/code&gt; 공유 상태를 참조 마지막 객체가 공유 상태를 파괴한다. 그렇지 않으면 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43f3508ad52f8c72c8bffdd8e6f95fe0b279e431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, the object is destroyed through the owned deleter.</source>
          <target state="translated">경우 &lt;code&gt;*this&lt;/code&gt; 객체를 소유하고는 마지막 &lt;code&gt;shared_ptr&lt;/code&gt; 의 그것을 소유 개체가 소유 Deleter가 통해 파괴된다.</target>
        </trans-unit>
        <trans-unit id="0047e92ce8b32348ae1bf76f7759ee5ab1deddb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; still has an associated running thread (i.e. &lt;code&gt;joinable() == true&lt;/code&gt;), call &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt;. Otherwise, assigns the state of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt; and sets &lt;code&gt;other&lt;/code&gt; to a default constructed state.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 여전히 실행중인 스레드가있는 경우 (즉, &lt;code&gt;joinable() == true&lt;/code&gt; ) &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; 호출하십시오 . 그렇지 않으면 &lt;code&gt;other&lt;/code&gt; 의 상태 를 &lt;code&gt;*this&lt;/code&gt; 에 지정 하고 &lt;code&gt;other&lt;/code&gt; 를 기본 생성 상태로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1c3de47b3604829aa8d6c1f140e9684e3f5dc92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--a == --b&lt;/code&gt; then &lt;code&gt;a == b&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;--a == --b&lt;/code&gt; 다음 &lt;code&gt;a == b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90fa435f3b59c79cbaeb4963bb4835737f7d7a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;::&lt;/code&gt; is followed by the character &lt;code&gt;~&lt;/code&gt; that is in turn followed by an identifier (that is, it specifies a destructor or pseudo-destructor), that identifier is looked up in the same scope as the name on the left hand side of &lt;code&gt;::&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;::&lt;/code&gt; 문자 뒤에 &lt;code&gt;~&lt;/code&gt; 차례에 식별자가 왼쪽의 이름과 같은 범위에서 룩업된다 (즉, 그것이 소멸 또는 의사 소멸자 지정) 식별자 하였다 &lt;code&gt;::&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2a97dc8c387c983d7ce89c28639a1a4934e5f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/always_noconv&quot;&gt;std::codecvt::always_noconv&lt;/a&gt;&lt;/code&gt; is true, the call to &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; may be skipped.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/always_noconv&quot;&gt;std::codecvt::always_noconv&lt;/a&gt;&lt;/code&gt; 사실, 호출하는 &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="383dd33e0c7222077e9f39a66a18786b4b4abb6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then the allocator is unchanged. Otherwise, after move-assignment, &lt;code&gt;get_allocator()&lt;/code&gt; equals &lt;code&gt;other.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; 된다 &lt;code&gt;false&lt;/code&gt; , 다음 할당이 변경되지 않는다. 그렇지 않으면 이동 할당 후 &lt;code&gt;get_allocator()&lt;/code&gt; &lt;code&gt;other.get_allocator()&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="effa1c8a8ecca962a3e2c90eb4b0b4cd886ee427" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; is true, then the allocators are exchanged using an unqualified call to non-member &lt;code&gt;swap&lt;/code&gt;. Otherwise, they are not swapped (and if &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;, the behavior is undefined).</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; 후 할당 자 이외의 부재로 사용되지 않은 호출에 해당 교환되는 &lt;code&gt;swap&lt;/code&gt; . 그렇지 않으면, 그것들은 교환되지 않습니다 (그리고 &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; 이면 동작은 정의되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="895e0eca3c2f91f7c107010968f8c4eae623b669" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is 2 (or a power of 2), the returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; 는 2 (또는 2의 거듭 제곱)이며, 반환 값은 정확 &lt;a href=&quot;../fenv/fe_round&quot;&gt;현재 반올림 모드는&lt;/a&gt; 무시됩니다</target>
        </trans-unit>
        <trans-unit id="1790032c97cf911e15ed06b1a6725dd974239d4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;SIZE_MAX&lt;/a&gt; / sizeof(U) &amp;lt; n&lt;/code&gt;, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt;, otherwise equivalent to &lt;code&gt;return static_cast&amp;lt;U*&amp;gt;(allocate_bytes(n * sizeof(U), alignof(U)) );&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;SIZE_MAX&lt;/a&gt; / sizeof(U) &amp;lt; n&lt;/code&gt; 슬로우 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; 달리 당량 &lt;code&gt;return static_cast&amp;lt;U*&amp;gt;(allocate_bytes(n * sizeof(U), alignof(U)) );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d5ebe4fc1a8abdaf844d29a3d314c89acaad005a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.get().*f&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; 의 특수화 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; 동등 &lt;code&gt;t1.get().*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="982ec353c22eb69baf317b330efaf0a7a5e7cce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; 의 특수화 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; 다음 &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; 상당하는 &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="975228dc0d0d9d407e294a92674384d84c5af876" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.*f&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; 다음 &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; 동등 &lt;code&gt;t1.*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebb6d3a6dda70443130e44d3d8eef15c8850d72d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; 다음 &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; 와 동등하다 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46e80aaa2cfeed3cb98adbf86549699888d28e48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then this destructor is a trivial destructor.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; ,이 소멸자 사소한 소멸자이다.</target>
        </trans-unit>
        <trans-unit id="50c9fd79a84089afcea1735d81a6458257a8ebf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is not the appropriate buffer size, &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; can be used to change it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; 가 적절한 버퍼 크기가 아닌 경우 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; 를 사용하여이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ea3c7ca7ae345831d1c696b26e5dd6650ec9617" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; has lower precision, it is implementation-defined whether the value is rounded or truncated.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; 낮은 정밀도를 가지고, 상기 값은 반올림 또는 절단 여부 구현 정의된다.</target>
        </trans-unit>
        <trans-unit id="4b20a41ac6a8f6f3b703c2287f3854ec31392c44" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../concepts/derivedfrom&quot;&gt;DerivedFrom&lt;/a&gt;&amp;lt;T, view_base&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../concepts/derivedfrom&quot;&gt;DerivedFrom&lt;/a&gt;&amp;lt;T, view_base&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; 것입니다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3253a1bdeb3cf6df583da218fc710e43b8aa013f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;which&lt;/code&gt;, attempts to reposition &lt;code&gt;gptr()&lt;/code&gt; (the next pointer in the get area). If &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;which&lt;/code&gt;, attempts to reposition &lt;code&gt;pptr()&lt;/code&gt; (the next pointer in the put area). If neither bit is set in &lt;code&gt;which&lt;/code&gt;, the operation fails.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; 설정되어 &lt;code&gt;which&lt;/code&gt; 위치 변경에, 시도 &lt;code&gt;gptr()&lt;/code&gt; (가져 오기 영역에서 다음 포인터). 경우 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; 에 설정되어 &lt;code&gt;which&lt;/code&gt; 위치 변경에, 시도 &lt;code&gt;pptr()&lt;/code&gt; (풋 지역의 다음 포인터). &lt;code&gt;which&lt;/code&gt; 에 비트가 설정되어 있지 않으면 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1cfad288bd7fbccd70e8241c69a8d092c6bd2656" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; or a similar allocator is used, a class does not have to implement a &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructor&lt;/a&gt; to satisfy this type requirement: a &lt;a href=&quot;../language/copy_constructor&quot;&gt;copy constructor&lt;/a&gt; that takes a &lt;code&gt;const T&amp;amp;&lt;/code&gt; argument can bind rvalue expressions. If a MoveInsertable class implements a move constructor, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after construction is unspecified.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 또는 유사한 할당 사용하는 클래스는 구현하지 않는 &lt;a href=&quot;../language/move_constructor&quot;&gt;이동 생성자&lt;/a&gt; A :이 유형의 요구 사항을 만족하는 &lt;a href=&quot;../language/copy_constructor&quot;&gt;복사 생성자&lt;/a&gt; 소요 &lt;code&gt;const T&amp;amp;&lt;/code&gt; 인수를 rvalue 표현식을 결합 할 수 있습니다. MoveInsertable 클래스가 이동 생성자를 구현하는 경우 생성 후 &lt;code&gt;rv&lt;/code&gt; 값 이 지정되지 않았다는 사실을 이용하기 위해 &lt;a href=&quot;../utility/move&quot;&gt;이동 의미&lt;/a&gt; 를 구현할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e00f15acad4e10cd2ecd0299fd4d8b97a99bb7d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; is a non-final non-union class type that is neither &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; nor derived from &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt;, throws an exception of an unspecified type that is publicly derived from both &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; and from &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt;, and constructed from &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt;. The default constructor of the &lt;code&gt;nested_exception&lt;/code&gt; base class calls &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;, capturing the currently handled exception object, if any, in a &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; 도 아닌 비 최종 비 노조 클래스 유형 &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; 도에서 파생 된 &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; , 공개적에서 파생 지정되지 않은 유형의 예외가 발생 &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt; 됩니다. 의 기본 생성자 &lt;code&gt;nested_exception&lt;/code&gt; 의 기본 클래스 호출 &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; 하는에있는 경우, 현재 처리 된 예외 객체를 캡처 &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ce6265115b5fdfcaa76a7165b74faf9d8dacb2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.*f&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; 다음 &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; 동등 &lt;code&gt;t1.*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f34e8cfb2a1707ab37515e5a9bdd7f9c647abe3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; 다음 &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; 와 동등하다 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bcb63cc68623b4a13fa5b83d65086795b276b60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T1&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T2&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the destructor of &lt;code&gt;pair&lt;/code&gt; is trivial.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T1&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T2&amp;gt;&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; 의 소멸자 &lt;code&gt;pair&lt;/code&gt; 간단하다.</target>
        </trans-unit>
        <trans-unit id="e1f522d5a7a2b7024a237d287703f33d30c5ccd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Y, D&amp;gt;::pointer&lt;/code&gt; is a pointer to a character type (e.g., when &lt;code&gt;Y&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;CharT&lt;/code&gt;), this may end up calling the &lt;a href=&quot;../../io/basic_ostream/operator_ltlt2&quot;&gt;overloads of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for null-terminated character strings&lt;/a&gt; (causing undefined behavior if the pointer does not in fact point to such a string), rather than &lt;a href=&quot;../../io/basic_ostream/operator_ltlt&quot;&gt;the overload for printing the value of the pointer itself&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Y, D&amp;gt;::pointer&lt;/code&gt; (경우에 예를 들면, 캐릭터 타입을 가리키는 포인터이고 &lt;code&gt;Y&lt;/code&gt; 가 인 &lt;code&gt;char&lt;/code&gt; 또는 &lt;code&gt;char[]&lt;/code&gt; 또는 &lt;code&gt;CharT&lt;/code&gt; )이 호출 끝낼 수 &lt;a href=&quot;../../io/basic_ostream/operator_ltlt2&quot;&gt;의 과부하 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 널 종료를 들어 문자열&lt;/a&gt; (포인터가 같은 문자열에 사실 지점에서하지 않는 경우 정의되지 않은 동작을 일으키는)보다는 &lt;a href=&quot;../../io/basic_ostream/operator_ltlt&quot;&gt;포인터 자체의 값을 인쇄 과부하&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f98e0f7ef82d28588de46aaf4b7958b9880eea5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the pointer is a non-null pointer that should not be dereferenced.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , 포인터가 역 참조해서는 안 널이 아닌 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="7608858d123991a3d0370b23e31edd9570a303db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the pointer points to a single null character.</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; , 하나의 널 (null) 문자에 대한 포인터를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="5881678af232e47a5ff281e340e3ff360633c7fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; has been never called for this object, then the global locale at the time of the call is returned. Otherwise, the locale passed to the last call to &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">이 객체에 대해 &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; 를 호출 한 적이 없으면 호출시 전역 로캘이 반환됩니다. 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; 에 대한 마지막 호출로 전달 된 로케일 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8a3196e43b35b6c3a7ee5a0b4c3620496db3d617" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; is a null pointer (i.e. there is no associated stream buffer), then &lt;code&gt;state | badbit&lt;/code&gt; is assigned. May throw an exception.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; 널 포인터 (즉, 어떤이 관련되어 스트림 버퍼)이며, 다음 &lt;code&gt;state | badbit&lt;/code&gt; 가 할당됩니다. 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="115f73826b05df3cd915bd8b19cd251d9d51edc4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic ostrstream and &lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 동적의 ostrstream 및 호출 된 &lt;a href=&quot;freeze&quot;&gt;동결 (false)를&lt;/a&gt; 그 다음에 호출되지 않은,이 소멸자 메모리 누수.</target>
        </trans-unit>
        <trans-unit id="bbdbfef825b7d3601eff06aaad9cae9874a72eb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic strstream and &lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 동적의 strstream 및 호출 된 &lt;a href=&quot;freeze&quot;&gt;동결 (false)를&lt;/a&gt; 그 다음에 호출되지 않은,이 소멸자 메모리 누수.</target>
        </trans-unit>
        <trans-unit id="478414339a40be92fc6757b885d21490b9c2c06c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic strstream and &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt;&lt;/code&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 동적의 strstream 및 호출 된 &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt;&lt;/code&gt; 그 다음에 호출되지 않은,이 소멸자 메모리 누수.</target>
        </trans-unit>
        <trans-unit id="28514525eb04de0df8ae0bd7f4815fcf5c0b385a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;T, Alloc&amp;gt;&lt;/code&gt; is false and &lt;code&gt;&lt;a href=&quot;../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args...&amp;gt;&lt;/code&gt; is true, returns &lt;code&gt;&lt;a href=&quot;../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;T, Alloc&amp;gt;&lt;/code&gt; 거짓과 &lt;code&gt;&lt;a href=&quot;../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args...&amp;gt;&lt;/code&gt; 사실, 반환 &lt;code&gt;&lt;a href=&quot;../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1eaf847410a4fe8abec9f71211445a94385c0d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_copy_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; must satisfy &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and the copy operation must not throw exceptions</source>
          <target state="translated">경우 &lt;code&gt;A::propagate_on_container_copy_assignment::value&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 다음 &lt;code&gt;A&lt;/code&gt; 는 만족해야 &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 및 복사 작업은 예외가 발생하지 않아야합니다</target>
        </trans-unit>
        <trans-unit id="53014a7b4b50d8ae84406194de8be90fc34e0d34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; must satisfy &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and the move operation must not throw exceptions.</source>
          <target state="translated">경우 &lt;code&gt;A::propagate_on_container_move_assignment::value&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 다음 &lt;code&gt;A&lt;/code&gt; 는 만족해야 &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable을&lt;/a&gt; 하고 이동 작업은 예외가 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="39a1f82ebac72503acedbfb5e0cc69d3fea6e2da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_swap::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lvalues of &lt;code&gt;A&lt;/code&gt; must be &lt;a href=&quot;swappable&quot;&gt;Swappable&lt;/a&gt; and the swap operation must not throw exceptions</source>
          <target state="translated">경우 &lt;code&gt;A::propagate_on_container_swap::value&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 의 lvalues &lt;code&gt;A&lt;/code&gt; 는 해야 &lt;a href=&quot;swappable&quot;&gt;스왑&lt;/a&gt; 과 스왑 작업은 예외가 발생하지 않아야합니다</target>
        </trans-unit>
        <trans-unit id="930ae60370eac3920b61ed4930312cdb72190d0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, then this will call placement-new, as by &lt;code&gt;::new((void*)p) T(rv)&lt;/code&gt;. This effectively requires &lt;code&gt;T&lt;/code&gt; to be move constructible.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 이고 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; ,이 호출은 새로운 배치에 의해 같은 &lt;code&gt;::new((void*)p) T(rv)&lt;/code&gt; . 이를 위해서는 &lt;code&gt;T&lt;/code&gt; 가 구성 가능하게 움직여야합니다.</target>
        </trans-unit>
        <trans-unit id="a6edb79bda8a280ffb6fcbbc9ba3defcf2428641" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, then this will call placement-new, as by &lt;code&gt;::new((void*)p) T(v)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 이고 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; ,이 호출은 새로운 배치에 의해로서 &lt;code&gt;::new((void*)p) T(v)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb858ecd848dc52275e556ff876a7f61bbd34174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a reference type, it is replaced by the type referred to</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 가 참조 형식이며, 이는 언급 된 형태로 대체</target>
        </trans-unit>
        <trans-unit id="b3c213b81227b94ede964107b48a991995b38510" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is cv-qualified, &lt;code&gt;A&lt;/code&gt; is replaced with cv-unqualified version of itself</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 이력서 - 자격, &lt;code&gt;A&lt;/code&gt; 는 자신의 이력서 - 비정규 버전으로 바뀝니다</target>
        </trans-unit>
        <trans-unit id="5d95d66680ab1fe42693574faecc757445aabf8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is cv-qualified, the top-level cv-qualifiers are ignored. If &lt;code&gt;A&lt;/code&gt; is a reference type, the referred type is used by deduction.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 이력서 - 자격 최상위 이력서 - 예선은 무시됩니다. 경우 &lt;code&gt;A&lt;/code&gt; 가 참조 형식 인 상기 언급 된 유형의 추론에 의해 사용된다.</target>
        </trans-unit>
        <trans-unit id="dbb888d618ec657b4fdce4930acdf4d77c7df288" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; was lvalue reference and &lt;code&gt;P&lt;/code&gt; was rvalue reference, A is considered to be more specialized than P</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 좌변 참조이고 &lt;code&gt;P&lt;/code&gt; 가 를 rvalue 참조했다, (A)는 더 P보다 전문 것으로 간주됩니다</target>
        </trans-unit>
        <trans-unit id="a0457548dadf8dfad5e452b8705d672e063c513a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; was more cv-qualified than &lt;code&gt;P&lt;/code&gt;, A is considered to be more specialized than P</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;P&lt;/code&gt; 보다 cv 한정된 경우 A 는 P 보다 전문화 된 것으로 간주됩니다</target>
        </trans-unit>
        <trans-unit id="164bc5f2461c5b557de9ec3b7a0a95d7ca7b6398" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;B&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;std::enable_if&lt;/code&gt; has a public member typedef &lt;code&gt;type&lt;/code&gt;, equal to &lt;code&gt;T&lt;/code&gt;; otherwise, there is no member typedef.</source>
          <target state="translated">경우 &lt;code&gt;B&lt;/code&gt; 는 인 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;std::enable_if&lt;/code&gt; 타입 정의 공개 부재 갖는 &lt;code&gt;type&lt;/code&gt; , 동일한 &lt;code&gt;T&lt;/code&gt; ; 그렇지 않으면 멤버 typedef가 없습니다.</target>
        </trans-unit>
        <trans-unit id="84997cfae0e3bc373338233f13fc51673ecc94bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is defined, for each constructor (or constructor template) &lt;code&gt;Ci&lt;/code&gt; declared in the named primary template (if it is defined), a fictional function template &lt;code&gt;Fi&lt;/code&gt;, is constructed, such that</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 가 정의 된 경우 , 명명 된 기본 템플리트에서 선언 된 각 생성자 (또는 생성자 템플리트) &lt;code&gt;Ci&lt;/code&gt; 에 대해 (정의 된 경우 ) Ci 함수 함수 템플리트 &lt;code&gt;Fi&lt;/code&gt; 는 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="cc1e774dd0f46e4682b7e19d8770ddcc69c901f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is not defined or does not declare any constructors, an additional fictional function template is added, derived as above from a hypothetical constructor &lt;code&gt;C()&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;C&lt;/code&gt; 는 정의되지 않은 또는 생성자 선언하지 않는 가상의 부가 기능 템플릿 가상 생성자에서 상기와 같이 유도되는 첨가 &lt;code&gt;C()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61f6db7fe67ce601045229a53fee7ef72360c40c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Count&lt;/code&gt; is not &lt;code&gt;std::dynamic_extent&lt;/code&gt;, &lt;code&gt;Count&lt;/code&gt;;</source>
          <target state="translated">경우 &lt;code&gt;Count&lt;/code&gt; 되지 않는 &lt;code&gt;std::dynamic_extent&lt;/code&gt; , &lt;code&gt;Count&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="e1dc222d7a60755a2201700bb9fa727680a8b6d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D&lt;/code&gt; is a reference type and the second overload is chosen, the program is ill-formed.</source>
          <target state="translated">경우 &lt;code&gt;D&lt;/code&gt; 가 참조 형식이고, 상기 제 과부하가 선택되고, 프로그램이 잘못 형성된다.</target>
        </trans-unit>
        <trans-unit id="f9c0db03f2072cdef42cb4c9c11cc3231d111137" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D&lt;/code&gt; is a reference type, the second overload is defined as deleted. These overloads only participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;D, decltype(d)&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. The program is ill-formed if either of these two constructors is selected by &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;D&lt;/code&gt; 가 참조 타입 삭제, 제 2 오버가 정의되어있다. &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;D, decltype(d)&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 이러한 과부하는 과부하 해결에만 참여 합니다 . 이 두 생성자 중 하나가 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;클래스 템플릿 인수 deduction에&lt;/a&gt; 의해 선택되면 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6d1f97a0f5c5a0f55060c5fcf0db428c8650e18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is a reference type, equivalent to &lt;code&gt;shared_ptr(r.release(), &lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;(r.get_deleter())&lt;/code&gt;. Otherwise, equivalent to &lt;code&gt;shared_ptr(r.release(), r.get_deleter())&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;Deleter&lt;/code&gt; 가이 에 해당 참조 형식이다 &lt;code&gt;shared_ptr(r.release(), &lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;(r.get_deleter())&lt;/code&gt; 등가 그렇지 않으면를.에 &lt;code&gt;shared_ptr(r.release(), r.get_deleter())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e307062451ff2a7a85e243f182577d712be79ad5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is a reference type, requires that &lt;code&gt;std::remove_reference&amp;lt;Deleter&amp;gt;::type&lt;/code&gt; is nothrow-&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Deleter&lt;/code&gt; 가이 참조 형식이며, 그 요구 &lt;code&gt;std::remove_reference&amp;lt;Deleter&amp;gt;::type&lt;/code&gt; nothrow-입니다 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="765f5fc1e61e543452d73e1fb0814a6856e4589a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is not a reference type, requires that it is nothrow-&lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Deleter&lt;/code&gt; 가 참조 유형이 아닌 경우 , &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 이 아니 어야 합니다.</target>
        </trans-unit>
        <trans-unit id="1aa2f10aa226cd93b28fcf97d03c1ee958d0bbf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Derived&lt;/code&gt; is &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;, such pointer may be used to make &lt;a href=&quot;virtual&quot;&gt;virtual function calls&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Derived&lt;/code&gt; 있다 &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;다형성&lt;/a&gt; , 같은 포인터하기 위해 사용될 수있는 &lt;a href=&quot;virtual&quot;&gt;가상 함수 호출을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3aeb6cf5a7fd827d219cf1ec41be16033ed0d80b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Derived&lt;/code&gt; is derived from &lt;code&gt;Base&lt;/code&gt; or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;Derived&lt;/code&gt; 에서 유래 &lt;code&gt;Base&lt;/code&gt; 또는 둘 (CV-자격을 무시하고 두 경우 모두에서) 동일한 비 연합 클래스 경우, 부재의 제공 상수 &lt;code&gt;value&lt;/code&gt; 과 동일한 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6ebd268ac27013dab52c304d8fe0d856e345f4dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E2&lt;/code&gt; is not a mutable member, the &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt; of the result is the union of the cv-qualifications of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;, otherwise (if &lt;code&gt;E2&lt;/code&gt; is a mutable member), it is the union of the volatile-qualifications of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;;</source>
          <target state="translated">경우 &lt;code&gt;E2&lt;/code&gt; 가 변경 가능한 구성원이 아닌의 &lt;a href=&quot;cv&quot;&gt;이력서 - 자격&lt;/a&gt; 결과는의 이력서 - 자격의 노동 조합 인 &lt;code&gt;E1&lt;/code&gt; 과 &lt;code&gt;E2&lt;/code&gt; (있는 경우는 true, 그렇지 않은 경우 &lt;code&gt;E2&lt;/code&gt; 가 변경 가능한 구성원), 그것은의 휘발성 자격의 노동 조합 인 &lt;code&gt;E1&lt;/code&gt; 이 와 &lt;code&gt;E2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="1cf4d112436b803bd3d27d42c800897ab593f0ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;&lt;code&gt;E(args)&lt;/code&gt; has class type cv &lt;code&gt;T&lt;/code&gt;, then.</source>
          <target state="translated">&lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;함수 호출 표현식 &lt;/a&gt; &lt;code&gt;E(args)&lt;/code&gt; 에 클래스 유형이 cv &lt;code&gt;T&lt;/code&gt; 인 경우 &lt;code&gt;E&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="1b8acc70084ea7a5796bb6ffccc7d45f74616a97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;&lt;code&gt;E(args)&lt;/code&gt; names a set of overloaded functions and/or function templates (but not callable objects), the following rules are followed:</source>
          <target state="translated">만약 &lt;code&gt;E&lt;/code&gt; 가 A의 &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;함수 호출 발현 &lt;/a&gt; &lt;code&gt;E(args)&lt;/code&gt; 이름 오버로드 된 기능 및 / 또는 기능 템플릿 (그러나 호출 객체)의 집합, 다음과 같은 규칙을 준수하고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8b40eb284409f27422ea732b684b0f26cb4eef16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; is not a polymorphic class type, or if &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; is an inaccessible or ambiguous base class of &lt;code&gt;E&lt;/code&gt;, there is no effect.</source>
          <target state="translated">경우 &lt;code&gt;E&lt;/code&gt; 는 다형성 클래스 유형이 아닌 경우, 또는 &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; 의 액세스 또는 모호한 기본 클래스 &lt;code&gt;E&lt;/code&gt; 는 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cfb9795d2d85864a23dfb415d8a0b25b1a06bb2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; specifies a member function, it may be virtual, in which case the final overrider of that function will be called, using dynamic dispatch at runtime.</source>
          <target state="translated">경우 &lt;code&gt;E&lt;/code&gt; 는 멤버 함수를 지정하고, 그 경우에 그 기능의 최종 overrider 런타임에 동적 디스패치를 이용하여 호출되며, 가상 수있다.</target>
        </trans-unit>
        <trans-unit id="7460d26bd30ccf50bedaefeb690ddad0b62aa2b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; exists and names a type, then &lt;code&gt;Hash::transparent_key_equal::is_transparent&lt;/code&gt; must be valid and name a type, and &lt;code&gt;Pred&lt;/code&gt; must be either &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../utility/functional/equal_to&quot;&gt;std::equal_to&lt;/a&gt;&amp;lt;Key&amp;gt;&lt;/code&gt; (the program is ill-formed otherwise).</source>
          <target state="translated">경우 &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; 유형을 존재와 이름, 다음 &lt;code&gt;Hash::transparent_key_equal::is_transparent&lt;/code&gt; 유효하고 유형 이름을해야 &lt;code&gt;Pred&lt;/code&gt; 를 가산는 하나 여야합니다 &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; , 또는 &lt;code&gt;&lt;a href=&quot;../utility/functional/equal_to&quot;&gt;std::equal_to&lt;/a&gt;&amp;lt;Key&amp;gt;&lt;/code&gt; (프로그램이 아픈 그렇지 않으면).</target>
        </trans-unit>
        <trans-unit id="e746872b3f4a32e36e22866e57c3635973587c0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; is an integral type, equivalent to &lt;code&gt;basic_string(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; 이 정수형 인 경우 &lt;code&gt;basic_string(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="236dbe55a4e3dcd17001ed4b1e01a9528c512d6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; is not &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, the behavior is undefined if &lt;code&gt;last&lt;/code&gt; is not reachable from &lt;code&gt;first&lt;/code&gt; by (possibly repeatedly) incrementing &lt;code&gt;first&lt;/code&gt;. If &lt;code&gt;InputIt&lt;/code&gt; is &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, the behavior is undefined if &lt;code&gt;last&lt;/code&gt; is not reachable from &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;first&lt;/code&gt; is not reachable from &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;InputIt&lt;/code&gt; 가 아닌 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 경우, 동작은 정의되지 않는다 &lt;code&gt;last&lt;/code&gt; 에서 도달 할 수없는 &lt;code&gt;first&lt;/code&gt; 증가 (반복 해)에 의해 &lt;code&gt;first&lt;/code&gt; . 경우 &lt;code&gt;InputIt&lt;/code&gt; 가 있다 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 경우, 동작은 정의되지 않는다 &lt;code&gt;last&lt;/code&gt; 에서 도달 할 수없는 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;first&lt;/code&gt; 에서 도달 할 수없는 &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7c4d085e7ff79e59c030b2b8c81a1702c66b3ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, this function rereads the input in order to detect duplicates.</source>
          <target state="translated">경우 &lt;code&gt;InputIt&lt;/code&gt; 만족 &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , 위하여이 함수를 다시 판독 입력 중복 검출한다.</target>
        </trans-unit>
        <trans-unit id="c3749207d2ce68de1c41a9f49f0c2035e0f8ee1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Iter&lt;/code&gt; does not have &lt;code&gt;pointer&lt;/code&gt;, but has all other four member types, then the member types are declared as follows:</source>
          <target state="translated">경우 &lt;code&gt;Iter&lt;/code&gt; 없습니다 &lt;code&gt;pointer&lt;/code&gt; 하지만, 다음과 같이 회원 유형이 선언되고있는 모든 다른 네 멤버 유형이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2654ba55a6d218cab7ca7778bb155b247c0f52ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Iter&lt;/code&gt; does not have all five member types &lt;code&gt;difference_type&lt;/code&gt;, &lt;code&gt;value_type&lt;/code&gt;, &lt;code&gt;pointer&lt;/code&gt;, &lt;code&gt;reference&lt;/code&gt;, and &lt;code&gt;iterator_category&lt;/code&gt;, then this template has no members by any of those names (&lt;code&gt;std::iterator_traits&lt;/code&gt; is SFINAE-friendly).</source>
          <target state="translated">경우 &lt;code&gt;Iter&lt;/code&gt; 다섯 멤버 유형이없는 &lt;code&gt;difference_type&lt;/code&gt; , &lt;code&gt;value_type&lt;/code&gt; , &lt;code&gt;pointer&lt;/code&gt; , &lt;code&gt;reference&lt;/code&gt; 및 &lt;code&gt;iterator_category&lt;/code&gt; 는 ,이 템플릿은 그 이름의 없음 회원이 없습니다 ( &lt;code&gt;std::iterator_traits&lt;/code&gt; SFINAE 쉬운).</target>
        </trans-unit>
        <trans-unit id="f45e1c1900c90ccc18a25b3d04a0c5ca7a8286f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is &lt;code&gt;std::dynamic_extent&lt;/code&gt;, the extent of the returned span &lt;code&gt;S&lt;/code&gt; is also &lt;code&gt;std::dynamic_extent&lt;/code&gt;; otherwise it is &lt;code&gt;sizeof(T) * N&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;N&lt;/code&gt; 이 된다 &lt;code&gt;std::dynamic_extent&lt;/code&gt; , 반환 스팬의 범위 &lt;code&gt;S&lt;/code&gt; 는 또한 &lt;code&gt;std::dynamic_extent&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;sizeof(T) * N&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="347ac408b6a94a1c447cd287529327ba6fa3d9ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is defined as a macro name at the point in the source code where &lt;code&gt;&amp;lt;cassert&amp;gt;&lt;/code&gt; is included, then &lt;code&gt;assert&lt;/code&gt; does nothing.</source>
          <target state="translated">소스 코드에서 &lt;code&gt;&amp;lt;cassert&amp;gt;&lt;/code&gt; 가 포함 된 지점에서 &lt;code&gt;NDEBUG&lt;/code&gt; 가 매크로 이름으로 정의 되면 &lt;code&gt;assert&lt;/code&gt; 는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f059b210d4e1ce59a4454923ec15e6398050571e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is not defined, then &lt;code&gt;assert&lt;/code&gt; checks if its argument (which must have scalar type) compares equal to zero. If it does, &lt;code&gt;assert&lt;/code&gt; outputs implementation-specific diagnostic information on the standard error output and calls &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;. The diagnostic information is required to include the text of &lt;code&gt;expression&lt;/code&gt;, as well as the values of the standard macros &lt;code&gt;__FILE__&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt;, and the standard variable &lt;code&gt;__func__&lt;/code&gt;(since C++11).</source>
          <target state="translated">경우 &lt;code&gt;NDEBUG&lt;/code&gt; 가 정의되어 있지 않은 경우, &lt;code&gt;assert&lt;/code&gt; 검사 인수 (스칼라 형을 가져야한다)이 제로인 경우와 비교. 만약 그렇다면, &lt;code&gt;assert&lt;/code&gt; 표준 오류 출력 및 통화에 대한 출력을 구현 고유의 진단 정보 &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; . 진단 정보는 &lt;code&gt;expression&lt;/code&gt; 텍스트와 표준 매크로 &lt;code&gt;__FILE__&lt;/code&gt; , &lt;code&gt;__LINE__&lt;/code&gt; 및 표준 변수 &lt;code&gt;__func__&lt;/code&gt; (C ++ 11부터)의 값을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf81f02b0ae53877b2da220b99b70dbdc5bf8ca4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; has one of the forms that include a function parameter list &lt;code&gt;(T)&lt;/code&gt;, then each parameter &lt;code&gt;P&lt;/code&gt;i from that list is compared with the corresponding argument &lt;code&gt;A&lt;/code&gt;i from &lt;code&gt;A&lt;/code&gt;'s function parameter list. If the last &lt;code&gt;P&lt;/code&gt;i is a pack expansion, then its declarator is compared with each remaining &lt;code&gt;A&lt;/code&gt;i in the parameter type list of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 에 함수 매개 변수 목록 &lt;code&gt;(T)&lt;/code&gt; 이 포함 된 양식 중 하나가있는 경우 해당 목록의 각 매개 변수 &lt;code&gt;P&lt;/code&gt; i 는 &lt;code&gt;A&lt;/code&gt; 의 함수 매개 변수 목록에 있는 해당 인수 &lt;code&gt;A&lt;/code&gt; i 와 비교 됩니다. 마지막 &lt;code&gt;P&lt;/code&gt; i 가 팩 확장 인 경우, 선언자는 &lt;code&gt;A&lt;/code&gt; 의 매개 변수 유형 목록에 &lt;code&gt;A&lt;/code&gt; 각 나머지 A i 와 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="03e7b27c0c840fc6ec6677dbe04f78b9c1de1735" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; has one of the forms that include a template parameter list &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;I&amp;gt;&lt;/code&gt;, then each element &lt;code&gt;P&lt;/code&gt;i of that template argument list is matched against the corresponding template argument &lt;code&gt;A&lt;/code&gt;i of its &lt;code&gt;A&lt;/code&gt;. If the last &lt;code&gt;P&lt;/code&gt;i is a pack expansion, then its pattern is compared against each remaining argument in the template argument list of &lt;code&gt;A&lt;/code&gt;. A trailing parameter pack that is not otherwise deduced, is deduced to an empty parameter pack.</source>
          <target state="translated">경우 &lt;code&gt;P&lt;/code&gt; 는 템플릿 파라미터리스트 포함 형태 중 하나 갖는 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;I&amp;gt;&lt;/code&gt; , 각 소자 &lt;code&gt;P&lt;/code&gt; 해당 템플릿 인수 목록 I는 해당 템플릿 인자에 대해 일치 나 그 중 &lt;code&gt;A&lt;/code&gt; . 마지막 &lt;code&gt;P&lt;/code&gt; i 가 팩 확장 인 경우, 패턴은 &lt;code&gt;A&lt;/code&gt; 의 템플리트 인수 목록에있는 나머지 각 인수와 비교 됩니다. 달리 추론되지 않은 후행 매개 변수 팩은 빈 매개 변수 팩으로 추론됩니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f363934a6c954657e01cc4569036680c0791d2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is a function type, pointer to function type, or pointer to member function type and if &lt;code&gt;A&lt;/code&gt; is a &lt;a href=&quot;overloaded_address&quot;&gt;set of overloaded functions&lt;/a&gt; not containing function templates, template argument deduction is attempted with each overload. If only one succeeds, that successful deduction is used. If none or more than one succeeds, the template parameter is non-deduced context (see below):</source>
          <target state="translated">경우 &lt;code&gt;P&lt;/code&gt; 는 멤버 함수 타입 함수 타입 포인터 함수 타입 또는 포인터이고, 만약 &lt;code&gt;A&lt;/code&gt; 가 A는 &lt;a href=&quot;overloaded_address&quot;&gt;오버 기능 세트&lt;/a&gt; 기능 템플릿을 포함하지 않는가 템플릿 인수 공제는 각각 과부하 시도된다. 하나만 성공하면 성공적인 추론이 사용됩니다. 둘 이상의 성공이 아닌 경우 템플릿 매개 변수는 제거되지 않은 컨텍스트입니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="798c24b5923fa6b7a5b42f42e0bab257c03db984" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is a reference type, it is replaced by the type referred to</source>
          <target state="translated">경우 &lt;code&gt;P&lt;/code&gt; 는 참조 타입이며, 이는 언급 된 형태로 대체</target>
        </trans-unit>
        <trans-unit id="000d2698f624166e9817ec6b2bf3be4c6abd2d81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is cv-qualified, &lt;code&gt;P&lt;/code&gt; is replaced with cv-unqualified version of itself</source>
          <target state="translated">경우 &lt;code&gt;P&lt;/code&gt; 는 CV-자격, &lt;code&gt;P&lt;/code&gt; 는 자신의 이력서 - 비정규 버전으로 바뀝니다</target>
        </trans-unit>
        <trans-unit id="aaad64c2f2873b4fe56c05d24d46c262bd388e7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;State&lt;/code&gt; is trivially copy constructible, &lt;code&gt;fpos&lt;/code&gt; has a trivial copy constructor. If &lt;code&gt;State&lt;/code&gt; is trivially copy assignable, &lt;code&gt;fpos&lt;/code&gt; has a trivial copy assignment operator. If &lt;code&gt;State&lt;/code&gt; is trivially destructible, &lt;code&gt;fpos&lt;/code&gt; has a trivial destructor.</source>
          <target state="translated">경우 &lt;code&gt;State&lt;/code&gt; 하찮게 작도 복사하고, &lt;code&gt;fpos&lt;/code&gt; 는 사소한 복사 생성자가 있습니다. 경우 &lt;code&gt;State&lt;/code&gt; 하찮게 할당 복사하고, &lt;code&gt;fpos&lt;/code&gt; 는 사소한 복사 할당 연산자가 있습니다. 경우 &lt;code&gt;State&lt;/code&gt; 하찮게 파괴하고, &lt;code&gt;fpos&lt;/code&gt; 는 사소한 소멸자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dfc67b9e7a073b3ee7a9cff59bc3b6f0015ab5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both reference types, and the</source>
          <target state="translated">경우 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 는 모두 참조 유형은, 상기</target>
        </trans-unit>
        <trans-unit id="b4afe72a5e507713bb840e388d5e58f8a34204b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both rvalue reference types: if the simple common reference type of &lt;code&gt;T1 &amp;amp;&lt;/code&gt; and &lt;code&gt;T2 &amp;amp;&lt;/code&gt; (determined according to the previous bullet) exists, then let &lt;code&gt;C&lt;/code&gt; denote that type's corresponding rvalue reference type. If &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T1, C&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T2, C&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, then the simple common reference type of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; is &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 는 모두 r- 수치 참조 종류 : 간단한 공통 기준 입력하면 &lt;code&gt;T1 &amp;amp;&lt;/code&gt; 및 &lt;code&gt;T2 &amp;amp;&lt;/code&gt; (이전 총알에 따라 측정)이 존재하고하자 &lt;code&gt;C&lt;/code&gt; 의 종류의 대응 r- 수치의 참조 타입임을 표시한다. 만약 &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T1, C&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T2, C&amp;gt;&lt;/code&gt; 모두 &lt;code&gt;true&lt;/code&gt; 의 후 간단한 공통 참조 타입 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 가 있다 &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acc4957d82e8a29ddb9310686f84a5c8e80923c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; is &lt;code&gt;&lt;i&gt;cv1&lt;/i&gt; X &amp;amp;&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; is &lt;code&gt;&lt;i&gt;cv2&lt;/i&gt; Y &amp;amp;&lt;/code&gt; (i.e., both are lvalue reference types): their simple common reference type is &lt;code&gt;decltype(false? &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 X &amp;amp;&amp;gt;() : &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 Y &amp;amp;&amp;gt;())&lt;/code&gt;, where</source>
          <target state="translated">경우 &lt;code&gt;T1&lt;/code&gt; 이 있다 &lt;code&gt;&lt;i&gt;cv1&lt;/i&gt; X &amp;amp;&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 는 것입니다 &lt;code&gt;&lt;i&gt;cv2&lt;/i&gt; Y &amp;amp;&lt;/code&gt; 자신의 간단한 공통의 참조 유형은 다음과 같습니다 (즉, 모두 좌변 참조 종류) &lt;code&gt;decltype(false? &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 X &amp;amp;&amp;gt;() : &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 Y &amp;amp;&amp;gt;())&lt;/code&gt; 여기서</target>
        </trans-unit>
        <trans-unit id="08dbf99d80fdb16cd55d43187dd92a8a606edf58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; (the template parameter of &lt;code&gt;shared_ptr&lt;/code&gt;) is an array type &lt;code&gt;U[N]&lt;/code&gt;, &lt;code&gt;idx&lt;/code&gt; must be less than &lt;code&gt;N&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 (의 템플릿 파라미터 &lt;code&gt;shared_ptr&lt;/code&gt; 에 ) 어레이 타입 &lt;code&gt;U[N]&lt;/code&gt; , &lt;code&gt;idx&lt;/code&gt; 이하이어야 &lt;code&gt;N&lt;/code&gt; 다르게 행동이 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="76e47a93376f512128c0f4db3b70d51d91d300a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; name the same type (including const/volatile qualifications), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 는 (CONST / 휘발성 자격 포함) 동일한 유형의 이름, 멤버 상수의 제공 &lt;code&gt;value&lt;/code&gt; 같음 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="38278b1e8c4f34f7f9afed63ddee71b7095445d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; has a member typedef &lt;code&gt;allocator_type&lt;/code&gt; which is convertible from &lt;code&gt;Alloc&lt;/code&gt;or is an alias of &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/erased_type&quot;&gt;std::experimental::erased_type&lt;/a&gt;&lt;/code&gt;(library fundamentals TS), the member constant &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 타입 정의 멤버 갖는다 &lt;code&gt;allocator_type&lt;/code&gt; 에서 컨버터블 &lt;code&gt;Alloc&lt;/code&gt; 또는 별칭 &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/erased_type&quot;&gt;std::experimental::erased_type&lt;/a&gt;&lt;/code&gt; (라이브러리 펀더멘털 TS)를 멤버 상수의 &lt;code&gt;value&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81aa069be603406651761b390a77246a11143050" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, a function type, or an array of unknown bound, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 (아마도 CV 정규화)는 &lt;code&gt;void&lt;/code&gt; 함수 타입 또는 결합 미지의 배열이 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf221325f890a6ce6f02bee9daee7fe55c23f701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; and if any two objects of type &lt;code&gt;T&lt;/code&gt; with the same value have the same &lt;a href=&quot;../language/objects&quot;&gt;object representation&lt;/a&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; 및 유형의 임의의 두 개체 경우 &lt;code&gt;T&lt;/code&gt; 와 동일한 값이 동일해야 &lt;a href=&quot;../language/objects&quot;&gt;객체 표현을&lt;/a&gt; 제공 부재 상수의 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd6768a7a8e61b9b33b46e7ee729a0e3a0f70982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt; (that is, a scalar type, a trivially copyable class with a &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial default constructor&lt;/a&gt;, or array of such type/class, possibly cv-qualified), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt; (즉, 스칼라 형, 함께 사소 복사 가능한 클래스 &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;사소한 기본 생성자&lt;/a&gt; , 또는 형 / 클래스 아마도 CV 수식의 배열) 제공 부재 상수의 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1568f85d20b8988df4e7cc3a1520f513dcc3a32c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/derived_class&quot;&gt;derived class&lt;/a&gt; of some base &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;a href=&quot;unique_ptr/unique_ptr&quot;&gt;implicitly convertible&lt;/a&gt; to &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt;. The default deleter of the resulting &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; will use &lt;a href=&quot;new/operator_delete&quot;&gt;operator delete&lt;/a&gt; for &lt;code&gt;B&lt;/code&gt;, leading to &lt;a href=&quot;../language/destructor#Virtual_destructors&quot;&gt;undefined behavior&lt;/a&gt; unless the destructor of &lt;code&gt;B&lt;/code&gt; is &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt;. Note that &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; behaves differently: &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; will use the &lt;a href=&quot;new/operator_delete&quot;&gt;operator delete&lt;/a&gt; for the type &lt;code&gt;T&lt;/code&gt; and the owned object will be deleted correctly even if the destructor of &lt;code&gt;B&lt;/code&gt; is not &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 A는 &lt;a href=&quot;../language/derived_class&quot;&gt;파생 클래스&lt;/a&gt; 일부베이스의 &lt;code&gt;B&lt;/code&gt; , 다음 &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 입니다 &lt;a href=&quot;unique_ptr/unique_ptr&quot;&gt;암시 적으로 변환&lt;/a&gt; 하는 &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; . 결과의 기본 Deleter가 &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; 사용 &lt;a href=&quot;new/operator_delete&quot;&gt;운영자가 삭제&lt;/a&gt; 를 위해 &lt;code&gt;B&lt;/code&gt; 로 이어지는 &lt;a href=&quot;../language/destructor#Virtual_destructors&quot;&gt;정의되지 않은 동작&lt;/a&gt; 의 소멸자하지 않는 &lt;code&gt;B&lt;/code&gt; 는 이다 &lt;a href=&quot;../language/virtual&quot;&gt;가상&lt;/a&gt; . 참고 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 동작합니다 다르게 : &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; 를 사용합니다 &lt;a href=&quot;new/operator_delete&quot;&gt;삭제 연산자를&lt;/a&gt; 유형에 대한 &lt;code&gt;T&lt;/code&gt; &lt;code&gt;B&lt;/code&gt; 의 소멸자 가 &lt;a href=&quot;../language/virtual&quot;&gt;가상&lt;/a&gt; 이 아닌 경우에도 소유 오브젝트가 올바르게 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="14d30fb0aa28f637b9fb71d066b29a527b12f2ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/objects#Polymorphic_objects&quot;&gt;polymorphic class&lt;/a&gt; (that is, a non-union class that declares or inherits at least one virtual function), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 A는 &lt;a href=&quot;../language/objects#Polymorphic_objects&quot;&gt;다형성 클래스&lt;/a&gt; (즉, 상속 선언하거나, 적어도 하나의 가상 함수 비 연합 클래스)의 부재에 제공 상수 &lt;code&gt;value&lt;/code&gt; 과 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b9f4f4e6212d0ba8a754d82884bd2c1bd59ed77a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/type-id&quot;&gt;scalar type&lt;/a&gt; (that is a possibly cv-qualified &lt;a href=&quot;is_arithmetic&quot;&gt;arithmetic&lt;/a&gt;, pointer, &lt;a href=&quot;is_member_pointer&quot;&gt;pointer to member&lt;/a&gt;, &lt;a href=&quot;../language/enum&quot;&gt;enumeration&lt;/a&gt;, or &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; type), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 A는 &lt;a href=&quot;../language/type-id&quot;&gt;스칼라 형&lt;/a&gt; (a 가능성 CV - 정규화 &lt;a href=&quot;is_arithmetic&quot;&gt;연산&lt;/a&gt; 포인터, &lt;a href=&quot;is_member_pointer&quot;&gt;부재에 대한 포인터&lt;/a&gt; , &lt;a href=&quot;../language/enum&quot;&gt;열거&lt;/a&gt; 나 &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 타입) 제공 부재 상수의 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="26b317cff4e6b234d366569c6bab42c37da84e1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../named_req/podtype&quot;&gt;PODType&lt;/a&gt; (&quot;plain old data type&quot;), that is, both trivial and standard-layout, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 A는 &lt;a href=&quot;../named_req/podtype&quot;&gt;PODType&lt;/a&gt; 이다 ( &quot;일반 이전 데이터 유형&quot;) 모두 사소한 표준 레이아웃은 부재 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aabad78089db78755c758b0100bec563037cafec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 A는 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; 타입의 부재를 제공 상수 &lt;code&gt;value&lt;/code&gt; 과 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aa4f125d6fcfcc5603d821627566fc4b66114754" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type and the cv-unqualified version of the type of other is &lt;code&gt;T&lt;/code&gt; or a class derived from &lt;code&gt;T&lt;/code&gt;, the &lt;a href=&quot;converting_constructor&quot;&gt;non-explicit constructors&lt;/a&gt; of &lt;code&gt;T&lt;/code&gt; are examined and the best match is selected by overload resolution. The constructor is then called to initialize the object.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 클래스 유형과 다른 유형의 이력서 - 자격이없는 버전입니다 &lt;code&gt;T&lt;/code&gt; 또는에서 파생 된 클래스 &lt;code&gt;T&lt;/code&gt; 의 &lt;a href=&quot;converting_constructor&quot;&gt;비 명시 적으로 생성자&lt;/a&gt; 의 &lt;code&gt;T&lt;/code&gt; 는 검토하고 최고의 경기는 오버로드 확인에 의해 선택된다. 그런 다음 생성자를 호출하여 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="da7735d51b45c0cf73d900692c844b55829fb21a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type that has no default constructor but has a constructor taking &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; is performed.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 기본 생성자가 있지만, 복용 생성자가 클래스 타입 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;list_initialization&quot;&gt;리스트 초기화를&lt;/a&gt; 수행한다.</target>
        </trans-unit>
        <trans-unit id="bd5fd7b67551be2174ad147f6096e9f4d8ec3b0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type,</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 클래스 타입이며,</target>
        </trans-unit>
        <trans-unit id="ec4bcfea7a6b88492eb03ffb2367361b716260ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, &lt;code&gt;T&lt;/code&gt; shall be a complete type; otherwise, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 클래스 타입이며, &lt;code&gt;T&lt;/code&gt; 는 완전한 형태이어야한다; 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="896d68960185cda4dfdf0280d92d7ef716c2b80f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, and the cv-unqualified version of the type of other is not &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, or if &lt;code&gt;T&lt;/code&gt; is non-class type, but the type of other is a class type, &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequences&lt;/a&gt; that can convert from the type of other to &lt;code&gt;T&lt;/code&gt; (or to a type derived from T if T is a class type and a conversion function is available) are examined and the best one is selected through overload resolution. The result of the conversion, which is a prvalue temporary(until C++17)prvalue expression(since C++17) if a &lt;a href=&quot;converting_constructor&quot;&gt;converting constructor&lt;/a&gt; was used, is then used to &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialize&lt;/a&gt; the object. The last step is usually &lt;a href=&quot;copy_elision&quot;&gt;optimized out&lt;/a&gt; and the result of the conversion is constructed directly in the memory allocated for the target object, but the appropriate constructor (move or copy) is required to be accessible even though it's not used.(until C++17)</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 클래스 유형 및 다른 유형의 CV-비정규 버전이 아닌가요 &lt;code&gt;T&lt;/code&gt; 또는 유래의 &lt;code&gt;T&lt;/code&gt; 경우, 또는 &lt;code&gt;T&lt;/code&gt; 가 아닌 클래스 타입이지만, 다른 유형은 클래스 타입 인 &lt;a href=&quot;implicit_cast&quot;&gt;사용자 정의 변환 시퀀스&lt;/a&gt; 다른 유형에서 &lt;code&gt;T&lt;/code&gt; 로 변환 할 수있는 (또는 T가 클래스 유형이고 변환 함수를 사용할 수있는 경우 T에서 파생 된 유형으로) 변환되는 것이 검사되고 과부하 해결을 통해 가장 적합한 유형이 선택됩니다. &lt;a href=&quot;converting_constructor&quot;&gt;변환 생성자&lt;/a&gt; 가 사용 된 경우 C ++ 17 이후 prvalue 임시 (C ++ 17 이후) prvalue 표현식 인 변환 결과 는 오브젝트 를 &lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 하는 데 사용됩니다 . 마지막 단계는 보통&lt;a href=&quot;copy_elision&quot;&gt;최적화되고&lt;/a&gt; 변환 결과는 대상 객체에 할당 된 메모리에 직접 구성되지만, 사용되지 않더라도 적절한 생성자 (이동 또는 복사)에 액세스 할 수 있어야합니다. (C ++ 17까지)</target>
        </trans-unit>
        <trans-unit id="d1e8a1503abd79c3951a5fdc99d54970e61781da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class, it</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 클래스이며, 그것을</target>
        </trans-unit>
        <trans-unit id="ed233d36e232baacab8bc15f22e8a539e4afdd7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a complete enumeration type, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names the underlying type of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 완전한 열거 타입, typedef에 멤버를 제공 &lt;code&gt;type&lt;/code&gt; 하는 이름의 기본 유형 &lt;code&gt;T&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="8db0456a21c631678465dcec0933012e0ff80219" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 (어떤 CV 수식 변이체를 포함한 배열 함수, 오브젝트 포인터, 함수 포인터 부재 오브젝트 포인터 멤버 함수 포인터 레퍼런스 클래스 조합 또는 열거이다)의 화합물의 종류이고, 부재 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 동일한 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef33179463348172c7683162235f438e5b4d890a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a const-qualified type (that is, &lt;code&gt;const&lt;/code&gt;, or &lt;code&gt;const volatile&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 (하다는 CONST 수식 유형 &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;const volatile&lt;/code&gt; )의 부재를 제공 상수 &lt;code&gt;value&lt;/code&gt; 과 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6bd5fbe7c6f6fa50f124d44f0d758532e44d5237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a const-qualified type, it must be a class type with a user-provided default constructor.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 CONST 자격 유형, 그것은 사용자가 제공하는 기본 생성자와 클래스 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="91f7440ceeb8c74be7fd249bfe485e7779ba5401" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a cv-qualified type, its cv-unqualified version is used for the purpose of default-initialization.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 이력서 자격 유형, 그 이력서 - 자격이 버전은 기본 초기화하기위한 목적으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="e52096d9a275548201e72366e41ec09c171ba7e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a final class (that is, a class declared with the &lt;a href=&quot;../language/final&quot;&gt;final specifier&lt;/a&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 최종적인 클래스 (즉, 클래스로 선언 &lt;a href=&quot;../language/final&quot;&gt;최종 지정자&lt;/a&gt; ) 제공 부재 상수의 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d0409542043a949225bfecbaf84bae28f3b1b559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a fundamental type (that is, arithmetic type, &lt;code&gt;void&lt;/code&gt;, or &lt;code&gt;nullptr_t&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 기본 타입 (인 산술 형 &lt;code&gt;void&lt;/code&gt; 또는 &lt;code&gt;nullptr_t&lt;/code&gt; ) 제공 부재 상수의 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="945c7b712dc29eea2b59cbb88e5b35a7559eb2f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a literal type, then this destructor is a trivial destructor.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 문자 그대로의 유형이,이 소멸자는 사소한 소멸자이다.</target>
        </trans-unit>
        <trans-unit id="64ca21f761a5e7e05def717cd2e2b74081f4cf00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a multidimensional array of some type &lt;code&gt;X&lt;/code&gt;, provides the member typedef &lt;code&gt;type&lt;/code&gt; equal to &lt;code&gt;X&lt;/code&gt;, otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 어떤 유형의 다차원 배열 &lt;code&gt;X&lt;/code&gt; , typedef에 제공 부재 &lt;code&gt;type&lt;/code&gt; 동일한 &lt;code&gt;X&lt;/code&gt; 를 달리, &lt;code&gt;type&lt;/code&gt; 인 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b1b0a24554bc1d76e3a383da4b1a44ea0d8546a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a non-class type, the value contained in the object is produced as the prvalue result. For a class type, this conversion.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 아닌 클래스 타입이 값은 prvalue 결과로 생성 된 객체에 포함. 클래스 유형의 경우이 변환입니다.</target>
        </trans-unit>
        <trans-unit id="69946f1172c363138f6dfe6642850f73c0486b56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a non-union class type, &lt;code&gt;T&lt;/code&gt; shall be a complete type; otherwise, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 비 노조 클래스 형식이며, &lt;code&gt;T&lt;/code&gt; 는 완전한 형태이어야한다; 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81c8d7a5988a6dccdd619ff7a279df533a7a5150" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type (lvalue reference or rvalue reference), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 기준 입력 (좌변 참조 또는 r- 수치 참조) 인 멤버 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8dafe7774d902eba322cf87364d4aea07d531abd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type then &lt;code&gt;is_const&amp;lt;T&amp;gt;::value&lt;/code&gt; is always &lt;code&gt;false&lt;/code&gt;. The proper way to check a potentially-reference type for const-ness is to remove the reference: &lt;code&gt;is_const&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 참조 형식은 다음 &lt;code&gt;is_const&amp;lt;T&amp;gt;::value&lt;/code&gt; 항상 &lt;code&gt;false&lt;/code&gt; . const-ness에 대한 잠재적 참조 유형을 확인하는 올바른 방법은 참조를 제거하는 것입니다 : &lt;code&gt;is_const&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ea9b4eb9eb04de1f92850f45ff1fddbdaee120f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type, then provides the member typedef &lt;code&gt;type&lt;/code&gt; which is a pointer to the referred type.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 참조 형식이며, 그 부재의 타입 정의를 제공 &lt;code&gt;type&lt;/code&gt; 참조 된 타입에 대한 포인터이다.</target>
        </trans-unit>
        <trans-unit id="2563eff1fa56e4b4ac0532f78126ffeeed82a1f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a scalar type, the object's initial value is the integral constant zero &lt;a href=&quot;explicit_cast&quot;&gt;explicitly converted&lt;/a&gt; to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 스칼라 타입이며, 객체의 초기 값은 적분 상수 제로 &lt;a href=&quot;explicit_cast&quot;&gt;명시 적 변환&lt;/a&gt; 에 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87c045c1fc56928cd55cfd53cf91e06e54ae07d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a standard layout type (that is, a scalar type, a standard-layout class, or an array of such type/class, possibly cv-qualified), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 표준 레이아웃 유형 (즉, 스칼라 형 표준 레이아웃 클래스, 또는 형 / 클래스 아마도 CV 수식의 배열) 제공 부재 상수의 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b944fcc6217049e07d88eb139271e7fb7cc4f093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a type with a virtual destructor, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 가상 소멸자와 타입 멤버 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4437c61374698795bc2e7b0a725c5aea0e02d36" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a union type, the first non-static named data member is zero-initialized and all padding is initialized to zero bits.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 유니온 타입이고, 데이터 부재라는 제 비 정적는 0으로 초기화되고 모든 패딩 비트 제로로 초기화된다.</target>
        </trans-unit>
        <trans-unit id="c4e59ca1d67fedc2671ca4bc2d55bea20110e0a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a volatile-qualified type (that is, &lt;code&gt;volatile&lt;/code&gt;, or &lt;code&gt;const volatile&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 (이라고 휘발성 정규화 타입 &lt;code&gt;volatile&lt;/code&gt; 또는 &lt;code&gt;const volatile&lt;/code&gt; )의 부재를 제공 상수 &lt;code&gt;value&lt;/code&gt; 과 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="902b6c9678e19fc91eed33a7ee6f68dcf0f1506d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/abstract_class&quot;&gt;abstract class&lt;/a&gt; (that is, a non-union class that declares or inherits at least one pure virtual function), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 입니다 &lt;a href=&quot;../language/abstract_class&quot;&gt;추상 클래스&lt;/a&gt; (즉, 선언하거나 상속 적어도 하나의 순수 가상 함수가 아닌 노조 클래스), 멤버 상수의 제공 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ec8806b61c0e95ac652393c60f0f6708ecf1e2f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/type-id&quot;&gt;object type&lt;/a&gt; (that is any possibly cv-qualified type other than function, reference, or &lt;code&gt;void&lt;/code&gt; types), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 인 &lt;a href=&quot;../language/type-id&quot;&gt;개체 유형&lt;/a&gt; (즉, 함수, 기준, 또는 이외 가능성 CV 수식 유형 &lt;code&gt;void&lt;/code&gt; 타입)의 부재를 제공 상수 &lt;code&gt;value&lt;/code&gt; 과 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f0fb50089c183d77cfb88879ad7a640e825184ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate type&lt;/a&gt;, &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt; is performed.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;a href=&quot;aggregate_initialization&quot;&gt;집계 유형&lt;/a&gt; , &lt;a href=&quot;aggregate_initialization&quot;&gt;집계 초기화를&lt;/a&gt; 수행한다.</target>
        </trans-unit>
        <trans-unit id="aa61f0f59c6b53db0c1c4a6741114952582e2eaf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an aggregate type and the initializer list has a single element of the same or derived type (possibly cv-qualified), the object is initialized from that element (by &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; for copy-list-initialization, or by &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; for direct-list-initialization).</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 집합 형이고 이니셜리스트 동일 또는 유도 형 (아마도 CV 수식) 중 하나의 요소를 가지고 상기 객체에 의해 (즉, 소자로부터 초기화 &lt;a href=&quot;copy_initialization&quot;&gt;복사 - 초기화&lt;/a&gt; 하거나하여 복사리스트 초기화를위한 &lt;a href=&quot;direct_initialization&quot;&gt;직접 -&lt;/a&gt; 직접 목록 초기화를 위한 초기화).</target>
        </trans-unit>
        <trans-unit id="689228bd3413da8a5503b4c482886c287f618b2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type (that is, an integral type or a floating-point type) or a &lt;code&gt;cv-qualified&lt;/code&gt; version thereof, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 산술 타입 (즉, 일체형 또는 부동 소수점 형) 또는 &lt;code&gt;cv-qualified&lt;/code&gt; 이들 버전 제공 부재 상수의 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fbccf0b2c1488a744757cc2db3268bc8b20be41f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T(-1) &amp;lt; T(0)&lt;/code&gt;: this results in &lt;code&gt;true&lt;/code&gt; for the floating-point types and the signed integer types, and in &lt;code&gt;false&lt;/code&gt; for the unsigned integer types and the type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 산술 타입이 상기 부재 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;T(-1) &amp;lt; T(0)&lt;/code&gt; :이 결과가 &lt;code&gt;true&lt;/code&gt; 부동 소수점 형식과위한 유형의 정수이고, 로그인 &lt;code&gt;false&lt;/code&gt; 부호없는 정수 타입 그리고 &lt;code&gt;bool&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="fcba9f80c891b0c1e133e1cb6925e4162b876bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T(0) &amp;lt; T(-1)&lt;/code&gt;: this results in &lt;code&gt;true&lt;/code&gt; for the unsigned integer types and the type &lt;code&gt;bool&lt;/code&gt; and in &lt;code&gt;false&lt;/code&gt; for the signed integer types and the floating-point types.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 산술 타입이 상기 부재 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;T(0) &amp;lt; T(-1)&lt;/code&gt; 이 결과 &lt;code&gt;true&lt;/code&gt; 부호없는 정수 유형 및 종류 &lt;code&gt;bool&lt;/code&gt; 과의 &lt;code&gt;false&lt;/code&gt; 에 대한 상기 타입 부호있는 정수 및 부동 포인트 타입.</target>
        </trans-unit>
        <trans-unit id="c1fc66fc47bed74ebe67e8cc80e0ae9110815b91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array of some type &lt;code&gt;X&lt;/code&gt;, provides the member typedef &lt;code&gt;type&lt;/code&gt; equal to &lt;code&gt;X&lt;/code&gt;, otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if T is a multidimensional array, only the first dimension is removed.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 어떤 유형의 배열 &lt;code&gt;X&lt;/code&gt; , typedef에 제공 부재 &lt;code&gt;type&lt;/code&gt; 동일한 &lt;code&gt;X&lt;/code&gt; 를 달리, &lt;code&gt;type&lt;/code&gt; 인 &lt;code&gt;T&lt;/code&gt; . T가 다차원 배열이면 첫 번째 차원 만 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="79fca8c3f06baf2e5727ef4a8e28e151e6f0be48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type &lt;code&gt;U[N]&lt;/code&gt;, these constructors do not participate in overload resolution if &lt;code&gt;Y(*)[N]&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an array type &lt;code&gt;U[]&lt;/code&gt;, these constructors do not participate in overload resolution if &lt;code&gt;Y(*)[]&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;. Otherwise, these constructors do not participate in overload resolution if &lt;code&gt;Y*&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 어레이 타입 &lt;code&gt;U[N]&lt;/code&gt; 있는 경우,이 생성자 과부하 해상도에 참여하지 않는 &lt;code&gt;Y(*)[N]&lt;/code&gt; 으로 변환 아닌 &lt;code&gt;T*&lt;/code&gt; . 경우 &lt;code&gt;T&lt;/code&gt; 는 어레이 타입 &lt;code&gt;U[]&lt;/code&gt; 하면 이러한 생성자 과부하 해상도에 참여하지 않는 &lt;code&gt;Y(*)[]&lt;/code&gt; 로 전환 아니다 &lt;code&gt;T*&lt;/code&gt; . 그렇지 않으면, &lt;code&gt;Y*&lt;/code&gt; 를 &lt;code&gt;T*&lt;/code&gt; 로 변환 할 수없는 경우 이러한 생성자는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0b5f23983416e1c75433eb3c8db868b92738cbbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type,</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 어레이 형태는,</target>
        </trans-unit>
        <trans-unit id="40f6a482e9f6bb37f7f795348ce26482a687ee2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to the number of dimensions of the array. For any other type, &lt;code&gt;value&lt;/code&gt; is 0.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 어레이 형태는, 부재의 제공 상수 &lt;code&gt;value&lt;/code&gt; 배열의 차원 수와 동일한다. 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 은 0입니다.</target>
        </trans-unit>
        <trans-unit id="50b11c4cc0a3bc2aa8bbbd2ffae9d6dac98f5145" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to the number of elements along the &lt;code&gt;N&lt;/code&gt;th dimension of the array, if &lt;code&gt;N&lt;/code&gt; is in &lt;code&gt;[0, std::rank&amp;lt;T&amp;gt;::value)&lt;/code&gt;. For any other type, or if &lt;code&gt;T&lt;/code&gt; is array of unknown bound along its first dimension and &lt;code&gt;N&lt;/code&gt; is 0, &lt;code&gt;value&lt;/code&gt; is 0.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 어레이 형태는, 부재 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 따라 요소들의 수와 동일한 &lt;code&gt;N&lt;/code&gt; 만약 어레이의 일 차원 &lt;code&gt;N&lt;/code&gt; 은 인 &lt;code&gt;[0, std::rank&amp;lt;T&amp;gt;::value)&lt;/code&gt; . 다른 유형 또는 &lt;code&gt;T&lt;/code&gt; 가 첫 번째 차원을 따라 알려지지 않은 배열이고 &lt;code&gt;N&lt;/code&gt; 이 0 인 경우 &lt;code&gt;value&lt;/code&gt; 은 0입니다.</target>
        </trans-unit>
        <trans-unit id="d418fb8b71e5b3d9f326ce97a54075d08f82dec3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 빈 타입 (즉, 크기 0의 비트 필드없이 가상 함수없이 가상베이스 클래스 이외의 비 정적 데이터 멤버, 어떤 비어베이스 클래스와 비 연합 클래스 타입) 멤버 상수 &lt;code&gt;value&lt;/code&gt; 과 동일한 &lt;code&gt;true&lt;/code&gt; 를 제공 합니다 . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="615ee340215311c44d8a0200015cab668b08669e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an error code enumeration, this template provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 에러 코드를 열거하고,이 템플릿은 부재 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f00d4c8f60284c8e8a5d4214a2b023ed99513026" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an error condition enum, this template provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 오류 조건 ENUM은,이 템플릿은 부재 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="64661dfb24aa2b41c7a58f86cc3e8e06dff1cc46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integral (except bool) or enumeration type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the signed integer type corresponding to &lt;code&gt;T&lt;/code&gt;, with the same cv-qualifiers.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 (BOOL 제외) 정수 또는 열거 형이며, 멤버 타입 정의를 제공 &lt;code&gt;type&lt;/code&gt; 에 대응하는 형 체결 정수이고 &lt;code&gt;T&lt;/code&gt; 동일한 CV-한정자를.</target>
        </trans-unit>
        <trans-unit id="f9f1f9d4a2f0ac4a591a53f86518618b379c091c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integral (except bool) or enumeration type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the unsigned integer type corresponding to &lt;code&gt;T&lt;/code&gt;, with the same cv-qualifiers. The unsigned integer type corresponding to an enumeration type is the unsigned integer type with the smallest &lt;a href=&quot;../language/implicit_cast#Integral_promotion&quot;&gt;rank&lt;/a&gt; having the same &lt;code&gt;sizeof&lt;/code&gt; as the enumeration.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 (BOOL 제외) 정수 또는 열거 형이며, 멤버 타입 정의를 제공 &lt;code&gt;type&lt;/code&gt; 에 대응하는 부호없는 정수 타입 &lt;code&gt;T&lt;/code&gt; 동일한 CV-한정자를. 열거 형에 대응하는 부호없는 정수형은 열거 형과 같은 &lt;code&gt;sizeof&lt;/code&gt; 를 갖는 가장 작은 &lt;a href=&quot;../language/implicit_cast#Integral_promotion&quot;&gt;순위를&lt;/a&gt; 갖는 부호없는 정수형 이다.</target>
        </trans-unit>
        <trans-unit id="c91459dde93fa1a39419b8fda3571b1d3f2524ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an non-union class type, all base classes and non-static data members are zero-initialized, and all padding is initialized to zero bits. The constructors, if any, are ignored.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 불유합 클래스 타입이 모든 기본 클래스 및 비 - 정적 데이터 멤버는 영으로 초기화하고, 모든 제로 패딩 비트를 초기화한다. 생성자 (있는 경우)는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c1d5d737127c3f29b041ec54c37e9b91100e0f8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an object type, then, for the type &lt;code&gt;U&lt;/code&gt; equal &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt;, if the expression &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;amp;&amp;gt;().~U()&lt;/code&gt; is well-formed in unevaluated context, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 개체 유형이 뒤, 타입 &lt;code&gt;U&lt;/code&gt; 는 동일 &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; , 만약 식 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;amp;&amp;gt;().~U()&lt;/code&gt; 평가되지 않은 상황에서 잘 형성된다 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 와 같습니다 . 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 은 &lt;code&gt;false&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c22afe114b35ac81cf800a1156d7baffcb6d3c14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is array type, each element is zero-initialized</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 어레이 형이며, 각 요소는 0으로 초기화이며</target>
        </trans-unit>
        <trans-unit id="dea68d51090e5d0f319644a92de20fb3d9b95d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the program that specializes &lt;code&gt;std::tx_exception&amp;lt;T&amp;gt;&lt;/code&gt; is ill-formed.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; 이 아닌 경우 &lt;code&gt;std::tx_exception&amp;lt;T&amp;gt;&lt;/code&gt; 를 전문화하는 프로그램 이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="73b3d58d3922df960693448a6c809c6309de2344" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not a standard placeholder type, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,0&amp;gt;&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 표준 자리 표시 자 형식이 아닙니다,이 템플릿에서 파생 된 &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,0&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ee1c8ebae98c21b02f68dd05886f8fe92f20e99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not const-qualified, then &lt;code&gt;rv&lt;/code&gt;'s resulting state (after the definition/expression is evaluated in either bullets above) is valid but unspecified; otherwise, it is unchanged.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 const-qualified가 아닌 경우 , &lt;code&gt;rv&lt;/code&gt; 의 결과 상태 (위의 두 글 머리 기호로 정의 / 표현이 평가 된 후)는 유효하지만 지정되지 않습니다. 그렇지 않으면 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="615bba93f7cf789b20b52441a5845c09300784e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is pointer to non-static member object or a pointer to non-static member function, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 비 정적 부재 객체 또는 비 정적 멤버 함수 포인터에 대한 포인터이며, 제공 부재 상수의 &lt;code&gt;value&lt;/code&gt; 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f5ac84ccbccc9198a7ab09ce3b026f6c47e5ff46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is reference type, nothing is done.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 참조 형, 아무것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f854a51cba2ddf3f5cc88ad123c5f24a105a0f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is the type of a standard placeholder (_1, _2, _3, ...), then this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,1&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,2&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,3&amp;gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 표준 자리의 유형 (_1이 _2, _3 ...),이 템플릿에서 파생 &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,1&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,2&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,3&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f81cf7e82856e3e7cad5504cd15ee27f838ea825" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is the type produced by a call to &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt;. For any other type, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 가 의 호출에 의해 생성 된 유형 &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; ,이 템플릿에서 파생 된 &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; . 다른 유형의 경우이 템플리트는 &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; 에서 파생됩니다 .</target>
        </trans-unit>
        <trans-unit id="51e3546d16456aa08a11e4cc71a3bbf5dec35bfe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is trivially-destructible, then this destructor is also trivial, so &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; is also trivially-destructible.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 는 하찮게-파괴이며,이 소멸자, 또한 사소한 그래서 &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; IS도 하찮게-파괴.</target>
        </trans-unit>
        <trans-unit id="d31c04866aa7a4ef595b5ddda4f6ba3e2b023b2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; models &lt;a href=&quot;../concepts/defaultconstructible&quot;&gt;&lt;code&gt;DefaultConstructible&lt;/code&gt;&lt;/a&gt;, the default constructor of &lt;code&gt;&lt;i&gt;semiregular&lt;/i&gt;&amp;lt;T&amp;gt;&lt;/code&gt; constructs a semiregular wrapper containing a value-initialized &lt;code&gt;T&lt;/code&gt; and is equivalent to:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가&lt;a href=&quot;../concepts/defaultconstructible&quot;&gt; &lt;code&gt;DefaultConstructible&lt;/code&gt; 을&lt;/a&gt; 모델링하는 경우 &lt;code&gt;&lt;i&gt;semiregular&lt;/i&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 의 기본 생성자 는 값으로 초기화 된 &lt;code&gt;T&lt;/code&gt; 를 포함하는 반 정규 래퍼를 구성하며 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="02a86ca705d443044b0fbfb7fbc9ab041d9a2f6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; names the type &quot;array of &lt;code&gt;U&lt;/code&gt;&quot; or &quot;reference to array of &lt;code&gt;U&lt;/code&gt;&quot;, the member typedef &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;U*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 가 유형을 &quot;array of &lt;code&gt;U&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;U&lt;/code&gt; 의 배열에 대한 참조 &quot;로 이름을 지정한 경우 멤버 typedef &lt;code&gt;type&lt;/code&gt; 은 &lt;code&gt;U*&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3c2891f9d56d7ae3301606af512c7f8ffc24cd7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 를 만족하는 모든 요구 &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType는&lt;/a&gt; 상기 부재의 제공 상수 &lt;code&gt;value&lt;/code&gt; 과 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac1553fe834dd9a1efb1dfce83c0e4902b9cd37a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; satisfies the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 를 만족하는 &lt;a href=&quot;../named_req/clock&quot;&gt;클록&lt;/a&gt; 요건이 멤버 상수를 제공하는 &lt;code&gt;value&lt;/code&gt; 과 동일 &lt;code&gt;true&lt;/code&gt; . 다른 유형의 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c87275ecad38359126e4f40cf9ccd9918c5e81e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and T is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">경우 &lt;code&gt;T&lt;/code&gt; 의 이동 생성자가 아닌 &lt;code&gt;noexcept&lt;/code&gt; 및 T가 아닌 &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; 에 &lt;code&gt;*this&lt;/code&gt; , 벡터 던지는 이동 생성자를 사용합니다. 던지면 보증이 면제되고 효과는 명시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="407149e5ef249263ab827511e7e341fc16d6fcf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T_i&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;F(T_i)&lt;/code&gt; is only considered if &lt;code&gt;std:remove_cvref_t&amp;lt;T&amp;gt;&lt;/code&gt; is also &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;T_i&lt;/code&gt; 가 있다 (아마도 이력서 자격) &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;F(T_i)&lt;/code&gt; 경우에만 고려 &lt;code&gt;std:remove_cvref_t&amp;lt;T&amp;gt;&lt;/code&gt; 또한 &lt;code&gt;bool&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="c4907a3ab559108aaf0ecc4b4c630266b6c2f7d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;V&lt;/code&gt; is not representable in &lt;code&gt;std::intmax_t&lt;/code&gt;, the program is ill-formed. If &lt;code&gt;Num&lt;/code&gt; or &lt;code&gt;Denom&lt;/code&gt; is not representable in &lt;code&gt;std::intmax_t&lt;/code&gt;, the program is ill-formed unless the implementation yields correct values for &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;U&lt;/code&gt; 또는 &lt;code&gt;V&lt;/code&gt; 가 에서 표현할 수없는 것입니다 &lt;code&gt;std::intmax_t&lt;/code&gt; , 프로그램이 잘못 형성된다. 경우 &lt;code&gt;Num&lt;/code&gt; 또는 &lt;code&gt;Denom&lt;/code&gt; 가 에서 표현할 수없는 것입니다 &lt;code&gt;std::intmax_t&lt;/code&gt; 구현에 대한 정확한 값을 산출하지 않는 한, 프로그램이 잘못 형성되는 &lt;code&gt;U&lt;/code&gt; 와 &lt;code&gt;V&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="1339288b4eceede884dbe475de639d7a8e96920b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; is not allocator-aware, the term is defined as if &lt;code&gt;A&lt;/code&gt; were &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, except that no allocator object needs to be created, and user-defined specializations of &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; are not instantiated.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 가 할당자를 인식하지 않는 경우 , 용어는 할당 자 오브젝트를 작성할 필요 가없고 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; 의 사용자 정의 전문화가 인스턴스화되지 않는 것을 제외하고 &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 인 것처럼 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="e215c6bfa230a8fadbd8fa567ff0d1dcc73d9d4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; is not allocator-aware, the term is defined as if &lt;code&gt;A&lt;/code&gt; were &lt;code&gt;std::allocator&amp;lt;T&amp;gt;&lt;/code&gt;, except that no allocator object needs to be created, and user-defined specializations of &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; are not instantiated.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 가 할당자를 인식하지 않는 경우 , 용어는 할당 자 오브젝트를 작성할 필요 가없고 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; 의 사용자 정의 전문화가 인스턴스화되지 않는 것을 제외하고 &lt;code&gt;A&lt;/code&gt; 가 &lt;code&gt;std::allocator&amp;lt;T&amp;gt;&lt;/code&gt; 인 것처럼 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="708924c7b6f5980aac166862125db725c9025582" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[s_first, s_last)&lt;/code&gt; is empty or if no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;[s_first, s_last)&lt;/code&gt; 비어 있거나 그런 순서가 발견되지 않는 경우, &lt;code&gt;last&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4de674a59bdc38a4524989e3aa936059b297e948" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[s_first, s_last)&lt;/code&gt; is empty, &lt;code&gt;first&lt;/code&gt; is returned. (since C++11)</source>
          <target state="translated">경우 &lt;code&gt;[s_first, s_last)&lt;/code&gt; 비어, &lt;code&gt;first&lt;/code&gt; 반환됩니다. (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="ac8a7837d00559195769abe3422b2d4b64b0803f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a &amp;lt; b&lt;/code&gt; and &lt;code&gt;b &amp;lt; c&lt;/code&gt; then &lt;code&gt;a &amp;lt; c&lt;/code&gt;</source>
          <target state="translated">만일 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 및 &lt;code&gt;b &amp;lt; c&lt;/code&gt; 다음 &lt;code&gt;a &amp;lt; c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0fbd3756fc442152ea5c157999e136ae32a5c4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a &amp;lt; b&lt;/code&gt; then &lt;code&gt;!(b &amp;lt; a)&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 후 &lt;code&gt;!(b &amp;lt; a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca13a23e17308315822746f838d58d67fdc10969" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;b == c&lt;/code&gt;, then &lt;code&gt;a == c&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;a == b&lt;/code&gt; 및 &lt;code&gt;b == c&lt;/code&gt; 다음 &lt;code&gt;a == c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57b477a3ad052ca87058c8d285998bd3826578b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt;, subsequent calls to the &lt;a href=&quot;operator()&quot;&gt;&lt;code&gt;operator()&lt;/code&gt;&lt;/a&gt; overload that does not accept a &lt;code&gt;param_type&lt;/code&gt; object will cause undefined behavior.</source>
          <target state="translated">&lt;code&gt;a == b&lt;/code&gt; 인 경우 &lt;code&gt;param_type&lt;/code&gt; 객체를 허용하지 않는 &lt;a href=&quot;operator()&quot;&gt; &lt;code&gt;operator()&lt;/code&gt; &lt;/a&gt; 오버로드 에 대한 후속 호출 은 정의되지 않은 동작을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="058ec9eda946d2f87a4c67ddd844abb0705335fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt;, then &lt;code&gt;b == a&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;a == b&lt;/code&gt; 다음 &lt;code&gt;b == a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e95c4991d153eb49fcdeb67a49f232435c188d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; compare equal (&lt;code&gt;a == b&lt;/code&gt; is contextually convertible to &lt;code&gt;true&lt;/code&gt;) then either they are both non-dereferenceable or &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; are references bound to the same object</source>
          <target state="translated">경우 와 &lt;code&gt;b&lt;/code&gt; 는 (동일한 비교 &lt;code&gt;a == b&lt;/code&gt; 문맥 적 컨버터블 &lt;code&gt;true&lt;/code&gt; 어느 후) 둘 다 비 dereferenceable되거나 &lt;code&gt;*a&lt;/code&gt; 및 &lt;code&gt;*b&lt;/code&gt; 동일한 객체에 바인딩 참조되고 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0965a7f22c182c2dc94b342ec734afedbfb197f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; and Stage 1 representation began with 0x or 0X, will pad after the x or X</source>
          <target state="translated">만약 &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; 및 1 개 단계 표현은 0X 또는 0X의 X 또는 X 후 의지 패드 시작</target>
        </trans-unit>
        <trans-unit id="55fb07ae63090e46c1b31757c60deb3993a02ead" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; and a sign character occurs in the representation, will pad after the sign</source>
          <target state="translated">만약 &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; 부호 후와 기호 문자가 표현에서 발생, 의지 패드</target>
        </trans-unit>
        <trans-unit id="df7f9cf85073b22f00c706bbf069fde1413ff653" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, will pad after</source>
          <target state="translated">만약 &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt; , 의지 패드 후</target>
        </trans-unit>
        <trans-unit id="efe26e828a675b79b7ef6061fde6939469a2c778" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::right&lt;/a&gt;&lt;/code&gt;, will pad before</source>
          <target state="translated">만약 &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::right&lt;/a&gt;&lt;/code&gt; , 의지 패드 전</target>
        </trans-unit>
        <trans-unit id="6ee5eea45cb84fb94f59a5848a1a90638eee5d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alignof(T)&lt;/code&gt; is not a valid expression, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;alignof(T)&lt;/code&gt; 유효한식이 아닌, 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="39035be25eaa7a5daa7ee9badf8db195c8f6f1c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 있습니다 &amp;plusmn; &amp;infin;, + &amp;infin;가 반환된다</target>
        </trans-unit>
        <trans-unit id="dc64028dd5e1343ad289a2a638ecad4eabe7dfc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 있다 &amp;plusmn; &amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 이 제기되고 구현 정의 된 값을 반환</target>
        </trans-unit>
        <trans-unit id="212c6a1d0fbeb2a948b299caf94641bec455cf7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned unmodified</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 있습니다 &amp;plusmn; &amp;infin;, 그것은 수정되지 않은 반환</target>
        </trans-unit>
        <trans-unit id="3af634b2f314cdb14e21e2e232aa0d848e98f5e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, and an unspecified value is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 있다 &amp;plusmn; &amp;infin;, 그것을 반환되고, 불특정 값이 저장된다 &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2926296a9d3ae122af29b30e2bff2458387535b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; &amp;plusmn; &amp;infin;이며, 그것은 수정되지 않은 반환</target>
        </trans-unit>
        <trans-unit id="dcb585953813ddfd53495aac0adc0c6028656a9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;&amp;infin;, or NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; &amp;plusmn; 0, &amp;plusmn; &amp;infin;, 또는 NaN의 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="97a7ce4796bb66aaa2d696b735ad8ca62a0d506b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; &amp;plusmn; 0, -&amp;infin; 반환 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4c925fdb14d37c5af0412f43389d6420fcbebc31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; &amp;plusmn; 0, 그것은 수정되지 않은 반환</target>
        </trans-unit>
        <trans-unit id="b763f3ae25fa4af1639d7559710e6c7dfb77bb58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified, and &lt;code&gt;0&lt;/code&gt; is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; &amp;plusmn; 0, 그것은이 수정되지 않은 반환되고, &lt;code&gt;0&lt;/code&gt; 에 저장됩니다 &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f109ac78880a8e0fd5ca3edc07d2d1bf947af61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; NaN의 인, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생하고 구현 정의 값이 반환된다</target>
        </trans-unit>
        <trans-unit id="40f86add69087dfb700cacff3b1846927488c73a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; NaN의 NaN이 반환된다</target>
        </trans-unit>
        <trans-unit id="5f68328ad47978170da252aebc348fd2a3ba01b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned, and an unspecified value is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; NaN의 NaN이 반환되고, 불특정 값이 저장된다 &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b0e2c569c27377f09ed2aa7f3f01ddd8ab82ed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; NaN의 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b47b8c75e53c96b45595a288fa682cfb71c94c2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a NaN, &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; NaN의이다, &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="103047025bbc6992cc2c0159391152d1cac0b073" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;std::lgamma(arg)&lt;/code&gt; is the logarithm of the factorial of &lt;code&gt;arg-1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 자연수이며, &lt;code&gt;std::lgamma(arg)&lt;/code&gt; 의 계승의 로그입니다 &lt;code&gt;arg-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d43e3c2f39b7c1f66e9428682a4d9539c507a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;std::tgamma(arg)&lt;/code&gt; is the factorial of &lt;code&gt;arg-1&lt;/code&gt;. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 자연수이며, &lt;code&gt;std::tgamma(arg)&lt;/code&gt; 중 하나입니다 계승 &lt;code&gt;arg-1&lt;/code&gt; . 인수가 충분히 작은 정수인 경우 많은 구현에서 정확한 정수 도메인 계승을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2b3d194b382b4cec828f1996e8820c92fc1bc82f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is infinite, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 무한대, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9e168df92098d4104c20f40ff2c56e9cb3e43970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not a floating-point number, the behavior is unspecified.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 가 부동 소수점 숫자가 아닌 경우 동작이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2804f0355d48777b9700b17ec3da3dcca55d9469" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not zero, infinite, or NaN, the value returned is exactly equivalent to &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;logb&quot;&gt;std::logb&lt;/a&gt;(arg))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 가 0, 무한 또는 NaN이 아닌 경우 반환되는 값은 &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;logb&quot;&gt;std::logb&lt;/a&gt;(arg))&lt;/code&gt; 와 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="210d2992bbf2bb7d542ddc01b1a18747c781302a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error may occur.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 0이거나 정수 0 미만이며, 기둥 오류가 발생할 수있다.</target>
        </trans-unit>
        <trans-unit id="05dafa4d596b7b6f157f2afaee02072f8d977259" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error or a domain error may occur.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 0이거나 정수 0 미만이며, 기둥 오류나 도메인 오류가 발생할 수있다.</target>
        </trans-unit>
        <trans-unit id="c39db051a1df2187c97bcf9b3a8feca13bc7aae3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, &lt;code&gt;FP_ILOGB0&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 제로, &lt;code&gt;FP_ILOGB0&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4481c06a081e138b96375d6a39a2024c3db3720a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, returns zero and stores zero in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;arg&lt;/code&gt; 제로, 0을 반환하고 매장에서 제로 &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="277ca8d97ddf64738fdbd1aa4e973cb1bc8ff33f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is true, the returned bitmask is suitable for matching characters without regard to their case.</source>
          <target state="translated">경우 &lt;code&gt;b&lt;/code&gt; 는 사실, 반환 된 비트 마스크는 경우에 관계없이 문자를 일치에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="bc2ce27f23e51347316eec1df499f96102e63b30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is &lt;code&gt;TIME_UTC&lt;/code&gt;, then.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 가 &lt;code&gt;TIME_UTC&lt;/code&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="39772be1360347ea75162c3cf41cc79a0690aefc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is finite and negative and &lt;code&gt;exp&lt;/code&gt; is finite and non-integer, a domain error occurs and a range error may occur.</source>
          <target state="translated">경우 &lt;code&gt;base&lt;/code&gt; 유한이고 음극 및 &lt;code&gt;exp&lt;/code&gt; 한정이 아닌 정수이고, 도메인 오류가 발생하여 다양한 오류가 발생할 수있다.</target>
        </trans-unit>
        <trans-unit id="fcb4bb9772be34cee0a2ea72f8a48a52aed0d515" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exp&lt;/code&gt; is negative, a domain error or a pole error may occur.</source>
          <target state="translated">경우 &lt;code&gt;base&lt;/code&gt; 0이고 &lt;code&gt;exp&lt;/code&gt; 음수 도메인 오류 또는 극 오류가 발생할 수있다.</target>
        </trans-unit>
        <trans-unit id="8cefb315066ca34b099a440410777215c4c88531" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exp&lt;/code&gt; is zero, a domain error may occur.</source>
          <target state="translated">경우 &lt;code&gt;base&lt;/code&gt; 0이고 &lt;code&gt;exp&lt;/code&gt; 제로, 도메인 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="735a9c2b9ccda41b360b2ccc955e4ce336eebbf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == 0&lt;/code&gt;, will use conversion specifier &lt;code&gt;%i&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;basefield == 0&lt;/code&gt; , 변환 지정자 사용합니다 &lt;code&gt;%i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72b1b1221364073e1a83ddb04c69595be539a496" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == hex &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%x&lt;/code&gt;</source>
          <target state="translated">경우, &lt;code&gt;basefield == hex &amp;amp;&amp;amp; !uppercase&lt;/code&gt; , 지정 변환을 사용 &lt;code&gt;%x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4a2fc2012f6b4718df5c8bbc44f6bc3ac7c622d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == hex&lt;/code&gt;, will use conversion specifier &lt;code&gt;%X&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;basefield == hex&lt;/code&gt; , 지정 변환을 사용 &lt;code&gt;%X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abc0fd7910d8386906f231979d946d3d6fcf720b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == oct&lt;/code&gt;, will use conversion specifier &lt;code&gt;%o&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;basefield == oct&lt;/code&gt; , 변환을 사용 지정자 &lt;code&gt;%o&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dafca5cc04b66da6cecdcb0541cbba62d4fe3fca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;begin == end&lt;/code&gt;, do nothing. Otherwise,</source>
          <target state="translated">경우 &lt;code&gt;begin == end&lt;/code&gt; , 아무것도하지 않습니다. 그렇지 않으면,</target>
        </trans-unit>
        <trans-unit id="bc82eb0dcae0fc58deeb2027018fdeadab408395" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; and &lt;code&gt;bool(b &amp;lt; c)&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;bool(a &amp;lt; c)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">경우 &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; 및 &lt;code&gt;bool(b &amp;lt; c)&lt;/code&gt; 모두 &lt;code&gt;true&lt;/code&gt; 다음 &lt;code&gt;bool(a &amp;lt; c)&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="0c3b57cf400e324fc93a37880e317b6a3f4e7284" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boolalpha != 0&lt;/code&gt; obtains &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).truename()&lt;/code&gt; if &lt;code&gt;v == true&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; if &lt;code&gt;v == false&lt;/code&gt;, and outputs each successive character &lt;code&gt;c&lt;/code&gt; of that string to &lt;code&gt;out&lt;/code&gt; with &lt;code&gt;*out++ = c&lt;/code&gt;. No further processing is done in this case, the function returns &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;boolalpha != 0&lt;/code&gt; 얻 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).truename()&lt;/code&gt; 의 경우 &lt;code&gt;v == true&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; 의 경우 &lt;code&gt;v == false&lt;/code&gt; 하고 각각의 연속적인 문자의 출력 &lt;code&gt;c&lt;/code&gt; 에 해당 문자열을 &lt;code&gt;out&lt;/code&gt; 으로 &lt;code&gt;*out++ = c&lt;/code&gt; . 이 경우 더 이상 처리하지 않고 함수가 반환 &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="209116e8fd40fdecd41f59a58ba5cba05cc96e2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boolalpha == 0&lt;/code&gt;, then converts &lt;code&gt;v&lt;/code&gt; to type &lt;code&gt;int&lt;/code&gt; and performs integer output.</source>
          <target state="translated">&lt;code&gt;boolalpha == 0&lt;/code&gt; 인 경우 &lt;code&gt;v&lt;/code&gt; 를 &lt;code&gt;int&lt;/code&gt; 유형으로 변환 하고 정수 출력을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="701f5d02367a24c659b0e907a89da5f3ee588ad7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is a null pointer, resizes the internal buffer to &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 널 포인터에 내부 버퍼 크기를 조절 &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb7a30a4993475e7a73929ac360a9b27b0b3f966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not a null pointer, instructs the stream to use the user-provided buffer of size &lt;code&gt;size&lt;/code&gt; beginning at &lt;code&gt;buffer&lt;/code&gt;. The stream must be closed (with &lt;code&gt;fclose&lt;/code&gt;) before the &lt;a href=&quot;../../language/lifetime&quot;&gt;lifetime&lt;/a&gt; of the array pointed to by &lt;code&gt;buffer&lt;/code&gt; ends. The contents of the array after a successful call to &lt;code&gt;setvbuf&lt;/code&gt; are indeterminate and any attempt to use it is undefined behavior.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; NULL 포인터 아니라, 크기의 사용자 제공 버퍼 사용하도록 지시 스트림 &lt;code&gt;size&lt;/code&gt; 에서 시작 &lt;code&gt;buffer&lt;/code&gt; . &lt;code&gt;buffer&lt;/code&gt; 가 가리키는 배열 의 &lt;a href=&quot;../../language/lifetime&quot;&gt;수명&lt;/a&gt; 이 끝나기 전에 스트림을 닫아야합니다 ( &lt;code&gt;fclose&lt;/code&gt; 사용 ) . &lt;code&gt;setvbuf&lt;/code&gt; 를 성공적으로 호출 한 후 배열의 내용 은 불확실하며이를 사용하려는 시도는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="a4aa2a51ab02bfef78d16d2394217fe58c759175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../c&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; 가 null이 아닌 경우 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../c&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fda3355283db2eca141b2739a1e7b6dba9c66231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt;, which turns off buffering.</source>
          <target state="translated">&lt;code&gt;buffer&lt;/code&gt; 가 null 인 경우 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt; 와 같 으며 버퍼링이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="4dd6d32ffac07b48320fad08007c3cbc378f1ccf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c16&lt;/code&gt; is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="translated">&lt;code&gt;c16&lt;/code&gt; 이 와이드 문자의 16 비트 표현에서 최종 코드 단위가 아닌 경우 &lt;code&gt;s&lt;/code&gt; 가 가리키는 배열에 쓰지 않고 &lt;code&gt;*ps&lt;/code&gt; 만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="43266a7e25edde20659efab6eb44b99980e95ed3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is invalid (does not contribute to a sequence of &lt;code&gt;char8_t&lt;/code&gt; corresponding to a valid multibyte character), the value of the macro &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; is stored in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;(size_t)(-1)&lt;/code&gt; is returned, and the conversion state is unspecified.</source>
          <target state="translated">경우 &lt;code&gt;c8&lt;/code&gt; 무효 (시퀀스에 기여하지 않는 &lt;code&gt;char8_t&lt;/code&gt; 유효한 다중 바이트 문자에 대응), 매크로 값 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; 가 저장된다 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 를 , &lt;code&gt;(size_t)(-1)&lt;/code&gt; 반환하고, 전환 상태는 지정되지 않는다.</target>
        </trans-unit>
        <trans-unit id="120e5087c8f2519bdf8d8babc3ba6bf88d5575b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is not the final UTF-8 code unit in a representation of a code point, the function does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="translated">경우 &lt;code&gt;c8&lt;/code&gt; 코드 포인트의 표현의 최종 UTF-8 코드 부 아니다 의해 배열이 가리키는 함수는 쓰지 않는다 &lt;code&gt;s&lt;/code&gt; 만 &lt;code&gt;*ps&lt;/code&gt; 갱신된다.</target>
        </trans-unit>
        <trans-unit id="e2b9d98d74c329c422daa370d8349ea12b339fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is the null character &lt;code&gt;u8'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">경우 &lt;code&gt;c8&lt;/code&gt; 널 문자이다 &lt;code&gt;u8'\0'&lt;/code&gt; 널 바이트는 초기 변속 상태 전환 상태 파라미터 복원하는데 필요한 임의의 시프트 시퀀스 저장 앞에 &lt;code&gt;*ps&lt;/code&gt; 초기 이동 상태를 나타 내기 위해 갱신된다.</target>
        </trans-unit>
        <trans-unit id="9b496091b9a18ce0c88a971b0705f925544a2dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is the end-of-file indicator (&lt;code&gt;traits::eq_int_type(c,traits::eof()) == true&lt;/code&gt;), then there is no character to append. The function does nothing and returns an unspecified value other than &lt;code&gt;traits::eof()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 파일 끝 지표 ( &lt;code&gt;traits::eq_int_type(c,traits::eof()) == true&lt;/code&gt; ), 다음 추가하려면 어떤 문자가 없습니다. 이 함수는 아무것도하지 않고 &lt;code&gt;traits::eof()&lt;/code&gt; 이외의 지정되지 않은 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d45180121f410762cee0225f3231172974d6d196" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c==&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, returns some value other than &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;. Otherwise, returns &lt;code&gt;(unsigned char)(c)&lt;/code&gt; on success, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">경우 &lt;code&gt;c==&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; , 이외의 값 반환 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 를 . 그렇지 않으면 성공하면 &lt;code&gt;(unsigned char)(c)&lt;/code&gt; , 실패 하면 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6b94f81efb67c916047d31de0fff924013dd49d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, pushes the character &lt;code&gt;ch&lt;/code&gt; (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner than subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that character. The external device associated with the stream is not modified.</source>
          <target state="translated">경우 &lt;code&gt;ch&lt;/code&gt; 동일하지 않는 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 는 , 문자 푸시 &lt;code&gt;ch&lt;/code&gt; (재 해석으로 &lt;code&gt;unsigned char&lt;/code&gt; 스트림과 연관된 입력 버퍼) &lt;code&gt;stream&lt;/code&gt; 에서 후속 판독 동작보다 이와 같이 &lt;code&gt;stream&lt;/code&gt; 이 문자를 검색하는 것이다. 스트림과 관련된 외부 장치는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d30189f2e98ef3c7b1c57bfc6a779e2cf97492e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;WEOF&lt;/code&gt;, pushes the wide character &lt;code&gt;ch&lt;/code&gt; into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner than subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that wide character. The external device associated with the stream is not modified.</source>
          <target state="translated">경우 &lt;code&gt;ch&lt;/code&gt; 같지 않음 &lt;code&gt;WEOF&lt;/code&gt; 는 , 와이드 문자 푸시 &lt;code&gt;ch&lt;/code&gt; 입력으로는 스트림과 관련된 완충액을 &lt;code&gt;stream&lt;/code&gt; 에서 후속 판독 동작보다 이와 같이 &lt;code&gt;stream&lt;/code&gt; 이 넓은 문자를 검색한다. 스트림과 관련된 외부 장치는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9dcd2adfbf165acf0dba129b8151a07f338a6fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">경우 &lt;code&gt;ch&lt;/code&gt; 동일 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 작업이 실패하고 스트림은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a114914a7e8a31a9eee7e4f7ac5bc1b503807f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;WEOF&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">경우 &lt;code&gt;ch&lt;/code&gt; 동일 &lt;code&gt;WEOF&lt;/code&gt; 을 작업이 실패하고 스트림은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb3d10516cbec80af986272f9e48f6efa09dd2d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;command&lt;/code&gt; is a null pointer, checks if the host environment has a command processor and returns a nonzero value if and only if the command processor exists.</source>
          <target state="translated">경우 &lt;code&gt;command&lt;/code&gt; 널 포인터이고 명령 프로세서가 존재하는 경우에만하는 경우 호스트 환경 명령 프로세서를 가지고 있으며, 체크하면 제로가 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="85aea9f0ae028fe2640a672d5e277a7841d76dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp(a,b)==true&lt;/code&gt; then &lt;code&gt;comp(b,a)==false&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;comp(a,b)==true&lt;/code&gt; 다음 &lt;code&gt;comp(b,a)==false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f7a074b5aca822ff123427c78123491180762d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp&lt;/code&gt; indicates two elements as equivalent, their order is unspecified.</source>
          <target state="translated">&lt;code&gt;comp&lt;/code&gt; 가 두 요소를 동등한 것으로 표시 하면 순서는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0175bc0a73471ec1cd27562640c1d6735174424d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;copy_options::directories_only&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, does nothing</source>
          <target state="translated">경우 &lt;code&gt;copy_options::directories_only&lt;/code&gt; 에 존재하는 &lt;code&gt;options&lt;/code&gt; 아무것도하지 않는다,</target>
        </trans-unit>
        <trans-unit id="815d288d8f8c46dcfd1ed95e2c2d74b9bc1cb888" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;copy_options::skip_symlink&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, does nothing.</source>
          <target state="translated">경우 &lt;code&gt;copy_options::skip_symlink&lt;/code&gt; 에 존재하는 &lt;code&gt;options&lt;/code&gt; , 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18daaf9d57908b8b11d5a5ce74779de8f547638e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt;, then &lt;code&gt;dest&lt;/code&gt; is allowed to be a null pointer.</source>
          <target state="translated">경우 &lt;code&gt;count&lt;/code&gt; 있다 &lt;code&gt;​0​&lt;/code&gt; , 다음 &lt;code&gt;dest&lt;/code&gt; 널 포인터로 할 수있다.</target>
        </trans-unit>
        <trans-unit id="6e56b4ab0e5150566fb64d55ba8a1e8a4d01e821" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting character array is not null-terminated.</source>
          <target state="translated">경우 &lt;code&gt;count&lt;/code&gt; 전체 문자열의 앞에 도달 &lt;code&gt;src&lt;/code&gt; 복사 된, 결과 문자 배열이 null 종료하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3896321b9a85e601977b36e1c20e47272d800cfd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting wide character array is not null-terminated.</source>
          <target state="translated">전체 문자열 &lt;code&gt;src&lt;/code&gt; 전에 &lt;code&gt;count&lt;/code&gt; 에 도달 하면 복사 된, 결과 와이드 문자 배열이 null 종료하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06245894aa3eefe9ed953846b24765091a53209d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero or negative, &lt;code&gt;first&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;count&lt;/code&gt; 제로 또는 부의 경우, &lt;code&gt;first&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4f336d1b1de719a5985455a6d30969f36f1d4096" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, strings are considered equal.</source>
          <target state="translated">경우에 &lt;code&gt;count&lt;/code&gt; 제로 스트링은 동일한 것으로 간주된다.</target>
        </trans-unit>
        <trans-unit id="3f2e6aaeeb8e09e4e7d2914ab4ee68da289d48f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function does nothing.</source>
          <target state="translated">경우 &lt;code&gt;count&lt;/code&gt; 제로,이 함수는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ad8eda07b3297819cd8064cc3589079cc052fd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function returns a null pointer.</source>
          <target state="translated">경우 &lt;code&gt;count&lt;/code&gt; 제로, 함수는 널 포인터를 반환한다.</target>
        </trans-unit>
        <trans-unit id="57a3e0d836eef087c17311ab2dbe908db83c04f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d_&lt;/code&gt; is a member variable holding the duration (i.e., time since epoch) of this &lt;code&gt;time_point&lt;/code&gt; object,</source>
          <target state="translated">&lt;code&gt;d_&lt;/code&gt; 가이 &lt;code&gt;time_point&lt;/code&gt; 객체 의 지속 시간 (에포크 이후의 시간)을 보유하는 멤버 변수 인 경우 ,</target>
        </trans-unit>
        <trans-unit id="3bbc1c66920a4038f904392405e8bb0f323da835" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;del&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it is assumed that the array was allocated with &lt;code&gt;new[]&lt;/code&gt;, and the destructor of this facet will call &lt;code&gt;delete[] tbl&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;del&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 배열에 할당 된 것으로 가정 &lt;code&gt;new[]&lt;/code&gt; ,이면의 소멸자 호출 &lt;code&gt;delete[] tbl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f2fea471de8b3d0628642cbd7cd79e507ef237c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::basic_ios::cur&lt;/a&gt;&lt;/code&gt; or the offset &lt;code&gt;off&lt;/code&gt; is not &lt;code&gt;​0​&lt;/code&gt;, and the most resent operation done on this filebuf object was output (that is, either the put buffer is not empty, or the most recently called function was &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;), then calls &lt;code&gt;std::codecvt::unshift&lt;/code&gt; to determine the unshift sequence necessary, and writes that sequence to the file by calling &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;dir&lt;/code&gt; 되지 않는 &lt;code&gt;&lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::basic_ios::cur&lt;/a&gt;&lt;/code&gt; 또는 오프셋 &lt;code&gt;off&lt;/code&gt; 아닌 &lt;code&gt;​0​&lt;/code&gt; ,이 filebuf 개체에 수행 된 대부분의 재전송 작업은 그 어느 풋 버퍼가 비어, 또는 가장 최근에 호출되지 않는다 (출력했다 함수는 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 였다 가 &lt;code&gt;std::codecvt::unshift&lt;/code&gt; 를 호출 하여 필요한 언 시프트 시퀀스를 결정하고 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 를 호출하여 해당 시퀀스를 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="57e5dcca2d6fb73331af4ef11d3a2dcb0d17f4d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a class member access expression (&lt;code&gt;e1.e2&lt;/code&gt; or &lt;code&gt;e1-&amp;gt;e2&lt;/code&gt;), the potential results of the object expression e1 is included in the set.</source>
          <target state="translated">경우 &lt;code&gt;e&lt;/code&gt; 는 클래스 멤버 액세스 식이다 ( &lt;code&gt;e1.e2&lt;/code&gt; 또는 &lt;code&gt;e1-&amp;gt;e2&lt;/code&gt; ), 오브젝트 식 E1의 전위 결과는 집합에 포함된다.</target>
        </trans-unit>
        <trans-unit id="a611f1da12dbf6983879f4306f9df44390150021" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a comma expression (&lt;code&gt;e1,e2&lt;/code&gt;), the potential results of &lt;code&gt;e2&lt;/code&gt; are in the set of potential results</source>
          <target state="translated">경우 &lt;code&gt;e&lt;/code&gt; 는 콤마 식이다 ( &lt;code&gt;e1,e2&lt;/code&gt; )의 전위 결과 &lt;code&gt;e2&lt;/code&gt; 잠재적 인 결과의 세트에</target>
        </trans-unit>
        <trans-unit id="b272bd28e80dd2ac2a3667aaa761508a1896965d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a glvalue conditional expression (&lt;code&gt;e1?e2:e3&lt;/code&gt;, where e2 and e3 are glvalues), the union of the potential results of &lt;code&gt;e2&lt;/code&gt; and &lt;code&gt;e3&lt;/code&gt; are both included in the set.</source>
          <target state="translated">경우 &lt;code&gt;e&lt;/code&gt; 는 glvalue 조건식이다 ( &lt;code&gt;e1?e2:e3&lt;/code&gt; E2 및 E3는 glvalues 곳)의 잠재적 인 결과의 결합 &lt;code&gt;e2&lt;/code&gt; 및 &lt;code&gt;e3&lt;/code&gt; 두 집합에 포함된다.</target>
        </trans-unit>
        <trans-unit id="2d9fdf08ba2dfa789e82b39c3610d8ef047043a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a pointer-to-member access expression (&lt;code&gt;e1.*e2&lt;/code&gt; or &lt;code&gt;e1-&amp;gt;*e2&lt;/code&gt;) whose second operand is a constant expression, the potential results of the object expression e1 are included in the set</source>
          <target state="translated">경우 &lt;code&gt;e&lt;/code&gt; 는 포인터 투 로타리 식이다 ( &lt;code&gt;e1.*e2&lt;/code&gt; 또는 &lt;code&gt;e1-&amp;gt;*e2&lt;/code&gt; ) 그 두 번째 오퍼랜드 상수 식 대물 식 (E1)의 전위 인 결과 집합에 포함</target>
        </trans-unit>
        <trans-unit id="136ae657a0856415b88b024f787e7474c99acad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an &lt;a href=&quot;expressions&quot;&gt;id-expression&lt;/a&gt;, the expression &lt;code&gt;e&lt;/code&gt; is its only potential result</source>
          <target state="translated">경우 &lt;code&gt;e&lt;/code&gt; 입니다 &lt;a href=&quot;expressions&quot;&gt;ID-표현&lt;/a&gt; , 식 &lt;code&gt;e&lt;/code&gt; 유일한 잠재적 인 결과입니다</target>
        </trans-unit>
        <trans-unit id="6a6dd1d96309aaabbc396100ce7a188d685eba16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an array subscript expression (&lt;code&gt;e1[e2]&lt;/code&gt;) where one of the operands is an array, the potential results of that operand is included in the set</source>
          <target state="translated">경우 &lt;code&gt;e&lt;/code&gt; 는 배열 첨자 표현은 ( &lt;code&gt;e1[e2]&lt;/code&gt; ) 피연산자 중 하나가 배열이고, 그 연산 결과의 전위는 세트에 포함</target>
        </trans-unit>
        <trans-unit id="a6876c60a5df4d3a02319ae4acfd99744e4aad8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an expression in parentheses (&lt;code&gt;(e1)&lt;/code&gt;), the potential results of &lt;code&gt;e1&lt;/code&gt; are included in the set</source>
          <target state="translated">경우 &lt;code&gt;e&lt;/code&gt; 는 괄호 표현이다 ( &lt;code&gt;(e1)&lt;/code&gt; ) 결과의 전위 &lt;code&gt;e1&lt;/code&gt; 집합에 포함</target>
        </trans-unit>
        <trans-unit id="af0a58bc0809e3f4c48c7935533640bb84b6d5da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;eofbit&lt;/code&gt; is set on the stream prior to the call, the construction of the sentry object will set &lt;code&gt;failbit&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;eofbit&lt;/code&gt; 를 호출하기 전에 스트림에 설정되어 보초 개체의 건축 설정됩니다 &lt;code&gt;failbit&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="ce0473bb777b78c63cd5012d3ff7b7e662f591ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;equiv(a,b)==true&lt;/code&gt; and &lt;code&gt;equiv(b,c)==true&lt;/code&gt;, then &lt;code&gt;equiv(a,c)==true&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;equiv(a,b)==true&lt;/code&gt; 과 &lt;code&gt;equiv(b,c)==true&lt;/code&gt; 다음 &lt;code&gt;equiv(a,c)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ba38a247100280f8e41691728cc66000be9e271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;equiv(a,b)==true&lt;/code&gt;, then &lt;code&gt;equiv(b,a)==true&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;equiv(a,b)==true&lt;/code&gt; 다음 &lt;code&gt;equiv(b,a)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="007bad278d6b4bc6d719829636a93a4a9c5a31b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt;, an implementation-defined status indicating successful termination is returned to the host environment. If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt;, an implementation-defined status, indicating</source>
          <target state="translated">경우 &lt;code&gt;exit_code&lt;/code&gt; 가 있다 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; , 성공적인 종료를 나타내는 구현 정의 상태는 호스트 환경에 반환됩니다. &lt;code&gt;exit_code&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt; 인 경우 나타내는 구현 정의 상태,</target>
        </trans-unit>
        <trans-unit id="f710623c293fe447df3d92556a487868ef46a327" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exp&lt;/code&gt; is 0, then &lt;code&gt;x&lt;/code&gt; is returned, unmodified</source>
          <target state="translated">경우 &lt;code&gt;exp&lt;/code&gt; 0, 다음 &lt;code&gt;x&lt;/code&gt; 수정되지 않은 반환</target>
        </trans-unit>
        <trans-unit id="fb1e695a18ffeb815e38e42b92e43f2bd57d73e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is a &lt;a href=&quot;../../language/pointer#Pointers_to_member_functions&quot;&gt;pointer to member function&lt;/a&gt; of class &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 가 클래스 &lt;code&gt;T&lt;/code&gt; 의&lt;a href=&quot;../../language/pointer#Pointers_to_member_functions&quot;&gt;멤버 함수&lt;/a&gt; 에 대한 포인터 인 경우 :</target>
        </trans-unit>
        <trans-unit id="4837b4b3957d1d06787bdcfc0793edea20847145" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fail()==true&lt;/code&gt;, returns &lt;code&gt;pos_type(-1)&lt;/code&gt;. Otherwise, returns &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;fail()==true&lt;/code&gt; , 반환 &lt;code&gt;pos_type(-1)&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d0463e8b7f222245f189b3d034b86d7447da42d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;failed()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, inserts the character &lt;code&gt;c&lt;/code&gt; into the associated stream buffer by calling &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt;, where &lt;code&gt;pbuf&lt;/code&gt; is the private member of type &lt;code&gt;streambuf_type*&lt;/code&gt;. Otherwise, does nothing.</source>
          <target state="translated">&lt;code&gt;failed()&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; 를 호출 하여 문자 &lt;code&gt;c&lt;/code&gt; 를 연관된 스트림 버퍼에 삽입합니다 . 여기서 &lt;code&gt;pbuf&lt;/code&gt; 는 &lt;code&gt;streambuf_type*&lt;/code&gt; 유형의 개인 멤버입니다 . 그렇지 않으면 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5400983ef77493ea136e60df816cfe45d2e66859" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;first == last&lt;/code&gt; or &lt;code&gt;first1 == last1&lt;/code&gt;, &lt;code&gt;init&lt;/code&gt; is returned, unmodified.</source>
          <target state="translated">경우 &lt;code&gt;first == last&lt;/code&gt; 또는 &lt;code&gt;first1 == last1&lt;/code&gt; , &lt;code&gt;init&lt;/code&gt; 수정되지 않은 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4e003924877b9a466eeb7d707612a5f3ab0c7f79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;first == last&lt;/code&gt;, this function has no effect and will merely return &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;first == last&lt;/code&gt; ,이 기능이 적용되지 않습니다 단순히 반환합니다 &lt;code&gt;d_first&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3800b7d6b3d5edad60afa41413956ee387d068de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_first_only&lt;/a&gt;&lt;/code&gt;, only the first match is replaced.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_first_only&lt;/a&gt;&lt;/code&gt; 가 포함 된 경우 첫 번째 일치 항목 만 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="8971b9fbad479977ae5fffcd5b1ef85254f363f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_no_copy&lt;/a&gt;&lt;/code&gt;, the non-matched subsequences are not copied into &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 포함 &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_no_copy&lt;/a&gt;&lt;/code&gt; , 비 일치하는 서브 시퀀스에 복사되지 않습니다 &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afcd9815060753d019811a5dfbfcd47253700f41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;) &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%a&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;) &amp;amp;&amp;amp; !uppercase&lt;/code&gt; , 변환을 사용 지정자 &lt;code&gt;%a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a696cef7fabb97b740bacedd6f505fc04deb3ca2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt;, will use conversion specifier &lt;code&gt;%A&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt; 변환 지정자 사용, &lt;code&gt;%A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7df1b6bc3f01af8b0302af4f0306bba39947fde8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;&lt;/code&gt;, will use conversion specifier &lt;code&gt;%f&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;&lt;/code&gt; , 변환을 사용 지정자 &lt;code&gt;%f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea893d1e69d7bcb42e6183b8b13629895919af1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt; &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%e&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt; &amp;amp;&amp;amp; !uppercase&lt;/code&gt; , 사용 변환 지정자 &lt;code&gt;%e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="479647145b4986f0d7bf8bafb84a155b21c78b60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;&lt;/code&gt;, will use conversion specifier &lt;code&gt;%E&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;&lt;/code&gt; , 사용할 변환 지정자 &lt;code&gt;%E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="305a95ccb899fefeb95b7edf07cbcae48fc8c6b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are the same file as determined by &lt;code&gt;&lt;a href=&quot;equivalent&quot;&gt;std::filesystem::equivalent&lt;/a&gt;&lt;/code&gt;, reports an error</source>
          <target state="translated">경우 &lt;code&gt;from&lt;/code&gt; 와 &lt;code&gt;to&lt;/code&gt; 결정에 따라 같은 파일입니다 &lt;code&gt;&lt;a href=&quot;equivalent&quot;&gt;std::filesystem::equivalent&lt;/a&gt;&lt;/code&gt; 오류를보고</target>
        </trans-unit>
        <trans-unit id="5981efb911c3a456cb02b7dc34b28f6d5a818dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; does not exist, reports an error.</source>
          <target state="translated">경우 &lt;code&gt;from&lt;/code&gt; 존재하지 않는 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="433f5d85237ac4e480b0d07ce3da6cac640403a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; is a directory, but &lt;code&gt;to&lt;/code&gt; is a regular file, reports an error</source>
          <target state="translated">경우 &lt;code&gt;from&lt;/code&gt; 디렉토리이지만, &lt;code&gt;to&lt;/code&gt; 일반 파일이며, 오류를보고</target>
        </trans-unit>
        <trans-unit id="77fcdb49cb08776e21d9d86e94d339ee3a5b233d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; is a symbolic link, then</source>
          <target state="translated">만약 &lt;code&gt;from&lt;/code&gt; 다음 심볼릭 링크입니다</target>
        </trans-unit>
        <trans-unit id="d60be77b3f79d2ace2289a720e9b7a98142b9a06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from_stream&lt;/code&gt; fails to parse everything specified by the format string, or if insufficient information is parsed to specify a complete result, or if parsing discloses contradictory information, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called.</source>
          <target state="translated">경우 &lt;code&gt;from_stream&lt;/code&gt; 은 형식 문자열에 의해 지정된 모든 구문 분석에 실패 충분한 정보를 완전한 결과를 지정하는 구문 분석하는 경우, 또는 경우, 또는 호에게 모순 된 정보를 분석 &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="a9f4f8c173e4f387e8d6984eea14c0c97052549e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from_stream&lt;/code&gt; fails to parse everything specified by the format string, or if insufficient information is parsed to specify a complete result, or if parsing discloses contradictory information, &lt;code&gt;is.setstate(&lt;a href=&quot;../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called.</source>
          <target state="translated">경우 &lt;code&gt;from_stream&lt;/code&gt; 은 형식 문자열에 의해 지정된 모든 구문 분석에 실패 충분한 정보를 완전한 결과를 지정하는 구문 분석하는 경우, 또는 경우, 또는 호에게 모순 된 정보를 분석 &lt;code&gt;is.setstate(&lt;a href=&quot;../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="a0b2248b896ee027fabe63c433625c357d75a244" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;g&lt;/code&gt; is volatile-qualified (i.e., its cv-qualifiers are either &lt;code&gt;volatile&lt;/code&gt; or &lt;code&gt;const volatile&lt;/code&gt;), the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;g&lt;/code&gt; 는 휘발성 자격 (즉, 자사의 이력서 - 예선 중 하나입니다 &lt;code&gt;volatile&lt;/code&gt; 또는 &lt;code&gt;const volatile&lt;/code&gt; , 동작이 정의되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="ec3b72193abe9aedc79922cd71ce4f681ce5bb3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get() == nullptr&lt;/code&gt; there are no effects. Otherwise, the owned object is destroyed via &lt;a href=&quot;get_deleter&quot;&gt;&lt;code&gt;get_deleter()&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;get&quot;&gt;&lt;code&gt;(get())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;code&gt;get() == nullptr&lt;/code&gt; 아무런 효과가 없습니다. 그렇지 않으면, 소유 한 객체는 &lt;a href=&quot;get_deleter&quot;&gt; &lt;code&gt;get_deleter()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;get&quot;&gt; &lt;code&gt;(get())&lt;/code&gt; &lt;/a&gt; 통해 파괴됩니다 .</target>
        </trans-unit>
        <trans-unit id="8cfb0ef527264e13542d3e75250bf692fe5adcb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;good() == true&lt;/code&gt;, returns the next character as obtained by &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;good() == true&lt;/code&gt; 인 경우 &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt; 로 얻은 다음 문자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d798bdc7a53000bbd5ee8924ceef0cc19c68c7ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;has_relative_path()&lt;/code&gt; returns false, the result is a copy of &lt;code&gt;*this&lt;/code&gt; Otherwise, the result is a path whose generic format pathname is the longest prefix of the generic format pathname of &lt;code&gt;*this&lt;/code&gt; that produces one fewer element in its iteration.</source>
          <target state="translated">경우 &lt;code&gt;has_relative_path()&lt;/code&gt; false를 돌려, 결과의 사본 &lt;code&gt;*this&lt;/code&gt; 그렇지 않으면 결과는 누구의 일반적인 형식 경로의 일반적인 형식 경로의 가장 긴 접두사 경로입니다 &lt;code&gt;*this&lt;/code&gt; 그것의 반복 한 적은 요소를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3dea94fff00231911d476ee1bc47f5dd6bbd2db9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i == j&lt;/code&gt; and &lt;code&gt;(i, j)&lt;/code&gt; is in the domain of &lt;code&gt;==&lt;/code&gt; then this is equivalent to &lt;code&gt;*j&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;i == j&lt;/code&gt; 및 &lt;code&gt;(i, j)&lt;/code&gt; 의 도메인에 &lt;code&gt;==&lt;/code&gt; 다음이 동등 &lt;code&gt;*j&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13008673cd8597a506cf3daa8b3ec63d08a1c87c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imbue()&lt;/code&gt; has been never called for this object, then the global locale at the time of the call is returned. Otherwise, the locale passed to the last call to &lt;code&gt;imbue()&lt;/code&gt; is returned.</source>
          <target state="translated">이 객체에 대해 &lt;code&gt;imbue()&lt;/code&gt; 를 호출 한 적이 없으면 호출시 전역 로캘이 반환됩니다. 그렇지 않으면 &lt;code&gt;imbue()&lt;/code&gt; 에 대한 마지막 호출로 전달 된 로케일 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9f7a6d2892cb99819b50181c82d0ac33627baaf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in==end&lt;/code&gt;, Stage 2 is terminated immediately, no further characters are extracted</source>
          <target state="translated">&lt;code&gt;in==end&lt;/code&gt; 인 경우 2 단계가 즉시 종료되고 더 이상 문자가 추출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f94d93ea046597d6595e925ae9e6a64c0253802b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index() == 0&lt;/code&gt;, returns a &lt;code&gt;sys_days&lt;/code&gt; that represents the date 7 days prior to the first &lt;code&gt;weekday()&lt;/code&gt; of the year and month.</source>
          <target state="translated">경우 &lt;code&gt;index() == 0&lt;/code&gt; 하는 반환 &lt;code&gt;sys_days&lt;/code&gt; 7일 전에 첫째로 날짜 표현 &lt;code&gt;weekday()&lt;/code&gt; 연도와 달을.</target>
        </trans-unit>
        <trans-unit id="b47ea618b12678469ff2fd08038755240643eae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is.good()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, calls &lt;code&gt;is.setstate(failbit)&lt;/code&gt;(since c++11) and returns. Otherwise, if &lt;code&gt;is.tie()&lt;/code&gt; is not a null pointer, calls &lt;code&gt;is.tie()-&amp;gt;flush()&lt;/code&gt; to synchronize the output sequence with external streams. This call can be suppressed if the put area of &lt;code&gt;is.tie()&lt;/code&gt; is empty. The implementation may defer the call to &lt;code&gt;flush&lt;/code&gt; until a call of &lt;code&gt;is.rdbuf()-&amp;gt;underflow()&lt;/code&gt; occurs. If no such call occurs before the sentry object is destroyed, it may be eliminated entirely.</source>
          <target state="translated">&lt;code&gt;is.good()&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 인 경우 is.setstate ( &lt;code&gt;is.setstate(failbit)&lt;/code&gt; (c ++ 11부터 )를 호출 하고 리턴합니다. 그렇지 않으면 &lt;code&gt;is.tie()&lt;/code&gt; 가 널 포인터가 아닌 경우 &lt;code&gt;is.tie()-&amp;gt;flush()&lt;/code&gt; 를 호출 하여 출력 시퀀스를 외부 스트림과 동기화하십시오. &lt;code&gt;is.tie()&lt;/code&gt; 의 put 영역 이 비어 있으면이 호출을 억제 할 수 있습니다 . 구현은 &lt;code&gt;is.rdbuf()-&amp;gt;underflow()&lt;/code&gt; 호출이 발생할 때까지 &lt;code&gt;flush&lt;/code&gt; 호출을 연기 할 수 있습니다 . 센트리 객체가 파괴되기 전에 이러한 호출이 발생하지 않으면 완전히 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbdd95c99548814da982d8d20409a38ef7943968" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isfinite(t) &amp;amp;&amp;amp; a == b&lt;/code&gt;, the result is equal to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;isfinite(t) &amp;amp;&amp;amp; a == b&lt;/code&gt; , 결과는 동일하다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a92eff5b31f025e8461e121aee4c206aa32fb17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isfinite(t) || (!isnan(t) &amp;amp;&amp;amp; b-a&amp;nbsp;!= 0)&lt;/code&gt;, the result is not &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;isfinite(t) || (!isnan(t) &amp;amp;&amp;amp; b-a&amp;nbsp;!= 0)&lt;/code&gt; 이면 결과는 &lt;code&gt;NaN&lt;/code&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="4c5e504a6bd1ecb25be6b144ecd53c96279275a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;islower&lt;/code&gt; returns a nonzero value, it is guaranteed that &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, and &lt;code&gt;isspace&lt;/code&gt; return zero for the same character in the same C locale.</source>
          <target state="translated">경우 &lt;code&gt;islower&lt;/code&gt; 와는 제로가 아닌 값을 반환, 그것은 보장된다 &lt;code&gt;iscntrl&lt;/code&gt; , &lt;code&gt;isdigit&lt;/code&gt; 에 , &lt;code&gt;ispunct&lt;/code&gt; 및 &lt;code&gt;isspace&lt;/code&gt; 와의 같은 C 로케일에서 동일한 문자에 대해 반환 제로.</target>
        </trans-unit>
        <trans-unit id="eeb4299451f00a6bbc3cc54d9636ef15cfbc4d81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isupper&lt;/code&gt; returns a nonzero value, it is guaranteed that &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, and &lt;code&gt;isspace&lt;/code&gt; return zero for the same character in the same C locale.</source>
          <target state="translated">경우 &lt;code&gt;isupper&lt;/code&gt; 반환이 아닌 값, 그것은 보장된다 &lt;code&gt;iscntrl&lt;/code&gt; , &lt;code&gt;isdigit&lt;/code&gt; 에 , &lt;code&gt;ispunct&lt;/code&gt; 및 &lt;code&gt;isspace&lt;/code&gt; 와의 같은 C 로케일에서 동일한 문자에 대해 반환 제로.</target>
        </trans-unit>
        <trans-unit id="1cf4537f9c301149e8cc2a31615b3d035dfb3d45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;lock&lt;/code&gt; 이미 소유 한 스레드에 의해 호출되는 &lt;code&gt;mutex&lt;/code&gt; 의 모드 (공유 또는 전용)에서을, 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="1025c2a2787ed452c780e1dcd1489b21d28b0a1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined: for example, the program</source>
          <target state="translated">경우 &lt;code&gt;lock&lt;/code&gt; 이미 소유 한 스레드에 의해 호출되는 &lt;code&gt;mutex&lt;/code&gt; , 행동은 정의되지 않는다 : 예를 들어, 프로그램</target>
        </trans-unit>
        <trans-unit id="9a44d1e0b185f370bee6a94519b229c4dac6e172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock_shared&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (exclusive or shared), the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;lock_shared&lt;/code&gt; 이미 소유 한 스레드에 의해 호출되는 &lt;code&gt;mutex&lt;/code&gt; 어떤 모드 (단독 또는 공유)에을, 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="4b1ebf8b0f2f951edb330b8fa8ae0d36a2cd369c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; is a &lt;a href=&quot;../language/static&quot;&gt;static member&lt;/a&gt; or a &lt;a href=&quot;../language/member_functions&quot;&gt;member function&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;member&lt;/code&gt; A는 &lt;a href=&quot;../language/static&quot;&gt;고정 부재&lt;/a&gt; 또는 &lt;a href=&quot;../language/member_functions&quot;&gt;부재의 기능&lt;/a&gt; , 동작은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="d629e4399641b9530158823e61e45ef4cbd7a6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mode &amp;gt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; wide-oriented. If &lt;code&gt;mode &amp;lt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; byte-oriented. If &lt;code&gt;mode==0&lt;/code&gt;, only queries the current orientation of the stream.</source>
          <target state="translated">&lt;code&gt;mode &amp;gt; 0&lt;/code&gt; 인 경우 &lt;code&gt;stream&lt;/code&gt; 넓은 방향 으로 만들려고 시도합니다 . &lt;code&gt;mode &amp;lt; 0&lt;/code&gt; 인 경우 &lt;code&gt;stream&lt;/code&gt; 지향 바이트 를 만들려고 시도합니다 . 경우 &lt;code&gt;mode==0&lt;/code&gt; 만 스트림의 현재 방향을 조회합니다.</target>
        </trans-unit>
        <trans-unit id="c3e26d9cac416d20dc7c2b6fc8e45df72eb4d94c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;money_base::space&lt;/code&gt; or &lt;code&gt;money_base::none&lt;/code&gt; is the last element in the &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt;, the parser does not attempt to consume any whitespace after the other components of the monetary value were parsed. Otherwise, one or more whitespace characters are consumed where &lt;code&gt;money_base::space&lt;/code&gt; appears.</source>
          <target state="translated">경우 &lt;code&gt;money_base::space&lt;/code&gt; 또는 &lt;code&gt;money_base::none&lt;/code&gt; 의 마지막 요소 인 &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; , 파서는 금전적 가치의 다른 구성 요소가 구문 분석 된 후에 공백을 소비하지 않습니다. 그렇지 않으면 &lt;code&gt;money_base::space&lt;/code&gt; 가 나타나는 하나 이상의 공백 문자가 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="e2acebccacc05bdce0834871463fa8d41cad28a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mp.grouping()&lt;/code&gt; does not permit thousands separators, the first separator encountered is treated as a parsing error, otherwise they are treated as optional.</source>
          <target state="translated">경우 &lt;code&gt;mp.grouping()&lt;/code&gt; 천 단위 구분을 허용하지 않습니다, 처음 발견 된 분리기 그렇지 않으면이 옵션으로 처리되어, 구문 분석 오류로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="3018443da1f5de49f03fa88048943ced63037aee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mp.positive_sign()&lt;/code&gt; (in case positive format pattern is used) or &lt;code&gt;mp.negative_sign()&lt;/code&gt; (in case negative format pattern is used) returns a string with more than one character, the first character returned is placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;sign&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern, and the rest of the characters are placed after all other characters, for example, formatting pattern &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; with units &lt;code&gt;123&lt;/code&gt; and negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt; may result in &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt;, while negative_sign of &lt;code&gt;&quot;()&quot;&lt;/code&gt; would generate &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;mp.positive_sign()&lt;/code&gt; (케이스 포지티브 형식의 패턴이 사용된다) 또는 &lt;code&gt;mp.negative_sign()&lt;/code&gt; (여기서 마이너스 형식 패턴이 사용되는) 하나 개 이상의 문자 스트링을 리턴 반환되는 첫 번째 문자는 출력 시퀀스 곳에 배치되고 &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;sign&lt;/a&gt;&lt;/code&gt; 가 형식화 패턴에 표시되고 나머지 문자는 다른 모든 문자 뒤에 배치됩니다 (예 : 단위 &lt;code&gt;123&lt;/code&gt; 및 음수 부호가 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 인 형식화 패턴 &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; 는 &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; 될 수 있습니다. &quot; , &lt;code&gt;&quot;()&quot;&lt;/code&gt; 의 negative_sign은 &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; 을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="790ce4186370cb3fc98f05fbcd1efa576fc74ae4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, a string representing</source>
          <target state="translated">만약 &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; , 문자열을 나타내는</target>
        </trans-unit>
        <trans-unit id="c48b8077ed302c34e54734ee208fe448aa9fce59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, the length of</source>
          <target state="translated">만약 &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; 의 길이</target>
        </trans-unit>
        <trans-unit id="f48f02b957cf489ffd4062413d130c7d61ac4261" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, the position of the first character of the</source>
          <target state="translated">만약 &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; 은의 첫 문자 위치</target>
        </trans-unit>
        <trans-unit id="d0a03be819895b29571bce6f30049ce00d836d67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0&lt;/code&gt; and &lt;code&gt;n &amp;lt; size()&lt;/code&gt;, returns a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; representing the part of the target sequence that was matched by the</source>
          <target state="translated">경우 &lt;code&gt;n &amp;gt; 0&lt;/code&gt; 및 &lt;code&gt;n &amp;lt; size()&lt;/code&gt; 상기의 참조를 반환 &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; 의해 일치 된 표적 서열의 부분을 나타내는</target>
        </trans-unit>
        <trans-unit id="c9ebc82c0ecb8a48088d0a25037fb0de7b63320a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, a string representing entire matched expression is returned.</source>
          <target state="translated">경우 &lt;code&gt;n == 0&lt;/code&gt; , 문자열을 나타내는 전체 유사한 표현이 반환된다.</target>
        </trans-unit>
        <trans-unit id="793a6257509b6fed6781f48113e3c6c7ee94fe8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, returns a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; representing the part of the target sequence matched by the entire matched regular expression.</source>
          <target state="translated">&lt;code&gt;n == 0&lt;/code&gt; 인 경우 일치하는 전체 정규식과 일치하는 대상 시퀀스 부분을 나타내는 &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; 대한 참조를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="465490bd86a1fdb5bc7e8b3d057830ae9c3992ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the counted range is valid and empty. Otherwise, the counted range is only valid if n is positive, i is dereferenceable, and &lt;code&gt;[++i, --n)&lt;/code&gt; is a valid counted range.</source>
          <target state="translated">경우 &lt;code&gt;n == 0&lt;/code&gt; , 카운트 범위는 유효하고 비어 있습니다. 그렇지 않으면, 계수 범위는 n이 양수이고 i가 역 참조 가능하며 &lt;code&gt;[++i, --n)&lt;/code&gt; 이 유효한 계수 범위 인 경우에만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="101f7c47a2904602ca47dee8ebc924745b56a92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the length of the entire matched expression is returned.</source>
          <target state="translated">경우 &lt;code&gt;n == 0&lt;/code&gt; 전체 정합 식의 길이가 반환된다.</target>
        </trans-unit>
        <trans-unit id="25afe120462723241b3dc46cef36ad98b886885e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the position of the first character of the entire matched expression is returned.</source>
          <target state="translated">경우 &lt;code&gt;n == 0&lt;/code&gt; 전체 정합 식의 선두 문자의 위치는 복귀된다.</target>
        </trans-unit>
        <trans-unit id="2c59d6a4ff2080c941bbe2819b072e112c520e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater or equal than 128, the behavior is implementation-defined</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 이 크면 128 같 동작이 구현 정의이고</target>
        </trans-unit>
        <trans-unit id="227f98cc1496f2fc8d051b223cb2a826b5a37aeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater or equal to 128, the behavior is implementation-defined.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 이 큰 경우 또는 128과 동일한 동작이 구현 정의된다.</target>
        </trans-unit>
        <trans-unit id="b0eb7273803ff8b80903c2e9df0d1f3a2350edf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater than the number of elements in the sequence, selects &lt;code&gt;last-first&lt;/code&gt; elements.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 시퀀스의 요소 선택의 수보다 &lt;code&gt;last-first&lt;/code&gt; 소자.</target>
        </trans-unit>
        <trans-unit id="184888f0f32fc840aab5148b93e76a03075f7c34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is negative, the iterator is decremented. In this case, &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 은 음수, 반복자는 감소된다. 이 경우 &lt;code&gt;InputIt&lt;/code&gt; 은 &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; 의 요구 사항을 충족해야합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4dfef1823205b211d7bbfb1b78e819c624879b9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;m&lt;/code&gt; is greater or equal to 128, the behavior is implementation-defined.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 또는 &lt;code&gt;m&lt;/code&gt; 이 크거나 128과 동일한 동작이 구현 정의된다.</target>
        </trans-unit>
        <trans-unit id="aad53311f76060eab43c7615e438c48408515bf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</source>
          <target state="translated">경우 &lt;code&gt;new_cap&lt;/code&gt; 이 보다 큰 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , past-the-end 반복자를 포함한 모든 반복자 및 요소에 대한 모든 참조가 무효화됩니다. 그렇지 않으면 반복자 또는 참조가 무효화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="255c1e92345c2e7929c0df945bb3108b691340d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is greater than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, new storage is allocated, and &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; is made equal or greater than &lt;code&gt;new_cap&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;new_cap&lt;/code&gt; 이 현재보다 큰 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , 신규 저장이 할당되고, &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 와 동일하거나 초과한다 &lt;code&gt;new_cap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b2651e65eddca052bf67c187fdb378c5807dec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than or equal to the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, there is no effect.</source>
          <target state="translated">&lt;code&gt;new_cap&lt;/code&gt; 이 현재 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 보다 작거나 같은 경우 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4474adc2275755af141c407f92c0e2fd9a1bdda5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, this is a non-binding shrink request.</source>
          <target state="translated">경우 &lt;code&gt;new_cap&lt;/code&gt; 가 적은 전류보다 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 이는 비 결합 수축 요청이다.</target>
        </trans-unit>
        <trans-unit id="a7e10ae2e285048c1842329a710bd58e4af2b39c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than the current &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;, this is a non-binding shrink-to-fit request equivalent to &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt;(since C++11).</source>
          <target state="translated">경우 &lt;code&gt;new_cap&lt;/code&gt; 가 적은 전류를 초과 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 본가 비 결합 수축 끼움에 요청 상당 &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; (11 ++ C입니다).</target>
        </trans-unit>
        <trans-unit id="bf95be7cd7ebf5692c3135c92a75c10543f6e749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_filename&lt;/code&gt; exists, the behavior is implementation-defined.</source>
          <target state="translated">경우 &lt;code&gt;new_filename&lt;/code&gt; 존재 동작은 구현 정의이다.</target>
        </trans-unit>
        <trans-unit id="80cb878f6f5866322edb61fa31de1ba01506d28f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_size&lt;/code&gt; is zero, the behavior is implementation defined: null pointer may be returned (in which case the old memory block may or may not be freed) or some non-null pointer may be returned that may not be used to access storage.</source>
          <target state="translated">경우 &lt;code&gt;new_size&lt;/code&gt; 가 (이 경우, 이전의 메모리 블록 또는하지 않을 수 해제 될 수 있음) 또는 몇몇 비 - 널 포인터 액세스 저장하는 데 사용되지 않을 수도 반환 될 수 NULL 포인터 리턴 될 수있다 : 제로 동작이 구현 정의이다.</target>
        </trans-unit>
        <trans-unit id="2de361cc207e32639639c741794ee2fcb6aa4087" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;noskipws&lt;/code&gt; is zero and &lt;code&gt;is.flags() &amp;amp; ios_base::skipws&lt;/code&gt; is nonzero, the function extracts and discards all whitespace characters until the next available character is not a whitespace character (as determined by the currently imbued locale in &lt;code&gt;is&lt;/code&gt;). If &lt;code&gt;is.rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; or &lt;code&gt;is.rdbuf()-&amp;gt;sgetc()&lt;/code&gt; returns &lt;code&gt;traits::eof()&lt;/code&gt;, the function calls &lt;code&gt;setstate(failbit | eofbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;noskipws&lt;/code&gt; 은 제로입니다 &lt;code&gt;is.flags() &amp;amp; ios_base::skipws&lt;/code&gt; IS 0이 아닌 함수 추출물 파기 (에서 현재 물든 로케일의 결정에 따라 사용 가능한 다음 문자가 공백 문자가 아닌 때까지 모든 공백 문자 &lt;code&gt;is&lt;/code&gt; ). 경우 &lt;code&gt;is.rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; 또는 &lt;code&gt;is.rdbuf()-&amp;gt;sgetc()&lt;/code&gt; 반환 &lt;code&gt;traits::eof()&lt;/code&gt; 함수 호출 &lt;code&gt;setstate(failbit | eofbit)&lt;/code&gt; (던질 수 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c309a7e2f969d9c1fa291f40fe3ab598e47bd4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; was not default-constructed, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 기본 구성이 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e236834fc06642f73e875ff2b0ea5467f35c428" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_p&lt;/code&gt; is a directory, then &lt;code&gt;new_p&lt;/code&gt; must be one of:</source>
          <target state="translated">경우 &lt;code&gt;old_p&lt;/code&gt; 이 디렉토리를하고, 다음 &lt;code&gt;new_p&lt;/code&gt; 중 하나 여야합니다 :</target>
        </trans-unit>
        <trans-unit id="769c85f3779db98891c17618ad67c5dc15d9f91f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_p&lt;/code&gt; is a non-directory file, then &lt;code&gt;new_p&lt;/code&gt; must be one of:</source>
          <target state="translated">경우 &lt;code&gt;old_p&lt;/code&gt; 이 아닌 디렉토리 파일입니다, 다음 &lt;code&gt;new_p&lt;/code&gt; 중 하나 여야합니다 :</target>
        </trans-unit>
        <trans-unit id="73715913e7ab67a68239322dafae4a19098bf520" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;openmode&lt;/code&gt; is not one of the modes listed, the &lt;code&gt;open()&lt;/code&gt; fails.</source>
          <target state="translated">경우 &lt;code&gt;openmode&lt;/code&gt; 는 나열된 모드 중 하나는 아니다 &lt;code&gt;open()&lt;/code&gt; 실패합니다.</target>
        </trans-unit>
        <trans-unit id="6e9a3e1afd67e93539e35474985138b3c3deb24f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::add&lt;/code&gt;, the file permissions are set to exactly &lt;code&gt;status(p).permissions() | (prms &amp;amp; perms::mask)&lt;/code&gt; (meaning, any valid bit that is set in &lt;code&gt;prms&lt;/code&gt;, but not in the file's current permissions is added to the file's permissions)</source>
          <target state="translated">경우 &lt;code&gt;opts&lt;/code&gt; 있다 &lt;code&gt;perm_options::add&lt;/code&gt; , 파일 사용 권한이 정확하게 설정되어 &lt;code&gt;status(p).permissions() | (prms &amp;amp; perms::mask)&lt;/code&gt; (즉, &lt;code&gt;prms&lt;/code&gt; 에 설정 되었지만 파일의 현재 권한에는없는 유효한 비트가 파일의 권한에 추가됨)</target>
        </trans-unit>
        <trans-unit id="38f8c3a3043f7271f4f818139555edb242b7d47e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::remove&lt;/code&gt;, the file permissions are set to exactly &lt;code&gt;status(p).permissions() &amp;amp; ~(prms &amp;amp; perms::mask)&lt;/code&gt; (meaning, any valid bit that is clear in &lt;code&gt;prms&lt;/code&gt;, but set in the file's current permissions is cleared in the file's permissions)</source>
          <target state="translated">경우 &lt;code&gt;opts&lt;/code&gt; 있다 &lt;code&gt;perm_options::remove&lt;/code&gt; , 파일 사용 권한이 정확하게 설정되어 &lt;code&gt;status(p).permissions() &amp;amp; ~(prms &amp;amp; perms::mask)&lt;/code&gt; (즉, 유효한에 분명하다 비트 &lt;code&gt;prms&lt;/code&gt; 파일의에서,하지만 설정 파일의 권한에서 현재 권한이 지워짐)</target>
        </trans-unit>
        <trans-unit id="743b1ea9d394f52e11e3859206c7efdd472d283a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::replace&lt;/code&gt;, file permissions are set to exactly &lt;code&gt;prms &amp;amp; &lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::mask&lt;/a&gt;&lt;/code&gt; (meaning, every valid bit of &lt;code&gt;prms&lt;/code&gt; is applied)</source>
          <target state="translated">경우 &lt;code&gt;opts&lt;/code&gt; 있다 &lt;code&gt;perm_options::replace&lt;/code&gt; , 파일 권한이 설정되어 정확히 &lt;code&gt;prms &amp;amp; &lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::mask&lt;/a&gt;&lt;/code&gt; (의미, 모든 유효 비트 &lt;code&gt;prms&lt;/code&gt; 적용됩니다)</target>
        </trans-unit>
        <trans-unit id="4fef9d0f0afa6e8487fa35a14b4387e28190db47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.good()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, returns. Otherwise, if &lt;code&gt;os.tie()&lt;/code&gt; is not a null pointer, calls &lt;code&gt;os.tie()-&amp;gt;flush()&lt;/code&gt; to synchronize the output sequence with external streams. During preparation, the constructor may call &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;os.good()&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; 를 돌려줍니다. 그렇지 않으면, &lt;code&gt;os.tie()&lt;/code&gt; 가 널 포인터가 아닌 경우, &lt;code&gt;os.tie()-&amp;gt;flush()&lt;/code&gt; 를 호출 하여 출력 순서를 외부 스트림과 동기화하십시오. 준비하는 동안 생성자는 &lt;code&gt;setstate(failbit)&lt;/code&gt; 호출 할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 던질 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="009d318ae78f457dac42968d4c493d6541c60df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.rdbuf()&lt;/code&gt; actually points to a &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt;&lt;code&gt;buf&lt;/code&gt;, toggles whether it emits (i.e., transmits data to the underlying stream buffer) when flushed:</source>
          <target state="translated">만약 &lt;code&gt;os.rdbuf()&lt;/code&gt; (A)에 실제로 점 &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt; &lt;code&gt;buf&lt;/code&gt; ,이 때 플러시 (기본 스트림 버퍼 즉, 송신 데이터)를 발광 여부를 토글 :</target>
        </trans-unit>
        <trans-unit id="86470d4ce8b2df93a46fea671370851ae460db55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains a value, then depending on whether &lt;code&gt;*this&lt;/code&gt; contains a value, the contained value is either &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or assigned from &lt;code&gt;*other&lt;/code&gt;(2) or &lt;code&gt;std::move(*other)&lt;/code&gt;(3). Note that a moved-from optional still</source>
          <target state="translated">경우에 &lt;code&gt;other&lt;/code&gt; 값을 포함하고 있는지에 따라 &lt;code&gt;*this&lt;/code&gt; 값을 포함, 포함 된 값 중 하나 인 &lt;a href=&quot;../../language/direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 또는 할당에서 &lt;code&gt;*other&lt;/code&gt; (2) 또는 &lt;code&gt;std::move(*other)&lt;/code&gt; (3). 이동 옵션은 여전히</target>
        </trans-unit>
        <trans-unit id="36484744e817604683f9351055f9e29eff44cf5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains a value, then depending on whether &lt;code&gt;*this&lt;/code&gt; contains a value, the contained value is either &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or assigned from &lt;code&gt;*other&lt;/code&gt;(5) or &lt;code&gt;std::move(*other)&lt;/code&gt;(6). Note that a moved-from optional still</source>
          <target state="translated">경우에 &lt;code&gt;other&lt;/code&gt; 값을 포함하고 있는지에 따라 &lt;code&gt;*this&lt;/code&gt; 값을 포함, 포함 된 값 중 하나 인 &lt;a href=&quot;../../language/direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 또는 할당에서 &lt;code&gt;*other&lt;/code&gt; (5) 또는 &lt;code&gt;std::move(*other)&lt;/code&gt; (6). 이동 옵션은 여전히</target>
        </trans-unit>
        <trans-unit id="c8399508478e3a1e9b6988b20831b2cf1587c5e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;, has no effects. Otherwise, copies the state of the stream &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. This is done in the following sequence:</source>
          <target state="translated">경우 &lt;code&gt;other&lt;/code&gt; 동일한 객체를 참조 &lt;code&gt;*this&lt;/code&gt; 아무런 효과가 없다. 그렇지 않으면, &lt;code&gt;other&lt;/code&gt; 스트림의 상태 를 &lt;code&gt;*this&lt;/code&gt; 에 복사하십시오 . 이것은 다음 순서로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="cde0508aa3c91b841b5bb98037ec418d76d0f467" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out_stream&lt;/code&gt; is a pointer to the associated &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;delim&lt;/code&gt; is the delimiter specified at the construction of this object, then the effect is equivalent to.</source>
          <target state="translated">경우 &lt;code&gt;out_stream&lt;/code&gt; 는 관련에 대한 포인터입니다 &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;delim&lt;/code&gt; 이 개체의 건설에 지정된 구분 기호, 그 효과는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9a4113e2f36160ea8f8bfa69f1009dc12f90fc93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p == 1&lt;/code&gt;, subsequent calls to the &lt;a href=&quot;operator()&quot;&gt;&lt;code&gt;operator()&lt;/code&gt;&lt;/a&gt; overload that does not accept a &lt;code&gt;param_type&lt;/code&gt; object will cause undefined behavior.</source>
          <target state="translated">&lt;code&gt;p == 1&lt;/code&gt; 인 경우 &lt;code&gt;param_type&lt;/code&gt; 객체를 허용하지 않는 &lt;a href=&quot;operator()&quot;&gt; &lt;code&gt;operator()&lt;/code&gt; &lt;/a&gt; 오버로드 에 대한 후속 호출 은 정의되지 않은 동작을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="39fcfc6551db4ea098125222aa584e4d80195a5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; does not exist, reports an error.</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 가 존재하지 않는 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="c7e10031a884549bafa7d7b0cdef0c9d208f99c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; does not exist, returns &lt;code&gt;file_status(file_type::not_found)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 가 존재하지 않는, 반환 &lt;code&gt;file_status(file_type::not_found)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35e83165c214a9475effb2ede4b6d71c2ec296a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; exists but file attributes cannot be determined, e.g. due to lack of permissions, returns &lt;code&gt;file_status(file_type::unknown)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 가 존재하지만 파일 특성이 결정할 수없는 예에 의한 권한의 부족으로 반환 &lt;code&gt;file_status(file_type::unknown)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="284cbde49fd69756d49af77ea69cb915f6cc4f80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; has an implementation-defined file type, returns &lt;code&gt;file_status(file_type::A, prms)&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is the implementation-defined &lt;a href=&quot;file_type&quot;&gt;&lt;code&gt;file_type&lt;/code&gt;&lt;/a&gt; constant for that type.</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 구현 정의 파일 형식, 반환이 &lt;code&gt;file_status(file_type::A, prms)&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; 는 구현 정의이다 &lt;a href=&quot;file_type&quot;&gt; &lt;code&gt;file_type&lt;/code&gt; &lt;/a&gt; 유형에 대한 상수를.</target>
        </trans-unit>
        <trans-unit id="84ba1d9110ba0eaab227ddc535151c53fd9656e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a block special file (as if by POSIX &lt;code&gt;S_ISBLK&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::block, prms)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 (같은 경우 POSIX에 의해 블록 특수 파일입니다 &lt;code&gt;S_ISBLK&lt;/code&gt; ), 반환 &lt;code&gt;file_status(file_type::block, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8d7bbe00812399696fe7cc6d0e4fb887d95e2e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a character special file (as if by POSIX &lt;code&gt;S_ISCHR&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::character, prms)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 문자 특수 파일입니다 (같은 경우 POSIX에 의해 &lt;code&gt;S_ISCHR&lt;/code&gt; ), 반환 &lt;code&gt;file_status(file_type::character, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5948ebb49968bd5b647e0007b11f05d39ecbae58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a directory (as if by POSIX &lt;code&gt;S_ISDIR&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::directory, prms)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 디렉토리입니다 (같은 경우 POSIX에 의해 &lt;code&gt;S_ISDIR&lt;/code&gt; ), 반환 &lt;code&gt;file_status(file_type::directory, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7098ea96e1e6fe0bd037998b47dc31e8e17fec8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a fifo or pipe file (as if by POSIX &lt;code&gt;S_ISFIFO&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::fifo, prms)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 (같은 경우 POSIX하여 FIFO 또는 파이프 파일입니다 &lt;code&gt;S_ISFIFO&lt;/code&gt; ), 반환 &lt;code&gt;file_status(file_type::fifo, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b2d16f4bd782dbe9f713f31636dbe449e4151e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a regular file (as if by POSIX &lt;code&gt;S_ISREG&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::regular, prms)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 일반 파일입니다 (같은 경우 POSIX에 의해 &lt;code&gt;S_ISREG&lt;/code&gt; ), 반환 &lt;code&gt;file_status(file_type::regular, prms)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd7f50e30d338262c2966fea6e46450e597e3af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a socket (as if by POSIX &lt;code&gt;S_ISSOCK&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::socket, prms)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 (같은 POSIX 경우와 소켓입니다 &lt;code&gt;S_ISSOCK&lt;/code&gt; ), 반환 &lt;code&gt;file_status(file_type::socket, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="249fe3aff7a5aaa72c5e17941aa8c099b4d5e055" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a symlink, returns &lt;code&gt;file_status(file_type::symlink)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 심볼릭 링크 인 경우 &lt;code&gt;file_status(file_type::symlink)&lt;/code&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a1524ab079a206332a561da96374e5f2392e60c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parm_n&lt;/code&gt; is declared with reference type or with a type not compatible with the type that results from &lt;a href=&quot;../../language/variadic_arguments#Default_conversions&quot;&gt;default argument promotions&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;parm_n&lt;/code&gt; 이 참조 유형 또는 &lt;a href=&quot;../../language/variadic_arguments#Default_conversions&quot;&gt;기본 인수 promotions의&lt;/a&gt; 결과 유형과 호환되지 않는 유형으로 선언 된 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e24b13015ddf20bc0adacae9ec44ca2ad7e04f7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt; and native encoding is UTF-8, constructs a path directly as if by &lt;code&gt;path(source)&lt;/code&gt; or &lt;code&gt;path(first, last)&lt;/code&gt;. Note: this is the typical situation of a POSIX system that uses Unicode, such as Linux.</source>
          <target state="translated">경우 &lt;code&gt;path::value_type&lt;/code&gt; 있다 &lt;code&gt;char&lt;/code&gt; 네이티브 인코딩은 UTF-8이며, 마치 직접 경로를 구성 &lt;code&gt;path(source)&lt;/code&gt; 또는 &lt;code&gt;path(first, last)&lt;/code&gt; . 참고 : 이는 Linux와 같이 유니 코드를 사용하는 POSIX 시스템의 일반적인 상황입니다.</target>
        </trans-unit>
        <trans-unit id="f1467bab99e474a5aa0ae0855c89eab043a29738" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt;, conversion, if any, is system-dependent. This is the case on typical POSIX systems (such as Linux), where native encoding is UTF-8 and &lt;code&gt;string()&lt;/code&gt; performs no conversion.</source>
          <target state="translated">경우 &lt;code&gt;path::value_type&lt;/code&gt; 있습니다 &lt;code&gt;char&lt;/code&gt; 변환이있는 경우, 시스템에 의존합니다. 기본 인코딩이 UTF-8이고 &lt;code&gt;string()&lt;/code&gt; 이 변환을 수행하지 않는 일반적인 POSIX 시스템 (예 : Linux)의 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="ecd5f9bafd39fb01f214968395060cedf4c94446" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;placement_params&lt;/code&gt; are provided, they are passed to the allocation function as additional arguments. Such allocation functions are known as &quot;placement new&quot;, after the standard allocation function &lt;code&gt;void* &lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, void*)&lt;/code&gt;, which simply returns its second argument unchanged. This is used to construct objects in allocated storage:</source>
          <target state="translated">경우 &lt;code&gt;placement_params&lt;/code&gt; 가 제공됩니다, 그들은 추가 인수로 할당 함수에 전달됩니다. 이러한 할당 함수는 표준 할당 함수 &lt;code&gt;void* &lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, void*)&lt;/code&gt; 뒤에 &quot;placement new&quot;라고하며, 두 번째 인수는 변경되지 않습니다. 이는 할당 된 스토리지에서 오브젝트를 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73eb91c9e150b84ef667442582643acf6c0ee10d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos &amp;gt; size()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;pos &amp;gt; size()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d5825465b5dfa7d68d014c8c650a4880927e452b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt;, this constructor throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt;. If any characters examined in &lt;code&gt;str&lt;/code&gt; are not &lt;code&gt;zero&lt;/code&gt; or &lt;code&gt;one&lt;/code&gt;, it throws &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt; 이 생성자는 던져 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; . 모든 문자가에서 조사하면 &lt;code&gt;str&lt;/code&gt; 을 하지 &lt;code&gt;zero&lt;/code&gt; 또는 &lt;code&gt;one&lt;/code&gt; , 그것은 던졌습니다 &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9cdf4cfe8233d41239dac602c3524239510fa6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos == size()&lt;/code&gt;, a reference to the character with value &lt;code&gt;CharT()&lt;/code&gt; (the null character) is returned.</source>
          <target state="translated">경우 &lt;code&gt;pos == size()&lt;/code&gt; , 값과 캐릭터의 참조 &lt;code&gt;CharT()&lt;/code&gt; (널 문자)가 리턴된다.</target>
        </trans-unit>
        <trans-unit id="45d948614cf70d9e5ba39df1cc54e194a17a73da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not a null pointer, then a pointer &lt;code&gt;ptr&lt;/code&gt; - internal to the conversion functions - will receive the address of the first unconverted character in &lt;code&gt;str.c_str()&lt;/code&gt;, and the index of that character will be calculated and stored in &lt;code&gt;*pos&lt;/code&gt;, giving the number of characters that were processed by the conversion.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 가 null 포인터가 아닌 경우 , 변환 함수 내부 의 포인터 &lt;code&gt;ptr&lt;/code&gt; 은 &lt;code&gt;str.c_str()&lt;/code&gt; 에서 변환되지 않은 첫 번째 문자의 주소를 수신하고 해당 문자의 색인은 &lt;code&gt;*pos&lt;/code&gt; 에 계산되어 저장됩니다 . 변환에 의해 처리 된 문자 수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f6fea302ec518c538cb888ab49b9e51eb713903c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not a null pointer, then a pointer &lt;code&gt;ptr&lt;/code&gt;, internal to the conversion functions, will receive the address of the first unconverted character in &lt;code&gt;str.c_str()&lt;/code&gt;, and the index of that character will be calculated and stored in &lt;code&gt;*pos&lt;/code&gt;, giving the number of characters that were processed by the conversion.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 가 null 포인터가 아닌 경우 , 변환 함수 내부 의 포인터 &lt;code&gt;ptr&lt;/code&gt; 은 &lt;code&gt;str.c_str()&lt;/code&gt; 에서 변환되지 않은 첫 번째 문자의 주소를 수신하고 해당 문자의 색인은 &lt;code&gt;*pos&lt;/code&gt; 에 계산되어 저장됩니다 . 변환에 의해 처리 된 문자 수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="079f39fe95713c066d5cd5476974d3a17ef66bef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not within the range of the container, an exception of type &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;pos&lt;/code&gt; 가 컨테이너의 범위 내에 있지, 형의 예외가 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="beb7dae20fb8d8052f57f043526ceb062d467b3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ps&lt;/code&gt; is not a null pointer, the &lt;code&gt;mbsinit&lt;/code&gt; function determines whether the pointed-to &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; object describes the initial conversion state.</source>
          <target state="translated">&lt;code&gt;ps&lt;/code&gt; 가 널 포인터가 아닌 경우 , &lt;code&gt;mbsinit&lt;/code&gt; 함수는 지정된 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 오브젝트가 초기 변환 상태를 설명 하는지 여부를 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="101e3c4415b14d26fb3724226aa4e6d4501f3aea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the behavior is the same as calling &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;(&lt;code&gt;new_size&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;ptr&lt;/code&gt; 널 포인터 동작이 호출하는 것과 동일 &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;new_size&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="75ce63992e734876e2a939cc380b004ef361f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the function does nothing.</source>
          <target state="translated">경우 &lt;code&gt;ptr&lt;/code&gt; 널 포인터이며,이 함수는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2dc2865c464168b736d26e4f6c5e34da572e57e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is empty, so is the new &lt;code&gt;shared_ptr&lt;/code&gt; (but its stored pointer is not necessarily null). Otherwise, the new &lt;code&gt;shared_ptr&lt;/code&gt; will share ownership with the initial value of &lt;code&gt;r&lt;/code&gt;, except that it is empty if the &lt;code&gt;dynamic_cast&lt;/code&gt; performed by &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; returns a null pointer.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 이 비어 있으면 새로운 &lt;code&gt;shared_ptr&lt;/code&gt; 도 마찬가지입니다 (그러나 저장된 포인터가 반드시 null 일 필요는 없습니다). 그렇지 않으면, 새로운 &lt;code&gt;shared_ptr&lt;/code&gt; 은 &lt;code&gt;dynamic_cast&lt;/code&gt; 의해 수행되는 &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; 가 널 포인터를 리턴하는 경우 비어 있다는 점을 제외하고 는 초기 값 &lt;code&gt;r&lt;/code&gt; 과 소유권을 공유 합니다.</target>
        </trans-unit>
        <trans-unit id="b29c481ab6a6599cf423510b090aefb5d2a5a864" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not null, sets the default memory resource pointer to &lt;code&gt;r&lt;/code&gt;; otherwise, sets the default memory resource pointer to &lt;code&gt;&lt;a href=&quot;new_delete_resource&quot;&gt;std::pmr::new_delete_resource&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 이 null이 아닌 경우 기본 메모리 리소스 포인터를 &lt;code&gt;r&lt;/code&gt; 로 설정합니다 . 그렇지 않으면 기본 메모리 자원 포인터를 &lt;code&gt;&lt;a href=&quot;new_delete_resource&quot;&gt;std::pmr::new_delete_resource&lt;/a&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="775fd3976f21369f6410f6f3d50cc92d417bb684" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rand()&lt;/code&gt; is used before any calls to &lt;code&gt;srand()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt; behaves as if it was seeded with &lt;code&gt;srand(1)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;rand()&lt;/code&gt; 를 호출하기 전에 사용 &lt;code&gt;srand()&lt;/code&gt; , &lt;code&gt;rand()&lt;/code&gt; 동작합니다는 것처럼는 글로리 &lt;code&gt;srand(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e1109753adbdfe03f2bb121a57562bbd3b95645" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() &amp;gt; 0&lt;/code&gt;, extracts &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(rdbuf()-&amp;gt;in_avail(), count)&lt;/code&gt; characters and stores them into successive locations of the characater array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;rdbuf()-&amp;gt;in_avail() &amp;gt; 0&lt;/code&gt; , 추출물 &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(rdbuf()-&amp;gt;in_avail(), count)&lt;/code&gt; 의 첫 번째 요소에 의해 지시되는 위치를 나타내는 문자 배열의 연속적인 위치에 문자 및 그것들을 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cb1ced447e9513c6cc2a7656394e6e283081981" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() == -1&lt;/code&gt;, calls &lt;code&gt;setstate(eofbit)&lt;/code&gt; and extracts no characters.</source>
          <target state="translated">경우 &lt;code&gt;rdbuf()-&amp;gt;in_avail() == -1&lt;/code&gt; 호출 &lt;code&gt;setstate(eofbit)&lt;/code&gt; 추출 아무 문자를.</target>
        </trans-unit>
        <trans-unit id="1d663866c5ef6d453a0e6e1c3a442d54a0a631ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() == 0&lt;/code&gt;, extracts no characters.</source>
          <target state="translated">경우 &lt;code&gt;rdbuf()-&amp;gt;in_avail() == 0&lt;/code&gt; , 어떤 문자를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="0bb9782f82ff3d24467c86f4716084ada4ca990f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; returns &lt;code&gt;Traits::eof()&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; 반환 &lt;code&gt;Traits::eof()&lt;/code&gt; 호출 &lt;code&gt;setstate(badbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f7f0c931fb16fc794bc074b32fcde3eb8dce586" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()&lt;/code&gt; is null or if &lt;code&gt;rdbuf-&amp;gt;sputbackc(ch)&lt;/code&gt; returns &lt;code&gt;Traits::eof()&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;rdbuf()&lt;/code&gt; null의 경우 또는 &lt;code&gt;rdbuf-&amp;gt;sputbackc(ch)&lt;/code&gt; 반환 &lt;code&gt;Traits::eof()&lt;/code&gt; 호출 &lt;code&gt;setstate(badbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c685f865d646b3c4c7e1a09a3ab4541aca64af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is a member variable holding the number of ticks in a duration object,</source>
          <target state="translated">&lt;code&gt;rep_&lt;/code&gt; 이 duration 객체의 틱 수를 보유하는 멤버 변수 인 경우 ,</target>
        </trans-unit>
        <trans-unit id="dd202d89b0c5b4958bcc3baf6d4f8cc9e4180f5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is a member variable holding the number of ticks in a duration object, and &lt;code&gt;D&lt;/code&gt; is the return type,</source>
          <target state="translated">경우 &lt;code&gt;rep_&lt;/code&gt; 이 기간 객체 틱 수를 들고 멤버 변수이고, &lt;code&gt;D&lt;/code&gt; 는 리턴 타입,</target>
        </trans-unit>
        <trans-unit id="d39a4ad84577a00c15233086e6e7ac8affa4a963" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is the member variable holding the number of ticks in this duration object,</source>
          <target state="translated">&lt;code&gt;rep_&lt;/code&gt; 이이 duration 객체에서 틱 수를 보유하는 멤버 변수 인 경우 ,</target>
        </trans-unit>
        <trans-unit id="f2eadcb39ee434e29ef05bd72b2b26a315c2acf9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer and &lt;code&gt;n&lt;/code&gt; is zero, the filebuf becomes</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터이며, &lt;code&gt;n&lt;/code&gt; 제로의 filebuf이된다</target>
        </trans-unit>
        <trans-unit id="9b53eb098a63b3e541f5d769951b6fce364d2e5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer and &lt;code&gt;n&lt;/code&gt; is zero, this function has no effect.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터이고, &lt;code&gt;n&lt;/code&gt; 은 제로이며,이 기능은 효과가 없다.</target>
        </trans-unit>
        <trans-unit id="1972341d22f77196bc1af118f58697bce937d0f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets its internal conversion state to represent the initial shift state and returns &lt;code&gt;​0​&lt;/code&gt; if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터는 초기 변속 상태로 복귀 표현하는데 내부 변환 상태를 리셋 &lt;code&gt;​0​&lt;/code&gt; 현재 멀티 인코딩 상태 의존성 (시프트 시퀀스를 사용하지 않는다) 또는 비 - 제로 값은 현재 멀티가 아닌 경우이면 인코딩은 상태에 따라 다릅니다 (시프트 시퀀스 사용).</target>
        </trans-unit>
        <trans-unit id="c39632bb99f5cb18b879a3b49462f93b75999d15" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets the global conversion state and determines whether shift sequences are used.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터 글로벌 변환 상태를 리셋하고, 시프트 시퀀스들이 사용되는지 여부를 판정한다.</target>
        </trans-unit>
        <trans-unit id="6138f983954415f7151da4086aa9c700eb8d9987" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c16rtomb(buf, u'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터가 호출은 동일하다 &lt;code&gt;std::c16rtomb(buf, u'\0', ps)&lt;/code&gt; 일부 내부 버퍼 용 &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b425a38a00e233a7e79446325b7bf9c1fc117a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c32rtomb(buf, U'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터가, 호출하는 것과 같습니다 &lt;code&gt;std::c32rtomb(buf, U'\0', ps)&lt;/code&gt; 일부 내부 버퍼에 대한 &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed35e82d64bb46cbad184112b5af458797318975" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c8rtomb(buf, u8'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터가 호출은 동일하다 &lt;code&gt;std::c8rtomb(buf, u8'\0', ps)&lt;/code&gt; 일부 내부 버퍼 용 &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12e013f90ae32cdb16251d5b6510a8d8d5565aed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::wcrtomb(buf, L'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터가 호출은 동일하다 &lt;code&gt;std::wcrtomb(buf, L'\0', ps)&lt;/code&gt; 일부 내부 버퍼 용 &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0c98fdcb47a8abb41d844fc8c53f32413a8247d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc16&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터의 값은 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;pc16&lt;/code&gt; 가 무시되고 호출에 해당하는 &lt;code&gt;std::mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f441bdad904ce2a3ae27b238bbd76507e2b519da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc32&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터의 값은 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;pc32&lt;/code&gt; 무시되고 호출에 해당하는 &lt;code&gt;std::mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92f917820ffd997e9b4bad50e8a1e2f43abff234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc8&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc8(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터의 값은 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;pc8&lt;/code&gt; 무시되고 호출에 해당하는 &lt;code&gt;std::mbrtoc8(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="002e16b0a8a0300cebc1bd2022bc72e0016d413f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pwc&lt;/code&gt; are ignored and call is equivalent to &lt;code&gt;std::mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터의 값은 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;pwc&lt;/code&gt; 무시하고 호출에 해당하는 &lt;code&gt;std::mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="387220b12d5b9da678e75cc38f39c0d62fd87341" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c16&lt;/code&gt; is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터 아니고 &lt;code&gt;c16&lt;/code&gt; 코드 포인트의 유효 가변 길이 부호화의 마지막 16 비트 부호 부, 함수는 모든 포함하는 코드 포인트의 멀티 바이트 문자 표현을 저장하는데 필요한 바이트의 수를 (결정 시프트 시퀀스를 수행하고 현재 멀티 바이트 변환 상태 ( &lt;code&gt;*ps&lt;/code&gt; ) 를 고려하여 멀티 바이트 문자 표현을 첫 번째 요소가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 문자 배열에 저장하고 필요에 따라 &lt;code&gt;*ps&lt;/code&gt; 를 업데이트 합니다. 이 함수는 최대 &lt;code&gt;MB_CUR_MAX&lt;/code&gt; 바이트를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e98391f16286d01eda72c77dda336407bf1f401" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c8&lt;/code&gt; is the last code unit in a valid UTF-8 encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; NULL 포인터 아니고 &lt;code&gt;c8&lt;/code&gt; 코드 포인트의 유효 UTF-8 인코딩 마지막 코드 부이고, 함수는 임의의 시프트 시퀀스를 포함하는 코드 포인트의 멀티 바이트 문자 표현을 저장하는데 필요한 바이트의 수를 (결정 현재 멀티 바이트 변환 상태 ( &lt;code&gt;*ps&lt;/code&gt; )를 고려하고, 멀티 바이트 문자 표현을 첫 번째 요소가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 문자 배열에 저장하여 필요에 따라 &lt;code&gt;*ps&lt;/code&gt; 를 업데이트 합니다. 이 함수는 최대 &lt;code&gt;MB_CUR_MAX&lt;/code&gt; 바이트를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efeff6f4bae9dbe7dacca63bdafb8df5873ba5a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to UTF-8 and stores the first UTf-8 code unit in &lt;code&gt;*pc8&lt;/code&gt; (if &lt;code&gt;pc8&lt;/code&gt; is not null).</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터가 아니라, 대부분의 검사 &lt;code&gt;n&lt;/code&gt; 바이트가 가리키는로 시작, 멀티 바이트 문자열의 바이트 &lt;code&gt;s&lt;/code&gt; (모든 이동 시퀀스 포함) 다음 멀티 바이트 문자를 완료하는 데 필요한 바이트 수를 결정합니다. 함수가 &lt;code&gt;s&lt;/code&gt; 의 다음 멀티 바이트 문자 가 완전하고 유효하다고 판별하면이 를 UTF-8로 변환하고 &lt;code&gt;*pc8&lt;/code&gt; 에 첫 번째 UTf-8 코드 단위를 저장합니다 ( &lt;code&gt;pc8&lt;/code&gt; 이 널이 아닌 경우 ).</target>
        </trans-unit>
        <trans-unit id="66571e29e3face4617295ef95324bcdf8412d045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 16-bit character and stores it in &lt;code&gt;*pc16&lt;/code&gt; (if &lt;code&gt;pc16&lt;/code&gt; is not null).</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터가 아니라, 대부분의 검사 &lt;code&gt;n&lt;/code&gt; 바이트가 가리키는로 시작, 멀티 바이트 문자열의 바이트 &lt;code&gt;s&lt;/code&gt; (모든 이동 시퀀스 포함) 다음 멀티 바이트 문자를 완료하는 데 필요한 바이트 수를 결정합니다. 함수가 &lt;code&gt;s&lt;/code&gt; 의 다음 멀티 바이트 문자 가 완전하고 유효한 것으로 판별 하면 해당 16 비트 문자로 변환하여 &lt;code&gt;*pc16&lt;/code&gt; 에 저장합니다 ( &lt;code&gt;pc16&lt;/code&gt; 이 널이 아닌 경우 ).</target>
        </trans-unit>
        <trans-unit id="e34686814ade46fa92cd32a9d644e0c7a90c8094" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 32-bit character and stores it in &lt;code&gt;*pc32&lt;/code&gt; (if &lt;code&gt;pc32&lt;/code&gt; is not null).</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터가 아니라, 대부분의 검사 &lt;code&gt;n&lt;/code&gt; 바이트가 가리키는로 시작, 멀티 바이트 문자열의 바이트 &lt;code&gt;s&lt;/code&gt; (모든 이동 시퀀스 포함) 다음 멀티 바이트 문자를 완료하는 데 필요한 바이트 수를 결정합니다. 함수가 &lt;code&gt;s&lt;/code&gt; 의 다음 멀티 바이트 문자 가 완전하고 유효한 것으로 판별 하면 해당 32 비트 문자로 변환하여 &lt;code&gt;*pc32&lt;/code&gt; 에 저장합니다 ( &lt;code&gt;pc32&lt;/code&gt; 가 널이 아닌 경우 ).</target>
        </trans-unit>
        <trans-unit id="2038e0d252e5f18478ed819b27d31e3681ca48d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding wide character and stores it in &lt;code&gt;*pwc&lt;/code&gt; (if &lt;code&gt;pwc&lt;/code&gt; is not null).</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터가 아니라, 대부분의 검사 &lt;code&gt;n&lt;/code&gt; 바이트가 가리키는로 시작, 멀티 바이트 문자열의 바이트 &lt;code&gt;s&lt;/code&gt; (모든 이동 시퀀스 포함) 다음 멀티 바이트 문자를 완료하는 데 필요한 바이트 수를 결정합니다. 함수가 &lt;code&gt;s&lt;/code&gt; 의 다음 멀티 바이트 문자 가 완전하고 유효하다고 판별 하면 해당 와이드 문자로 변환하여 &lt;code&gt;*pwc&lt;/code&gt; 에 저장합니다 ( &lt;code&gt;pwc&lt;/code&gt; 가 널이 아닌 경우 ).</target>
        </trans-unit>
        <trans-unit id="6f4c68687ec93f7e26b9a23cfefd0d3cb05dc64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte character or &lt;code&gt;-1&lt;/code&gt; if the first bytes pointed to by &lt;code&gt;s&lt;/code&gt; do not form a valid multibyte character or &lt;code&gt;​0​&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; is pointing at the null charcter &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터가 아닌, 다중 바이트 문자에 포함 또는 바이트 수 반환 &lt;code&gt;-1&lt;/code&gt; 첫 번째 바이트가 가리키는 경우 &lt;code&gt;s&lt;/code&gt; 유효한 멀티 바이트 문자 또는 형성하지 않는 &lt;code&gt;​0​&lt;/code&gt; 경우 &lt;code&gt;s&lt;/code&gt; 널 뜯 가리키는된다 &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f76e4a5183e8ca08cf45c471464ea38bd49564a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte representation of &lt;code&gt;wc&lt;/code&gt; or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;wc&lt;/code&gt; is not a valid character.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 널 포인터가 아닌,의 멀티 바이트 표현에 포함 된 바이트 수를 반환 &lt;code&gt;wc&lt;/code&gt; 또는 &lt;code&gt;-1&lt;/code&gt; 경우 &lt;code&gt;wc&lt;/code&gt; 유효한 문자가 아닙니다합니다.</target>
        </trans-unit>
        <trans-unit id="6d6df3a6410ecce9d2acc8ffd84bf56f540ac991" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;c32&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 널 포인터가 아닌 경우 , 함수는 &lt;code&gt;c32&lt;/code&gt; 의 멀티 바이트 문자 표현을 저장하는 데 필요한 바이트 수 (모든 시프트 시퀀스 포함 및 현재 멀티 바이트 변환 상태 &lt;code&gt;*ps&lt;/code&gt; 고려 )를 결정하고 멀티 바이트 문자 표현을 &lt;code&gt;s&lt;/code&gt; 로 첫 번째 요소를 가리키는 문자 배열로 , 필요에 따라 &lt;code&gt;*ps&lt;/code&gt; 가 업데이트 됩니다. 이 함수는 최대 &lt;code&gt;MB_CUR_MAX&lt;/code&gt; 바이트를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9d1c6974b8b676a8501a6cacc05cdd5f413866d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;wc&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 널 포인터가 아닌 경우 , 함수는 &lt;code&gt;wc&lt;/code&gt; 의 멀티 바이트 문자 표현을 저장하는 데 필요한 바이트 수 (모든 시프트 시퀀스 포함 및 현재 멀티 바이트 변환 상태 &lt;code&gt;*ps&lt;/code&gt; 고려 )를 결정하고 멀티 바이트 문자 표현을 &lt;code&gt;s&lt;/code&gt; 로 첫 번째 요소를 가리키는 문자 배열로 , 필요에 따라 &lt;code&gt;*ps&lt;/code&gt; 가 업데이트 됩니다. 이 함수는 최대 &lt;code&gt;MB_CUR_MAX&lt;/code&gt; 바이트를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7823afdead8eb41af529747e83ce1e0afbe2e6fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setjmp&lt;/code&gt; appears in any other context, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;setjmp&lt;/code&gt; 는이 다른 상황에서 나타납니다, 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="4c03a05548ddb96f3438cfeabf552db044243a9a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;showbase&lt;/code&gt; flag is set in &lt;code&gt;str.flags()&lt;/code&gt;, the currency symbol or currency string is required, if it is not set, the currency symbol is optional.</source>
          <target state="translated">&lt;code&gt;showbase&lt;/code&gt; 플래그가 &lt;code&gt;str.flags()&lt;/code&gt; 로 설정된 경우 통화 기호 또는 통화 문자열이 필요하며, 설정되지 않은 경우 통화 기호는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="8969128c7f7485e9cafa97fcadad06ea89f50051" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size()&lt;/code&gt; is 0, &lt;code&gt;data()&lt;/code&gt; may or may not return a null pointer.</source>
          <target state="translated">경우에 &lt;code&gt;size()&lt;/code&gt; 0 인 &lt;code&gt;data()&lt;/code&gt; 또는 NULL 포인터를 리턴하지 않을 수도있다.</target>
        </trans-unit>
        <trans-unit id="5a6ee964cf02ec47b4f466324fac4fa5368b4c54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage).</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 제로인, 행동 정의가 구현 (NULL 포인터가 리턴되거나, 일부 비 - 널 포인터 액세스 저장하는 데 사용되지 않을 수 복귀 될 수있다).</target>
        </trans-unit>
        <trans-unit id="4de52063dd761a69f5fec3a1f793d8ab34506b00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 제로, 행동은 정의 구현입니다 (널 포인터가 반환 될 수 있습니다, 또는 null이 아닌 포인터 액세스 저장에 사용되지 않을 수 있지만, 전달되어야한다는 반환 될 수 있습니다 &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fece348a8ee3d70f7e3352f3e69bf03a082365cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fread&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 나 &lt;code&gt;count&lt;/code&gt; 제로, &lt;code&gt;fread&lt;/code&gt; 0을 반환하고 수행하는 다른 작업입니다.</target>
        </trans-unit>
        <trans-unit id="a444353fd5b9d3848488fa96c9629f1e576c66a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fwrite&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">경우 &lt;code&gt;size&lt;/code&gt; 나 &lt;code&gt;count&lt;/code&gt; 제로, &lt;code&gt;fwrite&lt;/code&gt; 0을 반환하고 수행하는 다른 작업입니다.</target>
        </trans-unit>
        <trans-unit id="62c0f8b2707422825d3dfec002ee726a9c2cbd66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt;, that is, no inner allocators were declared, returns &lt;code&gt;*this&lt;/code&gt;. Otherwise returns a reference to &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt;, that is, a scoped allocator composed of all inner allocators of &lt;code&gt;*this&lt;/code&gt;, with the first inner allocator becoming the outer allocator.</source>
          <target state="translated">경우 &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt; , 어떤 내부 할당 자 선언되지 않았다되고, 반환 &lt;code&gt;*this&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; 대한 참조 , 즉 &lt;code&gt;*this&lt;/code&gt; 의 모든 내부 할당 자로 구성된 범위 할당 자가 반환 되고 첫 번째 내부 할당자는 외부 할당자가됩니다.</target>
        </trans-unit>
        <trans-unit id="791ac1fc4772ec7b51395220b898af37695b4777" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is greater than two (i.e., &lt;code&gt;T...&lt;/code&gt; consists of the types &lt;code&gt;T1, T2, R...&lt;/code&gt;), then if &lt;code&gt;std::common_reference_t&amp;lt;T1, T2&amp;gt;&lt;/code&gt; exists, the member &lt;code&gt;type&lt;/code&gt; denotes &lt;code&gt;std::common_reference_t&amp;lt;std::common_reference_t&amp;lt;T1, T2&amp;gt;, R...&amp;gt;&lt;/code&gt; if such a type exists. In all other cases, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;sizeof...(T)&lt;/code&gt; 크다 이상의 (즉, &lt;code&gt;T...&lt;/code&gt; 타입 구성 &lt;code&gt;T1, T2, R...&lt;/code&gt; ), 그 다음 만약 &lt;code&gt;std::common_reference_t&amp;lt;T1, T2&amp;gt;&lt;/code&gt; 존재의 부재 &lt;code&gt;type&lt;/code&gt; 이고 &lt;code&gt;std::common_reference_t&amp;lt;std::common_reference_t&amp;lt;T1, T2&amp;gt;, R...&amp;gt;&lt;/code&gt; 이 유형이 존재하는 경우. 다른 모든 경우에는 멤버 &lt;code&gt;type&lt;/code&gt; 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ecc26feb6c4b2ae80a7529b5d61cf9ff7a5b097b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is greater than two (i.e., &lt;code&gt;T...&lt;/code&gt; consists of the types &lt;code&gt;T1, T2, R...&lt;/code&gt;), then if &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; exists, the member &lt;code&gt;type&lt;/code&gt; denotes &lt;code&gt;std::common_type&amp;lt;std::common_type&amp;lt;T1, T2&amp;gt;::type, R...&amp;gt;::type&lt;/code&gt; if such a type exists. In all other cases, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;sizeof...(T)&lt;/code&gt; 보다 크다이 (즉, &lt;code&gt;T...&lt;/code&gt; 종류로 구성되어 &lt;code&gt;T1, T2, R...&lt;/code&gt; ), 다음의 경우 &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; 존재의 멤버 &lt;code&gt;type&lt;/code&gt; 은 &lt;code&gt;std::common_type&amp;lt;std::common_type&amp;lt;T1, T2&amp;gt;::type, R...&amp;gt;::type&lt;/code&gt; 냅니다. 다른 모든 경우에는 멤버 &lt;code&gt;type&lt;/code&gt; 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="78448ef5ca9bbafc2986882ac92ff12c158a9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is one (i.e., &lt;code&gt;T...&lt;/code&gt; contains only one type &lt;code&gt;T0&lt;/code&gt;), the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;T0&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;sizeof...(T)&lt;/code&gt; 하나 (즉,이다 &lt;code&gt;T...&lt;/code&gt; 한 종류의 포함 &lt;code&gt;T0&lt;/code&gt; 를 ) 멤버 &lt;code&gt;type&lt;/code&gt; 이름과 동일한 유형 &lt;code&gt;T0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b493ffdbed7ccd8ccc482ba14060e9c250b436b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is one (i.e., &lt;code&gt;T...&lt;/code&gt; contains only one type &lt;code&gt;T0&lt;/code&gt;), the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;std::common_type&amp;lt;T0, T0&amp;gt;::type&lt;/code&gt; if it exists; otherwise there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;sizeof...(T)&lt;/code&gt; 하나 (즉,이다 &lt;code&gt;T...&lt;/code&gt; 한 종류의 포함 &lt;code&gt;T0&lt;/code&gt; 를 ) 멤버 &lt;code&gt;type&lt;/code&gt; 이름과 동일한 유형으로 &lt;code&gt;std::common_type&amp;lt;T0, T0&amp;gt;::type&lt;/code&gt; 가 존재하는 경우; 그렇지 않으면 멤버 &lt;code&gt;type&lt;/code&gt; 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="05312f022c61c0809a5b4f6761df43d1433c8e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is two (i.e., &lt;code&gt;T...&lt;/code&gt; contains exactly two types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;),</source>
          <target state="translated">경우 &lt;code&gt;sizeof...(T)&lt;/code&gt; 두이다 (즉, &lt;code&gt;T...&lt;/code&gt; 정확히 두 가지 유형이 포함되어 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 를 )</target>
        </trans-unit>
        <trans-unit id="a9203e749bb438b9fb18b3027d7cd1938fde1b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is two (i.e., &lt;code&gt;T...&lt;/code&gt; contains two types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;):</source>
          <target state="translated">경우 &lt;code&gt;sizeof...(T)&lt;/code&gt; 두이다 (즉, &lt;code&gt;T...&lt;/code&gt; 두 가지 유형이 포함되어 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 를 )</target>
        </trans-unit>
        <trans-unit id="003d0981a91b043f4c661755c19594dc3f2d5e31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is zero, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;sizeof...(T)&lt;/code&gt; 제로, 어떤 멤버가없는 &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e9a3b7bb26a60d38196ba47db1b4041c4e0a434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(Types) == 0&lt;/code&gt; or if any of the types in &lt;code&gt;Types&lt;/code&gt; is not a complete object type, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;sizeof...(Types) == 0&lt;/code&gt; 의 유형의 경우 또는 &lt;code&gt;Types&lt;/code&gt; 완전한 객체 유형이 아닌, 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="4072b39e3de9b56d51b28e74e4a293634d9f7558" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp&lt;/code&gt; was not obtained by calling &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;seekpos()&lt;/code&gt; on the same file, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;sp&lt;/code&gt; 호출하는 것으로 취득하지 않은 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;seekpos()&lt;/code&gt; 같은 파일에을, 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="546524cf93679255723e493223804c25db718c37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::abs&lt;/code&gt; is called with an argument of type &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; cannot be converted to &lt;code&gt;int&lt;/code&gt; by &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">경우 &lt;code&gt;std::abs&lt;/code&gt; 유형의 인수로 호출 &lt;code&gt;X&lt;/code&gt; 등이 &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;X&lt;/code&gt; 는 변환 할 수 없습니다 &lt;code&gt;int&lt;/code&gt; 에 의해 &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;통합 홍보&lt;/a&gt; , 프로그램이 잘못 형성된다.</target>
        </trans-unit>
        <trans-unit id="feba3c26477487c1b1931e01bd15bdc0fb928819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; has no &lt;code&gt;fetch_and&lt;/code&gt; member (this member is only provided for &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;integral types&lt;/a&gt;), the program is ill-formed.</source>
          <target state="translated">경우 &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; 에는없는 &lt;code&gt;fetch_and&lt;/code&gt; (이 부재 만 제공된다 부재 &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;정수형&lt;/a&gt; ) 프로그램이 잘못 형성된다.</target>
        </trans-unit>
        <trans-unit id="88a445f32dd035df709cb7b01fefe9115a63d211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; has no &lt;code&gt;fetch_xor&lt;/code&gt; member (this member is only provided for &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;integral types&lt;/a&gt;), the program is ill-formed.</source>
          <target state="translated">경우 &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; 에는없는 &lt;code&gt;fetch_xor&lt;/code&gt; 부재 (부재 만이 제공된다 &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;정수형&lt;/a&gt; ) 프로그램이 잘못 형성된다.</target>
        </trans-unit>
        <trans-unit id="def722711403d134b11c7d54af7e5b4d9abce392" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::consume_header&lt;/code&gt; is not selected when reading a file beginning with byte order mark, the Unicode character U+FEFF (Zero width non-breaking space) will be read as the first character of the string content.</source>
          <target state="translated">경우 &lt;code&gt;std::consume_header&lt;/code&gt; 바이트 순서 표시가있는 파일의 시작을 읽을 때 선택하지 않은, 유니 코드 문자 (비 분리 공백 폭 제로) U + FEFF는 문자열 내용의 첫 번째 문자로 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3cb249ea0f28d0b2a75ca2a7f403cf2a7474c16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; is a reference, this is the rvalue reference version of the same type. Otherwise (such as if the wrapped iterator returns by value), this is &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; unchanged</source>
          <target state="translated">경우 &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; 기준은,이 같은 형태의 r- 수치 참조 버전이다. 그렇지 않은 경우 (예 : 랩핑 된 반복자가 값으로 리턴하는 경우) &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="949f1f6e0f15336724ef8f4cda94b4e5b055d867" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;std::wcstok&lt;/code&gt; for this particular wide string. The function searches for the first wide character which is</source>
          <target state="translated">경우 &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , 통화가 처음하는 전화로 처리됩니다 &lt;code&gt;std::wcstok&lt;/code&gt; 이 특정 넓은 문자열. 이 함수는 첫 번째 넓은 문자 인</target>
        </trans-unit>
        <trans-unit id="919d8cd3a8b53f2e18bf07280d97eede84dc299d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;strtok&lt;/code&gt; for this particular string. The function searches for the first character which is</source>
          <target state="translated">경우 &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , 통화가 처음 호출로 처리됩니다 &lt;code&gt;strtok&lt;/code&gt; 를 이 특정 문자열. 이 함수는 첫 번째 문자를 검색합니다</target>
        </trans-unit>
        <trans-unit id="98634ae53f4036b3363ce6cbf8811e0fd64f6b0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;std::wcstok&lt;/code&gt;: the function continues from where it left in previous invocation with the same &lt;code&gt;*ptr&lt;/code&gt;. The behavior is the same as if the pointer to the wide character that follows the last detected token is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , 통화가에 대한 후속 호출로 처리됩니다 &lt;code&gt;std::wcstok&lt;/code&gt; : 함수가이 같은으로 이전 호출에 남아있는 곳에서 계속 &lt;code&gt;*ptr&lt;/code&gt; . 동작은 마지막으로 감지 된 토큰 다음에 나오는 넓은 문자에 대한 포인터가 &lt;code&gt;str&lt;/code&gt; 로 전달되는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="66ec70311bf6aedd6bdb60bbe9f819c870804830" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;strtok&lt;/code&gt;: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , 호출이하는 후속 호출로 처리됩니다 &lt;code&gt;strtok&lt;/code&gt; 를 : 함수는 이전 호출에 남아있는 곳에서 계속됩니다. 동작은 이전에 저장된 포인터가 &lt;code&gt;str&lt;/code&gt; 로 전달되는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0f00ca1c926f1dd5787b11275ecdbddb1666242a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.flags() &amp;amp; str.adjustfield&lt;/code&gt; equals &lt;code&gt;str.internal&lt;/code&gt;, the fill characters are inserted where &lt;code&gt;none&lt;/code&gt; or &lt;code&gt;space&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">경우 &lt;code&gt;str.flags() &amp;amp; str.adjustfield&lt;/code&gt; 동일 &lt;code&gt;str.internal&lt;/code&gt; 채우기 문자가 삽입되는 곳 &lt;code&gt;none&lt;/code&gt; 또는 &lt;code&gt;space&lt;/code&gt; 서식 패턴이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1fa5ee33bcecc47b8c59730282fe17b184cd0916" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.flags() &amp;amp; str.showbase&lt;/code&gt; is non-zero (the &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; manipulator was used), then the currency symbol or string is generated by calling &lt;code&gt;mp.curr_symbol()&lt;/code&gt; and placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;symbol&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">경우 &lt;code&gt;str.flags() &amp;amp; str.showbase&lt;/code&gt; 있다 비제합니다 ( &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; 매니퓰레이터 사용한 예), 현재 심볼 또는 캐릭터 호출하여 생성 &lt;code&gt;mp.curr_symbol()&lt;/code&gt; 출력 순서로 배치 &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;symbol&lt;/a&gt;&lt;/code&gt; 에 나타난다 형식화 패턴</target>
        </trans-unit>
        <trans-unit id="1f05ec444fc20459f458416318c1d398ea88ac26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.width()&lt;/code&gt; is non-zero (e.g. &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; was just used) and the number of CharT's after Stage 2 is less than &lt;code&gt;str.width()&lt;/code&gt;, then copies of the &lt;code&gt;fill&lt;/code&gt; character are inserted at the position indicated by padding to bring the length of the sequence to &lt;code&gt;str.width()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;str.width()&lt;/code&gt; 제로가 아닌 (예를 들어, &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 단지 사용) 및 2 단계 이후 차트의의 수보다 적은 &lt;code&gt;str.width()&lt;/code&gt; , 다음의 사본을 &lt;code&gt;fill&lt;/code&gt; 문자가 위치에 삽입은로 표시 패딩을 사용하여 시퀀스 길이를 &lt;code&gt;str.width()&lt;/code&gt; 로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b4dee41190e5faa1ca923bd889668d6289ee307f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stream&lt;/code&gt; is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.</source>
          <target state="translated">경우 &lt;code&gt;stream&lt;/code&gt; 널 포인터, 열려있는 모든 출력 스트림은 사람 라이브러리 패키지 내에서 조작하거나 프로그램에, 그렇지 않으면 직접 액세스 할 수 없습니다 포함, 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="86e307545d5f002abef118325d5d3eb89a16b86d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t &amp;gt;= 0 &amp;amp;&amp;amp; t &amp;lt;= 1&lt;/code&gt;, the result is finite.</source>
          <target state="translated">만약 &lt;code&gt;t &amp;gt;= 0 &amp;amp;&amp;amp; t &amp;lt;= 1&lt;/code&gt; 의 결과는 유한하다.</target>
        </trans-unit>
        <trans-unit id="a189eebdd38827d96375b30f0eca568ef1adf1d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t == 0&lt;/code&gt;, the result is equal to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;t == 0&lt;/code&gt; , 그 결과는 동일하다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bcbb6f49ce7e941481d92cd71eec73b19dcdaf2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t == 1&lt;/code&gt;, the result is equal to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;t == 1&lt;/code&gt; , 그 결과는 동일하다 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35800f7e22639b64ad669cbfd0243c9e80c3180f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t1&lt;/code&gt; does not satisfy the previous items, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;(*t1).*f&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;t1&lt;/code&gt; 이전 항목을 만족시키지 않는 다음 &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; 동일하다 &lt;code&gt;(*t1).*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f9a950127cdac35950e54e7e7f5e552a16d7cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t1&lt;/code&gt; does not satisfy the previous items, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;t1&lt;/code&gt; 다음 이전 항목을 만족시키지 않는 &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; 에 상당 &lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="996fc7fea5a596a0a7f8caf3724383378f3397b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;rv&lt;/code&gt; do not refer to the same object , the value of &lt;code&gt;t&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the assignment.</source>
          <target state="translated">경우 &lt;code&gt;t&lt;/code&gt; 및 &lt;code&gt;rv&lt;/code&gt; 같은 객체를 참조하지 않는 값 &lt;code&gt;t&lt;/code&gt; 은 의 값에 해당 &lt;code&gt;rv&lt;/code&gt; 할당하기 전에.</target>
        </trans-unit>
        <trans-unit id="70f1cc8280f18381cdb55a983658d6c5ccf12f01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; represents a time point during a leap second insertion, the last representable value of &lt;code&gt;sys_time&lt;/code&gt; prior to the insertion of the leap second is returned. In all other cases, &lt;code&gt;utc_clock::from_sys(utc_clock::to_sys(t)) == t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 윤초 삽입 동안의 시점을 나타내는 경우 , 윤초 삽입 전에 &lt;code&gt;sys_time&lt;/code&gt; 의 마지막 표현 가능한 값 이 리턴된다. 다른 모든 경우에는 &lt;code&gt;utc_clock::from_sys(utc_clock::to_sys(t)) == t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="94842a48923ccea749a7b322cc54918cec93ee9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tbl&lt;/code&gt; is null, &lt;code&gt;classic_table()&lt;/code&gt; is used by all classification member functions. Otherwise, &lt;code&gt;tbl&lt;/code&gt; must be a pointer to the first element of an array of masks, at least &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; in size, and that array is used by all of this facet's classification member functions.</source>
          <target state="translated">경우 &lt;code&gt;tbl&lt;/code&gt; 널이다 &lt;code&gt;classic_table()&lt;/code&gt; 모든 분류 부재 함수가 사용된다. 그렇지 않으면 &lt;code&gt;tbl&lt;/code&gt; 은 마스크 배열의 첫 번째 요소 (최소 &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; 하며 해당 패싯의 모든 분류 멤버 함수에서 해당 배열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="60c9f234140c969280e37d90ead363e725f41fef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;this-&amp;gt;index() == rhs.index()&lt;/code&gt;, may throw any exception thrown by &lt;code&gt;swap(std::get&amp;lt;i&amp;gt;(*this), std::get&amp;lt;i&amp;gt;(rhs))&lt;/code&gt; with i being index().</source>
          <target state="translated">만약 &lt;code&gt;this-&amp;gt;index() == rhs.index()&lt;/code&gt; 에 의해 발생 예외 던질 수 &lt;code&gt;swap(std::get&amp;lt;i&amp;gt;(*this), std::get&amp;lt;i&amp;gt;(rhs))&lt;/code&gt; 나 인덱스로 되 ().</target>
        </trans-unit>
        <trans-unit id="b62e0ed67d83925a4f019bee274f6aaf3d721d41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;time_point&lt;/code&gt; has lower precision, it is implementation defined whether the value is rounded or truncated.</source>
          <target state="translated">경우 &lt;code&gt;time_point&lt;/code&gt; 이 낮은 정밀도를 가지고, 상기 값은 반올림 또는 절단되어 있는지 여부를 정의 구현이다.</target>
        </trans-unit>
        <trans-unit id="f39154959538bec12350c40feb86c48847d93013" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_duration&lt;/code&gt; is less or equal &lt;code&gt;timeout_duration.zero()&lt;/code&gt;, the function behaves like &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;timeout_duration&lt;/code&gt; 가 같거나 그보다 &lt;code&gt;timeout_duration.zero()&lt;/code&gt; 와 같은 기능 동작합니다 &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08ae6a5e709170320f3bb275e55a3ea39cb81509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_duration&lt;/code&gt; is less or equal &lt;code&gt;timeout_duration.zero()&lt;/code&gt;, the function behaves like &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;timeout_duration&lt;/code&gt; 이 &lt;code&gt;timeout_duration.zero()&lt;/code&gt; 보다 작거나 같은 경우 , 함수는 &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="94988ecccf327007cfe6e9600377b3a54d244a96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_time&lt;/code&gt; has already passed, this function behaves like &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;timeout_time&lt;/code&gt; 이 이미 통과 같은이 기능의 동작합니다 &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91299d6184527b913bd3a4c6c83fcc921365520d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_time&lt;/code&gt; has already passed, this function behaves like &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;timeout_time&lt;/code&gt; 이 이미 통과,이 기능의 동작합니다 같은 &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="985b3af9a0f9c066a712acb80e6a80e55df51846" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to&lt;/code&gt; does not exist, first executes &lt;code&gt;create_directory(to, from)&lt;/code&gt; (creates the new directory with a copy of the old directory's attributes)</source>
          <target state="translated">경우 &lt;code&gt;to&lt;/code&gt; 존재하지 않는, 첫 번째가 실행이 &lt;code&gt;create_directory(to, from)&lt;/code&gt; (이전 디렉토리의 속성의 사본을 새 디렉토리를 생성합니다)</target>
        </trans-unit>
        <trans-unit id="869575bcc3b25a2f60e9720ddcdac4374d7f2bc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time between two UTC &lt;code&gt;time_point&lt;/code&gt;s, those two &lt;code&gt;time_point&lt;/code&gt;s will be the same, and that &lt;code&gt;time_point&lt;/code&gt; will be returned.</source>
          <target state="translated">&lt;code&gt;tp&lt;/code&gt; 가 두 UTC &lt;code&gt;time_point&lt;/code&gt; 사이에 존재하지 않는 시간을 나타내는 경우 두 &lt;code&gt;time_point&lt;/code&gt; 는 동일하며 &lt;code&gt;time_point&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b14c2985a9828fa673de15ad4b5432c7eec337ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock()&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">경우 &lt;code&gt;try_lock()&lt;/code&gt; , 이전에 성공 &lt;code&gt;unlock()&lt;/code&gt; 동일한 개체에 대한 작업을</target>
        </trans-unit>
        <trans-unit id="f68c72d2cc410f03ed4771fd243cfec6c94f974e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;try_lock&lt;/code&gt; 가 이미 소유 한 스레드에 의해 호출되는 &lt;code&gt;mutex&lt;/code&gt; 의 모드 (공유 또는 전용)에서을, 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="2bcbd407f9c0eff5a0a0eb82929bbebd2a38ec19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;try_lock&lt;/code&gt; 가 이미 소유 한 스레드에 의해 호출되는 &lt;code&gt;mutex&lt;/code&gt; , 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="332a65a0871564214a2da39082b39ae682472b5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for(duration)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">경우 &lt;code&gt;try_lock_for(duration)&lt;/code&gt; , 이전의 성공 &lt;code&gt;unlock()&lt;/code&gt; 동일한 개체에 대한 작업을</target>
        </trans-unit>
        <trans-unit id="57e45d172606dd71b8ad2f147535c7a9c26b7b2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;try_lock_for&lt;/code&gt; 가 이미 소유 한 스레드에 의해 호출되는 &lt;code&gt;mutex&lt;/code&gt; 의 모드 (공유 또는 전용)에서을, 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="e2913e9dfd8101ebfeeca847b3fbb13f36f0e999" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;try_lock_for&lt;/code&gt; 가 이미 소유 한 스레드에 의해 호출되는 &lt;code&gt;mutex&lt;/code&gt; , 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="3e3938b542994009b61584f5206da7eb84b567ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared()&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">경우 &lt;code&gt;try_lock_shared()&lt;/code&gt; 전에 성공 &lt;code&gt;unlock()&lt;/code&gt; 동일한 개체에 대한 작업을</target>
        </trans-unit>
        <trans-unit id="88e17bb477f3b0dc9840117e325cc5419c64d635" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_for(duration)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">경우 &lt;code&gt;try_lock_shared_for(duration)&lt;/code&gt; , 이전의 성공 &lt;code&gt;unlock()&lt;/code&gt; 동일한 개체에 대한 작업을</target>
        </trans-unit>
        <trans-unit id="3cb436a54d222a2207a53f9e58e0c49e9a0e682d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;try_lock_shared_for&lt;/code&gt; 가 이미 소유 한 스레드에 의해 호출되는 &lt;code&gt;mutex&lt;/code&gt; 의 모드 (공유 또는 전용)에서을, 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="2b4a06da759220650268238bcf1faa9bc1408f74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_until(time_point)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">경우 &lt;code&gt;try_lock_shared_until(time_point)&lt;/code&gt; , 이전에 성공 &lt;code&gt;unlock()&lt;/code&gt; 동일한 개체에 대한 작업을</target>
        </trans-unit>
        <trans-unit id="2b919196e38c014769e5a77c9fece0fc9c129522" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;try_lock_shared_until&lt;/code&gt; 가 이미 소유 한 스레드에 의해 호출되는 &lt;code&gt;mutex&lt;/code&gt; 의 모드 (공유 또는 전용)에서을, 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="bd2e7ac4f22bfd95548a0a07a00613e5cf96f270" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until(time_point)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">경우 &lt;code&gt;try_lock_until(time_point)&lt;/code&gt; , 이전에 성공 &lt;code&gt;unlock()&lt;/code&gt; 동일한 개체에 대한 작업을</target>
        </trans-unit>
        <trans-unit id="ee385f3e6edb77e1716bf26ec86831203e82ffc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;try_lock_until&lt;/code&gt; 가 이미 소유 한 스레드에 의해 호출되는 &lt;code&gt;mutex&lt;/code&gt; 의 모드 (공유 또는 전용)에서을, 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="a43b3e939093abea19b584b116c2b4c2095ef181" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;try_lock_until&lt;/code&gt; 가 이미 소유 한 스레드에 의해 호출되는 &lt;code&gt;mutex&lt;/code&gt; , 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="5c29403a2f55f94d0b6bdf83a06a0e7ac5dae5f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is an array type, all dimensions other than the first must be specified as positive &lt;a href=&quot;constant_expression&quot;&gt;integral constant expression&lt;/a&gt;(until C++14)&lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;(since C++14), but the first dimension may be any expression convertible to &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;. This is the only way to directly create an array with size defined at runtime, such arrays are often referred to as</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 배열 형 이외의 모든 치수는 제 1 포지티브로 지정해야 &lt;a href=&quot;constant_expression&quot;&gt;적분 상수 식&lt;/a&gt; (C ++ 14까지) &lt;a href=&quot;constant_expression&quot;&gt;상수 식 변환&lt;/a&gt; 형의 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 하지만, 제 치수 월 (C ++ 14 보낸) &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 로 변환 가능한 표현식이어야합니다 . 이것은 런타임에 정의 된 크기로 배열을 직접 만드는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="987dae04e3210104881f78fd36a73b5af3bafb97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is not a &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;standard layout type&lt;/a&gt;, the behavior is undefined(until C++17)use of the &lt;code&gt;offsetof&lt;/code&gt; macro is conditionally-supported(since C++17).</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 이 &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;표준 레이아웃 &lt;/a&gt;유형 이 아닌 경우 동작은 정의되지 않으며 (C ++ 17까지) 매크로 &lt;code&gt;offsetof&lt;/code&gt; 사용 은 조건부로 지원됩니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="8b86993c41ea614db0c1542ae39296df1802bd91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeid&lt;/code&gt; is used on an object under construction or destruction (in a destructor or in a constructor, including constructor's &lt;a href=&quot;constructor&quot;&gt;initializer list&lt;/a&gt; or &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt;), then the &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object referred to by this &lt;code&gt;typeid&lt;/code&gt; represents the class that is being constructed or destroyed even if it is not the most-derived class.</source>
          <target state="translated">만약 &lt;code&gt;typeid&lt;/code&gt; (소멸자 또는 생성자의 포함 생성자에서 건설 또는 파괴에서 객체에 사용되는 &lt;a href=&quot;constructor&quot;&gt;초기화 목록&lt;/a&gt; 또는 &lt;a href=&quot;data_members#Member_initialization&quot;&gt;기본 멤버 이니셜 라이저&lt;/a&gt; ), 다음 &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 객체가이에 의해 참조 &lt;code&gt;typeid&lt;/code&gt; 건설 중이거나 클래스를 나타냅니다 가장 파생 된 클래스가 아니더라도 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="2c8bc9e007e9eab3e896a3aaff472ee164636be8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetc&lt;/code&gt; were performed, read operations retrieve the pushed-back characters in reverse order of &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ungetc&lt;/code&gt; 가 더 개재 판독이나 재배치없이 여러 번 호출 때문에 실패 할 수있다 (즉, 하나의 크기의 푸시 백 버퍼가 보장되지만, 어떤 큰 버퍼는 구현 정의 됨). 여러 개의 성공적인 &lt;code&gt;ungetc&lt;/code&gt; 가 수행 된 경우 읽기 조작은 &lt;code&gt;ungetc&lt;/code&gt; 의 역순으로 푸시 백 된 문자를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="b93c880a13d41dd5f02146648e0bcdb941ad4432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetwc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetwc&lt;/code&gt; were performed, read operations retrieve the pushed-back wide characters in reverse order of &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;ungetwc&lt;/code&gt; 가 더 개재 판독이나 재배치없이 여러 번 호출 때문에 실패 할 수있다 (즉, 하나의 크기의 푸시 백 버퍼가 보장되지만, 어떤 큰 버퍼는 구현 정의 됨). 여러 개의 성공적인 &lt;code&gt;ungetwc&lt;/code&gt; 가 수행 된 경우 읽기 조작은 &lt;code&gt;ungetwc&lt;/code&gt; 와 역순으로 푸시 백 된 와이드 문자를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="1e79c0c8a7bbdaf2db59b21cc3df9306376d12ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;using: namespace&lt;/code&gt; appears in the beginning of an attribute list, no other attributes in the attribute list can specify a namespace: the namespace specified in a using applies to them all:</source>
          <target state="translated">경우 &lt;code&gt;using: namespace&lt;/code&gt; 속성리스트의 시작 부분에 나타납니다, 속성리스트에서 다른 속성은 네임 스페이스를 지정할 수 있습니다 : A를 사용하여 모든 적용에 지정된 네임 스페이스를 :</target>
        </trans-unit>
        <trans-unit id="08c3c3c90c1cbb009889979159acc6ccce066254" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.index() != w.index()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">만약 &lt;code&gt;v.index() != w.index()&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="73386b30a8cd9063a65cadd69c4f27f4b4729d4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.index() != w.index()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">만약 &lt;code&gt;v.index() != w.index()&lt;/code&gt; , 반환 &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="60664f03dd91064cc8bcd5281122b9be42c2ecf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;v.valueless_by_exception()&lt;/code&gt; 인 경우 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="056416cb18ca600a6a47288399d10085b1d96979" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">만약 &lt;code&gt;v.valueless_by_exception()&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="c3e0828292e64efc70577bb97a628f74f2c468ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; compares equivalent to either bound, returns a reference to &lt;code&gt;v&lt;/code&gt;, not the bound.</source>
          <target state="translated">만약 &lt;code&gt;v&lt;/code&gt; 가 어느 한 쪽과 동등한지를 비교하는 , 경계가 아닌 &lt;code&gt;v&lt;/code&gt; 에 대한 참조를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="75a090849c6c030efd853b2c4e1bec200144bf8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;va_arg&lt;/code&gt; is called when there are no more arguments in &lt;code&gt;ap&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">경우 &lt;code&gt;va_arg&lt;/code&gt; 를가 에서 더 이상 인수가없는 경우라고 &lt;code&gt;ap&lt;/code&gt; , 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="adb7aa1f42112a75264739ee28d6e8827e04fc33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;w.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">만약 &lt;code&gt;w.valueless_by_exception()&lt;/code&gt; 인 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1ec2d68dd14c2554d3c630fe1822a69b8ee574f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;w.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">만약 &lt;code&gt;w.valueless_by_exception()&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="4a2e019de572732991114a4b9ac83594fefd4e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wc&lt;/code&gt; is the null character, the null byte is written to &lt;code&gt;s&lt;/code&gt;, preceded by any shift sequences necessary to restore the initial shift state.</source>
          <target state="translated">경우 &lt;code&gt;wc&lt;/code&gt; 널 문자, 널 바이트에 기록 &lt;code&gt;s&lt;/code&gt; 초기 변화의 상태를 복원하는 데 필요한 모든 시프트 시퀀스 앞에.</target>
        </trans-unit>
        <trans-unit id="2df38e58a0b81e321cbdefacc5fbfee02970c44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::in&lt;/code&gt; and this buffer is open for reading (that is, if &lt;code&gt;((which &amp;amp; ios_base::in) == ios_base::in&lt;/code&gt;), then repositions the read pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; inside the get area as described below</source>
          <target state="translated">경우 &lt;code&gt;which&lt;/code&gt; 포함 &lt;code&gt;ios_base::in&lt;/code&gt; 이 버퍼 경우하다 (판독 열려 &lt;code&gt;((which &amp;amp; ios_base::in) == ios_base::in&lt;/code&gt; 예), 판독 포인터를 재배치 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; 안쪽 아래 설명과 같이 영역을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="076480d9e864ea3eea8105519a4f861e38abff0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::in&lt;/code&gt; and this buffer is open for reading, then repositions the read pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; inside the get area as described below</source>
          <target state="translated">&lt;code&gt;ios_base::in&lt;/code&gt; &lt;code&gt;which&lt;/code&gt; 포함 된 경우 이 버퍼 판독 개방하고 판독 포인터 재배치 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; 후술 얻기 영역 안을</target>
        </trans-unit>
        <trans-unit id="412981fa397417a50c5b81ce7315076f976f90c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::out&lt;/code&gt; and this buffer is open for writing (that is, &lt;code&gt;(which &amp;amp; ios_base::out) == ios_base::out&lt;/code&gt;), then repositions the write pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; inside the put area as described below</source>
          <target state="translated">경우 &lt;code&gt;which&lt;/code&gt; 포함 &lt;code&gt;ios_base::out&lt;/code&gt; 하고 현재의 버퍼이고, 그 (기록을 위해 오픈 &lt;code&gt;(which &amp;amp; ios_base::out) == ios_base::out&lt;/code&gt; 후 재배치 라이트 포인터) &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; 안에 넣어 영역 아래와 같이</target>
        </trans-unit>
        <trans-unit id="ebb77a9083ead2007e8eed624a96ab97b1b10e5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::out&lt;/code&gt; and this buffer is open for writing, then repositions the write pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; inside the put area as described below</source>
          <target state="translated">경우 &lt;code&gt;which&lt;/code&gt; 포함 &lt;code&gt;ios_base::out&lt;/code&gt; 이 버퍼가 쓰기 위해 열려, 다음 기록 포인터를 재배치 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; 풋 영역 내에 후술하는 바와 같이이</target>
        </trans-unit>
        <trans-unit id="32ac61f3d8f163e81b3115553fcd68a7ebccec80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes both &lt;code&gt;ios_base::in&lt;/code&gt; and &lt;code&gt;ios_base::out&lt;/code&gt; and the buffer is open for both reading and writing (&lt;code&gt;(which &amp;amp; (ios_base::in|ios_base::out)) ==(ios_base::in|ios_base::out)&lt;/code&gt;), and &lt;code&gt;dir&lt;/code&gt; is either &lt;code&gt;ios_base::beg&lt;/code&gt; or &lt;code&gt;ios_base::end&lt;/code&gt;, then repositions both read and write pointers as described below.</source>
          <target state="translated">경우 &lt;code&gt;which&lt;/code&gt; 모두 포함 &lt;code&gt;ios_base::in&lt;/code&gt; 와 &lt;code&gt;ios_base::out&lt;/code&gt; 버퍼는 읽기와 쓰기 (모두 열려 있습니다 &lt;code&gt;(which &amp;amp; (ios_base::in|ios_base::out)) ==(ios_base::in|ios_base::out)&lt;/code&gt; )이고 &lt;code&gt;dir&lt;/code&gt; 은 &lt;code&gt;ios_base::beg&lt;/code&gt; 또는 &lt;code&gt;ios_base::end&lt;/code&gt; 이고, 아래에 설명 된대로 읽기 및 쓰기 포인터의 위치를 ​​변경합니다.</target>
        </trans-unit>
        <trans-unit id="d56bcb44c21f33d202f66d86615b3fd4c47e7a59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes both &lt;code&gt;ios_base::in&lt;/code&gt; and &lt;code&gt;ios_base::out&lt;/code&gt; and the buffer is open for both reading and writing, and &lt;code&gt;when&lt;/code&gt; is either &lt;code&gt;ios_base::beg&lt;/code&gt; or &lt;code&gt;ios_base::end&lt;/code&gt;, then repositions both read and write pointers as described below.</source>
          <target state="translated">경우 &lt;code&gt;which&lt;/code&gt; 모두 포함 &lt;code&gt;ios_base::in&lt;/code&gt; 와 &lt;code&gt;ios_base::out&lt;/code&gt; 버퍼는 읽기와 쓰기 모두 개방하고, &lt;code&gt;when&lt;/code&gt; 다음 중 하나입니다 &lt;code&gt;ios_base::beg&lt;/code&gt; 또는 &lt;code&gt;ios_base::end&lt;/code&gt; 후술하는 바와 같이, 다음 읽기 및 쓰기 포인터 모두를 재배치한다.</target>
        </trans-unit>
        <trans-unit id="9292e4a3413eb133a7f76bc6e4fe74a238c5b8bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, domain error</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 모두 제로인 도메인 오류</target>
        </trans-unit>
        <trans-unit id="8a5e321969b66fbefa9cdd24eacf386b98fffc2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, range error does not occur either</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 모두 제로인 범위 오차 중 발생하지</target>
        </trans-unit>
        <trans-unit id="1a0e37c7feac7db699e4130a50b199ceedd910f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;y&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">만약 &lt;code&gt;x&lt;/code&gt; IS &amp;plusmn; &amp;infin;와 &lt;code&gt;y&lt;/code&gt; NaN이는 NaN이 반환되지 않고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 발생합니다</target>
        </trans-unit>
        <trans-unit id="8abb2fb48327f23dca2adde7572dddc2e811ad8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin;, &amp;plusmn;0 is returned, and &amp;plusmn;&amp;infin; is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; IS &amp;plusmn; &amp;infin;, &amp;plusmn; 0이 반환되고, &amp;plusmn; &amp;infin;가 저장된다 &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b9e315fe80911902dd03d84688ec8a34941e551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 는 &amp;plusmn;이다 &amp;infin;, 그것은 수정되지 않은 반환</target>
        </trans-unit>
        <trans-unit id="0d517d0ca1b88b420f9a711836c289f554f6f27a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;y&lt;/code&gt; is not zero, &amp;plusmn;0 is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; &amp;plusmn; 0이고 &lt;code&gt;y&lt;/code&gt; 0이 반환되고, &amp;plusmn; 0이 아닌</target>
        </trans-unit>
        <trans-unit id="dcd1a0509c1e6bf68cbedd9162ffec0cc1242173" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;0 is returned, and &amp;plusmn;0 is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; &amp;plusmn; 0이고, &amp;plusmn; 0이 반환되고, &amp;plusmn; 0에 저장 &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb707c1e458814fee624b6c9deb60721133b5b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 는 &amp;plusmn; 0, 그것은 수정되지 않은 반환</target>
        </trans-unit>
        <trans-unit id="f41dcbd3d46c8769c4b2fb80c374a0e5c0d62c23" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is negative, &lt;code&gt;-&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 는 음수, &lt;code&gt;-&amp;pi;/2&lt;/code&gt; 를 반환</target>
        </trans-unit>
        <trans-unit id="d6968a9e1c046845040fc68d63a376b5e6b8b85a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is positive, &lt;code&gt;+&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 는 양의, &lt;code&gt;+&amp;pi;/2&lt;/code&gt; 를 반환</target>
        </trans-unit>
        <trans-unit id="742021246f19681537f6e140bb629b64b21e4348" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-0&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 제한된과 음수, &lt;code&gt;-0&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="854f55847c1c8f45111c844b75fe0c4c049cc744" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+0&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이다 &lt;code&gt;+&amp;infin;&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 제한된 긍정적이고, &lt;code&gt;+0&lt;/code&gt; 은 리턴</target>
        </trans-unit>
        <trans-unit id="70312266975b00e8f11c41c1477d3626e83ccaa9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 제한된과 음수, &lt;code&gt;-&amp;pi;&lt;/code&gt; 는 리턴</target>
        </trans-unit>
        <trans-unit id="adfdc77216731e53faa0611a28dda473ddae36f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이다 &lt;code&gt;-&amp;infin;&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 제한된 긍정적이고, &lt;code&gt;+&amp;pi;&lt;/code&gt; 가 반환</target>
        </trans-unit>
        <trans-unit id="c80b06556a1152fcb8c22f136b6473885d57b346" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 가 NaN의 NaN이 반환된다</target>
        </trans-unit>
        <trans-unit id="226af42b45e3a0a3b2917fd765deb1015d6b2d9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, NaN is returned, and NaN is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 가 NaN의 NaN이 반환되고, NaN이은에 저장됩니다 &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86712aaf103771c2d7819baa87af27b031d94ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, then NaN with the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 가 의 기호 NaN의 다음 NaN이 인 &lt;code&gt;y&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b0446e18a46c6733752844d64ec7ed2bde15bde6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is negative, a domain error may occur</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 음수, 도메인 오류가 발생할 수도</target>
        </trans-unit>
        <trans-unit id="0d4fee627ff864097e3bcf0e10e6f4e13892a483" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not zero, calculates the largest integral power of two that is not greater than &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is zero, returns zero.</source>
          <target state="translated">경우에 &lt;code&gt;x&lt;/code&gt; 는 0이 아닌,보다 큰 두개의 최대 전력 적분 계산 &lt;code&gt;x&lt;/code&gt; . 경우 &lt;code&gt;x&lt;/code&gt; 는 제로, 반환 제로.</target>
        </trans-unit>
        <trans-unit id="2a471c8ab6033df659f209b9c95baa221163a386" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not zero, calculates the number of bits needed to store the value &lt;code&gt;x&lt;/code&gt;, that is, \(1 + \lfloor log_2(x) \rfloor\)1 + floor(log</source>
          <target state="translated">만약 &lt;code&gt;x&lt;/code&gt; 0이 아닌 값을 저장하는데 필요한 비트 수를 계산 &lt;code&gt;x&lt;/code&gt; \ (1 + \ lfloor log_2 (X) \ rfloor \) 1 + 층이고, (로그</target>
        </trans-unit>
        <trans-unit id="e48634bd82e2df6f62aec245642cb59777238384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;x&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; &amp;plusmn; &amp;infin;이고 &lt;code&gt;x&lt;/code&gt; IS 유한, &lt;code&gt;x&lt;/code&gt; 는 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a2ddc1042c63e353212b7799d89a1b092aed734a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;x&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; &amp;plusmn; 0이고, &lt;code&gt;x&lt;/code&gt; NaN이는 NaN이 반환되지 않고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 상승</target>
        </trans-unit>
        <trans-unit id="1c4d4232381ec31f82701b3b12b902639c119342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 는 것입니다 구현 산술 연산에서 지속적으로 서명 제로를 지원하는 경우 -0, 결과는 부정적이다.</target>
        </trans-unit>
        <trans-unit id="bb77d357b03480982a5cb3af7fe4d1a54b4629b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; IS &lt;code&gt;+&amp;infin;&lt;/code&gt; 는 , &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="c32d4c116dec5e5a3f5f016622351bfcdbb1d9a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; IS &lt;code&gt;-&amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="f2d2be60f0f9dee6ef4e60532e876177666a7509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 유한이다 &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="04ca9c751f9bab309085f696c5ce7e061eb53bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is negative or &lt;code&gt;-0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 네거티브 또는 &lt;code&gt;-0&lt;/code&gt; , &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="6c2e024aa12ac316eec5865ba0f65ada4018df50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is positive or &lt;code&gt;+0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;0&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 이다 &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 과 &lt;code&gt;x&lt;/code&gt; 가 양수 또는 &lt;code&gt;+0&lt;/code&gt; , &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="db8ff25a6b35fd58c6e2ad1d8257aa1fdbbc1afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, but the domain error does not occur, zero is returned.</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 는 제로이지만, 도메인 오류가 발생하지 않습니다, 0을 반환한다.</target>
        </trans-unit>
        <trans-unit id="934c80b3e977f6c9efabb47ff6836e6a1d4145a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, pole error does not occur</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 는 제로, 극 오류가 발생하지 않습니다</target>
        </trans-unit>
        <trans-unit id="d5af0b5b04311e67b5c965ddebdd4dcbe743ea19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, the value stored in &lt;code&gt;*quo&lt;/code&gt; is unspecified.</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 는 제로에 저장된 값 &lt;code&gt;*quo&lt;/code&gt; 지정된다.</target>
        </trans-unit>
        <trans-unit id="687d9b31d16e817da643762a7f7e3d0c38df64e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z == std::chrono::choose::earliest&lt;/code&gt;, returns the earlier &lt;code&gt;sys_time&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;z == std::chrono::choose::earliest&lt;/code&gt; , 이전 반환 &lt;code&gt;sys_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="966a406501614a5b1c8f3e06813bd52dd307c0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z == std::chrono::choose::latest&lt;/code&gt;, returns the later &lt;code&gt;sys_time&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;z == std::chrono::choose::latest&lt;/code&gt; , 나중에 반환 &lt;code&gt;sys_time&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7157b6daee7178a7db7bf2b7f98b21bf5509b46f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; , 결과가 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="647d48a9a025440a82db0559ba003eb986c87f48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;&amp;infin;)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; , 결과는 &lt;code&gt;(NaN,&amp;plusmn;&amp;infin;)&lt;/code&gt; (허수 부분의 부호 미지정이다)</target>
        </trans-unit>
        <trans-unit id="5a29bd926acd8a4ed08d36ea492ffa17b0f65b06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/2,-0)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; 의 결과는 &lt;code&gt;(&amp;pi;/2,-0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d01365aea17ec2d928785c236cc8a0625a50a091" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; 의 결과는 &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aca45f2c4af7ce54c221c839224dcc7526370cce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,+0)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; , 그 결과는 &lt;code&gt;(+0,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b21cb1c0525d180376e59f65f141faac479dcda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; , 그 결과는 &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2af12e24fdf73967ee7ab61f7c4d443b37739feb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/2,NaN)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; 결과는 &lt;code&gt;(&amp;pi;/2,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b917afe8309bdfdc0889e4ce326dd3daf35a1e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , 결과는 &lt;code&gt;(&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc20a1d28cbfd032ecdaa31a57f9d5ee6abc083b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; 의 결과는 &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (실부의 징조 불특정) 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 상승</target>
        </trans-unit>
        <trans-unit id="349b76e235126b678fc00eb96b36b916c8c7d87d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised (the sign of the real part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; 의 결과는 &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 이 상승된다 (실수 부분의 부호가 지정되어 있지 않은)</target>
        </trans-unit>
        <trans-unit id="6a80692535fb97c3bb378cc0e2235f9e6f89868d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/4)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , 결과는 &lt;code&gt;(+&amp;infin;,&amp;pi;/4)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="992a6280563e8dfa9fd680864cf94914e2af8168" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , 결과는 &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02e1613ba0e3f7e9f51fc7723495ad1862a78f76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; 의 결과는 &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (허수 부분의 부호 미지정이다)</target>
        </trans-unit>
        <trans-unit id="dc7e1f5800458c8b0514039db23f6f89349f39ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; , 결과는 &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4153d9975c2c48f8bb5202575acc2cae61f572c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; 결과는 &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (실수 부분의 부호 미지정)</target>
        </trans-unit>
        <trans-unit id="eedb8eec778280d3bcff49c582c5fed9ffc52c94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; 결과는 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7210962b1c353ac908b8a5cf3e83977c0e1052f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+0,NaN)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; 결과는 &lt;code&gt;(+0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9373e34e81874d8368cad6f4032f12ba748b7b06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; 결과는 &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (허수 부분의 부호를 지정한다)</target>
        </trans-unit>
        <trans-unit id="856848cafe4c0e36a1ad5ce519dc2788d0c24266" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; 는 (어떤 유한 한 0이 아닌 Y), 그 결과는 &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38ca6940a23e8be06d24918b22d707bed394bbfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; 는 (어떤 유한 제로 Y의 경우), 결과는 &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60544872fb73c896e74dc8e5fa99009db9780c61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; 는 (어떤 유한 한 양의 Y의 경우), 결과는 &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff767095e325e1b139eddcef254efda6cab9a363" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; 는 (어떤 유한 한 양의 Y의 경우), 결과는 &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8364d367783724c998297e19343a0b6ad6b6639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; 는 (어떤 유한 한 양의 Y의 경우), 결과는 &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22be3e2e16abf84434eed428b48e35f8cb791fa2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; 는 (양의 제한된 Y의 경우), 결과는 &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d272464f92e06bbc97dc2b60b9f4b305f104403b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+0,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; 는 (양의 제한된 Y의 경우), 결과는 &lt;code&gt;(+0,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="306394ed21756723034bdce29c6c92e8e8f975e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; 는 (양의 제한된 Y의 경우), 결과는 &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0345ff8887f149be457a2b367cd95f127874bb66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; for finite positive y</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; 의 결과는 &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; 를위한 한정된 양의 Y는</target>
        </trans-unit>
        <trans-unit id="c635e396c397df4cdf68d1595b6463d80b6d5785" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; 의 결과는 &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; (상기 실수 부분의 부호 미지정이다) 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 상승</target>
        </trans-unit>
        <trans-unit id="7380faae64287df92ea78c0159ffc49274893e26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; 의 결과는 &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (허수 부분의 부호가 지정되어 있지 않은)과 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 는 상승</target>
        </trans-unit>
        <trans-unit id="36abdae4241c852caca11998cf42433abb16ad9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,+0)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+0,+0)&lt;/code&gt; 의 결과는 &lt;code&gt;(+0,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2cc8f6469e515605e9eee8a893ab1a721067296" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(-&amp;infin;,+0)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+0,+0)&lt;/code&gt; 의 결과는 &lt;code&gt;(-&amp;infin;,+0)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 는 상승</target>
        </trans-unit>
        <trans-unit id="7ad221569da1d5607bc6299fce77cb0f1118a11f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+0,+0)&lt;/code&gt; 의 결과는 &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01db2d5ca8d8ffef07cf540c0e3df9bf5160209e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+0,NaN)&lt;/code&gt; 결과는 &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89130d186050c98271f4a5474781aa4fa940206d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+0,NaN)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+0,NaN)&lt;/code&gt; 결과는 &lt;code&gt;(+0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6a317cdc33ca73c93da608e61b3b7948bfa218f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+0,NaN)&lt;/code&gt; 결과이다 &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (허수 부분의 부호를 지정하는 것이다)</target>
        </trans-unit>
        <trans-unit id="57dcd4bc678fdc22d1a23e97a110d173535b6bb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+1,+0)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(+1,+0)&lt;/code&gt; 의 결과는 &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 는 상승</target>
        </trans-unit>
        <trans-unit id="874f1995c8e575acb11421be6dbde7ae2969a42f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; 의 결과는 &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (부호 미지정이다)</target>
        </trans-unit>
        <trans-unit id="6c365d4aa356678ae4b570fb49e375a4b4ceb0dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,3&amp;pi;/4)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; 의 결과는 &lt;code&gt;(+&amp;infin;,3&amp;pi;/4)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="253435ca3d0567f0dfee4d306973a5da37660409" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(3&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; 의 결과는 &lt;code&gt;(3&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="579af3f5ca612edf51749805e68c03351cf80f69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt; 의 결과는 &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (부호 미지정이다)</target>
        </trans-unit>
        <trans-unit id="e78b08f96f6d2562376b89afa7f88fc21913df8a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;infin;)&lt;/code&gt; (sign of imaginary part unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt; 결과이다 &lt;code&gt;(NaN,&amp;infin;)&lt;/code&gt; (미지정 허수 부의 부호)</target>
        </trans-unit>
        <trans-unit id="65dfdfd349a76964ed4ba8c2ee003dcba4c70340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; 는 (어떤 유한 한 양의 Y 대)의 결과는 &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec76329fb7fb62b9dc71b27cfd5913208f8099b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;+0cis(y)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; 는 (어떤 유한 한 Y 용)는, 결과는 &lt;code&gt;+0cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75ba7cf268eccbdbd782004a0e2520694fb11834" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(&amp;pi;,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (Y 한정된 양의 경우), 결과는 &lt;code&gt;(&amp;pi;,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3891fa076b6dcc15dfa77f17c6418c9b728c5090" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; 는 (양의 한정을위한 Y)의 결과는 &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56a1f4835fd2810bef4e8bc0c75c1db28c6329f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt;, the result is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; for finite positive y</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; 의 결과는 &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; 한정된 양의 Y에 대한</target>
        </trans-unit>
        <trans-unit id="5e60ca2bf087c1d87278fedd358c4673cece7420" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-0,+0)&lt;/code&gt;, the result is &lt;code&gt;(-&amp;infin;,&amp;pi;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(-0,+0)&lt;/code&gt; 의 결과는 &lt;code&gt;(-&amp;infin;,&amp;pi;)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 는 상승</target>
        </trans-unit>
        <trans-unit id="89a4a107a9008e545e92be5b1df1c9b5efa21860" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; 의 결과는 &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (실수 부분의 부호 미지정)</target>
        </trans-unit>
        <trans-unit id="c1290368fb01d308fdca78b212732f24bae238f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;pi;/2)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; 의 결과는 &lt;code&gt;(&amp;plusmn;0,&amp;pi;/2)&lt;/code&gt; (실수 부분의 부호 미지정)</target>
        </trans-unit>
        <trans-unit id="02167beb857a58577bc43d28d09747ed8b716cf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; 의 결과는 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f227ab1339277464e7e7720ba15b77847f3dc1c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(NaN,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; 결과이다 &lt;code&gt;(NaN,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03b1fb212963f9bff1e0e7f5ce1396cadd18c663" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+0)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,+0)&lt;/code&gt; 의 결과는 &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (허수 부분의 부호를 지정하는 것이다)</target>
        </trans-unit>
        <trans-unit id="a0cec12a18e653673a21b6afcf4d2893eaec9952" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+0)&lt;/code&gt;, the result is &lt;code&gt;(NaN,+0)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,+0)&lt;/code&gt; 의 결과는 &lt;code&gt;(NaN,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48695bc07467a1b54d439f25c1947991dce4e386" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+y)&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,+y)&lt;/code&gt; (어떤 유한 비제 Y의 경우), 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="12d365d3a5d388624d62c5ea98bf5be25d94d436" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 결과이다 &lt;code&gt;(NaN,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43432f0ad9333692ce4de812743b6a8a23d990f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,y)&lt;/code&gt; (임의의 제로가 아닌 유한 Y의 경우), 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="a74898800da79711b4ca4b837358da0c34309906" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,y)&lt;/code&gt; (어떤 유한 Y의 경우), 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="3986c3fa864e6dfc01234c2970facb3af69b5d42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,y)&lt;/code&gt; (어떤 유한 Y의 경우), 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다.</target>
        </trans-unit>
        <trans-unit id="18e3df5ba9c4d12bc748141c867a2ba815fd8273" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any non-zero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,y)&lt;/code&gt; (0이 아닌 Y의 경우), 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="3b8c5fbb845c531633355abb0a0435a2ec8eaaf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any nonzero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,y)&lt;/code&gt; (제로가 아닌 Y의 경우), 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="29a55443041f03e5d510319aa0568a45742e55ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 이고 &lt;code&gt;(NaN,y)&lt;/code&gt; , 그 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="df2ad89444d23b170108bda8da8ca9ee00ba6c6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (어떤 유한 한 0이 아닌 X)의 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 는 상승</target>
        </trans-unit>
        <trans-unit id="e455efcd2e392de8d756291014af13967751bf1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite positive x), the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (임의의 한정된 양의 X의 경우), 결과는 &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2a071dd3e0155d43198db5c9184d3f7c8860d00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(&amp;pi;/2,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; 결과이다 (어떤 한정된 X 용) &lt;code&gt;(&amp;pi;/2,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85ebcf7fb682a9f3ba15fca2bb16f8628b521d02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; 결과이다 (어떤 한정된 X 용) &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a6ecedf7500b1db3b4febd7f8959d0c1390edf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (어떤 한정된 X의 경우), 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 상승된다.</target>
        </trans-unit>
        <trans-unit id="c7886e26ae70e5250a1e0be3778e2c07bd58265c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; 결과이다 (양의 한정을위한 X) &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa903ae726de223dfc94489d7c3a22ae1b23a345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (양의 한정된 X 용)의 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 는 상승</target>
        </trans-unit>
        <trans-unit id="22db9353e8948056621c723acfc1f37d717bc4e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;tanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (임의 대해 &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;tanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; 한정된 X)는, 결과가 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 상승</target>
        </trans-unit>
        <trans-unit id="0dc41eed06a38a2687f77d174ad8f99a0594fb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; even if x is NaN</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; 의 결과는 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; X가 NaN 인 경우에도</target>
        </trans-unit>
        <trans-unit id="e9108ce5453cd6b3af30a85d4f435185194ec60d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,NaN)&lt;/code&gt; (어떤 유한 비제 X의 경우), 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="9b6b50afd0ebe3c85bd3492ea56b4593b842689c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite nonzero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,NaN)&lt;/code&gt; (임의의 제로가 아닌 유한 X의 경우), 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="204a160d7ec82f80677f4376caef794a23c51075" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,NaN)&lt;/code&gt; (어떤 한정된 X의 경우), 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="6b650f50d0ed443a6d100ac136e84b4b3bd34bc7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,NaN)&lt;/code&gt; (어떤 한정된 X의 경우), 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다.</target>
        </trans-unit>
        <trans-unit id="5d3a8274e24f46eb6d9b27c393f4df139396e5ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any nonzero finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,NaN)&lt;/code&gt; (제로가 아닌 유한 X의 경우), 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다.</target>
        </trans-unit>
        <trans-unit id="d9b70aa5296158a2ccd9b37fee97192ed5754e1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,NaN)&lt;/code&gt; (양의 유한 x에 대한) 결과이다 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="de160560a0670a88a8b2426dbe34cfbd96bd8f64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;acosh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,NaN)&lt;/code&gt; (대한 &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;acosh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; 한정된 x)의 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다.</target>
        </trans-unit>
        <trans-unit id="bd01cea44335f9b94fea310daa7ab95e4c6b7953" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;tanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,NaN)&lt;/code&gt; (어떤를 들어 &lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;tanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; 의 유한 x)의 결과는 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="d668d6a37cc758c14994156de53988e57bc6b406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; (unless x is &amp;plusmn;&amp;infin;) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">경우 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;(x,NaN)&lt;/code&gt; 결과이다 &lt;code&gt;(NaN,NaN)&lt;/code&gt; (않는 X는 &amp;plusmn; &amp;infin;)와 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 가 제기 될 수있다</target>
        </trans-unit>
        <trans-unit id="074f956a744f2e0d54cbe071efce74d2c8aa0db4" translate="yes" xml:space="preserve">
          <source>If A was transformed from a function parameter pack, deduction fails.(until C++14) it is compared with each remaining parameter type of the parameter template.(since C++14).</source>
          <target state="translated">A가 함수 매개 변수 팩에서 변환 된 경우 공제는 실패합니다 (C ++ 14까지). 매개 변수 템플리트의 나머지 각 매개 변수 유형과 비교됩니다 (C ++ 14 이후).</target>
        </trans-unit>
        <trans-unit id="e0371b0116f4a5b56551a65f008047322bafb01e" translate="yes" xml:space="preserve">
          <source>If C is not an initializer-list constructor and the initializer list has a single element of possibly cv-qualified X, the implicit conversion sequence has Exact Match rank. If the initializer list has a single element of possibly cv-qualified type derived from X, the implicit conversion sequence has Conversion rank. (note the difference from aggregates: aggregates initialize directly from single-element init lists before considering &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, non-aggregates consider initializer_list constructors before any other constructors)</source>
          <target state="translated">C가 이니셜 라이저 목록 생성자가 아니고 이니셜 라이저 목록에 cv로 한정된 X의 단일 요소가있는 경우 암시 적 변환 시퀀스는 정확한 일치 순위를 갖습니다. 이니셜 라이저 목록에 X에서 파생 된 cv-qualified 형식의 단일 요소가있는 경우 암시 적 변환 시퀀스는 Conversion rank입니다. (집계에서 차이를주의 : 집계 목록 init을 단일 요소에서 직접 초기화 고려하기 전에 &lt;a href=&quot;aggregate_initialization&quot;&gt;집계 초기화&lt;/a&gt; , 비 집계는 다른 생성자 전에 initializer_list 생성자을 고려)</target>
        </trans-unit>
        <trans-unit id="d49d7071128c9d18da1c8f640ffd938c2f5bb26f" translate="yes" xml:space="preserve">
          <source>If P is a function parameter pack, the type A of each remaining parameter type of the argument template is compared with the type P of the declarator-id of the function parameter pack. Each comparison deduces template arguments for subsequent positions in the template parameter packs expanded by the function parameter pack.</source>
          <target state="translated">P가 함수 매개 변수 팩인 경우, 인수 템플리트의 나머지 각 매개 변수 유형의 A 유형은 함수 매개 변수 팩의 선언자 ID의 P 유형과 비교됩니다. 각 비교는 함수 매개 변수 팩으로 확장 된 템플리트 매개 변수 팩의 후속 위치에 대한 템플리트 인수를 추론합니다.</target>
        </trans-unit>
        <trans-unit id="67a08e610ae0b43d5b7d5de3fee248ad08df296b" translate="yes" xml:space="preserve">
          <source>If Stage 2 was terminated by the test &lt;code&gt;in==end&lt;/code&gt;, &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; is executed to set the eof bit.</source>
          <target state="translated">2 단계는 시험에 의해 중단 된 경우 &lt;code&gt;in==end&lt;/code&gt; , &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; EOF를 비트를 설정하기 위해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a0a49b47583d28360f42a9c412de856cbcf247f7" translate="yes" xml:space="preserve">
          <source>If Statements with Initializer</source>
          <target state="translated">이니셜 라이저가있는 If 문</target>
        </trans-unit>
        <trans-unit id="95e34bcbaa3c6e3efcc81854651af3ec74c54e09" translate="yes" xml:space="preserve">
          <source>If UTF-8 code unit produced is &lt;code&gt;u8'\0'&lt;/code&gt;, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">생성 된 UTF-8 코드 단위가 &lt;code&gt;u8'\0'&lt;/code&gt; 이면 변환 상태 &lt;code&gt;*ps&lt;/code&gt; 는 초기 시프트 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5031b0f6e6a8ffbd0c86254f140591158ac1c1ed" translate="yes" xml:space="preserve">
          <source>If UTF-8 encoding of the multibyte character in &lt;code&gt;*s&lt;/code&gt; consists of more than one UTF-8 code unit, then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc8&lt;/code&gt; will write out the additional UTF-8 code units, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*s&lt;/code&gt; 에서 멀티 바이트 문자의 UTF-8 인코딩이 둘 이상의 UTF-8 코드 단위로 구성된 경우,이 함수를 처음 호출 한 후 &lt;code&gt;*ps&lt;/code&gt; 는 다음 &lt;code&gt;mbrtoc8&lt;/code&gt; 호출 이 &lt;code&gt;*s&lt;/code&gt; 를 고려하지 않고 추가 UTF-8 코드 단위 .</target>
        </trans-unit>
        <trans-unit id="57e85fdf8664c8892feaa0067e2ab68c323b2c7e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; declaration specifies a default, it must be a friend function definition, and no other declarations of this function are allowed in the translation unit.</source>
          <target state="translated">경우 &lt;a href=&quot;friend&quot;&gt;친구의&lt;/a&gt; 선언이 디폴트를 지정, 그것은 친구의 함수 정의해야하며,이 기능의 다른 선언은 번역 단위에서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af125d901495baa7e68ae6bf7e676c729a2e9e7d" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lambda&quot;&gt;lambda-expression&lt;/a&gt; appears in a default argument, it cannot explicitly or implicitly capture anything.</source>
          <target state="translated">경우 &lt;a href=&quot;lambda&quot;&gt;람다 표현식은&lt;/a&gt; 기본 인수에 나타납니다, 명시 적 또는 암시 적으로 캡처 아무것도 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a76f53af271b5a909124051c648419560af0ae0d" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; appears as the last &lt;code&gt;P&lt;/code&gt;, then the type &lt;code&gt;P&lt;/code&gt; is matched against the type &lt;code&gt;A&lt;/code&gt; of each remaining argument of the call. Each match deduces the template arguments for the next position in the pack expansion:</source>
          <target state="translated">경우 &lt;a href=&quot;parameter_pack&quot;&gt;매개 변수 팩이&lt;/a&gt; 마지막으로 나타납니다 &lt;code&gt;P&lt;/code&gt; , 다음 유형의 &lt;code&gt;P&lt;/code&gt; 는 유형에 대해 일치 전화의 나머지 각 인수의. 각 일치는 팩 확장에서 다음 위치에 대한 템플리트 인수를 추론합니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b41eca314d823a30b3d9356e848b0ef641d30e0a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;choose&lt;/code&gt; is not passed and an ambiguous or nonexistent local time is encountered, a &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; or &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; exception (as applicable) will be thrown.</source>
          <target state="translated">A는 경우 &lt;code&gt;choose&lt;/code&gt; 에 전달되지 않고 모호한 또는 존재하지 않는 현지 시간, 발생되는 &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; 또는 &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; (해당하는 경우) 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b0232a855656fad38033f04cd7d4e9aba797f804" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;va_list&lt;/code&gt; instance is created, passed to another function, and used via &lt;code&gt;&lt;a href=&quot;va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; in that function, then any subsequent use in the calling function should be preceded by a call to &lt;code&gt;&lt;a href=&quot;va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;va_list&lt;/code&gt; 인스턴스가 생성되고, 다른 함수로 전달하고, 사용을 통해 &lt;code&gt;&lt;a href=&quot;va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; 를 다음 호출 기능의 후속 사용이 호출에 의해 선행되어야한다는 기능에 &lt;code&gt;&lt;a href=&quot;va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="80b021b3e6bb48d6dea03f2d437af9bc0159b35f" translate="yes" xml:space="preserve">
          <source>If a MoveAssignable class implements a move assignment operator, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after assignment is unspecified.</source>
          <target state="translated">MoveAssignable 클래스가 이동 할당 연산자를 구현하는 경우 할당 후 &lt;code&gt;rv&lt;/code&gt; 값 이 지정되지 않았다는 사실을 활용하기 위해 &lt;a href=&quot;../utility/move&quot;&gt;이동 의미 체계&lt;/a&gt; 를 구현할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50fd9c6db39f2b44036e6dd5cc6b5f20e25a53df" translate="yes" xml:space="preserve">
          <source>If a MoveConstructible class implements a move constructor, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after construction is unspecified.</source>
          <target state="translated">MoveConstructible 클래스가 이동 생성자를 구현하는 경우 생성 후 &lt;code&gt;rv&lt;/code&gt; 값 이 지정되지 않았다는 사실을 이용하기 위해 &lt;a href=&quot;../utility/move&quot;&gt;이동 의미&lt;/a&gt; 를 구현할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db6d3d9d7cd4ba49aa12646a4de72f6a71fe9090" translate="yes" xml:space="preserve">
          <source>If a UTF-8 string literal and a wide string literal are side by side, the program is ill-formed.</source>
          <target state="translated">UTF-8 문자열 리터럴과 넓은 문자열 리터럴이 나란히 있으면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2e7730383bc958aa60b61242e15f22a8a4d39ba2" translate="yes" xml:space="preserve">
          <source>If a call had been made to &lt;a href=&quot;sync&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt; since the last call to &lt;code&gt;emit()&lt;/code&gt;, then also flushes the wrapped stream by calling &lt;a href=&quot;../basic_streambuf/pubsync&quot;&gt;&lt;code&gt;pubsync()&lt;/code&gt;&lt;/a&gt; on it.</source>
          <target state="translated">&lt;code&gt;emit()&lt;/code&gt; 대한 마지막 호출 이후 에 &lt;a href=&quot;sync&quot;&gt; &lt;code&gt;sync&lt;/code&gt; &lt;/a&gt; 호출 한 경우에는 &lt;a href=&quot;../basic_streambuf/pubsync&quot;&gt; &lt;code&gt;pubsync()&lt;/code&gt; &lt;/a&gt; 를 호출하여 랩핑 된 스트림을 플러시 합니다.</target>
        </trans-unit>
        <trans-unit id="0ea2bfcf7eb556e144def8831349ca368e38aca7" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;sprintf&lt;/code&gt; or &lt;code&gt;snprintf&lt;/code&gt; causes copying to take place between objects that overlap, the behavior is undefined (e.g. &lt;code&gt;sprintf(buf, &quot;%s text&quot;, buf);&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;sprintf&lt;/code&gt; 또는 &lt;code&gt;snprintf&lt;/code&gt; 를 호출하여 겹치는 객체간에 복사가 발생하면 동작이 정의되지 않습니다 (예 : &lt;code&gt;sprintf(buf, &quot;%s text&quot;, buf);&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c3aa22cbaf61ec140e43d901a3568b282d2888df" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;try_lock&lt;/code&gt; fails, no further call to &lt;code&gt;try_lock&lt;/code&gt; is performed, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects and a &lt;code&gt;0&lt;/code&gt;-based index of the object that failed to lock is returned.</source>
          <target state="translated">를 호출하면 &lt;code&gt;try_lock&lt;/code&gt; 가 에 더 호출에 실패 &lt;code&gt;try_lock&lt;/code&gt; 이 수행되지 않습니다, &lt;code&gt;unlock&lt;/code&gt; 잠긴 객체와 호출됩니다 &lt;code&gt;0&lt;/code&gt; 잠금이 반환에 실패 개체의 기반 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="42b5fe2f519d0b2189f00f6cdee376383897d0d8" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;try_lock&lt;/code&gt; results in an exception, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects before rethrowing.</source>
          <target state="translated">&lt;code&gt;try_lock&lt;/code&gt; 호출로 예외가 발생 하면 다시 던지기 전에 잠긴 오브젝트에 대해 &lt;code&gt;unlock&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="409e5d2187197971805f527baaf18e9e29ae37c9" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes a const lvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;, and &lt;code&gt;std::forward&lt;/code&gt; ensures that a const lvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">를 호출하는 경우 &lt;code&gt;wrapper()&lt;/code&gt; 전달하는 const를 좌변 &lt;code&gt;std::string&lt;/code&gt; , 다음 &lt;code&gt;T&lt;/code&gt; IS 추론에 &lt;code&gt;const std::string&amp;amp;&lt;/code&gt; 및 &lt;code&gt;std::forward&lt;/code&gt; CONST의 좌변 참조가 전달되는 것을 보장 &lt;code&gt;foo&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="60d636afcff594f21611dd719c9b59be1be77be5" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes a non-const lvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;std::string&amp;amp;&lt;/code&gt;, and &lt;code&gt;std::forward&lt;/code&gt; ensures that a non-const lvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">를 호출하는 경우 &lt;code&gt;wrapper()&lt;/code&gt; 전달하는 const가 아닌 lvalue를 &lt;code&gt;std::string&lt;/code&gt; , 다음 &lt;code&gt;T&lt;/code&gt; 가 로 추론되는 &lt;code&gt;std::string&amp;amp;&lt;/code&gt; 및 &lt;code&gt;std::forward&lt;/code&gt; 비 const가 좌변 참조가 전달되는 것을 보장 &lt;code&gt;foo&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="531e469ff5d08b04534632e848505259a8c9345f" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes an rvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;std::string&lt;/code&gt; (not &lt;code&gt;std::string&amp;amp;&lt;/code&gt;, &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;, or &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;), and &lt;code&gt;std::forward&lt;/code&gt; ensures that an rvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">를 호출하는 경우 &lt;code&gt;wrapper()&lt;/code&gt; 를 rvalue의 통과 &lt;code&gt;std::string&lt;/code&gt; , 다음 &lt;code&gt;T&lt;/code&gt; 는 로 추론되는 &lt;code&gt;std::string&lt;/code&gt; (하지 &lt;code&gt;std::string&amp;amp;&lt;/code&gt; , &lt;code&gt;const std::string&amp;amp;&lt;/code&gt; 또는 &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; ) 및 &lt;code&gt;std::forward&lt;/code&gt; 보장하지만 rvalue 참조가 &lt;code&gt;foo&lt;/code&gt; 에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="3db6809411e108c8a32250227388ae4694cdc2d7" translate="yes" xml:space="preserve">
          <source>If a capacity change takes place, all iterators and references, including the past-the-end iterator, are invalidated.</source>
          <target state="translated">용량 변경이 발생하면 과거 반복기를 포함한 모든 반복자와 참조가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="91f5ccbd4323fb5f3ed4c55a818cff6f60b92726" translate="yes" xml:space="preserve">
          <source>If a capture list has a capture-default and does not explicitly capture the enclosing object (as &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;*this&lt;/code&gt;) or an automatic variable, it captures it</source>
          <target state="translated">캡처 목록에 캡처 기본값이 있고 둘러싸는 오브젝트 ( &lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;*this&lt;/code&gt; ) 또는 자동 변수를 명시 적으로 캡처하지 않으면 이를 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="7dd621d8a6ec99fac9a316fb824dc230d2630614" translate="yes" xml:space="preserve">
          <source>If a catch-clause for a derived class is placed after the catch-clause for a base class, the derived catch-clause will never be executed.</source>
          <target state="translated">파생 클래스에 대한 catch-clause가 기본 클래스에 대한 catch-clause 뒤에 배치되면 파생 된 catch-clause는 절대 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20b89c206d6d992d89351af992dfddfea294ca6c" translate="yes" xml:space="preserve">
          <source>If a class has a public virtual destructor, it can be derived from, and the derived object can be safely deleted through a pointer to the base object (&lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;GotW #18&lt;/a&gt;).</source>
          <target state="translated">클래스에 퍼블릭 가상 소멸자가있는 경우 클래스에서 파생 될 수 있으며 기본 오브젝트에 대한 포인터를 통해 파생 된 오브젝트를 안전하게 삭제할 수 있습니다 ( &lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;GotW # 18&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d189c715668bfca07f195aaf55d2d525ebbeda96" translate="yes" xml:space="preserve">
          <source>If a class requires a user-defined &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;, a user-defined &lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, or a user-defined &lt;a href=&quot;as_operator&quot;&gt;copy assignment operator&lt;/a&gt;, it almost certainly requires all three.</source>
          <target state="translated">클래스에 사용자 정의 &lt;a href=&quot;destructor&quot;&gt;소멸자&lt;/a&gt; , 사용자 정의 &lt;a href=&quot;copy_constructor&quot;&gt;사본 생성자&lt;/a&gt; 또는 사용자 정의 &lt;a href=&quot;as_operator&quot;&gt;사본 할당 연산자&lt;/a&gt; 가 필요한 경우 거의 세 가지가 모두 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d0521b23151547cdfdf59688f7fc84d8f6a00c6f" translate="yes" xml:space="preserve">
          <source>If a class template has been declared, but not defined, at the point of instantiation, the instantiation yields an incomplete class type:</source>
          <target state="translated">인스턴스화 시점에 클래스 템플릿이 선언되었지만 정의되지 않은 경우 인스턴스화는 불완전한 클래스 유형을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5de1ec538e9a507f38c522094bdfc9ac9990681e" translate="yes" xml:space="preserve">
          <source>If a const non-inline(since C++17) static data member or a constexpr static data member(since C++11) is &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;, a definition at namespace scope is still required, but it cannot have an initializer. This definition is deprecated for &lt;code&gt;constexpr&lt;/code&gt; data members(since C++17).</source>
          <target state="translated">const 비 인라인 (C ++ 17 이후) 정적 데이터 멤버 또는 constexpr 정적 데이터 멤버 (C ++ 11 이후)가 &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt; 인 경우 네임 스페이스 범위의 정의는 여전히 필요하지만 초기화 프로그램을 가질 수 없습니다. 이 정의는 &lt;code&gt;constexpr&lt;/code&gt; 데이터 멤버에 대해 더 이상 사용되지 않습니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="23a184ea03d379e5295d8a06a9fb5d4d84026185" translate="yes" xml:space="preserve">
          <source>If a constexpr if statement appears inside a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt;, and if condition is not &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;value-dependent&lt;/a&gt; after instantiation, the discarded statement is not instantiated when the enclosing template is instantiated .</source>
          <target state="translated">constexpr if 문이 &lt;a href=&quot;templates#Templated_entity&quot;&gt;템플릿 화 된 엔터티&lt;/a&gt; 내부에 나타나고 인스턴스화 후 조건에 &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;따라 값이 달라&lt;/a&gt; 지지 않으면 포함 된 템플릿이 인스턴스화 될 때 폐기 된 문이 인스턴스화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d387511a4c202656145b74050dd24c2d4377d5ea" translate="yes" xml:space="preserve">
          <source>If a constructor template or conversion function template has an &lt;a href=&quot;explicit&quot;&gt;conditional explicit specifier&lt;/a&gt; which happens to be &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;value-dependent&lt;/a&gt;, after deduction, if the context requires a candidate that is not explicit and the generated specialization is explicit, it is removed from the candidate set.</source>
          <target state="translated">생성자 템플릿 또는 변환 함수 템플릿에 &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;값에 따라 달라지는 &lt;/a&gt;&lt;a href=&quot;explicit&quot;&gt;조건부 명시 적 지정자가&lt;/a&gt; 있는 경우 , 추론 후 컨텍스트에 명시 적이 지 않은 후보가 필요하고 생성 된 전문화가 명시 적이면 후보 세트에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e7cac551c36c79f3db2d3cd4de291ee906f04949" translate="yes" xml:space="preserve">
          <source>If a contract condition of a virtual function &lt;code&gt;f&lt;/code&gt; odr-uses &lt;code&gt;*this&lt;/code&gt;, the class of which &lt;code&gt;f&lt;/code&gt; is a direct member must be an unambiguous and accessible base class of any class in which &lt;code&gt;f&lt;/code&gt; is overridden.</source>
          <target state="translated">가상 함수의 경우 계약 조건 &lt;code&gt;f&lt;/code&gt; ODR-용도는 &lt;code&gt;*this&lt;/code&gt; 의 클래스 &lt;code&gt;f&lt;/code&gt; 직접적인 부재가되는 임의의 클래스의 명백한 접근 기본 클래스이어야이고 &lt;code&gt;f&lt;/code&gt; 는 무시된다.</target>
        </trans-unit>
        <trans-unit id="a62eb301fbc04938195faede31c45cafa349ad46" translate="yes" xml:space="preserve">
          <source>If a conversion specification is invalid, the behavior is undefined.</source>
          <target state="translated">변환 스펙이 유효하지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5705ed552a56d6bfbeab747c83e7be8483a52343" translate="yes" xml:space="preserve">
          <source>If a data race occurs, the behavior of the program is undefined.</source>
          <target state="translated">데이터 레이스가 발생하면 프로그램의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="882bf051762ba2c1ce6191c7588fe5e3cee6567e" translate="yes" xml:space="preserve">
          <source>If a declaration introduces a variable with automatic storage duration, it is initialized when its declaration statement is executed. All automatic variables declared in a block are destroyed on exit from the block (regardless how the block is exited: via &lt;a href=&quot;exceptions&quot;&gt;exception&lt;/a&gt;, &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, or by reaching its end), in order opposite to their order of initialization.</source>
          <target state="translated">선언에 자동 저장 기간이있는 변수가 도입되면 선언문이 실행될 때 초기화됩니다. 블록에 선언 된 모든 자동 변수는 초기화 순서와 반대 순서로 블록이 종료되는 방식 (예 : &lt;a href=&quot;exceptions&quot;&gt;예외&lt;/a&gt; , &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; 또는 끝에 도달하여 종료)에 관계없이 파괴됩니다 .</target>
        </trans-unit>
        <trans-unit id="43c8efd199427ba6a640175787f51c9fb916e92f" translate="yes" xml:space="preserve">
          <source>If a delegating constructor exits with an exception after the non-delegating constructor successfully completed, the destructor for this object is called.</source>
          <target state="translated">위임되지 않은 생성자가 성공적으로 완료된 후 예외 생성자와 함께 예외가 발생하면이 개체의 소멸자가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1ac2fdfac54931742b99e44e4aa9aeaa05c1d2d6" translate="yes" xml:space="preserve">
          <source>If a destructor reset the terminate handler during stack unwinding and the unwinding later led to &lt;code&gt;terminate&lt;/code&gt; being called, the handler that was installed at the end of the throw expression is the one that will be called. (note: it was ambiguous whether re-throwing applied the new handlers).</source>
          <target state="translated">소멸자가 스택 해제 중 종료 처리기를 재설정하고 나중에 &lt;code&gt;terminate&lt;/code&gt; 가 호출 을 종료 하게하는 경우, throw 표현식의 끝에 설치된 처리기가 호출됩니다. (참고 : 다시 던지기가 새로운 핸들러를 적용했는지 여부는 모호했습니다).</target>
        </trans-unit>
        <trans-unit id="753c6e50ab4e318d953d5637b772a0f352fda59e" translate="yes" xml:space="preserve">
          <source>If a destructor reset the terminate handler during stack unwinding, it is unspecified which handler is called if the unwinding later led to &lt;code&gt;terminate&lt;/code&gt; being called.</source>
          <target state="translated">소멸자가 스택 해제 중 종료 처리기를 재설정하면 나중에 &lt;code&gt;terminate&lt;/code&gt; 가 호출 되어 종료 되는 경우 어떤 처리기가 호출되는지 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="482827679143ed383496ea91dbd86707c7632c8b" translate="yes" xml:space="preserve">
          <source>If a destructor reset the unexpected handler during stack unwinding and the unwinding later led to &lt;code&gt;unexpected&lt;/code&gt; being called, the handler that was installed at the end of the throw expression is the one that will be called. (note: it was ambiguous whether re-throwing applied the new handlers).</source>
          <target state="translated">소멸자가 스택 해제 중 예기치 않은 핸들러를 재설정하고 나중에 해제가 &lt;code&gt;unexpected&lt;/code&gt; 호출 을 유발 한 경우, throw 표현식의 끝에 설치된 핸들러가 호출됩니다. (참고 : 다시 던지기가 새로운 핸들러를 적용했는지 여부는 모호했습니다).</target>
        </trans-unit>
        <trans-unit id="f833e8b1ca41ece97da3b5dfb8d80f4a17d92a84" translate="yes" xml:space="preserve">
          <source>If a destructor reset the unexpected handler during stack unwinding, it is unspecified which handler is called if the unwinding later led to &lt;code&gt;unexpected&lt;/code&gt; being called.</source>
          <target state="translated">소멸자가 스택 해제 동안 예기치 않은 핸들러를 재설정하는 경우 나중에 해제가 &lt;code&gt;unexpected&lt;/code&gt; 호출로 이어질 경우 호출되는 핸들러는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b53fae349713df5efc757fb7b33531c67e72c29" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value (NaN where supported) is returned.</source>
          <target state="translated">도메인 오류가 발생하면 구현 정의 값 (지원되는 경우 NaN)이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="daaa304029da34d0537dff7e88f32d7146eac438" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned (NaN where supported).</source>
          <target state="translated">도메인 오류가 발생하면 구현 정의 값이 반환됩니다 (지원되는 경우 NaN).</target>
        </trans-unit>
        <trans-unit id="8a2b2a5d22410f7c139500bf2d1ad8bd3daffb21" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned.</source>
          <target state="translated">도메인 오류가 발생하면 구현 정의 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fc6ec94615e1c6cf0e59aab22eb031064112889e" translate="yes" xml:space="preserve">
          <source>If a file or a directory is deleted or added to the directory tree after the directory iterator has been created, it is unspecified whether the change would be observed through the iterator.</source>
          <target state="translated">디렉토리 반복기가 작성된 후 파일 또는 디렉토리가 삭제되거나 디렉토리 트리에 추가되면, 반복자를 통해 변경이 관찰되는지 여부는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3724f8b6f7d15be8a8f1594573af0e22249ce20e" translate="yes" xml:space="preserve">
          <source>If a file or a directory is deleted or added to the directory tree after the recursive directory iterator has been created, it is unspecified whether the change would be observed through the iterator.</source>
          <target state="translated">재귀 적 디렉토리 반복자가 작성된 후 파일 또는 디렉토리가 삭제되거나 디렉토리 트리에 추가되면, 반복자를 통해 변경이 관찰되는지 여부는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39efafdede79fd69777a0e208a3fd4446a9e9cf1" translate="yes" xml:space="preserve">
          <source>If a friend declaration is the first declaration of the function in a translation unit and has a contract condition, that declaration must be a definition and must be the only declaration of the function in the translation unit:</source>
          <target state="translated">친구 선언이 번역 단위에서 함수의 첫 번째 선언이고 계약 조건이있는 경우 해당 선언은 정의 여야하며 번역 단위에서 함수의 유일한 선언이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9348fef8e416c767f68b83ba99d0f25cfef8feda" translate="yes" xml:space="preserve">
          <source>If a function declared nodiscard or a function returning an enumeration or class declared nodiscard by value is called from a &lt;a href=&quot;../expressions#Discarded-value_expressions&quot;&gt;discarded-value expression&lt;/a&gt; other than a cast to void, the compiler is encouraged to issue a warning.</source>
          <target state="translated">nodiscard로 선언 된 함수 또는 값으로 nodiscard로 선언 된 열거 또는 클래스를 리턴하는 함수 가 void to cast 이외의 버림 된 &lt;a href=&quot;../expressions#Discarded-value_expressions&quot;&gt;값 표현식&lt;/a&gt; 에서 호출 되면 컴파일러는 경고를 발행하도록 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="0e42988e69c29f9c1e608a2f0ffd727f5c2644ec" translate="yes" xml:space="preserve">
          <source>If a function exits via an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">함수가 예외를 통해 종료되면 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ad964142a18dcc049d042a23d7d71322620a52d8" translate="yes" xml:space="preserve">
          <source>If a function has more than one final overrider, the program is ill-formed:</source>
          <target state="translated">함수에 둘 이상의 최종 재정의가 있으면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="bafd7cb9d12f56ccf89ae9b7b4d93ed2022e34a5" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; in one translation unit and the same function is declared without &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; in another translation unit, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">함수가 선언 된 경우 &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; 하나의 변환 부와 동일한 기능에 않고 선언 &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; 다른 변환 장치에있어서, 프로그램이 잘못 형성되고; 진단이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3f9e3de669a5122870e6bc1eb5118c628c85194" translate="yes" xml:space="preserve">
          <source>If a function is declared with the specifier &lt;code&gt;final&lt;/code&gt;, and another function attempts to override it, the program is ill-formed:</source>
          <target state="translated">지정자 &lt;code&gt;final&lt;/code&gt; 로 함수를 선언 하고 다른 함수가이를 대체하려고 시도하면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3888ddb42cb2148d436948685603df58149529f7" translate="yes" xml:space="preserve">
          <source>If a function is declared with the specifier &lt;code&gt;override&lt;/code&gt;, but does not override a virtual function, the program is ill-formed:</source>
          <target state="translated">지정자 &lt;code&gt;override&lt;/code&gt; 로 함수를 선언 했지만 가상 함수를 무시하지 않으면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2f9f7412482ccba02363ec8e1d82ccc1ed257746" translate="yes" xml:space="preserve">
          <source>If a function is declared with type &lt;code&gt;T&lt;/code&gt; listed in its exception specification, the function may throw exceptions of that type or a type derived from it.</source>
          <target state="translated">예외 사양에 &lt;code&gt;T&lt;/code&gt; 유형으로 나열된 함수가 선언 된 경우 해당 함수는 해당 유형의 예외 또는이 함수에서 파생 된 유형을 예외로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="0815633756bffaa6b84ff1cbf11092af43ee34c1" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a class type, &lt;code&gt;class&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">함수 또는 변수가 클래스 유형의 이름과 동일한 이름으로 범위에 존재 하면 명확성을 위해 이름 앞에 &lt;code&gt;class&lt;/code&gt; 를 추가하여 &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;정교한 유형 지정자를 만들 수 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43617584a5c434806ea859f8354d597162e188ea" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a non-union class type, &lt;code&gt;struct&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">함수 또는 변수가 비 유니언 클래스 유형의 이름과 동일한 이름으로 범위에 존재 하면 명확성을 위해 이름 앞에 &lt;code&gt;struct&lt;/code&gt; 를 추가하여 &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;정교한 유형 지정자를&lt;/a&gt; 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33c372b62b38e3e28c4c2d8049dc573ffb3184eb" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a union type, &lt;code&gt;union&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">함수 또는 변수가 공용체 유형의 이름과 동일한 이름을 가진 범위에 존재 하면 명확성을 위해 이름 앞에 &lt;code&gt;union&lt;/code&gt; 를 추가하여 &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;정교한 유형 지정자를 만들 수 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3caf3302d65692054c0bd57d280ffa6d4243e44a" translate="yes" xml:space="preserve">
          <source>If a function overrides more than one function, all of the overridden functions must have the same list of contract conditions; no diagnostic is required if corresponding conditions will always evaluate to the same value.</source>
          <target state="translated">함수가 둘 이상의 함수를 대체하는 경우, 대체 된 모든 함수는 동일한 계약 조건 목록을 가져야합니다. 해당 조건이 항상 동일한 값으로 평가되는 경우 진단이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="135a8489da58532d74209fec452fabacfcbf21c6" translate="yes" xml:space="preserve">
          <source>If a function template, variable template, member function template, or member function or static data member of a class template is explicitly instantiated with an explicit instantiation definition, the template definition must be present in the same translation unit.</source>
          <target state="translated">클래스 템플릿의 함수 템플릿, 변수 템플릿, 멤버 함수 템플릿 또는 멤버 함수 또는 정적 데이터 멤버가 명시 적 인스턴스화 정의로 명시 적으로 인스턴스화되는 경우 템플릿 정의는 동일한 변환 단위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f8f1e8e53e9248772a5ae660d45da68b260826d4" translate="yes" xml:space="preserve">
          <source>If a function that is not transaction-safe is called through a reference or pointer to a transaction-safe function, the behavior is undefined.</source>
          <target state="translated">트랜잭션 세이프가 아닌 함수가 트랜잭션 세이프 함수에 대한 참조 또는 포인터를 통해 호출되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bde24db3435358d326a5b26dc4f5fb9a3ee4c50" translate="yes" xml:space="preserve">
          <source>If a function uses return type deduction, it cannot be redeclared using the type that it deduces to, or another kind of return type deduction even if it deduces to the same type.</source>
          <target state="translated">함수가 리턴 유형 추론을 사용하는 경우 추론하는 유형 또는 동일한 유형으로 추론하더라도 다른 유형의 리턴 유형 추론을 사용하여 다시 선언 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="26770c3740e0e9cd92c88700d97b6e2c4081721f" translate="yes" xml:space="preserve">
          <source>If a function was introduced by a using-declaration, declaring a function with the same name and parameter list is ill-formed (unless the declaration is for the same function). If a function template was introduced by a using-declaration, declaring a function template with the same name, parameter type list, return type, and template parameter list is ill-formed. Two using-declarations can introduce functions with the same name and parameter list, but if a call to that function is attempted, the program is ill-formed.</source>
          <target state="translated">using-declaration에 의해 함수가 도입 된 경우, 동일한 이름과 매개 변수 목록을 가진 함수를 선언하는 것은 잘못된 형식입니다 (선포가 동일한 함수에 대한 것이 아닌 한). 함수 선언이 using-declaration에 의해 도입 된 경우, 이름, 매개 변수 유형 목록, 리턴 유형 및 템플리트 매개 변수 목록이 동일한 함수 템플리트를 선언하는 것은 잘못 구성됩니다. 두 개의 사용 선언은 동일한 이름과 매개 변수 목록을 가진 함수를 도입 할 수 있지만 해당 함수를 호출하려고하면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e751efac5a78fb2353ecab041674493ffe914d58" translate="yes" xml:space="preserve">
          <source>If a function-local (block-scope) static object was destroyed and then that function is called from the destructor of another static object and the control flow passes through the definition of that object (or if it is used indirectly, via pointer or reference), the behavior is undefined.</source>
          <target state="translated">함수 로컬 (block-scope) 정적 객체가 파괴 된 후 해당 함수가 다른 정적 객체의 소멸자에서 호출되고 제어 흐름이 해당 객체의 정의를 통과하거나 간접적으로 사용되는 경우 포인터 또는 참조를 통해 ), 동작이 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a5179d5f0b6b560d982bb76be1dd9a627d77214d" translate="yes" xml:space="preserve">
          <source>If a get area exists (e.g. the file was opened for reading), the effect is implementation-defined. Typical implementation may empty out the get area and move the current file position back by the corresponding number of bytes.</source>
          <target state="translated">get 영역이 존재하면 (예 : 파일을 읽기 위해 열었을 때) 효과는 구현 정의됩니다. 일반적인 구현은 get 영역을 비우고 현재 파일 위치를 해당 바이트 수만큼 뒤로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b16daea89246b1eee5a59e08c141c8e46338b5b" translate="yes" xml:space="preserve">
          <source>If a lambda captures the enclosing object (as &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;*this&lt;/code&gt;), either the nearest enclosing function must be a non-static member function or the lambda must be in a &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt;:</source>
          <target state="translated">람다가 둘러싸는 객체 ( &lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;*this&lt;/code&gt; )를 캡처하는 경우 가장 가까운 둘러싸는 함수는 비 정적 멤버 함수이거나 람다는 &lt;a href=&quot;data_members#Member_initialization&quot;&gt;기본 멤버 이니셜 라이저&lt;/a&gt; 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cfdecd26d4d9885f6eeae96917954311b903b67d" translate="yes" xml:space="preserve">
          <source>If a lambda expression (or an instantiation of a generic lambda's function call operator) ODR-uses &lt;code&gt;this&lt;/code&gt; or any variable with automatic storage duration, it must be captured by the lambda expression.</source>
          <target state="translated">람다 식 (또는 일반 람다의 함수 호출 연산자의 인스턴스화) &lt;code&gt;this&lt;/code&gt; 자동 저장 기간과 함께이 변수 나 변수를 ODR 사용 하는 경우 람다 식으로 캡처해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9245324f25aa6ef3f3a921517ba752285940aaf" translate="yes" xml:space="preserve">
          <source>If a lambda odr-uses a reference that is captured by reference, it is using the object referred-to by the original reference, not the captured reference itself:</source>
          <target state="translated">람다가 참조로 캡처 한 참조를 사용하는 경우 캡처 된 참조 자체가 아니라 원래 참조가 참조하는 객체를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1da4cd3d4148fc5555feb74d4e942788fe474123" translate="yes" xml:space="preserve">
          <source>If a lambda-expression appears in a &lt;a href=&quot;default_arguments&quot;&gt;default argument&lt;/a&gt;, it cannot explicitly or implicitly capture anything.</source>
          <target state="translated">람다식이 &lt;a href=&quot;default_arguments&quot;&gt;기본 인수에&lt;/a&gt; 나타나면 명시 적으로나 암시 적으로 아무것도 캡처 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e34c58387ec074a0a7abef6761392718c559bb60" translate="yes" xml:space="preserve">
          <source>If a member has a default member initializer and also appears in the member initialization list in a constructor, the default member initializer is ignored.</source>
          <target state="translated">멤버에 기본 멤버 이니셜 라이저가 있고 생성자의 멤버 초기화 목록에도 나타나는 경우 기본 멤버 이니셜 라이저는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f6c0536efbdc9b49435039f82fb9fa51a3523c3e" translate="yes" xml:space="preserve">
          <source>If a name is used in a class body before it is declared, and another declaration for that name is in scope, the program is &lt;a href=&quot;ub&quot;&gt;ill-formed, no diagnostic required&lt;/a&gt;.</source>
          <target state="translated">이름이 선언되기 전에 클래스 본문에서 이름이 사용되고 해당 이름에 대한 다른 선언이 범위 내에 있으면 프로그램이 &lt;a href=&quot;ub&quot;&gt;잘못 구성되고 진단이 필요하지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73b765e29ed3c027cc3bcfba763673a78b12e25b" translate="yes" xml:space="preserve">
          <source>If a narrowing conversion is required, other than from an integral type to a floating point type, the program is ill-formed.</source>
          <target state="translated">정수 형식에서 부동 소수점 형식으로의 변환 이외의 축소 변환이 필요한 경우 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a10165cb0c4c283cd3dc5405e46c820a8e3f7689" translate="yes" xml:space="preserve">
          <source>If a nested lambda &lt;code&gt;m2&lt;/code&gt; captures something that is also captured by the immediately enclosing lambda &lt;code&gt;m1&lt;/code&gt;, then &lt;code&gt;m2&lt;/code&gt;'s capture is transformed as follows:</source>
          <target state="translated">중첩 된 람다 &lt;code&gt;m2&lt;/code&gt; 가 즉시 둘러싸는 람다 &lt;code&gt;m1&lt;/code&gt; 에 의해 캡처 된 것을 캡처하면 , &lt;code&gt;m2&lt;/code&gt; 의 캡처는 다음과 같이 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="35c0cb6d4e19455e10fc3b8d1fea7080305eff39" translate="yes" xml:space="preserve">
          <source>If a new object is created at the address that was occupied by another object, then all pointers, references, and the name of the original object will automatically refer to the new object and, once the lifetime of the new object begins, can be used to manipulate the new object, but only if the following conditions are satisfied:</source>
          <target state="translated">다른 객체가 차지한 주소에 새 객체가 생성되면 모든 포인터, 참조 및 원래 객체의 이름이 자동으로 새 객체를 참조하고 새 객체의 수명이 시작되면 사용할 수 있습니다 다음 조건이 충족되는 경우에만 새 객체를 조작합니다.</target>
        </trans-unit>
        <trans-unit id="040c4b92d07b4519ff12ccd42bcfa061a377c5b4" translate="yes" xml:space="preserve">
          <source>If a non-reference entity is captured by reference, implicitly or explicitly, and the function call operator of the closure object is invoked after the entity's lifetime has ended, undefined behavior occurs. The C++ closures do not extend the lifetimes of the captured references.</source>
          <target state="translated">비 참조 엔티티가 참조에 의해 암시 적으로 또는 명시 적으로 캡처되고 엔티티의 수명이 종료 된 후 클로저 오브젝트의 함수 호출 연산자가 호출되면 정의되지 않은 동작이 발생합니다. C ++ 클로저는 캡처 된 참조의 수명을 연장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ceaa0be0f1cb1c411ff6ee0a8d7f52ed257f167" translate="yes" xml:space="preserve">
          <source>If a non-static data member has an &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt; and also appears in a member initializer list, then member initializer list is executed and the default member initializer is ignored:</source>
          <target state="translated">비 정적 데이터 멤버에 &lt;a href=&quot;data_members#Member_initialization&quot;&gt;기본 멤버 이니셜 라이저&lt;/a&gt; 가 있고 멤버 이니셜 라이저 목록에도 나타나는 경우 멤버 이니셜 라이저 목록이 실행되고 기본 멤버 이니셜 라이저가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0aab394949317f4e8f5352a010f660fb204a47ce" translate="yes" xml:space="preserve">
          <source>If a non-type template parameter is used in the parameter list, and the corresponding template argument is deduced, the type of the deduced template argument ( as specified in its enclosing template parameter list, meaning references are preserved) must match the type of the non-type template parameter exactly, except that cv-qualifiers are dropped, and except where the template argument is deduced from an array bound&amp;mdash;in that case any integral type is allowed, even bool though it would always become true:</source>
          <target state="translated">비 유형 템플릿 매개 변수가 매개 변수 목록에 사용되고 해당 템플릿 인수가 추론되는 경우 추론 된 템플릿 인수 유형 (포함 템플릿 매개 변수 목록에 지정된 참조가 유지됨)은 cv-qualifiers가 삭제되고 배열 인수에서 template 인수가 추론되는 경우를 제외하고는 형식이 아닌 템플릿 매개 변수가 정확합니다.이 경우 모든 정수 유형이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6a9d189d5910a05ceacbf1d41469dc00391c4252" translate="yes" xml:space="preserve">
          <source>If a pack expansion is nested within another pack expansion, the parameter packs that appear inside the innermost pack expansion are expanded by it, and there must be another pack mentioned in the enclosing pack expansion, but not in the innermost one:</source>
          <target state="translated">팩 확장이 다른 팩 확장 내에 중첩 된 경우 가장 안쪽 팩 확장 안에 표시되는 매개 변수 팩은 그에 의해 확장되며 가장 가까운 팩 확장이 아닌 엔 클로징 팩 확장에 언급 된 다른 팩이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0444eb973f9088dccc9bd6e7338a1a6d154f5d7f" translate="yes" xml:space="preserve">
          <source>If a parsing error is encountered, many implementations of this function leave &lt;code&gt;*t&lt;/code&gt; completely untouched.</source>
          <target state="translated">구문 분석 오류가 발생하면이 함수의 많은 구현에서 &lt;code&gt;*t&lt;/code&gt; 를 완전히 건드리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7dfecd9ffd391c85c521dbadb0fe904c065d326a" translate="yes" xml:space="preserve">
          <source>If a parsing error is encountered, most implementations of this function leave &lt;code&gt;*t&lt;/code&gt; unmodified.</source>
          <target state="translated">구문 분석 오류가 발생하면이 함수의 대부분의 구현은 &lt;code&gt;*t&lt;/code&gt; 를 수정하지 않은 채로 둡니다 .</target>
        </trans-unit>
        <trans-unit id="dcfd421c1a105975620bdb3e159a6ef656b96d8e" translate="yes" xml:space="preserve">
          <source>If a partial specialization of the member template is explicitly specialized for a given (implicit) specialization of the enclosing class template, the primary member template and its other partial specializations are still considered for this specialization of the enclosing class template.</source>
          <target state="translated">멤버 템플리트의 부분 특수화가 엔 클로징 클래스 템플리트의 지정된 (암시 적) 특수화에 대해 명시 적으로 특수화 된 경우, 기본 클래스 템플리트 및 기타 부분 특수화는 여전히 클래스 클래스 템플리트의이 특수화에 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="5e69c709c0eda47248b870b79a0045971cbc9fb3" translate="yes" xml:space="preserve">
          <source>If a pointer &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">포인터 &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95fa4aab00b2248a193df0012ce51bbbfdcb0a2a" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the correct sign).</source>
          <target state="translated">극점 오류가 발생하면 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; 이 반환됩니다 (올바른 부호 포함).</target>
        </trans-unit>
        <trans-unit id="88c1375fb3e07154fab82fd39487a150f20a7acc" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">극점 오류가 발생하면 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="83547df0814e730591b9f631b39a107992bddaca" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">극점 오류가 발생하면 &lt;code&gt;+HUGE_VAL&lt;/code&gt; , &lt;code&gt;+HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;+HUGE_VALL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="55c8a2c8fff5d682aefd99723282ecf86b260cc3" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;-HUGE_VAL&lt;/code&gt;, &lt;code&gt;-HUGE_VALF&lt;/code&gt;, or &lt;code&gt;-HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">극점 오류가 발생하면 &lt;code&gt;-HUGE_VAL&lt;/code&gt; , &lt;code&gt;-HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;-HUGE_VALL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1aad32c287435bd724b2b2cd991a06c95727932d" translate="yes" xml:space="preserve">
          <source>If a pole error or a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">오버플로로 인한 폴 오류 또는 범위 오류가 발생하면 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fd506f2079e184fcad156bfb8a88cdf9abf44715" translate="yes" xml:space="preserve">
          <source>If a postcondition &lt;a href=&quot;../definition#ODR-use&quot;&gt;odr-uses&lt;/a&gt; a parameter in its predicate and the function body modifies the value of that parameter directly or indirectly, the behavior is undefined.</source>
          <target state="translated">사후 조건 이 조건부에서 매개 변수를 &lt;a href=&quot;../definition#ODR-use&quot;&gt;odr- 사용&lt;/a&gt; 하고 함수 본문이 해당 매개 변수의 값을 직접 또는 간접적으로 수정하는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d235423e2c4c1707a767d1a11cf327433b3567be" translate="yes" xml:space="preserve">
          <source>If a postcondition is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is the source location of the function definition.</source>
          <target state="translated">사후 조건을 위반하면 &lt;code&gt;std::contract_violation&lt;/code&gt; 인수에 반영된 소스 위치가 함수 정의의 소스 위치입니다.</target>
        </trans-unit>
        <trans-unit id="8288ef9f3911668bdd42ba2bba9a0191080ea46e" translate="yes" xml:space="preserve">
          <source>If a precondition is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is implementation-defined.</source>
          <target state="translated">사전 조건을 위반하면 &lt;code&gt;std::contract_violation&lt;/code&gt; 인수에 반영된 소스 위치 가 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ef5fcd9d7689008da5f0e4bea11cd119b6efa160" translate="yes" xml:space="preserve">
          <source>If a primary template is a member of another class template, its partial specializations are members of the enclosing class template. If the enclosing template is instantiated, the declaration of each member partial specialization is instantiated as well (the same way declarations, but not definitions, of all other members of a template are instantiated).</source>
          <target state="translated">기본 템플릿이 다른 클래스 템플릿의 멤버 인 경우 부분 전문화는 둘러싸는 클래스 템플릿의 멤버입니다. 엔 클로징 템플리트가 인스턴스화되는 경우 각 멤버 부분 전문화의 선언도 인스턴스화됩니다 (템플릿의 다른 모든 멤버에 대한 정의는 정의와 동일하지 않음).</target>
        </trans-unit>
        <trans-unit id="18b3bedb6ae9572a6c3106b7d4be5f3ebdfc4df2" translate="yes" xml:space="preserve">
          <source>If a program contains declarations of function templates that are</source>
          <target state="translated">프로그램에 다음과 같은 함수 템플릿 선언이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="87ffbc04e56c0394a3ecec919c439f807e6404bc" translate="yes" xml:space="preserve">
          <source>If a put area exist (e.g. file was opened for writing), first calls &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; to write all pending output to the file, including any unshift sequences.</source>
          <target state="translated">넣기 영역이 존재하는 경우 (예 : 파일을 쓰기 위해 열린 경우) 먼저 &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; 를 호출 하여 시프트되지 않은 시퀀스를 포함하여 보류중인 모든 출력을 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="919f0fed96116787f70c42581aa4648db9ff5450" translate="yes" xml:space="preserve">
          <source>If a put area exists (e.g. the file was opened for writing), calls &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; to write all pending output to the file, then flushes the file as if by calling &lt;code&gt;&lt;a href=&quot;../c/fflush&quot;&gt;std::fflush&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">넣기 영역이 존재하는 경우 (예 : 파일을 쓰기 위해 열린 경우) &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 를 호출 하여 보류중인 모든 출력을 파일에 쓴 다음 &lt;code&gt;&lt;a href=&quot;../c/fflush&quot;&gt;std::fflush&lt;/a&gt;&lt;/code&gt; 를 호출하여 파일을 플러시합니다 .</target>
        </trans-unit>
        <trans-unit id="776889337c5b506a958bcb11170f9049bdd28571" translate="yes" xml:space="preserve">
          <source>If a putback position is available in the get area (&lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt;), and the character &lt;code&gt;c&lt;/code&gt; is equal to the character one position to the left of &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; (as determined by &lt;code&gt;Traits::eq(c, gptr()[-1])&lt;/code&gt;, then simply decrements the next pointer (&lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">가져 오기 위치에서 가져 오기 위치를 사용할 수있는 경우 ( &lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt; ) 문자 &lt;code&gt;c&lt;/code&gt; 가 문자 &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; 왼쪽의 한 위치 문자와 동일한 경우 (Trats &lt;code&gt;Traits::eq(c, gptr()[-1])&lt;/code&gt; 의해 결정됨 ) () [-1]) 다음 단순히 다음 포인터 ( &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; )를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="9cb9d7c878f7f8a77860594336867a6041aa5088" translate="yes" xml:space="preserve">
          <source>If a putback position is available in the get area (&lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt;), then decrements the next pointer (&lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;) and returns the character it now points to.</source>
          <target state="translated">가져 오기 영역 ( &lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt; ) 에서 putback 위치를 사용할 수 있으면 다음 포인터 ( &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; )를 줄이고 현재 가리키는 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="79ac53d959c455debaf74453ed6b72c19ac11dfa" translate="yes" xml:space="preserve">
          <source>If a putback position is not available, then calls &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; to back up the input sequence if possible.</source>
          <target state="translated">putback position을 사용할 수 &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; 을 호출 하여 가능한 경우 입력 시퀀스를 백업합니다.</target>
        </trans-unit>
        <trans-unit id="5c9db649e4e6e4c38883de06799ee045378481d1" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the same sign as &lt;code&gt;from&lt;/code&gt;).</source>
          <target state="translated">오버플로 인하여 범위 에러가 발생하는 경우, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; (와 같은 부호를 반환 &lt;code&gt;from&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9842b2827c672e6e4b846cc1f4ef41186aaaf5f3" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">오버플로로 인한 범위 오류가 발생하면 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9e1bf2f0df7137552a9579d23123773adeb14193" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">오버플로로 인한 범위 오류가 발생하면 &lt;code&gt;+HUGE_VAL&lt;/code&gt; , &lt;code&gt;+HUGE_VALF&lt;/code&gt; 또는 &lt;code&gt;+HUGE_VALL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="55d9e5e2db658de793b6612e1c8dc0adb82837dc" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct result (after rounding) is returned.</source>
          <target state="translated">언더 플로로 인한 범위 오류가 발생하면 올림 후 올바른 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="144f2afda2da10823b65a9e4c24a0b3bb37c9913" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct value (after rounding) is returned.</source>
          <target state="translated">언더 플로로 인한 범위 오류가 발생하면 올림 후 올바른 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="949156f77460641cf432a3cc1721f1ed036f3731" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding) is returned.</source>
          <target state="translated">언더 플로로 인해 범위 오류가 발생하면 올림 후 올바른 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="48f1515a1657338dc5a4774929668cb3a0851098" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding), that is.</source>
          <target state="translated">언더 플로로 인해 범위 오류가 발생하면 올바른 결과 (올림 후)입니다.</target>
        </trans-unit>
        <trans-unit id="bea570ee8fcad0dd93ebf596f86eddc89718e8ce" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned if subnormals are supported.</source>
          <target state="translated">언더 플로로 인해 범위 오류가 발생하는 경우, 비정규가 지원되면 올바른 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4771fa50f8d7229b07b35621538a1aac36cd67a9" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned.</source>
          <target state="translated">언더 플로로 인해 범위 오류가 발생하면 올바른 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ccb8e801dc7894cca248dbed67f56627d7cf0cc4" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt;)for the stream is set.</source>
          <target state="translated">읽기 또는 쓰기 오류가 발생 하면 스트림에 대한 오류 표시기 ( &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; )가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e789f3da6463649b436aef5182ff1d2b5da92664" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator for the stream (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt;) is set and the file position is unaffected.</source>
          <target state="translated">읽기 또는 쓰기 오류가 발생하면 스트림의 오류 표시기 ( &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; )가 설정되고 파일 위치에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86b3ac21433e164a790502ba1ef0db8db078e961" translate="yes" xml:space="preserve">
          <source>If a requires-expression contains invalid types or expressions in its requirements, and it does not appear within the declaration of a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt;, then the program is ill-formed.</source>
          <target state="translated">require-expression에 요구 사항에 유효하지 않은 유형 또는 표현식이 포함되어 있고 &lt;a href=&quot;templates#Templated_entity&quot;&gt;템플리트 엔티티&lt;/a&gt; 의 선언 내에 표시되지 않으면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4b01d79ca1850a7a1aa26257022da9a9b9591827" translate="yes" xml:space="preserve">
          <source>If a rewritten candidate is selected by overload resolution for an operator &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;x @ y&lt;/code&gt; is interpreted as the rewritten expression: &lt;code&gt;0 @ (y &amp;lt;=&amp;gt; x)&lt;/code&gt; if the selected candidate is a synthesized candidate with reversed order of parameters, or &lt;code&gt;(x &amp;lt;=&amp;gt; y) @ 0&lt;/code&gt; otherwise, using the selected rewritten &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; candidate.</source>
          <target state="translated">재 작성된 후보가 연산자 과부하 해상도가 선택되면 &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;x @ y&lt;/code&gt; 재기록 식으로 해석되어 &lt;code&gt;0 @ (y &amp;lt;=&amp;gt; x)&lt;/code&gt; 선택한 후보 역전 파라미터 순서 또는과 합성 후보이면 &lt;code&gt;(x &amp;lt;=&amp;gt; y) @ 0&lt;/code&gt; 그렇지 않으면 선택한 다시 쓴 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 후보를 사용하여 &amp;lt;=&amp;gt; y) @ 0 입니다.</target>
        </trans-unit>
        <trans-unit id="d146da8681a775135daad12f043cc5018dc0ef5e" translate="yes" xml:space="preserve">
          <source>If a signal handler is executed as a result of a call to &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (synchronously), then the execution of the handler is</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (동기식) 호출의 결과로 신호 핸들러가 실행 되면 핸들러 실행은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f5eeae6c512283e05fb7f521150bb498afe542b" translate="yes" xml:space="preserve">
          <source>If a standard-layout &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; holds two (or more) standard-layout classes as members, and these classes have a common initial sequence of data members, it is well-defined to examine any member of that common initial sequence regardless of which member of the union is active.</source>
          <target state="translated">표준 레이아웃 &lt;a href=&quot;union&quot;&gt;공용체&lt;/a&gt; 가 두 개 이상의 표준 레이아웃 클래스를 멤버로 보유하고이 클래스에 공통의 초기 데이터 시퀀스 시퀀스가있는 경우, 해당 멤버의 기본 멤버에 관계없이 해당 공통 초기 시퀀스의 멤버를 검사하는 것이 잘 정의되어 있습니다. 노동 조합이 활동하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3cc007cd990ced3f77a08ffa3521f8f43ea784b" translate="yes" xml:space="preserve">
          <source>If a standard-layout union holds two or more standard-layout structs, it is permitted to inspect the common initial part of them.</source>
          <target state="translated">표준 레이아웃 유니언이 둘 이상의 표준 레이아웃 구조체를 보유하는 경우 공통적 인 초기 부분을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c11517af35c72db9ca494141a4ef3243dbf8700" translate="yes" xml:space="preserve">
          <source>If a static data member is declared &lt;code&gt;constexpr&lt;/code&gt;, it is implicitly &lt;code&gt;inline&lt;/code&gt; and does not need to be redeclared at namespace scope. This redeclaration without an initializer (formerly required as shown above) is still permitted, but is deprecated.</source>
          <target state="translated">정적 데이터 멤버가 &lt;code&gt;constexpr&lt;/code&gt; 로 선언 되면 암시 적으로 &lt;code&gt;inline&lt;/code&gt; 되므로 네임 스페이스 범위에서 다시 선언 할 필요가 없습니다. 이니셜 라이저가없는이 선언 (이전에는 위에 표시된대로 필요)은 여전히 ​​허용되지만 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58d434e5ce1cbd3b6a5b0e91079e4162ccbc510a" translate="yes" xml:space="preserve">
          <source>If a static data member of &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; is declared &lt;code&gt;constexpr&lt;/code&gt;, it must be initialized with an initializer in which every expression is a constant expression, right inside the class definition:</source>
          <target state="translated">&lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; 의 정적 데이터 멤버 가 &lt;code&gt;constexpr&lt;/code&gt; 로 선언 되면 클래스 정의 내부에서 모든 표현식이 상수 표현식 인 이니셜 라이저로 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d5250822667240cedf5abd394540f13a00c0bf0" translate="yes" xml:space="preserve">
          <source>If a static data member of integral or enumeration type is declared &lt;code&gt;const&lt;/code&gt; (and not &lt;code&gt;volatile&lt;/code&gt;), it can be initialized with an &lt;a href=&quot;initialization&quot;&gt;initializer&lt;/a&gt; in which every expression is a &lt;a href=&quot;constexpr&quot;&gt;constant expression&lt;/a&gt;, right inside the class definition:</source>
          <target state="translated">정수 또는 열거 유형의 정적 데이터 멤버가 &lt;code&gt;const&lt;/code&gt; ( &lt;code&gt;volatile&lt;/code&gt; 아님)로 선언 된 경우 클래스 정의 내에서 모든 표현식이 &lt;a href=&quot;constexpr&quot;&gt;상수 표현식&lt;/a&gt; 인 &lt;a href=&quot;initialization&quot;&gt;이니셜 라이저&lt;/a&gt; 로 초기화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12dd0f953c32785837578e88c1ac2b71b7c9df42" translate="yes" xml:space="preserve">
          <source>If a substitution failure would occur in a requires-expression for every possible template argument, the program is ill-formed, no diagnostic required:</source>
          <target state="translated">가능한 모든 템플리트 인수에 대해 require-expression에서 대체 실패가 발생하면 프로그램이 잘못 구성되고 진단이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85a2d46acfcfae4cb4dbacf839e2b8264a66b2a5" translate="yes" xml:space="preserve">
          <source>If a textual representation is written using &lt;code&gt;os &amp;lt;&amp;lt; x&lt;/code&gt; and that representation is restored into the same or a different object &lt;code&gt;y&lt;/code&gt; of the same type using &lt;code&gt;is &amp;gt;&amp;gt; y&lt;/code&gt;, then &lt;code&gt;x==y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os &amp;lt;&amp;lt; x&lt;/code&gt; 사용하여 텍스트 표현을 작성 하고 해당 표현 &lt;code&gt;is &amp;gt;&amp;gt; y&lt;/code&gt; 사용하여 동일한 유형 의 동일하거나 다른 객체 &lt;code&gt;y&lt;/code&gt; 로 복원 되면 &lt;code&gt;x==y&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="137821a74c9d0d2d1139c4f208ae9d5537a8856a" translate="yes" xml:space="preserve">
          <source>If a thread offers</source>
          <target state="translated">스레드가 제공하는 경우</target>
        </trans-unit>
        <trans-unit id="e2107d4d6cd0905d309a488e5a792dc268bd6478" translate="yes" xml:space="preserve">
          <source>If a token matches a user-defined literal syntax and a regular literal syntax, it is assumed to be a regular literal (that is, it's impossible to overload &lt;code&gt;LL&lt;/code&gt; in &lt;code&gt;123LL&lt;/code&gt;).</source>
          <target state="translated">토큰이 사용자 정의 리터럴 구문 및 일반 리터럴 구문과 일치하면 일반 리터럴 인 것으로 가정합니다 (즉, &lt;code&gt;123LL&lt;/code&gt; 에서 &lt;code&gt;LL&lt;/code&gt; 을 오버로드 할 수 없음 ).</target>
        </trans-unit>
        <trans-unit id="e7ee443e3c5d2843d1d2376575bce346735adf6d" translate="yes" xml:space="preserve">
          <source>If a type contains both a &lt;code&gt;value_type&lt;/code&gt; member and a &lt;code&gt;element_type&lt;/code&gt; member, then the specializations (5) and (6) are ambiguous.</source>
          <target state="translated">유형에 &lt;code&gt;value_type&lt;/code&gt; 멤버와 &lt;code&gt;element_type&lt;/code&gt; 멤버 가 모두 포함 된 경우 전문화 (5) 및 (6)이 모호합니다.</target>
        </trans-unit>
        <trans-unit id="0fdf3b97165e0c642a71a4a01aa77341934eb9b1" translate="yes" xml:space="preserve">
          <source>If a union contains a non-static data member with a non-trivial &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt;, the default constructor of the union is deleted by default unless a &lt;a href=&quot;union#Union-like_classes&quot;&gt;variant member&lt;/a&gt; of the union has a default member initializer .</source>
          <target state="translated">공용체에 단순하지 않은 &lt;a href=&quot;default_constructor&quot;&gt;기본 생성자&lt;/a&gt; 가있는 비 정적 데이터 멤버가 포함 된 경우, 공용체 의 &lt;a href=&quot;union#Union-like_classes&quot;&gt;변형 멤버&lt;/a&gt; 에 기본 멤버 이니셜 라이저가 없는 경우 기본적으로 유니온의 기본 생성자가 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed781d9376b4a389124dc536ac979cb50e822257" translate="yes" xml:space="preserve">
          <source>If a union contains a non-static data member with a non-trivial special member function (&lt;a href=&quot;copy_constructor&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_constructor&quot;&gt;move&lt;/a&gt; constructor, &lt;a href=&quot;as_operator&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_operator&quot;&gt;move&lt;/a&gt; assignment, or &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;), that function is deleted by default in the union and needs to be defined explicitly by the programmer.</source>
          <target state="translated">공용체에 사소한 특수 구성원 함수 ( &lt;a href=&quot;copy_constructor&quot;&gt;복사&lt;/a&gt; / &lt;a href=&quot;move_constructor&quot;&gt;이동&lt;/a&gt; 생성자, &lt;a href=&quot;as_operator&quot;&gt;복사&lt;/a&gt; / &lt;a href=&quot;move_operator&quot;&gt;이동&lt;/a&gt; 지정 또는 &lt;a href=&quot;destructor&quot;&gt;소멸자&lt;/a&gt; ) 가있는 비 정적 데이터 멤버가 포함 된 경우 해당 함수는 기본적으로 공용체에서 삭제되므로이 함수는 명시 적으로 정의해야합니다. 프로그램 제작자.</target>
        </trans-unit>
        <trans-unit id="099b8ae16a17dd76f9cadbb47f54a708a0db6c1f" translate="yes" xml:space="preserve">
          <source>If a universal character name does not correspond to a code point in ISO/IEC 10646 (the range 0x0-0x10FFFF, inclusive) or if a universal-character-name corresponds to a surrogate code point (the range 0xD800-0xDFFF, inclusive), the program is ill-formed.</source>
          <target state="translated">범용 문자 이름이 ISO / IEC 10646의 코드 포인트 (0x0-0x10FFFF 포함)에 해당하지 않거나 범용 문자 이름이 서로 게이트 코드 포인트 (0xD800-0xDFFF 포함)에 해당하는 경우, 프로그램이 잘못 구성되었습니다.</target>
        </trans-unit>
        <trans-unit id="05d3d79510e285cdbcce2e730e70fb609e1930e6" translate="yes" xml:space="preserve">
          <source>If a user-defined &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is provided, the &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is called again on the value that it returns, recursively, until an &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is reached that returns a plain pointer. After that, built-in semantics are applied to that pointer.</source>
          <target state="translated">사용자 정의 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 가 제공되면 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 에 도달하여 일반 포인터를 리턴 할 때까지 재귀 적으로 리턴하는 값 에서 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 가 다시 호출됩니다 . 그 후 내장 시맨틱이 해당 포인터에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4afbc606ff35300da34cbcea95316abaecaec363" translate="yes" xml:space="preserve">
          <source>If a using-declaration brings the base class assignment operator into derived class, whose signature happens to match the derived class's copy-assignment or move-assignment operator, that operator is hidden by the implicitly-declared copy/move assignment operator of the derived class. Same applies to a using-declaration that inherits a base class constructor that happens to match the derived class copy/move constructor(since C++11).</source>
          <target state="translated">using-declaration이 기본 클래스 할당 연산자를 파생 클래스로 가져 오면 서명이 파생 클래스의 복사 할당 또는 이동 할당 연산자와 일치하는 경우 해당 연산자는 파생 클래스의 암시 적으로 선언 된 복사 / 이동 할당 연산자에 의해 숨겨집니다. . 파생 클래스 복사 / 이동 생성자와 일치하는 기본 클래스 생성자를 상속하는 using 선언에도 동일하게 적용됩니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="f5b571b0ea54c128d0c23143cfd6e47087b60bac" translate="yes" xml:space="preserve">
          <source>If a valid hex digit follows a hex escape in a string literal, it would fail to compile as an invalid escape sequence. String concatenation can be used as a workaround:</source>
          <target state="translated">유효한 16 진수가 문자열 리터럴에서 16 진수 이스케이프 뒤에 오는 경우 잘못된 이스케이프 시퀀스로 컴파일되지 않습니다. 문자열 연결을 해결 방법으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e40960cc6f868e411ccb39ae2869971ab6ec8fa0" translate="yes" xml:space="preserve">
          <source>If a violation handler exits by throwing an exception and a contract is violated on a call to a function with a non-throwing exception specification, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called:</source>
          <target state="translated">예외 처리기를 사용하여 위반 핸들러가 종료되고 예외가 아닌 예외 스펙이있는 함수를 호출 할 때 계약이 위반되면 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="89d508127947fb06fdf07d63dd69506781a83552" translate="yes" xml:space="preserve">
          <source>If a virtual function is non-throwing, all declarations, including the definition, of every overrider must be non-throwing as well, unless the overrider is defined as deleted:</source>
          <target state="translated">가상 함수가 던지기가 아닌 경우, 무시자가 삭제 된 것으로 정의되지 않는 한 모든 재정 의자 정의를 포함한 모든 선언도 던지지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a4f25c0ec9b3244cc6b75eca052c2b903d4a3faa" translate="yes" xml:space="preserve">
          <source>If a width specifier is used, matches exactly</source>
          <target state="translated">너비 지정자를 사용하면 정확히 일치</target>
        </trans-unit>
        <trans-unit id="ee230d51493f44d873329313db640aba06300254" translate="yes" xml:space="preserve">
          <source>If access-specifier is omitted, it defaults to &lt;code&gt;public&lt;/code&gt; for classes declared with class-key &lt;code&gt;struct&lt;/code&gt; and to &lt;code&gt;private&lt;/code&gt; for classes declared with class-key &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">access-specifier가 생략되면, class-key &lt;code&gt;struct&lt;/code&gt; 선언 된 클래스에 대해서는 &lt;code&gt;public&lt;/code&gt; 으로 기본 설정되고 class-key class로 선언 된 클래스 에 대해서는 &lt;code&gt;private&lt;/code&gt; 로 기본 설정 &lt;code&gt;class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bb883e9abe3625b7a86952913a7a8fb72c62f08" translate="yes" xml:space="preserve">
          <source>If after preparation is completed, &lt;code&gt;is.good() == true&lt;/code&gt;, then any subsequent calls to &lt;code&gt;operator bool&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">준비가 완료된 후 &lt;code&gt;is.good() == true&lt;/code&gt; 후속 &lt;code&gt;operator bool&lt;/code&gt; 호출 은 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="f9cb4a02d9dcd9af6fe36d5a1c910eb0e957522e" translate="yes" xml:space="preserve">
          <source>If all scalar types are big-endian, &lt;code&gt;std::endian::native&lt;/code&gt; equals &lt;code&gt;std::endian::big&lt;/code&gt;</source>
          <target state="translated">모든 스칼라 유형 빅 엔디안 경우 &lt;code&gt;std::endian::native&lt;/code&gt; 등호는 &lt;code&gt;std::endian::big&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d891a5fe804d25c6beb79958744a0d7c5ceede89" translate="yes" xml:space="preserve">
          <source>If all scalar types are little-endian, &lt;code&gt;std::endian::native&lt;/code&gt; equals &lt;code&gt;std::endian::little&lt;/code&gt;</source>
          <target state="translated">모든 스칼라 유형이 리틀 엔디안 인 경우 &lt;code&gt;std::endian::native&lt;/code&gt; &lt;code&gt;std::endian::little&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="12d243121b5c4fac9f94b27743279405785142b5" translate="yes" xml:space="preserve">
          <source>If all scalar types have sizeof equal to 1, endianness does not matter and all three values, &lt;code&gt;std::endian::little&lt;/code&gt;, &lt;code&gt;std::endian::big&lt;/code&gt;, and &lt;code&gt;std::endian::native&lt;/code&gt; are the same</source>
          <target state="translated">모든 스칼라 유형의 크기가 1과 같으면 엔디안은 중요하지 않으며 &lt;code&gt;std::endian::little&lt;/code&gt; , &lt;code&gt;std::endian::big&lt;/code&gt; 및 &lt;code&gt;std::endian::native&lt;/code&gt; 세 값 이 모두 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fee72b37f3cceab886b744b0079670d877f9da6f" translate="yes" xml:space="preserve">
          <source>If all these requirements are satisfied, the program behaves as if there is only one definition in the entire program. Otherwise, the behavior is undefined.</source>
          <target state="translated">이러한 모든 요구 사항이 충족되면 프로그램은 전체 프로그램에 하나의 정의 만있는 것처럼 작동합니다. 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36968e9ab5f085f057a3410989745d6fedfc4429" translate="yes" xml:space="preserve">
          <source>If all variable arguments share a common type, a &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; provides a convenient mechanism (albeit with a different syntax) for accessing variable arguments. In this case however the arguments cannot be modified since &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; can only provide a const pointer to its elements.</source>
          <target state="translated">모든 변수 인수가 공통 유형을 공유하는 경우 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 는 변수 인수에 액세스하기위한 편리한 메커니즘을 제공합니다 (다른 구문에도 불구하고). 그러나이 경우 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 는 해당 요소에 대한 const 포인터 만 제공 할 수 있으므로 인수를 수정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3d9bddcd412f103377a475053cbfe6abb6de8ca4" translate="yes" xml:space="preserve">
          <source>If allocation fails, calls &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&amp;lt;&amp;gt;::setstate(badbit)&lt;/code&gt; which may throw &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">할당이 실패하면 &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 던질 수있는 &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&amp;lt;&amp;gt;::setstate(badbit)&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="2d22bb8db5e7c03b3a89c230b5d801c2d5d1be4c" translate="yes" xml:space="preserve">
          <source>If allocation fails, the coroutine throws &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;, unless the Promise type defines the member function &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt;. If that member function is defined, allocation uses the &lt;code&gt;nothrow&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; and on allocation failure, the coroutine immediately returns the object obtained from &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; to the caller.</source>
          <target state="translated">Promise 유형이 멤버 함수 &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; 정의하지 않는 한 할당에 실패하면 코 루틴은 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 던집니다 . 해당 멤버 함수가 정의 된 경우 할당에서 &lt;code&gt;nothrow&lt;/code&gt; 형식의 &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; 및 할당 실패를 사용하면 코 루틴은 즉시 &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; 에서 얻은 객체를 호출자 에게 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="10b291b7c1e1eda28b0d49719b46140dae50f0df" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.</source>
          <target state="translated">할당이 성공하면 할당 된 메모리 블록에서 객체 유형에 맞게 정렬 된 가장 낮은 (첫 번째) 바이트에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c9ec1b427a47550a259fb9e7cce19a17de85fede" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any scalar type.</source>
          <target state="translated">할당이 성공하면 스칼라 유형에 맞게 정렬 된 할당 된 메모리 블록에서 가장 낮은 (첫 번째) 바이트에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="02152ab02c6a07719ce83211d89650966926f11f" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; function is declared in different translation units, the accumulated sets of default arguments must be the same at the end of each translation unit.</source>
          <target state="translated">경우 &lt;a href=&quot;inline&quot;&gt;인라인&lt;/a&gt; 함수가 서로 다른 번역 단위로 선언, 기본 인자의 누적 세트는 각 변환 단위의 끝에서 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="1551cfc134da3f21c2cecb1326986402690023a3" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; 경우 &amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3b6cc884811a5bc876e80b90a3283051d48412ce" translate="yes" xml:space="preserve">
          <source>If an adaptor takes multiple arguments, these forms are equivalent:</source>
          <target state="translated">어댑터가 여러 인수를 사용하는 경우 다음 형식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e01b1c25d1638defb1bea8fb709196bd2ebf642e" translate="yes" xml:space="preserve">
          <source>If an argument can be interpreted as both a &lt;a href=&quot;type-id&quot;&gt;type-id&lt;/a&gt; and an expression, it is always interpreted as a type-id, even if the corresponding template parameter is non-type:</source>
          <target state="translated">인수가 &lt;a href=&quot;type-id&quot;&gt;type-id&lt;/a&gt; 와 expression으로 해석 될 수있는 경우 해당 템플리트 매개 변수가 type이 아닌 경우에도 항상 type-id로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="c31ea93038a8a30a4e1fc8e381029269be15af66" translate="yes" xml:space="preserve">
          <source>If an array is so large (greater than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; elements, but less than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; bytes), that the difference between two pointers may not be representable as &lt;code&gt;std::ptrdiff_t&lt;/code&gt;, the result of subtracting two such pointers is undefined.</source>
          <target state="translated">배열이 너무 커서 ( &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; 요소 보다 크지 만 &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; 바이트 보다 작음 ) 두 포인터 간의 차이를 &lt;code&gt;std::ptrdiff_t&lt;/code&gt; 로 표현할 수없는 경우 이러한 두 포인터를 뺀 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="799e3725591131ec4c78246e418ad8132ce4bd81" translate="yes" xml:space="preserve">
          <source>If an assertion is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is the source location of the statement to which the assertion is applied.</source>
          <target state="translated">어설 션이 위반되면 &lt;code&gt;std::contract_violation&lt;/code&gt; 인수에 반영된 소스 위치는 어설 션이 적용되는 명령문의 소스 위치입니다.</target>
        </trans-unit>
        <trans-unit id="940fbe62d35554fccc76640b50d6adbc0079900c" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_acquire&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that</source>
          <target state="translated">스레드 A의 원자 저장소에 &lt;code&gt;memory_order_release&lt;/code&gt; 태그가 지정 되고 동일한 변수에서 스레드 B의 원자로드에 &lt;code&gt;memory_order_acquire&lt;/code&gt; 태그가 지정 되면 모든 메모리 쓰기 (비 원자 및 완화 원자)</target>
        </trans-unit>
        <trans-unit id="cf29cb2a4f015597bd5e89b82f0e88a7976c2e6a" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_consume&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that are</source>
          <target state="translated">스레드 A의 원자 저장소에 &lt;code&gt;memory_order_release&lt;/code&gt; 태그가 지정 되고 동일한 변수에서 스레드 B의 원자로드에 &lt;code&gt;memory_order_consume&lt;/code&gt; 태그가 지정된 경우 , 모든 메모리 쓰기 (비 원자 및 완화 원자)</target>
        </trans-unit>
        <trans-unit id="fb35a531d8dbb01db97b20b4045440d69aef50c3" translate="yes" xml:space="preserve">
          <source>If an entity is declared, but not defined in some inner namespace, and then declared through using-declaration in the outer namespace, and then a definition appears in the outer namespace with the same unqualified name, that definition is a member of the outer namespace and conflicts with the using-declration:</source>
          <target state="translated">엔터티가 선언되었지만 일부 내부 네임 스페이스에 정의되지 않은 경우 외부 네임 스페이스에서 using-declaration을 통해 선언 된 후 정의되지 않은 이름이 동일한 외부 네임 스페이스에 정의가 표시되면 해당 정의는 외부 네임 스페이스의 멤버입니다. 사용 감소와 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="cc997e2af47722454e317470db77023efe2a1536" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate.</source>
          <target state="translated">오류가 발생하면 스트림에 대한 파일 위치 표시기의 결과 값이 결정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6911b84a61e5b6d4a44d583d9d016bd32e93add2" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.</source>
          <target state="translated">오류가 발생하면 스트림에 대한 파일 위치 표시기의 결과 값이 결정되지 않습니다. 부분 요소를 읽으면 해당 값이 결정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a220d01f6d39ee26bbdcd1467c8f79348871f6b1" translate="yes" xml:space="preserve">
          <source>If an error occurs, the value of any cached attributes is unspecified.</source>
          <target state="translated">오류가 발생하면 캐시 된 속성 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cb826938ccf3fe4b9ff8ed25a48550d29964cf5" translate="yes" xml:space="preserve">
          <source>If an exception is thrown (e.g. by the constructor), the container is left unmodified, as if this function was never called (strong exception guarantee).</source>
          <target state="translated">예외가 발생하면 (예 : 생성자에 의해)이 함수가 호출되지 않은 것처럼 컨테이너가 수정되지 않은 상태로 유지됩니다 (강력한 예외 보장).</target>
        </trans-unit>
        <trans-unit id="e6b48d12afec14d3a79a0c500c4659180b4eec6c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown (which can be due to &lt;code&gt;Allocator::allocate()&lt;/code&gt; or element copy/move constructor/assignment), this function has no effect (strong exception guarantee).</source>
          <target state="translated">예외가 발생하면 ( &lt;code&gt;Allocator::allocate()&lt;/code&gt; 또는 요소 복사 / 이동 생성자 / 할당 으로 인해 발생할 수 있음 )이 함수는 영향을 미치지 않습니다 (강한 예외 보장).</target>
        </trans-unit>
        <trans-unit id="6b0edabc7639167b7745ce3af46fe3ed92a198db" translate="yes" xml:space="preserve">
          <source>If an exception is thrown and not caught, including exceptions that escape the initial function of &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;, the main function, and the constructor or destructor of any static or thread-local objects, then &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. It is implementation-defined whether any stack unwinding takes place for uncaught exceptions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 의 초기 함수 , 기본 함수 및 정적 또는 스레드 로컬 오브젝트의 생성자 또는 소멸자 를 이스케이프하는 예외를 포함하여 예외가 발생하고 포착되지 않으면 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 가 호출됩니다. 포착되지 않은 예외에 대해 스택 해제가 발생하는지 여부는 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="6c48ec192ada9dad6ea416b0b9a80403d55d5ef7" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, the insertion has no effect.</source>
          <target state="translated">조작에 의해 예외가 발생하면 삽입은 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74d7d81ca3798adddb2a94c8e751e9f52b51c3b5" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, this function has no effect (strong exception guarantee).</source>
          <target state="translated">어떤 조작으로도 예외가 발생하면이 기능은 영향을 미치지 않습니다 (강력한 예외 보장).</target>
        </trans-unit>
        <trans-unit id="5161835af8a659e8b34603c4018519221f368f0d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, this function has no effect.</source>
          <target state="translated">조작에 의해 예외가 발생하면이 기능은 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7330a7b17e421be1c44660348af259ca51b2771d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during &lt;code&gt;insert_after&lt;/code&gt; there are no effects (strong exception guarantee).</source>
          <target state="translated">&lt;code&gt;insert_after&lt;/code&gt; 동안 예외가 발생하면 아무런 영향이 없습니다 (강한 예외 보장).</target>
        </trans-unit>
        <trans-unit id="edd7ac01fb9845bcf837eeafecc9a3bfcff9c06c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, some objects in &lt;code&gt;[first, last)&lt;/code&gt; are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">초기화 중에 예외가 발생하면 &lt;code&gt;[first, last)&lt;/code&gt; 일부 객체 는 유효하지만 지정되지 않은 상태로 남아 있으며 이미 구성된 객체는 지정되지 않은 순서로 소멸됩니다.</target>
        </trans-unit>
        <trans-unit id="ec0adbbf8914c8a6c4eec4111473b5a13e8599b3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, some objects in the source range are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">초기화 중에 예외가 발생하면 소스 범위의 일부 오브젝트는 유효하지만 지정되지 않은 상태로 남아 있으며 이미 구성된 오브젝트는 지정되지 않은 순서로 소멸됩니다.</target>
        </trans-unit>
        <trans-unit id="e9fecf24ed4ce20def8a83e7f8d57995cf139492" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">초기화 중에 예외가 발생하면 이미 구성된 개체가 지정되지 않은 순서대로 소멸됩니다.</target>
        </trans-unit>
        <trans-unit id="e35211af8694cccb5bdef2a4d7dc7571b7be0615" translate="yes" xml:space="preserve">
          <source>If an exception is thrown for any reason, this function has no effect (strong exception guarantee).</source>
          <target state="translated">어떤 이유로 든 예외가 발생하면이 기능은 영향을 미치지 않습니다 (강력한 예외 보장).</target>
        </trans-unit>
        <trans-unit id="7307b2f5ebe1d631c57170aa7d478af487897112" translate="yes" xml:space="preserve">
          <source>If an exception is thrown for any reason, this function has no effect (strong exception guarantee).(since C++11).</source>
          <target state="translated">어떤 이유로 든 예외가 발생하면이 기능은 영향을 미치지 않습니다 (강력한 예외 보장). (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="e6bb71e623e7422ccad975c487b4cc2c5f5da503" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from a constructor or (rare) from a destructor of an object (regardless of the object's storage duration), destructors are called for all fully-constructed non-static non-variant (until C++14)members and base classes, in reverse order of completion of their constructors.  Variant members of union-like classes are only destroyed in the case of unwinding from constructor, and if the active member changed between initialization and destruction, the behavior is undefined.(since C++14).</source>
          <target state="translated">(객체의 저장 기간에 관계없이) 객체의 소멸자에서 생성자 또는 (희귀 한) 예외가 발생하면 모든 완전 비 정적 비 변형 (C ++ 14까지) 멤버에 대해 소멸자가 호출됩니다. 생성자의 완성 순서와 반대로 기본 클래스. 공용체와 유사한 클래스의 변형 멤버는 생성자에서 풀리는 경우에만 소멸되며 활성 멤버가 초기화와 소멸간에 변경되면 동작이 정의되지 않습니다 (C ++ 14부터).</target>
        </trans-unit>
        <trans-unit id="2ad1992b7bb0d63f90a28d4087b380a5f34ae1b1" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by T's move constructor, there are no effects.</source>
          <target state="translated">T의 이동 생성자가 아닌 다른 예외가 발생하면 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0aa3f34d072cd60cd1c35878bea5fd44d2e91e5c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of the value type, or if an exception is thrown while &lt;code&gt;emplace&lt;/code&gt; is used to insert a single element at the either end, there are no effects (strong exception guarantee).</source>
          <target state="translated">복사 생성자, 이동 생성자, 할당 연산자 또는 값 유형의 이동 할당 연산자 &lt;code&gt;emplace&lt;/code&gt; 의 예외가 발생하거나 emplace 를 사용하여 한쪽 끝에 단일 요소를 삽입하는 동안 예외가 발생 하면 효과 (강력한 예외 보장).</target>
        </trans-unit>
        <trans-unit id="e8ab6bfb09942462906da02ee59e1dffd07b24d4" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of the value type, or if an exception is thrown while &lt;code&gt;emplace&lt;/code&gt; is used to insert a single element at the end and the value type is either &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or nothrow move constructible, there are no effects (strong exception guarantee).</source>
          <target state="translated">복사 생성자가 아닌 예외가 발생하거나 값 유형의 이동 생성자, 지정 연산자 또는 이동 지정 연산자가 발생하거나 &lt;code&gt;emplace&lt;/code&gt; 를 사용하여 끝에 단일 요소를 삽입하는 동안 예외가 발생 하고 값 유형이 다음과 같은 경우 하나 &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; 또는 이동 작도 nothrow, 아무 효과 (강력한 예외 보증)이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b1a5d269dbdbb9335cbe2fc340876502acdd2c3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown when inserting a single element at either end, this function has no effect (strong exception guarantee).</source>
          <target state="translated">한쪽 끝에 단일 요소를 삽입 할 때 예외가 발생하면이 기능은 영향을 미치지 않습니다 (강한 예외 보장).</target>
        </trans-unit>
        <trans-unit id="bb38c7fc8ae93e70dfd12f9e670486bb28d436c3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown when inserting a single element at the end, and T is &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or &lt;code&gt;std::is_nothrow_move_constructible&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, there are no effects (strong exception guarantee).</source>
          <target state="translated">끝에 단일 요소를 삽입 할 때 예외가 발생하고 T가 &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; 또는 &lt;code&gt;std::is_nothrow_move_constructible&amp;lt;T&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 효과가 없습니다 (강한 예외 보장).</target>
        </trans-unit>
        <trans-unit id="5998c425618742c5b2fb20a25e64116eb53b0228" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, the order of elements in &lt;code&gt;*this&lt;/code&gt; is unspecified.</source>
          <target state="translated">예외가 발생하면 &lt;code&gt;*this&lt;/code&gt; 요소의 순서 는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5d6cabb3aae2ee52d65a4c1ac74ad65e7757f3c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, the shared lock is not acquired.</source>
          <target state="translated">예외가 발생하면 공유 잠금이 획득되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5440918eea68b650c34253d04fa176ac527a4e96" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, there are no effects (strong exception guarantee).</source>
          <target state="translated">예외가 발생하면 아무런 영향이 없습니다 (강력한 예외 보장).</target>
        </trans-unit>
        <trans-unit id="34d24286b06e2a97113c97c53555bf7644c31051" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (&lt;a href=&quot;../../language/exceptions&quot;&gt;strong exception guarantee&lt;/a&gt;).</source>
          <target state="translated">예외가 발생하면이 기능은 영향을 미치지 않습니다 ( &lt;a href=&quot;../../language/exceptions&quot;&gt;강한 예외 보장&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2bd98e6e41884aadeeb627570c45089a1aee3259" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee), except if the exception comes from the comparison function.</source>
          <target state="translated">예외가 발생하면 비교 함수에서 예외가 발생하는 경우를 제외하고이 함수는 적용되지 않습니다 (강력한 예외 보장).</target>
        </trans-unit>
        <trans-unit id="c56964bda95bd497a307eee33dbbbedb399c8d42" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee).</source>
          <target state="translated">예외가 발생하면이 기능은 영향을 미치지 않습니다 (강력한 예외 보장).</target>
        </trans-unit>
        <trans-unit id="b1f960da1aad3dc9c4054b8661e9f9da8db12dca" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee). If &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">예외가 발생하면이 기능은 영향을 미치지 않습니다 (강력한 예외 보장). 경우 &lt;code&gt;T&lt;/code&gt; 의 이동 생성자가 아닌 &lt;code&gt;noexcept&lt;/code&gt; 되지 않고 &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; 에 &lt;code&gt;*this&lt;/code&gt; , 벡터 던지는 이동 생성자를 사용합니다. 던지면 보증이 면제되고 효과는 명시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e81fff806c92690d8247fab353f430b076a5ddb" translate="yes" xml:space="preserve">
          <source>If an exception was stored in the shared state referenced by the future (e.g. via a call to &lt;a href=&quot;../promise/set_exception&quot;&gt;&lt;code&gt;std::promise::set_exception()&lt;/code&gt;&lt;/a&gt;) then that exception will be thrown.</source>
          <target state="translated">미래에 참조 된 공유 상태 (예 : &lt;a href=&quot;../promise/set_exception&quot;&gt; &lt;code&gt;std::promise::set_exception()&lt;/code&gt; &lt;/a&gt; 대한 호출을 통해)에 예외가 저장된 경우 해당 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d0137b7a583c99b14138ba2d912173e858c09f48" translate="yes" xml:space="preserve">
          <source>If an implicitly-declared destructor is not deleted, it is implicitly defined (that is, a function body is generated and compiled) by the compiler when it is &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. This implicitly-defined destructor has an empty body.</source>
          <target state="translated">내재적으로 선언 된 소멸자가 삭제되지 않은 경우, 컴파일러가 &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used 일&lt;/a&gt; 때 내재적으로 정의됩니다 (즉, 함수 본문이 생성 및 컴파일 됨) . 이 암시 적으로 정의 된 소멸자는 본문이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a6f2dbbaa4e8bf97f99dfa70fb418fa8a9f940e" translate="yes" xml:space="preserve">
          <source>If an inline function is declared in different translation units, the accumulated sets of &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; must be the same at the end of each translation unit.</source>
          <target state="translated">인라인 함수가 다른 변환 단위로 선언 된 경우 누적 된 &lt;a href=&quot;default_arguments&quot;&gt;기본 인수&lt;/a&gt; 세트 는 각 변환 단위의 끝에서 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7990c568402acf3a5d1219a03555ac57df4d740" translate="yes" xml:space="preserve">
          <source>If an inline function or variable(since C++17) with external linkage is defined differently in different translation units, the behavior is undefined.</source>
          <target state="translated">외부 연결이있는 인라인 함수 또는 변수 (C ++ 17부터)가 다른 변환 단위로 다르게 정의되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb3fc767b94cfd5625015f9349fa6a8307905fac" translate="yes" xml:space="preserve">
          <source>If an insertion is performed, the mapped value is &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; (default-constructed for class types, zero-initialized otherwise) and a reference to it is returned.</source>
          <target state="translated">삽입이 수행되면, 맵핑 된 값은 &lt;a href=&quot;../../language/value_initialization&quot;&gt;값으로 초기화되고&lt;/a&gt; (클래스 유형의 경우 기본값으로 구성되고, 그렇지 않으면 0으로 초기화 됨) 이에 대한 참조가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="18180e9058d1e19c0f11fd992aa464bc733a35a8" translate="yes" xml:space="preserve">
          <source>If an insertion occurs and results in a rehashing of the container, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;.</source>
          <target state="translated">삽입이 발생하여 컨테이너가 다시 해시되면 모든 반복자가 무효화됩니다. 그렇지 않으면 반복자는 영향을받지 않습니다. 참조가 무효화되지 않았습니다. 재해시는 새로운 요소 수가 &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt; 보다 큰 경우에만 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="0a574aa99696eb2cfb80cca007e805d644a25910" translate="yes" xml:space="preserve">
          <source>If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined.</source>
          <target state="translated">위의 템플릿 인스턴스화가 직접 또는 간접적으로 불완전한 유형에 의존하고 해당 유형이 가상적으로 완료된 경우 해당 인스턴스화가 다른 결과를 낳을 수있는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a64bffb3522d60e8b666b70574ce5d49611f5000" translate="yes" xml:space="preserve">
          <source>If an internal operation throws an exception, it is caught and &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;badbit&lt;/a&gt;&lt;/code&gt; is set. If &lt;code&gt;&lt;a href=&quot;../basic_ios/exceptions&quot;&gt;exceptions()&lt;/a&gt;&lt;/code&gt; is set for &lt;code&gt;badbit&lt;/code&gt;, the exception is rethrown.</source>
          <target state="translated">내부 작업에서 예외가 발생하면 예외가 발생하고 &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;badbit&lt;/a&gt;&lt;/code&gt; 가 설정됩니다. 경우 &lt;code&gt;&lt;a href=&quot;../basic_ios/exceptions&quot;&gt;exceptions()&lt;/a&gt;&lt;/code&gt; 로 설정되어 &lt;code&gt;badbit&lt;/code&gt; , 예외가 던져 준다.</target>
        </trans-unit>
        <trans-unit id="5a642538c4470f54f4f527d91f99d4f6fe81ff66" translate="yes" xml:space="preserve">
          <source>If an operation on traits emits an exception, the behavior is undefined.</source>
          <target state="translated">특성에 대한 작업에서 예외가 발생하면 동작이 정의되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e13b70715d8672a431c8a76c567c768c6ee6a7b" translate="yes" xml:space="preserve">
          <source>If an overriding function specifies &lt;a href=&quot;attributes/contract&quot;&gt;contract conditions&lt;/a&gt;, it must specify the same list contract conditions as the functions it overrides; no diagnostic is required if corresponding conditions will always evaluate to the same value. Otherwise, it is considered to have the list of contract conditions from one of its overriden functions; the names in the contract conditions are bound and the semantic constraints are checked at the point where the contract conditions appear.</source>
          <target state="translated">재정의 함수가 &lt;a href=&quot;attributes/contract&quot;&gt;계약 조건을&lt;/a&gt; 지정하는 경우 재정의 함수 와 동일한 목록 계약 조건을 지정해야합니다. 해당 조건이 항상 동일한 값으로 평가되는 경우 진단이 필요하지 않습니다. 그렇지 않으면, 대체 기능 중 하나의 계약 조건 목록이있는 것으로 간주됩니다. 계약 조건의 이름이 바인드되고 의미 조건이 계약 조건이 나타나는 지점에서 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="ea6490ada6b718e0dd1982f5bd44675af661c0e9" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; references the control block created by &lt;code&gt;std::make_shared&lt;/code&gt; after the lifetime of all shared owners ended, the memory occupied by &lt;code&gt;T&lt;/code&gt; persists until all weak owners get destroyed as well, which may be undesirable if &lt;code&gt;sizeof(T)&lt;/code&gt; is large.</source>
          <target state="translated">모든 공유 소유자의 수명이 종료 된 후 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;std::make_shared&lt;/code&gt; 의해 작성된 제어 블록을 참조하는 경우 &lt;code&gt;T&lt;/code&gt; 가 점유 한 메모리는 모든 약한 소유자가 파괴 될 때까지 지속되므로 &lt;code&gt;sizeof(T)&lt;/code&gt; 가 바람직하지 않은 경우 바람직하지 않을 수 있습니다 큰.</target>
        </trans-unit>
        <trans-unit id="be9fa8a822bab5c2b3736388d805151fa47e91f3" translate="yes" xml:space="preserve">
          <source>If any Ti is not a comparison category type (&lt;a href=&quot;weak_equality&quot;&gt;&lt;code&gt;std::weak_equality&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;partial_ordering&quot;&gt;&lt;code&gt;std::partial_ordering&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt;), U is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Ti가 비교 범주 유형이 아닌 경우 ( &lt;a href=&quot;weak_equality&quot;&gt; &lt;code&gt;std::weak_equality&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;strong_equality&quot;&gt; &lt;code&gt;std::strong_equality&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;partial_ordering&quot;&gt; &lt;code&gt;std::partial_ordering&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;weak_ordering&quot;&gt; &lt;code&gt;std::weak_ordering&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;strong_ordering&quot;&gt; &lt;code&gt;std::strong_ordering&lt;/code&gt; &lt;/a&gt; ) U는 &lt;code&gt;void&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fa759a7594dd95d5f9753141e5b119ba2c2846a0" translate="yes" xml:space="preserve">
          <source>If any argument is NaN, NaN is returned and domain error is not reported</source>
          <target state="translated">인수가 NaN이면 NaN이 반환되고 도메인 오류가보고되지 않습니다</target>
        </trans-unit>
        <trans-unit id="7e09a18bf23aa9504f4b8622f9df9a40a3b55dc8" translate="yes" xml:space="preserve">
          <source>If any candidate function is a &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; (static or non-static), but not a constructor, it is treated as if it has an extra parameter (</source>
          <target state="translated">후보 함수가 &lt;a href=&quot;member_functions&quot;&gt;멤버 함수&lt;/a&gt; (정적 또는 비 정적)이지만 생성자가 아닌 경우 추가 매개 변수가있는 것처럼 처리됩니다 (</target>
        </trans-unit>
        <trans-unit id="a6bcd0ea08bf821e3fbe550757f07bf7cf22d254" translate="yes" xml:space="preserve">
          <source>If any candidate is a function template, its specializations are generated using &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;, and such specializations are treated just like non-template functions except where specified otherwise in the tie-breaker rules. If a name refers to one or more function templates and also to a set of overloaded non-template functions, those functions and the specializations generated from the templates are all candidates.</source>
          <target state="translated">후보가 함수 템플릿 인 경우 &lt;a href=&quot;template_argument_deduction&quot;&gt;템플릿 인수 공제를&lt;/a&gt; 사용하여 해당 전문화가 생성 되며 이러한 전문화는 타이 브레이커 규칙에 달리 지정된 경우를 제외하고 비 템플릿 함수와 같이 처리됩니다. 이름이 하나 이상의 함수 템플릿과 오버로드 된 비 템플릿 함수 집합을 참조하는 경우 템플릿에서 생성 된 해당 기능 및 전문화가 모두 후보입니다.</target>
        </trans-unit>
        <trans-unit id="126493e0cbb7819d68c915080c830634b2cac172" translate="yes" xml:space="preserve">
          <source>If any function that is called directly by the stack unwinding mechanism, after initialization of the exception object and before the start of the exception handler, exits with an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. Such functions include &lt;a href=&quot;destructor&quot;&gt;destructors&lt;/a&gt; of objects with automatic storage duration whose scopes are exited, and the copy constructor of the exception object that is called (&lt;a href=&quot;copy_elision&quot;&gt;if not elided&lt;/a&gt;) to initialize catch-by-value arguments.</source>
          <target state="translated">스택 해제 메커니즘에 의해 직접 호출 된 함수가 예외 오브젝트 초기화 후 및 예외 핸들러 시작 전에 예외와 함께 종료되면 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 가 호출됩니다. 이러한 함수에는 범위가 종료 된 자동 저장 기간이있는 오브젝트의 &lt;a href=&quot;destructor&quot;&gt;소멸자&lt;/a&gt; 및 &lt;a href=&quot;copy_elision&quot;&gt;값별&lt;/a&gt; 인수를 초기화하기 위해 호출되는 예외 오브젝트의 복사 생성자가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="15dfee2b548c068d0cb9438923992bb46bcca31a" translate="yes" xml:space="preserve">
          <source>If any namespace in the associated set of classes and namespaces directly contains an inline namespace, that inline namespace is added to the set.</source>
          <target state="translated">연관된 클래스 및 네임 스페이스 세트의 네임 스페이스에 인라인 네임 스페이스가 직접 포함되어 있으면 해당 인라인 네임 스페이스가 세트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="96b81c5fbadca60870db38fc2f9a183bb9b6fdca" translate="yes" xml:space="preserve">
          <source>If any namespace in the associated set of classes and namespaces is an &lt;a href=&quot;namespace&quot;&gt;inline namespace&lt;/a&gt;, its enclosing namespace is also added to the set.</source>
          <target state="translated">연관된 클래스 및 네임 스페이스 세트의 네임 스페이스가 &lt;a href=&quot;namespace&quot;&gt;인라인 네임 스페이스 인&lt;/a&gt; 경우 해당 네임 스페이스도 세트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="77bf32371c11f8b0a2f664f75979c288885d06cb" translate="yes" xml:space="preserve">
          <source>If any of the function calls made, including the call to &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;, fails, returns a null pointer. If any of the function calls made throws an exception, the exception is caught and rethrown after calling &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;. If the file is already closed, returns a null pointer right away.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; 호출을 포함하여 함수 호출이 실패하면 널 포인터를 리턴합니다. 함수 호출 중 하나라도 예외를 throw하면 &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; 호출 한 후 예외가 발생하고 다시 발생 합니다. 파일이 이미 닫혀 있으면 즉시 널 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96b62f2f876cd9ccd1e029ff20920e414e1372bd" translate="yes" xml:space="preserve">
          <source>If any of the function parameters uses a</source>
          <target state="translated">함수 매개 변수 중 하나가</target>
        </trans-unit>
        <trans-unit id="2b9407b136cda4e52a8bcbbff35df15df1b4ed8a" translate="yes" xml:space="preserve">
          <source>If any of the operands is a pointer, the following rules apply:</source>
          <target state="translated">피연산자 중 하나가 포인터 인 경우 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6bea11d594aa54f1709b6bc92b826adf56fa3383" translate="yes" xml:space="preserve">
          <source>If any of the private members needs to access a public or protected member, a reference or pointer to the interface may be passed to the private function as a parameter. Alternatively, the back-reference may be maintained as part of the implementation class.</source>
          <target state="translated">개인 구성원 중 하나가 공용 또는 보호 구성원에 액세스해야하는 경우 인터페이스에 대한 참조 또는 포인터가 매개 변수로 개인 기능에 전달 될 수 있습니다. 대안 적으로, 역 참조는 구현 클래스의 일부로서 유지 될 수있다.</target>
        </trans-unit>
        <trans-unit id="f4cf008505537dd2a8c50313e658cc2022e63eda" translate="yes" xml:space="preserve">
          <source>If any of these situations occur in a translation unit, the definition of the type must appear in the same translation unit. Otherwise, it is not required.</source>
          <target state="translated">이러한 상황 중 하나가 번역 단위에서 발생하면 유형 정의가 동일한 번역 단위에 나타나야합니다. 그렇지 않으면 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="205c5da68a3eed873a307fa520147b2a4368cf96" translate="yes" xml:space="preserve">
          <source>If any template definition has a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt; in which the qualifier refers to the</source>
          <target state="translated">템플리트 정의 에 규정자가 참조되는 &lt;a href=&quot;qualified_lookup&quot;&gt;규정 된 이름&lt;/a&gt; 이있는 경우</target>
        </trans-unit>
        <trans-unit id="a99969c90cd633e5812cf58136c1c690e70c4d05" translate="yes" xml:space="preserve">
          <source>If any template definition has a member acess expression where the object expression is the</source>
          <target state="translated">템플리트 정의에 오브젝트 표현식이있는 멤버 액세스 표현식이있는 경우</target>
        </trans-unit>
        <trans-unit id="32c3e54b2ab54a4690246c40558fdcba870991e2" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on &lt;code&gt;*this&lt;/code&gt;, calling &lt;code&gt;notify_one&lt;/code&gt; unblocks one of the waiting threads.</source>
          <target state="translated">스레드가 &lt;code&gt;*this&lt;/code&gt; 에서 대기중인 경우 &lt;code&gt;notify_one&lt;/code&gt; 을 호출 하면 대기중인 스레드 중 하나의 차단이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="7d2a968ab7f2dd81e4eead9cc317c64526456d40" translate="yes" xml:space="preserve">
          <source>If applying &lt;code&gt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; to at least one of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; produces a different type, the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;std::common_type&amp;lt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T1&amp;gt;::type, &lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T2&amp;gt;::type&amp;gt;::type&lt;/code&gt;, if it exists; if not, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;T1&lt;/code&gt; 및 &lt;code&gt;T2&lt;/code&gt; 중 하나 이상에 적용 하면 다른 유형이 생성되는 경우 멤버 &lt;code&gt;type&lt;/code&gt; 이름은 &lt;code&gt;std::common_type&amp;lt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T1&amp;gt;::type, &lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T2&amp;gt;::type&amp;gt;::type&lt;/code&gt; 와 동일한 유형입니다. :: type&amp;gt; :: type ( 존재하는 경우); 그렇지 않은 경우 멤버 &lt;code&gt;type&lt;/code&gt; 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="08759afad939001ce25641ffda80dd6d474e5c10" translate="yes" xml:space="preserve">
          <source>If arg is NaN, NaN is returned</source>
          <target state="translated">arg가 NaN이면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a3fffd54a9398802b03cfe88989a4c46d2ce5774" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments to an operator in an expression has a class type or an enumeration type, both &lt;a href=&quot;expressions#Operators&quot;&gt;builtin operators&lt;/a&gt; and &lt;a href=&quot;operators&quot;&gt;user-defined operator overloads&lt;/a&gt; participate in overload resolution, with the set of candidate functions selected as follows:</source>
          <target state="translated">표현식에서 연산자에 대한 인수 중 하나 이상에 클래스 유형 또는 열거 유형이있는 경우 &lt;a href=&quot;expressions#Operators&quot;&gt;내장 연산자&lt;/a&gt; 와 &lt;a href=&quot;operators&quot;&gt;사용자 정의 연산자 과부하&lt;/a&gt; 모두 다음과 같이 선택된 후보 함수 세트와 함께 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="cfa2de104dcda4911fda849d8572dfd8b37d2933" translate="yes" xml:space="preserve">
          <source>If at least one of the deallocation functions is a destroying delete, all non-destroying deletes are ignored.</source>
          <target state="translated">할당 해제 기능 중 하나 이상이 삭제 삭제 인 경우 모든 비파괴 삭제는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="edc900123598455f7b2624a5d0192ef2c77c276f" translate="yes" xml:space="preserve">
          <source>If at least one of the operands is a pointer or pointer-to-member, array-to-pointer conversions, derived-to-base pointer conversions, function pointer conversions, and qualification conversions are applied as necessary to convert both operands to the same pointer type.</source>
          <target state="translated">피연산자 중 하나 이상이 포인터 또는 포인터-멤버, 배열-포인터 변환, 파생-베이스 포인터 변환, 함수 포인터 변환 및 자격 변환이 두 피연산자를 모두 동일한 것으로 변환하는 데 필요에 따라 적용되는 경우 포인터 타입.</target>
        </trans-unit>
        <trans-unit id="8702bce6fb50aa6cb7bc28c668acc4a3e2449f0f" translate="yes" xml:space="preserve">
          <source>If bool_constexpr returns &lt;code&gt;true&lt;/code&gt;, this declaration has no effect. Otherwise a compile-time error is issued, and the text of message, if any, is included in the diagnostic message.</source>
          <target state="translated">bool_constexpr이 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면이 선언은 적용되지 않습니다. 그렇지 않으면 컴파일 타임 오류가 발생하고 메시지 텍스트 (있는 경우)가 진단 메시지에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="72593242b61b146efa6a985e10a179d983cf718b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; contain values, the contained values are exchanged by calling &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(**this, *other)&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; lvalues must satisfy &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 에 값 이 모두 포함되어 있으면 &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(**this, *other)&lt;/code&gt; 사용하여 호출 하여 포함 된 값을 교환합니다 . swap (** this, * other) . &lt;code&gt;T&lt;/code&gt; 교환 &lt;a href=&quot;../../named_req/swappable&quot;&gt;가능을&lt;/a&gt; 만족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9149200a2a016ffa0cff6b7a2b77a8a41a09bef3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not contain a value, the function has no effect.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 가 모두 값을 포함하지 않으면 함수는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51fcf538b4bb73b4d1fbe54dfcf29fa14c9c5798" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Base&lt;/code&gt; and &lt;code&gt;Derived&lt;/code&gt; are non-union class types, and they are not the same type (ignoring cv-qualification), &lt;code&gt;Derived&lt;/code&gt; shall be a &lt;a href=&quot;../language/incomplete_type&quot;&gt;complete type&lt;/a&gt;; otherwise the behavior is undefined.</source>
          <target state="translated">두 경우 &lt;code&gt;Base&lt;/code&gt; 및 &lt;code&gt;Derived&lt;/code&gt; 비 노조 클래스 형이며, 그들은 동일한 유형 없습니다 (CV-자격을 무시) &lt;code&gt;Derived&lt;/code&gt; 한다 &lt;a href=&quot;../language/incomplete_type&quot;&gt;완전한 형태&lt;/a&gt; ; 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="031007df7a4bbbcc69dda82c9142cab39525a5c6" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are reference types before, determine which is more cv-qualified (in all other cases, cv-qualificiations are ignored for partial ordering purposes)</source>
          <target state="translated">두 경우 &lt;code&gt;P&lt;/code&gt; 및 &lt;code&gt;A&lt;/code&gt; 가 참조 형식이다 전에 더 CV 수식 (다른 모든 경우에, CV-qualificiations가 부분 정렬을 위해 무시한다)인지를 결정</target>
        </trans-unit>
        <trans-unit id="0fbe1e336c3df9cfce302d24095585fa919b438e" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are zero, returns zero. Otherwise, returns the greatest common divisor of &lt;code&gt;|m|&lt;/code&gt; and &lt;code&gt;|n|&lt;/code&gt;.</source>
          <target state="translated">두 경우 &lt;code&gt;m&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 은 제로이며, 반환 제로. 그렇지 않으면 &lt;code&gt;|m|&lt;/code&gt; 최대 공약수를 반환합니다. 그리고 &lt;code&gt;|n|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5805a8f51641bf5a39fc87b226394ea5441b146" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; represent valid dates (&lt;code&gt;x.ok() &amp;amp;&amp;amp; y.ok() == true&lt;/code&gt;), the result of the lexicographical comparison is consistent with the calendar order.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 모두 유효한 날짜 ( &lt;code&gt;x.ok() &amp;amp;&amp;amp; y.ok() == true&lt;/code&gt; )를 나타내는 경우 사전 사전 결과는 달력 순서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="942dbb8422270823dbf96e8d6ddba2211d8b9ddc" translate="yes" xml:space="preserve">
          <source>If both conversion functions and converting constructors can be used to perform some user-defined conversion, the conversion functions and constructors are both considered by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; in &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; and &lt;a href=&quot;reference_initialization&quot;&gt;reference-initialization&lt;/a&gt; contexts, but only the constructors are considered in &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; contexts.</source>
          <target state="translated">변환 함수와 변환 생성자를 모두 사용하여 일부 사용자 정의 변환을 수행 할 수있는 경우 &lt;a href=&quot;copy_initialization&quot;&gt;복사 초기화&lt;/a&gt; 및 &lt;a href=&quot;reference_initialization&quot;&gt;참조 초기화&lt;/a&gt; 컨텍스트 에서 &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해석&lt;/a&gt; 에 의해 변환 함수 및 생성자가 모두 고려 되지만 &lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 컨텍스트 에서는 생성자 만 고려 됩니다. .</target>
        </trans-unit>
        <trans-unit id="a385931d531ce68f4e5f9578700e55c228573984" translate="yes" xml:space="preserve">
          <source>If both copy and move assignment operators are provided, overload resolution selects the move assignment if the argument is an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;rvalue&lt;/i&gt;&lt;/a&gt; (either a &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;prvalue&lt;/i&gt;&lt;/a&gt; such as a nameless temporary or an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;xvalue&lt;/i&gt;&lt;/a&gt; such as the result of &lt;code&gt;std::move&lt;/code&gt;), and selects the copy assignment if the argument is an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;lvalue&lt;/i&gt;&lt;/a&gt; (named object or a function/operator returning lvalue reference). If only the copy assignment is provided, all argument categories select it (as long as it takes its argument by value or as reference to const, since rvalues can bind to const references), which makes copy assignment the fallback for move assignment, when move is unavailable.</source>
          <target state="translated">인수가있는 경우 모두 복사 및 이동 할당 연산자는 오버로드 확인의 선택 이동 할당을 제공하는 경우 &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;를 rvalue는&lt;/i&gt;&lt;/a&gt; (A 중 &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;prvalue&lt;/i&gt;&lt;/a&gt; 무명으로 임시 또는 &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;가 xValue&lt;/i&gt;&lt;/a&gt; 등의 결과로 &lt;code&gt;std::move&lt;/code&gt; 복사 할당), 및 선택을 인수가 &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;lvalue&lt;/i&gt;&lt;/a&gt; (명명 된 오브젝트 또는 lvalue 참조를 리턴하는 함수 / 연산자) 인 경우 복사 할당 만 제공되는 경우 모든 인수 범주가 값을 기준으로 또는 인수를 const 참조로 사용하는 한 (rvalue가 const 참조에 바인딩 될 수 있기 때문에) 인수를 선택하여 이동시 복사 할당을 이동 할당의 폴백으로 만듭니다. 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0bcac6e95caaa2cc81cc604fdcf629399d168aad" translate="yes" xml:space="preserve">
          <source>If both copy and move constructors are provided and no other constructors are viable, overload resolution selects the move constructor if the argument is an &lt;a href=&quot;value_category&quot;&gt;rvalue&lt;/a&gt; of the same type (an &lt;a href=&quot;value_category&quot;&gt;xvalue&lt;/a&gt; such as the result of &lt;code&gt;std::move&lt;/code&gt; or a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; such as a nameless temporary(until C++17)), and selects the copy constructor if the argument is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.</source>
          <target state="translated">모두 복사 및 이동 생성자 제공 인수가 있으면 다른 생성자 이동 생성자 가능한 과부하 해상도가 선택되어 있지 않은 경우 &lt;a href=&quot;value_category&quot;&gt;r- 수치&lt;/a&gt; 동일한 유형 (AN의 &lt;a href=&quot;value_category&quot;&gt;가 xValue&lt;/a&gt; 등의 결과로서 &lt;code&gt;std::move&lt;/code&gt; 또는 &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; 무명 등 temporary (C ++ 17까지))이고 인수가 &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; (명명 된 오브젝트 또는 lvalue 참조를 리턴하는 함수 / 연산자) 인 경우 복사 생성자를 선택합니다 . 복사 생성자 만 제공되는 경우 모든 인수 범주는 rvalue가 const 참조에 바인딩 될 수 있으므로 const에 대한 참조가 필요한 한 해당 인수를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="60aa98cd9f6dc6c43b3235a9ef70bcb42b49d023" translate="yes" xml:space="preserve">
          <source>If both expression are well-formed, the conversion is ambiguous, and the program is ill-formed.</source>
          <target state="translated">두식이 모두 제대로 구성되어 있으면 변환이 모호하고 프로그램이 잘못 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6e8d82bcd24247033be13b857c411fcd62b8ed61" translate="yes" xml:space="preserve">
          <source>If both of the operands are arrays, three-way comparison is ill-formed except when comparing class members of array type.</source>
          <target state="translated">두 피연산자가 모두 배열 인 경우 배열 유형의 클래스 멤버를 비교할 때를 제외하고 3 방향 비교는 잘못된 형식입니다.</target>
        </trans-unit>
        <trans-unit id="c64fda57212a716e4316cdd7fb2f466fbf4fcafb" translate="yes" xml:space="preserve">
          <source>If both operands are signed or both are unsigned, the operand with lesser</source>
          <target state="translated">두 피연산자 모두 부호가 있거나 둘 다 부호가없는 경우 피연산자는</target>
        </trans-unit>
        <trans-unit id="63fa8968e2f3efc134b4cba9025b815ed6390596" translate="yes" xml:space="preserve">
          <source>If both operands have arithmetic types, or if one operand has unscoped enumeration type and the other has integral type, the usual arithmetic conversions are applied to the operands, and then.</source>
          <target state="translated">두 피연산자에 산술 유형이 있거나 한 피연산자가 범위가 지정되지 않은 열거 유형을 갖고 다른 피연산자가 정수 유형을 갖는 경우 일반적인 산술 변환이 피연산자에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3cb97740b2dc89bf4961cce43d6e24c2e65d1e8e" translate="yes" xml:space="preserve">
          <source>If both operands have the same enumeration type E, the operator yields the result of converting the operands to the underlying type of E and applying &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; to the converted operands.</source>
          <target state="translated">두 피연산자가 모두 열거 유형 E가 동일한 경우, 연산자는 피연산자를 기본 유형의 E 로 변환하고 변환 된 피연산자에 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 를 적용한 결과를 산출합니다 .</target>
        </trans-unit>
        <trans-unit id="70c8bba595d6b98224b1253c961bdde354216878" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; flags are set in &lt;code&gt;policy&lt;/code&gt;, it is up to the implementation whether to perform asynchronous execution or lazy evaluation.</source>
          <target state="translated">양쪽 경우 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; 플래그가 설정되어 &lt;code&gt;policy&lt;/code&gt; , 그것은 비동기 실행 또는 게으른 평가를 수행할지 여부를 구현까지입니다.</target>
        </trans-unit>
        <trans-unit id="65568841562f35d225fc26d418379905f6cfe94d" translate="yes" xml:space="preserve">
          <source>If both the converted value and the precision are &lt;code&gt;​0​&lt;/code&gt; the conversion results in no characters.</source>
          <target state="translated">변환 된 값과 정밀도 둘 경우 &lt;code&gt;​0​&lt;/code&gt; 아무 문자의 변환 결과는.</target>
        </trans-unit>
        <trans-unit id="575a8782581ff485f4e8203e4d066fcc1e4f258b" translate="yes" xml:space="preserve">
          <source>If both the remainder and the quotient can be represented as objects of the corresponding type (int, long, long long, std::imaxdiv_t, respectively), returns both as an object of type &lt;code&gt;std::div_t&lt;/code&gt;, &lt;code&gt;std::ldiv_t&lt;/code&gt;, &lt;code&gt;std::lldiv_t&lt;/code&gt;, &lt;code&gt;std::imaxdiv_t&lt;/code&gt; defined as follows:</source>
          <target state="translated">나머지와 지수 모두 해당 타입의 오브젝트 (INT 긴, 긴 길이 표준 : imaxdiv_t를 각각) 타입의 객체로 모두 반환로 표현 될 수 있다면 &lt;code&gt;std::div_t&lt;/code&gt; , &lt;code&gt;std::ldiv_t&lt;/code&gt; , &lt;code&gt;std::lldiv_t&lt;/code&gt; , &lt;code&gt;std::imaxdiv_t&lt;/code&gt; 는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="fa4b3adcc137d0171dfddcda07618256693fd4ac" translate="yes" xml:space="preserve">
          <source>If c16 is the null wide character &lt;code&gt;u'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">c16이 널 와이드 문자 &lt;code&gt;u'\0'&lt;/code&gt; 인 경우, 초기 시프트 상태를 복원하는 데 필요한 시프트 시퀀스가 ​​앞에 오는 널 바이트가 저장되고 변환 상태 매개 변수 &lt;code&gt;*ps&lt;/code&gt; 는 초기 시프트 상태를 나타내도록 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="0f25466cdf38f545ddf52bc150f2465947dd2dd7" translate="yes" xml:space="preserve">
          <source>If c32 is the null wide character &lt;code&gt;U'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">c32가 널 와이드 문자 &lt;code&gt;U'\0'&lt;/code&gt; 인 경우, 초기 시프트 상태를 복원하는 데 필요한 시프트 시퀀스가 ​​앞에 오는 널 바이트가 저장되고 변환 상태 매개 변수 &lt;code&gt;*ps&lt;/code&gt; 는 초기 시프트 상태를 나타내도록 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="2180c8a148a56a1d4c18f8160ac19934198a22be" translate="yes" xml:space="preserve">
          <source>If called during exception handling (typically, in a &lt;code&gt;catch&lt;/code&gt; clause), captures the current exception object and creates an &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; that holds either a copy or a reference to that exception object (depending on the implementation). The referenced object remains valid at least as long as there is an &lt;code&gt;exception_ptr&lt;/code&gt; object that refers to it.</source>
          <target state="translated">예외 처리 중에 (일반적으로 &lt;code&gt;catch&lt;/code&gt; 절에서) 호출 되면 현재 예외 개체를 캡처하고 해당 구현에 따라 해당 예외 개체에 대한 참조 또는 복사본을 보유 하는 &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 을 만듭니다 . 참조 된 오브젝트는이를 참조하는 &lt;code&gt;exception_ptr&lt;/code&gt; 오브젝트 가있는 한 최소한 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="f5efa0791c0ccd4598c1223b0ede652827016b2d" translate="yes" xml:space="preserve">
          <source>If class-level &lt;code&gt;operator delete&lt;/code&gt; is a template function, it must have the return type of &lt;code&gt;void&lt;/code&gt;, the first argument &lt;code&gt;void*&lt;/code&gt;, and it must have two or more parameters. In other words, only placement forms can be templates. The specialization of the template operator delete is chosen with &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;.</source>
          <target state="translated">클래스 레벨 &lt;code&gt;operator delete&lt;/code&gt; 가 템플리트 함수 인 경우, 리턴 유형 인 &lt;code&gt;void&lt;/code&gt; , 첫 번째 인수 &lt;code&gt;void*&lt;/code&gt; 가 있어야하며 둘 이상의 매개 변수가 있어야합니다. 즉, 게재 위치 양식 만 템플릿이 될 수 있습니다. 템플릿 연산자 delete의 전문화는 &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; 과 함께 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="07af41f04d885dcdd7da101bd31c36d13b61ce99" translate="yes" xml:space="preserve">
          <source>If class-level &lt;code&gt;operator new&lt;/code&gt; is a template function, it must have the return type of &lt;code&gt;void*&lt;/code&gt;, the first argument &lt;code&gt;std::size_t&lt;/code&gt;, and it must have two or more parameters. In other words, only placement forms can be templates.</source>
          <target state="translated">클래스 레벨 &lt;code&gt;operator new&lt;/code&gt; 가 템플리트 함수 인 경우 리턴 유형 &lt;code&gt;void*&lt;/code&gt; , 첫 번째 인수 &lt;code&gt;std::size_t&lt;/code&gt; 가 있어야하며 둘 이상의 매개 변수가 있어야합니다. 즉, 게재 위치 양식 만 템플릿이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceee4451276b8b4bcab8ca22c22b303c8fd7055d" translate="yes" xml:space="preserve">
          <source>If concurrent calls to call_once pass different functions &lt;code&gt;f&lt;/code&gt;, it is unspecified which &lt;code&gt;f&lt;/code&gt; will be called. The selected function runs in the same thread as the &lt;code&gt;call_once&lt;/code&gt; invocation it was passed to.</source>
          <target state="translated">call_once에 대한 동시 호출이 다른 함수 &lt;code&gt;f&lt;/code&gt; 를 전달 하면 어떤 &lt;code&gt;f&lt;/code&gt; 를 호출할지 지정되지 않습니다. 선택된 함수 는 전달 된 &lt;code&gt;call_once&lt;/code&gt; 호출 과 동일한 스레드에서 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="e0b50d3647e11790677fe9a4c279326685cf8395" translate="yes" xml:space="preserve">
          <source>If condition evaluates to the value that doesn't match any of the &lt;code&gt;case:&lt;/code&gt; labels, and the &lt;code&gt;default:&lt;/code&gt; label is present, control is transferred to the statement labeled with the &lt;code&gt;default:&lt;/code&gt; label.</source>
          <target state="translated">조건이 &lt;code&gt;case:&lt;/code&gt; labels 중 하나와 일치하지 않는 값으로 평가되고 &lt;code&gt;default:&lt;/code&gt; label이있는 경우 &lt;code&gt;default:&lt;/code&gt; label로 레이블 된 명령문으로 제어가 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5d36a23ea15e574cf486f3e1d5ad8940a574a30" translate="yes" xml:space="preserve">
          <source>If condition evaluates to the value that is equal to the value of one of constant_expressions, then control is transferred to the statement that is labeled with that constant_expression.</source>
          <target state="translated">조건이 constant_expressions 중 하나의 값과 동일한 값으로 평가되면 해당 constant_expression으로 레이블이 지정된 명령문으로 제어가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="5aa862d229a90e1dcafc139a33ba48261cc1ac13" translate="yes" xml:space="preserve">
          <source>If condition is a declaration such as &lt;code&gt;T t = x&lt;/code&gt;, the declared variable is only in scope in the body of the loop, and is destroyed and recreated on every iteration, in other words, such while loop is equivalent to.</source>
          <target state="translated">condition이 &lt;code&gt;T t = x&lt;/code&gt; 와 같은 선언 인 경우 선언 된 변수는 루프 본문의 범위에만 있으며 반복 될 때마다 (즉, 루프가 동등한 동안) 반복되고 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="cc5437232ebb64eb1e0a00ed4f6909a6272177e2" translate="yes" xml:space="preserve">
          <source>If control reaches the end of a function with the return type &lt;code&gt;void&lt;/code&gt; (possibly cv-qualified), end of a constructor, end of a destructor, or the end of a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; for a function with the return type (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt; without encountering a return statement, &lt;code&gt;return;&lt;/code&gt; is executed.</source>
          <target state="translated">제어가 리턴 유형 &lt;code&gt;void&lt;/code&gt; (아마도 cv-qualified)가있는 &lt;a href=&quot;function-try-block&quot;&gt;함수&lt;/a&gt; 의 끝, 생성자 끝, 소멸자 또는 리턴 유형의 함수에 대한 function-try-block 의 끝에 도달하면 (cv 일 수 있음) -qualified) return 문을 만나지 않고 &lt;code&gt;void&lt;/code&gt; , &lt;code&gt;return;&lt;/code&gt; 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="62b123ef59b7917fbc8133c9aaa1f1f874506d99" translate="yes" xml:space="preserve">
          <source>If control reaches the end of the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt;, &lt;code&gt;return 0;&lt;/code&gt; is executed.</source>
          <target state="translated">컨트롤의 끝에 도달하면 &lt;a href=&quot;main_function&quot;&gt;메인 함수를&lt;/a&gt; , &lt;code&gt;return 0;&lt;/code&gt; 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="49147bdd2f3429795748cce29beffb564badb873" translate="yes" xml:space="preserve">
          <source>If cv appears after &lt;code&gt;*&lt;/code&gt; in the pointer declaration, it is part of declarator and applies to the pointer that's being declared.</source>
          <target state="translated">cv가 포인터 선언에서 &lt;code&gt;*&lt;/code&gt; 뒤에 나타나면 선언자의 일부이며 선언되는 포인터에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d8f20c7d00a034ba772281f4476c576329d5b6f" translate="yes" xml:space="preserve">
          <source>If cv appears before &lt;code&gt;*&lt;/code&gt; in the pointer declaration, it is part of decl-specifier-seq and applies to the the pointed-to object.</source>
          <target state="translated">cv가 포인터 선언에서 &lt;code&gt;*&lt;/code&gt; 앞에 나타나면 decl-specifier-seq의 일부이며 지정된 객체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dbec49aac99d6e7dc2b90341eae53b09e233425a" translate="yes" xml:space="preserve">
          <source>If declarations &lt;code&gt;D1&lt;/code&gt; and &lt;code&gt;D2&lt;/code&gt; are constrained and D1's associated constraints subsume D2's associated constraints (or if D2 is unconstrained), then D1 is said to be</source>
          <target state="translated">선언 &lt;code&gt;D1&lt;/code&gt; 과 &lt;code&gt;D2&lt;/code&gt; 가 구속되고 D1의 관련 구속 조건이 D2의 관련 구속 조건을 가정하거나 (또는 ​​D2가 구속되지 않은 경우), D1은</target>
        </trans-unit>
        <trans-unit id="2411be601f654a07bbdca0b7276e84a7d05756e0" translate="yes" xml:space="preserve">
          <source>If deduction fails , or if deduction succeeds, but the specialization it produces would be invalid (for example, an overloaded operator whose parameters are neither class nor enumeration types),(since C++14) the specialization is not included in the overload set, similar to &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;.</source>
          <target state="translated">추론이 실패하거나 추론이 성공하지만 생성하는 전문화가 유효하지 않은 경우 (예 : 매개 변수가 클래스 나 열거 형이 아닌 오버로드 된 연산자), (C ++ 14부터) 전문화는 과부하 세트에 포함되지 않습니다 &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="5007ba94c2b890c9a53ac3f2ede0070a7fe62fea" translate="yes" xml:space="preserve">
          <source>If deduction succeeds in both directions, and the original &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; were reference types, then additional tests are made:</source>
          <target state="translated">양방향으로 공제가 성공하고 원래 &lt;code&gt;P&lt;/code&gt; 및 &lt;code&gt;A&lt;/code&gt; 가 참조 유형 인 경우 추가 테스트가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c96fa04a65c71e2fd19130c8575defd3c41edbfb" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;M&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt; is not an integer type, or if either is (possibly cv-qualified) &lt;code&gt;bool&lt;/code&gt;, the program is ill-formed.</source>
          <target state="translated">어느 경우 &lt;code&gt;M&lt;/code&gt; 또는 &lt;code&gt;N&lt;/code&gt; 은 정수형 없거나 하나가 (아마도 CV 수식)이면 &lt;code&gt;bool&lt;/code&gt; 프로그램이 잘못 형성된다.</target>
        </trans-unit>
        <trans-unit id="c79ea3237a0ed39b951058e0ae87cf69e04e9f5e" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is a null pointer, the behavior is undefined, even if &lt;code&gt;count&lt;/code&gt; is zero.</source>
          <target state="translated">두 경우 &lt;code&gt;dest&lt;/code&gt; 또는 &lt;code&gt;src&lt;/code&gt; 널 포인터, 동작이 경우에도 정의되지 않는다 &lt;code&gt;count&lt;/code&gt; 제로이다.</target>
        </trans-unit>
        <trans-unit id="1250474b9c6ad69852373ae63ef180eb204a2f48" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; has an implementation-defined &lt;a href=&quot;file_type&quot;&gt;file type&lt;/a&gt;, the effects of this function are implementation-defined.</source>
          <target state="translated">어느 경우 &lt;code&gt;from&lt;/code&gt; 또는 &lt;code&gt;to&lt;/code&gt; 구현에 정의한 &lt;a href=&quot;file_type&quot;&gt;파일 형식&lt;/a&gt; 이 기능의 효과가 구현 정의된다.</target>
        </trans-unit>
        <trans-unit id="4165a5260d21b11f33113753f30c5f524bccf1ba" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; is not a regular file, a directory, or a symlink, as determined by &lt;code&gt;&lt;a href=&quot;is_other&quot;&gt;std::filesystem::is_other&lt;/a&gt;&lt;/code&gt;, reports an error</source>
          <target state="translated">두 경우 &lt;code&gt;from&lt;/code&gt; 나 &lt;code&gt;to&lt;/code&gt; 결정에 따라 일반 파일, 디렉토리 또는 심볼릭 링크 아닌 &lt;code&gt;&lt;a href=&quot;is_other&quot;&gt;std::filesystem::is_other&lt;/a&gt;&lt;/code&gt; 오류를보고</target>
        </trans-unit>
        <trans-unit id="6f243ca5c29fe6335eb0defcad2154158bb206f7" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;m&lt;/code&gt; or &lt;code&gt;n&lt;/code&gt; is zero, returns zero. Otherwise, returns the least common multiple of &lt;code&gt;|m|&lt;/code&gt; and &lt;code&gt;|n|&lt;/code&gt;.</source>
          <target state="translated">어느 경우 &lt;code&gt;m&lt;/code&gt; 또는 &lt;code&gt;n&lt;/code&gt; 은 제로, 반환 제로. 그렇지 않으면 &lt;code&gt;|m|&lt;/code&gt; 의 최소 ​​공배수를 반환합니다 그리고 &lt;code&gt;|n|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dab1eb6195d1939bf5f575a24a97060849eb62a" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;p1&lt;/code&gt; or &lt;code&gt;p2&lt;/code&gt; does not exist, an error is reported.</source>
          <target state="translated">어느 경우 &lt;code&gt;p1&lt;/code&gt; 또는 &lt;code&gt;p2&lt;/code&gt; 존재하지 않는 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="192b44dddfe8a0edbf403637b9dc082e8fcbccab" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; is NaN or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">두 경우 &lt;code&gt;x&lt;/code&gt; 가 NaN의 또는 &lt;code&gt;y&lt;/code&gt; 는 NaN의 NaN이 반환된다</target>
        </trans-unit>
        <trans-unit id="5798cb4e0bd7a6d21c2a60a89c9c101a7f709c34" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">어느 경우 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; NaN의 NaN이 반환된다</target>
        </trans-unit>
        <trans-unit id="777b045843b0ca1ef95a9acf19549cb4d27be21b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;|m|&lt;/code&gt; or &lt;code&gt;|n|&lt;/code&gt; is not representable as a value of type &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;M, N&amp;gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">하나 만약 &lt;code&gt;|m|&lt;/code&gt; 또는 &lt;code&gt;|n|&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;M, N&amp;gt;&lt;/code&gt; 유형의 값으로 표시 할 수 없으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1b8d9bd67fa1ccf8414b0062f383f3be7b83851" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, NaN is returned</source>
          <target state="translated">인수 중 하나가 NaN이면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="503d04bbbfdfac42a885dc014eabc01dd48a5379" translate="yes" xml:space="preserve">
          <source>If either function is declared despite being unspecified, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal. This makes it possible to instantiate &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">지정되지 않은 함수 중 하나라도 선언 된 경우 함수의 선언 (정의 일 필요는 없지만)이 합법적이라는 점을 제외하고는 반환 유형이 무엇인지 지정되지 않습니다. 이를 통해 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;void&amp;gt;&lt;/code&gt; 를 인스턴스화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dea65a53043b826e1ccaac4bd2898d99fa59f1dd" translate="yes" xml:space="preserve">
          <source>If either operand has scoped enumeration type, no conversion is performed: the other operand and the return type must have the same type</source>
          <target state="translated">피연산자가 범위 지정된 열거 유형 인 경우 변환이 수행되지 않습니다. 다른 피연산자와 리턴 유형은 동일한 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4facc3a3dde5ddbefb08336856d6b20eb05ed6dc" translate="yes" xml:space="preserve">
          <source>If either the remainder or the quotient cannot be represented, the behavior is undefined.</source>
          <target state="translated">나머지 또는 몫을 표현할 수없는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="529682e54cfd3160519cd2474a27a6556b3a893e" translate="yes" xml:space="preserve">
          <source>If erasing at begin - only erased elements</source>
          <target state="translated">처음에 지우는 경우-지워진 요소 만</target>
        </trans-unit>
        <trans-unit id="de5cb8f72cd15ee74ae08d973ff1870dcb3c7c8e" translate="yes" xml:space="preserve">
          <source>If erasing at end - only erased elements and the past-the-end iterator</source>
          <target state="translated">끝에서 지울 경우-지워진 요소와 과거 반복기 만</target>
        </trans-unit>
        <trans-unit id="9de48b7003a6c58f9874d3ee61667a92104df825" translate="yes" xml:space="preserve">
          <source>If errors prevent even knowing whether &lt;code&gt;p&lt;/code&gt; exists, the non-throwing overload sets &lt;code&gt;ec&lt;/code&gt; and returns &lt;code&gt;file_status(file_type::none)&lt;/code&gt;, and the throwing overload throws &lt;code&gt;filesystem_error&lt;/code&gt;</source>
          <target state="translated">오류가 &lt;code&gt;p&lt;/code&gt; 의 존재 여부를 알지 못하는 경우 , 던지지 않는 과부하는 &lt;code&gt;ec&lt;/code&gt; 를 설정 하고 &lt;code&gt;file_status(file_type::none)&lt;/code&gt; 반환 하고 던지는 과부하는 &lt;code&gt;filesystem_error&lt;/code&gt; 를 발생시킵니다</target>
        </trans-unit>
        <trans-unit id="3d96531c98aaf0d81f4a8e0e1ddfb0d8bc73bc9f" translate="yes" xml:space="preserve">
          <source>If execution of a function invoked as part of the algorithm throws an exception and &lt;code&gt;ExecutionPolicy&lt;/code&gt; is one of the &lt;a href=&quot;../algorithm/execution_policy_tag_t&quot;&gt;standard policies&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For any other &lt;code&gt;ExecutionPolicy&lt;/code&gt;, the behavior is implementation-defined.</source>
          <target state="translated">알고리즘의 일부로 호출되는 함수의 실행이 예외가 발생하고있는 경우 &lt;code&gt;ExecutionPolicy&lt;/code&gt; 가 중 하나입니다 &lt;a href=&quot;../algorithm/execution_policy_tag_t&quot;&gt;표준 정책&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 라고합니다. 다른 &lt;code&gt;ExecutionPolicy&lt;/code&gt; 의 경우 동작이 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2f4657ab0e97f8d71eba8e43d00ec9ecedaa739f" translate="yes" xml:space="preserve">
          <source>If execution of a function invoked as part of the algorithm throws an exception and &lt;code&gt;ExecutionPolicy&lt;/code&gt; is one of the &lt;a href=&quot;execution_policy_tag_t&quot;&gt;standard policies&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For any other &lt;code&gt;ExecutionPolicy&lt;/code&gt;, the behavior is implementation-defined.</source>
          <target state="translated">알고리즘의 일부로 호출되는 함수의 실행이 예외가 발생하고있는 경우 &lt;code&gt;ExecutionPolicy&lt;/code&gt; 가 중 하나입니다 &lt;a href=&quot;execution_policy_tag_t&quot;&gt;표준 정책&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 라고합니다. 다른 &lt;code&gt;ExecutionPolicy&lt;/code&gt; 의 경우 동작이 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="9a2f05c159a24f9f71a90bb51a81dc74cfece89a" translate="yes" xml:space="preserve">
          <source>If expr is omitted in the declaration of an array, the type declared is &quot;array of unknown bound of T&quot;, which is a kind of &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, except when used in a declaration with an &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initializer&lt;/a&gt;:</source>
          <target state="translated">배열 선언에서 expr을 생략하면 선언 된 형식은 &quot;알 수없는 경계의 배열 T&quot; 입니다. &lt;a href=&quot;aggregate_initialization&quot;&gt;집계 초기화 프로그램이&lt;/a&gt; 있는 선언에 사용 된 경우를 제외하고 는 &lt;a href=&quot;incomplete_type&quot;&gt;불완전한 형식입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d71ce2b38f67adf9252fa0e30106230c2ec3b97c" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a null pointer value, no destructors are called, and the deallocation function is not called.</source>
          <target state="translated">expression이 널 포인터 값으로 평가되면 소멸자가 호출되지 않고 할당 해제 기능이 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6030f7d71e85a510bb8fdfa1c9d0573272b5c6c2" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a null pointer value, no destructors are called, and the deallocation function may or may not be called (it's implementation-defined), but the default deallocation functions are guaranteed to do nothing when handed a null pointer.</source>
          <target state="translated">expression이 널 포인터 값으로 평가되면 소멸자가 호출되지 않고 할당 해제 함수가 호출되거나 구현되지 않을 수 있지만 (구현이 정의되어 있음), 기본 할당 해제 함수는 널 포인터를 전달할 때 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c393875f487dbcd2dff5fb7351c909c9b7c6ee3" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a pointer to a base class subobject of the object that was allocated with &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt;, the destructor of the base class must be virtual, otherwise the behavior is undefined.</source>
          <target state="translated">expression이 &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt; 로 할당 된 객체의 기본 클래스 하위 객체에 대한 포인터를 평가하는 경우 기본 클래스 의 소멸자는 가상이어야합니다. 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c30833ec734b1a7a3060b4576f5f2e61609aa23" translate="yes" xml:space="preserve">
          <source>If expression has array type &lt;code&gt;A&lt;/code&gt; and no ref-operator is present, then &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; has type</source>
          <target state="translated">식에 배열 유형 &lt;code&gt;A&lt;/code&gt; 가 있고 참조 연산자가 없으면 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; 에 유형이 있습니다</target>
        </trans-unit>
        <trans-unit id="e6b3ab3f640c9298f96902e88e604333b949d1d4" translate="yes" xml:space="preserve">
          <source>If expression is a function call which returns a prvalue of class type or is a &lt;a href=&quot;operator_other&quot;&gt;comma expression&lt;/a&gt; whose right operand is such a function call, a temporary object is not introduced for that prvalue.</source>
          <target state="translated">expression이 클래스 유형의 prvalue를 리턴하는 함수 호출이거나 올바른 피연산자가 그러한 함수 호출 인 &lt;a href=&quot;operator_other&quot;&gt;쉼표 표현식&lt;/a&gt; 인 경우 해당 prvalue에 임시 오브젝트가 도입되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcbd7c68e8be5419186b82db2695d726340da722" translate="yes" xml:space="preserve">
          <source>If expression is a prvalue other than a (possibly parenthesized) &lt;a href=&quot;consteval&quot;&gt;immediate invocation&lt;/a&gt;(since C++20), a temporary object is not &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from that prvalue.</source>
          <target state="translated">expression이 (괄호로 묶은) &lt;a href=&quot;consteval&quot;&gt;즉시 호출&lt;/a&gt; (C ++ 20 이후 ) 이외의 prvalue 인 경우 임시 오브젝트는 해당 prvalue에서 &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;구체화&lt;/a&gt; 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5eb42168b532c7b11548b11828f78705b38da223" translate="yes" xml:space="preserve">
          <source>If expression is a prvalue, the result object is initialized directly by that expression. This does not involve a copy or move constructor when the types match (see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;).</source>
          <target state="translated">expression이 prvalue 인 경우 결과 오브젝트는 해당 표현식에 의해 직접 초기화됩니다. 유형이 일치 할 때 복사 또는 이동 생성자가 포함되지 않습니다 ( &lt;a href=&quot;copy_elision&quot;&gt;복사 제거&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4e15b97975662cad27203429fdb2250f97231751" translate="yes" xml:space="preserve">
          <source>If expression is an lvalue expression that is the (possibly parenthesized) name of an automatic storage duration object declared in the body or as a parameter of the innermost enclosing function or lambda expression, then &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; to select the constructor to use for initialization of the returned value or, for &lt;code&gt;co_return&lt;/code&gt;, to select the overload of &lt;code&gt;promise.return_value()&lt;/code&gt;(since C++20) is performed</source>
          <target state="translated">expression이 본문에 선언 된 자동 저장 기간 오브젝트의 괄호 안에있는 lvalue 표현식이거나 가장 안쪽에있는 함수 또는 람다 표현식의 매개 변수로 사용되는 lvalue 표현식 인 경우, &lt;a href=&quot;overload_resolution&quot;&gt;과부하 분석&lt;/a&gt; 은 초기화에 사용할 생성자를 선택합니다. 반환 값 또는 &lt;code&gt;co_return&lt;/code&gt; 의 경우 promise 의 오버로드를 선택합니다 &lt;code&gt;promise.return_value()&lt;/code&gt; C ++ 20부터 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="adc41fc0a93030206f4cdfeba4b6fcb313c8da70" translate="yes" xml:space="preserve">
          <source>If expression is not a null pointer and the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt; deallocation function&lt;/a&gt; is not a destroying delete(since C++20), the &lt;code&gt;delete&lt;/code&gt; expression invokes the &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt; (if any) for the object that's being destroyed, or for every element of the array being destroyed (proceeding from the last element to the first element of the array).</source>
          <target state="translated">expression이 널 포인터 가 아니고 &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;할당 해제 함수&lt;/a&gt; 가 C ++ 20부터 삭제 삭제가 아닌 경우, &lt;code&gt;delete&lt;/code&gt; 표현식은 &lt;a href=&quot;destructor&quot;&gt;파괴&lt;/a&gt; 되는 오브젝트 또는 파괴되는 배열의 모든 요소에 대해 소멸자를 호출합니다 (있는 경우). (마지막 요소에서 배열의 첫 번째 요소로 진행).</target>
        </trans-unit>
        <trans-unit id="d68091a3a051bfac77278071ebbbc0e0bd6aacd1" translate="yes" xml:space="preserve">
          <source>If extraction fails (e.g. if a letter was entered where a digit is expected), &lt;code&gt;value&lt;/code&gt; is left unmodified and &lt;code&gt;failbit&lt;/code&gt; is set.</source>
          <target state="translated">추출이 실패하면 (예 : 숫자가 예상되는 곳에 문자가 입력 된 경우) &lt;code&gt;value&lt;/code&gt; 이 수정되지 않은 상태로 유지되고 &lt;code&gt;failbit&lt;/code&gt; 가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="88e6442a7bfe1de939efde09d5178c75fe73775c" translate="yes" xml:space="preserve">
          <source>If extraction fails, zero is written to &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt; is set. If extraction results in the value too large or too small to fit in &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; is written and &lt;code&gt;failbit&lt;/code&gt; flag is set.</source>
          <target state="translated">추출에 실패하면 0이 &lt;code&gt;value&lt;/code&gt; 기록 되고 &lt;code&gt;failbit&lt;/code&gt; 가 설정됩니다. 너무 크거나 너무 작은 값의 추출 결과에 맞게 경우 &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; 기록되고 &lt;code&gt;failbit&lt;/code&gt; 의 플래그가 설정된다.</target>
        </trans-unit>
        <trans-unit id="9f80eb0726a214c94ee0e311172def7a79d33bde" translate="yes" xml:space="preserve">
          <source>If feature testing is supported, the features described here are indicated by the macro constant &lt;code&gt;__cpp_transactional_memory&lt;/code&gt; with a value equal or greater &lt;code&gt;201505&lt;/code&gt;.</source>
          <target state="translated">기능 테스트가 지원되는 경우 여기에 설명 된 기능 은 값이 &lt;code&gt;201505&lt;/code&gt; 이상인 매크로 상수 &lt;code&gt;__cpp_transactional_memory&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7451ef31b492ad560a6bc540d182167c27d069c5" translate="yes" xml:space="preserve">
          <source>If for some &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;X​::​eq_int_type(e, X​::​to_int_type(c))&lt;/code&gt; is true, &lt;code&gt;c&lt;/code&gt;</source>
          <target state="translated">일부 &lt;code&gt;c&lt;/code&gt; 의 경우 , &lt;code&gt;X​::​eq_int_type(e, X​::​to_int_type(c))&lt;/code&gt; 가 true이면, &lt;code&gt;c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3824d6a7dbddfd44d6a10b166cb4fa4fdc9aa537" translate="yes" xml:space="preserve">
          <source>If forward declaration appears in local scope, it</source>
          <target state="translated">순방향 선언이 로컬 범위에 나타나면</target>
        </trans-unit>
        <trans-unit id="64e89aa46e58a2c727a5922e705eb374f16e676e" translate="yes" xml:space="preserve">
          <source>If implemented, returns the number of characters left to read from the file.</source>
          <target state="translated">구현 된 경우 파일에서 읽을 왼쪽 문자 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1dbd63790122a2d4ba6e64de77bc6208558b4f4f" translate="yes" xml:space="preserve">
          <source>If init-statement is used, the if statement is equivalent to.</source>
          <target state="translated">init-statement가 사용되면 if 문은 같습니다.</target>
        </trans-unit>
        <trans-unit id="3828f6a7891b0f54ec954884dcea4fe13ee69fe4" translate="yes" xml:space="preserve">
          <source>If init-statement is used, the switch statement is equivalent to.</source>
          <target state="translated">init-statement가 사용되면 switch 문은 같습니다.</target>
        </trans-unit>
        <trans-unit id="c47d0b28593af3bb521e18dc6a2d3803710c1f80" translate="yes" xml:space="preserve">
          <source>If initialization terminates by throwing an exception (e.g. from the constructor), if new-expression allocated any storage, it calls the appropriate &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt;: &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; for non-array &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; for array &lt;code&gt;type&lt;/code&gt;. The deallocation function is looked up in global scope if the new-expression used the &lt;code&gt;::new&lt;/code&gt; syntax, otherwise it is looked up in the scope of &lt;code&gt;T&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a class type. If the failed allocation function was usual (non-placement), lookup for the deallocation function follows the rules described in &lt;a href=&quot;delete&quot;&gt;delete-expression&lt;/a&gt;. For a failed placement new, all parameter types, except the first, of the matching deallocation function must be identical to the parameters of the placement new. The call to the deallocation function is made the value obtained earlier from the allocation function passed as the first argument, alignment passed as the optional alignment argument(since C++17), and &lt;code&gt;placement_params&lt;/code&gt;, if any, passed as the additional placement arguments. If no deallocation function is found, memory is not deallocated.</source>
          <target state="translated">새로운 식 스토리지를 할당하는 경우 (생성자에서 예) 예외를 발생하여 초기화가 종료는, 그것을 적절한 호출하면 &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;해제 기능&lt;/a&gt; : &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; 되지 않은 배열을위한 &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; 배열을위한 &lt;code&gt;type&lt;/code&gt; . 새로운 표현이 사용 된 경우, 해제 기능은 전역 범위에서 조회됩니다 &lt;code&gt;::new&lt;/code&gt; 구문을 그렇지 않으면 범위에 조회됩니다, &lt;code&gt;T&lt;/code&gt; 경우, &lt;code&gt;T&lt;/code&gt; 는 클래스 타입입니다. 실패한 할당 기능이 평소 (비 배치) 인 경우 할당 해제 기능을 검색하면 &lt;a href=&quot;delete&quot;&gt;delete-expression에&lt;/a&gt; 설명 된 규칙을 따릅니다.. 새로운 배치 실패의 경우, 일치하는 할당 해제 기능의 첫 번째 매개 변수 유형을 제외한 모든 매개 변수 유형은 새로운 배치의 매개 변수와 동일해야합니다. 할당 해제 함수 호출은 (17 ++ C 때문에) 이전에 첫 번째 인수로서 건네 할당 기능, 선택적 배향 인수로서 건네 정렬로부터 얻어진 값 및 이루어진다 &lt;code&gt;placement_params&lt;/code&gt; 을 추가 배치 인수로서 건네있는 경우. 할당 해제 기능이 없으면 메모리 할당이 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25af59fbe30345e9f2749bc57dd4353c2aaf12fb" translate="yes" xml:space="preserve">
          <source>If initializer is a brace-enclosed list of arguments, the array is &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">이니셜 라이저가 중괄호로 묶인 인수 목록 인 경우 배열은 &lt;a href=&quot;aggregate_initialization&quot;&gt;집계 초기화&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="03cdfead59246b594ac83a38977a55a017d25ad2" translate="yes" xml:space="preserve">
          <source>If initializer is a brace-enclosed list of arguments, the object is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt;.</source>
          <target state="translated">이니셜 라이저가 중괄호로 묶인 인수 목록 인 경우 오브젝트는 &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cb798be20c8b8f83663a5d3251bd571437d043f9" translate="yes" xml:space="preserve">
          <source>If initializer is a parenthesized list of arguments, the array is &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">이니셜 라이저가 괄호로 묶인 인수 목록 인 경우 배열은 &lt;a href=&quot;aggregate_initialization&quot;&gt;집계 초기화&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f352a230f880eaabfec8de9e04e32d41381d1c34" translate="yes" xml:space="preserve">
          <source>If initializer is a parenthesized list of arguments, the object is &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt;.</source>
          <target state="translated">이니셜 라이저가 괄호로 묶인 인수 목록 인 경우 객체는 &lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="b6b9b4663cfe2da6404a6f0c08f1da0645b33d77" translate="yes" xml:space="preserve">
          <source>If initializer is absent, each element is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;</source>
          <target state="translated">이니셜 라이저가 없으면 각 요소는 &lt;a href=&quot;default_initialization&quot;&gt;기본적으로 초기화됩니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05b0a18ac26e055f0b1b9a9cd56c953cc13ad39f" translate="yes" xml:space="preserve">
          <source>If initializer is absent, the object is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;.</source>
          <target state="translated">이니셜 라이저가 없으면 객체는 &lt;a href=&quot;default_initialization&quot;&gt;기본적으로 초기화&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="a4a45120f7db08d564e532f628e9ea01317f74f2" translate="yes" xml:space="preserve">
          <source>If initializer is an empty pair of parentheses, each element is &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">초기화자가 빈 괄호 쌍이면 각 요소는 &lt;a href=&quot;value_initialization&quot;&gt;값으로 초기화&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="19ed0a48a00d9537e7ba64e93a84031252754715" translate="yes" xml:space="preserve">
          <source>If it finds abbreviated name, followed by the characters that are valid for the full name, it continues reading until it consumes all the characters for the full name or finds a character that isn't expected, in which case parsing fails even if the first few characters were a valid abbreviation.</source>
          <target state="translated">축약 된 이름 다음에 전체 이름에 유효한 문자가 있으면 전체 이름에 대한 모든 문자를 사용하거나 예상하지 못한 문자를 찾을 때까지 계속 읽습니다.이 경우 첫 번째 경우에도 구문 분석이 실패합니다 몇 개의 문자가 유효한 약어였습니다.</target>
        </trans-unit>
        <trans-unit id="c6aab4ab699238bc505d419c37703aa0ef2626a9" translate="yes" xml:space="preserve">
          <source>If it is a non-const xvalue, the object to which it refers is in a valid but unspecified state;</source>
          <target state="translated">상수가 아닌 xvalue 인 경우 참조하는 오브젝트는 유효하지만 지정되지 않은 상태입니다.</target>
        </trans-unit>
        <trans-unit id="a83e8b41c48694346f5c6e5d8a58bf3d4cd145d7" translate="yes" xml:space="preserve">
          <source>If l&amp;ge;128, the behavior is implementation-defined</source>
          <target state="translated">l&amp;ge;128 인 경우 동작이 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="095b63a0e4834384f4f2cd6f96c502aa1765c012" translate="yes" xml:space="preserve">
          <source>If lineno is 0 or greater than 32767(until C++11)2147483647(since C++11), the behavior is undefined.</source>
          <target state="translated">lineno가 0보다 크거나 32767보다 크면 (C ++ 11까지) 2147483647 (C ++ 11부터), 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ce137b58879463fa5db786928dc6b5433066a3e" translate="yes" xml:space="preserve">
          <source>If lookup finds more than one deallocation function, the function to be called is selected as follows (see &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; for a more detailed description of these functions and their effects):</source>
          <target state="translated">조회에서 둘 이상의 할당 해제 기능을 찾으면 호출 할 기능이 다음과 같이 선택됩니다 ( 이 기능과 그 효과에 대한 자세한 설명 은 &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;할당 해제 기능&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="16f6bcbb6edddebfaed64c4a8ff01d6fc6f7b460" translate="yes" xml:space="preserve">
          <source>If members of a union are classes with user-defined constructors and destructors, to switch the active member, explicit destructor and placement new are generally needed:</source>
          <target state="translated">공용체 멤버가 사용자 정의 생성자와 소멸자가있는 클래스 인 경우 활성 멤버를 전환하려면 명시 적 소멸자와 새 배치가 일반적으로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9aaa368e593ef656dfef2f87849d89081dbdfcf4" translate="yes" xml:space="preserve">
          <source>If more than one match is possible, then any match is an acceptable result</source>
          <target state="translated">둘 이상의 일치가 가능한 경우 모든 일치가 허용되는 결과입니다</target>
        </trans-unit>
        <trans-unit id="02b8b892d773253c24c7deaa868506ebc598bb0d" translate="yes" xml:space="preserve">
          <source>If more than one preferred functions are found, only preferred functions are considered in the next step.</source>
          <target state="translated">둘 이상의 기본 기능이 발견되면 다음 단계에서 기본 기능 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="cbd23d50b99e7b96b25fd8ee6be5397b6972349c" translate="yes" xml:space="preserve">
          <source>If more than the implementation-defined maximum number of shared owners already locked the mutex in shared mode, &lt;code&gt;lock_shared&lt;/code&gt; blocks execution until the number of shared owners is reduced. The maximum number of owners is guaranteed to be at least 10000.</source>
          <target state="translated">구현 정의 된 최대 공유 소유자 수가 공유 모드에서 이미 뮤텍스를 잠근 경우 &lt;code&gt;lock_shared&lt;/code&gt; 는 공유 소유자 수가 줄어들 때까지 실행을 차단합니다. 최대 소유자 수는 10000 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f645135ade1dcc39a052821b217283911b76e60d" translate="yes" xml:space="preserve">
          <source>If multiple constructors are viable but none is better than the others, the implicit conversion sequence is the ambiguous conversion sequence.</source>
          <target state="translated">여러 생성자가 실행 가능하지만 다른 생성자보다 낫지 않은 경우 암시 적 변환 시퀀스는 모호한 변환 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="bbd656e7e48d690ef7ac59721f80eafd7184c36a" translate="yes" xml:space="preserve">
          <source>If multiple threads attempt to initialize the same static local variable concurrently, the initialization occurs exactly once (similar behavior can be obtained for arbitrary functions with &lt;code&gt;&lt;a href=&quot;../thread/call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">여러 스레드가 동일한 정적 로컬 변수를 동시에 초기화하려고 시도하면 초기화가 정확히 한 번만 발생합니다 ( &lt;code&gt;&lt;a href=&quot;../thread/call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; 하여 임의의 함수에 대해 비슷한 동작을 수행 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="71891f311caa8357864e30afc2d3a7d5ac7da117" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through an instance of &lt;code&gt;std::atomic&amp;lt;std::shared_ptr&amp;gt;&amp;gt;&lt;/code&gt; (or, deprecated as of C++20, through the &lt;a href=&quot;atomic&quot;&gt;standalone functions&lt;/a&gt; for atomic access to std::shared_ptr).</source>
          <target state="translated">여러 스레드의 실행이 동기화없이 동일한 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 오브젝트에 액세스하고 해당 액세스 중 하나가 비 const 멤버 함수 &lt;code&gt;shared_ptr&lt;/code&gt; 을 사용하는 경우 &lt;code&gt;std::atomic&amp;lt;std::shared_ptr&amp;gt;&amp;gt;&lt;/code&gt; 인스턴스를 통해 이러한 액세스가 모두 수행되지 않으면 데이터 경쟁이 발생합니다. std :: shared_ptr &amp;gt;&amp;gt; (또는 std :: shared_ptr에 대한 원자 적 액세스를위한 &lt;a href=&quot;atomic&quot;&gt;독립형 함수&lt;/a&gt; 를 통해 C ++ 20에서 더 이상 사용되지 않음 ).</target>
        </trans-unit>
        <trans-unit id="882b5e537cc3e18e7bf36e2a307bc0559f800747" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through these functions, which are overloads of the corresponding atomic access functions (&lt;code&gt;&lt;a href=&quot;../../atomic/atomic_load&quot;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_store&quot;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt;, etc.).</source>
          <target state="translated">여러 스레드의 실행이 동기화없이 동일한 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 객체에 액세스하고 해당 액세스 중 하나가 비 const 멤버 함수 &lt;code&gt;shared_ptr&lt;/code&gt; 을 사용하는 경우 이러한 모든 액세스가 이러한 함수를 통해 수행되지 않는 한 데이터 레이스가 발생합니다. 해당 원자 액세스 기능 ( &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_load&quot;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_store&quot;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="bd64a01ec402003b9db85651e928cb1f1bbc53d5" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;weak_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through an instance of &lt;code&gt;std::atomic&amp;lt;std::weak_ptr&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">여러 실행 스레드가 동기화없이 동일한 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 오브젝트에 액세스하고 해당 액세스가 &lt;code&gt;weak_ptr&lt;/code&gt; 의 비 const 멤버 함수 를 사용하는 경우 &lt;code&gt;std::atomic&amp;lt;std::weak_ptr&amp;gt;&amp;gt;&lt;/code&gt; 인스턴스를 통해 이러한 액세스가 모두 수행되지 않으면 데이터 경쟁이 발생합니다. std :: weak_ptr &amp;gt;&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="40f81f722965ce77fe317399aac97f912e696cd4" translate="yes" xml:space="preserve">
          <source>If n&amp;gt;=128, the behavior is implementation-defined</source>
          <target state="translated">n&amp;gt; = 128이면 동작이 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="42e3ee0efc70684fde11275bda977b0d1b55fd68" translate="yes" xml:space="preserve">
          <source>If necessary, obtains the status of &lt;code&gt;to&lt;/code&gt;, by no more than a single call to</source>
          <target state="translated">필요한 경우의 상태 획득 &lt;code&gt;to&lt;/code&gt; 한 번 호출보다는 더 이상에 의해을,</target>
        </trans-unit>
        <trans-unit id="b0434e8f18603c02eef4062d15cac7f0e1d6bd92" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;*this&lt;/code&gt; nor &lt;code&gt;other&lt;/code&gt; contain a value, the function has no effect.</source>
          <target state="translated">둘 경우 &lt;code&gt;*this&lt;/code&gt; 없으며 &lt;code&gt;other&lt;/code&gt; 값을 포함하지, 함수는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e8a7e77e5b17bbba28f9f5bde7a2ff9ba1ac92c" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; nor &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt;, nor any implementation-defined policy flag is set in &lt;code&gt;policy&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">어느 경우 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; 도 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; 않으며, 어떤 구현 정의 정책 플래그가 설정되어 &lt;code&gt;policy&lt;/code&gt; , 행동은 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="403cdbe454265b3fef8904df0622a89b983cd05c" translate="yes" xml:space="preserve">
          <source>If no captures are specified, the closure type has a defaulted copy assignment operator and a defaulted move assignment operator. Otherwise, it has a deleted copy assignment operator (this includes the case when there is a capture-default, even if it does not actually capture anything).</source>
          <target state="translated">캡처가 지정되지 않은 경우 클로저 유형에는 기본 복사 할당 연산자와 기본 이동 할당 연산자가 있습니다. 그렇지 않으면 삭제 된 복사 할당 연산자가 있습니다 (실제로 캡처하지 않더라도 캡처 기본값이있는 경우 포함).</target>
        </trans-unit>
        <trans-unit id="1b35fa3984aaeb3db9a1c2d09a20b6a3e68e64ef" translate="yes" xml:space="preserve">
          <source>If no captures are specified, the closure type has a defaulted default constructor. Otherwise, it has no default constructor (this includes the case when there is a capture-default, even if it does not actually capture anything).</source>
          <target state="translated">캡처가 지정되지 않은 경우 클로저 유형에는 기본 기본 생성자가 있습니다. 그렇지 않으면 기본 생성자가 없습니다 (실제로 아무것도 캡처하지 않더라도 캡처 기본값이있는 경우 포함).</target>
        </trans-unit>
        <trans-unit id="cd433247692a3d2cd8a72c9ba4974a4b61306058" translate="yes" xml:space="preserve">
          <source>If no characters are extracted then &lt;code&gt;std::ios::failbit&lt;/code&gt; is set on &lt;code&gt;is&lt;/code&gt;, which may throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">어떤 문자가 추출되지 않으면 다음 &lt;code&gt;std::ios::failbit&lt;/code&gt; 설정되어 &lt;code&gt;is&lt;/code&gt; 던질 수있는, &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69c02d0301239909ac59a990ef2ea5d140fa29fd" translate="yes" xml:space="preserve">
          <source>If no characters are extracted, &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; is called.</source>
          <target state="translated">추출 된 문자가 없으면 &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9ba27093f4416e619f89024b343671475c2b0970" translate="yes" xml:space="preserve">
          <source>If no characters were extracted, calls &lt;code&gt;setstate(failbit)&lt;/code&gt;.</source>
          <target state="translated">추출 된 문자가 없으면 &lt;code&gt;setstate(failbit)&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="536ea244a0d993a0064e14e4551396fff4cc9231" translate="yes" xml:space="preserve">
          <source>If no characters were extracted, calls &lt;code&gt;setstate(failbit)&lt;/code&gt;. In any case, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, a null character (&lt;code&gt;CharT()&lt;/code&gt; is stored in the next successive location of the array.</source>
          <target state="translated">추출 된 문자가 없으면 &lt;code&gt;setstate(failbit)&lt;/code&gt; 호출하십시오 . 어쨌든 &lt;code&gt;count&amp;gt;0&lt;/code&gt; 이면 배열의 다음 연속 위치에 널 문자 ( &lt;code&gt;CharT()&lt;/code&gt; 가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="878b0f05459600af7530cf7141a045ee2d7f3e8f" translate="yes" xml:space="preserve">
          <source>If no characters were inserted, executes &lt;code&gt;setstate(failbit)&lt;/code&gt;. If an exception was thrown while extracting, sets &lt;code&gt;failbit&lt;/code&gt; and, if &lt;code&gt;failbit&lt;/code&gt; is set in &lt;code&gt;exceptions()&lt;/code&gt;, rethrows the exception.</source>
          <target state="translated">문자가 삽입되지 않은 경우 &lt;code&gt;setstate(failbit)&lt;/code&gt; 실행하십시오 . 예외를 추출하는 동안 발생 된 경우, 세트 &lt;code&gt;failbit&lt;/code&gt; 경우와 &lt;code&gt;failbit&lt;/code&gt; 가 설정된다 &lt;code&gt;exceptions()&lt;/code&gt; , 예외 rethrows.</target>
        </trans-unit>
        <trans-unit id="edd868dcc474e443c25a49132bd6419f1abf7cca" translate="yes" xml:space="preserve">
          <source>If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="530f889d2ad8b60ee918f8e2702b7883b29fb175" translate="yes" xml:space="preserve">
          <source>If no errors occur earg</source>
          <target state="translated">오류가 발생하지 않으면 earg</target>
        </trans-unit>
        <trans-unit id="a4b69264dcfdc184105c0c5fcdc54a8a79767399" translate="yes" xml:space="preserve">
          <source>If no errors occur ln(1+arg) is returned.</source>
          <target state="translated">오류가 발생하지 않으면 ln (1 + arg)이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f3037fe820d838daa891fb3539a8329f215061a7" translate="yes" xml:space="preserve">
          <source>If no errors occur,</source>
          <target state="translated">오류가 발생하지 않으면</target>
        </trans-unit>
        <trans-unit id="47e97b549aae51b3c35168920f72ade75b7949f9" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;base&lt;/code&gt; raised to the power of &lt;code&gt;exp&lt;/code&gt; (or &lt;code&gt;iexp&lt;/code&gt;) (baseexp</source>
          <target state="translated">오류가 발생하지 않으면 &lt;code&gt;base&lt;/code&gt; 이 &lt;code&gt;exp&lt;/code&gt; (또는 &lt;code&gt;iexp&lt;/code&gt; )의 거듭 제곱 (baseexp</target>
        </trans-unit>
        <trans-unit id="ef48764b6bc2b922ac28634b1b57e0a32884367d" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;x&lt;/code&gt; multiplied by 2 to the power of &lt;code&gt;exp&lt;/code&gt; (x&amp;times;2exp</source>
          <target state="translated">오류가 발생하지 않으면, &lt;code&gt;x&lt;/code&gt; 에 2의 &lt;code&gt;exp&lt;/code&gt; 를 곱한 값 (x &amp;times; 2exp)</target>
        </trans-unit>
        <trans-unit id="be1997f1a364feb4c59b1137ec5be5c5163c893c" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;x&lt;/code&gt; multiplied by &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; to the power of &lt;code&gt;arg&lt;/code&gt; (x&amp;times;FLT_RADIXexp</source>
          <target state="translated">오류가 발생하지 않으면, &lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;arg&lt;/code&gt; 의 거듭 제곱 (x &amp;times; FLT_RADIXexp)으로 곱한 값</target>
        </trans-unit>
        <trans-unit id="43e9fba55e5f456a3880c2a5f09b14d52ee81371" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range [0 ; &amp;infin;) along the real axis and in the range [&amp;minus;</source>
          <target state="translated">에러가 발생하지 않으면, &lt;code&gt;z&lt;/code&gt; 의 복소 아크 코사인이 [0; &amp;infin;) 실제 축을 따라 [-</target>
        </trans-unit>
        <trans-unit id="3ba083c7eab3d055b75951c25f225f73acff4188" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="translated">오류가 발생하지 않으면, 복잡한 아크 사인 &lt;code&gt;z&lt;/code&gt; 허수 축과 -&amp;pi; / 2 구간 [바운드 스트립의 범위에 반환되고 실제 축을 따라 + &amp;pi; / 2].</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
