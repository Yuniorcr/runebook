<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="8391c2c17f2f4f13c610d9f810ea10436298326c" translate="yes" xml:space="preserve">
          <source>2) Replaces the contents with a copy of &lt;code&gt;str&lt;/code&gt;. Equivalent to &lt;code&gt;*this = str;&lt;/code&gt;. In particular, allocator propagation may take place.(since C++11)</source>
          <target state="translated">2) 내용을 &lt;code&gt;str&lt;/code&gt; 사본으로 바꿉니다 . 당량 &lt;code&gt;*this = str;&lt;/code&gt; . 특히 할당 자 전파가 발생할 수 있습니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="55f5b0316d675d818ea9ce9e4ccf85ef81a1eb0e" translate="yes" xml:space="preserve">
          <source>2) Replaces the contents with copies of those in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">2) 내용을 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 사본으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="d972332734e8b5d2c5018aca70fe2138a08cfe8f" translate="yes" xml:space="preserve">
          <source>2) Replaces the contents with those of &lt;code&gt;str&lt;/code&gt; using move semantics. &lt;code&gt;str&lt;/code&gt; is in a valid but unspecified state afterwards. If &lt;code&gt;std::allocator_traits&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the target allocator is replaced by a copy of the source allocator. If it is &lt;code&gt;false&lt;/code&gt; and the source and the target allocators do not compare equal, the target cannot take ownership of the source memory and must assign each character individually, allocating additional memory using its own allocator as needed. Unlike other container move assignments, references, pointers, and iterators to &lt;code&gt;str&lt;/code&gt; may be invalidated.</source>
          <target state="translated">2) 이동 의미를 사용하여 내용을 &lt;code&gt;str&lt;/code&gt; 의 내용으로 바꿉니다 . &lt;code&gt;str&lt;/code&gt; 은 유효하지만 지정되지 않은 상태입니다. 경우 &lt;code&gt;std::allocator_traits&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment()&lt;/code&gt; 이고 &lt;code&gt;true&lt;/code&gt; 목표 할당은 소스 할당의 복사본에 의해 대체된다. 이 경우 &lt;code&gt;false&lt;/code&gt; 소스와 대상 할당 자 동일 비교하지 않는 대상은 소스 메모리의 소유권을 할 수없고 필요에 따라 자신의 할당을 사용하여 추가 메모리를 할당, 개별적으로 각 문자를 할당해야합니다. 다른 컨테이너 이동 지정과 달리 &lt;code&gt;str&lt;/code&gt; 에 대한 참조, 포인터 및 반복기 는 무효화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8aa53b7f74bebffc4fbda5847fc2a84f6c97988" translate="yes" xml:space="preserve">
          <source>2) Replaces the file position state with the value of &lt;code&gt;st&lt;/code&gt;.</source>
          <target state="translated">2) 파일 위치 상태를 &lt;code&gt;st&lt;/code&gt; 값으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="00c2b558ca04a505b3df69c0f209e5d8c8b87e51" translate="yes" xml:space="preserve">
          <source>2) Resolves ambiguity according to the value of &lt;code&gt;z&lt;/code&gt;:</source>
          <target state="translated">2) &lt;code&gt;z&lt;/code&gt; 값에 따라 모호성을 해결합니다 .</target>
        </trans-unit>
        <trans-unit id="68e2fa5afec319a37b25ba54d39a3436371cf00c" translate="yes" xml:space="preserve">
          <source>2) Restores the distribution parameters and internal state with data read from &lt;code&gt;ist&lt;/code&gt;. The formatting flags of &lt;code&gt;ist&lt;/code&gt; are unchanged. The data must have been written using a stream with the same locale, &lt;code&gt;CharT&lt;/code&gt; and &lt;code&gt;Traits&lt;/code&gt; template parameters, otherwise the behavior is undefined. If bad input is encountered, &lt;code&gt;ist.setstate(std::ios::failbit)&lt;/code&gt; is called, which may throw &lt;code&gt;&lt;a href=&quot;../../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;d&lt;/code&gt; is unchanged in that case.</source>
          <target state="translated">2) &lt;code&gt;ist&lt;/code&gt; 에서 읽은 데이터로 분배 매개 변수 및 내부 상태를 복원합니다 . &lt;code&gt;ist&lt;/code&gt; 의 형식 플래그 는 변경되지 않습니다. 데이터는 동일한 로케일, &lt;code&gt;CharT&lt;/code&gt; 및 &lt;code&gt;Traits&lt;/code&gt; 템플리트 매개 변수 를 가진 스트림을 사용하여 작성되어야합니다 . 그렇지 않으면 동작이 정의되지 않습니다. 입력이 잘못되면 &lt;code&gt;ist.setstate(std::ios::failbit)&lt;/code&gt; 가 호출되어 &lt;code&gt;&lt;a href=&quot;../../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 있습니다. 이 경우 &lt;code&gt;d&lt;/code&gt; 는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12ce85ecd6eacf5e22a64dc9082d8c8da89ac681" translate="yes" xml:space="preserve">
          <source>2) Restores the internal state of the pseudo-random number engine &lt;code&gt;e&lt;/code&gt; from the serialized representation, which was created by an earlier call to &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; using a stream with the same imbued locale and the same &lt;code&gt;CharT&lt;/code&gt; and &lt;code&gt;Traits&lt;/code&gt;. If the input cannot be deserialized, &lt;code&gt;e&lt;/code&gt; is left unchanged and &lt;code&gt;failbit&lt;/code&gt; is raised on &lt;code&gt;ist&lt;/code&gt;</source>
          <target state="translated">2) 의사 난수 엔진 &lt;code&gt;e&lt;/code&gt; 의 내부 상태를 직렬화 된 표현에서 복원합니다 . 직렬화 된 표현 은 동일한 마킹 된 로케일과 동일한 &lt;code&gt;CharT&lt;/code&gt; 및 &lt;code&gt;Traits&lt;/code&gt; 를 가진 스트림을 사용하여 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 에 대한 이전 호출에 의해 생성되었습니다 . 입력을 직렬화 해제 할 수없는 경우 &lt;code&gt;e&lt;/code&gt; 는 변경되지 않고 &lt;code&gt;ist&lt;/code&gt; 에서 &lt;code&gt;failbit&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b643562f5497c25a66a27bfb34dea13cd6b925a7" translate="yes" xml:space="preserve">
          <source>2) Restores the internal state of the pseudo-random number engine adaptor &lt;code&gt;e&lt;/code&gt; from the serialized representation, which was created by an earlier call to &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; using a stream with the same imbued locale and the same &lt;code&gt;CharT&lt;/code&gt; and &lt;code&gt;Traits&lt;/code&gt;. If the input cannot be deserialized, &lt;code&gt;e&lt;/code&gt; is left unchanged and &lt;code&gt;failbit&lt;/code&gt; is raised on &lt;code&gt;ist&lt;/code&gt;</source>
          <target state="translated">2) 의사 난수 엔진 어댑터 &lt;code&gt;e&lt;/code&gt; 의 내부 상태를 직렬화 된 표현에서 복원합니다 . 직렬화 된 표현 은 동일한 마킹 된 로케일과 동일한 &lt;code&gt;CharT&lt;/code&gt; 및 &lt;code&gt;Traits&lt;/code&gt; 를 가진 스트림을 사용하여 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 에 대한 이전 호출에 의해 작성되었습니다 . 입력을 직렬화 해제 할 수없는 경우 &lt;code&gt;e&lt;/code&gt; 는 변경되지 않고 &lt;code&gt;ist&lt;/code&gt; 에서 &lt;code&gt;failbit&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a8a9c718bf3f1c50f601c7a42168cf9675fd5b33" translate="yes" xml:space="preserve">
          <source>2) Results in &lt;code&gt;container-&amp;gt;push_back(std::move(value))&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;container-&amp;gt;push_back(std::move(value))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4f49d2a78a32ec92ef629659a6ef39651123985" translate="yes" xml:space="preserve">
          <source>2) Results in &lt;code&gt;container-&amp;gt;push_front(std::move(value))&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;container-&amp;gt;push_front(std::move(value))&lt;/code&gt; 결과- &amp;gt; push_front (std :: move (value))</target>
        </trans-unit>
        <trans-unit id="88d460ebcb4a7e227650a141fb844f9ae792cd96" translate="yes" xml:space="preserve">
          <source>2) Results in &lt;code&gt;iter = container-&amp;gt;insert(iter, std::move(value)); ++iter;&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;iter = container-&amp;gt;insert(iter, std::move(value)); ++iter;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="516b0aee43907957ab96c5142d8c0766a5dbe91a" translate="yes" xml:space="preserve">
          <source>2) Rethrows the currently handled exception. Abandons the execution of the current catch block and passes control to the next matching exception handler (but not to another catch clause after the same try block: its compound-statement is considered to have been 'exited'), reusing the existing exception object: no new objects are made. This form is only allowed when an exception is presently being handled (it calls &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; if used otherwise). The catch clause associated with a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; must exit via rethrowing if used on a constructor.</source>
          <target state="translated">2) 현재 처리 된 예외를 다시 발생시킵니다. 현재 catch 블록의 실행을 포기하고 일치하는 다음 예외 처리기로 제어를 전달합니다 (그러나 동일한 try 블록 다음의 다른 catch 절은 아닙니다. 복합 명령문은 '종료'된 것으로 간주 됨). 기존 예외 객체를 재사용합니다. 새로운 물건이 만들어지지 않습니다. 이 형식은 예외가 현재 처리되고있을 때만 허용됩니다 ( 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 호출 함 ). &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; 과 연관된 catch 절 은 생성자에서 사용될 경우 다시 던지기를 통해 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="26438c9c057589edffd553b839a29cc2990f931f" translate="yes" xml:space="preserve">
          <source>2) Returns &lt;code&gt;!(*this == rhs)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;!(*this == rhs)&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="92ca7ae99ad5913e1af0f0bbf6f9c1d65dc3dae9" translate="yes" xml:space="preserve">
          <source>2) Returns &lt;code&gt;!(lhs == rhs)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;!(lhs == rhs)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="30afc5c8f541051bb4c57d5c54e5be145efd2b96" translate="yes" xml:space="preserve">
          <source>2) Returns &lt;code&gt;*this&lt;/code&gt; made relative to &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;*this&lt;/code&gt; &lt;code&gt;base&lt;/code&gt; 에 비례하여 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="e3acac0b6d2e53b82e830799ae6da07212d04f42" translate="yes" xml:space="preserve">
          <source>2) Returns &lt;code&gt;&lt;a href=&quot;reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&amp;lt;T*&amp;gt;&lt;/code&gt; to the reverse-beginning of the array &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&amp;lt;T*&amp;gt;&lt;/code&gt; 를 배열 &lt;code&gt;array&lt;/code&gt; 의 역 시작으로 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="64e1b994f736103a0d5e098cbbbeaa4e06129696" translate="yes" xml:space="preserve">
          <source>2) Returns &lt;code&gt;&lt;a href=&quot;reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&amp;lt;T*&amp;gt;&lt;/code&gt; to the reverse-end of the array &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&amp;lt;T*&amp;gt;&lt;/code&gt; 를 배열 &lt;code&gt;array&lt;/code&gt; 의 반대쪽 끝으로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8a4b5c8e19fea5024a1dcc49ddfbbf4cf4cab932" translate="yes" xml:space="preserve">
          <source>2) Returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;false&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="2d25ac2f6942aefebe5cc0c771c9533e84a2d592" translate="yes" xml:space="preserve">
          <source>2) Returns &lt;code&gt;p&lt;/code&gt; made relative to &lt;code&gt;base&lt;/code&gt;. Resolves symlinks and normalizes both &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;base&lt;/code&gt; before other processing. Effectively returns &lt;code&gt;weakly_canonical(p).lexically_relative(weakly_canonical(base))&lt;/code&gt; or &lt;code&gt;weakly_canonical(p, ec).lexically_relative(weakly_canonical(base, ec))&lt;/code&gt;, except the error code form returns &lt;code&gt;path()&lt;/code&gt; at the first error occurrence, if any.</source>
          <target state="translated">2) &lt;code&gt;base&lt;/code&gt; 에 대해 만들어진 &lt;code&gt;p&lt;/code&gt; 를 반환 합니다 . 다른 처리 전에 심볼릭 링크를 해결하고 &lt;code&gt;p&lt;/code&gt; 와 &lt;code&gt;base&lt;/code&gt; 를 모두 정규화합니다 . 오류 코드 형식 이 첫 번째 오류 발생시 &lt;code&gt;path()&lt;/code&gt; 를 반환하는 경우를 제외하고 는 &lt;code&gt;weakly_canonical(p).lexically_relative(weakly_canonical(base))&lt;/code&gt; 또는 &lt;code&gt;weakly_canonical(p, ec).lexically_relative(weakly_canonical(base, ec))&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="83221ec8f90b5a4723cfa7e220ac05808e72fdf1" translate="yes" xml:space="preserve">
          <source>2) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are not equal, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">2) 반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;lhs&lt;/code&gt; 과 &lt;code&gt;rhs&lt;/code&gt; 동일하지 않은 &lt;code&gt;false&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cd0abb5956f8b68030ed2093a06101c77846543" translate="yes" xml:space="preserve">
          <source>2) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">2) 반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;lhs&lt;/code&gt; 있다</target>
        </trans-unit>
        <trans-unit id="c5a778d30fccc8ec1566cb66ced23b2892bdb820" translate="yes" xml:space="preserve">
          <source>2) Returns &lt;code&gt;true&lt;/code&gt; if both &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;out&quot;&gt;do_out()&lt;/a&gt;&lt;/code&gt; return &lt;code&gt;std::codecvt_base::noconv&lt;/code&gt; for all valid inputs.</source>
          <target state="translated">2) 반환 &lt;code&gt;true&lt;/code&gt; 경우 모두 &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;out&quot;&gt;do_out()&lt;/a&gt;&lt;/code&gt; 반환 &lt;code&gt;std::codecvt_base::noconv&lt;/code&gt; 모든 유효한 입력합니다.</target>
        </trans-unit>
        <trans-unit id="e77c30e0fa90c18c95cdcfc1da799d5f6016daba" translate="yes" xml:space="preserve">
          <source>2) Returns &lt;code&gt;true&lt;/code&gt; if lhs is greater than rhs, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">2) lhs가 rhs보다 크면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48be6dacbaf7388f10e8de845fe77d895de78af4" translate="yes" xml:space="preserve">
          <source>2) Returns &lt;code&gt;true&lt;/code&gt; if the stream has no errors and is ready for I/O operations. Specifically, returns &lt;code&gt;!fail()&lt;/code&gt;.</source>
          <target state="translated">2) 스트림에 오류가없고 I / O 조작 준비가되어 있으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 특히 &lt;code&gt;!fail()&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="762d160a639ed47eeb92d2c2c6a7aafa24873bb3" translate="yes" xml:space="preserve">
          <source>2) Returns &lt;code&gt;​0​&lt;/code&gt; on success, &lt;code&gt;-1&lt;/code&gt; otherwise. The base class version returns &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">2) 반환 &lt;code&gt;​0​&lt;/code&gt; , 성공을 &lt;code&gt;-1&lt;/code&gt; , 그렇지. 기본 클래스 버전을 반환 &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66573d89c9a3008cd075232e504c463488cb532d" translate="yes" xml:space="preserve">
          <source>2) Returns a &lt;code&gt;bitset&amp;lt;N&amp;gt;&lt;/code&gt; containing the result of binary OR on corresponding pairs of bits of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">2) 대응하는 &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 비트 쌍에 대한 이진 OR의 결과를 포함하는 비트 세트 &lt;code&gt;bitset&amp;lt;N&amp;gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3ba6959d321f862e02b03b004377d2fb52fb3818" translate="yes" xml:space="preserve">
          <source>2) Returns a &lt;code&gt;year&lt;/code&gt; whose year value is the negation of that of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">2) 연도 값이 &lt;code&gt;*this&lt;/code&gt; 의 연도 값을 무효화 한 &lt;code&gt;year&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="67b3079f22afff50aa564be73562ad64837f5523" translate="yes" xml:space="preserve">
          <source>2) Returns a default-constructed &lt;a href=&quot;../directory_iterator&quot;&gt;&lt;code&gt;directory_iterator&lt;/code&gt;&lt;/a&gt;, which serves as the end iterator. The argument is ignored.</source>
          <target state="translated">2) 기본 생성 된 &lt;a href=&quot;../directory_iterator&quot;&gt; &lt;code&gt;directory_iterator&lt;/code&gt; 를&lt;/a&gt; 리턴하며 종료 반복자 역할을합니다. 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e34c79461484febbceafa098cb208a0bb2cd9f56" translate="yes" xml:space="preserve">
          <source>2) Returns a default-constructed &lt;a href=&quot;../recursive_directory_iterator&quot;&gt;&lt;code&gt;recursive_directory_iterator&lt;/code&gt;&lt;/a&gt;, which serves as the end iterator. The argument is ignored.</source>
          <target state="translated">2) 기본 &lt;a href=&quot;../recursive_directory_iterator&quot;&gt; &lt;code&gt;recursive_directory_iterator&lt;/code&gt; &lt;/a&gt; 리턴하며 종료 반복자 역할을합니다. 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="47aed59f34ac1bd3202e0e3fc97867fbe31dbf46" translate="yes" xml:space="preserve">
          <source>2) Returns a numeric array of &lt;code&gt;bool&lt;/code&gt; containing elements each of which is obtained by applying the indicated comparison operator to &lt;code&gt;lhsv&lt;/code&gt; and the corresponding value of &lt;code&gt;rhs&lt;/code&gt; .</source>
          <target state="translated">2) 표시된 비교 연산자를 &lt;code&gt;lhsv&lt;/code&gt; 및 해당 &lt;code&gt;rhs&lt;/code&gt; 값 에 적용하여 얻은 각 요소를 포함하는 &lt;code&gt;bool&lt;/code&gt; 의 숫자 배열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="cc704d1c42183b0c73e7522741b146fa164f7f50" translate="yes" xml:space="preserve">
          <source>2) Returns a pointer to the beginning of the &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;array&lt;/code&gt; 의 시작에 대한 포인터를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="350ac100a15d145bd87da82000afa024dd9fbd66" translate="yes" xml:space="preserve">
          <source>2) Returns a pointer to the current &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">2) 현재 &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; 대한 포인터를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="506a20237313f2c82ad97328770e6018e02606f8" translate="yes" xml:space="preserve">
          <source>2) Returns a pointer to the end of the array &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">2) 배열 &lt;code&gt;array&lt;/code&gt; 의 끝을 가리키는 포인터를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8dae6713ed6251680c0d1f1ccf90281e5966181b" translate="yes" xml:space="preserve">
          <source>2) Returns a pointer to the object owned by &lt;code&gt;*this&lt;/code&gt;, i.e. &lt;code&gt;get()&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;*this&lt;/code&gt; 소유의 객체에 대한 포인터 , 즉 &lt;code&gt;get()&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4f4fe41136a0d797668375e878d70d661fd05508" translate="yes" xml:space="preserve">
          <source>2) Returns a reference to the contained value.</source>
          <target state="translated">2) 포함 된 값에 대한 참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="798b546c2dd4437c5b2cef49d04028fbf7e65964" translate="yes" xml:space="preserve">
          <source>2) Returns a reference to the first &lt;code&gt;std::chrono::tzdb&lt;/code&gt; object held by the &lt;code&gt;tzdb_list&lt;/code&gt; singleton. Equivalent to &lt;code&gt;std::chrono::get_tzdb_list().front()&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;tzdb_list&lt;/code&gt; 싱글 톤이 보유한 첫 번째 &lt;code&gt;std::chrono::tzdb&lt;/code&gt; 객체에 대한 참조를 반환합니다 . 상응하는 &lt;code&gt;std::chrono::get_tzdb_list().front()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="588aa1d3a713e3c976e8b811a2ec64cec501ee66" translate="yes" xml:space="preserve">
          <source>2) Returns a value of type &lt;code&gt;&lt;a href=&quot;../time_base&quot;&gt;std::time_base::dateorder&lt;/a&gt;&lt;/code&gt;, which describes the default date format used by this locale (expected by &lt;code&gt;&lt;a href=&quot;get_date&quot;&gt;get_date()&lt;/a&gt;&lt;/code&gt; and produced by &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime()&lt;/a&gt;&lt;/code&gt; with format specifier &lt;code&gt;'%x'&lt;/code&gt;).</source>
          <target state="translated">2) 유형의 값을 반환 &lt;code&gt;&lt;a href=&quot;../time_base&quot;&gt;std::time_base::dateorder&lt;/a&gt;&lt;/code&gt; , 로케일에서 사용하는 기본 날짜 형식을 설명하는 (예상 &lt;code&gt;&lt;a href=&quot;get_date&quot;&gt;get_date()&lt;/a&gt;&lt;/code&gt; 에 의해 생산 및 &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime()&lt;/a&gt;&lt;/code&gt; 형식 지정자 &lt;code&gt;'%x'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ea94db201f751ed9cb97ddd5bc62214b4ec98591" translate="yes" xml:space="preserve">
          <source>2) Returns an &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; holding, in each &lt;code&gt;char&lt;/code&gt; element, the number of digits in each group of the numeric output formatted by &lt;a href=&quot;../num_put/put&quot;&gt;&lt;code&gt;num_put::put()&lt;/code&gt;&lt;/a&gt; (and, therefore, &lt;a href=&quot;../../io/basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">2) 각 &lt;code&gt;char&lt;/code&gt; 요소에 &lt;a href=&quot;../num_put/put&quot;&gt; &lt;code&gt;num_put::put()&lt;/code&gt; &lt;/a&gt; 의해 형식화 된 숫자 출력의 각 그룹에있는 자릿수를 보유 하는 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 을 리턴합니다 (따라서 &lt;a href=&quot;../../io/basic_ostream/operator_ltlt&quot;&gt; &lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="77e59afe50d770c0295182779e46a141c9d1cf63" translate="yes" xml:space="preserve">
          <source>2) Returns an iterator one past the last element of the path. Dereferencing this iterator is undefined behavior.</source>
          <target state="translated">2) 경로의 마지막 요소를지나 반복자를 반환합니다. 이 반복자를 역 참조하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="eb4f3ba0ac2bd3ce2cbe950ba8232429bb8eb092" translate="yes" xml:space="preserve">
          <source>2) Returns an iterator pointing to the first element that compares</source>
          <target state="translated">2) 비교하는 첫 번째 요소를 가리키는 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72ed9d6d08781485225f3096900ed434af13eb8d" translate="yes" xml:space="preserve">
          <source>2) Returns an iterator to the character following the last character of the view. Equivalent to &lt;code&gt;sv.end()&lt;/code&gt;.</source>
          <target state="translated">2) 뷰의 마지막 문자 다음에 오는 문자로 반복자를 리턴합니다. &lt;code&gt;sv.end()&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d7cac8eb55cdb675a9398f7f2b4bdfa43a3c7ff9" translate="yes" xml:space="preserve">
          <source>2) Returns an iterator to the element following the last element of the span. Equivalent to &lt;code&gt;s.end()&lt;/code&gt;.</source>
          <target state="translated">2) 범위의 마지막 요소 다음에 나오는 요소에 반복자를 반환합니다. &lt;code&gt;s.end()&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9bd6d6589506956e23a5e2a9a1ff6a171e4f6a54" translate="yes" xml:space="preserve">
          <source>2) Returns status of the entry, as if determined by a &lt;a href=&quot;../status&quot;&gt;symlink_status&lt;/a&gt; call (symlinks are not followed)</source>
          <target state="translated">2) &lt;a href=&quot;../status&quot;&gt;symlink_status&lt;/a&gt; 호출에 의해 결정된 것처럼 항목의 상태를 리턴합니다 (symlinks는 따르지 않습니다)</target>
        </trans-unit>
        <trans-unit id="e54c83ae65a74a9b190132d6cd903e49997eb107" translate="yes" xml:space="preserve">
          <source>2) Returns the</source>
          <target state="translated">2) 반환</target>
        </trans-unit>
        <trans-unit id="b8d3c6dce0679b1b8a24fe8e08411367b4c8f7a0" translate="yes" xml:space="preserve">
          <source>2) Returns the &amp;beta; distribution parameter. It is also known as the scale parameter. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">2) &amp;beta; 분포 모수를 구합니다. 스케일 파라미터라고도합니다. 기본값은 &lt;code&gt;1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e39147e488e17ede3f2e916406eef021f8304a9" translate="yes" xml:space="preserve">
          <source>2) Returns the b distribution parameter (scale). The default value is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">2) b 분포 모수 (척도)를 반환합니다. 기본값은 &lt;code&gt;0.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2a1c40654e49142d3480db2bab15da801206336f" translate="yes" xml:space="preserve">
          <source>2) Returns the b parameter. It defines the scale of the distribution. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">2) b 매개 변수를 리턴합니다. 분포의 규모를 정의합니다. 기본값은 &lt;code&gt;1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4384308f7cc6a52ea5418f2de8024a3c3a3c2c6b" translate="yes" xml:space="preserve">
          <source>2) Returns the character to be used as the decimal separator between integer and fractional parts.</source>
          <target state="translated">2) 정수와 소수 부분 사이의 소수점 구분 기호로 사용될 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8961e82863ed0805c731bebeee2322f77d00efe2" translate="yes" xml:space="preserve">
          <source>2) Returns the character to be used as the separator between digit groups when parsing or formatting integers and integral parts of floating-point values.</source>
          <target state="translated">2) 정수 및 부동 소수점 값의 정수 부분을 구문 분석하거나 형식화 할 때 숫자 그룹 사이의 분리 자로 사용될 문자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3e73b8cb6dc92025602bb774def09663c95d6b93" translate="yes" xml:space="preserve">
          <source>2) Returns the character to be used as the separator between digit groups when parsing or formatting the integral parts of monetary values.</source>
          <target state="translated">2) 통화 값의 필수 부분을 구문 분석하거나 형식화 할 때 숫자 그룹 사이의 분리 자로 사용될 문자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4736b20e57c9d91e8b07f86c4a28b0f5b7549949" translate="yes" xml:space="preserve">
          <source>2) Returns the character to use as the decimal point separator in monetary I/O if the format uses fractions (that is, if &lt;code&gt;&lt;a href=&quot;frac_digits&quot;&gt;do_frac_digits()&lt;/a&gt;&lt;/code&gt; is greater than zero). For typical U.S. locales, it is the character &lt;code&gt;'.'&lt;/code&gt; (or &lt;code&gt;L'.'&lt;/code&gt;)</source>
          <target state="translated">2) 형식이 분수를 사용하는 경우 (즉, &lt;code&gt;&lt;a href=&quot;frac_digits&quot;&gt;do_frac_digits()&lt;/a&gt;&lt;/code&gt; 가 0보다 큰 경우 ) 통화 I / O에서 소수점 구분 기호로 사용할 문자를 리턴합니다 . 일반적인 미국 로케일의 경우 문자 &lt;code&gt;'.'&lt;/code&gt; 입니다.(또는 &lt;code&gt;L'.'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b554cfad13c768d6c6936e57bea479631302cc17" translate="yes" xml:space="preserve">
          <source>2) Returns the deviation &amp;sigma; distribution parameter. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">2) 편차 &amp;sigma; 분포 모수를 구합니다. 기본값은 &lt;code&gt;1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a16f7e36cd153c7134e59830023018cf12b3111a" translate="yes" xml:space="preserve">
          <source>2) Returns the k distribution parameter. It defines the number of desired outcomes. The default value is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">2) k 분포 모수를 구합니다. 원하는 결과 수를 정의합니다. 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b21a8bb9b9b3a04278f3900bbbd3b199805e705d" translate="yes" xml:space="preserve">
          <source>2) Returns the list of probability densities at the boundaries of the intervals.</source>
          <target state="translated">2) 구간 경계에서 확률 밀도 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="26a8967f9cce057e3e53621ae15b1f2057d7a692" translate="yes" xml:space="preserve">
          <source>2) Returns the list of probability densities of the intervals.</source>
          <target state="translated">2) 구간의 확률 밀도 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="754e3d9a4f9435aca8034f9cad895b0773aa5893" translate="yes" xml:space="preserve">
          <source>2) Returns the log-deviation s distribution parameter. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">2) 로그 편차 분포 모수를 반환합니다. 기본값은 &lt;code&gt;1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="569144734182803819c2b1f446596d1d1bc31778" translate="yes" xml:space="preserve">
          <source>2) Returns the maximum value that &lt;code&gt;do_length(state, from, from_end, 1)&lt;/code&gt; can return for any valid range &lt;code&gt;[from, from_end)&lt;/code&gt; and any valid &lt;code&gt;state&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;do_length(state, from, from_end, 1)&lt;/code&gt; 가 유효한 범위 &lt;code&gt;[from, from_end)&lt;/code&gt; 및 유효한 &lt;code&gt;state&lt;/code&gt; 에 대해 반환 할 수 있는 최대 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2f8e55cc906769114f45735cef4925644dc0a387" translate="yes" xml:space="preserve">
          <source>2) Returns the n (the second degree of freedom) distribution parameter. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">2) n (두 번째 자유도) 분포 모수를 구합니다. 기본값은 &lt;code&gt;1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="630d3485cc733125051ccc35d473642df2403363" translate="yes" xml:space="preserve">
          <source>2) Returns the native-format representation of the pathname by reference.</source>
          <target state="translated">2) 참조로 경로명의 기본 형식 표현을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a7208a0a65b27afbe2949c62cf9109c3f234ff6e" translate="yes" xml:space="preserve">
          <source>2) Returns the number of digits to be displayed after the decimal point when printing monetary values</source>
          <target state="translated">2) 통화 값을 인쇄 할 때 소수점 뒤에 표시되는 자릿수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8939e2e3255d359791ad89a0ba7144c75377fcbc" translate="yes" xml:space="preserve">
          <source>2) Returns the number of elements with key that compares equivalent to the specified argument &lt;code&gt;x&lt;/code&gt;. This overload only participates in overload resolution if the qualified-id &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; is valid and denotes a type. This assumes that such Hash is callable with both K and Key type, and that its key_equal is transparent, which, together, allows calling this function without constructing an instance of &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">2) 지정된 인수 &lt;code&gt;x&lt;/code&gt; 와 동등한 키를 가진 요소 수를 반환합니다 . 규정 된 ID &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; 이 유효하고 유형을 나타내는 경우이 과부하는 과부하 해결에만 참여 합니다. 이것은 그러한 해시가 K와 Key 타입으로 호출 가능하고 key_equal이 투명하고 &lt;code&gt;Key&lt;/code&gt; 인스턴스를 구성하지 않고이 함수를 호출 할 수 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="9886b36293703ed26c455b85b7846e216f3a6fe0" translate="yes" xml:space="preserve">
          <source>2) Returns the number of elements with key that compares equivalent to the value &lt;code&gt;x&lt;/code&gt;. This overload only participates in overload resolution if the qualified-id &lt;code&gt;Compare::is_transparent&lt;/code&gt; is valid and denotes a type. They allow calling this function without constructing an instance of &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">2) 값 &lt;code&gt;x&lt;/code&gt; 와 동등한 키를 가진 요소 수를 반환합니다 . Qualified-id &lt;code&gt;Compare::is_transparent&lt;/code&gt; 가 유효하고 유형을 나타내는 경우이 과부하는 과부하 해결에만 참여 합니다. &lt;code&gt;Key&lt;/code&gt; 인스턴스를 생성하지 않고도이 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3226377a15a6ccddbefc7c046fcde51186e3a0fb" translate="yes" xml:space="preserve">
          <source>2) Returns the number of files and directories that were deleted (which may be zero if &lt;code&gt;p&lt;/code&gt; did not exist to begin with). The overload that takes &lt;code&gt;error_code&amp;amp;&lt;/code&gt; argument returns &lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintmax_t&lt;/a&gt;&amp;gt;(-1)&lt;/code&gt; on error.</source>
          <target state="translated">2) 삭제 된 파일 및 디렉토리 수를 리턴합니다 ( &lt;code&gt;p&lt;/code&gt; 가 존재하지 않으면 0이 될 수 있음 ). &lt;code&gt;error_code&amp;amp;&lt;/code&gt; 인수 를 사용하는 과부하는 오류시 &lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintmax_t&lt;/a&gt;&amp;gt;(-1)&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2ada8a9006c100c5271456adbb709585239f2993" translate="yes" xml:space="preserve">
          <source>2) Returns the pattern that determines the grouping of the digits in the monetary output, with the same exact meaning as &lt;code&gt;&lt;a href=&quot;../numpunct/grouping&quot;&gt;std::numpunct::do_grouping&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">2) 통화 출력에서 ​​숫자의 그룹화를 결정하는 패턴을 &lt;code&gt;&lt;a href=&quot;../numpunct/grouping&quot;&gt;std::numpunct::do_grouping&lt;/a&gt;&lt;/code&gt; 과 동일한 의미로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="32130ac3baff2871f6e8f13f30c7ab4d36aeca4a" translate="yes" xml:space="preserve">
          <source>2) Returns the pointer to the current character (</source>
          <target state="translated">2) 현재 문자에 ​​대한 포인터를 반환합니다 (</target>
        </trans-unit>
        <trans-unit id="f5360db51f28dbcd38bdf26ba565406cd6213bcb" translate="yes" xml:space="preserve">
          <source>2) Returns the stored &lt;code&gt;std::chrono::day&lt;/code&gt; value.</source>
          <target state="translated">2) 저장된 &lt;code&gt;std::chrono::day&lt;/code&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cad58dfef066540adfa02f66b3a706acd79aa932" translate="yes" xml:space="preserve">
          <source>2) Returns the stored &lt;code&gt;std::chrono::month&lt;/code&gt; value.</source>
          <target state="translated">2) 저장된 &lt;code&gt;std::chrono::month&lt;/code&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c6aba27c3fb9f5c674debbeb61e48936205d14bd" translate="yes" xml:space="preserve">
          <source>2) Returns the string used as the currency identifier by this locale. If &lt;code&gt;International&lt;/code&gt; (the second template parameter of &lt;code&gt;std::moneypunct&lt;/code&gt;) is &lt;code&gt;false&lt;/code&gt;, the identifier is usually a single (wide) character, such as &lt;code&gt;&quot;￥&quot;&lt;/code&gt; or &lt;code&gt;&quot;$&quot;&lt;/code&gt;. If &lt;code&gt;International&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the identifier is usually a four-character string holding the three-character &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_4217&quot;&gt;ISO 4217&lt;/a&gt; currency code followed by a space (&lt;code&gt;&quot;JPY &quot;&lt;/code&gt; or &lt;code&gt;&quot;USD &quot;&lt;/code&gt;)</source>
          <target state="translated">2)이 로케일에서 통화 식별자로 사용 된 문자열을 리턴합니다. 경우 &lt;code&gt;International&lt;/code&gt; (의 두 번째 템플릿 매개 변수 &lt;code&gt;std::moneypunct&lt;/code&gt; )는 &lt;code&gt;false&lt;/code&gt; , 식별자는 일반적으로 다음과 같은 단일 (와이드) 문자입니다 &lt;code&gt;&quot;￥&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;$&quot;&lt;/code&gt; . 경우 &lt;code&gt;International&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; , 식별자는 세 문자로 들고 네 문자열 보통 &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_4217&quot;&gt;ISO 4217&lt;/a&gt; 통화 코드는 공간 (다음에 &lt;code&gt;&quot;JPY &quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;USD &quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e7887877b659c0a6b382ef0cf51d12c66fa1c192" translate="yes" xml:space="preserve">
          <source>2) Returns the t distribution parameter. It identifies the number of trials. The default value is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">2) t 분포 모수를 구합니다. 시행 횟수를 식별합니다. 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b66ebd4cece8d564e6d69a38f8b8cf7bb39a807" translate="yes" xml:space="preserve">
          <source>2) Returns the value of the &lt;a href=&quot;fe_round&quot;&gt;floating point rounding macro&lt;/a&gt; that corresponds to the current rounding direction.</source>
          <target state="translated">2) 현재 반올림 방향에 해당하는 &lt;a href=&quot;fe_round&quot;&gt;부동 소수점 반올림 매크로&lt;/a&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="04ebaa70e4b5ae1242601266262488efa93190b5" translate="yes" xml:space="preserve">
          <source>2) Returns true if any of the bits in &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are not equal.</source>
          <target state="translated">2) &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 의 비트가 같지 않으면 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="684706ea115b5dd7bb203b7172a34dcaa9b23da0" translate="yes" xml:space="preserve">
          <source>2) Rvalue overload is deleted to prevent taking the address of &lt;code&gt;const&lt;/code&gt; rvalues.</source>
          <target state="translated">2)를 rvalue의 과부하의 주소 복용 방지하기 위해 삭제됩니다 &lt;code&gt;const&lt;/code&gt; 우변을.</target>
        </trans-unit>
        <trans-unit id="d86238bbc8e36a925c9f80302fa4069c3f0285ea" translate="yes" xml:space="preserve">
          <source>2) Same as (1) but may also propagate exceptions thrown by &lt;code&gt;pred&lt;/code&gt;</source>
          <target state="translated">2) (1)과 동일하지만 &lt;code&gt;pred&lt;/code&gt; 에 의해 발생 된 예외를 전파 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="57e247ebdf60c709e9ae22b0dda69f06a24842e0" translate="yes" xml:space="preserve">
          <source>2) Same as (1) but returns &lt;code&gt;local_days&lt;/code&gt; instead. Equivalent to &lt;code&gt;return local_days(sys_days(*this).time_since_epoch());&lt;/code&gt;.</source>
          <target state="translated">2) (1)과 동일하지만 대신 &lt;code&gt;local_days&lt;/code&gt; 를 반환 합니다. &lt;code&gt;return local_days(sys_days(*this).time_since_epoch());&lt;/code&gt; 를 반환하는 것과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="787ba623083b654803cc944b335d98a13f139e8d" translate="yes" xml:space="preserve">
          <source>2) Same as (1) except that the behavior is as if the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/lstat.html&quot;&gt;lstat&lt;/a&gt; is used (symlinks are not followed):</source>
          <target state="translated">2) 동작은 POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/lstat.html&quot;&gt;lstat&lt;/a&gt; 를 사용 하는 것처럼 (심볼릭 링크를 따르지 않는 ) 점을 제외하고 (1)과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9f60da33f6d9ebea7c44566f862bef1b340c47b0" translate="yes" xml:space="preserve">
          <source>2) Same as (1) except that the behavior is as if the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/lstat.html&quot;&gt;lstat&lt;/a&gt; is used (symlinks are not followed):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af966e118b06a72069dac8f7adf8f4ef42e3077" translate="yes" xml:space="preserve">
          <source>2) Same as (1), but executed according to &lt;code&gt;policy&lt;/code&gt;. This overload does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../algorithm/is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true</source>
          <target state="translated">2) (1)과 동일하지만 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . &lt;code&gt;&lt;a href=&quot;../algorithm/is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true가 아니면이 과부하는 과부하 해결에 참여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8683577e7b56386701932faf733e071045d7c48" translate="yes" xml:space="preserve">
          <source>2) Same as (1), but executed according to &lt;code&gt;policy&lt;/code&gt;. This overload does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../algorithm/is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">2) (1)과 동일하지만 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . &lt;code&gt;&lt;a href=&quot;../algorithm/is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true가 아니면이 과부하는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1654a4224b07ce94f8df3a08a02ac31f28af9634" translate="yes" xml:space="preserve">
          <source>2) Same as (1), but executed according to &lt;code&gt;policy&lt;/code&gt;. This overload does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true</source>
          <target state="translated">2) (1)과 동일하지만 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true가 아니면이 과부하는 과부하 해결에 참여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8521ba6b576268e0c550134ea77e3e28433962a8" translate="yes" xml:space="preserve">
          <source>2) Same as (1), but executed according to &lt;code&gt;policy&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true</source>
          <target state="translated">2) (1)과 동일하지만 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . 이 과부하는 &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true 인 경우에만 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="2124cbf53740fd55ccaf10707b644f6d1c12182c" translate="yes" xml:space="preserve">
          <source>2) Same as (1), but executed according to &lt;code&gt;policy&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">2) (1)과 동일하지만 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true 인 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="ebe57bded2a9a79d759a27216ef62cd996223a04" translate="yes" xml:space="preserve">
          <source>2) Same as (1), but may also fail spuriously.</source>
          <target state="translated">2) (1)과 동일하지만 허위로 실패 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb44f4f0eddcc4027b2c0e9421a0ee805eb12d71" translate="yes" xml:space="preserve">
          <source>2) Same as (1), but returns &lt;code&gt;local_days&lt;/code&gt; instead of &lt;code&gt;sys_days&lt;/code&gt;. Equivalent to &lt;code&gt;local_days(sys_days(*this).time_since_epoch())&lt;/code&gt;.</source>
          <target state="translated">2) (1)과 동일하지만 &lt;code&gt;sys_days&lt;/code&gt; 대신 &lt;code&gt;local_days&lt;/code&gt; 를 반환합니다 . 상당 &lt;code&gt;local_days(sys_days(*this).time_since_epoch())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a008aea8c4be4287c7f35d50f7f1955a8a9ab4d8" translate="yes" xml:space="preserve">
          <source>2) Same as (1), but the conversion is also &lt;code&gt;noexcept&lt;/code&gt;.</source>
          <target state="translated">2) (1)과 동일하지만 변환도 &lt;code&gt;noexcept&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b819c4b56ae1847eca755461645ce664da870ec" translate="yes" xml:space="preserve">
          <source>2) Same as (1), but uses &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_trivially_constructible&lt;/a&gt;&amp;lt;T, T&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">2) (1)과 동일하지만 &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_trivially_constructible&lt;/a&gt;&amp;lt;T, T&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="158d4174fc7bb0b591092979e26bc0885b332afe" translate="yes" xml:space="preserve">
          <source>2) Same as (1), but uses &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_trivially_constructible&lt;/a&gt;&amp;lt;T, const T&amp;amp;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">2) (1)과 동일하지만 &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_trivially_constructible&lt;/a&gt;&amp;lt;T, const T&amp;amp;&amp;gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2455df7b2175063ab628cedb488b1ec74f8ce49e" translate="yes" xml:space="preserve">
          <source>2) Same as (1), but uses &lt;code&gt;comp&lt;/code&gt; to compare the values.</source>
          <target state="translated">2) (1)과 동일하지만 &lt;code&gt;comp&lt;/code&gt; 를 사용하여 값을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="39d0d7b7ea9ff9127aed6deb2d0c6e2be24394f1" translate="yes" xml:space="preserve">
          <source>2) Same as (1), except that the attributes of the new directory are copied from &lt;code&gt;existing_p&lt;/code&gt; (which must be a directory that exists). It is OS-dependent which attributes are copied: on POSIX systems, the attributes are copied as if by</source>
          <target state="translated">2) 새 디렉토리의 속성이 &lt;code&gt;existing_p&lt;/code&gt; (존재하는 디렉토리 여야 함) 에서 복사된다는 점을 제외하고 (1)과 동일합니다 . POSIX 시스템에서 속성은 다음과 같이 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="2341cc9c6fc2861406e421041432094a4694bfee" translate="yes" xml:space="preserve">
          <source>2) Same as 1), but uses &lt;code&gt;&lt;a href=&quot;is_assignable&quot;&gt;std::is_trivially_assignable&lt;/a&gt;&amp;lt;T&amp;amp;, T&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">2) 1)과 동일하지만 &lt;code&gt;&lt;a href=&quot;is_assignable&quot;&gt;std::is_trivially_assignable&lt;/a&gt;&amp;lt;T&amp;amp;, T&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b7a7f1c4d66140d59703ce2be9bd8d7b0dd5ce5" translate="yes" xml:space="preserve">
          <source>2) Same as 1), but uses &lt;code&gt;&lt;a href=&quot;is_assignable&quot;&gt;std::is_trivially_assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">2) 1)과 동일하지만 &lt;code&gt;&lt;a href=&quot;is_assignable&quot;&gt;std::is_trivially_assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d88bfbdbb36791f1cf47a00b69cd034575faa322" translate="yes" xml:space="preserve">
          <source>2) Same as &lt;code&gt;getline(input, str, input.widen('\n'))&lt;/code&gt;, that is, the default delimiter is the endline character.</source>
          <target state="translated">2) &lt;code&gt;getline(input, str, input.widen('\n'))&lt;/code&gt; 과 동일합니다. 즉, 기본 구분 기호는 끝 문자입니다.</target>
        </trans-unit>
        <trans-unit id="2a60510c8e118ec323113052c9e5cc32ed9184d2" translate="yes" xml:space="preserve">
          <source>2) Same as &lt;code&gt;ostreambuf_iterator(stream.rdbuf())&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;ostreambuf_iterator(stream.rdbuf())&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="ae067033883014113425e5c4744db861b7d52f7a" translate="yes" xml:space="preserve">
          <source>2) Same, but &lt;code&gt;type&lt;/code&gt; cannot include parentheses:</source>
          <target state="translated">2) 동일하지만 &lt;code&gt;type&lt;/code&gt; 에는 괄호를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6d22cf7ab9fd315890290eaf83df26949f2ed10d" translate="yes" xml:space="preserve">
          <source>2) Searches for the file in implementation-defined manner. The intent of this syntax is to search for the files that are not controlled by the implementation. Typical implementations first search the directory where the current file resides and, only if the file is not found, search the standard include directories as with (1).</source>
          <target state="translated">2) 구현 정의 방식으로 파일을 검색합니다. 이 구문의 목적은 구현에 의해 제어되지 않는 파일을 검색하는 것입니다. 일반적인 구현에서는 먼저 현재 파일이있는 디렉토리를 검색하고 파일을 찾을 수없는 경우에만 (1)과 같이 표준 포함 디렉토리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="83e5006ee900293f9b17ba0a56fb606c36cc67ec" translate="yes" xml:space="preserve">
          <source>2) Seeds the underlying engine with the seed value &lt;code&gt;s&lt;/code&gt;. Effectively calls &lt;code&gt;e.seed(value)&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is the underlying engine.</source>
          <target state="translated">2) 시드 값 &lt;code&gt;s&lt;/code&gt; 로 기본 엔진을 시드합니다 . 효과적으로 &lt;code&gt;e.seed(value)&lt;/code&gt; 호출합니다 . 여기서 &lt;code&gt;e&lt;/code&gt; 는 기본 엔진입니다.</target>
        </trans-unit>
        <trans-unit id="070208aa54c5c3954acc1133746650d7456b1255" translate="yes" xml:space="preserve">
          <source>2) Sets file permissions to &lt;code&gt;perm&lt;/code&gt;.</source>
          <target state="translated">2) 파일 권한을 &lt;code&gt;perm&lt;/code&gt; 으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="4d8dff5e60439f19fbad0a1038c513b3b1664a7a" translate="yes" xml:space="preserve">
          <source>2) Sets file type to &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">2) 파일 형식을 &lt;code&gt;type&lt;/code&gt; 으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="cf5a1b8f6cba4055279c48e656c448a9fd8e8e35" translate="yes" xml:space="preserve">
          <source>2) Sets the &lt;code&gt;floatfield&lt;/code&gt; of the stream &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;scientific&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">2) 설정 &lt;code&gt;floatfield&lt;/code&gt; 스트림의 &lt;code&gt;str&lt;/code&gt; 에 &lt;code&gt;scientific&lt;/code&gt; 마치 호출하여 &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99f73e99b187c8783f2c722bce29a1143d224da1" translate="yes" xml:space="preserve">
          <source>2) Sets the associated parameter set to &lt;code&gt;params&lt;/code&gt;.</source>
          <target state="translated">2) 관련 파라미터 세트를 &lt;code&gt;params&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="a2e381e457457391dbb433f5bac59ef2a2057289" translate="yes" xml:space="preserve">
          <source>2) Sets the associated stream buffer to &lt;code&gt;sb&lt;/code&gt;. The error state is cleared by calling &lt;code&gt;&lt;a href=&quot;clear&quot;&gt;clear()&lt;/a&gt;&lt;/code&gt;. Returns the associated stream buffer before the operation. If there is no associated stream buffer, returns a null pointer.</source>
          <target state="translated">2) 관련 스트림 버퍼를 &lt;code&gt;sb&lt;/code&gt; 로 설정합니다 . 오류 상태는 &lt;code&gt;&lt;a href=&quot;clear&quot;&gt;clear()&lt;/a&gt;&lt;/code&gt; 를 호출하여 지 웁니다 . 작업 전에 관련 스트림 버퍼를 반환합니다. 연결된 스트림 버퍼가 없으면 null 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3cd279df430bb5b0e476b556bd51490847c7b224" translate="yes" xml:space="preserve">
          <source>2) Sets the bit at position &lt;code&gt;pos&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">2) 위치 &lt;code&gt;pos&lt;/code&gt; 의 비트 를 &lt;code&gt;false&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="b8b32bc3c8c48c3006f1655e8b5b333cd56c1c36" translate="yes" xml:space="preserve">
          <source>2) Sets the bit at position &lt;code&gt;pos&lt;/code&gt; to the value &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">2) 위치 &lt;code&gt;pos&lt;/code&gt; 의 비트를 값으로 설정 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c47fc2c83cdaef8884ec3896c7e1ab60732f5c0e" translate="yes" xml:space="preserve">
          <source>2) Sets the bits to the result of binary OR on corresponding pairs of bits of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;*this&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 의 해당 비트 쌍에 대한 이진 OR 결과로 비트를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="daafd4dc2b436ef899267802eb37328bbf36e368" translate="yes" xml:space="preserve">
          <source>2) Sets the current tied stream to &lt;code&gt;str&lt;/code&gt;. Returns the tied stream before the operation. If there is no tied stream, a null pointer is returned.</source>
          <target state="translated">2) 현재 연결된 스트림을 &lt;code&gt;str&lt;/code&gt; 로 설정합니다 . 작업 전에 연결된 스트림을 반환합니다. 묶인 스트림이 없으면 null 포인터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="77ef7fdb4c58ab14628d94dcbe6a4c1c1b4ed5c8" translate="yes" xml:space="preserve">
          <source>2) Sets the exception mask to &lt;code&gt;except&lt;/code&gt;.</source>
          <target state="translated">2) 예외 마스크를 &lt;code&gt;except&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="fe88e0919da14b89eabe35a9907df557c195fc76" translate="yes" xml:space="preserve">
          <source>2) Sets the field width to the given one. Returns the previous field width.</source>
          <target state="translated">2) 필드 너비를 주어진 것으로 설정합니다. 이전 필드 너비를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="89465e990db1d146cca41beafec452ffb5abc825" translate="yes" xml:space="preserve">
          <source>2) Sets the imaginary part to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">2) 허수 부를 &lt;code&gt;value&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="b62840a247fe057f7a18395f3da8e01892fcb3b0" translate="yes" xml:space="preserve">
          <source>2) Sets the maximum load factor to &lt;code&gt;ml&lt;/code&gt;.</source>
          <target state="translated">2) 최대 하중 계수를 &lt;code&gt;ml&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="60a12819ebc66ac9d400a09d83bc6795b16636bc" translate="yes" xml:space="preserve">
          <source>2) Sets the precision to the given one. Returns the previous precision.</source>
          <target state="translated">2) 정밀도를 주어진 것으로 설정합니다. 이전 정밀도를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d6f51212b959249e62b31b51142e82969ad6fe1c" translate="yes" xml:space="preserve">
          <source>2) Sets the real part to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">2) 실수 부분을 &lt;code&gt;value&lt;/code&gt; 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="a1f9add7f2592687e514ad4fdcadfd417e5bed21" translate="yes" xml:space="preserve">
          <source>2) Similar to (1), but it yields a specialization of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/subrange&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ranges::subrange&lt;/code&gt;&lt;/a&gt; when the the same condition is met.</source>
          <target state="translated">2) (1)과 유사하지만 동일한 조건이 충족 될 때 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/ranges/subrange&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;ranges::subrange&lt;/code&gt; &lt;/a&gt; 의 특수화를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="10aec6917ed97b26abd3c7faee4f84f08daa3b28" translate="yes" xml:space="preserve">
          <source>2) Specialization for pointers. If &lt;code&gt;T&lt;/code&gt; is an object type, provides a member type &lt;code&gt;value_type&lt;/code&gt; equal to &lt;code&gt;&lt;a href=&quot;../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. Otherwise, there is no member &lt;code&gt;value_type&lt;/code&gt;.</source>
          <target state="translated">2) 포인터 전문화. &lt;code&gt;T&lt;/code&gt; 가 객체 유형 인 경우 &lt;code&gt;&lt;a href=&quot;../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; &amp;lt;T&amp;gt;와 같은 멤버 유형 &lt;code&gt;value_type&lt;/code&gt; 을 제공하십시오 . 그렇지 않으면 &lt;code&gt;value_type&lt;/code&gt; 멤버가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="45c18ec003fcf5c20890b10f5b1f5fbdbd2e3fbd" translate="yes" xml:space="preserve">
          <source>2) Specialization for pointers. Provides a member type &lt;code&gt;difference_type&lt;/code&gt; equal to &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">2) 포인터 전문화. &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt; &lt;code&gt;difference_type&lt;/code&gt; 동일한 멤버 유형 difference_type을 제공합니다. .</target>
        </trans-unit>
        <trans-unit id="25d86a47c6b899b1f1df9adcb96e0ab88206f967" translate="yes" xml:space="preserve">
          <source>2) Specialization for type &lt;code&gt;void&lt;/code&gt; is provided, it declares the typedef &lt;code&gt;element_type&lt;/code&gt;, but no member functions.</source>
          <target state="translated">2) &lt;code&gt;void&lt;/code&gt; 유형에 대한 전문화 가 제공되며 typedef &lt;code&gt;element_type&lt;/code&gt; 을 선언 하지만 멤버 함수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="65a6768970698c58445ab21fb7c4dc1771866f7c" translate="yes" xml:space="preserve">
          <source>2) Static or thread-local object of class type that is initialized by a constructor call, if the constructor is &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; and all constructor arguments (including implicit conversions) are &lt;a href=&quot;constant_expression&quot;&gt;constant expressions&lt;/a&gt;, and if the initializers in the constructor's initializer list and the brace-or-equal initializers of the class members only contain constant expressions.</source>
          <target state="translated">2) 생성자가 &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; 이고 모든 생성자 인수 (암시 적 변환 포함)가 &lt;a href=&quot;constant_expression&quot;&gt;상수 표현식&lt;/a&gt; 이고 생성자의 이니셜 라이저 목록에있는 이니셜 라이저 및 중괄호 인 경우 생성자 호출에 의해 초기화되는 클래스 유형의 정적 또는 스레드 로컬 객체 클래스 멤버의 동일 이니셜 라이저에는 상수 표현식 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9ec197091834ee7983cb09b5df85878fb3b9ec6c" translate="yes" xml:space="preserve">
          <source>2) Suitably declared &lt;a href=&quot;name#Unqualified_identifiers&quot;&gt;unqualified identifiers&lt;/a&gt; (e.g. &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;cout&lt;/code&gt;)</source>
          <target state="translated">2) 적절하게 선언 된 &lt;a href=&quot;name#Unqualified_identifiers&quot;&gt;규정되지 않은 식별자&lt;/a&gt; (예 : &lt;code&gt;n&lt;/code&gt; 또는 &lt;code&gt;cout&lt;/code&gt; ) )</target>
        </trans-unit>
        <trans-unit id="b9af18f09c2ee1b5cddd8be9c39c6ceeb0373660" translate="yes" xml:space="preserve">
          <source>2) Swaps the arrays &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. In effect calls &lt;code&gt;&lt;a href=&quot;swap_ranges&quot;&gt;std::swap_ranges&lt;/a&gt;(a, a+N, b)&lt;/code&gt;. This overload does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;T2&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.(since C++17)</source>
          <target state="translated">2) 배열 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 를 바꿉니다 . 실제로 &lt;code&gt;&lt;a href=&quot;swap_ranges&quot;&gt;std::swap_ranges&lt;/a&gt;(a, a+N, b)&lt;/code&gt; 호출합니다 . &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;T2&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 가 아니면이 과부하는 과부하 해결에 참여하지 않습니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="3079d4646f618c386a0708d5fd966b77ead14111" translate="yes" xml:space="preserve">
          <source>2) The</source>
          <target state="translated">2)</target>
        </trans-unit>
        <trans-unit id="b793c688c914f8efd311b91fa7fe03541be021f3" translate="yes" xml:space="preserve">
          <source>2) The &lt;code&gt;enable_view&lt;/code&gt; variable template is used to indicate that whether a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;&lt;a href=&quot;../range/view&quot;&gt;View&lt;/a&gt;&lt;/code&gt;, as follows:</source>
          <target state="translated">2) &lt;code&gt;enable_view&lt;/code&gt; 변수 템플릿은 다음과 같이 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;&lt;a href=&quot;../range/view&quot;&gt;View&lt;/a&gt;&lt;/code&gt; 인지 나타내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="950c7bd5b13b8129416b8148a9c0282c83ea9997" translate="yes" xml:space="preserve">
          <source>2) The &lt;code&gt;explicit&lt;/code&gt; specifier may be used with a constant expression. The function is explicit if and only if that constant expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;explicit&lt;/code&gt; 지정자는 상수 표현식과 함께 사용될 수 있습니다. 상수 표현식이 &lt;code&gt;true&lt;/code&gt; 로 평가되는 경우에만 함수가 명시 적 입니다. .</target>
        </trans-unit>
        <trans-unit id="b4767755beb1e73cb3990ecf20a0c7d3d41705d3" translate="yes" xml:space="preserve">
          <source>2) The &lt;code&gt;register&lt;/code&gt; specifier is only allowed for objects declared at block scope and in function parameter lists. It indicates automatic storage duration, which is the default for these kinds of declarations. Additionally, the presence of this keyword may be used as a hint for the optimizer to store the value of this variable in a CPU register. This keyword was deprecated in C++11.</source>
          <target state="translated">2) &lt;code&gt;register&lt;/code&gt; 지정자는 블록 범위 및 함수 매개 변수 목록에서 선언 된 객체에만 허용됩니다. 자동 저장 기간을 나타내며 이러한 선언의 기본값입니다. 또한이 키워드가 존재하면 옵티마이 저가이 변수의 값을 CPU 레지스터에 저장하는 힌트로 사용될 수 있습니다. 이 키워드는 C ++ 11에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8290887e0e90e327b45b2d6d2c9b24ed2b76d9cf" translate="yes" xml:space="preserve">
          <source>2) The b distribution parameter (scale).</source>
          <target state="translated">2) b 분포 모수 (스케일).</target>
        </trans-unit>
        <trans-unit id="1a6f30ed216fc867166296b947e88c6b600594a5" translate="yes" xml:space="preserve">
          <source>2) The base class version of this function has no effect. The derived classes may override this function in order to be informed about the changes of the locale. The derived class may cache the locale and member facets between calls to &lt;code&gt;imbue()&lt;/code&gt;.</source>
          <target state="translated">2)이 기능의 기본 클래스 버전은 영향을 미치지 않습니다. 로케일의 변경 사항을 알리기 위해 파생 클래스가이 함수를 대체 할 수 있습니다. 파생 클래스는 &lt;code&gt;imbue()&lt;/code&gt; 호출간에 로캘 및 멤버 패싯을 캐시 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="14f9537c60c7b804288e7d756fa9eea92d2a2a54" translate="yes" xml:space="preserve">
          <source>2) The base class version of this function has no effect. The derived classes may override this function to allow absolute positioning of the position indicator.</source>
          <target state="translated">2)이 기능의 기본 클래스 버전은 영향을 미치지 않습니다. 파생 클래스는이 기능을 재정 의하여 위치 표시기의 절대 위치를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9210537b543c7ccb676ed8876ffff77435659859" translate="yes" xml:space="preserve">
          <source>2) The base class version of this function has no effect. The derived classes may override this function to allow relative positioning of the position indicator.</source>
          <target state="translated">2)이 기능의 기본 클래스 버전은 영향을 미치지 않습니다. 파생 클래스는이 기능을 재정 의하여 위치 표시기의 상대 위치를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="489cbc60d9e4ff2e05e82f993298aae5d533030c" translate="yes" xml:space="preserve">
          <source>2) The base class version of this function has no effect. The derived classes may override this function to allow removal or replacement of the controlled character sequence (the buffer) with a user-provided array, or for any other implementation-specific purpose.</source>
          <target state="translated">2)이 기능의 기본 클래스 버전은 영향을 미치지 않습니다. 파생 클래스는이 기능을 재정 의하여 제어 된 문자 시퀀스 (버퍼)를 사용자 제공 배열로 또는 다른 구현 별 목적으로 제거하거나 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de1ce89e13aae48a39f38fea924ee26418e5a148" translate="yes" xml:space="preserve">
          <source>2) The base class version of this function has no effect. The derived classes may override this function to allow synchronizing the underlying device with the buffers.</source>
          <target state="translated">2)이 기능의 기본 클래스 버전은 영향을 미치지 않습니다. 파생 클래스는 기본 장치를 버퍼와 동기화 할 수 있도록이 함수를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fe09d21a907cdcf7d545368a26b8685b7df2a85" translate="yes" xml:space="preserve">
          <source>2) The caller attempts to putback a different character from the one retrieved earlier (&lt;code&gt;pbackfail()&lt;/code&gt; is called with the character that needs to be put back), in which case</source>
          <target state="translated">2) 호출자는 이전에 검색된 것과 다른 문자를 &lt;code&gt;pbackfail()&lt;/code&gt; 시도합니다 ( pbackfail () 은 되돌려 야 하는 문자로 호출 됨).</target>
        </trans-unit>
        <trans-unit id="9f5d083c5637aa1678ab08f5602c6f753d6d8e5b" translate="yes" xml:space="preserve">
          <source>2) The caller attempts to putback a different character from the one retrieved earlier (&lt;code&gt;pbackfail()&lt;/code&gt; is called with the character that needs to be put back). In this situation, the purpose of &lt;code&gt;pbackfail()&lt;/code&gt; is to place the character &lt;code&gt;c&lt;/code&gt; into the get area at the position just before &lt;a href=&quot;gptr&quot;&gt;&lt;code&gt;basic_streambuf::gptr()&lt;/code&gt;&lt;/a&gt;, and, if possible, to modify the associated character sequence to reflect this change. This may involve backing up the get area as in the first variant.</source>
          <target state="translated">2) 호출자는 이전에 검색된 것과 다른 문자를 &lt;code&gt;pbackfail()&lt;/code&gt; 시도합니다 ( pbackfail () 은 되돌려 야 하는 문자로 호출 됨). 이 상황에서 &lt;code&gt;pbackfail()&lt;/code&gt; 의 목적은 문자 &lt;code&gt;c&lt;/code&gt; 를 &lt;a href=&quot;gptr&quot;&gt; &lt;code&gt;basic_streambuf::gptr()&lt;/code&gt; &lt;/a&gt; 직전의 위치에있는 get 영역에 배치 하고 가능한 경우이 변경 사항을 반영하도록 연관된 문자 순서를 수정하는 것입니다. 이것은 첫 번째 변형에서와 같이 get 영역을 백업하는 것을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cc89399707702f1779e5368a5c0ea82b8b2ae57" translate="yes" xml:space="preserve">
          <source>2) The concept &lt;code&gt;StrictTotallyOrderedWith&amp;lt;T, U&amp;gt;&lt;/code&gt; specifies that the comparison operators &lt;code&gt;==,!=,&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=&lt;/code&gt; on (possibly mixed) &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; operands yield results consistent with a strict total order. Comparing mixed operands yields results equivalent to comparing the operands converted to their common type.</source>
          <target state="translated">2) &lt;code&gt;StrictTotallyOrderedWith&amp;lt;T, U&amp;gt;&lt;/code&gt; 개념 은 비교 연산자 &lt;code&gt;==,!=,&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=&lt;/code&gt; ,! =, &amp;lt;,&amp;gt;, &amp;lt;=,&amp;gt; = 에서 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 피연산자가 엄격한 총 차수와 일치하는 결과를 산출하도록 지정합니다. 혼합 피연산자를 비교하면 공통 유형으로 변환 된 피연산자를 비교하는 것과 동일한 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f1e8c720cabc3e6d248f5d6b3fbe38dd3202d194" translate="yes" xml:space="preserve">
          <source>2) The copy assignment operator is deleted; &lt;code&gt;basic_filebuf&lt;/code&gt; is not &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">2) 복사 할당 연산자가 삭제됩니다. &lt;code&gt;basic_filebuf&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="9a63ad58af1bf84a2a92c4abcc14be43a779582a" translate="yes" xml:space="preserve">
          <source>2) The copy assignment operator is deleted; &lt;code&gt;basic_stringbuf&lt;/code&gt; is not &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">2) 복사 할당 연산자가 삭제됩니다. &lt;code&gt;basic_stringbuf&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="d0d21c7d0475cf5df4659c95a45488e713b12ffb" translate="yes" xml:space="preserve">
          <source>2) The copy constructor is defaulted (makes a bitwise copy of the tick count).</source>
          <target state="translated">2) 복사 생성자가 기본값으로 설정됩니다 (틱 카운트의 비트 단위 복사본을 만듭니다).</target>
        </trans-unit>
        <trans-unit id="5e25cd324c0b4b9ecaec01218a96f7b5b9a97d5c" translate="yes" xml:space="preserve">
          <source>2) The copy constructor is deleted: &lt;code&gt;std::seed_seq&lt;/code&gt; is not copyable.</source>
          <target state="translated">2) 복사 생성자가 삭제됩니다. &lt;code&gt;std::seed_seq&lt;/code&gt; 는 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="08ad7891ad7f0d7821788e8bf342fd9ee9291913" translate="yes" xml:space="preserve">
          <source>2) The copy constructor is deleted; &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; is not copyable.</source>
          <target state="translated">2) 복사 생성자가 삭제됩니다. &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 는 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="17290718c8349e1e2c025dae201d8975e42af596" translate="yes" xml:space="preserve">
          <source>2) The copy constructor is deleted; &lt;code&gt;std::basic_filebuf&lt;/code&gt; is not &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">2) 복사 생성자가 삭제됩니다. &lt;code&gt;std::basic_filebuf&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible이 아님&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eefd9b2d10ed93c62bbd922dbbaad8de45efe224" translate="yes" xml:space="preserve">
          <source>2) The copy constructor is protected, and is deleted. Input streams are not copyable.</source>
          <target state="translated">2) 복사 생성자가 보호되고 삭제됩니다. 입력 스트림은 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a2c4271a1901edd678bd8ec31a1788d4eb0a2900" translate="yes" xml:space="preserve">
          <source>2) The copy constructor is protected, and is deleted. Output streams are not copyable.</source>
          <target state="translated">2) 복사 생성자가 보호되고 삭제됩니다. 출력 스트림은 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cfe26d4fa627a1587125f8a89a2ee75c1a944b93" translate="yes" xml:space="preserve">
          <source>2) The default constructor is protected: only derived classes may construct &lt;code&gt;std::ios_base&lt;/code&gt;. The internal state is undefined after the construction. The derived class must call &lt;a href=&quot;../basic_ios/init&quot;&gt;&lt;code&gt;basic_ios::init()&lt;/code&gt;&lt;/a&gt; to complete initialization before first use or before destructor; otherwise the behavior is undefined.</source>
          <target state="translated">2) 기본 생성자는 보호됩니다. 파생 클래스 만 &lt;code&gt;std::ios_base&lt;/code&gt; 생성 할 수 있습니다 . 시공 후 내부 상태는 정의되지 않습니다. 파생 클래스는 &lt;a href=&quot;../basic_ios/init&quot;&gt; &lt;code&gt;basic_ios::init()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 처음 사용하기 전에 또는 소멸자 전에 초기화를 완료 해야합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="529a7ebc0c45dfd108d48d65115f536369081f55" translate="yes" xml:space="preserve">
          <source>2) The definition of an inline function or variable(since C++17) must be present in the translation unit where it is accessed (not necessarily before the point of access).</source>
          <target state="translated">2) 인라인 함수 또는 변수의 정의 (C ++ 17부터)는 액세스 단위 (액세스 지점 이전에 반드시 필요한 것은 아님)가 번역 단위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2cd86adb5facff344b42dfbbad25e5bc6252a398" translate="yes" xml:space="preserve">
          <source>2) The deviation &amp;sigma; distribution parameter.</source>
          <target state="translated">2) 편차 &amp;sigma; 분포 모수.</target>
        </trans-unit>
        <trans-unit id="86710c51236c9a5163f0d4a5fa18d71634ee3f9e" translate="yes" xml:space="preserve">
          <source>2) The execution policy type used as a unique type to disambiguate parallel algorithm overloading and indicate that a parallel algorithm's execution may be parallelized. The invocations of element access functions in parallel algorithms invoked with this policy (usually specified as &lt;code&gt;&lt;a href=&quot;execution_policy_tag&quot;&gt;std::execution::par&lt;/a&gt;&lt;/code&gt;) are permitted to execute in either the invoking thread or in a thread implicitly created by the library to support parallel algorithm execution. Any such invocations executing in the same thread are indeterminately sequenced with respect to each other.</source>
          <target state="translated">2) 병렬 알고리즘 오버로딩을 명확하게하고 병렬 알고리즘의 실행이 병렬화 될 수 있음을 나타 내기 위해 고유 한 유형으로 사용되는 실행 정책 유형. 이 정책으로 호출 된 병렬 알고리즘에서 요소 액세스 함수의 호출 (보통 &lt;code&gt;&lt;a href=&quot;execution_policy_tag&quot;&gt;std::execution::par&lt;/a&gt;&lt;/code&gt; 로 지정 )은 호출 스레드 또는 병렬 알고리즘 실행을 지원하기 위해 라이브러리에 의해 내재적으로 작성된 스레드에서 실행될 수 있습니다. 동일한 스레드에서 실행되는 이러한 호출은 서로에 대해 불확실하게 시퀀싱됩니다.</target>
        </trans-unit>
        <trans-unit id="96746981c0d5232419ee12cdfeeb5a231b82c80f" translate="yes" xml:space="preserve">
          <source>2) The exponent syntax for hexadecimal floating-point literal</source>
          <target state="translated">2) 16 진 부동 소수점 리터럴에 대한 지수 구문</target>
        </trans-unit>
        <trans-unit id="cbf30cf8905eae41f89d2b7e6cf429ccc5aa78e4" translate="yes" xml:space="preserve">
          <source>2) The expression &lt;code&gt;view::filter(E, P)&lt;/code&gt; is</source>
          <target state="translated">2) expression &lt;code&gt;view::filter(E, P)&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="b5c63534cd94f69bdc3e117d5503a36fbc1dda7a" translate="yes" xml:space="preserve">
          <source>2) The expression of a &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt;-specifier:</source>
          <target state="translated">2) &lt;a href=&quot;decltype&quot;&gt;decltype -specifier&lt;/a&gt; 의 표현 :</target>
        </trans-unit>
        <trans-unit id="4739a2426c595a401e800dc1225729611896ba2f" translate="yes" xml:space="preserve">
          <source>2) The first operand must be an expression of pointer to complete class type &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">2) 첫 번째 피연산자는 클래스 유형 &lt;code&gt;T*&lt;/code&gt; 를 완료하기위한 포인터의 표현식이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f2af795c7d5bb9f0a87c417eb44bb2189e5facca" translate="yes" xml:space="preserve">
          <source>2) The form with brace-enclosed list inside the square brackets is only used to call an overloaded &lt;code&gt;operator[]&lt;/code&gt;</source>
          <target state="translated">2) 대괄호 안에 중괄호로 묶인 목록이있는 양식은 과부하 된 &lt;code&gt;operator[]&lt;/code&gt; 를 호출 할 때만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd6b710a6029adf010e772119c69ce0fcd260658" translate="yes" xml:space="preserve">
          <source>2) The format character sequence is defined by the characters in &lt;code&gt;fmt&lt;/code&gt;. The resulting character sequence is copied to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">2) 형식 문자 순서는 &lt;code&gt;fmt&lt;/code&gt; 의 문자로 정의됩니다 . 결과 문자 시퀀스가 &lt;code&gt;out&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8f0e2f66751993cfa31f02e0999c593fdd8fa23c" translate="yes" xml:space="preserve">
          <source>2) The input is performed as a series of simple formatted extractions. Whitespace skipping is the same for each of them.</source>
          <target state="translated">2) 입력은 일련의 간단한 형식의 추출로 수행됩니다. 공백 생략은 각각에 대해 동일합니다.</target>
        </trans-unit>
        <trans-unit id="208b880632c15b8a0391499a7047133f8c2cbfa2" translate="yes" xml:space="preserve">
          <source>2) The k distribution parameter.</source>
          <target state="translated">2) k 분포 모수.</target>
        </trans-unit>
        <trans-unit id="97953aa781e3453c2f633e5ab6cd39cc03c48465" translate="yes" xml:space="preserve">
          <source>2) The list of probability densities at the boundaries of the intervals.</source>
          <target state="translated">2) 구간 경계에서의 확률 밀도 목록.</target>
        </trans-unit>
        <trans-unit id="10593803365fb6897be674b2da020e1166ff0c08" translate="yes" xml:space="preserve">
          <source>2) The list of probability densities of the intervals.</source>
          <target state="translated">2) 구간의 확률 밀도 목록.</target>
        </trans-unit>
        <trans-unit id="a48f0fe6e25df28c9399e861a734cfa34f2cea35" translate="yes" xml:space="preserve">
          <source>2) The log-deviation s distribution parameter.</source>
          <target state="translated">2) 로그 편차 분포 모수.</target>
        </trans-unit>
        <trans-unit id="0c46a443ec6b4f56f41d8d853075c97ec49a517e" translate="yes" xml:space="preserve">
          <source>2) The members declared after the specifier have protected member access</source>
          <target state="translated">2) 지정자 이후 선언 된 멤버는 멤버 액세스를 보호합니다.</target>
        </trans-unit>
        <trans-unit id="b7753c2a669f5dcffda1888b9670b0695adb2af3" translate="yes" xml:space="preserve">
          <source>2) The move assignment operator exchanges all data members of the base class, except for &lt;code&gt;rdbuf()&lt;/code&gt;, with &lt;code&gt;rhs&lt;/code&gt;, as if by calling &lt;code&gt;swap(*rhs)&lt;/code&gt;. This move assignment operator is protected: it is only called by the move assignment operators of the derived movable output stream classes &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly move-assign the associated streambuffers.</source>
          <target state="translated">2) 이동 할당 연산자는 &lt;code&gt;rdbuf()&lt;/code&gt; 제외한 기본 클래스의 모든 데이터 멤버를 &lt;code&gt;swap(*rhs)&lt;/code&gt; 을 호출하는 것처럼 &lt;code&gt;rhs&lt;/code&gt; 와 교환 합니다. 이 이동 할당 연산자는 보호됩니다. 파생 된 이동 가능 출력 스트림 클래스 &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt; 의 이동 할당 연산자에 의해서만 호출되며, 관련 스트림 버퍼 를 올바르게 이동 할당하는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ce749b0f73c8cb8352129428b67e0a96b2a6a64" translate="yes" xml:space="preserve">
          <source>2) The move assignment operator exchanges the gcount() values and all data members of the base class, except for &lt;code&gt;rdbuf()&lt;/code&gt;, with &lt;code&gt;rhs&lt;/code&gt;, as if by calling &lt;code&gt;swap(*rhs)&lt;/code&gt;. This move assignment operator is protected: it is only called by the move assignment operators of the derived movable input stream classes &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly move-assign the associated streambuffers.</source>
          <target state="translated">2) 이동 할당 연산자는 rdbuf ()를 제외한 gcount () 값과 기본 클래스의 모든 데이터 멤버를 호출하여 마치 &lt;code&gt;rhs&lt;/code&gt; 와 &lt;code&gt;rdbuf()&lt;/code&gt; &lt;code&gt;swap(*rhs)&lt;/code&gt; . 이 이동 할당 연산자는 보호됩니다. 파생 된 이동 가능 입력 스트림 클래스 &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; 의 이동 할당 연산자에 의해서만 호출되며, 관련 스트림 버퍼 를 올바르게 이동 할당하는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb032184de4bbe34484b6d70d20a6e29f4d859c6" translate="yes" xml:space="preserve">
          <source>2) The n (the second degree of freedom) distribution parameter.</source>
          <target state="translated">2) n (제 2 자유도) 분포 모수.</target>
        </trans-unit>
        <trans-unit id="99aa6ef75bd26ba2de70b65023abcfea43c79ddd" translate="yes" xml:space="preserve">
          <source>2) The name of the &lt;code&gt;std::chrono::time_zone&lt;/code&gt; for which this &lt;code&gt;link&lt;/code&gt; object provides an alternative name.</source>
          <target state="translated">2) 이 &lt;code&gt;link&lt;/code&gt; 객체가 다른 이름을 제공하는 &lt;code&gt;std::chrono::time_zone&lt;/code&gt; 이름.</target>
        </trans-unit>
        <trans-unit id="7fad383a36eccd125aeacc9525f3bf6c33c8a7df" translate="yes" xml:space="preserve">
          <source>2) The new pointer offset &lt;code&gt;newoff&lt;/code&gt; of type &lt;code&gt;off_type&lt;/code&gt; is determined</source>
          <target state="translated">2) 새로운 포인터 오프셋 &lt;code&gt;newoff&lt;/code&gt; 유형 &lt;code&gt;off_type&lt;/code&gt; 가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="5aec990e14101c0bcd77f4e22cf6a7cfb2367418" translate="yes" xml:space="preserve">
          <source>2) The non-member &lt;code&gt;any_cast&lt;/code&gt; functions provide type-safe access to the contained object.</source>
          <target state="translated">2) 멤버가 아닌 &lt;code&gt;any_cast&lt;/code&gt; 함수는 포함 된 개체에 대한 형식 안전 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="582c67ddf6f62ce1c1ef7f0f690cb6a06c0edb34" translate="yes" xml:space="preserve">
          <source>2) The number of uncaught exception objects in the current thread.</source>
          <target state="translated">2) 현재 스레드에서 포착되지 않은 예외 오브젝트 수.</target>
        </trans-unit>
        <trans-unit id="7f51319659c9a755cf2ce8b0c57e0fcc6d543174" translate="yes" xml:space="preserve">
          <source>2) The old value of the iterator.</source>
          <target state="translated">2) 반복자의 이전 값.</target>
        </trans-unit>
        <trans-unit id="dff5eafdffdb27565dbaeb4c69f6dd5798db7cee" translate="yes" xml:space="preserve">
          <source>2) The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 과부하는 기본 OS API 오류에서 &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다. &lt;code&gt;p&lt;/code&gt; 는 첫 번째 경로 인수로, OS 오류 코드는 오류 코드 인수로 구성됩니다. &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하는 과부하 는 OS API 호출이 실패하면이를 OS API 오류 코드로 설정하고 오류가 발생하지 않으면 &lt;code&gt;ec.clear()&lt;/code&gt; 실행 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83271095603ab7c6322a5e8f3914d379855a298a" translate="yes" xml:space="preserve">
          <source>2) The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument, &lt;code&gt;existing_p&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 과부하는 기본 OS API 오류에서 &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다. &lt;code&gt;p&lt;/code&gt; 는 첫 번째 경로 인수로, &lt;code&gt;existing_p&lt;/code&gt; 는 두 번째 경로 인수로, OS 오류 코드는 오류 코드 인수로 구성됩니다. &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하는 과부하 는 OS API 호출이 실패하면이를 OS API 오류 코드로 설정하고 오류가 발생하지 않으면 &lt;code&gt;ec.clear()&lt;/code&gt; 실행 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fedfe40539ff845ce724bcdefe4c0b4b5d1b5ab2" translate="yes" xml:space="preserve">
          <source>2) The pointer to the current character (</source>
          <target state="translated">2) 현재 문자에 ​​대한 포인터</target>
        </trans-unit>
        <trans-unit id="69cbd3e5e4d3a9ed59133e0252cfe374d2de3548" translate="yes" xml:space="preserve">
          <source>2) The previous value of the iterator.</source>
          <target state="translated">2) 반복자의 이전 값.</target>
        </trans-unit>
        <trans-unit id="561da9d0b8eb74564b3a716e4ed759c78b513270" translate="yes" xml:space="preserve">
          <source>2) The program is ill-formed if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;amp;&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;amp;&amp;gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="eca0f0583779e3e634f1c30803b6db16b0c89fa9" translate="yes" xml:space="preserve">
          <source>2) The random number generator is the function object &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">2) 난수 생성기는 함수 객체 &lt;code&gt;r&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="35e25ae4654ad718f8a3bffc69a7bad39d1064e8" translate="yes" xml:space="preserve">
          <source>2) The reference stored as value in the shared state.</source>
          <target state="translated">2) 참조는 공유 상태에서 값으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4dd94f6e52cf209cce4446ec0ad840b5d75fceea" translate="yes" xml:space="preserve">
          <source>2) The relative form of the path</source>
          <target state="translated">2) 경로의 상대적인 형태</target>
        </trans-unit>
        <trans-unit id="14e40c14e23a63774678bf09d3818d732824ff47" translate="yes" xml:space="preserve">
          <source>2) The result of &lt;a href=&quot;https://en.wikipedia.org/wiki/Fold_(higher-order_function)&quot;&gt;left fold&lt;/a&gt; of the given range over &lt;code&gt;op&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;op&lt;/code&gt; 에 대해 주어진 범위 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Fold_(higher-order_function)&quot;&gt;왼쪽 폴드&lt;/a&gt; 결과</target>
        </trans-unit>
        <trans-unit id="3381c306fe1c5e44690c74135fdd2c831b92183b" translate="yes" xml:space="preserve">
          <source>2) The result of &lt;code&gt;!lhs.equal(rhs)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;!lhs.equal(rhs)&lt;/code&gt; )의 결과 .</target>
        </trans-unit>
        <trans-unit id="7078d6b39da2557d2cfb099d99aaeab3db9616ea" translate="yes" xml:space="preserve">
          <source>2) The resulting absolute position as defined by the position indicator. The base class version returns &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt;.</source>
          <target state="translated">2) 위치 표시기에 의해 정의 된 결과 절대 위치. 기본 클래스 버전은 &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0e07d028ef438d861afc0f1edd39bd5977ee4657" translate="yes" xml:space="preserve">
          <source>2) The return type is &lt;code&gt;R&lt;/code&gt;. If &lt;code&gt;R&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, the result of the &lt;code&gt;invoke&lt;/code&gt; expression is discarded.</source>
          <target state="translated">2) 반환 유형은 &lt;code&gt;R&lt;/code&gt; 입니다. 경우 &lt;code&gt;R&lt;/code&gt; 은 (아마도 CV 정규화)는 &lt;code&gt;void&lt;/code&gt; 의 결과 &lt;code&gt;invoke&lt;/code&gt; 표현은 폐기된다.</target>
        </trans-unit>
        <trans-unit id="181a8cbb0dd338fa6fde71b3b9f2a20764e605be" translate="yes" xml:space="preserve">
          <source>2) The return type meets the requirements of constant &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">2) 반환 유형은 상수 &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 의 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="c42ab30e0dcd2fd028e8b3702d8a26313fc2f43e" translate="yes" xml:space="preserve">
          <source>2) The stored pointer, i.e., &lt;code&gt;get()&lt;/code&gt;</source>
          <target state="translated">2) 저장된 포인터, 즉 &lt;code&gt;get()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a5d5eedbfa032d05689dff895c55d7f69642213" translate="yes" xml:space="preserve">
          <source>2) The t distribution parameter.</source>
          <target state="translated">2) t 분포 모수.</target>
        </trans-unit>
        <trans-unit id="90f6ebb11f7b879e1a2203264460377befcb1ed5" translate="yes" xml:space="preserve">
          <source>2) The transformed &lt;code&gt;A&lt;/code&gt; can be another pointer or pointer to member type that can be converted to the deduced &lt;code&gt;A&lt;/code&gt; via a &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;qualification conversions&lt;/a&gt;or a function pointer conversion(since C++17):</source>
          <target state="translated">2) 변환 된 &lt;code&gt;A&lt;/code&gt; 는 &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;자격 변환&lt;/a&gt; 또는 함수 포인터 변환 (C ++ 17 이후)을 통해 추론 된 &lt;code&gt;A&lt;/code&gt; 로 변환 될 수있는 멤버 유형에 대한 다른 포인터 또는 포인터 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07df329930b026a6f5fd1751d93dbb43466ead78" translate="yes" xml:space="preserve">
          <source>2) The underlying iterator is initialized with &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">2) 기본 반복자는 &lt;code&gt;x&lt;/code&gt; 로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f5f72f52c7e8c564188399cb1ef1e5c4a31bca9" translate="yes" xml:space="preserve">
          <source>2) The value of the</source>
          <target state="translated">2) 가치</target>
        </trans-unit>
        <trans-unit id="b137e4833770fca0acf1fbd8939ba1635543491d" translate="yes" xml:space="preserve">
          <source>2) The value of the b parameter.</source>
          <target state="translated">2) b 매개 변수의 값.</target>
        </trans-unit>
        <trans-unit id="246b1340a1e80fa9e2f300866c54dea20d6847c5" translate="yes" xml:space="preserve">
          <source>2) The version of this function in the specialization of &lt;code&gt;&lt;a href=&quot;../pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; for pointer types returns &lt;code&gt;&lt;a href=&quot;../addressof&quot;&gt;std::addressof&lt;/a&gt;(r)&lt;/code&gt;</source>
          <target state="translated">2) 포인터 유형에 대한 &lt;code&gt;&lt;a href=&quot;../pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; 전문화에서이 함수의 버전은 &lt;code&gt;&lt;a href=&quot;../addressof&quot;&gt;std::addressof&lt;/a&gt;(r)&lt;/code&gt; (r)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7dc2591abff722b9450a8c74df7c5f201c0d140c" translate="yes" xml:space="preserve">
          <source>2) Then attempts to classify the character in the imbued locale by calling &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(getloc()).is(m, c)&lt;/code&gt;. If that returned &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; is returned by &lt;code&gt;isctype()&lt;/code&gt;.</source>
          <target state="translated">2) 그런 다음 &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(getloc()).is(m, c)&lt;/code&gt; 를 호출하여 내장 된 로케일의 문자를 분류하려고 시도합니다 . 그 반환하는 경우 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 에 의해 반환 &lt;code&gt;isctype()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a820a48acae67c57a408630003c72d23b5246a78" translate="yes" xml:space="preserve">
          <source>2) Then, direct base classes are initialized in left-to-right order as they appear in this class's base-specifier list</source>
          <target state="translated">2) 그런 다음 직접 기본 클래스는이 클래스의 기본 지정자 목록에 표시된대로 왼쪽에서 오른쪽으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="4c3eecd413e417961bcb5a2f9c21daa3a6a178a8" translate="yes" xml:space="preserve">
          <source>2) There is no other side effect X to M where A</source>
          <target state="translated">2) A에서 X에 대한 다른 부작용은 없습니다.</target>
        </trans-unit>
        <trans-unit id="a88fc3e49ead65c6e85be6221f3afd1cf04a39d3" translate="yes" xml:space="preserve">
          <source>2) This overload only participates in overload resolution if T is a specialization of std::pair. For &lt;code&gt;T = &lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;T1, T2&amp;gt;&lt;/code&gt;, equivalent to</source>
          <target state="translated">2)이 과부하는 T가 std :: pair의 전문화 인 경우에만 과부하 해결에 참여합니다. 들면 &lt;code&gt;T = &lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;T1, T2&amp;gt;&lt;/code&gt; , 당량</target>
        </trans-unit>
        <trans-unit id="8efa49525e665271a26732b061954aa9e798e3b4" translate="yes" xml:space="preserve">
          <source>2) Through a</source>
          <target state="translated">2) 통해</target>
        </trans-unit>
        <trans-unit id="397f7293066a1b923f53b2bbda4edb83f5fcee95" translate="yes" xml:space="preserve">
          <source>2) Throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos&lt;/code&gt; does not correspond to a valid position within the bitset</source>
          <target state="translated">2) 예외 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;pos&lt;/code&gt; 비트 세트 내에서 유효한 위치가 일치하지 않습니다</target>
        </trans-unit>
        <trans-unit id="fe12b00471782d3abe332b068facbae269da8878" translate="yes" xml:space="preserve">
          <source>2) Throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos&lt;/code&gt; does not correspond to a valid position within the bitset.</source>
          <target state="translated">2) 예외 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;pos&lt;/code&gt; 가 비트 세트 내의 유효한 위치에 해당하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e43b7e9cee947139e2e922b0e4d3005ec198aefd" translate="yes" xml:space="preserve">
          <source>2) Throws any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;T&lt;/code&gt; 의 생성자가 던진 예외를 던집니다 .</target>
        </trans-unit>
        <trans-unit id="d7de87e6665156bf82e0c82660acd2d3ddcb1982" translate="yes" xml:space="preserve">
          <source>2) Throws nothing</source>
          <target state="translated">2) 아무것도 던지지 않습니다</target>
        </trans-unit>
        <trans-unit id="d5f42bf81f9fa4ac5617a479c682553058d7f909" translate="yes" xml:space="preserve">
          <source>2) Throws nothing.</source>
          <target state="translated">2) 아무것도 던지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0aa8ff3d596328fb6ad4bd526319cc23a22db45f" translate="yes" xml:space="preserve">
          <source>2) To form a &lt;a href=&quot;pointer&quot;&gt;pointer to non-static member&lt;/a&gt;.</source>
          <target state="translated">2) &lt;a href=&quot;pointer&quot;&gt;비 정적 멤버에&lt;/a&gt; 대한 포인터 를 형성합니다 .</target>
        </trans-unit>
        <trans-unit id="b4abc5107f2e2f3e76cbfd525f378aead236b0cb" translate="yes" xml:space="preserve">
          <source>2) Trailing return type declaration: trailing return type is only allowed on the outermost function declarator. The decl-specifier-seq in this case must contain the keyword &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">2) 후행 리턴 유형 선언 : 후행 리턴 유형은 가장 바깥 쪽 함수 선언자에서만 허용됩니다. 이 경우 decl-specifier-seq에는 키워드 &lt;code&gt;auto&lt;/code&gt; 가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="302ab7f6af0594883108e1d3845c83b71c408a4a" translate="yes" xml:space="preserve">
          <source>2) Transfers the element pointed to by &lt;code&gt;it&lt;/code&gt; from &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. The element is inserted before the element pointed to by &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">2)가 가리키는 요소 전학 &lt;code&gt;it&lt;/code&gt; 으로부터 &lt;code&gt;other&lt;/code&gt; 에 &lt;code&gt;*this&lt;/code&gt; . &lt;code&gt;pos&lt;/code&gt; 가 가리키는 요소 앞에 요소가 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1776a89f9cd0f98f22ff560bf94f4fc7cf05476" translate="yes" xml:space="preserve">
          <source>2) Type-based non-throwing accessor: Equivalent to (1) with &lt;code&gt;I&lt;/code&gt; being the zero-based index of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;. The call is ill-formed if &lt;code&gt;T&lt;/code&gt; is not a unique element of &lt;code&gt;Types...&lt;/code&gt;.</source>
          <target state="translated">2) 유형 기반의 비 던지는 접근 : (1)에 해당합니다 &lt;code&gt;I&lt;/code&gt; 의 제로로부터 시작되는 인덱스되는 &lt;code&gt;T&lt;/code&gt; 의 &lt;code&gt;Types...&lt;/code&gt; . &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Types...&lt;/code&gt; 의 고유 한 요소가 아닌 경우 호출이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="56276b30aff93b4c918ce9dcc07191cd1b1bd869" translate="yes" xml:space="preserve">
          <source>2) Type-based value accessor: If &lt;code&gt;v&lt;/code&gt; holds the alternative &lt;code&gt;T&lt;/code&gt;, returns a reference to the value stored in &lt;code&gt;v&lt;/code&gt;. Otherwise, throws &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt;. The call is ill-formed if &lt;code&gt;T&lt;/code&gt; is not a unique element of &lt;code&gt;Types...&lt;/code&gt;.</source>
          <target state="translated">2) 유형 기반 값 접근 : 경우 &lt;code&gt;v&lt;/code&gt; 대체 보유하고 &lt;code&gt;T&lt;/code&gt; 를 ,에 저장된 값에 대한 참조를 반환 &lt;code&gt;v&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Types...&lt;/code&gt; 의 고유 한 요소가 아닌 경우 호출이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a28ac043b5a92413f90ca050cb84f25029dc5d9" translate="yes" xml:space="preserve">
          <source>2) UTF-8 character literal, e.g. &lt;code&gt;u8'a'&lt;/code&gt;. Such literal has type &lt;code&gt;char&lt;/code&gt;(until C++20)&lt;code&gt;char8_t&lt;/code&gt;(since C++20) and the value equal to ISO 10646 code point value of c-char, provided that the code point value is representable with a single UTF-8 code unit (that is, c-char is in the range 0x0-0x7F, inclusive). If c-char is not representable with a single UTF-8 code unit, the program is ill-formed.</source>
          <target state="translated">2) UTF-8 문자 리터럴 (예 : &lt;code&gt;u8'a'&lt;/code&gt; . 이러한 리터럴은 &lt;code&gt;char&lt;/code&gt; (C ++ 20까지) &lt;code&gt;char8_t&lt;/code&gt; (C ++ 20부터) 및 c-char의 ISO 10646 코드 포인트 값과 동일한 값을 갖습니다 (코드 포인트 값이 단일 UTF-8 코드로 표시 될 수있는 경우) 단위 (즉, c-char의 범위는 0x0-0x7F입니다). 단일 UTF-8 코드 단위로 c-char를 표현할 수없는 경우 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="be9e88a87a39032aa3c067ba42a4b3d35179387c" translate="yes" xml:space="preserve">
          <source>2) Unary left fold (... op E) becomes (((E</source>
          <target state="translated">2) 단항 왼쪽 접기 (... op E)는 (((E</target>
        </trans-unit>
        <trans-unit id="41961fb00708d365837720af730227f1e7508793" translate="yes" xml:space="preserve">
          <source>2) Underflow occurs (and &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; may be raised) if after the rounding of the result to the target floating-point type (that is, rounding to &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits&lt;/code&gt; bits), the result's absolute value is smaller than &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt;. Formally, the absolute value of a nonzero result computed as though the exponent range were unbounded is smaller than &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt;. Such implementation detects tinyness after rounding (e.g. SuperSparc)</source>
          <target state="translated">2) 결과를 목표 부동 소수점 유형으로 반올림 한 후 (즉, &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits&lt;/code&gt; &amp;lt;T&amp;gt; :: digits 비트로 반올림 ) 결과의 절대 값이 더 작은 경우 언더 플로우 가 발생하고 &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; 가 발생할 수 있습니다. 보다 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; &amp;lt;T&amp;gt; :: 분 () . 공식적으로 지수 범위가 제한되지 않은 것처럼 계산 된 0이 아닌 결과의 절대 값은 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; &amp;lt;T&amp;gt; :: min () 보다 작습니다 . 이러한 구현은 반올림 후 작은 정도를 감지합니다 (예 : SuperSparc)</target>
        </trans-unit>
        <trans-unit id="056c7ca31755058b072f2f89c93270a864830745" translate="yes" xml:space="preserve">
          <source>2) Used to obtain the sentinel type of the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">2) 유형 &lt;code&gt;T&lt;/code&gt; 의 센티넬 유형을 얻는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c1b0681dd646343ae259502e821d37cfe07693da" translate="yes" xml:space="preserve">
          <source>2) Uses &lt;a href=&quot;list_initialization&quot;&gt;copy-list-initialization&lt;/a&gt; to construct the return value of the function.</source>
          <target state="translated">2) &lt;a href=&quot;list_initialization&quot;&gt;copy-list-initialization&lt;/a&gt; 을 사용 하여 함수의 리턴 값을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="11c95151bab62e4037704f2e8ebaf4a0bf219403" translate="yes" xml:space="preserve">
          <source>2) Uses the delete expression as the deleter. A valid delete expression must be available, i.e. &lt;code&gt;delete ptr&lt;/code&gt; must be well formed, have well-defined behavior and not throw any exceptions. Equivalent to &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(ptr).swap(*this);&lt;/code&gt;.</source>
          <target state="translated">2) 삭제 표현식을 삭제 자로 사용합니다. 유효한 삭제 표현식을 사용할 수 있어야합니다. 즉, &lt;code&gt;delete ptr&lt;/code&gt; 이 올바르게 구성되어 있고 올바르게 정의 된 동작이 있어야하며 예외가 발생하지 않아야합니다. 당량 &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(ptr).swap(*this);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e138513d3ab1d7c6f9259e0ed42b6bf151df482" translate="yes" xml:space="preserve">
          <source>2) Value assignment, equivalent to &lt;code&gt;store(desired)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;store(desired)&lt;/code&gt; 과 동등한 가치 할당</target>
        </trans-unit>
        <trans-unit id="a10df013e9f0915b14bc450f19b61d3443e16f51" translate="yes" xml:space="preserve">
          <source>2) Variable template for &lt;code&gt;empty_view&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;empty_view&lt;/code&gt; 변수 템플릿 .</target>
        </trans-unit>
        <trans-unit id="e3a2875ae0d9153472ecdc37f03b5d1c3ad03471" translate="yes" xml:space="preserve">
          <source>2) Virtual destructor is usually required in a base class</source>
          <target state="translated">2) 가상 소멸자는 일반적으로 기본 클래스에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c29a0e8b717ed75e29ab47bcc40fdaa82b2309d1" translate="yes" xml:space="preserve">
          <source>2) When a named &lt;a href=&quot;reference#Rvalue_references&quot;&gt;rvalue reference&lt;/a&gt; variable is declared with an initializer</source>
          <target state="translated">2) 명명 된 &lt;a href=&quot;reference#Rvalue_references&quot;&gt;rvalue 참조&lt;/a&gt; 변수가 이니셜 라이저로 선언 된 경우</target>
        </trans-unit>
        <trans-unit id="c8ce328e0bb39ff88d5896c9ea941531a6c56240" translate="yes" xml:space="preserve">
          <source>2) When two functions with the same unqualified name are declared in different namespaces, and both have &lt;code&gt;&quot;C&quot;&lt;/code&gt; language linkage, the declarations refer to the same function.</source>
          <target state="translated">2) 규정되지 않은 이름을 가진 두 함수가 서로 다른 네임 스페이스에서 선언되고 둘 다 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 언어 연결을 갖는 경우 선언은 동일한 함수를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="a96294adb5fa3f90b21afdca0b3c8233e6403754" translate="yes" xml:space="preserve">
          <source>2) Wide string literal. The type of a &lt;code&gt;L&quot;...&quot;&lt;/code&gt; string literal is &lt;code&gt;const wchar_t[N]&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the size of the string in code units of the execution wide encoding, including the null terminator.</source>
          <target state="translated">2) 넓은 문자열 리터럴. &lt;code&gt;L&quot;...&quot;&lt;/code&gt; 문자열 리터럴 의 유형 은 &lt;code&gt;const wchar_t[N]&lt;/code&gt; . 여기서 &lt;code&gt;N&lt;/code&gt; 은 널 종료자를 포함하여 실행 전체 인코딩의 코드 단위로 문자열의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="d8b7ed238c60758453d42719ed9f033ea33dcb89" translate="yes" xml:space="preserve">
          <source>2) Wraps a const member function with no parameters.</source>
          <target state="translated">2) 매개 변수없이 const 멤버 함수를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="82be08f8e41bb938b3c303da8f2c0cf4ad97e7ae" translate="yes" xml:space="preserve">
          <source>2) Writes &lt;code&gt;count&lt;/code&gt; characters to the output sequence from the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. The characters are written as if by repeated calls to &lt;code&gt;&lt;a href=&quot;sputc&quot;&gt;sputc()&lt;/a&gt;&lt;/code&gt;. Writing stops when either &lt;code&gt;count&lt;/code&gt; characters are written or a call to &lt;code&gt;&lt;a href=&quot;sputc&quot;&gt;sputc()&lt;/a&gt;&lt;/code&gt; would have returned &lt;code&gt;Traits::eof()&lt;/code&gt;.</source>
          <target state="translated">2) 첫 번째 요소가 &lt;code&gt;s&lt;/code&gt; 로 가리키는 문자 배열의 &lt;code&gt;count&lt;/code&gt; 순서를 출력 순서에 기록 합니다 . 문자는 &lt;code&gt;&lt;a href=&quot;sputc&quot;&gt;sputc()&lt;/a&gt;&lt;/code&gt; 를 반복해서 호출하는 것처럼 작성됩니다 . &lt;code&gt;count&lt;/code&gt; 문자를 &lt;code&gt;&lt;a href=&quot;sputc&quot;&gt;sputc()&lt;/a&gt;&lt;/code&gt; 호출하면 &lt;code&gt;Traits::eof()&lt;/code&gt; 가 반환 되면 쓰기가 중지됩니다 .</target>
        </trans-unit>
        <trans-unit id="66af2655e87a9e9c59e356b783a2d60c640f92a8" translate="yes" xml:space="preserve">
          <source>2) Writes characters to the output sequence &lt;code&gt;out&lt;/code&gt; which represent the value of &lt;code&gt;v&lt;/code&gt;, formatted as requested by the formatting flags &lt;code&gt;str.flags()&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facets of the locale imbued in the stream &lt;code&gt;str&lt;/code&gt;. This function is called by all formatted output stream operators, such as &lt;code&gt;&lt;a href=&quot;../../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; n;&lt;/code&gt;.</source>
          <target state="translated">2) 출력 시퀀스에 문자를 기입 &lt;code&gt;out&lt;/code&gt; 의 값 대표되는 &lt;code&gt;v&lt;/code&gt; 요청한 서식 플래그로 포맷 &lt;code&gt;str.flags()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 스트림에 스며 로케일 패싯 &lt;code&gt;str&lt;/code&gt; . 이 함수는 &lt;code&gt;&lt;a href=&quot;../../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; n;&lt;/code&gt; 과 같은 형식화 된 모든 출력 스트림 연산자에 의해 호출됩니다 . .</target>
        </trans-unit>
        <trans-unit id="fb68e180bc5c9076b0953a9a46e57364a26f7b3a" translate="yes" xml:space="preserve">
          <source>2) Writes the results to a file stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">2) 결과를 파일 스트림 &lt;code&gt;stream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9d0bd4175c1bf2f0c0c43a79ba1a6a29c0912cf" translate="yes" xml:space="preserve">
          <source>2) Yields the size in bytes of the object representation of the type of expression, if that expression is evaluated.</source>
          <target state="translated">2) 해당 표현식이 평가되면 표현식 유형의 오브젝트 표시 크기를 바이트 단위로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="58f04a4a1a97eaf9db591eff20c86cd6c7270539" translate="yes" xml:space="preserve">
          <source>2) a copy of the &lt;code&gt;std::chrono::weekday_indexed&lt;/code&gt; object stored in &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;*this&lt;/code&gt; 에 저장된 &lt;code&gt;std::chrono::weekday_indexed&lt;/code&gt; 객체 의 사본</target>
        </trans-unit>
        <trans-unit id="d34a26780a58ee4350b0f0c7a2e4d9baecbeb883" translate="yes" xml:space="preserve">
          <source>2) a copy of the &lt;code&gt;std::chrono::weekday_last&lt;/code&gt; object stored in &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;*this&lt;/code&gt; 에 저장된 &lt;code&gt;std::chrono::weekday_last&lt;/code&gt; 객체 의 사본</target>
        </trans-unit>
        <trans-unit id="a7b1f6c13fab1c610bcf2ea7c0fa72e2704508d1" translate="yes" xml:space="preserve">
          <source>2) a copy of this duration object, with the number of ticks negated</source>
          <target state="translated">2) 틱 수가 무효화 된이 지속 기간 객체의 사본</target>
        </trans-unit>
        <trans-unit id="dcb5152138c7fa69e4b774009c9b97f2edbf85ae" translate="yes" xml:space="preserve">
          <source>2) a declaration of a function at block scope (that's not a &lt;a href=&quot;namespace#Using-declarations&quot;&gt;using-declaration&lt;/a&gt;)</source>
          <target state="translated">2) 블록 범위에서 함수 선언 ( &lt;a href=&quot;namespace#Using-declarations&quot;&gt;사용 선언이&lt;/a&gt; 아님)</target>
        </trans-unit>
        <trans-unit id="1a77efcd1ed046f4a26409e7bf6b31f5ae0d09f8" translate="yes" xml:space="preserve">
          <source>2) a function directly invoked by the exception handling mechanism while handling an exception that has not yet been caught exits via an exception (e.g. a destructor of some local object, or a copy constructor constructing a catch-clause parameter)</source>
          <target state="translated">2) 아직 포착되지 않은 예외를 처리하는 동안 예외 처리 메커니즘에 의해 직접 호출 된 함수 (예 : 일부 로컬 오브젝트의 소멸자 또는 catch-clause 매개 변수를 구성하는 복사 생성자)</target>
        </trans-unit>
        <trans-unit id="d6739c9b1964142e8846c31adb098c5b9114a60a" translate="yes" xml:space="preserve">
          <source>2) additional copies of &lt;code&gt;value&lt;/code&gt; are appended</source>
          <target state="translated">2) 추가 복사본 &lt;code&gt;value&lt;/code&gt; 추가된다</target>
        </trans-unit>
        <trans-unit id="0be286efeb0ed06601c983729d7755efd172d770" translate="yes" xml:space="preserve">
          <source>2) adds &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">2) 추가 &lt;code&gt;const&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77c1cb5073f792c06543a1b7139e1e7603aca7e7" translate="yes" xml:space="preserve">
          <source>2) all C streams are flushed and closed</source>
          <target state="translated">2) 모든 C 스트림이 플러시되고 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="d6324e66394574789cab02decb32e99d55fbb6dd" translate="yes" xml:space="preserve">
          <source>2) allocated buffer size (the beginning of the buffer does not need a special data member, it may be stored in the inherited pointer &lt;code&gt;&lt;a href=&quot;basic_streambuf/gptr&quot;&gt;eback()&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">2) 할당 된 버퍼 크기 (버퍼의 시작 부분에는 특별한 데이터 멤버가 필요하지 않으며 상속 된 포인터 &lt;code&gt;&lt;a href=&quot;basic_streambuf/gptr&quot;&gt;eback()&lt;/a&gt;&lt;/code&gt; 저장 될 수 있음 )</target>
        </trans-unit>
        <trans-unit id="2b1167aa9a7c025f6231e3af912f3af7dfa5d094" translate="yes" xml:space="preserve">
          <source>2) an object of type &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;std::bitset::reference&lt;/a&gt;&lt;/code&gt;, which allows writing to the requested bit.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;std::bitset::reference&lt;/a&gt;&lt;/code&gt; 유형의 객체로 요청 된 비트에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf7b40054eb1c9e4f754b5453651c07e5d31d0b3" translate="yes" xml:space="preserve">
          <source>2) attempts to convert the &lt;code&gt;externT&lt;/code&gt; characters from the character array defined by &lt;code&gt;[from, from_end)&lt;/code&gt;, given initial conversion state &lt;code&gt;state&lt;/code&gt;, to at most &lt;code&gt;max&lt;/code&gt;&lt;code&gt;internT&lt;/code&gt; characters, and returns the number of &lt;code&gt;externT&lt;/code&gt; characters that such conversion would consume. Modifies &lt;code&gt;state&lt;/code&gt; as if by executing &lt;code&gt;do_in(state, from, from_end, from, to, to+max, to)&lt;/code&gt; for some imaginary &lt;code&gt;[to, to+max)&lt;/code&gt; output buffer.</source>
          <target state="translated">2) 시도는 변환하는 &lt;code&gt;externT&lt;/code&gt; 에 의해 정의 된 문자 배열의 문자를 &lt;code&gt;[from, from_end)&lt;/code&gt; 초기 변환 상태 주어진 &lt;code&gt;state&lt;/code&gt; 기껏로, &lt;code&gt;max&lt;/code&gt; &lt;code&gt;internT&lt;/code&gt; 문자 및 반환의 수 &lt;code&gt;externT&lt;/code&gt; 의 이러한 변환이 소비하는 것이 자. 가상 &lt;code&gt;[to, to+max)&lt;/code&gt; 출력 버퍼에 대해 &lt;code&gt;do_in(state, from, from_end, from, to, to+max, to)&lt;/code&gt; 실행하여 &lt;code&gt;state&lt;/code&gt; 를 수정 합니다.</target>
        </trans-unit>
        <trans-unit id="01558284619f4fae390cae47f474668f6cbe82d9" translate="yes" xml:space="preserve">
          <source>2) attribute with a namespace, such as &lt;code&gt;[[gnu::unused]]&lt;/code&gt;</source>
          <target state="translated">2) 네임 스페이스가있는 속성 (예 : &lt;code&gt;[[gnu::unused]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d38cc158f020fe363e0e7d5e3c35d177e155dae2" translate="yes" xml:space="preserve">
          <source>2) average case linear worst case quadratic in distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 사이의 거리에서 평균 경우 선형 최악의 2 차</target>
        </trans-unit>
        <trans-unit id="2cf7ae39809692ef985348cfe0b01a2972cbd32b" translate="yes" xml:space="preserve">
          <source>2) bitwise AND</source>
          <target state="translated">2) 비트 AND</target>
        </trans-unit>
        <trans-unit id="917e9313c6fe9305ed1ce14d0a1c000bca25cdc7" translate="yes" xml:space="preserve">
          <source>2) by the members and friends(until C++17) of any class derived from &lt;code&gt;Base&lt;/code&gt;, but only when operating on an object of a type that is derived from &lt;code&gt;Base&lt;/code&gt; (including &lt;code&gt;this&lt;/code&gt;)</source>
          <target state="translated">2)과 친구들 그래피 (유래의 임의의 클래스 C ++ 17)까지 &lt;code&gt;Base&lt;/code&gt; 있지만으로부터 유도되는 유형의 객체상에서 동작 할 때 &lt;code&gt;Base&lt;/code&gt; (포함 &lt;code&gt;this&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b0521420c91cdfff77257c87adc6c76f6433608a" translate="yes" xml:space="preserve">
          <source>2) calls &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecc50aee5b5ce757053b94146270424166e2c821" translate="yes" xml:space="preserve">
          <source>2) calls &lt;code&gt;&lt;a href=&quot;../byte/strtol&quot;&gt;std::strtol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstol&quot;&gt;std::wcstol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../byte/strtol&quot;&gt;std::strtol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../wide/wcstol&quot;&gt;std::wcstol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c249120747da0d4828fd641dcd88f54ce3314ec" translate="yes" xml:space="preserve">
          <source>2) calls &lt;code&gt;&lt;a href=&quot;../byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstoul&quot;&gt;std::wcstoull&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../wide/wcstoul&quot;&gt;std::wcstoull&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f476f1b473d513799e1fda6615dbe01673d2b3bb" translate="yes" xml:space="preserve">
          <source>2) calls &lt;code&gt;buf.set_emit_on_sync(false)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;buf.set_emit_on_sync(false)&lt;/code&gt; 호출</target>
        </trans-unit>
        <trans-unit id="dc3e098ebd99b1fbf8ea67cf00bf2d155646c454" translate="yes" xml:space="preserve">
          <source>2) case label in a &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; statement;</source>
          <target state="translated">2) &lt;a href=&quot;switch&quot;&gt;스위치&lt;/a&gt; 명세서의 사례 라벨 ;</target>
        </trans-unit>
        <trans-unit id="3a69a6f3529b5647edf421af5578258207f416ec" translate="yes" xml:space="preserve">
          <source>2) class types with trivial default constructors and trivial destructors declared without initializers</source>
          <target state="translated">2) 간단한 기본 생성자와 초기화하지 않고 선언 된 간단한 소멸자가있는 클래스 유형</target>
        </trans-unit>
        <trans-unit id="cacc01b059fe15e1b8839f6d680fd21c86299d7e" translate="yes" xml:space="preserve">
          <source>2) compound statements;</source>
          <target state="translated">2) 복합 진술;</target>
        </trans-unit>
        <trans-unit id="47e0994774c3ad8efaaa35e819143ffb77306134" translate="yes" xml:space="preserve">
          <source>2) const rvalue reference overload is deleted to disallow rvalue arguments</source>
          <target state="translated">2) const rvalue 참조 과부하는 rvalue 인수를 허용하지 않도록 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="9268cbb9d1e8f2ae2abf9d99805de2adbac5a42a" translate="yes" xml:space="preserve">
          <source>2) constructs an object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt;, &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-non-list-initialized&lt;/a&gt; from &lt;code&gt;il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;, as the contained object. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, &lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;, Args...&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">2) 유형의 객체를 생성 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; , &lt;a href=&quot;../../language/direct_initialization&quot;&gt;직접 비리스트 초기화&lt;/a&gt; 에서 &lt;code&gt;il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; , 포함 된 객체있다. &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, &lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;, Args...&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; 이있는 경우이 과부하는 과부하 해결에만 참여합니다. 둘 다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6b432dab38092bde1f129853c4eec5b529f802a" translate="yes" xml:space="preserve">
          <source>2) constructs the container with the contents of the range &lt;code&gt;[first, last)&lt;/code&gt;. Sets &lt;code&gt;max_load_factor()&lt;/code&gt; to 1.0.</source>
          <target state="translated">2) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 내용으로 컨테이너를 구성합니다 . &lt;code&gt;max_load_factor()&lt;/code&gt; 를 1.0으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="62f4f2991fefcca16e226626cf3ebd69b1d81898" translate="yes" xml:space="preserve">
          <source>2) constructs the container with the contents of the range &lt;code&gt;[first, last)&lt;/code&gt;. Sets &lt;code&gt;max_load_factor()&lt;/code&gt; to 1.0. If multiple elements in the range have keys that compare equivalent, it is unspecified which element is inserted (pending &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;LWG2844&lt;/a&gt;).</source>
          <target state="translated">2) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 내용으로 컨테이너를 구성합니다 . &lt;code&gt;max_load_factor()&lt;/code&gt; 를 1.0으로 설정합니다 . 범위의 여러 요소에 동등한 키가있는 경우 삽입 할 요소가 지정되지 &lt;a href=&quot;http://wg21.link/lwg2844&quot;&gt;않습니다&lt;/a&gt; ( LWG2844 보류 중 ).</target>
        </trans-unit>
        <trans-unit id="5d77c666dae232bb4a839f2c318c7defedbce010" translate="yes" xml:space="preserve">
          <source>2) control information: flags that control formatting of both input and output sequences and the imbued locale</source>
          <target state="translated">2) 제어 정보 : 입력 및 출력 시퀀스와 임베딩 된 로케일의 형식을 제어하는 ​​플래그</target>
        </trans-unit>
        <trans-unit id="473e0ed1d382ee82a31f797c07d4f95fa3c33b65" translate="yes" xml:space="preserve">
          <source>2) copy constructor is deleted; &lt;code&gt;&lt;a href=&quot;../facet&quot;&gt;std::locale::facet&lt;/a&gt;&lt;/code&gt; is not copyable.</source>
          <target state="translated">2) 복사 생성자가 삭제됩니다. &lt;code&gt;&lt;a href=&quot;../facet&quot;&gt;std::locale::facet&lt;/a&gt;&lt;/code&gt; 는 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9bd8f9603471cf7f157350f038ce21151ef6f49b" translate="yes" xml:space="preserve">
          <source>2) copy constructor is deleted; &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; is not copyable.</source>
          <target state="translated">2) 복사 생성자가 삭제됩니다. &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; 는 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="396006b0bd215875c55d5929e74c63edfb2ed272" translate="yes" xml:space="preserve">
          <source>2) disables the &lt;code&gt;showbase&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showbase&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showbase&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: showbase&lt;/a&gt; ) 를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;showbase&lt;/code&gt; 플래그를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="ea089be7fb3dd90f719ef73bf77145d14addb599" translate="yes" xml:space="preserve">
          <source>2) disables the &lt;code&gt;showpoint&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpoint&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpoint&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: showpoint&lt;/a&gt; )를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;showpoint&lt;/code&gt; 플래그를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f8d6e35d033a29ee999c97df16b555d1e1f857e0" translate="yes" xml:space="preserve">
          <source>2) disables the &lt;code&gt;showpos&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpos&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpos&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: showpos&lt;/a&gt; ) 를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;showpos&lt;/code&gt; 플래그를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="01e2d044e2d50726f863fa86ebcfc98bb6b76a02" translate="yes" xml:space="preserve">
          <source>2) disables the &lt;code&gt;skipws&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::skipws&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::skipws&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: skipws&lt;/a&gt; ) 를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;skipws&lt;/code&gt; 플래그를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="830ed3861a4df7ae908b1e848e8fa4ea0500a122" translate="yes" xml:space="preserve">
          <source>2) disables the &lt;code&gt;unitbuf&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: unitbuf&lt;/a&gt; ) 를 호출하여 마치 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;unitbuf&lt;/code&gt; 플래그를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="df759cba18f24a52c289d053ce0420ec880cefe1" translate="yes" xml:space="preserve">
          <source>2) disables the &lt;code&gt;uppercase&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::uppercase&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;str.unsetf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::uppercase&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: uppercase&lt;/a&gt; ) 를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 에서 &lt;code&gt;uppercase&lt;/code&gt; 플래그를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="80336a7030dd6d36dd046135aa4d22da3f45e952" translate="yes" xml:space="preserve">
          <source>2) disjunctions</source>
          <target state="translated">2) 이탈</target>
        </trans-unit>
        <trans-unit id="5c21314f84712eeb476d7ec135879bf2bfabaa49" translate="yes" xml:space="preserve">
          <source>2) division</source>
          <target state="translated">2) 구분</target>
        </trans-unit>
        <trans-unit id="8128a517db1b59c5831edee42b0cf151beb26496" translate="yes" xml:space="preserve">
          <source>2) elaborated type specifier for a enumeration type</source>
          <target state="translated">2) 열거 형에 대한 정교한 형식 지정자</target>
        </trans-unit>
        <trans-unit id="8377f82ef52c02c38207b4d52ec015819e7bd77b" translate="yes" xml:space="preserve">
          <source>2) floating-point literal, returns a floating-point duration equivalent to &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::hours&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">2) 부동 소수점 리터럴, &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::hours&lt;/a&gt;&lt;/code&gt; 해당하는 부동 소수점 지속 시간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b12f1f31e0a00498b42c89d5162c64b275deed11" translate="yes" xml:space="preserve">
          <source>2) floating-point literal, returns a floating-point duration equivalent to &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::microseconds&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">2) 부동 소수점 리터럴, &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::microseconds&lt;/a&gt;&lt;/code&gt; 해당하는 부동 소수점 지속 시간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bf29beb4a159551ee80a7ff99c9dff5b717bc0c3" translate="yes" xml:space="preserve">
          <source>2) floating-point literal, returns a floating-point duration equivalent to &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::milliseconds&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">2) 부동 소수점 리터럴, &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::milliseconds&lt;/a&gt;&lt;/code&gt; 해당하는 부동 소수점 지속 시간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0f0d687244388427a907f0080302cf11c3885f50" translate="yes" xml:space="preserve">
          <source>2) floating-point literal, returns a floating-point duration equivalent to &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::minutes&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">2) 부동 소수점 리터럴, &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::minutes&lt;/a&gt;&lt;/code&gt; 해당하는 부동 소수점 지속 시간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7b9aff7642fac0c3d46f0b1ce848886720f4a928" translate="yes" xml:space="preserve">
          <source>2) floating-point literal, returns a floating-point duration equivalent to &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::nanoseconds&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">2) 부동 소수점 리터럴, &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::nanoseconds&lt;/a&gt;&lt;/code&gt; 해당하는 부동 소수점 지속 시간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e222c60ec7dacdbddc32c2115494185b0615426b" translate="yes" xml:space="preserve">
          <source>2) floating-point literal, returns a floating-point duration equivalent to &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">2) 부동 소수점 리터럴, &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt; 해당하는 부동 소수점 지속 시간을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2ee8b074561a5f3f646fcbcedde42cf80cc7620c" translate="yes" xml:space="preserve">
          <source>2) forms a literal &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;float&amp;gt;&lt;/code&gt; with the real part zero and imaginary part &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">2) 실수 부분 0과 허수 부분 &lt;code&gt;arg&lt;/code&gt; 로 리터럴 &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;float&amp;gt;&lt;/code&gt; 를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="79b55506fece8f977c8c2b7f39816a4ddf769c23" translate="yes" xml:space="preserve">
          <source>2) if &lt;code&gt;E2&lt;/code&gt; is a pointer to member function, the result is a special kind of prvalue designating that member function that can only be used as the left-hand operand of a member function call operator, and for no other purpose;</source>
          <target state="translated">2) &lt;code&gt;E2&lt;/code&gt; 가 멤버 함수에 대한 포인터 인 경우 결과는 멤버 함수 호출 연산자의 왼쪽 피연산자로만 사용할 수 있고 다른 목적으로는 사용할 수없는 멤버 함수를 지정하는 특별한 종류의 전치입니다.</target>
        </trans-unit>
        <trans-unit id="3f4528db942063533e667fd6958b5f4ed40d06f3" translate="yes" xml:space="preserve">
          <source>2) if &lt;code&gt;T&lt;/code&gt; is a pointer to member function of class &lt;code&gt;T0&lt;/code&gt; that takes no arguments, then &lt;code&gt;argument_type&lt;/code&gt; is &lt;code&gt;T0*&lt;/code&gt;, possibly cv-qualified</source>
          <target state="translated">2) &lt;code&gt;T&lt;/code&gt; 가 인수를 사용하지 않는 클래스 &lt;code&gt;T0&lt;/code&gt; 의 멤버 함수에 대한 포인터 인 경우 &lt;code&gt;argument_type&lt;/code&gt; 은 &lt;code&gt;T0*&lt;/code&gt; 이며 가능하면 cv-qualified</target>
        </trans-unit>
        <trans-unit id="4d3e032823b314823fde43f6d99a328a7b9894f9" translate="yes" xml:space="preserve">
          <source>2) if &lt;code&gt;T&lt;/code&gt; is a pointer to member function of class &lt;code&gt;T0&lt;/code&gt; that takes one argument &lt;code&gt;A1&lt;/code&gt;, then &lt;code&gt;second_argument_type&lt;/code&gt; is &lt;code&gt;A1&lt;/code&gt;, possibly cv-qualified</source>
          <target state="translated">2) &lt;code&gt;T&lt;/code&gt; 가 하나의 인수 &lt;code&gt;A1&lt;/code&gt; 을 취하는 클래스 &lt;code&gt;T0&lt;/code&gt; 의 멤버 함수에 대한 포인터 인 경우 &lt;code&gt;second_argument_type&lt;/code&gt; 은 &lt;code&gt;A1&lt;/code&gt; 이며 가능하면 cv-qualified</target>
        </trans-unit>
        <trans-unit id="d98e4582962c58e5be233886dc5d9025bc1d8d0c" translate="yes" xml:space="preserve">
          <source>2) if &lt;code&gt;T&lt;/code&gt; is a pointer to member function of class &lt;code&gt;T0&lt;/code&gt; that takes one argument, then &lt;code&gt;first_argument_type&lt;/code&gt; is &lt;code&gt;T0*&lt;/code&gt;, possibly cv-qualified</source>
          <target state="translated">2) &lt;code&gt;T&lt;/code&gt; 가 하나의 인수를 취하는 클래스 &lt;code&gt;T0&lt;/code&gt; 의 멤버 함수에 대한 포인터 인 경우 &lt;code&gt;first_argument_type&lt;/code&gt; 은 &lt;code&gt;T0*&lt;/code&gt; 이며 가능하면 cv-qualified</target>
        </trans-unit>
        <trans-unit id="8f4d29ee073785a8e8a69bfa088887f404fc9621" translate="yes" xml:space="preserve">
          <source>2) if the encoding represented by this &lt;code&gt;codecvt&lt;/code&gt; facet is state-dependent, and &lt;code&gt;state&lt;/code&gt; represents a conversion state that is not the initial shift state, writes the characters necessary to return to the initial shift state. The characters are written to a character array whose first element is pointed to by &lt;code&gt;to&lt;/code&gt;. No more than &lt;code&gt;to_end-to&lt;/code&gt; characters are written. The parameter &lt;code&gt;to_next&lt;/code&gt; is updated to point one past the last character written.</source>
          <target state="translated">2)이 &lt;code&gt;codecvt&lt;/code&gt; 패싯 이 나타내는 인코딩 이 상태에 의존하고 &lt;code&gt;state&lt;/code&gt; 가 초기 시프트 상태가 아닌 변환 상태를 나타내는 경우, 초기 시프트 상태로 돌아 가기 위해 필요한 문자를 씁니다. 문자는 첫 번째 요소가로 가리키는 문자 배열에 기록 &lt;code&gt;to&lt;/code&gt; . 이상 없음 &lt;code&gt;to_end-to&lt;/code&gt; 문자가 기록되지 않습니다. &lt;code&gt;to_next&lt;/code&gt; 매개 변수 는 마지막으로 쓴 문자를 지나치도록 갱신됩니다.</target>
        </trans-unit>
        <trans-unit id="28d8548256bf1d499db58bc732188e8cdc34c77d" translate="yes" xml:space="preserve">
          <source>2) if the encoding represented by this codecvt facet maps each internal character to the same, constant number of external characters, returns that number. If the encoding is variable-length (e.g. UTF-8 or UTF-16), returns &lt;code&gt;​0​&lt;/code&gt;. If the encoding is state-dependent, returns &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">2)이 codecvt 패싯으로 표시되는 인코딩이 각 내부 문자를 동일한 일정한 수의 외부 문자에 맵핑하면 해당 숫자를 리턴합니다. 인코딩이 가변 길이 인 경우 (예 UTF-8 또는 UTF-16), 복귀 &lt;code&gt;​0​&lt;/code&gt; . 인코딩이 상태에 따라 다르면 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="08eeb0877191f1272e5eed218f6c93d52d399e44" translate="yes" xml:space="preserve">
          <source>2) initialization of an object of non-class type with a single brace-enclosed initializer (note: for class types and other uses of braced-init-list, see &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt;)</source>
          <target state="translated">2) 단일 괄호로 묶인 이니셜 라이저로 클래스가 아닌 유형의 객체 초기화 (참고 : 클래스 유형 및 braced-init-list의 다른 용도는 &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="585964c490ac88716b76a845d5cadea440830d95" translate="yes" xml:space="preserve">
          <source>2) initialization of an unnamed temporary with a</source>
          <target state="translated">2) 무명 임시의 초기화</target>
        </trans-unit>
        <trans-unit id="1b6bff53e82250c6f4273af8416bffa5d1585880" translate="yes" xml:space="preserve">
          <source>2) iterator pointing to the character immediately following the character erased, or &lt;code&gt;end()&lt;/code&gt; if no such character exists</source>
          <target state="translated">2) 지워진 문자 바로 다음의 문자를 가리키는 반복자 또는 해당 문자가 없으면 &lt;code&gt;end()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b678b5b22484ed40a0467b3073907ad86d0cfa2" translate="yes" xml:space="preserve">
          <source>2) linear in size of &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;str&lt;/code&gt; 크기의 선형</target>
        </trans-unit>
        <trans-unit id="1a4523cc0aae262f701a5c62cdf70900862b2ab7" translate="yes" xml:space="preserve">
          <source>2) linear in the size of &lt;code&gt;this&lt;/code&gt; (formally, each CharT has to be destroyed). If allocators do not compare equal and do not propagate, then also linear in the size of &lt;code&gt;str&lt;/code&gt; (copy must be made)</source>
          <target state="translated">2) &lt;code&gt;this&lt;/code&gt; 의 크기는 선형이다 (공식적으로, 각 CharT는 파괴되어야한다). 할당자가 동일하게 비교되지 않고 전파되지 않으면 &lt;code&gt;str&lt;/code&gt; 의 크기도 선형입니다 (복사해야 함).</target>
        </trans-unit>
        <trans-unit id="4e280b0c39065f539943713b34d12de8fe15d5b8" translate="yes" xml:space="preserve">
          <source>2) log(a.size())</source>
          <target state="translated">2) 로그 (a.size ())</target>
        </trans-unit>
        <trans-unit id="1379bd25758af5980d6e604ffcaf7e06c26ae1d6" translate="yes" xml:space="preserve">
          <source>2) lvalue of any type &lt;code&gt;T&lt;/code&gt; may be converted to a lvalue or rvalue reference to the same type &lt;code&gt;T&lt;/code&gt;, more or less cv-qualified. Likewise, an rvalue may be converted to a more or less cv-qualified rvalue reference. The result of a reference &lt;code&gt;const_cast&lt;/code&gt; refers to the original object if expression is a glvalue and to the &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized temporary&lt;/a&gt; otherwise(since C++17).</source>
          <target state="translated">2) 임의의 타입 &lt;code&gt;T&lt;/code&gt; 의 lvalue는 다소 cv-qualified 된 동일한 타입 &lt;code&gt;T&lt;/code&gt; 에 대한 lvalue 또는 rvalue 참조로 변환 될 수있다 . 마찬가지로, rvalue는 다소 cv-qualified rvalue 참조로 변환 될 수 있습니다. 참조 &lt;code&gt;const_cast&lt;/code&gt; 의 결과는 표현식이 glvalue이면 원본 객체를 참조 하고 그렇지 않으면 &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;구체화 된 임시를 참조&lt;/a&gt; 합니다 (C ++ 17 이후).</target>
        </trans-unit>
        <trans-unit id="7f9e3952e5b6d2c8c74148b79121eba39f85c9e8" translate="yes" xml:space="preserve">
          <source>2) may throw &lt;code&gt;&lt;a href=&quot;../../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; on bad input.</source>
          <target state="translated">2) 잘못된 입력에 &lt;code&gt;&lt;a href=&quot;../../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa25d9823fb0d85b3d522883742bda293bd67276" translate="yes" xml:space="preserve">
          <source>2) may throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if no characters are extracted from &lt;code&gt;is&lt;/code&gt; (e.g the stream is at end of file, or consists of whitespace only), or if an exception is thrown during input.</source>
          <target state="translated">2) 던질 수 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 어떤 문자가 추출되지 않은 경우 &lt;code&gt;is&lt;/code&gt; (예를 스트림 파일의 끝에, 또는 만 공백으로 구성), 또는 예외가 발생하는 동안 입력되는 경우.</target>
        </trans-unit>
        <trans-unit id="45c022142f0968e893d85127c3f2d5f098a97b3f" translate="yes" xml:space="preserve">
          <source>2) meets the &lt;a href=&quot;../../named_req/transformationtrait&quot;&gt;TransformationTrait&lt;/a&gt; requirements with a member typedef &lt;code&gt;type&lt;/code&gt; equal to the type of the alternative with index &lt;code&gt;I&lt;/code&gt;</source>
          <target state="translated">2) 인덱스 &lt;code&gt;I&lt;/code&gt; 을 가진 대안의 &lt;code&gt;type&lt;/code&gt; 과 동일한 구성원 typedef 유형으로 &lt;a href=&quot;../../named_req/transformationtrait&quot;&gt;TransformationTrait&lt;/a&gt; 요구 사항을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="d8bcea9e674521c4899dd60c9eca9cb5f872efd5" translate="yes" xml:space="preserve">
          <source>2) meets the &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; requirements with a BaseCharacteristic of &lt;code&gt;std::integral_constant&amp;lt;std::size_t, sizeof...(Types)&amp;gt;&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;std::integral_constant&amp;lt;std::size_t, sizeof...(Types)&amp;gt;&lt;/code&gt; 의 &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;기본 특성으로 UnaryTypeTrait&lt;/a&gt; 요구 사항을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="7b0922619c98ef3bf3372e9384eca35939556879" translate="yes" xml:space="preserve">
          <source>2) member functions</source>
          <target state="translated">2) 멤버 함수</target>
        </trans-unit>
        <trans-unit id="fb4b2188b3d1b79a923bf27b35991a95b8e14a70" translate="yes" xml:space="preserve">
          <source>2) namespace-scoped friend functions (and function templates) that are declared in an associated class are visible through ADL even if they are not visible through ordinary lookup</source>
          <target state="translated">2) 관련 클래스에서 선언 된 네임 스페이스 범위의 친구 함수 (및 함수 템플릿)는 일반 조회를 통해 보이지 않더라도 ADL을 통해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d915fbc4ed419e4439c5ad936fe45e0dedcaae04" translate="yes" xml:space="preserve">
          <source>2) negated argument, &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(-val.real(), -val.imag())&lt;/code&gt;</source>
          <target state="translated">2) 부정 인수, &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(-val.real(), -val.imag())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16e923e3764201cfaef48dd9a7a680923e571a7c" translate="yes" xml:space="preserve">
          <source>2) non-void specialization, used to communicate objects between threads</source>
          <target state="translated">2) 공허하지 않은 특수화, 스레드 간 객체 통신에 사용</target>
        </trans-unit>
        <trans-unit id="3d1c3db64b3d601282a0882fa99ed29819cb2aef" translate="yes" xml:space="preserve">
          <source>2) none.</source>
          <target state="translated">2) 없음</target>
        </trans-unit>
        <trans-unit id="97c56d63e57e1af1443f0668c051f87f45a87914" translate="yes" xml:space="preserve">
          <source>2) on the right-hand-side of an assignment expression</source>
          <target state="translated">2) 대입 식의 오른쪽</target>
        </trans-unit>
        <trans-unit id="39de1086ff80ca534b5ee60f09d0d884373b7078" translate="yes" xml:space="preserve">
          <source>2) op ...) op E</source>
          <target state="translated">2) op ...) op E</target>
        </trans-unit>
        <trans-unit id="dacfb6cd3e6ec129fc896095f6537b2598811395" translate="yes" xml:space="preserve">
          <source>2) or, if not that, (only in context of non-class initialization by conversion), the standard conversion sequence from the return type of F1 to the type being initialized is</source>
          <target state="translated">2) 또는 그렇지 않은 경우 (변환에 의한 비 클래스 초기화의 컨텍스트에서만) 반환 유형 F1에서 초기화되는 유형으로의 표준 변환 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="42eeea1f07d3ce5dda592abea703417ac1f6924d" translate="yes" xml:space="preserve">
          <source>2) p made proximate against base</source>
          <target state="translated">2) p는베이스에 근접하여 만들어 짐</target>
        </trans-unit>
        <trans-unit id="645ee1721eafcc6400b43f5e73a9f28be73534dc" translate="yes" xml:space="preserve">
          <source>2) postfix decrement (post-decrement)</source>
          <target state="translated">2) 접미사 감소 (사후 감소)</target>
        </trans-unit>
        <trans-unit id="499d2c537c0841899b7c2716bd8ba882c873094b" translate="yes" xml:space="preserve">
          <source>2) prefix decrement (pre-decrement)</source>
          <target state="translated">2) 접두사 감소 (사전 감소)</target>
        </trans-unit>
        <trans-unit id="2908071c8896ac2f011ed5dcba01e5a36aebb624" translate="yes" xml:space="preserve">
          <source>2) removes the topmost &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">2) 최상위 &lt;code&gt;const&lt;/code&gt; 를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="8d00c166bfa15f423524d248b38172b36c084eb2" translate="yes" xml:space="preserve">
          <source>2) replaces current settings with given ones.</source>
          <target state="translated">2) 현재 설정을 지정된 설정으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="4db887dd9860a46694236e4cae62ff9e065fb444" translate="yes" xml:space="preserve">
          <source>2) replaces the associated byte stream with &lt;code&gt;bytebuf&lt;/code&gt; .</source>
          <target state="translated">2) 관련 바이트 스트림을 &lt;code&gt;bytebuf&lt;/code&gt; 로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="2fe6d5892d176d177b26eff6ead780f12b24b413" translate="yes" xml:space="preserve">
          <source>2) returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;false&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="71e3b774300d2eebd3845a90f2b9e3f07562f569" translate="yes" xml:space="preserve">
          <source>2) returns &lt;code&gt;static_cast&amp;lt;const OuterAlloc&amp;amp;&amp;gt;(*this)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;static_cast&amp;lt;const OuterAlloc&amp;amp;&amp;gt;(*this)&lt;/code&gt; )를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c8070e737f861b063b5a5931976bab26eba33624" translate="yes" xml:space="preserve">
          <source>2) returns &lt;code&gt;std::u8string_view{str, len}&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;std::u8string_view{str, len}&lt;/code&gt; 반환합니다</target>
        </trans-unit>
        <trans-unit id="741e74c6d31e5f009d234037c3e5515d65a95079" translate="yes" xml:space="preserve">
          <source>2) returns &lt;code&gt;std::u8string{str, len}&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;std::u8string{str, len}&lt;/code&gt; 반환합니다</target>
        </trans-unit>
        <trans-unit id="72cef41fc2856e5795da50c38e552f85c1551ef4" translate="yes" xml:space="preserve">
          <source>2) right shift of lhs by rhs bits</source>
          <target state="translated">2) rhs 비트에 의한 lh의 우측 시프트</target>
        </trans-unit>
        <trans-unit id="4b78590ed44f9576a3024115fa5bf682c65bbc4e" translate="yes" xml:space="preserve">
          <source>2) rvalues can be bound to non-const implicit object parameter (unless this is for a ref-qualified member function)(since C++11) and do not affect the ranking of the implicit conversions.</source>
          <target state="translated">2) rvalue는 const가 아닌 암시 적 객체 매개 변수에 바인딩 될 수 있습니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="4983d8348f815ac7500fbb734db536a9ef8cbf55" translate="yes" xml:space="preserve">
          <source>2) same as (1), but the evaluation of the assignment expression will not call any operation that is not trivial. For the purposes of this check, a call to &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; is considered trivial and not considered an &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-use&lt;/a&gt; of &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">2) (1)과 동일하지만 대입 식의 평가는 사소하지 않은 연산을 호출하지 않습니다. 이 검사의 목적에 대한 호출 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; 사소한 것으로 간주하고 고려하지 &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;ODR 사용&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="040bf5037ee6e2b0b7c99f42d9d6e90979f99631" translate="yes" xml:space="preserve">
          <source>2) same as 1), and additionally &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; is either a non-class type or a class type with a trivial destructor.</source>
          <target state="translated">2) 1)과 동일하며 추가적으로 &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; 은 비 클래스 타입이거나 간단한 소멸자를 가진 클래스 타입입니다.</target>
        </trans-unit>
        <trans-unit id="5fde760dde32ffe3dbeb0423cd83e67b12e713fb" translate="yes" xml:space="preserve">
          <source>2) same as 1), but the formatted replacement is performed as if by calling &lt;a href=&quot;match_results/format&quot;&gt;&lt;code&gt;out = m.format(out, fmt, fmt + char_traits&amp;lt;charT&amp;gt;::length(fmt), flags)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">2) 1)과 동일하지만 &lt;a href=&quot;match_results/format&quot;&gt; &lt;code&gt;out = m.format(out, fmt, fmt + char_traits&amp;lt;charT&amp;gt;::length(fmt), flags)&lt;/code&gt; &lt;/a&gt; 를 호출 하는 것처럼 형식이 지정된 교체가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fa0f781ec9fd767be727083ea0b6bc0d022b3634" translate="yes" xml:space="preserve">
          <source>2) same as 1), but the variable definition does not call any operation that is not trivial. For the purposes of this check, the call to &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; is considered trivial.</source>
          <target state="translated">2) 1)과 동일하지만 변수 정의는 사소하지 않은 연산을 호출하지 않습니다. 이 검사의 목적 상 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; 대한 호출 은 사소한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="9bf77a6ee39f03c968c06bdd069b8f0fab44acc1" translate="yes" xml:space="preserve">
          <source>2) sets the &lt;code&gt;adjustfield&lt;/code&gt; of the stream &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;right&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::right&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::right&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: right&lt;/a&gt; , &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: adjustfield&lt;/a&gt; ) 를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 의 &lt;code&gt;adjustfield&lt;/code&gt; 를 &lt;code&gt;right&lt;/code&gt; 으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="6ea314d9ffcbac359db2b200393e32fbd3767e53" translate="yes" xml:space="preserve">
          <source>2) sets the &lt;code&gt;basefield&lt;/code&gt; of the stream &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;hex&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::hex&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::basefield&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">2) 설정 &lt;code&gt;basefield&lt;/code&gt; 스트림의 &lt;code&gt;str&lt;/code&gt; 에 &lt;code&gt;hex&lt;/code&gt; 것처럼 호출 &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::hex&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::basefield&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd06baac4e12d446a33abcc0a3f84fb823191950" translate="yes" xml:space="preserve">
          <source>2) sets the fill character to &lt;code&gt;ch&lt;/code&gt;, returns previous value of the fill character</source>
          <target state="translated">2) 채우기 문자를 &lt;code&gt;ch&lt;/code&gt; 로 설정하고 채우기 문자의 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5544c78645ec7a0b4e796edd30f176b5b185272d" translate="yes" xml:space="preserve">
          <source>2) sets the input position indicator to position &lt;code&gt;off&lt;/code&gt;, relative to position, defined by &lt;code&gt;dir&lt;/code&gt;. Specifically, executes &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(off, dir, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">2) 입력 위치 표시기를 &lt;code&gt;dir&lt;/code&gt; 로 정의 된 위치를 기준으로 위치 &lt;code&gt;off&lt;/code&gt; 로 설정합니다 . 특히 &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(off, dir, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/openmode&quot;&gt;std :: ios_base :: in&lt;/a&gt; )을 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="9c863ac3c9ba4c51f67bffe142fd6d2825fa6de7" translate="yes" xml:space="preserve">
          <source>2) sets the output position indicator to offset &lt;code&gt;off&lt;/code&gt; relative to &lt;code&gt;dir&lt;/code&gt; by calling &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(off, dir, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(off, dir, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/openmode&quot;&gt;std :: ios_base :: out&lt;/a&gt; ) 을 호출 하여 출력 위치 표시기를 &lt;code&gt;dir&lt;/code&gt; 에 대해 오프셋 &lt;code&gt;off&lt;/code&gt; 하도록 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="422c09505cfb974f530d194e14890378649b74da" translate="yes" xml:space="preserve">
          <source>2) simple by-copy capture that is a &lt;a href=&quot;parameter_pack&quot;&gt;pack expansion&lt;/a&gt;</source>
          <target state="translated">2) &lt;a href=&quot;parameter_pack&quot;&gt;팩 확장 인&lt;/a&gt; 간단한 복사 방지 캡처</target>
        </trans-unit>
        <trans-unit id="62337324964c46f8ae9d574acd9e8ea18781c64c" translate="yes" xml:space="preserve">
          <source>2) substring &lt;code&gt;[pos2, pos2 + count2)&lt;/code&gt; of &lt;code&gt;str&lt;/code&gt;, except if &lt;code&gt;count2==npos&lt;/code&gt; or if would extend past &lt;code&gt;str.size()&lt;/code&gt;, &lt;code&gt;[pos2, str.size())&lt;/code&gt; is used.</source>
          <target state="translated">2) 서브 스트링 &lt;code&gt;[pos2, pos2 + count2)&lt;/code&gt; 의 &lt;code&gt;str&lt;/code&gt; 경우를 제외 &lt;code&gt;count2==npos&lt;/code&gt; 또는 과거 연장한다면 &lt;code&gt;str.size()&lt;/code&gt; , &lt;code&gt;[pos2, str.size())&lt;/code&gt; 에 사용된다.</target>
        </trans-unit>
        <trans-unit id="cb0d0968e5aceea7da38db43e4ede65eb85ea624" translate="yes" xml:space="preserve">
          <source>2) subtraction</source>
          <target state="translated">2) 빼기</target>
        </trans-unit>
        <trans-unit id="85eba9dd44e727bee6ef5572598d349081d2c4ed" translate="yes" xml:space="preserve">
          <source>2) terminate the program (e.g. by calling &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">2) 프로그램 종료 (예 : &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 호출 )</target>
        </trans-unit>
        <trans-unit id="2e38f68a7a5ee1660aed123acffe528717b1858a" translate="yes" xml:space="preserve">
          <source>2) the &lt;a href=&quot;fe_round&quot;&gt;floating point rounding macro&lt;/a&gt; describing the current rounding direction or a negative value if the direction cannot be determined.</source>
          <target state="translated">2) 현재 반올림 방향을 나타내는 &lt;a href=&quot;fe_round&quot;&gt;부동 소수점 반올림 매크로&lt;/a&gt; 또는 방향을 결정할 수없는 경우 음수 값.</target>
        </trans-unit>
        <trans-unit id="61cdf37d9e22d6701ff8a91312cc3be8a510bbc3" translate="yes" xml:space="preserve">
          <source>2) the equals sign followed by an expression</source>
          <target state="translated">2) 등호 뒤에 표현식</target>
        </trans-unit>
        <trans-unit id="6849194d4d225f049cba72ebb81aec654d5b7f9c" translate="yes" xml:space="preserve">
          <source>2) the exception thrown by &lt;code&gt;std::unexpected_handler&lt;/code&gt; still violates the exception specification:</source>
          <target state="translated">2) &lt;code&gt;std::unexpected_handler&lt;/code&gt; 던진 예외는 여전히 예외 스펙을 위반합니다.</target>
        </trans-unit>
        <trans-unit id="d732e7f4be12377ae50409a2eaff4e24e66a812f" translate="yes" xml:space="preserve">
          <source>2) the integral number of minutes &lt;code&gt;since_midnight&lt;/code&gt; is after &lt;code&gt;(00:00:00 + hours())&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;since_midnight&lt;/code&gt; 의 정수 분 은 &lt;code&gt;(00:00:00 + hours())&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="63345f37c9e05c2005df6177be1f792d4d248c46" translate="yes" xml:space="preserve">
          <source>2) the prefix is a single character</source>
          <target state="translated">2) 접두사는 단일 문자입니다</target>
        </trans-unit>
        <trans-unit id="bfa7f660ebffe298de690d4fab7feb1a53102985" translate="yes" xml:space="preserve">
          <source>2) the prefix is a single character. Effectively returns &lt;code&gt;!empty() &amp;amp;&amp;amp; Traits::eq(front(), x)&lt;/code&gt;</source>
          <target state="translated">2) 접두사는 단일 문자입니다. 효과적으로 &lt;code&gt;!empty() &amp;amp;&amp;amp; Traits::eq(front(), x)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6702473a4d8bb1b1d89df01f1d19448729deb164" translate="yes" xml:space="preserve">
          <source>2) the previous byte stream.</source>
          <target state="translated">2) 이전 바이트 스트림</target>
        </trans-unit>
        <trans-unit id="28f08b05497ffb72cbe3e2c7c0b6212dfa1f47ff" translate="yes" xml:space="preserve">
          <source>2) the static version of the initialization produces the same value in the initialized variable as would be produced by the dynamic initialization if all variables not required to be initialized statically were initialized dynamically.</source>
          <target state="translated">2) 정적 버전의 초기화는 정적 초기화에 필요하지 않은 모든 변수가 동적으로 초기화 된 경우 동적 초기화에 의해 생성 된 초기화 변수에서 동일한 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8d94628f33dfdde218a3cdc0aaec377ed0669117" translate="yes" xml:space="preserve">
          <source>2) the suffix is a single character</source>
          <target state="translated">2) 접미사는 단일 문자입니다</target>
        </trans-unit>
        <trans-unit id="620c5465e17ddd3a791e6b26fc6d5cca3448c79c" translate="yes" xml:space="preserve">
          <source>2) the suffix is a single character. Effectively returns &lt;code&gt;!empty() &amp;amp;&amp;amp; Traits::eq(back(), x)&lt;/code&gt;</source>
          <target state="translated">2) 접미사는 단일 문자입니다. 효과적으로 &lt;code&gt;!empty() &amp;amp;&amp;amp; Traits::eq(back(), x)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="30957c44c756ec33162837ef900bb78b3e525036" translate="yes" xml:space="preserve">
          <source>2) throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos&lt;/code&gt; does not correspond to a valid position within the bitset.</source>
          <target state="translated">2) 발생 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;pos&lt;/code&gt; 가 비트 세트 내의 유효한 위치에 해당하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="083e3f94c31c2f99fb9a39f11563a44aae36fff7" translate="yes" xml:space="preserve">
          <source>2) total size of the new array would exceed implementation-defined maximum value.</source>
          <target state="translated">2) 새 어레이의 총 크기는 구현 정의 최대 값을 초과합니다.</target>
        </trans-unit>
        <trans-unit id="18b66566486cc99d527e4485b441b36c5c6fe953" translate="yes" xml:space="preserve">
          <source>2) unary left fold</source>
          <target state="translated">2) 단항 왼쪽 접기</target>
        </trans-unit>
        <trans-unit id="96201f4eb7637c46af19688b2e4dde22bd2fd7ab" translate="yes" xml:space="preserve">
          <source>2) unary minus (negation).</source>
          <target state="translated">2) 단항 빼기 (음수).</target>
        </trans-unit>
        <trans-unit id="b2f68d3087fdc4bafce8692c0f66f6935f2ad59e" translate="yes" xml:space="preserve">
          <source>2) value is converted to a string as if by &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; in the default (&quot;C&quot;) locale. The conversion specifier is &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;e&lt;/code&gt; (resolving in favor of &lt;code&gt;f&lt;/code&gt; in case of a tie), chosen according to the requirement for a shortest representation: the string representation consists of the smallest number of characters such that there is at least one digit before the radix point (if present) and parsing the representation using the corresponding &lt;a href=&quot;from_chars&quot;&gt;&lt;code&gt;std::from_chars&lt;/code&gt;&lt;/a&gt; function recovers value exactly. If there are several such representations, one with the smallest difference to &lt;code&gt;value&lt;/code&gt; is chosen, resolving any remaining ties using rounding according to &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/float_round_style&quot;&gt;std::round_to_nearest&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">2) 값은 기본 ( &quot;C&quot;) 로케일에서 &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; 에 의해 문자열로 변환 됩니다. 변환 지정자는 &lt;code&gt;f&lt;/code&gt; 또는 &lt;code&gt;e&lt;/code&gt; ( 동점 인 경우 &lt;code&gt;f&lt;/code&gt; 를 선호 함 )이며 가장 짧은 표현의 요구 사항에 따라 선택됩니다. 문자열 표현은 가장 작은 숫자로 구성되어 있습니다. 기수 점 (있는 경우)을 표시하고 해당 &lt;a href=&quot;from_chars&quot;&gt; &lt;code&gt;std::from_chars&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 표현을 구문 분석하면 값이 정확하게 복구됩니다. 그러한 표현이 여러 개인 경우, &lt;code&gt;value&lt;/code&gt; 과의 차이가 가장 작은 것이 선택되어 &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/float_round_style&quot;&gt;std::round_to_nearest&lt;/a&gt;&lt;/code&gt; 에 따라 반올림을 사용하여 나머지 관계를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="cf3e79486507c8bb6a0d07aedec8a96331370665" translate="yes" xml:space="preserve">
          <source>2) when an object with dynamic storage duration is created by a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; with no initializer or when an object is created by a new-expression with the initializer consisting of an empty pair of parentheses(until C++03);</source>
          <target state="translated">2) 동적 저장 시간을 갖는 객체가 이니셜 라이저가없는 &lt;a href=&quot;new&quot;&gt;새로운 표현식에&lt;/a&gt; 의해 생성 되거나 이니셜 라이저가 빈 괄호 쌍으로 구성된 새로운 표현식에 의해 생성 된 경우 (C ++ 03까지);</target>
        </trans-unit>
        <trans-unit id="0b6215cf3787fe42bfd61b320c1fbb2949360c37" translate="yes" xml:space="preserve">
          <source>2) when the &lt;a href=&quot;overloaded_address&quot;&gt;address of a function template specialization&lt;/a&gt; is taken</source>
          <target state="translated">2) &lt;a href=&quot;overloaded_address&quot;&gt;기능 템플릿 전문화&lt;/a&gt; 의 주소 가 취해진 경우</target>
        </trans-unit>
        <trans-unit id="309961c401f19c5969dc3218b3cbe7bde15a51e3" translate="yes" xml:space="preserve">
          <source>2) within the &lt;a href=&quot;function&quot;&gt;declaration&lt;/a&gt; of a non-static member function anywhere after the (optional) cv-qualifier sequence, including &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(deprecated), &lt;a href=&quot;noexcept_spec&quot;&gt;noexcept specification&lt;/a&gt;(C++11), and the trailing return type(since C++11)</source>
          <target state="translated">2) &lt;a href=&quot;except_spec&quot;&gt;동적 예외 사양&lt;/a&gt; (더 이상 사용되지 않음), &lt;a href=&quot;noexcept_spec&quot;&gt;noexcept 사양&lt;/a&gt; (C ++ 11) 및 후행 반환 유형 (C ++ 이후 )을 포함하여 (선택적) cv 한정자 시퀀스 이후의 임의 위치에서 비 정적 멤버 함수 &lt;a href=&quot;function&quot;&gt;선언&lt;/a&gt; 11)</target>
        </trans-unit>
        <trans-unit id="7bc012a5869f0d7cc3571080bd458da9a19bcb7f" translate="yes" xml:space="preserve">
          <source>2) zero or one</source>
          <target state="translated">2) 0 또는 1</target>
        </trans-unit>
        <trans-unit id="b68032e197ec2f3a82f44aed13bbe55f177daa36" translate="yes" xml:space="preserve">
          <source>2)(until C++11)when a named variable of a scalar type &lt;code&gt;T&lt;/code&gt; is declared with the initializer consisting of an equals sign followed by a brace-enclosed expression (Note: as of C++11, this is classified as &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt;, and narrowing conversion is not allowed).</source>
          <target state="translated">2) (C ++ 11까지) 스칼라 타입 &lt;code&gt;T&lt;/code&gt; 의 명명 된 변수가 등호로 구성되고 이괄 호로 묶은 표현식으로 구성된 이니셜 라이저로 선언 될 때 (주 : C ++ 11부터는 &lt;a href=&quot;list_initialization&quot;&gt;목록&lt;/a&gt; 으로 분류 됨 초기화 및 축소 변환은 허용되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="c98e8d57709194b724950d3113eba02c58efa92c" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt;;</source>
          <target state="translated">2) &lt;a href=&quot;cast_operator&quot;&gt;사용자 정의 변환 기능&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="91986c83bc299300b48be931117bb4e5bb08ac39" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt; in the statement will execute iteration_expression</source>
          <target state="translated">2) 명령문에서 &lt;a href=&quot;continue&quot;&gt;계속&lt;/a&gt; iteration_expression을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a33439daf73c7fbc692eaa66fa48355cfaeecb68" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt; statement;</source>
          <target state="translated">2) &lt;a href=&quot;continue&quot;&gt;계속&lt;/a&gt; 진술;</target>
        </trans-unit>
        <trans-unit id="b01e8220c5eaa6f43f0caa381375a0b71590a265" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop;</source>
          <target state="translated">2) &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; 루프;</target>
        </trans-unit>
        <trans-unit id="f5c2df16cf17af221fc1d03b553776874dc28aef" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;escape&quot;&gt;Escape sequences&lt;/a&gt; and universal character names in character literals and non-raw string literals are expanded and converted to the</source>
          <target state="translated">2) 문자 리터럴 및 비원시 문자열 리터럴의 &lt;a href=&quot;escape&quot;&gt;이스케이프 시퀀스&lt;/a&gt; 및 범용 문자 이름이 확장되어</target>
        </trans-unit>
        <trans-unit id="51138821a0d6f922459861204dc6af4353b9aef7" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; (which is a regular function body wrapped in a try/catch block)</source>
          <target state="translated">2) &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; (try / catch 블록에 싸여있는 일반 함수 본문)</target>
        </trans-unit>
        <trans-unit id="eec7dc365cda0c10c4fff1e5f84f467fccf9fe50" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; statement with an else clause;</source>
          <target state="translated">2) else 절이있는 &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; 문</target>
        </trans-unit>
        <trans-unit id="a9a965269fa27f6f5a50240a851257ecf688076a" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;namespace#Inline_namespaces&quot;&gt;Inline namespace definition&lt;/a&gt; for the namespace ns_name. Declarations inside ns_name will be visible in its enclosing namespace.</source>
          <target state="translated">2) 네임 스페이스 ns_name에 대한 &lt;a href=&quot;namespace#Inline_namespaces&quot;&gt;인라인 네임 스페이스 정의&lt;/a&gt; . ns_name 내부의 선언은 둘러싸는 네임 스페이스에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="188a0d073dc039d6e86eac5be9dd98834331e16d" translate="yes" xml:space="preserve">
          <source>2)&lt;a href=&quot;this&quot;&gt;&lt;code&gt;*this&lt;/code&gt;&lt;/a&gt; is odr-used if &lt;code&gt;this&lt;/code&gt; appears as a</source>
          <target state="translated">2) &lt;a href=&quot;this&quot;&gt; &lt;code&gt;*this&lt;/code&gt; &lt;/a&gt; ODR 사용되는 경우이며 &lt;code&gt;this&lt;/code&gt; A와 나타날</target>
        </trans-unit>
        <trans-unit id="167daa046c9063e2ff86329a1abd25df65a907cb" translate="yes" xml:space="preserve">
          <source>2)&lt;b&gt;Pointer to member declarator&lt;/b&gt;: the declaration &lt;code&gt;S C::* D;&lt;/code&gt; declares &lt;code&gt;D&lt;/code&gt; as a pointer to non-static member of &lt;code&gt;C&lt;/code&gt; of type determined by decl-specifier-seq&lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">2) &lt;b&gt;멤버 선언자에&lt;/b&gt; 대한 &lt;b&gt;포인터&lt;/b&gt; : 선언 &lt;code&gt;S C::* D;&lt;/code&gt; decl-specifier-seq &lt;code&gt;S&lt;/code&gt; 에 의해 결정된 &lt;code&gt;C&lt;/code&gt; 유형 의 비 정적 멤버에 대한 포인터로 &lt;code&gt;D&lt;/code&gt; 를 선언 합니다 .</target>
        </trans-unit>
        <trans-unit id="61f159f773894aa1dfa2d0261f590d402930ff0d" translate="yes" xml:space="preserve">
          <source>2)&lt;b&gt;Promotion&lt;/b&gt;: integral promotion, floating-point promotion</source>
          <target state="translated">2) &lt;b&gt;프로모션&lt;/b&gt; : 통합 프로모션, 부동 소수점 프로모션</target>
        </trans-unit>
        <trans-unit id="20497d82cd2021b3351ca3f338cd20fcfa75f8d7" translate="yes" xml:space="preserve">
          <source>2)&lt;b&gt;Read-read coherence&lt;/b&gt;: if a value computation A of some atomic M (a read)</source>
          <target state="translated">2) &lt;b&gt;읽기-읽기 일관성&lt;/b&gt; : 일부 원자 M의 값 계산 A (읽기)</target>
        </trans-unit>
        <trans-unit id="a1f77cbb89c6cb2d76ae40c6c9354f6b5cf1ed3e" translate="yes" xml:space="preserve">
          <source>2)&lt;b&gt;Rvalue reference declarator&lt;/b&gt;: the declaration &lt;code&gt;S&amp;amp;&amp;amp; D;&lt;/code&gt; declares &lt;code&gt;D&lt;/code&gt; as an</source>
          <target state="translated">2) &lt;b&gt;Rvalue 참조 선언자&lt;/b&gt; : 선언 &lt;code&gt;S&amp;amp;&amp;amp; D;&lt;/code&gt; 선언 &lt;code&gt;D&lt;/code&gt; 는 int로서</target>
        </trans-unit>
        <trans-unit id="17aa2b86cd788ca1bca9d7dc2dc4748a8898c88c" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;!(a == b)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;!(a == b)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68d0b5297e5c8c8128bb182e4423740892d91c7a" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;!(lhs == rhs)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;!(lhs == rhs)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4d0f7d78504e926245fc71573216fb642484916" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;!(x == y)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;!(x == y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="209c1b247609e7892d029b3ba1cf5a71fa9e1033" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;!(x == y)&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;!(x == y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ac5cc2c6f8787cccabf54bfdcf6c6c7da70ac51" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;&quot;C&quot;&lt;/code&gt;, which makes it possible to link with functions written in the C programming language, and to define, in a C++ program, functions that can be called from the modules written in C.</source>
          <target state="translated">2) &lt;code&gt;&quot;C&quot;&lt;/code&gt; -C 프로그래밍 언어로 작성된 함수와 링크하고 C ++ 프로그램에서 C로 작성된 모듈에서 호출 할 수있는 함수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efa2f1dfeca7c20055549fb5a0e6e60b313f6708" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;&amp;amp;a[i+j] == &amp;amp;a[i] + j&lt;/code&gt; This means that valarray elements are adjacent in memory.</source>
          <target state="translated">2) &lt;code&gt;&amp;amp;a[i+j] == &amp;amp;a[i] + j&lt;/code&gt; 이는 valarray 요소가 메모리에 인접 해 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c663ca95a48b238acac9a191fcaf1233ad371a51" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;&lt;a href=&quot;../c/fgetc&quot;&gt;std::fgetc&lt;/a&gt;(f)&lt;/code&gt; and &lt;code&gt;str.rdbuf()-&amp;gt;sbumpc()&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../c/fgetc&quot;&gt;std::fgetc&lt;/a&gt;(f)&lt;/code&gt; 및 &lt;code&gt;str.rdbuf()-&amp;gt;sbumpc()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03dc35247d364d06cd2ed344c06491dcca58915d" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if required additional memory could not be obtained. May throw implementation-defined exception for other errors. &lt;code&gt;delete ptr&lt;/code&gt; is called if an exception occurs.</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 필요한 경우 추가 메모리를 확보 할 수 없습니다. 다른 오류에 대해서는 구현 정의 예외가 발생할 수 있습니다. 예외가 발생하면 &lt;code&gt;delete ptr&lt;/code&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="21b412f899d6bd8e2db71c5f644078ec3ba1fff8" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;&lt;a href=&quot;../weekday_last&quot;&gt;std::chrono::weekday_last&lt;/a&gt;(*this)&lt;/code&gt;</source>
          <target state="translated">2)&lt;code&gt;&lt;a href=&quot;../weekday_last&quot;&gt;std::chrono::weekday_last&lt;/a&gt;(*this)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6a8d61a4904228a32c2542301d01e717400a174" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;&lt;a href=&quot;../year&quot;&gt;std::chrono::year&lt;/a&gt;(-int(*this))&lt;/code&gt;</source>
          <target state="translated">2)&lt;code&gt;&lt;a href=&quot;../year&quot;&gt;std::chrono::year&lt;/a&gt;(-int(*this))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9da2081446b74e8533d68b5bed358389c881ed97" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, &lt;a href=&quot;system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&amp;gt;{}(&lt;br/&gt; &lt;p&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;&lt;a href=&quot;system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;, &lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_clock&lt;/a&gt;&amp;gt;{}(&lt;br/&gt; &lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;.&lt;/p&gt;
&amp;lt;&lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_clock&lt;/a&gt;, Source&amp;gt;{}(t)))&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, &lt;a href=&quot;system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&amp;gt;{}(&lt;br/&gt; &lt;p&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;&lt;a href=&quot;system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;, &lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_clock&lt;/a&gt;&amp;gt;{}(&lt;br/&gt; &lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;.&lt;/p&gt; &amp;lt;&lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_clock&lt;/a&gt;, Source&amp;gt;{}(t)))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bdc15719dd74f0c6f4f73fa3a42e8e5560d74df" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, &lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_clock&lt;/a&gt;&amp;gt;{}(&lt;br/&gt; &lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;&lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_clock&lt;/a&gt;, Source&amp;gt;{}(t))&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, &lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_clock&lt;/a&gt;&amp;gt;{}(&lt;br/&gt; &lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;&lt;a href=&quot;utc_clock&quot;&gt;std::chrono::utc_clock&lt;/a&gt;, Source&amp;gt;{}(t))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fd0a1f3909570ced0b9ae890fc9b11f99be42db" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;&lt;a href=&quot;year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(y, &lt;a href=&quot;month&quot;&gt;std::chrono::month&lt;/a&gt;(m))&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;&lt;a href=&quot;year_month&quot;&gt;std::chrono::year_month&lt;/a&gt;(y, &lt;a href=&quot;month&quot;&gt;std::chrono::month&lt;/a&gt;(m))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="acd9d7e3b8118ba59ea394984d0f99cabfe6ecf8" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;CD(CD(lhs).count() - CD(rhs).count())&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;CD(CD(lhs).count() - CD(rhs).count())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6534086490d8319b71fa9e9d4a9d0d77a3840b06" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;O(N log N)&lt;/code&gt; swaps &lt;code&gt;and O(N)&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">2) 술어의 &lt;code&gt;O(N log N)&lt;/code&gt; 스왑 &lt;code&gt;and O(N)&lt;/code&gt; 응용 프로그램.</target>
        </trans-unit>
        <trans-unit id="7ef2cb96bd5ccf1761333f5951c2e5db040dcda2" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;O(N log N)&lt;/code&gt; swaps and &lt;code&gt;O(N)&lt;/code&gt; applications of the predicate</source>
          <target state="translated">2) 술어의 &lt;code&gt;O(N log N)&lt;/code&gt; 스왑 및 &lt;code&gt;O(N)&lt;/code&gt; 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="3d75bb5849e659c2d768f741007272a5d59e85c6" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;T&lt;/code&gt; has a constructor which takes &lt;code&gt;Alloc&lt;/code&gt; as the last argument.</source>
          <target state="translated">2) &lt;code&gt;T&lt;/code&gt; 에는 &lt;code&gt;Alloc&lt;/code&gt; 을 마지막 인수로 사용 하는 생성자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e17b88d3502f3955838e6da2af2c9bb9a1f0be1" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;atomic_ref&lt;/code&gt; is not &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">2) &lt;code&gt;atomic_ref&lt;/code&gt; 는 없다 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df09275d22528baad4008ee4c1661aebfd696ae3" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt; except when deduced from a brace-enclosed initializer list:</source>
          <target state="translated">2) &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt; 중괄호로 묶인 초기화 목록에서 추론 할 때를 제외하고 :</target>
        </trans-unit>
        <trans-unit id="bdf62302556c80a37217ea882bfdeb070d3a3b9a" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;bitset&amp;lt;N&amp;gt;(lhs) |= rhs&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;bitset&amp;lt;N&amp;gt;(lhs) |= rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e8de1aa93764c63662e23a0edbf0abcb986bed0" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;cmp != 0&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;cmp != 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce8a5a15e0bb9875702e4b0d55ed84209615564e" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;dangling&lt;/code&gt; can be constructed from arguments of arbitrary number and arbitrary non-void type. The construction does not have any side-effect itself.</source>
          <target state="translated">2) &lt;code&gt;dangling&lt;/code&gt; 은 임의의 수와 임의의 비 공백 유형의 인수로 구성 할 수 있습니다. 건축 자체에는 부작용이 없습니다.</target>
        </trans-unit>
        <trans-unit id="fc3f48befd81e28228ddc5beb272800d1793f5a1" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">2)&lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ccc3be7b97f38d22a1e17f0b013935646b992a0a" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;false&lt;/code&gt; if the path is absolute, &lt;code&gt;true&lt;/code&gt; otherwise.</source>
          <target state="translated">2) 경로가 절대 &lt;code&gt;true&lt;/code&gt; &lt;code&gt;false&lt;/code&gt; , 그렇지 않으면 true</target>
        </trans-unit>
        <trans-unit id="03e0208607adbd050c3d708e8ff2fd0e1c9f6ce3" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;false&lt;/code&gt; if the predicate &lt;code&gt;pred&lt;/code&gt; still evaluates to &lt;code&gt;false&lt;/code&gt; after the &lt;code&gt;rel_time&lt;/code&gt; timeout expired, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;false&lt;/code&gt; 술어가있는 경우 &lt;code&gt;pred&lt;/code&gt; 아직 평가 &lt;code&gt;false&lt;/code&gt; 애프터 &lt;code&gt;rel_time&lt;/code&gt; 의 제한 시간이 만료 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2937f73af771d7d2711fc006ab6b9eb827e0884c" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;false&lt;/code&gt; if the predicate &lt;code&gt;pred&lt;/code&gt; still evaluates to &lt;code&gt;false&lt;/code&gt; after the &lt;code&gt;timeout_time&lt;/code&gt; timeout expired, otherwise &lt;code&gt;true&lt;/code&gt;. If the timeout had already expired, evaluates and returns the result of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;false&lt;/code&gt; 술어가있는 경우 &lt;code&gt;pred&lt;/code&gt; 아직 평가 &lt;code&gt;false&lt;/code&gt; 애프터 &lt;code&gt;timeout_time&lt;/code&gt; 의 제한 시간이 만료 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; . 제한 시간이 이미 만료 된 경우 &lt;code&gt;pred&lt;/code&gt; 의 결과를 평가하고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c5b309196039b593e5bde33ca66e5d1ebc71780a" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;from_stream(is, fmt.c_str(), tp, &lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(abbrev))&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;from_stream(is, fmt.c_str(), tp, &lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(abbrev))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0de3c1229e14304085c63b87dea1a3d01bbe7dbf" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;get()&lt;/code&gt;.</source>
          <target state="translated">2)&lt;code&gt;get()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="956bf8794e664c4a6a56406efc55a69e5ffb8ffd" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;greater&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;less&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, otherwise &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;greater&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 있다 &lt;code&gt;less&lt;/code&gt; , &lt;code&gt;less&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;greater&lt;/code&gt; 달리 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea990990d655c174dfc674caf5fec20a3b3cb7e2" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;high&lt;/code&gt;</source>
          <target state="translated">2)&lt;code&gt;high&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="557907f628f8a4df2207aeeacb4ddc1348607b0f" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;int(x) != int(y)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;int(x) != int(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b739feb81f47d8bb969efaec0e9c7cb1af19ded" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;is&lt;/code&gt;</source>
          <target state="translated">2)&lt;code&gt;is&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd88b678e478307587a341bc9a067cec7e1cf414" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;ist&lt;/code&gt;</source>
          <target state="translated">2)&lt;code&gt;ist&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a17307ad800cb24e7fb176aba00747b738ae261e" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;last&lt;/code&gt;</source>
          <target state="translated">2)&lt;code&gt;last&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac7880d21715c5fae0f76e62a180d1664762db29" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;lhs.base() != rhs.base()&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;lhs.base() != rhs.base()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8babffe6e9283750603d7f4b5b90a1f65de68877" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;log(c.size()) + &lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;log(c.size()) + &lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7de9d64257b17c86d839e38026fb3af4bb82075b" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;obj-&amp;gt;compare_exchange_strong(*expected, desired)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;obj-&amp;gt;compare_exchange_strong(*expected, desired)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3635cbb0f0f5968f893eefee0ff5678b7314d6af" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;obj-&amp;gt;fetch_add(arg, order)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;obj-&amp;gt;fetch_add(arg, order)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6886be927e5d544963384275f42886f76a4d3987" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;obj-&amp;gt;fetch_and(arg, order)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;obj-&amp;gt;fetch_and(arg, order)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef2212d45844f497c1aab8e8e06c470b1fb768a9" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;obj-&amp;gt;fetch_or(arg, order)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;obj-&amp;gt;fetch_or(arg, order)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce9500af54b795a690eff591da1cf50d8028a244" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;obj-&amp;gt;fetch_sub(arg, order)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;obj-&amp;gt;fetch_sub(arg, order)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1ab3c7bfffc76f60244e1dab4c05c3208eb605b" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;obj-&amp;gt;fetch_xor(arg, order)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;obj-&amp;gt;fetch_xor(arg, order)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8470e7cea6faca21bb2b1d45ce7c0bfb7552ffa9" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;other.get_id()&lt;/code&gt; equal to &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;get_id&quot;&gt;get_id()&lt;/a&gt;&lt;/code&gt; returns the value of &lt;code&gt;other.get_id()&lt;/code&gt; prior to the start of construction</source>
          <target state="translated">2) &lt;code&gt;other.get_id()&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id()&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;get_id&quot;&gt;get_id()&lt;/a&gt;&lt;/code&gt; 는 생성을 시작하기 전에 &lt;code&gt;other.get_id()&lt;/code&gt; 의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a7c7251cece5e074050666e58aec5887c5eb70e" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">2)&lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c885b043f15502c71fdc41eb13ad0dab35453eff" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;promise&lt;/code&gt; is not copy-assignable.</source>
          <target state="translated">2) &lt;code&gt;promise&lt;/code&gt; 은 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2f45cff909050496aac313641faf97c17c2ead19" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;ref(t.get())&lt;/code&gt;</source>
          <target state="translated">2)&lt;code&gt;ref(t.get())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a07e188a9620802a099d9fca724f54d2fd5fdd28" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;s.end()&lt;/code&gt;</source>
          <target state="translated">2)&lt;code&gt;s.end()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b12866528a2c911c1f5c811b5f59fc449c53c93" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;std::chrono::get_tzdb_list().front()&lt;/code&gt;.</source>
          <target state="translated">2)&lt;code&gt;std::chrono::get_tzdb_list().front()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="a4a610da0c2483e0dcc93c17aca83b8098bacc9e" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;std::pmr::vector&lt;/code&gt; is an alias template that uses a &lt;a href=&quot;../memory/polymorphic_allocator&quot;&gt;polymorphic allocator&lt;/a&gt;</source>
          <target state="translated">2) &lt;code&gt;std::pmr::vector&lt;/code&gt; 는 &lt;a href=&quot;../memory/polymorphic_allocator&quot;&gt;다형성 할당자를&lt;/a&gt; 사용하는 별칭 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="63687de7020d8df795b2441c184eae9b671e1dfa" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;sv.end()&lt;/code&gt;</source>
          <target state="translated">2)&lt;code&gt;sv.end()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea97bdab6c615953d04cb8f009a67d59f3778984" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">2)&lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd92d0ea25d947deb6fe0798ff216199799c8b60" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; do not refer to the same object, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">2) &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 같은 객체를 참조하지 않으면 &lt;code&gt;true&lt;/code&gt; 이고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6cbbc40c9ec2fec480131704cdcb6a50f9fcc740" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is</source>
          <target state="translated">2) &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이면</target>
        </trans-unit>
        <trans-unit id="f2481e7d7710cf162f60ff612735fe1d03ebc175" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are not equal, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;lhs&lt;/code&gt; 과 &lt;code&gt;rhs&lt;/code&gt; 같지입니다 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="c4f5f0094da64c29d409c1ba2c415bfff00d7719" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">2) &lt;code&gt;lhs&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이면</target>
        </trans-unit>
        <trans-unit id="8872cc369fa854f8baf4c05b786ced317e80c56e" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;path() != rhs.path()&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;path() != rhs.path()&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="d8ac909094e680682b3c146b6aea624f8b106cd2" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; 거나 &lt;code&gt;equivalent&lt;/code&gt; 하고, &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;less&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7670f5df5ce0244c44ee6d7e0007f11e6492346" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt; or &lt;code&gt;unordered&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; 거나 &lt;code&gt;equivalent&lt;/code&gt; 하고, &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;less&lt;/code&gt; 또는 &lt;code&gt;unordered&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7a6df0daf1bf3e22bd7340faab527a0fe8ed4c5" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, &lt;code&gt;equivalent&lt;/code&gt;, or &lt;code&gt;equal&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; , &lt;code&gt;equivalent&lt;/code&gt; 또는 &lt;code&gt;equal&lt;/code&gt; 하고, &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;less&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5faf547f449d141528b8c168939dd4a1baba058e" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;less&lt;/code&gt; 또는 &lt;code&gt;equivalent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a8ff1a288f926bf97b773c82282a1aa87ed35ac" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;equivalent&lt;/code&gt;, or &lt;code&gt;equal&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 있다 &lt;code&gt;less&lt;/code&gt; , &lt;code&gt;equivalent&lt;/code&gt; 또는 &lt;code&gt;equal&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca5b6c3deda05ece1e197fb794aa33090cfb1f07" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;equivalent&lt;/code&gt;, or &lt;code&gt;unordered&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;less&lt;/code&gt; , &lt;code&gt;equivalent&lt;/code&gt; 또는 &lt;code&gt;unordered&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebad42849438542001adc103e3fce9deb7075cca" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 있다 &lt;code&gt;less&lt;/code&gt; 또는 &lt;code&gt;equivalent&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;greater&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c796b516162af0e3e1844f636929b827becd470" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt; or &lt;code&gt;unordered&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;less&lt;/code&gt; 또는 &lt;code&gt;equivalent&lt;/code&gt; 하고, &lt;code&gt;false&lt;/code&gt; 있는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; 거나 &lt;code&gt;unordered&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa349488701da2b5bb041f0c069dc832a540a62e" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;equivalent&lt;/code&gt;, or &lt;code&gt;equal&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 있다 &lt;code&gt;less&lt;/code&gt; , &lt;code&gt;equivalent&lt;/code&gt; 또는 &lt;code&gt;equal&lt;/code&gt; 하고, &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;greater&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb543f0b0635803b005cff8b3d70792484822295" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;less&lt;/code&gt; 와 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 이고 &lt;code&gt;greater&lt;/code&gt; 또는 &lt;code&gt;equivalent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0fafe82d07cce3a72ad60f1082ad877e38a7a846" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, &lt;code&gt;equivalent&lt;/code&gt;, or &lt;code&gt;equal&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;less&lt;/code&gt; 와 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; , &lt;code&gt;equivalent&lt;/code&gt; 또는 &lt;code&gt;equal&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1c04c48f2380be99a3959e21acedbd7706ca6e7" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, &lt;code&gt;equivalent&lt;/code&gt;, or &lt;code&gt;unordered&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;less&lt;/code&gt; 와 &lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; , &lt;code&gt;equivalent&lt;/code&gt; 또는 &lt;code&gt;unordered&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="669fedb296937f0eb00beb590eb4c8e5d76deae6" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if any of the bits are set to &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">2) 비트 중 하나라도 &lt;code&gt;true&lt;/code&gt; 로 설정되면 &lt;code&gt;true&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="287cc9eae751ada4e1dd47095ac82f3074353eca" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to different time points, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">2) &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 가 다른 시점을 참조 하면 &lt;code&gt;true&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e0fc69e6e56c78afd9b58a19ea3fabc3b75c644b" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if the contents of the containers are not equal, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 용기의 내용물이 같지 않으면 &lt;code&gt;false&lt;/code&gt; 그렇지</target>
        </trans-unit>
        <trans-unit id="4f110d7fa78436badfd4c486f7d495c5b954c0b2" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if the engine adaptors are not equivalent, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">2) 엔진 어댑터가 동일하지 않으면 &lt;code&gt;true&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7d308c5dcea009527f8637c73b94b3c8d7fa352f" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if the engines are not equivalent, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">2) 엔진이 동일하지 않으면 &lt;code&gt;true&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f3f37d6d416c5b842473de2bb0dcf54960dd993b" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;true&lt;/code&gt; if the error category or error value compare are not equal.</source>
          <target state="translated">2) &lt;code&gt;true&lt;/code&gt; 에러 카테고리 또는 에러 값과 비교하는 경우 동일하지 않다.</target>
        </trans-unit>
        <trans-unit id="7b7acf72ef6740f62149d3e00aa8746801dafb3a" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;unsigned(x) != unsigned(y)&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;unsigned(x) != unsigned(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35e660f8192c1e06658f32d65e5f4c81fc545b6d" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;value&lt;/code&gt; is moved into the new element.</source>
          <target state="translated">2) &lt;code&gt;value&lt;/code&gt; 이 새로운 요소로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="a2034b68d3bb5a2db84b6d1ac1a90557d76f11fd" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;view::iota(E)&lt;/code&gt; and &lt;code&gt;view::iota(E, F)&lt;/code&gt; are</source>
          <target state="translated">2) &lt;code&gt;view::iota(E)&lt;/code&gt; 및 &lt;code&gt;view::iota(E, F)&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="ef4883b8e5c4ddc733a492033816ad54c6b64921" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;x.date() != y.date()&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;x.date() != y.date()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5086dbfca06a7a641a147fcc1f91aacab45b4881" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;x.month() != y.month()&lt;/code&gt;</source>
          <target state="translated">2) &lt;code&gt;x.month() != y.month()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd1daf01bf695865810181b1ceec896f7ede3b9d" translate="yes" xml:space="preserve">
          <source>2)&lt;code&gt;x.name() != y.name()&lt;/code&gt;.</source>
          <target state="translated">2) &lt;code&gt;x.name() != y.name()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f72e378da18db8d2186d4ae16a5b235f978d73c8" translate="yes" xml:space="preserve">
          <source>2)digit-sequence representing a whole number with a decimal separator, in this case the exponent is optional: &lt;code&gt;1.&lt;/code&gt;, &lt;code&gt;1.e-2&lt;/code&gt;</source>
          <target state="translated">2) 소수 구분 기호로 정수를 나타내는 숫자 순서,이 경우 지수는 선택 사항입니다. &lt;code&gt;1.&lt;/code&gt; , &lt;code&gt;1.e-2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="446e6652a695015432d0d61d79646a32852def09" translate="yes" xml:space="preserve">
          <source>2)lhs must be an expression of type pointer to class type &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">2) lhs는 클래스 유형 &lt;code&gt;T*&lt;/code&gt; 포인터 유형의 표현식이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d173a9d60b71f0cf3b81d723c7bcb2084845d154" translate="yes" xml:space="preserve">
          <source>2)root-directory (if any)</source>
          <target state="translated">2) 루트 디렉토리 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="ccbc1bba81b28ef9c3dc15ca80a9ef2fa5bf6618" translate="yes" xml:space="preserve">
          <source>2*arg</source>
          <target state="translated">2*arg</target>
        </trans-unit>
        <trans-unit id="a57d6ad1b24fb56cef62c7ce08063a39f49da8fd" translate="yes" xml:space="preserve">
          <source>2, 4-8) (none)</source>
          <target state="translated">2, 4-8) (없음)</target>
        </trans-unit>
        <trans-unit id="2eeedb90968ab94c40f7bd7f3be7d59b5e08f0e0" translate="yes" xml:space="preserve">
          <source>2,3) A copy of the pointed-to shared pointer.</source>
          <target state="translated">2,3) 공유 공유 포인터의 사본.</target>
        </trans-unit>
        <trans-unit id="1fbf20b3e41b170f4a6146dae9e7a474742f472e" translate="yes" xml:space="preserve">
          <source>2,3) Applies the operator between each element of the valarray and the scalar.</source>
          <target state="translated">2,3) valarray의 각 요소와 스칼라 사이에 연산자를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="7f541936d449a0b44e0a16f37b1f62331d08f498" translate="yes" xml:space="preserve">
          <source>2,3) Assigns &lt;code&gt;cx.real()&lt;/code&gt; and &lt;code&gt;cx.imag()&lt;/code&gt; to the real and the imaginary parts of the complex number respectively.</source>
          <target state="translated">2,3) &lt;code&gt;cx.real()&lt;/code&gt; 및 &lt;code&gt;cx.imag()&lt;/code&gt; 를 복소수의 실수 부와 허수 부에 각각 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="0a5e4af74c00b93030ced3220c542f8aa2ec422a" translate="yes" xml:space="preserve">
          <source>2,3) Expands to an integer constant expression with value</source>
          <target state="translated">2,3) 값이있는 정수 상수 표현식으로 확장</target>
        </trans-unit>
        <trans-unit id="9ba5a933a3a33bf4477ec8b7b37691aae4e37c7a" translate="yes" xml:space="preserve">
          <source>2,3) Same as (1), but accepts any &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;, null-terminated multicharacter string, or an input iterator pointing to a null-terminated multicharacter sequence. Equivalent to &lt;code&gt;return operator/=(path(source));&lt;/code&gt;.</source>
          <target state="translated">2,3) (1)과 동일하지만 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; , null로 끝나는 다중 문자 문자열 또는 null로 끝나는 다중 문자 시퀀스를 가리키는 입력 반복자를 허용합니다. 동등 &lt;code&gt;return operator/=(path(source));&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf1a28ef18e811865e16ae09ce175a696143c037" translate="yes" xml:space="preserve">
          <source>2,3) Same as (1), but the object constructed is a possibly-multidimensional array whose every non-array element is initialized as if by the expression &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::construct(a2, pv)&lt;/code&gt; where &lt;code&gt;a2&lt;/code&gt; of type &lt;code&gt;A2&lt;/code&gt; is the copy of the allocator rebound to manage objects of type &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/remove_all_extents&quot;&gt;std::remove_all_extents_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;. The overload (2) creates an array of size &lt;code&gt;N&lt;/code&gt; along its first dimension. The array elements are initialized in ascending order of their addresses, and when their lifetime ends are destroyed in the reverse order of their original construction.</source>
          <target state="translated">2,3) (1)과 동일하지만 생성 된 객체는 모든 비 배열 요소가 &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::construct(a2, pv)&lt;/code&gt; 식으로 초기화되는 다차원 배열 일 수 있습니다. 여기서 &lt;code&gt;a2&lt;/code&gt; 유형 &lt;code&gt;A2&lt;/code&gt; 의 유형은 &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/remove_all_extents&quot;&gt;std::remove_all_extents_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 유형의 오브젝트를 관리하기 위해 할당 자 리바운드의 사본입니다 . 과부하 (2) 는 첫 번째 차원을 따라 &lt;code&gt;N&lt;/code&gt; 크기의 배열을 만듭니다 . 배열 요소는 주소의 오름차순으로 초기화되고 수명이 끝날 때 원래 구성의 역순으로 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="018f274ddc47293c462130d5bd238bc492ecf46c" translate="yes" xml:space="preserve">
          <source>2,3) Same as (1), but the object constructed is a possibly-multidimensional array whose non-array elements of type &lt;code&gt;std::remove_all_extents_t&amp;lt;T&amp;gt;&lt;/code&gt; are value-initialized as if by placement-new expression &lt;code&gt;::new(pv) &lt;a href=&quot;../../types/remove_all_extents&quot;&gt;std::remove_all_extents_t&lt;/a&gt;&amp;lt;T&amp;gt;()&lt;/code&gt;. The overload (2) creates an array of size &lt;code&gt;N&lt;/code&gt; along the first dimension. The array elements are initialized in ascending order of their addresses, and when their lifetime ends are destroyed in the reverse order of their original construction.</source>
          <target state="translated">2,3) (1)과 동일하지만 생성 된 객체는 &lt;code&gt;std::remove_all_extents_t&amp;lt;T&amp;gt;&lt;/code&gt; 유형의 비 배열 요소 가 배치-새 표현식 &lt;code&gt;::new(pv) &lt;a href=&quot;../../types/remove_all_extents&quot;&gt;std::remove_all_extents_t&lt;/a&gt;&amp;lt;T&amp;gt;()&lt;/code&gt; . 과부하 (2) 는 첫 번째 차원을 따라 크기 &lt;code&gt;N&lt;/code&gt; 의 배열을 만듭니다 . 배열 요소는 주소의 오름차순으로 초기화되고 수명이 끝날 때 원래 구성의 역순으로 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="3d453906f3db33d3d81c44ff93850c3210eb625f" translate="yes" xml:space="preserve">
          <source>2,4) Elements are compared using the given binary predicate &lt;code&gt;p&lt;/code&gt;. The behavior is undefined if it is not an equivalence relation.</source>
          <target state="translated">2,4) 주어진 2 진 술어 &lt;code&gt;p&lt;/code&gt; 를 사용하여 요소를 비교합니다 . 동치 관계가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9fd0b8ea9fe33311db94688fbdc0e5e98eb140e" translate="yes" xml:space="preserve">
          <source>2,4) O(N) applications of the predicate, and O(N log N) swaps, where N = last - first.</source>
          <target state="translated">2,4) 술어의 O (N) 응용 프로그램 및 O (N log N) 스왑. 여기서 N = 마지막-첫 번째.</target>
        </trans-unit>
        <trans-unit id="82bfbd27f6c900324f67720ca2a407bd89554dd7" translate="yes" xml:space="preserve">
          <source>2,4) Performs &lt;code&gt;*d_first = *first;&lt;/code&gt;. For every &lt;code&gt;d&lt;/code&gt; in &lt;code&gt;[1, last - first - 1]&lt;/code&gt;, assigns &lt;code&gt;*(first + d) - *(first + d - 1)&lt;/code&gt; (overload (2)) or &lt;code&gt;op(*(first + d), *(first + d - 1))&lt;/code&gt; (overload (4)) to &lt;code&gt;*(d_first + d)&lt;/code&gt;. This is executed according to &lt;code&gt;policy&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">2,4) &lt;code&gt;*d_first = *first;&lt;/code&gt; 수행합니다 . . 모든 옵션 &lt;code&gt;d&lt;/code&gt; 의 &lt;code&gt;[1, last - first - 1]&lt;/code&gt; , 대입 &lt;code&gt;*(first + d) - *(first + d - 1)&lt;/code&gt; (과부하 (2)) 또는 &lt;code&gt;op(*(first + d), *(first + d - 1))&lt;/code&gt; (과부하 (4)) ~ &lt;code&gt;*(d_first + d)&lt;/code&gt; . 이것은 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true 인 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="f2c70c4348c997f8ada3083a9866ea3442c47537" translate="yes" xml:space="preserve">
          <source>2,4) Same as (1) and (3), respectively, but executed according to &lt;code&gt;policy&lt;/code&gt; and the moves may be performed in any order. These overloads does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">2,4) 각각 (1) 및 (3)과 동일하지만 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행 되며 이동은 임의의 순서로 수행 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true가 아니면 이러한 과부하는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7e23a0134ee56102030a6d7a6f0b48bf5b193fa4" translate="yes" xml:space="preserve">
          <source>2,4) Same as (1,3), but executed according to &lt;code&gt;policy&lt;/code&gt;. These overloads do not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true</source>
          <target state="translated">2,4) (1,3)과 동일하지만 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true가 아니면 이러한 과부하는 과부하 해결에 참여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24d59d8f6154a1aa99b7e79fa09bf73989c0371f" translate="yes" xml:space="preserve">
          <source>2,4) Same as (1,3), but executed according to &lt;code&gt;policy&lt;/code&gt;. These overloads do not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">2,4) (1,3)과 동일하지만 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true가 아니면 이러한 과부하는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="86b93d93131c4d8e7de7d3ec5d3cdb6efa1deaf7" translate="yes" xml:space="preserve">
          <source>2,4) Same as (1,3), but executed according to &lt;code&gt;policy&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true</source>
          <target state="translated">2,4) (1,3)과 동일하지만 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true 인 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="86f3e31fcf2db7c0bc61ea56eb43cb46106da43c" translate="yes" xml:space="preserve">
          <source>2,4) Same as (1,3), except the mapped value is constructed from &lt;code&gt;value_type(std::move(k), &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;M&amp;gt;(obj))&lt;/code&gt;</source>
          <target state="translated">2,4) 매핑 된 값이 &lt;code&gt;value_type(std::move(k), &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;M&amp;gt;(obj))&lt;/code&gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;M&amp;gt; (obj)) 로 구성된다는 점을 제외하고 (1,3)과 동일</target>
        </trans-unit>
        <trans-unit id="918d9a24234a4b6eaab57e11c9c3d0527b8bc575" translate="yes" xml:space="preserve">
          <source>2,4) The object of type &lt;code&gt;string_type&lt;/code&gt; to use as the representation of &lt;code&gt;false&lt;/code&gt;. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;&quot;false&quot;&lt;/code&gt; and &lt;code&gt;L&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">2,4) &lt;code&gt;string_type&lt;/code&gt; 유형의 객체 는 &lt;code&gt;false&lt;/code&gt; 표시로 사용됩니다 . &lt;code&gt;std::numpunct&lt;/code&gt; 의 표준 전문화는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 및 &lt;code&gt;L&quot;false&quot;&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d44bfea873efca969b40fd5f871fa83ea6d17e4e" translate="yes" xml:space="preserve">
          <source>2,4) The value of the atomic variable before the modification. Formally, the value immediately preceding the effects of this function in the &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">2,4) 수정 전 원자 변수의 값. 공식적으로,이 값은 바로이 함수의 효과 항 &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;수정 순&lt;/a&gt; 의 &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ae83859a203ce9166a88c2baacaa761e0e817c2" translate="yes" xml:space="preserve">
          <source>2,4) The value of the referenced object before the modification.</source>
          <target state="translated">2,4) 수정 전 참조 된 객체의 값.</target>
        </trans-unit>
        <trans-unit id="e08c409333299d333c6484f0c8e738bbbac6725b" translate="yes" xml:space="preserve">
          <source>2,4) a copy of the &lt;code&gt;day&lt;/code&gt; made before modification</source>
          <target state="translated">2,4) 수정 &lt;code&gt;day&lt;/code&gt; 의 사본</target>
        </trans-unit>
        <trans-unit id="19f62009cf80411e41d4843867ad567578f32188" translate="yes" xml:space="preserve">
          <source>2,4) a copy of the &lt;code&gt;month&lt;/code&gt; made before modification</source>
          <target state="translated">2,4) 수정 전 &lt;code&gt;month&lt;/code&gt; 의 사본</target>
        </trans-unit>
        <trans-unit id="e33ea80cde798ea0598cf06c35fd6879cd8fe605" translate="yes" xml:space="preserve">
          <source>2,4) a copy of the &lt;code&gt;time_point&lt;/code&gt; made before modification</source>
          <target state="translated">2,4) 수정 전 &lt;code&gt;time_point&lt;/code&gt; 의 사본</target>
        </trans-unit>
        <trans-unit id="3791d25d6538cdfe2b33ae1eb6bb04fcf70cc2dc" translate="yes" xml:space="preserve">
          <source>2,4) a copy of the &lt;code&gt;weekday&lt;/code&gt; made before modification</source>
          <target state="translated">2,4) 수정 전의 &lt;code&gt;weekday&lt;/code&gt; 사본</target>
        </trans-unit>
        <trans-unit id="e542c06cfbd7a826f7b1876b6eb5154d84d94242" translate="yes" xml:space="preserve">
          <source>2,4) a copy of the &lt;code&gt;year&lt;/code&gt; made before modification</source>
          <target state="translated">2,4) 수정 &lt;code&gt;year&lt;/code&gt; 사본</target>
        </trans-unit>
        <trans-unit id="2d94fdd2ad152c7fecf4d370a5a9d9ea672955ad" translate="yes" xml:space="preserve">
          <source>2,4) a copy of the duration made before modification</source>
          <target state="translated">2,4) 수정 전 기간의 사본</target>
        </trans-unit>
        <trans-unit id="6799429717fc8f4c3da105fa656767ff8d9b555f" translate="yes" xml:space="preserve">
          <source>2,4) type is &lt;a href=&quot;decltype&quot;&gt;&lt;code&gt;decltype(e)&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;e&lt;/code&gt; is the initializer.</source>
          <target state="translated">2,4) type은 &lt;a href=&quot;decltype&quot;&gt; &lt;code&gt;decltype(e)&lt;/code&gt; &lt;/a&gt; 이며 여기서 &lt;code&gt;e&lt;/code&gt; 는 초기화 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="216b22061fff2e1006cda85a67ec6ef180591376" translate="yes" xml:space="preserve">
          <source>2,4)&lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">2,4)&lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82a86776052eec0eab672ec07043fdf2b3dd0395" translate="yes" xml:space="preserve">
          <source>2,4)&lt;code&gt;O(&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2))&lt;/code&gt;</source>
          <target state="translated">2,4) &lt;code&gt;O(&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ab87de2e789914e676e6d2bb6b8a4775bf3a9c7" translate="yes" xml:space="preserve">
          <source>2,4)&lt;code&gt;O(N log N)&lt;/code&gt; comparisons.</source>
          <target state="translated">2,4) &lt;code&gt;O(N log N)&lt;/code&gt; 비교.</target>
        </trans-unit>
        <trans-unit id="e9aa2496405f6a2ea1fcb56cc9009f28d2f0dcb0" translate="yes" xml:space="preserve">
          <source>2,4)&lt;code&gt;O(last-first)&lt;/code&gt; applications of the corresponding predicate.</source>
          <target state="translated">2,4) 해당 술어의 &lt;code&gt;O(last-first)&lt;/code&gt; 어플리케이션.</target>
        </trans-unit>
        <trans-unit id="5b9f0b74be025b0dc4b7ef0dc2adf927918206f7" translate="yes" xml:space="preserve">
          <source>2,4)&lt;code&gt;end&lt;/code&gt;</source>
          <target state="translated">2,4)&lt;code&gt;end&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8de80d6dff656985a666188baa2ab5f4106fee86" translate="yes" xml:space="preserve">
          <source>2,4)&lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">2,4)&lt;code&gt;end&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="00383d73e24daabb7d9b6599e85970721380f34f" translate="yes" xml:space="preserve">
          <source>2,4)&lt;code&gt;high&lt;/code&gt;</source>
          <target state="translated">2,4)&lt;code&gt;high&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="716afc08a0831396510b7316c8cd1087855f0db7" translate="yes" xml:space="preserve">
          <source>2,4,5,6) Throws any exception thrown by the constructor of the contained type.</source>
          <target state="translated">2,4,5,6) 포함 된 유형의 생성자가 던진 예외를 모두 처리합니다.</target>
        </trans-unit>
        <trans-unit id="92d1d705523a7a8cb79bfb49d3e6d4bf49999160" translate="yes" xml:space="preserve">
          <source>2,4,6) Same as (1,3,5), but executed according to &lt;code&gt;policy&lt;/code&gt;. These overloads do not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true</source>
          <target state="translated">2,4,6) (1,3,5)와 동일하지만 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true가 아니면 이러한 과부하는 과부하 해결에 참여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53cefd5728cb595aa61919f16f02740aa20b127d" translate="yes" xml:space="preserve">
          <source>2,4,6) Same as (1,3,5), but executed according to &lt;code&gt;policy&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true</source>
          <target state="translated">2,4,6) (1,3,5)와 동일하지만 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true 인 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="39c0eb8a2d4bcf5102382b35a0547b3dc653b8ad" translate="yes" xml:space="preserve">
          <source>2,4,6) Same as (1,3,5), but uses &lt;code&gt;r&lt;/code&gt; as the source range, as if using &lt;code&gt;ranges::begin(r)&lt;/code&gt; as &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;ranges::end(r)&lt;/code&gt; as &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">2,4,6) (1,3,5)와 동일하지만 &lt;code&gt;ranges::begin(r)&lt;/code&gt; 을 &lt;code&gt;first&lt;/code&gt; 로 사용 하고 &lt;code&gt;ranges::end(r)&lt;/code&gt; 를 &lt;code&gt;last&lt;/code&gt; 로 사용하는 것처럼 &lt;code&gt;r&lt;/code&gt; 을 소스 범위로 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="f16da40abb78f97ba13b5d63ffc526f9398f845f" translate="yes" xml:space="preserve">
          <source>2,4,6)&lt;code&gt;O(last-first)&lt;/code&gt; applications of the predicate</source>
          <target state="translated">2,4,6) 술어의 &lt;code&gt;O(last-first)&lt;/code&gt; 어플리케이션</target>
        </trans-unit>
        <trans-unit id="f8e4aead195ed743595e6e6ae9859d5e747fcf09" translate="yes" xml:space="preserve">
          <source>2,4,6,8) Same as (1,3,5,7), but executed according to &lt;code&gt;policy&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; is true</source>
          <target state="translated">2,4,6,8) (1,3,5,7)과 동일하지만 &lt;code&gt;policy&lt;/code&gt; 에 따라 실행됩니다 . &lt;code&gt;&lt;a href=&quot;is_execution_policy&quot;&gt;std::is_execution_policy_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ExecutionPolicy&amp;gt;&amp;gt;&lt;/code&gt; 가 true 인 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="ad1b343f55d0b389cca0a209a5ee49a16e5f70d1" translate="yes" xml:space="preserve">
          <source>2,4,6,8) same, but the complexity is specified as O(x), rather than &quot;at most x&quot;</source>
          <target state="translated">2,4,6,8) 동일하지만 복잡도는 &quot;최대 x&quot;가 아닌 O (x)로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="3e6a52365e1b13ced4b61bed6e82ccaa4dd25594" translate="yes" xml:space="preserve">
          <source>2,6) Subtracts &lt;code&gt;other&lt;/code&gt; from &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">2,6) &lt;code&gt;*this&lt;/code&gt; 에서 &lt;code&gt;other&lt;/code&gt; 를 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="b8fedb0dda8560210a9d701d71d490f5698436c7" translate="yes" xml:space="preserve">
          <source>2,6) when an object with dynamic storage duration is created by a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; with the initializer consisting of an empty pair of parentheses or braces(since C++11);</source>
          <target state="translated">2,6) 빈 괄호 또는 중괄호로 구성된 이니셜 라이저를 사용하여 &lt;a href=&quot;new&quot;&gt;새 표현식&lt;/a&gt; 으로 동적 저장 기간이있는 오브젝트를 작성하는 경우 (C ++ 11부터);</target>
        </trans-unit>
        <trans-unit id="b63fd28bc6d3336dcf79fecc0debc624e0e77a98" translate="yes" xml:space="preserve">
          <source>2-1074</source>
          <target state="translated">2-1074</target>
        </trans-unit>
        <trans-unit id="94963ab36f819bd40319201d4921403178e34b4b" translate="yes" xml:space="preserve">
          <source>2-149</source>
          <target state="translated">2-149</target>
        </trans-unit>
        <trans-unit id="516e471b863562f9eb4fdd5c58c36fa25d326323" translate="yes" xml:space="preserve">
          <source>2-3) (none)</source>
          <target state="translated">2-3) (없음)</target>
        </trans-unit>
        <trans-unit id="0aa8dcbb8de0bf30bc36092ba04ce217c33a893d" translate="yes" xml:space="preserve">
          <source>2-3) &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">2-3) &lt;code&gt;bool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="740751042416ade8ac442d2d79ce8b0d75bc3c1b" translate="yes" xml:space="preserve">
          <source>2-3) Assigns the state of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">2-3) &lt;code&gt;other&lt;/code&gt; 의 상태를 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="889691d541af4e86b741adf70af8ab79df8a09da" translate="yes" xml:space="preserve">
          <source>2-3) Constructs a &lt;code&gt;polymorphic_allocator&lt;/code&gt; using &lt;code&gt;other.resource()&lt;/code&gt; as the underlying memory resource.</source>
          <target state="translated">2-3) &lt;code&gt;other.resource()&lt;/code&gt; 를 기본 메모리 리소스로 사용하여 &lt;code&gt;polymorphic_allocator&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="7bfc152513f74bc3f451b1d8fa223f5179a67f6e" translate="yes" xml:space="preserve">
          <source>2-3) Copies (2) or moves (3) content of &lt;code&gt;other&lt;/code&gt; into a new instance, so that any content is equivalent in both type and value to those of &lt;code&gt;other&lt;/code&gt; prior to the constructor call, or empty if &lt;code&gt;other&lt;/code&gt; is empty. Formally,</source>
          <target state="translated">2-3) &lt;code&gt;other&lt;/code&gt; 내용을 새 인스턴스로 복사 (2)하거나 이동 (3) 하여 모든 내용이 유형과 값 이 생성자 호출 이전 의 &lt;code&gt;other&lt;/code&gt; 내용과 동일 하거나 &lt;code&gt;other&lt;/code&gt; 이 비어 있는 경우 비어 있습니다. 공식적으로</target>
        </trans-unit>
        <trans-unit id="4ef6e9ddbb0060905f916920d28833ac56897878" translate="yes" xml:space="preserve">
          <source>2-3) Copy and move constructors are defaulted.</source>
          <target state="translated">2-3) 복사 및 이동 생성자가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="e5ec3fa89ad90a7aa3abfd97ec4476c90c5eb7dc" translate="yes" xml:space="preserve">
          <source>2-3) First, performs the same steps as the default constructor, then associates the stream with a file by calling &lt;code&gt;rdbuf()-&amp;gt;open(filename, mode | &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;)&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;../basic_filebuf/open&quot;&gt;std::basic_filebuf::open&lt;/a&gt;&lt;/code&gt; for the details on the effects of that call). If the &lt;code&gt;open()&lt;/code&gt; call returns a null pointer, sets &lt;code&gt;setstate(failbit)&lt;/code&gt;. Overload (3) is only provided if &lt;code&gt;std::filesystem::path::value_type&lt;/code&gt; is not &lt;code&gt;char&lt;/code&gt;.(since C++17)</source>
          <target state="translated">2-3) 먼저 기본 생성자와 동일한 단계를 수행 한 다음 &lt;code&gt;rdbuf()-&amp;gt;open(filename, mode | &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;)&lt;/code&gt; 을 호출하여 스트림을 파일과 연결합니다 ( &lt;code&gt;&lt;a href=&quot;../basic_filebuf/open&quot;&gt;std::basic_filebuf::open&lt;/a&gt;&lt;/code&gt; 그 전화의 효과에 대한 자세한 내용을 보려면여십시오). 경우] &lt;code&gt;open()&lt;/code&gt; 호출이 반환 널 포인터, 세트 &lt;code&gt;setstate(failbit)&lt;/code&gt; . 오버로드 (3)은 &lt;code&gt;std::filesystem::path::value_type&lt;/code&gt; 이 &lt;code&gt;char&lt;/code&gt; 이 아닌 경우에만 제공됩니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="af710b1b50adee94452ffb3c81b729f9644bd669" translate="yes" xml:space="preserve">
          <source>2-3) First, performs the same steps as the default constructor, then associates the stream with a file by calling &lt;code&gt;rdbuf()-&amp;gt;open(filename, mode | &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;../basic_filebuf/open&quot;&gt;std::basic_filebuf::open&lt;/a&gt;&lt;/code&gt; for the details on the effects of that call). If the &lt;code&gt;open()&lt;/code&gt; call returns a null pointer, sets &lt;code&gt;setstate(failbit)&lt;/code&gt;. Overload (3) is only provided if &lt;code&gt;std::filesystem::path::value_type&lt;/code&gt; is not &lt;code&gt;char&lt;/code&gt;.(since C++17)</source>
          <target state="translated">2-3) 먼저 기본 생성자와 동일한 단계를 수행 한 다음 &lt;code&gt;rdbuf()-&amp;gt;open(filename, mode | &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt; 을 호출하여 스트림을 파일과 연결합니다 ( &lt;code&gt;&lt;a href=&quot;../basic_filebuf/open&quot;&gt;std::basic_filebuf::open&lt;/a&gt;&lt;/code&gt; 그 전화의 효과에 대한 자세한 내용을 보려면여십시오). 경우] &lt;code&gt;open()&lt;/code&gt; 호출이 반환 널 포인터, 세트 &lt;code&gt;setstate(failbit)&lt;/code&gt; . 오버로드 (3)은 &lt;code&gt;std::filesystem::path::value_type&lt;/code&gt; 이 &lt;code&gt;char&lt;/code&gt; 이 아닌 경우에만 제공됩니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="a4cc98c07fb98634c349771cc526894afed8857f" translate="yes" xml:space="preserve">
          <source>2-3) First, performs the same steps as the default constructor, then associates the stream with a file by calling &lt;code&gt;rdbuf()-&amp;gt;open(filename, mode)&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;../basic_filebuf/open&quot;&gt;std::basic_filebuf::open&lt;/a&gt;&lt;/code&gt; for the details on the effects of that call). If the &lt;code&gt;open()&lt;/code&gt; call returns a null pointer, sets &lt;code&gt;setstate(failbit)&lt;/code&gt;. Overload (3) is only provided if &lt;code&gt;std::filesystem::path::value_type&lt;/code&gt; is not &lt;code&gt;char&lt;/code&gt;.(since C++17)</source>
          <target state="translated">2-3) 먼저, 기본 생성자와 같은 단계를 수행 한 다음 &lt;code&gt;rdbuf()-&amp;gt;open(filename, mode)&lt;/code&gt; 를 호출하여 스트림을 파일과 연결합니다 ( 효과에 대한 자세한 내용 은 &lt;code&gt;&lt;a href=&quot;../basic_filebuf/open&quot;&gt;std::basic_filebuf::open&lt;/a&gt;&lt;/code&gt; 참조 ). 그 전화의). 경우] &lt;code&gt;open()&lt;/code&gt; 호출이 반환 널 포인터, 세트 &lt;code&gt;setstate(failbit)&lt;/code&gt; . 오버로드 (3)은 &lt;code&gt;std::filesystem::path::value_type&lt;/code&gt; 이 &lt;code&gt;char&lt;/code&gt; 이 아닌 경우에만 제공됩니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="ac1a3cb5611393a23cd5b6bae53cdf7081154423" translate="yes" xml:space="preserve">
          <source>2-3) Linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">2-3) 리니어 &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0653ebee98127d5677f6e705dbde0779dcb5a981" translate="yes" xml:space="preserve">
          <source>2-3) These deduction guides are provided for &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; to allow deduction from a &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;size_type&lt;/code&gt; parameter type in (3) refers to the &lt;code&gt;size_type&lt;/code&gt; member type of the type deduced by the deduction guide. These overloads only participate in overload resolution if &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">2-3)이 추론 가이드는 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 에서 추론 할 수 있도록 &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; 됩니다. (3)에서 의 &lt;code&gt;size_type&lt;/code&gt; 파라미터 타입 은 추론 가이드에 의해 추론 된 타입의 &lt;code&gt;size_type&lt;/code&gt; 멤버 타입을 지칭한다 . 이러한 과부하는 &lt;code&gt;Alloc&lt;/code&gt; 이&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator를&lt;/a&gt; 만족하는 경우에만 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="bc443359bc7da4318780f5fab12b2865c734117b" translate="yes" xml:space="preserve">
          <source>2-3) Throws nothing.</source>
          <target state="translated">2-3) 아무것도 던지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="587c3d9cdb15c3845ebca72f800e9ac08fe5a765" translate="yes" xml:space="preserve">
          <source>2-3)&lt;code&gt;&lt;a href=&quot;../regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; if the supplied regular expression is not valid.</source>
          <target state="translated">2-3) &lt;code&gt;&lt;a href=&quot;../regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; 제공된 정규식이 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="5453310cbaed08a6a438ac8591e07014d55e7a8e" translate="yes" xml:space="preserve">
          <source>2-4) Replaces the managed object with an object pointed to by &lt;code&gt;ptr&lt;/code&gt;. &lt;code&gt;Y&lt;/code&gt; must be a complete type and implicitly convertible to &lt;code&gt;T&lt;/code&gt;. Additionally:</source>
          <target state="translated">2-4) 관리 대상 객체를 &lt;code&gt;ptr&lt;/code&gt; 이 가리키는 객체로 바꿉니다 . &lt;code&gt;Y&lt;/code&gt; 는 완전한 유형이어야하고 암시 적으로 &lt;code&gt;T&lt;/code&gt; 로 변환 가능해야합니다 . 또한 :</target>
        </trans-unit>
        <trans-unit id="c3b4b5e4cfda469127ab508c67ab25aa8ac7bd9a" translate="yes" xml:space="preserve">
          <source>2-4) in the specialization for arrays behave the same as the constructors that take a pointer parameter in the primary template except that they additionally do not participate in overload resolution unless one of the following is true:</source>
          <target state="translated">2-4) 배열 전문화에서는 다음 중 하나에 해당하지 않는 한 오버로드 확인에 참여하지 않는다는 점을 제외하고 기본 템플릿에서 포인터 매개 변수를 사용하는 생성자와 동일하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="bab11a81a191ef4f40ffd3d426d5a68fccc4e31e" translate="yes" xml:space="preserve">
          <source>2-4) linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">2-4) &lt;code&gt;count&lt;/code&gt; 선형</target>
        </trans-unit>
        <trans-unit id="07f1cf8e1830909c73f8514ca9ae21b1aaf53359" translate="yes" xml:space="preserve">
          <source>2-5) First, copies the list of the requested submatch out of the &lt;code&gt;submatches&lt;/code&gt; or &lt;code&gt;submatch&lt;/code&gt; argument into the member list stored in the iterator and constructs the member &lt;code&gt;&lt;a href=&quot;../regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; by passing &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;re&lt;/code&gt;, and &lt;code&gt;m&lt;/code&gt; to its four-argument constructor (that constructor performs the initial call to &lt;code&gt;&lt;a href=&quot;../regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt;) and sets the internal counter of submatches to zero.</source>
          <target state="translated">2-5) 먼저 요청 된 부분 일치 목록을 부분 &lt;code&gt;submatches&lt;/code&gt; 또는 부분 &lt;code&gt;submatch&lt;/code&gt; 인수에서 반복자에 저장된 구성원 목록으로 &lt;code&gt;&lt;a href=&quot;../regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; 하고 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;re&lt;/code&gt; 및 &lt;code&gt;m&lt;/code&gt; 을 4 에 전달 하여 std :: regex_iterator 구성원을 구성합니다. 인수 생성자 (해당 생성자가 &lt;code&gt;&lt;a href=&quot;../regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; 대한 초기 호출)를 수행하고 부분 일치의 내부 카운터를 0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="cd7f0186fa34163a5969c15d6ebcb56229957b74" translate="yes" xml:space="preserve">
          <source>2-5) The overload that does not take a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;../filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">2-5) &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하지 않는 오버로드는 기본 OS API 오류에서 &lt;a href=&quot;../filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다. &lt;code&gt;p&lt;/code&gt; 는 첫 번째 경로 인수로, OS 오류 코드는 오류 코드 인수로 구성됩니다. &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 매개 변수 를 사용하는 과부하 는 OS API 호출이 실패하면이를 OS API 오류 코드로 설정하고 오류가 발생하지 않으면 &lt;code&gt;ec.clear()&lt;/code&gt; 실행 합니다. &lt;code&gt;noexcept&lt;/code&gt; 로 표시되지 않은 과부하 는 메모리 할당에 실패하면 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a93e93a5dcf699744c91784f301e4092ebc0ed6f" translate="yes" xml:space="preserve">
          <source>2-6) Throws any exception thrown by the constructor or assignment operator of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, the initialization state of &lt;code&gt;*this&lt;/code&gt; (and of &lt;code&gt;other&lt;/code&gt; in case of (2-3) and (5-6) ) is unchanged, i.e. if the object contained a value, it still contains a value, and the other way round. The contents of &lt;code&gt;value&lt;/code&gt; and the contained values of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; depend on the exception safety guarantees of the operation from which the exception originates (copy-constructor, move-assignment, etc.).</source>
          <target state="translated">2-6) &lt;code&gt;T&lt;/code&gt; 의 생성자 또는 할당 연산자에 의해 발생 된 예외를 처리합니다 . 예외가 발생하면 &lt;code&gt;*this&lt;/code&gt; (및 &lt;code&gt;other&lt;/code&gt; (2-3) 및 (5-6)의 경우) 초기화 상태 는 변경되지 않습니다. 즉, 객체에 값이 포함되어 있으면 여전히 값이 포함됩니다. 다른 방법으로 라운드. &lt;code&gt;*this&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; * &lt;code&gt;value&lt;/code&gt; 의 내용 및 포함 된 값은 예외가 발생한 작업 (복사 생성자, 이동 할당 등)의 예외 안전 보장에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="8168f14f6082b85346fd88fc93ff27220a67c1bd" translate="yes" xml:space="preserve">
          <source>2-6)&lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">2-6)&lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fca03c9c3234b4ce9edc76e008229226b7c4185" translate="yes" xml:space="preserve">
          <source>2. Omitted, in which case it is &lt;code&gt;int&lt;/code&gt; for scoped enumerations or an implementation-defined integral type capable of representing all values of the enum (for unscoped enumerations).</source>
          <target state="translated">2. 어떤 경우에는 그것이 생략 &lt;code&gt;int&lt;/code&gt; 범위 열거하거나 (범위가 지정되지 않은 열거 용)에 열거 된 모든 값을 나타낼 수있는 구현을 정의 일체형.</target>
        </trans-unit>
        <trans-unit id="bb9bcd435bd2ebea492b9adefdaf2a99e9f2889f" translate="yes" xml:space="preserve">
          <source>2. Otherwise, if either argument is &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt; or integer type, then both arguments are cast to &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt;</source>
          <target state="translated">2. 그렇지 않으면, 인수가 &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt; 또는 정수 유형 인 경우 두 인수 모두 &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt; &amp;lt;double&amp;gt;으로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="0a030694b1f0fe28d4604a6643a9438aff3bca99" translate="yes" xml:space="preserve">
          <source>2. Returns a value of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; that represents the hash value of the parameter.</source>
          <target state="translated">2. 매개 변수의 해시 값을 나타내는 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 유형의 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6e7999ab528fc5eee95f558f2a5f5551abee5281" translate="yes" xml:space="preserve">
          <source>2.1 Phases of translation [lex.phases]</source>
          <target state="translated">2.1 번역 단계 [lex.phases]</target>
        </trans-unit>
        <trans-unit id="3da874ea4f4f8acb8fd90317fef0f6203e8d2b8e" translate="yes" xml:space="preserve">
          <source>2.2 Phases of translation [lex.phases]</source>
          <target state="translated">2.2 번역 단계 [lex.phases]</target>
        </trans-unit>
        <trans-unit id="a36d13b57797389bde90bd9f90d71624172b9ee5" translate="yes" xml:space="preserve">
          <source>20) If defined, called by the custom array form of &lt;a href=&quot;../../language/new&quot;&gt;placement new[] &lt;/a&gt; expression with the matching signature if allocating an array of objects of type T.</source>
          <target state="translated">20) 정의 된 경우, 유형 T의 객체 배열을 할당하는 경우 일치하는 서명을 가진 &lt;a href=&quot;../../language/new&quot;&gt;배치 new []&lt;/a&gt; 표현식 의 사용자 정의 배열 양식에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e069377af238426154821ca13205027e4508e443" translate="yes" xml:space="preserve">
          <source>20) Returns &lt;code&gt;bool(opt) ? value == *opt : false&lt;/code&gt;.</source>
          <target state="translated">20) &lt;code&gt;bool(opt) ? value == *opt : false&lt;/code&gt; 리턴합니다 . value == * opt : false .</target>
        </trans-unit>
        <trans-unit id="9082079c7fd7d756a2ca1dea888cbb83753b7b38" translate="yes" xml:space="preserve">
          <source>20)&lt;code&gt;&lt;a href=&quot;year_month_day&quot;&gt;std::chrono::year_month_day&lt;/a&gt;(ym.year(), ym.month(), d)&lt;/code&gt;</source>
          <target state="translated">20) &lt;code&gt;&lt;a href=&quot;year_month_day&quot;&gt;std::chrono::year_month_day&lt;/a&gt;(ym.year(), ym.month(), d)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad1384880a61d5d618b57013cff8835b92cb787f" translate="yes" xml:space="preserve">
          <source>20.4 Tuples [tuple]</source>
          <target state="translated">20.4 튜플 [튜플]</target>
        </trans-unit>
        <trans-unit id="db4f17f6a672f5349653a3ec9fd1f4670b78bdc1" translate="yes" xml:space="preserve">
          <source>20.5.1.3 Freestanding implementations (p: 458)</source>
          <target state="translated">20.5.1.3 독립 실행 형 구현 (p : 458)</target>
        </trans-unit>
        <trans-unit id="18b0171738e934d28c51bcaf474b7720a328bae3" translate="yes" xml:space="preserve">
          <source>201210L</source>
          <target state="translated">201210L</target>
        </trans-unit>
        <trans-unit id="28faf88dd60cdf723204487a4f7df0aafc48b579" translate="yes" xml:space="preserve">
          <source>201304L</source>
          <target state="translated">201304L</target>
        </trans-unit>
        <trans-unit id="a6773c442ad40a34d6d049c0a3b43e047b8faf73" translate="yes" xml:space="preserve">
          <source>201309L</source>
          <target state="translated">201309L</target>
        </trans-unit>
        <trans-unit id="22e1780cf464ae56301359d6053c77eece6bf03c" translate="yes" xml:space="preserve">
          <source>201402L</source>
          <target state="translated">201402L</target>
        </trans-unit>
        <trans-unit id="570780b72403d061c69a2c525c832b5dcab07c2d" translate="yes" xml:space="preserve">
          <source>201411L</source>
          <target state="translated">201411L</target>
        </trans-unit>
        <trans-unit id="a86efe0a5f51a64efd9d09ae4295c2df7832c101" translate="yes" xml:space="preserve">
          <source>201505L</source>
          <target state="translated">201505L</target>
        </trans-unit>
        <trans-unit id="2c6c6b5fbca54afe21f48f9914d33b2fb3a8de15" translate="yes" xml:space="preserve">
          <source>201510L</source>
          <target state="translated">201510L</target>
        </trans-unit>
        <trans-unit id="8c9556aee6c253eb2033ecd408d371fb236ecb14" translate="yes" xml:space="preserve">
          <source>201603L</source>
          <target state="translated">201603L</target>
        </trans-unit>
        <trans-unit id="8baf514ae5246c02581735d581edda919cc8495d" translate="yes" xml:space="preserve">
          <source>201606L</source>
          <target state="translated">201606L</target>
        </trans-unit>
        <trans-unit id="839656e8a730180b7d5b1cabbc6ba903b5f6645d" translate="yes" xml:space="preserve">
          <source>201611L</source>
          <target state="translated">201611L</target>
        </trans-unit>
        <trans-unit id="6558e2e4db996ec157f4f4d4a3660c06b5769758" translate="yes" xml:space="preserve">
          <source>201703L</source>
          <target state="translated">201703L</target>
        </trans-unit>
        <trans-unit id="29f571fe0fb8e73e4d69b21fc4b7e306595a9d00" translate="yes" xml:space="preserve">
          <source>201711L</source>
          <target state="translated">201711L</target>
        </trans-unit>
        <trans-unit id="811750e354c2e1f1ba98b25a78490cf52f54fe34" translate="yes" xml:space="preserve">
          <source>201806L</source>
          <target state="translated">201806L</target>
        </trans-unit>
        <trans-unit id="1b640a5a2b2026a8e1225ac802370770ed8f0a73" translate="yes" xml:space="preserve">
          <source>201811L</source>
          <target state="translated">201811L</target>
        </trans-unit>
        <trans-unit id="538a51da7bb400f7f64247da30ed80832acc1598" translate="yes" xml:space="preserve">
          <source>201902L</source>
          <target state="translated">201902L</target>
        </trans-unit>
        <trans-unit id="4d26f186658c382630f11aff54a5a188c8cbadb2" translate="yes" xml:space="preserve">
          <source>21) If defined, and if (17) is not defined, called by the usual single-object &lt;a href=&quot;../../language/delete&quot;&gt;delete-expressions&lt;/a&gt; if deallocating an object of type T.</source>
          <target state="translated">21) 정의 된 경우 (17)이 정의되지 않은 경우, 유형 T의 오브젝트를 할당 해제하는 경우 일반적인 단일 오브젝트 &lt;a href=&quot;../../language/delete&quot;&gt;삭제 표현식에&lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c687b9d6d81e1ea6f8820127b8762a31537aafb" translate="yes" xml:space="preserve">
          <source>21) If defined, called by the custom single-object &lt;a href=&quot;../../language/new&quot;&gt;placement new&lt;/a&gt; expression with the matching signature if allocating an object of type T if its alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;. If this overload is not provided, but allocator-unaware member form (19) is, allocator-unaware member overload is called instead.</source>
          <target state="translated">21) 정의 된 경우, 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하는 경우 T 유형의 오브젝트를 할당하는 경우 일치하는 서명을 가진 사용자 정의 단일 오브젝트 &lt;a href=&quot;../../language/new&quot;&gt;배치 새&lt;/a&gt; 표현식에 의해 호출됩니다 . 이 과부하가 제공되지 않지만 할당 자 비 인식 멤버 양식 (19)이 있으면 할당 자 비 인식 멤버 오버로드가 대신 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="36b65a43bf6055bd665cc844c1788411523c60c2" translate="yes" xml:space="preserve">
          <source>21) Returns &lt;code&gt;bool(opt) ? *opt != value : true&lt;/code&gt;.</source>
          <target state="translated">21) &lt;code&gt;bool(opt) ? *opt != value : true&lt;/code&gt; 리턴합니다 . * opt! = value : true .</target>
        </trans-unit>
        <trans-unit id="a9ac7d2cda4a2ae92fcfcd611a816af9bfca61f8" translate="yes" xml:space="preserve">
          <source>21)&lt;code&gt;&lt;a href=&quot;year_month_day&quot;&gt;std::chrono::year_month_day&lt;/a&gt;(ym.year(), ym.month(), &lt;a href=&quot;day&quot;&gt;std::chrono::day&lt;/a&gt;(d))&lt;/code&gt;</source>
          <target state="translated">21) &lt;code&gt;&lt;a href=&quot;year_month_day&quot;&gt;std::chrono::year_month_day&lt;/a&gt;(ym.year(), ym.month(), &lt;a href=&quot;day&quot;&gt;std::chrono::day&lt;/a&gt;(d))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dda19e5a3ed35617e12ccce718920ea28415853f" translate="yes" xml:space="preserve">
          <source>22) If defined, and if (18) is not defined, called by the usual array &lt;a href=&quot;../../language/delete&quot;&gt;delete[]-expressions&lt;/a&gt; if deallocating an array of objects of type T.</source>
          <target state="translated">22) 정의 된 경우 (18)이 정의되지 않은 경우 일반 배열 &lt;a href=&quot;../../language/delete&quot;&gt;delete []-표현식에&lt;/a&gt; 의해 호출됩니다 ( T 형의 객체 배열을 할당 해제하는 경우).</target>
        </trans-unit>
        <trans-unit id="9859b0ada183b94584f103ed56619889d5739710" translate="yes" xml:space="preserve">
          <source>22) If defined, called by the custom array form of &lt;a href=&quot;../../language/new&quot;&gt;placement new[] &lt;/a&gt; expression with the matching signature if allocating an array of objects of type T. if its alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;. If this overload is not provided, but allocator-unaware member form (20) is, allocator-unaware member overload is called instead.</source>
          <target state="translated">22) 정의 된 경우, T 유형의 오브젝트 배열을 할당하는 경우 일치하는 서명을 가진 &lt;a href=&quot;../../language/new&quot;&gt;배치 new []&lt;/a&gt; 표현식 의 사용자 정의 배열 양식에 의해 호출됩니다 . 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하는 경우 . 이 과부하가 제공되지 않지만 할당 자 비 인식 멤버 양식 (20)이 제공되면 할당 자 비 인식 멤버 오버로드가 대신 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a5a5e9ec9432a7b6777283f2cd1eac168d5c4020" translate="yes" xml:space="preserve">
          <source>22) Returns &lt;code&gt;bool(opt) ? value != *opt : true&lt;/code&gt;.</source>
          <target state="translated">22) &lt;code&gt;bool(opt) ? value != *opt : true&lt;/code&gt; 리턴합니다 . value! = * opt : true 입니다.</target>
        </trans-unit>
        <trans-unit id="8dc6ff218c8bdb4582de327769a00b45673ff8c4" translate="yes" xml:space="preserve">
          <source>22,24)&lt;code&gt;&lt;a href=&quot;year_month_day&quot;&gt;std::chrono::year_month_day&lt;/a&gt;(y, md.month(), md.day())&lt;/code&gt;</source>
          <target state="translated">22,24) &lt;code&gt;&lt;a href=&quot;year_month_day&quot;&gt;std::chrono::year_month_day&lt;/a&gt;(y, md.month(), md.day())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c554e18f1f7efcd614d3a775eaa00548f94bb604" translate="yes" xml:space="preserve">
          <source>23) Returns &lt;code&gt;bool(opt) ? *opt &amp;lt; value : true&lt;/code&gt;.</source>
          <target state="translated">23) &lt;code&gt;bool(opt) ? *opt &amp;lt; value : true&lt;/code&gt; 리턴합니다 . * opt &amp;lt;value : true .</target>
        </trans-unit>
        <trans-unit id="63c937d92e7f2c97253aa685c09999050bc61791" translate="yes" xml:space="preserve">
          <source>23,24) If defined, and if (19,20) are not defined, called in preference to allocator-unaware members if the alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;.</source>
          <target state="translated">23,24) 정의 된 경우 및 (19,20)이 정의되지 않은 경우 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하면 할당 자 인식하지 못하는 멤버에 대해 우선적으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="bf06d7fc10ff49bfeadb22775c70dfc06e9b84bd" translate="yes" xml:space="preserve">
          <source>23,25)&lt;code&gt;&lt;a href=&quot;year_month_day&quot;&gt;std::chrono::year_month_day&lt;/a&gt;(&lt;a href=&quot;year&quot;&gt;std::chrono::year&lt;/a&gt;(y), md.month(), md.day())&lt;/code&gt;</source>
          <target state="translated">23,25) &lt;code&gt;&lt;a href=&quot;year_month_day&quot;&gt;std::chrono::year_month_day&lt;/a&gt;(&lt;a href=&quot;year&quot;&gt;std::chrono::year&lt;/a&gt;(y), md.month(), md.day())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ad1b6658bf460d78521a43b6624d60b4d50cb84" translate="yes" xml:space="preserve">
          <source>24) Returns &lt;code&gt;bool(opt) ? value &amp;lt; *opt : false&lt;/code&gt;.</source>
          <target state="translated">24) &lt;code&gt;bool(opt) ? value &amp;lt; *opt : false&lt;/code&gt; 리턴합니다 . value &amp;lt;* opt : false .</target>
        </trans-unit>
        <trans-unit id="2f1edab4092b028014791e589c249930e7c2f2ea" translate="yes" xml:space="preserve">
          <source>24-bit RANLUX generator by Martin L&amp;uuml;scher and Fred James, 1994.</source>
          <target state="translated">1994 년 Martin L&amp;uuml;scher와 Fred James의 24 비트 RANLUX 생성기.</target>
        </trans-unit>
        <trans-unit id="6744f34128a774233270686b8f8d4a1f82f7137a" translate="yes" xml:space="preserve">
          <source>24-hour format</source>
          <target state="translated">24 시간 형식</target>
        </trans-unit>
        <trans-unit id="4a0accf14cd80c6d8c7dbffc298bb4b2d07c4c08" translate="yes" xml:space="preserve">
          <source>25) If defined, called by the custom single-object &lt;a href=&quot;../../language/new&quot;&gt;placement new&lt;/a&gt; expression with the matching signature if the object's constructor throws an exception. If this function is not provided, and a matching (15) is not provided either, no deallocation function is called.</source>
          <target state="translated">25) 정의 된 경우, 객체의 생성자가 예외를 throw하면 일치하는 서명을 가진 사용자 정의 단일 객체 &lt;a href=&quot;../../language/new&quot;&gt;배치 새&lt;/a&gt; 표현식에 의해 호출됩니다 . 이 기능이 제공되지 않고 일치하는 (15)도 제공되지 않으면 할당 해제 기능이 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe16ddc062ab560dc4c18cbd4db2ff6d25ea9478" translate="yes" xml:space="preserve">
          <source>25) Returns &lt;code&gt;bool(opt) ? *opt &amp;lt;= value : true&lt;/code&gt;.</source>
          <target state="translated">25) &lt;code&gt;bool(opt) ? *opt &amp;lt;= value : true&lt;/code&gt; 리턴합니다 . * opt &amp;lt;= value : true .</target>
        </trans-unit>
        <trans-unit id="0cdc19fa8cfab3913be1bb9e9d6243bd831b9f65" translate="yes" xml:space="preserve">
          <source>26) If defined, called by the custom array form of &lt;a href=&quot;../../language/new&quot;&gt;placement new[] &lt;/a&gt; expression with the matching signature if any of the objects' constructors throws an exception (after executing the destructors for all objects that were constructed successfully). If this function is not provided, and a matching (16) is not provided either, no deallocation function is called.</source>
          <target state="translated">26) 정의 된 경우, 객체 생성자가 예외를 발생시키는 경우 (성공적으로 구성된 모든 객체에 대해 소멸자를 실행 한 후) 일치하는 서명을 가진 &lt;a href=&quot;../../language/new&quot;&gt;배치 new []&lt;/a&gt; 표현식 의 사용자 정의 배열 양식에 의해 호출됩니다 . 이 기능이 제공되지 않고 일치하는 (16)도 제공되지 않으면 할당 해제 기능이 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f369615dab0da56359caf5ac2d7325c47c4f2e65" translate="yes" xml:space="preserve">
          <source>26) Returns &lt;code&gt;bool(opt) ? value &amp;lt;= *opt : false&lt;/code&gt;.</source>
          <target state="translated">26) &lt;code&gt;bool(opt) ? value &amp;lt;= *opt : false&lt;/code&gt; 리턴합니다 . value &amp;lt;= * opt : false .</target>
        </trans-unit>
        <trans-unit id="1997cc535be30b9938fc6401ebda36b2512111ec" translate="yes" xml:space="preserve">
          <source>26)&lt;code&gt;&lt;a href=&quot;year_month_day_last&quot;&gt;std::chrono::year_month_day_last&lt;/a&gt;(ym.year(), &lt;a href=&quot;month_day_last&quot;&gt;std::chrono::month_day_last&lt;/a&gt;(ym.month()))&lt;/code&gt;</source>
          <target state="translated">26) &lt;code&gt;&lt;a href=&quot;year_month_day_last&quot;&gt;std::chrono::year_month_day_last&lt;/a&gt;(ym.year(), &lt;a href=&quot;month_day_last&quot;&gt;std::chrono::month_day_last&lt;/a&gt;(ym.month()))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f48468f12b58ba04a79b8034682b682e54eacc0e" translate="yes" xml:space="preserve">
          <source>27) Returns &lt;code&gt;bool(opt) ? *opt &amp;gt; value : false&lt;/code&gt;.</source>
          <target state="translated">27) &lt;code&gt;bool(opt) ? *opt &amp;gt; value : false&lt;/code&gt; 리턴합니다 . * opt&amp;gt; value : false .</target>
        </trans-unit>
        <trans-unit id="45c9dc4681c196ab01796a0295947eab8f490743" translate="yes" xml:space="preserve">
          <source>27,29)&lt;code&gt;&lt;a href=&quot;year_month_day_last&quot;&gt;std::chrono::year_month_day_last&lt;/a&gt;(y, mdl)&lt;/code&gt;</source>
          <target state="translated">27,29) &lt;code&gt;&lt;a href=&quot;year_month_day_last&quot;&gt;std::chrono::year_month_day_last&lt;/a&gt;(y, mdl)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7853db86124acd126bbb4b74a3853f85b1a4d90b" translate="yes" xml:space="preserve">
          <source>27-30) If defined, &lt;a href=&quot;../../language/delete&quot;&gt;delete-expressions&lt;/a&gt; does not execute the destructor for *p before placing a call to &lt;code&gt;operator delete&lt;/code&gt;. Instead, direct invocation of the destructor such as by &lt;code&gt;p-&amp;gt;~T();&lt;/code&gt; becomes the responsibility of this user-defined operator delete.</source>
          <target state="translated">27-30) 정의 된 경우 &lt;a href=&quot;../../language/delete&quot;&gt;delete 표현식&lt;/a&gt; 은 &lt;code&gt;operator delete&lt;/code&gt; 호출하기 전에 * p에 대한 소멸자를 실행하지 않습니다 . 대신 &lt;code&gt;p-&amp;gt;~T();&lt;/code&gt; 와 같은 소멸자를 직접 호출하십시오 . 이 사용자 정의 운영자 삭제의 책임이됩니다.</target>
        </trans-unit>
        <trans-unit id="0e46112e4fed32117edbd51fcc6057597df7a5e3" translate="yes" xml:space="preserve">
          <source>28) Returns &lt;code&gt;bool(opt) ? value &amp;gt; *opt : true&lt;/code&gt;.</source>
          <target state="translated">28) &lt;code&gt;bool(opt) ? value &amp;gt; *opt : true&lt;/code&gt; 리턴합니다 . value&amp;gt; * opt : true 입니다.</target>
        </trans-unit>
        <trans-unit id="84fc5e5ce62c45455d09d92f5a6c243264a6032c" translate="yes" xml:space="preserve">
          <source>28,30)&lt;code&gt;&lt;a href=&quot;year_month_day_last&quot;&gt;std::chrono::year_month_day_last&lt;/a&gt;(&lt;a href=&quot;year&quot;&gt;std::chrono::year&lt;/a&gt;(y), mdl)&lt;/code&gt;</source>
          <target state="translated">28,30) &lt;code&gt;&lt;a href=&quot;year_month_day_last&quot;&gt;std::chrono::year_month_day_last&lt;/a&gt;(&lt;a href=&quot;year&quot;&gt;std::chrono::year&lt;/a&gt;(y), mdl)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55c84e953fbaeb30e380ed10fb458eea7ca66da9" translate="yes" xml:space="preserve">
          <source>29) Returns &lt;code&gt;bool(opt) ? *opt &amp;gt;= value : false&lt;/code&gt;.</source>
          <target state="translated">29) &lt;code&gt;bool(opt) ? *opt &amp;gt;= value : false&lt;/code&gt; 리턴합니다 . * opt&amp;gt; = value : false .</target>
        </trans-unit>
        <trans-unit id="7ee1b608113c55f0834af57e55d70aa3dd86701f" translate="yes" xml:space="preserve">
          <source>2a) however, the exception specification allows &lt;code&gt;&lt;a href=&quot;../bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt;: the thrown exception object is destroyed, and &lt;code&gt;&lt;a href=&quot;../bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; is constructed by the C++ runtime and thrown instead.</source>
          <target state="translated">2a) 그러나 예외 사양에서는 &lt;code&gt;&lt;a href=&quot;../bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; : 허용 된 예외 객체가 소멸되고 &lt;code&gt;&lt;a href=&quot;../bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; 은 C ++ 런타임에 의해 구성되어 대신 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="5cb9439c87e44f0eee76910f343289a5fc58e58c" translate="yes" xml:space="preserve">
          <source>2b) the exception specification does not allow &lt;code&gt;&lt;a href=&quot;../bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt;: &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; is called.</source>
          <target state="translated">2b) 예외 사양에서는 &lt;code&gt;&lt;a href=&quot;../bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; 허용하지 않습니다 . &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ec9980ec2e616ee3315db433b1e89c30f9377afb" translate="yes" xml:space="preserve">
          <source>2c) if &lt;code&gt;T1&lt;/code&gt; is allocator-aware (&lt;code&gt;&lt;a href=&quot;../uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T1, inner_allocator_type&amp;gt;::value==true&lt;/code&gt;), and its constructor takes the allocator as the last argument (&lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, Args1..., inner_allocator_type&amp;amp;&amp;gt;::value==true&lt;/code&gt;), then &lt;code&gt;xprime&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../utility/tuple/tuple_cat&quot;&gt;std::tuple_cat&lt;/a&gt;(&lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;Args1&amp;amp;&amp;amp;...&amp;gt;(std::move(x)), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;inner_allocator_type&amp;amp;&amp;gt;(inner_allocator()))&lt;/code&gt;.  Same rules apply to &lt;code&gt;T2&lt;/code&gt; and the replacement of &lt;code&gt;y&lt;/code&gt; with &lt;code&gt;yprime&lt;/code&gt;  Once &lt;code&gt;xprime&lt;/code&gt; and &lt;code&gt;yprime&lt;/code&gt; are constructed, constructs the pair &lt;code&gt;p&lt;/code&gt; in allocated storage by calling</source>
          <target state="translated">2c) &lt;code&gt;T1&lt;/code&gt; 이 할당 자 인식 ( &lt;code&gt;&lt;a href=&quot;../uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T1, inner_allocator_type&amp;gt;::value==true&lt;/code&gt; )이고 생성자가 할당자를 마지막 인수 ( &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, Args1..., inner_allocator_type&amp;amp;&amp;gt;::value==true&lt;/code&gt; ) &lt;code&gt;xprime&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../../utility/tuple/tuple_cat&quot;&gt;std::tuple_cat&lt;/a&gt;(&lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;Args1&amp;amp;&amp;amp;...&amp;gt;(std::move(x)), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;inner_allocator_type&amp;amp;&amp;gt;(inner_allocator()))&lt;/code&gt; . 동일한 규칙이 &lt;code&gt;T2&lt;/code&gt; 에 적용되고 &lt;code&gt;y&lt;/code&gt; 를 &lt;code&gt;yprime&lt;/code&gt; 으로 교체 &lt;code&gt;xprime&lt;/code&gt; 및 &lt;code&gt;yprime&lt;/code&gt; 이 구성 되면 쌍 &lt;code&gt;p&lt;/code&gt; 를 구성합니다. 할당 된 스토리지에서</target>
        </trans-unit>
        <trans-unit id="7eb05f281d790790f78faabeb621483c68bf74dd" translate="yes" xml:space="preserve">
          <source>2i</source>
          <target state="translated">2i</target>
        </trans-unit>
        <trans-unit id="9a858fdd0a0969f96224393e42f1671ec2f233ef" translate="yes" xml:space="preserve">
          <source>2n</source>
          <target state="translated">2n</target>
        </trans-unit>
        <trans-unit id="2dcaeb9e7ed7e579aa8b8ba6e8829281084ce59d" translate="yes" xml:space="preserve">
          <source>2s2</source>
          <target state="translated">2s2</target>
        </trans-unit>
        <trans-unit id="77de68daecd823babbb58edb1c8e14d7106e83bb" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>
        </trans-unit>
        <trans-unit id="93ed9c6938b1842bf41a4b8540f19c023806ca02" translate="yes" xml:space="preserve">
          <source>3) (for data members only, not member functions) When used in &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;unevaluated operands&lt;/a&gt;.</source>
          <target state="translated">3) (데이터 멤버 만 해당, 멤버 함수는 아님) &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;평가되지 않은 피연산자에&lt;/a&gt; 사용되는 경우 .</target>
        </trans-unit>
        <trans-unit id="4fd3dc7487f8a80579d5f8be29c2412440b68dd8" translate="yes" xml:space="preserve">
          <source>3) (none).</source>
          <target state="translated">3) (없음).</target>
        </trans-unit>
        <trans-unit id="f412c21f9fd850859756cf6f8cde85c9cc2a4f8c" translate="yes" xml:space="preserve">
          <source>3) &lt;code&gt;(bool)(std::get&amp;lt;0&amp;gt;(lhs) &amp;lt; std::get&amp;lt;0&amp;gt;(rhs)) || (!(bool)(std::get&amp;lt;0&amp;gt;(rhs) &amp;lt; std::get&amp;lt;0&amp;gt;(lhs)) &amp;amp;&amp;amp; lhstail &amp;lt; rhstail)&lt;/code&gt;, where &lt;code&gt;lhstail&lt;/code&gt; is lhs without its first element, and &lt;code&gt;rhstail&lt;/code&gt; is rhs without its first element. For two empty tuples, returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;(bool)(std::get&amp;lt;0&amp;gt;(lhs) &amp;lt; std::get&amp;lt;0&amp;gt;(rhs)) || (!(bool)(std::get&amp;lt;0&amp;gt;(rhs) &amp;lt; std::get&amp;lt;0&amp;gt;(lhs)) &amp;amp;&amp;amp; lhstail &amp;lt; rhstail)&lt;/code&gt; 여기서 &lt;code&gt;lhstail&lt;/code&gt; 가 첫 요소없이 좌를이고 &lt;code&gt;rhstail&lt;/code&gt; 가 최초없이 우입니다 요소. 두 개의 빈 튜플의 경우 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e6a3ffaf1f8e433f953a495e10b6acbfb87664db" translate="yes" xml:space="preserve">
          <source>3) &lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;CT&amp;gt;()(x.get(), y.get())&lt;/code&gt;, where &lt;code&gt;CT&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;unique_ptr&amp;lt;T1, D1&amp;gt;::pointer, unique_ptr&amp;lt;T2, D2&amp;gt;::pointer&amp;gt;::type&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;CT&amp;gt;()(x.get(), y.get())&lt;/code&gt; , 여기서 &lt;code&gt;CT&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;unique_ptr&amp;lt;T1, D1&amp;gt;::pointer, unique_ptr&amp;lt;T2, D2&amp;gt;::pointer&amp;gt;::type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2be4071f71740c496b54640b542bc8c3b487d937" translate="yes" xml:space="preserve">
          <source>3) &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e1cbcd61f251bf7ac6d32239024455fbf326f65" translate="yes" xml:space="preserve">
          <source>3) &lt;code&gt;CT(lhs).count() &amp;lt; CT(rhs).count()&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;CT(lhs).count() &amp;lt; CT(rhs).count()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87bee209fbf0b7f657eeac78da3fcefe66a99f50" translate="yes" xml:space="preserve">
          <source>3) A</source>
          <target state="translated">3) A</target>
        </trans-unit>
        <trans-unit id="8f333f080a1eab002bc9740bac51bf9769477bd2" translate="yes" xml:space="preserve">
          <source>3) A &lt;a href=&quot;structured_binding&quot;&gt;structured binding&lt;/a&gt; is odr-used if it appears as a</source>
          <target state="translated">3) &lt;a href=&quot;structured_binding&quot;&gt;구조적 바인딩&lt;/a&gt; 이</target>
        </trans-unit>
        <trans-unit id="b188a6ff7ea0de5610c6653bc130c0fbd5477958" translate="yes" xml:space="preserve">
          <source>3) A &lt;code&gt;std::chrono::day&lt;/code&gt; value corresponding to the last day of the stored year and month.</source>
          <target state="translated">3) 저장된 연도 및 월의 마지막 날에 해당하는 &lt;code&gt;std::chrono::day&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="5a1c89bc54d1a6b6db2e7d3303f208fade04441e" translate="yes" xml:space="preserve">
          <source>3) A carries dependency into another evaluation X, and X carries dependency into B</source>
          <target state="translated">3) A는 다른 평가 X에 의존하고 X는 B에 의존한다</target>
        </trans-unit>
        <trans-unit id="7af017b7c88a6276245e5bf115b539d97b0b7ffa" translate="yes" xml:space="preserve">
          <source>3) A declaration that consists solely of an elaborated type specifier always declares a class type named by identifier in the &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; that contains the declaration.</source>
          <target state="translated">3) 정교한 형식 지정 자로 만 구성된 선언은 항상 선언 이 포함 된 &lt;a href=&quot;scope&quot;&gt;범위&lt;/a&gt; 에서 식별자로 명명 된 클래스 형식을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="39d0bb31e412d6eadcee39bd1861a2cc86e62eca" translate="yes" xml:space="preserve">
          <source>3) A non-type template &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; with an optional name.</source>
          <target state="translated">3) 선택적인 이름을 가진 유형이 아닌 템플릿 &lt;a href=&quot;parameter_pack&quot;&gt;매개 변수 팩&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d581f61df3255edce79e2bcf896c0f882f281e4" translate="yes" xml:space="preserve">
          <source>3) A non-type template argument or an array bound in which a subexpression references a template</source>
          <target state="translated">3) 타입이 아닌 템플릿 인수 또는 하위 표현식이 템플릿을 참조하는 바인딩 된 배열</target>
        </trans-unit>
        <trans-unit id="fa8572e10980da3c78b1f6510cdbda7fceba97e6" translate="yes" xml:space="preserve">
          <source>3) A specialization for user-defined fancy pointer types may define an additional static member function.</source>
          <target state="translated">3) 사용자 정의 팬시 포인터 유형에 대한 전문화는 추가 정적 멤버 함수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c89d927e6bd97c96c485fc4a17feacc218eb28b" translate="yes" xml:space="preserve">
          <source>3) A standard conversion sequence &lt;code&gt;S1&lt;/code&gt; is</source>
          <target state="translated">3) 표준 변환 순서 &lt;code&gt;S1&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="a404e0480fce5bf74f08f5befd742384386fb31b" translate="yes" xml:space="preserve">
          <source>3) A string containing the latest remote database version.</source>
          <target state="translated">3) 최신 원격 데이터베이스 버전을 포함하는 문자열.</target>
        </trans-unit>
        <trans-unit id="840f814d1ba6d22fe1578d48daf10220a13af485" translate="yes" xml:space="preserve">
          <source>3) A template template &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; with an optional name.</source>
          <target state="translated">3) 선택적인 이름을 가진 템플릿 템플릿 &lt;a href=&quot;parameter_pack&quot;&gt;매개 변수 팩&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="778baf7289829434b4c6c05167a0700403180cc6" translate="yes" xml:space="preserve">
          <source>3) A template template parameter pack with an optional name</source>
          <target state="translated">3) 선택적인 이름을 가진 템플릿 템플릿 매개 변수 팩</target>
        </trans-unit>
        <trans-unit id="770b543e148403ea4dededf7526f310ae3d46b3e" translate="yes" xml:space="preserve">
          <source>3) A type template &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt;.</source>
          <target state="translated">3) 타입 템플릿 &lt;a href=&quot;parameter_pack&quot;&gt;파라미터 팩&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14fdc9083f4eac7a50f08f933d275b687d9bb749" translate="yes" xml:space="preserve">
          <source>3) A value of any integral or enumeration type can be converted to a pointer type. A pointer converted to an integer of sufficient size and back to the same pointer type is guaranteed to have its original value, otherwise the resulting pointer cannot be dereferenced safely (the round-trip conversion in the opposite direction is not guaranteed; the same pointer may have multiple integer representations) The null pointer constant &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; or integer zero is not guaranteed to yield the null pointer value of the target type; &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt; or &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; should be used for this purpose.</source>
          <target state="translated">3) 정수 또는 열거 유형의 값을 포인터 유형으로 변환 할 수 있습니다. 충분한 크기의 정수로 변환되고 동일한 포인터 유형으로 다시 변환되는 포인터는 원래 값을 갖도록 보장됩니다. 그렇지 않으면 결과 포인터를 안전하게 참조 해제 할 수 없습니다 (반대 방향의 왕복 변환은 보장되지 않습니다. 동일한 포인터 다중 정수 표현이있는 경우) 널 포인터 상수 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 또는 정수 0은 목표 유형의 널 포인터 값을 산출하지 않습니다. &lt;a href=&quot;static_cast&quot;&gt;이를 위해 static_cast&lt;/a&gt; 또는 &lt;a href=&quot;implicit_cast&quot;&gt;암시 적 변환을&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f552c1726716c82fbccf7a2867e0be7c5de21a4c" translate="yes" xml:space="preserve">
          <source>3) An inline function or variable(since C++17) with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt; (e.g. not declared &lt;code&gt;static&lt;/code&gt;) has the following additional properties:</source>
          <target state="translated">3) &lt;a href=&quot;storage_duration&quot;&gt;외부 링크가&lt;/a&gt; 있는 인라인 함수 또는 변수 (C ++ 17 이후) (예 : &lt;code&gt;static&lt;/code&gt; 선언되지 않음 )에는 다음과 같은 추가 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e125c75ae4a99ed3a1eb8a67cdd34c16a97207b5" translate="yes" xml:space="preserve">
          <source>3) Analyzes a string &lt;code&gt;s&lt;/code&gt;. Match results are returned in &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">3) 문자열 &lt;code&gt;s&lt;/code&gt; 를 분석합니다 . 일치 결과는 &lt;code&gt;m&lt;/code&gt; 으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="99c474666d172eea06f27f6e7791328349727abf" translate="yes" xml:space="preserve">
          <source>3) Any exception thrown by the move constructor of &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;value&lt;/code&gt; 의 이동 생성자가 던진 예외</target>
        </trans-unit>
        <trans-unit id="277dd10cd98338b61305a206c3ba9cc041bb39c5" translate="yes" xml:space="preserve">
          <source>3) Any exceptions thrown by copy/move constructor of &lt;code&gt;f&lt;/code&gt; and by the allocator's &lt;code&gt;allocate&lt;/code&gt; function if memory allocation fails.</source>
          <target state="translated">3) &lt;code&gt;f&lt;/code&gt; 의 복사 / 이동 생성자 와 메모리 할당에 실패한 경우 할당 자의 &lt;code&gt;allocate&lt;/code&gt; 함수에 의해 발생하는 예외 .</target>
        </trans-unit>
        <trans-unit id="c344ba4971b23645d12f07ff10b697bda0957870" translate="yes" xml:space="preserve">
          <source>3) Any exceptions thrown by the &lt;code&gt;Compare&lt;/code&gt; object.</source>
          <target state="translated">3) &lt;code&gt;Compare&lt;/code&gt; 객체에 의해 발생 된 예외 .</target>
        </trans-unit>
        <trans-unit id="711b68a51c1768e3b8e3ae3b077cfbddb75664a9" translate="yes" xml:space="preserve">
          <source>3) Appends a substring &lt;code&gt;[pos, pos+count)&lt;/code&gt; of &lt;code&gt;str&lt;/code&gt;. If the requested substring lasts past the end of the string, or if &lt;code&gt;count == npos&lt;/code&gt;, the appended substring is &lt;code&gt;[pos, size())&lt;/code&gt;. If &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">3) &lt;code&gt;str&lt;/code&gt; 의 하위 문자열 &lt;code&gt;[pos, pos+count)&lt;/code&gt; 을 추가합니다 . 요청 된 하위 문자열이 문자열의 끝을 지난 경우 또는 &lt;code&gt;count == npos&lt;/code&gt; 인 경우 추가 된 하위 문자열은 &lt;code&gt;[pos, size())&lt;/code&gt; 입니다. 경우 &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="80e2a402b0577257e8c7923fedcad6eb1cc319fe" translate="yes" xml:space="preserve">
          <source>3) Applies &lt;code&gt;unary_op&lt;/code&gt; to each element in the range [first; last) and reduces the results (possibly permuted and aggregated in unspecified manner) along with the initial value &lt;code&gt;init&lt;/code&gt; over &lt;code&gt;binary_op&lt;/code&gt;.</source>
          <target state="translated">3) 적용 &lt;code&gt;unary_op&lt;/code&gt; 제 범위 [각 요소; 마지막) 초기 값과 함께 결과 (가능한 순열의 불특정하게 응집) 감소 &lt;code&gt;init&lt;/code&gt; 위에 &lt;code&gt;binary_op&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="c31e7c2f08c0e946090d4f29f5797e5765024af1" translate="yes" xml:space="preserve">
          <source>3) Applies the offset &lt;code&gt;d&lt;/code&gt; to &lt;code&gt;pt&lt;/code&gt; in negative direction. Effectively returns &lt;code&gt;CT(ot.time_since_epoch() - d)&lt;/code&gt;, where &lt;code&gt;CT&lt;/code&gt; is the return type.</source>
          <target state="translated">3) 오프셋 &lt;code&gt;d&lt;/code&gt; 를 음의 방향으로 &lt;code&gt;pt&lt;/code&gt; 에 적용합니다 . 효과적으로 반환 &lt;code&gt;CT(ot.time_since_epoch() - d)&lt;/code&gt; 여기서, &lt;code&gt;CT&lt;/code&gt; 는 복귀 형이다.</target>
        </trans-unit>
        <trans-unit id="4de92ce9b6ae9639e9b18c50ba6cdaf2bfe64abf" translate="yes" xml:space="preserve">
          <source>3) Assigns a null-terminated character string pointed to by &lt;code&gt;ptr&lt;/code&gt;. Equivalent to &lt;code&gt;assign(ptr);&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;ptr&lt;/code&gt; 이 가리키는 null로 끝나는 문자열을 할당합니다 . 등가 &lt;code&gt;assign(ptr);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afa3c34805c67bd23f3ac1c048f464b6df724f6b" translate="yes" xml:space="preserve">
          <source>3) Assigns a null-terminated string pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;s&lt;/code&gt; 가 가리키는 null로 끝나는 문자열을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="8d825df8ba69b54dafc39a8f5e95c82cb9c5a093" translate="yes" xml:space="preserve">
          <source>3) Assigns the pathname identified by detected-format character range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">3) 감지 된 형식 문자 범위 &lt;code&gt;[first, last)&lt;/code&gt; 식별되는 경로 이름을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="5e2f95e0668e5ea74a4004353550d86f7032a01d" translate="yes" xml:space="preserve">
          <source>3) Assigns the selected elements from &lt;code&gt;sl_arr&lt;/code&gt; to the referred to elements of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;sl_arr&lt;/code&gt; 에서 선택된 요소를 &lt;code&gt;*this&lt;/code&gt; 의 참조 된 요소에 지정 합니다 .</target>
        </trans-unit>
        <trans-unit id="bcf8c246ad821da73e30c82a073b3e8a40983b64" translate="yes" xml:space="preserve">
          <source>3) Assigns the type and value of &lt;code&gt;rhs&lt;/code&gt;, as if by &lt;code&gt;any(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;ValueType&amp;gt;(rhs)).swap(*this)&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; is not the same type as &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. .</source>
          <target state="translated">3) 마치 &lt;code&gt;any(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;ValueType&amp;gt;(rhs)).swap(*this)&lt;/code&gt; &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;ValueType&amp;gt; (rhs)). swap (* this) 처럼 &lt;code&gt;rhs&lt;/code&gt; 의 유형과 값을 지정 합니다. 경우에 과부하는 오버로드 확인에 참여 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; &amp;lt;치형&amp;gt; 있는 그대로가 아니라 같은 종류의 &lt;code&gt;any&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt; &lt;a href=&quot;../../types/decay&quot;&gt;표준 : decay_t&lt;/a&gt; &amp;lt;치형이 &amp;gt;&amp;gt; 입니다 &lt;code&gt;true&lt;/code&gt; . .</target>
        </trans-unit>
        <trans-unit id="72455795a2eb56051b09bfa5eae38d55c9855cf4" translate="yes" xml:space="preserve">
          <source>3) At the end of this phase, all preprocessor directives are removed from the source.</source>
          <target state="translated">3)이 단계가 끝나면 모든 전 처리기 지시문이 소스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b617b63b51df48825f9812a2ff92c4ab9db6bbd3" translate="yes" xml:space="preserve">
          <source>3) Atomic types are not copy/move constructible</source>
          <target state="translated">3) 원 자형은 복사 / 이동이 불가능하다</target>
        </trans-unit>
        <trans-unit id="125fa86e943fea4422d5e5c22612a46dba3c3dc2" translate="yes" xml:space="preserve">
          <source>3) Atomic variables are not &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">3) 원자 변수는 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="df76596a0cd8cc957f4b28abfe1ee8efc6c0976e" translate="yes" xml:space="preserve">
          <source>3) Average case: &lt;code&gt;c.count(key)&lt;/code&gt;, worst case: &lt;code&gt;c.size()&lt;/code&gt;</source>
          <target state="translated">3) 평균 사례 : &lt;code&gt;c.count(key)&lt;/code&gt; , 최악의 경우 : &lt;code&gt;c.size()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a4709e9943c676621b3bd79567e41f762a7b9cb" translate="yes" xml:space="preserve">
          <source>3) Behaves the same as the reset member of the primary template, except that it will only participate in overload resolution if either</source>
          <target state="translated">3) 기본 템플릿의 재설정 멤버와 동일하게 작동합니다. 단 하나의 경우에만 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="db0a5cb60cad1b857e2dc32774d4170343af6876" translate="yes" xml:space="preserve">
          <source>3) Binary right fold (E op ... op I) becomes (E</source>
          <target state="translated">3) 이진 오른쪽 접기 (E op ... op I)는 (E</target>
        </trans-unit>
        <trans-unit id="a6c533dca72a273606f1a4bdcd3aae2cd8adcbd1" translate="yes" xml:space="preserve">
          <source>3) Both ranges must be sorted with the given comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">3) 주어진 비교 함수 &lt;code&gt;comp&lt;/code&gt; 로 두 범위를 정렬해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9f24dab55a5be9d15ce3a2dfff9cf8e261471119" translate="yes" xml:space="preserve">
          <source>3) Called by non-array &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate storage required for a single object whose alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;</source>
          <target state="translated">3) 정렬 요구 사항이 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 를 초과하는 단일 객체에 필요한 스토리지를 할당하기 위해 비 배열 &lt;a href=&quot;../../language/new&quot;&gt;새 표현식&lt;/a&gt; 에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="517a2e7859fad342e8339288262270e3d64cd5ae" translate="yes" xml:space="preserve">
          <source>3) Calls every callback registered by &lt;code&gt;&lt;a href=&quot;../ios_base/register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; passing &lt;a href=&quot;../ios_base/event&quot;&gt;&lt;code&gt;copyfmt_event&lt;/code&gt;&lt;/a&gt; as parameter</source>
          <target state="translated">3) &lt;a href=&quot;../ios_base/event&quot;&gt; &lt;code&gt;copyfmt_event&lt;/code&gt; &lt;/a&gt; 를 매개 변수로 전달 하여 &lt;code&gt;&lt;a href=&quot;../ios_base/register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; 의해 등록 된 모든 콜백을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="138ee6153e3047f1d93689ab3206212aab811973" translate="yes" xml:space="preserve">
          <source>3) Calls the appropriate insertion operator, given an rvalue reference to an output stream object (equivalent to &lt;code&gt;os &amp;lt;&amp;lt; value&lt;/code&gt;). This function template does not participate in overload resolution unless the expression &lt;code&gt;os &amp;lt;&amp;lt; value&lt;/code&gt; is well-formed.(since C++17)</source>
          <target state="translated">3) 출력 스트림 객체에 대한 rvalue 참조가 주어지면 적절한 삽입 연산자를 호출합니다 ( &lt;code&gt;os &amp;lt;&amp;lt; value&lt;/code&gt; 와 동일 ). 이 함수 템플릿은 &lt;code&gt;os &amp;lt;&amp;lt; value&lt;/code&gt; 식이 제대로 구성되어 있지 않으면 과부하 해결에 참여하지 않습니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="de070a5983dd60787ac4aa28adf1665de1e9000e" translate="yes" xml:space="preserve">
          <source>3) Catch-all handler, which is activated for any exception</source>
          <target state="translated">3) 모든 예외에 대해 활성화되는 Catch-all 핸들러</target>
        </trans-unit>
        <trans-unit id="0dc4b2fd6e3b694b7ff8fd35f20434adce6f039f" translate="yes" xml:space="preserve">
          <source>3) Checks if none of the bits are set to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">3) 비트가 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있지 않은지 확인</target>
        </trans-unit>
        <trans-unit id="6982458057cdcb098a70a57ce003a934dc6a6555" translate="yes" xml:space="preserve">
          <source>3) Checks if the character &lt;code&gt;c&lt;/code&gt; is classified by the mask &lt;code&gt;m&lt;/code&gt;</source>
          <target state="translated">3) 문자 &lt;code&gt;c&lt;/code&gt; 가 마스크 &lt;code&gt;m&lt;/code&gt; 으로 분류 되는지 확인</target>
        </trans-unit>
        <trans-unit id="3f66e3e4edb359a08dd261ed52a0bda80001c7a1" translate="yes" xml:space="preserve">
          <source>3) Checks if unary predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for at least one element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">3) 단항 술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;[first, last)&lt;/code&gt; 범위에있는 하나 이상의 요소에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="a6ad21aeb5bc08ed6ed57f70c99d7834d64b675d" translate="yes" xml:space="preserve">
          <source>3) Checks if unary predicate &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for at least one element in the range &lt;code&gt;[first, last)&lt;/code&gt; (after projecting with the projection &lt;code&gt;proj&lt;/code&gt;).</source>
          <target state="translated">3) 단항 술어 &lt;code&gt;pred&lt;/code&gt; 가 ( &lt;code&gt;proj&lt;/code&gt; 투영 한 후 &lt;code&gt;[first, last)&lt;/code&gt; 범위에있는 하나 이상의 요소에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="8551280e75bef1b3f4675121add3c0f3124fb646" translate="yes" xml:space="preserve">
          <source>3) Checks whether &lt;a href=&quot;root_directory&quot;&gt;&lt;code&gt;root_directory()&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">3) &lt;a href=&quot;root_directory&quot;&gt; &lt;code&gt;root_directory()&lt;/code&gt; &lt;/a&gt; 가 비어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="cc9f436acf6b24c0d26142d074257a80ae6cc54c" translate="yes" xml:space="preserve">
          <source>3) Checks whether &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">3) &lt;code&gt;lhs&lt;/code&gt; 가 있는지 확인</target>
        </trans-unit>
        <trans-unit id="24e17aba77f331c3ab3ac15c7858d72606dceab0" translate="yes" xml:space="preserve">
          <source>3) Checks whether &lt;code&gt;lhs&lt;/code&gt; is less than &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;lhs&lt;/code&gt; 가 &lt;code&gt;rhs&lt;/code&gt; 보다 작은 지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="d2f3181e798a05645e2751614f028ec0cfcd196d" translate="yes" xml:space="preserve">
          <source>3) Checks whether &lt;code&gt;lhs&lt;/code&gt; is less than &lt;code&gt;rhs&lt;/code&gt;. Equivalent to &lt;code&gt;lhs.compare(rhs) &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;lhs&lt;/code&gt; 가 &lt;code&gt;rhs&lt;/code&gt; 보다 작은 지 확인합니다 . 상당 &lt;code&gt;lhs.compare(rhs) &amp;lt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb940299605f34d29ed114c450d6d0424c55fa83" translate="yes" xml:space="preserve">
          <source>3) Compares a &lt;code&gt;[pos1, pos1+count1)&lt;/code&gt; substring of this string to a substring &lt;code&gt;[pos2, pos2+count2)&lt;/code&gt; of</source>
          <target state="translated">3) 이 문자열 의 &lt;code&gt;[pos1, pos1+count1)&lt;/code&gt; 하위 문자열을 다음의 하위 문자열 &lt;code&gt;[pos2, pos2+count2)&lt;/code&gt; 과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="4af7afc9d4203c77090cf48e632fdd4573df17e1" translate="yes" xml:space="preserve">
          <source>3) Compares a &lt;code&gt;sub_match&lt;/code&gt; with a null-terminated sequence of the underlying character type pointed to by &lt;code&gt;s&lt;/code&gt;. Equivalent to &lt;code&gt;str().compare(c)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;s&lt;/code&gt; 가 가리키는 기본 문자 유형의 null로 끝나는 시퀀스와 &lt;code&gt;sub_match&lt;/code&gt; 를 비교합니다 . 동등 &lt;code&gt;str().compare(c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f69c1fbb422599bc962725dbb96d7bdaad883f11" translate="yes" xml:space="preserve">
          <source>3) Computes the</source>
          <target state="translated">3) 계산</target>
        </trans-unit>
        <trans-unit id="a465bbf8b7710efdab73d9b8968c0c39cc33a3c0" translate="yes" xml:space="preserve">
          <source>3) Computes the inverse tangent of &lt;code&gt;vy&lt;/code&gt; and each value in the numeric array &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;vy&lt;/code&gt; 의 역 탄젠트 와 숫자 형 배열 &lt;code&gt;x&lt;/code&gt; 의 각 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="23b37ceb45df6ff2140af9f2e37a5581f8c59a28" translate="yes" xml:space="preserve">
          <source>3) Computes the values of &lt;code&gt;vbase&lt;/code&gt; raised to the power defined by the elements in the numeric array &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">3) 숫자 형 배열 &lt;code&gt;exp&lt;/code&gt; 의 요소로 정의 된 &lt;code&gt;vbase&lt;/code&gt; 올린 vbase 값을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="e286893b47fa45ff6c3363e04afec204645e51c3" translate="yes" xml:space="preserve">
          <source>3) Constant if &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;, otherwise linear in &lt;code&gt;&lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;other&lt;/code&gt; 가 &lt;code&gt;*this&lt;/code&gt; 와 동일한 객체를 참조 하면 상수 , 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 에서 선형입니다 .</target>
        </trans-unit>
        <trans-unit id="e57bad1d757a6ed22cdc55d4717801ae6b025f43" translate="yes" xml:space="preserve">
          <source>3) Constructs a &lt;code&gt;std::basic_stringbuf&lt;/code&gt; object by performing the same initialization as 1), followed by initializing the associated character sequence as if by calling &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str(new_str)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">3) 1)과 동일한 초기화를 수행 한 후 &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str(new_str)&lt;/a&gt;&lt;/code&gt; 을 호출하는 것처럼 관련 문자 시퀀스를 초기화하여 &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 객체를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="00f3989c9581377f00769097da18714b0f548a59" translate="yes" xml:space="preserve">
          <source>3) Constructs a &lt;code&gt;std::default_delete&amp;lt;U[]&amp;gt;&lt;/code&gt; object from another &lt;code&gt;std::default_delete&amp;lt;U[]&amp;gt;&lt;/code&gt; object. This constructor will only participate in overload resolution if &lt;code&gt;U(*)[]&lt;/code&gt; is implicitly convertible to &lt;code&gt;T(*)[]&lt;/code&gt;.</source>
          <target state="translated">3) 다른 &lt;code&gt;std::default_delete&amp;lt;U[]&amp;gt;&lt;/code&gt; 객체로부터 &lt;code&gt;std::default_delete&amp;lt;U[]&amp;gt;&lt;/code&gt; 객체를 구성합니다. 이 생성자는 &lt;code&gt;U(*)[]&lt;/code&gt; 이 암시 적으로 &lt;code&gt;T(*)[]&lt;/code&gt; 로 변환 가능한 경우에만 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="96dd5708df38048ad24e2fe617abdc01737563f0" translate="yes" xml:space="preserve">
          <source>3) Constructs a &lt;code&gt;std::packaged_task&lt;/code&gt; object with a shared state and a copy of the task, initialized with &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;. Uses the provided allocator to allocate memory necessary to store the task. This constructor does not participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;../packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&amp;lt;R(ArgTypes...)&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">3) 공유 상태와 작업의 복사본을 가진 &lt;code&gt;std::packaged_task&lt;/code&gt; 객체를 구성하고 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; 초기화 합니다. 제공된 할당자를 사용하여 작업을 저장하는 데 필요한 메모리를 할당합니다. &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&amp;lt;R(ArgTypes...)&amp;gt;&lt;/code&gt; 와 동일한 유형 인 경우이 생성자는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cb8305cde77f61f5d205904b755db7179acca055" translate="yes" xml:space="preserve">
          <source>3) Constructs a &lt;code&gt;std::seed_seq&lt;/code&gt; with the initial seed sequence obtained by iterating over the range &lt;code&gt;[begin, end)&lt;/code&gt; and copying the values obtained by dereferencing the iterator, modulo 232</source>
          <target state="translated">3) 범위 &lt;code&gt;[begin, end)&lt;/code&gt; 반복하고 반복자를 역 참조하여 얻은 값을 모듈로 232로 복사하여 얻은 초기 시드 시퀀스 로 &lt;code&gt;std::seed_seq&lt;/code&gt; 를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="13a04e470438cbc38e9779df6f1cea0bcdcef69e" translate="yes" xml:space="preserve">
          <source>3) Constructs a &lt;code&gt;time_point&lt;/code&gt; by converting &lt;code&gt;t&lt;/code&gt; to &lt;code&gt;duration&lt;/code&gt;. This constructor only participates in overload resolution if &lt;code&gt;Duration2&lt;/code&gt; is implicitly convertible to &lt;code&gt;duration&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;t&lt;/code&gt; 를 &lt;code&gt;duration&lt;/code&gt; 으로 변환 하여 &lt;code&gt;time_point&lt;/code&gt; 를 구성합니다 . &lt;code&gt;Duration2&lt;/code&gt; 가 묵시적으로 &lt;code&gt;duration&lt;/code&gt; 로 변환 가능한 경우에만이 생성자는 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="a2a1529ec0920516a4d3095830d89fe2d0a3f650" translate="yes" xml:space="preserve">
          <source>3) Constructs a &lt;code&gt;weekday&lt;/code&gt; object representing the day of the week &lt;code&gt;dp&lt;/code&gt; corresponds to. This constructor defines an implicit conversion from &lt;code&gt;std::chrono::sys_days&lt;/code&gt; to &lt;code&gt;weekday&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;dp&lt;/code&gt; 에 해당 하는 &lt;code&gt;weekday&lt;/code&gt; 나타내는 요일 객체를 구성합니다 . 이 생성자는 &lt;code&gt;std::chrono::sys_days&lt;/code&gt; 에서 &lt;code&gt;weekday&lt;/code&gt; 로의 암시 적 변환을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="99a57aece3f0696c55f367ff55ed379ddd1a6cf7" translate="yes" xml:space="preserve">
          <source>3) Constructs a &lt;code&gt;year_month_day&lt;/code&gt; object that stores the year &lt;code&gt;ymdl.year()&lt;/code&gt;, month &lt;code&gt;ymdl.month()&lt;/code&gt; and day &lt;code&gt;ymdl.day()&lt;/code&gt;.</source>
          <target state="translated">3) 연도 &lt;code&gt;ymdl.year()&lt;/code&gt; , 월 &lt;code&gt;ymdl.month()&lt;/code&gt; 및 &lt;code&gt;ymdl.day()&lt;/code&gt; 일 을 저장 하는 &lt;code&gt;year_month_day&lt;/code&gt; 객체를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="476b68f911e0029bec53a4f4a3685c41402606cb" translate="yes" xml:space="preserve">
          <source>3) Constructs a &lt;code&gt;year_month_weekday&lt;/code&gt; object corresponding to the date represented by &lt;code&gt;dp&lt;/code&gt;. For any &lt;code&gt;year_month_weekday&lt;/code&gt; object storing a valid date, converting it to &lt;code&gt;sys_days&lt;/code&gt; and back yields the same value. This constructor defines an implicit conversion from &lt;code&gt;sys_days&lt;/code&gt; to &lt;code&gt;year_month_weekday&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;dp&lt;/code&gt; 로 나타내는 날짜에 해당 하는 &lt;code&gt;year_month_weekday&lt;/code&gt; 객체를 구성합니다 . 어떤 내용 &lt;code&gt;year_month_weekday&lt;/code&gt; 의 오브젝트가 유효한 날짜를 기억로 변환 &lt;code&gt;sys_days&lt;/code&gt; 뒷면과 동일한 값을 산출한다. 이 생성자에서 암시 적 변환을 정의 &lt;code&gt;sys_days&lt;/code&gt; 에 &lt;code&gt;year_month_weekday&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="91b0e2de75ca61ecc916b3d71ac67dbe804f50e5" translate="yes" xml:space="preserve">
          <source>3) Constructs a bitset using the characters in the &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;&lt;code&gt;str&lt;/code&gt;. An optional starting position &lt;code&gt;pos&lt;/code&gt; and length &lt;code&gt;n&lt;/code&gt; can be provided, as well as characters denoting alternate values for set (&lt;code&gt;one&lt;/code&gt;) and unset (&lt;code&gt;zero&lt;/code&gt;) bits. &lt;code&gt;Traits::eq()&lt;/code&gt; is used to compare the character values.</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; &lt;code&gt;str&lt;/code&gt; 의 문자를 사용하여 비트 세트를 구성합니다 . 선택적인 시작 위치 &lt;code&gt;pos&lt;/code&gt; 및 길이 &lt;code&gt;n&lt;/code&gt; 과 세트 ( &lt;code&gt;one&lt;/code&gt; ) 및 설정되지 않은 ( &lt;code&gt;zero&lt;/code&gt; ) 비트의 대체 값을 나타내는 문자가 제공 될 수 있습니다 . &lt;code&gt;Traits::eq()&lt;/code&gt; 는 문자 값을 비교하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2ecc8edae63177c476e693356ecaafbb380e0079" translate="yes" xml:space="preserve">
          <source>3) Constructs a copy of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;other&lt;/code&gt; 사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2c604462fc4435d3e62e6e0e1364f0662b73eca6" translate="yes" xml:space="preserve">
          <source>3) Constructs a copy of &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; , this copy constructor is a trivial copy constructor.</source>
          <target state="translated">3) &lt;code&gt;other&lt;/code&gt; 사본을 만듭니다. 경우 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; 이 복사 생성자는 사소한 복사 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="b6551e4ab1347d774118033aacfc8b835d211089" translate="yes" xml:space="preserve">
          <source>3) Constructs a distribution object where the intervals are taken from the initializer list &lt;code&gt;bl&lt;/code&gt; and the weights generated by the function &lt;code&gt;fw&lt;/code&gt;.</source>
          <target state="translated">3) 이니셜 라이저 목록 &lt;code&gt;bl&lt;/code&gt; 에서 간격이 취해지는 분포 객체 와 함수 &lt;code&gt;fw&lt;/code&gt; 에 의해 생성 된 가중치를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="fe98fada32eafe7fee0c1f9b54c5d85a913e88ea" translate="yes" xml:space="preserve">
          <source>3) Constructs a distribution object where the intervals are taken from the initializer list &lt;code&gt;ilist&lt;/code&gt; and the weights generated by the function &lt;code&gt;fw&lt;/code&gt;.</source>
          <target state="translated">3) 이니셜 라이저 목록 &lt;code&gt;ilist&lt;/code&gt; 에서 간격이 취해지는 분포 객체 와 함수 &lt;code&gt;fw&lt;/code&gt; 에 의해 생성 된 가중치를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="9010ff91722191d49898f46fb2db293153fd9fcb" translate="yes" xml:space="preserve">
          <source>3) Constructs a duration with &lt;code&gt;r&lt;/code&gt; ticks. Note that this constructor only participates in overload resolution if &lt;code&gt;Rep2&lt;/code&gt; (the argument type) is implicitly convertible to &lt;code&gt;rep&lt;/code&gt; (the type of this duration's ticks) and</source>
          <target state="translated">3) &lt;code&gt;r&lt;/code&gt; 틱 으로 지속 시간을 구성합니다 . 이 생성자는 &lt;code&gt;Rep2&lt;/code&gt; (인수 유형)가 암시 적으로 &lt;code&gt;rep&lt;/code&gt; (이 기간의 눈금 유형)로 암시 적으로 변환 될 수있는 경우에만 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="5fcbc718af2ff4abacd7d3b3cccb97a2e4243517" translate="yes" xml:space="preserve">
          <source>3) Constructs a numeric array with &lt;code&gt;count&lt;/code&gt; copies of &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;val&lt;/code&gt; 의 &lt;code&gt;count&lt;/code&gt; 사본으로 숫자 형 배열을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="c7e48481604863d0dfa95055a712627ab6abe30d" translate="yes" xml:space="preserve">
          <source>3) Constructs a regex from a sequence of &lt;code&gt;count&lt;/code&gt; characters, pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;s&lt;/code&gt; 가 가리키는 일련의 &lt;code&gt;count&lt;/code&gt; 문자 로 정규식을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="3df5c87f17409e414fcfbef003853974662da9be" translate="yes" xml:space="preserve">
          <source>3) Constructs a span that is a view over the range &lt;code&gt;[first, last)&lt;/code&gt;; equivalent to &lt;code&gt;span(first, last - first)&lt;/code&gt;.</source>
          <target state="translated">3) 범위 &lt;code&gt;[first, last)&lt;/code&gt; 범위에 대한 범위 인 범위를 구성합니다 . 등가 &lt;code&gt;span(first, last - first)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67ec80fdc38d323b47d618c8fc41ea3821841740" translate="yes" xml:space="preserve">
          <source>3) Constructs a view of the first &lt;code&gt;count&lt;/code&gt; characters of the character array starting with the element pointed by &lt;code&gt;s&lt;/code&gt;. &lt;code&gt;s&lt;/code&gt; can contain null characters. The behavior is undefined if &lt;code&gt;[s, s+count)&lt;/code&gt; is not a valid range (even though the constructor may not access any of the elements of this range). After construction, &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;s&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;s&lt;/code&gt; 가 가리키는 요소로 시작하는 문자 배열 의 첫 번째 &lt;code&gt;count&lt;/code&gt; 문자 보기를 구성합니다 . &lt;code&gt;s&lt;/code&gt; 는 널 문자를 포함 할 수 있습니다. &lt;code&gt;[s, s+count)&lt;/code&gt; 가 유효한 범위가 아닌 경우 동작이 정의되지 않습니다 (생성자가이 범위의 요소에 액세스 할 수 없더라도). 생성 후 &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 와 같고 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;count&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="964a4bae8736a3a8075177aac2441d4c603692a7" translate="yes" xml:space="preserve">
          <source>3) Constructs error code from an error code enum &lt;code&gt;e&lt;/code&gt;. Equivalent to &lt;code&gt;*this = make_error_code(e)&lt;/code&gt;. The overload participates in overload resolutions only if &lt;code&gt;&lt;a href=&quot;is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&amp;lt;ErrorCodeEnum&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">3) 에러 코드 ENUM에서 에러 코드를 생성 &lt;code&gt;e&lt;/code&gt; . &lt;code&gt;*this = make_error_code(e)&lt;/code&gt; 와 같습니다 . &lt;code&gt;&lt;a href=&quot;is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&amp;lt;ErrorCodeEnum&amp;gt;::value == true&lt;/code&gt; 경우에만 과부하가 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="a3eb138f76af62a7607422b7f4c883c461912cca" translate="yes" xml:space="preserve">
          <source>3) Constructs the &lt;code&gt;wstring_convert&lt;/code&gt; object with a specified conversion facet and specified shift state, using default-constructed values for the error strings</source>
          <target state="translated">3) 오류 문자열에 대해 기본값으로 구성된 값을 사용하여 지정된 변환 패싯 및 지정된 시프트 상태로 &lt;code&gt;wstring_convert&lt;/code&gt; 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a33d1d304b0a25cef109d968ef63330daaa9f944" translate="yes" xml:space="preserve">
          <source>3) Constructs the container with &lt;code&gt;count&lt;/code&gt;&lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;default-inserted&lt;/a&gt; instances of &lt;code&gt;T&lt;/code&gt;. No copies are made.</source>
          <target state="translated">3) &lt;code&gt;count&lt;/code&gt; &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;디폴트 삽입&lt;/a&gt; 인스턴스 &lt;code&gt;T&lt;/code&gt; 로 컨테이너를 구축합니다 . 사본이 없습니다.</target>
        </trans-unit>
        <trans-unit id="830d36d02be6282ca0f8a0acac62fe5e14e68950" translate="yes" xml:space="preserve">
          <source>3) Constructs the distribution with weights in &lt;code&gt;weights&lt;/code&gt;. Effectively calls &lt;code&gt;discrete_distribution(weights.begin(), weights.end())&lt;/code&gt;.  4) Constructs the distribution with &lt;code&gt;count&lt;/code&gt; weights that are generated using function &lt;code&gt;unary_op&lt;/code&gt;. Each of the weights is equal to w.</source>
          <target state="translated">3) 가중치를 &lt;code&gt;weights&lt;/code&gt; 분포를 구성합니다 . 효과적으로 &lt;code&gt;discrete_distribution(weights.begin(), weights.end())&lt;/code&gt; 호출합니다 . 4) &lt;code&gt;unary_op&lt;/code&gt; 함수를 사용하여 생성 된 &lt;code&gt;count&lt;/code&gt; 가중치로 분포를 구성합니다 . 각 가중치는 w와 같습니다.</target>
        </trans-unit>
        <trans-unit id="3cd122753f7c40e2ec55d1daa7ae71573e4c662b" translate="yes" xml:space="preserve">
          <source>3) Constructs the engine and initializes the state by calling &lt;code&gt;s.generate(a, a+n*k)&lt;/code&gt; where a is an array of length n*k and k is ceil(w/32) and then, iteratively for i=-n,...,-1, setting each element of the engine state X</source>
          <target state="translated">3) 엔진을 구성하고 &lt;code&gt;s.generate(a, a+n*k)&lt;/code&gt; 를 호출하여 상태를 초기화합니다. 여기서 a는 길이 n * k의 배열이고 k는 ceil (w / 32)이고 i =-에 대해 반복적으로 n, ...,-1, 엔진 상태 X의 각 요소 설정</target>
        </trans-unit>
        <trans-unit id="feefcacec5d3c35a3cd07177a9d51f945c665e9c" translate="yes" xml:space="preserve">
          <source>3) Constructs the string with a substring &lt;code&gt;[pos, pos+count)&lt;/code&gt; of &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;count == npos&lt;/code&gt;, if &lt;code&gt;count&lt;/code&gt; is not specified, or if the requested substring lasts past the end of the string, the resulting substring is &lt;code&gt;[pos, other.size())&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;other&lt;/code&gt; 의 하위 문자열 &lt;code&gt;[pos, pos+count)&lt;/code&gt; 로 문자열을 구성합니다 . 경우 &lt;code&gt;count == npos&lt;/code&gt; , 만약 &lt;code&gt;count&lt;/code&gt; 지정되지 않거나 요구 스트링은 스트링의 끝을지나 지속되면, 결과 스트링은 &lt;code&gt;[pos, other.size())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54929ae13db823098c100ac62d399b341043eb6f" translate="yes" xml:space="preserve">
          <source>3) Constructs the underlying engine with seed sequence &lt;code&gt;seq&lt;/code&gt;. This constructor only participate in overload resolution if &lt;code&gt;Sseq&lt;/code&gt; qualifies as a &lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;. In particular, this constructor does not participate in overload resolution if &lt;code&gt;Sseq&lt;/code&gt; is implicitly convertible to &lt;code&gt;result_type&lt;/code&gt;.</source>
          <target state="translated">3) 시드 시퀀스 &lt;code&gt;seq&lt;/code&gt; 로 기본 엔진을 구성합니다 . 이 생성자 는 &lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;Sseq&lt;/a&gt; 가 &lt;code&gt;Sseq&lt;/code&gt; 자격이되는 경우에만 과부하 해결에 참여 합니다. 특히 &lt;code&gt;Sseq&lt;/code&gt; 가 암시 적으로 &lt;code&gt;result_type&lt;/code&gt; 으로 변환 가능한 경우이 생성자 는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7ff9e2d6bae24b89f3f3d60f64fe7f2302f8db90" translate="yes" xml:space="preserve">
          <source>3) Constructs with underlying error code &lt;code&gt;ev&lt;/code&gt; and associated error category &lt;code&gt;ecat&lt;/code&gt;.</source>
          <target state="translated">3) 기본 오류 코드 &lt;code&gt;ev&lt;/code&gt; 및 관련 오류 범주 &lt;code&gt;ecat&lt;/code&gt; 으로 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="f812bfcbb7b7abc8f2a249295f4b678a65bf2709" translate="yes" xml:space="preserve">
          <source>3) Conversion that converts pointer-to-derived to pointer-to-base is better than the conversion of pointer-to-derived to pointer-to-void, and conversion of pointer-to-base to void is better than pointer-to-derived to void.</source>
          <target state="translated">3) 포인터에서 파생 된 포인터를 포인터에서베이스로 변환하는 변환은 포인터에서 파생 된 포인터를 무효로 변환하는 것보다 낫고, 포인터를베이스에서 공백으로 변환하는 것이 포인터보다 낫다 무효화하기 위해 파생되었습니다.</target>
        </trans-unit>
        <trans-unit id="e63ec24229261a6479dd28ae8072057c214c2012" translate="yes" xml:space="preserve">
          <source>3) Converting constructor. Initializes each element of the tuple with the corresponding value in &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;UTypes&amp;gt;(args)&lt;/code&gt;.</source>
          <target state="translated">3) 변환 생성자. &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;UTypes&amp;gt;(args)&lt;/code&gt; 의 해당 값으로 튜플의 각 요소를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="af805f3b773460453ed30bf0c519ec57ec7edb30" translate="yes" xml:space="preserve">
          <source>3) Converts &lt;code&gt;other&lt;/code&gt; to a &lt;code&gt;std::chrono::sys_time&lt;/code&gt; as if by &lt;code&gt;zone-&amp;gt;to_sys(other)&lt;/code&gt; (where &lt;code&gt;zone&lt;/code&gt; is the non-static data member holding the stored time zone pointer) and assigns the result to the stored time point. The time zone pointer is unchanged. After this call, &lt;code&gt;get_local_time() == other&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;std::chrono::sys_time&lt;/code&gt; &lt;code&gt;zone-&amp;gt;to_sys(other)&lt;/code&gt; 의해 마치 &lt;code&gt;other&lt;/code&gt; 를 std :: chrono :: sys_time 으로 변환 하고 (여기서 &lt;code&gt;zone&lt;/code&gt; 은 저장된 시간대 포인터를 보유한 비 정적 데이터 멤버 임) 결과를 저장된 시간대에 할당합니다. 시간대 포인터는 변경되지 않습니다. 이 호출 후, &lt;code&gt;get_local_time() == other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb3f848d2885d8f262ac8c726f9425d1c4e86823" translate="yes" xml:space="preserve">
          <source>3) Converts a signed decimal integer to a string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%lld&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">3) 부호있는 십진 정수를 &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%lld&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에 대해 생성하는 내용과 동일한 내용의 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="e75aea4c132f1d76b2355f56c6289278e0523232" translate="yes" xml:space="preserve">
          <source>3) Converts a signed decimal integer to a wide string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%lld&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">3) 부호있는 십진 정수를 &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%lld&quot;, value)&lt;/code&gt; 가 충분히 큰 &lt;code&gt;buf&lt;/code&gt; 에 대해 생성하는 내용과 동일한 내용을 가진 넓은 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="dd8f5032db43607915e0d96906bf3d79af6eb796" translate="yes" xml:space="preserve">
          <source>3) Converts the (possibly wide) character &lt;code&gt;c&lt;/code&gt; to multibyte representation if the character can be represented with a single byte (for example, ASCII characters in UTF-8 encoding are single bytes). Returns &lt;code&gt;dflt&lt;/code&gt; if such conversion does not exist.</source>
          <target state="translated">3) 문자를 단일 바이트로 표시 할 수있는 경우 (가능하면 와이드 문자 &lt;code&gt;c&lt;/code&gt; ) 를 멀티 바이트 표시로 변환합니다 ( 예 : UTF-8 인코딩의 ASCII 문자는 단일 바이트 임). 그러한 변환이 존재하지 않으면 &lt;code&gt;dflt&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="31f9446d0d45d092b3886a9085482b5ea7b4f82b" translate="yes" xml:space="preserve">
          <source>3) Converts the calendar date and time stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object pointed to by &lt;code&gt;t&lt;/code&gt; into a character string, according to the format conversion sequence formed by concatenating &lt;code&gt;'%'&lt;/code&gt;, the value of &lt;code&gt;modifier&lt;/code&gt; if not &lt;code&gt;'\0'&lt;/code&gt;, and the value of &lt;code&gt;format&lt;/code&gt;. The format is interpreted the same way as the function &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt;, except that the formats that are described as locale-dependent are defined by this locale, and additional format specifiers may be supported (the &lt;code&gt;fill&lt;/code&gt; argument is provided for these implementation-defined format specifiers to use). The string is written to the output iterator &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">3)에 저장된 달력 날짜 및 시간 변환 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 오브젝트가 가리키는 &lt;code&gt;t&lt;/code&gt; 연결하여 형성되는 포맷 변환의 순서에 따라, 문자열에 &lt;code&gt;'%'&lt;/code&gt; 의 값을 &lt;code&gt;modifier&lt;/code&gt; 하지 않을 경우 &lt;code&gt;'\0'&lt;/code&gt; 및 값 &lt;code&gt;format&lt;/code&gt; . 형식은 로케일 종속으로 설명 된 형식이이 로케일에 의해 정의되고 추가 형식 지정자가 지원 될 수 있다는 점을 제외하고 &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; 함수와 동일한 방식으로 해석 됩니다 ( &lt;code&gt;fill&lt;/code&gt; 인수는 이러한 구현 정의에 제공됩니다) 사용할 형식 지정자). 문자열은 출력 반복자 출력에 기록 &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d88e37ff7b6eb3524e059b8810e273e70057345d" translate="yes" xml:space="preserve">
          <source>3) Converts the character &lt;code&gt;c&lt;/code&gt; to lower case if a lower case form is defined by this locale.</source>
          <target state="translated">3) 이 로케일로 소문자 형식이 정의 된 경우 문자 &lt;code&gt;c&lt;/code&gt; 를 소문자로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="1d53e1f3c14ea87c07a93345c0b40052af556c2d" translate="yes" xml:space="preserve">
          <source>3) Converts the character &lt;code&gt;c&lt;/code&gt; to upper case if an upper case form is defined by this locale.</source>
          <target state="translated">3) 이 로케일로 대문자 양식이 정의 된 경우 문자 &lt;code&gt;c&lt;/code&gt; 를 대문자로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="367ceb3385c6acfacdbf505e5a4a5dd25e4edee3" translate="yes" xml:space="preserve">
          <source>3) Converts the narrow string &lt;code&gt;str&lt;/code&gt; to wide_string.</source>
          <target state="translated">3) 좁은 문자열 &lt;code&gt;str&lt;/code&gt; 을 wide_string으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="61921ae71470ece8e99faa506a905265438537f8" translate="yes" xml:space="preserve">
          <source>3) Converts the single-byte character &lt;code&gt;c&lt;/code&gt; to the corresponding wide character representation using the simplest reasonable transformation. Typically, this applies only to the characters whose multibyte encoding is a single byte (e.g. U+0000-U+007F in UTF-8).</source>
          <target state="translated">3) 가장 간단한 합리적인 변환을 사용하여 1 바이트 문자 &lt;code&gt;c&lt;/code&gt; 를 해당 와이드 문자 표현으로 변환합니다. 일반적으로 이는 멀티 바이트 인코딩이 단일 바이트 인 문자에만 적용됩니다 (예 : UTF-8의 U + 0000-U + 007F).</target>
        </trans-unit>
        <trans-unit id="31c2af87cdf387057c1ad476332cd7f87f9f25b9" translate="yes" xml:space="preserve">
          <source>3) Converts the wide string &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;byte_string&lt;/code&gt;.</source>
          <target state="translated">3) 넓은 문자열 &lt;code&gt;str&lt;/code&gt; 을 &lt;code&gt;byte_string&lt;/code&gt; 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="68e37c01f15885010341eed1f8525729244327e1" translate="yes" xml:space="preserve">
          <source>3) Copies a &lt;code&gt;regex_iterator&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;regex_iterator&lt;/code&gt; 를 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="9a6178933fbb19c7258b289edd5b4e450a3bbb69" translate="yes" xml:space="preserve">
          <source>3) Copy constructor is deleted.</source>
          <target state="translated">3) 복사 생성자가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="96208b9a778d7b0bcebef2b7c7aff7a8dc5a3deb" translate="yes" xml:space="preserve">
          <source>3) Copy constructor. Constructs the container with the copy of the contents of &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;alloc&lt;/code&gt; is not provided, allocator is obtained by calling &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::select_on_container_copy_construction(other.get_allocator())&lt;/code&gt;.</source>
          <target state="translated">3) 복사 생성자. &lt;code&gt;other&lt;/code&gt; 의 내용을 복사하여 컨테이너를 구성합니다 . 경우 &lt;code&gt;alloc&lt;/code&gt; 제공되지 않고, 호출 할당함으로써 얻어지는 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::select_on_container_copy_construction(other.get_allocator())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c55c22645cc620c02a81fb5ca61445338606b562" translate="yes" xml:space="preserve">
          <source>3) Copy-constructor. Constructs a match result with a copy of &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">3) 복사 생성자. &lt;code&gt;rhs&lt;/code&gt; 복사본을 사용하여 일치 결과를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="efdb897683cf7111b40201a35236bb4fe024dc9f" translate="yes" xml:space="preserve">
          <source>3) Copy-constructor: initializes each allocator from the corresponding allocator of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">3) 복사 생성자 : &lt;code&gt;other&lt;/code&gt; 할당 자에서 각 할당자를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="a026ea4ae7c67343b1a2c863b4606ed80bd8ed23" translate="yes" xml:space="preserve">
          <source>3) Copy-constructs the underlying container &lt;code&gt;c&lt;/code&gt; with the contents of &lt;code&gt;cont&lt;/code&gt;. Copy-constructs the comparison functor &lt;code&gt;comp&lt;/code&gt; with the contents of &lt;code&gt;compare&lt;/code&gt;. Calls &lt;code&gt;&lt;a href=&quot;../../algorithm/make_heap&quot;&gt;std::make_heap&lt;/a&gt;(c.begin(), c.end(), comp)&lt;/code&gt;.  This is also the default constructor.(until C++11)</source>
          <target state="translated">3) 기본 컨테이너 &lt;code&gt;c&lt;/code&gt; 를 &lt;code&gt;cont&lt;/code&gt; 의 내용으로 복사 구성합니다 . 비교 functor &lt;code&gt;comp&lt;/code&gt; 를 &lt;code&gt;compare&lt;/code&gt; 의 내용으로 복사 합니다. &lt;code&gt;&lt;a href=&quot;../../algorithm/make_heap&quot;&gt;std::make_heap&lt;/a&gt;(c.begin(), c.end(), comp)&lt;/code&gt; 호출 합니다. 이것은 또한 기본 생성자입니다. (C ++ 11까지)</target>
        </trans-unit>
        <trans-unit id="256485a8519f254b2dc39000e98b72eb990ce7ed" translate="yes" xml:space="preserve">
          <source>3) Creates an optional object constructed in-place from &lt;code&gt;il&lt;/code&gt; and &lt;code&gt;args...&lt;/code&gt;. Equivalent to &lt;code&gt;return &lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;T&amp;gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place&lt;/a&gt;, il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;il&lt;/code&gt; 과 &lt;code&gt;args...&lt;/code&gt; 에서 제자리에 구성된 선택적 객체를 만듭니다 . &lt;code&gt;return &lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;T&amp;gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place&lt;/a&gt;, il, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt; &amp;lt;T&amp;gt; ( &lt;a href=&quot;../in_place&quot;&gt;std :: in_place&lt;/a&gt; , il, &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;Args&amp;gt; (args) ...); 를 반환하는 것과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="7aa2dd3231d1498c19cd0271b11d4ff43cd4ac9a" translate="yes" xml:space="preserve">
          <source>3) Creates new &lt;code&gt;std::thread&lt;/code&gt; object and associates it with a thread of execution. The new thread of execution starts executing</source>
          <target state="translated">3) 새로운 &lt;code&gt;std::thread&lt;/code&gt; 객체를 생성 하고이를 실행 스레드와 연결합니다. 새로운 실행 스레드가 실행을 시작합니다</target>
        </trans-unit>
        <trans-unit id="3624e9fc407de6e033f497636094f84ab9eb4ab4" translate="yes" xml:space="preserve">
          <source>3) Declares an unnamed parameter</source>
          <target state="translated">3) 명명되지 않은 매개 변수를 선언</target>
        </trans-unit>
        <trans-unit id="82314d8e4577e9e1f4378af06c54f895d00398d2" translate="yes" xml:space="preserve">
          <source>3) Defaulted move constructor.</source>
          <target state="translated">3) 기본 이동 생성자.</target>
        </trans-unit>
        <trans-unit id="08f8f359c5d1c597a7e97c802c134f8992f03134" translate="yes" xml:space="preserve">
          <source>3) Defines an</source>
          <target state="translated">3) 정의</target>
        </trans-unit>
        <trans-unit id="0bcda4427e20520699a650963f66ff8713a2c96d" translate="yes" xml:space="preserve">
          <source>3) Deleted default constructor: if it is selected by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, the program fails to compile.</source>
          <target state="translated">3) 삭제 된 기본 생성자 : &lt;a href=&quot;overload_resolution&quot;&gt;과부하 해결 방법으로&lt;/a&gt; 선택한 경우 프로그램이 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8c622798603707f70de1bc37982045bcd4b7a94" translate="yes" xml:space="preserve">
          <source>3) Deriving from &lt;code&gt;view_base&lt;/code&gt; enables &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; types to model &lt;code&gt;&lt;a href=&quot;../range/view&quot;&gt;View&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;view_base&lt;/code&gt; 에서 파생 하면 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 유형이 &lt;code&gt;&lt;a href=&quot;../range/view&quot;&gt;View&lt;/a&gt;&lt;/code&gt; 를 모델링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d760507a71a3d976887ec24433ae871eb44095f6" translate="yes" xml:space="preserve">
          <source>3) Designates the class, struct, or union named by the elaborated-class-specifier (see &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;) as a friend of this class. This means that the friend's member declarations and definitions can access private and protected members of this class and also that the friend can inherit from private and protected members of this class. The name of the class that is used in this friend declaration does not need to be previously declared.</source>
          <target state="translated">3) 정교한 클래스 지정자 ( &lt;a href=&quot;elaborated_type_specifier&quot;&gt;정교한 유형 지정자&lt;/a&gt; 참조)에 의해 명명 된 클래스, 구조체 또는 공용체 를이 클래스의 친구로 지정합니다 . 이는 친구의 멤버 선언 및 정의가이 클래스의 비공개 및 보호 된 멤버에 액세스 할 수 있고 친구가이 클래스의 비공개 및 보호 된 멤버로부터 상속받을 수 있음을 의미합니다. 이 친구 선언에 사용 된 클래스 이름은 미리 선언 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b69a0016830c846f181b39dcd147ee1a295aed28" translate="yes" xml:space="preserve">
          <source>3) Determines whether &lt;code&gt;Fn&lt;/code&gt; is callable with the arguments &lt;code&gt;ArgTypes...&lt;/code&gt; (same as (1)), and that such call is known not to throw any exceptions.</source>
          <target state="translated">3) &lt;code&gt;ArgTypes...&lt;/code&gt; ((1)과 동일) 인수를 사용하여 &lt;code&gt;Fn&lt;/code&gt; 을 호출 할 수 있는지 여부 와 이러한 호출이 예외를 발생시키지 않는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="85f4c27522c0349d0ae6adbeefa55004d2b19d37" translate="yes" xml:space="preserve">
          <source>3) Directly from within the body of a member function of X</source>
          <target state="translated">3) X의 멤버 함수 본문에서 직접</target>
        </trans-unit>
        <trans-unit id="6d2317fc5f8f9714149de99823ef08e6b0ec3451" translate="yes" xml:space="preserve">
          <source>3) Drops the current</source>
          <target state="translated">3) 전류를 떨어 뜨린다</target>
        </trans-unit>
        <trans-unit id="371ba3aa6758a6944bc9b3944af0b40ae779e73b" translate="yes" xml:space="preserve">
          <source>3) Each comment is replaced by one space character.</source>
          <target state="translated">3) 각 주석은 하나의 공백 문자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="358db00ca9b7b7ee0f23a4c02934608814d1a665" translate="yes" xml:space="preserve">
          <source>3) Effectively calls &lt;code&gt;reset(m.release())&lt;/code&gt;. &lt;code&gt;auto_ptr_ref&lt;/code&gt; is an implementation-defined type that holds a reference to &lt;code&gt;auto_ptr&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; is implicitly &lt;a href=&quot;operator_auto_ptr&quot;&gt;convertible to&lt;/a&gt; and &lt;a href=&quot;auto_ptr&quot;&gt;from&lt;/a&gt; this type. The implementation is allowed to provide the template with a different name or implement equivalent functionality in other ways.</source>
          <target state="translated">3) 효과적으로 &lt;code&gt;reset(m.release())&lt;/code&gt; 호출합니다 . &lt;code&gt;auto_ptr_ref&lt;/code&gt; 는 참조 보유 구현 정의 타입 &lt;code&gt;auto_ptr&lt;/code&gt; 은이 . &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; 암시 적이다 &lt;a href=&quot;operator_auto_ptr&quot;&gt;로 전환&lt;/a&gt; 하고 &lt;a href=&quot;auto_ptr&quot;&gt;에서&lt;/a&gt; 이러한 유형의. 구현시 템플릿에 다른 이름을 제공하거나 다른 방식으로 동등한 기능을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea208722e0a45d69241102c67a42ab1b3451dbab" translate="yes" xml:space="preserve">
          <source>3) Elements are compared using the given binary comparison function &lt;code&gt;comp&lt;/code&gt; and the ranges must be sorted with respect to the same.</source>
          <target state="translated">3) 주어진 이진 비교 함수 &lt;code&gt;comp&lt;/code&gt; 를 사용하여 요소를 비교 하고 범위는 동일한 것에 대해 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5d22482345876679aa9fdfb5d7b06e47e4ef8653" translate="yes" xml:space="preserve">
          <source>3) Elements are compared using the given binary comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">3) 주어진 이진 비교 함수 &lt;code&gt;comp&lt;/code&gt; 를 사용하여 요소를 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="59b37effce3cec5b869a56a3839a873a040b696e" translate="yes" xml:space="preserve">
          <source>3) Elements are compared using the given binary predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">3) 주어진 2 진 술어 &lt;code&gt;p&lt;/code&gt; 를 사용하여 요소를 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="17053674bbf2a8299fe18a28822bedb78c3e43d2" translate="yes" xml:space="preserve">
          <source>3) Elements are compared using the given binary predicate &lt;code&gt;p&lt;/code&gt;. The behavior is undefined if it is not an equivalence relation.</source>
          <target state="translated">3) 주어진 2 진 술어 &lt;code&gt;p&lt;/code&gt; 를 사용하여 요소를 비교합니다 . 동치 관계가 아닌 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91ebae6040c235a28005697223fcadfa976d1c3f" translate="yes" xml:space="preserve">
          <source>3) Elements are compared using the given comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">3) 주어진 비교 함수 &lt;code&gt;comp&lt;/code&gt; 를 사용하여 요소를 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="e6cf8873670f23aba3147d8e63b8ec2ca7a42a6a" translate="yes" xml:space="preserve">
          <source>3) Empty condition is equivalent to &lt;code&gt;while(true)&lt;/code&gt;</source>
          <target state="translated">3) 빈 상태는 &lt;code&gt;while(true)&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="febe29958b978cc0b5ed698897c04c8f1c90ad59" translate="yes" xml:space="preserve">
          <source>3) Equivalent to &lt;code&gt;*this = *this - dy;&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;*this = *this - dy;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55215fb0ae7aa1bda84ea52ce0fbe8b05b033324" translate="yes" xml:space="preserve">
          <source>3) Equivalent to &lt;code&gt;--d_; return *this;&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;--d_; return *this;&lt;/code&gt; 와 같습니다 . return * this;</target>
        </trans-unit>
        <trans-unit id="dfeae69bb12877f410f2084a8a1fec7071220c90" translate="yes" xml:space="preserve">
          <source>3) Equivalent to &lt;code&gt;--rep_; return *this;&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;--rep_; return *this;&lt;/code&gt; 와 같습니다 . return * this;</target>
        </trans-unit>
        <trans-unit id="28ad7cdc9d8ad0b552ad9519fa54146bb4fbd6db" translate="yes" xml:space="preserve">
          <source>3) Equivalent to &lt;code&gt;compare(path(s))&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;compare(path(s))&lt;/code&gt; )와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c1b42a201ef2b69b394c723dc2226ee5d29f1161" translate="yes" xml:space="preserve">
          <source>3) Equivalent to &lt;code&gt;construct(p, &lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;(), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;())&lt;/code&gt;, that is, passes the inner allocator on to the pair's member types if they accept them. 4) Equivalent to</source>
          <target state="translated">3) &lt;code&gt;construct(p, &lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;(), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;())&lt;/code&gt; 와 동일합니다. 즉, 내부 할당자를 허용하는 경우 내부 할당자를 쌍의 멤버 유형으로 전달합니다. 4) 해당</target>
        </trans-unit>
        <trans-unit id="ca271bc27bb8474ab419c4adc63a86f71a080cc3" translate="yes" xml:space="preserve">
          <source>3) Equivalent to &lt;code&gt;find(basic_string_view(s, count), pos)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;find(basic_string_view(s, count), pos)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="518e357748186b4bbd10dce6b0caf559889d1367" translate="yes" xml:space="preserve">
          <source>3) Equivalent to &lt;code&gt;find_first_not_of(basic_string_view(s, count), pos)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;find_first_not_of(basic_string_view(s, count), pos)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="689eda5bae81027f2f599a002893efef293ed99e" translate="yes" xml:space="preserve">
          <source>3) Equivalent to &lt;code&gt;find_first_of(basic_string_view(s, count), pos)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;find_first_of(basic_string_view(s, count), pos)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d655f76faa2a47414ae96366af6b3d45d8678096" translate="yes" xml:space="preserve">
          <source>3) Equivalent to &lt;code&gt;find_last_not_of(basic_string_view(s, count), pos)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;find_last_not_of(basic_string_view(s, count), pos)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="94546a75c6157c8961a1d464fa70fbf18c1722ef" translate="yes" xml:space="preserve">
          <source>3) Equivalent to &lt;code&gt;find_last_of(basic_string_view(s, count), pos)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;find_last_of(basic_string_view(s, count), pos)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f2c9d9a6578fab3a1310fb014e51bb73b63b4a8a" translate="yes" xml:space="preserve">
          <source>3) Equivalent to &lt;code&gt;rep_ *= rhs; return *this;&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;rep_ *= rhs; return *this;&lt;/code&gt; 와 동등 함 ; return * this;</target>
        </trans-unit>
        <trans-unit id="b1f2c02c0a848dd1986f1a6b291721df46d46019" translate="yes" xml:space="preserve">
          <source>3) Equivalent to &lt;code&gt;rfind(basic_string_view(s, count), pos)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;rfind(basic_string_view(s, count), pos)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7e4ac87b75bbf9fe4e9f8ec0af038f5fdcb3e071" translate="yes" xml:space="preserve">
          <source>3) Equivalent to &lt;code&gt;substr(pos1, count1).compare(v.substr(pos2, count2))&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;substr(pos1, count1).compare(v.substr(pos2, count2))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c29ecc183143b7582767ac6c6b23b3d8ccc95ae" translate="yes" xml:space="preserve">
          <source>3) Equivalent to multiple alignas specifiers applied to the same declaration, one for each member of the &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt;, which can be either type or non-type parameter pack.</source>
          <target state="translated">3) 동일한 선언에 적용되는 여러 개의 alignas 지정자와 동일하며, &lt;a href=&quot;parameter_pack&quot;&gt;매개 변수 팩&lt;/a&gt; 의 각 구성원마다 하나씩 ( 유형 또는 비 유형 매개 변수 팩일 수 있음).</target>
        </trans-unit>
        <trans-unit id="c2846db01371a2675f89c2fdde8bf5ebf2aaa44e" translate="yes" xml:space="preserve">
          <source>3) Equivalent to: &lt;code&gt;return compare_exchange_strong(expected, desired, order, fail_order);&lt;/code&gt;, where &lt;code&gt;fail_order&lt;/code&gt; is the same as &lt;code&gt;order&lt;/code&gt; except that &lt;code&gt;std:memory_order_acq_rel&lt;/code&gt; is replaced by &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; is replaced by &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">3) 다음과 같습니다. &lt;code&gt;return compare_exchange_strong(expected, desired, order, fail_order);&lt;/code&gt; 여기서 &lt;code&gt;fail_order&lt;/code&gt; 는 동일하다 &lt;code&gt;order&lt;/code&gt; 것을 제외 &lt;code&gt;std:memory_order_acq_rel&lt;/code&gt; 로 대체 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; 로 대체된다 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="300e574cb8d2b13ad4d80db6cdaab7e7dd27c5a7" translate="yes" xml:space="preserve">
          <source>3) Equivalent to: &lt;code&gt;return l = l ^ r;&lt;/code&gt;.</source>
          <target state="translated">3) 다음과 같습니다. &lt;code&gt;return l = l ^ r;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7f58ee1cc15a004eaa02255565eae7753771767" translate="yes" xml:space="preserve">
          <source>3) Equivalent to: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(l) ^ static_cast&amp;lt;unsigned int&amp;gt;(r));&lt;/code&gt;.</source>
          <target state="translated">3) 다음과 같습니다. &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(l) ^ static_cast&amp;lt;unsigned int&amp;gt;(r));&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae59c372c71c2577a6a605eb96f49235932b16a" translate="yes" xml:space="preserve">
          <source>3) Executes (1) for every element of &lt;code&gt;p&lt;/code&gt; that does not already exist. If &lt;code&gt;p&lt;/code&gt; already exists, the function does nothing (this condition is not treated as an error).</source>
          <target state="translated">3) 존재하지 않는 &lt;code&gt;p&lt;/code&gt; 의 모든 요소에 대해 (1)을 실행 합니다. 경우 &lt;code&gt;p&lt;/code&gt; 는 이미 존재하는 함수는 (이 조건은 오류로 간주되지 않습니다) 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5b2efd0c240c794cc63ccee8608aa8fa2795f22" translate="yes" xml:space="preserve">
          <source>3) Explicit instantiation declaration (without template argument deduction if every non-default template parameter is explicitly specified)</source>
          <target state="translated">3) 명시 적 인스턴스화 선언 (기본이 아닌 모든 템플릿 매개 변수가 명시 적으로 지정된 경우 템플릿 인수 공제없이)</target>
        </trans-unit>
        <trans-unit id="da06a15019c259b377c2872d2d85209978de2728" translate="yes" xml:space="preserve">
          <source>3) Extracts characters from &lt;code&gt;in&lt;/code&gt; and appends them to &lt;code&gt;s&lt;/code&gt;, except that whenever an &lt;code&gt;escape&lt;/code&gt; character is extracted, it is ignored and the next character is appended to &lt;code&gt;s&lt;/code&gt;. Extraction stops when &lt;code&gt;!in==true&lt;/code&gt; or when an unescaped &lt;code&gt;delim&lt;/code&gt; character is found.</source>
          <target state="translated">3)에서 문자를 추출 &lt;code&gt;in&lt;/code&gt; 와에게 추가 &lt;code&gt;s&lt;/code&gt; 제외하고 때마다 것을 &lt;code&gt;escape&lt;/code&gt; 문자를 추출, 그것은 무시되고 다음 문자가 추가됩니다 &lt;code&gt;s&lt;/code&gt; . &lt;code&gt;!in==true&lt;/code&gt; 또는 이스케이프 처리되지 않은 &lt;code&gt;delim&lt;/code&gt; 문자가 발견 되면 추출이 중지됩니다 .</target>
        </trans-unit>
        <trans-unit id="5fba60a745b100066e65b0f865c19e1368649f58" translate="yes" xml:space="preserve">
          <source>3) Finds the first character equal to none of characters in character string pointed to by &lt;code&gt;s&lt;/code&gt;. The length of the string is determined by the first null character using &lt;code&gt;Traits::length(s)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;s&lt;/code&gt; 가 가리키는 문자열에서 문자가없는 첫 번째 문자를 찾습니다 . 문자열의 길이는 &lt;code&gt;Traits::length(s)&lt;/code&gt; 사용하여 첫 번째 널 문자로 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="743c48cacd7f806bd5330d71c1fe59f65526abaa" translate="yes" xml:space="preserve">
          <source>3) Finds the first character equal to one of the characters in character string pointed to by &lt;code&gt;s&lt;/code&gt;. The length of the string is determined by the first null character using &lt;code&gt;Traits::length(s)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;s&lt;/code&gt; 가 가리키는 문자열의 문자 중 하나와 동일한 첫 번째 문자를 찾습니다 . 문자열의 길이는 &lt;code&gt;Traits::length(s)&lt;/code&gt; 사용하여 첫 번째 널 문자로 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c4f9369d9aa41e3c2e70caf678cef11bd5c59bc" translate="yes" xml:space="preserve">
          <source>3) Finds the first substring equal to the character string pointed to by &lt;code&gt;s&lt;/code&gt;. The length of the string is determined by the first null character using &lt;code&gt;Traits::length(s)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;s&lt;/code&gt; 가 가리키는 문자열과 동일한 첫 번째 하위 문자열을 찾습니다 . 문자열의 길이는 &lt;code&gt;Traits::length(s)&lt;/code&gt; 사용하여 첫 번째 널 문자로 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5f47c71c2880d2fbd432e526b56eb61b5a06792b" translate="yes" xml:space="preserve">
          <source>3) Finds the last character equal to none of characters in character string pointed to by &lt;code&gt;s&lt;/code&gt;. The length of the string is determined by the first null character using &lt;code&gt;Traits::length(s)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;s&lt;/code&gt; 가 가리키는 문자열에서 문자가없는 마지막 문자를 찾습니다 . 문자열의 길이는 &lt;code&gt;Traits::length(s)&lt;/code&gt; 사용하여 첫 번째 널 문자로 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="81dc74e59e430cbc397dc6041420bcec0328bf2d" translate="yes" xml:space="preserve">
          <source>3) Finds the last character equal to one of characters in character string pointed to by &lt;code&gt;s&lt;/code&gt;. The length of the string is determined by the first null character using &lt;code&gt;Traits::length(s)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;s&lt;/code&gt; 가 가리키는 문자열의 문자 중 하나와 동일한 마지막 문자를 찾습니다 . 문자열의 길이는 &lt;code&gt;Traits::length(s)&lt;/code&gt; 사용하여 첫 번째 널 문자로 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8de8caf6e440fce8a707b30a798616333911f49f" translate="yes" xml:space="preserve">
          <source>3) Finds the last substring equal to the character string pointed to by &lt;code&gt;s&lt;/code&gt;. The length of the string is determined by the first null character using &lt;code&gt;Traits::length(s)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;s&lt;/code&gt; 가 가리키는 문자열과 동일한 마지막 부분 문자열을 찾습니다 . 문자열의 길이는 &lt;code&gt;Traits::length(s)&lt;/code&gt; 사용하여 첫 번째 널 문자로 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d8aa0b5faac0679b63d25e5d332bcf8124bbc228" translate="yes" xml:space="preserve">
          <source>3) First, destroys the currently contained value (if any). Then &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initializes&lt;/a&gt; the contained value as if constructing a value of type &lt;code&gt;T_I&lt;/code&gt; with the arguments &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. If an exception is thrown, &lt;code&gt;*this&lt;/code&gt; may become &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt;. This overload only participates in overload resolution if &lt;code&gt;std::is_constructible_v&amp;lt;T_I, Args...&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. The behavior is undefined if &lt;code&gt;I&lt;/code&gt; is not less than &lt;code&gt;sizeof...(Types)&lt;/code&gt;.</source>
          <target state="translated">3) 먼저 현재 포함 된 값 (있는 경우)을 삭제합니다. 그런 다음 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; &amp;lt;Args&amp;gt; (args) ... 인수를 사용하여 &lt;code&gt;T_I&lt;/code&gt; 유형의 값을 구성하는 것처럼 포함 된 값을 &lt;a href=&quot;../../language/direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 합니다 . 예외가 발생하면 &lt;code&gt;*this&lt;/code&gt; 는 &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception &lt;/a&gt;이 될 수 있습니다 . &lt;code&gt;std::is_constructible_v&amp;lt;T_I, Args...&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인경우이 과부하는 과부하 해결에만 참여 합니다 . 경우의 동작은 정의되지 않는다 &lt;code&gt;I&lt;/code&gt; 보다 작되지 &lt;code&gt;sizeof...(Types)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b74c9c6cec2f0fc5a85adb2516f8f8d0411e086f" translate="yes" xml:space="preserve">
          <source>3) For all &lt;code&gt;i&lt;/code&gt;, assigns &lt;code&gt;std::get&amp;lt;i&amp;gt;(other)&lt;/code&gt; to &lt;code&gt;std::get&amp;lt;i&amp;gt;(*this)&lt;/code&gt;.</source>
          <target state="translated">3) 모든 &lt;code&gt;i&lt;/code&gt; 에 대해 &lt;code&gt;std::get&amp;lt;i&amp;gt;(other)&lt;/code&gt; 를 &lt;code&gt;std::get&amp;lt;i&amp;gt;(*this)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fda0586ac2841e1c4bf77f4ed375e08016f88616" translate="yes" xml:space="preserve">
          <source>3) For arguments whose type is a &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt; specialization, in addition to the class rules, the following types are examined and their associated classes and namespaces are added to the set</source>
          <target state="translated">3) 유형이 &lt;a href=&quot;class_template&quot;&gt;클래스 템플릿&lt;/a&gt; 전문인 인수의 경우 클래스 규칙 외에도 다음 유형이 검사되고 관련 클래스 및 네임 스페이스가 세트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9a96fde6dc6a721ec123f58887136dd6d5e5bae9" translate="yes" xml:space="preserve">
          <source>3) For user-defined string literals, let &lt;code&gt;str&lt;/code&gt; be the literal without ud-suffix:</source>
          <target state="translated">3) 사용자 정의 문자열 리터럴의 경우 &lt;code&gt;str&lt;/code&gt; 을 ud-suffix가없는 리터럴로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ca581ff7dc4b7ab8bca2073141703488dd827412" translate="yes" xml:space="preserve">
          <source>3) Forcing a destructor to be generated by the compiler</source>
          <target state="translated">3) 컴파일러가 소멸자를 강제로 생성</target>
        </trans-unit>
        <trans-unit id="a001493f7c64ebd5131c969f057200e92f277664" translate="yes" xml:space="preserve">
          <source>3) Generalized sum of &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;unary_op(*first)&lt;/code&gt;, &lt;code&gt;unary_op(*(first+1))&lt;/code&gt;, ... &lt;code&gt;unary_op(*(last-1))&lt;/code&gt; over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">3) 일반화 합 &lt;code&gt;init&lt;/code&gt; 및 &lt;code&gt;unary_op(*first)&lt;/code&gt; , &lt;code&gt;unary_op(*(first+1))&lt;/code&gt; , ... &lt;code&gt;unary_op(*(last-1))&lt;/code&gt; 위에 &lt;code&gt;binary_op&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="ce3eea3f5ef8fb841547136c9dd4631e86f4c26f" translate="yes" xml:space="preserve">
          <source>3) Hexadecimal integer literal (base 16, the first digit is the most significant, the letters 'a' through 'f' represent values (decimal) 10 through 15)</source>
          <target state="translated">3) 16 진 정수 리터럴 (기수 16, 첫 번째 숫자가 가장 중요하고 문자 'a'- 'f'는 값 (10 진) 10-15를 나타냄)</target>
        </trans-unit>
        <trans-unit id="18e078a9567ad63837bd7d87285b557739f3eebb" translate="yes" xml:space="preserve">
          <source>3) If &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_nothrow_constructible&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_nothrow_constructible&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 멤버 상수 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 제공 하고 그렇지 않으면 &lt;code&gt;value&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e94749bfa4a5a0b79c148b4ca19fb18bb64dba88" translate="yes" xml:space="preserve">
          <source>3) If &lt;code&gt;P&lt;/code&gt; is a class and &lt;code&gt;P&lt;/code&gt; has the form &lt;a href=&quot;templates#template-id&quot;&gt;simple-template-id&lt;/a&gt;, then the transformed &lt;code&gt;A&lt;/code&gt; can be a derived class of the deduced &lt;code&gt;A&lt;/code&gt;. Likewise, if &lt;code&gt;P&lt;/code&gt; is a pointer to a class of the form</source>
          <target state="translated">3) &lt;code&gt;P&lt;/code&gt; 가 클래스이고 &lt;code&gt;P&lt;/code&gt; 가 &lt;a href=&quot;templates#template-id&quot;&gt;simple-template-id&lt;/a&gt; 형식 이면 변환 된 &lt;code&gt;A&lt;/code&gt; 는 추론 된 &lt;code&gt;A&lt;/code&gt; 의 파생 클래스가 될 수 있습니다 . 마찬가지로 &lt;code&gt;P&lt;/code&gt; 가 양식의 클래스에 대한 포인터 인 경우</target>
        </trans-unit>
        <trans-unit id="ef5a440cf5a7d96884abf3428d187a098ad5ef5e" translate="yes" xml:space="preserve">
          <source>3) If &lt;code&gt;P&lt;/code&gt; is a reference type, the type referred to by &lt;code&gt;P&lt;/code&gt; is used for deduction.</source>
          <target state="translated">경우 3) &lt;code&gt;P&lt;/code&gt; 가 참조 형식이고, 유형으로 지칭 &lt;code&gt;P&lt;/code&gt; 가 공제 사용된다.</target>
        </trans-unit>
        <trans-unit id="6bc253b23035e64331429769682cb2e482d523c1" translate="yes" xml:space="preserve">
          <source>3) If &lt;code&gt;bool(rhs) == false&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">3) 만약 &lt;code&gt;bool(rhs) == false&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1807f237b62d7c0ff529f93d2db801fcd9c690de" translate="yes" xml:space="preserve">
          <source>3) If &lt;code&gt;lhs.first&amp;lt;rhs.first&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;. Otherwise, if &lt;code&gt;rhs.first&amp;lt;lhs.first&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;. Otherwise, if &lt;code&gt;lhs.second&amp;lt;rhs.second&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;. Otherwise, returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;lhs.first&amp;lt;rhs.first&lt;/code&gt; 인 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 &lt;code&gt;rhs.first&amp;lt;lhs.first&lt;/code&gt; 인 경우 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 &lt;code&gt;lhs.second&amp;lt;rhs.second&lt;/code&gt; 인 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="67866eea868fe4a8c70c8483deec54f1cc4ac010" translate="yes" xml:space="preserve">
          <source>3) If &lt;code&gt;newoff + off &amp;lt; 0&lt;/code&gt; (the repositioning would move the pointer to before the beginning of the buffer) or if &lt;code&gt;newoff + off&lt;/code&gt; would point past the end of the buffer (or past the last initialized character in the buffer if overallocation is used), the function fails</source>
          <target state="translated">3) &lt;code&gt;newoff + off &amp;lt; 0&lt;/code&gt; (위치 변경으로 포인터가 버퍼의 시작 이전으로 이동) 또는 &lt;code&gt;newoff + off&lt;/code&gt; 가 버퍼의 끝을지나거나 초과 할당이 사용 된 경우 버퍼의 마지막 초기화 문자를 지나는 경우 ), 기능이 실패합니다</target>
        </trans-unit>
        <trans-unit id="0df5689e29daebbe75d2f6ac6c767d39a929b0bf" translate="yes" xml:space="preserve">
          <source>3) If &lt;code&gt;newoff + off&lt;/code&gt; is negative or out of bounds of the initialized part of the buffer, the function fails</source>
          <target state="translated">3) &lt;code&gt;newoff + off&lt;/code&gt; 가 음수이거나 버퍼의 초기화 된 부분의 범위를 벗어난 경우, 함수는 실패합니다</target>
        </trans-unit>
        <trans-unit id="19ba36340ed98541145953df41d284633158ec39" translate="yes" xml:space="preserve">
          <source>3) If &lt;code&gt;other&lt;/code&gt; is empty, the constructed object is empty. Otherwise, the constructed object contains either the object contained in &lt;code&gt;other&lt;/code&gt;, or an object of the same type constructed from the object contained in &lt;code&gt;other&lt;/code&gt;, considering that object as an rvalue.</source>
          <target state="translated">3) &lt;code&gt;other&lt;/code&gt; 가 비어 있으면 생성 된 개체가 비어 있습니다. 그렇지 않으면 생성 된 객체에 &lt;code&gt;other&lt;/code&gt; 에 포함 된 객체가 포함되거나 해당 객체를 rvalue로 간주 하여 &lt;code&gt;other&lt;/code&gt; 에 포함 된 객체로 구성된 동일한 유형의 객체가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd2aa3e86b06b6154367fb110e80875de0a3964b" translate="yes" xml:space="preserve">
          <source>3) If &lt;code&gt;x.year() != y.year()&lt;/code&gt;, &lt;code&gt;x.year() &amp;lt; y.year()&lt;/code&gt;; otherwise if &lt;code&gt;x.month() != y.month()&lt;/code&gt;, &lt;code&gt;x.month() &amp;lt; y.month()&lt;/code&gt;; otherwise &lt;code&gt;x.day() &amp;lt; y.day()&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;x.year() != y.year()&lt;/code&gt; 이면 &lt;code&gt;x.year() &amp;lt; y.year()&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;x.month() != y.month()&lt;/code&gt; , &lt;code&gt;x.month() &amp;lt; y.month()&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;x.day() &amp;lt; y.day()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0b5f4a61ac6473689f8135a405addb4bf6a0345" translate="yes" xml:space="preserve">
          <source>3) If &lt;code&gt;x.year() != y.year()&lt;/code&gt;, &lt;code&gt;x.year() &amp;lt; y.year()&lt;/code&gt;; otherwise, &lt;code&gt;x.month() &amp;lt; y.month()&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;x.year() != y.year()&lt;/code&gt; 이면 &lt;code&gt;x.year() &amp;lt; y.year()&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;x.month() &amp;lt; y.month()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="91aa1ac09d5fdd2c721db5151ac9be65d3a40a3f" translate="yes" xml:space="preserve">
          <source>3) If a key equivalent to &lt;code&gt;k&lt;/code&gt; already exists in the container, does nothing. Otherwise, behaves like &lt;a href=&quot;emplace_hint&quot;&gt;emplace_hint&lt;/a&gt; except that the element is constructed as &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;k&lt;/code&gt; 에 해당하는 키 가 컨테이너에 이미 존재하면 아무 것도 수행하지 않습니다. 그렇지 않으면 요소가 &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt; 로 구성되는 것을 제외하고 &lt;a href=&quot;emplace_hint&quot;&gt;emplace_hint&lt;/a&gt; 와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="086bb4d0a1b953edf002802349143c605fdb99a8" translate="yes" xml:space="preserve">
          <source>3) If an exception is thrown, the transaction is committed normally.</source>
          <target state="translated">3) 예외가 발생하면 트랜잭션이 정상적으로 커밋됩니다.</target>
        </trans-unit>
        <trans-unit id="5af73dfc31bb8d64df3c5724de8db163c310bf9b" translate="yes" xml:space="preserve">
          <source>3) If any argument is a pack expansion, it must be the last argument in the list</source>
          <target state="translated">3) 인수가 팩 확장 인 경우 목록의 마지막 인수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="4748e891646a457897a2c3a6d8280513e474d98e" translate="yes" xml:space="preserve">
          <source>3) If new_type is a pointer or reference to &lt;code&gt;Base&lt;/code&gt;, and the type of expression is a pointer or reference to &lt;code&gt;Derived&lt;/code&gt;, where &lt;code&gt;Base&lt;/code&gt; is a unique, accessible base class of &lt;code&gt;Derived&lt;/code&gt;, the result is a pointer or reference to the &lt;code&gt;Base&lt;/code&gt; class subobject within the &lt;code&gt;Derived&lt;/code&gt; object pointed or identified by expression. (Note: an implicit conversion and &lt;code&gt;static_cast&lt;/code&gt; can perform this conversion as well.)</source>
          <target state="translated">하는 new_type는 포인터 또는 참조 경우 3) &lt;code&gt;Base&lt;/code&gt; 및 표현식의 타입에 대한 포인터 또는 참조 인 &lt;code&gt;Derived&lt;/code&gt; 여기서, &lt;code&gt;Base&lt;/code&gt; 의 독특한 접근 기본 클래스 &lt;code&gt;Derived&lt;/code&gt; 의 결과에 대한 포인터 또는 참조 인 &lt;code&gt;Base&lt;/code&gt; 클래스 하위 개체 내에는 &lt;code&gt;Derived&lt;/code&gt; 객체는 지적 또는 식에 의해 확인했다. (참고 : 암시 적 변환 및 &lt;code&gt;static_cast&lt;/code&gt; 도이 변환을 수행 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="9e5e61a20823b52cf2d425fddca3543d9f64af78" translate="yes" xml:space="preserve">
          <source>3) If new_type is an rvalue reference type, &lt;code&gt;static_cast&lt;/code&gt; converts the value of glvalue, class prvalue, or array prvalue(until C++17)any lvalue(since C++17)expression to</source>
          <target state="translated">3) new_type이 rvalue 참조 유형 인 경우 &lt;code&gt;static_cast&lt;/code&gt; 는 glvalue, 클래스 prvalue 또는 배열 prvalue (C ++ 17까지)의 모든 lvalue (C ++ 17 이후) 표현식을</target>
        </trans-unit>
        <trans-unit id="9ec4ed623544cdc35eda94b168316c079c5a765d" translate="yes" xml:space="preserve">
          <source>3) If no characters were extracted for whatever reason (not even the discarded delimiter), &lt;code&gt;getline&lt;/code&gt; sets &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;&lt;code&gt;failbit&lt;/code&gt;&lt;/a&gt; and returns.</source>
          <target state="translated">3) 어떤 이유로 든 문자가 추출되지 않으면 (버려진 구분 기호조차 포함되지 않음) &lt;code&gt;getline&lt;/code&gt; 은 &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt; &lt;code&gt;failbit&lt;/code&gt; 를&lt;/a&gt; 설정 하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1de74d7eeabbd39188b5931c52aa25d198f922c8" translate="yes" xml:space="preserve">
          <source>3) If no specializations match, the primary template is used</source>
          <target state="translated">3) 일치하는 전문화가 없으면 기본 템플릿이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0a80c955f7945b93bfc82dd8cbfbecbc9435ea49" translate="yes" xml:space="preserve">
          <source>3) If one operand is pointer to</source>
          <target state="translated">3) 하나의 피연산자가</target>
        </trans-unit>
        <trans-unit id="df1474025a19d6acd889fb32730262ba99f1d4f7" translate="yes" xml:space="preserve">
          <source>3) If return-type-requirement is present, then:</source>
          <target state="translated">3) 반환 유형 요구 사항이 있으면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="80f164dcbf1bf6e176fb4108c247e347c553d841" translate="yes" xml:space="preserve">
          <source>3) If the argument is an unparenthesized &lt;a href=&quot;name&quot;&gt;id-expression&lt;/a&gt; or an unparenthesized &lt;a href=&quot;operator_member_access&quot;&gt;class member access&lt;/a&gt; expression, then decltype yields the type of the entity named by this expression. If there is no such entity, or if the argument names a set of overloaded functions, the program is ill-formed.</source>
          <target state="translated">3) 인수가 괄호로 묶이지 않은 &lt;a href=&quot;name&quot;&gt;id- 표현식&lt;/a&gt; 또는 괄호로 묶지 않은 &lt;a href=&quot;operator_member_access&quot;&gt;클래스 멤버 액세스&lt;/a&gt; 표현식 인 경우 decltype은이 표현식으로 명명 된 엔티티의 유형을 생성합니다. 그러한 엔티티가 없거나 인수가 오버로드 된 함수 세트를 명명하는 경우 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f51692ad66852966d7b1e054dde635a17d3a5a6b" translate="yes" xml:space="preserve">
          <source>3) If the candidate function has more than &lt;code&gt;M&lt;/code&gt; parameters and the &lt;code&gt;M+1&lt;/code&gt;'st parameter and all parameters that follow have default arguments, it is viable. For the rest of overload resolution, the parameter list is truncated at M.</source>
          <target state="translated">3) 후보 함수에 &lt;code&gt;M&lt;/code&gt; 개 이상의 매개 변수가 있고 &lt;code&gt;M+1&lt;/code&gt; 'st 매개 변수 및 그 뒤에 오는 모든 매개 변수에 기본 인수가있는 경우 실행 가능합니다. 나머지 과부하 해결의 경우 매개 변수 목록이 M에서 잘립니다.</target>
        </trans-unit>
        <trans-unit id="03d0370f5977c4c68bd33fce7688cacef8c7ef93" translate="yes" xml:space="preserve">
          <source>3) If the pointers are pointers to object and represent the same address, they</source>
          <target state="translated">3) 포인터가 객체에 대한 포인터이고 동일한 주소를 나타내는 경우</target>
        </trans-unit>
        <trans-unit id="99be6833ae341b08b300b24b7cd653a2949d68a3" translate="yes" xml:space="preserve">
          <source>3) If the type is a function type F, it is replaced by the type &quot;pointer to F&quot;</source>
          <target state="translated">3) 유형이 함수 유형 F 인 경우 &quot;포인터에서 F&quot;유형으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="22721145066de589245fca01eb49ec62017cd25a" translate="yes" xml:space="preserve">
          <source>3) If the value of &lt;code&gt;lexically_relative(base)&lt;/code&gt; is not an empty path, return it. Otherwise return &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;lexically_relative(base)&lt;/code&gt; 의 값이 빈 경로가 아닌 경우이를 리턴하십시오. 그렇지 않으면 &lt;code&gt;*this&lt;/code&gt; 를 반환 하십시오 .</target>
        </trans-unit>
        <trans-unit id="119a07d4658a0a6516be001b781bcc4272659c92" translate="yes" xml:space="preserve">
          <source>3) If there are more than one expression in parentheses, new_type must be a class with a suitably declared &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt;. This expression is a prvalue of type new_typedesignating a temporary(until C++17)whose result object is(since C++17)&lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; with expressions.</source>
          <target state="translated">3) 괄호 안에 둘 이상의 표현식이있는 경우 new_type은 적절하게 선언 된 &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; 가있는 클래스 여야합니다 . 이 표현식은 결과 객체가 (C ++ 17부터) 표현식으로 &lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 되는 임시 (C ++ 17까지)를 지정하는 new_type 유형의 prvalue 입니다.</target>
        </trans-unit>
        <trans-unit id="e60aa24e7bd0dfc16a7572c5c73ae791cffaa4a3" translate="yes" xml:space="preserve">
          <source>3) If, within an object of non-union class type, two pointers point to different non-static data members with the same &lt;a href=&quot;access&quot;&gt;member access&lt;/a&gt;, or to subobjects or array elements of such members, recursively, the pointer to the later declared member</source>
          <target state="translated">3) 비 유니언 클래스 유형의 오브젝트 내에서 두 개의 포인터가 동일한 &lt;a href=&quot;access&quot;&gt;멤버 액세스 권한을&lt;/a&gt; 가진 다른 비 정적 데이터 멤버를 가리 키 거나 해당 멤버의 서브 오브젝트 또는 배열 요소를 재귀 적으로 가리키는 경우 나중에 선언 된 멤버에 대한 포인터</target>
        </trans-unit>
        <trans-unit id="e58698e166a9caf0503ebde7652c7737d0b733d7" translate="yes" xml:space="preserve">
          <source>3) Ignores all elements for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">3) 술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 모든 요소를 ​​무시 합니다 .</target>
        </trans-unit>
        <trans-unit id="5e51728260b227dbe5a1a22bea06c587fc12f926" translate="yes" xml:space="preserve">
          <source>3) Implements &lt;code&gt;operator&amp;lt;=&lt;/code&gt; in terms of &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">3)를 구현 &lt;code&gt;operator&amp;lt;=&lt;/code&gt; 환산 &lt;code&gt;operator&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dadd6f16c0b728768b490b7f262229e212a5c803" translate="yes" xml:space="preserve">
          <source>3) In a class definition, &lt;code&gt;final&lt;/code&gt; may appear as class-virt-specifier immediately after the name of the class, just before the colon that begins the base-clause, if used.</source>
          <target state="translated">3) 클래스 정의에서 &lt;code&gt;final&lt;/code&gt; 은 클래스 이름 바로 다음에 기본 절을 시작하는 콜론 바로 앞의 클래스 버트 지정자로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4201ae0917c987e398845110d21d6318890f1e11" translate="yes" xml:space="preserve">
          <source>3) In a function call expression, when the function parameter has reference type</source>
          <target state="translated">3) 함수 호출 표현식에서 함수 매개 변수에 참조 유형이있는 경우</target>
        </trans-unit>
        <trans-unit id="ab655fee316e27400bec8121994a361b2d320ee2" translate="yes" xml:space="preserve">
          <source>3) Informs the compiler that multiplication, division, and absolute value of complex numbers may use simplified mathematical formulas (x+iy)&amp;times;(u+iv) = (xu-yv)+i(yu+xv), (x+iy)/(u+iv) = [(xu+yv)+i(yu-xv)]/(u2</source>
          <target state="translated">3) 복소수의 곱셈, 나눗셈 및 절대 값이 단순화 된 수학 공식 (x + iy) &amp;times; (u + iv) = (xu-yv) + i (yu + xv), (x + iy)를 사용할 수 있음을 컴파일러에 알립니다. ) / (u + iv) = [(xu + yv) + i (yu-xv)] / (u2</target>
        </trans-unit>
        <trans-unit id="b9bce6884c7af5520b8d268ea7b7f89893834131" translate="yes" xml:space="preserve">
          <source>3) Initializes &lt;code&gt;base_&lt;/code&gt; with &lt;code&gt;view::all(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;R&amp;gt;(r))&lt;/code&gt; and initializes &lt;code&gt;pred_&lt;/code&gt; with &lt;code&gt;std::​move(pred)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;view::all(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;R&amp;gt;(r))&lt;/code&gt; &lt;a href=&quot;../utility/forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;R&amp;gt; (r))로 &lt;code&gt;base_&lt;/code&gt; 를 초기화 하고 &lt;code&gt;std::​move(pred)&lt;/code&gt; &lt;code&gt;pred_&lt;/code&gt; 를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="f6ff8ebdb0b4a588f1d0b70d1c1e4c5e34fd0a1d" translate="yes" xml:space="preserve">
          <source>3) Initializes &lt;code&gt;first&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U1&amp;gt;(x)&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U2&amp;gt;(y)&lt;/code&gt;.</source>
          <target state="translated">3)를 초기화 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U1&amp;gt;(x)&lt;/code&gt; 과 &lt;code&gt;second&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U2&amp;gt;(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="040ad719b13d0b757b1cbb72e508c554d548be29" translate="yes" xml:space="preserve">
          <source>3) Initializes &lt;code&gt;value_&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;bound_&lt;/code&gt; with &lt;code&gt;bound&lt;/code&gt;. This constructor is used to create bounded iota views, e.g. &lt;code&gt;iota(10, 20)&lt;/code&gt; yields numbers from 10 to 19.</source>
          <target state="translated">3) &lt;code&gt;value_&lt;/code&gt; 를 &lt;code&gt;value&lt;/code&gt; 로 초기화 하고 &lt;code&gt;bound_&lt;/code&gt; 를 &lt;code&gt;bound&lt;/code&gt; 로 초기화합니다 . 이 생성자는 제한된 iota 뷰를 만드는 데 사용됩니다. 예를 들어 &lt;code&gt;iota(10, 20)&lt;/code&gt; 은 10에서 19까지의 숫자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c3c6f0b13c08ef174375cc6daaba8db4923159bb" translate="yes" xml:space="preserve">
          <source>3) Initializes multiple bases using a &lt;a href=&quot;parameter_pack#Base_specifiers_and_member_initializer_lists&quot;&gt;pack expansion&lt;/a&gt;</source>
          <target state="translated">3) &lt;a href=&quot;parameter_pack#Base_specifiers_and_member_initializer_lists&quot;&gt;팩 확장을&lt;/a&gt; 사용하여 여러베이스를 초기화</target>
        </trans-unit>
        <trans-unit id="de45a418929d5ac281d3dc92cf05db0c626eaab5" translate="yes" xml:space="preserve">
          <source>3) Initializes the error condition with error code &lt;code&gt;val&lt;/code&gt; and error category &lt;code&gt;cat&lt;/code&gt;.</source>
          <target state="translated">3) 에러 코드 &lt;code&gt;val&lt;/code&gt; 및 에러 카테고리 &lt;code&gt;cat&lt;/code&gt; 로 에러 조건을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="45dcae9221ffb9ec9919501350f4a76a243888ac" translate="yes" xml:space="preserve">
          <source>3) Initializes the iterator and stores the value of &lt;code&gt;s&lt;/code&gt; in a data member. If &lt;code&gt;s&lt;/code&gt; is null, then end-of-stream iterator is constructed.</source>
          <target state="translated">3) 반복자를 초기화하고 &lt;code&gt;s&lt;/code&gt; 값을 데이터 멤버에 저장합니다 . 경우 &lt;code&gt;s&lt;/code&gt; 널 (null)이며, 다음 엔드 - 스트림 반복자가 구성된다.</target>
        </trans-unit>
        <trans-unit id="44906afb9363eaecfe4cb84873e486483d3b541e" translate="yes" xml:space="preserve">
          <source>3) Inserts the characters in the range &lt;code&gt;[s, s+count)&lt;/code&gt; at the position &lt;code&gt;index&lt;/code&gt;. The range can contain null characters.</source>
          <target state="translated">3) 위치 &lt;code&gt;index&lt;/code&gt; 에서 &lt;code&gt;[s, s+count)&lt;/code&gt; 범위의 문자를 삽입합니다 . 범위는 널 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b12c6c2ba3cb6246a33014dc234b4fb0cd5c695" translate="yes" xml:space="preserve">
          <source>3) It cannot be defined as deleted or declared with C &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt;(since C++17), &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;, &lt;a href=&quot;static&quot;&gt;static&lt;/a&gt;, or &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;</source>
          <target state="translated">3) C &lt;a href=&quot;language_linkage&quot;&gt;언어 링크&lt;/a&gt; (C ++ 17부터), &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; , &lt;a href=&quot;static&quot;&gt;static&lt;/a&gt; 또는 &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; 로 삭제되거나 선언 된 것으로 정의 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="15428be4fcb993ee6f6258c59a10daa1006cc23e" translate="yes" xml:space="preserve">
          <source>3) Iterator pointing to the first element inserted, or &lt;code&gt;pos&lt;/code&gt; if &lt;code&gt;count==0&lt;/code&gt;.</source>
          <target state="translated">3) 제 요소 반복자 포인팅 삽입 또는 &lt;code&gt;pos&lt;/code&gt; 경우 &lt;code&gt;count==0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83292122e3a0ca8a4e419d61132b33af01c55f4b" translate="yes" xml:space="preserve">
          <source>3) Iterator to the last element inserted, or &lt;code&gt;pos&lt;/code&gt; if &lt;code&gt;count==0&lt;/code&gt;.</source>
          <target state="translated">마지막 삽입 요소, 또는 3) 반복자 &lt;code&gt;pos&lt;/code&gt; 경우 &lt;code&gt;count==0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86650132452794ca72a06d35352364377c46886a" translate="yes" xml:space="preserve">
          <source>3) Less-than operator for variants:</source>
          <target state="translated">3) 변형에 대한 연산자 미만 :</target>
        </trans-unit>
        <trans-unit id="ad1d235b6022b632bfd1ecf8353fb1f773b001d5" translate="yes" xml:space="preserve">
          <source>3) Linear in &lt;code&gt;&lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 선형 (처음, 마지막)</target>
        </trans-unit>
        <trans-unit id="04c6071f6596bd7e8bbddff803623c685bda15bc" translate="yes" xml:space="preserve">
          <source>3) Linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">3) 선형 &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c560ac0ad5a730cae89247a67aa496ace192c481" translate="yes" xml:space="preserve">
          <source>3) Linear in &lt;code&gt;count&lt;/code&gt; plus linear in the distance between &lt;code&gt;pos&lt;/code&gt; and end of the container.</source>
          <target state="translated">3) 용기의 &lt;code&gt;pos&lt;/code&gt; 와 끝 사이의 거리 에서 &lt;code&gt;count&lt;/code&gt; 에 선형 + 계수를 더한 값 .</target>
        </trans-unit>
        <trans-unit id="5a139df81a0286fecf91448f4312bacb00685b92" translate="yes" xml:space="preserve">
          <source>3) Linear in &lt;code&gt;count&lt;/code&gt; plus linear in the lesser of the distances between &lt;code&gt;pos&lt;/code&gt; and either of the ends of the container.</source>
          <target state="translated">3) &lt;code&gt;pos&lt;/code&gt; 와 용기의 양 끝 사이의 거리가 적을 수록 &lt;code&gt;count&lt;/code&gt; 선형 + 선형 .</target>
        </trans-unit>
        <trans-unit id="8068c94a235a98640c2d4d1bdc4cc9d21c073f98" translate="yes" xml:space="preserve">
          <source>3) Linear in &lt;code&gt;ilist.size()&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;ilist.size()&lt;/code&gt; 선형</target>
        </trans-unit>
        <trans-unit id="44f4ac8bda69ffee597405d7bfd5538cbc07ef19" translate="yes" xml:space="preserve">
          <source>3) Linear in size of &lt;code&gt;other&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;other&lt;/code&gt; 크기의 선형</target>
        </trans-unit>
        <trans-unit id="65888332e68ca1792c776ad0e92aa6e8f144ec5a" translate="yes" xml:space="preserve">
          <source>3) Linear in the size of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;ilist&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;*this&lt;/code&gt; 및 &lt;code&gt;ilist&lt;/code&gt; 크기의 선형 .</target>
        </trans-unit>
        <trans-unit id="9976c7fa0c26c5aebc4ef6a454fb47e62e0b73b2" translate="yes" xml:space="preserve">
          <source>3) Literal operators with these parameter lists are the first-choice literal operator for user-defined floating-point literals</source>
          <target state="translated">3) 이러한 매개 변수 목록이있는 리터럴 연산자는 사용자 정의 부동 소수점 리터럴에 대한 첫 번째 리터럴 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="670c5df297f8149bf34051561218c28c5b7037c7" translate="yes" xml:space="preserve">
          <source>3) Locks the associated mutex by calling &lt;code&gt;m.lock()&lt;/code&gt;. The behavior is undefined if the current thread already owns the mutex except when the mutex is recursive.</source>
          <target state="translated">3) &lt;code&gt;m.lock()&lt;/code&gt; 을 호출하여 관련 뮤텍스를 잠급니다 . 뮤텍스가 재귀적일 때를 제외하고 현재 스레드가 이미 뮤텍스를 소유 한 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f4fbadacf39bbf3f9bcc1471343229056016eaf" translate="yes" xml:space="preserve">
          <source>3) Locks the associated mutex in shared mode by calling &lt;code&gt;m.lock_shared()&lt;/code&gt;. The behavior is undefined if this thread already owns the mutex in any mode.</source>
          <target state="translated">3) &lt;code&gt;m.lock_shared()&lt;/code&gt; 를 호출하여 공유 뮤텍스를 공유 모드로 잠급니다 . 이 스레드가 이미 모든 모드에서 뮤텍스를 소유 한 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb3fb484080da1fee970fd8a475c6c772acae1a4" translate="yes" xml:space="preserve">
          <source>3) Logical inclusive OR</source>
          <target state="translated">3) 논리 포함 OR</target>
        </trans-unit>
        <trans-unit id="a7ba55ea9804b266aca10a49cf13a6dec30af883" translate="yes" xml:space="preserve">
          <source>3) May throw any exception thrown by move-constructing any T_i in &lt;code&gt;Types...&lt;/code&gt;.</source>
          <target state="translated">3) 입주 건설의 모든 T_i을에 의해 던져진 예외 던질 수 &lt;code&gt;Types...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca40123da837f0fee79c9b550ed45612562fb752" translate="yes" xml:space="preserve">
          <source>3) Move assignment operator. Replaces the contents with those of &lt;code&gt;other&lt;/code&gt; using move semantics.</source>
          <target state="translated">3) 할당 연산자를 이동하십시오. 이동 의미론을 사용하여 내용을 &lt;code&gt;other&lt;/code&gt; 내용으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="5b47250dca512e9cbfd28a37162f550d375a96df" translate="yes" xml:space="preserve">
          <source>3) Move constructor.</source>
          <target state="translated">3) 생성자를 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="ab9942e808a2d88c706e7eac74af13a25ba991ba" translate="yes" xml:space="preserve">
          <source>3) Move constructor. Constructs a path whose pathname, in both native and generic formats, is the same as that of &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt; is left in valid but unspecified state.</source>
          <target state="translated">3) 생성자를 이동하십시오. 경로 이름, 네이티브 및 일반 형식의 것과 동일 경로 구축 &lt;code&gt;p&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; 는 유효하지만, 지정되지 않은 상태로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="799e4c4e82132cadecf2ebc2ddbcdc904f042751" translate="yes" xml:space="preserve">
          <source>3) Move constructor. Constructs the promise with the shared state of &lt;code&gt;other&lt;/code&gt; using move semantics. After construction, &lt;code&gt;other&lt;/code&gt; has no shared state.</source>
          <target state="translated">3) 생성자를 이동하십시오. 이동 의미론을 사용하여 &lt;code&gt;other&lt;/code&gt; 공유 상태로 약속을 구성합니다 . 시공 후 &lt;code&gt;other&lt;/code&gt; 은 공유 상태가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bde2905f8fda7b64e53c6f7498f3e51ad8fdcbed" translate="yes" xml:space="preserve">
          <source>3) Move constructor. If &lt;code&gt;other&lt;/code&gt; is not &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt;, constructs a variant holding the same alternative as &lt;code&gt;other&lt;/code&gt; and &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initializes&lt;/a&gt; the contained value with &lt;code&gt;std::get&amp;lt;other.index()&amp;gt;(std::move(other))&lt;/code&gt;. Otherwise, initializes a &lt;code&gt;valueless_by_exception&lt;/code&gt; variant. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; is true for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;. It is trivial if &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_trivially_move_constructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; is true for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;.</source>
          <target state="translated">3) 생성자를 이동하십시오. 경우 &lt;code&gt;other&lt;/code&gt; 아니다 &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt; , 같은 대안 들고 변형 구축 &lt;code&gt;other&lt;/code&gt; 및 &lt;a href=&quot;../../language/direct_initialization&quot;&gt;직접 - 초기화를&lt;/a&gt; 함께 포함 된 값 &lt;code&gt;std::get&amp;lt;other.index()&amp;gt;(std::move(other))&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;valueless_by_exception&lt;/code&gt; 변형을 초기화합니다 . &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Types...&lt;/code&gt; 모든 &lt;code&gt;T_i&lt;/code&gt; 에 대해 true 인 경우이 과부하는 과부하 해결에만 참여 합니다. &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_trivially_move_constructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; &amp;lt;T_i&amp;gt; 가 &lt;code&gt;Types...&lt;/code&gt; 모든 &lt;code&gt;T_i&lt;/code&gt; 에 대해 true이면 사소합니다 .</target>
        </trans-unit>
        <trans-unit id="a86f7af723b648e64c975342ed4cc057730f5be8" translate="yes" xml:space="preserve">
          <source>3) Move constructor: If &lt;code&gt;other&lt;/code&gt; contains a value, initializes the contained value as if &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initializing&lt;/a&gt; (but not direct-list-initializing) an object of type &lt;code&gt;T&lt;/code&gt; with the expression &lt;code&gt;std::move(*other)&lt;/code&gt; and</source>
          <target state="translated">3) 이동 생성자는 다음과 같은 경우에 &lt;code&gt;other&lt;/code&gt; 값을 포함하는 것처럼 포함 값을 초기화하는 &lt;a href=&quot;../../language/direct_initialization&quot;&gt;초기화 다이렉트&lt;/a&gt; (그러나이 직접리스트 초기화) 유형의 객체가 아닌 &lt;code&gt;T&lt;/code&gt; 식으로는 &lt;code&gt;std::move(*other)&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="bb85cf7a1f9e7ee2dbe753e86c7632bc1cd9b12a" translate="yes" xml:space="preserve">
          <source>3) Move constructor: move-constructs a &lt;code&gt;std::basic_syncbuf&lt;/code&gt; object by moving all contents from another &lt;code&gt;std::basic_syncbuf&lt;/code&gt; object &lt;code&gt;rhs&lt;/code&gt;, including the temporary storage, the wrapped stream pointer, policy, and all other state (such as the mutex pointer). After move, &lt;code&gt;rhs&lt;/code&gt; is not associated with a stream, and &lt;code&gt;rhs.get_wrapped()==nullptr&lt;/code&gt;. The put area member pointers of the base class &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;rhs&lt;/code&gt; are guaranteed to be null. Destroying a moved-from &lt;code&gt;rhs&lt;/code&gt; will not produce any output.</source>
          <target state="translated">3) 이동 생성자 : move 는 임시 저장소, 래핑 된 스트림 포인터, 정책 및 기타 모든 상태 (예 : 뮤텍스 포인터)를 포함하여 다른 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 객체 &lt;code&gt;rhs&lt;/code&gt; 의 모든 내용을 이동 하여 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 객체를 이동합니다. . 이동 후, &lt;code&gt;rhs&lt;/code&gt; 스트림과 연관되지 않고 &lt;code&gt;rhs.get_wrapped()==nullptr&lt;/code&gt; . &lt;code&gt;rhs&lt;/code&gt; 의 기본 클래스 &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 의 풋 영역 멤버 포인터는 null입니다. 이동 된 &lt;code&gt;rhs&lt;/code&gt; 을 폐기 해도 출력이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3014b09e00db1e8e8f66806e4206bf583890196" translate="yes" xml:space="preserve">
          <source>3) Move constructor: move-constructs the first base class &lt;code&gt;basic_istream&lt;/code&gt; as &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;(std::move(rhs));&lt;/code&gt;, which in turn move-constructs and initializes the virtual base &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt;. The initialization of the other base, &lt;code&gt;basic_ostream&lt;/code&gt;, is implementation-defined (e.g., a protected default constructor may be added to &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;, which does nothing) because move-construction cannot use &lt;code&gt;rhs&lt;/code&gt; twice. This move constructor is protected: it is called by the move constructors of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; before they move-construct and associate the stream buffer.</source>
          <target state="translated">3) 이동 생성자 : &lt;code&gt;basic_istream&lt;/code&gt; 첫 번째 기본 클래스 basic_istream 을 &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;(std::move(rhs));&lt;/code&gt; 가상 기반 &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; 이동 구성하고 초기화합니다 . 이동 기반 구성은 &lt;code&gt;rhs&lt;/code&gt; 를 두 번 사용할 수 없으므로 다른 기본 인 &lt;code&gt;basic_ostream&lt;/code&gt; 의 초기화 는 구현에 따라 정의됩니다 (예 : 보호 된 기본 생성자가 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 추가 될 수 있음 ) . 이 이동 생성자는 보호됩니다. 파생 스트림 클래스 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; 이동 생성자가 스트림 버퍼를 이동 구성하고 연결하기 전에이 생성자를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="20482acf4cb43ffb2b523d35fee40416682818a0" translate="yes" xml:space="preserve">
          <source>3) Move constructors. Moves a weak_ptr instance from &lt;code&gt;r&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. After this, &lt;code&gt;r&lt;/code&gt; is empty and &lt;code&gt;r.use_count()==0&lt;/code&gt;. The templated overload doesn't participate in the overload resolution unless &lt;code&gt;Y*&lt;/code&gt; is implicitly convertible to &lt;code&gt;T*&lt;/code&gt;</source>
          <target state="translated">3) 생성자를 이동하십시오. weak_ptr 인스턴스를 &lt;code&gt;r&lt;/code&gt; 에서 &lt;code&gt;*this&lt;/code&gt; 로 이동합니다 . 그 후에 &lt;code&gt;r&lt;/code&gt; 은 비어 있고 &lt;code&gt;r.use_count()==0&lt;/code&gt; 입니다. &lt;code&gt;Y*&lt;/code&gt; 를 암시 적으로 &lt;code&gt;T*&lt;/code&gt; 로 변환 할 수 없는 경우 템플릿 된 과부하는 과부하 해결에 참여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c832b249444bf57f849b280268cf06acdcca18ef" translate="yes" xml:space="preserve">
          <source>3) Move-constructs a &lt;code&gt;std::basic_filebuf&lt;/code&gt; object by moving all contents from another &lt;code&gt;std::basic_filebuf&lt;/code&gt; object &lt;code&gt;rhs&lt;/code&gt;, including the buffers, the associated file, the locale, the openmode, the is_open variable, and all other state. After move, &lt;code&gt;rhs&lt;/code&gt; is not associated with a file and &lt;code&gt;rhs.is_open()==false&lt;/code&gt;. The member pointers of the base class &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;rhs&lt;/code&gt; and of the base class of &lt;code&gt;*this&lt;/code&gt; are guaranteed to point to different buffers (unless null).</source>
          <target state="translated">3) &lt;code&gt;std::basic_filebuf&lt;/code&gt; 버퍼, 관련 파일, 로케일, 열린 모드, is_open 변수 및 기타 모든 상태를 포함하여 다른 &lt;code&gt;std::basic_filebuf&lt;/code&gt; 객체 &lt;code&gt;rhs&lt;/code&gt; 의 모든 내용을 이동 하여 std :: basic_filebuf 객체를 구성합니다 . 이동 후 &lt;code&gt;rhs&lt;/code&gt; 는 파일 및 &lt;code&gt;rhs.is_open()==false&lt;/code&gt; 와 연관되지 않습니다 . 기본 클래스의 멤버 포인터는 &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;rhs&lt;/code&gt; 와의 기본 클래스의 &lt;code&gt;*this&lt;/code&gt; (널하지 않는 한) 다른 버퍼를 가리 키도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="2e36d88fd76fb51a1c6930542afcef0cf2138ad2" translate="yes" xml:space="preserve">
          <source>3) Move-constructs the underlying container &lt;code&gt;c&lt;/code&gt; with &lt;code&gt;std::move(cont)&lt;/code&gt;.</source>
          <target state="translated">3) 기본 컨테이너 &lt;code&gt;c&lt;/code&gt; 를 &lt;code&gt;std::move(cont)&lt;/code&gt; 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="7bd22c8f7f1e8644439876601f5406f410be68be" translate="yes" xml:space="preserve">
          <source>3) Moves the elements in the range &lt;code&gt;(first, last)&lt;/code&gt; from &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. The elements are inserted after the element pointed to by &lt;code&gt;pos&lt;/code&gt;. The element pointed-to by &lt;code&gt;first&lt;/code&gt; is not moved. The behavior is undefined if &lt;code&gt;pos&lt;/code&gt; is an iterator in the range &lt;code&gt;(first,last)&lt;/code&gt;.</source>
          <target state="translated">3) 범위 &lt;code&gt;(first, last)&lt;/code&gt; 의 요소 를 &lt;code&gt;other&lt;/code&gt; 에서 &lt;code&gt;*this&lt;/code&gt; 로 이동 합니다. 요소는 &lt;code&gt;pos&lt;/code&gt; 가 가리키는 요소 뒤에 삽입됩니다 . &lt;code&gt;first&lt;/code&gt; 가리키는 요소는 이동되지 않습니다. &lt;code&gt;pos&lt;/code&gt; 가 &lt;code&gt;(first,last)&lt;/code&gt; 범위의 반복자 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0d9ad0647ad5c759b3ec9f1989561dc61f998495" translate="yes" xml:space="preserve">
          <source>3) Non-throwing &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt; (unlike &lt;code&gt;noexcept(true)&lt;/code&gt; guarantees stack unwinding and may call &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">3) 던지지 않는 &lt;a href=&quot;except_spec&quot;&gt;동적 예외 사양&lt;/a&gt; ( &lt;code&gt;noexcept(true)&lt;/code&gt; 와 달리 스택 해제를 보장하고 &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 호출 할 수 있음 )</target>
        </trans-unit>
        <trans-unit id="b76732269d03ccd8485ad891bb696c1eba4abbdc" translate="yes" xml:space="preserve">
          <source>3) Nothing.</source>
          <target state="translated">3) 아무것도 아니다.</target>
        </trans-unit>
        <trans-unit id="4003a149764097ada52339a281c59e55001f55f7" translate="yes" xml:space="preserve">
          <source>3) Number of characters written if successful (not including the terminating null character) or a negative value if an error occurred.</source>
          <target state="translated">3) 성공하면 기록 된 문자 수 (종료 널 문자 제외) 또는 오류가 발생한 경우 음수 값.</target>
        </trans-unit>
        <trans-unit id="199f53855c03aabdcac6f164ee51dd6230e50052" translate="yes" xml:space="preserve">
          <source>3) Number of elements removed.</source>
          <target state="translated">3) 제거 된 요소 수.</target>
        </trans-unit>
        <trans-unit id="745cde883a1fe304fa578edf6da7aab7e013ee7d" translate="yes" xml:space="preserve">
          <source>3) Number of wide characters written (not counting the terminating null wide character) if successful or negative value if an encoding error occurred or if the number of characters to be generated was equal or greater than &lt;code&gt;size&lt;/code&gt; (including when &lt;code&gt;size&lt;/code&gt; is zero)</source>
          <target state="translated">3) 인코딩 오류가 발생하거나 생성 될 문자 수가 &lt;code&gt;size&lt;/code&gt; 보다 크거나 같은 경우 ( &lt;code&gt;size&lt;/code&gt; 가 0 인 경우 포함 ) 기록 된 와이드 문자 수 (종료 널 와이드 문자를 계산하지 않음 )</target>
        </trans-unit>
        <trans-unit id="2662cd45cc5538f6af799495aa4fbbbd7a58c342" translate="yes" xml:space="preserve">
          <source>3) Number of wide characters written (not counting the terminating null wide character) if successful or negative value if an encoding error occurred or if the number of characters to be generated was equal or greater than &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">3) 인코딩 오류가 발생하거나 생성 될 문자 수가 &lt;code&gt;size&lt;/code&gt; 이상인 경우 기록 된 와이드 문자 수 (종료 널 와이드 문자를 계산하지 않음) .</target>
        </trans-unit>
        <trans-unit id="75ab421ee70fed4ed412a4d704fcf006774db642" translate="yes" xml:space="preserve">
          <source>3) O(NlogN) in general, where N is &lt;code&gt;size() + ilist.size()&lt;/code&gt;. Linear if &lt;code&gt;ilist&lt;/code&gt; is sorted with respect to &lt;code&gt;&lt;a href=&quot;value_comp&quot;&gt;value_comp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">3) 일반적으로 O (NlogN). 여기서 N은 &lt;code&gt;size() + ilist.size()&lt;/code&gt; 입니다. &lt;code&gt;ilist&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;value_comp&quot;&gt;value_comp()&lt;/a&gt;&lt;/code&gt; 와 관련하여 정렬 된 경우 선형 입니다.</target>
        </trans-unit>
        <trans-unit id="fb9e7f6922c74f96dcd64727f3598e1705b1d870" translate="yes" xml:space="preserve">
          <source>3) Omitted trailing-return-type: the return type of the closure's &lt;code&gt;operator()&lt;/code&gt; is &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced&lt;/a&gt; from &lt;a href=&quot;return&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt; statements as if for a function whose &lt;a href=&quot;function#Return_type_deduction&quot;&gt;return type is declared auto&lt;/a&gt;.</source>
          <target state="translated">3) 생략 후행 리턴 형 : 폐쇄의의 반환 형식 &lt;code&gt;operator()&lt;/code&gt; 입니다 &lt;a href=&quot;template_argument_deduction&quot;&gt;추론&lt;/a&gt; 에서 &lt;a href=&quot;return&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt; 하는 경우로서 그 기능에 대한 문 &lt;a href=&quot;function#Return_type_deduction&quot;&gt;수익 형 자동차를 선언한다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6e13d8366bd793510883424adeab2b27b28314b" translate="yes" xml:space="preserve">
          <source>3) Only copies the elements for which the predicate &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. The relative order of the elements that are copied is preserved. The behavior is undefined if the source and the destination ranges overlap.</source>
          <target state="translated">3) 술어 &lt;code&gt;pred&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 요소 만 복사 합니다 . 복사 된 요소의 상대적 순서가 유지됩니다. 소스와 대상 범위가 겹치는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9106723e00be9201249bf6af1408d15a2c80d988" translate="yes" xml:space="preserve">
          <source>3) Opaque enum declaration for an unscoped enumeration must specify the underlying type.</source>
          <target state="translated">3) 범위가 지정되지 않은 열거에 대한 불투명 열거 선언은 기본 유형을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="23973f1d942c2275f88c02ce2f4462cbc2b04733" translate="yes" xml:space="preserve">
          <source>3) Orders &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; by the order of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;&amp;amp;rhs&lt;/code&gt;. Equivalent to &lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;const error_category*&amp;gt;()(this, &amp;amp;rhs)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 를 &lt;code&gt;this&lt;/code&gt; 과 &lt;code&gt;&amp;amp;rhs&lt;/code&gt; 의 순서로 주문하십시오 . 등가 &lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;const error_category*&amp;gt;()(this, &amp;amp;rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b8de6cc0c7aed032be141148a8b722d842daa5d" translate="yes" xml:space="preserve">
          <source>3) Otherwise, checks whether &lt;code&gt;c&lt;/code&gt; equals &lt;code&gt;'_'&lt;/code&gt; and the bitmask &lt;code&gt;f&lt;/code&gt; includes the result of calling &lt;code&gt;&lt;a href=&quot;lookup_classname&quot;&gt;lookup_classname()&lt;/a&gt;&lt;/code&gt; for the character class &lt;code&gt;[:w:]&lt;/code&gt;, in which case &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">3) 그렇지 여부를 체크 &lt;code&gt;c&lt;/code&gt; 동일 &lt;code&gt;'_'&lt;/code&gt; 와 비트 마스크 &lt;code&gt;f&lt;/code&gt; 호출 한 결과 포함 &lt;code&gt;&lt;a href=&quot;lookup_classname&quot;&gt;lookup_classname()&lt;/a&gt;&lt;/code&gt; 문자 클래스를 &lt;code&gt;[:w:]&lt;/code&gt; , 경우에 &lt;code&gt;true&lt;/code&gt; 를 반환한다.</target>
        </trans-unit>
        <trans-unit id="70f4c9c154011c2187f7759ba9e0a58967135971" translate="yes" xml:space="preserve">
          <source>3) Otherwise, if &lt;code&gt;E2&lt;/code&gt; and &lt;code&gt;E3&lt;/code&gt; have different types, at least one of which is a (possibly cv-qualified) class type, or both are glvalues of the same value category and have the same type except for cv-qualification, then an attempt is made to form an &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion sequence&lt;/a&gt; ignoring member access, whether an operand is a bit-field, or whether a conversion function is deleted(since C++14) from each of the operands to the</source>
          <target state="translated">3) 그렇지 않으면 &lt;code&gt;E2&lt;/code&gt; 와 &lt;code&gt;E3&lt;/code&gt; 의 유형이 다르거 나 그 중 하나 이상이 (cv-qualified) 클래스 유형이거나 둘 다 같은 값 범주의 glvalue이고 cv-qualification을 제외하고 동일한 유형을 갖는 경우 피연산자가 비트 필드인지 또는 각 피연산자에서 피연산자에 대한 변환 함수가 삭제되는지 (C ++ 14부터) 여부에 따라 멤버 액세스를 무시하고 &lt;a href=&quot;implicit_cast&quot;&gt;암시적인 변환 시퀀스&lt;/a&gt; 를 작성하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="e3e1f4bc9437f198420f3a42654833fe270a5008" translate="yes" xml:space="preserve">
          <source>3) Otherwise, if &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are both &lt;code&gt;V&amp;amp;&lt;/code&gt; for some type &lt;code&gt;V&lt;/code&gt; that meets the syntactic requirements of &lt;code&gt;&lt;a href=&quot;../../concepts/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;&amp;lt;V&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../concepts/assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;V&amp;amp;, V&amp;gt;&lt;/code&gt;, exchanges the referenced values as if by &lt;code&gt;V v{std::move(t)}; t = std::move(u); u = std::move(v);&lt;/code&gt;. If the semantic requirements of either concept are not satisfied, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">3) 그렇지 않으면, &lt;code&gt;&lt;a href=&quot;../../concepts/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;&amp;lt;V&amp;gt;&lt;/code&gt; &amp;lt;V&amp;gt; 및 &lt;code&gt;&lt;a href=&quot;../../concepts/assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;V&amp;amp;, V&amp;gt;&lt;/code&gt; &amp;lt;V &amp;amp;, V&amp;gt; 의 구문 요구 사항을 충족하는 일부 유형 &lt;code&gt;V&lt;/code&gt; 에 대해 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 가 모두 &lt;code&gt;V&amp;amp;&lt;/code&gt; 경우 &lt;code&gt;V v{std::move(t)}; t = std::move(u); u = std::move(v);&lt;/code&gt; 의해 참조 된 값을 교환합니다. }; t = std :: move (u); u = std :: move (v); . 두 개념 중 하나의 의미 요구 사항이 충족되지 않으면 프로그램이 잘못 형성됩니다. 진단이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88c61c2e4aab2e466e58588f765636b5775a65dc" translate="yes" xml:space="preserve">
          <source>3) Otherwise, if either is a pointer to a virtual member function, the result is unspecified.</source>
          <target state="translated">3) 그렇지 않으면 가상 멤버 함수에 대한 포인터 인 경우 결과가 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6368464f68e30f03aa03ef43c24298e8b78b1d76" translate="yes" xml:space="preserve">
          <source>3) Otherwise, if the stream buffer mode is not dynamic or the stream buffer is currently frozen, the function fails and returns &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">3) 그렇지 않으면, 스트림 버퍼 모드가 동적이 아니거나 스트림 버퍼가 현재 정지 된 경우 함수가 실패하고 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a6d0283f448702fd1a84893cf29fed278ede2c82" translate="yes" xml:space="preserve">
          <source>3) Otherwise, returns &lt;code&gt;Traits::eof()&lt;/code&gt;.</source>
          <target state="translated">3) 그렇지 않으면 &lt;code&gt;Traits::eof()&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="df96ecf19fcd5f311c11c51bc719bc29c39a8c66" translate="yes" xml:space="preserve">
          <source>3) Otherwise, the next pointer is assigned as if by &lt;code&gt;gptr() = eback()+newoff&lt;/code&gt; or &lt;code&gt;pptr() = pbase()+newoff&lt;/code&gt;.</source>
          <target state="translated">3) 그렇지 않으면 다음 포인터가 &lt;code&gt;gptr() = eback()+newoff&lt;/code&gt; 또는 &lt;code&gt;pptr() = pbase()+newoff&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f22651593e63fb4e87b2b2b71befdd326088533a" translate="yes" xml:space="preserve">
          <source>3) Performs atomic bitwise and. Equivalent to &lt;code&gt;fetch_and(arg)&lt;/code&gt; &amp;amp; arg.</source>
          <target state="translated">3) 원자를 비트 단위로 수행합니다. &lt;code&gt;fetch_and(arg)&lt;/code&gt; &amp;amp; arg 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7cf61b6c18bada575e3f374e9983692fff35fc84" translate="yes" xml:space="preserve">
          <source>3) Performs atomic bitwise and. Equivalent to &lt;code&gt;return fetch_and(arg) &amp;amp; arg;&lt;/code&gt;.</source>
          <target state="translated">3) 원자를 비트 단위로 수행합니다. &lt;code&gt;return fetch_and(arg) &amp;amp; arg;&lt;/code&gt; 를 반환하는 것과 같습니다 . .</target>
        </trans-unit>
        <trans-unit id="b2a57e6a26fb685bd0f06d7735ce653db8cdf8a7" translate="yes" xml:space="preserve">
          <source>3) Performs atomic pre-decrement. Equivalent to &lt;code&gt;fetch_sub(1)-1&lt;/code&gt;</source>
          <target state="translated">3) 원자 사전 감소를 수행합니다. 등가 &lt;code&gt;fetch_sub(1)-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a33f9787080e90df24bcc4e78fb7039f6e2e90e8" translate="yes" xml:space="preserve">
          <source>3) Performs atomic pre-decrement. Equivalent to &lt;code&gt;return fetch_sub(1) - 1;&lt;/code&gt;</source>
          <target state="translated">3) 원자 사전 감소를 수행합니다. &lt;code&gt;return fetch_sub(1) - 1;&lt;/code&gt; 을 반환하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="dce1f3cb4ef8a04d6922cc12c907cc7112350620" translate="yes" xml:space="preserve">
          <source>3) Preprocessor constant expression that evaluates to &lt;code&gt;1&lt;/code&gt; if the file name is found and &lt;code&gt;​0​&lt;/code&gt; if not. The program is ill-formed if the argument would not be a valid argument to the &lt;code&gt;#include&lt;/code&gt; directive.</source>
          <target state="translated">3) 일정한 처리기 식으로 평가하는 것이 &lt;code&gt;1&lt;/code&gt; 파일 이름이 발견되는 경우 &lt;code&gt;​0​&lt;/code&gt; 이 아니라면. 인수가 &lt;code&gt;#include&lt;/code&gt; 지시문에 유효한 인수가 아닌 경우 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b8721f805f20b3b05c9fc921d29e29ad249bfbd" translate="yes" xml:space="preserve">
          <source>3) Prompting text which is sent to interactive devices will be shown before the program waits for input.</source>
          <target state="translated">3) 프로그램이 입력을 대기하기 전에 대화식 장치로 전송되는 프롬프트 텍스트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3c0a3af8a4ffb7e108373f747a9b0226794ff8a5" translate="yes" xml:space="preserve">
          <source>3) Reads the data from null-terminated character string &lt;code&gt;buffer&lt;/code&gt;</source>
          <target state="translated">3) null로 끝나는 문자열 &lt;code&gt;buffer&lt;/code&gt; 에서 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="1987c2e2bf2f178daacab600c61051e608bea8ac" translate="yes" xml:space="preserve">
          <source>3) Reads the data from null-terminated character string &lt;code&gt;buffer&lt;/code&gt;.</source>
          <target state="translated">3) null로 끝나는 문자열 &lt;code&gt;buffer&lt;/code&gt; 에서 데이터를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="8f00b2bef9860a58dc87b440b7afccf7db80d98a" translate="yes" xml:space="preserve">
          <source>3) Reads the data from null-terminated wide string &lt;code&gt;buffer&lt;/code&gt;</source>
          <target state="translated">3) 널 종료 와이드 스트링 &lt;code&gt;buffer&lt;/code&gt; 에서 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="17ff56ed2692b9b2018a3f5600ca3878c8e0e80f" translate="yes" xml:space="preserve">
          <source>3) Reads the data from null-terminated wide string &lt;code&gt;buffer&lt;/code&gt;.</source>
          <target state="translated">3) 널 종료 와이드 스트링 &lt;code&gt;buffer&lt;/code&gt; 에서 데이터를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="64312e0e2af20f65585c2deb188b505ac912b497" translate="yes" xml:space="preserve">
          <source>3) Removes all elements for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">3) 술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 모든 요소를 ​​제거합니다 .</target>
        </trans-unit>
        <trans-unit id="310f5ebf8540a04bda8b40a1bc9d4dd5526e65b4" translate="yes" xml:space="preserve">
          <source>3) Removes all elements with the key equivalent to &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">3)에 해당하는 키의 모든 요소 삭제 &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4415369549290e578edb60f8e1f33b4e74708761" translate="yes" xml:space="preserve">
          <source>3) Removes the characters in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 문자를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="544c58ab324d92afbde9bd592b0d8902e8476d0b" translate="yes" xml:space="preserve">
          <source>3) Removes the element (if one exists) with the key equivalent to &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">3)에 해당하는 키를 가진 요소 (있는 경우)를 제거 &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81c9303915ae21b5cd2b6b5570fd3e30353c9770" translate="yes" xml:space="preserve">
          <source>3) Replace each slash character in the root-name with &lt;code&gt;path::preferred_separator&lt;/code&gt;.</source>
          <target state="translated">3) root-name의 각 슬래시 문자를 &lt;code&gt;path::preferred_separator&lt;/code&gt; 로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="6f9d84cda7d3d351025115d6a2983f6e3213f125" translate="yes" xml:space="preserve">
          <source>3) Replaces all elements for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">3) 술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 모든 요소를 ​​대체 합니다 .</target>
        </trans-unit>
        <trans-unit id="cc2407531d0f96aaaeadd7acec07ab09d97704c4" translate="yes" xml:space="preserve">
          <source>3) Replaces each value in &lt;code&gt;*this&lt;/code&gt; with a copy of &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;*this&lt;/code&gt; 의 각 값 을 &lt;code&gt;val&lt;/code&gt; 사본으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="b5a886685c3e16dded625568a49d963af8f0fb7f" translate="yes" xml:space="preserve">
          <source>3) Replaces the contents of &lt;code&gt;*this&lt;/code&gt; with a new path value constructed from detected-format &lt;code&gt;source&lt;/code&gt;, which is left in valid, but unspecified state. Equivalent to &lt;code&gt;assign(std::move(source))&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;*this&lt;/code&gt; 의 내용을 감지 된 형식 &lt;code&gt;source&lt;/code&gt; 구성된 새로운 경로 값으로 대체합니다. 이 경로 값 은 유효하지만 지정되지 않은 상태로 남아 있습니다. 에 해당 &lt;code&gt;assign(std::move(source))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="576824a8f9ea5847e8fcc701cc58c3cc93280e22" translate="yes" xml:space="preserve">
          <source>3) Replaces the contents with a substring &lt;code&gt;[pos, pos+count)&lt;/code&gt; of &lt;code&gt;str&lt;/code&gt;. If the requested substring lasts past the end of the string, or if &lt;code&gt;count == npos&lt;/code&gt;, the resulting substring is &lt;code&gt;[pos, str.size())&lt;/code&gt;. If &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">3) 내용 을 &lt;code&gt;str&lt;/code&gt; 의 하위 문자열 &lt;code&gt;[pos, pos+count)&lt;/code&gt; 로 바꿉니다 . 요청 된 하위 문자열이 문자열의 끝을 지난 경우 또는 &lt;code&gt;count == npos&lt;/code&gt; 인 경우 결과 하위 문자열은 &lt;code&gt;[pos, str.size())&lt;/code&gt; 입니다. 경우 &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="03b2fcf1f7504d24271eb69478891bb5b7d2cabc" translate="yes" xml:space="preserve">
          <source>3) Replaces the contents with the elements from the initializer list &lt;code&gt;ilist&lt;/code&gt;.</source>
          <target state="translated">3) 초기화 목록 &lt;code&gt;ilist&lt;/code&gt; 의 요소로 내용을 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="13bb493e1a2a07b34e03b2b85046f26ec68eae8f" translate="yes" xml:space="preserve">
          <source>3) Replaces the contents with those identified by initializer list &lt;code&gt;ilist&lt;/code&gt;.</source>
          <target state="translated">3) 이니셜 라이저 목록 &lt;code&gt;ilist&lt;/code&gt; 로 식별 된 내용으로 내용을 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="ef480fdc4715540c535b67104f0be3a077d9ff0a" translate="yes" xml:space="preserve">
          <source>3) Replaces the contents with those of null-terminated character string pointed to by &lt;code&gt;s&lt;/code&gt; as if by &lt;code&gt;assign(s, Traits::length(s))&lt;/code&gt;.</source>
          <target state="translated">3) 마치 마치 &lt;code&gt;assign(s, Traits::length(s))&lt;/code&gt; 처럼 &lt;code&gt;s&lt;/code&gt; 가 가리키는 null로 끝나는 문자열로 내용을 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="e269b1ba162c3802910e2880f4db900ea451a1f3" translate="yes" xml:space="preserve">
          <source>3) Returns &lt;code&gt;proximate(p, current_path(), ec)&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;proximate(p, current_path(), ec)&lt;/code&gt; 반환합니다</target>
        </trans-unit>
        <trans-unit id="fcd3e9270cb3648094c10618d20e91cf9291367f" translate="yes" xml:space="preserve">
          <source>3) Returns &lt;code&gt;static_cast&amp;lt;T&amp;gt;(std::move(*std::any_cast&amp;lt;U&amp;gt;(&amp;amp;operand)))&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;static_cast&amp;lt;T&amp;gt;(std::move(*std::any_cast&amp;lt;U&amp;gt;(&amp;amp;operand)))&lt;/code&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3dae875d437b9ad5b93fadfd5f4be759cb67b989" translate="yes" xml:space="preserve">
          <source>3) Returns &lt;code&gt;std::regex_match(str, str + &lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;charT&amp;gt;::length(str), m, e, flags)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;std::regex_match(str, str + &lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;charT&amp;gt;::length(str), m, e, flags)&lt;/code&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8abe04d6a65d859a86311ce0c8798df947619f86" translate="yes" xml:space="preserve">
          <source>3) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">3) 반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;lhs&lt;/code&gt; 있다</target>
        </trans-unit>
        <trans-unit id="7918b80e898ded5d6e97ac97b077589e837608a6" translate="yes" xml:space="preserve">
          <source>3) Returns &lt;code&gt;true&lt;/code&gt; if lhs is less than or equal to rhs, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">3) 반환 &lt;code&gt;true&lt;/code&gt; 좌가 나, 우 같음보다 작 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="0b4b3fc69cba2c69b75d5370bf375d279f982337" translate="yes" xml:space="preserve">
          <source>3) Returns a &lt;code&gt;bitset&amp;lt;N&amp;gt;&lt;/code&gt; containing the result of binary XOR on corresponding pairs of bits of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">3) 대응하는 &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 쌍의 비트에 대한 이진 XOR의 결과를 포함하는 비트 세트 &lt;code&gt;bitset&amp;lt;N&amp;gt;&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9a23ccf8edcb838b99e8ee8c314068aead06ea37" translate="yes" xml:space="preserve">
          <source>3) Returns a const-qualified iterator to the reverse-beginning of the container &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">3) 컨테이너 &lt;code&gt;c&lt;/code&gt; 의 역 시작에 const 한정 반복자를 돌려 줍니다.</target>
        </trans-unit>
        <trans-unit id="389c919ddf46812630bd663635937fafcec64a1e" translate="yes" xml:space="preserve">
          <source>3) Returns a const-qualified iterator to the reverse-end of the container &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">3) const 한정된 반복자를 컨테이너 &lt;code&gt;c&lt;/code&gt; 의 반대쪽 끝으로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bba8a7d67c95b0c502523c9d7a3e9ff7954f65f2" translate="yes" xml:space="preserve">
          <source>3) Returns a numeric array of &lt;code&gt;bool&lt;/code&gt; containing elements each of which is obtained by applying the indicated comparison operator to the corresponding value of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhsv&lt;/code&gt;.</source>
          <target state="translated">3) 표시된 비교 연산자를 대응하는 &lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhsv&lt;/code&gt; 값에 적용하여 얻은 각 요소를 포함하는 &lt;code&gt;bool&lt;/code&gt; 의 숫자 배열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="347d9f13e5f0de90871565d57db2a0da42067b3a" translate="yes" xml:space="preserve">
          <source>3) Returns a string containing the latest remote database version.</source>
          <target state="translated">3) 최신 원격 데이터베이스 버전이 포함 된 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3125c23569a2a0a23a19892e81d51814a585e9fc" translate="yes" xml:space="preserve">
          <source>3) Returns exactly &lt;code&gt;std::begin(c)&lt;/code&gt;, with &lt;code&gt;c&lt;/code&gt; always treated as const-qualified. If &lt;code&gt;C&lt;/code&gt; is a standard &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, this always returns &lt;code&gt;C::const_iterator&lt;/code&gt;.</source>
          <target state="translated">3) 정확히 &lt;code&gt;std::begin(c)&lt;/code&gt; )를 반환 하고 &lt;code&gt;c&lt;/code&gt; 는 항상 const 한정으로 처리됩니다. 경우 &lt;code&gt;C&lt;/code&gt; 가 표준입니다 &lt;a href=&quot;../named_req/container&quot;&gt;컨테이너&lt;/a&gt; , 이것은 항상 반환 &lt;code&gt;C::const_iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59aa2d9d6dec20809b1d0a178cdfd88d91b8be3e" translate="yes" xml:space="preserve">
          <source>3) Returns exactly &lt;code&gt;std::end(c)&lt;/code&gt;, with &lt;code&gt;c&lt;/code&gt; always treated as const-qualified. If &lt;code&gt;C&lt;/code&gt; is a standard &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, this always returns a &lt;code&gt;C::const_iterator&lt;/code&gt;.</source>
          <target state="translated">3) 정확히 &lt;code&gt;std::end(c)&lt;/code&gt; )를 반환 하고 &lt;code&gt;c&lt;/code&gt; 는 항상 const 한정으로 처리됩니다. 경우 &lt;code&gt;C&lt;/code&gt; 가 표준입니다 &lt;a href=&quot;../named_req/container&quot;&gt;컨테이너&lt;/a&gt; 이 항상 반환 &lt;code&gt;C::const_iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="996196d6521c5c7b2c554427b75896857ce5f751" translate="yes" xml:space="preserve">
          <source>3) Returns the format structure (of type &lt;a href=&quot;../money_base&quot;&gt;&lt;code&gt;std::money_base::format&lt;/code&gt;&lt;/a&gt;) which describes the formatting of positive monetary values.</source>
          <target state="translated">3) 양의 통화 값의 형식을 설명 하는 형식 구조 ( &lt;a href=&quot;../money_base&quot;&gt; &lt;code&gt;std::money_base::format&lt;/code&gt; &lt;/a&gt; )를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="477bbd5c6845e534597a26535c28e03e8a1d8033" translate="yes" xml:space="preserve">
          <source>3) Returns the native-format representation of the pathname by value.</source>
          <target state="translated">3) 경로 이름의 기본 형식 표현을 값으로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="216c048ed4bc4f444c6c4082ca1c39abe2a50014" translate="yes" xml:space="preserve">
          <source>3) Returns the pointer one past the end of the get area.</source>
          <target state="translated">3) get 영역의 끝을지나 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8134a36d5fcae3e74503193ede20ea1921facc82" translate="yes" xml:space="preserve">
          <source>3) Returns the pointer one past the end of the put area.</source>
          <target state="translated">3) 풋 영역의 끝을지나 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bfe9a00312f690b0210d8e9e30a3959a15595212" translate="yes" xml:space="preserve">
          <source>3) Returns the shared pointer pointed-to by &lt;code&gt;p&lt;/code&gt;. As with the non-specialized &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_load&quot;&gt;std::atomic_load_explicit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;mo&lt;/code&gt; cannot be &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;p&lt;/code&gt; 가 가리키는 공유 포인터를 반환합니다 . 비 전문과 마찬가지로 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_load&quot;&gt;std::atomic_load_explicit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;mo&lt;/code&gt; 수 없습니다 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30ff31b55716571c59891a700329900acd714bc3" translate="yes" xml:space="preserve">
          <source>3) Returns the stored &lt;code&gt;std::chrono::day&lt;/code&gt; value.</source>
          <target state="translated">3) 저장된 &lt;code&gt;std::chrono::day&lt;/code&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="407bd14ded9dfd8122000901458dcecf239dd014" translate="yes" xml:space="preserve">
          <source>3) Returns the stored &lt;code&gt;std::chrono::weekday&lt;/code&gt; value.</source>
          <target state="translated">3) 저장된 &lt;code&gt;std::chrono::weekday&lt;/code&gt; 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0b6d156648e07714726cb41e1c416ee8bbf5bae5" translate="yes" xml:space="preserve">
          <source>3) Returns the string that is used for formatting of negative monetary values.</source>
          <target state="translated">3) 음의 통화 값을 형식화하는 데 사용되는 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="653086588b06d64a925a3b2058d67d280de70556" translate="yes" xml:space="preserve">
          <source>3) Returns the string that is used for formatting of positive monetary values.</source>
          <target state="translated">3) 양의 통화 값을 형식화하는 데 사용되는 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ad5ed1f6fd61797eb99ea91f52811e8b9c04cba8" translate="yes" xml:space="preserve">
          <source>3) Returns the string to be used as the representation of the boolean value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">3) 부울 값 &lt;code&gt;true&lt;/code&gt; 의 표현으로 사용될 문자열을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="40ceb43e70d8dd1204d160e3ce8b5e87fa0a3ebb" translate="yes" xml:space="preserve">
          <source>3) Same as (1), but evaluations of both expressions from (1) are known not to throw exceptions</source>
          <target state="translated">3) (1)과 동일하지만 (1)의 두 표현식을 모두 평가하면 예외가 발생하지 않는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="75fdda12724b08f74cb742d27bc91e98893793ec" translate="yes" xml:space="preserve">
          <source>3) Same as (1), but uses &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_nothrow_constructible&lt;/a&gt;&amp;lt;T, T&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">3) (1)과 동일하지만 &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_nothrow_constructible&lt;/a&gt;&amp;lt;T, T&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4666db7c3270a52a92a3e4e85c6daac2091990b6" translate="yes" xml:space="preserve">
          <source>3) Same as (1), but uses &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_nothrow_constructible&lt;/a&gt;&amp;lt;T, const T&amp;amp;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">3) (1)과 동일하지만 &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_nothrow_constructible&lt;/a&gt;&amp;lt;T, const T&amp;amp;&amp;gt;&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5b74c80c3864f0ecdb94780d074fa5d1029adf44" translate="yes" xml:space="preserve">
          <source>3) Same as (2), but if &lt;code&gt;&lt;a href=&quot;../directory_options&quot;&gt;std::filesystem::directory_options::skip_permission_denied&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;options&lt;/code&gt; and construction encounters a permissions denied error, constructs the end iterator and does not report an error.</source>
          <target state="translated">3) (2)와 동일하지만 &lt;code&gt;options&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../directory_options&quot;&gt;std::filesystem::directory_options::skip_permission_denied&lt;/a&gt;&lt;/code&gt; 가 설정 되고 구성에 권한 거부 오류가 발생하면 종료 반복자를 구성하며 오류를보고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29cb7d52643a6db784f8f2d44725bcdca11329ab" translate="yes" xml:space="preserve">
          <source>3) Same as (2). &lt;code&gt;Y*&lt;/code&gt; must be implicitly convertible to &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">3) (2)와 동일합니다. &lt;code&gt;Y*&lt;/code&gt; 는 암시 적으로 &lt;code&gt;T*&lt;/code&gt; 로 변환 가능해야합니다 .</target>
        </trans-unit>
        <trans-unit id="43d958e8ae30ecb323acdee3ad42ee7d8c5989b9" translate="yes" xml:space="preserve">
          <source>3) Same as 1), but uses &lt;code&gt;&lt;a href=&quot;is_assignable&quot;&gt;std::is_nothrow_assignable&lt;/a&gt;&amp;lt;T&amp;amp;, T&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">3) 1)과 동일하지만 &lt;code&gt;&lt;a href=&quot;is_assignable&quot;&gt;std::is_nothrow_assignable&lt;/a&gt;&amp;lt;T&amp;amp;, T&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0b6e4619b9b66b516a340ac59b04dc8ecf3114d" translate="yes" xml:space="preserve">
          <source>3) Same as 1), but uses &lt;code&gt;&lt;a href=&quot;is_assignable&quot;&gt;std::is_nothrow_assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">3) 1)과 동일하지만 &lt;code&gt;&lt;a href=&quot;is_assignable&quot;&gt;std::is_nothrow_assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf00c1915110a8f8302efd280a583c34435221bc" translate="yes" xml:space="preserve">
          <source>3) Same as &lt;code&gt;get(s, count, widen('\n'))&lt;/code&gt;, that is, reads at most &lt;code&gt;count-1&lt;/code&gt; characters and stores them into character string pointed to by &lt;code&gt;s&lt;/code&gt; until &lt;code&gt;'\n'&lt;/code&gt; is found.</source>
          <target state="translated">3) &lt;code&gt;get(s, count, widen('\n'))&lt;/code&gt; 과 동일합니다. 즉, 최대 &lt;code&gt;count-1&lt;/code&gt; 문자를 읽고 &lt;code&gt;'\n'&lt;/code&gt; 을 찾을 때까지 &lt;code&gt;s&lt;/code&gt; 가 가리키는 문자열에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="f35e1ceefb7704839e967552ca2749d9e731cbf4" translate="yes" xml:space="preserve">
          <source>3) Same as &lt;code&gt;noexcept(true)&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;noexcept(true)&lt;/code&gt; 와 동일 (true)</target>
        </trans-unit>
        <trans-unit id="28927916b5f2d702653bd8d3cdb9d87d5f2105c2" translate="yes" xml:space="preserve">
          <source>3) Same rules apply to possibly multilevel pointers to data members and possibly multilevel pointers to arrays of known and unknown bound (arrays to cv-qualified elements are considered to be cv-qualified themselves)(since C++17)</source>
          <target state="translated">3) 동일한 규칙이 데이터 멤버에 대한 다중 레벨 포인터 및 알려지고 알려지지 않은 바인드 배열에 대한 다중 레벨 포인터에 적용됩니다 (CV 규정 요소에 대한 배열은 자체적으로 CV 규정으로 간주됩니다) (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="c88bdf1e6603ab75c1a66dc891e02f5dac9a3278" translate="yes" xml:space="preserve">
          <source>3) Seeds the underlying engine with the seed sequence &lt;code&gt;seq&lt;/code&gt;. Effectively calls &lt;code&gt;e.seed(seq)&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is the underlying engine. This template only participate in overload resolution if &lt;code&gt;Sseq&lt;/code&gt; qualifies as a &lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;. In particular, this template does not participate in overload resolution if &lt;code&gt;Sseq&lt;/code&gt; is implicitly convertible to &lt;code&gt;result_type&lt;/code&gt;.</source>
          <target state="translated">3) 시드 시퀀스 &lt;code&gt;seq&lt;/code&gt; 로 기본 엔진을 시드합니다 . 효과적으로 &lt;code&gt;e.seed(seq)&lt;/code&gt; 호출합니다 . 여기서 &lt;code&gt;e&lt;/code&gt; 는 기본 엔진입니다. 이 템플릿 은 &lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;Sseq&lt;/a&gt; 가 &lt;code&gt;Sseq&lt;/code&gt; 자격을 갖춘 경우에만 과부하 해결에 참여 합니다. 특히 &lt;code&gt;Sseq&lt;/code&gt; 가 암시 적으로 &lt;code&gt;result_type&lt;/code&gt; 으로 변환 가능한 경우이 템플릿은 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="66256b254b71b452daa6c3c11989098848af677f" translate="yes" xml:space="preserve">
          <source>3) Sets the &lt;code&gt;floatfield&lt;/code&gt; of the stream &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;fixed&lt;/code&gt; and &lt;code&gt;scientific&lt;/code&gt; simultaneously as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt;. This enables hexadecimal floating-point formatting.</source>
          <target state="translated">3) &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: fixed&lt;/a&gt; | &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: scientific&lt;/a&gt; , &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: floatfield&lt;/a&gt; ) 를 호출하는 것처럼 스트림 &lt;code&gt;str&lt;/code&gt; 의 &lt;code&gt;floatfield&lt;/code&gt; 를 &lt;code&gt;fixed&lt;/code&gt; 및 &lt;code&gt;scientific&lt;/code&gt; 동시에 설정합니다 . 이것은 16 진 부동 소수점 형식화를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="539c675f402dc407efe8702c820cd3501d36e4b9" translate="yes" xml:space="preserve">
          <source>3) Sets the bits to the result of binary XOR on corresponding pairs of bits of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;*this&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 의 해당 비트 쌍에서 이진 XOR의 결과로 비트를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="0880c4c5eccb5f5716a83df72128c2a2e98bf13e" translate="yes" xml:space="preserve">
          <source>3) Shifts the elements towards the end of the range. If &lt;code&gt;n &amp;lt;= 0 || n &amp;gt;= last - first&lt;/code&gt;, there are no effects. Otherwise, for every integer &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, last - first - n)&lt;/code&gt;, moves the element originally at position &lt;code&gt;first + i&lt;/code&gt; to position &lt;code&gt;first + n + i&lt;/code&gt;. If &lt;code&gt;ForwardIt&lt;/code&gt; meets the &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; requirements, then the moves are performed in decreasing order of &lt;code&gt;i&lt;/code&gt; starting from &lt;code&gt;last - first - n - 1&lt;/code&gt;.</source>
          <target state="translated">3) 요소를 범위의 끝으로 이동합니다. 만약 &lt;code&gt;n &amp;lt;= 0 || n &amp;gt;= last - first&lt;/code&gt; , 효과가 없습니다. 그렇지 않으면 &lt;code&gt;[0, last - first - n)&lt;/code&gt; 모든 정수 &lt;code&gt;i&lt;/code&gt; 에 대해 원래 위치 &lt;code&gt;first + i&lt;/code&gt; 에서 요소 를 &lt;code&gt;first + n + i&lt;/code&gt; 위치로 이동합니다 . &lt;code&gt;ForwardIt&lt;/code&gt; 이 &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; 요구 사항을 충족하는 경우 , 이동은 &lt;code&gt;last - first - n - 1&lt;/code&gt; 부터 시작하여 &lt;code&gt;i&lt;/code&gt; 의 내림차순으로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c9d0c2185c5586bd7bed52acf3ae314e951d96c" translate="yes" xml:space="preserve">
          <source>3) Specialization for array types. Provides a member type &lt;code&gt;value_type&lt;/code&gt; equal to &lt;code&gt;&lt;a href=&quot;../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/remove_extent&quot;&gt;std::remove_extent_t&lt;/a&gt;&amp;lt;I&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">3) 배열 유형에 대한 전문화. &lt;code&gt;&lt;a href=&quot;../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/remove_extent&quot;&gt;std::remove_extent_t&lt;/a&gt;&amp;lt;I&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt; &lt;a href=&quot;../types/remove_extent&quot;&gt;std :: remove_extent_t&lt;/a&gt; &amp;lt;I &amp;gt;&amp;gt;와 같은 멤버 유형 &lt;code&gt;value_type&lt;/code&gt; 을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="58bd4662686ae1223f5baf954179e2d03f2c1d7f" translate="yes" xml:space="preserve">
          <source>3) Specialization for const-qualified types.</source>
          <target state="translated">3) const 한정 타입의 전문화.</target>
        </trans-unit>
        <trans-unit id="54ab7c739fef8476a189076fbf661003474506a2" translate="yes" xml:space="preserve">
          <source>3) Static or thread-local object (not necessarily of class type), that is not initialized by a constructor call, if the object is &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt; or if every expression in its initializer is a constant expression.</source>
          <target state="translated">3) 객체가 &lt;a href=&quot;value_initialization&quot;&gt;값 초기화&lt;/a&gt; 되거나 초기화 자의 모든 표현식이 상수 표현식 인 경우 생성자 호출에 의해 초기화되지 않는 정적 또는 스레드 로컬 객체 (클래스 유형은 아님) .</target>
        </trans-unit>
        <trans-unit id="097d0b441067ba5d47d8543320b37efde3660d0b" translate="yes" xml:space="preserve">
          <source>3) Subtracts &lt;code&gt;d.count()&lt;/code&gt; days from &lt;code&gt;wd&lt;/code&gt;. Equivalent to &lt;code&gt;return wd + -d;&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;wd&lt;/code&gt; 에서 &lt;code&gt;d.count()&lt;/code&gt; 일을 뺍니다 . &lt;code&gt;return wd + -d;&lt;/code&gt; 를 반환하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2f3dca6824ef61799f78ac90e853a90658e6bfab" translate="yes" xml:space="preserve">
          <source>3) Subtracts &lt;code&gt;ds.count()&lt;/code&gt; days from &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;d&lt;/code&gt; 에서 &lt;code&gt;ds.count()&lt;/code&gt; 일을 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="7037daccc56ce1933ba8a1fbeeb87a58e2f62d6d" translate="yes" xml:space="preserve">
          <source>3) Subtracts &lt;code&gt;ms.count()&lt;/code&gt; months from &lt;code&gt;m&lt;/code&gt; and returns the result. Equivalent to &lt;code&gt;return m + -ms;&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;m&lt;/code&gt; 에서 &lt;code&gt;ms.count()&lt;/code&gt; 개월을 빼고 결과를 반환합니다. &lt;code&gt;return m + -ms;&lt;/code&gt; 를 반환하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ed35f317e0d17207eecbd63ea299f598c773b64d" translate="yes" xml:space="preserve">
          <source>3) Subtracts &lt;code&gt;ys.count()&lt;/code&gt; years from &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;y&lt;/code&gt; 에서 &lt;code&gt;ys.count()&lt;/code&gt; 년을 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="05713a69cd3b7ea822c8c9b8e7caf63a80afbb9b" translate="yes" xml:space="preserve">
          <source>3) Suitably declared &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified identifiers&lt;/a&gt; (e.g. &lt;code&gt;&lt;a href=&quot;../string/basic_string/npos&quot;&gt;std::string::npos&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">3) 적절하게 선언 &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;된 정규화 된 식별자&lt;/a&gt; (예 : &lt;code&gt;&lt;a href=&quot;../string/basic_string/npos&quot;&gt;std::string::npos&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4f76236eac167e2ccfa25151cd48c3dd1b1bd111" translate="yes" xml:space="preserve">
          <source>3) The</source>
          <target state="translated">3)</target>
        </trans-unit>
        <trans-unit id="bfa5d73f47f7efd6871f71c1cedbefaef7874a84" translate="yes" xml:space="preserve">
          <source>3) The &lt;code&gt;static&lt;/code&gt; specifier is only allowed in the declarations of objects (except in function parameter lists), declarations of functions (except at block scope), and declarations of anonymous unions. When used in a declaration of a class member, it declares a &lt;a href=&quot;static&quot;&gt;static member&lt;/a&gt;. When used in a declaration of an object, it specifies static storage duration (except if accompanied by &lt;code&gt;thread_local&lt;/code&gt;). When used in a declaration at namespace scope, it specifies internal linkage.</source>
          <target state="translated">3) &lt;code&gt;static&lt;/code&gt; 지정자는 객체 선언 (함수 매개 변수 목록 제외), 함수 선언 (블록 범위 제외) 및 익명 공용체 선언에서만 허용됩니다. 클래스 멤버의 선언에 사용될 때 &lt;a href=&quot;static&quot;&gt;정적 멤버를&lt;/a&gt; 선언합니다 . 객체 선언에 사용될 때 정적 저장 기간을 지정합니다 ( &lt;code&gt;thread_local&lt;/code&gt; 이 동반되는 경우 제외 ). 네임 스페이스 범위의 선언에 사용될 때 내부 연결을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a47e59365dd3deb1e9dc95fb2cf9637cc23e5693" translate="yes" xml:space="preserve">
          <source>3) The binary operation &lt;code&gt;binary_op&lt;/code&gt; is applied to pairs of elements from two ranges: one defined by &lt;code&gt;[first1, last1)&lt;/code&gt; and the other beginning at &lt;code&gt;first2&lt;/code&gt;.</source>
          <target state="translated">3) 이진 연산 &lt;code&gt;binary_op&lt;/code&gt; 는 두 개의 범위 (하나는 &lt;code&gt;[first1, last1)&lt;/code&gt; 의해 정의되고 다른 하나는 &lt;code&gt;first2&lt;/code&gt; 에서 시작 ) 의 요소 쌍에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="99a25d1bfda3ab89fd10b1a019376ed17dbddf19" translate="yes" xml:space="preserve">
          <source>3) The buffer, which may be replaced by an external, user-provided buffer.</source>
          <target state="translated">3) 버퍼는 외부 사용자 제공 버퍼로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9fea7e9e911871543216c2bca462ae2d68f713a" translate="yes" xml:space="preserve">
          <source>3) The comma operator (&lt;code&gt;,&lt;/code&gt;). The value for the empty pack is &lt;code&gt;void()&lt;/code&gt;</source>
          <target state="translated">3) 쉼표 연산자 ( &lt;code&gt;,&lt;/code&gt; ). 빈 팩의 값은 &lt;code&gt;void()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="106baa92685ed4789c9f3278b624715075f482d4" translate="yes" xml:space="preserve">
          <source>3) The copy constructor is deleted, &lt;code&gt;wbuffer_convert&lt;/code&gt; is not &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">3) 복사 생성자가 삭제되고 &lt;code&gt;wbuffer_convert&lt;/code&gt; 는 CopyConstructible 이 아닙니다 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="57c540f15553b610f14a86f8853f67d76a13deaa" translate="yes" xml:space="preserve">
          <source>3) The copy constructor is deleted: &lt;code&gt;std::random_device&lt;/code&gt; is not copyable nor movable.</source>
          <target state="translated">3) 복사 생성자가 삭제됩니다 : &lt;code&gt;std::random_device&lt;/code&gt; 는 복사 할 수 없거나 이동할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="538902239ad978c74ef7a4bcaa6ed7a88a4c7c1c" translate="yes" xml:space="preserve">
          <source>3) The copy constructor was declared &lt;code&gt;private:&lt;/code&gt; and not defined until C++11 and is declared as deleted in C++11: I/O streams are not &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">3) 복사 생성자가 &lt;code&gt;private:&lt;/code&gt; 으로 선언 되었으며 C ++ 11까지 정의되지 않았으며 C ++ 11에서 삭제 된 것으로 선언되었습니다. I / O 스트림은 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="ef862ed2daae32aa871acb691d2af8257cf12604" translate="yes" xml:space="preserve">
          <source>3) The execution policy type used as a unique type to disambiguate parallel algorithm overloading and indicate that a parallel algorithm's execution may be parallelized, vectorized, or migrated across threads (such as by a parent-stealing scheduler). The invocations of element access functions in parallel algorithms invoked with this policy are permitted to execute in an unordered fashion in unspecified threads, and unsequenced with respect to one another within each thread.</source>
          <target state="translated">3) 병렬 알고리즘 오버로딩을 명확하게하기 위해 고유 한 유형으로 사용되는 실행 정책 유형. 이 정책으로 호출 된 병렬 알고리즘에서 요소 액세스 함수의 호출은 지정되지 않은 스레드에서 순서가없는 방식으로 실행될 수 있으며 각 스레드 내에서 서로에 대해 순서가 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b969fc5d4983cfa6b335ab96d4eaa577cf84b39" translate="yes" xml:space="preserve">
          <source>3) The members declared after the specifier have private member access</source>
          <target state="translated">3) 지정자 이후 선언 된 멤버는 개인 멤버 액세스 권한을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a27c6d6d4626ae8c9e794867e6db9bdc8a12c3bb" translate="yes" xml:space="preserve">
          <source>3) The move constructor copies the value of &lt;code&gt;gcount()&lt;/code&gt; from &lt;code&gt;rhs&lt;/code&gt;, sets the gcount() value of rhs to zero, and uses &lt;code&gt;basic_ios&amp;lt;CharT, Traits&amp;gt;::move(rhs)&lt;/code&gt; to move all basic_ios members, except for the &lt;code&gt;rdbuf()&lt;/code&gt;, from &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. This move constructor is protected: it is called by the move constructors of movable input stream classes &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly move the associated stream buffer.</source>
          <target state="translated">3) 이동 생성자 는 &lt;code&gt;rhs&lt;/code&gt; 에서 &lt;code&gt;gcount()&lt;/code&gt; 값을 복사하고 rhs 의 gcount () 값을 0으로 설정하고 &lt;code&gt;basic_ios&amp;lt;CharT, Traits&amp;gt;::move(rhs)&lt;/code&gt; 를 사용하여 &lt;code&gt;rdbuf()&lt;/code&gt; 제외한 모든 basic_ios 멤버를 이동합니다 () 에서 &lt;code&gt;rhs&lt;/code&gt; 으로 &lt;code&gt;*this&lt;/code&gt; . 이 이동 생성자는 보호됩니다. 이동 가능한 입력 스트림 클래스 &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; 의 이동 생성자에 의해 호출되며 연결된 스트림 버퍼를 올바르게 이동하는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8253f464ab63b9544bb4b7a5ba673657dcaa92f7" translate="yes" xml:space="preserve">
          <source>3) The move constructor uses &lt;code&gt;basic_ios&amp;lt;CharT, Traits&amp;gt;::move(rhs)&lt;/code&gt; to move all basic_ios members, except for the &lt;code&gt;rdbuf()&lt;/code&gt;, from &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. This move constructor is protected: it is called by the move constructors of movable output stream classes &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly move the associated streambuffer.</source>
          <target state="translated">3) 이동 생성자는 &lt;code&gt;basic_ios&amp;lt;CharT, Traits&amp;gt;::move(rhs)&lt;/code&gt; 를 사용하여 &lt;code&gt;rdbuf()&lt;/code&gt; 제외한 모든 basic_ios 멤버 를 &lt;code&gt;rhs&lt;/code&gt; 에서 &lt;code&gt;*this&lt;/code&gt; 로 이동 합니다. 이 이동 생성자는 보호됩니다. 이동 가능한 출력 스트림 클래스 &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt; 의 이동 생성자에 의해 호출되며 연결된 스트림 버퍼 를 올바르게 이동하는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c5f5e6303c3981281bdf12b22a9967c96eff97c" translate="yes" xml:space="preserve">
          <source>3) The numeric arguments &lt;code&gt;units&lt;/code&gt; is converted to a wide character string as if by &lt;code&gt;ct.widen(buf1, buf1 + &lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf1, &quot;%.0Lf&quot;, units), buf2)&lt;/code&gt;, where &lt;code&gt;ct&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet imbued in &lt;code&gt;str.getloc()&lt;/code&gt; and &lt;code&gt;buf1&lt;/code&gt; and &lt;code&gt;buf2&lt;/code&gt; are sufficiently large character buffers. The resulting character string &lt;code&gt;buf2&lt;/code&gt; is processed, formatted, and output to &lt;code&gt;out&lt;/code&gt; as desribed below.</source>
          <target state="translated">3) 숫자 인수 &lt;code&gt;units&lt;/code&gt; 는 &lt;code&gt;ct.widen(buf1, buf1 + &lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf1, &quot;%.0Lf&quot;, units), buf2)&lt;/code&gt; 의해 와이드 문자 스트링으로 변환됩니다. 여기서 &lt;code&gt;ct&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; &lt;code&gt;str.getloc()&lt;/code&gt; 및 &lt;code&gt;buf1&lt;/code&gt; 및 &lt;code&gt;buf2&lt;/code&gt; 에 포함 된 ctype 패싯 은 충분히 큰 문자 버퍼입니다. 얻어진 문자열 &lt;code&gt;buf2&lt;/code&gt; 처리 포맷 및 출력되는 &lt;code&gt;out&lt;/code&gt; 아래 desribed있다.</target>
        </trans-unit>
        <trans-unit id="9d23036119f9057dac90391026d9f10d74793ec9" translate="yes" xml:space="preserve">
          <source>3) The pointer one past the end of the get area.</source>
          <target state="translated">3) get 영역의 끝을 지나는 포인터.</target>
        </trans-unit>
        <trans-unit id="4522f0a21976a2225b32579b72b1aea157568164" translate="yes" xml:space="preserve">
          <source>3) The pointer one past the end of the put area.</source>
          <target state="translated">3) 풋 영역의 끝을 지나는 포인터.</target>
        </trans-unit>
        <trans-unit id="5739e5b8d09abf81265c1829686de1ae25206b35" translate="yes" xml:space="preserve">
          <source>3) The program is ill-formed if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6233aa93b494442e3d3982e63f956a5fb19dfba8" translate="yes" xml:space="preserve">
          <source>3) The proximate form of the path</source>
          <target state="translated">3) 경로의 가장 가까운 형태</target>
        </trans-unit>
        <trans-unit id="f7c28efecd0b1bf8f774df7cb16171047445f27c" translate="yes" xml:space="preserve">
          <source>3) The random number generator is the function object &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">3) 난수 생성기는 함수 객체 &lt;code&gt;g&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e800546551b8927f2c5472761bbbcc6aea77c856" translate="yes" xml:space="preserve">
          <source>3) The result encoding in the case of &lt;code&gt;u8string()&lt;/code&gt; is always UTF-8.</source>
          <target state="translated">3) &lt;code&gt;u8string()&lt;/code&gt; 의 경우 결과 인코딩 은 항상 UTF-8입니다.</target>
        </trans-unit>
        <trans-unit id="8c7594a004dbf92a4cfa7dbf8383d65e67748ae8" translate="yes" xml:space="preserve">
          <source>3) The underlying iterator is initialized with that of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">3) 기본 반복자는 &lt;code&gt;other&lt;/code&gt; 반복자와 함께 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="37983c33230cd98fd38753f8dbad4d00fc819fa2" translate="yes" xml:space="preserve">
          <source>3) Then, non-static data members are initialized in order of declaration in the class definition.</source>
          <target state="translated">3) 정적이 아닌 데이터 멤버는 클래스 정의에서 선언 된 순서대로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="09efa6229584955cc0d4f32db27a05bce6094a2d" translate="yes" xml:space="preserve">
          <source>3) This overload only participates in overload resolution if T is a specialization of std::pair. Equivalent to</source>
          <target state="translated">3)이 과부하는 T가 std :: pair의 전문화 인 경우에만 과부하 해결에 참여합니다. 에 해당</target>
        </trans-unit>
        <trans-unit id="e8d1f320a7a5eb1a513d5f28ed9a79257cee0b53" translate="yes" xml:space="preserve">
          <source>3) Throws any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;. Has the following</source>
          <target state="translated">3) &lt;code&gt;T&lt;/code&gt; 의 생성자가 던진 예외를 던집니다 . 다음이 있습니다</target>
        </trans-unit>
        <trans-unit id="180d52fc736ff4085fc3cd183c0e31bace34a9e5" translate="yes" xml:space="preserve">
          <source>3) Transfers the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; from &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. The elements are inserted before the element pointed to by &lt;code&gt;pos&lt;/code&gt;. The behavior is undefined if &lt;code&gt;pos&lt;/code&gt; is an iterator in the range &lt;code&gt;[first,last)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;[first, last)&lt;/code&gt; 범위의 요소 를 &lt;code&gt;other&lt;/code&gt; 에서 &lt;code&gt;*this&lt;/code&gt; 로 전송 합니다. 요소는 &lt;code&gt;pos&lt;/code&gt; 가 가리키는 요소 앞에 삽입됩니다 . &lt;code&gt;pos&lt;/code&gt; 가 &lt;code&gt;[first,last)&lt;/code&gt; 범위의 반복자 인 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3664df048e90beb28440427bae630d23ce78e957" translate="yes" xml:space="preserve">
          <source>3) Transfers the ownership of the object managed by &lt;code&gt;r&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; manages no object, &lt;code&gt;*this&lt;/code&gt; manages no object too. After the assignment, &lt;code&gt;*this&lt;/code&gt; contains the pointer previously held by &lt;code&gt;r&lt;/code&gt;, and &lt;code&gt;use_count()==1&lt;/code&gt;; also &lt;code&gt;r&lt;/code&gt; is empty. Equivalent to &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(r).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;r&lt;/code&gt; 에 의해 관리되는 오브젝트의 소유권 을 &lt;code&gt;*this&lt;/code&gt; 로 전송합니다 . &lt;code&gt;r&lt;/code&gt; &lt;code&gt;*this&lt;/code&gt; 오브젝트를 관리하지 않으면 *이 오브젝트도 관리하지 않습니다. 할당 후 &lt;code&gt;*this&lt;/code&gt; 는 &lt;code&gt;r&lt;/code&gt; 에 의해 이전에 보유 된 포인터를 포함 하고 &lt;code&gt;use_count()==1&lt;/code&gt; ; 또한 &lt;code&gt;r&lt;/code&gt; 은 비어 있습니다. 당량 &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(r).swap(*this)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fb32edff5d6d482cde4402d55a0f26597a58a64" translate="yes" xml:space="preserve">
          <source>3) UTF-16 character literal, e.g. &lt;code&gt;u'貓'&lt;/code&gt;, but not &lt;code&gt;u'🍌'&lt;/code&gt; (&lt;code&gt;u'\U0001f34c'&lt;/code&gt;). Such literal has type &lt;code&gt;char16_t&lt;/code&gt; and the value equal to ISO 10646 code point value of c-char, provided that the code point value is representable with a single UTF-16 code unit (that is, c-char is in the range 0x0-0xFFFF, inclusive). If c-char is not representable with a single UTF-16 code unit, the program is ill-formed.</source>
          <target state="translated">3) UTF-16 문자 리터럴 (예 : &lt;code&gt;u'貓'&lt;/code&gt; 이지만 &lt;code&gt;u'🍌'&lt;/code&gt; ( &lt;code&gt;u'\U0001f34c'&lt;/code&gt; )은 아닙니다 . 이러한 리터럴은 &lt;code&gt;char16_t&lt;/code&gt; 유형 과 c-char의 ISO 10646 코드 포인트 값과 동일한 값을 갖습니다. 단, 코드 포인트 값은 단일 UTF-16 코드 단위로 표현 가능합니다 (즉, c-char의 범위는 0x0-0xFFFF입니다). , 포함한). 단일 UTF-16 코드 단위로 c-char를 표현할 수없는 경우 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0eb1cd751938a22a6214ac1b9240979fd29cc6b0" translate="yes" xml:space="preserve">
          <source>3) UTF-8 encoded string literal. The type of a &lt;code&gt;u8&quot;...&quot;&lt;/code&gt; string literal is &lt;code&gt;const char[N]&lt;/code&gt;(until C++20)&lt;code&gt;const char8_t[N]&lt;/code&gt;(since C++20), where &lt;code&gt;N&lt;/code&gt; is the size of the string in UTF-8 code units including the null terminator.</source>
          <target state="translated">3) UTF-8 인코딩 문자열 리터럴. &lt;code&gt;u8&quot;...&quot;&lt;/code&gt; 문자열 리터럴 의 유형 은 &lt;code&gt;const char[N]&lt;/code&gt; (C ++ 20까지) &lt;code&gt;const char8_t[N]&lt;/code&gt; (C ++ 20부터)이며 여기서 &lt;code&gt;N&lt;/code&gt; 은 UTF-8의 문자열 크기입니다. 널 종료자를 포함한 코드 단위.</target>
        </trans-unit>
        <trans-unit id="04ad1633cce0abf907d5083b7a4ffaf95348fe38" translate="yes" xml:space="preserve">
          <source>3) Uses a copy of &lt;code&gt;str&lt;/code&gt; as initial contents of the underlying string device. The underlying &lt;code&gt;basic_stringbuf&lt;/code&gt; object is constructed as &lt;code&gt;basic_stringbuf&amp;lt;Char,Traits,Allocator&amp;gt;(str, mode | ios_base::in)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;str&lt;/code&gt; 의 사본을 기본 문자열 장치의 초기 내용으로 사용합니다. 기본 &lt;code&gt;basic_stringbuf&lt;/code&gt; 객체는 &lt;code&gt;basic_stringbuf&amp;lt;Char,Traits,Allocator&amp;gt;(str, mode | ios_base::in)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e835e4bcc4392bc0a331b564871e685c77ddf29f" translate="yes" xml:space="preserve">
          <source>3) Uses a copy of &lt;code&gt;str&lt;/code&gt; as initial contents of the underlying string device. The underlying &lt;code&gt;basic_stringbuf&lt;/code&gt; object is constructed as &lt;code&gt;basic_stringbuf&amp;lt;Char,Traits,Allocator&amp;gt;(str, mode | ios_base::out)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;str&lt;/code&gt; 의 사본을 기본 문자열 장치의 초기 내용으로 사용합니다. 기본 &lt;code&gt;basic_stringbuf&lt;/code&gt; 객체는 &lt;code&gt;basic_stringbuf&amp;lt;Char,Traits,Allocator&amp;gt;(str, mode | ios_base::out)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="83d42b2907d10c4217066cc14296a1b1547d6768" translate="yes" xml:space="preserve">
          <source>3) Uses a copy of &lt;code&gt;str&lt;/code&gt; as initial contents of the underlying string device. The underlying &lt;code&gt;basic_stringbuf&lt;/code&gt; object is constructed as &lt;code&gt;basic_stringbuf&amp;lt;Char,Traits,Allocator&amp;gt;(str, mode)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;str&lt;/code&gt; 의 사본을 기본 문자열 장치의 초기 내용으로 사용합니다. 기본 &lt;code&gt;basic_stringbuf&lt;/code&gt; 객체는 &lt;code&gt;basic_stringbuf&amp;lt;Char,Traits,Allocator&amp;gt;(str, mode)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="09bc43c84c31674f028769647df22694756ec5ee" translate="yes" xml:space="preserve">
          <source>3) Uses the &lt;a href=&quot;../../language/delete&quot;&gt;delete-expression&lt;/a&gt;&lt;code&gt;delete ptr&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is not an array type; &lt;code&gt;delete[] ptr&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is an array type(since C++17) as the deleter. &lt;code&gt;Y&lt;/code&gt; must be a complete type. The delete expression must be well-formed, have well-defined behavior and not throw any exceptions. This constructor additionally does not participate in overload resolution if the delete expression is not well-formed.(since C++17)</source>
          <target state="translated">3) &lt;code&gt;T&lt;/code&gt; 가 배열 유형이 아닌 경우 &lt;a href=&quot;../../language/delete&quot;&gt;delete-expression &lt;/a&gt; &lt;code&gt;delete ptr&lt;/code&gt; 을 사용합니다 . &lt;code&gt;delete[] ptr&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; 가 삭제 자로 배열 유형 (C ++ 17부터) 인 경우 ptr &lt;code&gt;Y&lt;/code&gt; 는 완전한 유형이어야합니다. 삭제 표현식은 올바른 형식이어야하고 올바르게 정의 된 동작을 가지며 예외를 발생시키지 않아야합니다. 삭제 표현식의 형식이 올바르지 않은 경우이 생성자는 또한 과부하 해결에 참여하지 않습니다. (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="c395b404baa79c386b4d710ca413c2f1807e804e" translate="yes" xml:space="preserve">
          <source>3) Uses the specified deleter &lt;code&gt;d&lt;/code&gt; as the deleter. &lt;code&gt;Deleter&lt;/code&gt; must be callable for the type &lt;code&gt;T&lt;/code&gt;, i.e. &lt;code&gt;d(ptr)&lt;/code&gt; must be well formed, have well-defined behavior and not throw any exceptions. &lt;code&gt;Deleter&lt;/code&gt; must be &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, and its copy constructor and destructor must not throw exceptions. Equivalent to &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(ptr, d).swap(*this);&lt;/code&gt;.</source>
          <target state="translated">3) 지정된 삭제 기 &lt;code&gt;d&lt;/code&gt; 를 삭제 기로 사용합니다 . 유형 &lt;code&gt;T&lt;/code&gt; 에 대해 &lt;code&gt;Deleter&lt;/code&gt; 를 호출 할 수 있어야합니다 . 즉 &lt;code&gt;d(ptr)&lt;/code&gt; 이 올바르게 구성되어 있고 올바르게 정의 된 동작이 있어야하며 예외가 발생하지 않아야합니다. &lt;code&gt;Deleter&lt;/code&gt; 는 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 이어야하며 해당 복사 생성자와 소멸자는 예외를 발생시키지 않아야합니다. 당량 &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(ptr, d).swap(*this);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8035b06b4704ada294cf21d12af4d289132f3e32" translate="yes" xml:space="preserve">
          <source>3) When an array of any &lt;a href=&quot;types#Character_types&quot;&gt;character type&lt;/a&gt; is &lt;a href=&quot;aggregate_initialization#Character_arrays&quot;&gt;initialized with a string literal&lt;/a&gt; that is too short, the remainder of the array is zero-initialized.</source>
          <target state="translated">임의의 배열하면 3) &lt;a href=&quot;types#Character_types&quot;&gt;캐릭터 타입이&lt;/a&gt; 되는 &lt;a href=&quot;aggregate_initialization#Character_arrays&quot;&gt;캐릭터 문자로 초기화&lt;/a&gt; 너무 짧은 어레이의 나머지 부분은 제로 - 초기화된다.</target>
        </trans-unit>
        <trans-unit id="7f13d95ac4e8156c5779496326ed3f4e7b6fe42b" translate="yes" xml:space="preserve">
          <source>3) When two variables with &lt;code&gt;&quot;C&quot;&lt;/code&gt; language linkage and the same name that appear in different namespaces, they refer to the same variable.</source>
          <target state="translated">3) &lt;code&gt;&quot;C&quot;&lt;/code&gt; 언어 연결과 이름이 다른 두 변수가 서로 다른 네임 스페이스에 나타나는 경우 동일한 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4155f7c75562837f51e2a50206a32e961f0f059b" translate="yes" xml:space="preserve">
          <source>3) Wraps a non-const member function with a single parameter.</source>
          <target state="translated">3) 상수가 아닌 멤버 함수를 단일 매개 변수로 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="295654c8321ff1ec4c4e8a96eac87a6e3ed5f21e" translate="yes" xml:space="preserve">
          <source>3) Writes the results to a character string &lt;code&gt;buffer&lt;/code&gt;.</source>
          <target state="translated">3) 결과를 문자열 &lt;code&gt;buffer&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4f587e6945116c94dad66390db735ce2ddace527" translate="yes" xml:space="preserve">
          <source>3) Writes the results to a wide string &lt;code&gt;buffer&lt;/code&gt;. At most &lt;code&gt;size-1&lt;/code&gt; wide characters are written followed by null wide character.</source>
          <target state="translated">3) 결과를 넓은 문자열 &lt;code&gt;buffer&lt;/code&gt; 합니다. 최대 &lt;code&gt;size-1&lt;/code&gt; 와이드 문자가 쓰여지고 그 뒤에 널 와이드 문자가옵니다.</target>
        </trans-unit>
        <trans-unit id="803e45e8f371490b430b8a7554b3a153af2d6267" translate="yes" xml:space="preserve">
          <source>3) adds &lt;code&gt;volatile&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;volatile&lt;/code&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="0283dee7c30148a16571de6fdc53d78b6a17c0c6" translate="yes" xml:space="preserve">
          <source>3) all names except for the functions and function templates are ignored (no collision with variables)</source>
          <target state="translated">3) 함수 및 함수 템플릿을 제외한 모든 이름은 무시됩니다 (변수와의 충돌 없음)</target>
        </trans-unit>
        <trans-unit id="b92787ecfa67da771730f619ea829e7c5b701fde" translate="yes" xml:space="preserve">
          <source>3) any declaration that is not a function or a function template (e.g. a function object or another variable whose name conflicts with the name of the function that's being looked up)</source>
          <target state="translated">3) 함수 또는 함수 템플릿이 아닌 선언 (예 : 함수 객체 또는 조회중인 함수의 이름과 이름이 충돌하는 다른 변수)</target>
        </trans-unit>
        <trans-unit id="658e8718bdcaedd95b8e191a1d44644c43f146f3" translate="yes" xml:space="preserve">
          <source>3) as a function call argument</source>
          <target state="translated">3) 함수 호출 인수</target>
        </trans-unit>
        <trans-unit id="7edf1af248df188c9ec386cbc14ba718e90ef9b4" translate="yes" xml:space="preserve">
          <source>3) atomic constraints</source>
          <target state="translated">3) 원자 제약</target>
        </trans-unit>
        <trans-unit id="3e3283342f36405013afd4a4f53a71bf0470e73a" translate="yes" xml:space="preserve">
          <source>3) attribute with arguments, such as &lt;code&gt;[[deprecated(&quot;because&quot;)]]&lt;/code&gt;</source>
          <target state="translated">3) 인수가있는 속성 (예 : &lt;code&gt;[[deprecated(&quot;because&quot;)]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d691fb320f3108e5388841a4dc3ecd35f03a748" translate="yes" xml:space="preserve">
          <source>3) binary right fold</source>
          <target state="translated">3) 이진 오른쪽 접기</target>
        </trans-unit>
        <trans-unit id="04a489ba555c6fcc3c9976d9b52269cfe1cff7db" translate="yes" xml:space="preserve">
          <source>3) bitwise OR</source>
          <target state="translated">3) 비트 OR</target>
        </trans-unit>
        <trans-unit id="652c10999778959225a32c8a85781e8e17e5cf95" translate="yes" xml:space="preserve">
          <source>3) braced-init-list: possibly empty, comma-separated list of expressions and other braced-init-lists</source>
          <target state="translated">3) braced-init-list : 비어 있고 쉼표로 구분 된 표현식 목록 및 기타 braced-init-list</target>
        </trans-unit>
        <trans-unit id="4a92bfe20c2b41c2ffab2f58ee0fc0a40ff982ba" translate="yes" xml:space="preserve">
          <source>3) by-copy capture with an &lt;a href=&quot;initialization&quot;&gt;initializer&lt;/a&gt;</source>
          <target state="translated">3) &lt;a href=&quot;initialization&quot;&gt;이니셜 라이저를&lt;/a&gt; 이용한 복사 별 캡처</target>
        </trans-unit>
        <trans-unit id="bc97f5c61121198677a9697e708fca91bc3491c3" translate="yes" xml:space="preserve">
          <source>3) calls &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtold&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstold&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtold&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstold&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f57fc1089d4ab92c199a3abb2e4e84fe0b895d7" translate="yes" xml:space="preserve">
          <source>3) calls &lt;code&gt;&lt;a href=&quot;../byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstol&quot;&gt;std::wcstoll&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../wide/wcstol&quot;&gt;std::wcstoll&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b58c2fe23c209a07cbd3e585d20b1c41b3e21888" translate="yes" xml:space="preserve">
          <source>3) characters in the range &lt;code&gt;[first2, last2)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;[first2, last2)&lt;/code&gt; 범위의 문자 .</target>
        </trans-unit>
        <trans-unit id="55c9063212dece2c40b250c09342ca588b514856" translate="yes" xml:space="preserve">
          <source>3) copy constructor. Constructs the container with the copy of the contents of &lt;code&gt;other&lt;/code&gt;, copies the load factor, the predicate, and the hash function as well. If &lt;code&gt;alloc&lt;/code&gt; is not provided, allocator is obtained by calling &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::select_on_container_copy_construction(other.get_allocator())&lt;/code&gt;.</source>
          <target state="translated">3) 복사 생성자. &lt;code&gt;other&lt;/code&gt; 의 컨텐츠 사본으로 컨테이너를 구성하고 로드 팩터, 술어 및 해시 함수도 복사합니다. 경우 &lt;code&gt;alloc&lt;/code&gt; 제공되지 않고, 호출 할당함으로써 얻어지는 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::select_on_container_copy_construction(other.get_allocator())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6893855af86b5c0cd63c25edcf00090090e8fc67" translate="yes" xml:space="preserve">
          <source>3) counts elements for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">3) 술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 요소를 계산 합니다 .</target>
        </trans-unit>
        <trans-unit id="760b93562a5dc4b1eb578d2151b6295f3cf52a06" translate="yes" xml:space="preserve">
          <source>3) cv-qualification rules are the same as for member of object operator, with one additional rule: a pointer to member that refers to a mutable member cannot be used to modify that member in a const object;</source>
          <target state="translated">3) cv-qualification 규칙은 객체 연산자의 멤버와 동일하며 하나의 추가 규칙이 있습니다. 가변 멤버를 참조하는 멤버에 대한 포인터는 const 객체에서 해당 멤버를 수정하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a0f626627b9f81f4e7e0997546307bc99fec13bb" translate="yes" xml:space="preserve">
          <source>3) cv-qualified versions of one of the above</source>
          <target state="translated">3) 상기 중 하나의 cv 인증 버전</target>
        </trans-unit>
        <trans-unit id="1048b9840acffeb9919c9a3a9dd1d739a28b7cb3" translate="yes" xml:space="preserve">
          <source>3) default label in a &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; statement.</source>
          <target state="translated">3) &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; 문 에 기본 레이블 .</target>
        </trans-unit>
        <trans-unit id="b3ed4381a4c5a4a0a776d0e839431fab990896f2" translate="yes" xml:space="preserve">
          <source>3) explicitly deleted function definition</source>
          <target state="translated">3) 명시 적으로 삭제 된 함수 정의</target>
        </trans-unit>
        <trans-unit id="a97ff3ac0c9ec92446d737c4d9d5b54e6f2b8b3b" translate="yes" xml:space="preserve">
          <source>3) files created by &lt;code&gt;&lt;a href=&quot;../../io/c/tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; are removed</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../../io/c/tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; 로 작성된 파일 이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="eb4b749f55c8e582961149bc519050d0fdb8be68" translate="yes" xml:space="preserve">
          <source>3) forms a literal &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;long double&amp;gt;&lt;/code&gt; with the real part zero and imaginary part &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">3) 실수 부분 0과 허수 부분 &lt;code&gt;arg&lt;/code&gt; 로 리터럴 &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;long double&amp;gt;&lt;/code&gt; 을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="65f35e330e5d2b7197814a8722f3d83824815d80" translate="yes" xml:space="preserve">
          <source>3) if &lt;code&gt;E2&lt;/code&gt; is a &lt;a href=&quot;static&quot;&gt;static member function&lt;/a&gt;, the result is an lvalue designating that static member function. Essentially, &lt;code&gt;E1&lt;/code&gt; is evaluated and discarded in this case;</source>
          <target state="translated">3) &lt;code&gt;E2&lt;/code&gt; 가 &lt;a href=&quot;static&quot;&gt;정적 멤버 함수&lt;/a&gt; 인 경우 결과는 해당 정적 멤버 함수를 지정하는 lvalue입니다. 기본적 으로이 경우 &lt;code&gt;E1&lt;/code&gt; 을 평가하고 버립니다.</target>
        </trans-unit>
        <trans-unit id="e25fdb0857d791e3ee9fff7d173d5fcc148e102f" translate="yes" xml:space="preserve">
          <source>3) if &lt;code&gt;T&lt;/code&gt; is a class type with a member type &lt;code&gt;T::argument_type&lt;/code&gt;, then &lt;code&gt;argument_type&lt;/code&gt; is an alias of that.</source>
          <target state="translated">3) &lt;code&gt;T&lt;/code&gt; 가 멤버 유형이 &lt;code&gt;T::argument_type&lt;/code&gt; 인 클래스 유형 인 경우 &lt;code&gt;argument_type&lt;/code&gt; 은 그 별명입니다.</target>
        </trans-unit>
        <trans-unit id="ae210b7bef5f4480ec5f9f0fe776140f4e8d036d" translate="yes" xml:space="preserve">
          <source>3) if &lt;code&gt;T&lt;/code&gt; is a class type with a member type &lt;code&gt;T::first_argument_type&lt;/code&gt;, then &lt;code&gt;first_argument_type&lt;/code&gt; is an alias of that.</source>
          <target state="translated">3) &lt;code&gt;T&lt;/code&gt; 가 멤버 유형이 &lt;code&gt;T::first_argument_type&lt;/code&gt; 인 클래스 유형 인 경우 &lt;code&gt;first_argument_type&lt;/code&gt; 은 그 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="0806903e4bdd82779de06ae3f5540676a2dcfab4" translate="yes" xml:space="preserve">
          <source>3) if &lt;code&gt;T&lt;/code&gt; is a class type with a member type &lt;code&gt;T::second_argument_type&lt;/code&gt;, then &lt;code&gt;second_argument_type&lt;/code&gt; is an alias of that.</source>
          <target state="translated">3) &lt;code&gt;T&lt;/code&gt; 가 멤버 유형이 &lt;code&gt;T::second_argument_type&lt;/code&gt; 인 클래스 유형 인 경우 &lt;code&gt;second_argument_type&lt;/code&gt; 은 그 별명입니다.</target>
        </trans-unit>
        <trans-unit id="5187a9b908ae317f2fa0d3270c45a1c06f97df60" translate="yes" xml:space="preserve">
          <source>3) if &lt;code&gt;T&lt;/code&gt; is an array type, each element of the array is value-initialized;</source>
          <target state="translated">3) &lt;code&gt;T&lt;/code&gt; 가 배열 유형 인 경우 배열의 각 요소는 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="048ef5dbf48237f293fb0aacd098a3a77010af17" translate="yes" xml:space="preserve">
          <source>3) initialization of a prvalue temporary by &lt;a href=&quot;explicit_cast&quot;&gt;functional cast&lt;/a&gt; or with a parenthesized expression list</source>
          <target state="translated">3) &lt;a href=&quot;explicit_cast&quot;&gt;함수형 캐스트&lt;/a&gt; 또는 괄호 로 묶은 표현식 목록을 사용하여 임시 prvalue 초기화</target>
        </trans-unit>
        <trans-unit id="a4101a4f5111b9bc9e8639bcdb38879ae15c070b" translate="yes" xml:space="preserve">
          <source>3) initialization of an object with dynamic storage duration with a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, where the initializer is a brace-init-list</source>
          <target state="translated">3) 이니셜 라이저가 brace-init-list 인 &lt;a href=&quot;new&quot;&gt;new-expression을&lt;/a&gt; 사용하여 동적 저장 기간을 가진 객체 의 초기화</target>
        </trans-unit>
        <trans-unit id="6b17f8578d2fcc738f6a3ee08e2209758da8a73f" translate="yes" xml:space="preserve">
          <source>3) inserts &lt;code&gt;count&lt;/code&gt; copies of the &lt;code&gt;value&lt;/code&gt; after the element pointed to by &lt;code&gt;pos&lt;/code&gt;</source>
          <target state="translated">3) 삽입은 &lt;code&gt;count&lt;/code&gt; 의 복사 &lt;code&gt;value&lt;/code&gt; 가리키는 요소 뒤에 &lt;code&gt;pos&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="739382f91ea511bc575531ff12244cb1f7da1949" translate="yes" xml:space="preserve">
          <source>3) inserts &lt;code&gt;count&lt;/code&gt; copies of the &lt;code&gt;value&lt;/code&gt; before &lt;code&gt;pos&lt;/code&gt;</source>
          <target state="translated">3) 삽입은 &lt;code&gt;count&lt;/code&gt; 의 복사 &lt;code&gt;value&lt;/code&gt; 전에 &lt;code&gt;pos&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50a391ff617f9d513ed9544c032250601e82fa2f" translate="yes" xml:space="preserve">
          <source>3) iterator pointing to the character &lt;code&gt;last&lt;/code&gt; pointed to before the erase, or &lt;code&gt;end()&lt;/code&gt; if no such character exists</source>
          <target state="translated">3) 지우기 전에 &lt;code&gt;last&lt;/code&gt; 가리키는 문자를 가리키는 반복자 또는 그러한 문자가 없으면 &lt;code&gt;end()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc7972856cd774c97ade8a6c1051488492723094" translate="yes" xml:space="preserve">
          <source>3) linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">3) 선형 &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65ad8d83fcd2f6d74a5f43e50c748c4101d25c3d" translate="yes" xml:space="preserve">
          <source>3) linear in size of &lt;code&gt;other&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;other&lt;/code&gt; 크기의 선형</target>
        </trans-unit>
        <trans-unit id="8880501fa9d2e5a0f3c44a1480b013b5066ec13a" translate="yes" xml:space="preserve">
          <source>3) linear in size of &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;s&lt;/code&gt; 크기의 선형</target>
        </trans-unit>
        <trans-unit id="f5919b81092eb362583fce5f28096ef4be37d0f6" translate="yes" xml:space="preserve">
          <source>3) meets the &lt;a href=&quot;../../named_req/transformationtrait&quot;&gt;TransformationTrait&lt;/a&gt; requirements with a member typedef &lt;code&gt;type&lt;/code&gt; that names, respectively, &lt;code&gt;&lt;a href=&quot;../../types/add_cv&quot;&gt;std::add_const_t&lt;/a&gt;&amp;lt;std::variant_alternative&amp;lt;I,T&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/add_cv&quot;&gt;std::add_volatile_t&lt;/a&gt;&amp;lt;std::variant_alternative&amp;lt;I,T&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../../types/add_cv&quot;&gt;std::add_cv_t&lt;/a&gt;&amp;lt;std::variant_alternative&amp;lt;I,T&amp;gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">3) 각각 &lt;code&gt;&lt;a href=&quot;../../types/add_cv&quot;&gt;std::add_const_t&lt;/a&gt;&amp;lt;std::variant_alternative&amp;lt;I,T&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;std :: variant_alternative &amp;lt;I, T &amp;gt;&amp;gt; , &lt;code&gt;&lt;a href=&quot;../../types/add_cv&quot;&gt;std::add_volatile_t&lt;/a&gt;&amp;lt;std::variant_alternative&amp;lt;I,T&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;std :: variant_alternative &amp;lt;I, T &amp;gt;&amp;gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/add_cv&quot;&gt;std::add_cv_t&lt;/a&gt;&amp;lt;std::variant_alternative&amp;lt;I,T&amp;gt;&amp;gt;&lt;/code&gt; 라는 멤버 typedef &lt;code&gt;type&lt;/code&gt; &lt;a href=&quot;../../named_req/transformationtrait&quot;&gt;TransformationTrait&lt;/a&gt; 요구 사항을 충족합니다. :: add_cv_t &amp;lt;std :: variant_alternative &amp;lt;I, T &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7da20d5c8aa15b36c664a144aed60475997a65c7" translate="yes" xml:space="preserve">
          <source>3) meets the &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; requirements with a BaseCharacteristic of &lt;code&gt;std::integral_constant&amp;lt;std::size_t, variant_size&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;std::integral_constant&amp;lt;std::size_t, variant_size&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 의 &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;기본 특성으로 UnaryTypeTrait&lt;/a&gt; 요구 사항을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="f140a0dadbf9861e93c2d7f748cf156f6e335408" translate="yes" xml:space="preserve">
          <source>3) nested types</source>
          <target state="translated">3) 중첩 유형</target>
        </trans-unit>
        <trans-unit id="aace007f9daf107f5ee3d35b2c3626a157b0bafb" translate="yes" xml:space="preserve">
          <source>3) or, if not that, (only in context of initialization by conversion function for direct reference binding of a reference to function type), the return type of F1 is the same kind of reference (lvalue or rvalue) as the reference being initialized, and the return type of F2 is not</source>
          <target state="translated">3) 또는 그렇지 않은 경우 (함수 유형에 대한 참조의 직접 참조 바인딩을위한 변환 함수에 의한 초기화 컨텍스트에서만) F1의 리턴 유형은 초기화되는 참조와 동일한 종류의 참조 (lvalue 또는 rvalue)입니다. F2의 반환 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="edd8dcf20c7ac7372295c877853c3c50cd4a0d2f" translate="yes" xml:space="preserve">
          <source>3) pointer to user-provided allocation function</source>
          <target state="translated">3) 사용자 제공 할당 기능에 대한 포인터</target>
        </trans-unit>
        <trans-unit id="cf0da5f3045a63172f8ea6c259a1dc694fa07b5f" translate="yes" xml:space="preserve">
          <source>3) private storage: indexed extensible data structure that allows both &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;void*&lt;/code&gt; members, which may be implemented as two arbitrary-length arrays or a single array of two-element structs or another container.</source>
          <target state="translated">3) 개인 스토리지 : 두 개의 임의 길이 배열 또는 두 개의 요소로 구성된 단일 배열 또는 다른 컨테이너로 구현 될 수있는 &lt;code&gt;long&lt;/code&gt; 및 &lt;code&gt;void*&lt;/code&gt; 멤버를 모두 허용하는 인덱스 확장 가능한 데이터 구조 .</target>
        </trans-unit>
        <trans-unit id="322b17151b0745396c865a8bac191207b1f57b49" translate="yes" xml:space="preserve">
          <source>3) remainder</source>
          <target state="translated">3) 나머지</target>
        </trans-unit>
        <trans-unit id="2351f17694b79338b53c2d32168976a4792dffa5" translate="yes" xml:space="preserve">
          <source>3) removes the topmost &lt;code&gt;volatile&lt;/code&gt;.</source>
          <target state="translated">3) 맨 위 &lt;code&gt;volatile&lt;/code&gt; 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="68f693d59bb82f6a335d7b8b6db09b00e73b4ebf" translate="yes" xml:space="preserve">
          <source>3) returns &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::u16string&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::u16string&lt;/a&gt;{str, len}&lt;/code&gt; {str, len}을 반환합니다</target>
        </trans-unit>
        <trans-unit id="41bf597f82b1d1cad984db5bf1743e58d7e7fd73" translate="yes" xml:space="preserve">
          <source>3) returns &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::u16string_view&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::u16string_view&lt;/a&gt;{str, len}&lt;/code&gt; {str, len}을 반환합니다</target>
        </trans-unit>
        <trans-unit id="7e108ba8ca31bd5a74bfc0038ace97fffddb4d2d" translate="yes" xml:space="preserve">
          <source>3) returns &lt;code&gt;array&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;array&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="7de3f2600661414fd71954cabb9a03a6cda6f63d" translate="yes" xml:space="preserve">
          <source>3) returns &lt;code&gt;il.size() == 0&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;il.size() == 0&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="f730a2a3ae2515ddc24201563e53cace850bcbe9" translate="yes" xml:space="preserve">
          <source>3) same as (1), but the evaluation of the assignment expression will not call any operation that is not noexcept.</source>
          <target state="translated">3) (1)과 동일하지만 할당 표현식의 평가는 예외가 아닌 연산을 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03d5a2a70ee8ca2243558b268e4e4f3b9f09b5aa" translate="yes" xml:space="preserve">
          <source>3) same as (2), but the conversion specified for the as-if printf is &lt;code&gt;f&lt;/code&gt; if &lt;code&gt;fmt&lt;/code&gt; is &lt;a href=&quot;chars_format&quot;&gt;&lt;code&gt;std::chars_format::fixed&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;e&lt;/code&gt; if &lt;code&gt;fmt&lt;/code&gt; is &lt;a href=&quot;chars_format&quot;&gt;&lt;code&gt;std::chars_format::scientific&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;a&lt;/code&gt; (but without leading &quot;0x&quot; in the result) if &lt;code&gt;fmt&lt;/code&gt; is &lt;a href=&quot;chars_format&quot;&gt;&lt;code&gt;std::chars_format::hex&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;g&lt;/code&gt; if &lt;code&gt;fmt&lt;/code&gt; is &lt;a href=&quot;chars_format&quot;&gt;&lt;code&gt;chars_format::general&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">3) (2) 그러나의 printf이면 그대로 지정된 전환과 동일한 &lt;code&gt;f&lt;/code&gt; 는 만약 &lt;code&gt;fmt&lt;/code&gt; IS &lt;a href=&quot;chars_format&quot;&gt; &lt;code&gt;std::chars_format::fixed&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;e&lt;/code&gt; 만약 &lt;code&gt;fmt&lt;/code&gt; IS &lt;a href=&quot;chars_format&quot;&gt; &lt;code&gt;std::chars_format::scientific&lt;/code&gt; &lt;/a&gt; , (그러나 선행없이 &quot;0X &quot;경우)의 결과 &lt;code&gt;fmt&lt;/code&gt; IS &lt;a href=&quot;chars_format&quot;&gt; &lt;code&gt;std::chars_format::hex&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;g&lt;/code&gt; 만약 &lt;code&gt;fmt&lt;/code&gt; 있다 &lt;a href=&quot;chars_format&quot;&gt; &lt;code&gt;chars_format::general&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ca3056fd191501960dcfeda57e3b77eade0904b" translate="yes" xml:space="preserve">
          <source>3) same as 1), but the destructor is noexcept.</source>
          <target state="translated">3) 1)과 동일하지만 소멸자는 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="062bfe9955207c02833ad59b374c43c1054ba514" translate="yes" xml:space="preserve">
          <source>3) same as 1), but the variable definition is &lt;code&gt;noexcept&lt;/code&gt;.</source>
          <target state="translated">3) 1)과 동일하지만 변수 정의는 &lt;code&gt;noexcept&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="66679282225c2a9805ff609db87b9d14b1b16d41" translate="yes" xml:space="preserve">
          <source>3) same as &lt;code&gt;reduce(first, last, init, &lt;a href=&quot;../utility/functional/plus&quot;&gt;std::plus&lt;/a&gt;&amp;lt;&amp;gt;())&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;reduce(first, last, init, &lt;a href=&quot;../utility/functional/plus&quot;&gt;std::plus&lt;/a&gt;&amp;lt;&amp;gt;())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="493d1c0f698618d6fcf449a293e4e494204001cd" translate="yes" xml:space="preserve">
          <source>3) selection statements;</source>
          <target state="translated">3) 선택 진술;</target>
        </trans-unit>
        <trans-unit id="e40a06b4c4c919cace92ac3e95bd905380d8d850" translate="yes" xml:space="preserve">
          <source>3) sequence of file-names, omitting any directory separators</source>
          <target state="translated">3) 파일 이름 순서, 디렉토리 구분 기호 생략</target>
        </trans-unit>
        <trans-unit id="9dab6dd52eb6a5b6430a643119131d10af088428" translate="yes" xml:space="preserve">
          <source>3) sets the &lt;code&gt;adjustfield&lt;/code&gt; of the stream &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;internal&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: internal&lt;/a&gt; , &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: adjustfield&lt;/a&gt; ) 를 호출 하여 스트림 &lt;code&gt;str&lt;/code&gt; 의 &lt;code&gt;adjustfield&lt;/code&gt; 를 &lt;code&gt;internal&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="a030f7757853bd064515368512146c6208e9c3a5" translate="yes" xml:space="preserve">
          <source>3) sets the &lt;code&gt;basefield&lt;/code&gt; of the stream &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;oct&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::oct&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::basefield&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">3) 세트 &lt;code&gt;basefield&lt;/code&gt; 스트림의 &lt;code&gt;str&lt;/code&gt; 행 &lt;code&gt;oct&lt;/code&gt; 호출하여 마치 &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::oct&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::basefield&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b9f444b741cfcacfcfa162ebe7a6d19a187794e" translate="yes" xml:space="preserve">
          <source>3) the constructor or the destructor of a static or thread-local object throws an exception</source>
          <target state="translated">3) 정적 또는 스레드 로컬 객체의 생성자 또는 소멸자가 예외를 throw합니다.</target>
        </trans-unit>
        <trans-unit id="d3a14c2c25daeecf9721e0c14c79c2509890a20e" translate="yes" xml:space="preserve">
          <source>3) the integral number of seconds &lt;code&gt;since_midnight&lt;/code&gt; is after &lt;code&gt;(00:00:00 + hours() + minutes())&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;since_midnight&lt;/code&gt; 의 정수 초 는 &lt;code&gt;(00:00:00 + hours() + minutes())&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ae09ff8d6024c2ce661567593dee2e65e0a180e2" translate="yes" xml:space="preserve">
          <source>3) the number of initializer-clauses exceeds the number of elements to initialize.</source>
          <target state="translated">3) initializer-clauses의 수가 초기화 할 요소 수를 초과합니다.</target>
        </trans-unit>
        <trans-unit id="99f391f7d7fd6d3e3aed88d7abe41b7608b6acbc" translate="yes" xml:space="preserve">
          <source>3) the prefix is a C-style string</source>
          <target state="translated">3) 접두사는 C 스타일 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ff4d37a601705f3d7c6ad760cc78a5d303d9b145" translate="yes" xml:space="preserve">
          <source>3) the prefix is a C-style string. Effectively returns &lt;code&gt;starts_with(basic_string_view(x))&lt;/code&gt;</source>
          <target state="translated">3) 접두사는 C 스타일 문자열입니다. 효과적으로 &lt;code&gt;starts_with(basic_string_view(x))&lt;/code&gt; 반환합니다</target>
        </trans-unit>
        <trans-unit id="f0e9f99a03ccb78d7ba37682df275e5edfbc0f81" translate="yes" xml:space="preserve">
          <source>3) the suffix is a C-style string</source>
          <target state="translated">3) 접미사는 C 스타일 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="90859d09b3d3abd69f86a6ae803a432705ce263f" translate="yes" xml:space="preserve">
          <source>3) the suffix is a C-style string. Effectively returns &lt;code&gt;ends_with(basic_string_view(x))&lt;/code&gt;</source>
          <target state="translated">3) 접미사는 C 스타일 문자열입니다. &lt;code&gt;ends_with(basic_string_view(x))&lt;/code&gt; 효과적으로 반환</target>
        </trans-unit>
        <trans-unit id="30c54d48beb81bd741cbc614ddde246ff002abb9" translate="yes" xml:space="preserve">
          <source>3) throw exception of type &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or derived from &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">타입 3) 투사 예외 &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 또는 유래의 &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4477776429f85888df04e99879179c77664579a" translate="yes" xml:space="preserve">
          <source>3) void specialization, used to communicate stateless events</source>
          <target state="translated">3) 무효화 전문화, 무국적 이벤트 전달에 사용</target>
        </trans-unit>
        <trans-unit id="f7a2a2b99877d43ec11afa3802d7fabc4254a28b" translate="yes" xml:space="preserve">
          <source>3) when &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;passing an argument&lt;/a&gt; to a function by value</source>
          <target state="translated">3) 값으로 함수에 &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;인수&lt;/a&gt; 를 전달할 때</target>
        </trans-unit>
        <trans-unit id="ca998f5ae7afbeb398d907d4e1568527eb4c8fbf" translate="yes" xml:space="preserve">
          <source>3) when a &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;placement operator delete&lt;/a&gt; that is a function template specialization is selected to match a placement operator new</source>
          <target state="translated">3) 기능 템플릿 전문인 &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;게재 위치 연산자 삭제&lt;/a&gt; 가 게재 위치 연산자와 일치하도록 선택된 경우 new</target>
        </trans-unit>
        <trans-unit id="ba5d76df1540f5a2ad7124efb079b6d27a6bcdee" translate="yes" xml:space="preserve">
          <source>3) when a base class or a non-static data member is not mentioned in a constructor &lt;a href=&quot;constructor&quot;&gt;initializer list&lt;/a&gt; and that constructor is called.</source>
          <target state="translated">3) 생성자 &lt;a href=&quot;constructor&quot;&gt;이니셜 라이저 목록에&lt;/a&gt; 기본 클래스 또는 비 정적 데이터 멤버가 언급되지 않고 해당 생성자가 호출되는 경우.</target>
        </trans-unit>
        <trans-unit id="88a8d15a551fe11ceb9affb6bfc4fea786e0d27b" translate="yes" xml:space="preserve">
          <source>3) within &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt;(since C++11)</source>
          <target state="translated">3) &lt;a href=&quot;data_members#Member_initialization&quot;&gt;기본 멤버 이니셜 라이저&lt;/a&gt; 내 (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="003ed6baf0ee44b4225c9005067d80bc0fd7c3a1" translate="yes" xml:space="preserve">
          <source>3) zero or one</source>
          <target state="translated">3) 0 또는 1</target>
        </trans-unit>
        <trans-unit id="80a03ff972d6d894bbb0e1e9623570323fe77a56" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;../../language/converting_constructor&quot;&gt;Converting constructor&lt;/a&gt;. Constructs the object from a complex number of a different type.</source>
          <target state="translated">3) &lt;a href=&quot;../../language/converting_constructor&quot;&gt;생성자 변환&lt;/a&gt; . 다른 유형의 복소수로 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="34ebe71d05fa1515274916febf5c9aa334da85c4" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;../../language/copy_constructor&quot;&gt;Copy constructor&lt;/a&gt;. Constructs the container with the copy of the contents of &lt;code&gt;other&lt;/code&gt;. If &lt;code&gt;alloc&lt;/code&gt; is not provided, allocator is obtained by calling &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::select_on_container_copy_construction(other.get_allocator())&lt;/code&gt;.</source>
          <target state="translated">3) &lt;a href=&quot;../../language/copy_constructor&quot;&gt;복사 생성자&lt;/a&gt; . &lt;code&gt;other&lt;/code&gt; 의 내용을 복사하여 컨테이너를 구성합니다 . 경우 &lt;code&gt;alloc&lt;/code&gt; 제공되지 않고, 호출 할당함으로써 얻어지는 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::select_on_container_copy_construction(other.get_allocator())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2930629e5508933cf0fbf8a631b540b919d2a22" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;../memory/new/operator_new&quot;&gt;allocation function&lt;/a&gt;;</source>
          <target state="translated">3) &lt;a href=&quot;../memory/new/operator_new&quot;&gt;할당 기능&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="0a60eec6ef68d32907f86128f2d9f998e1595759" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;access&quot;&gt;Access specifiers&lt;/a&gt;&lt;code&gt;public:&lt;/code&gt;, &lt;code&gt;protected:&lt;/code&gt;, and &lt;code&gt;private:&lt;/code&gt;</source>
          <target state="translated">3) &lt;a href=&quot;access&quot;&gt;액세스 지정자 &lt;/a&gt; &lt;code&gt;public:&lt;/code&gt; , &lt;code&gt;protected:&lt;/code&gt; 및 &lt;code&gt;private:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea5b006c914513406213f5f5f6569ad1d6471537" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; loop;</source>
          <target state="translated">3) &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; 루프;</target>
        </trans-unit>
        <trans-unit id="3f914731c94ec7072589bdea0eb1de05a4fb29fa" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;namespace#Unnamed_namespaces&quot;&gt;Unnamed namespace definition&lt;/a&gt;. Its members have potential scope from their point of declaration to the end of the translation unit, and have &lt;a href=&quot;storage_duration&quot;&gt;internal linkage&lt;/a&gt;.</source>
          <target state="translated">3) &lt;a href=&quot;namespace#Unnamed_namespaces&quot;&gt;이름이없는 네임 스페이스 정의&lt;/a&gt; . 멤버는 선언 시점부터 번역 단위의 끝까지 잠재적 인 범위를 가지며 &lt;a href=&quot;storage_duration&quot;&gt;내부 연결이&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="24d0238fcca8074356e620b3e61cf1c23e9e578a" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;operator_alternative&quot;&gt;Trigraph sequences&lt;/a&gt; are replaced by corresponding single-character representations.</source>
          <target state="translated">3) &lt;a href=&quot;operator_alternative&quot;&gt;Trigraph 시퀀스&lt;/a&gt; 는 해당하는 단일 문자 표현으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="186935f90c2a2d47aa24834883a2b6cf13d0e96a" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;parameter_pack&quot;&gt;Parameter pack&lt;/a&gt;, only appears in &lt;a href=&quot;function#Parameter_list&quot;&gt;parameter declarations&lt;/a&gt;.</source>
          <target state="translated">3) &lt;a href=&quot;parameter_pack&quot;&gt;매개 변수 팩&lt;/a&gt; 은 &lt;a href=&quot;function#Parameter_list&quot;&gt;매개 변수 선언&lt;/a&gt; 에만 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="8ac9cefd36a7e8cb498276532e1236485f6fe0c8" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; statement with an optional expression;</source>
          <target state="translated">3) 선택적인 표현으로 진술을 &lt;a href=&quot;return&quot;&gt;반환&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="0d5704a9796efaca386f916b15a809d3bad39fd9" translate="yes" xml:space="preserve">
          <source>3)&lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; statement.</source>
          <target state="translated">3) &lt;a href=&quot;switch&quot;&gt;스위치&lt;/a&gt; 설명.</target>
        </trans-unit>
        <trans-unit id="cb94de0bcb8492e48f1dc19ce4b95eb2fe7ea34a" translate="yes" xml:space="preserve">
          <source>3)&lt;b&gt;Conversion&lt;/b&gt;: integral conversion, floating-point conversion, floating-integral conversion, pointer conversion, pointer-to-member conversion, boolean conversion, user-defined conversion of a derived class to its base</source>
          <target state="translated">3) &lt;b&gt;변환&lt;/b&gt; : 적분 변환, 부동 소수점 변환, 부동 적분 변환, 포인터 변환, 포인터-멤버 변환, 부울 변환, 파생 클래스의 기본 사용자 정의 변환</target>
        </trans-unit>
        <trans-unit id="b1fc0b76711dae95edf8d9e2aad2b35ac1298f6f" translate="yes" xml:space="preserve">
          <source>3)&lt;b&gt;Read-write coherence&lt;/b&gt;: if a value computation A of some atomic M (a read)</source>
          <target state="translated">3) &lt;b&gt;읽기-쓰기 일관성&lt;/b&gt; : 일부 원자 M의 값 계산 A (읽기)</target>
        </trans-unit>
        <trans-unit id="0f479b86781470652259f260d7283ed76366bc7e" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;&amp;amp;a[i] != &amp;amp;b[j]&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;&amp;amp;a[i] != &amp;amp;b[j]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="daf6e681ae9fc502f0178f2bf8f9b8378995ef59" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">3)&lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11b6284f44475577270c81f0fcc53c5bc937506a" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos &amp;gt; other.size()&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;pos &amp;gt; other.size()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80be02499b71a5b42a6ad2cd00ad202c75cd9f8a" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt; if any character is not one or zero</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt; 모든 문자가 하나 또는 0이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="ee0ee61edbc835898bbe9e881b557190690360d9" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; if the thread could not be started. The exception may represent the error condition &lt;code&gt;std::errc::resource_unavailable_try_again&lt;/code&gt; or another implementation-specific error condition.</source>
          <target state="translated">스레드를 시작할 수없는 경우 3) &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 예외는 오류 조건 &lt;code&gt;std::errc::resource_unavailable_try_again&lt;/code&gt; 또는 다른 구현 별 오류 조건을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04b6bddd10bd85f982b7c7e02fa8e5ec50c3bb97" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;V&amp;gt;()(lhs.get(), rhs.get())&lt;/code&gt;, where V is the &lt;a href=&quot;../../language/operator_comparison#Pointer_comparison_operators&quot;&gt;composite pointer type&lt;/a&gt; of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::element_type*&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;U&amp;gt;::element_type*&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&amp;lt;V&amp;gt;()(lhs.get(), rhs.get())&lt;/code&gt; , V는 여기서 &lt;a href=&quot;../../language/operator_comparison#Pointer_comparison_operators&quot;&gt;합성 포인터 타입&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::element_type*&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;U&amp;gt;::element_type*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2ff6b581a992bc5ed00241f6be98110fc897f2c" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;&lt;a href=&quot;../c/ungetc&quot;&gt;std::ungetc&lt;/a&gt;(c, f)&lt;/code&gt; and &lt;code&gt;str.rdbuf()-&amp;gt;sputbackc(c)&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../c/ungetc&quot;&gt;std::ungetc&lt;/a&gt;(c, f)&lt;/code&gt; 및 &lt;code&gt;str.rdbuf()-&amp;gt;sputbackc(c)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12c4fe0dced8910c1ebe55544adc6ae1452c2cc4" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;&lt;a href=&quot;../day&quot;&gt;std::chrono::day&lt;/a&gt;(unsigned(d) - ds.count())&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../day&quot;&gt;std::chrono::day&lt;/a&gt;(unsigned(d) - ds.count())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a68e58864d24db1442e3fbde87a9c0a831b953b8" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if required additional memory could not be obtained. May throw implementation-defined exception for other errors. &lt;code&gt;delete ptr&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is not an array type, &lt;code&gt;delete[] ptr&lt;/code&gt; otherwise)(since C++17) is called if an exception occurs.</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 필요한 경우 추가 메모리를 확보 할 수 없습니다. 다른 오류에 대해서는 구현 정의 예외가 발생할 수 있습니다. &lt;code&gt;T&lt;/code&gt; 가 배열 유형이 아닌 경우 &lt;code&gt;delete ptr&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;delete[] ptr&lt;/code&gt; ) (C ++ 17부터) 예외가 발생하면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="af5d815259c3b60276bf884c88405bc53b10a777" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;&lt;a href=&quot;../year&quot;&gt;std::chrono::year&lt;/a&gt;(int(y) - ys.count())&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;../year&quot;&gt;std::chrono::year&lt;/a&gt;(int(y) - ys.count())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22376aa5bc2befa5e18854f733111daf08cf9111" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;&lt;a href=&quot;get_id&quot;&gt;get_id()&lt;/a&gt;&lt;/code&gt; not equal to &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id()&lt;/a&gt;&lt;/code&gt; (i.e. &lt;code&gt;&lt;a href=&quot;joinable&quot;&gt;joinable&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;)</source>
          <target state="translated">3) &lt;code&gt;&lt;a href=&quot;get_id&quot;&gt;get_id()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id()&lt;/a&gt;&lt;/code&gt; 같지 않음 (즉, &lt;code&gt;&lt;a href=&quot;joinable&quot;&gt;joinable&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="00464795ad06ca2789a7eb293b09e4790d31f33f" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;bitset&amp;lt;N&amp;gt;(lhs) ^= rhs&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;bitset&amp;lt;N&amp;gt;(lhs) ^= rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54676b88618d9bf0a4f1322beff074c3d0b3a270" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;cmp &amp;lt; 0&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;cmp &amp;lt; 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03cbcb175c6041d32cc33d77f7d3646888c1168f" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;find_if&lt;/code&gt; searches for an element for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;find_if&lt;/code&gt; 는 술어 &lt;code&gt;p&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하는 요소를 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="10c799d009d312c8c1e7d60be1224553fe978d1a" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;from_stream(is, fmt.c_str(), tp, nullptr, &amp;amp;offset)&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;from_stream(is, fmt.c_str(), tp, nullptr, &amp;amp;offset)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91aa2433cb57e87ad1fedf9d9afb1081fd513bc3" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;int(x) &amp;lt; int(y)&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;int(x) &amp;lt; int(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ee42b1e4054bff3d4bc18fbb76e88e170b2c7ca" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;lhs.base() &amp;gt; rhs.base()&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;lhs.base() &amp;gt; rhs.base()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8fe1c79e81a8df8bd999c7bb3f74c1117d4d23ab" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;lhs.base() &amp;lt; rhs.base()&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;lhs.base() &amp;lt; rhs.base()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e67819b5769ff9ce78e7a0f8090966cdd8db4eda" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;log(c.size()) + c.count(k)&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;log(c.size()) + c.count(k)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3043b605bf8664d093a88682bdeb768f76394119" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;obj-&amp;gt;compare_exchange_weak(*expected, desired, succ, fail)&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;obj-&amp;gt;compare_exchange_weak(*expected, desired, succ, fail)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70be4c4f47064bf34fe1b11183a074306e30992d" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;std::future&lt;/code&gt; is not &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">3) &lt;code&gt;std::future&lt;/code&gt; 는 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="ad543b3625d76ef9b046adbca5547f55a88e8121" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*this&lt;/code&gt; is less than &lt;code&gt;rhs&lt;/code&gt; as defined by the order of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;&amp;amp;rhs&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;*this&lt;/code&gt; 보다 작은 &lt;code&gt;rhs&lt;/code&gt; 의 순서에 의해 정의되는 &lt;code&gt;this&lt;/code&gt; 하고 &lt;code&gt;&amp;amp;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a88814c75f464c72593230dad55ac4babb59c5a8" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs.category() &amp;lt; rhs.category()&lt;/code&gt;. Otherwise, &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs.category() == rhs.category() &amp;amp;&amp;amp; lhs.value() &amp;lt; rhs.value()&lt;/code&gt;. Otherwise, &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;lhs.category() &amp;lt; rhs.category()&lt;/code&gt; 경우 &lt;code&gt;true&lt;/code&gt; 입니다. 그렇지 않으면 &lt;code&gt;lhs.category() == rhs.category() &amp;amp;&amp;amp; lhs.value() &amp;lt; rhs.value()&lt;/code&gt; 경우 &lt;code&gt;true&lt;/code&gt; 입니다. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c72507023428e56ff45ee7b56e7dd4f83b81a696" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs.category() &amp;lt; rhs.category()&lt;/code&gt;. Otherwise, &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs.category() == rhs.category() &amp;amp;&amp;amp; lhs.value() &amp;lt; rhs.value()&lt;/code&gt;. Otherwise, &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">3) &lt;code&gt;lhs.category() &amp;lt; rhs.category()&lt;/code&gt; 경우 &lt;code&gt;true&lt;/code&gt; 입니다. 그렇지 않으면 &lt;code&gt;lhs.category() == rhs.category() &amp;amp;&amp;amp; lhs.value() &amp;lt; rhs.value()&lt;/code&gt; 경우 &lt;code&gt;true&lt;/code&gt; 입니다. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fa77abcbdcd2f48d164e5dd8000ad38d0f0cb146" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;path() &amp;lt; rhs.path()&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">3) &lt;code&gt;true&lt;/code&gt; 하는 경우 &lt;code&gt;path() &amp;lt; rhs.path()&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="ee302b109c618e0a780fe3b5fbe71a7826b5e330" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;true&lt;/code&gt; if none of the bits are set to &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;true&lt;/code&gt; 하는 비트 중 어느 것도 설정되지 않은 경우 &lt;code&gt;true&lt;/code&gt; 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7eaa355954b88254373deea6dae34705f8d24530" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;lhs&lt;/code&gt; refers to time point</source>
          <target state="translated">3) &lt;code&gt;lhs&lt;/code&gt; 가 시점을 참조 하면 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9c102c6444ed9fc5851c91a8e4dc902adc0590c" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;true&lt;/code&gt; if the contents of the &lt;code&gt;lhs&lt;/code&gt; are lexicographically</source>
          <target state="translated">3) &lt;code&gt;lhs&lt;/code&gt; 의 내용 이 사전 식 으로되어 있으면 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1dd7a248be501a4042d715962342e1a95b29904f" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;unsigned(x) &amp;lt; unsigned(y)&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;unsigned(x) &amp;lt; unsigned(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e2d0cf46781a3fb477eea2995343c50cf9b536b" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;x.date() &amp;lt; y.date()&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;x.date() &amp;lt; y.date()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f089b779b450b4bef75dc0cf56ee5679085489e9" translate="yes" xml:space="preserve">
          <source>3)&lt;code&gt;x.month() &amp;lt; y.month() || (x.month() == y.month() &amp;amp;&amp;amp; x.day() &amp;lt; y.day())&lt;/code&gt;</source>
          <target state="translated">3) &lt;code&gt;x.month() &amp;lt; y.month() || (x.month() == y.month() &amp;amp;&amp;amp; x.day() &amp;lt; y.day())&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
