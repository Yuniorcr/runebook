<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="7e427ab8b4862191565a1a29a01d981f9c08b30f" translate="yes" xml:space="preserve">
          <source>Increment and decrement</source>
          <target state="translated">증감</target>
        </trans-unit>
        <trans-unit id="cfe414b6ddcaa8292d016a5a3592ec3f7ea7fada" translate="yes" xml:space="preserve">
          <source>Increment and decrement operators are overloaded for many standard library types. In particular, every &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt; overloads operator++ and every &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; overloads operator--, even if those operators are no-ops for the particular iterator.</source>
          <target state="translated">증분 및 감소 연산자는 많은 표준 라이브러리 유형에 대해 오버로드됩니다. 특히, 모든 &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator는&lt;/a&gt; 연산자 ++를 오버로드하고 모든 &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator는&lt;/a&gt; 연산자를 오버로드합니다 (해당 연산자가 특정 반복자에 대해 운영 체제가없는 경우에도).</target>
        </trans-unit>
        <trans-unit id="f17d70be0f16733c0dc8c67eabfb624d43b60216" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators</source>
          <target state="translated">증감 연산자</target>
        </trans-unit>
        <trans-unit id="cc787748953bd4e94e67cc95ac787d4d3cfb9a68" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators increment or decrement the value of the object.</source>
          <target state="translated">증감 연산자는 객체의 값을 증감시킵니다.</target>
        </trans-unit>
        <trans-unit id="0f9b5e452f10a6b34da1fb48e02ee30bd5033db1" translate="yes" xml:space="preserve">
          <source>Incrementable</source>
          <target state="translated">Incrementable</target>
        </trans-unit>
        <trans-unit id="cc5ea811af56aeeaf46a0c9737e89031c9af2a17" translate="yes" xml:space="preserve">
          <source>Increments given iterator &lt;code&gt;it&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">증분 반복자에게 부여 &lt;code&gt;it&lt;/code&gt; 함으로써 &lt;code&gt;n&lt;/code&gt; 요소.</target>
        </trans-unit>
        <trans-unit id="e3348f80bc84ba16802159a506f193e84a80b03d" translate="yes" xml:space="preserve">
          <source>Increments or decrements the iterator.</source>
          <target state="translated">반복자를 늘리거나 줄입니다.</target>
        </trans-unit>
        <trans-unit id="84c43591c7009c31f153f3e91418e222e8d0fdab" translate="yes" xml:space="preserve">
          <source>Increments or decrements the iterator. Inverse operations are applied to the underlying operator because of the reverse order.</source>
          <target state="translated">반복자를 늘리거나 줄입니다. 역 연산으로 인해 역 연산이 기본 연산자에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="39764a20978ad7b2e0a6b9bd65f20bac9b65b929" translate="yes" xml:space="preserve">
          <source>Increments or decrements the number of ticks for this duration.</source>
          <target state="translated">이 기간 동안의 틱 수를 늘리거나 줄입니다.</target>
        </trans-unit>
        <trans-unit id="910224cadb5c448e8d25dd0213abaae95c58e5ea" translate="yes" xml:space="preserve">
          <source>Index into the array pointed to by the stored pointer.</source>
          <target state="translated">저장된 포인터가 가리키는 배열로 색인합니다.</target>
        </trans-unit>
        <trans-unit id="9d3b08115f1b71f8141facbb6d5edfd271773b19" translate="yes" xml:space="preserve">
          <source>Indicated by a trailing &lt;code&gt;...&lt;/code&gt;(other than one introducing a pack expansion)(since C++11) following the parameter-list of a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;.</source>
          <target state="translated">트레일로 나타낸 &lt;code&gt;...&lt;/code&gt; (A)의 파라미터리스트하기 (11 ++ C 보낸) (팩 확장 도입 이외) &lt;a href=&quot;function&quot;&gt;함수 선언&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d49ada4a4f9e6394d6c031cdd3db87968627070f" translate="yes" xml:space="preserve">
          <source>Indicated by using the following syntax for a parameter in the parameter-list of a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt;함수 선언&lt;/a&gt; 의 매개 변수 목록에서 매개 변수에 다음 구문을 사용하여 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="1712d2e8f937518e01b0931bd205206ed1a8017a" translate="yes" xml:space="preserve">
          <source>Indicates if the match results are ready (valid) or not.</source>
          <target state="translated">일치 결과가 준비되었는지 (유효한지) 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="05d56af25aa45704ec160c601a10df5e1c115f08" translate="yes" xml:space="preserve">
          <source>Indicates if this match was successful</source>
          <target state="translated">이 일치가 성공했는지 나타냅니다</target>
        </trans-unit>
        <trans-unit id="fb13d85a03c61cb1a77aee405db444e1e7dd0d1e" translate="yes" xml:space="preserve">
          <source>Indicates that dependency chain in release-consume &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; propagates in and out of the function, which allows the compiler to skip unnecessary memory fence instructions.</source>
          <target state="translated">release-consume &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; 종속성 체인 이 함수 안팎으로 전파되어 컴파일러가 불필요한 메모리 차단 명령어를 건너 뛸 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b1eef975978a88d290550921db3dd4b23de6ed3c" translate="yes" xml:space="preserve">
          <source>Indicates that the fall through from the previous case label is intentional and should not be diagnosed by a compiler that warns on fallthrough.</source>
          <target state="translated">이전 사례 라벨에서 제외 된 것은 의도적 인 것이며, 넘어짐에 대해 경고하는 컴파일러에 의해 진단되어서는 안됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="07a894f6f65f599ff826de67eb639e25aa960be1" translate="yes" xml:space="preserve">
          <source>Indicates that the function definition should be optimized for invocation from a &lt;a href=&quot;../transactional_memory&quot;&gt;synchronized statement&lt;/a&gt;.</source>
          <target state="translated">함수 정의가 &lt;a href=&quot;../transactional_memory&quot;&gt;동기화 된 명령문&lt;/a&gt; 에서 호출하도록 최적화되어야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="404bc23b0c3c1dc2dde1e96665adb2a133cb2f1a" translate="yes" xml:space="preserve">
          <source>Indicates that the function definition should be optimized for invocation from a &lt;a href=&quot;../transactional_memory&quot;&gt;synchronized statement&lt;/a&gt;. In particular, it avoids serializing synchronized blocks that make a call to a function that is transaction-safe for the majority of calls, but not for all calls.</source>
          <target state="translated">함수 정의가 &lt;a href=&quot;../transactional_memory&quot;&gt;동기화 된 명령문&lt;/a&gt; 에서 호출하도록 최적화되어야 함을 나타냅니다 . 특히, 대부분의 통화에 대해 트랜잭션에 안전한 기능을 호출하지만 모든 통화에 대해 호출되는 기능을 호출하지 않는 동기화 된 블록을 직렬화하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="3763a0ac1424ab7603605b2e6e73c73516778f16" translate="yes" xml:space="preserve">
          <source>Indicates that the function does not return.</source>
          <target state="translated">함수가 반환되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aadf5ff318f6e9ff51544f26ee3de70c127e4ff5" translate="yes" xml:space="preserve">
          <source>Indicates that the name or entity declared with this attribute is &lt;a href=&quot;https://en.wikipedia.org/wiki/Deprecation&quot;&gt;deprecated&lt;/a&gt;, that is, the use is allowed, but discouraged for some reason.</source>
          <target state="translated">이 속성으로 선언 된 이름 또는 엔티티는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Deprecation&quot;&gt;더 이상 사용되지 않습니다&lt;/a&gt; . 즉, 사용이 허용되지만 어떤 이유로 사용 하지 않는 것을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="eb1d4e9c5ff0d33dedb5c76e1e3e0a72c774ec1e" translate="yes" xml:space="preserve">
          <source>Indicates that the use of the name or entity declared with this attribute is allowed, but discouraged for some reason. Compilers typically issue warnings on such uses. The string-literal, if specified, is usually included in the warnings.</source>
          <target state="translated">이 속성으로 선언 된 이름 또는 엔티티를 사용할 수 있지만 어떤 이유로 권장하지 않음을 나타냅니다. 컴파일러는 일반적으로 이러한 용도로 경고를 발행합니다. 문자열 리터럴 (지정된 경우)은 일반적으로 경고에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1b877dccdb68430deec81ae5c7d0c2899c1a04b6" translate="yes" xml:space="preserve">
          <source>Indicates that this data member need not have an address distinct from all other non-static data members of its class.</source>
          <target state="translated">이 데이터 멤버가 해당 클래스의 다른 모든 비 정적 데이터 멤버와 다른 주소를 가질 필요는 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6a97cea227e92a547c1dd0162d3c17f7d0180b0c" translate="yes" xml:space="preserve">
          <source>Indicates that this data member need not have an address distinct from all other non-static data members of its class. This means that if the member has an empty type (e.g. stateless Allocator), the compiler may optimise it to occupy no space, just like if it were an &lt;a href=&quot;../ebo&quot;&gt;empty base&lt;/a&gt;. If the member is not empty, any tail padding in it may be also reused to store other data members.</source>
          <target state="translated">이 데이터 멤버가 해당 클래스의 다른 모든 비 정적 데이터 멤버와 다른 주소를 가질 필요는 없음을 나타냅니다. 즉, 멤버에 빈 유형 (예 : Stateless Allocator)이 있으면 컴파일러는 &lt;a href=&quot;../ebo&quot;&gt;빈베이스 인&lt;/a&gt; 것처럼 공간을 차지하지 않도록 최적화 할 수 있습니다 . 멤버가 비어 있지 않으면 다른 데이터 멤버를 저장하기 위해 테일 패딩을 재사용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e16e5df080d66d35fd0fc9ce14ca2cddaaf531e" translate="yes" xml:space="preserve">
          <source>Indicates the endianness of all &lt;a href=&quot;../language/type-id&quot;&gt;scalar types&lt;/a&gt;:</source>
          <target state="translated">모든 &lt;a href=&quot;../language/type-id&quot;&gt;스칼라 유형&lt;/a&gt; 의 엔디안을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b7ced8b89669e17290208433d069c305c4668cd4" translate="yes" xml:space="preserve">
          <source>Indirect access</source>
          <target state="translated">간접 액세스</target>
        </trans-unit>
        <trans-unit id="945f4467f9e3980b9bc435c192be55e1cdba33ac" translate="yes" xml:space="preserve">
          <source>Indirect callable concepts</source>
          <target state="translated">간접 호출 가능 개념</target>
        </trans-unit>
        <trans-unit id="615d0df84a8bde5c3b3b45942556ad9ee41f5c88" translate="yes" xml:space="preserve">
          <source>IndirectRelation</source>
          <target state="translated">IndirectRelation</target>
        </trans-unit>
        <trans-unit id="a517704fa906449a7f15a8ece89573834bd716d4" translate="yes" xml:space="preserve">
          <source>IndirectStrictWeakOrder</source>
          <target state="translated">IndirectStrictWeakOrder</target>
        </trans-unit>
        <trans-unit id="4fd88b3054ecad93f1a95a527c3891631b31f23d" translate="yes" xml:space="preserve">
          <source>IndirectUnaryInvocableIndirectRegularUnaryInvocable</source>
          <target state="translated">IndirectUnaryInvocableIndirectRegularUnaryInvocable</target>
        </trans-unit>
        <trans-unit id="d4d035f7c30e113629f27edd40bf70e82d6284b2" translate="yes" xml:space="preserve">
          <source>IndirectUnaryPredicate</source>
          <target state="translated">IndirectUnaryPredicate</target>
        </trans-unit>
        <trans-unit id="1ba4d5bf8c849bf8c04b9c6e21cc8e1df44157c8" translate="yes" xml:space="preserve">
          <source>Indirection through a pointer that became invalid in this manner and passing it to a deallocation function (double-delete) is undefined behavior. Any other use is implementation-defined.</source>
          <target state="translated">이런 방식으로 유효하지 않은 포인터를 통한 간접 할당 및 할당 해제 기능 (이중 삭제)에 전달하는 것은 정의되지 않은 동작입니다. 다른 용도는 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="fc6c8e1f0dc3858c691ccb1300793e524ab1874b" translate="yes" xml:space="preserve">
          <source>Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have undefined behavior. Any other use of an invalid pointer value has implementation-defined behavior.</source>
          <target state="translated">유효하지 않은 포인터 값을 통한 간접 처리 및 유효하지 않은 포인터 값을 할당 해제 함수에 전달하면 동작이 정의되지 않습니다. 유효하지 않은 포인터 값을 사용하면 구현 정의 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="caa250f6b40fd31e6e435ad3ec42b55df8c15198" translate="yes" xml:space="preserve">
          <source>IndirectlyComparable</source>
          <target state="translated">IndirectlyComparable</target>
        </trans-unit>
        <trans-unit id="79246d49d2de7bde0e84161dfa390e35ead80dbb" translate="yes" xml:space="preserve">
          <source>IndirectlyCopyable</source>
          <target state="translated">IndirectlyCopyable</target>
        </trans-unit>
        <trans-unit id="c1b4de1846b6ae50bbf1bb567d1c5423353b3f7c" translate="yes" xml:space="preserve">
          <source>IndirectlyCopyableStorable</source>
          <target state="translated">IndirectlyCopyableStorable</target>
        </trans-unit>
        <trans-unit id="4f10a919177009406f024b0a5f8b598cade73a1d" translate="yes" xml:space="preserve">
          <source>IndirectlyMovable</source>
          <target state="translated">IndirectlyMovable</target>
        </trans-unit>
        <trans-unit id="be4b7238e8cf0d8749bb2f509a225195d878018a" translate="yes" xml:space="preserve">
          <source>IndirectlyMovableStorable</source>
          <target state="translated">IndirectlyMovableStorable</target>
        </trans-unit>
        <trans-unit id="1fb085c0bd571e7f0dafcbf700d51d838a32da50" translate="yes" xml:space="preserve">
          <source>IndirectlySwappable</source>
          <target state="translated">IndirectlySwappable</target>
        </trans-unit>
        <trans-unit id="b5f6e97cd4faf7045970097d59a8c5be90de03ff" translate="yes" xml:space="preserve">
          <source>Inexact result</source>
          <target state="translated">부정확 한 결과</target>
        </trans-unit>
        <trans-unit id="98df9b88a5e801dd458f9dea0b5eb524b074282a" translate="yes" xml:space="preserve">
          <source>Infinite loop without side-effects</source>
          <target state="translated">부작용없는 무한 루프</target>
        </trans-unit>
        <trans-unit id="8f1b65e86ba58e7d09ad5b638567441248d44fd1" translate="yes" xml:space="preserve">
          <source>Informally &quot;A is more specialized than B&quot; means &quot;A accepts a subset of the types that B accepts&quot;.</source>
          <target state="translated">비공식적으로 &quot;A가 B보다 더 전문화 됨&quot;은 &quot;A가 B가 수용하는 유형의 서브 세트를 승인 함&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8e26416412a250dc41f16163d325bfe0d9375649" translate="yes" xml:space="preserve">
          <source>Informally &quot;A is more specialized than B&quot; means &quot;A accepts fewer types than B&quot;.</source>
          <target state="translated">비공식적으로 &quot;A가 B보다 더 전문화 됨&quot;은 &quot;A가 B보다 적은 유형을 받아들입니다&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="837818b163877df19b00b59309303eba5812d227" translate="yes" xml:space="preserve">
          <source>Informally, an object is odr-used if its value is read (unless it is a compile time constant) or written, its address is taken, or a reference is bound to it; a reference is odr-used if it is used and its referent is not known at compile time; and a function is odr-used if a function call to it is made or its address is taken. If an object, a reference or a function is odr-used, its definition must exist somewhere in the program; a violation of that is usually a link-time error.</source>
          <target state="translated">비공식적으로, 객체가 값을 읽거나 (컴파일 시간 상수가 아닌 한) 기록되면, 주소가 취해 지거나 참조가 바인드됩니다. 참조가 사용되고 참조가 컴파일 타임에 알려지지 않은 경우 참조는 odr-used입니다. 함수를 호출하거나 주소를 가져 오면 함수가 사용됩니다. 객체, 참조 또는 함수를 사용하는 경우 해당 정의는 프로그램 어딘가에 존재해야합니다. 이를 위반하면 대개 링크 타임 오류입니다.</target>
        </trans-unit>
        <trans-unit id="c6ae6b7147966f4caadf3becb3a298c96ec40912" translate="yes" xml:space="preserve">
          <source>Informally, two types are</source>
          <target state="translated">비공식적으로 두 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="37bbacc3d1827431eb0e90015863e8cd1f6d09b3" translate="yes" xml:space="preserve">
          <source>Informs the compiler that the dependency tree started by an &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; atomic load operation does not extend past the return value of &lt;code&gt;std::kill_dependency&lt;/code&gt;; that is, the argument does not carry a dependency into the return value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; 원자로드 조작으로 시작된 종속성 트리 가 &lt;code&gt;std::kill_dependency&lt;/code&gt; 의 리턴 값을 초과 하여 확장되지 않음을 컴파일러에 알립니다 . 즉, 인수는 리턴 값에 종속성을 갖지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9f0d94767eeb4fdf66bcb63f83f831a24817f3f" translate="yes" xml:space="preserve">
          <source>Informs the garbage collector or leak detector that the specified memory region (&lt;code&gt;n&lt;/code&gt; bytes beginning at the byte pointed to by &lt;code&gt;p&lt;/code&gt;) contains no traceable pointers. If any part of the region is within an allocated object, the entire region must be contained in the same object.</source>
          <target state="translated">지정된 메모리 영역 ( &lt;code&gt;p&lt;/code&gt; 가 가리키는 바이트에서 시작하는 &lt;code&gt;n&lt;/code&gt; 바이트 )에 추적 가능한 포인터가 없음을 가비지 수집기 또는 누출 감지기에 알립니다 . 영역의 일부가 할당 된 개체 내에 있으면 전체 영역이 동일한 개체에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b00d875f974811886ac196dcb915203f177f6a1" translate="yes" xml:space="preserve">
          <source>Informs the implementation that the object &lt;code&gt;ptr&lt;/code&gt; points to is aligned to at least &lt;code&gt;N&lt;/code&gt;. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of &lt;code&gt;assume_aligned&lt;/code&gt;.</source>
          <target state="translated">오브젝트 &lt;code&gt;ptr&lt;/code&gt; 이 가리키는 &lt;code&gt;N&lt;/code&gt; 이 최소한 의 구현을 통지합니다 . 구현 &lt;code&gt;assume_aligned&lt;/code&gt; 정보를 사용하여보다 효율적인 코드를 생성 할 수 있지만 객체가 assume_aligned 의 반환 값을 통해 액세스하는 경우에만이 가정을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="24e63953e4f041a3bb4ac3148f230860861e7ff3" translate="yes" xml:space="preserve">
          <source>Inheritance diagram.</source>
          <target state="translated">상속 다이어그램.</target>
        </trans-unit>
        <trans-unit id="43a9b1d67674ea8718fc711a00f7bb00fbb4c4df" translate="yes" xml:space="preserve">
          <source>Inherited copy and move constructors are not included in the list of candidate functions when constructing a derived class object.</source>
          <target state="translated">상속 된 복사 및 이동 생성자는 파생 클래스 개체를 생성 할 때 후보 함수 목록에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f06971d5187bb5c21be32f180285afdb914b12b" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../../types/integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; 에서 상 속됨</target>
        </trans-unit>
        <trans-unit id="f30304d5307d8a19e13fb3ed0a2bac9d82e0a424" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../error/exception&quot;&gt;std :: exception&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="01fe97cbbb0941b6f2a72d6bcbf5bf30c49dc7b1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="179a5175974c4d0f1231cb42168b0c03c785293b" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/system_error&quot;&gt; std::system_error&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../error/system_error&quot;&gt;std :: system_error&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="7a80e3d34750b628e39956fcaf30d5d8a1ed24f4" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../types/integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; 에서 상 속됨</target>
        </trans-unit>
        <trans-unit id="dc3357171bb4abff2c5bcfa928f18def082a907c" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../error/exception&quot;&gt;std :: exception&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="30b72f9cdb58e5970783c671d3934c33faeb1623" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/logic_error/logic_error&quot;&gt; std::logic_error&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../error/logic_error/logic_error&quot;&gt;std :: logic_error&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="957863018da5b123ab6f6ee5e33f1ffffd93019e" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../error/runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="4810ddaa7ee3800c8518272cbd3eab0a576e08e1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/system_error&quot;&gt; std::system_error&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../error/system_error&quot;&gt;std :: system_error&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="8f42576c785a3be8154970999da87190cb9371f9" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../exception&quot;&gt;std :: exception&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="1ff5d17ac32734b6c4b40b6f4b8d2dbbce7f1b33" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../types/integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; 에서 상 속됨</target>
        </trans-unit>
        <trans-unit id="64a89d3879a72da7c6ee665cb1868939227a129a" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../utility/pair&quot;&gt; std::pair&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../utility/pair&quot;&gt;std :: pair&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="ad227e6a5a2991b9ae2118d21b1ded53643ffeb6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;bad_alloc&quot;&gt; std::bad_alloc&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;bad_alloc&quot;&gt;std :: bad_alloc&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="0640747e62ff14ba1b29b108a996ca8f524d1b5a" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_ios&quot;&gt; std::basic_ios&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;basic_ios&quot;&gt;std :: basic_ios&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="de0c89b89174954a9f92de2b010f4eba6cf65be6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_istream&quot;&gt; std::basic_istream&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;basic_istream&quot;&gt;std :: basic_istream&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="5294336a5cb08c884f1c1c77c83e45be59fa6ba0" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_ostream&quot;&gt; std::basic_ostream&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;basic_ostream&quot;&gt;std :: basic_ostream&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="9055f46788224b7f31bcf6f24250ff5d47695175" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_streambuf&quot;&gt; std::basic_streambuf&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;basic_streambuf&quot;&gt;std :: basic_streambuf&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="538de0fbed9b76df7a6ab5144cdd294244e05923" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;codecvt&quot;&gt; std::codecvt&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;codecvt&quot;&gt;std :: codecvt&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="691ededb623378951567ffd0bfa980099fbe3761" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;codecvt_base&quot;&gt; std::codecvt_base&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;codecvt_base&quot;&gt;std :: codecvt_base&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="55051117752349a92484d2d68e1536f7ba751ac6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;collate&quot;&gt; std::collate&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;collate&quot;&gt;std :: collate&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="646bf27bfd425c0266f785460d8846b085490446" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;exception&quot;&gt;std :: exception&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="2b1e16a440f913fb0c212304822e1171df74e082" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt; 에서 상 속됨</target>
        </trans-unit>
        <trans-unit id="3d307388b240b50355fd55953eea3dcf640dd433" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;ios_base&quot;&gt; std::ios_base&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ios_base&quot;&gt;std :: ios_base&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="e507c076782fb8eb8b54d375f2f956f7369f545d" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;messages&quot;&gt; std::messages&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;messages&quot;&gt;std :: messages&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="f67af012ab32d51632e38d03380caedc6cb1fd11" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;money_base&quot;&gt;std::money_base&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;money_base&quot;&gt;std :: money_base&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="88842694e8b959006d435b6cad10e7a20f4f86fe" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;moneypunct&quot;&gt; std::moneypunct&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;moneypunct&quot;&gt;std :: moneypunct&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="4d17a29ada80f7d12d7692d7e6aaa8521d515613" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;numpunct&quot;&gt; std::numpunct&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpunct&quot;&gt;std :: numpunct&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="96f6c2f33d9e5a486e8905be371715ec2d5e0e4c" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="7efc4c44fcbc8224af5b604f6ea179f896007df5" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;time_get&quot;&gt; std::time_get&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;time_get&quot;&gt;std :: time_get&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="6fda6ad022c33ce0f5b1400e8f343ad50076eeb0" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;time_put&quot;&gt; std::time_put&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;time_put&quot;&gt;std :: time_put&lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="e7135edcc0660dff5ef07a7531f5a314d1a14345" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype&amp;lt;CharT&amp;gt;</source>
          <target state="translated">std :: ctype &amp;lt;CharT&amp;gt;에서 상 속됨</target>
        </trans-unit>
        <trans-unit id="96606dedfe0d1180adfbb7cf5dc6b000d690eeaa" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype&amp;lt;char&amp;gt;</source>
          <target state="translated">std :: ctype &amp;lt;char&amp;gt;에서 상 속됨</target>
        </trans-unit>
        <trans-unit id="6835bd4de94e4c8ff9fa81f21f0a45e937163c89" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype_base</source>
          <target state="translated">std :: ctype_base에서 상속</target>
        </trans-unit>
        <trans-unit id="2a9684185e4ab4b7acc08548b265978c0ac9b665" translate="yes" xml:space="preserve">
          <source>Inherited from std::messages_base</source>
          <target state="translated">std :: messages_base에서 상속</target>
        </trans-unit>
        <trans-unit id="ec11a5942722961cf6c8bf90cef0c0ab7cbfd804" translate="yes" xml:space="preserve">
          <source>Inherited from std::time_base</source>
          <target state="translated">std :: time_base에서 상속</target>
        </trans-unit>
        <trans-unit id="a162155e80acef2e40d64da7fae4b6cef737ccc3" translate="yes" xml:space="preserve">
          <source>Inheriting constructors</source>
          <target state="translated">상속 생성자</target>
        </trans-unit>
        <trans-unit id="ed212d227256484af63b60ae12f72487723786d7" translate="yes" xml:space="preserve">
          <source>Inheriting from empty base classes usually does not increase the size of a class due to &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;.</source>
          <target state="translated">빈 기본 클래스에서 상속해도 &lt;a href=&quot;../language/ebo&quot;&gt;빈 기본 최적화&lt;/a&gt; 로 인해 클래스 크기가 증가하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="f6e1e46e4baf5716e3220f3484c1af85b95e71c8" translate="yes" xml:space="preserve">
          <source>Initialization by constructor</source>
          <target state="translated">생성자 별 초기화</target>
        </trans-unit>
        <trans-unit id="d0105ebd75116f796a8152546a960d90f6068ea4" translate="yes" xml:space="preserve">
          <source>Initialization of &lt;a href=&quot;../language/storage_duration#Static_local_variables&quot;&gt;function-local statics&lt;/a&gt; is guaranteed to occur only once even when called from multiple threads, and may be more efficient than the equivalent code using &lt;code&gt;std::call_once&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../language/storage_duration#Static_local_variables&quot;&gt;함수 로컬 스태틱의&lt;/a&gt; 초기화는 여러 스레드에서 호출 된 경우에도 한 번만 발생하며 &lt;code&gt;std::call_once&lt;/code&gt; 사용하는 동등한 코드보다 효율적일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d91f501eae2c832f1b0b7e4d4973d0855f66060e" translate="yes" xml:space="preserve">
          <source>Initialization order</source>
          <target state="translated">초기화 순서</target>
        </trans-unit>
        <trans-unit id="49fb3cd233b01d2f3fca6d231ff8868b279e8d64" translate="yes" xml:space="preserve">
          <source>Initialization to all bits zero does not guarantee that a floating-point or a pointer would be initialized to 0.0 and the null pointer value, respectively (although that is true on all common platforms).</source>
          <target state="translated">모든 비트를 0으로 초기화한다고해서 부동 소수점 또는 포인터가 각각 0.0과 널 포인터 값으로 초기화되는 것은 아닙니다 (모든 공통 플랫폼에서 적용됨).</target>
        </trans-unit>
        <trans-unit id="6ea9d5c7645589c136d59cd57df44af49ce9783f" translate="yes" xml:space="preserve">
          <source>Initialization with a &lt;a href=&quot;../../language/string_literal&quot;&gt;string literal&lt;/a&gt; that contains embedded &lt;code&gt;'\0'&lt;/code&gt; characters uses the overload (5), which stops at the first null character. This can be avoided by specifying a different constructor or by using &lt;a href=&quot;operator_q__q_s&quot;&gt;&lt;code&gt;operator&quot;&quot;s&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">포함 된 &lt;code&gt;'\0'&lt;/code&gt; 문자 가 포함 된 &lt;a href=&quot;../../language/string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; 을 사용하여 초기화 하면 첫 번째 null 문자에서 중지되는 오버로드 (5)가 사용됩니다. 다른 생성자를 지정하거나 &lt;a href=&quot;operator_q__q_s&quot;&gt; &lt;code&gt;operator&quot;&quot;s&lt;/code&gt; &lt;/a&gt; 사용하면이를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8b6090f523a6604aaf83ad226d272f3e664763f" translate="yes" xml:space="preserve">
          <source>Initializer lists</source>
          <target state="translated">이니셜 라이저 목록</target>
        </trans-unit>
        <trans-unit id="5205b0ca0f0fefcfe68c33103c2c9c1ce338c249" translate="yes" xml:space="preserve">
          <source>Initializer lists may be implemented as a pair of pointers or pointer and length. Copying a &lt;code&gt;std::initializer_list&lt;/code&gt; does not copy the underlying objects.</source>
          <target state="translated">이니셜 라이저 목록은 한 쌍의 포인터 또는 포인터와 길이로 구현 될 수 있습니다. 카피 &lt;code&gt;std::initializer_list&lt;/code&gt; 기본 개체를 복사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4cd615dbf08a4b7ea3976db14aee644d6937efce" translate="yes" xml:space="preserve">
          <source>Initializes an aggregate from braced-init-list.</source>
          <target state="translated">braced-init-list에서 집계를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="44dcbda2c857e660e975019d6dd123883526dd75" translate="yes" xml:space="preserve">
          <source>Initializes an object from another object.</source>
          <target state="translated">다른 객체에서 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0d3ed04db9734c04b00626e83cd3a554c91216b4" translate="yes" xml:space="preserve">
          <source>Initializes an object from braced-init-list.</source>
          <target state="translated">braced-init-list에서 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="b28ee811ef30d6e7a7f950db96ff44c9ab341ca0" translate="yes" xml:space="preserve">
          <source>Initializes an object from explicit set of constructor arguments.</source>
          <target state="translated">명시적인 생성자 인수 집합에서 개체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="3612fbe04b3d4f902d2d49989872e1c625ef8e37" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;bound_&lt;/code&gt; with &lt;code&gt;bound&lt;/code&gt;.</source>
          <target state="translated">박람회 전용 데이터 멤버 &lt;code&gt;bound_&lt;/code&gt; 를 &lt;code&gt;bound&lt;/code&gt; 로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="e582f41fbe9142faa1edac6dc025f737e0f1efef" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;current_&lt;/code&gt; with &lt;code&gt;current&lt;/code&gt; and exposition-only data members &lt;code&gt;parent_&lt;/code&gt; with &lt;code&gt;addressof(parent)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;addressof(parent)&lt;/code&gt; 하여 &lt;code&gt;current&lt;/code&gt; 및 박람회 전용 데이터 멤버 &lt;code&gt;parent_&lt;/code&gt; 로 노출 전용 데이터 멤버 &lt;code&gt;current_&lt;/code&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="687eeb5c76107cbf76d277e107912b3a093ddbf0" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;end_&lt;/code&gt; with &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="translated">박람회 전용 데이터 멤버 &lt;code&gt;end_&lt;/code&gt; 를 &lt;code&gt;parent&lt;/code&gt; 로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="45a2d2edd8a0c33265b1f7964c619dbe931e75f5" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;value_&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. This value will be returned by operator* and incremented by operator++</source>
          <target state="translated">&lt;code&gt;value_&lt;/code&gt; 하여 박람회 전용 데이터 멤버 value_ 를 초기화 &lt;code&gt;value&lt;/code&gt; . 이 값은 operator *에 의해 반환되고 operator ++에 의해 증가합니다.</target>
        </trans-unit>
        <trans-unit id="3ed19383d0a866bf81dc2a8bf40d1563412b85cf" translate="yes" xml:space="preserve">
          <source>Initializes the</source>
          <target state="translated">초기화</target>
        </trans-unit>
        <trans-unit id="a8d332dbed9d2af60e29bd52e5cde6a80c7ad53b" translate="yes" xml:space="preserve">
          <source>Initializes the default-constructed atomic object &lt;code&gt;obj&lt;/code&gt; with the value &lt;code&gt;desired&lt;/code&gt;. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race.</source>
          <target state="translated">기본 구성된 원자 객체 &lt;code&gt;obj&lt;/code&gt; 를 &lt;code&gt;desired&lt;/code&gt; 값 으로 초기화합니다 . 이 기능은 원 자성이 아닙니다. 원자 연산을 통해 다른 스레드에서 동시 액세스하는 것은 데이터 경쟁입니다.</target>
        </trans-unit>
        <trans-unit id="e49e9f39572d1033a19aeb243a49b9e378d309f2" translate="yes" xml:space="preserve">
          <source>Initializes the internal instance of the comparator to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">비교기의 내부 인스턴스를 &lt;code&gt;c&lt;/code&gt; 로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="a51259c3c84f8a09271df7eb1d4694a4b3224cee" translate="yes" xml:space="preserve">
          <source>Initializes the iterator to point to the same value as &lt;code&gt;it&lt;/code&gt; points.</source>
          <target state="translated">같은 값을 차례로 반복자 초기화 &lt;code&gt;it&lt;/code&gt; 포인트.</target>
        </trans-unit>
        <trans-unit id="398735e9fedddd7f0aacad1eb358f7b46a4ac840" translate="yes" xml:space="preserve">
          <source>Injected class name</source>
          <target state="translated">주입 된 클래스 이름</target>
        </trans-unit>
        <trans-unit id="7bb9ce0cdba5a821d492b917cf5fb720a0f90bd9" translate="yes" xml:space="preserve">
          <source>Inline assembly</source>
          <target state="translated">인라인 어셈블리</target>
        </trans-unit>
        <trans-unit id="4f9c73f65355a3ed7fedd216f2992cf3deebb61c" translate="yes" xml:space="preserve">
          <source>Inline assembly for Itanium-based HP-UX</source>
          <target state="translated">Itanium 기반 HP-UX 용 인라인 어셈블리</target>
        </trans-unit>
        <trans-unit id="e51e51dc5c1aa8a193565e7fce22f1c142ed7d5c" translate="yes" xml:space="preserve">
          <source>Inline const variables at namespace scope have &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt; by default (unlike the non-inline non-volatile const-qualified variables).</source>
          <target state="translated">네임 스페이스 범위의 인라인 const 변수는 기본적으로 &lt;a href=&quot;storage_duration&quot;&gt;외부&lt;/a&gt; 인라인 비 휘발성 const 한정 변수와 달리 외부 연결 을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="49bfb486d3b3c3cb304f4493385555eb5b8a098a" translate="yes" xml:space="preserve">
          <source>Inline namespaces</source>
          <target state="translated">인라인 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="00b64c52a93228b3beba41ea40e5bd41acc77e53" translate="yes" xml:space="preserve">
          <source>Inline variables</source>
          <target state="translated">인라인 변수</target>
        </trans-unit>
        <trans-unit id="7be4e5da3a5437427b26df1ed281ec5d61782f49" translate="yes" xml:space="preserve">
          <source>Inline variables eliminate the main obstacle to packaging C++ code as header-only libraries.</source>
          <target state="translated">인라인 변수는 C ++ 코드를 헤더 전용 라이브러리로 패키징하는 데있어 주요 장애물을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="c05e081250483115acb3291c729e966cb6237c5d" translate="yes" xml:space="preserve">
          <source>Input/Output</source>
          <target state="translated">Input/Output</target>
        </trans-unit>
        <trans-unit id="249f397392db7fe682a1d1ecc1a52c8e40ceb983" translate="yes" xml:space="preserve">
          <source>Input/output</source>
          <target state="translated">Input/output</target>
        </trans-unit>
        <trans-unit id="cb5679ee6b70828884e48e829adaa69eeff5975a" translate="yes" xml:space="preserve">
          <source>Input/output library</source>
          <target state="translated">입 / 출력 라이브러리</target>
        </trans-unit>
        <trans-unit id="23a1c2b90e7720bee1275126fc61ab157f7fb4f4" translate="yes" xml:space="preserve">
          <source>Input/output manipulators</source>
          <target state="translated">입 / 출력 조작기</target>
        </trans-unit>
        <trans-unit id="2dd11dbfca0e0084817673f0057830adc2def0af" translate="yes" xml:space="preserve">
          <source>InputIterator</source>
          <target state="translated">InputIterator</target>
        </trans-unit>
        <trans-unit id="5ce3b480664c159e1d12685b429698048d6ea3d0" translate="yes" xml:space="preserve">
          <source>InputRange</source>
          <target state="translated">InputRange</target>
        </trans-unit>
        <trans-unit id="2626e21603d8fe73a7e6ad428ec1925d9f5ce790" translate="yes" xml:space="preserve">
          <source>Insert an object of type &lt;code&gt;T&lt;/code&gt;, constructed with &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 앞에 &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)&lt;/code&gt; &amp;lt;Args&amp;gt; (args)로 구성된 &lt;code&gt;T&lt;/code&gt; 유형의 객체를 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="bd0f39cfbd64e0b854da8b25dafdd19e3e5f4946" translate="yes" xml:space="preserve">
          <source>Insertion caused rehash</source>
          <target state="translated">삽입으로 인한 해시</target>
        </trans-unit>
        <trans-unit id="dd68ac29c94054b522d28e6c6323109f3d58ed57" translate="yes" xml:space="preserve">
          <source>Insertion changed capacity</source>
          <target state="translated">삽입 용량 변경</target>
        </trans-unit>
        <trans-unit id="90792df8b1ed4fcb7ea818e84aee0085187c66dc" translate="yes" xml:space="preserve">
          <source>Insertion or removal of elements - linear O(n)</source>
          <target state="translated">요소 삽입 또는 제거-선형 O (n)</target>
        </trans-unit>
        <trans-unit id="8dd87d390aed8473e28b99fc188dddac51d8f873" translate="yes" xml:space="preserve">
          <source>Insertion or removal of elements - linear in the distance to the end of the vector O(n)</source>
          <target state="translated">요소 삽입 또는 제거-벡터 끝까지의 거리에서 선형 O (n)</target>
        </trans-unit>
        <trans-unit id="a9f7998ac9050fd1635baf4429d529d9a7bb0521" translate="yes" xml:space="preserve">
          <source>Insertion or removal of elements at the end - amortized constant O(1)</source>
          <target state="translated">끝 부분의 요소 삽입 또는 제거-상각 상수 O (1)</target>
        </trans-unit>
        <trans-unit id="89dc0ff756b3d85bb1be7c9942ebc7011ccf494e" translate="yes" xml:space="preserve">
          <source>Insertion or removal of elements at the end or beginning - constant O(1)</source>
          <target state="translated">끝 또는 시작에서 요소 삽입 또는 제거-상수 O (1)</target>
        </trans-unit>
        <trans-unit id="40dbe6b4bec47b9cf461b0137ff76c424defca97" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;n&lt;/code&gt; copies of &lt;code&gt;t&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 앞에 &lt;code&gt;n&lt;/code&gt; 의 &lt;code&gt;t&lt;/code&gt; 를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="c32005ed652dab6de9fb37a37722957c3e2724e8" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the associated stream, then inserts the delimiter, if one was specified at construction time.</source>
          <target state="translated">삽입 &lt;code&gt;value&lt;/code&gt; 하나가 건설 시간에 지정된 경우 관련 스트림에 후, 구분 기호를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="459fe20a1ffd7a6cd82618f9958505d8f6d74257" translate="yes" xml:space="preserve">
          <source>Inserts a character or a character string.</source>
          <target state="translated">문자 또는 문자열을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="1292e82dd313319fd90a6127a6a0b0fa41ee3b4b" translate="yes" xml:space="preserve">
          <source>Inserts a copy of &lt;code&gt;rv&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;, possibly using move semantics</source>
          <target state="translated">이동 시맨틱을 사용하여 &lt;code&gt;p&lt;/code&gt; 앞에 &lt;code&gt;rv&lt;/code&gt; 사본을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="080a7d3105b387ca72b759dd0ac8cbe8daf7bece" translate="yes" xml:space="preserve">
          <source>Inserts a copy of &lt;code&gt;t&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 앞에 &lt;code&gt;t&lt;/code&gt; 의 사본을 삽입합니다</target>
        </trans-unit>
        <trans-unit id="dddeb94b4972c7384daa43582f102c411ce2464e" translate="yes" xml:space="preserve">
          <source>Inserts a new element into a position after the specified position in the container. The element is constructed in-place, i.e. no copy or move operations are performed. The constructor of the element is called with exactly the same arguments, as supplied to the function.</source>
          <target state="translated">컨테이너에서 지정된 위치 뒤의 위치에 새 요소를 삽입합니다. 요소가 제자리에 구성되어 있습니다. 즉, 복사 또는 이동 작업이 수행되지 않습니다. 요소의 생성자는 함수에 제공된 것과 정확히 동일한 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ca770757036e4fe2be6c21dfdc40521b78bb495b" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the container as close as possible to the position just before &lt;code&gt;hint&lt;/code&gt;. The element is constructed in-place, i.e. no copy or move operations are performed.</source>
          <target state="translated">&lt;code&gt;hint&lt;/code&gt; 직전의 위치에 가능한 한 가까운 곳에 새로운 요소를 컨테이너에 삽입합니다 . 요소가 제자리에 구성되어 있습니다. 즉, 복사 또는 이동 작업이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c894839e77e9ab81555b68a4eab970743f5cf11" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the container constructed in-place with the given &lt;code&gt;args&lt;/code&gt; .</source>
          <target state="translated">주어진 &lt;code&gt;args&lt;/code&gt; 대신 제자리에 구성된 컨테이너에 새 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="2ebf2c045edb5580cda64f0fcb67ffe1f644265e" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the container constructed in-place with the given &lt;code&gt;args&lt;/code&gt; if there is no element with the key in the container.</source>
          <target state="translated">컨테이너 에 키가있는 요소가없는 경우 지정된 &lt;code&gt;args&lt;/code&gt; 로 제자리에 구성된 컨테이너에 새 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="764a3843820016f0a301fc81d7090ba832667367" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the container directly before &lt;code&gt;pos&lt;/code&gt;. The element is constructed through &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt;, which typically uses placement-new to construct the element in-place at a location provided by the container. The arguments &lt;code&gt;args...&lt;/code&gt; are forwarded to the constructor as &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 직전에 컨테이너에 새 요소를 삽입합니다 . 요소는 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt; construct를 통해 구성 되며, 일반적으로 배치 새 항목을 사용하여 컨테이너가 제공하는 위치에 요소를 제 위치에 구성합니다. 인수 &lt;code&gt;args...&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 로 생성자에게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cf81cb318be0807a9f9dfa69a27e14ef4b04921" translate="yes" xml:space="preserve">
          <source>Inserts a new element to the beginning of the container. The element is constructed through &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt;, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments &lt;code&gt;args...&lt;/code&gt; are forwarded to the constructor as &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">컨테이너의 시작 부분에 새 요소를 삽입합니다. 요소는 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt; construct를 통해 구성 되며, 일반적으로 배치 새 항목을 사용하여 컨테이너가 제공하는 위치에 요소를 제 위치에 구성합니다. 인수 &lt;code&gt;args...&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 로 생성자에게 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="de2a91ea3a0922ba9fd2c6820a52603ceaf2bfd4" translate="yes" xml:space="preserve">
          <source>Inserts a new element to the container as close as possible to the position just before &lt;code&gt;hint&lt;/code&gt;. The element is constructed in-place, i.e. no copy or move operations are performed.</source>
          <target state="translated">&lt;code&gt;hint&lt;/code&gt; 직전의 위치에 가능한 한 가까운 곳에 새로운 요소를 컨테이너에 삽입합니다 . 요소가 제자리에 구성되어 있습니다. 즉, 복사 또는 이동 작업이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d62b4192e275e6e5464e704bf2f2c06f78857362" translate="yes" xml:space="preserve">
          <source>Inserts a new element to the container, using &lt;code&gt;hint&lt;/code&gt; as a suggestion where the element should go. The element is constructed in-place, i.e. no copy or move operations are performed.</source>
          <target state="translated">&lt;code&gt;hint&lt;/code&gt; 를 요소가있는 위치로 힌트 를 사용하여 컨테이너에 새 요소를 삽입합니다 . 요소가 제자리에 구성되어 있습니다. 즉, 복사 또는 이동 작업이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06b953e63c9c91232d7dddd7cd152b54414e60b1" translate="yes" xml:space="preserve">
          <source>Inserts a newline character into the output sequence &lt;code&gt;os&lt;/code&gt; and flushes it as if by calling &lt;code&gt;os.put(os.widen('\n'))&lt;/code&gt; followed by &lt;code&gt;os.flush()&lt;/code&gt;.</source>
          <target state="translated">출력 시퀀스 &lt;code&gt;os&lt;/code&gt; 에 개행 문자를 삽입하고 &lt;code&gt;os.put(os.widen('\n'))&lt;/code&gt; 다음에 &lt;code&gt;os.flush()&lt;/code&gt; 를 호출하는 것처럼 플러시합니다 .</target>
        </trans-unit>
        <trans-unit id="5f4e0eed677f446544f8308f60d7118157395fd2" translate="yes" xml:space="preserve">
          <source>Inserts a null character into the output sequence &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.put(CharT())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os.put(CharT())&lt;/code&gt; 호출 하여 출력 시퀀스 &lt;code&gt;os&lt;/code&gt; 에 널 문자를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="3be6541a3cdc8be869ffb1e36075af35ad2d9e5f" translate="yes" xml:space="preserve">
          <source>Inserts a textual representation of &lt;code&gt;d&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;. The behavior is undefined if &lt;code&gt;CharT&lt;/code&gt; is neither &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;, or if &lt;code&gt;Rep&lt;/code&gt; is neither a floating-point type nor a integral type with conversion rank equal to or greater than &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 의 텍스트 표현 을 &lt;code&gt;os&lt;/code&gt; 에 삽입합니다 . 만약 동작이 정의되어 &lt;code&gt;CharT&lt;/code&gt; 도 아닌 &lt;code&gt;char&lt;/code&gt; 또는 &lt;code&gt;wchar_t&lt;/code&gt; 의 경우, 또는 &lt;code&gt;Rep&lt;/code&gt; 부동 소수점 형식이나 변환 계수와 일체형도가 동등하거나보다 &lt;code&gt;short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b309639bb23b684cc4e6d27b3891dbc4686b983" translate="yes" xml:space="preserve">
          <source>Inserts a textual representation of &lt;code&gt;r&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;. The exact format is unspecified.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 의 텍스트 표현 을 &lt;code&gt;os&lt;/code&gt; 에 삽입합니다 . 정확한 형식은 지정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16b3b45d0513a34bfe5cb9a485fed3fcd636a919" translate="yes" xml:space="preserve">
          <source>Inserts characters into the string.</source>
          <target state="translated">문자열에 문자를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="0b8fe07029996680c6a7a04171ab4c8c1f427b51" translate="yes" xml:space="preserve">
          <source>Inserts copies of elements in &lt;code&gt;[i, j)&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 전에 &lt;code&gt;[i, j)&lt;/code&gt; 에 요소의 사본을 삽입합니다</target>
        </trans-unit>
        <trans-unit id="4f550772dfe95225e7aadcf101fd0fcec8c748a7" translate="yes" xml:space="preserve">
          <source>Inserts data into the stream.</source>
          <target state="translated">스트림에 데이터를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="eba77933a2e344cf988fd3ca6a623ff9d2ff92d0" translate="yes" xml:space="preserve">
          <source>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.</source>
          <target state="translated">컨테이너에 동등한 키를 가진 요소가 포함되어 있지 않으면 컨테이너에 요소를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="ccd9e30db577ad68c0e1422c4c4a79f885e3e582" translate="yes" xml:space="preserve">
          <source>Inserts element(s) into the container.</source>
          <target state="translated">컨테이너에 요소를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="1a4eb8d141fa15817e7fa53f7d0ceee266ac871a" translate="yes" xml:space="preserve">
          <source>Inserts elements after the specified position in the container.</source>
          <target state="translated">컨테이너에서 지정된 위치 뒤에 요소를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="8ad0a7fe7ffe735c0e8d1f3247c2284b472ecf85" translate="yes" xml:space="preserve">
          <source>Inserts elements at the specified location in the container.</source>
          <target state="translated">컨테이너의 지정된 위치에 요소를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="e3538cf079d871f7078cd6d2626f91c5fe3217d1" translate="yes" xml:space="preserve">
          <source>Inserts or extracts a bitset from a character stream.</source>
          <target state="translated">문자 스트림에서 비트 세트를 삽입하거나 추출합니다.</target>
        </trans-unit>
        <trans-unit id="436cbc44494163237fbc2dae7c0dbecac89e17a0" translate="yes" xml:space="preserve">
          <source>Inserts the element at the position &lt;code&gt;last-1&lt;/code&gt; into the</source>
          <target state="translated">위치의 요소를 삽입 &lt;code&gt;last-1&lt;/code&gt; 로</target>
        </trans-unit>
        <trans-unit id="de7c44cdab798ba02a3b54672adb89734e298e3e" translate="yes" xml:space="preserve">
          <source>Inserts the given value &lt;code&gt;value&lt;/code&gt; to the container.</source>
          <target state="translated">지정된 값 삽입 &lt;code&gt;value&lt;/code&gt; 컨테이너에 있습니다.</target>
        </trans-unit>
        <trans-unit id="da42294637fdcfd28f56598c14c33d9cc2c56bd5" translate="yes" xml:space="preserve">
          <source>Inserts the value of the pointer managed by &lt;code&gt;p&lt;/code&gt; into the output stream &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 관리하는 포인터의 값을 출력 스트림 &lt;code&gt;os&lt;/code&gt; 에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="27f20e401e741fb3278e97286227b847ff4a5a37" translate="yes" xml:space="preserve">
          <source>Inserts the value of the pointer stored in ptr into the output stream os.</source>
          <target state="translated">ptr에 저장된 포인터의 값을 출력 스트림 os에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="cc4361d50be18c5e552170a7006899011cb13d66" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;../language/constraints&quot;&gt; requirements&lt;/a&gt; for type requirements (since C++20)</source>
          <target state="translated">유형 요구 &lt;a href=&quot;../language/constraints&quot;&gt;사항에&lt;/a&gt; 대한 요구 사항 내부 (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="600f1274eac8f378c8f16ed6ad8ee46ff4edfb74" translate="yes" xml:space="preserve">
          <source>Inside a class definition, the keyword &lt;a href=&quot;../keywords/static&quot;&gt;&lt;code&gt;static&lt;/code&gt;&lt;/a&gt; declares members that are not bound to class instances.</source>
          <target state="translated">클래스 정의 내에서 &lt;a href=&quot;../keywords/static&quot;&gt; &lt;code&gt;static&lt;/code&gt; &lt;/a&gt; 키워드 는 클래스 인스턴스에 바인딩되지 않은 멤버를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="03675817cd2b928d6905ad0345e0c7efd3baeea5" translate="yes" xml:space="preserve">
          <source>Inside a declaration or a definition of a template, &lt;code&gt;typename&lt;/code&gt; can be used to declare that a &lt;a href=&quot;../language/dependent_name&quot;&gt;dependent qualified name&lt;/a&gt; is a type.</source>
          <target state="translated">템플릿의 선언 또는 정의 내에서 &lt;code&gt;typename&lt;/code&gt; 을 사용하여 &lt;a href=&quot;../language/dependent_name&quot;&gt;종속 정규화 된 이름&lt;/a&gt; 이 유형 임을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c75e28d40b1ee1647f206ce29f91a72118f77dcb" translate="yes" xml:space="preserve">
          <source>Inside a declaration or a definition of a template,(until C++11)&lt;code&gt;typename&lt;/code&gt; can be used before a non-dependent qualified type name. It has no effect in this case.</source>
          <target state="translated">템플릿의 선언 또는 정의 내에서 (C ++ 11까지) &lt;code&gt;typename&lt;/code&gt; 은 비 종속적 인 한정된 형식 이름 앞에 사용할 수 있습니다. 이 경우에는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6cd46b31dc66a09cb27a8b94558ff90367369cb8" translate="yes" xml:space="preserve">
          <source>Inside a template definition, &lt;code&gt;template&lt;/code&gt; can be used to declare that a &lt;a href=&quot;../language/dependent_name&quot;&gt;dependent name&lt;/a&gt; is a template.</source>
          <target state="translated">템플릿 정의 내부 &lt;code&gt;template&lt;/code&gt; 선언 할 수 있습니다 &lt;a href=&quot;../language/dependent_name&quot;&gt;따라 이름&lt;/a&gt; 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="350b4808c73cf8468a6f363916c30c4a397b3dc5" translate="yes" xml:space="preserve">
          <source>Inside class definition</source>
          <target state="translated">내부 클래스 정의</target>
        </trans-unit>
        <trans-unit id="6b5698bf0daa42ff37c1cd0dca09d5b7656e92d2" translate="yes" xml:space="preserve">
          <source>Inside the definition of a &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; (both &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt; and &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt;), the meaning of some constructs may differ from one instantiation to another. In particular, types and expressions may depend on types of type template parameters and values of non-type template parameters.</source>
          <target state="translated">&lt;a href=&quot;templates&quot;&gt;템플릿&lt;/a&gt; 정의 ( &lt;a href=&quot;class_template&quot;&gt;클래스 템플릿&lt;/a&gt; 및 &lt;a href=&quot;function_template&quot;&gt;함수 템플릿&lt;/a&gt; 모두 ) 내에서 일부 구성의 의미는 인스턴스화마다 다를 수 있습니다. 특히, 유형 및 표현은 유형 템플릿 파라미터의 유형 및 비 타입 템플릿 파라미터의 값에 의존 할 수있다.</target>
        </trans-unit>
        <trans-unit id="29bb12e4f618840806749020bc50cf4a005ce46d" translate="yes" xml:space="preserve">
          <source>Inspects the declared type of an entity or the type and value category of an expression.</source>
          <target state="translated">선언 된 엔터티 형식 또는 식의 형식 및 값 범주를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="55e8d92a13e25eb28d03d82349c3f32ae5b1856b" translate="yes" xml:space="preserve">
          <source>Instances of this class may also hold the special distinct value that does not represent any thread. Once a thread has finished, the value of &lt;code&gt;std::thread::id&lt;/code&gt; may be reused by another thread.</source>
          <target state="translated">이 클래스의 인스턴스는 스레드를 나타내지 않는 특별한 고유 값을 보유 할 수도 있습니다. 스레드가 완료되면 &lt;code&gt;std::thread::id&lt;/code&gt; 값을 다른 스레드에서 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0323fe82517b3deef4dcc33c2202e8572f5af700" translate="yes" xml:space="preserve">
          <source>Instead of being defined by specific types, each category of iterator is defined by the operations that can be performed on it. This definition means that any type that supports the necessary operations can be used as an iterator -- for example, a pointer supports all of the operations required by &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, so a pointer can be used anywhere a &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; is expected.</source>
          <target state="translated">특정 유형으로 정의되는 대신 각 반복기 범주는 수행 할 수있는 조작으로 정의됩니다. 지원이 필요한 작업을 반복자로 사용될 수있는 모든 종류의 것을이 정의 수단 - 예를 들면은, 포인터가 필요로하는 모든 작업을 지원 &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator을&lt;/a&gt; 포인터를 사용할 수는, 어디서든 &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator이&lt;/a&gt; 예상된다.</target>
        </trans-unit>
        <trans-unit id="b12082e6b05d3b9bc176ff98ba66b29e9e0b12fe" translate="yes" xml:space="preserve">
          <source>Instead of creating copies of files, create hardlinks that resolve to the same files as the originals</source>
          <target state="translated">파일 사본을 작성하는 대신 원본과 동일한 파일로 해석되는 하드 링크를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="78afece0e04a5cf908cc483529a4871648680f1b" translate="yes" xml:space="preserve">
          <source>Instead of creating copies of files, create symlinks pointing to the originals. Note: the source path must be an absolute path unless the destination path is in the current directory.</source>
          <target state="translated">파일 사본을 만드는 대신 원본을 가리키는 심볼릭 링크를 만듭니다. 참고 : 대상 경로가 현재 디렉토리에 있지 않으면 소스 경로는 절대 경로 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cfaebf91cdac75d382847870cf98c644ae8839f0" translate="yes" xml:space="preserve">
          <source>Instead of using the overload (2) together with new, it is often a better idea to use &lt;code&gt;&lt;a href=&quot;make_unique&quot;&gt;std::make_unique&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">오버로드 (2)를 new와 함께 사용하는 대신 &lt;code&gt;&lt;a href=&quot;make_unique&quot;&gt;std::make_unique&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="15df2d5892f1c21a31c35b32a3d847ba47bdff20" translate="yes" xml:space="preserve">
          <source>Instructs the regular expression engine to make matching faster, with the potential cost of making construction slower. For example, this might mean converting a non-deterministic FSA to a deterministic FSA.</source>
          <target state="translated">정규식 엔진이 건설 속도를 늦출 수있는 잠재적 인 비용으로 더 빨리 일치하도록 지시합니다. 예를 들어, 비 결정적 FSA를 결정적 FSA로 변환하는 것을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d29911b1bd2caeb5ec80c99646811291a26cf594" translate="yes" xml:space="preserve">
          <source>IntType</source>
          <target state="translated">IntType</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">정수 타입</target>
        </trans-unit>
        <trans-unit id="d19f3662fc5d3aa69996dfa0c88356fda0d60fc4" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">성공시 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 정수 값 . 변환 된 값이 해당 리턴 유형의 범위를 벗어나면 범위 오류가 발생하고 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; 이 리턴됩니다. 어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1da9ae4426444f430bd1d7493a5b5250c7cfec29" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">성공시 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 정수 값 . 변환 된 값이 해당 리턴 유형의 범위를 벗어나면 범위 오류가 발생하고 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; 가 리턴됩니다. 어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="52e4539e8037f8f852f5856d00606b776679d442" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;​0​&lt;/code&gt; is returned, as appropriate. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">성공시 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 정수 값 . 변환 된 값이 반환 유형의 대응 범위를 벗어나게되면 범위 에러가 발생하고 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;​0​&lt;/code&gt; 적절하게 복귀된다. 어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="21098bb738833ee0f4f792151a59d559da8ec6b0" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, the return value is undefined. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">성공시 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 정수 값 . 변환 된 값이 해당 반환 유형의 범위를 벗어나면 반환 값이 정의되지 않습니다. 어떤 변환을 수행 할 수없는 경우, &lt;code&gt;​0​&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="b825f7aa91a4416d2a86fdbf6d9049ea6b2d615d" translate="yes" xml:space="preserve">
          <source>Integral constant expression</source>
          <target state="translated">정수 상수 표현</target>
        </trans-unit>
        <trans-unit id="1f4e6183969d6ec80ad6d2f378b3a85f029c653b" translate="yes" xml:space="preserve">
          <source>Integral conversions</source>
          <target state="translated">완전한 변환</target>
        </trans-unit>
        <trans-unit id="320e2752aea495aec73f84035d1bb6ef868679ad" translate="yes" xml:space="preserve">
          <source>Integral promotion</source>
          <target state="translated">통합 프로모션</target>
        </trans-unit>
        <trans-unit id="270f2235f730fd6efca2aa9d17f0dc702810f771" translate="yes" xml:space="preserve">
          <source>Intel C++ Inline Assembly</source>
          <target state="translated">인텔 C ++ 인라인 어셈블리</target>
        </trans-unit>
        <trans-unit id="48e94a1cde254c1213e9904ae2fa6aec7a82e049" translate="yes" xml:space="preserve">
          <source>Inter-thread happens-before</source>
          <target state="translated">스레드 간 발생</target>
        </trans-unit>
        <trans-unit id="fbefd7a4bdb4b3775050f8fe665496f4fc106f7d" translate="yes" xml:space="preserve">
          <source>Inter-thread synchronization and memory ordering determine how</source>
          <target state="translated">스레드 간 동기화 및 메모리 순서에 따라 방법이 결정됩니다</target>
        </trans-unit>
        <trans-unit id="e341892f1cc87078f7d5e926c1138ccb82e90235" translate="yes" xml:space="preserve">
          <source>Internal Compiler Error</source>
          <target state="translated">내부 컴파일러 오류</target>
        </trans-unit>
        <trans-unit id="8db0e387b648322ee87a237498c06354600d50c6" translate="yes" xml:space="preserve">
          <source>Internal extensible array</source>
          <target state="translated">내부 확장 가능 어레이</target>
        </trans-unit>
        <trans-unit id="3eec2f184115efd5c87c5ee6ebf0d6b3a9c071ab" translate="yes" xml:space="preserve">
          <source>Internally, a locale object is implemented as-if it is a reference-counted pointer to an array (indexed by &lt;code&gt;&lt;a href=&quot;locale/id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt;) of reference-counted pointers to facets: copying a locale only copies one pointer and increments several reference counts. To maintain the standard C++ library thread safety guarantees (operations on different objects are always thread-safe), both the locale reference count and each facet reference count are updated in thread-safe manner, similar to &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">내부적으로, 로케일 객체는 패싯에 대한 참조 카운트 포인터의 배열에 대한 참조 카운트 포인터 인 경우처럼 구현됩니다 ( &lt;code&gt;&lt;a href=&quot;locale/id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; 로 패싯) : 로케일을 복사하면 하나의 포인터 만 복사하고 여러 참조가 증가합니다 카운트. 표준 C ++ 라이브러리 스레드 안전 보장을 유지하기 위해 (다른 객체에 대한 작업은 항상 스레드 안전) 로케일 참조 수와 각 패싯 참조 수는 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 과 유사하게 스레드 안전 방식으로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="9dac1e92729539ac11d8cad38e7bddd13ef84d39" translate="yes" xml:space="preserve">
          <source>Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="translated">내부적으로 문자는 쓰기 직전 에 &lt;code&gt;unsigned char&lt;/code&gt; 문자로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a300aede5a38ab0ed12e3cbf6171db92a06f041" translate="yes" xml:space="preserve">
          <source>Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its key. This allows fast access to individual elements, since once the hash is computed, it refers to the exact bucket the element is placed into.</source>
          <target state="translated">내부적으로 요소는 특정 순서로 정렬되지 않고 버킷으로 구성됩니다. 요소가 배치되는 버킷은 전적으로 해당 키의 해시에 달려 있습니다. 해시가 계산되면 요소가 배치 된 정확한 버킷을 참조하므로 개별 요소에 빠르게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e3d09a97f93ab12396f4f53a23484c5868af0eb" translate="yes" xml:space="preserve">
          <source>Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once a hash is computed, it refers to the exact bucket the element is placed into.</source>
          <target state="translated">내부적으로 요소는 특정 순서로 정렬되지 않고 버킷으로 구성됩니다. 요소가 배치되는 버킷은 전적으로 해당 값의 해시에 따라 다릅니다. 해시가 계산되면 요소가 배치 된 정확한 버킷을 참조하므로 개별 요소에 빠르게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d351577d1e15db8313b9f13fd0274b045e4b3f2" translate="yes" xml:space="preserve">
          <source>Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once hash is computed, it refers to the exact bucket the element is placed into.</source>
          <target state="translated">내부적으로 요소는 특정 순서로 정렬되지 않고 버킷으로 구성됩니다. 요소가 배치되는 버킷은 전적으로 해당 값의 해시에 따라 다릅니다. 해시가 계산되면 요소가 배치 된 정확한 버킷을 참조하므로 개별 요소에 빠르게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4000ac517f025eca6a922c089403bb09186f8d96" translate="yes" xml:space="preserve">
          <source>International monetary numeric formatting parameters</source>
          <target state="translated">국제 통화 숫자 형식화 매개 변수</target>
        </trans-unit>
        <trans-unit id="a8ae931d734dc08b103a3cda5b6a5d402a381387" translate="yes" xml:space="preserve">
          <source>Interpolation operations</source>
          <target state="translated">보간 연산</target>
        </trans-unit>
        <trans-unit id="0f1ee1e93c2e9e3ff3649d6745a31dd59c9090f7" translate="yes" xml:space="preserve">
          <source>Interprets a floating point value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 바이트 문자열에서 부동 소수점 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="c521564a7a070d90bbed7e76e298ba2e2b938b7a" translate="yes" xml:space="preserve">
          <source>Interprets a floating point value in a string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;str&lt;/code&gt; 의 부동 소수점 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="bc48cbadb6a84efbed23317d93156122ffd8c740" translate="yes" xml:space="preserve">
          <source>Interprets a floating point value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 넓은 문자열에서 부동 소수점 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="ad9f4a5a657fd23f774f0701ca42e9ed82c97178" translate="yes" xml:space="preserve">
          <source>Interprets a signed integer value in the string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;str&lt;/code&gt; 에서 부호있는 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="9a608036eb59f94001912ca3733a0c15c944b183" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a byte string pointed to by &lt;code&gt;nptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nptr&lt;/code&gt; 이 가리키는 바이트 문자열의 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="566cf8ed0ac571b4f2aa3ca75d488875487baeb4" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 바이트 문자열의 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="cc2bd5d023e90da3e1640fc0f66845e22f6c8508" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 넓은 문자열의 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="042a224facaad3cdf57ba7458290bd20ddbab9ab" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 바이트 문자열에서 부호없는 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="65b433c8b60cb3b8c5443581467dc0f6ae5b6523" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a wide string pointed to by &lt;code&gt;nptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nptr&lt;/code&gt; 이 가리키는 넓은 문자열에서 부호없는 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="148c33b3cec53bcad46f4795046e389f68465431" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 넓은 문자열에서 부호없는 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="aabb8c7d3ca13ab71a2338fd76d6fca5fd94220c" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in the string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;str&lt;/code&gt; 에서 부호없는 정수 값을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="9aa738055f64e3e6394c5784c7988113147a1c1a" translate="yes" xml:space="preserve">
          <source>Interrupted function</source>
          <target state="translated">중단 된 기능</target>
        </trans-unit>
        <trans-unit id="dded3e7aba46e073c03bff678699e36b51e2c4a9" translate="yes" xml:space="preserve">
          <source>Introduces a name that is defined elsewhere into the declarative region where this using-declaration appears.</source>
          <target state="translated">이 사용 선언이 나타나는 선언 영역의 다른 곳에 정의 된 이름을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="d63eba892386df3bd9064d08a9292099f5ee5b9f" translate="yes" xml:space="preserve">
          <source>Introduces implementation-defined attributes for types, objects, code, etc.  &lt;code&gt;[[&lt;/code&gt;</source>
          <target state="translated">유형, 객체, 코드 등에 대한 구현 정의 속성을 소개합니다. &lt;code&gt;[[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45ff4427a9f1fb0c18cbcdf6b26d6a2d22f2df2f" translate="yes" xml:space="preserve">
          <source>Invalid argument</source>
          <target state="translated">잘못된 인수</target>
        </trans-unit>
        <trans-unit id="1383c7b39080e5234bcaae9c303e96b402357694" translate="yes" xml:space="preserve">
          <source>Invalid non-zero alignments, such as &lt;code&gt;alignas(3)&lt;/code&gt; are ill-formed.</source>
          <target state="translated">&lt;code&gt;alignas(3)&lt;/code&gt; 와 같은 잘못된 0이 아닌 정렬 은 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="86c96ba7411037b346432868bfdb3e867290952c" translate="yes" xml:space="preserve">
          <source>Invalid scalar</source>
          <target state="translated">잘못된 스칼라</target>
        </trans-unit>
        <trans-unit id="b6b99ba962e359de15e0e27fd677ea67331c95bc" translate="yes" xml:space="preserve">
          <source>Invalid seek</source>
          <target state="translated">잘못된 탐색</target>
        </trans-unit>
        <trans-unit id="41fc9b91f0fee77d14d8c449a0016aae8b1ef082" translate="yes" xml:space="preserve">
          <source>Invalidated</source>
          <target state="translated">Invalidated</target>
        </trans-unit>
        <trans-unit id="5184a57889a8a3581992c2997ad61b14585f2ce0" translate="yes" xml:space="preserve">
          <source>Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid.</source>
          <target state="translated">포함 된 요소를 참조하는 모든 참조, 포인터 또는 반복자를 무효화합니다. 과거의 모든 반복자는 유효합니다.</target>
        </trans-unit>
        <trans-unit id="7c48efeaf38e5bc872433889acf9dca25ee7978e" translate="yes" xml:space="preserve">
          <source>Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterators are also invalidated.</source>
          <target state="translated">포함 된 요소를 참조하는 모든 참조, 포인터 또는 반복자를 무효화합니다. 과거의 모든 반복자도 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="84523b9994334aa4168c1ce7715701ecd8e7c500" translate="yes" xml:space="preserve">
          <source>Invalidates any references, pointers, or iterators referring to contained elements. May also invalidate past-the-end iterators.</source>
          <target state="translated">포함 된 요소를 참조하는 모든 참조, 포인터 또는 반복자를 무효화합니다. 또한 과거 반복기를 무효화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="900eb067daacf1fc2f277185d1c086ea7646a1aa" translate="yes" xml:space="preserve">
          <source>Invalidates iterators and references at or after the point of the erase, including the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 반복자를 포함하여 지우기 시점 또는 이후의 반복자와 참조를 무효화합니다 .</target>
        </trans-unit>
        <trans-unit id="57cfa38621b674967383a26be5a5ea85e99b30e4" translate="yes" xml:space="preserve">
          <source>Invalidation notes</source>
          <target state="translated">무효화 노트</target>
        </trans-unit>
        <trans-unit id="4b1ed8b8c1a0fe2800fdf2738e1f7cc4d2d7cef2" translate="yes" xml:space="preserve">
          <source>Inverse cosine (or arc cosine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;,-1) and (1,&amp;infin;) of the real axis.  The mathematical definition of the principal value of arc cosine is acos z =</source>
          <target state="translated">역 코사인 (또는 아크 코사인)은 다중 값 함수이며 복잡한 평면에서 분기 절단이 필요합니다. 브랜치 컷은 일반적으로 실제 축의 선 세그먼트 (-&amp;infin;, -1) 및 (1, &amp;infin;)에 배치됩니다. 아크 코사인의 주요 값의 수학적 정의는 acos z =</target>
        </trans-unit>
        <trans-unit id="92db73712a1ea6cdea29021a66a4e0d10b6b003b" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segment (-&amp;infin;,+1) of the real axis.</source>
          <target state="translated">역 쌍곡 코사인은 다중 값 함수이며 복잡한 평면에서 분기 절단이 필요합니다. 브랜치 컷은 일반적으로 실제 축의 선분 (-&amp;infin;, + 1)에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="3ff0648a78636309b1cc12a67a5c7841a27e8966" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-</source>
          <target state="translated">역 쌍곡 사인은 다중 값 함수이며 복잡한 평면에서 분기 절단이 필요합니다. 브랜치 컷은 일반적으로 선 세그먼트에 배치됩니다 (-</target>
        </trans-unit>
        <trans-unit id="60cf8f72dc186c6f4b4743734e8e8ed4cb1bd30a" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segmentd (-&amp;infin;,-1] and [+1,+&amp;infin;) of the real axis.  The mathematical definition of the principal value of the inverse hyperbolic tangent is atanh z =</source>
          <target state="translated">역 쌍곡 탄젠트는 다중 값 함수이며 복잡한 평면에서 분기 절단이 필요합니다. 브랜치 컷은 일반적으로 실제 축의 세그먼트 (-&amp;infin;, -1] 및 [+ 1, + &amp;infin;)에 배치됩니다. 역 쌍곡 탄젠트의 주요 값의 수학적 정의는 atanh z =</target>
        </trans-unit>
        <trans-unit id="ff28b3449f26b28c2a2ed73fffb64ba03b0e2959" translate="yes" xml:space="preserve">
          <source>Inverse sine (or arc sine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;,-1) and (1,&amp;infin;) of the real axis.</source>
          <target state="translated">역 사인 (또는 아크 사인)은 다중 값 함수이며 복잡한 평면에서 분기 절단이 필요합니다. 브랜치 컷은 일반적으로 실제 축의 선 세그먼트 (-&amp;infin;, -1) 및 (1, &amp;infin;)에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="8a394149a1f48f15fcf530168253dbecfeb4322f" translate="yes" xml:space="preserve">
          <source>Inverse tangent (or arc tangent) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;i,-i) and (+i,+&amp;infin;i) of the imaginary axis.  The mathematical definition of the principal value of inverse tangent is atan z = -</source>
          <target state="translated">역 탄젠트 (또는 아크 탄젠트)는 다중 값 함수이며 복잡한 평면에서 분기 절단이 필요합니다. 브랜치 컷은 일반적으로 가상 축의 선분 (-&amp;infin;i, -i) 및 (+ i, + &amp;infin;i)에 배치됩니다. 역 탄젠트의 주요 값의 수학적 정의는 atan z =-</target>
        </trans-unit>
        <trans-unit id="e22b4961b86c756eeda2aa9b446c8173116dbbc7" translate="yes" xml:space="preserve">
          <source>Inverts the referenced bit.</source>
          <target state="translated">참조 된 비트를 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="08fcf3f000c798d1019b77985f2565bd9131f8e3" translate="yes" xml:space="preserve">
          <source>InvocableRegularInvocable</source>
          <target state="translated">InvocableRegularInvocable</target>
        </trans-unit>
        <trans-unit id="d4f9cb47dbcc2422f0bd9a0424a0965a711f4fe4" translate="yes" xml:space="preserve">
          <source>Invoke the &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; object &lt;code&gt;f&lt;/code&gt; with the parameters &lt;code&gt;args&lt;/code&gt;. As by &lt;code&gt;INVOKE(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 매개 변수를 사용 하여 &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; 오브젝트 &lt;code&gt;f&lt;/code&gt; 를 호출하십시오 . 등에 의해 &lt;code&gt;INVOKE(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; &lt;a href=&quot;../forward&quot;&gt;표준 : 순방향&lt;/a&gt; &amp;lt;F&amp;gt; (F), &lt;a href=&quot;../forward&quot;&gt;표준 : 순방향&lt;/a&gt; &amp;lt;인수&amp;gt; (인수)이 ...) .</target>
        </trans-unit>
        <trans-unit id="43a887b06ff69b20968832ea3de0f894899ed0b1" translate="yes" xml:space="preserve">
          <source>Invoke the &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; object &lt;code&gt;f&lt;/code&gt; with a tuple of arguments.</source>
          <target state="translated">튜플 인수로 &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; 객체 &lt;code&gt;f&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a0f26292e2434ecd2054e3f89ad01624a3592aac" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;b.seed()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b.seed()&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="533e38b5b781a7cf4c13a2c009ad69bee4e181ab" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;b.seed(q)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b.seed(q)&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c8de535373bc28162e3e7e5c533ad8d22bcee959" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;b.seed(s)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b.seed(s)&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="43efae5b116e5f3d09b4e59697f462efb6558f1d" translate="yes" xml:space="preserve">
          <source>Invokes implementation-defined behaviour if not &lt;code&gt;&lt;a href=&quot;../io/streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; is used as the traits template parameter in input/output classes.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 가 입력 / 출력 클래스에서 특성 템플리트 매개 변수로 사용될 때 &lt;code&gt;&lt;a href=&quot;../io/streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; 가 아닌 경우 구현 정의 동작을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fed12ee3ef79fc236fc9bb3fd94d2fb99592217c" translate="yes" xml:space="preserve">
          <source>Invokes implementation-defined behaviour if this type is not &lt;code&gt;&lt;a href=&quot;../io/fpos&quot;&gt;std::streampos&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; is used as the traits template parameter in input/output classes</source>
          <target state="translated">원용하는 구현 정의 동작은 이러한 유형되지 않은 경우 &lt;code&gt;&lt;a href=&quot;../io/fpos&quot;&gt;std::streampos&lt;/a&gt;&lt;/code&gt; 때 &lt;code&gt;X&lt;/code&gt; 는 입력 / 출력 클래스의 특성 템플릿 매개 변수로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="10839e4e143f807b60e96a2d95d532d052d717e3" translate="yes" xml:space="preserve">
          <source>Invokes the stored callable function target with the parameters &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 매개 변수를 사용하여 저장된 호출 가능 함수 대상을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b3c06b4bbdf7388ea26ca66d81ec0d37bcc14b0f" translate="yes" xml:space="preserve">
          <source>Invoking over Incomplete Types</source>
          <target state="translated">불완전한 유형 호출</target>
        </trans-unit>
        <trans-unit id="d82b06adf1a876d702b6a3905d8d56b51827e40e" translate="yes" xml:space="preserve">
          <source>Is a directory</source>
          <target state="translated">디렉토리인가</target>
        </trans-unit>
        <trans-unit id="3dfd81af531e4d3b7128a14d5c41e637a26dc974" translate="yes" xml:space="preserve">
          <source>It can also be called using member function call syntax:</source>
          <target state="translated">멤버 함수 호출 구문을 사용하여 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="09e1f9f748059f808777769884d3dc5b93769167" translate="yes" xml:space="preserve">
          <source>It can also be used to detect validity of an expression:</source>
          <target state="translated">또한 표현식의 유효성을 감지하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ee5198972c83e32aa4a5a28496aa84dc1d7e5c4" translate="yes" xml:space="preserve">
          <source>It can be used to specify additional constraints in terms of local parameters. The constraint-expression must be satisfied by the substituted template arguments, if any. Substitution of template arguments into a nested requirement causes substitution into the constraint-expression only to the extent needed to determine whether the constraint-expression is satisfied.</source>
          <target state="translated">로컬 매개 변수와 관련하여 추가 제한 조건을 지정하는 데 사용할 수 있습니다. constraint-expression은 대체 된 템플리트 인수 (있는 경우)로 충족되어야합니다. 템플리트 인수를 중첩 된 요구 사항으로 대체하면 constraint-expression이 충족되는지 여부를 판별하는 데 필요한 정도로만 constraint-expression으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="619583a1fc7588b9b8e425ca17f621a35be87edb" translate="yes" xml:space="preserve">
          <source>It can be used with a named variable:</source>
          <target state="translated">명명 된 변수와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc95ed9cfcbc19e43b1a73cbe3345e11d2c4b4b0" translate="yes" xml:space="preserve">
          <source>It can be used within a function template's &lt;a href=&quot;noexcept_spec&quot;&gt; noexcept specifier&lt;/a&gt; to declare that the function will throw exceptions for some types but not others.</source>
          <target state="translated">함수 템플릿의 &lt;a href=&quot;noexcept_spec&quot;&gt;noexcept 지정자&lt;/a&gt; 내 에서 함수가 일부 유형에 대해서는 예외를 throw하지만 다른 유형에는 예외를 throw하지 않을 것이라고 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1095ba2835f4490f22e5cd2104e56ec80a11aef2" translate="yes" xml:space="preserve">
          <source>It consists of a collection of</source>
          <target state="translated">그것은 모음으로 구성</target>
        </trans-unit>
        <trans-unit id="a6dfca72e61bb66f5282dc9be56b501edd0e1c20" translate="yes" xml:space="preserve">
          <source>It consists of a count of ticks of type &lt;code&gt;Rep&lt;/code&gt; and a tick period, where the tick period is a compile-time rational constant representing the number of seconds from one tick to the next.</source>
          <target state="translated">&lt;code&gt;Rep&lt;/code&gt; 유형의 틱 수 와 틱 기간으로 구성되며, 여기서 틱 기간은 한 틱에서 다음 틱까지의 초 수를 나타내는 컴파일 타임 합리적인 상수입니다.</target>
        </trans-unit>
        <trans-unit id="8fe8176ea54439a7ccb802fb9944ca38d007f40a" translate="yes" xml:space="preserve">
          <source>It has the same &lt;a href=&quot;access&quot;&gt;access&lt;/a&gt; as the corresponding base constructor. It is &lt;code&gt;constexpr&lt;/code&gt; if the user-defined constructor would have satisfied &lt;code&gt;constexpr&lt;/code&gt; constructor requirements. It is deleted if the corresponding base constructor is deleted or if a defaulted default constructor would be deleted (except that the construction of the base whose constructor is being inherited doesn't count). An inheriting constructor cannot be explicitly instantiated or explicitly specialized.</source>
          <target state="translated">해당 기본 생성자 와 동일한 &lt;a href=&quot;access&quot;&gt;액세스 권한이 있습니다&lt;/a&gt; . 그것은이다 &lt;code&gt;constexpr&lt;/code&gt; 사용자 정의 생성자가 만족했을 경우 &lt;code&gt;constexpr&lt;/code&gt; 의 생성자 요구 사항을. 해당 기본 생성자가 삭제되거나 기본 기본 생성자가 삭제되는 경우 삭제됩니다 (생성자가 상속되는 기본 구성은 제외). 상속 생성자는 명시 적으로 인스턴스화하거나 명시 적으로 특수화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ac2d8ef890218e1971697be578d263616be6031" translate="yes" xml:space="preserve">
          <source>It indicates that a the function definition should be optimized for invocation from a &lt;code&gt;synchronized&lt;/code&gt; statement. In particular, it avoids serializing synchronized blocks that make a call to a function that is transaction-safe for the majority of calls, but not for all calls (e.g. hash table insertion that may have to rehash, allocator that may have to request a new block, a simple function that may rarely log).</source>
          <target state="translated">함수 정의가 &lt;code&gt;synchronized&lt;/code&gt; 명령문 에서 호출하도록 최적화되어야 함을 나타냅니다 . 특히, 대부분의 호출에 대해 트랜잭션에 안전한 기능을 호출하지만 모든 호출에 대해 호출하지 않는 동기화 된 블록을 직렬화하지 않아도됩니다 (예 : 다시 해시해야 할 해시 테이블 삽입, 새 요청이 필요한 할당 자) 블록, 거의 기록하지 않을 수있는 간단한 함수).</target>
        </trans-unit>
        <trans-unit id="31f0bb20de8e96b8260678ddcc2cec2269507d64" translate="yes" xml:space="preserve">
          <source>It is a non-binding request to reduce &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;. It depends on the implementation if the request is fulfilled.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 로 줄이기위한 바인딩이 아닌 요청 입니다. 요청이 이행되면 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2d5740434b4376cbb133c18052ef3ec7113f5eaf" translate="yes" xml:space="preserve">
          <source>It is a non-binding request to reduce &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;. It depends on the implementation whether the request is fulfilled.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 로 줄이기위한 바인딩이 아닌 요청 입니다. 요청이 이행되는지 여부는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4b00903590e8f552a1ace12bc5841762223d788d" translate="yes" xml:space="preserve">
          <source>It is a non-binding request to reduce the memory usage without changing the size of the sequence. It depends on the implementation whether the request is fulfilled.</source>
          <target state="translated">시퀀스 크기를 변경하지 않고 메모리 사용량을 줄이려면 비 바인딩 요청입니다. 요청이 이행되는지 여부는 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d97fe75aaa98f7e001c2ef2b3b758e21ceb5c984" translate="yes" xml:space="preserve">
          <source>It is allowed for the same declaration to be found more than once:</source>
          <target state="translated">동일한 선언이 두 번 이상 발견 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7acda9ca39c15e684583b5939db44164abbca690" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;code&gt;p&lt;/code&gt; does not refer to a symbolic link.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 기호 링크를 나타내지 않으면 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="4ac6d6c59239a9e9a0945510352b875d15d0c303" translate="yes" xml:space="preserve">
          <source>It is equivalent to.</source>
          <target state="translated">동일합니다.</target>
        </trans-unit>
        <trans-unit id="dd397495d30164a47687cc68d3ee3debb8de228e" translate="yes" xml:space="preserve">
          <source>It is implementation-defined whether &lt;code&gt;rand()&lt;/code&gt; is thread-safe.</source>
          <target state="translated">&lt;code&gt;rand()&lt;/code&gt; 가 스레드 안전 인지 여부는 구현 정의 입니다.</target>
        </trans-unit>
        <trans-unit id="84efe53047a466556350dca48b226733f419c2a9" translate="yes" xml:space="preserve">
          <source>It is implementation-defined whether any &lt;a href=&quot;../language/objects#Alignment&quot;&gt;extended alignment&lt;/a&gt; is supported.</source>
          <target state="translated">&lt;a href=&quot;../language/objects#Alignment&quot;&gt;확장 정렬&lt;/a&gt; 이 지원 되는지 여부는 구현 정의 입니다.</target>
        </trans-unit>
        <trans-unit id="f3b9b360dbecc9ae1960b9e40b3f44904781af81" translate="yes" xml:space="preserve">
          <source>It is implementation-defined whether dynamic initialization happens-before the first statement of the main function (for statics) or the initial function of the thread (for thread-locals), or deferred to happen after.</source>
          <target state="translated">동적 초기화가 주 함수의 첫 번째 명령문 (정적) 또는 스레드의 초기 함수 (스레드 로컬) 이전에 발생하는지 또는 이후에 발생하도록 지연되는지에 대해 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="61a3a1813d80165d2df5ab50673ad21ec5aecc5a" translate="yes" xml:space="preserve">
          <source>It is implementation-defined which scalar types satisfy this trait, but unsigned(until C++20) integer types that do not use padding bits are guaranteed to have unique object representations.</source>
          <target state="translated">스칼라 유형이이 특성을 만족시키는 것은 구현에 따라 정의되지만, 패딩 비트를 사용하지 않는 부호없는 (C ++ 20까지) 정수 유형은 고유 한 객체 표현을 갖도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="f452c9b19e8125eb753da2303a095249683e2189" translate="yes" xml:space="preserve">
          <source>It is important to remember this rule while ordering the header files of a translation unit. For more examples of the interplay between function overloads and function specializations, expand below:</source>
          <target state="translated">변환 단위의 헤더 파일을 주문할 때이 규칙을 기억하는 것이 중요합니다. 기능 과부하와 기능 전문화 간의 상호 작용에 대한 더 많은 예를 보려면 아래로 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="84f7f9e6e1a9d37badb5dd8311ca6a0bc6dbdb31" translate="yes" xml:space="preserve">
          <source>It is intended that &lt;code&gt;Copyable&amp;lt;T&amp;gt;&lt;/code&gt; also requires &lt;code&gt;std::&lt;a href=&quot;assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;gt;&lt;/code&gt; (assignment from const rvalue) and &lt;code&gt;std::&lt;a href=&quot;assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, T&amp;amp;&amp;gt;&lt;/code&gt; (assignment from non-const lvalue) to be satisfied.</source>
          <target state="translated">것으로 의도된다 &lt;code&gt;Copyable&amp;lt;T&amp;gt;&lt;/code&gt; 또한 필요 &lt;code&gt;std::&lt;a href=&quot;assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;gt;&lt;/code&gt; (CONST r- 수치의 할당)과 &lt;code&gt;std::&lt;a href=&quot;assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, T&amp;amp;&amp;gt;&lt;/code&gt; (비 CONST 좌변에서 할당)를 만족한다.</target>
        </trans-unit>
        <trans-unit id="e89c6edc67ab990f4dbf2f94411a54a2785ae48a" translate="yes" xml:space="preserve">
          <source>It is legal to pass a pointer to a &lt;code&gt;va_list&lt;/code&gt; object to another function and then use that object after the function returns.</source>
          <target state="translated">&lt;code&gt;va_list&lt;/code&gt; 객체에 대한 포인터를 다른 함수 에 전달한 다음 함수가 반환 된 후 해당 객체를 사용하는 것이 합법적 입니다.</target>
        </trans-unit>
        <trans-unit id="600fa81257e98fe2222f530f6041ece9a9c792cf" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that immediately after setting the write time, the value returned by (1) is the same as what was passed as the argument to (2) because the file system's time may be more granular than &lt;code&gt;file_time_type&lt;/code&gt;.</source>
          <target state="translated">파일 시간이 &lt;code&gt;file_time_type&lt;/code&gt; 보다 세분화 될 수 있기 때문에 쓰기 시간을 설정 한 직후 (1)에서 반환 한 값이 (2)에 인수로 전달 된 값과 동일한 것은 보장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="19e7f91c42b80c040f054b6d4d2717f7558a91ea" translate="yes" xml:space="preserve">
          <source>It is not possible to change the precedence, grouping, or number of operands of operators.</source>
          <target state="translated">연산자의 우선 순위, 그룹화 또는 피연산자 수를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d6f058ae02644804095fa603da188cdda6b78a90" translate="yes" xml:space="preserve">
          <source>It is not possible to query the current output format.</source>
          <target state="translated">현재 출력 형식을 쿼리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="ab4860699c3e4136650eba42ced4751e96f60a0f" translate="yes" xml:space="preserve">
          <source>It is not user-provided (meaning, it is implicitly-defined or defaulted);</source>
          <target state="translated">사용자가 제공하지 않습니다 (즉, 암시 적으로 정의되거나 기본값 임).</target>
        </trans-unit>
        <trans-unit id="97be44c3bf3295b1767f75794d7dfeb5ea6fcc99" translate="yes" xml:space="preserve">
          <source>It is only safe to invoke the destructor if all threads have been notified. It is not required that they have exited their respective wait functions: some threads may still be waiting to reacquire the associated lock, or may be waiting to be scheduled to run after reacquiring it.</source>
          <target state="translated">모든 스레드에 통보 된 경우 소멸자를 호출하는 것이 안전합니다. 이들이 각각의 대기 기능을 종료 할 필요는 없습니다. 일부 스레드는 여전히 연관된 잠금을 다시 확보하기 위해 대기 중이거나 다시 확보 한 후 실행되도록 스케줄 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e70768e4115e7101bd5fd956648b5b4a1a7b7407" translate="yes" xml:space="preserve">
          <source>It is permitted to call &lt;code&gt;shared_from_this&lt;/code&gt; only on a previously shared object, i.e. on an object managed by &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; (in particular, &lt;code&gt;shared_from_this&lt;/code&gt; cannot be called during construction of &lt;code&gt;*this&lt;/code&gt;).</source>
          <target state="translated">전화를 허용 &lt;code&gt;shared_from_this&lt;/code&gt; 을 단에 의해 관리되는 객체의 이전에 공유 객체, 즉에 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; (특히, &lt;code&gt;shared_from_this&lt;/code&gt; 는 건설 중에 호출 할 수 없습니다 &lt;code&gt;*this&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e237c9465035935c40984d4ba69fc9854677f449" translate="yes" xml:space="preserve">
          <source>It is permitted to call &lt;code&gt;shared_from_this&lt;/code&gt; only on a previously shared object, i.e. on an object managed by &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. Otherwise the behavior is undefined(until C++17)&lt;code&gt;&lt;a href=&quot;bad_weak_ptr&quot;&gt;std::bad_weak_ptr&lt;/a&gt;&lt;/code&gt; is thrown (by the shared_ptr constructor from a default-constructed &lt;code&gt;weak_this&lt;/code&gt;)(since C++17).</source>
          <target state="translated">이전에 공유 된 객체, 즉 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; &amp;lt;T&amp;gt;에 의해 관리되는 객체에서만 &lt;code&gt;shared_from_this&lt;/code&gt; 를 호출 할 수 있습니다. 그렇지 않으면 동작이 정의되지 않습니다 (C ++ 17까지) &lt;code&gt;&lt;a href=&quot;bad_weak_ptr&quot;&gt;std::bad_weak_ptr&lt;/a&gt;&lt;/code&gt; 이 (기본적으로 구성된 &lt;code&gt;weak_this&lt;/code&gt; 에서 shared_ptr 생성자에 의해) throw됩니다 ( C ++ 17 이후).</target>
        </trans-unit>
        <trans-unit id="87374d898360b164d7d485ca958f9b4f6331b966" translate="yes" xml:space="preserve">
          <source>It is permitted to form references to references through type manipulations in templates or typedefs, in which case the</source>
          <target state="translated">템플릿 또는 typedef에서 유형 조작을 통해 참조에 대한 참조를 형성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c212dba4876364523e05a1fc0269ee84b6e501a5" translate="yes" xml:space="preserve">
          <source>It is possible to construct &lt;code&gt;std::gslice&lt;/code&gt; objects that select some indices more than once: if the above example used the strides &lt;code&gt;{1,1,1} &lt;/code&gt;, the indices would have been &lt;code&gt;{3, 4, 5, 4, 5, 6, ...} &lt;/code&gt;. Such gslices may only be used as arguments to the const version of &lt;code&gt;std::valarray::operator[]&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">일부 인덱스를 두 번 이상 선택하는 &lt;code&gt;std::gslice&lt;/code&gt; 객체 를 생성 할 수 있습니다 . 위의 예에서 보폭 &lt;code&gt;{1,1,1} &lt;/code&gt; 을 사용한 경우 인덱스는 &lt;code&gt;{3, 4, 5, 4, 5, 6, ...} &lt;/code&gt; . 이러한 gslice는 &lt;code&gt;std::valarray::operator[]&lt;/code&gt; 의 const 버전에 대한 인수로만 사용할 수 있으며 , 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ede96757c156e593ca1e3cea610558948eb5cc8" translate="yes" xml:space="preserve">
          <source>It is possible to execute &lt;code&gt;delete this;&lt;/code&gt;, if the program can guarantee that the object was allocated by &lt;code&gt;new&lt;/code&gt;, however, this renders every pointer to the deallocated object invalid, including the &lt;code&gt;this&lt;/code&gt; pointer itself: after &lt;code&gt;delete this;&lt;/code&gt; returns, such member function cannot refer to a member of a class (since this involves an implicit dereference of &lt;code&gt;this&lt;/code&gt;) and no other member function may be called. This is used, for example, in the member function of the control block of &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; responsible for decrementing the reference count, when the last reference to the managed object goes out of scope.</source>
          <target state="translated">&lt;code&gt;delete this;&lt;/code&gt; 것이 가능하다 ; 그러나 프로그램이 객체가 &lt;code&gt;new&lt;/code&gt; 에 의해 할당되었다는 것을 보장 할 수 있다면, &lt;code&gt;this&lt;/code&gt; 포인터 자체를 포함하여 할당 해제 된 객체에 대한 모든 포인터가 유효하지 않게 됩니다 &lt;code&gt;delete this;&lt;/code&gt; (이 내재적 역 참조 포함하기 때문에 수익률은 같은 멤버 함수는 클래스의 멤버를 참조 할 수 없습니다 &lt;code&gt;this&lt;/code&gt; )와 다른 멤버 함수를 호출 할 수 없습니다. 예를 들어 관리 대상 개체에 대한 마지막 참조가 범위를 벗어난 경우 참조 카운트를 감소시키는 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 제어 블록의 멤버 함수에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f49e2aea7f63f794694b0764f8e62bb0888805b" translate="yes" xml:space="preserve">
          <source>It is safe, and in fact, preferable in generic code, to use deduction to forwarding reference, &lt;code&gt;for (auto&amp;amp;&amp;amp; var : sequence)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for (auto&amp;amp;&amp;amp; var : sequence)&lt;/code&gt; 포워딩 참조에 추론을 사용하는 것이 안전하고 실제로 일반 코드에서 선호됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f58e92744c1e3c6d83adcd0474626686db527bd" translate="yes" xml:space="preserve">
          <source>It is said that a converting constructor specifies an implicit conversion from the types of its arguments (if any) to the type of its class. Note that non-explicit &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; also specifies an implicit conversion.</source>
          <target state="translated">변환 생성자는 인수 유형 (있는 경우)에서 클래스 유형으로의 암시 적 변환을 지정한다고합니다. 비명 시적 &lt;a href=&quot;cast_operator&quot;&gt;사용자 정의 변환 함수&lt;/a&gt; 는 또한 암시 적 변환을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="edfaaadef05ca0b8cdce0f012fc27fee94079175" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to ensure that &lt;code&gt;std::string_view&lt;/code&gt; does not outlive the pointed-to character array:</source>
          <target state="translated">&lt;code&gt;std::string_view&lt;/code&gt; 가 지정된 문자 배열보다 오래 걸리지 않도록하는 것은 프로그래머의 책임입니다 .</target>
        </trans-unit>
        <trans-unit id="a4d949d7d8bd7c5ac1b3559c799fce0b606f5cea" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to ensure that the &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; object passed to the iterator's constructor outlives the iterator. Because the iterator stores a &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; which stores a pointer to the regex, incrementing the iterator after the regex was destroyed results in undefined behavior.</source>
          <target state="translated">반복자의 생성자에 전달 된 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; 객체가 반복자보다 오래 지속 되도록하는 것은 프로그래머의 책임 입니다. 반복자는 정규식에 대한 포인터를 저장하는 &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; 를 저장하므로 정규식이 삭제 된 후 반복기를 증가 시키면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5d0ef4a8a26d0c98d105421ede3ede0ed4125959" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to ensure that the &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; object passed to the iterator's constructor outlives the iterator. Because the iterator stores a pointer to the regex, incrementing the iterator after the regex was destroyed accesses a dangling pointer.</source>
          <target state="translated">반복자의 생성자에 전달 된 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; 객체가 반복자보다 오래 지속 되도록하는 것은 프로그래머의 책임 입니다. 반복자가 정규식에 대한 포인터를 저장하므로 정규식이 삭제 된 후 반복자를 증가 시키면 매달려 포인터에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="8ae84d20cf6f06aca28cb06cdba2bd625fad38b1" translate="yes" xml:space="preserve">
          <source>It is undefined behavior to reuse storage that is or was occupied by a const complete object of static, thread-local, or automatic storage duration because such objects may be stored in read-only memory.</source>
          <target state="translated">정적, 스레드 로컬 또는 자동 스토리지 기간의 const 완료 오브젝트가 차지하거나 차지한 스토리지를 재사용하는 것은 정의되지 않은 동작입니다. 이러한 오브젝트는 읽기 전용 메모리에 저장 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="48d04478371a33f8869a2e04a1a90a78036dbfec" translate="yes" xml:space="preserve">
          <source>It is unspecified how the implementation makes these adjustments. This means that a compiler may call an implementation-specific search function, in which case a user-defined specialization of &lt;code&gt;regex_search&lt;/code&gt; will not be called.</source>
          <target state="translated">구현에서 이러한 조정을 수행하는 방법은 지정되지 않았습니다. 이것은 컴파일러가 구현 별 검색 기능을 호출 할 수 있음을 의미하며,이 경우 사용자 정의 &lt;code&gt;regex_search&lt;/code&gt; 전문화 가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7589f89a7b5d81e1f9bfdc1b0ceb532d0fc8435" translate="yes" xml:space="preserve">
          <source>It is unspecified when the past-the-end iterator is invalidated.</source>
          <target state="translated">과거의 이터레이터가 무효화되면 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="326b1cd1f8d02d7684396bd886d2e1c17251cc10" translate="yes" xml:space="preserve">
          <source>It is unspecified whether &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; is actually included when the standard library functions perform the swap, so the user-provided &lt;code&gt;swap()&lt;/code&gt; should not expect it to be included.</source>
          <target state="translated">표준 라이브러리 함수가 스왑을 수행 할 때 &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; 가 실제로 포함 되는지 여부는 지정되지 않으므로 사용자가 제공 한 &lt;code&gt;swap()&lt;/code&gt; 은 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c08baf030a373796ca075a1cddf067e089df15bb" translate="yes" xml:space="preserve">
          <source>It is unspecified whether library versions of &lt;code&gt;operator new&lt;/code&gt; make any calls to &lt;code&gt;&lt;a href=&quot;../c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;or &lt;code&gt;&lt;a href=&quot;../c/aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt;(since C++17).</source>
          <target state="translated">&lt;code&gt;operator new&lt;/code&gt; 라이브러리 버전이 &lt;code&gt;&lt;a href=&quot;../c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../c/aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt; (C ++ 17부터)을 호출 하는지 여부는 지정되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="a4ad188c2e57b182fa5e3f165eb2ba5d04005026" translate="yes" xml:space="preserve">
          <source>It is unspecified whether the destructor for the object referred to by &lt;code&gt;typeid&lt;/code&gt; is executed at the end of the program.</source>
          <target state="translated">&lt;code&gt;typeid&lt;/code&gt; 가 참조하는 오브젝트의 소멸자 가 프로그램 종료시 실행 되는지 여부는 지정되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="ba80c2d544e0bc888b885567b5eaf901bde4dfd1" translate="yes" xml:space="preserve">
          <source>It is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined copy assignment operator (same applies to &lt;a href=&quot;move_operator&quot;&gt;move assignment&lt;/a&gt;).</source>
          <target state="translated">상속 격자에서 둘 이상의 경로를 통해 액세스 할 수있는 가상 기본 클래스 서브 오브젝트가 내재적으로 정의 된 복사 지정 연산자에 의해 두 번 이상 지정되는지 여부는 지정되지 않습니다 ( &lt;a href=&quot;move_operator&quot;&gt;이동 지정&lt;/a&gt; 에도 동일 함 ).</target>
        </trans-unit>
        <trans-unit id="95593cbb778289249ae714a71b756ce2cf19a0ff" translate="yes" xml:space="preserve">
          <source>It is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined move assignment operator (same applies to &lt;a href=&quot;as_operator&quot;&gt;copy assignment&lt;/a&gt;).</source>
          <target state="translated">상속 격자에서 둘 이상의 경로를 통해 액세스 할 수있는 가상 기본 클래스 서브 오브젝트가 내재적으로 정의 된 이동 지정 연산자에 의해 두 번 이상 지정되는지 여부는 지정되지 않습니다 ( &lt;a href=&quot;as_operator&quot;&gt;복사 지정&lt;/a&gt; 에도 동일 함 ).</target>
        </trans-unit>
        <trans-unit id="923b1d52d8265df676c6882541dea0ee1c7e5835" translate="yes" xml:space="preserve">
          <source>It is unspecified whether virtual base subobjects are compared more than once.</source>
          <target state="translated">가상 기본 하위 오브젝트가 두 번 이상 비교되는지 여부는 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b0253dc9c61d1b681c7e56bf36a208e187bd7459" translate="yes" xml:space="preserve">
          <source>It is up to the program to ensure that the alignment assumption actually holds. A call to &lt;code&gt;assume_aligned&lt;/code&gt; does not cause the compiler to verify or enforce this.</source>
          <target state="translated">정렬 가정이 실제로 유지되도록하는 것은 프로그램에 달려 있습니다. &lt;code&gt;assume_aligned&lt;/code&gt; 를 호출한다고 해서 컴파일러가이를 확인하거나 시행하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="c454768f7ee08c8dd39602a9d383338c66d1c6a9" translate="yes" xml:space="preserve">
          <source>It is used to represent offsets from stream positions (values of type &lt;code&gt;&lt;a href=&quot;fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;std::streamoff&lt;/code&gt; value of &lt;code&gt;-1&lt;/code&gt; is also used to represent error conditions by some of the I/O library functions.</source>
          <target state="translated">스트림 위치의 오프셋 ( &lt;code&gt;&lt;a href=&quot;fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; 유형의 값)을 나타내는 데 사용됩니다 . &lt;code&gt;-1&lt;/code&gt; 의 &lt;code&gt;std::streamoff&lt;/code&gt; 값은 일부 I / O 라이브러리 함수에 의한 오류 조건을 나타내는 데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc825523729ab0100d6865928993fc1eba1d20c0" translate="yes" xml:space="preserve">
          <source>It may be thrown by the member functions of &lt;code&gt;&lt;a href=&quot;../../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;, by &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stod&lt;/a&gt;&lt;/code&gt; families of functions, and by the bounds-checked member access functions (e.g. &lt;code&gt;&lt;a href=&quot;../../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../container/map/at&quot;&gt;std::map::at&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 의 멤버 함수 , &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stod&lt;/a&gt;&lt;/code&gt; 함수 패밀리 및 범위 확인 멤버 액세스 함수 (예 : &lt;code&gt;&lt;a href=&quot;../../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt; :)에 의해 발생 될 수 있습니다. at 및 &lt;code&gt;&lt;a href=&quot;../../container/map/at&quot;&gt;std::map::at&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e6c4c0849336c6395a555e7802361736a0a0c377" translate="yes" xml:space="preserve">
          <source>It may not be monotonic: on most systems, the system time can be adjusted at any moment. It is the only C++ clock that has the ability to map its time points to C-style time, and, therefore, to be displayed(until C++20).</source>
          <target state="translated">대부분의 시스템에서 시스템 시간은 언제든지 조정할 수 있습니다. 시간 포인트를 C 스타일 시간에 매핑하여 표시 할 수있는 유일한 C ++ 시계입니다 (C ++ 20까지).</target>
        </trans-unit>
        <trans-unit id="4ff81608e3ae9cd2b8502e188922f1126aed8496" translate="yes" xml:space="preserve">
          <source>It must have a &lt;code&gt;constexpr&lt;/code&gt; constructor that takes some implementation-defined literal type.</source>
          <target state="translated">구현 정의 리터럴 유형을 취하는 &lt;code&gt;constexpr&lt;/code&gt; 생성자가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a342065b388bf8640367f4a9dd97692d21114f7f" translate="yes" xml:space="preserve">
          <source>It owns the allocated memory and frees it on destruction, even if &lt;code&gt;deallocate&lt;/code&gt; has not been called for some of the allocated blocks.</source>
          <target state="translated">할당 된 블록 중 일부에 대해 할당 &lt;code&gt;deallocate&lt;/code&gt; 가 호출되지 않은 경우에도 할당 된 메모리를 소유하고 파기시이를 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="747d8a8f672f5ac61ae339d4eb41b3ce9338913c" translate="yes" xml:space="preserve">
          <source>It provides a way to seed a large number of random number engines or to seed a generator that requires a lot of entropy, given a small seed or a poorly distributed initial seed sequence.</source>
          <target state="translated">작은 시드 나 잘못 분포 된 초기 시드 시퀀스에서 많은 난수 엔진을 시드하거나 많은 엔트로피가 필요한 생성기를 시드하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="85a990d0ad9f04a8b78c0432369377fa53e60519" translate="yes" xml:space="preserve">
          <source>It provides the guarantee that all output made to the same final destination buffer (std::cout in the examples above) will be free of data races and will not be interleaved or garbled in any way, as long as every write to the that final destination buffer is made through (possibly different) instances of &lt;code&gt;std::basic_osyncstream&lt;/code&gt;.</source>
          <target state="translated">동일한 최종 대상 버퍼 (위의 예에서 std :: cout)에 대한 모든 출력에 데이터 레이스가없고 해당 최종에 대한 모든 쓰기가 수행되는 한 어떠한 방식으로도 인터리브 또는 왜곡되지 않도록 보장합니다. 대상 버퍼는 &lt;code&gt;std::basic_osyncstream&lt;/code&gt; 인스턴스를 통해 만들어집니다 (아마도 다름) .</target>
        </trans-unit>
        <trans-unit id="0cdae659e4031c70f43c202403b0e9b266332015" translate="yes" xml:space="preserve">
          <source>It returns the iterator itself, which makes it possible to use code such as &lt;code&gt;*iter = value&lt;/code&gt; to output (insert) the value into the underlying container.</source>
          <target state="translated">이터레이터 자체를 리턴하므로 &lt;code&gt;*iter = value&lt;/code&gt; 와 같은 코드를 사용 하여 기본 컨테이너에 값 을 출력 (삽입) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e71ff091467aa53e4a20b3c8e2eb730c31146dd" translate="yes" xml:space="preserve">
          <source>It returns the iterator itself, which makes it possible to use code such as &lt;code&gt;*iter = value&lt;/code&gt; to output (insert) the value into the underlying stream.</source>
          <target state="translated">반복자 자체를 리턴하므로 &lt;code&gt;*iter = value&lt;/code&gt; 와 같은 코드를 사용 하여 값을 기본 스트림에 출력 (삽입) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bcdb39cfdb013b01f34aa6003e5bc508f218b9f" translate="yes" xml:space="preserve">
          <source>It's unspecified if these functions zero out the fields in &lt;code&gt;*t&lt;/code&gt; that they do not set directly: portable programs should initialize every field to zero before calling &lt;code&gt;get()&lt;/code&gt;.</source>
          <target state="translated">이러한 함수가 &lt;code&gt;*t&lt;/code&gt; 에서 직접 설정하지 않은 필드를 제로화하면 지정되지 않습니다. 이식 가능한 프로그램은 &lt;code&gt;get()&lt;/code&gt; 호출하기 전에 모든 필드를 0으로 초기화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="091b8d78ec3176b66348479ab0a7eba113756aa7" translate="yes" xml:space="preserve">
          <source>Iter</source>
          <target state="translated">Iter</target>
        </trans-unit>
        <trans-unit id="eaad30c6c7239ee4988afc79198142d6357df99b" translate="yes" xml:space="preserve">
          <source>Iteration statements</source>
          <target state="translated">반복문</target>
        </trans-unit>
        <trans-unit id="3e6a261991d848c9d7f1a6f775a1646474ac0d8e" translate="yes" xml:space="preserve">
          <source>Iteration statements repeatedly execute some code.</source>
          <target state="translated">반복문은 반복적으로 일부 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="4dee12b442c04cdb4820f91dbc5c57a6bfcea0f2" translate="yes" xml:space="preserve">
          <source>Iterator adaptors</source>
          <target state="translated">반복자 어댑터</target>
        </trans-unit>
        <trans-unit id="4d118461fd53be5789511318e9a62fde653cd961" translate="yes" xml:space="preserve">
          <source>Iterator associated types</source>
          <target state="translated">반복기 관련 유형</target>
        </trans-unit>
        <trans-unit id="7dfb7f0ff3c8f35daf7e4c6ffdf06bc0e90e799b" translate="yes" xml:space="preserve">
          <source>Iterator categories</source>
          <target state="translated">반복자 범주</target>
        </trans-unit>
        <trans-unit id="4f31e7d075beed31a4d019c7620a3efff3cce0c6" translate="yes" xml:space="preserve">
          <source>Iterator category</source>
          <target state="translated">반복자 범주</target>
        </trans-unit>
        <trans-unit id="45c0e163119730d64e4e88a9e88e486c24564923" translate="yes" xml:space="preserve">
          <source>Iterator category tags carry information that can be used to select the most efficient algorithms for the specific requirement set that is implied by the category.</source>
          <target state="translated">반복자 카테고리 태그에는 카테고리가 암시하는 특정 요구 사항 세트에 대해 가장 효율적인 알고리즘을 선택하는 데 사용할 수있는 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f22a4cac482679567538d501753a8d2f46eb0e0" translate="yes" xml:space="preserve">
          <source>Iterator concepts</source>
          <target state="translated">반복자 개념</target>
        </trans-unit>
        <trans-unit id="740d1be15d7c47c82fc9496173a7a69a59de33d0" translate="yes" xml:space="preserve">
          <source>Iterator customization points</source>
          <target state="translated">반복자 사용자 정의 지점</target>
        </trans-unit>
        <trans-unit id="e2f44595e956bf36ac4508978a8443a14cf70b6e" translate="yes" xml:space="preserve">
          <source>Iterator following the last removed element. If the iterator &lt;code&gt;pos&lt;/code&gt; refers to the last element, the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator is returned.</source>
          <target state="translated">마지막으로 제거 된 요소 다음의 반복자입니다. 반복자 &lt;code&gt;pos&lt;/code&gt; 가 마지막 요소를 참조하면 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 반복자가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0451248583f78c974b012649cf5f233b3518219f" translate="yes" xml:space="preserve">
          <source>Iterator in the destination range, pointing at the last element moved.</source>
          <target state="translated">마지막으로 이동 한 요소를 가리키는 대상 범위의 반복자.</target>
        </trans-unit>
        <trans-unit id="40bd84a12b0a1ba291337eb5470a260a83e5f5e0" translate="yes" xml:space="preserve">
          <source>Iterator in the destination range, pointing past the last element copied if &lt;code&gt;count&amp;gt;0&lt;/code&gt; or &lt;code&gt;result&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;count&amp;gt;0&lt;/code&gt; 또는 그렇지 않으면 &lt;code&gt;result&lt;/code&gt; 경우 복사 된 마지막 요소를 지나서 대상 범위의 반복자 .</target>
        </trans-unit>
        <trans-unit id="ca76fdc86a85ddcf65acd3db20c917b98cafb8cc" translate="yes" xml:space="preserve">
          <source>Iterator invalidation</source>
          <target state="translated">반복자 무효화</target>
        </trans-unit>
        <trans-unit id="281878789a9bcc6f2d63b03ac4ff75d8b3e62807" translate="yes" xml:space="preserve">
          <source>Iterator library</source>
          <target state="translated">반복자 라이브러리</target>
        </trans-unit>
        <trans-unit id="03896d2a57195b9fd730686c9c0802a354747640" translate="yes" xml:space="preserve">
          <source>Iterator one past the last element assigned if &lt;code&gt;count &amp;gt; 0&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;count &amp;gt; 0&lt;/code&gt; 인 경우 마지막으로 지정된 요소를 반복하는 반복자 , 그렇지 않은 경우 &lt;code&gt;first&lt;/code&gt; 반복자 .</target>
        </trans-unit>
        <trans-unit id="daf74fe0d4457d50bd01e94a09fc1b13a7e9ff50" translate="yes" xml:space="preserve">
          <source>Iterator one past the last element assigned if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;count&amp;gt;0&lt;/code&gt; 인 경우 마지막으로 지정된 요소를 반복하는 반복자 , 그렇지 않은 경우 &lt;code&gt;first&lt;/code&gt; 반복자 .</target>
        </trans-unit>
        <trans-unit id="2663ac3786b007e1d7f5bd8a7c0213e70730b1d7" translate="yes" xml:space="preserve">
          <source>Iterator operations</source>
          <target state="translated">반복자 작업</target>
        </trans-unit>
        <trans-unit id="f4dd65c96326a21c8c14e8530698df94d1156bd2" translate="yes" xml:space="preserve">
          <source>Iterator operations (e.g. incrementing an iterator) read, but do not modify the underlying container, and may be executed concurrently with operations on other iterators on the same container, with the const member functions, or reads from the elements. Container operations that invalidate any iterators modify the container and cannot be executed concurrently with any operations on existing iterators even if those iterators are not invalidated.</source>
          <target state="translated">반복자 조작 (예 : 반복자 증가)은 기본 컨테이너를 읽지 않지만 수정하지는 않으며 동일한 컨테이너의 다른 반복자에 대한 조작과 const 멤버 함수를 사용하거나 요소에서 읽습니다. 반복자를 무효화하는 컨테이너 작업은 컨테이너를 수정하며 해당 반복자가 무효화되지 않더라도 기존 반복자에 대한 작업과 동시에 실행될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d40f4ce641e0ed75eeba005dc0c9d3144fe2cd68" translate="yes" xml:space="preserve">
          <source>Iterator past the end of the constructed range.</source>
          <target state="translated">생성 된 범위의 끝을 지나는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="13fa518a2303933b7f035ca34918a1466f897682" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was parsed successfully.</source>
          <target state="translated">성공적으로 구문 분석 된 &lt;code&gt;[beg, end)&lt;/code&gt; 의 마지막 문자를 지나는 반복자를 반복 합니다.</target>
        </trans-unit>
        <trans-unit id="8307d2d53c29a25c0e984348242a9471e3ee81a1" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was recognized as a part of a valid date.</source>
          <target state="translated">유효한 날짜의 일부로 인식 된 &lt;code&gt;[beg, end)&lt;/code&gt; 의 마지막 문자를 지나는 하나를 가리키는 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="f64d4fa39c12455a17caddb09b8107c7a4df881a" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was recognized as a part of a valid month name.</source>
          <target state="translated">유효한 월 이름의 일부로 인식 된 &lt;code&gt;[beg, end)&lt;/code&gt; 의 마지막 문자를 지나는 하나를 가리키는 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="31e9b344102f3edc337a21ee322aadf820b9757e" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was recognized as a part of a valid weekname.</source>
          <target state="translated">올바른 주 이름의 일부로 인식 된 &lt;code&gt;[beg, end)&lt;/code&gt; 의 마지막 문자를 지나는 하나를 가리키는 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="31207a4529bcf9380d04c9069cc1655551460207" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was recognized as a part of a valid year.</source>
          <target state="translated">유효한 연도의 일부로 인식 된 &lt;code&gt;[beg, end)&lt;/code&gt; 의 마지막 문자를 지나는 하나를 가리키는 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="7f09da5861ec2d1af9b0e94d0a6f97c745163842" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character that was produced .</source>
          <target state="translated">마지막으로 생성 된 문자를 지나는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="2cbfd446fa55ac919f1565a7433ab297897ff7cd" translate="yes" xml:space="preserve">
          <source>Iterator pointing to the emplaced element.</source>
          <target state="translated">배치 된 요소를 가리키는 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="3f31d65a0a3b3c0a3916fdb12c528f4639b09cbb" translate="yes" xml:space="preserve">
          <source>Iterator pointing to the first element that is</source>
          <target state="translated">첫 번째 요소를 가리키는 반복자</target>
        </trans-unit>
        <trans-unit id="be0840eb05b1b352b3e742ca7bea27adaa5d7b17" translate="yes" xml:space="preserve">
          <source>Iterator pointing to the first element that is not</source>
          <target state="translated">아닌 첫 번째 요소를 가리키는 반복자</target>
        </trans-unit>
        <trans-unit id="e185fa2c4bb3e71229767b9d27a937494c54ba69" translate="yes" xml:space="preserve">
          <source>Iterator primitives</source>
          <target state="translated">반복자 프리미티브</target>
        </trans-unit>
        <trans-unit id="10484316b5b2a8004d6321237a6c2d261f03e5f9" translate="yes" xml:space="preserve">
          <source>Iterator tags</source>
          <target state="translated">반복자 태그</target>
        </trans-unit>
        <trans-unit id="ae607ca99d952a6e9f09c84027726aaa7bfec65b" translate="yes" xml:space="preserve">
          <source>Iterator to an element with key equivalent to &lt;code&gt;key&lt;/code&gt;. If no such element is found, past-the-end (see &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt;) iterator is returned.</source>
          <target state="translated">열쇠 동등한 요소에 반복자 &lt;code&gt;key&lt;/code&gt; . 그러한 요소를 찾지 못하면 과거 ( &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 참조 ) 반복자가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9278ea56b5788d570f426ec7cbcb9a565e893cd1" translate="yes" xml:space="preserve">
          <source>Iterator to one past the last element of &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">의 마지막 요소 지난 1에 반복자 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b813a67f31fb479727b79b93d1bb1438b02ec92e" translate="yes" xml:space="preserve">
          <source>Iterator to one past the last value in the numeric array.</source>
          <target state="translated">숫자 형 배열의 마지막 값을지나 1 회 반복합니다.</target>
        </trans-unit>
        <trans-unit id="b07ec936a0496c6833779c2921debff842152dd7" translate="yes" xml:space="preserve">
          <source>Iterator to the beginning of last occurrence of the sequence &lt;code&gt;[s_first, s_last)&lt;/code&gt; in range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위에서 &lt;code&gt;[s_first, s_last)&lt;/code&gt; 시퀀스의 마지막 발생 시작까지 반복자 .</target>
        </trans-unit>
        <trans-unit id="cea2fc59b7d3bb9197c3cb893d4095461e65324e" translate="yes" xml:space="preserve">
          <source>Iterator to the beginning of the found sequence in the range &lt;code&gt;[first, last)&lt;/code&gt;. If no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위에서 찾은 시퀀스의 시작 부분에 대한 반복자 입니다. 이러한 순서를 찾지 못하면 &lt;code&gt;last&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b99865a2f5ee2de11db467c05b05ecda3a38125e" translate="yes" xml:space="preserve">
          <source>Iterator to the element before the first element.</source>
          <target state="translated">첫 번째 요소 앞의 요소에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="aacd4e93e79a35d8d4d88a56fccd361ca76b515c" translate="yes" xml:space="preserve">
          <source>Iterator to the element following the last element.</source>
          <target state="translated">마지막 요소 다음의 요소에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="d47c96b870ac902b9cfccfbc43f02d3063565e47" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last element copied.</source>
          <target state="translated">마지막으로 복사 한 요소를 지난 요소에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="96509680368807f6fc1a0194dd4883b178732836" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last element exchanged in the range beginning with &lt;code&gt;first2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;first2&lt;/code&gt; 로 시작하는 범위에서 교환 된 마지막 요소 이후의 요소에 대한 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="7a39ffa9063e11b7b654f129a912184da2ac6267" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last element moved.</source>
          <target state="translated">마지막으로 이동 한 요소 이후의 요소에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="1b5d7dd5569e766929089fcefe6c58bc9d731aa5" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last element written.</source>
          <target state="translated">마지막으로 쓴 요소를 지난 요소에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="6bea32d087ab585bed1f7fe96375cf86af1211fa" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last sub-match.</source>
          <target state="translated">마지막 하위 일치를 지난 요소에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="60a6218c749d504f60e9f3fa5bf31fa53f0671ac" translate="yes" xml:space="preserve">
          <source>Iterator to the first element in the range &lt;code&gt;[first, last)&lt;/code&gt; that is equal to an element from the range &lt;code&gt;[s_first; s_last)&lt;/code&gt;. If no such element is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;[s_first; s_last)&lt;/code&gt; 범위의 요소와 동일한 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 첫 번째 요소에 대한 반복자입니다. s_last) . 그러한 요소가 없으면 &lt;code&gt;last&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="744169b8a1b971b02107d9fd30c4e5ed51e12ef8" translate="yes" xml:space="preserve">
          <source>Iterator to the first element of &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">첫 번째 요소에 &lt;code&gt;a&lt;/code&gt; 반복자</target>
        </trans-unit>
        <trans-unit id="e5fdfe83ec17cb438ffef8507e749f160d782415" translate="yes" xml:space="preserve">
          <source>Iterator to the first element of the second group.</source>
          <target state="translated">두 번째 그룹의 첫 번째 요소에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="1cbe4199bf321f6884c70afda2be99aff476ac84" translate="yes" xml:space="preserve">
          <source>Iterator to the first element satisfying the condition or &lt;code&gt;last&lt;/code&gt; if no such element is found.</source>
          <target state="translated">조건을 만족하는 첫 번째 요소에 대한 반복자 또는 해당 요소가없는 경우 &lt;code&gt;last&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4b75fadcd5e3ebde98aa445d8daad03877fd6a8" translate="yes" xml:space="preserve">
          <source>Iterator to the first element.</source>
          <target state="translated">첫 번째 요소에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="55aa966d43052a99cbd2f2b66a9a360393c342eb" translate="yes" xml:space="preserve">
          <source>Iterator to the first sub-match.</source>
          <target state="translated">첫 번째 하위 일치 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="5580fefb10d0046c754d643bd5733ccca8b1345e" translate="yes" xml:space="preserve">
          <source>Iterator to the first value in the numeric array.</source>
          <target state="translated">숫자 형 배열의 첫 번째 값에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="ea592c537962f37901180bcbeecea954bf89d9fa" translate="yes" xml:space="preserve">
          <source>Iterator to the greatest element in the range &lt;code&gt;[first, last)&lt;/code&gt;. If several elements in the range are equivalent to the greatest element, returns the iterator to the first such element. Returns &lt;code&gt;last&lt;/code&gt; if the range is empty.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위에서 가장 큰 요소에 대한 반복자 입니다. 범위 내의 여러 요소가 가장 큰 요소와 동일한 경우 반복자를 첫 번째 요소로 리턴합니다. 범위가 비어 있으면 &lt;code&gt;last&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cab09d343a65548dadf0705016f36b2bc1aec5ff" translate="yes" xml:space="preserve">
          <source>Iterator to the smallest element in the range &lt;code&gt;[first, last)&lt;/code&gt;. If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns &lt;code&gt;last&lt;/code&gt; if the range is empty.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위에서 가장 작은 요소에 대한 반복자 입니다. 범위 내의 여러 요소가 가장 작은 요소와 동일한 경우 반복자를 첫 번째 요소로 리턴합니다. 범위가 비어 있으면 &lt;code&gt;last&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="162032b2b677de764fe8e5f27091a7c4e6a44150" translate="yes" xml:space="preserve">
          <source>Iterators and references to the erased element are invalidated. If the element is the last element in the container, the past-the-end iterator is also invalidated. Other references and iterators are not affected.</source>
          <target state="translated">지워진 요소에 대한 반복자와 참조가 무효화됩니다. 요소가 컨테이너의 마지막 요소 인 경우, 과거의 반복자도 무효화됩니다. 다른 참조 및 반복자는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e582a97f0f7104a2e13358f17facd4235fcb6d40" translate="yes" xml:space="preserve">
          <source>Iterators and references to the erased element are invalidated. It is unspecified whether the past-the-end iterator is invalidated if the element is the last element in the container. Other references and iterators are not affected.</source>
          <target state="translated">지워진 요소에 대한 반복자와 참조가 무효화됩니다. 요소가 컨테이너의 마지막 요소 인 경우 과거 반복자가 무효화되는지 여부는 지정되지 않습니다. 다른 참조 및 반복자는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c5b6d9e93629888dbe6bf92a0305e9d1ac53f56" translate="yes" xml:space="preserve">
          <source>Iterators and references to the erased element are invalidated. It is unspecified whether the past-the-end iterator is invalidated. Other references and iterators are not affected.</source>
          <target state="translated">지워진 요소에 대한 반복자와 참조가 무효화됩니다. 과거의 이터레이터가 무효화되는지 여부는 지정되지 않습니다. 다른 참조 및 반복자는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="420aea18856c45985924dcd36529cee071e75fd3" translate="yes" xml:space="preserve">
          <source>Iterators and references to the erased element are invalidated. The past-the-end iterator is also invalidated. Other references and iterators are not affected.</source>
          <target state="translated">지워진 요소에 대한 반복자와 참조가 무효화됩니다. 과거의 이터레이터도 무효화됩니다. 다른 참조 및 반복자는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f88e8afffd84ac565f746527f36f9909c4f45150" translate="yes" xml:space="preserve">
          <source>Iterators are not dereferenceable if.</source>
          <target state="translated">반복자는 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="05eeb7b671baac73a3dc80180a6545670e55373f" translate="yes" xml:space="preserve">
          <source>Iterators for which the behavior of the expression &lt;code&gt;*i&lt;/code&gt; is defined are called</source>
          <target state="translated">표현식 &lt;code&gt;*i&lt;/code&gt; 의 동작 이 정의 된 반복자를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="6d7e7b94342bc88f5dc26254b6ed839ec8bfb385" translate="yes" xml:space="preserve">
          <source>Iterators library</source>
          <target state="translated">반복자 라이브러리</target>
        </trans-unit>
        <trans-unit id="7987698c6d69adbd970dfb91d269e601291f3c2e" translate="yes" xml:space="preserve">
          <source>Iterators that fall into one of the above categories and also meet the requirements of &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; are called contiguous iterators.</source>
          <target state="translated">위의 범주 중 하나에 속하고 &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; 의 요구 사항을 충족하는 반복자를 연속 반복 자라고 합니다.</target>
        </trans-unit>
        <trans-unit id="c0510377d9129680624a5c7430c75a54b51eeddb" translate="yes" xml:space="preserve">
          <source>Iterators that fall into one of the above categories and also meet the requirements of &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; are called mutable iterators.</source>
          <target state="translated">위의 범주 중 하나에 속하고 &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; 의 요구 사항을 충족하는 반복자를 변경 가능한 반복 자라고 합니다.</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="273fff5103ab0399a739b1cec1bc3d252efc223f" translate="yes" xml:space="preserve">
          <source>JAPANESE INDUSTRIAL STANDARD SYMBOL - IDEOGRAPHIC NUMBER ZERO</source>
          <target state="translated">일본 산업 표준 기호-사상 수 제로</target>
        </trans-unit>
        <trans-unit id="6c943af0faee20a16a4d1c5eaf93012533909700" translate="yes" xml:space="preserve">
          <source>Jacobi amplitude (a value of floating-point or integral type, measured in radians)</source>
          <target state="translated">자코비 진폭 (라디안으로 측정 된 부동 소수점 또는 정수 유형의 값)</target>
        </trans-unit>
        <trans-unit id="bdfb777e0387993e2e3d113ac36512201456491d" translate="yes" xml:space="preserve">
          <source>Jump statements</source>
          <target state="translated">점프 진술</target>
        </trans-unit>
        <trans-unit id="bb520de1f12d4fa9ce54eeee10e58e891322ab58" translate="yes" xml:space="preserve">
          <source>Jump statements unconditionally transfer flow control.</source>
          <target state="translated">점프 문은 무조건 전송 흐름 제어를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="dcbf88c31714264b514798a7ba1a0f7ac134056f" translate="yes" xml:space="preserve">
          <source>Just as with a traditional loop, a &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used to exit the loop early and a &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used to restart the loop with the next element.</source>
          <target state="translated">기존 루프와 마찬가지로 &lt;a href=&quot;break&quot;&gt;break 문&lt;/a&gt; 을 사용하여 루프를 일찍 종료하고 &lt;a href=&quot;continue&quot;&gt;continue 문&lt;/a&gt; 을 사용하여 다음 요소로 루프를 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36d6db48eace81a33b705adbb64b285f0559048e" translate="yes" xml:space="preserve">
          <source>Just before becoming the end-of-sequence iterator, a &lt;code&gt;std::regex_token_iterator&lt;/code&gt; may become a</source>
          <target state="translated">시퀀스 종료 반복자가되기 직전에 &lt;code&gt;std::regex_token_iterator&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="c59dd0c7462928fa236b7f578176acd87d90eab2" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::packaged_task&lt;/code&gt; is a polymorphic, allocator-aware container: the stored callable target may be allocated on heap or with a provided allocator.</source>
          <target state="translated">마찬가지로 &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::packaged_task&lt;/code&gt; 다형성, 할당 인식 컨테이너 : 저장된 호출 대상이 힙 또는 제공 할당 할당 할 수있다.</target>
        </trans-unit>
        <trans-unit id="31d4b9f30362c85a4f4a427bba244a69e9b807a9" translate="yes" xml:space="preserve">
          <source>Just like in &lt;a href=&quot;classes&quot;&gt;struct&lt;/a&gt; declaration, the default member access in a union is &lt;a href=&quot;access&quot;&gt;public&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;classes&quot;&gt;구조체&lt;/a&gt; 선언 과 마찬가지로 공용체의 기본 멤버 액세스는 &lt;a href=&quot;access&quot;&gt;public&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74e2c21175f1eb09564bc31283c20889926ace69" translate="yes" xml:space="preserve">
          <source>Just like with members of primary templates, they only need to be defined if used in the program.</source>
          <target state="translated">기본 템플릿의 멤버와 마찬가지로 프로그램에서 사용되는 경우에만 정의하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="0f2005c51f34f60847d9627b7dadf8093b2d0c22" translate="yes" xml:space="preserve">
          <source>K), GNSUM(op, a</source>
          <target state="translated">K), GNSUM (op, a</target>
        </trans-unit>
        <trans-unit id="237e3ecc9a063e55a6f9fd6d2f03d4b8adf12c9a" translate="yes" xml:space="preserve">
          <source>K), GSUM(op, b</source>
          <target state="translated">K), GSUM (op, b</target>
        </trans-unit>
        <trans-unit id="7e6d3d8f6e5c6078631d54fbfd4b0dea03e2e179" translate="yes" xml:space="preserve">
          <source>Keep the existing file, without reporting an error.</source>
          <target state="translated">오류를보고하지 않고 기존 파일을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="6f7fcc18225d37208291e381d4c7a5f47bd1ba73" translate="yes" xml:space="preserve">
          <source>LANGUAGE TAG (U+E0001) - VARIATION SELECTOR-256 (U+E01EF)</source>
          <target state="translated">언어 태그 (U + E0001)-변수 선택기 -256 (U + E01EF)</target>
        </trans-unit>
        <trans-unit id="503ecf5371128a4d54cb093dfb32e39ad03cc18f" translate="yes" xml:space="preserve">
          <source>LATIN CAPITAL LETTER A WITH GRAVE - LATIN CAPITAL LETTER O WITH DIAERESIS</source>
          <target state="translated">무덤이있는 라틴어 대문자 A-DIAERESIS가있는 라틴어 대문자 O</target>
        </trans-unit>
        <trans-unit id="cb668f2f6c1dafcf47fe99fa01b751c3e0263d0b" translate="yes" xml:space="preserve">
          <source>LATIN CAPITAL LETTER O WITH STROKE - LATIN SMALL LETTER O WITH DIAERESIS</source>
          <target state="translated">스트로크가있는 라틴 대문자 L-DIAERESIS가있는 라틴 대문자 O</target>
        </trans-unit>
        <trans-unit id="b2be5f99f56a223f3c293b996a761c0efa14627e" translate="yes" xml:space="preserve">
          <source>LATIN SMALL LETTER O WITH STROKE - CANADIAN SYLLABICS BLACKFOOT W</source>
          <target state="translated">스트로크가있는 라틴어 작은 편지 O-캐나다의 상징적 표현 BLACKFOOT W</target>
        </trans-unit>
        <trans-unit id="b4da84710b41fc09dd78f93b82fe6010bab5fd27" translate="yes" xml:space="preserve">
          <source>LC_ALLLC_COLLATELC_CTYPELC_MONETARYLC_NUMERICLC_TIME</source>
          <target state="translated">LC_ALLLC_COLLATELC_CTYPELC_MONETARYLC_NUMERICLC_TIME</target>
        </trans-unit>
        <trans-unit id="823feb18075201a2009bf899a2b4bee49397d8df" translate="yes" xml:space="preserve">
          <source>LC_TIME</source>
          <target state="translated">LC_TIME</target>
        </trans-unit>
        <trans-unit id="3fd1097fbc5a624096c5064ce332869e38dcdca6" translate="yes" xml:space="preserve">
          <source>LEFT-TO-RIGHT EMBEDDING - RIGHT-TO-LEFT OVERRIDE</source>
          <target state="translated">왼쪽에서 오른쪽으로 임베딩-오른쪽에서 왼쪽으로 오버라이드</target>
        </trans-unit>
        <trans-unit id="0ada04f560eef4501438475ec6acb0a8112461d2" translate="yes" xml:space="preserve">
          <source>LINEAR B SYLLABLE B008 A - CHEESE WEDGE (U+1F9C0)</source>
          <target state="translated">리니어 B SYLLABLE B008 A-치즈 웨지 (U + 1F9C0)</target>
        </trans-unit>
        <trans-unit id="65a740810ab447ffb984bd6fdf5448611bcca5d2" translate="yes" xml:space="preserve">
          <source>LLP64</source>
          <target state="translated">LLP64</target>
        </trans-unit>
        <trans-unit id="7ec33462cf14446f400924757e3fbb4271e0e95e" translate="yes" xml:space="preserve">
          <source>LLVM libc++ stores 1 less member: it maintains the rdbuf pointer as a void* member of ios_base.</source>
          <target state="translated">LLVM libc ++는 1 개의 적은 멤버를 저장합니다. rdbuf 포인터를 ios_base의 void * 멤버로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="bee2cfeb49f65a60be1386935bbd919b5ec97964" translate="yes" xml:space="preserve">
          <source>LP32</source>
          <target state="translated">LP32</target>
        </trans-unit>
        <trans-unit id="6cb8b2a9a5c6dacaca21f4343040021510d35c97" translate="yes" xml:space="preserve">
          <source>LP64</source>
          <target state="translated">LP64</target>
        </trans-unit>
        <trans-unit id="886ea7c4764552dcb2bbbe1db0b81daf2c0b4980" translate="yes" xml:space="preserve">
          <source>LWG 103</source>
          <target state="translated">LWG 103</target>
        </trans-unit>
        <trans-unit id="9de8fb82db7ea881cdd4818eeacc5cb88103d780" translate="yes" xml:space="preserve">
          <source>LWG 2021</source>
          <target state="translated">LWG 2021</target>
        </trans-unit>
        <trans-unit id="706cd71dbc70f54b74c9e4ca12893e72483f65ac" translate="yes" xml:space="preserve">
          <source>LWG 2048</source>
          <target state="translated">LWG 2048</target>
        </trans-unit>
        <trans-unit id="389f244b561a8b2e450ab0c1b620aab9c04f7844" translate="yes" xml:space="preserve">
          <source>LWG 2063</source>
          <target state="translated">LWG 2063</target>
        </trans-unit>
        <trans-unit id="31dc00d2b0f8ffb9c931311abf894031771bb886" translate="yes" xml:space="preserve">
          <source>LWG 2067</source>
          <target state="translated">LWG 2067</target>
        </trans-unit>
        <trans-unit id="deb8bac4bda6e7ac7927ac3f217096d074e4651c" translate="yes" xml:space="preserve">
          <source>LWG 2101</source>
          <target state="translated">LWG 2101</target>
        </trans-unit>
        <trans-unit id="96c382be88841f29be2b8476fd6eff0e02b692b5" translate="yes" xml:space="preserve">
          <source>LWG 2111</source>
          <target state="translated">LWG 2111</target>
        </trans-unit>
        <trans-unit id="d6e902d68f062e389836f2f573f3f247e27c9102" translate="yes" xml:space="preserve">
          <source>LWG 2141</source>
          <target state="translated">LWG 2141</target>
        </trans-unit>
        <trans-unit id="723eb1c8bcf878531e1514ce67bc69259241d3c4" translate="yes" xml:space="preserve">
          <source>LWG 2193</source>
          <target state="translated">LWG 2193</target>
        </trans-unit>
        <trans-unit id="810962e6457ba64d5c3482fefe25972a3420fcff" translate="yes" xml:space="preserve">
          <source>LWG 2231</source>
          <target state="translated">LWG 2231</target>
        </trans-unit>
        <trans-unit id="07b5419b2eca5506d8ab14a0d772cee5a0b24141" translate="yes" xml:space="preserve">
          <source>LWG 2316</source>
          <target state="translated">LWG 2316</target>
        </trans-unit>
        <trans-unit id="234d204a978e35929b3a3e894af0d8b867af1065" translate="yes" xml:space="preserve">
          <source>LWG 2377</source>
          <target state="translated">LWG 2377</target>
        </trans-unit>
        <trans-unit id="0de14022bde80593834d413238d25e72ecbcc411" translate="yes" xml:space="preserve">
          <source>LWG 2396</source>
          <target state="translated">LWG 2396</target>
        </trans-unit>
        <trans-unit id="98c9816aa981f67350096307bddd08234109379b" translate="yes" xml:space="preserve">
          <source>LWG 2408</source>
          <target state="translated">LWG 2408</target>
        </trans-unit>
        <trans-unit id="88897052b0b54ca7be3e73d84b0b00921d9e552c" translate="yes" xml:space="preserve">
          <source>LWG 2420</source>
          <target state="translated">LWG 2420</target>
        </trans-unit>
        <trans-unit id="4df86d5ce11e282b81c2bbb5175527f98652fcef" translate="yes" xml:space="preserve">
          <source>LWG 2422</source>
          <target state="translated">LWG 2422</target>
        </trans-unit>
        <trans-unit id="84b18947260bfe1f0a5996d405140bb230ae0767" translate="yes" xml:space="preserve">
          <source>LWG 2441</source>
          <target state="translated">LWG 2441</target>
        </trans-unit>
        <trans-unit id="cbfcae2a308f80ed1c6f7b0aa1df94fb40aaf739" translate="yes" xml:space="preserve">
          <source>LWG 2442</source>
          <target state="translated">LWG 2442</target>
        </trans-unit>
        <trans-unit id="39d7d59672fbad6538e7af83c470ceced5e98772" translate="yes" xml:space="preserve">
          <source>LWG 2444</source>
          <target state="translated">LWG 2444</target>
        </trans-unit>
        <trans-unit id="64c015ca6fb365162de4d9802c96ff79810e3eba" translate="yes" xml:space="preserve">
          <source>LWG 2456</source>
          <target state="translated">LWG 2456</target>
        </trans-unit>
        <trans-unit id="479bc2ddf5e751a671056d086c6f5edd270c71fa" translate="yes" xml:space="preserve">
          <source>LWG 2458</source>
          <target state="translated">LWG 2458</target>
        </trans-unit>
        <trans-unit id="1edc38665e8899d906240e69ba2477977706ba89" translate="yes" xml:space="preserve">
          <source>LWG 2459</source>
          <target state="translated">LWG 2459</target>
        </trans-unit>
        <trans-unit id="6be2a0368db7a8aa977aee824cc855ad8d6cb8b3" translate="yes" xml:space="preserve">
          <source>LWG 2460</source>
          <target state="translated">LWG 2460</target>
        </trans-unit>
        <trans-unit id="40c67758d05b4454663ae12087f93b2294a7887e" translate="yes" xml:space="preserve">
          <source>LWG 2485</source>
          <target state="translated">LWG 2485</target>
        </trans-unit>
        <trans-unit id="ef5117f94807e8fa3fd3d6d510e7ee4f699f4b23" translate="yes" xml:space="preserve">
          <source>LWG 2510</source>
          <target state="translated">LWG 2510</target>
        </trans-unit>
        <trans-unit id="5f130db76eea1dbe14493e67e4a16dbe505a9e2e" translate="yes" xml:space="preserve">
          <source>LWG 2550</source>
          <target state="translated">LWG 2550</target>
        </trans-unit>
        <trans-unit id="ca02fd1a836a738f855f4be277ea46227c2c6ff3" translate="yes" xml:space="preserve">
          <source>LWG 2554</source>
          <target state="translated">LWG 2554</target>
        </trans-unit>
        <trans-unit id="41e9bbe3caae10f06305c082750ab7abc56ee095" translate="yes" xml:space="preserve">
          <source>LWG 2556</source>
          <target state="translated">LWG 2556</target>
        </trans-unit>
        <trans-unit id="a7fa4024fcd73ba7048d1081eb12cb834158b7ab" translate="yes" xml:space="preserve">
          <source>LWG 2597</source>
          <target state="translated">LWG 2597</target>
        </trans-unit>
        <trans-unit id="f677e3426681f881a680fe99e83000652b32a988" translate="yes" xml:space="preserve">
          <source>LWG 2682</source>
          <target state="translated">LWG 2682</target>
        </trans-unit>
        <trans-unit id="81d82ea92f45eea83f18af5577cc2d919bfe90d4" translate="yes" xml:space="preserve">
          <source>LWG 270</source>
          <target state="translated">LWG 270</target>
        </trans-unit>
        <trans-unit id="8e573b1dfb07e6658a7360ffdc338e9b3f93b49f" translate="yes" xml:space="preserve">
          <source>LWG 2735</source>
          <target state="translated">LWG 2735</target>
        </trans-unit>
        <trans-unit id="227dbdd98899cadd424a56e2f7d7d6a78f38856f" translate="yes" xml:space="preserve">
          <source>LWG 2739</source>
          <target state="translated">LWG 2739</target>
        </trans-unit>
        <trans-unit id="9eb33f94aa6faf46b0eb2f66260ee186604d4a50" translate="yes" xml:space="preserve">
          <source>LWG 2782</source>
          <target state="translated">LWG 2782</target>
        </trans-unit>
        <trans-unit id="d920e722f9f2beb6d3d46c97d699d7aca6281fdd" translate="yes" xml:space="preserve">
          <source>LWG 2783</source>
          <target state="translated">LWG 2783</target>
        </trans-unit>
        <trans-unit id="63dbc60824b85913f49c89b16c9025b3daf3402a" translate="yes" xml:space="preserve">
          <source>LWG 2843</source>
          <target state="translated">LWG 2843</target>
        </trans-unit>
        <trans-unit id="fdaad41a94231184e89d21323eb4df5beb258d0e" translate="yes" xml:space="preserve">
          <source>LWG 2870</source>
          <target state="translated">LWG 2870</target>
        </trans-unit>
        <trans-unit id="63de5c8018c8f07659e2254629b4ebfecbdf0e68" translate="yes" xml:space="preserve">
          <source>LWG 2901</source>
          <target state="translated">LWG 2901</target>
        </trans-unit>
        <trans-unit id="65a38639ef5dfa6b953951bf416dbef1b06d2565" translate="yes" xml:space="preserve">
          <source>LWG 2935</source>
          <target state="translated">LWG 2935</target>
        </trans-unit>
        <trans-unit id="8df8d07f79de7eff959bd46fc88293ce52ce6252" translate="yes" xml:space="preserve">
          <source>LWG 2936</source>
          <target state="translated">LWG 2936</target>
        </trans-unit>
        <trans-unit id="6af1a8a4fbc321bb616e82f22c084066312fc066" translate="yes" xml:space="preserve">
          <source>LWG 2937</source>
          <target state="translated">LWG 2937</target>
        </trans-unit>
        <trans-unit id="620d7168575a023def1c823681197877ef6db868" translate="yes" xml:space="preserve">
          <source>LWG 2942</source>
          <target state="translated">LWG 2942</target>
        </trans-unit>
        <trans-unit id="6ec364c67d40cf80dd78cca2c8063943882a4782" translate="yes" xml:space="preserve">
          <source>LWG 2945</source>
          <target state="translated">LWG 2945</target>
        </trans-unit>
        <trans-unit id="584b1cd1ca53e0a10c9c53d113a6c1b03f94da27" translate="yes" xml:space="preserve">
          <source>LWG 2946</source>
          <target state="translated">LWG 2946</target>
        </trans-unit>
        <trans-unit id="2092ab29c8ec4efb56008c5dbf84dd1a89910f85" translate="yes" xml:space="preserve">
          <source>LWG 2955</source>
          <target state="translated">LWG 2955</target>
        </trans-unit>
        <trans-unit id="db6b4c474d2b187cadd86c637f7b9a707deded5a" translate="yes" xml:space="preserve">
          <source>LWG 2956</source>
          <target state="translated">LWG 2956</target>
        </trans-unit>
        <trans-unit id="6651b628d955dbc375211fd9965b95e7828c0930" translate="yes" xml:space="preserve">
          <source>LWG 2969</source>
          <target state="translated">LWG 2969</target>
        </trans-unit>
        <trans-unit id="f25beb31bbd789f502c7039a906832b4193e490b" translate="yes" xml:space="preserve">
          <source>LWG 2974</source>
          <target state="translated">LWG 2974</target>
        </trans-unit>
        <trans-unit id="03b6470838ea079e5b35bdd7f4c0a4324f5be97c" translate="yes" xml:space="preserve">
          <source>LWG 2975</source>
          <target state="translated">LWG 2975</target>
        </trans-unit>
        <trans-unit id="00b1711427feb1cdc052a19c3dd5ba1f5d784d54" translate="yes" xml:space="preserve">
          <source>LWG 2979</source>
          <target state="translated">LWG 2979</target>
        </trans-unit>
        <trans-unit id="03245fa5249a80c9e88d330bdbed3d5b0efd3c1a" translate="yes" xml:space="preserve">
          <source>LWG 2980</source>
          <target state="translated">LWG 2980</target>
        </trans-unit>
        <trans-unit id="8e27ede83edeebcb833e56711cf9e85bad9f6a81" translate="yes" xml:space="preserve">
          <source>LWG 2981</source>
          <target state="translated">LWG 2981</target>
        </trans-unit>
        <trans-unit id="3094306bb363791eae0c331ba69cdfa31cd03bd2" translate="yes" xml:space="preserve">
          <source>LWG 2989</source>
          <target state="translated">LWG 2989</target>
        </trans-unit>
        <trans-unit id="b88afb71ca72f3a5b4d7ca39bd5f6d7740d1ca6c" translate="yes" xml:space="preserve">
          <source>LWG 2993</source>
          <target state="translated">LWG 2993</target>
        </trans-unit>
        <trans-unit id="d940e3b0bc4c6c07c3b76d624ad35c4b1995863f" translate="yes" xml:space="preserve">
          <source>LWG 3000</source>
          <target state="translated">LWG 3000</target>
        </trans-unit>
        <trans-unit id="4efd58af92ed99b44892eea2a6474d567bd785e3" translate="yes" xml:space="preserve">
          <source>LWG 3001</source>
          <target state="translated">LWG 3001</target>
        </trans-unit>
        <trans-unit id="1061d475efae99eb0cd73389f5cc7edb38d2b547" translate="yes" xml:space="preserve">
          <source>LWG 3012</source>
          <target state="translated">LWG 3012</target>
        </trans-unit>
        <trans-unit id="0007b14636a9f8886845093dd4fceab33f240906" translate="yes" xml:space="preserve">
          <source>LWG 3013</source>
          <target state="translated">LWG 3013</target>
        </trans-unit>
        <trans-unit id="66844fe2413d66059e9dfcdf2de2b069f47bdc1a" translate="yes" xml:space="preserve">
          <source>LWG 3014</source>
          <target state="translated">LWG 3014</target>
        </trans-unit>
        <trans-unit id="c6e63f6d84c4a00806bd3c82b03223958cc3e8ef" translate="yes" xml:space="preserve">
          <source>LWG 3024</source>
          <target state="translated">LWG 3024</target>
        </trans-unit>
        <trans-unit id="d4a638b7c5508bb67a4aa7d1d18ad719debb7ef5" translate="yes" xml:space="preserve">
          <source>LWG 3025</source>
          <target state="translated">LWG 3025</target>
        </trans-unit>
        <trans-unit id="633b0245721ec6f09845623cc66b7d4cd4a42726" translate="yes" xml:space="preserve">
          <source>LWG 3065</source>
          <target state="translated">LWG 3065</target>
        </trans-unit>
        <trans-unit id="172b1343747b38d1683b7b9b0e7208f82799b40e" translate="yes" xml:space="preserve">
          <source>LWG 3074</source>
          <target state="translated">LWG 3074</target>
        </trans-unit>
        <trans-unit id="fec86e1855b1d157821d7f496304297f01df2663" translate="yes" xml:space="preserve">
          <source>LWG 3075</source>
          <target state="translated">LWG 3075</target>
        </trans-unit>
        <trans-unit id="ad4916674d38c8cbc53c0d10cb3a10d32caa2e0f" translate="yes" xml:space="preserve">
          <source>LWG 3076</source>
          <target state="translated">LWG 3076</target>
        </trans-unit>
        <trans-unit id="3e2a83c594fad4b9e122e8313412c496da714783" translate="yes" xml:space="preserve">
          <source>LWG 3096</source>
          <target state="translated">LWG 3096</target>
        </trans-unit>
        <trans-unit id="b8a6836406e247baec45da221ee2d125a3cbeda4" translate="yes" xml:space="preserve">
          <source>L_tmpnam</source>
          <target state="translated">L_tmpnam</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="ef93e00ee616b79b01a6a513b42f7bef6875e5e6" translate="yes" xml:space="preserve">
          <source>Labels (&lt;a href=&quot;goto&quot;&gt;goto targets&lt;/a&gt;, &lt;code&gt;case&lt;/code&gt; labels, and &lt;code&gt;default:&lt;/code&gt;) appearing in a substatement of a constexpr if can only be referenced (by &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; or &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;) in the same substatement.</source>
          <target state="translated">동일한 하위 명령문에서 ( &lt;a href=&quot;switch&quot;&gt;스위치&lt;/a&gt; 또는 &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; 로만) 참조 할 수있는 경우 constexpr의 하위 명령문에 표시되는 레이블 ( &lt;a href=&quot;goto&quot;&gt;goto 대상&lt;/a&gt; , &lt;code&gt;case&lt;/code&gt; 레이블 및 &lt;code&gt;default:&lt;/code&gt; :) .</target>
        </trans-unit>
        <trans-unit id="4192545e02bafef39c99c48279c9d025ce9cc37d" translate="yes" xml:space="preserve">
          <source>Laguerre polynomials</source>
          <target state="translated">Laguerre 다항식</target>
        </trans-unit>
        <trans-unit id="a7a791f6abd60dc5a353ea53ddfb3ee7c9745d37" translate="yes" xml:space="preserve">
          <source>Lambda capture</source>
          <target state="translated">람다 캡처</target>
        </trans-unit>
        <trans-unit id="1d382614f838c28eb61834675bae6d432fff0445" translate="yes" xml:space="preserve">
          <source>Lambda capture of *this by value as [=,*this]</source>
          <target state="translated">*이 값으로 [=, * this]의 Lambda 캡처</target>
        </trans-unit>
        <trans-unit id="7bd97cf3e71e6cfe2f11b11baf163207e4fee010" translate="yes" xml:space="preserve">
          <source>Lambda captures</source>
          <target state="translated">람다 캡처</target>
        </trans-unit>
        <trans-unit id="ad760081fe95ad36f1148cf3a82266f36a17d08b" translate="yes" xml:space="preserve">
          <source>Lambda expressions</source>
          <target state="translated">람다 식</target>
        </trans-unit>
        <trans-unit id="29608c2c063008f0167b6a128fd16e27d0f6f38e" translate="yes" xml:space="preserve">
          <source>Lambda expressions (since C++11)</source>
          <target state="translated">람다 식 (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="b7d5884df6b1a928d6d7c3491a4a743a3e414bb2" translate="yes" xml:space="preserve">
          <source>Lambda-expressions are not allowed in &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;unevaluated expressions&lt;/a&gt;, &lt;a href=&quot;template_parameters&quot;&gt;template arguments&lt;/a&gt;, &lt;a href=&quot;type_alias&quot;&gt;alias declarations&lt;/a&gt;, &lt;a href=&quot;typedef&quot;&gt;typedef declarations&lt;/a&gt;, and anywhere in a function (or function template) declaration except the function body and the function's &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt;.</source>
          <target state="translated">람다 식은 &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;평가되지 않은 식&lt;/a&gt; , &lt;a href=&quot;template_parameters&quot;&gt;템플릿 인수&lt;/a&gt; , &lt;a href=&quot;type_alias&quot;&gt;별칭 선언&lt;/a&gt; , &lt;a href=&quot;typedef&quot;&gt;typedef 선언&lt;/a&gt; 및 함수 본문 및 함수의 &lt;a href=&quot;default_arguments&quot;&gt;기본 인수를&lt;/a&gt; 제외한 함수 (또는 함수 템플릿) 선언의 모든 위치에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="677b369051c8d8b22e38c70e8f452a88713342b3" translate="yes" xml:space="preserve">
          <source>Language feature-testing macros</source>
          <target state="translated">언어 기능 테스트 매크로</target>
        </trans-unit>
        <trans-unit id="2c4c5fa97a894aab5c689757f00ca2ff05f31ca9" translate="yes" xml:space="preserve">
          <source>Language features</source>
          <target state="translated">언어 특징</target>
        </trans-unit>
        <trans-unit id="9ca65a6a550090403c1994a3813c60f37d61983a" translate="yes" xml:space="preserve">
          <source>Language linkage</source>
          <target state="translated">언어 연계</target>
        </trans-unit>
        <trans-unit id="b4444821bc7114c255e706d9193016c8234ee05f" translate="yes" xml:space="preserve">
          <source>Language specifications can only appear in &lt;a href=&quot;scope#Namespace_scope&quot;&gt;namespace scope&lt;/a&gt;.</source>
          <target state="translated">언어 사양은 &lt;a href=&quot;scope#Namespace_scope&quot;&gt;네임 스페이스 범위&lt;/a&gt; 에만 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e794492ee652fe942ec624908ae4ef64d0ff8202" translate="yes" xml:space="preserve">
          <source>Language support</source>
          <target state="translated">언어 지원</target>
        </trans-unit>
        <trans-unit id="cc8615e79210c7c7a5e9fe165da74603db62e518" translate="yes" xml:space="preserve">
          <source>Language support libraries provide classes and functions that interact closely with language features and support common language idioms.</source>
          <target state="translated">언어 지원 라이브러리는 언어 기능과 밀접하게 상호 작용하고 공통 언어 관용구를 지원하는 클래스와 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="972ad8d8a50397ba8c02433ed8f048eeb4074b85" translate="yes" xml:space="preserve">
          <source>Layout</source>
          <target state="translated">Layout</target>
        </trans-unit>
        <trans-unit id="5c7c4bf8885640694e2c9d84d334b33834362e92" translate="yes" xml:space="preserve">
          <source>Leap seconds are not inserted into GPS. Thus, every time a leap second is inserted into UTC, UTC falls another second behind GPS. As of December 2017, UTC is 18 seconds behind GPS, reflecting the 18 leap seconds inserted between 1980 and 2017. Thus, 2018-01-01 00:00:00 UTC is equivalent to 2018-01-01 00:00:18 GPS. GPS is a constant 19 seconds behind &lt;a href=&quot;tai_clock&quot;&gt;TAI&lt;/a&gt;.</source>
          <target state="translated">윤초는 GPS에 삽입되지 않습니다. 따라서 윤초가 UTC에 삽입 될 때마다 UTC가 GPS보다 1 초 더 빠릅니다. 2017 년 12 월 현재 UTC는 GPS보다 18 초 빠르며 1980 년에서 2017 년 사이에 삽입 된 18 초 윤초를 반영합니다. 따라서 2018-01-01 00:00:00 UTC는 2018-01-01 00:00:18 GPS와 같습니다. . GPS는 &lt;a href=&quot;tai_clock&quot;&gt;TAI&lt;/a&gt; 보다 19 초가 일정 합니다.</target>
        </trans-unit>
        <trans-unit id="611855b599edd2fe82347140d615a27b9df0aac3" translate="yes" xml:space="preserve">
          <source>Leap seconds are not inserted into TAI. Thus, every time a leap second is inserted into UTC, UTC falls another second behind TAI. As of December 2017, UTC is 37 seconds behind TAI, reflecting the 10-second initial offset and the 27 leap seconds inserted between 1958 and 2017. Thus, 2018-01-01 00:00:00 UTC is equivalent to 2018-01-01 00:00:37 TAI.</source>
          <target state="translated">윤초는 TAI에 삽입되지 않습니다. 따라서 윤초가 UTC에 삽입 될 때마다 UTC가 TAI보다 1 초 더 빠릅니다. 2017 년 12 월 현재 UTC는 TAI보다 37 초 빠르며 10 초 초기 오프셋과 1958 년에서 2017 년 사이에 삽입 된 27 윤초를 반영합니다. 따라서 2018-01-01 00:00:00 UTC는 2018-01- 01 00:00:37 TAI.</target>
        </trans-unit>
        <trans-unit id="bf56ec55d59d151077b04a3c3b2a260fcafe6e19" translate="yes" xml:space="preserve">
          <source>Leaves the &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; of the vector unchanged (note: the standard's restriction on the changes to capacity is in the specification of &lt;code&gt;vector::reserve&lt;/code&gt;, see &lt;a href=&quot;http://stackoverflow.com/a/18467916&quot;&gt;[1]&lt;/a&gt;).</source>
          <target state="translated">벡터 의 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 를 변경하지 않은 채로 둡니다 (참고 : 용량 변경에 대한 표준의 제한은 &lt;code&gt;vector::reserve&lt;/code&gt; 사양에 있습니다. &lt;a href=&quot;http://stackoverflow.com/a/18467916&quot;&gt;[1]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="86e0813490cdee81f22682268815667b06f5c776" translate="yes" xml:space="preserve">
          <source>Leaves the &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; of the vector unchanged (note: the standard's restriction on the changes to capacity is in the specification of &lt;code&gt;vector::reserve&lt;/code&gt;, see &lt;a href=&quot;https://stackoverflow.com/a/18467916&quot;&gt;[1]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741a41d00730604d24e69761626a739d511f27fa" translate="yes" xml:space="preserve">
          <source>Leaving a synchronized block by any means (reaching the end, executing goto, break, continue, or return, or throwing an exception) exits the block and synchronizes-with the next block in the single total order if the exited block was an outer block. The behavior is undefined if &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; is used to exit a synchronized block.</source>
          <target state="translated">종료 된 블록에 도달 한 경우 (종료, goto, break, continue 또는 return 또는 예외 발생) 수단을 통해 동기화 된 블록을 떠나면 블록이 종료되고 종료 된 블록이 외부 블록 인 경우 단일 블록의 다음 순서와 동기화됩니다. . &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; 를 사용하여 동기화 된 블록을 종료 하면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="31d6213c56c41b4cc125420dcc2b33093d12c123" translate="yes" xml:space="preserve">
          <source>Leaving an atomic block by any means other than exception (reaching the end, goto, break, continue, return) commits the transaction. The behavior is undefined if &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; is used to exit an atomic block.</source>
          <target state="translated">예외 이외의 다른 방법으로 원자 블록을 남겨두면 (종료, 이동, 중단, 계속, 리턴) 트랜잭션을 커밋합니다. &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; 를 사용하여 원자 블록을 종료 하면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bdffb77ae44e48c63c181cf7541184b7bfe75b59" translate="yes" xml:space="preserve">
          <source>Left-to-right</source>
          <target state="translated">Left-to-right</target>
        </trans-unit>
        <trans-unit id="f644f1aaae2b85733ad956d52e9d411a359c5caf" translate="yes" xml:space="preserve">
          <source>LegacyBidirectionalIterator</source>
          <target state="translated">LegacyBidirectionalIterator</target>
        </trans-unit>
        <trans-unit id="c4a5b29b136f2ede2a2531477e7bb3c2ca5abf2b" translate="yes" xml:space="preserve">
          <source>LegacyBidirectionalIterator is a LegacyBidirectionalIterator that additionally satisfies the &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; requirements.</source>
          <target state="translated">LegacyBidirectionalIterator는 &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; 요구 사항 을 추가로 충족시키는 LegacyBidirectionalIterator입니다 .</target>
        </trans-unit>
        <trans-unit id="c0fa292844214f93eb7bc4d960957ba473ff303f" translate="yes" xml:space="preserve">
          <source>LegacyContiguousIterator</source>
          <target state="translated">LegacyContiguousIterator</target>
        </trans-unit>
        <trans-unit id="abba9ce1b1082ec030ac0427b7a1d0e517041d2c" translate="yes" xml:space="preserve">
          <source>LegacyForwardIterator</source>
          <target state="translated">LegacyForwardIterator</target>
        </trans-unit>
        <trans-unit id="096905dbdfa46128b8feb9520f8a815491bb23e6" translate="yes" xml:space="preserve">
          <source>LegacyForwardIterator is a LegacyForwardIterator that additionally satisfies the &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; requirements.</source>
          <target state="translated">LegacyForwardIterator는 &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; 요구 사항 을 추가로 충족시키는 LegacyForwardIterator 입니다.</target>
        </trans-unit>
        <trans-unit id="9bdad701a59fe021a9f0ea8f1e2907f8e0e60476" translate="yes" xml:space="preserve">
          <source>LegacyInputIterator</source>
          <target state="translated">LegacyInputIterator</target>
        </trans-unit>
        <trans-unit id="585fe456965ba38488a01543309716171330d718" translate="yes" xml:space="preserve">
          <source>LegacyIterator</source>
          <target state="translated">LegacyIterator</target>
        </trans-unit>
        <trans-unit id="3cdb555f844cd2dc50f1ef7c5652c1f890df1f87" translate="yes" xml:space="preserve">
          <source>LegacyIterator is the base set of requirements used by other iterator types: &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, and &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;. Iterators can be thought of as an abstraction of pointers.</source>
          <target state="translated">: LegacyIterator 다른 반복자 타입이 사용 조건의 기본 세트이다 &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; , &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; 및 &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; . 반복자는 포인터의 추상화로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e768ef221583d1c5e44ef0573554b7ccf685e09" translate="yes" xml:space="preserve">
          <source>LegacyOutputIterator</source>
          <target state="translated">LegacyOutputIterator</target>
        </trans-unit>
        <trans-unit id="8fa47f5539d2203c38a39fce4c4b0ef195c146d3" translate="yes" xml:space="preserve">
          <source>LegacyRandomAccessIterator</source>
          <target state="translated">LegacyRandomAccessIterator</target>
        </trans-unit>
        <trans-unit id="742f0b2803ca04b5223bb318425b08421d148103" translate="yes" xml:space="preserve">
          <source>LegacyRandomAccessIterator is a LegacyRandomAccessIterator that additionally satisfies the &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; requirements.</source>
          <target state="translated">LegacyRandomAccessIterator는 &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; 요구 사항 을 추가로 충족시키는 LegacyRandomAccessIterator 입니다.</target>
        </trans-unit>
        <trans-unit id="5846955db6bef539707c3590c701613c5f0cf50f" translate="yes" xml:space="preserve">
          <source>Legend</source>
          <target state="translated">Legend</target>
        </trans-unit>
        <trans-unit id="5d59dd3a73ef773d7095755185b08a856862f59c" translate="yes" xml:space="preserve">
          <source>Legendre polynomials</source>
          <target state="translated">레전드 다항식</target>
        </trans-unit>
        <trans-unit id="7906417f7e9cebe12726504e25b8c0b72bf1f772" translate="yes" xml:space="preserve">
          <source>LessThanComparable</source>
          <target state="translated">LessThanComparable</target>
        </trans-unit>
        <trans-unit id="274ae48acc8830f71730c0873d33a6285228a9de" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;CMP(x,y)&lt;/code&gt; be &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, and &lt;code&gt;0&lt;/code&gt; otherwise. For any &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;, the product of &lt;code&gt;CMP(lerp(a, b, t2), lerp(a, b, t1))&lt;/code&gt;, &lt;code&gt;CMP(t2, t1)&lt;/code&gt;, and &lt;code&gt;CMP(b, a)&lt;/code&gt; is non-negative. (That is, &lt;code&gt;lerp&lt;/code&gt; is monotonic.).</source>
          <target state="translated">하자 &lt;code&gt;CMP(x,y)&lt;/code&gt; 수 &lt;code&gt;1&lt;/code&gt; 의 경우 &lt;code&gt;x &amp;gt; y&lt;/code&gt; , &lt;code&gt;-1&lt;/code&gt; 경우, &lt;code&gt;x &amp;lt; y&lt;/code&gt; 및 &lt;code&gt;0&lt;/code&gt; 그렇지. 임의의 &lt;code&gt;t1&lt;/code&gt; 및 &lt;code&gt;t2&lt;/code&gt; 에 대해, &lt;code&gt;CMP(lerp(a, b, t2), lerp(a, b, t1))&lt;/code&gt; , &lt;code&gt;CMP(t2, t1)&lt;/code&gt; 및 &lt;code&gt;CMP(b, a)&lt;/code&gt; 음이 아니다. (즉, &lt;code&gt;lerp&lt;/code&gt; 는 단조입니다.)</target>
        </trans-unit>
        <trans-unit id="12941d0eb9ed4aeacc52d5f00426e066fee74e7d" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;P&lt;/code&gt; equal the precision if nonzero, &lt;code&gt;6&lt;/code&gt; if the precision is not specified, or &lt;code&gt;1&lt;/code&gt; if the precision is &lt;code&gt;​0​&lt;/code&gt;. Then, if a conversion with style &lt;code&gt;E&lt;/code&gt; would have an exponent of &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">하자 &lt;code&gt;P&lt;/code&gt; 가 0이 아닌 경우, 동일 정밀도 &lt;code&gt;6&lt;/code&gt; 정밀도 지정이 아닌 경우, 또는 &lt;code&gt;1&lt;/code&gt; 정밀도 인 경우 &lt;code&gt;​0​&lt;/code&gt; . 그런 다음 스타일 &lt;code&gt;E&lt;/code&gt; 를 사용한 변환 의 지수가 &lt;code&gt;X&lt;/code&gt; 인 경우 :</target>
        </trans-unit>
        <trans-unit id="1d96618afd4263ec0d73d199a2618f5e147e9e73" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;U&lt;/code&gt; be &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">하자 &lt;code&gt;U&lt;/code&gt; 이 될 &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32d8483331780e895e2e6534b1cf368ac9e20d64" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;Y&lt;/code&gt; be &lt;code&gt;typename &lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::element_type&lt;/code&gt;, then the resulting &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;'s stored pointer will be obtained by evaluating, respectively:</source>
          <target state="translated">&lt;code&gt;Y&lt;/code&gt; 를 &lt;code&gt;typename &lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::element_type&lt;/code&gt; 이라고하자 결과 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 의 저장된 포인터는 각각 다음과 같이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="7bf1f858e1bdfaa71eed61b027d72a6d348da6cc" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;fn&lt;/code&gt; be the call wrapper returned by a call to &lt;code&gt;std::mem_fn&lt;/code&gt; with a pointer to member &lt;code&gt;pm&lt;/code&gt;. Then the expression &lt;code&gt;fn(t, a2, ..., aN)&lt;/code&gt; is equivalent to &lt;code&gt;INVOKE(pm, t, a2, ..., aN)&lt;/code&gt;, where</source>
          <target state="translated">하자 &lt;code&gt;fn&lt;/code&gt; 호출에 의해 반환 된 호출 래퍼 수 &lt;code&gt;std::mem_fn&lt;/code&gt; 멤버에 대한 포인터 &lt;code&gt;pm&lt;/code&gt; . 그런 다음 &lt;code&gt;fn(t, a2, ..., aN)&lt;/code&gt; 표현식 은 &lt;code&gt;INVOKE(pm, t, a2, ..., aN)&lt;/code&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4affff119284bd8c17502a7b4ba9cddc4335375c" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;since_midnight&lt;/code&gt; be the stored duration:</source>
          <target state="translated">하자 &lt;code&gt;since_midnight&lt;/code&gt; 는 저장 기간 수 :</target>
        </trans-unit>
        <trans-unit id="81727cefad0e4f620e16d3a8ef618ac5d109ea3a" translate="yes" xml:space="preserve">
          <source>Let's consider now those cases employing argument-dependent lookup (i.e., we use the more common call format &lt;code&gt;f(t)&lt;/code&gt;).</source>
          <target state="translated">이제 인수 의존적 조회를 사용하는 경우를 생각해 보자 (즉, 우리는 더 일반적인 호출 형식 &lt;code&gt;f(t)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="41a116dfc9200f26422a8e9d5e49911e4bc90a0d" translate="yes" xml:space="preserve">
          <source>Letters in the integer literals are case-insensitive: &lt;code&gt;0xDeAdBeEfU&lt;/code&gt; and &lt;code&gt;0XdeadBEEFu&lt;/code&gt; represent the same number (one exception is the long-long-suffix, which is either &lt;code&gt;ll&lt;/code&gt; or &lt;code&gt;LL&lt;/code&gt;, never &lt;code&gt;lL&lt;/code&gt; or &lt;code&gt;Ll&lt;/code&gt;).</source>
          <target state="translated">정수 리터럴의 문자는 대소 문자를 구분하지 않습니다. &lt;code&gt;0xDeAdBeEfU&lt;/code&gt; 및 &lt;code&gt;0XdeadBEEFu&lt;/code&gt; 는 같은 숫자를 나타냅니다 (한 예외는 long-suffix입니다 ( &lt;code&gt;ll&lt;/code&gt; 또는 &lt;code&gt;LL&lt;/code&gt; , 절대 &lt;code&gt;lL&lt;/code&gt; 또는 &lt;code&gt;Ll&lt;/code&gt; )).</target>
        </trans-unit>
        <trans-unit id="4e3f5ccac8e611393a344b1488ebf8b88e0bab4b" translate="yes" xml:space="preserve">
          <source>Lexicographical comparison is a operation with the following properties:</source>
          <target state="translated">사전 비교는 다음 특성을 가진 조작입니다.</target>
        </trans-unit>
        <trans-unit id="7273c76d82ab971497c1735a342d6d033382649f" translate="yes" xml:space="preserve">
          <source>Lexicographically compares two ranges &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;[first2, last2)&lt;/code&gt; using three-way comparison and produces a result of the strongest applicable comparison category type.</source>
          <target state="translated">사전 방식은 3 방향 비교를 사용하여 두 가지 범위 &lt;code&gt;[first1, last1)&lt;/code&gt; 및 &lt;code&gt;[first2, last2)&lt;/code&gt; 를 비교하고 가장 강력한 적용 가능한 비교 범주 유형의 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="67a093b5f3afa1ec9d50b3d089465752e5b76f7f" translate="yes" xml:space="preserve">
          <source>Library Fundamentals TS</source>
          <target state="translated">도서관 기본 사항 TS</target>
        </trans-unit>
        <trans-unit id="6b5e123be926567d010847ac064936336ad593ea" translate="yes" xml:space="preserve">
          <source>Library Fundamentals TS v2</source>
          <target state="translated">라이브러리 기초 TS v2</target>
        </trans-unit>
        <trans-unit id="e2667d1d4071efd5b07b3f89a3f29b6be4e37f9e" translate="yes" xml:space="preserve">
          <source>Library feature-test macros</source>
          <target state="translated">라이브러리 기능 테스트 매크로</target>
        </trans-unit>
        <trans-unit id="d181f5a9fb0d9e7127fc14e913193f77a0078f2d" translate="yes" xml:space="preserve">
          <source>Library feature-test macros (C++20)</source>
          <target state="translated">라이브러리 기능 테스트 매크로 (C ++ 20)</target>
        </trans-unit>
        <trans-unit id="1ca30982b1bbf9fa6a34598686144ccd0b751409" translate="yes" xml:space="preserve">
          <source>Library features</source>
          <target state="translated">라이브러리 기능</target>
        </trans-unit>
        <trans-unit id="09e12a24dc663d40201c5b3eab12424fb6edc742" translate="yes" xml:space="preserve">
          <source>Library support</source>
          <target state="translated">도서관 지원</target>
        </trans-unit>
        <trans-unit id="08957d8442d6c53a0376743b1046564066c5beb9" translate="yes" xml:space="preserve">
          <source>Library types</source>
          <target state="translated">도서관 유형</target>
        </trans-unit>
        <trans-unit id="541a37e25273e2d6d7d8ea77a193f781a3f90323" translate="yes" xml:space="preserve">
          <source>Library-wide</source>
          <target state="translated">Library-wide</target>
        </trans-unit>
        <trans-unit id="e791557e003ef45d34d52d1fde8fc7381122402d" translate="yes" xml:space="preserve">
          <source>Library-wide definitions</source>
          <target state="translated">라이브러리 전체 정의</target>
        </trans-unit>
        <trans-unit id="8d05a85e0ee31a873e2f15997f3ffa7b057cefff" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.</source>
          <target state="translated">Creative Commons Attribution-ShareAlike Unported License v3.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8d33f31baff91c27917dcfcd7222cc394cee13fd" translate="yes" xml:space="preserve">
          <source>Lifetime</source>
          <target state="translated">Lifetime</target>
        </trans-unit>
        <trans-unit id="fcab1aea1859e79acfdb16f5548fc5e8f346103c" translate="yes" xml:space="preserve">
          <source>Lifetime management overhead: pImpl (as well as OO factory) place the implementation object on the heap, which imposes significant runtime overhead at construction and destruction. This may be partially offset by custom allocators, since allocation size for pImpl (but not OO factory) is known at compile time.</source>
          <target state="translated">수명 관리 오버 헤드 : pImpl (및 OO 팩토리)은 구현 오브젝트를 힙에 배치하므로 구성 및 소멸시 런타임 오버 헤드가 상당히 증가합니다. 컴파일 타임에 pImpl (OO 팩토리는 아님)의 할당 크기가 알려져 있기 때문에 이것은 커스텀 할당 자에 의해 부분적으로 상쇄 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce83a9e6e299b9deac4e3b17e7674a70743eba46" translate="yes" xml:space="preserve">
          <source>Lifetime of a &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; is exactly its storage duration.</source>
          <target state="translated">&lt;a href=&quot;reference&quot;&gt;참조의&lt;/a&gt; 수명 은 정확히 저장 기간입니다.</target>
        </trans-unit>
        <trans-unit id="aa1c59351fb4e3a194ae9298bc34b5f343ca9a77" translate="yes" xml:space="preserve">
          <source>Lifetime of a member of a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; begins when that member is made active</source>
          <target state="translated">&lt;a href=&quot;union&quot;&gt;노조원&lt;/a&gt; 의 일생은 그 회원이 활동할 때 시작됩니다</target>
        </trans-unit>
        <trans-unit id="bfaa411f86a50808036a50484d4f059e87177ec8" translate="yes" xml:space="preserve">
          <source>Lifetime of a temporary</source>
          <target state="translated">일시적인 수명</target>
        </trans-unit>
        <trans-unit id="b06c7b4fe84d7d3832ffd284a1596b4ff15c6d2b" translate="yes" xml:space="preserve">
          <source>Lifetime of an object is equal to or is nested within the lifetime of its storage, see &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;.</source>
          <target state="translated">오브젝트의 수명이 스토리지의 수명과 같거나 중첩되어 있습니다 ( &lt;a href=&quot;storage_duration&quot;&gt;스토리지 기간&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="51e3b5d26b2a87dc97df037e11067c891e623490" translate="yes" xml:space="preserve">
          <source>Lifetimes of member objects and base subobjects begin and end following &lt;a href=&quot;constructor#Initialization_order&quot;&gt;class initialization order&lt;/a&gt;.</source>
          <target state="translated">멤버 객체 및 기본 하위 객체의 수명은 &lt;a href=&quot;constructor#Initialization_order&quot;&gt;클래스 초기화 순서에&lt;/a&gt; 따라 시작 및 종료 됩니다.</target>
        </trans-unit>
        <trans-unit id="1332053b53e77535f34952c3e92e4a52a83ed6ef" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt;, this function typically performs only one allocation, and places both the &lt;code&gt;T&lt;/code&gt; object and the control block in the allocated memory block (the standard recommends but does not require this, all known implementations do this). A copy of &lt;code&gt;alloc&lt;/code&gt; is stored as part of the control block so that it can be used to deallocate it once both shared and weak reference counts reach zero.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; 와 같이이 함수는 일반적으로 하나의 할당 만 수행하고 &lt;code&gt;T&lt;/code&gt; 객체와 제어 블록을 할당 된 메모리 블록에 배치합니다 (표준에서는 권장하지만 요구하지는 않지만 모든 알려진 구현은이 작업을 수행함 ). &lt;code&gt;alloc&lt;/code&gt; 의 사본은 제어 블록의 일부로 저장되므로 공유 및 약한 참조 카운트가 모두 0에 도달하면 할당을 해제하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb0723405e133e81ce558a6f85e371f734d41854" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;, a typical implementation of &lt;code&gt;weak_ptr&lt;/code&gt; stores two pointers:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 과 같이 &lt;code&gt;weak_ptr&lt;/code&gt; 의 일반적인 구현은 두 개의 포인터를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="70ffb5a0c307ec17f33f7f7369b3ef25ef794da7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;unsigned char&lt;/code&gt;, it can be used to access raw memory occupied by other objects (&lt;a href=&quot;../language/objects&quot;&gt;object representation&lt;/a&gt;), but unlike those types, it is not a character type and is not an arithmetic type. A byte is only a collection of bits, and the only operators defined for it are the bitwise ones.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 및 &lt;code&gt;unsigned char&lt;/code&gt; char 와 같이 다른 객체 ( &lt;a href=&quot;../language/objects&quot;&gt;객체 표현&lt;/a&gt; )가 차지하는 원시 메모리에 액세스하는 데 사용할 수 있지만 이러한 유형과 달리 문자 유형이 아니며 산술 유형이 아닙니다. 바이트는 비트의 모음 일 뿐이며 이에 대해 정의 된 유일한 연산자는 비트 단위입니다.</target>
        </trans-unit>
        <trans-unit id="a0e7b4ff05a45ce92b546002d8fc2f4e84c6ea38" translate="yes" xml:space="preserve">
          <source>Like a hard link, a symbolic link allows a file to have multiple logical names. The presence of a hard link guarantees the existence of a file, even after the original name has been removed. A symbolic link provides no such assurance; in fact, the file named by the &lt;code&gt;target&lt;/code&gt; argument need not exist when the link is created. A symbolic link can cross file system boundaries.</source>
          <target state="translated">하드 링크와 마찬가지로 기호 링크를 사용하면 파일에 여러 논리 이름이있을 수 있습니다. 하드 링크가 있으면 원래 이름을 제거한 후에도 파일이 존재합니다. 심볼릭 링크는 그러한 보증을 제공하지 않습니다. 실제로, 링크가 작성 될 때 &lt;code&gt;target&lt;/code&gt; 인수에 의해 명명 된 파일 이 존재할 필요는 없습니다. 심볼릭 링크는 파일 시스템 경계를 넘을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cc2c9ed197596f0e8ca54e8df4a5e29bc4bbde4" translate="yes" xml:space="preserve">
          <source>Like a reference, a structured binding is an alias to an existing object. Unlike a reference, the type of a structured binding does not have to be a reference type.</source>
          <target state="translated">참조와 마찬가지로 구조적 바인딩은 기존 객체의 별칭입니다. 참조와 달리 구조적 바인딩의 유형은 참조 유형일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="067a7fb7f8bc363ab9405d15f7f42f52d531593e" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isalnum&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::isalnum&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않으면 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1f83c5788970238d8dce9e165785dcf50fdef59c" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isalpha&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::isalpha&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않으면 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="02650958be1dd2146a9becd39224244d381efde4" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isblank&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::isblank&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않으면 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0340210c2f7ce33d0ebf0f6392410ac886edccce" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::iscntrl&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::iscntrl&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않으면 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2dd464fdeabb59a1a5f506eb7ecd2b3abdac9a22" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isdigit&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::isdigit&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않으면 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7dda039594fc889284a6c61532474b72fdbd1f81" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isgraph&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::isgraph&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않으면 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e6241819c2a6db7cd413177f3e7eb9b7229e9f1f" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::islower&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::islower&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않으면 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7ccc47ed9fcd07aec0dbec6222f54d9803cf130c" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isprint&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::isprint&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않으면 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="411696ff296361e95ad61309fa87bc8c79319127" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::ispunct&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::ispunct&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않으면 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a2bc2b3471f087c8466e836925f03b3603558f3f" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isspace&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::isspace&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않으면 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="395c220484621ffd75d1964f6130a00ce4ddab49" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isupper&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::isupper&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않은 경우 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cb2c7e80bd4929826427f19fc7c64d9e9ff5d018" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isxdigit&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::isxdigit&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않은 경우 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ff408cea9c029c8dab319c58cbd0c36f0d4045fe" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::tolower&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::tolower&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않으면 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c3e68c1eaec4b4e283489b5c67ab059adf32011f" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::toupper&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 의&lt;/a&gt; 다른 모든 함수와 마찬가지로 &lt;code&gt;std::toupper&lt;/code&gt; 의 동작은 인수 값이 &lt;code&gt;unsigned char&lt;/code&gt; 또는 &lt;code&gt;EOF&lt;/code&gt; 와 같지 않으면 정의되지 않습니다 . 일반 &lt;code&gt;char&lt;/code&gt; (또는 &lt;code&gt;signed char&lt;/code&gt; ) 와 함께 이러한 함수를 안전하게 사용하려면 먼저 인수를 &lt;code&gt;unsigned char&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="277019aab45ab5f935fb6e92f8f5746e4c25daa8" translate="yes" xml:space="preserve">
          <source>Like any template declaration, an alias template can only be declared at class scope or namespace scope.</source>
          <target state="translated">템플릿 선언과 마찬가지로 별칭 템플릿은 클래스 범위 또는 네임 스페이스 범위에서만 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca47c4b0c6ddc7644bfef7979156876bc8446bd5" translate="yes" xml:space="preserve">
          <source>Like class prvalues, array prvalues convert to xvalues by &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporary materialization&lt;/a&gt; when evaluated.</source>
          <target state="translated">클래스 prvalue와 마찬가지로 배열 prvalue는 평가시 &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;임시 구체화&lt;/a&gt; 를 통해 xvalue로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="0347742fa713e18c4beb5d442719947cba761472" translate="yes" xml:space="preserve">
          <source>Like language references, constness is shallow for &lt;code&gt;atomic_ref&lt;/code&gt; - it is possible to modify the referenced value through a &lt;code&gt;const&lt;/code&gt;&lt;code&gt;atomic_ref&lt;/code&gt; object.</source>
          <target state="translated">언어 참조와 마찬가지로 constness는 atomic_ref에 대해 &lt;code&gt;atomic_ref&lt;/code&gt; 습니다 . &lt;code&gt;const&lt;/code&gt; &lt;code&gt;atomic_ref&lt;/code&gt; 객체를 통해 참조 된 값을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a2c18bbb70b4975f8de70e1d0f45d8ebbaac4a9" translate="yes" xml:space="preserve">
          <source>Like other classes, class templates have an injected-class-name. The injected-class-name can be used as a template-name or a type-name.</source>
          <target state="translated">다른 클래스와 마찬가지로 클래스 템플릿에는 주입 된 클래스 이름이 있습니다. 주입 된 클래스 이름은 템플리트 이름 또는 유형 이름으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a6e90ef50926b9b7275d89708dfc849a157f540" translate="yes" xml:space="preserve">
          <source>Like other members, injected-class-names are inherited. In the presence of private or protected inheritance, the injected-class-name of an indirect base class might end up being inaccessible in a derived class.</source>
          <target state="translated">다른 멤버와 마찬가지로 주입 된 클래스 이름이 상속됩니다. 개인 또는 보호 된 상속이있는 경우 간접 기본 클래스의 주입 된 클래스 이름이 파생 클래스에서 액세스 할 수 없게 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f1d175f286f2d5f07aef906a2e3bc134ab3f16" translate="yes" xml:space="preserve">
          <source>Like other streambuf classes, &lt;code&gt;std::basic_syncbuf&lt;/code&gt; is normally only accessed through the corresponding stream, &lt;a href=&quot;basic_osyncstream&quot;&gt;&lt;code&gt;std::osyncstream&lt;/code&gt;&lt;/a&gt;, not directly.</source>
          <target state="translated">다른 streambuf 클래스와 마찬가지로 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 는 일반적으로 직접가 아닌 해당 스트림 &lt;a href=&quot;basic_osyncstream&quot;&gt; &lt;code&gt;std::osyncstream&lt;/code&gt; &lt;/a&gt; 통해서만 액세스 됩니다.</target>
        </trans-unit>
        <trans-unit id="bd2d3509f0729065894ca6384a10fe999c819fe7" translate="yes" xml:space="preserve">
          <source>Likewise, function-try-block of the &lt;a href=&quot;main_function&quot;&gt;main() function&lt;/a&gt; does not catch the exceptions thrown from the constructors and destructors of &lt;a href=&quot;storage_duration&quot;&gt;static&lt;/a&gt; objects (except for the constructors of function-local statics).</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;main_function&quot;&gt;main () 함수&lt;/a&gt; 의 function-try-block은 &lt;a href=&quot;storage_duration&quot;&gt;정적&lt;/a&gt; 객체 의 생성자와 소멸자에서 throw 된 예외를 포착하지 않습니다 (함수-로컬 정적의 생성자를 제외).</target>
        </trans-unit>
        <trans-unit id="ab6af34df8147c6b3a0969fea41e698ff89bc410" translate="yes" xml:space="preserve">
          <source>Likewise, the 16-digit string &lt;code&gt;9007199254740993&lt;/code&gt; does not survive text-&amp;gt;double-&amp;gt;text roundtrip, becoming &lt;code&gt;9007199254740992&lt;/code&gt;: the 64-bit IEEE 754 type double guarantees this roundtrip only for 15 decimal digits.</source>
          <target state="translated">마찬가지로, 16 자리 문자열 &lt;code&gt;9007199254740993&lt;/code&gt; 이 되고, 텍스트 -&amp;gt; 더블&amp;gt; 텍스트 왕복 생존하지 않습니다 &lt;code&gt;9007199254740992&lt;/code&gt; 를 : 64 비트 IEEE 754 종류를 두 번 보장이 왕복에만 15 진수.</target>
        </trans-unit>
        <trans-unit id="28d080135c0996528be81f65c40eb528ec429cbe" translate="yes" xml:space="preserve">
          <source>Likewise, the inequality operator is typically implemented in terms of &lt;code&gt;operator==&lt;/code&gt;:</source>
          <target state="translated">마찬가지로 부등식 연산자는 일반적으로 &lt;code&gt;operator==&lt;/code&gt; 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d8bc984a49e87697786db72d2563a91679f73c6" translate="yes" xml:space="preserve">
          <source>Limits of floating point types</source>
          <target state="translated">부동 소수점 유형의 한계</target>
        </trans-unit>
        <trans-unit id="68c715c0e0c866487981ad26eed257940f23ee03" translate="yes" xml:space="preserve">
          <source>Limits of integer types</source>
          <target state="translated">정수 유형의 한계</target>
        </trans-unit>
        <trans-unit id="15ff631ff253c68efadbbe156b2dbda674f664c6" translate="yes" xml:space="preserve">
          <source>Limits of other integer types</source>
          <target state="translated">다른 정수 유형의 한계</target>
        </trans-unit>
        <trans-unit id="af502f2b37eea07ed9083c7daf40f34553f6fccd" translate="yes" xml:space="preserve">
          <source>Linear</source>
          <target state="translated">Linear</target>
        </trans-unit>
        <trans-unit id="d663d9eccd3592374d465e1969446c41d66c8a96" translate="yes" xml:space="preserve">
          <source>Linear in &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt; 선형입니다 .</target>
        </trans-unit>
        <trans-unit id="5ee30c8aafcff81625dfef38a2177634d49c1eed" translate="yes" xml:space="preserve">
          <source>Linear in &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 선형 .</target>
        </trans-unit>
        <trans-unit id="dd2f30444814df4f83cd7413476e4b0fd89443cb" translate="yes" xml:space="preserve">
          <source>Linear in &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">리니어 &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7bbb05054f896c8a5f8b773dacbef4017beeded" translate="yes" xml:space="preserve">
          <source>Linear in &lt;code&gt;rcount&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rcount&lt;/code&gt; 의 선형 .</target>
        </trans-unit>
        <trans-unit id="1a961c5a00bbaee66696314d28a309bcc73bf9a0" translate="yes" xml:space="preserve">
          <source>Linear in size of the container.</source>
          <target state="translated">컨테이너 크기의 선형.</target>
        </trans-unit>
        <trans-unit id="47e94bceda1e4178a1dbb6f4ff6dcd1259ef8d37" translate="yes" xml:space="preserve">
          <source>Linear in the difference between the current size and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">현재 크기와 &lt;code&gt;count&lt;/code&gt; 의 차이가 선형입니다 .</target>
        </trans-unit>
        <trans-unit id="c0ba0eb11bb040b4fe1f3679f71ea7620138693f" translate="yes" xml:space="preserve">
          <source>Linear in the difference between the current size and &lt;code&gt;count&lt;/code&gt;. Additional complexity possible due to list traversal to reach the first element to erase/the end position to insert.</source>
          <target state="translated">현재 크기와 &lt;code&gt;count&lt;/code&gt; 의 차이가 선형입니다 . 삭제할 첫 번째 요소 / 삽입 끝 위치에 도달하는 목록 순회로 인해 추가 복잡성이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baaef666d55118a41c333430f0a97ec79990b1cb" translate="yes" xml:space="preserve">
          <source>Linear in the difference between the current size and &lt;code&gt;count&lt;/code&gt;. Additional complexity possible due to reallocation if capacity is less than &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">현재 크기와 &lt;code&gt;count&lt;/code&gt; 의 차이가 선형입니다 . 용량이 &lt;code&gt;count&lt;/code&gt; 보다 적 으면 재 할당으로 인해 추가 복잡성이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61fc9e3129ac082fe227ebd6080874ba58bf854d" translate="yes" xml:space="preserve">
          <source>Linear in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;last&lt;/code&gt; 사이의 거리에서 선형입니다 .</target>
        </trans-unit>
        <trans-unit id="5120f8d10505c4347d98aef0265d53cc5b14811e" translate="yes" xml:space="preserve">
          <source>Linear in the distance between &lt;code&gt;pos&lt;/code&gt; and end of the container.</source>
          <target state="translated">용기의 &lt;code&gt;pos&lt;/code&gt; 와 끝 사이의 거리가 선형입니다 .</target>
        </trans-unit>
        <trans-unit id="e00c01e410d339ff063543b8db6c55336a7eb35e" translate="yes" xml:space="preserve">
          <source>Linear in the length of the underlying character sequence.</source>
          <target state="translated">기본 문자 시퀀스의 길이에서 선형입니다.</target>
        </trans-unit>
        <trans-unit id="daef509e105270395b1f8ee55aa3597f2d32c098" translate="yes" xml:space="preserve">
          <source>Linear in the lesser of the distances between &lt;code&gt;pos&lt;/code&gt; and either of the ends of the container.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 와 컨테이너의 양쪽 끝 사이의 거리가 작을수록 선형입니다 .</target>
        </trans-unit>
        <trans-unit id="f9e42220f12301a5a104063cb40d7e22a40f20c0" translate="yes" xml:space="preserve">
          <source>Linear in the number of sub-matches.</source>
          <target state="translated">부분 일치 횟수의 선형.</target>
        </trans-unit>
        <trans-unit id="c5ddd8aed976c4d32ca29544bac6a99205868cfe" translate="yes" xml:space="preserve">
          <source>Linear in the size of the bucket &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">버킷 크기의 선형 &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="320de548d4905427a59ae55bf65f8ed7ea812394" translate="yes" xml:space="preserve">
          <source>Linear in the size of the container adaptor.</source>
          <target state="translated">컨테이너 어댑터의 크기가 선형입니다.</target>
        </trans-unit>
        <trans-unit id="58a053e51fd6f7ec6e1969382ddb0c636fee3c4d" translate="yes" xml:space="preserve">
          <source>Linear in the size of the container, i.e., the number of elements.</source>
          <target state="translated">컨테이너 크기, 즉 요소 수의 선형.</target>
        </trans-unit>
        <trans-unit id="9e42d6edd168f206c67991730a76dd86d7fd13ac" translate="yes" xml:space="preserve">
          <source>Linear in the size of the container.</source>
          <target state="translated">컨테이너 크기의 선형.</target>
        </trans-unit>
        <trans-unit id="d098f3f0fdf3fe294ef9db9875c8f3ba39748928" translate="yes" xml:space="preserve">
          <source>Linear in the size of the numeric array.</source>
          <target state="translated">숫자 형 배열의 크기가 선형입니다.</target>
        </trans-unit>
        <trans-unit id="39f6b3d4e54ae45f608cfae2731dfa12f1a130f4" translate="yes" xml:space="preserve">
          <source>Linear in the size of the string</source>
          <target state="translated">끈 크기의 선형</target>
        </trans-unit>
        <trans-unit id="d34b2255c2e995e02e21a14b3a4851ac5882aba2" translate="yes" xml:space="preserve">
          <source>Linear in the size of the string, although existing implementations operate in constant time.</source>
          <target state="translated">기존 구현은 일정한 시간에 작동하지만 문자열 크기는 선형입니다.</target>
        </trans-unit>
        <trans-unit id="2f4742601a668a97966b78c0c256da0091787c9f" translate="yes" xml:space="preserve">
          <source>Linear in the size of the string.</source>
          <target state="translated">문자열 크기가 선형입니다.</target>
        </trans-unit>
        <trans-unit id="d504b6d983be80c3da82ac77491361a106de8dd6" translate="yes" xml:space="preserve">
          <source>Linear in the size of the strings.</source>
          <target state="translated">문자열 크기가 선형입니다.</target>
        </trans-unit>
        <trans-unit id="c67c2146b42dc18f8ac7602e8c37c39d0d1a88f4" translate="yes" xml:space="preserve">
          <source>Linear in the size of the views.</source>
          <target state="translated">뷰 크기가 선형입니다.</target>
        </trans-unit>
        <trans-unit id="353a3b1efc1c504f1131664f1c9da4bb8225908a" translate="yes" xml:space="preserve">
          <source>Linear interpolation</source>
          <target state="translated">선형 보간</target>
        </trans-unit>
        <trans-unit id="2eb90c9fc96f9c707142bd2df66bbb959c695585" translate="yes" xml:space="preserve">
          <source>Linear.</source>
          <target state="translated">Linear.</target>
        </trans-unit>
        <trans-unit id="bd2f979972802ff1d01a873d1a8e13284150ffe8" translate="yes" xml:space="preserve">
          <source>Linear: the number of calls to the destructor of T is the same as the number of elements erased, the assignment operator of T is called the number of times equal to the number of elements in the vector after the erased elements.</source>
          <target state="translated">선형 : T의 소멸자에 대한 호출 수는 지워진 요소 수와 동일하며 T의 대입 연산자는 지워진 요소 다음에 벡터의 요소 수와 같은 횟수라고합니다.</target>
        </trans-unit>
        <trans-unit id="4ee1b770c5760a0a6cf5b30f78ae338fd8baa73a" translate="yes" xml:space="preserve">
          <source>Linear: the number of calls to the destructor of T is the same as the number of elements erased, the number of calls to the assignment operator of T is no more than the lesser of the number of elements before the erased elements and the number of elements after the erased elements.</source>
          <target state="translated">선형 : T의 소멸자에 대한 호출 수는 지워진 요소 수와 동일합니다. T의 할당 연산자에 대한 호출 수는 지워진 요소 이전의 요소 수와 지워진 요소 뒤에 요소.</target>
        </trans-unit>
        <trans-unit id="8f51211d5882b7b1d7f5bacb8c562304994eec22" translate="yes" xml:space="preserve">
          <source>Link has been severed</source>
          <target state="translated">링크가 끊어졌습니다</target>
        </trans-unit>
        <trans-unit id="b27dc31140950c016978fcb4c144b7b2d3cbc47c" translate="yes" xml:space="preserve">
          <source>Linkage</source>
          <target state="translated">Linkage</target>
        </trans-unit>
        <trans-unit id="55ecf80e85b7d19bbe4096b1255534070ebf5b46" translate="yes" xml:space="preserve">
          <source>Linkage specification</source>
          <target state="translated">연계 사양</target>
        </trans-unit>
        <trans-unit id="44da027a7d61f0dfd1784a90d378229ab9cfb71e" translate="yes" xml:space="preserve">
          <source>List initialization is performed in the following situations:</source>
          <target state="translated">다음과 같은 상황에서 목록 초기화가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7094bd5e681efcce9038e6d995bf2d060fc85079" translate="yes" xml:space="preserve">
          <source>List operations</source>
          <target state="translated">목록 작업</target>
        </trans-unit>
        <trans-unit id="00863cc84a92ec056c8a5802850de22482d7a20f" translate="yes" xml:space="preserve">
          <source>List-initialization</source>
          <target state="translated">List-initialization</target>
        </trans-unit>
        <trans-unit id="54a3b43bb92df32d485a7093803f903e36c579fd" translate="yes" xml:space="preserve">
          <source>Lists the exceptions that a function might directly or indirectly throw.</source>
          <target state="translated">함수가 직간접 적으로 발생할 수있는 예외를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="88f0bff43cf350627f446597dc555fcbb10deccb" translate="yes" xml:space="preserve">
          <source>Literal constant expression</source>
          <target state="translated">리터럴 상수 표현</target>
        </trans-unit>
        <trans-unit id="a7c8f6e22e4cf98d224c691373983e8bb4a14cd5" translate="yes" xml:space="preserve">
          <source>Literal operators</source>
          <target state="translated">리터럴 연산자</target>
        </trans-unit>
        <trans-unit id="793829f43d6401d24000acee9b0edc1896c5c837" translate="yes" xml:space="preserve">
          <source>Literal type that extends string literals:</source>
          <target state="translated">문자열 리터럴을 확장하는 리터럴 유형 :</target>
        </trans-unit>
        <trans-unit id="2304c62e8f7798124c1dc52b057e7762191e4112" translate="yes" xml:space="preserve">
          <source>LiteralType</source>
          <target state="translated">LiteralType</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="b85acf10db8d6b17de3526edb467be756ff163a4" translate="yes" xml:space="preserve">
          <source>Literals are the tokens of a C++ program that represent constant values embedded in the source code.</source>
          <target state="translated">리터럴은 소스 코드에 포함 된 상수 값을 나타내는 C ++ 프로그램의 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="207b5847d31f577b34ce5944ce67366ee6a9f77d" translate="yes" xml:space="preserve">
          <source>Loads the data from locations, defined by &lt;code&gt;vlist&lt;/code&gt;,, converts them to wide string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">&lt;code&gt;vlist&lt;/code&gt; 에 의해 정의 된 위치에서 데이터를로드하고 이를 넓은 문자열로 변환하고 결과를 다양한 싱크에 씁니다.</target>
        </trans-unit>
        <trans-unit id="306845665660271f5edceb9cf305119d107a9b6d" translate="yes" xml:space="preserve">
          <source>Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">주어진 위치에서 데이터를로드하고 해당 문자열로 변환하여 결과를 다양한 싱크에 씁니다.</target>
        </trans-unit>
        <trans-unit id="b98547f12140b861f02fc92da40524e3b426e7b6" translate="yes" xml:space="preserve">
          <source>Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">주어진 위치에서 데이터를로드하고이를 넓은 문자열로 변환 한 다음 결과를 다양한 싱크에 씁니다.</target>
        </trans-unit>
        <trans-unit id="7bea89bc2ce48c930dc7395bbdbef3f7216a1506" translate="yes" xml:space="preserve">
          <source>Loads the data from the locations, defined by &lt;code&gt;vlist&lt;/code&gt;, converts them to character string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">&lt;code&gt;vlist&lt;/code&gt; 에 의해 정의 된 위치에서 데이터를로드하고 이를 동등한 문자열로 변환 한 후 결과를 다양한 싱크에 씁니다.</target>
        </trans-unit>
        <trans-unit id="3efe7e57b877b99e83abee299be618072a6caad5" translate="yes" xml:space="preserve">
          <source>Loads the execution context &lt;code&gt;env&lt;/code&gt; saved by a previous call to &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt;. This function does not return. Control is transferred to the call site of the macro &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; that set up &lt;code&gt;env&lt;/code&gt;. That &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; then returns the value, passed as the &lt;code&gt;status&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 에 대한 이전 호출로 저장된 실행 컨텍스트 &lt;code&gt;env&lt;/code&gt; 를 로드합니다 . 이 함수는 반환되지 않습니다. 제어는 &lt;code&gt;env&lt;/code&gt; 를 설정 한 매크로 &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 의 호출 사이트로 전송됩니다 . 그런 다음 &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;status&lt;/code&gt; 로 전달 된 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f3f3766d936a084f7885a89b74bff964f93af54b" translate="yes" xml:space="preserve">
          <source>Local classes</source>
          <target state="translated">지역 수업</target>
        </trans-unit>
        <trans-unit id="4aae5a412706d04afcfacf152e9fb5c7502dd7b9" translate="yes" xml:space="preserve">
          <source>Local classes cannot define &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt; inside the class definition</source>
          <target state="translated">로컬 클래스는 클래스 정의 내에서 &lt;a href=&quot;friend&quot;&gt;친구 기능을&lt;/a&gt; 정의 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="537fd817534a9d16da0662978fafc67944474038" translate="yes" xml:space="preserve">
          <source>Local classes cannot have &lt;a href=&quot;friend#Template_friends&quot;&gt;friend templates&lt;/a&gt;</source>
          <target state="translated">지역 수업은 &lt;a href=&quot;friend#Template_friends&quot;&gt;친구 템플릿을&lt;/a&gt; 가질 수 없습니다</target>
        </trans-unit>
        <trans-unit id="25934a3163283e7417a8ccb81533f8c6db7c89fa" translate="yes" xml:space="preserve">
          <source>Local classes other than &lt;a href=&quot;lambda&quot;&gt;closure types&lt;/a&gt;(since C++14) cannot have member templates</source>
          <target state="translated">C ++ 14부터 &lt;a href=&quot;lambda&quot;&gt;클로저 유형&lt;/a&gt; 이외의 로컬 클래스 는 멤버 템플릿을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b64c37e179f49fcbc2cadc0fb2d42cd79c4fdd9" translate="yes" xml:space="preserve">
          <source>Local monetary numeric formatting parameters</source>
          <target state="translated">현지 통화 숫자 형식화 매개 변수</target>
        </trans-unit>
        <trans-unit id="9ac34b8bf1cd18f9b339db9b7d7bfbe70142b73d" translate="yes" xml:space="preserve">
          <source>Local variables are not allowed in default arguments  unless used in unevaluated context(since C++14):</source>
          <target state="translated">평가되지 않은 컨텍스트 (C ++ 14부터)에서 사용되지 않으면 로컬 변수는 기본 인수에 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8970f0e691a0a23a47517698017c997507efd496" translate="yes" xml:space="preserve">
          <source>Locale</source>
          <target state="translated">Locale</target>
        </trans-unit>
        <trans-unit id="6c3524ddb4dbd6e55cdddfdad87f91e490674af0" translate="yes" xml:space="preserve">
          <source>Locale-independent unicode conversion facets</source>
          <target state="translated">로케일 독립적 인 유니 코드 변환 패싯</target>
        </trans-unit>
        <trans-unit id="9e57020d7e664c3bc1f3a56095434c59ad016632" translate="yes" xml:space="preserve">
          <source>Locale-specific facet categories</source>
          <target state="translated">로케일 특정 패싯 카테고리</target>
        </trans-unit>
        <trans-unit id="a222060e32289bf6910ac4a07a10733be500bd99" translate="yes" xml:space="preserve">
          <source>Locales</source>
          <target state="translated">Locales</target>
        </trans-unit>
        <trans-unit id="3a0f6d00aea8688a68e6b8a0597983687499bda4" translate="yes" xml:space="preserve">
          <source>Locales and facets</source>
          <target state="translated">로케일 및 패싯</target>
        </trans-unit>
        <trans-unit id="d2ba11823ed33de4da4e31b0eebe19082e18127d" translate="yes" xml:space="preserve">
          <source>Localization library</source>
          <target state="translated">현지화 라이브러리</target>
        </trans-unit>
        <trans-unit id="c07f512f68e601c83a418f3dad591a2645430943" translate="yes" xml:space="preserve">
          <source>Localization utilities</source>
          <target state="translated">현지화 유틸리티</target>
        </trans-unit>
        <trans-unit id="dc8dbeb23836a69ebeafc222497183282817c913" translate="yes" xml:space="preserve">
          <source>Localizations</source>
          <target state="translated">Localizations</target>
        </trans-unit>
        <trans-unit id="d71da9d4cb1a804d59d89b1825a9880a0942d7ab" translate="yes" xml:space="preserve">
          <source>Locates the first character in the character array &lt;code&gt;[beg, end)&lt;/code&gt; that does not satisfy the classification mask &lt;code&gt;m&lt;/code&gt;, that is, the first character &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt; would return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">문자 배열의 첫 번째 문자에 위치 &lt;code&gt;[beg, end)&lt;/code&gt; , 분류 마스크를 만족하지 않는 &lt;code&gt;m&lt;/code&gt; , 첫 번째 문자이고, &lt;code&gt;c&lt;/code&gt; 를 되도록 &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="357cdcce80e8002095e52999c10401e1457183fd" translate="yes" xml:space="preserve">
          <source>Locates the first character in the character array &lt;code&gt;[beg, end)&lt;/code&gt; that satisfies the classification mask &lt;code&gt;m&lt;/code&gt;, that is, the first character &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;table()[(unsigned char) c] &amp;amp; m&lt;/code&gt; would return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">문자 배열의 첫 번째 문자에 위치 &lt;code&gt;[beg, end)&lt;/code&gt; 을 만족 분류 마스크 있다는 &lt;code&gt;m&lt;/code&gt; 이고, 첫 문자 &lt;code&gt;c&lt;/code&gt; 되도록 &lt;code&gt;table()[(unsigned char) c] &amp;amp; m&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31e9f816605eb9508f673fc28eb1f9b42210f44e" translate="yes" xml:space="preserve">
          <source>Locates the first occurrence of wide character &lt;code&gt;ch&lt;/code&gt; in the initial &lt;code&gt;count&lt;/code&gt; wide characters of the wide character array pointed to by &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 이 가리키는 와이드 문자 배열 의 초기 &lt;code&gt;count&lt;/code&gt; 와이드 문자 에서 첫 번째 와이드 문자 &lt;code&gt;ch&lt;/code&gt; 를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="14fbab694e4672e756dc11003aa78ae825a8fc71" translate="yes" xml:space="preserve">
          <source>Lock freedom</source>
          <target state="translated">자유 잠금</target>
        </trans-unit>
        <trans-unit id="ee78ba28c676d3bfd6bbd0d0ac4dc1adaedada08" translate="yes" xml:space="preserve">
          <source>Lockable</source>
          <target state="translated">Lockable</target>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="89301c33d91c56fca51d422389610ec0003774ae" translate="yes" xml:space="preserve">
          <source>Locks the associated mutex in shared mode. Effectively calls &lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt;.</source>
          <target state="translated">공유 모드에서 연관된 뮤텍스를 잠급니다. 효과적으로 &lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="0e4c226b5fbb2b899205fcb0ab7e1977150757b6" translate="yes" xml:space="preserve">
          <source>Locks the associated mutex. Effectively calls &lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt;.</source>
          <target state="translated">연관된 뮤텍스를 잠급니다. 효과적으로 &lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="bdeef0016a6ddc17439dd3082bbe560063b4040e" translate="yes" xml:space="preserve">
          <source>Locks the given &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; objects &lt;code&gt;lock1&lt;/code&gt;, &lt;code&gt;lock2&lt;/code&gt;, &lt;code&gt;...&lt;/code&gt;, &lt;code&gt;lockn&lt;/code&gt; using a deadlock avoidance algorithm to avoid deadlock.</source>
          <target state="translated">교착 상태를 피하기 위해 교착 상태 방지 알고리즘을 사용하여 지정된 &lt;a href=&quot;../named_req/lockable&quot;&gt;잠금 가능&lt;/a&gt; 오브젝트 &lt;code&gt;lock1&lt;/code&gt; , &lt;code&gt;lock2&lt;/code&gt; , &lt;code&gt;...&lt;/code&gt; 을 &lt;code&gt;lockn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07953af6eaa80da971053dc23bda5d5c2a2e5a5c" translate="yes" xml:space="preserve">
          <source>Locks the mutex. If another thread has already locked the mutex, a call to &lt;code&gt;lock&lt;/code&gt; will block execution until the lock is acquired.</source>
          <target state="translated">뮤텍스를 잠급니다. 다른 스레드가 이미 뮤텍스를 잠근 경우 &lt;code&gt;lock&lt;/code&gt; 호출 은 잠금을 획득 할 때까지 실행을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="9b108190806dbf643b285b25368b99531689061b" translate="yes" xml:space="preserve">
          <source>Logarithmic in the size of the container in general, but amortized constant if the new element is inserted just before &lt;code&gt;hint&lt;/code&gt;.</source>
          <target state="translated">일반적으로 컨테이너 크기는 로그이지만 새 요소가 &lt;code&gt;hint&lt;/code&gt; 바로 앞에 삽입되면 상수가 상각됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9067460d73ae825ba6714018f7615492aa47865" translate="yes" xml:space="preserve">
          <source>Logarithmic in the size of the container plus linear in the number of the elements found.</source>
          <target state="translated">컨테이너 크기의 로그 + 발견 된 요소 수의 선형</target>
        </trans-unit>
        <trans-unit id="5e5188bc43c4d9b70c9cf627bba80326dacae4d7" translate="yes" xml:space="preserve">
          <source>Logarithmic in the size of the container.</source>
          <target state="translated">컨테이너 크기의 로그.</target>
        </trans-unit>
        <trans-unit id="73b7130da3c78f3712cf8aced2ce52c3b3bb17f4" translate="yes" xml:space="preserve">
          <source>Logarithmic number of comparisons plus the complexity of &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">대수 비교 수에 &lt;code&gt;Container::emplace_back&lt;/code&gt; 의 복잡도를 더한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="58b1b6caf7fe5a42c100cf12c95e7a3c6866c24d" translate="yes" xml:space="preserve">
          <source>Logarithmic number of comparisons plus the complexity of &lt;code&gt;Container::pop_back&lt;/code&gt;.</source>
          <target state="translated">대수 비교 수에 &lt;code&gt;Container::pop_back&lt;/code&gt; 의 복잡도를 더한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="1c3cf65301fe13dbcf804ac556fa2da47b162343" translate="yes" xml:space="preserve">
          <source>Logarithmic number of comparisons plus the complexity of &lt;code&gt;Container::push_back&lt;/code&gt;.</source>
          <target state="translated">대수 비교 수에 &lt;code&gt;Container::push_back&lt;/code&gt; 의 복잡성을 더한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="c5d5c5fb2a8798e4f962780fba63386de96b07b6" translate="yes" xml:space="preserve">
          <source>Logical AND</source>
          <target state="translated">논리 AND</target>
        </trans-unit>
        <trans-unit id="e9b0aefdf7ed2c67abbfc572bbc5743979450674" translate="yes" xml:space="preserve">
          <source>Logical OR</source>
          <target state="translated">논리 OR</target>
        </trans-unit>
        <trans-unit id="ab411408fbd29ad68b53700b2e7826c03e6703f0" translate="yes" xml:space="preserve">
          <source>Logical operations</source>
          <target state="translated">논리 연산</target>
        </trans-unit>
        <trans-unit id="4654c9b2b818a080fc48b5bd5a47f40691d6eb0d" translate="yes" xml:space="preserve">
          <source>Logical operator type traits</source>
          <target state="translated">논리 연산자 유형 특성</target>
        </trans-unit>
        <trans-unit id="a5da835bb3de6e8855950138a28dea23921e5aaa" translate="yes" xml:space="preserve">
          <source>Logical operators</source>
          <target state="translated">논리 연산자</target>
        </trans-unit>
        <trans-unit id="7015ab4fc4ea24735dbe884238cc1b54bf915eca" translate="yes" xml:space="preserve">
          <source>Lookup</source>
          <target state="translated">Lookup</target>
        </trans-unit>
        <trans-unit id="9df7d9cefaf31feb4f6b24d79bad8d071fcb03de" translate="yes" xml:space="preserve">
          <source>Lookup rules</source>
          <target state="translated">조회 규칙</target>
        </trans-unit>
        <trans-unit id="cab4a2117d8f9c8117e26920652c300561edd076" translate="yes" xml:space="preserve">
          <source>Low level memory management</source>
          <target state="translated">저수준 메모리 관리</target>
        </trans-unit>
        <trans-unit id="bd3740e01fb4f11441f7e643cef68b3881c9e618" translate="yes" xml:space="preserve">
          <source>Low-level memory management utilities</source>
          <target state="translated">저수준 메모리 관리 유틸리티</target>
        </trans-unit>
        <trans-unit id="3769a18de297ff08768c9476ca9be5fa9f7cb3ea" translate="yes" xml:space="preserve">
          <source>Lowercase version of &lt;code&gt;ch&lt;/code&gt; or unmodified &lt;code&gt;ch&lt;/code&gt; if no lowercase version is listed in the current C locale.</source>
          <target state="translated">의 소문자 버전 &lt;code&gt;ch&lt;/code&gt; 또는 수정되지 않은 &lt;code&gt;ch&lt;/code&gt; 더 소문자 버전은 현재 C 로케일에 표시되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="befc5b417a1ee8ed446b10341ff5e771b51fffbc" translate="yes" xml:space="preserve">
          <source>Lvalue and rvalue references</source>
          <target state="translated">Lvalue 및 rvalue 참조</target>
        </trans-unit>
        <trans-unit id="3327811a28b6dc92897c7bd726a6ee4cb5edaa0f" translate="yes" xml:space="preserve">
          <source>Lvalue references</source>
          <target state="translated">Lvalue 참조</target>
        </trans-unit>
        <trans-unit id="a213708ed1a0d723b5b6a805c274cf9bff5d1146" translate="yes" xml:space="preserve">
          <source>Lvalue references can be used to alias an existing object (optionally with different cv-qualification):</source>
          <target state="translated">Lvalue 참조를 사용하여 기존 객체의 별칭을 지정할 수 있습니다 (선택적으로 다른 cv-qualification 사용).</target>
        </trans-unit>
        <trans-unit id="08f35d31d723fb0a56bd4bcfd14b0053b8eb609f" translate="yes" xml:space="preserve">
          <source>Lvalue to rvalue conversion</source>
          <target state="translated">L 값에서 R 값으로 변환</target>
        </trans-unit>
        <trans-unit id="43e928199e03709bb299f1077cb46f632464d9e4" translate="yes" xml:space="preserve">
          <source>Lvalue to rvalue conversion (e.g. function call to a function that takes a value).</source>
          <target state="translated">Lvalue를 rvalue로 변환 (예 : 값을 취하는 함수에 대한 함수 호출)</target>
        </trans-unit>
        <trans-unit id="41bc669bb535a7e446d5f35250e723d4b222463a" translate="yes" xml:space="preserve">
          <source>M, ..., a</source>
          <target state="translated">M, ..., a</target>
        </trans-unit>
        <trans-unit id="5de4e334f963f744c52ad0d25e83c8a8e959ae90" translate="yes" xml:space="preserve">
          <source>M, ..., b</source>
          <target state="translated">M, ..., b</target>
        </trans-unit>
        <trans-unit id="a06f1b8f093c7cc11caa03599d07adbc807edfe6" translate="yes" xml:space="preserve">
          <source>MACRON</source>
          <target state="translated">MACRON</target>
        </trans-unit>
        <trans-unit id="850947f3d010de98ad370f2f73bc49ca69c2b7c5" translate="yes" xml:space="preserve">
          <source>MATH_ERRNO</source>
          <target state="translated">MATH_ERRNO</target>
        </trans-unit>
        <trans-unit id="74b7d4ceae8b4d3f14a2b48ce0dd4a45027ad623" translate="yes" xml:space="preserve">
          <source>MATH_ERRNO, MATH_ERREXCEPT, math_errhandling</source>
          <target state="translated">MATH_ERRNO, MATH_ERREXCEPT, math_errhandling</target>
        </trans-unit>
        <trans-unit id="0b26b4988457eebaa5d41abd9af85e69645b9b63" translate="yes" xml:space="preserve">
          <source>MB_CUR_MAX</source>
          <target state="translated">MB_CUR_MAX</target>
        </trans-unit>
        <trans-unit id="6bfcb6f4e22f270971b8066d4c18f2a3c153409a" translate="yes" xml:space="preserve">
          <source>MB_LEN_MAX</source>
          <target state="translated">MB_LEN_MAX</target>
        </trans-unit>
        <trans-unit id="a3de7ac6ae1a36761d2bb7db4fb097d2d59a0d43" translate="yes" xml:space="preserve">
          <source>MIDDLE DOT - MASCULINE ORDINAL INDICATOR</source>
          <target state="translated">중간 점-직진 표시기</target>
        </trans-unit>
        <trans-unit id="0beb871a186f42594bcfbcc8916c8146ec93832e" translate="yes" xml:space="preserve">
          <source>MOESI protocol</source>
          <target state="translated">MOESI 프로토콜</target>
        </trans-unit>
        <trans-unit id="1240ae02c583b36398d148ddc49074ea0ee43ffd" translate="yes" xml:space="preserve">
          <source>MSVC function &lt;code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/e9b52ceh.aspx&quot;&gt;_control87()&lt;/a&gt;&lt;/code&gt; enables trapping of the floating-point exceptions, which generates a hardware exception, which can be converted to C++ exceptions with &lt;code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/5z4bw5h5.aspx&quot;&gt;_set_se_translator&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">MSVC 함수 &lt;code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/e9b52ceh.aspx&quot;&gt;_control87()&lt;/a&gt;&lt;/code&gt; 사용하면 부동 소수점 예외를 트래핑 할 수 있으며 하드웨어 예외를 생성하며 &lt;code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/5z4bw5h5.aspx&quot;&gt;_set_se_translator&lt;/a&gt;&lt;/code&gt; 를 사용 하여 C ++ 예외로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d7ac97eaf33ec3cf9c03bd404689cfd6e8e46fe" translate="yes" xml:space="preserve">
          <source>MSVC function &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/e9b52ceh.aspx&quot;&gt;_control87()&lt;/a&gt;&lt;/code&gt; enables trapping of the floating-point exceptions, which generates a hardware exception, which can be converted to C++ exceptions with &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/5z4bw5h5.aspx&quot;&gt;_set_se_translator&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d6fc761949b6e88739a8a2fe091585d2e12ec1" translate="yes" xml:space="preserve">
          <source>Macro (and function) that saves (and jumps) to an execution context</source>
          <target state="translated">실행 컨텍스트에 저장하고 점프하는 매크로 (및 기능)</target>
        </trans-unit>
        <trans-unit id="54b23dc205b8e1437102e969e0df1e0a65dc7096" translate="yes" xml:space="preserve">
          <source>Macro Constants</source>
          <target state="translated">매크로 상수</target>
        </trans-unit>
        <trans-unit id="fc1086b9f1dd6c6f26d36bd306a911dfb2aafce8" translate="yes" xml:space="preserve">
          <source>Macro constants</source>
          <target state="translated">매크로 상수</target>
        </trans-unit>
        <trans-unit id="2f38b57c7b725c5c9e818e78c55ee7bbba8563a8" translate="yes" xml:space="preserve">
          <source>Macro containing the last error number</source>
          <target state="translated">마지막 오류 번호를 포함하는 매크로</target>
        </trans-unit>
        <trans-unit id="5b3a11a44726526a8271fd69a51140ab465210aa" translate="yes" xml:space="preserve">
          <source>Macro name</source>
          <target state="translated">매크로 이름</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="f314f8acf113225093359e0691186dc638458d3f" translate="yes" xml:space="preserve">
          <source>Macros for data types</source>
          <target state="translated">데이터 타입을위한 매크로</target>
        </trans-unit>
        <trans-unit id="ac71fe79e397b89328648d619d9408673bd60d02" translate="yes" xml:space="preserve">
          <source>Main classes</source>
          <target state="translated">주요 수업</target>
        </trans-unit>
        <trans-unit id="e4ac70ee360a262794e6e975e302e13279210903" translate="yes" xml:space="preserve">
          <source>Main function</source>
          <target state="translated">주요 기능</target>
        </trans-unit>
        <trans-unit id="99859e4cd4b9cce2f83ab42dc587698a3602b044" translate="yes" xml:space="preserve">
          <source>Maintenance overhead</source>
          <target state="translated">유지 관리 오버 헤드</target>
        </trans-unit>
        <trans-unit id="b74e5fa51321d77a94a62fd68d1ad7b564b98a8d" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;language/noexcept_spec&quot;&gt;exception specifications&lt;/a&gt; be part of the type system</source>
          <target state="translated">만들기 &lt;a href=&quot;language/noexcept_spec&quot;&gt;예외 사양은&lt;/a&gt; 타입 시스템의 일부가 될 수</target>
        </trans-unit>
        <trans-unit id="6c08c5931ae98077d74c2fcd13d3f199daa1d289" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;f&lt;/code&gt; the new global &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; and returns the previously installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">만듭니다 &lt;code&gt;f&lt;/code&gt; 를 새로운 글로벌 &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; 반환 이전에 설치 한 &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65917fbeb3c6129587b44cf1b845bea5476e82d9" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;f&lt;/code&gt; the new global terminate handler function and returns the previously installed &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">차종 &lt;code&gt;f&lt;/code&gt; 새로운 글로벌 핸들러 기능을 종료하고, 이전에 설치 한 반환 &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b87d9c9486d3bcd72b7d0fe8b4ab7ceb6d812eec" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;new_p&lt;/code&gt; the new global new-handler function and returns the previously installed new-handler.</source>
          <target state="translated">차종은 &lt;code&gt;new_p&lt;/code&gt; 새로운 세계 새로운 핸들러 함수 반환 이전에 설치 한 새로운 핸들러를.</target>
        </trans-unit>
        <trans-unit id="ec8c940401a44da0f32dd9b030215fd134a7013f" translate="yes" xml:space="preserve">
          <source>Makes the most recently extracted character available again.</source>
          <target state="translated">가장 최근에 추출한 문자를 다시 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="96fe058e3a49999026b621bd5db51a5c913b4002" translate="yes" xml:space="preserve">
          <source>Making &lt;code&gt;&lt;a href=&quot;memory/owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt; more flexible (&lt;a href=&quot;memory/owner_less_void&quot;&gt;&lt;code&gt;std::owner_less&amp;lt;void&amp;gt;&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;memory/owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt; 보다 유연하게 만들기 ( &lt;a href=&quot;memory/owner_less_void&quot;&gt; &lt;code&gt;std::owner_less&amp;lt;void&amp;gt;&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0c16d51463aefe216e81a0bd813cbff2e451ca3d" translate="yes" xml:space="preserve">
          <source>Making a virtual call to a pure virtual function from a constructor or the destructor of the abstract class is undefined behavior (regardless of whether it has a definition or not).</source>
          <target state="translated">추상 클래스의 생성자 또는 소멸자에서 순수 가상 함수를 가상으로 호출하는 것은 정의가 있는지 여부에 관계없이 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="6b8f8ae2577f5b38158790bbc573b214aa51aaaa" translate="yes" xml:space="preserve">
          <source>Making non-modifying sequence operations more robust (two-range overloads for &lt;code&gt;&lt;a href=&quot;algorithm/mismatch&quot;&gt;std::mismatch&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;algorithm/is_permutation&quot;&gt;std::is_permutation&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">수정하지 않는 시퀀스 작업을보다 견고하게 만들기 ( &lt;code&gt;&lt;a href=&quot;algorithm/mismatch&quot;&gt;std::mismatch&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;algorithm/is_permutation&quot;&gt;std::is_permutation&lt;/a&gt;&lt;/code&gt; 2 범위 과부하 )</target>
        </trans-unit>
        <trans-unit id="093902494fcace52d152c76c43c81becca401b50" translate="yes" xml:space="preserve">
          <source>Manages format flags.</source>
          <target state="translated">포맷 플래그를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="9b66e0ff5e969314f7b51fc9d7ca3a9cf4a3c17f" translate="yes" xml:space="preserve">
          <source>Manages the associated distribution parameter set.</source>
          <target state="translated">연관된 분배 매개 변수 세트를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="f62964b0cba3090f15f7c7c169b11e039cc6021f" translate="yes" xml:space="preserve">
          <source>Manages the associated stream buffer.</source>
          <target state="translated">연관된 스트림 버퍼를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="aa5c32a8e138595d4766f2b368480e3dea10b879" translate="yes" xml:space="preserve">
          <source>Manages the contents of the underlying string object.</source>
          <target state="translated">기본 문자열 객체의 내용을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="57d385100206298ef30b732a8a74a273e12fee69" translate="yes" xml:space="preserve">
          <source>Manages the file position state.</source>
          <target state="translated">파일 위치 상태를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="4b0c6baba7868d541df5a1d3ef12c5d69bb016de" translate="yes" xml:space="preserve">
          <source>Manages the fill character used to pad the output conversions to the specified field width.</source>
          <target state="translated">출력 변환을 지정된 필드 너비로 채우는 데 사용되는 채우기 문자를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="fc74e82d452fdfbe907a8fe1326c0b7d7df02587" translate="yes" xml:space="preserve">
          <source>Manages the floating-point rounding direction.</source>
          <target state="translated">부동 소수점 반올림 방향을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="0e6eaddb68bc270047cd5aa7f3b44d9637620333" translate="yes" xml:space="preserve">
          <source>Manages the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold.</source>
          <target state="translated">최대로드 팩터 (버킷 당 요소 수)를 관리합니다. 로드 팩터가이 임계 값을 초과하면 컨테이너가 자동으로 버킷 수를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="daa55aac6e6edc66679c2eb334f89dce6b539bde" translate="yes" xml:space="preserve">
          <source>Manages the minimum number of characters to generate on certain output operations and the maximum number of characters to generate on certain input operations.</source>
          <target state="translated">특정 출력 조작에서 생성 할 최소 문자 수와 특정 입력 조작에서 생성 할 최대 문자 수를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="9111786b8ae1322461661a6b8d566d1d3675a5ed" translate="yes" xml:space="preserve">
          <source>Manages the precision (i.e. how many digits are generated) of floating point output performed by &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt; 의해 수행되는 부동 소수점 출력의 정밀도 (즉, 생성 된 자릿수)를 관리합니다 .</target>
        </trans-unit>
        <trans-unit id="887d2a92b7896a60b0850785e37481b9b04bbad8" translate="yes" xml:space="preserve">
          <source>Manages the status of the floating-point environment.</source>
          <target state="translated">부동 소수점 환경의 상태를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="25d259883659a20164c7acf68339bc48d8362b03" translate="yes" xml:space="preserve">
          <source>Manages the tied stream. A tied stream is an output stream which is synchronized with the sequence controlled by the stream buffer (&lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt;), that is, &lt;code&gt;flush()&lt;/code&gt; is called on the tied stream before any input/output operation on &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">연결된 스트림을 관리합니다. 연결 스트림은 스트림 버퍼 ( &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; )에 의해 제어되는 시퀀스와 동기화되는 출력 스트림입니다 . 즉, &lt;code&gt;*this&lt;/code&gt; 에 대한 입력 / 출력 조작 전에 연결 스트림에서 &lt;code&gt;flush()&lt;/code&gt; 가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="e42c0bcf36c095bb9efb82dcb299ae099631d5a9" translate="yes" xml:space="preserve">
          <source>Manipulators</source>
          <target state="translated">Manipulators</target>
        </trans-unit>
        <trans-unit id="aa5986c6a9620c6b6e1856b7e2e600fe262ff7db" translate="yes" xml:space="preserve">
          <source>Manipulators are helper functions that make it possible to control input/output streams using &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">조작자는 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 또는 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 사용하여 입력 / 출력 스트림을 제어 할 수있는 도우미 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="0ce8863df9e71406305b90f9ea018e8bb9b2e809" translate="yes" xml:space="preserve">
          <source>Many classes in the standard library overload &lt;code&gt;operator()&lt;/code&gt; to be used as function objects.</source>
          <target state="translated">표준 라이브러리의 많은 클래스는 함수 객체로 사용되는 &lt;code&gt;operator()&lt;/code&gt; 를 오버로드 합니다.</target>
        </trans-unit>
        <trans-unit id="0edc88ddffd739223885d2fe9cd8f80ed597ff78" translate="yes" xml:space="preserve">
          <source>Many compilers also implement the non-standard &lt;a href=&quot;impl&quot;&gt;&lt;code&gt;pragma&lt;/code&gt;&lt;/a&gt;&lt;code&gt;#pragma once&lt;/code&gt; with similar effects: it disables processing of a file if the same file (where file identity is determined in OS-specific way) has already been included.</source>
          <target state="translated">많은 컴파일러는 비슷한 효과 로 비표준 &lt;a href=&quot;impl&quot;&gt; &lt;code&gt;pragma&lt;/code&gt; &lt;/a&gt; &lt;code&gt;#pragma once&lt;/code&gt; 구현합니다 . 동일한 파일 (파일 ID가 OS 별 방식으로 결정된 경우)이 이미 포함 된 경우 파일 처리를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6f405e95e132707ef26ac64e6bc3fe82236e30e2" translate="yes" xml:space="preserve">
          <source>Many compilers issue &quot;strict aliasing&quot; warnings in such cases, even though technically such constructs run afoul of something other than the paragraph commonly known as the &quot;strict aliasing rule&quot;.</source>
          <target state="translated">기술적으로 그러한 구조가 일반적으로 &quot;엄격한 앨리어싱 규칙&quot;으로 알려진 단락 이외의 것을 실행하더라도 많은 컴파일러는 이러한 경우 &quot;엄격한 앨리어싱&quot;경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="e9f40adecaac3afe40b8b2e36b992f8de08d6cdf" translate="yes" xml:space="preserve">
          <source>Many implementations also provide &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total ordering&lt;/a&gt; of pointers of random origin, e.g. if they are implemented as addresses within continuous virtual address space. Those implementations that do not (e.g. where not all bits of the pointer are part of a memory address and have to be ignored for comparison, or an additional calculation is required or otherwise pointer and integer is not a 1 to 1 relationship), provide a specialization of &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; for pointers that has that guarantee. This makes it possible to use all pointers of random origin as keys in standard associative containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">많은 구현들은 또한 임의의 원점 포인터의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;엄격한 총 순서&lt;/a&gt; 를 제공 한다. (예를 들어, 포인터의 모든 비트가 메모리 주소의 일부가 아니며 비교를 위해 무시되거나, 추가 계산이 필요하거나 포인터와 정수가 1 : 1 관계가 아닌 경우) 구현은 다음을 제공합니다. &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; 전문화 는 그 보증이있는 포인터에 적합합니다. 이를 통해 &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; 과 같은 표준 연관 컨테이너에서 무작위 원점의 모든 포인터를 키로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6df4f43ab58f853f38804bd87ed02d4813b8bfca" translate="yes" xml:space="preserve">
          <source>Many implementations do not update the get area in &lt;code&gt;seekpos()&lt;/code&gt;, delegating to &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; that is called by the next &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">많은 구현에서는 &lt;code&gt;seekpos()&lt;/code&gt; 의 get 영역을 업데이트하지 않고 다음 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt; 의해 호출되는 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 위임합니다 .</target>
        </trans-unit>
        <trans-unit id="f68fed89e22619f36d034e4ae6b5e591f90adb28" translate="yes" xml:space="preserve">
          <source>Many low-level OS APIs for directory traversal retrieve file attributes along with the next directory entry. The constructors and the non-const member functions of &lt;code&gt;directory_iterator&lt;/code&gt; store these attributes, if any, in the pointed-to &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; without calling &lt;a href=&quot;refresh&quot;&gt;&lt;code&gt;directory_entry::refresh&lt;/code&gt;&lt;/a&gt;, which makes it possible to examine the attributes of the directory entries as they are being iterated over, without making additional system calls.</source>
          <target state="translated">디렉토리 탐색을위한 많은 저수준 OS API는 다음 디렉토리 항목과 함께 파일 속성을 검색합니다. &lt;code&gt;directory_iterator&lt;/code&gt; 의 생성자와 const가 아닌 멤버 함수는 directory_entry &lt;a href=&quot;refresh&quot;&gt; &lt;code&gt;directory_entry::refresh&lt;/code&gt; &lt;/a&gt; 를 호출하지 않고 point_to- &lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt; 에 이러한 속성을 저장 합니다. 추가 시스템 호출없이</target>
        </trans-unit>
        <trans-unit id="039f47ebbed9ac7270772eb78d294ff20051a865" translate="yes" xml:space="preserve">
          <source>Many low-level OS APIs for directory traversal retrieve file attributes along with the next directory entry. The constructors and the non-const member functions of &lt;code&gt;directory_iterator&lt;/code&gt; store these attributes, if any, in the pointed-to &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; without calling &lt;strong&gt;&lt;code&gt;directory_entry::refresh&lt;/code&gt;&lt;/strong&gt;, which makes it possible to examine the attributes of the directory entries as they are being iterated over, without making additional system calls.</source>
          <target state="translated">디렉토리 탐색을위한 많은 저수준 OS API는 다음 디렉토리 항목과 함께 파일 속성을 검색합니다. &lt;code&gt;directory_iterator&lt;/code&gt; 의 생성자와 const가 아닌 멤버 함수는 directory_entry &lt;strong&gt; &lt;code&gt;directory_entry::refresh&lt;/code&gt; &lt;/strong&gt; 를 호출하지 않고 point_to- &lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt; 에 이러한 속성을 저장 합니다. 추가 시스템 호출없이&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ed89c2f28cb830995daa3a7b4042d44d35eeacb" translate="yes" xml:space="preserve">
          <source>Many low-level OS APIs for directory traversal retrieve file attributes along with the next directory entry. The constructors and the non-const member functions of &lt;code&gt;directory_iterator&lt;/code&gt; store these attributes, if any, in the pointed-to &lt;a href=&quot;directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; without calling &lt;a href=&quot;directory_entry/refresh&quot;&gt;&lt;code&gt;directory_entry::refresh&lt;/code&gt;&lt;/a&gt;, which makes it possible to examine the attributes of the directory entries as they are being iterated over, without making additional system calls.</source>
          <target state="translated">디렉토리 탐색을위한 많은 저수준 OS API는 다음 디렉토리 항목과 함께 파일 속성을 검색합니다. &lt;code&gt;directory_iterator&lt;/code&gt; 의 생성자와 const가 아닌 멤버 함수는 directory_entry &lt;a href=&quot;directory_entry/refresh&quot;&gt; &lt;code&gt;directory_entry::refresh&lt;/code&gt; &lt;/a&gt; 를 호출하지 않고 point_to- &lt;a href=&quot;directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt; 에 이러한 속성을 저장 합니다. 추가 시스템 호출없이</target>
        </trans-unit>
        <trans-unit id="e5aebdb8c7063bd86b2ac2bb9180c0f2ca620fad" translate="yes" xml:space="preserve">
          <source>Many standard library functions (for example, many algorithms) expect their arguments to satisfy Swappable, which means that any time the standard library performs a swap, it uses the equivalent of &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(t, u);&lt;/code&gt;.</source>
          <target state="translated">많은 표준 라이브러리 함수 (예를 들어, 많은 알고리즘)을 만족 스왑 그들의 인수를 기대하는 수단 언제든지 스왑, 그것의 동등한 사용하는 표준 라이브러리를 수행 &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(t, u);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5121f00841245e1a12c2ae4fef43200d5c0249fe" translate="yes" xml:space="preserve">
          <source>Many standard library functions expect their arguments to satisfy ValueSwappable, which means that any time the standard library performs a swap, it uses the equivalent of &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(*iter1, *iter2);&lt;/code&gt;.</source>
          <target state="translated">많은 표준 라이브러리 함수는 인수가 ValueSwappable을 만족할 것으로 예상합니다. 즉, 표준 라이브러리가 스왑을 수행 할 때마다 &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(*iter1, *iter2);&lt;/code&gt; 사용과 동등한 기능을 사용합니다 . 스왑 (* iter1, * iter2); .</target>
        </trans-unit>
        <trans-unit id="afe6902aeefe49078fe8050bd00528c238507028" translate="yes" xml:space="preserve">
          <source>Maps the wide character &lt;code&gt;wc&lt;/code&gt; using the current C locale's LC_CTYPE mapping category identified by &lt;code&gt;desc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;desc&lt;/code&gt; 로 식별 된 현재 C 로케일의 LC_CTYPE 맵핑 범주를 사용하여 와이드 문자 &lt;code&gt;wc&lt;/code&gt; 를 맵핑 합니다.</target>
        </trans-unit>
        <trans-unit id="4077ecc006514db344c55f8c4fad2c745c0130ce" translate="yes" xml:space="preserve">
          <source>Marks a declaration, a group of declarations, or another module as exported by the current module.</source>
          <target state="translated">현재 모듈에서 내 보낸 선언, 선언 그룹 또는 다른 모듈을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b756154598ee707bf908cd000d9935386991975f" translate="yes" xml:space="preserve">
          <source>Matches a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">리터럴 &lt;code&gt;%&lt;/code&gt; 문자와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="72f947b49a5a8e988f9298c168a0e3f58111d4e5" translate="yes" xml:space="preserve">
          <source>Matches one whitespace character.</source>
          <target state="translated">하나의 공백 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="fcfacbcdbc0dc12100a2ddcea744584b78974f4f" translate="yes" xml:space="preserve">
          <source>Matches zero or one whitespace character.</source>
          <target state="translated">공백 문자 0 개 또는 1 개를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="a188c6effe4bde401e7ad28544fc6e87a9daffac" translate="yes" xml:space="preserve">
          <source>Matching of &lt;a href=&quot;language/template_parameters#Template_template_arguments&quot;&gt;template template-arguments&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;language/template_parameters#Template_template_arguments&quot;&gt;템플릿 템플릿 인수의&lt;/a&gt; 일치</target>
        </trans-unit>
        <trans-unit id="20eb57cf8e0dada9d1ba105b859145de9af95dd7" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic cosine is cosh z =</source>
          <target state="translated">쌍곡 코사인의 수학적 정의는 cosh z =</target>
        </trans-unit>
        <trans-unit id="26750d755fd0345482bcbffe431aa399db954d60" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic sine is sinh z =</source>
          <target state="translated">쌍곡 사인의 수학적 정의는 sinh z =</target>
        </trans-unit>
        <trans-unit id="e84aec3fc0130942848a9f7d933b06ea09b78dbd" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic tangent is tanh z =</source>
          <target state="translated">쌍곡 탄젠트의 수학적 정의는 tanh z =</target>
        </trans-unit>
        <trans-unit id="cdb41af16e4d375b018b261d1a2817a89b9975b7" translate="yes" xml:space="preserve">
          <source>Mathematical functions and types</source>
          <target state="translated">수학 함수 및 유형</target>
        </trans-unit>
        <trans-unit id="e69584469298924788f58d14e045618717167ab1" translate="yes" xml:space="preserve">
          <source>Mathematical special functions</source>
          <target state="translated">수학적 특수 함수</target>
        </trans-unit>
        <trans-unit id="86c50200efef0be47369777679929f798cf2e81a" translate="yes" xml:space="preserve">
          <source>Mathematical special functions for C++17</source>
          <target state="translated">C ++ 17을위한 수학 특수 함수</target>
        </trans-unit>
        <trans-unit id="5d307dd0d56fc9ce2efcd46807c5cc26c88385c1" translate="yes" xml:space="preserve">
          <source>Mathematics argument out of domain of function</source>
          <target state="translated">기능 영역에서 벗어난 수학 인수</target>
        </trans-unit>
        <trans-unit id="f8777efcd5a7cb7cda3c0f39eeda95994a1a15e9" translate="yes" xml:space="preserve">
          <source>Maxcode</source>
          <target state="translated">Maxcode</target>
        </trans-unit>
        <trans-unit id="d3dc367122aa7293e5afbfae55b89a3439308677" translate="yes" xml:space="preserve">
          <source>Maximum number of buckets.</source>
          <target state="translated">최대 버킷 수</target>
        </trans-unit>
        <trans-unit id="149a459f54b376ce18459ec98c8686438b039d4d" translate="yes" xml:space="preserve">
          <source>Maximum number of characters.</source>
          <target state="translated">최대 문자 수</target>
        </trans-unit>
        <trans-unit id="40479cd9e5c70abfcec7f229a5343100ee1e982b" translate="yes" xml:space="preserve">
          <source>Maximum number of elements.</source>
          <target state="translated">최대 요소 수</target>
        </trans-unit>
        <trans-unit id="74c9f71fbcac6b3790990dc6749cb13cfcb51bec" translate="yes" xml:space="preserve">
          <source>Maximum number of submatches.</source>
          <target state="translated">최대 부분 일치 수</target>
        </trans-unit>
        <trans-unit id="c386253a5eac67332c4d54f0c89f27e31946d1fa" translate="yes" xml:space="preserve">
          <source>May also throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if additional memory required for internal data structures cannot be allocated.</source>
          <target state="translated">또한 던질 수 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 내부 데이터 구조에 필요한 추가 메모리를 할당 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="3b12ceeda37fe6a0712324b0b075665414e87d72" translate="yes" xml:space="preserve">
          <source>May appear in the declaration of a non-static &lt;a href=&quot;data_members&quot;&gt;class members&lt;/a&gt; of non-reference non-const type:</source>
          <target state="translated">비 참조 비 const 유형의 비 정적 &lt;a href=&quot;data_members&quot;&gt;클래스 멤버&lt;/a&gt; 선언에 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b266289267f1b69728db3ede6cf1835744b3fe8f" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://gcc.godbolt.org/z/6itUO1&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="translated">( &lt;a href=&quot;https://gcc.godbolt.org/z/6itUO1&quot;&gt;demo&lt;/a&gt; ) 로 컴파일 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c7f6ea88007fac3556846ed6f0bd902e3dfa12f" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://godbolt.org/z/QYZvsl&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="translated">( &lt;a href=&quot;https://godbolt.org/z/QYZvsl&quot;&gt;demo&lt;/a&gt; ) 로 컴파일 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70f7c1e91932b1a70687c4ebae101b3db1ba5098" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://godbolt.org/z/e2bC84&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="translated">( &lt;a href=&quot;https://godbolt.org/z/e2bC84&quot;&gt;demo&lt;/a&gt; ) 로 컴파일 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17b2c58fc2da61849ab101eba953459e4980b963" translate="yes" xml:space="preserve">
          <source>May only be applied to a &lt;a href=&quot;../statements#Expression_statements&quot;&gt;null statement&lt;/a&gt; to create a</source>
          <target state="translated">&lt;a href=&quot;../statements#Expression_statements&quot;&gt;null 문&lt;/a&gt; 에만 적용 하여</target>
        </trans-unit>
        <trans-unit id="5b24b967e2517fdf19db9e1d07428b9424c7e88d" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;, may also propagate exceptions thrown by &lt;a href=&quot;../unique_lock/lock&quot;&gt;&lt;code&gt;lock.lock()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../unique_lock/unlock&quot;&gt;&lt;code&gt;lock.unlock()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 던질 수 있으며 &lt;a href=&quot;../unique_lock/lock&quot;&gt; &lt;code&gt;lock.lock()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../unique_lock/unlock&quot;&gt; &lt;code&gt;lock.unlock()&lt;/code&gt; &lt;/a&gt; 의해 발생 된 예외를 전파 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82f82cbc23b684cfee57e315e7faddcf81a5e024" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;, may also propagate exceptions thrown by &lt;code&gt;lock.lock()&lt;/code&gt; or &lt;code&gt;lock.unlock()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 던질 수 있으며 &lt;code&gt;lock.lock()&lt;/code&gt; 또는 &lt;code&gt;lock.unlock()&lt;/code&gt; 의해 발생 된 예외를 전파 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c170df4323127a54ff75977e5aea172641a66b1" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if an exception is thrown during output.</source>
          <target state="translated">던질 수 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 예외가 출력시 발생되는 경우.</target>
        </trans-unit>
        <trans-unit id="9537e9cfb9ff89dce06742cc44b6f80d289fe969" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; on stream errors.</source>
          <target state="translated">던질 수 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 스트림 오류에.</target>
        </trans-unit>
        <trans-unit id="74e16b22a77e8236ce676f4f2f124c10d8901a2b" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 생성자 에서 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 을 던질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cab3d4a6660b25cecf735f777424ba412487e934" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::wstring&lt;/a&gt;&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::wstring&lt;/a&gt;&lt;/code&gt; 생성자 에서 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 을 던질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="962f83e06ea50e04d31c9f8437b97c5191adb569" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; from the the &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 생성자 에서 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 을 던질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f18fce82e50be7509279d8759683168fd690cfd" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">던질 수 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 메모리 할당이 실패 할 경우.</target>
        </trans-unit>
        <trans-unit id="eb0efb1fe6c128b1e051773ebaffa4603c205e9c" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 던질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ba6e5262639e253495b627007f9b05da37e203d" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;exceptions()&amp;amp;badbit!=0&lt;/code&gt;.</source>
          <target state="translated">던질 수 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 하는 경우 &lt;code&gt;exceptions()&amp;amp;badbit!=0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1533fcb442ebdf84b8b8136c017750a808b170e" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; in case of failure, if &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt;.</source>
          <target state="translated">던질 수 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 실패의 경우, 경우에 &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaa5c6b529feaa58739bd67ba50e2fb2001b4fb7" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 던질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88e82c73c9f5acd5341c52abeb46b516d79c0a4c" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if the system cannot allocate memory required to track reachable objects.</source>
          <target state="translated">던질 수 &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 시스템에 할당 할 수없는 경우 메모리 접근 할 객체를 추적해야합니다.</target>
        </trans-unit>
        <trans-unit id="50334b4e66ee014f5ce48f4fae49d65f13d9afac" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, the functions have no effect. If an exception is thrown during the construction of the array, already-initialized elements are destroyed in reverse order.(since C++20).</source>
          <target state="translated">던질 수 &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 또는 생성자에 의해 throw되는 예외 &lt;code&gt;T&lt;/code&gt; 를 . 예외가 발생하면 기능이 적용되지 않습니다. 배열을 구성하는 동안 예외가 발생하면 이미 초기화 된 요소가 역순으로 소멸됩니다 (C ++ 20 이후).</target>
        </trans-unit>
        <trans-unit id="fdfbbb46059a0d2dcd9098fe9a358cdc6c64a4b0" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, this function has no effect.</source>
          <target state="translated">던질 수 &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 또는 생성자에 의해 throw되는 예외 &lt;code&gt;T&lt;/code&gt; 를 . 예외가 발생하면이 기능은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3490986d7e9db538d6473a2861a95a9c29b566de" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; when setting the badbit.</source>
          <target state="translated">던질 수 &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; badbit을 설정할 때.</target>
        </trans-unit>
        <trans-unit id="55d3334b217863c436b19298f8ac48b6aa3046e7" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; to indicate an &lt;a href=&quot;error_type&quot;&gt;error condition&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;error_type&quot;&gt;오류 조건&lt;/a&gt; 을 나타 내기 위해 &lt;code&gt;&lt;a href=&quot;regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; 를 던질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2aac967544933ac46c56aad850b11b876e778a6" translate="yes" xml:space="preserve">
          <source>May throw any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;, typically including &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 포함하여 &lt;code&gt;T&lt;/code&gt; 의 생성자가 던진 예외를 던질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="295aca95b34c6da649adb7e8f83289b1503b3665" translate="yes" xml:space="preserve">
          <source>May throw any exceptions thrown by &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::allocate()&lt;/code&gt;, such as &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::allocate()&lt;/code&gt; 의해 발생 된 예외 ( 예 : &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d89ff13f4c0ab3dc3033aad665ca0c8a7d4a1d6" translate="yes" xml:space="preserve">
          <source>May throw any exceptions thrown by the call to &lt;code&gt;allocate_object&lt;/code&gt; or the constructor of &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">assign_object 호출 또는 &lt;code&gt;U&lt;/code&gt; 생성자에 의해 발생 된 예외를 throw 할 &lt;code&gt;allocate_object&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdf7c3ace6d1c50a2a552ed9dfc67f2851b5de5c" translate="yes" xml:space="preserve">
          <source>May throw any exceptions thrown by the call to &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt; 호출로 인해 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="014505538b8bc36d85ed833b2d3a182aea673970" translate="yes" xml:space="preserve">
          <source>Meaningless C headers</source>
          <target state="translated">무의미한 C 헤더</target>
        </trans-unit>
        <trans-unit id="6853c98a6f4358bbfed1b3b9c81d308649299b0f" translate="yes" xml:space="preserve">
          <source>Member</source>
          <target state="translated">Member</target>
        </trans-unit>
        <trans-unit id="d880b0db33396f09e94ad458e37bf499710140d0" translate="yes" xml:space="preserve">
          <source>Member access</source>
          <target state="translated">회원 액세스</target>
        </trans-unit>
        <trans-unit id="b14800487e886a905875d25619be005b0bb88353" translate="yes" xml:space="preserve">
          <source>Member access does not affect visibility: names of private and privately-inherited members are visible and considered by overload resolution, implicit conversions to inaccessible base classes are still considered, etc. Member access check is the last step after any given language construct is interpreted. The intent of this rule is that replacing any &lt;code&gt;private&lt;/code&gt; with &lt;code&gt;public&lt;/code&gt; never alters the behavior of the program.</source>
          <target state="translated">멤버 액세스는 가시성에 영향을 미치지 않습니다. 프라이빗 및 프라이빗 상속 멤버의 이름은 오버로드 확인으로 볼 수 있고 고려되며 액세스 할 수없는 기본 클래스로의 암시 적 변환은 여전히 ​​고려됩니다. 멤버 액세스 확인은 주어진 언어 구성이 해석 된 후 마지막 단계입니다. 이 규칙의 목적은 &lt;code&gt;private&lt;/code&gt; 을 &lt;code&gt;public&lt;/code&gt; 바꾸면 프로그램의 동작이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf9ba14f65379b3cac2135b4415ee8ccd2ae4dbf" translate="yes" xml:space="preserve">
          <source>Member access operators</source>
          <target state="translated">회원 액세스 운영자</target>
        </trans-unit>
        <trans-unit id="0dbd252428ccbd0d975da572dc34df0626898460" translate="yes" xml:space="preserve">
          <source>Member alias templates</source>
          <target state="translated">회원 별명 템플릿</target>
        </trans-unit>
        <trans-unit id="c618f84bc8f235803205b6351cb60f5fe7b25f6f" translate="yes" xml:space="preserve">
          <source>Member classes</source>
          <target state="translated">회원 클래스</target>
        </trans-unit>
        <trans-unit id="53b558837f61bee946a0dd1ce0e5906eb1fbb225" translate="yes" xml:space="preserve">
          <source>Member constant</source>
          <target state="translated">멤버 상수</target>
        </trans-unit>
        <trans-unit id="11178f71158bbe4d9b5ae241f21a139cf3506414" translate="yes" xml:space="preserve">
          <source>Member constants</source>
          <target state="translated">멤버 상수</target>
        </trans-unit>
        <trans-unit id="14511f9334df9fc1bdabba7170aa8468f6d02cfd" translate="yes" xml:space="preserve">
          <source>Member function</source>
          <target state="translated">회원 기능</target>
        </trans-unit>
        <trans-unit id="e7d2a79cda830630ecf28efb73b93f5d64c726ea" translate="yes" xml:space="preserve">
          <source>Member function &lt;code&gt;operator()&lt;/code&gt;</source>
          <target state="translated">멤버 함수 &lt;code&gt;operator()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d34638b7646acd7bec35ca244b9f93a8a851424" translate="yes" xml:space="preserve">
          <source>Member function definition</source>
          <target state="translated">멤버 함수 정의</target>
        </trans-unit>
        <trans-unit id="08497771fff890fda9af78587c591fe51ef91e55" translate="yes" xml:space="preserve">
          <source>Member function table</source>
          <target state="translated">멤버 함수 테이블</target>
        </trans-unit>
        <trans-unit id="55bb0b5562e8411fcb96bbac022a9f6ac7ea4d1b" translate="yes" xml:space="preserve">
          <source>Member function templates</source>
          <target state="translated">멤버 함수 템플릿</target>
        </trans-unit>
        <trans-unit id="b217f7514e4e69fd38aa7c54a821e91e41f619c3" translate="yes" xml:space="preserve">
          <source>Member functions</source>
          <target state="translated">회원 기능</target>
        </trans-unit>
        <trans-unit id="980cb8724fcd1049e2076cf5101d5771adc84b3d" translate="yes" xml:space="preserve">
          <source>Member functions (including virtual member functions) can be called from member initializers, but the behavior is undefined if not all direct bases are initialized at that point.</source>
          <target state="translated">멤버 이니셜 라이저에서 멤버 함수 (가상 멤버 함수 포함)를 호출 할 수 있지만 해당 시점에서 모든 직접베이스가 초기화되지 않은 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de7182652ce370c94f7c684b95c200a783818dee" translate="yes" xml:space="preserve">
          <source>Member functions of a local class have no linkage</source>
          <target state="translated">로컬 클래스의 멤버 함수에는 연결이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5d511dbaf6e4bdbdd2335cea43d07a07ffcc20d" translate="yes" xml:space="preserve">
          <source>Member functions of a local class have to be defined entirely inside the class body</source>
          <target state="translated">로컬 클래스의 멤버 함수는 클래스 본문 내부에서 완전히 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0656eb615cbde62fa5517f8cf8a8d9f0cd48715c" translate="yes" xml:space="preserve">
          <source>Member initialization</source>
          <target state="translated">멤버 초기화</target>
        </trans-unit>
        <trans-unit id="0b96269b9ecb978e0c0b9cfaf7fa59a36ac1af38" translate="yes" xml:space="preserve">
          <source>Member initializers and aggregates</source>
          <target state="translated">멤버 이니셜 라이저 및 집계</target>
        </trans-unit>
        <trans-unit id="19bedac337c4148b66c642456a9ebdfc9f5a6c88" translate="yes" xml:space="preserve">
          <source>Member lifetime</source>
          <target state="translated">회원 평생</target>
        </trans-unit>
        <trans-unit id="d2fbdd7c0d6a0fe8e113aa296a28047ef253149d" translate="yes" xml:space="preserve">
          <source>Member name</source>
          <target state="translated">회원 이름</target>
        </trans-unit>
        <trans-unit id="74fa726e3f14b875e371e46176a78863344d0e2a" translate="yes" xml:space="preserve">
          <source>Member name lookup</source>
          <target state="translated">회원 이름 조회</target>
        </trans-unit>
        <trans-unit id="fde74c71ca6b1383761e00548de51dddc150302d" translate="yes" xml:space="preserve">
          <source>Member object</source>
          <target state="translated">멤버 객체</target>
        </trans-unit>
        <trans-unit id="d4037494affff8e1187b4614057e3d3856936fa0" translate="yes" xml:space="preserve">
          <source>Member objects</source>
          <target state="translated">멤버 객체</target>
        </trans-unit>
        <trans-unit id="7c1c4577121db570224d4e6d1b453b5fee33ebf0" translate="yes" xml:space="preserve">
          <source>Member of a class template outside of template</source>
          <target state="translated">템플릿 외부의 클래스 템플릿 멤버</target>
        </trans-unit>
        <trans-unit id="fcf850420e837ff3777a4510c350a70dc493bb17" translate="yes" xml:space="preserve">
          <source>Member of object</source>
          <target state="translated">객체의 멤버</target>
        </trans-unit>
        <trans-unit id="4300f5098631ebd1c4cf89699b5b4370fc4f18ee" translate="yes" xml:space="preserve">
          <source>Member or a member template may be nested within many enclosing class templates. In an explicit specialization for such a member, there's a &lt;code&gt;template&amp;lt;&amp;gt;&lt;/code&gt; for every enclosing class template that is explicitly specialized.</source>
          <target state="translated">멤버 또는 멤버 템플릿은 많은 엔 클로징 클래스 템플릿 내에 중첩 될 수 있습니다. 이러한 멤버에 대한 명시 적 전문화에는 명시 적으로 특수화 된 모든 클래스 클래스 템플리트에 대한 &lt;code&gt;template&amp;lt;&amp;gt;&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2fae0c7a45f97c1ebd785be8d844ad4e439ae3c" translate="yes" xml:space="preserve">
          <source>Member specification</source>
          <target state="translated">멤버 사양</target>
        </trans-unit>
        <trans-unit id="87b9dbba6959e8f157ca46a3351b964abfdee42b" translate="yes" xml:space="preserve">
          <source>Member templates</source>
          <target state="translated">회원 템플릿</target>
        </trans-unit>
        <trans-unit id="d7ae56afa08fe3824c2cd242b7909d3e66c1ecc3" translate="yes" xml:space="preserve">
          <source>Member type</source>
          <target state="translated">회원 유형</target>
        </trans-unit>
        <trans-unit id="55c0692816e400cc9f1e8bcd75e4a14f74352890" translate="yes" xml:space="preserve">
          <source>Member type &lt;code&gt;result_type&lt;/code&gt;</source>
          <target state="translated">멤버 유형 &lt;code&gt;result_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22c15de225ed427b7d10b0a6ea94574676a92b6e" translate="yes" xml:space="preserve">
          <source>Member types</source>
          <target state="translated">회원 유형</target>
        </trans-unit>
        <trans-unit id="2a9c2afdee2bf076807c340c63de865c0262cc04" translate="yes" xml:space="preserve">
          <source>Member types and constants</source>
          <target state="translated">멤버 타입과 상수</target>
        </trans-unit>
        <trans-unit id="8e74c7d99d2202da874a715a8b5fbfbc2b8cb4db" translate="yes" xml:space="preserve">
          <source>Member variable templates</source>
          <target state="translated">멤버 변수 템플릿</target>
        </trans-unit>
        <trans-unit id="1cb449c1126609b4b41e1d87f65f0d7cd19b49b9" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Members</target>
        </trans-unit>
        <trans-unit id="84f16231bc3f47eb66803d5355786879bfe2e29d" translate="yes" xml:space="preserve">
          <source>Members identical to std::optional</source>
          <target state="translated">std :: optional과 동일한 멤버</target>
        </trans-unit>
        <trans-unit id="8441142a0e7debda365fc2602acee6048f15bbbe" translate="yes" xml:space="preserve">
          <source>Members of &lt;a href=&quot;union&quot;&gt;anonymous unions&lt;/a&gt; cannot be captured.</source>
          <target state="translated">&lt;a href=&quot;union&quot;&gt;익명 조합의&lt;/a&gt; 멤버는 캡처 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="02c67b9d74374d2cbad42e0e00560d1e26c88740" translate="yes" xml:space="preserve">
          <source>Members of an anonymous union are injected in the enclosing scope (and must not conflict with other names declared there).</source>
          <target state="translated">익명 공용체의 멤버는 포함 범위에 삽입되며 여기에 선언 된 다른 이름과 충돌해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b8b5ab3d00ea4a372f20b27f763c84738411ec47" translate="yes" xml:space="preserve">
          <source>Members of an inline namespace are treated as if they are members of the enclosing namespace in many situations (listed below). This property is transitive: if a namespace N contains an inline namespace M, which in turn contains an inline namespace O, then the members of O can be used as though they were members of M or N.</source>
          <target state="translated">인라인 네임 스페이스의 멤버는 여러 상황에서 (아래에 나열된) 둘러싸는 네임 스페이스의 멤버 인 것처럼 처리됩니다. 이 속성은 전 이적입니다. 네임 스페이스 N에 인라인 네임 스페이스 M이 있고 인라인 네임 스페이스 O가 포함 된 경우 O의 멤버는 마치 M 또는 N의 멤버 인 것처럼 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8586c2e60536f02fc22562f8abc3249a46b2b677" translate="yes" xml:space="preserve">
          <source>Members of array type cannot deduce their size from member initializers:</source>
          <target state="translated">배열 유형의 멤버는 멤버 초기화 프로그램에서 크기를 추론 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ab44845744014b08b5a156f5657ab462609baf4" translate="yes" xml:space="preserve">
          <source>Members of partial specializations</source>
          <target state="translated">부분 전문화의 구성원</target>
        </trans-unit>
        <trans-unit id="208131f2e00ae33985ce221300cd22605d845623" translate="yes" xml:space="preserve">
          <source>Members of partial specializations are not related to the members of the primary template.</source>
          <target state="translated">부분 전문화 영역의 구성원은 기본 템플릿의 구성원과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="856df469166bb63fb5a5f500f0b2fd7e30149e12" translate="yes" xml:space="preserve">
          <source>Members of specializations</source>
          <target state="translated">전문화 멤버</target>
        </trans-unit>
        <trans-unit id="177c4eb396c6113e03b1ec47971bf87273b4f749" translate="yes" xml:space="preserve">
          <source>Members of the current instantiation may be both dependent and non-dependent.</source>
          <target state="translated">현재 인스턴스화의 멤버는 종속적이거나 비의존적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e686f3fba635d862001096dc688423be262661a" translate="yes" xml:space="preserve">
          <source>Members of unknown specialization are always dependent, and are looked up and bound at the point of instantiation as all dependent names (see above).</source>
          <target state="translated">알려지지 않은 전문화 영역의 구성원은 항상 종속적이며 인스턴스화 지점에서 모든 종속 이름으로 조회 및 바인딩됩니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="b61b70edbe3a97caa2ecb5ac100b7aca209a1cba" translate="yes" xml:space="preserve">
          <source>Memory allocation</source>
          <target state="translated">메모리 할당</target>
        </trans-unit>
        <trans-unit id="c839b2598611d3f060e76b276a742153340abc1c" translate="yes" xml:space="preserve">
          <source>Memory is released back to the upstream resource even if &lt;code&gt;deallocate&lt;/code&gt; has not been called for some of the allocated blocks.</source>
          <target state="translated">할당 된 블록 중 일부에 대해 할당 &lt;code&gt;deallocate&lt;/code&gt; 가 호출되지 않은 경우에도 메모리가 업스트림 리소스로 다시 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="bdea69651115220379a7626fdc86765943dcd523" translate="yes" xml:space="preserve">
          <source>Memory leaks</source>
          <target state="translated">메모리 누수</target>
        </trans-unit>
        <trans-unit id="f8b9af79a08c4c809a8587ce76e5d96c65e611a2" translate="yes" xml:space="preserve">
          <source>Memory location</source>
          <target state="translated">메모리 위치</target>
        </trans-unit>
        <trans-unit id="1c5536b98ab016fe61807564b4a34c80211a7613" translate="yes" xml:space="preserve">
          <source>Memory management</source>
          <target state="translated">메모리 관리</target>
        </trans-unit>
        <trans-unit id="ab97ff6f2dba5d3f1cd5aeb9b43d517c7ff39baa" translate="yes" xml:space="preserve">
          <source>Memory model</source>
          <target state="translated">메모리 모델</target>
        </trans-unit>
        <trans-unit id="9c23e8bd787dd8370f724a94edc52271e09548bc" translate="yes" xml:space="preserve">
          <source>Memory model and data races</source>
          <target state="translated">메모리 모델 및 데이터 레이스</target>
        </trans-unit>
        <trans-unit id="6b03cc66f3ec38d27d0315d16067b31e093e9aea" translate="yes" xml:space="preserve">
          <source>Memory order</source>
          <target state="translated">메모리 순서</target>
        </trans-unit>
        <trans-unit id="650d40654b9659dd0612cce810ff5fea98b79081" translate="yes" xml:space="preserve">
          <source>Memory resources</source>
          <target state="translated">메모리 자원</target>
        </trans-unit>
        <trans-unit id="4203c5ba750ba970dd9f023b43c81a0fd337c099" translate="yes" xml:space="preserve">
          <source>Memory resources implement memory allocation strategies that can be used by &lt;code&gt;&lt;a href=&quot;memory/polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">메모리 자원은 &lt;code&gt;&lt;a href=&quot;memory/polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt; 사용할 수있는 메모리 할당 전략을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a26524a9138484663e1a18b861e087f36fe4484a" translate="yes" xml:space="preserve">
          <source>Memory synchronization ordering</source>
          <target state="translated">메모리 동기화 순서</target>
        </trans-unit>
        <trans-unit id="813e99320a4c03b9ad6cec6f1e925a0b781749db" translate="yes" xml:space="preserve">
          <source>Mergeable</source>
          <target state="translated">Mergeable</target>
        </trans-unit>
        <trans-unit id="e8960ff445c6c6fffe8acbabe2366e4cbf4abc97" translate="yes" xml:space="preserve">
          <source>Merges two consecutive sorted ranges &lt;code&gt;[first, middle)&lt;/code&gt; and &lt;code&gt;[middle, last)&lt;/code&gt; into one sorted range &lt;code&gt;[first, last)&lt;/code&gt;. For equivalent elements in the original two ranges, the elements from the first range (preserving their original order) precede the elements from the second range (preserving their original order).</source>
          <target state="translated">두 개의 연속 정렬 된 범위 &lt;code&gt;[first, middle)&lt;/code&gt; 및 &lt;code&gt;[middle, last)&lt;/code&gt; 를 하나의 정렬 된 범위 &lt;code&gt;[first, last)&lt;/code&gt; 병합 합니다. 원래 두 범위의 동등한 요소의 경우 첫 번째 범위의 요소 (원래 순서 유지)가 두 번째 범위의 요소 (원래 순서 유지)보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="348e4e60780310e575bfb01a962f7cd5abae550b" translate="yes" xml:space="preserve">
          <source>Merges two sorted lists into one. The lists should be sorted into ascending order.</source>
          <target state="translated">정렬 된 두 목록을 하나로 병합합니다. 목록은 오름차순으로 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="62e4dd6599b3076f4c7e24d143d22cfe633e9e61" translate="yes" xml:space="preserve">
          <source>Merges two sorted ranges &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;[first2, last2)&lt;/code&gt; into one sorted range beginning at &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="translated">두 개의 정렬 된 범위 &lt;code&gt;[first1, last1)&lt;/code&gt; 및 &lt;code&gt;[first2, last2)&lt;/code&gt; 를 &lt;code&gt;d_first&lt;/code&gt; 에서 시작하여 하나의 정렬 된 범위로 병합 합니다.</target>
        </trans-unit>
        <trans-unit id="be990907531784c554a9a73c087e598fb1ce6368" translate="yes" xml:space="preserve">
          <source>Message too large</source>
          <target state="translated">너무 큰 메시지</target>
        </trans-unit>
        <trans-unit id="461fdb47a2520c8a10c99484faf4d44d448c8df5" translate="yes" xml:space="preserve">
          <source>Metafunctions and detection idiom</source>
          <target state="translated">메타 기능 및 탐지 관용구</target>
        </trans-unit>
        <trans-unit id="07195d88dee403459dfced037630ce1c768e14de" translate="yes" xml:space="preserve">
          <source>Metaprogramming and type traits</source>
          <target state="translated">메타 프로그래밍 및 유형 특성</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="932b125ec81f14231f7250288b48b92b461a8de5" translate="yes" xml:space="preserve">
          <source>Methods and operators</source>
          <target state="translated">방법과 연산자</target>
        </trans-unit>
        <trans-unit id="67dd111ccc6d0d86efc4c55e49ca364b9cb96922" translate="yes" xml:space="preserve">
          <source>Microsoft Visual Studio stores just those three members.</source>
          <target state="translated">Microsoft Visual Studio는이 세 멤버 만 저장합니다.</target>
        </trans-unit>
        <trans-unit id="47dddb5186287e21994356577aa0866b4c1d8ea3" translate="yes" xml:space="preserve">
          <source>Microsoft also extends the specification of fflush by defining its effects on an input stream: in Visual Studio 2013 and prior, it &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/9yky46tz(v=vs.120)&quot;&gt;discarded the input buffer&lt;/a&gt;, in Visual Studio 2015 and newer, it &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot;&gt;has no effect, buffers are retained&lt;/a&gt;.</source>
          <target state="translated">Microsoft는 또한 입력 스트림에 대한 효과를 정의하여 fflush의 사양을 확장합니다. Visual Studio 2013 및 이전 버전에서는 &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/9yky46tz(v=vs.120)&quot;&gt;입력 버퍼를 버리고&lt;/a&gt; Visual Studio 2015 이상 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot;&gt;에서는 버퍼가 유지되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1e6ca7ba44f07ef77ced3289ef9027ae3985768" translate="yes" xml:space="preserve">
          <source>Minimal incomplete type support for standard containers</source>
          <target state="translated">표준 컨테이너에 대한 최소 불완전한 유형 지원</target>
        </trans-unit>
        <trans-unit id="039230108efa19823a7b4883634eb496fa5690f9" translate="yes" xml:space="preserve">
          <source>Minimum/maximum operations</source>
          <target state="translated">최소 / 최대 작업</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="9f352649528dbc4b941a3c142ba8ef1c7ced2ff5" translate="yes" xml:space="preserve">
          <source>Miscellaneous algorithms and math</source>
          <target state="translated">기타 알고리즘 및 수학</target>
        </trans-unit>
        <trans-unit id="7d1b5fe97a66d6423d5658882ed141e544353f5f" translate="yes" xml:space="preserve">
          <source>Miscellaneous transformations</source>
          <target state="translated">기타 변환</target>
        </trans-unit>
        <trans-unit id="acace02a8a5c263c4d1a277ad3914f44e1003ded" translate="yes" xml:space="preserve">
          <source>Miscellanous</source>
          <target state="translated">Miscellanous</target>
        </trans-unit>
        <trans-unit id="b2168739b0a770dbc449ab787b7f9985648b3334" translate="yes" xml:space="preserve">
          <source>Mixed categories</source>
          <target state="translated">혼합 카테고리</target>
        </trans-unit>
        <trans-unit id="781cc7f1a888cc264c3daec6aa247cc3fa4f8d16" translate="yes" xml:space="preserve">
          <source>Mixing &lt;code&gt;auto&lt;/code&gt; variables and functions in one declaration, as in &lt;code&gt;auto f() -&amp;gt; int, i = 0;&lt;/code&gt; is not allowed.</source>
          <target state="translated">&lt;code&gt;auto f() -&amp;gt; int, i = 0;&lt;/code&gt; 에서와 같이 &lt;code&gt;auto&lt;/code&gt; 변수와 함수를 하나의 선언으로 혼합 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="c8d28082b4fc6c7b86480f164e10796d9ee93fa2" translate="yes" xml:space="preserve">
          <source>Modification of the element denoted by this iterator is permitted, but results in undefined behavior if the resulting value does not satisfy the filter's predicate.</source>
          <target state="translated">이 반복자로 표시된 요소의 수정은 허용되지만 결과 값이 필터의 술어를 만족하지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fde60483a8643008b46b560bb3120711a8d791b9" translate="yes" xml:space="preserve">
          <source>Modification order</source>
          <target state="translated">수정 순서</target>
        </trans-unit>
        <trans-unit id="f7d91c2034d3989f0f9d751cdc240eeaa5a1f0bd" translate="yes" xml:space="preserve">
          <source>Modified first or last element</source>
          <target state="translated">첫 번째 또는 마지막 요소 수정</target>
        </trans-unit>
        <trans-unit id="5ae95629e2c8d41b6f08c30afaaf87f67a8aeb67" translate="yes" xml:space="preserve">
          <source>Modified middle only</source>
          <target state="translated">수정 된 중간 만</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="4ab3cf9c369166302907228f36238db8a9f5670f" translate="yes" xml:space="preserve">
          <source>Modifies the default formatting for floating-point input/output.</source>
          <target state="translated">부동 소수점 입 / 출력의 기본 형식을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="15f0dab11aac15b6b8ac3cdd786afb259b8c6d63" translate="yes" xml:space="preserve">
          <source>Modifies the default numeric base for integer I/O.</source>
          <target state="translated">정수 I / O의 기본 숫자 기준을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="e948b2b964fb2481f64aff925d09ed89d0d5aac5" translate="yes" xml:space="preserve">
          <source>Modifies the default positioning of the fill characters. &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; apply to any output, &lt;code&gt;internal&lt;/code&gt; applies to integer, floating-point, and monetary output. Has no effect on input.</source>
          <target state="translated">채우기 문자의 기본 위치를 수정합니다. &lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;right&lt;/code&gt; 은 모든 출력에 적용되고 &lt;code&gt;internal&lt;/code&gt; 는 정수, 부동 소수점 및 통화 출력에 적용됩니다. 입력에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f0803b14853f0ca1c462262bd06651312d6fd2a" translate="yes" xml:space="preserve">
          <source>Modifies the integer type. Can be mixed in any order. Only one of each group can be present in type name.</source>
          <target state="translated">정수 유형을 수정합니다. 어떤 순서로도 혼합 할 수 있습니다. 각 그룹 중 하나만 유형 이름에 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d554ea1e6c13dd8a9b9dcc293f7edfd4d7e0bab2" translate="yes" xml:space="preserve">
          <source>Modifies the point in time &lt;code&gt;*this&lt;/code&gt; represents by one tick of the &lt;code&gt;duration&lt;/code&gt;.</source>
          <target state="translated">특정 시점 수정 &lt;code&gt;*this&lt;/code&gt; &lt;code&gt;duration&lt;/code&gt; 1 틱으로 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ac257bedb96e8a5ed9f2d761616b185ecd321a9f" translate="yes" xml:space="preserve">
          <source>Modifies the time point &lt;code&gt;*this&lt;/code&gt; represents by the duration &lt;code&gt;dy&lt;/code&gt; or &lt;code&gt;dm&lt;/code&gt;.</source>
          <target state="translated">시점을 수정합니다. &lt;code&gt;*this&lt;/code&gt; &lt;code&gt;dy&lt;/code&gt; 또는 &lt;code&gt;dm&lt;/code&gt; 기간으로 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="0109c0f778cd7e5d5f58cdb0bef696d2ed4bfbeb" translate="yes" xml:space="preserve">
          <source>Modifies the time point by the given duration.</source>
          <target state="translated">주어진 지속 시간으로 시점을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="b99643bd9f016aabf23ffef5df0d85745e624465" translate="yes" xml:space="preserve">
          <source>Modifying sequence operations</source>
          <target state="translated">시퀀스 작업 수정</target>
        </trans-unit>
        <trans-unit id="2b3cc44d73da07886ee8baef1ee867321f0ada02" translate="yes" xml:space="preserve">
          <source>Modifying the object references through the returned pointer is undefined behavior.</source>
          <target state="translated">반환 된 포인터를 통해 객체 참조를 수정하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="ebfc8aea76355cffda7dc26e5f6ffed8b15e2998" translate="yes" xml:space="preserve">
          <source>Modifying the string returned by &lt;code&gt;getenv&lt;/code&gt; invokes undefined behavior.</source>
          <target state="translated">&lt;code&gt;getenv&lt;/code&gt; 가 리턴 한 문자열을 수정 하면 정의되지 않은 동작이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="5c27456bde155168271b9f0d0a03593e3d004434" translate="yes" xml:space="preserve">
          <source>Modules (since C++20)</source>
          <target state="translated">모듈 (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="87aa2b5a478fd2bc39c2606c02ad3374b1b33a57" translate="yes" xml:space="preserve">
          <source>Modules are orthogonal to &lt;a href=&quot;namespace&quot;&gt;namespaces&lt;/a&gt;.</source>
          <target state="translated">모듈은 &lt;a href=&quot;namespace&quot;&gt;네임 스페이스&lt;/a&gt; 와 직교 합니다 .</target>
        </trans-unit>
        <trans-unit id="15b644db7c27b8824e56787512daf5e002e08b35" translate="yes" xml:space="preserve">
          <source>Modules help divide large amounts of code into logical parts.</source>
          <target state="translated">모듈은 많은 양의 코드를 논리적 부분으로 나누는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ba486ce8a0bc9ff868847c4d17e3966a68af4067" translate="yes" xml:space="preserve">
          <source>Monetary numeric formatting parameters</source>
          <target state="translated">통화 숫자 형식화 매개 변수</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="8a88993f3238117d849d456cb7e4e84ee89d728a" translate="yes" xml:space="preserve">
          <source>Month, day, year (american) order</source>
          <target state="translated">월, 일, 년 (미국) 주문</target>
        </trans-unit>
        <trans-unit id="d08db9b01ebe6924d7a1bf996c9b0ed0b4fab126" translate="yes" xml:space="preserve">
          <source>More formally, &lt;code&gt;nth_element&lt;/code&gt; partially sorts the range &lt;code&gt;[first, last)&lt;/code&gt; in ascending order so that the condition &lt;code&gt;!(*j &amp;lt; *i)&lt;/code&gt; (for (1-2), or &lt;code&gt;comp(*j, *i) == false&lt;/code&gt; for (3-4)) is met for any &lt;code&gt;i&lt;/code&gt; in the range &lt;code&gt;[first, nth)&lt;/code&gt; and for any &lt;code&gt;j&lt;/code&gt; in the range &lt;code&gt;[nth, last)&lt;/code&gt;. The element placed in the &lt;code&gt;nth&lt;/code&gt; position is exactly the element that would occur in this position if the range was fully sorted.</source>
          <target state="translated">보다 공식적으로, &lt;code&gt;nth_element&lt;/code&gt; 는 범위 &lt;code&gt;[first, last)&lt;/code&gt; 를 부분적으로 오름차순 으로 정렬하여 조건 &lt;code&gt;!(*j &amp;lt; *i)&lt;/code&gt; ((1-2)의 경우 또는 &lt;code&gt;comp(*j, *i) == false&lt;/code&gt; 경우 ( 3-4))는 &lt;code&gt;[first, nth)&lt;/code&gt; 범위의 모든 &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;[nth, last)&lt;/code&gt; 범위의 모든 &lt;code&gt;j&lt;/code&gt; 에 대해 충족됩니다 . &lt;code&gt;nth&lt;/code&gt; 위치에 배치 된 요소는 범위가 완전히 정렬 된 경우이 위치에서 발생하는 요소입니다.</target>
        </trans-unit>
        <trans-unit id="8ad85aba1e03e90f4ea308da91cb434da83f1201" translate="yes" xml:space="preserve">
          <source>More generally, a declaration that appears in any namespace scope and introduces a name using an unqualified identifier always introduces a member into the namespace it's in and not to any other namespace. The exceptions are explicit instantiations and explicit specializations of a primary template that is defined in an inline namespace: because they do not introduce a new name, they may use unqualified-id in an enclosing namespace.</source>
          <target state="translated">보다 일반적으로, 네임 스페이스 범위에 나타나고 규정되지 않은 식별자를 사용하여 이름을 소개하는 선언은 항상 다른 네임 스페이스가 아닌 멤버를 네임 스페이스에 도입합니다. 인라인 네임 스페이스에 정의 된 기본 템플릿의 명시 적 인스턴스화 및 명시 적 특수화는 예외입니다. 새로운 이름을 도입하지 않기 때문에 엔 클로징 네임 스페이스에서 unqualified-id를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aced5c6bdae8930320b0a84e8806de43ea20de7e" translate="yes" xml:space="preserve">
          <source>More importantly, when a function has both rvalue reference and lvalue reference &lt;a href=&quot;overload_resolution&quot;&gt;overloads&lt;/a&gt;, the rvalue reference overload binds to rvalues (including both prvalues and xvalues), while the lvalue reference overload binds to lvalues:</source>
          <target state="translated">더 중요한 것은 함수에 rvalue 참조와 lvalue 참조 &lt;a href=&quot;overload_resolution&quot;&gt;과부하&lt;/a&gt; 가 모두 있는 경우 rvalue 참조 과부하는 rvalue (prvalue 및 xvalue 모두 포함)에 바인딩되고 lvalue 참조 과부하는 lvalue에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="042cb75d428b075638d2d6b2981b93fb7100eec4" translate="yes" xml:space="preserve">
          <source>More precisely,</source>
          <target state="translated">더 정확하게,</target>
        </trans-unit>
        <trans-unit id="12d2d8c92f9d4fd32f5f1106d05e584341d60749" translate="yes" xml:space="preserve">
          <source>More precisely, if &lt;code&gt;T&lt;/code&gt; is an object type, then &lt;code&gt;CopyConstructible&amp;lt;T&amp;gt;&lt;/code&gt; is satisfied only if given.</source>
          <target state="translated">더 정확하게 말하면, &lt;code&gt;T&lt;/code&gt; 가 객체 유형이면 &lt;code&gt;CopyConstructible&amp;lt;T&amp;gt;&lt;/code&gt; 는 주어진 경우에만 만족됩니다.</target>
        </trans-unit>
        <trans-unit id="390ebcb02784fc921ce7255ea43ab7b5c0c22766" translate="yes" xml:space="preserve">
          <source>More precisely, if &lt;code&gt;T&lt;/code&gt; is an object type, then &lt;code&gt;MoveConstructible&amp;lt;T&amp;gt;&lt;/code&gt; is satisfied only if given.</source>
          <target state="translated">보다 정확하게 말하면, &lt;code&gt;T&lt;/code&gt; 가 객체 유형이면 &lt;code&gt;MoveConstructible&amp;lt;T&amp;gt;&lt;/code&gt; 는 주어진 경우에만 만족됩니다.</target>
        </trans-unit>
        <trans-unit id="abf4cfe7b468de981e652ab471007fe1cf184911" translate="yes" xml:space="preserve">
          <source>Moreover, if a class is</source>
          <target state="translated">또한 수업이</target>
        </trans-unit>
        <trans-unit id="155edc9b15c11dc21e1b4548edbad4e1215c059f" translate="yes" xml:space="preserve">
          <source>Moreover, the specialization has to be more specialized than the primary template.</source>
          <target state="translated">또한 전문화 과정은 기본 템플릿보다 전문화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="efb9a37b6f75f2498f990faf5ad9f0869a407c15" translate="yes" xml:space="preserve">
          <source>Most algorithms have overloads that accept execution policies. The standard library algorithms support several &lt;a href=&quot;algorithm/execution_policy_tag_t&quot;&gt;execution policies&lt;/a&gt;, and the library provides corresponding execution policy types and objects. Users may select an execution policy statically by invoking a parallel algorithm with an &lt;a href=&quot;algorithm/execution_policy_tag&quot;&gt;execution policy object&lt;/a&gt; of the corresponding type.</source>
          <target state="translated">대부분의 알고리즘에는 실행 정책을 허용하는 과부하가 있습니다. 표준 라이브러리 알고리즘은 여러 &lt;a href=&quot;algorithm/execution_policy_tag_t&quot;&gt;실행 정책을&lt;/a&gt; 지원 하며 라이브러리는 해당 실행 정책 유형 및 객체를 제공합니다. 사용자는 해당 유형 의 &lt;a href=&quot;algorithm/execution_policy_tag&quot;&gt;실행 정책 개체&lt;/a&gt; 로 병렬 알고리즘을 호출하여 실행 정책을 정적으로 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc6a96c2bf79396b900217be397fde454fb98507" translate="yes" xml:space="preserve">
          <source>Most concepts in the standard library impose both syntactic and semantic requirements. In general, only the syntactic requirements can be checked by the compiler. If a semantic requirement is not met at the point of use, the program is ill-formed, no diagnostic required.</source>
          <target state="translated">표준 라이브러리의 대부분의 개념은 구문 및 의미 요구 사항을 모두 적용합니다. 일반적으로 구문 요구 사항 만 컴파일러에서 확인할 수 있습니다. 사용 시점에서 시맨틱 요구 사항이 충족되지 않으면 프로그램이 잘못 구성되고 진단이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="781816a1d277bbc9eb1433baedd102171fdafd77" translate="yes" xml:space="preserve">
          <source>Most containers have at least several member functions in common, and share functionalities. Which container is the best for the particular application depends not only on the offered functionality, but also on its efficiency for different workloads.</source>
          <target state="translated">대부분의 컨테이너에는 공통적으로 여러 멤버 함수가 있으며 기능을 공유합니다. 특정 응용 프로그램에 가장 적합한 컨테이너는 제공되는 기능뿐만 아니라 다양한 작업 부하의 효율성에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="e62a8c15144afd6bef7aa39651c138fe6e1aae25" translate="yes" xml:space="preserve">
          <source>Most multibyte character encodings use single-byte codes to represent the characters from the ASCII character set. This function may be used to convert such characters to &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="translated">대부분의 멀티 바이트 문자 인코딩은 단일 바이트 코드를 사용하여 ASCII 문자 세트의 문자를 나타냅니다. 이 함수는 이러한 문자를 &lt;code&gt;wchar_t&lt;/code&gt; 로 변환하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c598cbf439c8837b1ca206b16302fc6a8e671f8" translate="yes" xml:space="preserve">
          <source>Most of the classes are templated, so they can be adapted to any basic character type. Separate typedefs are provided for the most common basic character types (&lt;code&gt;char&lt;/code&gt; and &lt;code&gt;wchar_t&lt;/code&gt;). The classes are organized into the following hierarchy:</source>
          <target state="translated">대부분의 클래스는 템플릿으로되어 있으므로 기본 문자 유형에 맞게 조정할 수 있습니다. 가장 일반적인 기본 문자 유형 ( &lt;code&gt;char&lt;/code&gt; 및 &lt;code&gt;wchar_t&lt;/code&gt; )에 대해 별도의 typedef가 제공됩니다 . 클래스는 다음과 같은 계층으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="096ace82e91d90831e1c4645b3d45c6185c05537" translate="yes" xml:space="preserve">
          <source>Most statements in a typical C++ program are expression statements, such as assignments or function calls.</source>
          <target state="translated">일반적인 C ++ 프로그램에서 대부분의 명령문은 할당 또는 함수 호출과 같은 표현식 명령문입니다.</target>
        </trans-unit>
        <trans-unit id="a2333535991c67ef2e86e131a8535fb756804d7f" translate="yes" xml:space="preserve">
          <source>Movable</source>
          <target state="translated">Movable</target>
        </trans-unit>
        <trans-unit id="0a9ed9691d6eeb1d4822ae73e0c5eadefaad241c" translate="yes" xml:space="preserve">
          <source>Move assignment operator</source>
          <target state="translated">할당 연산자 이동</target>
        </trans-unit>
        <trans-unit id="47bc76102bfdfe08b85837682799b53a220e67af" translate="yes" xml:space="preserve">
          <source>Move assignment operator. Replaces the contents with those of &lt;code&gt;other&lt;/code&gt; using move semantics.</source>
          <target state="translated">할당 연산자를 이동하십시오. 이동 의미론을 사용하여 내용을 &lt;code&gt;other&lt;/code&gt; 내용으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="9faeffa8862f7a244a0700c0596d5af7fc217adc" translate="yes" xml:space="preserve">
          <source>Move assignment operators typically &quot;steal&quot; the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc.), rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state. For example, move-assigning from a &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; or from a &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; may result in the argument being left empty. This is not, however, a guarantee. A move assignment is less, not more restrictively defined than ordinary assignment; where ordinary assignment must leave two copies of data at completion, move assignment is required to leave only one.</source>
          <target state="translated">할당 할당 연산자는 일반적으로 인수가 보유한 리소스 (예 : 동적으로 할당 된 객체, 파일 설명자, TCP 소켓, I / O 스트림, 실행중인 스레드 등의 포인터)를 &quot;훔치고&quot;복사하지 않습니다. 일부 유효하지만 불확실한 상태의 인수. 예를 들어 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 에서 이동 할당 하면 인수가 비어있을 수 있습니다. 그러나 이것이 보장되는 것은 아닙니다. 이동 배정은 일반 배정보다 덜 제한적이지 않고 덜 제한적입니다. 일반 할당이 완료 될 때 두 개의 데이터 사본을 남겨 두어야하는 경우 이동 할당은 하나만 남겨 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="389a7c6fdc797b8f1865d27d1759a2d438b0f975" translate="yes" xml:space="preserve">
          <source>Move assigns the file stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move는 &lt;code&gt;*this&lt;/code&gt; &lt;code&gt;other&lt;/code&gt; 의 파일 스트림 을 할당하여 &lt;code&gt;&lt;a href=&quot;../basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; 기본 클래스와 관련 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 효과적으로 이동 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="24f428bf7dd6f1e0c847ba71b49720a8f401e750" translate="yes" xml:space="preserve">
          <source>Move assigns the file stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move는 &lt;code&gt;*this&lt;/code&gt; &lt;code&gt;other&lt;/code&gt; 의 파일 스트림 을 할당하여 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 기본 클래스와 관련 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 효과적으로 이동 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="16356f1d24da83c00f7fba21a216c445c97ce389" translate="yes" xml:space="preserve">
          <source>Move assigns the file stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move는 &lt;code&gt;*this&lt;/code&gt; &lt;code&gt;other&lt;/code&gt; 의 파일 스트림 을 할당하여 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 기본 클래스와 관련 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 효과적으로 이동 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="33ed75bd9ae7d7e710f7cb59e2701e5a3f320cb2" translate="yes" xml:space="preserve">
          <source>Move assigns the string stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move는 &lt;code&gt;*this&lt;/code&gt; &lt;code&gt;other&lt;/code&gt; 의 문자열 스트림 을 할당하여 &lt;code&gt;&lt;a href=&quot;../basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; 기본 클래스와 관련 &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; 효과적으로 이동 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="8b304cb7e35b160ac11b6e6da6fcb29cbf8bd2ea" translate="yes" xml:space="preserve">
          <source>Move assigns the string stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move는 &lt;code&gt;*this&lt;/code&gt; &lt;code&gt;other&lt;/code&gt; 의 문자열 스트림 을 할당하여 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 기본 클래스와 관련 &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; 효과적으로 이동 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="49accf919a08e0856fd5c2205f087017e46e4554" translate="yes" xml:space="preserve">
          <source>Move assigns the string stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move는 &lt;code&gt;*this&lt;/code&gt; &lt;code&gt;other&lt;/code&gt; 의 문자열 스트림 을 할당하여 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 기본 클래스와 관련 &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; 효과적으로 이동 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="f3459363ce95b7b8d213432c0b3912511b7bb422" translate="yes" xml:space="preserve">
          <source>Move constructor</source>
          <target state="translated">생성자 이동</target>
        </trans-unit>
        <trans-unit id="dabcb34f032395075663b5ab1b4ca93fa1b421af" translate="yes" xml:space="preserve">
          <source>Move constructor of &lt;code&gt;A&lt;/code&gt; must not throw exceptions</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 이동 생성자는 예외를 발생시키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="76c87719ef4631d051ec31847319db90f2a38c3c" translate="yes" xml:space="preserve">
          <source>Move constructors</source>
          <target state="translated">생성자 이동</target>
        </trans-unit>
        <trans-unit id="2a326707754a17c67859bb0d4a68df79e51ee6cb" translate="yes" xml:space="preserve">
          <source>Move constructors are usually noexcept, since otherwise they are unusable in any code that provides strong exception guarantee.</source>
          <target state="translated">Move 생성자는 일반적으로 예외가 아닙니다. 그렇지 않으면 강력한 예외 보장을 제공하는 모든 코드에서 사용할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="81267231da879e100dbc03825b8c3e0a2957c4a3" translate="yes" xml:space="preserve">
          <source>Move constructors obtain their instances of allocators by move-constructing from the allocator belonging to the old container.</source>
          <target state="translated">이동 생성자는 이전 컨테이너에 속한 할당 자에서 이동을 생성하여 할당 자의 인스턴스를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="137fb2f17f31808cc157fa054ef5ad4347edeebc" translate="yes" xml:space="preserve">
          <source>Move constructors typically &quot;steal&quot; the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc.) rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state. For example, moving from a &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; or from a &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; may result in the argument being left empty. However, this behavior should not be relied upon. For some types, such as &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, the moved-from state is fully specified.</source>
          <target state="translated">생성자는 일반적으로 인수가 보유한 자원 (예 : 동적으로 할당 된 객체, 파일 설명자, TCP 소켓, I / O 스트림, 실행중인 스레드에 대한 포인터)을 복사하지 않고 &quot;도용&quot;하고 인수를 그대로 둡니다. 유효하지만 결정되지 않은 상태. 예를 들어 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 에서 이동하면 인수가 비어있을 수 있습니다. 그러나이 동작에 의존해서는 안됩니다. &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 과 같은 일부 유형의 경우 이동 된 상태가 완전히 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="a87e8b5e582f2bbe391df33ee67064ce26cb64b8" translate="yes" xml:space="preserve">
          <source>Move semantics make it possible to safely transfer resource ownership between objects, across scopes, and in and out of threads, while maintaining resource safety.</source>
          <target state="translated">이동 의미론을 사용하면 리소스 안전성을 유지하면서 개체 간, 범위 및 스레드 내외에서 리소스 소유권을 안전하게 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="539161ece173c055968a1a1de35756020b668502" translate="yes" xml:space="preserve">
          <source>Move-assignment will replace the allocator only if &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만 이동 할당이 할당자를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="2a2b02d69358e93089fbaa89a49b928011b4e236" translate="yes" xml:space="preserve">
          <source>Move-assigns a synchronized output stream:</source>
          <target state="translated">동기화 된 출력 스트림을 이동 할당합니다.</target>
        </trans-unit>
        <trans-unit id="729a0dfe5f81eedccb7e27b2fac2b5add97556cb" translate="yes" xml:space="preserve">
          <source>MoveAssignable</source>
          <target state="translated">MoveAssignable</target>
        </trans-unit>
        <trans-unit id="502c9efbaad373888b5ccbb225e0b2b8dcc695c1" translate="yes" xml:space="preserve">
          <source>MoveConstructible</source>
          <target state="translated">MoveConstructible</target>
        </trans-unit>
        <trans-unit id="47b28d1ca8cc2963e3c114ddac02f3738d7266e5" translate="yes" xml:space="preserve">
          <source>MoveInsertable</source>
          <target state="translated">MoveInsertable</target>
        </trans-unit>
        <trans-unit id="0cba8c550dfeac021edea6a142972a2b3c4254ac" translate="yes" xml:space="preserve">
          <source>Moves elements from another &lt;code&gt;forward_list&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">다른 &lt;code&gt;forward_list&lt;/code&gt; 에서 &lt;code&gt;*this&lt;/code&gt; 로 요소를 이동 합니다 .</target>
        </trans-unit>
        <trans-unit id="f642e2f2760b86f5ae81c771704418f0a85fea71" translate="yes" xml:space="preserve">
          <source>Moves or renames the filesystem object identified by &lt;code&gt;old_p&lt;/code&gt; to &lt;code&gt;new_p&lt;/code&gt; as if by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html&quot;&gt;rename&lt;/a&gt;:</source>
          <target state="translated">이동 또는로 식별되는 파일 시스템 객체의 이름을 변경 &lt;code&gt;old_p&lt;/code&gt; 에 &lt;code&gt;new_p&lt;/code&gt; 는 POSIX에 의해 것처럼 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html&quot;&gt;이름 바꾸기를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f8c4f952db4952b742d95751551e39d3d9452537" translate="yes" xml:space="preserve">
          <source>Moves or renames the filesystem object identified by &lt;code&gt;old_p&lt;/code&gt; to &lt;code&gt;new_p&lt;/code&gt; as if by the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html&quot;&gt;rename&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f6470d9b55060017967677bfa10f722a11ccd6" translate="yes" xml:space="preserve">
          <source>Moves the elements from the range &lt;code&gt;[first, last)&lt;/code&gt;, to another range ending at &lt;code&gt;d_last&lt;/code&gt;. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved.</source>
          <target state="translated">&lt;code&gt;[first, last)&lt;/code&gt; 범위에서 &lt;code&gt;d_last&lt;/code&gt; 로 끝나는 다른 범위로 요소를 이동합니다 . 요소는 역순으로 이동하지만 (마지막 요소가 먼저 이동 됨) 상대 순서는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="502b5aeda54563820fc7b31c565eaaa6bcbf6e12" translate="yes" xml:space="preserve">
          <source>Moves the end of the view back by &lt;code&gt;n&lt;/code&gt; characters.</source>
          <target state="translated">보기의 끝을 &lt;code&gt;n&lt;/code&gt; 자로 뒤로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="e55336fdb98f11cedfd0e48efbdbb786db1d30e0" translate="yes" xml:space="preserve">
          <source>Moves the file position indicator to the beginning of the given file stream.</source>
          <target state="translated">파일 위치 표시기를 지정된 파일 스트림의 시작 부분으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="2fd746e8e68c6c51da4d2e5d3dd279e473ac3ff3" translate="yes" xml:space="preserve">
          <source>Moves the iterator one level up in the directory hierarchy. Invalidates all copies of the previous value of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">디렉토리 계층에서 반복기를 한 레벨 위로 이동합니다. 이전 값 &lt;code&gt;*this&lt;/code&gt; 의 모든 사본을 무효화합니다 .</target>
        </trans-unit>
        <trans-unit id="725b5a475515852bdc56678fa33e316b36e459ef" translate="yes" xml:space="preserve">
          <source>Moves the start of the view forward by &lt;code&gt;n&lt;/code&gt; characters.</source>
          <target state="translated">보기 시작을 &lt;code&gt;n&lt;/code&gt; 자로 앞으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="7135dfbadfa84a70be0103c96edea84447561b3b" translate="yes" xml:space="preserve">
          <source>Multibyte/wide character conversion</source>
          <target state="translated">멀티 바이트 / 와이드 문자 변환</target>
        </trans-unit>
        <trans-unit id="737f5043d52ad9a5bf99e386e8ced8ff5c737ec0" translate="yes" xml:space="preserve">
          <source>Multibyte/wide character conversions</source>
          <target state="translated">멀티 바이트 / 와이드 문자 변환</target>
        </trans-unit>
        <trans-unit id="b816bfbe5973e3f1a932359a517a19fd4cc2d3aa" translate="yes" xml:space="preserve">
          <source>Multicharacter literals were inherited by C from the B programming language. Although not specified by the C or C++ standard, compilers implement multicharacter literals as specified in B: the values of each char in the literal initialize successive bytes of the resulting integer, in big-endian zero-padded right-adjusted order, e.g. the value of &lt;code&gt;'\1'&lt;/code&gt; is &lt;code&gt;0x00000001&lt;/code&gt; and the value of &lt;code&gt;'\1\2\3\4'&lt;/code&gt; is &lt;code&gt;0x01020304&lt;/code&gt;.</source>
          <target state="translated">다중 문자 리터럴은 B 프로그래밍 언어에서 C로 상속되었습니다. C 또는 C ++ 표준에 의해 지정되지 않았지만 컴파일러는 B에 지정된대로 다중 문자 리터럴을 구현합니다. 리터럴의 각 문자 값은 결과 정수의 연속 바이트를 빅 엔디안 0으로 채워진 오른쪽으로 조정 된 순서로 초기화합니다 (예 : 값). 의 &lt;code&gt;'\1'&lt;/code&gt; 인 &lt;code&gt;0x00000001&lt;/code&gt; 과 값 &lt;code&gt;'\1\2\3\4'&lt;/code&gt; IS &lt;code&gt;0x01020304&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00762e90f2d0e1fc656e0809cb403c7716fbb355" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays</source>
          <target state="translated">다차원 배열</target>
        </trans-unit>
        <trans-unit id="cf133c71b3c2efeaae5de6091eefa30415ff9388" translate="yes" xml:space="preserve">
          <source>Multimap is an associative container that contains a sorted list of key-value pairs, while permitting multiple entries with the same key. Sorting is done according to the comparison function &lt;code&gt;Compare&lt;/code&gt;, applied to the keys. Search, insertion, and removal operations have logarithmic complexity.</source>
          <target state="translated">멀티 맵은 정렬 된 키-값 쌍 목록을 포함하고 동일한 키를 가진 여러 항목을 허용하는 연관 컨테이너입니다. 키에 적용된 비교 기능 &lt;code&gt;Compare&lt;/code&gt; 에 따라 정렬이 수행됩니다 . 검색, 삽입 및 제거 작업에는 로그가 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="d93c4759f084c66474a537bb4779321a39600e76" translate="yes" xml:space="preserve">
          <source>Multipass guarantee</source>
          <target state="translated">멀티 패스 보증</target>
        </trans-unit>
        <trans-unit id="8b79533d9d6f933b934e06befaa830db21925807" translate="yes" xml:space="preserve">
          <source>Multiple adjacent bit fields are usually packed together (although this behavior is implementation-defined):</source>
          <target state="translated">여러 개의 인접한 비트 필드는 일반적으로 함께 묶여 있습니다 (이 동작은 구현 정의되어 있음).</target>
        </trans-unit>
        <trans-unit id="8aba9a4022dc2b5b9217a1e0bae22b4f22da6f84" translate="yes" xml:space="preserve">
          <source>Multiple copy elisions may be chained to eliminate multiple copies.</source>
          <target state="translated">여러 개의 사본을 제거하기 위해 여러 개의 사본 제거가 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba8252d9e78468463f91fd69124355d767e70b19" translate="yes" xml:space="preserve">
          <source>Multiple functions in the same scope may have the same name, as long as their parameter lists and, for member functions, cv/ref qualifications are different. This is known as &lt;a href=&quot;overload_resolution&quot;&gt;function overloading&lt;/a&gt;. Function declarations that differ only in the return type and the noexcept specification(since C++17) cannot be overloaded.</source>
          <target state="translated">동일한 범위의 여러 함수는 매개 변수 목록과 멤버 함수의 경우 cv / ref 자격이 다른 한 동일한 이름을 가질 수 있습니다. 이것을 &lt;a href=&quot;overload_resolution&quot;&gt;함수 과부하라고&lt;/a&gt; 합니다. 반환 유형과 noexcept 사양 (C ++ 17부터)에서만 다른 함수 선언은 오버로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19da41d50ad4d265081c36d7f4e65700ca15e75b" translate="yes" xml:space="preserve">
          <source>Multiple namespace blocks with the same name are allowed. All declarations within those blocks are declared in the named scope.</source>
          <target state="translated">이름이 같은 여러 네임 스페이스 블록이 허용됩니다. 해당 블록 내의 모든 선언은 명명 된 범위에서 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="0ad5548e15a3586c8d471050a4ce94a8e1a22844" translate="yes" xml:space="preserve">
          <source>Multiple overloads of &lt;code&gt;f()&lt;/code&gt; declared before the</source>
          <target state="translated">전에 선언 된 &lt;code&gt;f()&lt;/code&gt; 의 여러 과부하</target>
        </trans-unit>
        <trans-unit id="7732a546fbb87f09193f1be1a7646b62b57f3a87" translate="yes" xml:space="preserve">
          <source>Multiple threads may use &lt;code&gt;fetch_sub&lt;/code&gt; to concurrently process an indexed container.</source>
          <target state="translated">여러 스레드가 &lt;code&gt;fetch_sub&lt;/code&gt; 를 사용 하여 인덱스 된 컨테이너를 동시에 처리 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98b77f5ad932fcd3f371127c2c40dc5f446e3196" translate="yes" xml:space="preserve">
          <source>Multiplication of the largest subnormal number by the number one machine epsilon greater than 1.0 gives the tiny value 0x0.fffffffffffff8p-1022 before rounding, but normal value 1p-1022 after rounding. The implementation used to execute this test (IBM Power7) detects tinyness before rounding.</source>
          <target state="translated">가장 큰 비정규 수에 1보다 큰 엡실론이 1.0보다 큰 숫자를 곱하면 반올림 전에 작은 값 0x0.fffffffffffff8p-1022가 발생하지만 반올림 후 정상 값은 1p-1022입니다. 이 테스트 (IBM Power7)를 실행하는 데 사용 된 구현은 반올림 전에 작은 크기를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="3385a32109aa5346add0ca1e71e6f6b9c5a102b4" translate="yes" xml:space="preserve">
          <source>Multiplication, division, and remainder</source>
          <target state="translated">곱셈, 나눗셈 및 나머지</target>
        </trans-unit>
        <trans-unit id="2e1863d77d06e578e88a57a55375c7c7a23d1f8f" translate="yes" xml:space="preserve">
          <source>Multiplicative operators</source>
          <target state="translated">곱하기 연산자</target>
        </trans-unit>
        <trans-unit id="4ababc1f5e400d86b62ba5912633f6b986ca9b90" translate="yes" xml:space="preserve">
          <source>Must return a &lt;code&gt;Type&amp;amp;&lt;/code&gt;, and afterwards, &lt;code&gt;p&lt;/code&gt; is equivalent to &lt;code&gt;nullptr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Type&amp;amp;&lt;/code&gt; 반환해야 하며, 이후 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;nullptr&lt;/code&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b01214e920406c4416e08d1f978fb4406baa93f9" translate="yes" xml:space="preserve">
          <source>Must return a value that is contextually convertible to bool.</source>
          <target state="translated">상황에 맞게 bool로 변환 가능한 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d217e2a97fe63fa480adebe696bb142ffa30b17" translate="yes" xml:space="preserve">
          <source>Mutable is used to specify that the member does not affect the externally visible state of the class (as often used for mutexes, memo caches, lazy evaluation, and access instrumentation).</source>
          <target state="translated">Mutable은 멤버가 클래스의 외부에서 볼 수있는 상태에 영향을 미치지 않도록 지정하는 데 사용됩니다 (뮤텍스, 메모 캐시, 지연 평가 및 액세스 계측에 자주 사용됨).</target>
        </trans-unit>
        <trans-unit id="bd2b0f087b02e413546a53c4f93f4cdf1581cc30" translate="yes" xml:space="preserve">
          <source>Mutex</source>
          <target state="translated">Mutex</target>
        </trans-unit>
        <trans-unit id="bcf81f2350a4ddaf862acb054f396be56471328b" translate="yes" xml:space="preserve">
          <source>Mutex, the sole type in &lt;code&gt;MutexTypes...&lt;/code&gt;</source>
          <target state="translated">Mutex, &lt;code&gt;MutexTypes...&lt;/code&gt; 의 유일한 유형 ...</target>
        </trans-unit>
        <trans-unit id="623593159179e7d5bbf03c1ec57146a2c9e50ba8" translate="yes" xml:space="preserve">
          <source>MutexTypes</source>
          <target state="translated">MutexTypes</target>
        </trans-unit>
        <trans-unit id="bd89464f515bc7c1945f885ef807721ee91c256b" translate="yes" xml:space="preserve">
          <source>Mutual exclusion</source>
          <target state="translated">상호 배제</target>
        </trans-unit>
        <trans-unit id="07e8ae8c3cca7c116c9e3ce24998de394a271a66" translate="yes" xml:space="preserve">
          <source>Mutual exclusion algorithms prevent multiple threads from simultaneously accessing shared resources. This prevents data races and provides support for synchronization between threads.</source>
          <target state="translated">상호 배제 알고리즘은 여러 스레드가 동시에 공유 리소스에 액세스하지 못하게합니다. 이는 데이터 경쟁을 방지하고 스레드 간 동기화를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="353bddf63f102523e0e94e44ec2f4291ad09b7ae" translate="yes" xml:space="preserve">
          <source>Mutual exclusion locks, such as &lt;code&gt;&lt;a href=&quot;../thread/mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; or &lt;a href=&quot;atomic_flag&quot;&gt;atomic spinlock&lt;/a&gt;, are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../thread/mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; 또는 &lt;a href=&quot;atomic_flag&quot;&gt;atomic spinlock&lt;/a&gt; 과 같은 상호 배제 잠금 은 릴리스 획득 동기화의 예입니다. 잠금이 스레드 A에 의해 해제되고 스레드 B에 의해 획득되면 중요한 섹션 (릴리스 이전)에서 발생한 모든 것 스레드 A와 관련하여 동일한 임계 섹션을 실행하는 스레드 B (수집 후)에 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="ba50285183f637f345b41123255cc7bf40eee6e3" translate="yes" xml:space="preserve">
          <source>N applications of &lt;code&gt;operator/=(path(&quot;..&quot;))&lt;/code&gt;, followed by</source>
          <target state="translated">N의 애플리케이션 &lt;code&gt;operator/=(path(&quot;..&quot;))&lt;/code&gt; ,이어서</target>
        </trans-unit>
        <trans-unit id="55893568e7cbf1b7a6b29a66a2452f93270c34d9" translate="yes" xml:space="preserve">
          <source>N may be any permutation of a1, ..., aN and</source>
          <target state="translated">N은 a1, ..., aN 및</target>
        </trans-unit>
        <trans-unit id="1250d9586efc9d80cc6c7239aa2177dcff4d7295" translate="yes" xml:space="preserve">
          <source>N op I))))</source>
          <target state="translated">N op I))))</target>
        </trans-unit>
        <trans-unit id="7f15122e3dfe9680a6663ac72323d5f09c66970e" translate="yes" xml:space="preserve">
          <source>N&amp;minus;1 op (E</source>
          <target state="translated">N-1 op (E</target>
        </trans-unit>
        <trans-unit id="8613cc7937238f206e33227381780a70bc3d7fb9" translate="yes" xml:space="preserve">
          <source>N)</source>
          <target state="translated">N)</target>
        </trans-unit>
        <trans-unit id="8b19c15f1ccf07bf3626b4a8b2548d375ec3fa3f" translate="yes" xml:space="preserve">
          <source>N) is defined as follows:</source>
          <target state="translated">N)은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a100c474d11fd67b64c08abc7f23a4a2f4cc1e66" translate="yes" xml:space="preserve">
          <source>N)) for any K where 1 &amp;lt; K+1 = M &amp;le; N</source>
          <target state="translated">N)) 1 &amp;lt;K + 1 = M &amp;le; N 인 K에 대해</target>
        </trans-unit>
        <trans-unit id="77952d1fe50f676e5e862f5a754bb0d05488449e" translate="yes" xml:space="preserve">
          <source>N)) where</source>
          <target state="translated">N)) 어디서</target>
        </trans-unit>
        <trans-unit id="d983d30d3a24dc6620175e14187869fa136530fc" translate="yes" xml:space="preserve">
          <source>N)))</source>
          <target state="translated">N)))</target>
        </trans-unit>
        <trans-unit id="31329860809c98077449f6ad92ec9504b89cb28b" translate="yes" xml:space="preserve">
          <source>N*log(size()+N)), where N is &lt;code&gt;source.size()&lt;/code&gt;.</source>
          <target state="translated">N * log (size () + N)), 여기서 N은 &lt;code&gt;source.size()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c264d85396033becba7559b9702cd4354a3b890f" translate="yes" xml:space="preserve">
          <source>N-1 op E</source>
          <target state="translated">N-1 op E</target>
        </trans-unit>
        <trans-unit id="39b94b742092e3ba7ac4ebd9524bb1c81f255b00" translate="yes" xml:space="preserve">
          <source>N3922</source>
          <target state="translated">N3922</target>
        </trans-unit>
        <trans-unit id="3978b69456fb978edbba4310d37fe1c6ecb893f4" translate="yes" xml:space="preserve">
          <source>N4387</source>
          <target state="translated">N4387</target>
        </trans-unit>
        <trans-unit id="c44f384c13dc675d729b43652997307ca17e8a2b" translate="yes" xml:space="preserve">
          <source>N&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">N&lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d82a19a46f2f7da0f84cb56740a41e0148eda5c1" translate="yes" xml:space="preserve">
          <source>NAN</source>
          <target state="translated">NAN</target>
        </trans-unit>
        <trans-unit id="f0d1c3c27252776cf6fab5b297dd84293196ad68" translate="yes" xml:space="preserve">
          <source>NRVO</source>
          <target state="translated">NRVO</target>
        </trans-unit>
        <trans-unit id="3ad6166ad6b1dfdf3797d9216ac661a1daea38f8" translate="yes" xml:space="preserve">
          <source>NRVO was mandatory in constant expressions</source>
          <target state="translated">NRVO는 상수 표현에 필수적이었다</target>
        </trans-unit>
        <trans-unit id="065e03753f6454aa1d90a1883ea3bf51044f5c10" translate="yes" xml:space="preserve">
          <source>NTTP</source>
          <target state="translated">NTTP</target>
        </trans-unit>
        <trans-unit id="85476691293312e0eddef863daabeefe9aa5acfc" translate="yes" xml:space="preserve">
          <source>NUL-terminated.</source>
          <target state="translated">NUL-terminated.</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="7929777f461a9c2e7071443c14f9e07d070abdd6" translate="yes" xml:space="preserve">
          <source>NaN values never compare equal to themselves or to other NaN values. Copying a NaN is not required, by IEEE-754, to preserve its bit representation (sign and &lt;a href=&quot;nan.2&quot;&gt;payload&lt;/a&gt;), though most implementation do.</source>
          <target state="translated">NaN 값은 자신이나 다른 NaN 값과 같지 않습니다. IEEE-754에서는 비트 구현 (sign and &lt;a href=&quot;nan.2&quot;&gt;payload&lt;/a&gt; ) 을 유지하기 위해 NaN을 복사 할 필요가 없지만 대부분의 구현에서는 필요합니다.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="e11bc388c83c1b8b82ae73a235837ab0ef1b8869" translate="yes" xml:space="preserve">
          <source>Name lookup</source>
          <target state="translated">이름 조회</target>
        </trans-unit>
        <trans-unit id="b6bc7d50b342a34806ee88ab2690eb319c435c81" translate="yes" xml:space="preserve">
          <source>Name lookup and binding are different for</source>
          <target state="translated">이름 조회 및 바인딩이 다릅니다</target>
        </trans-unit>
        <trans-unit id="480387aa2ed9cd405fb53a80e0ad8ef0f482feba" translate="yes" xml:space="preserve">
          <source>Name lookup is the procedure by which a &lt;a href=&quot;name&quot;&gt;name&lt;/a&gt;, when encountered in a program, is associated with the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; that introduced it.</source>
          <target state="translated">이름 조회는 프로그램에서 발견 될 때 &lt;a href=&quot;name&quot;&gt;name&lt;/a&gt; 이 그것을 도입 한 &lt;a href=&quot;declarations&quot;&gt;선언&lt;/a&gt; 과 연관 되는 절차 입니다.</target>
        </trans-unit>
        <trans-unit id="5ca9e948abdb518c09be2641fab9cc9d573e48a4" translate="yes" xml:space="preserve">
          <source>Name lookup rules make it impractical to declare operators in global or user-defined namespace that operate on types from the std namespace, e.g. a custom &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;operator+&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; or for &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; (unless the element types of the vector/pair are user-defined types, which would add their namespace to ADL). Such operators would not be looked up from template instantiations, such as the standard library algorithms. See &lt;a href=&quot;dependent_name&quot;&gt;dependent names&lt;/a&gt; for further details.</source>
          <target state="translated">이름 조회 규칙은 비현실적 std 네임 스페이스에서 유형에서 작동 전역 또는 사용자 정의 네임 스페이스 사업자, 예를 들어, 사용자 정의 선언 할 수 있도록 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;operator+&lt;/code&gt; 를위한 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 또는 대한 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; (의 요소 유형하지 않는 한 벡터 / 쌍은 사용자 정의 형식으로, ADL에 네임 스페이스를 추가합니다. 이러한 연산자는 표준 라이브러리 알고리즘과 같은 템플릿 인스턴스화에서 찾지 않습니다. 자세한 내용은 &lt;a href=&quot;dependent_name&quot;&gt;종속 이름&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="3013f39113916e6419f8088ed3c67869df636b9d" translate="yes" xml:space="preserve">
          <source>Named Return Value Optimization</source>
          <target state="translated">명명 된 반환 값 최적화</target>
        </trans-unit>
        <trans-unit id="f44438b5a472bd21faa49423e23b1eb88ebdfc5f" translate="yes" xml:space="preserve">
          <source>Named requirements</source>
          <target state="translated">명명 된 요구 사항</target>
        </trans-unit>
        <trans-unit id="5d20b518c977a68ada4a25be86f69791473df0e8" translate="yes" xml:space="preserve">
          <source>Named sets of such requirements are called</source>
          <target state="translated">이러한 요구 사항의 명명 된 집합을 호출</target>
        </trans-unit>
        <trans-unit id="3feb744677b698e301be638132eacb767a8d61ef" translate="yes" xml:space="preserve">
          <source>Named sockets are UNIX domain sockets constructed with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html&quot;&gt;socket&lt;/a&gt; and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html&quot;&gt;bind&lt;/a&gt; POSIX APIs, which may be used for advanced interprocess communication. In particular, they may be used to transport open file descriptors from one running process to another.</source>
          <target state="translated">명명 된 소켓은 고급 프로세스 간 통신에 사용될 수있는 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html&quot;&gt;소켓&lt;/a&gt; 및 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html&quot;&gt;바인드&lt;/a&gt; POSIX API로 구성된 UNIX 도메인 소켓 입니다. 특히, 하나의 실행중인 프로세스에서 다른 프로세스로 열린 파일 디스크립터를 전송하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a97e72293967c371e645dc4966907494004b6512" translate="yes" xml:space="preserve">
          <source>Named sockets are UNIX domain sockets constructed with &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html&quot;&gt;socket&lt;/a&gt; and &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html&quot;&gt;bind&lt;/a&gt; POSIX APIs, which may be used for advanced interprocess communication. In particular, they may be used to transport open file descriptors from one running process to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7c08c3ab75f37e2da656c1aab228f5f3a793b1" translate="yes" xml:space="preserve">
          <source>Names</source>
          <target state="translated">Names</target>
        </trans-unit>
        <trans-unit id="c9b864b84da76323cdde2ab3f20373514e5220f1" translate="yes" xml:space="preserve">
          <source>Names and identifiers</source>
          <target state="translated">이름과 식별자</target>
        </trans-unit>
        <trans-unit id="5dba54e935821f929da3325c377d095d8e0b34ed" translate="yes" xml:space="preserve">
          <source>Names at the top-level namespace scope (file scope in C) that are &lt;code&gt;const&lt;/code&gt; and not &lt;code&gt;extern&lt;/code&gt; have external linkage in C, but internal linkage in C++.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 이고 &lt;code&gt;extern&lt;/code&gt; 이 아닌 최상위 네임 스페이스 범위 (C의 파일 범위)의 이름은 C에 외부 연결이 있지만 C ++에 내부 연결이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3063d4cd8cda973d2c9e30f2ca7be83f7c01f92d" translate="yes" xml:space="preserve">
          <source>Names encountered in a program are associated with the declarations that introduced them using &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;. Each name is only valid within a part of the program called its &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;. Some names have &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt; which makes them refer to the same entities when they appear in different scopes or translation units.</source>
          <target state="translated">프로그램에서 발견 된 이름은 &lt;a href=&quot;lookup&quot;&gt;이름 조회를&lt;/a&gt; 사용하여 소개 한 선언과 연관됩니다 . 각 이름은 &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; 라는 프로그램의 일부에서만 유효합니다 . 일부 이름에는 서로 다른 범위 나 번역 단위에 나타날 때 동일한 엔터티를 나타내는 &lt;a href=&quot;storage_duration&quot;&gt;연결&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a9aa2bab33fd05a2da5d335efe4a2e09b164f3c" translate="yes" xml:space="preserve">
          <source>Names introduced by &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; declarations within a non-local class X become members of the innermost enclosing namespace of X, but they do not become visible to ordinary &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; (neither &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; nor &lt;a href=&quot;qualified_lookup&quot;&gt;qualified&lt;/a&gt;) unless a matching declaration is provided at namespace scope, either before or after the class definition. Such name may be found through &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt; which considers both namespaces and classes.</source>
          <target state="translated">로컬이 아닌 클래스 X 내에서 &lt;a href=&quot;friend&quot;&gt;친구&lt;/a&gt; 선언에 의해 도입 된 이름은 X의 가장 안쪽에있는 네임 스페이스의 멤버가되지만 일치하는 선언이 네임 스페이스 범위에서 제공되지 않는 한 &lt;a href=&quot;qualified_lookup&quot;&gt;정규화 된 &lt;/a&gt;&lt;a href=&quot;lookup&quot;&gt;이름 조회&lt;/a&gt; ( &lt;a href=&quot;unqualified_lookup&quot;&gt;정규화되지&lt;/a&gt; 도 정규화 되지 않음 )에 표시 되지 않습니다. 또는 클래스 정의 후에. 이러한 이름은 네임 스페이스와 클래스를 모두 고려하는 &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt; 을 통해 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1935b005dc184ad84620c13afec466318085ca9" translate="yes" xml:space="preserve">
          <source>Names introduced into a namespace scope by a using-declaration can be used just like any other names, including qualified lookup from other scopes:</source>
          <target state="translated">using-declaration을 통해 네임 스페이스 범위에 도입 된 이름은 다른 범위의 정규화 된 조회를 포함하여 다른 이름과 마찬가지로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abc354041c1ad60236f2a24daaf11e19bd038ee8" translate="yes" xml:space="preserve">
          <source>Names of &lt;a href=&quot;../language/reference&quot;&gt;rvalue reference&lt;/a&gt; variables are &lt;a href=&quot;../language/value_category&quot;&gt;lvalues&lt;/a&gt; and have to be converted to &lt;a href=&quot;../language/value_category&quot;&gt;xvalues&lt;/a&gt; to be bound to the function overloads that accept rvalue reference parameters, which is why &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructors&lt;/a&gt; and &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operators&lt;/a&gt; typically use &lt;code&gt;std::move&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../language/reference&quot;&gt;rvalue 참조&lt;/a&gt; 변수의 이름 은 &lt;a href=&quot;../language/value_category&quot;&gt;lvalue&lt;/a&gt; 이며 rvalue 참조 매개 변수를 허용하는 함수 오버로드에 바인딩 되도록 &lt;a href=&quot;../language/value_category&quot;&gt;xvalues&lt;/a&gt; 로 변환해야 하므로 &lt;a href=&quot;../language/move_constructor&quot;&gt;이동 생성자&lt;/a&gt; 와 &lt;a href=&quot;../language/move_operator&quot;&gt;이동 할당 연산자는&lt;/a&gt; 일반적으로 &lt;code&gt;std::move&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db1e5452b458ffc1ce5b7de086a71fa73749c0e6" translate="yes" xml:space="preserve">
          <source>Names of &lt;code&gt;thread_local&lt;/code&gt; variables with internal or external linkage referred from different scopes may refer to the same or to different instances depending on whether the code is executing in the same or in different threads.</source>
          <target state="translated">다른 범위에서 참조되는 내부 또는 외부 연결을 갖는 &lt;code&gt;thread_local&lt;/code&gt; 변수의 이름은 코드가 동일한 스레드에서 실행되는지 다른 스레드에서 실행되는지에 따라 동일하거나 다른 인스턴스를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8dae2c410db83e5bd98bf3a1359488efbedbb6b" translate="yes" xml:space="preserve">
          <source>Names of any class members can only be used in four contexts:</source>
          <target state="translated">모든 반원의 이름은 다음 네 가지 상황에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b43957c55d7ffebeb7c1698dd30daec7bfa5f9cc" translate="yes" xml:space="preserve">
          <source>Names that appear in expression-list or brace-init-list are evaluated in scope of the constructor:</source>
          <target state="translated">expression-list 또는 brace-init-list에 나타나는 이름은 생성자의 범위에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="68a7b15b97ad42eb5d4cb110e1e2208e8db49ff3" translate="yes" xml:space="preserve">
          <source>Namespace &lt;code&gt;std::regex_constants&lt;/code&gt;</source>
          <target state="translated">네임 스페이스 &lt;code&gt;std::regex_constants&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="69aee25fb2b7251f96c077bac9928b36b2f0092d" translate="yes" xml:space="preserve">
          <source>Namespace alias</source>
          <target state="translated">네임 스페이스 별명</target>
        </trans-unit>
        <trans-unit id="15feeecb0e0bd445b4ec4c17a571fe55224d4791" translate="yes" xml:space="preserve">
          <source>Namespace aliases</source>
          <target state="translated">네임 스페이스 별명</target>
        </trans-unit>
        <trans-unit id="9d3514105c3b51acfe33dab56a9ad9112ffd5783" translate="yes" xml:space="preserve">
          <source>Namespace aliases allow the programmer to define an alternate name for a namespace.</source>
          <target state="translated">네임 스페이스 별명을 사용하면 프로그래머가 네임 스페이스의 대체 이름을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8ea1a0aa60760b378411518c66664dc0aebf042" translate="yes" xml:space="preserve">
          <source>Namespace declaration</source>
          <target state="translated">네임 스페이스 선언</target>
        </trans-unit>
        <trans-unit id="1a0de11ba24e7fe94cf87f5c813cc5958139da55" translate="yes" xml:space="preserve">
          <source>Namespace definition</source>
          <target state="translated">네임 스페이스 정의</target>
        </trans-unit>
        <trans-unit id="7abe5aadb217584bf97533759728f989dd4a7122" translate="yes" xml:space="preserve">
          <source>Namespace definitions are only allowed at namespace scope, including the global scope.</source>
          <target state="translated">네임 스페이스 정의는 글로벌 범위를 포함하여 네임 스페이스 범위에서만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="b2fb3696d13cbe0ff41f03594167b5ebd95c58c5" translate="yes" xml:space="preserve">
          <source>Namespace members</source>
          <target state="translated">네임 스페이스 멤버</target>
        </trans-unit>
        <trans-unit id="6ef4650b141111ec251678ed3bf718413e6ab572" translate="yes" xml:space="preserve">
          <source>Namespace scope</source>
          <target state="translated">네임 스페이스 범위</target>
        </trans-unit>
        <trans-unit id="98cc70f9e7340456a64ac9fdf7b1eede2f30a8e3" translate="yes" xml:space="preserve">
          <source>Namespace-scope anonymous unions must be declared static unless they appear in an unnamed namespace.</source>
          <target state="translated">네임 스페이스 범위 익명 공용체는 명명되지 않은 네임 스페이스에 나타나지 않으면 정적으로 선언되어야합니다.</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="6ade31b5444def27ab30c5c64abc17a78b593fc9" translate="yes" xml:space="preserve">
          <source>Namespaces provide a method for preventing name conflicts in large projects.</source>
          <target state="translated">네임 스페이스는 대규모 프로젝트에서 이름 충돌을 방지하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8655490bdfd99b50e55540721bde65050a10ca66" translate="yes" xml:space="preserve">
          <source>Narrow and wide orientation</source>
          <target state="translated">좁고 넓은 방향</target>
        </trans-unit>
        <trans-unit id="d6f5cbdcb5ba2c44829f73b263418c7c018a552d" translate="yes" xml:space="preserve">
          <source>Narrow character</source>
          <target state="translated">좁은 캐릭터</target>
        </trans-unit>
        <trans-unit id="00612e7ff2b16d807e5421756762dc8ce833f708" translate="yes" xml:space="preserve">
          <source>Narrow/multibyte character</source>
          <target state="translated">좁은 / 멀티 바이트 문자</target>
        </trans-unit>
        <trans-unit id="02ec8760336fb09c698a2687c11d370174266ee2" translate="yes" xml:space="preserve">
          <source>Narrowing conversions</source>
          <target state="translated">축소 전환</target>
        </trans-unit>
        <trans-unit id="aa2311a58a83585cb18d67d0ab7bfd5d14fb5130" translate="yes" xml:space="preserve">
          <source>Narrowing is always successful and is always reversible (by calling &lt;code&gt;&lt;a href=&quot;widen&quot;&gt;widen()&lt;/a&gt;&lt;/code&gt;) for all characters from the basic source character set (latin letters, digits, and punctuations required to write a C++ program).</source>
          <target state="translated">좁히기는 항상 성공하며 기본 소스 문자 세트의 모든 문자 (대문자, 숫자 및 문장 부호 C ++ 프로그램을 작성하는 데 필요한 구두점)에 대해 항상 되돌릴 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;widen&quot;&gt;widen()&lt;/a&gt;&lt;/code&gt; 호출 ).</target>
        </trans-unit>
        <trans-unit id="d58074e0c552f383bd0ec261612a709f3413f4a1" translate="yes" xml:space="preserve">
          <source>Narrowing of any digit character guarantees that if the result is subtracted from the character literal &lt;code&gt;'0'&lt;/code&gt;, the difference equals the digit value of the original character.</source>
          <target state="translated">숫자 문자를 좁 히면 문자 리터럴 &lt;code&gt;'0'&lt;/code&gt; 에서 결과를 빼면 차이가 원래 문자의 숫자 값과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8dbe486ad6ba7275ed9b6d093c1f795836a5e22a" translate="yes" xml:space="preserve">
          <source>Narrowing, if successful, preserves all character classification categories known to &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">좁 히면 성공하면 &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt; 알려진 모든 문자 분류 범주가 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a4742e8a9730fb2d9ea65a3e7a57cdd49ba4360" translate="yes" xml:space="preserve">
          <source>Narrows a wide character &lt;code&gt;c&lt;/code&gt; if its multibyte character equivalent in the initial shift state is a single byte.</source>
          <target state="translated">초기 시프트 상태에서 동등한 멀티 바이트 문자가 단일 바이트 인 경우 와이드 문자 &lt;code&gt;c&lt;/code&gt; 를 좁 힙니다 .</target>
        </trans-unit>
        <trans-unit id="e856674ce1f8ad1d8b857f019d9b05cec7538227" translate="yes" xml:space="preserve">
          <source>Native handle</source>
          <target state="translated">기본 핸들</target>
        </trans-unit>
        <trans-unit id="db030e0b7158dfda8f21b860c6287b6a5341fd7b" translate="yes" xml:space="preserve">
          <source>Native pathname format</source>
          <target state="translated">기본 경로 이름 형식</target>
        </trans-unit>
        <trans-unit id="ca5b116732b30e4ee615a6e0c70fc845595ecbca" translate="yes" xml:space="preserve">
          <source>Nearest integer floating point operations</source>
          <target state="translated">가장 가까운 정수 부동 소수점 연산</target>
        </trans-unit>
        <trans-unit id="dfaab505f47d58982ff129c9d7d12a74d6eb3cc8" translate="yes" xml:space="preserve">
          <source>Negative value if &lt;code&gt;lhs&lt;/code&gt; appears before &lt;code&gt;rhs&lt;/code&gt; in lexicographical order.</source>
          <target state="translated">사전에 &lt;code&gt;rhs&lt;/code&gt; 앞에 &lt;code&gt;lhs&lt;/code&gt; 가 나타나는 경우 음수 값 입니다.</target>
        </trans-unit>
        <trans-unit id="87491531316873a8136087161a4d5513bf956b22" translate="yes" xml:space="preserve">
          <source>Negative value if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 가 음수 인 경우 음수</target>
        </trans-unit>
        <trans-unit id="273543511f403081caee3e55984dd6ca3f79876b" translate="yes" xml:space="preserve">
          <source>Negative value if &lt;code&gt;s1&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; 이 음수 인 경우 음수</target>
        </trans-unit>
        <trans-unit id="ceca0034b729fc521079379a02d62ac4de8dc88a" translate="yes" xml:space="preserve">
          <source>Negative value if the first differing byte (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) in &lt;code&gt;lhs&lt;/code&gt; is less than the corresponding byte in &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 의 첫 번째 다른 바이트 ( &lt;code&gt;unsigned char&lt;/code&gt; 로 해석 됨 ) 가 &lt;code&gt;rhs&lt;/code&gt; 의 해당 바이트보다 작은 경우 음수 값 입니다.</target>
        </trans-unit>
        <trans-unit id="282e0a77a7206269a1ec03af267a85cf22416793" translate="yes" xml:space="preserve">
          <source>Negative value if the value of the first differing wide character in &lt;code&gt;lhs&lt;/code&gt; is less than the value of the corresponding wide character in &lt;code&gt;rhs&lt;/code&gt;: &lt;code&gt;lhs&lt;/code&gt; precedes &lt;code&gt;rhs&lt;/code&gt; in lexicographical order.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 에서 첫 번째로 다른 넓은 문자 의 값이 &lt;code&gt;rhs&lt;/code&gt; 에서 해당하는 넓은 문자의 값보다 작은 경우 음의 값 : &lt;code&gt;lhs&lt;/code&gt; 는 사전 순서대로 &lt;code&gt;rhs&lt;/code&gt; 앞에옵니다 .</target>
        </trans-unit>
        <trans-unit id="f8dce9bcbeee998252a5f32963f3424cf3f7e0d3" translate="yes" xml:space="preserve">
          <source>Negators</source>
          <target state="translated">Negators</target>
        </trans-unit>
        <trans-unit id="f7a7b461a2da4ad85b1265cf9c4d04f21c5ffddb" translate="yes" xml:space="preserve">
          <source>Nested allocator class</source>
          <target state="translated">중첩 된 할당 자 클래스</target>
        </trans-unit>
        <trans-unit id="25e8c5172b7e5d7b584594533302eddfd95e8bc0" translate="yes" xml:space="preserve">
          <source>Nested class declarations obey &lt;a href=&quot;access&quot;&gt;member access&lt;/a&gt; specifiers, a private member class cannot be named outside the scope of the enclosing class, although objects of that class may be manipulated:</source>
          <target state="translated">중첩 클래스 선언은 &lt;a href=&quot;access&quot;&gt;멤버 액세스&lt;/a&gt; 지정자를 준수하며 , 해당 클래스의 오브젝트를 조작 할 수 있지만 개인 멤버 클래스는 클래스의 범위 밖에서 이름을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="65046fcf73f5e6ac3773f70ea1badbd965d975c0" translate="yes" xml:space="preserve">
          <source>Nested classes</source>
          <target state="translated">중첩 클래스</target>
        </trans-unit>
        <trans-unit id="1b5839fbae7339935c12e6b4b66fd2e922b275ad" translate="yes" xml:space="preserve">
          <source>Nested classes can be forward-declared and later defined, either within the same enclosing class body, or outside of it:</source>
          <target state="translated">중첩 된 클래스는 동일한 선언 클래스 본문 내에서 또는 외부에서 앞으로 선언되어 나중에 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64808f48e8bd759c2c2b1d7832534e1bd54d3712" translate="yes" xml:space="preserve">
          <source>Nested requirements</source>
          <target state="translated">중첩 된 요구 사항</target>
        </trans-unit>
        <trans-unit id="ea849e260b8735345217e4f53f113c9fcde5b394" translate="yes" xml:space="preserve">
          <source>Network is down</source>
          <target state="translated">네트워크가 다운되었습니다</target>
        </trans-unit>
        <trans-unit id="72752d57c3c282cc523b7154bbf54840e4683a46" translate="yes" xml:space="preserve">
          <source>Network unreachable</source>
          <target state="translated">연결할 수없는 네트워크</target>
        </trans-unit>
        <trans-unit id="80c3052d33ccdee15ffaaa110c5c39072495fe63" translate="yes" xml:space="preserve">
          <source>Never</source>
          <target state="translated">Never</target>
        </trans-unit>
        <trans-unit id="3c4e963fe5e99296e8a4ab9dc3cfa9311f0e21c6" translate="yes" xml:space="preserve">
          <source>New operators such as &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;amp;|&lt;/code&gt; cannot be created.</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;amp;|&lt;/code&gt; 와 같은 새로운 연산자 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ede4611858dc430c3ea6396ebc14993ab64f79d1" translate="yes" xml:space="preserve">
          <source>New-expressions are allowed to elide or combine allocations made through replaceable allocation functions. In case of elision, the storage may be provided by the compiler without making the call to an allocation function (this also permits optimizing out unused new-expression). In case of combining, the allocation made by a new-expression E1 may be extended to provide additional storage for another new-expression E2 if all of the following is true:</source>
          <target state="translated">새로운 표현은 교체 가능한 할당 함수를 통해 만들어진 할당을 제거하거나 결합 할 수 있습니다. 제거의 경우, 할당 함수를 호출하지 않고 컴파일러가 스토리지를 제공 할 수 있습니다 (이렇게하면 사용되지 않은 새 표현식을 최적화 할 수도 있습니다). 결합하는 경우, 다음 모두가 참인 경우, 새로운 표현 E1에 의해 이루어진 할당은 다른 새로운 표현 E2에 대한 추가 스토리지를 제공하도록 확장 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="493d0f0040b36ea8241324dced2e890dfb4b6119" translate="yes" xml:space="preserve">
          <source>Newer &quot;Minimum standard&quot;, recommended by Park, Miller, and Stockmeyer in 1993.</source>
          <target state="translated">1993 년 Park, Miller 및 Stockmeyer가 권장하는 최신 &quot;최소 표준&quot;.</target>
        </trans-unit>
        <trans-unit id="79ac146d5b7ee7fd72cce1790f7da1b8a2f032a2" translate="yes" xml:space="preserve">
          <source>Newlines are kept, and it's unspecified whether non-newline whitespace sequences may be collapsed into single space characters.</source>
          <target state="translated">줄 바꿈이 유지되며 줄 바꿈이 아닌 공백 시퀀스가 ​​단일 공백 ​​문자로 축소 될 수 있는지 여부는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de67bdd002151bf79b109ea669e76942392196e1" translate="yes" xml:space="preserve">
          <source>Niebloids</source>
          <target state="translated">Niebloids</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="f130b9c617343f8c039eb502e65e2bfe55e02212" translate="yes" xml:space="preserve">
          <source>No STREAM resources</source>
          <target state="translated">STREAM 리소스가 없습니다</target>
        </trans-unit>
        <trans-unit id="7dd7bd839e3806d4920233a25bbd072dba9f30a1" translate="yes" xml:space="preserve">
          <source>No additional synchronization guarantees other than what's already provided by shared state.</source>
          <target state="translated">공유 상태에서 이미 제공 한 것 이외의 추가 동기화를 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bcc62e49c9ca3ab05ca96f0f3e27fde373feffa" translate="yes" xml:space="preserve">
          <source>No bounds checking is performed: the behavior is undefined if &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt;.</source>
          <target state="translated">경계 검사가 수행되지 않습니다. &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt; 경우 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e792e65ee8a80fd8989ad1b66325f180ccd8b365" translate="yes" xml:space="preserve">
          <source>No buffer space available</source>
          <target state="translated">사용 가능한 버퍼 공간이 없습니다.</target>
        </trans-unit>
        <trans-unit id="099e11888438840a8566c983d5b1e6de2dad8524" translate="yes" xml:space="preserve">
          <source>No child processes</source>
          <target state="translated">자식 프로세스가 없습니다</target>
        </trans-unit>
        <trans-unit id="8959031a2aef1c7c15f7657b554e13b4559478e9" translate="yes" xml:space="preserve">
          <source>No destructors for automatic objects are called. If replacing of &lt;code&gt;std::longjmp&lt;/code&gt; with &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;catch&lt;/code&gt; would execute a non-trivial destructor for any automatic object, the behavior of such &lt;code&gt;std::longjmp&lt;/code&gt; is undefined.</source>
          <target state="translated">자동 객체에 대한 소멸자는 호출되지 않습니다. 의 교체하면 &lt;code&gt;std::longjmp&lt;/code&gt; 함께 &lt;code&gt;throw&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 는 함께 &lt;code&gt;catch&lt;/code&gt; 모든 자동 객체의 비 사소한 소멸자를 실행할 것 등의 행동 &lt;code&gt;std::longjmp&lt;/code&gt; 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7ad248d7445e862eb6d5aac0fef62ca217cfdbf" translate="yes" xml:space="preserve">
          <source>No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">요소가 복사되거나 이동되지 않으며 컨테이너 노드의 내부 포인터 만 재 지정됩니다. 전송 된 요소에 대한 모든 포인터와 참조는 계속 유효하지만 &lt;code&gt;source&lt;/code&gt; 가 아닌 &lt;code&gt;*this&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9ae4f5756c09ebfc4d7b62cc8ca55e5eb9ed890" translate="yes" xml:space="preserve">
          <source>No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;. Iterators referring to the transferred elements and all iterators referring to &lt;code&gt;*this&lt;/code&gt; are invalidated.</source>
          <target state="translated">요소가 복사되거나 이동되지 않으며 컨테이너 노드의 내부 포인터 만 재 지정됩니다. 전송 된 요소에 대한 모든 포인터와 참조는 계속 유효하지만 &lt;code&gt;source&lt;/code&gt; 가 아닌 &lt;code&gt;*this&lt;/code&gt; 를 참조하십시오 . 전송 된 요소를 참조하는 반복자 및 &lt;code&gt;*this&lt;/code&gt; 참조하는 모든 반복자 는 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="cc3224dd2db8f1be53245ed8d7053751754bb987" translate="yes" xml:space="preserve">
          <source>No elements are copied or moved, only the internal pointers of the list nodes are re-pointed. The behavior is undefined if: &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;. No iterators or references become invalidated, the iterators to moved elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">요소가 복사되거나 이동되지 않으며 목록 노드의 내부 포인터 만 다시 지정됩니다. &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; 경우 동작이 정의되지 않습니다 . 반복자 또는 참조가 무효화되지 않고 이동 된 요소에 대한 반복자는 계속 유효하지만 이제는 &lt;code&gt;other&lt;/code&gt; 가 아니라 &lt;code&gt;*this&lt;/code&gt; 를 참조 합니다.</target>
        </trans-unit>
        <trans-unit id="a446797facd648759f6798d6324eb89c747b63a0" translate="yes" xml:space="preserve">
          <source>No elements are copied. &lt;code&gt;pos&lt;/code&gt; must be either a deferenceable valid iterator into &lt;code&gt;*this&lt;/code&gt; or the &lt;code&gt;&lt;a href=&quot;before_begin&quot;&gt;before_begin()&lt;/a&gt;&lt;/code&gt; iterator (in particular, &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; is not a valid argument for &lt;code&gt;pos&lt;/code&gt;). The behavior is undefined if &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;. No iterators or references become invalidated, the iterators to the moved elements now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">요소가 복사되지 않습니다. &lt;code&gt;pos&lt;/code&gt; 는 &lt;code&gt;*this&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;before_begin&quot;&gt;before_begin()&lt;/a&gt;&lt;/code&gt; 반복자 (특히 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;pos&lt;/code&gt; 에 유효한 인수가 아님 ) 에 대해 유추 할 수있는 유효한 반복자 여야합니다 . &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; 경우 동작이 정의되지 않습니다 . 반복자 또는 참조가 무효화 되지 않으며, 이동 된 요소에 대한 반복자는 이제 &lt;code&gt;other&lt;/code&gt; 가 아니라 &lt;code&gt;*this&lt;/code&gt; 를 참조 합니다.</target>
        </trans-unit>
        <trans-unit id="978b5fdcd4067d166cd18666eaf43106a672a214" translate="yes" xml:space="preserve">
          <source>No elements are copied. The container &lt;code&gt;other&lt;/code&gt; becomes empty after the operation. The function does nothing if &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;. If &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;, the behavior is undefined. No iterators or references become invalidated, except that the iterators of moved elements now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;other&lt;/code&gt;. The first version uses &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the elements, the second version uses the given comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">요소가 복사되지 않습니다. 컨테이너 &lt;code&gt;other&lt;/code&gt; 수술 후 빈됩니다. &lt;code&gt;other&lt;/code&gt; 함수가 &lt;code&gt;*this&lt;/code&gt; 와 동일한 객체를 참조 하면이 함수는 아무 작업도 수행하지 않습니다 . 경우 &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; , 행동은 정의되지 않는다. 이동 된 요소의 반복자가 이제 &lt;code&gt;other&lt;/code&gt; 가 아니라 &lt;code&gt;*this&lt;/code&gt; 를 참조하는 것을 제외하고는 반복자 또는 참조가 무효화 되지 않습니다 . 첫 번째 버전은 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 를 사용하여 요소를 비교하고 두 번째 버전은 주어진 비교 함수 &lt;code&gt;comp&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
