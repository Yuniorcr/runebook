<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="23f5f0bc241ede95c8b95f28926489818949b926" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;b&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="2bb99be1b33f5434b2445e03cb34d8a6a579d58a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&amp;nbsp;||&amp;nbsp;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&amp;nbsp;||&amp;nbsp;b&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="2a6fe5721dcaed5f5571c1df43306cbcf9419ed1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*b&lt;/code&gt;&lt;code&gt;a/b&lt;/code&gt;&lt;code&gt;a%b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a*b&lt;/code&gt;&lt;code&gt;a/b&lt;/code&gt;&lt;code&gt;a%b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="651a7fd4e3376d1b529bdcbdfef563ca0533be34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a++&lt;/code&gt; and &lt;code&gt;a--&lt;/code&gt;, the built-in &lt;a href=&quot;operator_incdec#Built-in_postfix_operators&quot;&gt;post-increment and post-decrement&lt;/a&gt; expressions;</source>
          <target state="translated">&lt;code&gt;a++&lt;/code&gt; 내장 된 &lt;a href=&quot;operator_incdec#Built-in_postfix_operators&quot;&gt;후행 증가 및 후 감소&lt;/a&gt; 표현 인 a ++ 및 &lt;code&gt;a--&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b9b4853cc8b679073c90a4283853cef1bdb6aa93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a++&lt;/code&gt;&lt;code&gt;a--&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a++&lt;/code&gt;&lt;code&gt;a--&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40f71d1177d089c770c15990883694ba2436856c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+b&lt;/code&gt;&lt;code&gt;a-b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a+b&lt;/code&gt;&lt;code&gt;a-b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="604fe9f396bb38c888a7cd9ca00a2b3313cd37ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+t*(b&amp;minus;a)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a+t*(b&amp;minus;a)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="3ab58f8e1616dca1459e8859aad1e49ff0f006ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a, b&lt;/code&gt;, the built-in &lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;comma&lt;/a&gt; expression, where &lt;code&gt;b&lt;/code&gt; is an lvalue;</source>
          <target state="translated">&lt;code&gt;a, b&lt;/code&gt; , 내장 &lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;쉼표&lt;/a&gt; 표현식. 여기서 &lt;code&gt;b&lt;/code&gt; 는 lvalue입니다.</target>
        </trans-unit>
        <trans-unit id="0b63743f0e009827bc1a19f4a37f51e2afa4ebaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a, b&lt;/code&gt;, the built-in &lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;comma&lt;/a&gt; expression, where &lt;code&gt;b&lt;/code&gt; is an rvalue;</source>
          <target state="translated">&lt;code&gt;a, b&lt;/code&gt; , 내장 &lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;쉼표&lt;/a&gt; 표현식. 여기서 &lt;code&gt;b&lt;/code&gt; 는 rvalue입니다.</target>
        </trans-unit>
        <trans-unit id="f13f1bf7d4a88c474b4c124571a4cdaf5fcef346" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.*mp&lt;/code&gt;, the &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;pointer to member of object&lt;/a&gt; expression, where &lt;code&gt;a&lt;/code&gt; is an lvalue and &lt;code&gt;mp&lt;/code&gt; is a pointer to data member;</source>
          <target state="translated">&lt;code&gt;a.*mp&lt;/code&gt; , &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;객체&lt;/a&gt; 표현식의 멤버에 대한 포인터 . 여기서 &lt;code&gt;a&lt;/code&gt; 는 lvalue이고 &lt;code&gt;mp&lt;/code&gt; 는 데이터 멤버에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="054c8dbd6c4141367bf0e06564a191264154f8d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.*mp&lt;/code&gt;, the &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;pointer to member of object&lt;/a&gt; expression, where &lt;code&gt;a&lt;/code&gt; is an rvalue and &lt;code&gt;mp&lt;/code&gt; is a pointer to data member;</source>
          <target state="translated">&lt;code&gt;a.*mp&lt;/code&gt; , &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;객체&lt;/a&gt; 표현의 멤버에 대한 포인터 . 여기서 &lt;code&gt;a&lt;/code&gt; 는 rvalue이고 &lt;code&gt;mp&lt;/code&gt; 는 데이터 멤버에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="a12bafee58504cf32e553d18077939cae56ac2db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.*mp&lt;/code&gt;, the &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;pointer to member of object&lt;/a&gt; expression, where &lt;code&gt;mp&lt;/code&gt; is a pointer to member function&lt;sup id=&quot;cite_ref-pmfc_2-2&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;, or where &lt;code&gt;a&lt;/code&gt; is an rvalue and &lt;code&gt;mp&lt;/code&gt; is a pointer to data member(until C++11);</source>
          <target state="translated">&lt;code&gt;a.*mp&lt;/code&gt; , &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;객체&lt;/a&gt; 표현의 멤버에 대한 포인터 , 여기서 &lt;code&gt;mp&lt;/code&gt; 는 멤버 함수에 대한 포인터 &lt;sup id=&quot;cite_ref-pmfc_2-2&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; , 또는 &lt;code&gt;a&lt;/code&gt; 는 rvalue이고 &lt;code&gt;mp&lt;/code&gt; 는 데이터 멤버에 대한 포인터 (C ++ 11까지);</target>
        </trans-unit>
        <trans-unit id="348483aee04ee297b3509d8fa6ab0301b599dcd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.allocate(n, cvptr)&lt;/code&gt;(optional)</source>
          <target state="translated">&lt;code&gt;a.allocate(n, cvptr)&lt;/code&gt; (선택 사항)</target>
        </trans-unit>
        <trans-unit id="b1c8c45c7f2fb84e1ceec650893365190c8ff908" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.cbegin()&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;a.cbegin()&lt;/code&gt; (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="dbd9d47d782935580d715c456f6159d150814af9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.cend()&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;a.cend()&lt;/code&gt; (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="edd16b1271c19074f45c56d469214a6ceebbe902" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.construct(p, &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a.construct(p, &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="335aa3aa755d830415c3fae49ea2369c15068026" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.construct(xptr, args)&lt;/code&gt;(optional)</source>
          <target state="translated">&lt;code&gt;a.construct(xptr, args)&lt;/code&gt; (선택 사항)</target>
        </trans-unit>
        <trans-unit id="273e32bfaa5fecd7967d410ee2881bee219644da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.destroy(xptr)&lt;/code&gt;(optional)</source>
          <target state="translated">&lt;code&gt;a.destroy(xptr)&lt;/code&gt;(optional)</target>
        </trans-unit>
        <trans-unit id="78ee484aba800903ee2300ad2388b656579e6355" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.m&lt;/code&gt;, the &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member of object&lt;/a&gt; expression, except where &lt;code&gt;m&lt;/code&gt; is a member enumerator or a non-static member function, or where &lt;code&gt;a&lt;/code&gt; is an rvalue and &lt;code&gt;m&lt;/code&gt; is a non-static data member of non-reference type;</source>
          <target state="translated">&lt;code&gt;a.m&lt;/code&gt; 은 &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;개체의 부재&lt;/a&gt; 여기서 식 제외 &lt;code&gt;m&lt;/code&gt; 은 멤버 열거 나 비 정적 멤버 함수, 또는 여기서 &lt;code&gt;a&lt;/code&gt; r- 수치이고, &lt;code&gt;m&lt;/code&gt; 은 비 - 참조 형의 비 정적 데이터 멤버이고;</target>
        </trans-unit>
        <trans-unit id="9377be0ff51d3a086a794f7a2e1a7dac2a0c0bc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.m&lt;/code&gt;, the &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member of object&lt;/a&gt; expression, where &lt;code&gt;a&lt;/code&gt; is an rvalue and &lt;code&gt;m&lt;/code&gt; is a non-static data member of non-reference type;</source>
          <target state="translated">&lt;code&gt;a.m&lt;/code&gt; &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;은 객체&lt;/a&gt; 표현 의 멤버이며 , 여기서 &lt;code&gt;a&lt;/code&gt; 는 rvalue이고 &lt;code&gt;m&lt;/code&gt; 은 비 참조 유형의 비 정적 데이터 멤버입니다.</target>
        </trans-unit>
        <trans-unit id="a555a2bf950ffe6f88d60984260b763579eb879d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.m&lt;/code&gt;, the &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member of object&lt;/a&gt; expression, where &lt;code&gt;m&lt;/code&gt; is a member enumerator or a non-static member function&lt;sup id=&quot;cite_ref-pmfc_2-0&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;, or where &lt;code&gt;a&lt;/code&gt; is an rvalue and &lt;code&gt;m&lt;/code&gt; is a non-static data member of non-reference type(until C++11);</source>
          <target state="translated">&lt;code&gt;a.m&lt;/code&gt; , &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;객체&lt;/a&gt; 표현 의 멤버 . 여기서 &lt;code&gt;m&lt;/code&gt; 은 멤버 열거 자 또는 비 정적 멤버 함수 &lt;sup id=&quot;cite_ref-pmfc_2-0&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; 이고 &lt;code&gt;a&lt;/code&gt; 는 rvalue이고 &lt;code&gt;m&lt;/code&gt; 은 비 참조 유형의 비 정적 데이터 멤버입니다 (C ++까지) 11);</target>
        </trans-unit>
        <trans-unit id="765faaa96e8be4e5a697e7782fb97a1ff248a731" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.max_size()&lt;/code&gt;(optional)</source>
          <target state="translated">&lt;code&gt;a.max_size()&lt;/code&gt;(optional)</target>
        </trans-unit>
        <trans-unit id="6c2db632390a099b810a511c412e721d1f1433b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.max_size()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a.max_size()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="9992605ae29cb99de315230cb83448cae35607fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.select_on_container_copy_construction()&lt;/code&gt;(optional)</source>
          <target state="translated">&lt;code&gt;a.select_on_container_copy_construction()&lt;/code&gt;(optional)</target>
        </trans-unit>
        <trans-unit id="5bb2e68d5445cea4b26205a011d0aa743c92c1c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;--a&lt;/code&gt; designate the same iterator object</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;--a&lt;/code&gt; 는 동일한 반복자 객체를 지정</target>
        </trans-unit>
        <trans-unit id="f31eaec78feeaa800628c492c87ab6534c3741a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, iterators of type &lt;code&gt;It&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;It&lt;/code&gt; 유형의 반복자</target>
        </trans-unit>
        <trans-unit id="5631a3cf4c29c6f79070b420431c77b390f8e0e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; is decrementable (there exists such &lt;code&gt;b&lt;/code&gt; that &lt;code&gt;a == ++b&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; decrementable (예 존재 &lt;code&gt;b&lt;/code&gt; 그 &lt;code&gt;a == ++b&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ac98130a25e5c8384dabd16fe9382c357c44bcf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;, &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; expression of type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 유형 의 , &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; 표현식</target>
        </trans-unit>
        <trans-unit id="8d29d3977e5b8a50f7a696f9fad2683f5fb22150" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; (C ++ 11)</target>
        </trans-unit>
        <trans-unit id="a080773255c341a2088ee851b7f90e5bac4bd5d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2f22fec43020b5dc49f065e22815a286b8bbb67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; objects of type &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 유형의 목적 &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1d31d50a712824c04328c864690dfa1c88c42e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, expressions of type &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;const T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; , 유형 &lt;code&gt;T&lt;/code&gt; 또는 &lt;code&gt;const T&lt;/code&gt; 의 표현식</target>
        </trans-unit>
        <trans-unit id="389219c29b183cc320f4ca708b26cd26d18dfc92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;, a dereferenceable iterator of type &lt;code&gt;It&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 유형의하는 dereferenceable 반복자 &lt;code&gt;It&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19e7f63a1c3565dc153df6600b5b3d9e0123ea40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;, an object of type &lt;code&gt;A&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 타입 &lt;code&gt;A&lt;/code&gt; 의 객체</target>
        </trans-unit>
        <trans-unit id="5c1e4d0de2fa18498a98cd2fc17e3c86937b8a86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a[b] *a &amp;amp;a a-&amp;gt;b a.b a-&amp;gt;*b a.*b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a[b] *a &amp;amp;a a-&amp;gt;b a.b a-&amp;gt;*b a.*b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d905dc296ace802dee418d5f24801c46eb426ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a[n]&lt;/code&gt; and &lt;code&gt;p[n]&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_subscript_operator&quot;&gt;subscript&lt;/a&gt; expressions, where one operand in &lt;code&gt;a[n]&lt;/code&gt; is an array lvalue(since C++11);</source>
          <target state="translated">&lt;code&gt;a[n]&lt;/code&gt; 내장 &lt;a href=&quot;operator_member_access#Built-in_subscript_operator&quot;&gt;첨자&lt;/a&gt; 표현식 a [n] 및 &lt;code&gt;p[n]&lt;/code&gt; , 여기서 &lt;code&gt;a[n]&lt;/code&gt; 한 피연산자 는 배열 lvalue (C ++ 11부터)입니다.</target>
        </trans-unit>
        <trans-unit id="a9a9c05ad8bcdf97de191518b1fab31fd2e30e38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a[n]&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_subscript_operator&quot;&gt;subscript&lt;/a&gt; expression, where one operand is an array rvalue;</source>
          <target state="translated">&lt;code&gt;a[n]&lt;/code&gt; 하나의 피연산자가 배열 rvalue 인 내장 &lt;a href=&quot;operator_member_access#Built-in_subscript_operator&quot;&gt;첨자&lt;/a&gt; 표현식 a [n] .</target>
        </trans-unit>
        <trans-unit id="e2db2c6d5b3de2f11a703f87fdd6fbd9dab79f94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;adopt_lock_t&lt;/code&gt; parameter was last, impeding class template argument deduction</source>
          <target state="translated">&lt;code&gt;adopt_lock_t&lt;/code&gt; 매개 변수가 마지막이므로 클래스 템플리트 인수 공제를 방해 함</target>
        </trans-unit>
        <trans-unit id="1d54ad5b7394903eb5b06e3e59b78dcd7dfccc78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alignas(0)&lt;/code&gt; is always ignored.</source>
          <target state="translated">&lt;code&gt;alignas(0)&lt;/code&gt; 은 항상 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="04c28354be7a9b1f9297d6b36dad32a3246f1858" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alignas(&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alignas(&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5451bd76eefe6c53b00dc7c14d8a175e34bbaf58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alignas(&lt;/code&gt;pack&lt;code&gt;...&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alignas(&lt;/code&gt;pack&lt;code&gt;...&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a3c108fa195acccb5821c422ab6eeb4eb80f3aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alignas(&lt;/code&gt;type-id&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alignas(&lt;/code&gt;type-id&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bb50882db8c7597e2f1fc5fa6f15b1a0758ca35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alignment&lt;/code&gt; required to be a fundamental or supported extended alignment value</source>
          <target state="translated">&lt;code&gt;alignment&lt;/code&gt; 기본 또는 확장 지원 배향 값일 필요</target>
        </trans-unit>
        <trans-unit id="09bc6a6eaf998ab70767507d3993c71049f6c87b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alignment&lt;/code&gt; shall be a power of two.</source>
          <target state="translated">&lt;code&gt;alignment&lt;/code&gt; 은 2의 거듭 제곱이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ebd2ec0b130f71d262d87cd87e080e799f354dca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alignof(&lt;/code&gt;type-id&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alignof(&lt;/code&gt;type-id&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f44e7b7045981421755d118aa1f74107340a7771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;allocator_type::value_type&lt;/code&gt; must be the same as &lt;code&gt;X::value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;allocator_type::value_type&lt;/code&gt; 은 &lt;code&gt;X::value_type&lt;/code&gt; 과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="3532ce805aaa10fb133fe6a09e77355516837e45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;app&lt;/code&gt;, &lt;code&gt;out|app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;app&lt;/code&gt; , &lt;code&gt;out|app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07c827073bf89e714367ae756bf6369538f5f235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt;, suitable argument list, which may be empty</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; , 적합한 인수 목록. 비어있을 수 있음</target>
        </trans-unit>
        <trans-unit id="37d5e9afff11c7d6f1a32d566e8647f07d8068c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt;: a function parameter pack with the pattern &lt;code&gt;Arg&amp;amp;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; : 패턴 &lt;code&gt;Arg&amp;amp;&amp;amp;&lt;/code&gt; 가진 함수 매개 변수 팩</target>
        </trans-unit>
        <trans-unit id="5badce74e4250cbddfbfaee79d4cc54fac1ff9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argument_type&lt;/code&gt;(deprecated in C++17)</source>
          <target state="translated">&lt;code&gt;argument_type&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="2f117061012ddeffdc3050c3b2b1050ec416dac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argument_type&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;argument_type&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음) (C ++ 20에서 제거됨)</target>
        </trans-unit>
        <trans-unit id="42c2f18252f2ad115d660eb4fe5d1c943f0deaaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_writable_bytes&lt;/code&gt; only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_const&quot;&gt;std::is_const_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;as_writable_bytes&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../types/is_const&quot;&gt;std::is_const_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="a33ed179d2cca7162a766f390d4bcea8b632ae99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm (&lt;/code&gt;string_literal&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;asm (&lt;/code&gt; string_literal &lt;code&gt;)&lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81416574a3bdb5b6e662f9881120a34330414456" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atexit&lt;/code&gt; is thread-safe: calling the function from several threads does not induce a data race.</source>
          <target state="translated">&lt;code&gt;atexit&lt;/code&gt; 은 스레드로부터 안전합니다. 여러 스레드에서 함수를 호출해도 데이터 경쟁이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82fe65c70980dd8294c7a044920ff6948bb995a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_cancel&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;atomic_cancel&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="718753e51ee58fcc3a9b874bbfc25e05ee87099f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_cancel&lt;/code&gt;compound-statement.</source>
          <target state="translated">&lt;code&gt;atomic_cancel&lt;/code&gt;compound-statement.</target>
        </trans-unit>
        <trans-unit id="c4bb431c9a8c27ffbcb57f1e2030ffcdaa682589" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_commit&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;atomic_commit&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="dc03de8684bde862cdd451c15145d5937d4aa9e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_commit&lt;/code&gt;compound-statement.</source>
          <target state="translated">&lt;code&gt;atomic_commit&lt;/code&gt;compound-statement.</target>
        </trans-unit>
        <trans-unit id="9917e2226a40c215ff624d65d369e5d18521d70b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_noexcept&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;atomic_noexcept&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="5d7a8f566cfc5ea680fc175590dc8b6fc4e5f7b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_noexcept&lt;/code&gt;compound-statement.</source>
          <target state="translated">&lt;code&gt;atomic_noexcept&lt;/code&gt;compound-statement.</target>
        </trans-unit>
        <trans-unit id="84df6b95b4568b36529d65a8fee8565da22271bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_thread_fence&lt;/code&gt; imposes stronger synchronization constraints than an atomic store operation with the same &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;. While an atomic store-release operation prevents all preceding writes from moving past the store-release, an &lt;code&gt;atomic_thread_fence&lt;/code&gt; with &lt;code&gt;memory_order_release&lt;/code&gt; ordering prevents all preceding writes from moving past all subsequent stores.</source>
          <target state="translated">&lt;code&gt;atomic_thread_fence&lt;/code&gt; 는 동일한 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; 사용하는 원자 저장소 작업보다 더 강력한 동기화 제한 조건을 부과 합니다. 원자 매장 해제 조작은 상점 출시를지나, 이동 앞의 모든 쓰기를 방지하는 동안 &lt;code&gt;atomic_thread_fence&lt;/code&gt; 와 &lt;code&gt;memory_order_release&lt;/code&gt; 의 모든 후속 매장을지나 이동 주문을 방지 모든 이전 쓰기를.</target>
        </trans-unit>
        <trans-unit id="d2b8b8d94103c192bc34b9f2294272b3203ef193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;audit&lt;/code&gt; contract level</source>
          <target state="translated">&lt;code&gt;audit&lt;/code&gt; 계약 레벨</target>
        </trans-unit>
        <trans-unit id="76aee5a355d183a0f5d23e16f44cf76ee2b9d2e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto &amp;amp;&amp;amp; __range =&lt;/code&gt;range_expression&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;auto &amp;amp;&amp;amp; __range =&lt;/code&gt; range_expression &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9f17e418dc5efb3e325fa889fa484a44b496616" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto p = &lt;a href=&quot;../memory/unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&amp;lt;S&amp;gt;(); p-&amp;gt;bar()&lt;/code&gt; calls &lt;code&gt;p.operator-&amp;gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;auto p = &lt;a href=&quot;../memory/unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&amp;lt;S&amp;gt;(); p-&amp;gt;bar()&lt;/code&gt; 는 &lt;code&gt;p.operator-&amp;gt;()&lt;/code&gt; 를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="032d85b2fb46f2a33a2e395c59034caf15133db6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="ec4949cdf660704545c46868dec318b7dbf26454" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto&lt;/code&gt; placeholder type specifier</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 자리 표시 자 유형 지정자</target>
        </trans-unit>
        <trans-unit id="dd355700463adc8e941685a068bf44f8191f5a8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_ptr&lt;/code&gt; is a smart pointer that manages an object obtained via &lt;a href=&quot;../language/new&quot;&gt;new expression&lt;/a&gt; and deletes that object when &lt;code&gt;auto_ptr&lt;/code&gt; itself is destroyed. It may be used to provide exception safety for dynamically-allocated objects, for passing ownership of dynamically-allocated objects into functions and for returning dynamically-allocated objects from functions.</source>
          <target state="translated">&lt;code&gt;auto_ptr&lt;/code&gt; 은 &lt;a href=&quot;../language/new&quot;&gt;새로운 표현식을&lt;/a&gt; 통해 얻은 객체를 관리하고 &lt;code&gt;auto_ptr&lt;/code&gt; 자체가 파괴 될 때 해당 객체를 삭제 하는 스마트 포인터입니다 . 동적으로 할당 된 객체에 대한 예외 안전성을 제공하고 동적으로 할당 된 객체의 소유권을 함수에 전달하고 함수에서 동적으로 할당 된 객체를 반환하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83ea9a5c7bd8a0003bfe61072b17683f502bbfcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_ptr_ref&lt;/code&gt; is an implementation-defined type that holds a reference to &lt;code&gt;auto_ptr&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; is implicitly &lt;a href=&quot;operator_auto_ptr&quot;&gt;convertible to&lt;/a&gt; and &lt;a href=&quot;operator=&quot;&gt;assignable from&lt;/a&gt; this type. The implementation is allowed to provide the template with a different name or implement equivalent functionality in other ways.</source>
          <target state="translated">&lt;code&gt;auto_ptr_ref&lt;/code&gt; 는 참조 보유 구현 정의 타입 &lt;code&gt;auto_ptr&lt;/code&gt; 은이 . &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; 은이 유형으로 암시 적으로 &lt;a href=&quot;operator_auto_ptr&quot;&gt;변환 가능&lt;/a&gt; 하고 &lt;a href=&quot;operator=&quot;&gt;할당 가능&lt;/a&gt; 합니다. 구현시 템플릿에 다른 이름을 제공하거나 다른 방식으로 동등한 기능을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1181b079848ad4630e4817e7becf18e0449676f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;available&lt;/code&gt; -- free space available to a non-privileged process (may be equal or less than &lt;code&gt;free&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;available&lt;/code&gt; - 비 특권 프로세스에 사용할 수있는 자유 공간 (이하일 수있다 &lt;code&gt;free&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="193a702a1ece3e62c51179d1fd50a43ed52b5dbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;awaiter.await_suspend(handle)&lt;/code&gt; is called, where handle is the coroutine handle representing the current coroutine. Inside that function, the suspended coroutine state is observable via that handle, and it's this function's responsibility to schedule it to resume on some executor, or to be destroyed (returning false counts as scheduling)</source>
          <target state="translated">&lt;code&gt;awaiter.await_suspend(handle)&lt;/code&gt; 이 호출됩니다. 여기서 handle은 현재 코 루틴을 나타내는 코 루틴 핸들입니다. 해당 함수 내에서 일시 중지 된 코 루틴 상태는 해당 핸들을 통해 관찰 가능하며 일부 실행 프로그램에서 재개하거나 파기되도록 예약하는 것은이 함수의 책임입니다 (스케줄링으로 잘못된 카운트를 리턴 함)</target>
        </trans-unit>
        <trans-unit id="d025861833dc33a493957293ac40ae06518ca811" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;axiom&lt;/code&gt; contract level</source>
          <target state="translated">&lt;code&gt;axiom&lt;/code&gt; 계약 레벨</target>
        </trans-unit>
        <trans-unit id="145025995cddfb0c2c9c5f6b4c119aef67258c74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b == a + (b - a)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b == a + (b - a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca7fddee6b98e45102228f555b713744042ea185" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.size()&lt;/code&gt; where &lt;code&gt;b&lt;/code&gt; is the largest possible container</source>
          <target state="translated">&lt;code&gt;b.size()&lt;/code&gt; 여기서 &lt;code&gt;b&lt;/code&gt; 는 가능한 가장 큰 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="ce50e8c6ef19594e1c432b6f85c1a4b90bf3a38d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b1 &amp;amp;&amp;amp; b2&lt;/code&gt;, &lt;code&gt;b1 &amp;amp;&amp;amp; bool(b2)&lt;/code&gt; and &lt;code&gt;bool(b1) &amp;amp;&amp;amp; b2&lt;/code&gt; are all equal to &lt;code&gt;bool(b1) &amp;amp;&amp;amp; bool(b2)&lt;/code&gt; and have the same short-circuit evaluation;</source>
          <target state="translated">&lt;code&gt;b1 &amp;amp;&amp;amp; b2&lt;/code&gt; , &lt;code&gt;b1 &amp;amp;&amp;amp; bool(b2)&lt;/code&gt; 및 &lt;code&gt;bool(b1) &amp;amp;&amp;amp; b2&lt;/code&gt; 는 모두 &lt;code&gt;bool(b1) &amp;amp;&amp;amp; bool(b2)&lt;/code&gt; 와 동일하며 단락 평가가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d123116bc0f09ca3ad761949ce648847c34c92b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b1 || b2&lt;/code&gt;, &lt;code&gt;b1 || bool(b2)&lt;/code&gt; and &lt;code&gt;bool(b1) || b2&lt;/code&gt; are all equal to &lt;code&gt;bool(b1) || bool(b2)&lt;/code&gt; and have the same short-circuit evaluation;</source>
          <target state="translated">&lt;code&gt;b1 || b2&lt;/code&gt; , &lt;code&gt;b1 || bool(b2)&lt;/code&gt; 및 &lt;code&gt;bool(b1) || b2&lt;/code&gt; 는 모두 &lt;code&gt;bool(b1) || bool(b2)&lt;/code&gt; 과 같습니다. || bool (b2) 이며 동일한 단락 평가를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6eac658ea175ac6c07451b1a46e798bdf17973ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b1&lt;/code&gt;, &lt;code&gt;b2&lt;/code&gt;, two lvalues of type &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;b1&lt;/code&gt; , &lt;code&gt;b2&lt;/code&gt; , 유형의 두 lvalues &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="6412a702062a0e09604a23adde3b60d786050fcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;, a value of type &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="514056c1b49ea5088c99f6942670236289b94c07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;, an object of type &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 타입, &lt;code&gt;B&lt;/code&gt; 타입의 객체</target>
        </trans-unit>
        <trans-unit id="d7b9ab4cd6e6ceb7dce4b20058d3e2f787ff2546" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;back_inserter&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;back_insert_iterator&quot;&gt;std::back_insert_iterator&lt;/a&gt;&lt;/code&gt; for the container &lt;code&gt;c&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;back_inserter&lt;/code&gt; 는 컨테이너 &lt;code&gt;c&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;back_insert_iterator&quot;&gt;std::back_insert_iterator&lt;/a&gt;&lt;/code&gt; 를 인수 유형에서 추론 한 유형으로 구성하는 편리한 함수 템플리트입니다 .</target>
        </trans-unit>
        <trans-unit id="aef2a40fcb800e3d5daaaf24742ed673ba9aa6ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bad_exception&lt;/code&gt; object to initialize with</source>
          <target state="translated">&lt;code&gt;bad_exception&lt;/code&gt; 초기화 할 bad_exception 객체</target>
        </trans-unit>
        <trans-unit id="23fc76c7aa7f5cc34c63b8435077717406faa856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;basic_ios&lt;/code&gt; accessors</source>
          <target state="translated">&lt;code&gt;basic_ios&lt;/code&gt; 접근 자</target>
        </trans-unit>
        <trans-unit id="991738fdb1ba79201bd3b5fff575043207e9cd52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;begin()&lt;/code&gt; returns a &lt;a href=&quot;../../iterator&quot;&gt;mutable&lt;/a&gt; or &lt;a href=&quot;../../iterator&quot;&gt;constant&lt;/a&gt; iterator, depending on the constness of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;begin()&lt;/code&gt; 은 &lt;code&gt;*this&lt;/code&gt; 의 constness에 따라 &lt;a href=&quot;../../iterator&quot;&gt;변경 가능&lt;/a&gt; 하거나 &lt;a href=&quot;../../iterator&quot;&gt;상수&lt;/a&gt; 반복자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3b2fabff44652b835a21acf2d98bc9b7da6e6b10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb7fcec2ec181e4e03c55c4a974329ae46c607c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;begin[k] = r2&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;begin[k] = r2&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f62481721c1ee365dcb7f62b2010bbb186f92805" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;beta(x, y)&lt;/code&gt; equals &lt;code&gt;beta(y, x)&lt;/code&gt;  When &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are positive integers, beta(x,y) equals \(\frac{(x-1)!(y-1)!}{(x+y-1)!}\).</source>
          <target state="translated">&lt;code&gt;beta(x, y)&lt;/code&gt; 동일 &lt;code&gt;beta(y, x)&lt;/code&gt; 경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 양의 정수, &amp;beta;- (x, y)의 동일 \ (\ FRAC있다 {(X-1)! (Y-1)!} {(X + y-1)!} \).</target>
        </trans-unit>
        <trans-unit id="604472692ecd3c5f988851b616db9e5f20d83e85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bidirectional_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bidirectional_iterator_tag&lt;/code&gt; 는 &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator에&lt;/a&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="125381ef6ab81d128250226bfde14db875a5b559" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_function&lt;/code&gt; does not define &lt;code&gt;operator()&lt;/code&gt;; it is expected that derived classes will define this. &lt;code&gt;binary_function&lt;/code&gt; provides only three types - &lt;code&gt;first_argument_type&lt;/code&gt;, &lt;code&gt;second_argument_type&lt;/code&gt; and &lt;code&gt;result_type&lt;/code&gt; - defined by the template parameters.</source>
          <target state="translated">&lt;code&gt;binary_function&lt;/code&gt; 은 &lt;code&gt;operator()&lt;/code&gt; 정의하지 않습니다 . 파생 클래스가이를 정의 할 것으로 예상됩니다. &lt;code&gt;binary_function&lt;/code&gt; 은 템플리트 매개 변수로 정의 된 &lt;code&gt;first_argument_type&lt;/code&gt; , &lt;code&gt;second_argument_type&lt;/code&gt; 및 &lt;code&gt;result_type&lt;/code&gt; 의 세 가지 유형 만 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="16e551d920ab702201b563e5755c74ae3279f81b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_function&lt;/code&gt; is a base class for creating function objects with two arguments.</source>
          <target state="translated">&lt;code&gt;binary_function&lt;/code&gt; 은 두 개의 인수로 함수 객체를 작성하기위한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="ef3776fa71d38eff37d16e4c999b4523cedc63cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_function&lt;/code&gt; is deprecated in C++11 and removed in C++17.</source>
          <target state="translated">&lt;code&gt;binary_function&lt;/code&gt; 은 C ++ 11에서 더 이상 사용되지 않으며 C ++ 17에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="fdf831ffca60a5c8451d6a8a5a4b17a971fdc8d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_negate&lt;/code&gt; is a wrapper function object returning the complement of the binary predicate it holds.</source>
          <target state="translated">&lt;code&gt;binary_negate&lt;/code&gt; 는 보유하는 2 진 술어의 보수를 리턴하는 랩퍼 함수 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="8013c54114d282ea5e941f7cdfba99882e44212e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_negate&lt;/code&gt; objects are easily constructed with helper function &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;binary_negate&lt;/code&gt; 객체는 도우미 함수 &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt; 로 쉽게 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0a58479ad5dd66246e935f29e88258c7a2b6c98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_op&lt;/code&gt; shall not invalidate iterators (including the end iterators) or subranges, nor modify elements in the ranges [first, last) or [d_first, d_first + (last - first)). Otherwise, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;binary_op&lt;/code&gt; 는 반복자 (종료 반복자를 포함) 또는 하위 범위를 무효화하거나 [first, last) 또는 [d_first, d_first + (last-first)) 범위의 요소를 수정하지 않아야합니다. 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9dc047979d7e3924246308fcb6924a121b70c6a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary|app&lt;/code&gt;, &lt;code&gt;binary|out|app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;binary|app&lt;/code&gt; , &lt;code&gt;binary|out|app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f0eed32cfc737c24a7788ccbca87ffd49f8f11f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary|out&lt;/code&gt;, &lt;code&gt;binary|out|trunc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;binary|out&lt;/code&gt; , &lt;code&gt;binary|out|trunc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6acb4c2014ee265eae300200f0e5c83e074d4983" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary|out|in|app&lt;/code&gt;, &lt;code&gt;binary|in|app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;binary|out|in|app&lt;/code&gt; , &lt;code&gt;binary|in|app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b591230d50c861956000b7a76117395374361917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bitset&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bitset&lt;/code&gt; 의 요구 사항을 충족 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; 와 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7451240076a835cf07a3a852892863076f665623" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool(b1 != b2)&lt;/code&gt;, &lt;code&gt;bool(b1 != bool(b2))&lt;/code&gt;, and &lt;code&gt;bool(bool(b1) != b2)&lt;/code&gt; are all equal to &lt;code&gt;(bool(b1) != bool(b2))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool(b1 != b2)&lt;/code&gt; , &lt;code&gt;bool(b1 != bool(b2))&lt;/code&gt; 및 &lt;code&gt;bool(bool(b1) != b2)&lt;/code&gt; 은 모두 &lt;code&gt;(bool(b1) != bool(b2))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d5690794fcc294f7e0800d3f91cdc1efa41f6d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool(b1 == b2)&lt;/code&gt;, &lt;code&gt;bool(b1 == bool(b2))&lt;/code&gt;, and &lt;code&gt;bool(bool(b1) == b2)&lt;/code&gt; are all equal to &lt;code&gt;(bool(b1) == bool(b2))&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;bool(b1 == b2)&lt;/code&gt; , &lt;code&gt;bool(b1 == bool(b2))&lt;/code&gt; 및 &lt;code&gt;bool(bool(b1) == b2)&lt;/code&gt; 은 모두 &lt;code&gt;(bool(b1) == bool(b2))&lt;/code&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0ce05b089af758edd37a80b26957774ddd79e3f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt; - type, capable of holding one of the two values: &lt;a href=&quot;bool_literal&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;bool_literal&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;. The value of &lt;code&gt;sizeof(bool)&lt;/code&gt; is implementation defined and might differ from 1.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 유형으로, &lt;a href=&quot;bool_literal&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;bool_literal&quot;&gt; &lt;code&gt;false&lt;/code&gt; &lt;/a&gt; 두 값 중 하나를 보유 할 수 있습니다. &lt;code&gt;sizeof(bool)&lt;/code&gt; 의 값 은 구현 정의이며 1과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d6ea2b6beaddc310f73e08e5cebae9d443418c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt; result of the corresponding relational operation.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 해당 관계 연산의 부울 결과.</target>
        </trans-unit>
        <trans-unit id="6dd8657c98c6f75feace5c8bb8c68d633da923ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, and unscoped enumerations are converted to &lt;code&gt;int&lt;/code&gt; or wider integer types as in &lt;a href=&quot;implicit_cast#Integer_promotion&quot;&gt;integer promotion&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; 및 unscoped 열거는 &lt;a href=&quot;implicit_cast#Integer_promotion&quot;&gt;정수 승격&lt;/a&gt; 에서와 같이 &lt;code&gt;int&lt;/code&gt; 또는 더 넓은 정수 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="7c142d9cd8f4e00ee27b16d8937b7bfc659f09ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;, the result is &lt;code&gt;false&lt;/code&gt; if the original value is zero and &lt;code&gt;true&lt;/code&gt; for all other values. For the remaining integral types, the result is the value of the enum if it can be represented by the target type and unspecified otherwise.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 이면 원래 값이 0이고 다른 모든 값에 대해 &lt;code&gt;true&lt;/code&gt; 이면 결과는 &lt;code&gt;false&lt;/code&gt; 입니다. 나머지 적분 유형의 경우 결과는 대상 유형으로 표시되고 달리 지정되지 않은 경우 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="1704b5f6c511d5e29b31127118c09864980fcfe7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;boyer_moore_horspool_searcher&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;boyer_moore_horspool_searcher&lt;/code&gt; 는 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e95a8719b769a84cb4a89872dd1a2fd9dd057945" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;boyer_moore_searcher&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;boyer_moore_searcher&lt;/code&gt; 는 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3018cefa81e15a18496ea3ac39a93bdedc72dd92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c, d&lt;/code&gt;, values of type &lt;code&gt;CharT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;c, d&lt;/code&gt; , &lt;code&gt;CharT&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="6f14da71e36259d43be9260b7cd2f545b82b0aa2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; on success except if &lt;code&gt;c&lt;/code&gt; was &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, in which case unspecified value other than &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 인 경우를 제외하고 성공시 &lt;code&gt;c&lt;/code&gt; ,이 경우 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 이외의 지정되지 않은 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6595e0c469c9ea725dee3becc791202e2a799c0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; on success except if &lt;code&gt;c&lt;/code&gt; was &lt;code&gt;Traits::eof()&lt;/code&gt;, in which case &lt;code&gt;Traits::not_eof(c)&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 가 &lt;code&gt;Traits::eof()&lt;/code&gt; 인 경우를 제외하고 성공한 경우 &lt;code&gt;c&lt;/code&gt; : 이 경우 &lt;code&gt;Traits::not_eof(c)&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b7f9b20f1dc860253fa886fac6fad0c25eb76b95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;, a value of type &lt;code&gt;const CharT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; , &lt;code&gt;const CharT&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="e3fb041f39c4cd76a7056dff86c286a069714d0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_str() + i == &lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator[](i))&lt;/code&gt; for every &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, size()]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c_str() + i == &lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator[](i))&lt;/code&gt; &lt;code&gt;[0, size()]&lt;/code&gt; 모든 &lt;code&gt;i&lt;/code&gt; 에 대해 c_str () + i == std :: addressof (operator [] (i)) 입니다 .</target>
        </trans-unit>
        <trans-unit id="89aa3cbc65df52ce608a5e7ac02629217ec8ff46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_str()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; perform the same function.</source>
          <target state="translated">&lt;code&gt;c_str()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; 는 동일한 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="6201ce88486526a9d5a89edff10f9b5e844bcd6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_str()[i] == operator[](i)&lt;/code&gt; for every &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, size())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c_str()[i] == operator[](i)&lt;/code&gt; &lt;code&gt;[0, size())&lt;/code&gt; 모든 &lt;code&gt;i&lt;/code&gt; 에 대해 c_str () [i] == operator [] (i) 입니다 .</target>
        </trans-unit>
        <trans-unit id="695d6e4e6f82836c536ff6f67b5f20765d596e63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;canonical&lt;/code&gt; has a spurious &lt;code&gt;base&lt;/code&gt; parameter</source>
          <target state="translated">&lt;code&gt;canonical&lt;/code&gt; 은 가짜 &lt;code&gt;base&lt;/code&gt; 매개 변수를 가지고</target>
        </trans-unit>
        <trans-unit id="e9d778424d09648ae8bb3c55c8adff2c01840148" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;capacity&lt;/code&gt; -- total size of the filesystem, in bytes</source>
          <target state="translated">&lt;code&gt;capacity&lt;/code&gt; - 파일 시스템의 총 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="e0aa74fd60235dd91c5b99d21f5b5e7a5710903c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catalog&lt;/code&gt; was erroneously specified as &lt;code&gt;int&lt;/code&gt; in C++11, this was corrected in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2028&quot;&gt;LWG issue #2028&lt;/a&gt; and included in C++14.</source>
          <target state="translated">&lt;code&gt;catalog&lt;/code&gt; 가 C ++ 11에서 &lt;code&gt;int&lt;/code&gt; 로 잘못 지정 되었으며 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2028&quot;&gt;LWG 문제 # 2028&lt;/a&gt; 에서 수정 되었으며 C ++ 14에 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="32b335a992e48a7e39b96c9ecbbec7090251bf77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch (&lt;/code&gt;Tobject&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;catch (&lt;/code&gt; Tobject &lt;code&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a76c13a4ced6d8aeca096ef03a660eb7e7fa09b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;...&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;...&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="951bcd9d5950fad26037ec8b382fe18ad9f95445" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;attr(optional)type-specifier-seqabstract-declarator(optional)&lt;code&gt;)&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;attr(optional)type-specifier-seqabstract-declarator(optional)&lt;code&gt;)&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="2abc29fe0d27d382c9e9d7ae5c97bad94bc7e7bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;attr(optional)type-specifier-seqdeclarator&lt;code&gt;)&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;attr(optional)type-specifier-seqdeclarator&lt;code&gt;)&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="265d210565c8bc198c650902495592b14e615308" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cbegin()&lt;/code&gt; always returns a &lt;a href=&quot;../../iterator&quot;&gt;constant&lt;/a&gt; iterator. It is equivalent to &lt;code&gt;const_cast&amp;lt;const basic_string&amp;amp;&amp;gt;(*this).begin()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cbegin()&lt;/code&gt; 항상 &lt;a href=&quot;../../iterator&quot;&gt;상수&lt;/a&gt; 반복자를 반환 합니다. 그것은 상당로 &lt;code&gt;const_cast&amp;lt;const basic_string&amp;amp;&amp;gt;(*this).begin()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b53fa0f87ce816608c34ff5bb1db059f792f746f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ch&lt;/code&gt; on success, &lt;code&gt;WEOF&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 성공시 ch , 실패시 &lt;code&gt;WEOF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5902bdd8082d07b7175e87e8b6552496268cd717" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ch&lt;/code&gt; on success, &lt;code&gt;WEOF&lt;/code&gt; on failure. If an encoding error occurs, &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;EILSEQ&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 성공시 ch , 실패시 &lt;code&gt;WEOF&lt;/code&gt; 인코딩 오류가 발생하면 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;EILSEQ&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="116b892a6e17f0b2ba65fcd7677fdb425a911eea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char16_t&lt;/code&gt; - type for UTF-16 character representation, required to be large enough to represent any UTF-16 code unit (16 bits). It has the same size, signedness, and alignment as &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint_least16_t&lt;/a&gt;&lt;/code&gt;, but is a distinct type.</source>
          <target state="translated">&lt;code&gt;char16_t&lt;/code&gt; -UTF-16 문자 표현을위한 유형으로, UTF-16 코드 단위 (16 비트)를 표현할 수있을만큼 커야합니다. 크기, 부호 및 정렬이 &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint_least16_t&lt;/a&gt;&lt;/code&gt; 와 동일하지만 고유 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="945338457821b46645aa197b8c00ce884b6a5203" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char16_t&lt;/code&gt; or &lt;code&gt;char32_t&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;char16_t&lt;/code&gt; 또는 &lt;code&gt;char32_t&lt;/code&gt; (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="ad9febd37adb97f5e837608e018649d4d054b2ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char32_t&lt;/code&gt; - type for UTF-32 character representation, required to be large enough to represent any UTF-32 code unit (32 bits). It has the same size, signedness, and alignment as &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint_least32_t&lt;/a&gt;&lt;/code&gt;, but is a distinct type.</source>
          <target state="translated">&lt;code&gt;char32_t&lt;/code&gt; -UTF-32 문자 표현을위한 유형으로, UTF-32 코드 단위 (32 비트)를 표현할 수있을만큼 커야합니다. 크기, 부호 및 정렬이 &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint_least32_t&lt;/a&gt;&lt;/code&gt; 와 동일하지만 고유 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2f76727583c7173fe3787d74015da4f9af2fb447" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char8_t&lt;/code&gt; - type for UTF-8 character representation, required to be large enough to represent any UTF-8 code unit (8 bits). It has the same size, signedness, and alignment as &lt;code&gt;unsigned char&lt;/code&gt; (and. therefore, the same size and alignment as &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;signed char&lt;/code&gt;), but is a distinct type.</source>
          <target state="translated">&lt;code&gt;char8_t&lt;/code&gt; -UTF-8 문자 표현을위한 유형으로, UTF-8 코드 단위 (8 비트)를 표현할 수있을만큼 커야합니다. &lt;code&gt;unsigned char&lt;/code&gt; 과 크기, 부호 및 정렬 이 동일 하지만 &lt;code&gt;char&lt;/code&gt; 및 &lt;code&gt;signed char&lt;/code&gt; 와 크기 및 정렬이 동일 하지만 고유 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a95fe516a9410a312c1068687b2ef3abb86b13de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char8_t&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;char8_t&lt;/code&gt; (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="67a29b292971e9727b5bd8ba50bf35dfa62b49ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; - type for character representation which can be most efficiently processed on the target system (has the same representation and alignment as either &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, but is always a distinct type). &lt;a href=&quot;../string/multibyte&quot;&gt;Multibyte characters strings&lt;/a&gt; use this type to represent code units. The character types are large enough to represent any UTF-8 eight-bit code unit(since C++14). The signedness of &lt;code&gt;char&lt;/code&gt; depends on the compiler and the target platform: the defaults for ARM and PowerPC are typically unsigned, the defaults for x86 and x64 are typically signed.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 대상 시스템에서 가장 효율적으로 처리 할 수있는 문자 표현 용 char 유형 ( &lt;code&gt;signed char&lt;/code&gt; 또는 &lt;code&gt;unsigned char&lt;/code&gt; 과 동일한 표현 및 정렬을 갖지만 항상 고유 한 유형 임) &lt;a href=&quot;../string/multibyte&quot;&gt;멀티 바이트 문자 문자열&lt;/a&gt; 은이 유형을 사용하여 코드 단위를 나타냅니다. 문자 유형은 UTF-8 8 비트 코드 단위 (C ++ 14부터)를 나타낼만큼 충분히 큽니다. &lt;code&gt;char&lt;/code&gt; 의 부호는 컴파일러와 대상 플랫폼에 따라 다릅니다. ARM 및 PowerPC의 기본값은 일반적으로 부호가없고 x86 및 x64의 기본값은 일반적으로 부호가 있습니다.</target>
        </trans-unit>
        <trans-unit id="025be35fa02ce9330b9d00a12b219b118b301b0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; can be converted to &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;unsigned int&lt;/code&gt; depending on the underlying type: &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; (see above);</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 는 기본 유형에 따라 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;unsigned int&lt;/code&gt; 로 변환 될 수 있습니다 . &lt;code&gt;signed char&lt;/code&gt; 또는 &lt;code&gt;unsigned char&lt;/code&gt; (위 참조);</target>
        </trans-unit>
        <trans-unit id="47a3a82c4593fa0959ef8cbe7bf50f291eea94cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 또는 &lt;code&gt;wchar_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fb8babbd1e77119f20f4cc12d08b49df3573f51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt;).</target>
        </trans-unit>
        <trans-unit id="8902bbe3b62d5a977dd3062a35a69ce055124a21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_traits&amp;lt;char16_t&amp;gt;&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;char_traits&amp;lt;char16_t&amp;gt;&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="d2dc1a15f34d17da88aad9dde6ec3e69635d3345" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_traits&amp;lt;char32_t&amp;gt;&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;char_traits&amp;lt;char32_t&amp;gt;&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="34589ff4f2cb873608e4f3a38668d00d2387c096" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_traits&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;char_traits&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="bd37483306e249adabda089c75cf31326832d4e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chrono&lt;/code&gt; I/O</source>
          <target state="translated">&lt;code&gt;chrono&lt;/code&gt; I / O</target>
        </trans-unit>
        <trans-unit id="1a4855b8a75e7b38866fc680ea79de08951ccd36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cl&lt;/code&gt;, an object of type &lt;code&gt;X::char_class_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cl&lt;/code&gt; &lt;code&gt;X::char_class_type&lt;/code&gt; 유형의 객체</target>
        </trans-unit>
        <trans-unit id="57a18910b3fe4f7ebabccebcdfec1c594102f977" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class-template-name&amp;lt;I&amp;gt;&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;class-template-name&amp;lt;I&amp;gt;&lt;/code&gt;;</target>
        </trans-unit>
        <trans-unit id="447e41573e79eb660fb45e428d9831293a2bb516" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class-template-name&amp;lt;T&amp;gt;&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;class-template-name&amp;lt;T&amp;gt;&lt;/code&gt;;</target>
        </trans-unit>
        <trans-unit id="840262bf641c742885644a8867137b23e642ee04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clear&lt;/code&gt; invalidates all iterators and references. Because it erases all elements, this technically complies with the rules above.</source>
          <target state="translated">&lt;code&gt;clear&lt;/code&gt; 는 모든 반복자와 참조를 무효화합니다. 모든 요소를 ​​지우므로 기술적으로 위의 규칙을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="40837755ab7959ccd1e6e1c575733ddfc3d086ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;close()&lt;/code&gt; is typically called through the destructor of &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; (which, in turn, is typically called by the destructor of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;close()&lt;/code&gt; 는 일반적으로 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 의 소멸자를 통해 호출됩니다 (이는 일반적으로 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 의 소멸자가 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3d9dcf30735aeba307868d3b80bb591d9d12750b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;co_await&lt;/code&gt;expr</source>
          <target state="translated">&lt;code&gt;co_await&lt;/code&gt;expr</target>
        </trans-unit>
        <trans-unit id="b54d011270f4edc60c88fc86547fc85c84bfc825" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;co_return expr&lt;/code&gt; where expr has type void</source>
          <target state="translated">&lt;code&gt;co_return expr&lt;/code&gt; 여기서 expr은 void 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b6af45614986a085cc196762b62c12a486df7559" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;co_yield&lt;/code&gt;braced-init-list</source>
          <target state="translated">&lt;code&gt;co_yield&lt;/code&gt;braced-init-list</target>
        </trans-unit>
        <trans-unit id="95154f3d418ab26ed6d327edf5d5ebfec32b9c6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;co_yield&lt;/code&gt;expr</source>
          <target state="translated">&lt;code&gt;co_yield&lt;/code&gt;expr</target>
        </trans-unit>
        <trans-unit id="6faca95322a3b3d33815965dd2f73dd6ccf68e98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;common_type&amp;lt;int, int&amp;gt;::type&lt;/code&gt; is &lt;code&gt;int&amp;amp;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;common_type&amp;lt;int, int&amp;gt;::type&lt;/code&gt; 은 &lt;code&gt;int&amp;amp;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e8493c1deebf8f0e11beacd2cc163a9d752492e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;common_type&lt;/code&gt; is not SFINAE-friendly</source>
          <target state="translated">&lt;code&gt;common_type&lt;/code&gt; 은 SFINAE 친화적이지 않습니다</target>
        </trans-unit>
        <trans-unit id="64efe9a1bf02848912f9333dac7816a88d09c9cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;common_type&lt;/code&gt; specializations are nearly impossible to write</source>
          <target state="translated">&lt;code&gt;common_type&lt;/code&gt; 전문화는 거의 불가능하다</target>
        </trans-unit>
        <trans-unit id="554fb3f88c0ecbe59bb9447e2022926cd7b08560" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;comp(lhs.first, rhs.first)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;comp(lhs.first, rhs.first)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f2523d45a894bd83c166d7c2f86f45441c477dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;comp&lt;/code&gt;, an object of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;comp&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; 유형의 객체</target>
        </trans-unit>
        <trans-unit id="cdf1059c5241ff6172285cce25a7e15b8a2a809d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;complex&lt;/code&gt;&amp;lt;float&amp;gt;&lt;code&gt;complex&lt;/code&gt;&amp;lt;double&amp;gt;&lt;code&gt;complex&lt;/code&gt;&amp;lt;long double&amp;gt;</source>
          <target state="translated">&lt;code&gt;complex&lt;/code&gt; &amp;lt;float&amp;gt; &lt;code&gt;complex&lt;/code&gt; &amp;lt;double&amp;gt; &lt;code&gt;complex&lt;/code&gt; &amp;lt;long double&amp;gt;</target>
        </trans-unit>
        <trans-unit id="26dc5a3ad5b984fe0791f4d98e3a2ae086ecdace" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concept&lt;/code&gt;concept-name&lt;code&gt;=&lt;/code&gt;constraint-expression&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;concept&lt;/code&gt;concept-name&lt;code&gt;=&lt;/code&gt;constraint-expression&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="297480fbe0c371720393479054cc75c4eb9efe23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;condition_variable&lt;/code&gt; is used in combination with a &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; to facilitate inter-thread communication.</source>
          <target state="translated">&lt;code&gt;condition_variable&lt;/code&gt; 은 스레드 간 통신을 용이하게하기 위해 &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce602ea724c696fc4264247e3f5c11195508073e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const T&amp;amp;&lt;/code&gt; otherwise (&lt;code&gt;It&lt;/code&gt; is constant),</source>
          <target state="translated">&lt;code&gt;const T&amp;amp;&lt;/code&gt; 그렇지 ( &lt;code&gt;It&lt;/code&gt; 상수)</target>
        </trans-unit>
        <trans-unit id="a996f39e93f402c926c96e8454425deb9f7fa668" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const T*&lt;/code&gt; specialization member types</source>
          <target state="translated">&lt;code&gt;const T*&lt;/code&gt; 전문화 멤버 유형</target>
        </trans-unit>
        <trans-unit id="8ee674418aeb67071bc8ac00d898ea7ae954fdb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const char16_t[]&lt;/code&gt; or &lt;code&gt;const char32_t[]&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;const char16_t[]&lt;/code&gt; 또는 &lt;code&gt;const char32_t[]&lt;/code&gt; (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="66f567ad8c4304d5cdef87608b2a1af88972dada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const char8_t[]&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;const char8_t[]&lt;/code&gt; (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="9eed69b60f79e50e3e0cbc5aa8f6736a3226f411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const char[]&lt;/code&gt; or &lt;code&gt;const wchar_t[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const char[]&lt;/code&gt; 또는 &lt;code&gt;const wchar_t[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6df32d7fb02903624617eb9d49776e35b4496ecc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const int (* volatile S::* const)[20]&lt;/code&gt; and &lt;code&gt;int (* const S::* volatile)[20]&lt;/code&gt; are similar;</source>
          <target state="translated">&lt;code&gt;const int (* volatile S::* const)[20]&lt;/code&gt; 및 &lt;code&gt;int (* const S::* volatile)[20]&lt;/code&gt; 은 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="47f8209f26f85dfd3a4a12e900c44507f02c23a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const int (*)(int *)&lt;/code&gt; and &lt;code&gt;int (*)(int *)&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;const int (*)(int *)&lt;/code&gt; 및 &lt;code&gt;int (*)(int *)&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="52508689cda680f3e3c998354c4471c1de258e53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const int * volatile *&lt;/code&gt; and &lt;code&gt;int * * const&lt;/code&gt; are similar;</source>
          <target state="translated">&lt;code&gt;const int * volatile *&lt;/code&gt; 와 &lt;code&gt;int * * const&lt;/code&gt; 는 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="515e72e3784d234c7642a509460ae78aecf30768" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; &amp;lt; &lt;code&gt;const volatile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; &amp;lt; &lt;code&gt;const volatile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ecbcb74ecd84607917d5d8459726b7ca1500a93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; - defines that the type is</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; - 유형이</target>
        </trans-unit>
        <trans-unit id="849523fe8ba7e5e307622eb0fcdc78dfb1857ae3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; Object of type &lt;code&gt;X::hasher&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; &lt;code&gt;X::hasher&lt;/code&gt; 유형의 const 객체</target>
        </trans-unit>
        <trans-unit id="eb46134c57f52e5a5e9f17f34016e7e0dde21300" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; Object of type &lt;code&gt;X::key_equal&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; &lt;code&gt;X::key_equal&lt;/code&gt; 유형의 const 객체</target>
        </trans-unit>
        <trans-unit id="3b2f6157e9d655a9fd9e59e89ed7af589e05200b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; Object of type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 유형의 const 객체</target>
        </trans-unit>
        <trans-unit id="8fd4e9f1b889fc95d587a6ae498ab55f271be55b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; type qualifier</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 타입 한정자</target>
        </trans-unit>
        <trans-unit id="86870f391072bb2629fd0ebc05f5cc5f658c6111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_cast &amp;lt;&lt;/code&gt;new_type&lt;code&gt;&amp;gt; (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const_cast &amp;lt;&lt;/code&gt; new_type &lt;code&gt;&amp;gt; (&lt;/code&gt; 식 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4df3b2f2a6e041b66d00d0f4162026f7c6293554" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_cast&lt;/code&gt; conversion</source>
          <target state="translated">&lt;code&gt;const_cast&lt;/code&gt; 변환</target>
        </trans-unit>
        <trans-unit id="73834da188aa4ff3291884a29d89d96fcef4eee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_cast&lt;/code&gt; makes it possible to form a reference or pointer to non-const type that is actually referring to a &lt;a href=&quot;cv&quot;&gt;const object&lt;/a&gt; or a reference or pointer to non-volatile type that is actually referring to a &lt;a href=&quot;cv&quot;&gt;volatile object&lt;/a&gt;. Modifying a const object through a non-const access path and referring to a volatile object through a non-volatile &lt;a href=&quot;value_category#glvalue&quot;&gt;glvalue&lt;/a&gt; results in undefined behavior.</source>
          <target state="translated">&lt;code&gt;const_cast&lt;/code&gt; 는 실제로 &lt;a href=&quot;cv&quot;&gt;const 객체를&lt;/a&gt; 참조하는 비 const 유형에 대한 참조 또는 포인터 또는 실제로 &lt;a href=&quot;cv&quot;&gt;휘발성 객체를&lt;/a&gt; 참조하는 비 휘발성 유형에 대한 참조 또는 포인터를 형성 할 수 있습니다. 비 const 액세스 경로를 통해 const 객체를 수정하고 비 휘발성 &lt;a href=&quot;value_category#glvalue&quot;&gt;glvalue를&lt;/a&gt; 통해 휘발성 객체를 참조하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1b05714965760fefb084cefcc9d67a2e9e945860" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_iterator&lt;/code&gt; to the character following the last character.</source>
          <target state="translated">&lt;code&gt;const_iterator&lt;/code&gt; 는 마지막 문자 다음에 오는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="ff3530967d52517c00cc586fba76e43e4a0a499f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_iterator&lt;/code&gt; to the first character.</source>
          <target state="translated">&lt;code&gt;const_iterator&lt;/code&gt; 를 첫 번째 문자로</target>
        </trans-unit>
        <trans-unit id="7a75a6dc00b537c7e4ccb590a1cf2062b47a7c48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_pointer&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;const_pointer&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음) (C ++ 20에서 제거됨)</target>
        </trans-unit>
        <trans-unit id="db5830dbbab3c9f6d28543e44b265d86291893a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_reference&lt;/code&gt; for const a.</source>
          <target state="translated">&lt;code&gt;const_reference&lt;/code&gt; const a에 대한 const_reference</target>
        </trans-unit>
        <trans-unit id="697d0afbfbbac7bcabba065341cb16898159a75d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_reference&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;const_reference&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음) (C ++ 20에서 제거됨)</target>
        </trans-unit>
        <trans-unit id="f582d6a3965005d8ce7701813243bbd8179302b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_reverse_iterator&lt;/code&gt; to the character following the last character.</source>
          <target state="translated">&lt;code&gt;const_reverse_iterator&lt;/code&gt; 를 마지막 문자 뒤의 문자로</target>
        </trans-unit>
        <trans-unit id="d40cb8bf749e11876abefa1600db4e84ee627a91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_reverse_iterator&lt;/code&gt; to the first character.</source>
          <target state="translated">&lt;code&gt;const_reverse_iterator&lt;/code&gt; 를 첫 문자로.</target>
        </trans-unit>
        <trans-unit id="997295cc2d3b4a33cc70ee37adc5f4933187cd57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;consteval&lt;/code&gt; - specifies that a function is an</source>
          <target state="translated">&lt;code&gt;consteval&lt;/code&gt; - 함수가</target>
        </trans-unit>
        <trans-unit id="f174eb524209ad8a24d7788c23ab74fb724c4c41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;consteval&lt;/code&gt;: specifies that the function call operator is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt;. &lt;code&gt;consteval&lt;/code&gt; and &lt;code&gt;constexpr&lt;/code&gt; cannot be used at the same time.</source>
          <target state="translated">&lt;code&gt;consteval&lt;/code&gt; : 함수 호출 연산자가 &lt;a href=&quot;consteval&quot;&gt;즉시 함수&lt;/a&gt; 임을 지정합니다 . &lt;code&gt;consteval&lt;/code&gt; 과 &lt;code&gt;constexpr&lt;/code&gt; 을 동시에 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="60390c6e7c6371a354f2d11599e1853f362f7b67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; - specifies that the value of a variable or function can appear in &lt;a href=&quot;constant_expression&quot;&gt;constant expressions&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; - 변수 또는 함수의 값이 &lt;a href=&quot;constant_expression&quot;&gt;상수 표현식에&lt;/a&gt; 나타날 수 있도록 지정합니다</target>
        </trans-unit>
        <trans-unit id="cfd989462cbbec291a71037d602f200cc2b6115d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; function template returning the greatest common divisor of two integers</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; 두 정수의 최대 공약수를 반환하는 constexpr 함수 템플릿</target>
        </trans-unit>
        <trans-unit id="66f79f40a4b87ef73a0f44c9587b2f9522b60936" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; function template returning the least common multiple of two integers</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; 함수 템플릿 두 정수의 최소 공배수를 반환</target>
        </trans-unit>
        <trans-unit id="d48f275f501771bc35ea1b933c63b8ca18257d2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; value of type &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; equal to &lt;code&gt;abs(Denom) / gcd(Num, Denom)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; 타입의 값 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 같음 &lt;code&gt;abs(Denom) / gcd(Num, Denom)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78223edf07f451eab868f42e4d9bfd12755afd42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; value of type &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; equal to &lt;code&gt;sign(Num) * sign(Denom) * abs(Num) / gcd(Num, Denom)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; 타입의 값 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 동일가 &lt;code&gt;sign(Num) * sign(Denom) * abs(Num) / gcd(Num, Denom)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4239f3fafdcb184672789e0caaa9b1ac92caab06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt;: explicitly specifies that the function call operator is a &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; function. When this specifier is not present, the function call operator will be &lt;code&gt;constexpr&lt;/code&gt; anyway, if it happens to satisfy all constexpr function requirements</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; : 함수 호출 연산자가 &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; 함수 임을 명시 적으로 지정합니다 . 이 지정자가 없으면 함수 호출 연산자는 모든 constexpr 함수 요구 사항을 충족시키는 경우 어쨌든 &lt;code&gt;constexpr&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c21b845984d62717a898bcc9bb64709bf51e4868" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;container&lt;/code&gt;(protected member object)</source>
          <target state="translated">&lt;code&gt;container&lt;/code&gt; (보호 된 멤버 객체)</target>
        </trans-unit>
        <trans-unit id="6d86df7b769f8c1634520185d4a68bac68fa2fb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;container&lt;/code&gt;(protected)</source>
          <target state="translated">&lt;code&gt;container&lt;/code&gt;(protected)</target>
        </trans-unit>
        <trans-unit id="2ee4f7675766eb987c78ea16c7ca4abc8bedea9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contiguous_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;contiguous_iterator_tag&lt;/code&gt; 는 &lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator에&lt;/a&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="99de603392e55955fac05bfba02c1711ee23a25b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copy_options&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type). &lt;code&gt;none&lt;/code&gt; represents the empty bitmask; every other enumerator represents a distinct bitmask element.</source>
          <target state="translated">&lt;code&gt;copy_options&lt;/code&gt; 는 &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; 의 요구 사항을 충족합니다 (비트 연산자 &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;operator|&lt;/code&gt; , &lt;code&gt;operator^&lt;/code&gt; , &lt;code&gt;operator~&lt;/code&gt; , &lt;code&gt;operator&amp;amp;=&lt;/code&gt; , &lt;code&gt;operator|=&lt;/code&gt; 및 &lt;code&gt;operator^=&lt;/code&gt; 는이 유형에 대해 정의 됨). &lt;code&gt;none&lt;/code&gt; 은 빈 비트 마스크를 나타냅니다. 다른 모든 열거자는 고유 한 비트 마스크 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0e9c49a708a699991cfa76215085b76622684a55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copyfmt()&lt;/code&gt; may be used to save and restore the state of a stream. Boost provides a more fine-grained &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/io/doc/ios_state.html&quot;&gt;IO state savers&lt;/a&gt; library for the same purpose.</source>
          <target state="translated">&lt;code&gt;copyfmt()&lt;/code&gt; 사용하여 스트림 상태를 저장하고 복원 할 수 있습니다. Boost는 같은 목적 으로보다 세분화 된 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/io/doc/ios_state.html&quot;&gt;IO 상태 보호기&lt;/a&gt; 라이브러리를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="70460f5d188e7b87c850552d101cfa5a2b51d7dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copyfmt()&lt;/code&gt; may be used to save and restore the state of a stream. Boost provides a more fine-grained &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/io/doc/ios_state.html&quot;&gt;IO state savers&lt;/a&gt; library for the same purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67284dc08863291b978ed366654a06f2dfc06c26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count-1&lt;/code&gt; characters have been extracted (in which case &lt;code&gt;setstate(failbit)&lt;/code&gt; is executed).</source>
          <target state="translated">&lt;code&gt;count-1&lt;/code&gt; 문자가 추출되었습니다 (이 경우 &lt;code&gt;setstate(failbit)&lt;/code&gt; 가 실행 됨).</target>
        </trans-unit>
        <trans-unit id="14c1d900f819911905383fbcb787713b7c0b5161" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count-1&lt;/code&gt; characters have been stored</source>
          <target state="translated">&lt;code&gt;count-1&lt;/code&gt; 문자가 저장되었습니다</target>
        </trans-unit>
        <trans-unit id="4370421f845ed887052d082daed02d0e18096fda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; characters were extracted and stored</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 문자가 추출되어 저장되었습니다</target>
        </trans-unit>
        <trans-unit id="574c30c0681bfef17be02cc120d42b90c22648db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; characters were extracted. This test is disabled in the special case when &lt;code&gt;count&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 문자가 추출되었습니다. &lt;code&gt;count&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max()&lt;/code&gt; &amp;lt; &lt;a href=&quot;../streamsize&quot;&gt;std :: streamsize&lt;/a&gt; &amp;gt; :: max () 와 같은 특수한 경우이 테스트는 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="1ac51d4b143d94e6de0cb20876eeda02db8ba0f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;&lt;code&gt; - index&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; &lt;code&gt; - index&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a25961a22949d5108d96f348e53bd2197bde8ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cptr&lt;/code&gt;, a value of type &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::const_pointer&lt;/code&gt;, obtained by conversion from &lt;code&gt;ptr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cptr&lt;/code&gt; 입력 값 &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::const_pointer&lt;/code&gt; 로부터 변환 된 &lt;code&gt;ptr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8df13a1dc06479e30c994b1d8c70e8b5752fc60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cs&lt;/code&gt;, an object of type &lt;code&gt;const X::string_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cs&lt;/code&gt; &lt;code&gt;const X::string_type&lt;/code&gt; 유형의 객체 인 cs</target>
        </trans-unit>
        <trans-unit id="762b5aaed1848d4d32f2c16128b1af381c844d8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current&lt;/code&gt;(private)</source>
          <target state="translated">&lt;code&gt;current&lt;/code&gt;(private)</target>
        </trans-unit>
        <trans-unit id="ef5daddd507bab168de9ec7cde201b949b2a2274" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current&lt;/code&gt;(protected)</source>
          <target state="translated">&lt;code&gt;current&lt;/code&gt;(protected)</target>
        </trans-unit>
        <trans-unit id="165cd74ab0314daa74559a33432202810671ce0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cv-list T&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;cv-list T&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="c0c4671227f8ea9a45bf577b5a7e4b537aeb1997" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cvptr&lt;/code&gt;, a value of type &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::const_void_pointer&lt;/code&gt;, obtained by conversion from &lt;code&gt;cptr&lt;/code&gt; or from &lt;code&gt;vptr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cvptr&lt;/code&gt; 또는 &lt;code&gt;vptr&lt;/code&gt; 에서 변환하여 얻은 &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::const_void_pointer&lt;/code&gt; 유형의 값인 &lt;code&gt;cptr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1cd93fe2dba1d9398c3a10408b3a9cc95efd41db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d.count()&lt;/code&gt; is formatted using the rules of &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_string&quot;&gt;std::to_string&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_wstring&quot;&gt;std::to_wstring&lt;/a&gt;&lt;/code&gt;. In particular, if &lt;code&gt;Rep&lt;/code&gt; is a floating-point type, it is always formatted with 6 digits after the decimal point, and the number of significant digits in the resulting string may be zero if &lt;code&gt;d.count()&lt;/code&gt; is small.</source>
          <target state="translated">&lt;code&gt;d.count()&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_string&quot;&gt;std::to_string&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_wstring&quot;&gt;std::to_wstring&lt;/a&gt;&lt;/code&gt; 규칙을 사용하여 형식이 지정됩니다 . 특히 &lt;code&gt;Rep&lt;/code&gt; 가 부동 소수점 형식 인 경우 소수점 뒤에 항상 6 자리로 서식이 지정되며 &lt;code&gt;d.count()&lt;/code&gt; 가 작 으면 결과 문자열의 유효 자릿수가 0이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="651f9fdce67570503479d6ae44a4f63b5a121f00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; converted to a duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 유형이 &lt;code&gt;ToDuration&lt;/code&gt; 기간으로 변환되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3556a8cbed18d0c1515390f4058f1738c12097f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded down to a duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; &lt;code&gt;ToDuration&lt;/code&gt; 유형의 기간으로 내림 합니다.</target>
        </trans-unit>
        <trans-unit id="a0df75951e723a2a73f0a26e7b0f6523aabc62df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded down to a the next time point using duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; &lt;code&gt;ToDuration&lt;/code&gt; 유형의 지속 시간을 사용하여 다음 시점으로 내림 합니다.</target>
        </trans-unit>
        <trans-unit id="91429683e5e5d73122930f863155680438d3cef5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded to nearest time point using duration of type &lt;code&gt;ToDuration&lt;/code&gt;, rounding to even in halfway cases.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; &lt;code&gt;ToDuration&lt;/code&gt; 유형의 지속 시간을 사용하여 가장 가까운 시점으로 반올림하고 중간 경우에도 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="ddb5d33a92a03c56ccd48c588ed2837d58e323c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded to the nearest duration of type &lt;code&gt;ToDuration&lt;/code&gt;, rounding to even in halfway cases.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 는 &lt;code&gt;ToDuration&lt;/code&gt; 유형의 가장 가까운 지속 시간으로 반올림되며, 중간 경우에도 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="16443f163b0e6c80febceec5eec07385daff8273" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded up to a duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 는 &lt;code&gt;ToDuration&lt;/code&gt; 유형의 지속 시간으로 올림되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ba1cb3758fcce4c43dfa0709d08b3a59b9056177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded up to a the next time point using duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; &lt;code&gt;ToDuration&lt;/code&gt; 유형의 지속 시간을 사용하여 다음 시점으로 올림 합니다.</target>
        </trans-unit>
        <trans-unit id="183399524adf86e2819866b426f01c7672820d48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt;, a value of type &lt;code&gt;D&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 유형 &lt;code&gt;D&lt;/code&gt; 의 값</target>
        </trans-unit>
        <trans-unit id="e3bb057ec0cff334c09022fc05ef1585e446c51a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dangling&lt;/code&gt; is a placeholder type and an empty class type, used together with the template aliases &lt;a href=&quot;safe_iterator_t&quot;&gt;&lt;code&gt;ranges::safe_iterator_t&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;safe_iterator_t&quot;&gt;&lt;code&gt;ranges::safe_subrange_t&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;dangling&lt;/code&gt; 는 자리 표시 자 유형 및 빈 클래스 유형이며 템플릿 별칭 &lt;a href=&quot;safe_iterator_t&quot;&gt; &lt;code&gt;ranges::safe_iterator_t&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;safe_iterator_t&quot;&gt; &lt;code&gt;ranges::safe_subrange_t&lt;/code&gt; &lt;/a&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="aeed77864ca001a76bddf2e2e61a40c1bd601eac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data() + i == &lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator[](i))&lt;/code&gt; for every &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, size()]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data() + i == &lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator[](i))&lt;/code&gt; &lt;code&gt;[0, size()]&lt;/code&gt; 모든 &lt;code&gt;i&lt;/code&gt; 에 대해 data () + i == std :: addressof (operator [] (i)) 입니다 .</target>
        </trans-unit>
        <trans-unit id="3078b7f1d4c80c1b110d86087c6a9c473662279e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data()[i] == operator[](i)&lt;/code&gt; for every &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, size())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data()[i] == operator[](i)&lt;/code&gt; &lt;code&gt;[0, size())&lt;/code&gt; 모든 &lt;code&gt;i&lt;/code&gt; 에 대해 data () [i] == operator [] (i) 입니다 .</target>
        </trans-unit>
        <trans-unit id="bc8c38fa982e5b5987d2045d9f1de50971e21b72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;day&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;day&lt;/code&gt; 는 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2c8d8959ca5d98560b564de242b2ff6597d0895e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dd&lt;/code&gt; - 2-digit day of the month from &lt;code&gt;timeptr-&amp;gt;tm_mday&lt;/code&gt; as if printed by &lt;code&gt;sprintf&lt;/code&gt; using &lt;code&gt;%2d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dd&lt;/code&gt; - &lt;code&gt;timeptr-&amp;gt;tm_mday&lt;/code&gt; 에서 &lt;code&gt;%2d&lt;/code&gt; 사용하여 &lt;code&gt;sprintf&lt;/code&gt; 로 인쇄 한 것처럼 2 자리 일</target>
        </trans-unit>
        <trans-unit id="3a4e33e259910ef0f388744164686b75a72316f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dd&lt;/code&gt; - the day of the month</source>
          <target state="translated">&lt;code&gt;dd&lt;/code&gt; 이 달의 날</target>
        </trans-unit>
        <trans-unit id="44934ee72f5258c4f8a1a82e0459ef6eff3639b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decay-copy(E)&lt;/code&gt; if the decayed type of &lt;code&gt;E&lt;/code&gt; models &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;decay-copy(E)&lt;/code&gt; 유형 &lt;code&gt;E&lt;/code&gt; 모델 인 경우 붕괴 복사 (E) &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="078d40eeb791c9eab2e7e15d623435c16b5089e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype (&lt;/code&gt;entity&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;decltype (&lt;/code&gt; 엔티티 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4cef2572a50bbbe02226f827cb2bf71f7ae07148" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;decltype (&lt;/code&gt; 표현식 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d07aaf3ec110725af7032c41e5d6408aa1442075" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype(x)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; denotes a structured binding, names the</source>
          <target state="translated">&lt;code&gt;decltype(x)&lt;/code&gt; 여기서 &lt;code&gt;x&lt;/code&gt; 는 구조적 바인딩을 나타내며</target>
        </trans-unit>
        <trans-unit id="f1a653258ed2585cc60d039f08f1fbfbf13b7dbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype&lt;/code&gt; is useful when declaring types that are difficult or impossible to declare using standard notation, like lambda-related types or types that depend on template parameters.</source>
          <target state="translated">&lt;code&gt;decltype&lt;/code&gt; 은 템플릿 매개 변수에 의존하는 람다 관련 형식 또는 형식과 같이 표준 표기법을 사용하여 선언하기 어렵거나 불가능한 형식을 선언 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="07299d3502543191e52ab8611cc9e0f05b87eaa5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;decltype&lt;/code&gt; 지정자</target>
        </trans-unit>
        <trans-unit id="8084031d231829e0e18c517a74547421c9d48533" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declval&lt;/code&gt; is commonly used in templates where acceptable template parameters may have no constructor in common, but have the same member function whose return type is needed.</source>
          <target state="translated">&lt;code&gt;declval&lt;/code&gt; 은 일반적으로 허용 가능한 템플릿 매개 변수에 공통 생성자가 없지만 반환 유형이 필요한 동일한 멤버 함수가있는 템플릿에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a6dc6c66ff444f92e9f64dbedde3409bfb1824a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dec|oct|hex&lt;/code&gt;. Useful for masking operations</source>
          <target state="translated">&lt;code&gt;dec|oct|hex&lt;/code&gt; . 마스킹 작업에 유용</target>
        </trans-unit>
        <trans-unit id="cc2d34009345d5e40053315ffb025faba8832df1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_random_engine&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;default_random_engine&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="fc940c3f86e149b6fb8a0ab49cbd0ccb714b4cb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_searcher&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;default_searcher&lt;/code&gt; 는 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="077c4a7145581b449d92305cc732ff815a9e69ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 표현 삭제</target>
        </trans-unit>
        <trans-unit id="9a58ce0460f67f92ccc8361cf11684a665c52292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete&lt;/code&gt;&lt;code&gt;delete[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt;&lt;code&gt;delete[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ed5aed6aee0f8e724cb90f7e02d46ceb3dd3341" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;desired&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;desired&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="96fc1ef1f4ce59d38242b0f4733b4018c5e91675" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="9c3be877342461a62b3323a91353e1089ee314e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;difference_type&lt;/code&gt; - a signed integer type that can be used to identify distance between iterators</source>
          <target state="translated">&lt;code&gt;difference_type&lt;/code&gt; - 반복자 사이의 거리를 식별하는 데 사용할 수있는 부호있는 정수 유형</target>
        </trans-unit>
        <trans-unit id="8e8722abed6c9126adc03f7ab6341effd317dc53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;difference_type&lt;/code&gt; is not defined in the primary &lt;code&gt;atomic&lt;/code&gt; template or in the partial specializations for &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../memory/weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;difference_type&lt;/code&gt; 은 기본 &lt;code&gt;atomic&lt;/code&gt; 템플리트 또는 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../memory/weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 에 대한 부분 특수화에 정의되어 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c64a0caf494dd72f874d22b68ca58c859f45ef02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;difference_type&lt;/code&gt; is not defined in the primary &lt;code&gt;atomic_ref&lt;/code&gt; template.</source>
          <target state="translated">&lt;code&gt;difference_type&lt;/code&gt; 은 기본 &lt;code&gt;atomic_ref&lt;/code&gt; 템플리트에 정의되어 있지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="605f6727baefcb30f85c08791de23fffeae36f3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;difference_type&lt;/code&gt;, the type denoted by &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::difference_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;difference_type&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::difference_type&lt;/code&gt; &amp;lt;It&amp;gt; :: difference_type으로 표시되는 유형</target>
        </trans-unit>
        <trans-unit id="674eefb4052cba056071a4c1441d7ae046690b63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;directory_iterator&lt;/code&gt; is a &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; that iterates over the &lt;a href=&quot;directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; elements of a directory (but does not visit the subdirectories). The iteration order is unspecified, except that each directory entry is visited only once. The special pathnames dot and dot-dot are skipped.</source>
          <target state="translated">&lt;code&gt;directory_iterator&lt;/code&gt; 는 디렉토리 의 &lt;a href=&quot;directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt; 요소 를 반복 하지만 하위 디렉토리를 방문하지 않는 &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; 입니다 . 각 디렉토리 항목이 한 번만 방문된다는 점을 제외하고 반복 순서는 지정되지 않습니다. 특수 경로 이름 점과 점은 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="829c4c4ce416288a27de4d058572b018eab9b490" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;directory_options&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type). &lt;code&gt;none&lt;/code&gt; represents the empty bitmask; every other enumerator represents a distinct bitmask element.</source>
          <target state="translated">&lt;code&gt;directory_options&lt;/code&gt; 는 &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; 의 요구 사항을 충족합니다 (비트 연산자 &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;operator|&lt;/code&gt; , &lt;code&gt;operator^&lt;/code&gt; , &lt;code&gt;operator~&lt;/code&gt; , &lt;code&gt;operator&amp;amp;=&lt;/code&gt; , &lt;code&gt;operator|=&lt;/code&gt; 및 &lt;code&gt;operator^=&lt;/code&gt; 는이 유형에 대해 정의 됨). &lt;code&gt;none&lt;/code&gt; 은 빈 비트 마스크를 나타냅니다. 다른 모든 열거자는 고유 한 비트 마스크 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2e930479c54dd2256429b8c01c0a013c61557767" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;discard_block_engine&lt;/code&gt; is a pseudo-random number generator adaptor that discards a certain amount of data produced by the base engine. From each block of size &lt;code&gt;P&lt;/code&gt; generated by the base engine, the adaptor keeps only &lt;code&gt;R&lt;/code&gt; numbers, discarding the rest.</source>
          <target state="translated">&lt;code&gt;discard_block_engine&lt;/code&gt; 은 기본 엔진에서 생성 된 특정 양의 데이터를 버리는 의사 난수 생성기 어댑터입니다. 기본 엔진에 의해 생성 된 크기 &lt;code&gt;P&lt;/code&gt; 의 각 블록 에서 어댑터는 &lt;code&gt;R&lt;/code&gt; 번호 만 유지 하고 나머지는 버립니다.</target>
        </trans-unit>
        <trans-unit id="a7a9857b4458b10f76bad1287594cfca5be13bab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;double&lt;/code&gt; value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of the return type, the return value is undefined. If no conversion can be performed, &lt;code&gt;0.0&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 성공시 &lt;code&gt;str&lt;/code&gt; 의 내용에 해당하는 double 값 . 변환 된 값이 반환 유형의 범위를 벗어나면 반환 값이 정의되지 않습니다. 변환을 수행 할 수 없으면 &lt;code&gt;0.0&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e64f9f04e39c7e554c344fe1b8a940257bb356a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;double&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="0afff59ccefd7da74ebc53ac40b22ad894d74b4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;duration&lt;/code&gt; to copy from</source>
          <target state="translated">&lt;code&gt;duration&lt;/code&gt; 복사 기간</target>
        </trans-unit>
        <trans-unit id="4281bf65b65452c452d3ec6c674684e06dfd8cbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamic_cast &amp;lt;&lt;/code&gt;new_type&lt;code&gt;&amp;gt; (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dynamic_cast &amp;lt;&lt;/code&gt; new_type &lt;code&gt;&amp;gt; (&lt;/code&gt; 식 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8238dbb029f152a176f6c19d54b08e09c4978a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamic_cast&lt;/code&gt; conversion</source>
          <target state="translated">&lt;code&gt;dynamic_cast&lt;/code&gt; 변환</target>
        </trans-unit>
        <trans-unit id="093e05fc743668e8b3ebc73ef075855f8b635caa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamic_cast&lt;/code&gt; or &lt;code&gt;typeid&lt;/code&gt; expressions.</source>
          <target state="translated">&lt;code&gt;dynamic_cast&lt;/code&gt; 또는 &lt;code&gt;typeid&lt;/code&gt; 표현식.</target>
        </trans-unit>
        <trans-unit id="2253736d7af1b4fa986169ef0ac6ea784c56ac02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e, f&lt;/code&gt;, values of type &lt;code&gt;X::int_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;e, f&lt;/code&gt; , &lt;code&gt;X::int_type&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="78e0ec35ac993e5d463c1502149eaa544cbb4c65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e.get&amp;lt;i&amp;gt;()&lt;/code&gt;, if lookup for the identifier &lt;code&gt;get&lt;/code&gt; in the scope of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; by class member access lookup finds at least one declaration that is a function template whose first template parameter is a non-type parameter</source>
          <target state="translated">&lt;code&gt;e.get&amp;lt;i&amp;gt;()&lt;/code&gt; , 식별자에 대한 조회 경우 &lt;code&gt;get&lt;/code&gt; 범위에서 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 반원 액세스 룩업 발견하여 제 템플릿 파라미터 비 형 매개 변수 함수 템플릿은 하나 이상의 선언</target>
        </trans-unit>
        <trans-unit id="13cd5e6dd0d5f72fe829b7c9c3af3e1387fde400" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; has an immediate subexpression that is potentially-throwing</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 는 잠재적으로 던지는 부분 표현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="198087d50eb4b71b3034a51e4177330cb59ef362" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; if &lt;code&gt;X​::​eq_int_type(e, X​::​eof())&lt;/code&gt; is false</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 의 경우 &lt;code&gt;X​::​eq_int_type(e, X​::​eof())&lt;/code&gt; 거짓</target>
        </trans-unit>
        <trans-unit id="81a63e0f7a1fa5d3862bbf48583450c2410bc4b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; if &lt;code&gt;e&lt;/code&gt; and</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 의 경우 &lt;code&gt;e&lt;/code&gt; 와</target>
        </trans-unit>
        <trans-unit id="e51930a3435e04d0b1af0277065a00be36f910ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is a &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; that casts a polymorphic reference type</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 는 다형성 참조 유형을 캐스팅 하는 &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cf1fdd68c9dc26bdf66120e899db55f937491e92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 는 &lt;a href=&quot;throw&quot;&gt;던지기 표현이다&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d29dcac31c9d9d957b9cab2b7e7b0595348049d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is a &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt; expression applied to a dereferenced pointer to a polymorphic type</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 는 다형성 유형에 대한 역 참조 된 포인터에 적용되는 &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt; 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="8525600fecd6ad271a9b35fb4310321803537880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is a function call to a</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 는 a에 대한 함수 호출입니다.</target>
        </trans-unit>
        <trans-unit id="83682ad848127e8d972825cf60b01a4d1ce26671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; makes an implicit call to a</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 는 암시 적 호출을한다</target>
        </trans-unit>
        <trans-unit id="ad4ed26807ff3a1be89ef12864b69ad7937db687" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; | &lt;code&gt;E&lt;/code&gt;exponent-sign(optional)digit-sequence</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; | &lt;code&gt;E&lt;/code&gt; 지수 (선택 사항) 숫자 순서</target>
        </trans-unit>
        <trans-unit id="bf415de3f3608ad294691f55bcab37fd2e95a1f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8f05f2ec9f57075c86ff42ec6032858ca5f430b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt;, a non-const value of type &lt;code&gt;E&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; , 유형 &lt;code&gt;E&lt;/code&gt; 의 비 상수 값</target>
        </trans-unit>
        <trans-unit id="a60fb4aafcf27b03b577305dea2cefe453740828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;element_type&lt;/code&gt; was not updated for array support</source>
          <target state="translated">&lt;code&gt;element_type&lt;/code&gt; 이 배열 지원을 위해 업데이트되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="a98ac6d89c7ed950198f31905d6401942c23ed46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;else&lt;/code&gt;statement-false</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt;statement-false</target>
        </trans-unit>
        <trans-unit id="7a16baeb5992329a7fbbccf120a1ee402b84130c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;emplace&lt;/code&gt; returned &lt;code&gt;reference&lt;/code&gt;, breaking compatibility with pre-C++17 containers</source>
          <target state="translated">&lt;code&gt;emplace&lt;/code&gt; C ++ 17 이전 컨테이너와의 호환성을 깨뜨리고 반환 된 &lt;code&gt;reference&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db6a754161971e2f16d66f027bb5654e3ebcb03b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;empty_view&lt;/code&gt; does not reference any element.</source>
          <target state="translated">&lt;code&gt;empty_view&lt;/code&gt; 는 어떤 요소도 참조하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f64e8ad0206e4e3d2f71704519756ca7cefcee0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;empty_view&lt;/code&gt; is always empty.</source>
          <target state="translated">&lt;code&gt;empty_view&lt;/code&gt; 는 항상 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f61ebafa708b9099b0bae824de3758d80065782" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_shared_from_this&lt;/code&gt; provides the safe alternative to an expression like &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(this)&lt;/code&gt;, which is likely to result in &lt;code&gt;this&lt;/code&gt; being destructed more than once by multiple owners that are unaware of each other (see example below).</source>
          <target state="translated">&lt;code&gt;enable_shared_from_this&lt;/code&gt; 가 같은 표현식으로 안전한 대안을 제공 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(this)&lt;/code&gt; 의 발생 확률이고, &lt;code&gt;this&lt;/code&gt; 존재 서로 알지 못하는 여러 소유자 번 이상 파괴 (아래의 예를 참조).</target>
        </trans-unit>
        <trans-unit id="7fc22c384dd5d5d6c09837f18ec1281990d0f5b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;; &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a69f14aaeaeff8576804f56671474ae6698e5614" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;{&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; &lt;code&gt;struct|class&lt;/code&gt; name &lt;code&gt;:&lt;/code&gt; type &lt;code&gt;{&lt;/code&gt; 열거 자 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; 열거 자 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="589810a338b7c285afc57b48cd8c15059b5cd3d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;; &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8169dce7fb17d2a667303f95f69ac650aef23654" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;{&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; &lt;code&gt;struct|class&lt;/code&gt; 이름 &lt;code&gt;{&lt;/code&gt; enumerator &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; enumerator &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="043981be691aaad7b9a1ca4f78e0ad8575dc953f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;enum-name</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;enum-name</target>
        </trans-unit>
        <trans-unit id="78e25eedb0b1c8ae6d4fd5f14224be78a0b6d564" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;; &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a3de75a82c3a17e225e1e38842fc1d21aac4f9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;{&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 이름 &lt;code&gt;:&lt;/code&gt; type &lt;code&gt;{&lt;/code&gt; 열거 자 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; 열거 자 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b76682da4f8719096619c21f6aabdb2802794357" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;name&lt;code&gt;{&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 이름 &lt;code&gt;{&lt;/code&gt; 열거 자 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; 열거 자 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1ac6f2f35c9b33160a889afd00ee4f0971d409f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equiv(a, b)&lt;/code&gt;, an expression equivalent to &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;equiv(a, b)&lt;/code&gt; &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; 와 동등한 표현식</target>
        </trans-unit>
        <trans-unit id="83d7e0123adf6d55ac6129b2b5f6fb366d57c0f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;errno&lt;/code&gt; is a preprocessor macro used for error indication. It expands to a  static(until C++11) thread-local(since C++11) modifiable lvalue of type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 는 오류 표시에 사용되는 전 처리기 매크로입니다. &lt;code&gt;int&lt;/code&gt; 유형의 정적 (C ++ 11까지) thread-local (C ++ 11 이후) 수정 가능한 lvalue로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1f077484b7276f5bff23fb2d6f374ac5ee833cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;errnum&lt;/code&gt; is usually acquired from the &lt;code&gt;errno&lt;/code&gt; variable, however the function accepts any value of type &lt;code&gt;int&lt;/code&gt;. The contents of the string are locale-specific.</source>
          <target state="translated">&lt;code&gt;errnum&lt;/code&gt; 은 일반적으로 &lt;code&gt;errno&lt;/code&gt; 변수 에서 가져 오지만 함수는 &lt;code&gt;int&lt;/code&gt; 유형의 모든 값을 허용합니다 . 문자열의 내용은 로케일마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="54efe898b5fea0cd8bb94f7f5aa8270dfa1b9f16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error_code&lt;/code&gt; overload marked noexcept but can allocate memory</source>
          <target state="translated">&lt;code&gt;error_code&lt;/code&gt; 과부하가 noexcept로 표시되었지만 메모리를 할당 할 수 있음</target>
        </trans-unit>
        <trans-unit id="27bd9b6f4c75a94e86d00cda519a354a4f72f2b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error_code&lt;/code&gt; overload of &lt;code&gt;create_directories&lt;/code&gt; marked noexcept but can allocate memory</source>
          <target state="translated">&lt;code&gt;error_code&lt;/code&gt; no_cept로 표시되었지만 메모리를 할당 할 수있는 &lt;code&gt;create_directories&lt;/code&gt; 의error_code 과부하</target>
        </trans-unit>
        <trans-unit id="52cfd267d1fb93da1a4aedefd71b8e743dbda303" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error_code&lt;/code&gt; overload of &lt;code&gt;remove_all&lt;/code&gt; marked noexcept but can allocate memory</source>
          <target state="translated">&lt;code&gt;error_code&lt;/code&gt; &lt;code&gt;remove_all&lt;/code&gt; 의error_code 과부하가 noexcept로 표시되었지만 메모리를 할당 할 수 있음</target>
        </trans-unit>
        <trans-unit id="5c11ebc0c34134b531bb8050773b25db71f2c59f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;explicit (&lt;/code&gt;expression&lt;code&gt;) &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;explicit (&lt;/code&gt; expression &lt;code&gt;) &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af93d7f007d90bd5aca4c45c10991cb3a8b1a37c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;explicit&lt;/code&gt;(optional)template-name&lt;code&gt;( &lt;/code&gt;parameter-declaration-clause&lt;code&gt;)&lt;/code&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;simple-template-id&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; (선택적) 템플릿 이름 &lt;code&gt;( &lt;/code&gt; parameter-declaration-clause &lt;code&gt;)&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; simple-template-id &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fdfdc1de971bdf143d06485bfdc02c7e978ef52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;explicit&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;conversion-type-id</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;conversion-type-id</target>
        </trans-unit>
        <trans-unit id="c3138f3333aae641d3bfc8fedd2f306d422041a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; was an optional modifier which declared the template as</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; 는 템플릿을 다음과 같이 선언 한 선택적 수정 자입니다.</target>
        </trans-unit>
        <trans-unit id="36220c85ab9a339c91c5e30ceb71a2e4c11f8b6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; { declaration-seq(optional) }</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; {declaration-seq (선택 사항)}</target>
        </trans-unit>
        <trans-unit id="8b62da7283d4c3b18d849cfca6b3d95e1ce92809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;header-nameattribute-specifier-seq(optional);</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;header-nameattribute-specifier-seq(optional);</target>
        </trans-unit>
        <trans-unit id="44f4c7ad0f040b74172a809e6d3fb94b2b5dc37b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;module-nameattribute-specifier-seq(optional);</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;module-nameattribute-specifier-seq(optional);</target>
        </trans-unit>
        <trans-unit id="1f2bebbcbecabffc8bc29480848d5e366f08c912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;module-partitionattribute-specifier-seq(optional);</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;module-partitionattribute-specifier-seq(optional);</target>
        </trans-unit>
        <trans-unit id="54d67f80550db94cc293c103d3fc4f35bdb0a8e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;module&lt;/code&gt;module-namemodule-partition(optional)attribute-specifier-seq(optional);</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;module&lt;/code&gt;module-namemodule-partition(optional)attribute-specifier-seq(optional);</target>
        </trans-unit>
        <trans-unit id="9d8980fe83d7975c2646da89d015605fc7f980e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;class-declaration</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;class-declaration</target>
        </trans-unit>
        <trans-unit id="07ebce777588c91477930df782fcb0bca3595580" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;declaration</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;declaration</target>
        </trans-unit>
        <trans-unit id="485ef5eb58313ba3ac975a24caf194cd959679c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;function-declaration</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;function-declaration</target>
        </trans-unit>
        <trans-unit id="5388f146e02862bb30e5065eb61d15826ff0e267" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;declaration</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;declaration</target>
        </trans-unit>
        <trans-unit id="7454445cf39c47030674769c03a1878c2bc9d18a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern &quot;C&quot;&lt;/code&gt; makes it possible to include header files containing declarations of C library functions in a C++ program, but if the same header file is shared with a C program, &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; (which is not allowed in C) must be hidden with an appropriate &lt;a href=&quot;../preprocessor/conditional&quot;&gt;&lt;code&gt; #ifdef&lt;/code&gt;&lt;/a&gt;, typically &lt;a href=&quot;../preprocessor/replace#Predefined_macros&quot;&gt;&lt;code&gt;__cplusplus&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;extern &quot;C&quot;&lt;/code&gt; 를 사용하면 C ++ 프로그램에 C 라이브러리 함수 선언이 포함 된 헤더 파일을 포함 할 수 있지만 동일한 헤더 파일이 C 프로그램과 공유되는 경우 &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; ( C 에서는 허용되지 않음)를 숨겨야합니다. 적절한 &lt;a href=&quot;../preprocessor/conditional&quot;&gt; &lt;code&gt; #ifdef&lt;/code&gt; &lt;/a&gt; , 일반적으로 &lt;a href=&quot;../preprocessor/replace#Predefined_macros&quot;&gt; &lt;code&gt;__cplusplus&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="049b4bcce0935dea35ed60c4ae97bc6e867a7fbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="5d9a515d675b4e07c00fbc73882cc1c3629012a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;class|struct&lt;/code&gt;template-name&lt;code&gt;&amp;lt;&lt;/code&gt;argument-list&lt;code&gt;&amp;gt;&amp;nbsp;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;class|struct&lt;/code&gt;template-name&lt;code&gt;&amp;lt;&lt;/code&gt;argument-list&lt;code&gt;&amp;gt;&amp;nbsp;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c255b2cff76b9eb52459bd30442e96150366823c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;return-typename&lt;code&gt;&amp;lt;&lt;/code&gt;argument-list&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;parameter-list&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;return-typename&lt;code&gt;&amp;lt;&lt;/code&gt;argument-list&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;parameter-list&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d908e2a396ade66d08b92dca3ffcf19d34c78fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;return-typename&lt;code&gt;(&lt;/code&gt;parameter-list&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;return-typename&lt;code&gt;(&lt;/code&gt;parameter-list&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32e0da78131b0ea3faae80e66e7e23d4d6149a24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;string-literal&lt;code&gt;{&lt;/code&gt;declaration-seq(optional)&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;string-literal&lt;code&gt;{&lt;/code&gt;declaration-seq(optional)&lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="69209b29e1cf199dca3645be1461d158b2a2cfac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;string-literaldeclaration</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;string-literaldeclaration</target>
        </trans-unit>
        <trans-unit id="f78ec137a973c5ec3dc121582762566259b3af91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f F&lt;/code&gt; defines &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f F&lt;/code&gt; 는 &lt;code&gt;float&lt;/code&gt; 를 정의</target>
        </trans-unit>
        <trans-unit id="03c25b2fab4161ce3c2fbc787a8d6582f759cce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; , &lt;code&gt;F&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cad38087acf499649711df7384c393d972c26c38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;, a value of type &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;const T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; , 유형 &lt;code&gt;T&lt;/code&gt; 또는 &lt;code&gt;const T&lt;/code&gt; 의 값</target>
        </trans-unit>
        <trans-unit id="847bf2a4954a4921538a67def8856f447eab86eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;, an object of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 타입, &lt;code&gt;T&lt;/code&gt; 타입의 객체</target>
        </trans-unit>
        <trans-unit id="3e8a397a92f1dba996055e94aedcf5d5313672bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; (the match prefix is empty)</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; (일치 접두어가 비어 있음)</target>
        </trans-unit>
        <trans-unit id="fc85e8617ab3828a493182ef70f7ed80805532e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; (the match suffix is empty)</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; (일치 접미어가 비어 있음)</target>
        </trans-unit>
        <trans-unit id="61de516f32c260e7f5fe5a90b1537cd8a9f50ba3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equivalent&lt;/code&gt; or &lt;code&gt;equal&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;nonequivalent&lt;/code&gt; or &lt;code&gt;nonequal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;equivalent&lt;/code&gt; 또는 &lt;code&gt;equal&lt;/code&gt; 하고, &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;nonequivalent&lt;/code&gt; 또는 &lt;code&gt;nonequal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08f8613034a79e75a5eb4f9cacdde2bd87f6dad6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equivalent&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;nonequivalent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 이다 &lt;code&gt;equivalent&lt;/code&gt; 하고 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 것입니다 &lt;code&gt;nonequivalent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3f984d543664578f98b0890dc56486ff61a964e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; if &lt;code&gt;value() == 0&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 있는 경우 &lt;code&gt;value() == 0&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="12593eb094b85fbe61ac28dd575bb8383436e121" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_clock&lt;/code&gt; meets the &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; requirements.</source>
          <target state="translated">&lt;code&gt;file_clock&lt;/code&gt; 은 &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="416ddf4cf02b3239ae22a62374699393ea1dfa24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_clock&lt;/code&gt; provides exactly one of the following two pairs of static member functions:</source>
          <target state="translated">&lt;code&gt;file_clock&lt;/code&gt; 은 다음 두 쌍의 정적 멤버 함수 중 정확히 하나를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="861ae764ff85f053ef94bbe86ba1da8f51ed8538" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_type&lt;/code&gt; defines constants that indicate a type of a file or directory a path refers to. The value of the enumerators are distinct.</source>
          <target state="translated">&lt;code&gt;file_type&lt;/code&gt; 은 경로가 참조하는 파일 또는 디렉토리의 유형을 나타내는 상수를 정의합니다. 열거 자의 가치는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="315f3972bbf217124d728f85cd82f43338739a74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; if &lt;code&gt;filename&lt;/code&gt; was not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;. Otherwise a pointer to an internal static buffer is returned. If no suitable filename can be generated, &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 이 아닌 경우 &lt;code&gt;filename&lt;/code&gt; 입니다. 그렇지 않으면 내부 정적 버퍼에 대한 포인터가 리턴됩니다. 적합한 파일 이름을 생성 할 수 없으면 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2f0a388ea10d5b4afdd683236395d3f162dab456" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter_view&lt;/code&gt; models the concepts &lt;a href=&quot;bidirectionalrange&quot;&gt;&lt;code&gt;BidirectionalRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;forwardrange&quot;&gt;&lt;code&gt;ForwardRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;inputrange&quot;&gt;&lt;code&gt;InputRange&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;commonrange&quot;&gt;&lt;code&gt;CommonRange&lt;/code&gt;&lt;/a&gt; when the underlying view &lt;code&gt;V&lt;/code&gt; models respective concepts.</source>
          <target state="translated">&lt;code&gt;filter_view&lt;/code&gt; 기본 뷰 &lt;code&gt;V&lt;/code&gt; 가 각각의 개념을 모델링 할 때 filter_view 는 &lt;a href=&quot;bidirectionalrange&quot;&gt; &lt;code&gt;BidirectionalRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;forwardrange&quot;&gt; &lt;code&gt;ForwardRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;inputrange&quot;&gt; &lt;code&gt;InputRange&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;commonrange&quot;&gt; &lt;code&gt;CommonRange&lt;/code&gt; &lt;/a&gt; 개념을 모델링합니다.</target>
        </trans-unit>
        <trans-unit id="f37f86eed243731ca29e87bcda6f57b2623cc211" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;final&lt;/code&gt; is an identifier with a special meaning when used in a member function declaration or class head. In other contexts it is not reserved and may be used to name objects and functions.</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; 은 멤버 함수 선언 또는 클래스 헤드에 사용될 때 특별한 의미를 가진 식별자입니다. 다른 상황에서는 예약되지 않았으며 객체와 함수의 이름을 지정하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15f3cf2d47658fb9c7978dd6f9d53f3eadb64eb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first + n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;first + n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46a34ea218c9e779e94050c713fd1986d0e4aba1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first&lt;/code&gt; may be equal to &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 는 &lt;code&gt;d_first&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="60a99992dd9908440e59e9e2f9f3db563bb373c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;second&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; , &lt;code&gt;second&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="518c95550251b1dce01e670f8e121ae364e26a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first_argument_type&lt;/code&gt;(deprecated in C++17)</source>
          <target state="translated">&lt;code&gt;first_argument_type&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="a2cf7d2be84b74299c23ec77ba8cdc09ae28eca2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first_argument_type&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;first_argument_type&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음) (C ++ 20에서 제거됨)</target>
        </trans-unit>
        <trans-unit id="4efc34975233ec239fcf6e9b4ab9dc49f949f706" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first_argument_type&lt;/code&gt;(deprecated in c++17)</source>
          <target state="translated">&lt;code&gt;first_argument_type&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="bf9da79a9b566df73577ccd300df42a8addf6893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float&lt;/code&gt; - single precision floating point type. Usually IEEE-754 32 bit floating point type  &lt;code&gt;double&lt;/code&gt; - double precision floating point type. Usually IEEE-754 64 bit floating point type  &lt;code&gt;long double&lt;/code&gt; - extended precision floating point type. Does not necessarily map to types mandated by IEEE-754. Usually 80-bit x87 floating point type on x86 and x86-64 architectures.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; - 단 정밀도 부동 소수점 유형 일반적으로 IEEE-754 32 비트 부동 소수점 형 &lt;code&gt;double&lt;/code&gt; - 더블 정밀도 부동 소수점 형. 일반적으로 IEEE-754 64 비트 부동 소수점 유형 &lt;code&gt;long double&lt;/code&gt; -extended precision floating point type. IEEE-754가 규정 한 유형에 반드시 매핑 될 필요는 없습니다. x86 및 x86-64 아키텍처에서는 일반적으로 80 비트 x87 부동 소수점 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5bc2e8ab17f92697edff68a9e6809baeedd1e915" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float&lt;/code&gt; arguments are converted to &lt;code&gt;double&lt;/code&gt; as in &lt;a href=&quot;implicit_cast#Floating_point_promotion&quot;&gt;floating-point promotion&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; &lt;a href=&quot;implicit_cast#Floating_point_promotion&quot;&gt;소수점 승격&lt;/a&gt; 에서와 같이 부동 인수가 &lt;code&gt;double&lt;/code&gt; 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1b210fa17e7776b83abe5b8a384f92783f3ce9ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format&lt;/code&gt; outputs a format string, replacing any format specifiers or escape sequences in that string with match data from &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 은 형식 문자열을 출력하여 해당 형식의 형식 지정자 또는 이스케이프 시퀀스를 &lt;code&gt;*this&lt;/code&gt; 의 일치 데이터로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="a5048c3cbf0c190dd404e79a9563420bf857519e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forward_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;forward_iterator_tag&lt;/code&gt; 는 &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator에&lt;/a&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="bf9be84bda9d166275c01cfadaa207fc4b41fe58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;free&lt;/code&gt; -- free space on the filesystem, in bytes</source>
          <target state="translated">&lt;code&gt;free&lt;/code&gt; - 무료 공간을 파일 시스템에 바이트</target>
        </trans-unit>
        <trans-unit id="a7afdf1046ea93dac61f053f7d4f8f4ec0b1cf21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;freopen&lt;/code&gt; is the only way to change the narrow/wide orientation of a stream once it has been established by an I/O operation or by &lt;code&gt;std::fwide&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;freopen&lt;/code&gt; 은 스트림이 I / O 작업 또는 &lt;code&gt;std::fwide&lt;/code&gt; 의해 설정된 경우 좁은 / 넓은 방향을 변경하는 유일한 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="e33960b6ff810b12078cc22f4b31c010c8a5086f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt; 지정자</target>
        </trans-unit>
        <trans-unit id="c14fdb9545dd74cee178f1fad87bbe49e06d83bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;, &lt;code&gt;inline&lt;/code&gt;, &lt;code&gt;virtual&lt;/code&gt;, or nothing (no return type)</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt; , &lt;code&gt;inline&lt;/code&gt; , &lt;code&gt;virtual&lt;/code&gt; 또는 none (반환 유형 없음)</target>
        </trans-unit>
        <trans-unit id="cedf6954f71bbf3380f7b71ce0985a33d71e392f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;elaborated-class-specifier&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;elaborated-class-specifier&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0d23dd5011162edd99095564a0ee89e9c57636c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;function-declaration</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;function-declaration</target>
        </trans-unit>
        <trans-unit id="0db7504e7cc620e3b7b6ce702f40a98249e2e90c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;function-definition</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;function-definition</target>
        </trans-unit>
        <trans-unit id="520ab55d4d6de951979ebfc33a84a5d921959f87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;simple-type-specifier&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;simple-type-specifier&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b01fa6400ad6c2440063ed3d0bfd34b0dc273495" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;typename-specifier&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;typename-specifier&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b512d836d2b7abdabdbdefb44526763ca79643c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;front_inserter&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;front_insert_iterator&quot;&gt;std::front_insert_iterator&lt;/a&gt;&lt;/code&gt; for the container &lt;code&gt;c&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;front_inserter&lt;/code&gt; 는 컨테이너 &lt;code&gt;c&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;front_insert_iterator&quot;&gt;std::front_insert_iterator&lt;/a&gt;&lt;/code&gt; 를 인수 유형에서 추론 한 유형으로 구성하는 편리한 함수 템플리트입니다 .</target>
        </trans-unit>
        <trans-unit id="e04cb834c6dcbe1f873e017d0cfe4f6ed63d0863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g()&lt;/code&gt; has amortized constant complexity.</source>
          <target state="translated">&lt;code&gt;g()&lt;/code&gt; 는 일정한 복잡성을 상각했다</target>
        </trans-unit>
        <trans-unit id="b6112ef2d798b5d72f641fc2facd4c5152a78700" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g()&lt;/code&gt; is in the range &lt;code&gt;[G::min(), G::max()]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g()&lt;/code&gt; 는 &lt;code&gt;[G::min(), G::max()]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c8d7022caa34fdc4632fa0b0458578ff40e48b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt; is an lvalue in the &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; expression if it is an lvalue in the call expression, and is an rvalue otherwise. Thus &lt;code&gt;std::move(g)(call_args...)&lt;/code&gt; can move the bound arguments into the call, where &lt;code&gt;g(call_args...)&lt;/code&gt; would copy.</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; 표현식의 lvalue ( 호출 표현식의 lvalue 인 경우)이고 그렇지 않은 경우 rvalue입니다. 따라서 &lt;code&gt;std::move(g)(call_args...)&lt;/code&gt; 는 바인딩 된 인수를 호출로 이동할 수 있으며 여기서 &lt;code&gt;g(call_args...)&lt;/code&gt; 는 복사합니다.</target>
        </trans-unit>
        <trans-unit id="4edaf06963d1ba18614f939860e2628c44009177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; , &lt;code&gt;G&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="94f5507af9f623e2eec2ff1fa06a25a71e14ad55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt;, &lt;code&gt;g1&lt;/code&gt;, &lt;code&gt;g2&lt;/code&gt;, lvalues of a type satisfying &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; , &lt;code&gt;g1&lt;/code&gt; , &lt;code&gt;g2&lt;/code&gt; , &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator를&lt;/a&gt; 만족하는 유형의 l 값</target>
        </trans-unit>
        <trans-unit id="34b81a135481f308b7ef8efb863ef7ce2a2b732d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt;, a value of type &lt;code&gt;G&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 타입, &lt;code&gt;G&lt;/code&gt; 타입의 값</target>
        </trans-unit>
        <trans-unit id="411215b54d449f9618e7ef52494cb145feee0a20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="e2074e08c05eeca723858592a445e1f203b9bdd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_future()&lt;/code&gt; has already been called on a promise with the same shared state as &lt;code&gt;*this&lt;/code&gt;. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;future_already_retrieved&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;get_future()&lt;/code&gt; 는 이미 &lt;code&gt;*this&lt;/code&gt; 와 동일한 공유 상태의 약속에 대해 호출되었습니다 . 오류 범주는 &lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;future_already_retrieved&lt;/code&gt; &lt;/a&gt; 로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b073fc02d3fb4d433180e83cc3ba037eddccaacd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_future&lt;/code&gt; can be called only once for each &lt;code&gt;packaged_task&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get_future&lt;/code&gt; 는 각 &lt;code&gt;packaged_task&lt;/code&gt; 에 대해 한 번만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91b4b348569fe839c9d79a8973645af16f96667a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getline&lt;/code&gt; reads characters from an input stream and places them into a string:</source>
          <target state="translated">&lt;code&gt;getline&lt;/code&gt; 은 입력 스트림에서 문자를 읽고 문자열에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="ee199872d7cea13b60631d13afd2fba4ed220694" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;goodbit&lt;/code&gt; if &lt;code&gt;sb&lt;/code&gt; is not a null pointer, otherwise &lt;code&gt;badbit&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;goodbit&lt;/code&gt; &lt;code&gt;sb&lt;/code&gt; 가 널 포인터가 아닌 경우 goodbit , 그렇지 않은 경우 &lt;code&gt;badbit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8937a0902728f0df77cdfa6c9d933e0ec25a812" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gps_clock&lt;/code&gt; meets the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements. It does not meet the &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; requirements unless the implementation can guarantee that &lt;a href=&quot;gps_clock/now&quot;&gt;&lt;code&gt;now()&lt;/code&gt;&lt;/a&gt; does not throw an exception.</source>
          <target state="translated">&lt;code&gt;gps_clock&lt;/code&gt; 은 &lt;a href=&quot;../named_req/clock&quot;&gt;시계&lt;/a&gt; 요구 사항을 충족합니다 . 구현에서 &lt;a href=&quot;gps_clock/now&quot;&gt; &lt;code&gt;now()&lt;/code&gt; &lt;/a&gt; 가 예외를 발생시키지 않는다고 보장 할 수 없으면 &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; 요구 사항을 충족 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3864519d2183bfb5ce854fe8e1fcb2c7da1679d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gslice_array&lt;/code&gt; to initialize with</source>
          <target state="translated">&lt;code&gt;gslice_array&lt;/code&gt; 로 초기화</target>
        </trans-unit>
        <trans-unit id="7ec56ed1681f55a9a6dc88025fbe99be66e31868" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h&lt;/code&gt;, a value of type &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;const T&lt;/code&gt;, whose argument type is &lt;code&gt;Key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h&lt;/code&gt; , 입력 값 &lt;code&gt;T&lt;/code&gt; 또는 &lt;code&gt;const T&lt;/code&gt; 그 인수 형이며, &lt;code&gt;Key&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="111f616087040965483bbd613b70e0fda243f2e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash_value&lt;/code&gt; originates from the boost.filesystem library where it was used for interoperability with boost.hash (which &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/doc/html/hash/reference.html#boost.hash_val_idm45507095703056&quot;&gt;calls hash_value&lt;/a&gt; where available).</source>
          <target state="translated">&lt;code&gt;hash_value&lt;/code&gt; 는 boost.filesystem 라이브러리에서 유래하며 boost.hash (사용 가능한 경우 hash_value를 &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/doc/html/hash/reference.html#boost.hash_val_idm45507095703056&quot;&gt;호출 함)와의&lt;/a&gt; 상호 운용성에 사용되었습니다 .</target>
        </trans-unit>
        <trans-unit id="413e2bde88644c7def63b683ed383cb90442abbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash_value&lt;/code&gt; originates from the boost.filesystem library where it was used for interoperability with boost.hash (which &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/doc/html/hash/reference.html#boost.hash_val_idm45507095703056&quot;&gt;calls hash_value&lt;/a&gt; where available).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27b6941a88dbd576a2a2cc11f8d26dbd015e1a90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt; and &lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt; 와 &lt;code&gt;key_equal&lt;/code&gt; &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7aea8deea0bde7eac532953c4c0d7fd1068b7183" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt; and &lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;code&gt;value_type&lt;/code&gt;&lt;a href=&quot;emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; into &lt;code&gt;X&lt;/code&gt; from &lt;code&gt;*i&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt; 및 &lt;code&gt;key_equal&lt;/code&gt; &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; , &lt;code&gt;value_type&lt;/code&gt; &lt;a href=&quot;emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; 으로 &lt;code&gt;X&lt;/code&gt; 에서 &lt;code&gt;*i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba9369c4408e11b73dd0ee3d4ea2c0ba897e8e08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt; and &lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt; 와 &lt;code&gt;key_equal&lt;/code&gt; &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cd69adb31cff6805d6e79766c0f05d07992b1b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt;&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt; &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , &lt;code&gt;key_equal&lt;/code&gt; &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfcb282c32b3cd3e320440a37e082cc3cd592510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a1713b6e25c2f4865d58a7c17a5ad31b4f5bb1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hh&lt;/code&gt; - 2-digit hour from &lt;code&gt;timeptr-&amp;gt;tm_hour&lt;/code&gt; as if printed by &lt;code&gt;sprintf&lt;/code&gt; using &lt;code&gt;%.2d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hh&lt;/code&gt; - 2 자리 시간 내지 &lt;code&gt;timeptr-&amp;gt;tm_hour&lt;/code&gt; 인쇄 것처럼 &lt;code&gt;sprintf&lt;/code&gt; 를 사용 &lt;code&gt;%.2d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53896df8aca81db5e2f25a4961cb85d988b062dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hh&lt;/code&gt; - hours</source>
          <target state="translated">&lt;code&gt;hh&lt;/code&gt; 시간</target>
        </trans-unit>
        <trans-unit id="671fdc3e4d1f215ae1223caeb16c561628665336" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hours()&lt;/code&gt; returns the integral number of hours &lt;code&gt;since_midnight&lt;/code&gt; is after 00:00:00.</source>
          <target state="translated">&lt;code&gt;hours()&lt;/code&gt; 는 &lt;code&gt;since_midnight&lt;/code&gt; 이 00:00:00 이후 인 정수 시간을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c98fc30e60f72693a16df6b71119374088a3b262" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hypot(x, y)&lt;/code&gt;, &lt;code&gt;hypot(y, x)&lt;/code&gt;, and &lt;code&gt;hypot(x, -y)&lt;/code&gt; are equivalent</source>
          <target state="translated">&lt;code&gt;hypot(x, y)&lt;/code&gt; , &lt;code&gt;hypot(y, x)&lt;/code&gt; 및 &lt;code&gt;hypot(x, -y)&lt;/code&gt; 는 동일합니다</target>
        </trans-unit>
        <trans-unit id="78d36c3670a120414836e17fbb363e2dd80744e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i == 2&lt;/code&gt; is considered more likely than any other value of &lt;code&gt;i&lt;/code&gt;, but the &lt;code&gt;[[&lt;strong&gt;likely&lt;/strong&gt;]]&lt;/code&gt; has no effect on the &lt;code&gt;i == 1&lt;/code&gt; case even though it falls through the &lt;code&gt;case 2:&lt;/code&gt; label.</source>
          <target state="translated">&lt;code&gt;i == 2&lt;/code&gt; 가능성이 임의의 다른 값보다 간주 &lt;code&gt;i&lt;/code&gt; 있지만는 &lt;code&gt;[[&lt;strong&gt;likely&lt;/strong&gt;]]&lt;/code&gt; 상의 영향이 없다 &lt;code&gt;i == 1&lt;/code&gt; 가 통해 떨어지는 경우에도 &lt;code&gt;case 2:&lt;/code&gt; 라벨.</target>
        </trans-unit>
        <trans-unit id="b976ac77602b68cce0c449c176cdf386647ac678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterators&lt;/a&gt; such that &lt;code&gt;[i, j)&lt;/code&gt; is a valid range and that the iterators refer to elements implicitly convertible to &lt;code&gt;value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;j&lt;/code&gt; , &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterators&lt;/a&gt; 되도록 &lt;code&gt;[i, j)&lt;/code&gt; 유효한 범위는 상기 반복기가 암시 적으로 변환 요소를 참조하는 것이 &lt;code&gt;value_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f6d9764f8087379022430768a7a169413bbe17a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, objects of a container's &lt;code&gt;iterator&lt;/code&gt; type,</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 컨테이너의 &lt;code&gt;iterator&lt;/code&gt; 유형 의 객체 인 i 및 &lt;code&gt;j&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18e96bffb01e60c107a8239648857167f5c74951" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, values of type &lt;code&gt;It&lt;/code&gt; or &lt;code&gt;const It&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;j&lt;/code&gt; , &lt;code&gt;It&lt;/code&gt; 또는 &lt;code&gt;const It&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="cbf29f78689bf07a8e6132a8f717ff5fdfca186a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, objects of type &lt;code&gt;It&lt;/code&gt; or &lt;code&gt;const It&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;It&lt;/code&gt; 또는 &lt;code&gt;const It&lt;/code&gt; 유형의 객체</target>
        </trans-unit>
        <trans-unit id="18deb471df56ecbe71a4c38845fcc195736a1eb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03cf4985f5ecbdda5b97e43539f8485780115cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt;, dereferenceable iterator of type &lt;code&gt;It&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; , 유형의 dereferenceable 반복자 &lt;code&gt;It&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5cc15c2bb86d65f2fb65ca31cce0e3eed25a4e7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ib&lt;/code&gt;,&lt;code&gt;ie&lt;/code&gt; are &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterators&lt;/a&gt; with a &lt;code&gt;value_type&lt;/code&gt; of unsigned integer values of at least 32 bits.</source>
          <target state="translated">&lt;code&gt;ib&lt;/code&gt; , &lt;code&gt;ie&lt;/code&gt; 이다 &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterators&lt;/a&gt; A의 &lt;code&gt;value_type&lt;/code&gt; 적어도 32 비트의 부호없는 정수 값.</target>
        </trans-unit>
        <trans-unit id="7f6694aedba6d7abc5755c6543b84050f1f2d24a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;(static)</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt;(static)</target>
        </trans-unit>
        <trans-unit id="388eaffb6c01131dc19ce798454c600802009327" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;&lt;code&gt;constexpr&lt;/code&gt;(optional)&lt;code&gt;(&lt;/code&gt;condition&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt;&lt;code&gt;constexpr&lt;/code&gt;(optional)&lt;code&gt;(&lt;/code&gt;condition&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1c4f6e56383e839c77c6f0a8ed70ebc070ed02f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore&lt;/code&gt; behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, it extracts characters from the stream and discards them until any one of the following conditions occurs:</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; 는 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 구성하고 확인한 후 스트림에서 문자를 추출하여 다음 조건 중 하나가 발생할 때까지 해당 문자를 버립니다.</target>
        </trans-unit>
        <trans-unit id="777d6c1fb31ff0cfb09ff85f3f835fca8b105d38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;il.begin()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;il.begin()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="2223610ff829ee9123d368c88fde6fef3651fa54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;il.end()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;il.end()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="c244beea1817d5ff90b031967df2dc1d6efc2cda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;il&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;il&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="389b8bf8dc4e62dfa9d6e3312fc5c0f1694b19b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;il&lt;/code&gt;, an object of type &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;value_type&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;il&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;value_type&amp;gt;&lt;/code&gt; &amp;lt;value_type&amp;gt; 유형의 객체 인 il</target>
        </trans-unit>
        <trans-unit id="385ae00297d1ac58a35a032dea056ac29f1cd1c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;in&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="0ec3fec471c769b0028e361778d1ff16414c77da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;independent_bits_engine&lt;/code&gt; is a random number engine adaptor that produces random numbers with different number of bits than that of the wrapped engine.</source>
          <target state="translated">&lt;code&gt;independent_bits_engine&lt;/code&gt; 은 랩핑 된 엔진과 다른 비트 수로 난수를 생성하는 난수 엔진 어댑터입니다.</target>
        </trans-unit>
        <trans-unit id="141398579848ffc093d3d4fe6c88adcc411f38a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index&lt;/code&gt; is the user-provided value passed to &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; when registering the function.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 는 전달 된 사용자 제공 값입니다. &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; 함수를 등록 할 때 register_callback ()에입니다.</target>
        </trans-unit>
        <trans-unit id="8aaca78507992147a73d84775d11c42b2e40f9ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indirect_array&lt;/code&gt; to initialize with</source>
          <target state="translated">&lt;code&gt;indirect_array&lt;/code&gt; 로 초기화</target>
        </trans-unit>
        <trans-unit id="da7fbcd8eb53b0869c2ab43c83b782f0fc87e3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inline&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 지정자</target>
        </trans-unit>
        <trans-unit id="e8b06c80b6a672997e657c88831908a56cf3efd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inline&lt;/code&gt;(optional)&lt;code&gt;namespace&lt;/code&gt;attr(optional)&lt;code&gt;{ &lt;/code&gt;namespace-body&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; (선택 사항) &lt;code&gt;namespace&lt;/code&gt; attr (선택 사항) &lt;code&gt;{ &lt;/code&gt; namespace-body &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92fcb6106eac2fa99448f0e0e49f6d7d69e513b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inline&lt;/code&gt;(optional)&lt;code&gt;namespace&lt;/code&gt;attr(optional)identifier&lt;code&gt;{ &lt;/code&gt;namespace-body&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; (선택 사항) &lt;code&gt;namespace&lt;/code&gt; attr (선택 사항) 식별자 &lt;code&gt;{ &lt;/code&gt; namespace-body &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cff8c42e8bd2ae405de522be35af9c42f0ef715d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inline&lt;/code&gt;&lt;code&gt;namespace&lt;/code&gt;ns_name { declarations }</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; &lt;code&gt;namespace&lt;/code&gt; ns_name {선언}</target>
        </trans-unit>
        <trans-unit id="116e0fe82c54955cf01a9937cdc1321af775ea37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="3be7a3e01de26a5164dbfd037a805870a7e38ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;input_iterator_tag&lt;/code&gt; 는&lt;a href=&quot;../named_req/inputiterator&quot;&gt; LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c74daf231867ea3b60b7c99690e2d6b255ffe413" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;insert_or_assign&lt;/code&gt; returns more information than &lt;code&gt;operator[]&lt;/code&gt; and does not require default-constructibility of the mapped type.</source>
          <target state="translated">&lt;code&gt;insert_or_assign&lt;/code&gt; 은보다 많은 정보를 반환합니다 &lt;code&gt;operator[]&lt;/code&gt; 하며 맵핑 된 유형의 기본 구성이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="443968eb686146e29de33ab24e056f1dd0c65e0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;insert_return_type&lt;/code&gt;(since C++17)</source>
          <target state="translated">&lt;code&gt;insert_return_type&lt;/code&gt; (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="241e9902f59ff439ac42d797096feb5ee566294e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inserter&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;insert_iterator&quot;&gt;std::insert_iterator&lt;/a&gt;&lt;/code&gt; for the container &lt;code&gt;c&lt;/code&gt; and its iterator &lt;code&gt;i&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;inserter&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;insert_iterator&quot;&gt;std::insert_iterator&lt;/a&gt;&lt;/code&gt; 컨테이너 &lt;code&gt;c&lt;/code&gt; 및 해당 반복자 &lt;code&gt;i&lt;/code&gt; 에 대한 std :: insert_iterator 를 구성하는 편리한 함수 템플리트입니다. 인수 유형에서 추론 한 유형으로 .</target>
        </trans-unit>
        <trans-unit id="057de6e24b8ab26f37b3b86ecf25cc860351f643" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int (* const *)(int *)&lt;/code&gt; and &lt;code&gt;int (* volatile *)(int *)&lt;/code&gt; are similar;</source>
          <target state="translated">&lt;code&gt;int (* const *)(int *)&lt;/code&gt; 및 &lt;code&gt;int (* volatile *)(int *)&lt;/code&gt; 는 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="48ea95fbaba1b0dbd21298dc774cbe17d002f6ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int (*)(int * const)&lt;/code&gt; and &lt;code&gt;int (*)(int *)&lt;/code&gt; are similar (they are the same type);</source>
          <target state="translated">&lt;code&gt;int (*)(int * const)&lt;/code&gt; 와 &lt;code&gt;int (*)(int *)&lt;/code&gt; 는 비슷합니다 (동일한 타입입니다).</target>
        </trans-unit>
        <trans-unit id="5d15c0772df0971f9687b78820f226ccd72eecc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int (*)(int *)&lt;/code&gt; and &lt;code&gt;int (*)(const int *)&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;int (*)(int *)&lt;/code&gt; 및 &lt;code&gt;int (*)(const int *)&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="bd850e51b0a74012934879a370718571cb96e6a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int (S::*)() const&lt;/code&gt; and &lt;code&gt;int (S::*)()&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;int (S::*)() const&lt;/code&gt; 및 &lt;code&gt;int (S::*)()&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="4111163b3f8fdbde555a417a0587d2ece9578791" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt; - basic integer type. The keyword &lt;code&gt;int&lt;/code&gt; may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it's guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits (see below).</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; - 기본 정수 유형 키워드 &lt;code&gt;int&lt;/code&gt; 아래 나열된 수정자를 사용하는 경우 int를 생략 할 수 있습니다. 길이 수정자가 없으면 너비가 16 비트 이상이어야합니다. 그러나 32/64 비트 시스템에서는 너비가 32 비트 이상인 것이 거의 독점적으로 보장됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="51b6196d0c7c2679b2d61ea8fbb53b459dd8cb77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;&lt;code&gt;main&lt;/code&gt;&lt;code&gt;()&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;body&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt;&lt;code&gt;main&lt;/code&gt;&lt;code&gt;()&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;body&lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d6bb4984004e90cc09875909163eb7f968fca99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;&lt;code&gt;main&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;int&lt;/code&gt;argc&lt;code&gt;,&lt;/code&gt;&lt;code&gt;char&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;argv&lt;code&gt;[]&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;body&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt;&lt;code&gt;main&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;int&lt;/code&gt;argc&lt;code&gt;,&lt;/code&gt;&lt;code&gt;char&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;argv&lt;code&gt;[]&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;body&lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f83ac3b4e3ec48699e12339b5892899400cf07fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;intmax_t*&lt;/code&gt; or &lt;code&gt;uintmax_t*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;intmax_t*&lt;/code&gt; 또는 &lt;code&gt;uintmax_t*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2ee6087049c4a7176433e4088143e7614fdc603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_state&lt;/code&gt;(deprecated)</source>
          <target state="translated">&lt;code&gt;io_state&lt;/code&gt;(deprecated)</target>
        </trans-unit>
        <trans-unit id="4d7cce0f90e17b616e716122aeac71956f548947" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ios&lt;/code&gt; refers to the stream object for which the callback is invoked: &lt;code&gt;*this&lt;/code&gt; is passed as the argument when callbacks are invoked by &lt;code&gt;&lt;a href=&quot;../ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; member functions.</source>
          <target state="translated">&lt;code&gt;ios&lt;/code&gt; 는 콜백이 호출되는 스트림 객체를 나타냅니다. &lt;code&gt;*this&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; 의해 콜백이 호출 될 때 인수로 전달됩니다. 멤버 함수 .</target>
        </trans-unit>
        <trans-unit id="0e2d53cf94b70b8cafca6763310cf0eaf11119a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt; (reference to the stream after extraction of consecutive whitespace).</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; (연속 공백 추출 후 스트림 참조)입니다.</target>
        </trans-unit>
        <trans-unit id="4fedb03004a680c63b22ba8eb8a01ff66fb6f653" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt;, an input stream</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; , 입력 스트림</target>
        </trans-unit>
        <trans-unit id="21c5fea12a20a74cfe31d4cc9a804eba03a5a863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt;, lvalue of a specialization of &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; 의 전문의 좌변 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41e6679a08145bbcb9389bae0a5f56abbdd4be92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="1e3a41e68a345159b15102972bec9ae1a1f13e75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_always_equal&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;is_always_equal&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="a2705b3ce1ac51a19c9249b3cf3e6651264796d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_always_equal&lt;/code&gt;(C++17)&lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::is_always_equal::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for every allocator &lt;code&gt;A&lt;/code&gt; among &lt;code&gt;OuterAlloc&lt;/code&gt; and &lt;code&gt;InnerAlloc...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is_always_equal&lt;/code&gt; (C ++ 17) &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::is_always_equal::value&lt;/code&gt; 는 &lt;code&gt;OuterAlloc&lt;/code&gt; 및 &lt;code&gt;InnerAlloc...&lt;/code&gt; 중 모든 할당 자 &lt;code&gt;A&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="c2119c35a8f19a347e85544b010ec5ea974fdc00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_always_equal&lt;/code&gt;(since C++17)</source>
          <target state="translated">&lt;code&gt;is_always_equal&lt;/code&gt; (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="e506b53e2d1fbcb0355850b8a7a5448acee68a81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_modulo&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for signed integer types, unless the implementation defines signed integer overflow to wrap.</source>
          <target state="translated">&lt;code&gt;is_modulo&lt;/code&gt; 구현에서 랩핑 할 부호있는 정수 오버 플로우를 정의하지 않는 한 is_modulo 는 부호있는 정수 유형에 대해 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a8f90c8c322bbe5a2de9888a255af234a56268a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_modulo&lt;/code&gt; was required to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is_modulo&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 여야했습니다.</target>
        </trans-unit>
        <trans-unit id="ce8a3e2f016914c87bba189cef2b04d0f35ccc04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isdigit&lt;/code&gt; and &lt;code&gt;isxdigit&lt;/code&gt; are the only standard narrow character classification functions that are not affected by the currently installed C locale. although some implementations (e.g. Microsoft in 1252 codepage) may classify additional single-byte characters as digits.</source>
          <target state="translated">&lt;code&gt;isdigit&lt;/code&gt; 및 &lt;code&gt;isxdigit&lt;/code&gt; 는 현재 설치된 C 로케일의 영향을받지 않는 유일한 표준 좁은 문자 분류 기능입니다. 일부 구현 (예 : 1252 코드 페이지의 Microsoft)은 추가 1 바이트 문자를 숫자로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03ca901dd1c3cf178377939122dcac1b084722d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;istrstream&lt;/code&gt; has been deprecated since C++98, &lt;code&gt;&lt;a href=&quot;basic_istringstream&quot;&gt;std::istringstream&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_source&quot;&gt;boost::iostreams::array_source&lt;/a&gt; are the recommended replacements.</source>
          <target state="translated">&lt;code&gt;istrstream&lt;/code&gt; 은 C ++ 98, &lt;code&gt;&lt;a href=&quot;basic_istringstream&quot;&gt;std::istringstream&lt;/a&gt;&lt;/code&gt; 및 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_source&quot;&gt;boost :: iostreams :: array_source&lt;/a&gt; 부터 사용되지 않습니다. 가 권장되는 대체입니다.</target>
        </trans-unit>
        <trans-unit id="32c4b2fa37bc6582e4878f76f18602b5bc33f050" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;istrstream&lt;/code&gt; has been deprecated since C++98, &lt;code&gt;&lt;a href=&quot;basic_istringstream&quot;&gt;std::istringstream&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_source&quot;&gt;boost::iostreams::array_source&lt;/a&gt; are the recommended replacements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5edd0a0de37b0c2018cffd8918604843a5da04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&lt;/code&gt;(protected member object)</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; (보호 멤버 오브젝트)</target>
        </trans-unit>
        <trans-unit id="2f6228c2bf65ab429079525886977a8a82322066" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator_category&lt;/code&gt; - the category of the iterator. Must be one of &lt;a href=&quot;iterator_tags&quot;&gt;iterator category tags&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;iterator_category&lt;/code&gt; -이터레이터 의 카테고리 &lt;a href=&quot;iterator_tags&quot;&gt;반복자 범주 태그&lt;/a&gt; 중 하나 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="6c25d10cbb7bd92ac69fb00b2f385e3a959241b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator_concept&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;iterator_concept&lt;/code&gt; (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="f98ae9387f7361a914c5167c81d08f001775f77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;k&lt;/code&gt;, a value of type convertible to &lt;code&gt;Key&lt;/code&gt; or &lt;code&gt;const Key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; 는 &lt;code&gt;Key&lt;/code&gt; 또는 &lt;code&gt;const Key&lt;/code&gt; 로 변환 가능한 유형의 값</target>
        </trans-unit>
        <trans-unit id="256f7f56e4f1142fd96bfebe17b16058836d8603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key_compare&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt;; an ordering relation over &lt;code&gt;Key&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/multimap&quot;&gt;std::multimap&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;key_compare&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../container/multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt; 대한 key_compare ; &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../container/multimap&quot;&gt;std::multimap&lt;/a&gt;&lt;/code&gt; &lt;code&gt;Key&lt;/code&gt; 에 대한 순서 관계</target>
        </trans-unit>
        <trans-unit id="1328b6295690f4839bcaa8688257d852878b7ba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key_compare&lt;/code&gt; is &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;key_compare&lt;/code&gt; 는 &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible입니다&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c656810f208efe9d951232e34bfa6d6fa554f88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key_compare&lt;/code&gt; is &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;code&gt;value_type&lt;/code&gt; is &lt;a href=&quot;emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; into &lt;code&gt;X&lt;/code&gt; from &lt;code&gt;*i&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;key_compare&lt;/code&gt; 이다 &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; 및 &lt;code&gt;value_type&lt;/code&gt; 있다 &lt;a href=&quot;emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; 으로 &lt;code&gt;X&lt;/code&gt; 에서 &lt;code&gt;*i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e76cf2b2fbf296175b2f81c9c806a60b32c23bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ebf5299058b9fd564cac587f10aa739cdc1e5bae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kittens...&lt;/code&gt;, a set of arguments to &lt;code&gt;purr&lt;/code&gt; that meets the requirements for that operation,</source>
          <target state="translated">&lt;code&gt;kittens...&lt;/code&gt; , 해당 작업의 요구 사항을 충족시키는 &lt;code&gt;purr&lt;/code&gt; 에 대한 일련의 인수 ,</target>
        </trans-unit>
        <trans-unit id="54e81ff78f39fe2d54d46f191d9f15b4b92f3555" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;knuth_b&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;knuth_b&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="d84ead23b080bf2969278be7d79c70f8f003d56c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;l L&lt;/code&gt; defines &lt;code&gt;long double&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;l L&lt;/code&gt; 은 &lt;code&gt;long double&lt;/code&gt; 을 정의합니다</target>
        </trans-unit>
        <trans-unit id="a66fbc2abf78618601cc872cf9936b7953fe1e49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;l&lt;/code&gt; or &lt;code&gt;L&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;l&lt;/code&gt; 또는 &lt;code&gt;L&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55c1d39a34f823ca69b882713b76e9b26fde79c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;last_spec&lt;/code&gt; is an empty tag type that is used in conjunction with other calendar types to indicate the last thing in a sequence. Depending on context, it may indicate the last day of a month (as in &lt;code&gt;2018y/February/last&lt;/code&gt;, for last day of February 2018, i.e., 2018-02-28) or the last day of the week in a month (as in &lt;code&gt;2018/February/Sunday[last]&lt;/code&gt;, for last Sunday of February 2018, i.e., 2018-02-25).</source>
          <target state="translated">&lt;code&gt;last_spec&lt;/code&gt; 은 다른 달력 유형과 함께 사용하여 시퀀스의 마지막 항목을 나타내는 빈 태그 유형입니다. 상황에 따라 한 달의 마지막 날 ( &lt;code&gt;2018y/February/last&lt;/code&gt; , 2018 년 2 월 마지막 날, 즉 2018-02-28) 또는 한 달의 마지막 날 ( 2018/2 &lt;code&gt;2018/February/Sunday[last]&lt;/code&gt; , 2018 년 2 월 마지막 일요일 (예 : 2018-02-25)</target>
        </trans-unit>
        <trans-unit id="54cc2b77e86abe38449e33cfa9dd560a4abe8ab8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;leap&lt;/code&gt; has a defaulted copy constructor and a defaulted copy assignment operator.</source>
          <target state="translated">&lt;code&gt;leap&lt;/code&gt; 에는 기본 복사 생성자와 기본 복사 할당 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8764c6aafcb55d7e707f060f26a7ecfcaec7ee50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left|right|internal&lt;/code&gt;. Useful for masking operations</source>
          <target state="translated">&lt;code&gt;left|right|internal&lt;/code&gt; . 마스킹 작업에 유용</target>
        </trans-unit>
        <trans-unit id="3774fb54b1cf9a8fe6a2c568734146ef5a21aaa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs.base() - rhs.base()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs.base() - rhs.base()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="35322d42c0afddc226669dc0d9f53d98ccab2c85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs.empty()&lt;/code&gt; and &lt;code&gt;rhs.empty()&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;lhs.empty()&lt;/code&gt; 및 &lt;code&gt;rhs.empty()&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="9a06433bb3b1a7b9c84fb97951b411c54c2f9743" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs.outer_allocator() == rhs.outer_allocator()&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;lhs.outer_allocator() == rhs.outer_allocator()&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="710766adbf1e5001e6e2a0bf5345bdec2798b4cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equivalent only if they are both empty or share ownership.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 및 &lt;code&gt;rhs&lt;/code&gt; 는 비어 있거나 소유권을 공유하는 경우에만 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1ef7a535d3323c6880222db1587fa5064e3fc340" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt; is considered</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 로 간주됩니다</target>
        </trans-unit>
        <trans-unit id="d74003b8bcf891027bfc27d7536b0e86891ce0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt; is equal to &lt;code&gt;rcopy&lt;/code&gt;, unless &lt;code&gt;rhs&lt;/code&gt; is a non-const xvalue that refers to &lt;code&gt;lcopy&lt;/code&gt; (i.e., the assignment is a self-move-assignment),</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; &lt;code&gt;rhs&lt;/code&gt; 가 lcopy를 참조하는 비 -const xvalue가 아닌 한, lhs 는 &lt;code&gt;rcopy&lt;/code&gt; 와 &lt;code&gt;lcopy&lt;/code&gt; (즉, 할당은 자체 이동 할당 임).</target>
        </trans-unit>
        <trans-unit id="763ce1b85e689b44ff97faf88affdaed11e7d453" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt;, an lvalue that refers to an object &lt;code&gt;lcopy&lt;/code&gt; such that &lt;code&gt;decltype((lhs))&lt;/code&gt; is &lt;code&gt;LHS&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; , &lt;code&gt;decltype((lhs))&lt;/code&gt; 가 &lt;code&gt;LHS&lt;/code&gt; 가 되도록 객체 &lt;code&gt;lcopy&lt;/code&gt; 를 나타내는 lvalue ,</target>
        </trans-unit>
        <trans-unit id="2b8c327f19757863cbf19a339d53e0d5afe33fe5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;linear_congruential_engine&lt;/code&gt; is a random number engine based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;Linear congruential generator (LCG)&lt;/a&gt;. A LCG has a state that consists of a single integer.</source>
          <target state="translated">&lt;code&gt;linear_congruential_engine&lt;/code&gt; 은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;LCG (Linear Congruential Generator)&lt;/a&gt; 기반의 난수 엔진 입니다. LCG에는 단일 정수로 구성된 상태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b51e9a8d7e26b4195f2b7e94b0a57bcd4109928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;link&lt;/code&gt; is not copyable but does have a defaulted move constructor and a defaulted move assignment operator. However, as users have only &lt;code&gt;const&lt;/code&gt; access to &lt;code&gt;link&lt;/code&gt; objects, these functions cannot be called in user code without invoking &lt;a href=&quot;../language/ub&quot;&gt;undefined behavior&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; 는 복사 할 수 없지만 기본 이동 생성자와 기본 이동 할당 연산자가 있습니다. 그러나 사용자는 &lt;code&gt;link&lt;/code&gt; 객체에 대한 &lt;code&gt;const&lt;/code&gt; 액세스 권한 만 있으므로 &lt;a href=&quot;../language/ub&quot;&gt;정의되지 않은 동작&lt;/a&gt; 을 호출하지 않으면 사용자 코드에서 이러한 함수를 호출 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a42862b4b4516aed99ecd46ac714cbc76bcd3114" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ll&lt;/code&gt; or &lt;code&gt;LL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ll&lt;/code&gt; 또는 &lt;code&gt;LL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fbd2294c8228b0d41a9477a6b9cd59874805d44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loc&lt;/code&gt;, an object of type &lt;code&gt;X::locale_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;loc&lt;/code&gt; , &lt;code&gt;X::locale_type&lt;/code&gt; 유형의 객체</target>
        </trans-unit>
        <trans-unit id="c8c3052ccaee4a1e8a114c753bca6e29759f1669" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock()&lt;/code&gt; is usually not called directly: &lt;code&gt;&lt;a href=&quot;../unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; are used to manage exclusive locking.</source>
          <target state="translated">&lt;code&gt;lock()&lt;/code&gt; 은 일반적으로 직접 호출되지 않습니다. &lt;code&gt;&lt;a href=&quot;../unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; 는 독점 잠금을 관리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a075e9526e3f87afdd25b322a41e6af35f3545ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock_shared()&lt;/code&gt; is usually not called directly: &lt;code&gt;&lt;a href=&quot;../shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; is used to manage shared locking.</source>
          <target state="translated">&lt;code&gt;lock_shared()&lt;/code&gt; 는 일반적으로 직접 호출되지 않습니다. &lt;code&gt;&lt;a href=&quot;../shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; 은 공유 잠금을 관리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6eed4bda9461a124aae3680bdafdaf2b3b9db713" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long long int&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;long long int&lt;/code&gt; (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="631749813cf9be03983337499d431fda1eace348" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long long int&lt;/code&gt;(since C++11).</source>
          <target state="translated">&lt;code&gt;long long int&lt;/code&gt; (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="b0dafe31e5994a5ce21867a198e9a54684dbded6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long long&lt;/code&gt; - target type will have width of at least 64 bits.</source>
          <target state="translated">&lt;code&gt;long long&lt;/code&gt; - 대상 유형의 너비는 64 비트 이상입니다.</target>
        </trans-unit>
        <trans-unit id="f620edf133a71d4e25ca283e969ee4c9f3b69ca6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long&lt;/code&gt; - target type will have width of at least 32 bits.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; - 대상 유형의 너비는 32 비트 이상입니다.</target>
        </trans-unit>
        <trans-unit id="e6106b1d6be411097b6601fe37141ec083d96cae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long&lt;/code&gt; type modifier</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 유형 수정 자</target>
        </trans-unit>
        <trans-unit id="6cc7d1a6f4dad505abfccdbfcdd92fac7d853104" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;longjmp&lt;/code&gt; is the mechanism used in C to handle unexpected error conditions where the function cannot return meaningfully. C++ generally uses &lt;a href=&quot;../../language/exceptions&quot;&gt;exception handling&lt;/a&gt; for this purpose.</source>
          <target state="translated">&lt;code&gt;longjmp&lt;/code&gt; 는 함수가 의미있게 리턴 할 수없는 예기치 않은 오류 조건을 처리하기 위해 C에서 사용되는 메커니즘입니다. C ++은 일반적 으로이 목적 으로 &lt;a href=&quot;../../language/exceptions&quot;&gt;예외 처리&lt;/a&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d25f9f69a8c41a16a4eb7bc6204b6470fddab862" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_move_iterator&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt; for the given iterator &lt;code&gt;i&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;make_move_iterator&lt;/code&gt; 는 주어진 반복자에 대해 &lt;code&gt;&lt;a href=&quot;move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt; 를 구성하는 편리한 함수 템플리트입니다. &lt;code&gt;i&lt;/code&gt; 인수의 유형에서 추론 된 유형으로 .</target>
        </trans-unit>
        <trans-unit id="67fc72aae3aa997980eef58fc8416c608ee1be9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_reverse_iterator&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; for the given iterator &lt;code&gt;i&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;make_reverse_iterator&lt;/code&gt; 는 주어진 반복자 &lt;code&gt;i&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; 를 인수의 유형에서 추론 된 유형으로 구성하는 편리한 함수 템플리트입니다 .</target>
        </trans-unit>
        <trans-unit id="8643df2129d822a941644d9e55fb33513904875c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mask_array&lt;/code&gt; to initialize with</source>
          <target state="translated">&lt;code&gt;mask_array&lt;/code&gt; 초기화 할 mask_array</target>
        </trans-unit>
        <trans-unit id="6051a265e3eb5ef540cc9e4026f402307e618b2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;match_flag_type&lt;/code&gt; is a &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; that specifies additional regular expression matching options.</source>
          <target state="translated">&lt;code&gt;match_flag_type&lt;/code&gt; 은 추가 정규식 일치 옵션을 지정 하는 &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f7969f5305d2a0f5cda3cd1317fd7c00542f472b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mersenne_twister_engine&lt;/code&gt; is a random number engine based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_twister&quot;&gt;Mersenne Twister&lt;/a&gt; algorithm. It produces high quality unsigned integer random numbers of type &lt;code&gt;UIntType&lt;/code&gt; on the interval [0, 2w</source>
          <target state="translated">&lt;code&gt;mersenne_twister_engine&lt;/code&gt; 은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_twister&quot;&gt;Mersenne Twister&lt;/a&gt; 알고리즘을 기반으로하는 난수 엔진입니다 . 간격 [0, 2w에서 &lt;code&gt;UIntType&lt;/code&gt; 유형의 고품질 부호없는 정수 난수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="03e36b86fc41a84634e577bf6c49cf39d160cc8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;(st.width()), N) - 1&lt;/code&gt; characters are extracted (if &lt;code&gt;st.width()&lt;/code&gt; is greater than zero)</source>
          <target state="translated">&lt;code&gt;min(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;(st.width()), N) - 1&lt;/code&gt; 문자가 추출됩니다 ( &lt;code&gt;st.width()&lt;/code&gt; 가 0보다 큰 경우)</target>
        </trans-unit>
        <trans-unit id="f69ad950aa6cd383a3875964e57fddaa56fac574" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min&lt;/code&gt; is only meaningful for bounded types and for unbounded unsigned types, that is, types that represent an infinite set of negative values have no meaningful minimum.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 은 바운딩 된 유형과 부호없는 unsigned 유형에 대해서만 의미가 있습니다. 즉, 무한 음수 값 집합을 나타내는 유형에는 의미있는 최소값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="11720682258a6e6ea94f82b3b68a01ceca39d154" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minstd_rand0&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;minstd_rand0&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="6cd727f122c0fc301841d5b5bc920fce6c61a502" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minstd_rand&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;minstd_rand&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="44da149f671c50d09ff780ccb663a27eefb6a8a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minutes()&lt;/code&gt; returns the integral number of minutes &lt;code&gt;since_midnight&lt;/code&gt; is after &lt;code&gt;(00:00:00 + hours())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;minutes()&lt;/code&gt; 는 &lt;code&gt;since_midnight&lt;/code&gt; 이 &lt;code&gt;(00:00:00 + hours())&lt;/code&gt; 이후 의 정수 (분)를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2e2341fbef188cb5eeb260f3c23e801a73700139" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mm&lt;/code&gt; - 2-digit minute from &lt;code&gt;timeptr-&amp;gt;tm_min&lt;/code&gt; as if printed by &lt;code&gt;sprintf&lt;/code&gt; using &lt;code&gt;%.2d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mm&lt;/code&gt; - &lt;code&gt;timeptr-&amp;gt;tm_min&lt;/code&gt; 에서 2 자리 분 ( &lt;code&gt;%.2d&lt;/code&gt; 사용하여 &lt;code&gt;sprintf&lt;/code&gt; 로 인쇄 한 것처럼)</target>
        </trans-unit>
        <trans-unit id="ad3d933f46f39e052abdb8b71c4dafb32e73d1c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mm&lt;/code&gt; - minutes</source>
          <target state="translated">&lt;code&gt;mm&lt;/code&gt; - 분</target>
        </trans-unit>
        <trans-unit id="61b2a411b1194735f191e01a2375261d7904aadd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt;; top-level-declaration-seq(optional)</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; ; 최상위 선언-식 (선택 사항)</target>
        </trans-unit>
        <trans-unit id="8ac208616f1198d65bee4d69b943f7ea1ecde749" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;monotonic_buffer_resource&lt;/code&gt; can be constructed with an initial buffer. If there is no initial buffer, or if the buffer is exhausted, additional buffers are obtained from an</source>
          <target state="translated">&lt;code&gt;monotonic_buffer_resource&lt;/code&gt; 는 초기 버퍼로 구성 될 수 있습니다. 초기 버퍼가 없거나 버퍼가 소진 된 경우 추가 버퍼는</target>
        </trans-unit>
        <trans-unit id="5aceb6d7c7df1b4d24df89ff70c7e10f8baf1802" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;monotonic_buffer_resource&lt;/code&gt; is not thread-safe.</source>
          <target state="translated">&lt;code&gt;monotonic_buffer_resource&lt;/code&gt; 는 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b52eb1c48377fd49827020c8059087d06d4946e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month().ok() &amp;amp;&amp;amp; weekday_indexed().ok()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;month().ok() &amp;amp;&amp;amp; weekday_indexed().ok()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47cee466ffd7cdb9de816c8c1fcd46074df71a9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month().ok() &amp;amp;&amp;amp; weekday_last().ok()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;month().ok() &amp;amp;&amp;amp; weekday_last().ok()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="daa97aa6666c88ba085bd172ef9069a910588a91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month().ok()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;month().ok()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="c3c964de040a242a94594eda876807048353a201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month&lt;/code&gt; 는 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="edc5d1e07f39b981842e107954ae7debbb92ead2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month_day&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month_day&lt;/code&gt; 는 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="721ab309caf01adaf72782284d2873bf3214d819" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month_day_last&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month_day_last&lt;/code&gt; 는 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;간단하게 복사 가능한 &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType입니다.&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="03f5d76987240a4e54cba6e45b0324fc39727c0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month_weekday&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month_weekday&lt;/code&gt; 는 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6a16aa97c2bcf582298bbeecd9cf526963d42306" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month_weekday_last&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month_weekday_last&lt;/code&gt; 는 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b04124853544caec5fe640efce4338b719310311" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;move_if_noexcept&lt;/code&gt; obtains an rvalue reference to its argument if its move constructor does not throw exceptions or if there is no copy constructor (move-only type), otherwise obtains an lvalue reference to its argument. It is typically used to combine move semantics with strong exception guarantee.</source>
          <target state="translated">&lt;code&gt;move_if_noexcept&lt;/code&gt; 는 이동 생성자가 예외를 발생시키지 않거나 복사 생성자가없는 경우 (이동 전용 유형) 인수에 대한 rvalue 참조를 얻습니다. 그렇지 않으면 해당 인수에 대한 lvalue 참조를 얻습니다. 일반적으로 이동 의미론과 강력한 예외 보장을 결합하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dcab2982ae60519dfa11b3b8789ca936b139623b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt19937&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;mt19937&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="7711b5ec07f8028b86083b76a35f48f55d22ef28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt19937_64&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;mt19937_64&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="6d3eef6ccbd823c22c01d70b739ba0f2bfee3dfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiline&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;multiline&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="9596b73eb0b017538a63ae7bb20302807cf463a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt; - does not affect storage duration or linkage. See &lt;a href=&quot;cv&quot;&gt;const/volatile&lt;/a&gt; for the explanation.</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; -저장 기간 또는 연결에 영향을 미치지 않습니다. 설명은 &lt;a href=&quot;cv&quot;&gt;const / volatile&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ef657e8a1674cf45aa9164d0e015bb5350196c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt; - permits modification of the class member declared mutable even if the containing object is declared const.</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; 포함 객체가 const로 선언 된 경우에도 mutable로 선언 된 클래스 멤버를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99b6b7266dbef06a872fb4dd7eb9bedc727ccea2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; 지정자</target>
        </trans-unit>
        <trans-unit id="d3224dab8827312710beba51a3e704b17dc0c841" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt; type specifier</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; 타입 지정자</target>
        </trans-unit>
        <trans-unit id="4df916efe552ebd362d8e85d53164a72d1c6e74c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt;: allows body to modify the parameters captured by copy, and to call their non-const member functions</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; : 본문에서 복사하여 캡처 한 매개 변수를 수정하고 비 const 멤버 함수를 호출 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0be5eed25c0bd5a04f1885d02d6e5cbef563aed2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutex&lt;/code&gt; offers exclusive, non-recursive ownership semantics:</source>
          <target state="translated">&lt;code&gt;mutex&lt;/code&gt; 는 독점적 인 비 재귀 소유권 의미론을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="83c65f0571699204cd08bdc45cd8a861d113d0c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutex_type&lt;/code&gt;(if &lt;code&gt;sizeof...(MutexTypes)==1&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;mutex_type&lt;/code&gt; (크기가 &lt;code&gt;sizeof...(MutexTypes)==1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e2678c37d2ffbbbaca79109eaaac8e0743f9a1ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n + a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n + a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1df4f23ae577313cfa56d7bed35293c0435e2f57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n, i, j&lt;/code&gt;, values of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n, i, j&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="3f97ee369c6a99450c231306794325ac21356db4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; can be both positive or negative</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 은 양수이거나 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3865fbe8a147b296b97a18587ebb8451959508c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, a value of type &lt;code&gt;X::size_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; &lt;code&gt;X::size_type&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="b3733ce69ea4fb00b43cf5dd8c6fe20f531dd2bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, a value of type &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::size_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::size_type&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="440dd0a1c40939c6592cd89ff3cbc07504417e0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, an integer of type &lt;code&gt;difference_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; , &lt;code&gt;difference_type&lt;/code&gt; 유형의 정수</target>
        </trans-unit>
        <trans-unit id="353801c2154651bb24a1e0cbc3079409fcae6183" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, an integral value</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; , 정수 값</target>
        </trans-unit>
        <trans-unit id="931550a878f4982e02bd2763b6cf378a1f759168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace A::B::inline C { ... }&lt;/code&gt; is equivalent to &lt;code&gt;namespace A::B { inline namespace C { ... } }&lt;/code&gt;. &lt;code&gt;inline&lt;/code&gt; may appear in front of every namespace name except the first: &lt;code&gt;namespace A::inline B::C {}&lt;/code&gt; is equivalent to &lt;code&gt;namespace A { inline namespace B { namespace C {} } }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;namespace A::B::inline C { ... }&lt;/code&gt; 는 &lt;code&gt;namespace A::B { inline namespace C { ... } }&lt;/code&gt; . &lt;code&gt;inline&lt;/code&gt; 제 제외한 모든 네임 스페이스 이름 앞에 나타날 수 &lt;code&gt;namespace A::inline B::C {}&lt;/code&gt; 에 해당 &lt;code&gt;namespace A { inline namespace B { namespace C {} } }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5f1a83961f9db377d752c83fd741a490a7b4c57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt; { declarations }</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; {선언}</target>
        </trans-unit>
        <trans-unit id="9622ab87c139ab1b29defe9f2aa9a39bec35b7d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;alias_name = &lt;code&gt;::&lt;/code&gt;ns_name&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; alias_name = &lt;code&gt;::&lt;/code&gt; ns_name &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6d8088f30582e3305ca05a1fa13fddc31666468" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;alias_name = nested_name&lt;code&gt;::&lt;/code&gt;ns_name&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; alias_name = nested_name &lt;code&gt;::&lt;/code&gt; ns_name &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bec759c3dfa6a683cbe5714f88a0000d1d61d31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;alias_name = ns_name&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; alias_name = ns_name &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc800922ab5b9a8debe963270907cd8c2afa96a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;name&lt;code&gt;=&lt;/code&gt;qualified-namespace&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt;name&lt;code&gt;=&lt;/code&gt;qualified-namespace&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d1118e7b8e29f999ae87d047d0e161a70da230a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;ns_name { declarations }</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; ns_name {선언}</target>
        </trans-unit>
        <trans-unit id="f6ba9baaa556978003350c542bf864cccb3b0cff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;ns_name&lt;code&gt;::&lt;/code&gt;&lt;code&gt;inline&lt;/code&gt;(since C++20)(optional)name { declarations }</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; ns_name &lt;code&gt;::&lt;/code&gt; &lt;code&gt;inline&lt;/code&gt; (C ++ 20부터) (선택 사항) name {선언}</target>
        </trans-unit>
        <trans-unit id="5dcc4cb18db587b8b2ec5a9937617fe8da19fded" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;native_handle_type&lt;/code&gt;(optional)</source>
          <target state="translated">&lt;code&gt;native_handle_type&lt;/code&gt;(optional)</target>
        </trans-unit>
        <trans-unit id="d168126fb676dc5ba1f8da9c420c3b60cc37638c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new &lt;/code&gt;T</source>
          <target state="translated">&lt;code&gt;new &lt;/code&gt; T</target>
        </trans-unit>
        <trans-unit id="294bdbf6d4e099fa80b89bb6b29ca56b89bcdbe4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new &lt;/code&gt;T&lt;code&gt;(&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;(until C++03).</source>
          <target state="translated">&lt;code&gt;new &lt;/code&gt; T &lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; (C ++ 03까지).</target>
        </trans-unit>
        <trans-unit id="c507be339e01230b2a2421be72fed9ed3d2ba709" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 표현</target>
        </trans-unit>
        <trans-unit id="6a49623f29f5f3dc93f2bc1d8e6afd869037d67a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;&lt;code&gt;new[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt;&lt;code&gt;new[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1f9ab9b83b0ff1cfbec3fa0f2657bc3efa77e4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d30056c5f449d74627c825a4d9dbb67095bac924" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;(&lt;/code&gt;args, ...&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; T &lt;code&gt;(&lt;/code&gt; args, ... &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b9ae2f1a0eabfc0dc5e948662745d5550e3a806" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; T &lt;code&gt;{ &lt;/code&gt; arg1, arg2, ... &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="010e3be45f98751f90c9186436cda7920ef235b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a84b23a2f738a119793f5305f7d1d6ee1cb7ed8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_p&lt;/code&gt; ends with dot or with dot-dot</source>
          <target state="translated">&lt;code&gt;new_p&lt;/code&gt; 는 점 또는 점으로 끝납니다</target>
        </trans-unit>
        <trans-unit id="dc967e31638fb13dc7b69a3a369bace3b889e413" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_p&lt;/code&gt; names a non-existing directory ending with a directory separator</source>
          <target state="translated">&lt;code&gt;new_p&lt;/code&gt; 는 디렉토리 구분자로 끝나는 존재하지 않는 디렉토리를 명명합니다.</target>
        </trans-unit>
        <trans-unit id="fbd974c99b0ab7a6248a32ef40aa52756bdbd908" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;node_type&lt;/code&gt;(since C++17)</source>
          <target state="translated">&lt;code&gt;node_type&lt;/code&gt; (C ++ 17부터)</target>
        </trans-unit>
        <trans-unit id="acc081ae343fc7533936440595e83dc55dd44c03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept(&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;noexcept(&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c24e7cdbea9d139de0946f0b05b56febebba7c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept&lt;/code&gt; is an improved version of &lt;a href=&quot;except_spec&quot;&gt;&lt;code&gt;throw()&lt;/code&gt;&lt;/a&gt;, which is deprecated in C++11. Unlike pre-C++17 &lt;a href=&quot;except_spec&quot;&gt;&lt;code&gt;throw()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;noexcept&lt;/code&gt; will not call &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; and may or may not unwind the stack, which potentially allows the compiler to implement &lt;code&gt;noexcept&lt;/code&gt; without the runtime overhead of &lt;a href=&quot;except_spec&quot;&gt;&lt;code&gt;throw()&lt;/code&gt;&lt;/a&gt;. As of C++17, &lt;code&gt;throw()&lt;/code&gt; is redefined to be an exact equivalent of &lt;code&gt;noexcept(true)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; 는 향상된 버전의 &lt;a href=&quot;except_spec&quot;&gt; &lt;code&gt;throw()&lt;/code&gt; &lt;/a&gt; 로 C ++ 11에서는 더 이상 사용되지 않습니다. 사전 C ++ (17)과는 달리 &lt;a href=&quot;except_spec&quot;&gt; &lt;code&gt;throw()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;noexcept&lt;/code&gt; 는 호출하지 않습니다 &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 월 또는 5 월하지 잠재적 컴파일러 구현 할 수 있습니다 스택, 언 와인드 &lt;code&gt;noexcept&lt;/code&gt; 을 의 런타임 오버 헤드없이 &lt;a href=&quot;except_spec&quot;&gt; &lt;code&gt;throw()&lt;/code&gt; &lt;/a&gt; . C ++ 17부터 &lt;code&gt;throw()&lt;/code&gt; 는 &lt;code&gt;noexcept(true)&lt;/code&gt; 와 정확히 일치하도록 재정의되었습니다 .</target>
        </trans-unit>
        <trans-unit id="015e6404e45474d0f4b21fb1a47ce8c5d654560a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="a1b14049eecc97923d6024027c8c2f7ace1fca8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept&lt;/code&gt; specifications</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; 사양</target>
        </trans-unit>
        <trans-unit id="65ff1fa2e72e419dda4d71ee9e6093765d18540f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; 지정자</target>
        </trans-unit>
        <trans-unit id="e1bbd04e13e487469c0bd8e54d5383313ce5238e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not1&lt;/code&gt; is a helper function to create a function object that returns the complement of the unary predicate function passed. The function object created is of type &lt;code&gt;&lt;a href=&quot;unary_negate&quot;&gt;std::unary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;not1&lt;/code&gt; 은 전달 된 단항 술어 함수의 보수를 리턴하는 함수 오브젝트를 작성하는 헬퍼 함수입니다. 작성된 함수 오브젝트는 &lt;code&gt;&lt;a href=&quot;unary_negate&quot;&gt;std::unary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="1cd72ce45ba072d1b92b5fd8c78ecd167e104d93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not2&lt;/code&gt; is a helper function to create a function object that returns the complement of the binary predicate function passed. The function object created is of type &lt;code&gt;&lt;a href=&quot;binary_negate&quot;&gt;std::binary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;not2&lt;/code&gt; 는 전달 된 이진 술어 함수의 보수를 리턴하는 함수 오브젝트를 작성하는 헬퍼 함수입니다. 작성된 함수 오브젝트는 &lt;code&gt;&lt;a href=&quot;binary_negate&quot;&gt;std::binary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="02eeb439232745421d8c2bcc11cb50225d202710" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not_fn&lt;/code&gt; is intended to replace the C++03-era negators &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;not_fn&lt;/code&gt; 은 C ++ 03 시대 &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt; 를 대체하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0f4dcb3230322b63393ab0b70a62509500a82e0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; provides a mechanism to notify other threads that a given thread has completely finished, including destroying all &lt;a href=&quot;../keyword/thread_local&quot;&gt;thread_local&lt;/a&gt; objects. It operates as follows:</source>
          <target state="translated">&lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; 는 모든 &lt;a href=&quot;../keyword/thread_local&quot;&gt;thread_local&lt;/a&gt; 객체의 파괴를 포함하여 지정된 스레드가 완전히 완료되었음을 다른 스레드에 알리는 메커니즘을 제공 합니다. 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b5fef976c2bc54a725b0f87c8ce3dd90052df0e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;np != p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np != p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75c1ce30646d639b7e7202895f501a3da1d7b19a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;np == p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np == p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cef01ebf9a66a13171933809f6193371fdbd2d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nth&lt;/code&gt; may be the end iterator, in this case the function has no effect.</source>
          <target state="translated">&lt;code&gt;nth&lt;/code&gt; 는 end iterator 일 수 있습니다.이 경우에는 기능이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6bd9eb9e2df463fbc055a140631d32dfae3ee6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nth_element&lt;/code&gt; is a partial sorting algorithm that rearranges elements in &lt;code&gt;[first, last)&lt;/code&gt; such that:</source>
          <target state="translated">&lt;code&gt;nth_element&lt;/code&gt; 는 다음 과 같이 &lt;code&gt;[first, last)&lt;/code&gt; 요소를 재정렬하는 부분 정렬 알고리즘 입니다.</target>
        </trans-unit>
        <trans-unit id="7f47a446144093bb6aef8760b8abc76c6071fd0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;o + p&lt;/code&gt; has a type convertible to &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; and the result of the conversion is equal to &lt;code&gt;p + o&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;o + p&lt;/code&gt; 의 유형은 &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; 변환 가능하며 변환 결과는 &lt;code&gt;p + o&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2eb351964003cae258c50dfe3a35ac417ec19e69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;o&lt;/code&gt;, a value of some type that is writable to the output iterator (there may be multiple types that are writable, e.g. if &lt;code&gt;operator=&lt;/code&gt; may be a template. There is no notion of &lt;code&gt;value_type&lt;/code&gt; as for the input iterators)</source>
          <target state="translated">&lt;code&gt;o&lt;/code&gt; 출력 반복자에 쓸 수있는 일부 유형의 값 ( &lt;code&gt;operator=&lt;/code&gt; 템플릿 일 수있는 경우에 쓸 수있는 여러 유형이있을 수 있습니다 . 입력 반복자에 대한 &lt;code&gt;value_type&lt;/code&gt; 개념은 없습니다 )</target>
        </trans-unit>
        <trans-unit id="7906f5cbf1f50d7b47f9b1710c48448bbf1f85a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ob&lt;/code&gt; is an &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ob&lt;/code&gt; 는 &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="49c9793bb09dc0351d1b52cd8fbd503e82f4dc95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offsetof&lt;/code&gt; cannot be implemented in standard C++ and requires compiler support: &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/gcc-7_1_0-release/gcc/ginclude/stddef.h#L416-L417&quot;&gt;GCC&lt;/a&gt;, &lt;a href=&quot;https://github.com/llvm-mirror/clang/blob/release_70/lib/Headers/stddef.h#L120&quot;&gt;LLVM&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;offsetof&lt;/code&gt; 표준 C ++ 구현 및 컴파일러 지원을 필요로 할 수 없습니다 &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/gcc-7_1_0-release/gcc/ginclude/stddef.h#L416-L417&quot;&gt;GCC&lt;/a&gt; , &lt;a href=&quot;https://github.com/llvm-mirror/clang/blob/release_70/lib/Headers/stddef.h#L120&quot;&gt;LLVM을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1550d528d81c9513ee291d3d137ea795ea16e22e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offsetof&lt;/code&gt; throws no exceptions; the expression &lt;code&gt;noexcept(offsetof(type, member))&lt;/code&gt; always evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;offsetof&lt;/code&gt; 는 예외를 발생시키지 않습니다. &lt;code&gt;noexcept(offsetof(type, member))&lt;/code&gt; 표현식은 항상 &lt;code&gt;true&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="10d8e5e2e6c2fc83be27f282f8161832ab2f139d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_p&lt;/code&gt; is a directory which is an ancestor of &lt;code&gt;new_p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;old_p&lt;/code&gt; 가 의 조상 인 디렉토리입니다 &lt;code&gt;new_p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71d44d78011719f149c165478becc563edf2889e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op1&lt;/code&gt; or &lt;code&gt;op2&lt;/code&gt; must not have side effects.</source>
          <target state="translated">&lt;code&gt;op1&lt;/code&gt; 또는 &lt;code&gt;op2&lt;/code&gt; 에는 부작용이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="adad2a941f6ab3ecdf96f65d8ae11328f5ae81d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op1&lt;/code&gt; or &lt;code&gt;op2&lt;/code&gt; must not invalidate any iterators, including the end iterators, or modify any elements of the range involved.</source>
          <target state="translated">&lt;code&gt;op1&lt;/code&gt; 또는 &lt;code&gt;op2&lt;/code&gt; 는 종료 반복자를 포함하여 반복자를 무효화하거나 관련된 범위의 요소를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="112cde45940f65461c5785534ec8f7c430d7e092" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; must not have side effects.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 에는 부작용이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="086dc8f46b9d3654c7787174b89cec865eea90f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; must not invalidate any iterators, including the end iterators, nor modify any elements of the range involved, and also *last.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 는 엔드 이터레이터를 포함하여 이터레이터를 무효화하거나 관련 범위의 요소 및 마지막 요소를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9b5370c2bec0e4b78acfaa61dec8cb748135b0c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; must not invalidate any iterators, including the end iterators, or modify any elements of the range involved.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 는 종료 반복자를 포함하여 반복자를 무효화하거나 관련된 범위의 요소를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="495903ba6e724d674ab4a75b0dcf1c8280f57c89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; must not invalidate any iterators, including the end iterators, or modify any elements of the ranges involved.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 는 종료 반복자를 포함한 반복자를 무효화하거나 관련된 범위의 요소를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="43436629c08c4505f761868c26d4a01bac6a1d2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open()&lt;/code&gt; is typically called through the constructor or the &lt;code&gt;open()&lt;/code&gt; member function of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;open()&lt;/code&gt; 은 일반적으로 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 의 생성자 또는 &lt;code&gt;open()&lt;/code&gt; 멤버 함수를 통해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7728a14a8b819f8a9d76b6870c043331add54f2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_mode&lt;/code&gt;(deprecated)</source>
          <target state="translated">&lt;code&gt;open_mode&lt;/code&gt;(deprecated)</target>
        </trans-unit>
        <trans-unit id="f764e14352e8d6fb26fb5254da595a18b3bfaeb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, when called on the return value of &lt;code&gt;&lt;a href=&quot;../io/manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../io/manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt; 의 리턴 값에서 호출 될 때 operator &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dca1a1540e1cce4520f29eb1b44ee1c6ca652a14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&amp;lt;&amp;lt; &lt;/code&gt;, when called on the return value of &lt;code&gt;&lt;a href=&quot;../io/manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&amp;lt;&amp;lt; &lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../io/manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt; 의 리턴 값에서 호출 될 때 operator &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="9691a1cc99507551131eb3c4925d3064a98d3083" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&amp;lt;&lt;/code&gt; is a strict weak ordering relation</source>
          <target state="translated">&lt;code&gt;operator&amp;lt;&lt;/code&gt; 는 엄격한 약한 주문 관계입니다</target>
        </trans-unit>
        <trans-unit id="64ed06c8ab9f156add5a77b5c874e04ef517b4db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator*&lt;/code&gt; and &lt;code&gt;operator-&amp;gt;&lt;/code&gt; provide access to the object owned by &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator*&lt;/code&gt; 및 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 는 &lt;code&gt;*this&lt;/code&gt; 가 소유 한 객체에 대한 액세스를 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="9233aa3b7f89164727a126de9342f35da81a913c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator+&lt;/code&gt; and &lt;code&gt;operator-&lt;/code&gt; such that, for an object &lt;code&gt;p&lt;/code&gt; of type (possibly const) &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; and an object &lt;code&gt;o&lt;/code&gt; of type (possibly const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator+&lt;/code&gt; 및 &lt;code&gt;operator-&lt;/code&gt; 같은 유형 의 객체 &lt;code&gt;p&lt;/code&gt; ( &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; const) fpos &amp;lt;State&amp;gt; 및 유형 의 객체 &lt;code&gt;o&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; const) std :: streamoff</target>
        </trans-unit>
        <trans-unit id="3ee3af128ed53550cbdd7518cd7ca15a1967ff13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator+=&lt;/code&gt; and &lt;code&gt;operator-=&lt;/code&gt; which can accept a (possibly const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; and adds/subtracts it from the stored offset, respectively.</source>
          <target state="translated">&lt;code&gt;operator+=&lt;/code&gt; 및 &lt;code&gt;operator-=&lt;/code&gt; 는 (가능하면 const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; 저장된 오프셋에서 각각 더하거나 뺍니다.</target>
        </trans-unit>
        <trans-unit id="7de0e0de71209395ce1649bdf944473e9d832ab6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator-&lt;/code&gt; which can subtract two objects of type (possibly const) &lt;code&gt;std::fpos&lt;/code&gt; producing an &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;, such that for two such objects &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;p == q + (p - q)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator-&lt;/code&gt; &lt;code&gt;std::fpos&lt;/code&gt; 생성하는 &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; 유형의 두 객체를 뺄 수 있습니다 . 이러한 두 객체 &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;q&lt;/code&gt; 의 경우 &lt;code&gt;p == q + (p - q)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67f0f43b79f175c617cfd759b4bd4ed9e48caca2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.&lt;/code&gt; cannot be overloaded, and for &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, in &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, the built-in operator does not introduce any additional function signatures: built-in &lt;code&gt;operator-&amp;gt;&lt;/code&gt; does not apply if there exists an overloaded &lt;code&gt;operator-&amp;gt;&lt;/code&gt; that is a &lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;viable function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;operator.&lt;/code&gt; 오버로드 할 수 없으며, 대한 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 에 &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;사용자 정의 사업자에 대한 오버로드 확인&lt;/a&gt; , 내장 된 추가 기능의 서명을 도입하지 않는 운영자 : 내장 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 오버로드가 존재하는 경우에는 적용되지 않습니다 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 그 A는 &lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;가능한 함수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fbb3ca3c68671c35cfb1ef33d64b5f210f898ea7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;identifier</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;identifier</target>
        </trans-unit>
        <trans-unit id="239e361f041ad35c6ff0532443ae874a6c92e877" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;suffix-identifier</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;suffix-identifier</target>
        </trans-unit>
        <trans-unit id="6999a5c6afb70992d316d3b394d63adc44382529" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;delete []&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; &lt;code&gt;delete []&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31deec09e57eb86531b56b163c9a128d786f83c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80d9c23f95f593132a04ef27cb5eb947186e566a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;new []&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; &lt;code&gt;new []&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec719697fcb83b62494cce9f446b2b5a748a0d6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;new&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8fbab894de22dc4b06b8900ff94ce982b3de0a6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;conversion-type-id</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;conversion-type-id</target>
        </trans-unit>
        <trans-unit id="b07d3291d1d4bba2bd2c34bc2cfd3a5561e0e78d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;op</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;op</target>
        </trans-unit>
        <trans-unit id="2909dcdcc0a9cbd2fda55e2078d1128f224c276b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;type</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;type</target>
        </trans-unit>
        <trans-unit id="c4f0d5823ef995b3af1b29584894a58d6ec4b0d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;user-defined-string-literal(since C++14)</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; 사용자 정의 문자열 리터럴 (C ++ 14부터)</target>
        </trans-unit>
        <trans-unit id="fae38b8e726a3b72cca21c5813ed5594e4001192" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator=(X&amp;amp;) = default&lt;/code&gt; was non-trivial</source>
          <target state="translated">&lt;code&gt;operator=(X&amp;amp;) = default&lt;/code&gt; 은 사소하지 않았습니다</target>
        </trans-unit>
        <trans-unit id="63dc6a1b69fef825c68e024e1e1431dc194dc2e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator==&lt;/code&gt; and &lt;code&gt;operator!=&lt;/code&gt; that compare two objects of type (possibly const) &lt;code&gt;std::fpos&lt;/code&gt; and returns a value of type convertible to &lt;code&gt;bool&lt;/code&gt;. &lt;code&gt;p != q&lt;/code&gt; is equivalent to &lt;code&gt;!(p == q)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator==&lt;/code&gt; 및 &lt;code&gt;operator!=&lt;/code&gt; 는 &lt;code&gt;std::fpos&lt;/code&gt; 유형의 두 객체를 비교 하고 &lt;code&gt;bool&lt;/code&gt; 로 변환 가능한 유형의 값을 반환합니다 . &lt;code&gt;p != q&lt;/code&gt; 는 &lt;code&gt;!(p == q)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39d269f4f1f68438431582408bf841c32f549f02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator==&lt;/code&gt; is an equivalence relation</source>
          <target state="translated">&lt;code&gt;operator==&lt;/code&gt; 는 등가 관계입니다</target>
        </trans-unit>
        <trans-unit id="3d61c5ee92c0d49653eaa3a52c2d1de7ec7b9420" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator==&lt;/code&gt; is defined as defaulted in the definition of &lt;code&gt;T&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;operator==&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 의 정의에서 기본값으로 정의 되며</target>
        </trans-unit>
        <trans-unit id="e9356a1e78f8cbfe3d2f7bf66376ed1f93958a16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator[]&lt;/code&gt; is non-const because it inserts the key if it doesn't exist. If this behavior is undesirable or if the container is &lt;code&gt;const&lt;/code&gt;, &lt;a href=&quot;at&quot;&gt;&lt;code&gt;at()&lt;/code&gt;&lt;/a&gt; may be used.</source>
          <target state="translated">&lt;code&gt;operator[]&lt;/code&gt; 는 존재하지 않는 경우 키를 삽입하기 때문에 상수가 아닙니다. 이 동작이 바람직하지 않거나 컨테이너가 &lt;code&gt;const&lt;/code&gt; 인 경우 &lt;a href=&quot;at&quot;&gt; &lt;code&gt;at()&lt;/code&gt; &lt;/a&gt; 이 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13f08fb543a60dc58a2ea30fbdbededba9bc375e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator[]&lt;/code&gt; provides access to elements of an array managed by a &lt;code&gt;unique_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator[]&lt;/code&gt; 는 &lt;code&gt;unique_ptr&lt;/code&gt; 로 관리되는 배열 요소에 대한 액세스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="883870465553c6cdc607766b28f6468761a82f6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optional&lt;/code&gt; objects whose states to swap</source>
          <target state="translated">&lt;code&gt;optional&lt;/code&gt; 상태를 바꿀 선택적 객체</target>
        </trans-unit>
        <trans-unit id="4fbf68b51971745343c3ffd40d040a0e3e1a307b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;opts&lt;/code&gt; is required to have only one of &lt;code&gt;replace&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, or &lt;code&gt;remove&lt;/code&gt; to be set.</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; 는 &lt;code&gt;replace&lt;/code&gt; , &lt;code&gt;add&lt;/code&gt; 또는 &lt;code&gt;remove&lt;/code&gt; 중 하나만 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a78e804adbc080203711f861cae5a953da4fc7e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order&lt;/code&gt; must be one of &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;. Otherwise the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 중 하나 여야합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7204af3ca4f2aed86069165b606be99f4e2300f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order&lt;/code&gt; must be one of &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;. Otherwise the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 중 하나 여야합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73445bbb3ca832810ca8e503535082a01a9eeb93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt; (reference to the stream after insertion of the null character).</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; (널 문자 삽입 후 스트림 참조)</target>
        </trans-unit>
        <trans-unit id="c6b824d3af2a1cc6b8c2142ae1483bc865ef7340" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt; (reference to the stream after manipulation).</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; (조작 후 스트림 참조).</target>
        </trans-unit>
        <trans-unit id="032f0b3487a5ca21c992a1f045aefccc97a9be7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt;, an output stream</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; , 출력 스트림</target>
        </trans-unit>
        <trans-unit id="52ca514c495ce1aab59e22c682594847bbd20e11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt;, lvalue of a specialization of &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 전문화의 lvalue</target>
        </trans-unit>
        <trans-unit id="c96784d61f11c38f7f6143a78187f534012c3007" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="8498a31a9efd8e8be6b0e17ecaa089beea7bdd90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ost&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ost&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="9c689bba213fce99939bdec65d89bcde7dda5e0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ostrstream&lt;/code&gt; has been deprecated since C++98, &lt;code&gt;&lt;a href=&quot;basic_ostringstream&quot;&gt;std::ostringstream&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_sink&quot;&gt;boost::iostreams::array_sink&lt;/a&gt; are the recommended replacements.</source>
          <target state="translated">&lt;code&gt;ostrstream&lt;/code&gt; C ++ 98부터 ostrstream 이 사용되지 않으며 &lt;code&gt;&lt;a href=&quot;basic_ostringstream&quot;&gt;std::ostringstream&lt;/a&gt;&lt;/code&gt; 및 &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_sink&quot;&gt;boost :: iostreams :: array_sink&lt;/a&gt; 가 권장되는 대체입니다.</target>
        </trans-unit>
        <trans-unit id="94c516fe0a94e3b19aa10baa5992b79161a6417a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ostrstream&lt;/code&gt; has been deprecated since C++98, &lt;code&gt;&lt;a href=&quot;basic_ostringstream&quot;&gt;std::ostringstream&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_sink&quot;&gt;boost::iostreams::array_sink&lt;/a&gt; are the recommended replacements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f153dff8fd2252b6cece0cbb71dec8fd509cbd1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;other&lt;/code&gt; is left with no associated file. Note that the base class move assignment swaps all stream state variables (except for &lt;code&gt;rdbuf&lt;/code&gt;) between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 파일은 관련 파일없이 남아 있습니다. 기본 클래스 이동 지정 은 &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이의 모든 스트림 상태 변수 ( &lt;code&gt;rdbuf&lt;/code&gt; 제외)를 교환합니다 .</target>
        </trans-unit>
        <trans-unit id="5dfa669a6643570842768d3c8af930a8bded28ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;out&lt;/code&gt;, &lt;code&gt;out|trunc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; , &lt;code&gt;out|trunc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78ed9da4c97b581673150388516e0e2b9bf414f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="a0234f068508744db144a8f4f24cbb727104a0fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;output_iterator_tag&lt;/code&gt; 대응하는 &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="151a095e9390db143eee3847774c0e9cd2500d42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;out|in|app&lt;/code&gt;, &lt;code&gt;in|app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;out|in|app&lt;/code&gt; , &lt;code&gt;in|app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff0efac0feea602422410e8b7256210660023bdb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;override&lt;/code&gt; is an identifier with a special meaning when used after member function declarators: it's not a reserved keyword otherwise.</source>
          <target state="translated">&lt;code&gt;override&lt;/code&gt; 는 멤버 함수 선언자 뒤에 사용될 때 특별한 의미를 가진 식별자입니다. 그렇지 않으면 예약 키워드가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b37336d8be8522632aaf92f068edcc5fc1306e8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p + o&lt;/code&gt; has type &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; and stores an offset that is the result of adding &lt;code&gt;o&lt;/code&gt; to the offset of &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p + o&lt;/code&gt; 는 &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; 유형을 가지며 &lt;code&gt;p&lt;/code&gt; 의 오프셋에 &lt;code&gt;o&lt;/code&gt; 를 추가 한 결과 인 오프셋을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="6c538706b366113c705286df152d776a2ec6aa9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p - o&lt;/code&gt; has type &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; and stores an offset that is the result of subtracting &lt;code&gt;o&lt;/code&gt; from the offset of &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p - o&lt;/code&gt; 는 &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; 유형을 가지며 &lt;code&gt;p&lt;/code&gt; 의 오프셋에서 &lt;code&gt;o&lt;/code&gt; 를 뺀 결과 인 오프셋을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="59ce2be2c428fc29f56c47bde0b8952f2140fde4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p, q&lt;/code&gt;, values of type &lt;code&gt;const CharT*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p, q&lt;/code&gt; , &lt;code&gt;const CharT*&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="0bf18dd04ded5880be160a1161b6bb30895803ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p-&amp;gt;*mp&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;pointer to member of pointer&lt;/a&gt; expression, where &lt;code&gt;mp&lt;/code&gt; is a pointer to data member;</source>
          <target state="translated">&lt;code&gt;p-&amp;gt;*mp&lt;/code&gt; , &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;포인터&lt;/a&gt; 표현식 멤버에 대한 내장 포인터 . 여기서 &lt;code&gt;mp&lt;/code&gt; 는 데이터 멤버에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="fd5ab0235afc288a57ad9fbf269861d99aee101e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p-&amp;gt;*mp&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;pointer to member of pointer&lt;/a&gt; expression, where &lt;code&gt;mp&lt;/code&gt; is a pointer to member function&lt;sup id=&quot;cite_ref-pmfc_2-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;;</source>
          <target state="translated">&lt;code&gt;p-&amp;gt;*mp&lt;/code&gt; , &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;포인터&lt;/a&gt; 표현식 멤버에 대한 내장 포인터 . 여기서 &lt;code&gt;mp&lt;/code&gt; 는 멤버 함수에 대한 포인터입니다 &lt;sup id=&quot;cite_ref-pmfc_2-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; ;</target>
        </trans-unit>
        <trans-unit id="d647ed0e69a621aee58bfb437764f9f6f57a9644" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p-&amp;gt;m&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member of pointer&lt;/a&gt; expression, except where &lt;code&gt;m&lt;/code&gt; is a member enumerator or a non-static member function;</source>
          <target state="translated">&lt;code&gt;p-&amp;gt;m&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 은 멤버 열거 자 또는 비 정적 멤버 함수 인 경우를 제외하고 내장 된 &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;포인터&lt;/a&gt; 표현식 멤버입니다 .</target>
        </trans-unit>
        <trans-unit id="decc8a48f2e43780bffcfc24eccfab7b70d4b019" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p-&amp;gt;m&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member of pointer&lt;/a&gt; expression, where &lt;code&gt;m&lt;/code&gt; is a member enumerator or a non-static member function&lt;sup id=&quot;cite_ref-pmfc_2-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;;</source>
          <target state="translated">&lt;code&gt;p-&amp;gt;m&lt;/code&gt; , &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;포인터&lt;/a&gt; 표현 의 내장 멤버 . 여기서 &lt;code&gt;m&lt;/code&gt; 은 멤버 열거 자 또는 비 정적 멤버 함수입니다 &lt;sup id=&quot;cite_ref-pmfc_2-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; ;</target>
        </trans-unit>
        <trans-unit id="d91a4e8a8b40a713d9c0c11cc0d6f8157332110a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p1&lt;/code&gt; and &lt;code&gt;p2&lt;/code&gt;, objects of type &lt;code&gt;X::pointer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p1&lt;/code&gt; 및 &lt;code&gt;p2&lt;/code&gt; , &lt;code&gt;X::pointer&lt;/code&gt; 유형의 객체</target>
        </trans-unit>
        <trans-unit id="2fdbf1680504d5fe8ef0f07168890765f7a7837e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; must have been returned by a prior call to &lt;code&gt;allocate(bytes, alignment)&lt;/code&gt; on a &lt;code&gt;memory_resource&lt;/code&gt; that compares equal to &lt;code&gt;*this&lt;/code&gt;, and the storage it points to must not yet have been deallocated, otherwise the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;*this&lt;/code&gt; 와 비교 되는 &lt;code&gt;memory_resource&lt;/code&gt; 에서 assign &lt;code&gt;allocate(bytes, alignment)&lt;/code&gt; 에 대한 이전 호출에 의해 리턴되어야하며 , 이를 가리키는 스토리지는 아직 할당 해제되지 않았어야 합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86c9ed195a73935b9716d0c908fe04050917471f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; | &lt;code&gt;P&lt;/code&gt;exponent-sign(optional)digit-sequence</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; | &lt;code&gt;P&lt;/code&gt; 지수 부호 (선택 사항) 숫자 순서</target>
        </trans-unit>
        <trans-unit id="d513ab3d55fc832db51ef3c9a24dc140d2150524" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; , &lt;code&gt;q2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb12774f3eaef9d2fbe7eabc6816979bbcbdac38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;, a (possibly const) value of type &lt;code&gt;P&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; 유형의 a (아마도 const) 값</target>
        </trans-unit>
        <trans-unit id="06a9dfc8a3226eb094336f1d83bc095f0f4cc3f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;, a valid const iterator into &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 에 유효한 CONST 반복자 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dda70b02c1417aebe7356f487e2312107813a9f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;, a value of type &lt;code&gt;const CharT*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; , &lt;code&gt;const CharT*&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="bf42ece8a8b704ccc31f7c6d166de57b47e04378" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; constructor supports creation from UTF-8 string when the source is a sequence of &lt;code&gt;char8_t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 소스가 &lt;code&gt;char8_t&lt;/code&gt; 시퀀스 인 경우 경로 생성자는 UTF-8 문자열에서의 작성을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="bfe847d99e91df30f9b2b1c997d690f6c9d3e19f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perm_options&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type).</source>
          <target state="translated">&lt;code&gt;perm_options&lt;/code&gt; 는 &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; 의 요구 사항을 충족합니다 (비트 연산자 &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;operator|&lt;/code&gt; , &lt;code&gt;operator^&lt;/code&gt; , &lt;code&gt;operator~&lt;/code&gt; , &lt;code&gt;operator&amp;amp;=&lt;/code&gt; , &lt;code&gt;operator|=&lt;/code&gt; 및 &lt;code&gt;operator^=&lt;/code&gt; 는이 유형에 대해 정의 됨).</target>
        </trans-unit>
        <trans-unit id="7ee26e88b54b4a023e55266a4a3f22951b680147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt; - defines a pointer to the type iterated over (&lt;code&gt;value_type&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; - (타입에 대한 포인터가 반복 정의 &lt;code&gt;value_type&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e79147d00db804701f1432b2de52a0ee8c9866be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt; is the same type as &lt;code&gt;element_type*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; 는 &lt;code&gt;element_type*&lt;/code&gt; 과 같은 유형입니다</target>
        </trans-unit>
        <trans-unit id="d4eac86c5a412a3fecf58e540135ae2be1988069" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt; is the same type as &lt;code&gt;element_type*&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; is a pointer type &lt;code&gt;V*&lt;/code&gt; such that &lt;code&gt;V(*)[]&lt;/code&gt; is convertible to &lt;code&gt;element_type(*)[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; 와 같은 타입 &lt;code&gt;element_type*&lt;/code&gt; 및 &lt;code&gt;U&lt;/code&gt; 가 포인터 타입이다 &lt;code&gt;V*&lt;/code&gt; 되도록 &lt;code&gt;V(*)[]&lt;/code&gt; 하는 컨버터블 &lt;code&gt;element_type(*)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c5d8e68715c162ba85ea985f5b5bb4621395292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt; is the same type as &lt;code&gt;element_type*&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; is some pointer type &lt;code&gt;V*&lt;/code&gt; such that &lt;code&gt;V(*)[]&lt;/code&gt; is implicitly convertible to &lt;code&gt;element_type(*)[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; 와 같은 타입 &lt;code&gt;element_type*&lt;/code&gt; 및 &lt;code&gt;U&lt;/code&gt; 는 어떤 포인터 타입 인 &lt;code&gt;V*&lt;/code&gt; 되도록 &lt;code&gt;V(*)[]&lt;/code&gt; 암시 적 변환 가능한 &lt;code&gt;element_type(*)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56f1ebd031796dfa24a0a58f2845dcb2e9561460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음) (C ++ 20에서 제거됨)</target>
        </trans-unit>
        <trans-unit id="d1061ab44e5f87ced20028c2ff2ad959879b250d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;polymorphic_allocator&lt;/code&gt; does not propagate on container copy assignment, move assignment, or swap. As a result, move assignment of a &lt;code&gt;polymorphic_allocator&lt;/code&gt;-using container can throw, and swapping two &lt;code&gt;polymorphic_allocator&lt;/code&gt;-using containers whose allocators do not compare equal results in undefined behavior.</source>
          <target state="translated">&lt;code&gt;polymorphic_allocator&lt;/code&gt; 는 컨테이너 사본 할당, 이동 할당 또는 스왑시 전파되지 않습니다. 결과적으로 컨테이너를 사용 하여 &lt;code&gt;polymorphic_allocator&lt;/code&gt; 의 이동 할당이 발생하고 할당자가 정의되지 않은 동작에서 동일한 결과를 비교하지 않는 컨테이너를 사용하여 두 개의 &lt;code&gt;polymorphic_allocator&lt;/code&gt; 를 교환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="625f99b6248f4d1722f67a9433f27d568b065d23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;polymorphic_allocator&lt;/code&gt;s do not propagate on container copy construction.</source>
          <target state="translated">&lt;code&gt;polymorphic_allocator&lt;/code&gt; 는 컨테이너 복사본 생성시 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5e918c456b10043e8203133417d79d51c29c66d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pos&lt;/code&gt;, a value of type &lt;code&gt;X::pos_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; , &lt;code&gt;X::pos_type&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="8cb67828ec4d1356afd884c8cf511326963cfbaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pos_type(newoff)&lt;/code&gt; on success, &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure and if pos_type cannot represent the resulting stream position.</source>
          <target state="translated">&lt;code&gt;pos_type(newoff)&lt;/code&gt; 성공, &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; , 실패 및 pos_type가 생성 스트림 위치를 표시 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="6498cc9ae3662e3b03086527cb6accd9d3f42543" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(&amp;plusmn;0, -&amp;infin;)&lt;/code&gt; returns +&amp;infin; and may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(&amp;plusmn;0, -&amp;infin;)&lt;/code&gt; 은 + &amp;infin;을 반환하고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 를 올릴 수 있습니다</target>
        </trans-unit>
        <trans-unit id="042e94e352fb34d331cb6fc5334ea7fed3a2d3fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(&amp;plusmn;0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is negative, finite, and is an even integer or a non-integer, returns +&amp;infin; and raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(&amp;plusmn;0, exp)&lt;/code&gt; (여기서 &lt;code&gt;exp&lt;/code&gt; 는 음수, 유한이며 정수 또는 정수가 아닌 정수)이며 + &amp;infin;을 반환하고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 를 올립니다 .</target>
        </trans-unit>
        <trans-unit id="ee4eec21814b8d94f592dabb5cd16ff37f602187" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(&amp;plusmn;0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is positive non-integer or a positive even integer, returns +0</source>
          <target state="translated">&lt;code&gt;pow(&amp;plusmn;0, exp)&lt;/code&gt; (여기서 &lt;code&gt;exp&lt;/code&gt; 는 양의 정수가 아닌 정수 또는 양의 짝수 정수인 경우 +0을 반환 함)</target>
        </trans-unit>
        <trans-unit id="4063720964f4e1762c5635e9b59232784a0d4540" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+&amp;infin;, exp)&lt;/code&gt; returns +&amp;infin; for any positive &lt;code&gt;exp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(+&amp;infin;, exp)&lt;/code&gt; 는 양의 &lt;code&gt;exp&lt;/code&gt; 에 대해 + &amp;infin;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56ebf1acd4f1f0c4a5274430626232999a270b35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+&amp;infin;, exp)&lt;/code&gt; returns +0 for any negative &lt;code&gt;exp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(+&amp;infin;, exp)&lt;/code&gt; 는 음수 &lt;code&gt;exp&lt;/code&gt; 에 대해 +0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="290d8d6e91b01d354bcde6fecd105bc84bb83b5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is a negative odd integer, returns +&amp;infin; and raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(+0, exp)&lt;/code&gt; , 여기서 &lt;code&gt;exp&lt;/code&gt; 는 음의 정수입니다. + &amp;infin;을 반환하고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 를 올립니다 .</target>
        </trans-unit>
        <trans-unit id="3878047bc1ba88caaa0d085bfa6aaec4e2ca959f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is a positive odd integer, returns +0</source>
          <target state="translated">&lt;code&gt;pow(+0, exp)&lt;/code&gt; , 여기서 &lt;code&gt;exp&lt;/code&gt; 는 양의 홀수 정수이며 +0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd1582f9f2bfd41942e34cebc3721377ce599a2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+1, exp)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; for any &lt;code&gt;exp&lt;/code&gt;, even when &lt;code&gt;exp&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(+1, exp)&lt;/code&gt; 는 &lt;code&gt;exp&lt;/code&gt; 가 &lt;code&gt;NaN&lt;/code&gt; 인 경우에도 &lt;code&gt;exp&lt;/code&gt; 에 대해 &lt;code&gt;1&lt;/code&gt; 을 반환합니다</target>
        </trans-unit>
        <trans-unit id="dc7237a85469de1b40fe31197bdde1ed77eb2948" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; returns +&amp;infin; if &lt;code&gt;exp&lt;/code&gt; is a positive non-integer or even integer</source>
          <target state="translated">&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; 는 &lt;code&gt;exp&lt;/code&gt; 가 양의 정수가 아니거나 정수인 경우 + &amp;infin;을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a734c05c169aa85465d6092079877e0218736515" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; returns +0 if &lt;code&gt;exp&lt;/code&gt; is a negative non-integer or even integer</source>
          <target state="translated">&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; 는 &lt;code&gt;exp&lt;/code&gt; 가 음수가 아닌 정수이거나 정수일 경우 +0을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="700ada9b089696d54cc43eebe2567eaa09e43d01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; returns -&amp;infin; if &lt;code&gt;exp&lt;/code&gt; is a positive odd integer</source>
          <target state="translated">&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; 는 &lt;code&gt;exp&lt;/code&gt; 가 양의 홀수 인 경우 -&amp;infin;을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3c266a9e25ce2048682bdb2a100bbbf6e740ceb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; returns -0 if &lt;code&gt;exp&lt;/code&gt; is a negative odd integer</source>
          <target state="translated">&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; 는 &lt;code&gt;exp&lt;/code&gt; 가 음의 정수일 경우 -0을 반환합니다</target>
        </trans-unit>
        <trans-unit id="ef3bb65d06173ef9916b6d047828bd8344e86186" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is a negative odd integer, returns -&amp;infin; and raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(-0, exp)&lt;/code&gt; , 여기서 &lt;code&gt;exp&lt;/code&gt; 는 음의 정수입니다. -&amp;infin;을 반환하고 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 를 올립니다 .</target>
        </trans-unit>
        <trans-unit id="50deaa3867ca4b36a7f84a69f7c8fb4bb898765b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is a positive odd integer, returns -0</source>
          <target state="translated">&lt;code&gt;pow(-0, exp)&lt;/code&gt; , 여기서 &lt;code&gt;exp&lt;/code&gt; 는 양의 홀수 정수이며 -0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="447e291f802b84fb27f91b3026e77b14323ccb22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-1, &amp;plusmn;&amp;infin;)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(-1, &amp;plusmn;&amp;infin;)&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 반환합니다</target>
        </trans-unit>
        <trans-unit id="0c04a0ce7e8f42d74e5388e22f76da75a979a54c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, &amp;plusmn;0)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; for any &lt;code&gt;base&lt;/code&gt;, even when &lt;code&gt;base&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, &amp;plusmn;0)&lt;/code&gt; 은 &lt;code&gt;base&lt;/code&gt; 가 &lt;code&gt;NaN&lt;/code&gt; 인 경우에도 모든 &lt;code&gt;base&lt;/code&gt; 에 대해 &lt;code&gt;1&lt;/code&gt; 을 반환합니다</target>
        </trans-unit>
        <trans-unit id="4a71fc23b8b5a698d841d4415831f0fa35d4ddef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, +&amp;infin;)&lt;/code&gt; returns +&amp;infin; for any &lt;code&gt;|base|&amp;gt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, +&amp;infin;)&lt;/code&gt; 는 &lt;code&gt;|base|&amp;gt;1&lt;/code&gt; 대해 + &amp;infin;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06fde8b1bde3c2c448f1910dc0f1b60dbb034481" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, +&amp;infin;)&lt;/code&gt; returns +0 for any &lt;code&gt;|base|&amp;lt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, +&amp;infin;)&lt;/code&gt; 는 &lt;code&gt;|base|&amp;lt;1&lt;/code&gt; 대해 +0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31af622727a3672337932c35fe9e49310d7fef72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, -&amp;infin;)&lt;/code&gt; returns +&amp;infin; for any &lt;code&gt;|base|&amp;lt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, -&amp;infin;)&lt;/code&gt; 는 &lt;code&gt;|base|&amp;lt;1&lt;/code&gt; 대해 + &amp;infin;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49a620a430e4139058cc89942e34ef8005a0253a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, -&amp;infin;)&lt;/code&gt; returns +0 for any &lt;code&gt;|base|&amp;gt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, -&amp;infin;)&lt;/code&gt; 는 &lt;code&gt;|base|&amp;gt;1&lt;/code&gt; 대해 +0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1f971d5f39b82653837792e77c6f4888a84edec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, exp)&lt;/code&gt; returns &lt;code&gt;NaN&lt;/code&gt; and raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;base&lt;/code&gt; is finite and negative and &lt;code&gt;exp&lt;/code&gt; is finite and non-integer.</source>
          <target state="translated">&lt;code&gt;pow(base, exp)&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 을 반환 하고 &lt;code&gt;base&lt;/code&gt; 가 유한하고 음수이고 &lt;code&gt;exp&lt;/code&gt; 가 유한하고 정수가 아닌 경우 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="9d7cf028e07dd0eaf95da860c70dd83e851c29f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(float, int)&lt;/code&gt; returns &lt;code&gt;float&lt;/code&gt; until C++11 (per overload 4) but returns &lt;code&gt;double&lt;/code&gt; since C++11 (per overload 7).</source>
          <target state="translated">&lt;code&gt;pow(float, int)&lt;/code&gt; 는 C ++ 11 (과부하 4 당)까지 &lt;code&gt;float&lt;/code&gt; 를 반환 하지만 C ++ 11 (과부하 7 당) 이후 &lt;code&gt;double&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1b1fae023fa49e4833b3e21e8841e921d4f06a73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;printf&lt;/code&gt; family of functions should produce the same sequence using &lt;code&gt;%p&lt;/code&gt; format specifier.</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; 함수 계열은 &lt;code&gt;%p&lt;/code&gt; 형식 지정자를 사용하여 동일한 시퀀스를 생성해야 합니다.</target>
        </trans-unit>
        <trans-unit id="26d9d6de8db2eb2f8a42e0d3402444909f7380de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt; access specifier</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; 액세스 지정자</target>
        </trans-unit>
        <trans-unit id="d06e845dd87ad90bf1bed9db6304b845f3753b8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</target>
        </trans-unit>
        <trans-unit id="7d06457bc1a108ff2b5a3fb6cacd2d0879f1e659" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;base_class</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt;base_class</target>
        </trans-unit>
        <trans-unit id="2be979307e8c4ecb073d5d7f8c2c69f96da8ea58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propagate_on_container_copy_assignment&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for at least one allocator &lt;code&gt;A&lt;/code&gt; among &lt;code&gt;OuterAlloc&lt;/code&gt; and &lt;code&gt;InnerAlloc...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;propagate_on_container_copy_assignment&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; 는 &lt;code&gt;OuterAlloc&lt;/code&gt; 및 &lt;code&gt;InnerAlloc...&lt;/code&gt; 중 하나 이상의 할당 자 &lt;code&gt;A&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 입니다 ...</target>
        </trans-unit>
        <trans-unit id="0a45f9401d8e6380fa755c6da39c0c81ec78bc2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propagate_on_container_move_assignment&lt;/code&gt;(C++14)</source>
          <target state="translated">&lt;code&gt;propagate_on_container_move_assignment&lt;/code&gt;(C++14)</target>
        </trans-unit>
        <trans-unit id="62f33439d93f9ada7b8d0a92dc1fa3b75c71b2c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propagate_on_container_move_assignment&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for at least one allocator &lt;code&gt;A&lt;/code&gt; among &lt;code&gt;OuterAlloc&lt;/code&gt; and &lt;code&gt;InnerAlloc...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;propagate_on_container_move_assignment&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; 는 &lt;code&gt;OuterAlloc&lt;/code&gt; 및 &lt;code&gt;InnerAlloc...&lt;/code&gt; 중 하나 이상의 할당 자 &lt;code&gt;A&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 입니다 ...</target>
        </trans-unit>
        <trans-unit id="42e23f2cd472fcc8e748a4059324eaa52062ed17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propagate_on_container_swap&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for at least one allocator &lt;code&gt;A&lt;/code&gt; among &lt;code&gt;OuterAlloc&lt;/code&gt; and &lt;code&gt;InnerAlloc...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;propagate_on_container_swap&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; 는 &lt;code&gt;OuterAlloc&lt;/code&gt; 및 &lt;code&gt;InnerAlloc...&lt;/code&gt; 중 하나 이상의 할당 자 &lt;code&gt;A&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 입니다 ...</target>
        </trans-unit>
        <trans-unit id="a6e3da20abe20ecf600244767a7228b8ec7219b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt; access specifier</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 액세스 지정자</target>
        </trans-unit>
        <trans-unit id="0dac7c331aa38c811453a012236db1f4ecc81cc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</target>
        </trans-unit>
        <trans-unit id="bf5ed0fb019fba1b1e4776c0bc6a3b60f1f50260" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt;base_class</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt;base_class</target>
        </trans-unit>
        <trans-unit id="d543477baebfc303e229d1b12c5465e379252a52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pt - d&lt;/code&gt; behaved erratically for unsigned &lt;code&gt;duration&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;pt - d&lt;/code&gt; 서명되지 않은 비정상적 행동 &lt;code&gt;duration&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="90804637cd522ac07670221ad0bb2db775bb32ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptr&lt;/code&gt;, a value of type &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::pointer&lt;/code&gt;, obtained by calling &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::allocate()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::pointer&lt;/code&gt; 유형의 값인 ptr 은 &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::allocate()&lt;/code&gt; 호출하여 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c1816369eba63545ea58a82705ae7b104b2093ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="98127c9da9e6d997403382be8dae19cbae7b3ddd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; access specifier</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; 액세스 지정자</target>
        </trans-unit>
        <trans-unit id="c2535c3ba85e352bae5b83bc911fdd83338ce3db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</target>
        </trans-unit>
        <trans-unit id="880ecefc2b9aeb88a42626aa4c5046e1af5b36d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt;base_class</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt;base_class</target>
        </trans-unit>
        <trans-unit id="f29797f27b4f5d46325487b01341bb5f6d2c7214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;purr(kittens...)&lt;/code&gt; may be used in a constant expression if &lt;code&gt;kittens...&lt;/code&gt; can be so used, unless &lt;code&gt;purr&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;purr(kittens...)&lt;/code&gt; 경우 일정한 발현에 사용될 수있다 &lt;code&gt;kittens...&lt;/code&gt; 그렇게 사용될 수 없다면, &lt;code&gt;purr&lt;/code&gt; 있다</target>
        </trans-unit>
        <trans-unit id="e0d0718501a69c7609d845166e16c50475b3cdae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;purr&lt;/code&gt;, an operation on &lt;code&gt;It&lt;/code&gt; that is required to be supported by MeowIterator,</source>
          <target state="translated">&lt;code&gt;purr&lt;/code&gt; 에 동작 &lt;code&gt;It&lt;/code&gt; MeowIterator 의해 지원 될 필요가있다,</target>
        </trans-unit>
        <trans-unit id="1c67093ec2487091c75ddf44f1541f90c75dca19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q1&lt;/code&gt; and &lt;code&gt;q2&lt;/code&gt;, two const iterators into &lt;code&gt;a&lt;/code&gt; such that &lt;code&gt;[q1, q2)&lt;/code&gt; is a valid range</source>
          <target state="translated">&lt;code&gt;q1&lt;/code&gt; 및 &lt;code&gt;q2&lt;/code&gt; 로 두 CONST 반복자 되도록 &lt;code&gt;[q1, q2)&lt;/code&gt; 유효 범위는 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfc434c5a3d577e8bcb2b5a651536d299f5787e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q1&lt;/code&gt;, &lt;code&gt;q2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;q1&lt;/code&gt; , &lt;code&gt;q2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35578f384495877ae734f3d077fa1b9f3901bccf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; is an object of &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; is a potentially constant object of &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; 는 &lt;code&gt;S&lt;/code&gt; 의 객체 이고 &lt;code&gt;r&lt;/code&gt; 은 잠재적으로 일정한 &lt;code&gt;S&lt;/code&gt; 의 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="4ed03c127fd5c9bdd21111ed8901a64761f9ce66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt;, &lt;code&gt;q1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; , &lt;code&gt;q1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="510143bb4bc0d569aa30b51358da3e4cce321048" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt;, a lvalue of some type satisfying &lt;a href=&quot;seedsequence&quot;&gt;SeedSequence&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; , &lt;a href=&quot;seedsequence&quot;&gt;SeedSequence를&lt;/a&gt; 만족시키는 어떤 유형의 lvalue</target>
        </trans-unit>
        <trans-unit id="8126fdcbc449aa27110d9e7e3285749608d7a2cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt;, a valid dereferenceable const iterator into &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; ,에 유효한 dereferenceable CONST 반복자 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ef715c08da87f8dbdf20a665776590c211fc002" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; and &lt;code&gt;++r&lt;/code&gt; designate the same iterator object, &lt;code&gt;r&lt;/code&gt; is dereferencable or past-the-end</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 과 &lt;code&gt;++r&lt;/code&gt; 는 동일한 반복자 객체를 지정합니다. &lt;code&gt;r&lt;/code&gt; 은 참조 할 수 없거나 끝났습니다.</target>
        </trans-unit>
        <trans-unit id="e4aa33d08f8c0974302181fa64af62a1feb3e5a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="46ead29af315ed03ad8d452c8d919f32e38888f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; is dereferencable</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 은 참조 할 수 없다</target>
        </trans-unit>
        <trans-unit id="5d5ac794aec0ac4eeea4af1673a17ee20e884d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; is incrementable</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 은 증분 가능</target>
        </trans-unit>
        <trans-unit id="39f632268f6c7887230654fc3d3825ae396c158b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, a value of type &lt;code&gt;It&amp;amp;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; , &lt;code&gt;It&amp;amp;&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="956d59ddbfc632ab4ded450c800a2bd4f897f931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, an lvalue of type &lt;code&gt;CharT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; , &lt;code&gt;CharT&lt;/code&gt; 유형의 lvalue</target>
        </trans-unit>
        <trans-unit id="80db8cfc9956eb3c1de4af7a53e262df60a93cab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, an lvalue of type &lt;code&gt;It&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; &lt;code&gt;It&lt;/code&gt; 유형의 lvalue 인 r .</target>
        </trans-unit>
        <trans-unit id="d89f7173bffdb7dff443cf98d95ae9c1e5c89f58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, an lvalue of type &lt;code&gt;T&lt;/code&gt; obtained by the expression &lt;code&gt;*ptr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; &lt;code&gt;*ptr&lt;/code&gt; 식 * ptr로 얻은 &lt;code&gt;T&lt;/code&gt; 유형의 lvalue</target>
        </trans-unit>
        <trans-unit id="349b097a8745964e5528610acb2d276c44b2dfa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, an lvalue of type &lt;code&gt;X&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 입력의 좌변 &lt;code&gt;X&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="2a20f01e1c4c5aeb82b93359a535bd4702ce8246" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rand()&lt;/code&gt; is not recommended for serious random-number generation needs. It is recommended to use C++11's &lt;a href=&quot;../random&quot;&gt;random number generation&lt;/a&gt; facilities to replace rand().(since C++11).</source>
          <target state="translated">&lt;code&gt;rand()&lt;/code&gt; 는 심각한 난수 생성 요구에 권장되지 않습니다. rand ()를 대체 하기 위해 C ++ 11의 &lt;a href=&quot;../random&quot;&gt;난수 생성&lt;/a&gt; 기능 을 사용하는 것이 좋습니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="63092ad067b962bb744290c3b8860b9cad535111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;random_access_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;random_access_iterator_tag&lt;/code&gt; 에 대응 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc4b04723ffa3c7143c9033f54c289926dd19cca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranges::begin(E)&lt;/code&gt; and &lt;code&gt;ranges::begin(t)&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;ranges::begin(E)&lt;/code&gt; 및 &lt;code&gt;ranges::begin(t)&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="b44969908c2d08c23acc53cd6c178ed7acff3351" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranges::end(E)&lt;/code&gt; and &lt;code&gt;ranges::end(t)&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;ranges::end(E)&lt;/code&gt; 및 &lt;code&gt;ranges::end(t)&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="800883fa519bd72070c2a1e0287106b2d0d8562f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranlux24&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;ranlux24&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="2d565ea845f27d2bb1fbace67d387f1fca3ecf86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranlux24_base&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;ranlux24_base&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="7d876385690e83f9f74ca8d39f8cb05c887c309e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranlux48&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;ranlux48&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="5910f409e209ee99f841ab8f3183517a83eb6098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranlux48_base&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;ranlux48_base&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="69601cbb8b00f423e101d5c4b9fa8eafd68af897" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rb&lt;/code&gt;,&lt;code&gt;re&lt;/code&gt; are &lt;a href=&quot;outputiterator&quot;&gt;mutable&lt;/a&gt;&lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt; with a &lt;code&gt;value_type&lt;/code&gt; of unsigned integer values of at least 32 bits.</source>
          <target state="translated">&lt;code&gt;rb&lt;/code&gt; , &lt;code&gt;re&lt;/code&gt; 는 32 비트 이상의 부호없는 정수 값의 &lt;code&gt;value_type&lt;/code&gt; 을 갖는 &lt;a href=&quot;outputiterator&quot;&gt;변경 가능한 &lt;/a&gt;&lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="1f38e682c94bea1b1ea626cf465e65d010cdb40a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rcopy&lt;/code&gt;, a distinct object that is equal to &lt;code&gt;rhs&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;rcopy&lt;/code&gt; 는 &lt;code&gt;rhs&lt;/code&gt; 와 같은 고유 한 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="bfb39847458d7f586b236cc53d450da13c194e64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdbuf()-&amp;gt;sputbackc()&lt;/code&gt; or &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; return &lt;code&gt;traits::eof()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rdbuf()-&amp;gt;sputbackc()&lt;/code&gt; 또는 &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; 는 &lt;code&gt;traits::eof()&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b663b26438681e782f763683bd9154b1ec2d8361" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rebind&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;rebind&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음) (C ++ 20에서 제거됨)</target>
        </trans-unit>
        <trans-unit id="0cd838c1a4cc8e60af9a0e537b3692cd18cb8e28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recursive_directory_iterator&lt;/code&gt; is an &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; that iterates over the &lt;a href=&quot;directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; elements of a directory, and, recursively, over the entries of all subdirectories. The iteration order is unspecified, except that each directory entry is visited only once.</source>
          <target state="translated">&lt;code&gt;recursive_directory_iterator&lt;/code&gt; 는 &lt;a href=&quot;directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt; 의 directory_entry 요소 를 반복하고 모든 하위 디렉토리의 항목을 반복적 으로 나타내는 &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; 입니다 . 각 디렉토리 항목이 한 번만 방문된다는 점을 제외하고 반복 순서는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30dc9f28b8f62cbb2bc8ffe10de818246455e131" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recursive_mutex&lt;/code&gt; offers exclusive, recursive ownership semantics:</source>
          <target state="translated">&lt;code&gt;recursive_mutex&lt;/code&gt; 는 독점적 인 재귀 소유권 의미를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="598e7618503b29c6fbb045f594ce4024c5ec9942" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref_&amp;shy;view&lt;/code&gt; is a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of the elements of some other &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;. It wraps a reference to that &lt;code&gt;Range&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ref_&amp;shy;view&lt;/code&gt; A는 &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; 다른 요소의 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; . 해당 &lt;code&gt;Range&lt;/code&gt; 에 대한 참조를 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="2f69b53eb3b26327fb1b3702a93e2c01575ac711" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference,&lt;/code&gt; the type denoted by &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reference,&lt;/code&gt; &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt; 로 표시되는 유형</target>
        </trans-unit>
        <trans-unit id="60c35e0f46449e1c244042bacc03642577f30615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference&lt;/code&gt; - defines a reference to the type iterated over (&lt;code&gt;value_type&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; - 반복되는 유형에 대한 참조를 정의합니다 ( &lt;code&gt;value_type&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="abcf815b721ede9c83eedeb75e9115c1eba2b395" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음) (C ++ 20에서 제거됨)</target>
        </trans-unit>
        <trans-unit id="f3666f59f83dac548eb815cb74c9381040b8d908" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference&lt;/code&gt;, convertible to &lt;code&gt;value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; , &lt;code&gt;value_type&lt;/code&gt; 으로 변환 가능</target>
        </trans-unit>
        <trans-unit id="4ac3623e8103740b628f9cb099baaddf8ca2ec66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference&lt;/code&gt;, the type denoted by &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::reference&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::reference&lt;/code&gt; &amp;lt;It&amp;gt; :: reference 로 표시되는 유형</target>
        </trans-unit>
        <trans-unit id="85eb9faf32144c3d811f6fc0dc7cab7837909b60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refs&lt;/code&gt; is used for resource management: if &lt;code&gt;refs == 0&lt;/code&gt;, the implementation destroys the facet, when the last &lt;code&gt;&lt;a href=&quot;locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; object holding it is destroyed. Otherwise, the object is not destroyed.</source>
          <target state="translated">&lt;code&gt;refs&lt;/code&gt; 는 자원 관리에 사용됩니다. &lt;code&gt;refs == 0&lt;/code&gt; 이면 마지막 &lt;code&gt;&lt;a href=&quot;locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; 객체를 파괴 할 때 구현이 패싯을 삭제합니다 . 그렇지 않으면 객체가 파괴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0770f5fc37f5b2939a35296243da85be1cc805d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regex_replace&lt;/code&gt; uses a regular expression to perform substitution on a sequence of characters:</source>
          <target state="translated">&lt;code&gt;regex_replace&lt;/code&gt; 는 정규식을 사용하여 일련의 문자를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="3abfeba8a9c538f0cf69429a4f827b597bda06a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regex_search&lt;/code&gt; will successfully match any subsequence of the given sequence, whereas &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; will only return &lt;code&gt;true&lt;/code&gt; if the regular expression matches the</source>
          <target state="translated">&lt;code&gt;regex_search&lt;/code&gt; 공히은 성공적 반면, 주어진 순서의 서브 순서와 일치합니다 &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; 단지 돌아갑니다 &lt;code&gt;true&lt;/code&gt; 정규 표현식이 일치하는 경우</target>
        </trans-unit>
        <trans-unit id="fd08c8dd3fa527f82569a2f504f2043aa282f84c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;register&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="a4b18bcf26db26f86cb624fc878d8f89231e92b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rehash(0)&lt;/code&gt; may be used to force an unconditional rehash, such as after suspension of automatic rehashing by temporarily increasing &lt;code&gt;max_load_factor()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rehash(0)&lt;/code&gt; 은 &lt;code&gt;max_load_factor()&lt;/code&gt; 일시적으로 증가시켜 자동 재해시를 중단 한 후와 같이 무조건 재해시를 강제하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d303fc5ae6388cc35f1ecf3e0b09b3ec63f9eb2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reinterpret_cast &amp;lt;&lt;/code&gt;new_type&lt;code&gt;&amp;gt; (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reinterpret_cast &amp;lt;&lt;/code&gt; new_type &lt;code&gt;&amp;gt; (&lt;/code&gt; 식 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14460c574491c661c3edad1c4eaa6d0c1d141919" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reinterpret_cast&lt;/code&gt; conversion</source>
          <target state="translated">&lt;code&gt;reinterpret_cast&lt;/code&gt; 변환</target>
        </trans-unit>
        <trans-unit id="9fb828870ecbababc828107487f0641b7befa4b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;parameter-list(optional)&lt;code&gt;)&lt;/code&gt;&lt;code&gt;{ &lt;/code&gt;requirement-seq&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; parameter-list (선택 사항) &lt;code&gt;)&lt;/code&gt; &lt;code&gt;{ &lt;/code&gt; requirements-seq &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d54690ec4ac98e1852dca752d039b531cc70949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt;&lt;code&gt;{ &lt;/code&gt;requirement-seq&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; &lt;code&gt;{ &lt;/code&gt; requirements-seq &lt;code&gt;} &lt;/code&gt; 필요</target>
        </trans-unit>
        <trans-unit id="4effb89389c1532c36384587723fd397983c5c02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt;constraint-expression&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt;constraint-expression&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdf531d04698e1e674e0df4bfd21bfed4b6ed6b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reserve()&lt;/code&gt; cannot be used to reduce the capacity of the container; to that end &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; is provided.</source>
          <target state="translated">&lt;code&gt;reserve()&lt;/code&gt; 를 사용하여 컨테이너 용량을 줄일 수 없습니다. 이를 위해 &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; 이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1c317ad0068ea950a562690062c814fdd39b88a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reserve()&lt;/code&gt; does not change the size of the vector.</source>
          <target state="translated">&lt;code&gt;reserve()&lt;/code&gt; 는 벡터의 크기를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36ee631c57d63311fe1e24caeb9fd6f7f45220bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result_type&lt;/code&gt;(deprecated in C++17)</source>
          <target state="translated">&lt;code&gt;result_type&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="9f29033a26d7952123ef1720a8d7e5f132e49d5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result_type&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;result_type&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음) (C ++ 20에서 제거됨)</target>
        </trans-unit>
        <trans-unit id="ecfcc8cf0eb270aacf613b351daa7c984fd6411a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result_type&lt;/code&gt;(deprecated in c++17)</source>
          <target state="translated">&lt;code&gt;result_type&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="53205186a9d1b9e609da0735d2a91c945832654c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return { &lt;/code&gt;arg1, arg2, ...&lt;code&gt;}&amp;nbsp;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;return { &lt;/code&gt; arg1, arg2, ... &lt;code&gt;}&amp;nbsp;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7a0e4ff406666b99cf5b53f8b57040d63d0d362" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5dfc017bb05e736eb42027876df7331521a9164f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b72d3a462726fd7091404eb215473552ec092f7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reverse_iterator&lt;/code&gt;; &lt;code&gt;const_reverse_iterator&lt;/code&gt; for constant &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reverse_iterator&lt;/code&gt; ; 상수 &lt;code&gt;a&lt;/code&gt; 에 대한 &lt;code&gt;const_reverse_iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf468550f1171a88fbcc93509e42cbedafa6fdad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs.base() - lhs.base()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rhs.base() - lhs.base()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97ca0442554e3e00894e57c816c145d8ef910d43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt; as determined by the owner-based ordering.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; 소유자 기반 주문에 의해 결정된 rhs .</target>
        </trans-unit>
        <trans-unit id="0e60c7bec1515be2c2a36930ced4b3085ed7343d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt; if, and only if, &lt;code&gt;rhs&lt;/code&gt; contains a value and &lt;code&gt;lhs&lt;/code&gt; does not.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; 에 값이 포함되어 있고 &lt;code&gt;lhs&lt;/code&gt; 에 포함 되지 않는 경우에만 &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c174340582093b0d466d6c3647a1351bb9d3ec1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt; if, and only if, both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; do not contain a value.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; , 그리고 경우에만 경우, 모두 &lt;code&gt;lhs&lt;/code&gt; 와 &lt;code&gt;rhs&lt;/code&gt; 값을 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="565957bc63bd899f43c3c7e99a64361f55afc1d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f801c14939021b1abafe3a8ff39f5b5192b017e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt;, an expression such that &lt;code&gt;decltype((rhs))&lt;/code&gt; is &lt;code&gt;RHS&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; , &lt;code&gt;decltype((rhs))&lt;/code&gt; 가 &lt;code&gt;RHS&lt;/code&gt; 인 식 ,</target>
        </trans-unit>
        <trans-unit id="06b8452485cd1012fdc37402144dfc5c1fc47e4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt;, or to the same time point as &lt;code&gt;rhs&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; , 또는 같은 시점에 &lt;code&gt;rhs&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="f75d3402a3e508993184ec535748f1aa5f7fd557" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="ba9ce0fa5cec935b2c8522b016d18d19dd1e12ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rv&lt;/code&gt;, a non-const rvalue of type &lt;code&gt;X::value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; &lt;code&gt;X::value_type&lt;/code&gt; 유형의 비 상수 rvalue</target>
        </trans-unit>
        <trans-unit id="d23ebc7f5ccc22387d2fcae2190fa7ada5611250" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rv&lt;/code&gt;, an &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; expression of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; , 유형 &lt;code&gt;T&lt;/code&gt; 의 &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; 표현식</target>
        </trans-unit>
        <trans-unit id="03db902365c41636203b9c342c8ba4a53c80e104" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rv&lt;/code&gt;, an rvalue of type &lt;code&gt;T&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; , 타입의를 rvalue &lt;code&gt;T&lt;/code&gt; , 및</target>
        </trans-unit>
        <trans-unit id="184f94c984426654bdbda6329a8491ce29b9b1b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s2&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="86bfb8d2d1f71afee842e4a2ab03f528b4510a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;, a value of type &lt;code&gt;CharT*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; &lt;code&gt;CharT*&lt;/code&gt; 유형의 값인 s</target>
        </trans-unit>
        <trans-unit id="d0ab2d78e8c406f38df50f0691bde80be6d60c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;, a value of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 유형 &lt;code&gt;T&lt;/code&gt; 의 값</target>
        </trans-unit>
        <trans-unit id="8db70f70831b4c294a499fa786043548a5c6e2cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;, an object of type &lt;code&gt;X::string_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; , &lt;code&gt;X::string_type&lt;/code&gt; 유형의 객체</target>
        </trans-unit>
        <trans-unit id="26ddc407a8dc737f9234973e0a96e43e6529d514" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scientific|fixed&lt;/code&gt;. Useful for masking operations</source>
          <target state="translated">&lt;code&gt;scientific|fixed&lt;/code&gt; . 마스킹 작업에 유용</target>
        </trans-unit>
        <trans-unit id="3b72e415dad9c30cfbfd7cc356cb8ffee8f09ce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; or, if &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt;, &lt;code&gt;scoped_allocator_adaptor&amp;lt;OuterAlloc&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt; 경우 &lt;code&gt;scoped_allocator_adaptor&amp;lt;OuterAlloc&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb19d02e623ce44c8baceb5958f961c939ef04dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;second_argument_type&lt;/code&gt;(deprecated in C++17)</source>
          <target state="translated">&lt;code&gt;second_argument_type&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="083845aa3ea21544c8ba2547aa3c7c77463199ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;second_argument_type&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;second_argument_type&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음) (C ++ 20에서 제거됨)</target>
        </trans-unit>
        <trans-unit id="f4d51052d4b9993e738ae3d474d50f444db05ed2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;second_argument_type&lt;/code&gt;(deprecated in c++17)</source>
          <target state="translated">&lt;code&gt;second_argument_type&lt;/code&gt; (C ++ 17에서 더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="af796c30ead3a9fdf671d740087f35fb78179325" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds()&lt;/code&gt; returns the integral number of seconds &lt;code&gt;since_midnight&lt;/code&gt; is after &lt;code&gt;(00:00:00 + hours() + minutes())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seconds()&lt;/code&gt; 는 &lt;code&gt;since_midnight&lt;/code&gt; 이 &lt;code&gt;(00:00:00 + hours() + minutes())&lt;/code&gt; 이후 의 정수 (초)를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e84262979b83b06a446439fcf9438a7168d791ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seek_dir&lt;/code&gt;(deprecated)</source>
          <target state="translated">&lt;code&gt;seek_dir&lt;/code&gt;(deprecated)</target>
        </trans-unit>
        <trans-unit id="4ef2fc6bec3d3f6ea251d4cfc5eaea77641e1555" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seekg&lt;/code&gt; behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; is not affected. After constructing and checking the sentry object,</source>
          <target state="translated">&lt;code&gt;seekg&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; 가 영향을받지 않는 것을 제외하고 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 작동 합니다. 센트리 객체를 구성하고 확인한 후</target>
        </trans-unit>
        <trans-unit id="3859b43d876458b72bdd19fcf82fc23176f8083f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seekoff()&lt;/code&gt; is called by &lt;code&gt;std::basic_streambuf::pubseekoff&lt;/code&gt;, which is called by &lt;code&gt;std::basic_istream::seekg&lt;/code&gt;, &lt;code&gt;std::basic_ostream::seekp&lt;/code&gt;, &lt;code&gt;std::basic_istream::tellg&lt;/code&gt;, and &lt;code&gt;std::basic_ostream::tellp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seekoff()&lt;/code&gt; 는 &lt;code&gt;std::basic_streambuf::pubseekoff&lt;/code&gt; 에 의해 호출되며 &lt;code&gt;std::basic_istream::seekg&lt;/code&gt; , &lt;code&gt;std::basic_ostream::seekp&lt;/code&gt; , &lt;code&gt;std::basic_istream::tellg&lt;/code&gt; 및 &lt;code&gt;std::basic_ostream::tellp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57787c098e93d798111197b309a8dfb0121cf24c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seekpos()&lt;/code&gt; is called by &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;std::basic_streambuf::pubseekpos()&lt;/a&gt;&lt;/code&gt;, which is called by the single-argument versions of &lt;code&gt;&lt;a href=&quot;../basic_istream/seekg&quot;&gt;std::basic_istream::seekg()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream/seekp&quot;&gt;std::basic_ostream::seekp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seekpos()&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;std::basic_streambuf::pubseekpos()&lt;/a&gt;&lt;/code&gt; 에 의해 호출되며 &lt;code&gt;&lt;a href=&quot;../basic_istream/seekg&quot;&gt;std::basic_istream::seekg()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_ostream/seekp&quot;&gt;std::basic_ostream::seekp()&lt;/a&gt;&lt;/code&gt; 의 단일 인수 버전에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="be1052ab32228a15576834a15d52cfde8554eb29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setbuf()&lt;/code&gt; may be called after opening the file, but before any I/O (may crash otherwise). With a user-provided buffer, reading from file reads largest multiples of 4096 that fit in the buffer.</source>
          <target state="translated">&lt;code&gt;setbuf()&lt;/code&gt; 는 파일을 연 후 I / O 전에 호출 될 수 있습니다 (그렇지 않으면 충돌이 발생할 수 있음). 사용자가 제공 한 버퍼를 사용하면 파일에서 읽을 때 버퍼에 맞는 4096의 최대 배수를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="f6144b5565e83fdf200e5745c534734a6d046f07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setbuf()&lt;/code&gt; may be called at any time, even after some I/O took place. Current contents of the buffer, if any, are lost.</source>
          <target state="translated">&lt;code&gt;setbuf()&lt;/code&gt; 는 일부 I / O가 발생한 후에도 언제든지 호출 될 수 있습니다. 버퍼의 현재 내용이있는 경우 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="323507d89c10daabb8de88ec6a458b1f6bb35383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setbuf()&lt;/code&gt; may only be called when the &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; is not associated with a file (has no effect otherwise). With a user-provided buffer, reading from file reads &lt;code&gt;n-1&lt;/code&gt; bytes at a time.</source>
          <target state="translated">&lt;code&gt;setbuf()&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 가 파일과 연관되지 않은 경우에만 호출 될 수 있습니다 (그렇지 않으면 영향을주지 않음). 사용자 제공 버퍼를 사용하면 파일에서 읽을 때 한 번에 &lt;code&gt;n-1&lt;/code&gt; 바이트를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="b741f6475a4db6325d4c2a84af32b33137e4f09c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share()&lt;/code&gt; requires &lt;code&gt;valid()&lt;/code&gt; to be &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;share()&lt;/code&gt; 는 &lt;code&gt;valid()&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="a9b9155015e2be62108cf1293fbf94ee9dcaeb29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;short&lt;/code&gt; - target type will be optimized for space and will have width of at least 16 bits.</source>
          <target state="translated">&lt;code&gt;short&lt;/code&gt; - 대상 유형은 공간에 최적화되며 너비는 16 비트 이상입니다.</target>
        </trans-unit>
        <trans-unit id="123cd1b0c99105ee84e7c9596d06e3bc090d142a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;short&lt;/code&gt; type modifier</source>
          <target state="translated">&lt;code&gt;short&lt;/code&gt; 유형 수정 자</target>
        </trans-unit>
        <trans-unit id="00cee6c0e1d6a509e189e8ac023c2419b1eda94d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shuffle_order_engine&lt;/code&gt; is a random number engine adaptor that shuffles the random numbers generated by the base engine. It maintains a table of size &lt;code&gt;K&lt;/code&gt; and delivers a randomly selected number from that table when requested, replacing it with a number generated by the base engine.</source>
          <target state="translated">&lt;code&gt;shuffle_order_engine&lt;/code&gt; 은 기본 엔진에서 생성 된 난수를 섞는 난수 엔진 어댑터입니다. &lt;code&gt;K&lt;/code&gt; 크기의 테이블을 유지 관리하고 요청시 해당 테이블에서 임의로 선택된 숫자를 전달하여 기본 엔진에서 생성 한 숫자로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="91ecdd19dc81d00e8c83ad49e607d64ce37755a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed char*&lt;/code&gt; or &lt;code&gt;unsigned char*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed char*&lt;/code&gt; 또는 &lt;code&gt;unsigned char*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99b1822957ab42790e46e37e8a072c0c142570dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed char&lt;/code&gt; - type for signed character representation.</source>
          <target state="translated">&lt;code&gt;signed char&lt;/code&gt; -부호있는 문자 표현을위한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="596da374058fd7f0afbd5bbfcab7831fa9ecc192" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;signed short&lt;/code&gt; can be converted to &lt;code&gt;int&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;signed char&lt;/code&gt; 또는 &lt;code&gt;signed short&lt;/code&gt; &lt;code&gt;int&lt;/code&gt; 로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97c41131c74026f6e0bd5d8a010afc2374be4c86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed int*&lt;/code&gt; or &lt;code&gt;unsigned int*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed int*&lt;/code&gt; 또는 &lt;code&gt;unsigned int*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="390386b58ee200c58393ed79e778468e78146d2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed long long*&lt;/code&gt; or &lt;code&gt;unsigned long long*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed long long*&lt;/code&gt; 또는 &lt;code&gt;unsigned long long*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c67607f035def4bfabdfda943eebe4134024166f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed long*&lt;/code&gt; or &lt;code&gt;unsigned long*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed long*&lt;/code&gt; 또는 &lt;code&gt;unsigned long*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb4277f86bbc8fa4d2dcac6e5b0970f2986f4dbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed short*&lt;/code&gt; or &lt;code&gt;unsigned short*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed short*&lt;/code&gt; &lt;code&gt;unsigned short*&lt;/code&gt; * 또는 짧은 부호 *</target>
        </trans-unit>
        <trans-unit id="1ebc8f89a2a9e50681b4e5e39d16abf9fa7fa81d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed&lt;/code&gt; - target type will have signed representation (this is the default if omitted)</source>
          <target state="translated">&lt;code&gt;signed&lt;/code&gt; -대상 유형에 부호가있는 표현이 있습니다 (생략하면 기본값 임)</target>
        </trans-unit>
        <trans-unit id="fbc6c6b5d94333cdff627e24c708ccae2b37208c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed&lt;/code&gt; type modifier</source>
          <target state="translated">&lt;code&gt;signed&lt;/code&gt; 유형 수정 자</target>
        </trans-unit>
        <trans-unit id="7b7aafb7a506ca43395920321487c82e485d5bc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size() == 0&lt;/code&gt; (&lt;code&gt;false&lt;/code&gt; if &lt;code&gt;*this&lt;/code&gt; represents the result of a successful match, &lt;code&gt;true&lt;/code&gt; otherwise).</source>
          <target state="translated">&lt;code&gt;size() == 0&lt;/code&gt; ( &lt;code&gt;*this&lt;/code&gt; 성공적인 일치 결과를 나타내는 경우 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 않으면 true )</target>
        </trans-unit>
        <trans-unit id="a0200f935f43d9ea73514596b9949236ec288429" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof(&lt;/code&gt;type&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sizeof(&lt;/code&gt;type&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74f6283da9a908523be109da51f59eccc8b34ea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof(char)&lt;/code&gt;, &lt;code&gt;sizeof(char8_t)&lt;/code&gt;, &lt;code&gt;sizeof(signed char)&lt;/code&gt;, and &lt;code&gt;sizeof(unsigned char)&lt;/code&gt; are always equal to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sizeof(char)&lt;/code&gt; , &lt;code&gt;sizeof(char8_t)&lt;/code&gt; , &lt;code&gt;sizeof(signed char)&lt;/code&gt; 및 &lt;code&gt;sizeof(unsigned char)&lt;/code&gt; 는 항상 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f2d407c4db07ea8eef95042a8a76e72dab2cb554" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof...(&lt;/code&gt;parameter_pack&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sizeof...(&lt;/code&gt;parameter_pack&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d8295868555deebe8ffb79d642c5c679c33ab6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof...(Types) != 1&lt;/code&gt; or</source>
          <target state="translated">&lt;code&gt;sizeof...(Types) != 1&lt;/code&gt; 또는</target>
        </trans-unit>
        <trans-unit id="b2dd33a1c9d816423d275199656286347d3db010" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; and</source>
          <target state="translated">&lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="1cdc29f44e0d0eb9ab54a7720438cfdfe2e6fc57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="fdc4b227ac6249bc4fc72287a6944b2440e3ed95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof&lt;/code&gt;expression</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt;expression</target>
        </trans-unit>
        <trans-unit id="e46af83e16a811405d39a5136eed045dbc6877d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slice_array&lt;/code&gt; to initialize with</source>
          <target state="translated">&lt;code&gt;slice_array&lt;/code&gt; 초기화 할 slice_array</target>
        </trans-unit>
        <trans-unit id="b2bcdf452501c9b678e966ff76f6fd25eca36018" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sp&lt;/code&gt; on success or &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;sp&lt;/code&gt; 성공시 sp 또는 실패시 &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d41a831635e74183514711ce5e212aa8540f055" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;space_info.available&lt;/code&gt; is set to &lt;code&gt;f_bavail*f_frsize&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;space_info.available&lt;/code&gt; 이 &lt;code&gt;f_bavail*f_frsize&lt;/code&gt; 로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="ec90f237c7368e2b51a082ed93cf39569cde5592" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;space_info.capacity&lt;/code&gt; is set as if by &lt;code&gt;f_blocks*f_frsize&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;space_info.capacity&lt;/code&gt; 는 &lt;code&gt;f_blocks*f_frsize&lt;/code&gt; 에 의해 설정됩니다</target>
        </trans-unit>
        <trans-unit id="956d7231f6bf9b016483d7b4a0fed9bae1d5fd31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;space_info.free&lt;/code&gt; is set to &lt;code&gt;f_bfree*f_frsize&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;space_info.free&lt;/code&gt; 가 &lt;code&gt;f_bfree*f_frsize&lt;/code&gt; 로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="8dc60df38163004a901463b4b2e0ee6fa8bba7b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;srand()&lt;/code&gt; is not guaranteed to be thread-safe.</source>
          <target state="translated">&lt;code&gt;srand()&lt;/code&gt; 는 스레드 안전을 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c45e7e857ad07375c7ff6c09de088475818794e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ss&lt;/code&gt; - 2-digit second from &lt;code&gt;timeptr-&amp;gt;tm_sec&lt;/code&gt; as if printed by &lt;code&gt;sprintf&lt;/code&gt; using &lt;code&gt;%.2d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ss&lt;/code&gt; - 2 자리 제 &lt;code&gt;timeptr-&amp;gt;tm_sec&lt;/code&gt; 인쇄 것처럼 &lt;code&gt;sprintf&lt;/code&gt; 를 사용 &lt;code&gt;%.2d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4fa4797d7e4e56c30b5cd6e5451aeccf65e0d28b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ss&lt;/code&gt; - seconds</source>
          <target state="translated">&lt;code&gt;ss&lt;/code&gt; - 초</target>
        </trans-unit>
        <trans-unit id="691d79484e20930f6f97b2512b3af59ec6f01b0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;st.width() - 1&lt;/code&gt; characters are extracted (if &lt;code&gt;st.width()&lt;/code&gt; is greater than zero)</source>
          <target state="translated">&lt;code&gt;st.width() - 1&lt;/code&gt; 문자가 추출됩니다 ( &lt;code&gt;st.width()&lt;/code&gt; 가 0보다 큰 경우)</target>
        </trans-unit>
        <trans-unit id="e6188cc0ce71e5819a7f3d7172eea907c503d273" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;st&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;st&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="6a6533b5d19f97b1c8ec289e396a87c9a7ce3b8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt;, a value of type &lt;code&gt;X::state_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; , &lt;code&gt;X::state_type&lt;/code&gt; 유형의 값</target>
        </trans-unit>
        <trans-unit id="137369e42bcf3ba18490493f75c373a147357d4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="88b6bbcd3ba3cedf0c70220790b608d1076fb3b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; storage specifier</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 스토리지 지정자</target>
        </trans-unit>
        <trans-unit id="900dab33d17ef07271e0d9fbf3a2f564ae5ecbde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;T&lt;code&gt;&amp;amp;&lt;/code&gt;ref&lt;code&gt;= constexpr;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; T &lt;code&gt;&amp;amp;&lt;/code&gt; ref &lt;code&gt;= constexpr;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d44865d23521c1a15985e408614ba223370167e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;Tobject&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt;Tobject&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22c0c82bde8082dbd01c5219ee5de28b24f391b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;Tobject&lt;code&gt;= constexpr;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; Tobject &lt;code&gt;= constexpr;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a8debab36b3f3b8d43751102d5ff3dbd91d63fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;data_member</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt;data_member</target>
        </trans-unit>
        <trans-unit id="76b4ce031d77c4b1820cf9a0abbb850a85584a79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;member_function</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt;member_function</target>
        </trans-unit>
        <trans-unit id="0fe5f8cbf46f1af00de7dfab8a7ed4ac4097a5c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_assert&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;bool_constexpr&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static_assert&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;bool_constexpr&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57cfcccf24b9f4cbd3374f6385c918f0ff932eb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_assert&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;bool_constexpr&lt;code&gt;,&lt;/code&gt;message&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static_assert&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;bool_constexpr&lt;code&gt;,&lt;/code&gt;message&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87e5ec838bed11e196ddefdb9f84a030cef65a17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast &amp;lt;&lt;/code&gt;new_type&lt;code&gt;&amp;gt; (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static_cast &amp;lt;&lt;/code&gt; new_type &lt;code&gt;&amp;gt; (&lt;/code&gt; 식 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a80e989f7fd47ae49da3c00a161119cc065006a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;&lt;/code&gt;T&lt;code&gt;&amp;gt;(&lt;/code&gt;other&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;&lt;/code&gt;T&lt;code&gt;&amp;gt;(&lt;/code&gt;other&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f748d435919e62b9dbcd85bd69ee07adf73ef2a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-1)&lt;/code&gt; if encoding error occurs. Nothing is written to &lt;code&gt;*pwc&lt;/code&gt;, the value &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; is stored in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; and the value of &lt;code&gt;*ps&lt;/code&gt; is left unspecified.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-1)&lt;/code&gt; 인코딩 오류가 발생한 경우 static_cast &amp;lt; std :: size_t &amp;gt; (-1) &lt;code&gt;*pwc&lt;/code&gt; 에 아무것도 기록되지 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; , EILSEQ 값 은 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 에 저장되며 &lt;code&gt;*ps&lt;/code&gt; 값은 지정되지 않은 상태로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdf0510fccd0959ccde826256af53acac868200e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-2)&lt;/code&gt; if the next &lt;code&gt;n&lt;/code&gt; bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to &lt;code&gt;*pwc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-2)&lt;/code&gt; 다음 &lt;code&gt;n&lt;/code&gt; 바이트가 불완전하지만 지금까지 유효한 멀티 바이트 문자를 구성하는 경우 . &lt;code&gt;*pwc&lt;/code&gt; 에 아무것도 기록되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3c1bd3ffc2201dd55a94a0eee33a688ba46753ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(t)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(t)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="33e6b255bed0b5078515f4b4f2bb5ccdef12194b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;To&amp;gt;(fun())&lt;/code&gt; is equal to &lt;code&gt;[]() -&amp;gt; To { return fun(); }()&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;To&amp;gt;(fun())&lt;/code&gt; 은 &lt;code&gt;[]() -&amp;gt; To { return fun(); }()&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="b1d0930f989e7a9b27263d94d9d956f9a433ac9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;typename &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference&lt;/a&gt;&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(t)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;typename &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference&lt;/a&gt;&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(t)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a4a2866542a98e87edaceca4b712cfae49435a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&lt;/code&gt; conversion</source>
          <target state="translated">&lt;code&gt;static_cast&lt;/code&gt; 변환</target>
        </trans-unit>
        <trans-unit id="d8feda07a6b401eca5278d4cf8ec524b614fd12c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&lt;/code&gt; may also be used to disambiguate function overloads by performing a function-to-pointer conversion to specific type, as in.</source>
          <target state="translated">&lt;code&gt;static_cast&lt;/code&gt; 는 함수-포인터를 특정 유형으로 변환하여 함수 과부하를 명확하게하는 데 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="baa3bbadf4fb980e424c228048633bb156a9aad1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::&lt;a href=&quot;same&quot;&gt;Same&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; subsumes &lt;code&gt;std::&lt;a href=&quot;same&quot;&gt;Same&lt;/a&gt;&amp;lt;U, T&amp;gt;&lt;/code&gt; and vice versa.</source>
          <target state="translated">&lt;code&gt;std::&lt;a href=&quot;same&quot;&gt;Same&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; 포섭 &lt;code&gt;std::&lt;a href=&quot;same&quot;&gt;Same&lt;/a&gt;&amp;lt;U, T&amp;gt;&lt;/code&gt; 반대 및 부사장.</target>
        </trans-unit>
        <trans-unit id="ede0befc08584ae7a5fdf3a513d0dcccabc5c6b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::abs&lt;/code&gt; was erroneously required to have overloads for integer types returning &lt;code&gt;double&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::abs&lt;/code&gt; 는 실수로 &lt;code&gt;double&lt;/code&gt; 을 리턴하는 정수 유형에 과부하가 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="6c54c3bc37b2a8917b0fc03bd885ff743f102d0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::accumulate&lt;/code&gt; performs a left fold. In order to perform a right fold, one must reverse the order of the arguments to the binary operator, and use reverse iterators.</source>
          <target state="translated">&lt;code&gt;std::accumulate&lt;/code&gt; 는 왼쪽 접기를 수행합니다. 오른쪽 접기를 수행하려면 인수의 순서를 이진 연산자로 바꾸고 역 반복자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bcc2ebd66f6f03846c63c93062450ad4cf220759" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::add_pointer&lt;/code&gt; was required to produce</source>
          <target state="translated">&lt;code&gt;std::add_pointer&lt;/code&gt; 를 생성해야했습니다.</target>
        </trans-unit>
        <trans-unit id="b1234e7bdd717c6d017d2bb87c22008eb08e0a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::allocator_arg&lt;/code&gt; is a constant of type &lt;code&gt;&lt;a href=&quot;allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;&lt;/code&gt; used to disambiguate, at call site, the overloads of the constructors and member functions of allocator-aware objects, such as &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../thread/packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;, (until C++17)and &lt;code&gt;&lt;a href=&quot;../thread/promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::allocator_arg&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../thread/packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; 와 같은 할당 자 인식 객체의 생성자 및 멤버 함수의 오버로드를 호출 사이트에서 명확하게하는 데 사용되는 &lt;code&gt;&lt;a href=&quot;allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;&lt;/code&gt; 유형의 상수입니다. packaged_task , (C ++ 17까지) 및 &lt;code&gt;&lt;a href=&quot;../thread/promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b0e63dff632dcb321d0e56a33d6d39b1b98452a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::allocator_arg_t&lt;/code&gt; is an empty class type used to disambiguate the overloads of constructors and member functions of allocator-aware objects, including &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../thread/packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;, (until C++17)and &lt;code&gt;&lt;a href=&quot;../thread/promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::allocator_arg_t&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../thread/packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; , (C ++ 17까지) 및 &lt;code&gt;&lt;a href=&quot;../thread/promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; 포함하여 할당 자 인식 객체의 생성자 및 멤버 함수의 과부하를 명확하게하는 데 사용되는 빈 클래스 유형입니다. :: 약속 .</target>
        </trans-unit>
        <trans-unit id="0397b262f2892865e4509d76daa0c90a2aad6b66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::array&lt;/code&gt; is a container that encapsulates fixed size arrays.</source>
          <target state="translated">&lt;code&gt;std::array&lt;/code&gt; 는 고정 크기 배열을 캡슐화하는 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="47bb28b8cd6bf39d74e4ee0354a8fde98b200ce8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::array&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; except that default-constructed array is not empty and that the complexity of swapping is linear, satisfies the requirements of &lt;a href=&quot;../named_req/contiguouscontainer&quot;&gt;ContiguousContainer&lt;/a&gt;,(since C++17) and partially satisfies the requirements of &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::array&lt;/code&gt; 를 만족 요건 &lt;a href=&quot;../named_req/container&quot;&gt;컨테이너&lt;/a&gt; 와 &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; 그 기본적 구성 배열을 제외하고는 비우고되지 스와핑의 복잡성이 선형 인 것을 만족하는 요건 &lt;a href=&quot;../named_req/contiguouscontainer&quot;&gt;ContiguousContainer&lt;/a&gt; , 부분적으로 만족하는 요건 (C ++ 17) 이후 &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76f124fee1f6d404bb5d3c59df3332f4ba0e6997" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atan2(y, x)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../complex/arg&quot;&gt;std::arg&lt;/a&gt;(&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;(x,y))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::atan2(y, x)&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../complex/arg&quot;&gt;std::arg&lt;/a&gt;(&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;(x,y))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbef2b205fea689e577abcebc9dc5b7b84b115b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; was permitted for</source>
          <target state="translated">&lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; 에 대해 허용되었습니다</target>
        </trans-unit>
        <trans-unit id="bb4b933229da7eb89ef0e1d0dba9aa3137507bc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic&amp;lt;bool&amp;gt;&lt;/code&gt; uses the primary template. It is guaranteed to be a standard layout struct.</source>
          <target state="translated">&lt;code&gt;std::atomic&amp;lt;bool&amp;gt;&lt;/code&gt; 은 기본 템플릿을 사용합니다. 표준 레이아웃 구조가 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="4c0b05c455392c723841488c17ad3333763a7b15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;std::atomic&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="4a0803b61a969f4a0731b2365b00b3c8c077e75b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic_flag&lt;/code&gt; is an atomic boolean type. Unlike all specializations of &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;, it is guaranteed to be lock-free. Unlike &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;, &lt;code&gt;std::atomic_flag&lt;/code&gt; does not provide load or store operations.</source>
          <target state="translated">&lt;code&gt;std::atomic_flag&lt;/code&gt; 는 원자 부울 유형입니다. &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 의 모든 전문화와 달리 잠금이없는 것이 보장됩니다. 달리 &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; , &lt;code&gt;std::atomic_flag&lt;/code&gt; 로드 또는 저장 작업을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38cbf066238967320059f92fe8d8095dc30f0a6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic_ref&lt;/code&gt; is &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::atomic_ref&lt;/code&gt; 는 &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c0bec0c1a6726f4ba3ff1919aef2655cc5d1549" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::back_insert_iterator&lt;/code&gt; is an &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that appends to a container for which it was constructed. The container's &lt;code&gt;push_back()&lt;/code&gt; member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::back_insert_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::back_insert_iterator&lt;/code&gt; 는 생성 된 컨테이너에 추가 되는 &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; 입니다. 컨테이너의 &lt;code&gt;push_back()&lt;/code&gt; 멤버 함수는 반복자 (역 참조 여부에 관계없이)가 할당 될 때마다 호출됩니다. 증가 &lt;code&gt;std::back_insert_iterator&lt;/code&gt; 조작은 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ccbe9f22a72664a5718095af50ed8534ef901f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_alloc&lt;/code&gt; is the type of the object thrown as exceptions by the &lt;a href=&quot;operator_new&quot;&gt;allocation functions&lt;/a&gt; to report failure to allocate storage.</source>
          <target state="translated">&lt;code&gt;std::bad_alloc&lt;/code&gt; 은 스토리지 할당 실패를보고하기 위해 &lt;a href=&quot;operator_new&quot;&gt;할당 함수&lt;/a&gt; 에서 예외로 발생하는 오브젝트 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="f894909b251043c10519cdc9419593fbd42c3929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_array_new_length&lt;/code&gt; is the type of the object thrown as exceptions by the &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to report invalid array lengths if.</source>
          <target state="translated">&lt;code&gt;std::bad_array_new_length&lt;/code&gt; 는 잘못된 배열 길이를보고하기 위해 &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt; 에서 예외로 throw 한 오브젝트 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="3cece263d9e71f9d724d7edcfb758b9850990db8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_exception&lt;/code&gt; is the type of the exception thrown by the C++ runtime in the following situations:</source>
          <target state="translated">&lt;code&gt;std::bad_exception&lt;/code&gt; 은 다음과 같은 상황에서 C ++ 런타임에서 발생하는 예외 유형입니다.</target>
        </trans-unit>
        <trans-unit id="326879d3dd40f1fab9d393072c4d721a39f2e130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_function_call&lt;/code&gt; is the type of the exception thrown by &lt;a href=&quot;function/operator()&quot;&gt; &lt;code&gt;std::function::operator()&lt;/code&gt; &lt;/a&gt; if the function wrapper has no target.</source>
          <target state="translated">&lt;code&gt;std::bad_function_call&lt;/code&gt; 은 함수 래퍼에 대상이없는 경우 &lt;a href=&quot;function/operator()&quot;&gt; &lt;code&gt;std::function::operator()&lt;/code&gt; &lt;/a&gt; 발생하는 예외 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="f6aa2069b29e331b758f7a814d4a7763e6d6f81f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_variant_access&lt;/code&gt; is the type of the exception thrown in the following situations:</source>
          <target state="translated">&lt;code&gt;std::bad_variant_access&lt;/code&gt; 는 다음 상황에서 발생하는 예외 유형입니다.</target>
        </trans-unit>
        <trans-unit id="36ec4a07aa10ab404e6cd9a170ecee64252fa5a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_weak_ptr&lt;/code&gt; is the type of the object thrown as exceptions by the constructors of &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; that take &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; as the argument, when the &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; refers to an already deleted object.</source>
          <target state="translated">&lt;code&gt;std::bad_weak_ptr&lt;/code&gt; 의 생성자에 의해 예외로 던져 개체의 유형 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 이 걸릴 &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 하여 인수로 &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 이미 삭제 된 개체를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c6230cfe80f845737eb67452ccf7bbac692f90ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_filebuf&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; whose associated character sequence is a file. Both the input sequence and the output sequence are associated with the same file, and a joint file position is maintained for both operations.</source>
          <target state="translated">&lt;code&gt;std::basic_filebuf&lt;/code&gt; 는 연관된 문자 순서가 파일 인 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 입니다. 입력 순서와 출력 순서는 모두 동일한 파일과 연관되어 있으며 두 파일의 결합 파일 위치가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4fe3a0b10ce1dabce9f14a49bd17e9baca64483c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_osyncstream&lt;/code&gt;, &lt;code&gt;std::basic_syncbuf&lt;/code&gt;, and typedefs</source>
          <target state="translated">&lt;code&gt;std::basic_osyncstream&lt;/code&gt; , &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 및 typedefs</target>
        </trans-unit>
        <trans-unit id="3462726fed80b85e9359be5d293b2169b295577d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_string&lt;/code&gt; and &lt;code&gt;std::sub_match&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::basic_string&lt;/code&gt; 및 &lt;code&gt;std::sub_match&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34319833fb2ad6fb976269b586a465fcfaea3aaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_string&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;and &lt;a href=&quot;../named_req/contiguouscontainer&quot;&gt;ContiguousContainer&lt;/a&gt;(since C++17).</source>
          <target state="translated">&lt;code&gt;std::basic_string&lt;/code&gt; 은 &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; 및 &lt;a href=&quot;../named_req/contiguouscontainer&quot;&gt;ContiguousContainer&lt;/a&gt; (C ++ 17부터) 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="25042ac23a934cf1670e58afd01a08f042989654" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_string_view&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;std::basic_string_view&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="5c74e2a9de4dbc23d6fdac9505857cb54752ed5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_stringbuf&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; whose associated character sequence is a memory-resident sequence of arbitrary characters, which can be initialized from or made available as an instance of &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_stringbuf&lt;/code&gt; 되는 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 그 연관 문자 시퀀스에서의 초기화 또는 인스턴스로서 사용할 수 문자, 임의의 메모리 상주 시퀀스 인 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2f68bb275827e707542a32b2132fc70d0be8bf8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_syncbuf&lt;/code&gt; is a wrapper for a &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; (provided at construction time as a pointer). It accumulates output in its own internal buffer, and atomically transmits its entire contents to the wrapped buffer on destruction and when explicitly requested, so that they appear as a contiguous sequence of characters. It guarantees that there are no data races and no interleaving of characters sent to the wrapped buffer as long as all other outputs made to the same buffer are made through, possibly different, instances of &lt;code&gt;std::basic_syncbuf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_syncbuf&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; (구성시 포인터로 제공됨 )의 래퍼입니다 . 자체 내부 버퍼에 출력을 누적하고 소멸시 및 명시 적으로 요청 될 때 전체 내용을 랩핑 된 버퍼로 원자 적으로 전송하여 연속적인 문자 시퀀스로 표시합니다. 동일한 버퍼에 대한 다른 모든 출력이 다른 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 인스턴스를 통해 생성되는 한 데이터 레이스가없고 랩핑 된 버퍼로 전송되는 문자의 인터리빙이 없음을 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="fd83eadd1fc2d1f8db155ac3d34318bc1cf56684" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_syncbuf&lt;/code&gt; objects whose states to swap</source>
          <target state="translated">&lt;code&gt;std::basic_syncbuf&lt;/code&gt; 상태를 교환 할 std :: basic_syncbuf 객체</target>
        </trans-unit>
        <trans-unit id="97f580905e381c907d981e60e66970e721b2cc85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bernoulli_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::bernoulli_distribution&lt;/code&gt; &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;bernoulli_distribution&lt;/a&gt; 은 RandomNumberDistribution을 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="43c36891564fc4f7245b7b75bc84f9cba02ebeba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bind_front&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; provide support for &lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;partial function application&lt;/a&gt;, i.e. binding arguments to functions to produce new functions.</source>
          <target state="translated">&lt;code&gt;std::bind_front&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;부분 함수 응용 프로그램을&lt;/a&gt; 지원 합니다 . 즉, 함수에 인수를 바인딩하여 새 함수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="23785313d052adc0763e422629822ed2e8e29065" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::binomial_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::binomial_distribution&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution을&lt;/a&gt; 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="a9224a909447446235fdc4fa450b3009f5990c5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bit_xor&amp;lt;&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;std::bit_xor&lt;/code&gt; with parameter and return type deduced.</source>
          <target state="translated">&lt;code&gt;std::bit_xor&amp;lt;&amp;gt;&lt;/code&gt; 는 매개 변수 및 리턴 유형이 추론 된 &lt;code&gt;std::bit_xor&lt;/code&gt; 의 특수화입니다 .</target>
        </trans-unit>
        <trans-unit id="32ab0725b4937789956cd3134e83f4fc6bca42ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::boolalpha&lt;/code&gt; is an I/O manipulator, so it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::boolalpha&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::boolalpha&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::boolalpha&lt;/code&gt; 그것과 같은 식으로 호출 할 수 있도록 I / O 조작 장치이며, &lt;code&gt;out &amp;lt;&amp;lt; std::boolalpha&lt;/code&gt; 임의위한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 또는 이런 식 &lt;code&gt;in &amp;gt;&amp;gt; std::boolalpha&lt;/code&gt; 어떤을 위해 &lt;code&gt;in&lt;/code&gt; 유형의 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97d1b1f997f3c874053645c2d47ec851fbbaffec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::byte&lt;/code&gt; is a distinct type that implements the concept of byte as specified in the C++ language definition.</source>
          <target state="translated">&lt;code&gt;std::byte&lt;/code&gt; 는 C ++ 언어 정의에 지정된 바이트 개념을 구현하는 고유 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e846956a578897f5a7e8147360b6876f9d4a4e1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::calloc&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;std::realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt;(since C++17), &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::calloc&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;std::realloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt; (C ++ 17부터), &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c2b3f8186c4392f51363031a506c5b7fef66d2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::cauchy_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::cauchy_distribution&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution의&lt;/a&gt; 모든 요구 사항을 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="22639445336d9d5d493d71fecd2210de50ce3b9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::cbrt(arg)&lt;/code&gt; is not equivalent to &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;(arg, 1.0/3)&lt;/code&gt; because &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; cannot raise a negative base to a fractional exponent.</source>
          <target state="translated">&lt;code&gt;std::cbrt(arg)&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; 는 음의 밑을 소수 지수로 올릴 수 없기 때문에 std :: cbrt (arg) 는 &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;(arg, 1.0/3)&lt;/code&gt; 와 동일 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3ec330bf10bf64cd6976f9f6cdbde763a641535" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chi_squared_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::chi_squared_distribution&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution의&lt;/a&gt; 모든 요구 사항을 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f3e8cbc766caa8d1c32abffb171a8a2c76a622ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::clock_time_conversion&lt;/code&gt; is a trait that specifies how to convert a &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;Source&lt;/code&gt; clock to that of the &lt;code&gt;Dest&lt;/code&gt; clock. It does so by providing an const-callable &lt;code&gt;operator()&lt;/code&gt; that accepts an argument of type &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Source, Duration&amp;gt;&lt;/code&gt; and returns a &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Dest, OtherDuration&amp;gt;&lt;/code&gt; that represents an equivalent point in time. The duration of the returned time point is computed from the source duration in a manner that varies for each specialization. &lt;code&gt;clock_time_conversion&lt;/code&gt; is normally only used indirectly, via &lt;code&gt;std::chrono::clock_cast&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::chrono::clock_time_conversion&lt;/code&gt; 은 &lt;code&gt;Source&lt;/code&gt; 클록 의 &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;Dest&lt;/code&gt; 클록 으로 변환하는 방법을 지정하는 특성입니다 . &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Source, Duration&amp;gt;&lt;/code&gt; &amp;lt;Source, Duration&amp;gt; 유형의 인수를 허용 하고 동등한 점을 나타내는 &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Dest, OtherDuration&amp;gt;&lt;/code&gt; &amp;lt;Dest, OtherDuration&amp;gt; 을 리턴 하는 const-callable &lt;code&gt;operator()&lt;/code&gt; 를 제공하여 이를 수행합니다. 제 시간에. 리턴 된 시점의 지속 시간은 각 전문화에 따라 달라지는 방식으로 소스 지속 시간으로부터 계산됩니다. &lt;code&gt;clock_time_conversion&lt;/code&gt; 은 일반적으로 &lt;code&gt;std::chrono::clock_cast&lt;/code&gt; 를 통해 간접적으로 만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f045d2731dae7d9a2469f88b10eff5dd32f72004" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::days&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::chrono::days&lt;/code&gt; (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="2ea4b95a0683371b2f9ca49e28e41457c8ef2523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::file_clock&lt;/code&gt; is an alias for the clock used for &lt;code&gt;&lt;a href=&quot;../filesystem/file_time_type&quot;&gt;std::filesystem::file_time_type&lt;/a&gt;&lt;/code&gt;. Its epoch is unspecified.</source>
          <target state="translated">&lt;code&gt;std::chrono::file_clock&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../filesystem/file_time_type&quot;&gt;std::filesystem::file_time_type&lt;/a&gt;&lt;/code&gt; 사용되는 시계의 별명입니다 . 그 시대는 지정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e125350fc562e970446db9758feb9b73754284bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::high_resolution_clock&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::chrono::high_resolution_clock&lt;/code&gt; 은 &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="df728f8be5b4f6a57be6ab7ff93578a6707a0ae0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::last&lt;/code&gt;, for the last day of the month;</source>
          <target state="translated">&lt;code&gt;std::chrono::last&lt;/code&gt; , 매월 마지막 날;</target>
        </trans-unit>
        <trans-unit id="0127b3d83922034df1531223fe21706512bf36a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::months&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::chrono::months&lt;/code&gt; (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="5d887bf37e598dda8d113c25633ab88f4cb13600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::steady_clock&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::chrono::steady_clock&lt;/code&gt; 은 &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="52324f00eaa15e4cdc6c43217ed2771a102427a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::system_clock&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::chrono::system_clock&lt;/code&gt; 은 &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="7fc04ed7e313d32198d59c13b4792d1b0b173e71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::weeks&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::chrono::weeks&lt;/code&gt; (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="9ac4f34b32160656cbecc98a1ee4572f732b67f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::years&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::chrono::years&lt;/code&gt; (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="bfa5e06d771be8d4f6dc7663237bbe9daf5d82bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::years&lt;/code&gt;- and &lt;code&gt;std::chrono::months&lt;/code&gt;-oriented arithmetic are supported directly. An implicit conversion to &lt;code&gt;std::chrono::sys_days&lt;/code&gt; allows &lt;code&gt;std::chrono::days&lt;/code&gt;-oriented arithmetic to be performed efficiently.</source>
          <target state="translated">&lt;code&gt;std::chrono::years&lt;/code&gt; 및 &lt;code&gt;std::chrono::months&lt;/code&gt; 지향 산술이 직접 지원됩니다. &lt;code&gt;std::chrono::sys_days&lt;/code&gt; 암시 적으로 변환 하면 &lt;code&gt;std::chrono::days&lt;/code&gt; 지향 산술을 효율적으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5484ab6c0379a27fdb71488f7d15e044a76eb4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono&lt;/code&gt; library</source>
          <target state="translated">&lt;code&gt;std::chrono&lt;/code&gt; 라이브러리</target>
        </trans-unit>
        <trans-unit id="4d296ea5863ff7b777d56292c8433e0452f6c6fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::codecvt_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet which encapsulates multibyte/wide character conversion rules of a locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::codecvt_byname&lt;/code&gt; 은 구성시 지정된 로케일의 멀티 바이트 / 와이드 문자 변환 규칙을 캡슐화 하는 &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 패싯입니다.</target>
        </trans-unit>
        <trans-unit id="b7dd739f104fae21a79d350564d83476981e9e5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::codecvt_utf16&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet which encapsulates conversion between a UTF-16 encoded byte string and UCS2 or UTF-32 character string (depending on the type of &lt;code&gt;Elem&lt;/code&gt;). This codecvt facet can be used to read and write UTF-16 files in binary mode.</source>
          <target state="translated">&lt;code&gt;std::codecvt_utf16&lt;/code&gt; 은 UTF-16으로 인코딩 된 바이트 문자열과 UCS2 또는 UTF-32 문자열 사이의 변환을 캡슐화 하는 &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 패싯입니다 ( &lt;code&gt;Elem&lt;/code&gt; 유형에 따라 다름 ). 이 codecvt 패싯을 사용하여 UTF-16 파일을 2 진 모드로 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29c174bd3330ba8bf72caa31f7b6b42fa1d9156b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::codecvt_utf8&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet which encapsulates conversion between a UTF-8 encoded byte string and UCS2 or UTF-32 character string (depending on the type of &lt;code&gt;Elem&lt;/code&gt;). This codecvt facet can be used to read and write UTF-8 files, both text and binary.</source>
          <target state="translated">&lt;code&gt;std::codecvt_utf8&lt;/code&gt; 은 UTF-8로 인코딩 된 바이트 문자열과 UCS2 또는 UTF-32 문자열 사이의 변환을 캡슐화 하는 &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 패싯입니다 ( &lt;code&gt;Elem&lt;/code&gt; 유형에 따라 다름 ). 이 codecvt 패싯은 텍스트와 이진 모두 UTF-8 파일을 읽고 쓰는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f832b9bf45eec9f2f115b12128fe723b4c68cfe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::codecvt_utf8_utf16&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet which encapsulates conversion between a UTF-8 encoded byte string and UTF-16 encoded character string. If &lt;code&gt;Elem&lt;/code&gt; is a 32-bit type, one UTF-16 code unit will be stored in each 32-bit character of the output sequence.</source>
          <target state="translated">&lt;code&gt;std::codecvt_utf8_utf16&lt;/code&gt; 은 UTF-8 인코딩 된 바이트 문자열과 UTF-16 인코딩 된 문자열 간의 변환을 캡슐화 하는 &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 패싯입니다. 경우 &lt;code&gt;Elem&lt;/code&gt; 모델은 32 비트 타입 번 UTF-16 코드 부는 출력 시퀀스의 각 32 비트 문자를 저장한다.</target>
        </trans-unit>
        <trans-unit id="a27e5fee138f572ad520ea598cf73bc2e8e68699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::collate_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet which encapsulates locale-specific collation (comparison) and hashing of strings. Just like &lt;code&gt;&lt;a href=&quot;collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt;, it can be imbued in &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt; and applied, by means of &lt;code&gt;std::locale::operator()&lt;/code&gt;, directly to all standard algorithms that expect a string comparison predicate.</source>
          <target state="translated">&lt;code&gt;std::collate_byname&lt;/code&gt; 은 로케일 특정 데이터 정렬 (비교) 및 문자열 해시를 캡슐화 하는 &lt;code&gt;&lt;a href=&quot;collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; 패싯입니다. 마찬가지로 &lt;code&gt;&lt;a href=&quot;collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; , 그것은에 물든 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt; 과의 수단으로 적용 &lt;code&gt;std::locale::operator()&lt;/code&gt; 직접 문자열 비교 술어를 기대하는 모든 표준 알고리즘.</target>
        </trans-unit>
        <trans-unit id="f0fee92b6a576e7386950be6f1be627eb62f33db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::condition_variable&lt;/code&gt; works only with &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&amp;lt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&amp;gt;&lt;/code&gt;; this restriction allows for maximal efficiency on some platforms. &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; provides a condition variable that works with any &lt;a href=&quot;../named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; object, such as &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::condition_variable&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&amp;lt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&amp;gt;&lt;/code&gt; 에서만 작동합니다 . 이 제한은 일부 플랫폼에서 최대 효율성을 허용합니다. &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; 과 같은 &lt;a href=&quot;../named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; 객체 와 작동하는 조건 변수를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="7a09cabee8cc7327ea6113cf876758db70326f71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::condition_variable_any&lt;/code&gt; can be used with &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; in order to wait on a &lt;code&gt;&lt;a href=&quot;shared_mutex&quot;&gt;std::shared_mutex&lt;/a&gt;&lt;/code&gt; in shared ownership mode.</source>
          <target state="translated">&lt;code&gt;std::condition_variable_any&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; 과 함께 사용하여 공유 소유권 모드에서 &lt;code&gt;&lt;a href=&quot;shared_mutex&quot;&gt;std::shared_mutex&lt;/a&gt;&lt;/code&gt; 를 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da285dc396f63c6f4370c85412e3bf4c8b70288c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::copysign&lt;/code&gt; is the only portable way to manipulate the sign of a NaN value (to examine the sign of a NaN, &lt;code&gt;signbit&lt;/code&gt; may also be used).</source>
          <target state="translated">&lt;code&gt;std::copysign&lt;/code&gt; 은 NaN 값의 부호를 조작 할 수있는 유일한 방법입니다 (NaN 부호를 검사하기 위해 부호 &lt;code&gt;signbit&lt;/code&gt; 도 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="dec4cfaf4dd31be3402d0290d7bcf0c2cda100d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ctype_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet which encapsulates character classification rules of the locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::ctype_byname&lt;/code&gt; 은 구성시 지정된 로케일의 문자 분류 규칙을 캡슐화 하는 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯입니다.</target>
        </trans-unit>
        <trans-unit id="48d133c7dc05905738abe26c5cc2610f78667ed8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::cv_status&lt;/code&gt; is used by the &lt;code&gt;wait_for&lt;/code&gt; and &lt;code&gt;wait_until&lt;/code&gt; methods of &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::cv_status&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;wait_for&lt;/code&gt; 및 &lt;code&gt;wait_until&lt;/code&gt; 메소드에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="78c2046db037983cb249ce8d08603b36997f911a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::default_delete&lt;/code&gt; is the default destruction policy used by &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; when no deleter is specified.</source>
          <target state="translated">&lt;code&gt;std::default_delete&lt;/code&gt; 는 삭제자가 지정되지 않은 경우 &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 사용하는 기본 삭제 정책 입니다.</target>
        </trans-unit>
        <trans-unit id="11ee961a9fe952865469b5b1362eb3a6d1138456" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::defer_lock&lt;/code&gt;, &lt;code&gt;std::try_to_lock&lt;/code&gt; and &lt;code&gt;std::adopt_lock&lt;/code&gt; are instances of empty struct tag types &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::defer_lock_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::try_to_lock_t&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::adopt_lock_t&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;std::defer_lock&lt;/code&gt; , &lt;code&gt;std::try_to_lock&lt;/code&gt; 및 &lt;code&gt;std::adopt_lock&lt;/code&gt; 은 각각 빈 구조체 태그 유형 &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::defer_lock_t&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::try_to_lock_t&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::adopt_lock_t&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff534366543af0ca822f02d2f5404431b0438911" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::defer_lock_t&lt;/code&gt;, &lt;code&gt;std::try_to_lock_t&lt;/code&gt; and &lt;code&gt;std::adopt_lock_t&lt;/code&gt; are empty struct tag types used to specify locking strategy for &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::scoped_lock&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::defer_lock_t&lt;/code&gt; , &lt;code&gt;std::try_to_lock_t&lt;/code&gt; 및 &lt;code&gt;std::adopt_lock_t&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::scoped_lock&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; 대한 잠금 전략을 지정하는 데 사용되는 빈 구조체 태그 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="a5ba3a6548fd85a605db2a04aef9e451efc0f9a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::deque&lt;/code&gt; (double-ended queue) is an indexed sequence container that allows fast insertion and deletion at both its beginning and its end. In addition, insertion and deletion at either end of a deque never invalidates pointers or references to the rest of the elements.</source>
          <target state="translated">&lt;code&gt;std::deque&lt;/code&gt; (double-ended queue)는 시작과 끝 모두에서 빠르게 삽입하고 삭제할 수있는 인덱스 시퀀스 컨테이너입니다. 또한, deque의 끝에 삽입 및 삭제가 나머지 요소에 대한 포인터 또는 참조를 무효화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac7511003a8120ef1ac2ae270a948663e03c1233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::deque&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::deque&lt;/code&gt; 는 &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; , &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; 및 &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; 의 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="cd1189e9a91c6fd7c0c352263f9b637a6e4ec29e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::discrete_distribution&lt;/code&gt; produces random integers on the interval &lt;code&gt;[0, n)&lt;/code&gt;, where the probability of each individual integer &lt;code&gt;i&lt;/code&gt; is defined as w</source>
          <target state="translated">&lt;code&gt;std::discrete_distribution&lt;/code&gt; 은 &lt;code&gt;[0, n)&lt;/code&gt; 간격에서 임의의 정수를 생성하며 , 여기서 각 개별 정수 &lt;code&gt;i&lt;/code&gt; 의 확률은 w로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="73b9063244eaf29698d1ce46baf9783f844ba9e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::discrete_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::discrete_distribution&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution의&lt;/a&gt; 모든 요구 사항을 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="babc06a10c9c15005fb04a3d088bf1290c70919d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::dynamic_extent&lt;/code&gt; is a constant of type &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; that is used to differentiate &lt;a href=&quot;../span&quot;&gt;&lt;code&gt;std::span&lt;/code&gt;&lt;/a&gt; of static and dynamic extent.</source>
          <target state="translated">&lt;code&gt;std::dynamic_extent&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 유형의 상수 이며 정적 및 동적 범위의 &lt;a href=&quot;../span&quot;&gt; &lt;code&gt;std::span&lt;/code&gt; &lt;/a&gt; 을 구별하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0c7ae6a02052d574c16ef064424d6bdfd3ac30f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::enable_shared_from_this&lt;/code&gt; allows an object &lt;code&gt;t&lt;/code&gt; that is currently managed by a &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; named &lt;code&gt;pt&lt;/code&gt; to safely generate additional &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; instances &lt;code&gt;pt1, pt2, ...&lt;/code&gt; that all share ownership of &lt;code&gt;t&lt;/code&gt; with &lt;code&gt;pt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::enable_shared_from_this&lt;/code&gt; 개체 수 &lt;code&gt;t&lt;/code&gt; 현재에 의해 관리되는 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 이름 &lt;code&gt;pt&lt;/code&gt; 안전하게 추가 생성에 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 인스턴스는 &lt;code&gt;pt1, pt2, ...&lt;/code&gt; 의 모든 지분이 &lt;code&gt;t&lt;/code&gt; 와 &lt;code&gt;pt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b225dda4f3adfeaed7ea510758b565e3aecef23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::equal&lt;/code&gt; should not be used to compare the ranges formed by the iterators from &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; because the order in which the elements are stored in those containers may be different even if the two containers store the same elements.</source>
          <target state="translated">&lt;code&gt;std::equal&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; 에서 반복자에 의해 형성된 범위를 비교하는 데 사용해서는 안됩니다 . 요소가 해당 컨테이너에 저장된 순서는 두 컨테이너가 동일한 요소를 저장하더라도 달라집니다.</target>
        </trans-unit>
        <trans-unit id="632f518e0f97f3ba086be4ec5a62bb8100c02856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::error_category&lt;/code&gt; serves as the base class for specific error category types, such as &lt;code&gt;&lt;a href=&quot;system_category&quot;&gt;std::system_category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/iostream_category&quot;&gt;std::iostream_category&lt;/a&gt;&lt;/code&gt;, etc. Each specific category class defines the &lt;code&gt;error_code&lt;/code&gt; - &lt;code&gt;error_condition&lt;/code&gt; mapping and holds the explanatory strings for all error_conditions. The objects of error category classes are treated as singletons, passed by reference.</source>
          <target state="translated">&lt;code&gt;std::error_category&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;system_category&quot;&gt;std::system_category&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/iostream_category&quot;&gt;std::iostream_category&lt;/a&gt;&lt;/code&gt; 등과 같은 특정 오류 범주 유형의 기본 클래스로 사용됩니다 . 각 특정 범주 클래스는 &lt;code&gt;error_code&lt;/code&gt; - &lt;code&gt;error_condition&lt;/code&gt; 맵핑을 정의하고 모든 error_condition에 대한 설명 문자열을 보유합니다. 오류 범주 클래스의 개체는 참조로 전달 된 싱글 톤으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="fac9c199fb321fcb496aead48672d7b130b469fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::error_code&lt;/code&gt; is a platform-dependent error code. Each &lt;code&gt;std::error_code&lt;/code&gt; object holds an error code originating from the operating system or some low-level interface and a pointer to an object of type &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;, which corresponds to the said interface. The error code values may be not unique across different error categories.</source>
          <target state="translated">&lt;code&gt;std::error_code&lt;/code&gt; 는 플랫폼에 따른 오류 코드입니다. 각 &lt;code&gt;std::error_code&lt;/code&gt; 오브젝트는 운영 체제 또는 일부 저수준 인터페이스에서 발생하는 오류 코드와 &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; 유형의 오브젝트에 대한 포인터를 보유하며 , 이는 해당 인터페이스에 해당합니다. 오류 코드 값은 다른 오류 범주에서 고유하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f695bdc00126c7ac476d86d0fb6b8427fd15538f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::error_condition&lt;/code&gt; is a platform-independent error code. Like &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;, it is uniquely identified by an integer value and a &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;, but unlike &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;, the value is not platform-dependent.</source>
          <target state="translated">&lt;code&gt;std::error_condition&lt;/code&gt; 은 플랫폼 독립적 오류 코드입니다. &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 정수 값과 &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; 로 고유하게 식별 되지만 &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 와 달리 값은 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d8e8654c75557ba66cb78816d2393b7f829e6472" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::exception_ptr&lt;/code&gt; is a nullable pointer-like type that manages an exception object which has been thrown and captured with &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;. An instance of &lt;code&gt;std::exception_ptr&lt;/code&gt; may be passed to another function, possibly on another thread, where the exception may be rethrown and handled with a catch clause.</source>
          <target state="translated">&lt;code&gt;std::exception_ptr&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; 으로 발생 및 캡처 된 예외 오브젝트를 관리하는 널 입력 가능 포인터 유사 유형입니다 . &lt;code&gt;std::exception_ptr&lt;/code&gt; 의 인스턴스는 다른 스레드에서 다른 함수로 전달 될 수 있으며 예외는 catch 절로 다시 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14b49292590a444036557cbbbda93f38fff8d1b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::exception_ptr&lt;/code&gt; is not implicitly convertible to any arithmetic, enumeration, or pointer type. It is contextually convertible to &lt;code&gt;bool&lt;/code&gt;, and will evaluate to false if it is null, true otherwise.</source>
          <target state="translated">&lt;code&gt;std::exception_ptr&lt;/code&gt; 은 암시 적으로 산술, 열거 또는 포인터 유형으로 변환 할 수 없습니다. 문맥 상으로 &lt;code&gt;bool&lt;/code&gt; 로 변환 가능하고 , null의 경우는 false, 그렇지 않은 경우는 true로 평가됩니다</target>
        </trans-unit>
        <trans-unit id="57641bf827fb4f30125de277f6b3255d2e659787" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::exception_ptr&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::exception_ptr&lt;/code&gt; 은 &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt; 의 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="9855684a30c9ba5dfd239066f3ae8f0d65a98657" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::execution::seq&lt;/code&gt;, &lt;code&gt;std::execution::par&lt;/code&gt;, &lt;code&gt;std::execution::par_unseq&lt;/code&gt;, and &lt;code&gt;std::execution::unseq&lt;/code&gt; are instances of the execution policy types &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::sequenced_policy&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::parallel_policy&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::parallel_unsequenced_policy&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;std::execution::unsequenced_policy&lt;/code&gt; respectively. They are used to specify the execution policy of parallel algorithms - i.e., the kinds of parallelism allowed.</source>
          <target state="translated">&lt;code&gt;std::execution::seq&lt;/code&gt; , &lt;code&gt;std::execution::par&lt;/code&gt; , &lt;code&gt;std::execution::par_unseq&lt;/code&gt; 및 &lt;code&gt;std::execution::unseq&lt;/code&gt; 는 실행 정책 유형 &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::sequenced_policy&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::parallel_policy&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::parallel_unsequenced_policy&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;std::execution::unsequenced_policy&lt;/code&gt; 각각. 병렬 알고리즘의 실행 정책, 즉 허용되는 병렬 처리의 종류를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f81f924ab5fb012ab97a4c81941f6da54601b41c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::exponential_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::exponential_distribution&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution을&lt;/a&gt; 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="731f75b5983a917cf59abfe73aa61c1e6683808d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::extreme_value_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::extreme_value_distribution&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution의&lt;/a&gt; 모든 요구 사항을 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="6b45df502c8abb6d9404ea462f3d01ebde814a38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::fisher_f_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::fisher_f_distribution&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution의&lt;/a&gt; 모든 요구 사항을 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f4c4072e32a83cf416dd9cce5e53d8848117eccb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::fmod&lt;/code&gt;, but not &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt; is useful for doing silent wrapping of floating-point types to unsigned integer types: &lt;code&gt;(0.0 &amp;lt;= (y = std::fmod( &lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;(x), 65536.0 )) ? y : 65536.0 + y)&lt;/code&gt; is in the range &lt;code&gt;[-0.0 .. 65535.0]&lt;/code&gt;, which corresponds to &lt;code&gt;unsigned short&lt;/code&gt;, but &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;(&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;(x), 65536.0&lt;/code&gt; is in the range &lt;code&gt;[-32767.0, +32768.0]&lt;/code&gt;, which is outside of the range of &lt;code&gt;signed short&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::fmod&lt;/code&gt; 이지만 &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt; 는 부동 소수점 유형을 부호없는 정수 유형으로 자동 줄 바꿈하는 데 유용합니다. &lt;code&gt;(0.0 &amp;lt;= (y = std::fmod( &lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;(x), 65536.0 )) ? y : 65536.0 + y)&lt;/code&gt; 는 &lt;code&gt;[-0.0 .. 65535.0]&lt;/code&gt; 범위에 있으며 &lt;code&gt;unsigned short&lt;/code&gt; 해당 하지만 &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;(&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;(x), 65536.0&lt;/code&gt; 은 &lt;code&gt;[-32767.0, +32768.0]&lt;/code&gt; 범위에 있습니다 . ] , &lt;code&gt;signed short&lt;/code&gt; 범위를 벗어납니다 .</target>
        </trans-unit>
        <trans-unit id="cbfadbd0a7ccd1e3ec0ee00d99bda6db1cc5ccdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::forward_list&lt;/code&gt; is a container that supports fast insertion and removal of elements from anywhere in the container. Fast random access is not supported. It is implemented as a singly-linked list and essentially does not have any overhead compared to its implementation in C. Compared to &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; this container provides more space efficient storage when bidirectional iteration is not needed.</source>
          <target state="translated">&lt;code&gt;std::forward_list&lt;/code&gt; 는 컨테이너의 어느 곳에서나 요소를 빠르게 삽입하고 제거하는 것을 지원하는 컨테이너입니다. 빠른 임의 액세스는 지원되지 않습니다. 단일 연결 목록으로 구현되며 기본적으로 C에서의 구현에 비해 오버 헤드가 없습니다. &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 와 비교 하여이 컨테이너는 양방향 반복이 필요하지 않을 때 더 공간 효율적인 저장 공간을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c2ebf9e9e435ee3056ad9fc9787f7844dacc9bd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::forward_list&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; (except for the &lt;code&gt;size&lt;/code&gt; member function and that &lt;code&gt;operator==&lt;/code&gt;'s complexity is always linear), &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::forward_list&lt;/code&gt; 는 &lt;a href=&quot;../named_req/container&quot;&gt;컨테이너&lt;/a&gt; 의 요구 사항을 충족합니다 ( &lt;code&gt;size&lt;/code&gt; 멤버 함수를 제외하고 &lt;code&gt;operator==&lt;/code&gt; 의 복잡성이 항상 선형 임), &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; 및 &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7837beae5eb8318478a03816d5fe69264da35bd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::front_insert_iterator&lt;/code&gt; is an &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that prepends elements to a container for which it was constructed. The container's &lt;code&gt;push_front()&lt;/code&gt; member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::front_insert_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::front_insert_iterator&lt;/code&gt; 는 생성 된 컨테이너 앞에 요소를 추가 하는 &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; 입니다. 컨테이너의 &lt;code&gt;push_front()&lt;/code&gt; 멤버 함수는 반복자 (역 참조 여부에 관계없이)가 할당 될 때마다 호출됩니다. 증가 &lt;code&gt;std::front_insert_iterator&lt;/code&gt; 조작은 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a292140cf981fe03ff447787efd5c8db75cd6be5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt; results in &lt;code&gt;&lt;a href=&quot;bad_function_call&quot;&gt;std::bad_function_call&lt;/a&gt;&lt;/code&gt; exception being thrown.</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;bad_function_call&quot;&gt;std::bad_function_call&lt;/a&gt;&lt;/code&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="a3ae0891ae968af55946d0eb13471e46bd7151c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 의 요구 사항을 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="2c5b3f73ed92b9406389fdf0d10ca68e16404c14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt; to compare</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; 비교</target>
        </trans-unit>
        <trans-unit id="a327e115acfa4ae14e0d19493fc8762f3f4abead" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt;'s allocator support was poorly specified and inconsistently implemented. Some implementations do not provide overloads (6-10) at all, some provide the overloads but ignore the supplied allocator argument, and some provide the overloads and use the supplied allocator for construction but not when the &lt;code&gt;std::function&lt;/code&gt; is reassigned. As a result, allocator support was removed in C++17.</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; 의 할당 자 지원이 잘못 지정되어 일관성이 구현되지 않았습니다. 일부 구현은 과부하 (6-10)를 전혀 제공하지 않으며, 일부는 과부하를 제공하지만 제공된 할당 자 인수를 무시하고, 일부는 과부하를 제공하고 제공된 할당자를 구성에 사용하지만 &lt;code&gt;std::function&lt;/code&gt; 을 다시 할당 할 때는 사용하지 않습니다 . 결과적으로 할당 자 지원은 C ++ 17에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="712d2dee9547b4620e4b013fe8a329852f4ba582" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt;'s allocator support was poorly specified and inconsistently implemented. Some implementations do not support uses-allocator construction at all, some provide the needed constructor overloads but ignore the supplied allocator argument, and some provide the overloads and use the supplied allocator for construction but not when the &lt;code&gt;std::function&lt;/code&gt; is reassigned. As a result, allocator support was removed in C++17.</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; 의 할당 자 지원이 잘못 지정되어 일관성이 구현되지 않았습니다. 일부 구현은 use-allocator 생성을 전혀 지원하지 않으며, 일부는 필요한 생성자 오버로드를 제공하지만 제공된 할당 자 인수를 무시하고, 일부는 오버로드를 제공하고 제공된 할당자를 사용하여 구성하지만 &lt;code&gt;std::function&lt;/code&gt; 을 다시 할당 할 때는 사용하지 않습니다 . 결과적으로 할당 자 지원은 C ++ 17에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="ef1a78cf97a17ae6134be85fe81b8bc55f188b06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::gamma_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::gamma_distribution&lt;/code&gt; 은 RandomNumberDistribution을 충족 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="480cc0303c36c42d3e2b99061ea26d10538b0a7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::geometric_distribution&amp;lt;&amp;gt;(p)&lt;/code&gt; is exactly equivalent to &lt;code&gt;&lt;a href=&quot;negative_binomial_distribution&quot;&gt;std::negative_binomial_distribution&lt;/a&gt;&amp;lt;&amp;gt;(1, p)&lt;/code&gt;. It is also the discrete counterpart of &lt;code&gt;&lt;a href=&quot;exponential_distribution&quot;&gt;std::exponential_distribution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::geometric_distribution&amp;lt;&amp;gt;(p)&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;negative_binomial_distribution&quot;&gt;std::negative_binomial_distribution&lt;/a&gt;&amp;lt;&amp;gt;(1, p)&lt;/code&gt; 와 정확히 동일합니다 . 또한 &lt;code&gt;&lt;a href=&quot;exponential_distribution&quot;&gt;std::exponential_distribution&lt;/a&gt;&lt;/code&gt; 과 별개 입니다.</target>
        </trans-unit>
        <trans-unit id="a875eff720096f08c747f9f90b5860be91e34e17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::geometric_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::geometric_distribution&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution을&lt;/a&gt; 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="9c0402cd35d0eb2692fe862c055f0797c10f2179" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::gslice&lt;/code&gt; is the selector class that identifies a subset of &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; indices defined by a multi-level set of strides and sizes. Objects of type &lt;code&gt;std::gslice&lt;/code&gt; can be used as indices with valarray's &lt;code&gt;operator[]&lt;/code&gt; to select, for example, columns of a multidimensional array represented as a &lt;code&gt;valarray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::gslice&lt;/code&gt; 는 여러 수준의 보폭과 크기로 정의 된 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 인덱스 의 하위 집합을 식별하는 선택기 클래스입니다 . &lt;code&gt;std::gslice&lt;/code&gt; 유형의 오브젝트는 예를 들어 &lt;code&gt;valarray&lt;/code&gt; 로 표시되는 다차원 배열의 열을 선택하기 위해 valarray의 &lt;code&gt;operator[]&lt;/code&gt; 를 사용하여 색인으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52dbd11ae18bfb43cb00666d6f58bf0da1cc38ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::gslice_array&lt;/code&gt; is a helper template used by &lt;code&gt;&lt;a href=&quot;gslice&quot;&gt;std::gslice&lt;/a&gt;&lt;/code&gt; subscript operator. It has reference semantics to a subset of the array specified by the &lt;code&gt;std::gslice&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;std::gslice_array&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;gslice&quot;&gt;std::gslice&lt;/a&gt;&lt;/code&gt; 첨자 연산자가 사용하는 도우미 템플릿 입니다. &lt;code&gt;std::gslice&lt;/code&gt; 객체로 지정된 배열의 하위 집합에 대한 참조 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9633ecc1dd7b10e73c946202a0686610bf5c770" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::gslice_array&lt;/code&gt; is a helper template used by &lt;code&gt;std::indirect_array&lt;/code&gt; subscript operator. It has reference semantics to a subset of the array specified by an indirect array (&lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;&lt;/code&gt; object).</source>
          <target state="translated">&lt;code&gt;std::gslice_array&lt;/code&gt; 는 &lt;code&gt;std::indirect_array&lt;/code&gt; 첨자 연산자가 사용하는 도우미 템플릿 입니다. 간접 배열 ( &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 객체)로 지정된 배열의 하위 집합에 대한 참조 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="95b85e3781209d98618a09001f316b61cd5843df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::hypot(x, y)&lt;/code&gt; is equivalent to &lt;code&gt;std::abs(&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;(x,y))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::hypot(x, y)&lt;/code&gt; 는 &lt;code&gt;std::abs(&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;(x,y))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f0ea701b80954df580c165eadacf5776c180e46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::identity&lt;/code&gt; is a function object type whose &lt;code&gt;operator()&lt;/code&gt; returns its argument unchanged.</source>
          <target state="translated">&lt;code&gt;std::identity&lt;/code&gt; 는 &lt;code&gt;operator()&lt;/code&gt; 가 인수를 변경하지 않고 반환 하는 함수 객체 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="1c22e521fdbeb5e6776597727367efcea87a9141" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::identity&lt;/code&gt; is the identity function object: it returns its argument unchanged.</source>
          <target state="translated">&lt;code&gt;std::identity&lt;/code&gt; 는 identity 함수 객체이며 인수를 변경하지 않고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0385a1ac553e11d96d8d78b097dd0c676c86b86f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::in_place&lt;/code&gt;, &lt;code&gt;std::in_place_type&lt;/code&gt;, and &lt;code&gt;std::in_place_index&lt;/code&gt; are disambiguation tags that can be passed to the constructors of &lt;code&gt;&lt;a href=&quot;optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;any&quot;&gt;std::any&lt;/a&gt;&lt;/code&gt; to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.</source>
          <target state="translated">&lt;code&gt;std::in_place&lt;/code&gt; , &lt;code&gt;std::in_place_type&lt;/code&gt; 및 &lt;code&gt;std::in_place_index&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;any&quot;&gt;std::any&lt;/a&gt;&lt;/code&gt; 의 생성자에 전달할 수있는 명확성 태그이며 포함 된 오브젝트를 구성해야 함을 나타냅니다. 제자리에, 그리고 (후자의 2 개) 구성 될 객체의 유형.</target>
        </trans-unit>
        <trans-unit id="0168b9b751bd08c3bd1414db013cd45caa3e814d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::incrementable_traits&amp;lt;Iter&amp;gt;::difference_type&lt;/code&gt; if valid, otherwise &lt;code&gt;void&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::incrementable_traits&amp;lt;Iter&amp;gt;::difference_type&lt;/code&gt; 유효한 경우, 그렇지 않은 경우 &lt;code&gt;void&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d26bc5cdd9718de74b05d5b78f85e86c1265c0b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::insert_iterator&lt;/code&gt; is a &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that inserts elements into a container for which it was constructed, at the position pointed to by the supplied iterator. The container's &lt;code&gt;insert()&lt;/code&gt; member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::insert_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::insert_iterator&lt;/code&gt; 는 제공된 반복자가 가리키는 위치에서 요소를 구성된 컨테이너에 요소를 삽입 하는 &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; 입니다. 컨테이너의 &lt;code&gt;insert()&lt;/code&gt; 멤버 함수는 반복자 (역 참조 여부에 관계없이)가 할당 될 때마다 호출됩니다. 증가 &lt;code&gt;std::insert_iterator&lt;/code&gt; 조작은 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ed0c5bbe217d673ceb1003957bd5b7d91123fdb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::int&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::int&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e4313d5011c53e518c756a2252c4df9a362a403" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::int_fast&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::int_fast&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="056289e3e32a5cd8ae69529fe2789e844000ec9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::int_least&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::int_least&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5374c575ed2e778888b40082dccbedb38c0e168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::integral_constant&amp;lt;std::size_t, N&amp;gt;&lt;/code&gt; for some &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::integral_constant&amp;lt;std::size_t, N&amp;gt;&lt;/code&gt; 일부 &lt;code&gt;N&lt;/code&gt; 의 경우std :: integral_constant &amp;lt;std :: size_t, N&amp;gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="80ce62b2f6c64e9cc1a197075ce8d58710a0e3f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::integral_constant&lt;/code&gt; wraps a static constant of specified type. It is the base class for the C++ type traits.</source>
          <target state="translated">&lt;code&gt;std::integral_constant&lt;/code&gt; 는 지정된 유형의 정적 상수를 래핑합니다. C ++ 유형 특성의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="6a4b13ca29e2535668fcc8630678687f8e5f495a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ios_base::failure&lt;/code&gt; may be defined either as a member class of &lt;code&gt;&lt;a href=&quot;../ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; or as a synonym (typedef) for another class with equivalent functionality.(since C++17).</source>
          <target state="translated">&lt;code&gt;std::ios_base::failure&lt;/code&gt; 의 구성원 어느 클래스로 정의 될 수있다 &lt;code&gt;&lt;a href=&quot;../ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; 또는 동등한 기능을 다른 클래스의 동의어 (타입 정의)한다. (17 ++ C입니다).</target>
        </trans-unit>
        <trans-unit id="c35cebda19804ec67065696fcf947069ced92a75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_aggregate&lt;/code&gt; type trait</source>
          <target state="translated">&lt;code&gt;std::is_aggregate&lt;/code&gt; 유형 특성</target>
        </trans-unit>
        <trans-unit id="17c43791619df5add71d65dae6f070413cd24fb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_base_of&amp;lt;A, B&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; even if &lt;code&gt;A&lt;/code&gt; is a private, protected, or ambiguous base class of &lt;code&gt;B&lt;/code&gt;. In many situations, &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;B*, A*&amp;gt;&lt;/code&gt; is the more appropriate test.</source>
          <target state="translated">&lt;code&gt;std::is_base_of&amp;lt;A, B&amp;gt;::value&lt;/code&gt; 이다 &lt;code&gt;true&lt;/code&gt; 하더라도 &lt;code&gt;A&lt;/code&gt; 는 의 보호 전용 또는 모호한 기본 클래스 &lt;code&gt;B&lt;/code&gt; . 많은 상황에서 &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;B*, A*&amp;gt;&lt;/code&gt; 가 더 적합한 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="fc232ada3163773b55f91cfd4ebcdc316148abd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_default_constructible&amp;lt;T&amp;gt;&lt;/code&gt; does not test that &lt;code&gt;T x;&lt;/code&gt; would compile; it attempts &lt;a href=&quot;../language/direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; with an empty argument list (see &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&lt;/code&gt;). Thus, &lt;code&gt;std::is_default_constructible_v&amp;lt;const int&amp;gt;&lt;/code&gt; and &lt;code&gt;std::is_default_constructible_v&amp;lt;const int[10]&amp;gt;&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::is_default_constructible&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;code&gt;T x;&lt;/code&gt; 테스트하지 않습니다 . 컴파일; 빈 인수 목록으로 &lt;a href=&quot;../language/direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 를 시도 합니다 ( &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&lt;/code&gt; 참조 ). 따라서 &lt;code&gt;std::is_default_constructible_v&amp;lt;const int&amp;gt;&lt;/code&gt; 및 &lt;code&gt;std::is_default_constructible_v&amp;lt;const int[10]&amp;gt;&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4a7e3513494283e7e309e272990310bfd22e4c1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_empty&amp;lt;T&amp;gt;&lt;/code&gt; and all other type traits are empty classes.</source>
          <target state="translated">&lt;code&gt;std::is_empty&amp;lt;T&amp;gt;&lt;/code&gt; 및 기타 모든 유형 특성은 빈 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="cd321ebf2f2858e8889f2a97ec260a2a043e7c22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_invocable&lt;/code&gt;, &lt;code&gt;std::invoke_result&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::is_invocable&lt;/code&gt; , &lt;code&gt;std::invoke_result&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f22e915926826ff5411e65d836e38f3853fb4bee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_sorted&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_sorted_until&quot;&gt;std::is_sorted_until&lt;/a&gt;&lt;/code&gt; both return true for empty ranges and ranges of length one.</source>
          <target state="translated">&lt;code&gt;std::is_sorted&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;is_sorted_until&quot;&gt;std::is_sorted_until&lt;/a&gt;&lt;/code&gt; 모두 빈 범위와 길이가 1 인 범위에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="76d5f0212c195e3069a6f21f54bdf8d5d6793a50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::isspace(c,is.getloc())&lt;/code&gt; is true for the next character &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;is&lt;/code&gt; (this whitespace character remains in the input stream).</source>
          <target state="translated">&lt;code&gt;std::isspace(c,is.getloc())&lt;/code&gt; 은 다음 문자 &lt;code&gt;c&lt;/code&gt; in에 대해 true &lt;code&gt;is&lt;/code&gt; (이 공백 문자는 입력 스트림에 남아 있습니다).</target>
        </trans-unit>
        <trans-unit id="accacfbe11581a503dba5062106078b5b1e65e10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::istream_iterator&lt;/code&gt; is a single-pass input iterator that reads successive objects of type &lt;code&gt;T&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; object for which it was constructed, by calling the appropriate &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;. The actual read operation is performed when the iterator is incremented, not when it is dereferenced. The first object is read when the iterator is constructed. Dereferencing only returns a copy of the most recently read object.</source>
          <target state="translated">&lt;code&gt;std::istream_iterator&lt;/code&gt; 는 적절한 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 호출하여 생성 된 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 객체 에서 &lt;code&gt;T&lt;/code&gt; 유형의 연속 객체를 읽는 단일 패스 입력 반복기입니다 . 실제 읽기 작업은 반복자가 해제 될 때가 아니라 반복자가 증가 할 때 수행됩니다. 반복자가 구성 될 때 첫 번째 오브젝트를 읽습니다. 역 참조는 가장 최근에 읽은 객체의 사본 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9cbfd53846c23724a1c027d6e2f38dde642ad5df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::istreambuf_iterator&lt;/code&gt; has a trivial copy constructor, a constexpr default constructor, and a trivial destructor.</source>
          <target state="translated">&lt;code&gt;std::istreambuf_iterator&lt;/code&gt; 에는 간단한 복사 생성자, constexpr 기본 생성자 및 간단한 소멸자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="69bcfd3a6166f9c6c392b5e7165bc3ea05cee29d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::istreambuf_iterator&lt;/code&gt; is a single-pass input iterator that reads successive characters from the &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; object for which it was constructed.</source>
          <target state="translated">&lt;code&gt;std::istreambuf_iterator&lt;/code&gt; 는 구성된 &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 객체 에서 연속 문자를 읽는 단일 패스 입력 반복기입니다 .</target>
        </trans-unit>
        <trans-unit id="9aa098edcf5248bd33724b3a40884863ecff491f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iswdigit&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;iswxdigit&quot;&gt;std::iswxdigit&lt;/a&gt;&lt;/code&gt; are the only standard wide character classification functions that are not affected by the currently installed C locale.</source>
          <target state="translated">&lt;code&gt;std::iswdigit&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;iswxdigit&quot;&gt;std::iswxdigit&lt;/a&gt;&lt;/code&gt; 는 현재 설치된 C 로케일의 영향을받지 않는 유일한 표준 와이드 문자 분류 기능입니다.</target>
        </trans-unit>
        <trans-unit id="7cfa97d219e1324e07edaccefe8988d5dccc17b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iterator&lt;/code&gt; is the base class provided to simplify definitions of the required types for iterators.</source>
          <target state="translated">&lt;code&gt;std::iterator&lt;/code&gt; 는 반복자 에 필요한 유형의 정의를 단순화하기 위해 제공되는 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b7042ea0b4cf46ee11c1e2aad8beb6aaeece852a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type*&lt;/code&gt; and &lt;code&gt;std::sub_match&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type*&lt;/code&gt; 및 &lt;code&gt;std::sub_match&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b55313b2cef60e74e0c2c5ed04471f86f95bff4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type&lt;/code&gt; and &lt;code&gt;std::sub_match&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type&lt;/code&gt; 및 &lt;code&gt;std::sub_match&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73e0d90f769db9ddd2bc286113fc7c3922356c42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iterator_traits&lt;/code&gt; is the type trait class that provides uniform interface to the properties of &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt; types. This makes it possible to implement algorithms only in terms of iterators.</source>
          <target state="translated">&lt;code&gt;std::iterator_traits&lt;/code&gt; 는 &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt; 유형 의 속성에 대한 균일 한 인터페이스를 제공하는 유형 특성 클래스입니다 . 이를 통해 반복자 측면에서만 알고리즘을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62067c7c19b742e9f2f87539809741fc87924de4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::launder&lt;/code&gt; has no effect on its argument. Its return value must be used to access the object. Thus, it's always an error to discard the return value.</source>
          <target state="translated">&lt;code&gt;std::launder&lt;/code&gt; 는 인수에 영향을 미치지 않습니다. 오브젝트에 액세스하려면 리턴 값을 사용해야합니다. 따라서 반환 값을 버리는 것은 항상 오류입니다.</target>
        </trans-unit>
        <trans-unit id="a6fd8f68c4429333d078e5364ffa87742fef95c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::launder&lt;/code&gt; may be used in a &lt;a href=&quot;../language/constant_expression&quot;&gt;core constant expression&lt;/a&gt; if the value of its argument may be used in a core constant expression.</source>
          <target state="translated">&lt;code&gt;std::launder&lt;/code&gt; 인수의 값이 &lt;a href=&quot;../language/constant_expression&quot;&gt;핵심 상수 표현식에&lt;/a&gt; 사용될 수있는 경우 std :: launder 는 핵심 상수 표현식에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0400f4a420bf2d62df57d158e61abc76eca486" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::list&amp;lt;T, A&amp;gt;&lt;/code&gt; allocates nodes of some internal type &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;, using the allocator &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::rebind_alloc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, which is implemented in terms of &lt;code&gt;A::rebind&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;::other&lt;/code&gt; if A is an &lt;code&gt;std::allocator&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::list&amp;lt;T, A&amp;gt;&lt;/code&gt; 할당 노드 일부 내부 유형의 &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; 상기 할당하여 &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::rebind_alloc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 측면에서 구현된다 &lt;code&gt;A::rebind&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;::other&lt;/code&gt; 경우 A가 &lt;code&gt;std::allocator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66722744970a911306b103b6b3a4bb83fa74da8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::list&amp;lt;T, A&amp;gt;&lt;/code&gt; allocates nodes of some internal type &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;, using the allocator &lt;code&gt;A::rebind&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;::other&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::list&amp;lt;T, A&amp;gt;&lt;/code&gt; 는 할당 자 &lt;code&gt;A::rebind&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;::other&lt;/code&gt; 사용하여 일부 내부 유형 &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="c15f65983fc9b680377c222e85dac10cf4ab4144" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::list&lt;/code&gt; is a container that supports constant time insertion and removal of elements from anywhere in the container. Fast random access is not supported. It is usually implemented as a doubly-linked list. Compared to &lt;code&gt;&lt;a href=&quot;forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; this container provides bidirectional iteration capability while being less space efficient.</source>
          <target state="translated">&lt;code&gt;std::list&lt;/code&gt; 는 컨테이너의 어느 곳에서나 요소를 지속적으로 삽입하고 제거하는 것을 지원하는 컨테이너입니다. 빠른 임의 액세스는 지원되지 않습니다. 일반적으로 이중 연결 목록으로 구현됩니다. &lt;code&gt;&lt;a href=&quot;forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; 와 비교 하여이 컨테이너는 공간 효율적이 아닌 양방향 반복 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0b4e21027fec7854716699e00372b2255194f58b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::list&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::list&lt;/code&gt; 는 &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; , &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; 및 &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; 의 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="39480e048d13612808ce9e8bdf46a4d2d1efff1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::locale::facet&lt;/code&gt; is the base class for facets. It provides a common base class so that locales could store pointers to the facets they implement in a single indexed container, and it abstracts support for facet reference counting. Whenever a facet is added to a locale, the locale increments the reference count in the facet (through an implementation-specific mechanism). Whenever a locale is destructed or modified, it decrements the reference count in each facet it no longer implements. Whenever a facet's reference count becomes zero, the locale performs &lt;code&gt;delete static_cast&amp;lt;std::locale::facet*&amp;gt;(f)&lt;/code&gt; where &lt;code&gt;f&lt;/code&gt; is the pointer to the facet.</source>
          <target state="translated">&lt;code&gt;std::locale::facet&lt;/code&gt; 는 패싯 의 기본 클래스입니다. 로케일이 단일 인덱스 컨테이너에 구현하는 패싯에 대한 포인터를 저장할 수 있도록 공통 기본 클래스를 제공하며 패싯 참조 계산에 대한 지원을 추상화합니다. 패싯이 로케일에 추가 될 때마다 로케일은 패싯에서 참조 구현 횟수를 증가시킵니다 (구현 별 메커니즘을 통해). 로케일이 파괴되거나 수정 될 때마다 더 이상 구현하지 않는 각 패싯의 참조 횟수가 감소합니다. 패싯의 참조 수가 0이 될 때마다 로케일은 &lt;code&gt;delete static_cast&amp;lt;std::locale::facet*&amp;gt;(f)&lt;/code&gt; 여기서 &lt;code&gt;f&lt;/code&gt; 는 패싯에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="25f4c47baf2c706d9502a2677329ad5ff357de25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::localeconv&lt;/code&gt; modifies a static object, calling it from different threads without synchronization is undefined behavior.</source>
          <target state="translated">&lt;code&gt;std::localeconv&lt;/code&gt; 는 정적 객체를 수정하여 동기화하지 않고 다른 스레드에서 호출하는 것은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="17fcade94977b46d0779598ca948f02a54971ac1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::lognormal_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::lognormal_distribution&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution의&lt;/a&gt; 모든 요구 사항을 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="36ea267312e8c2f25e5b22940ec75bd0844adcad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::make_shared&lt;/code&gt; uses &lt;code&gt;::new&lt;/code&gt;, so if any special behavior has been set up using a class-specific &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt;, it will differ from &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::make_shared&lt;/code&gt; 는 &lt;code&gt;::new&lt;/code&gt; 를 사용하므로 클래스 별 &lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; 사용하여 특수 동작을 설정 한 경우 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="b24879d26d53111bc2ca5c76cc8a905a3eaaf320" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::map::value_compare&lt;/code&gt; is a function object that compares objects of type &lt;code&gt;std::map::value_type&lt;/code&gt; (key-value pairs) by comparing of the first components of the pairs.</source>
          <target state="translated">&lt;code&gt;std::map::value_compare&lt;/code&gt; 는 쌍의 첫 번째 구성 요소를 비교하여 &lt;code&gt;std::map::value_type&lt;/code&gt; (키-값 쌍) 유형의 오브젝트를 비교하는 함수 오브젝트입니다 .</target>
        </trans-unit>
        <trans-unit id="69b03e94f70798f70251e093522baf56a3c25fde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::map&lt;/code&gt; is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function &lt;code&gt;Compare&lt;/code&gt;. Search, removal, and insertion operations have logarithmic complexity. Maps are usually implemented as &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;red-black trees&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::map&lt;/code&gt; 은 고유 키와 키-값 쌍을 포함하는 정렬 된 연관 컨테이너입니다. 키는 비교 기능 &lt;code&gt;Compare&lt;/code&gt; 를 사용하여 정렬됩니다 . 검색, 제거 및 삽입 작업에는 로그가 복잡합니다. 지도는 일반적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;빨강 검정 나무&lt;/a&gt; 로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9b8c058371534a10bf6f6f1cfb81ee79141b674" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::map&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::map&lt;/code&gt; 은 &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; , &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; 및 &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; 의 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="84be1b95a94a0df278624077a9bf062e43144c11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::mask_array&lt;/code&gt; is a helper template used by the &lt;a href=&quot;operator_at&quot;&gt;valarray subscript operator&lt;/a&gt; with &lt;code&gt;std::valarray&amp;lt;bool&amp;gt;&lt;/code&gt; argument. It has reference semantics and provides access to the subset of the valarray consisting of the elements whose indices correspond to &lt;code&gt;true&lt;/code&gt; values in the &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; mask.</source>
          <target state="translated">&lt;code&gt;std::mask_array&lt;/code&gt; 는 vadray &lt;a href=&quot;operator_at&quot;&gt;첨자 연산자&lt;/a&gt; 가 &lt;code&gt;std::valarray&amp;lt;bool&amp;gt;&lt;/code&gt; 인수 와 함께 사용하는 도우미 템플릿 입니다. 참조 시맨틱을 가지며 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; &amp;lt;bool&amp;gt; 마스크 의 인덱스가 &lt;code&gt;true&lt;/code&gt; 값에 해당하는 요소로 구성된 valarray의 서브 세트에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1ba44ed66d1e1555c21ea7a3d7af56fb9452ba4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::match_results&lt;/code&gt; meets the requirements of a &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; and of a &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;, except that only copy assignment, move assignment, and operations defined for a constant containers are supported, and that the semantics of comparison functions are different from those required for a container.</source>
          <target state="translated">&lt;code&gt;std::match_results&lt;/code&gt; 는 &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; 및 &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; 의 요구 사항을 충족하지만 , 상수 컨테이너에 대해 정의 된 사본 지정, 이동 지정 및 조작 만 지원되며 비교 함수의 의미가 컨테이너에 필요한 것과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="486be6c729cd8f9005df324c3f9cee7e87d5dd71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::max_align_t&lt;/code&gt; is a &lt;a href=&quot;../named_req/trivialtype&quot;&gt;trivial&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;standard-layout&lt;/a&gt; type whose &lt;a href=&quot;../language/objects#Alignment&quot;&gt;alignment requirement&lt;/a&gt; is at least as strict (as large) as that of every scalar type.</source>
          <target state="translated">&lt;code&gt;std::max_align_t&lt;/code&gt; 는 &lt;a href=&quot;../language/objects#Alignment&quot;&gt;정렬 요구 사항&lt;/a&gt; 이 모든 스칼라 유형 의 정렬 &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;수준&lt;/a&gt; 보다 최소한 (거의) 엄격한 &lt;a href=&quot;../named_req/trivialtype&quot;&gt;사소한 &lt;/a&gt;표준 레이아웃 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="de74cc16225bf11bc2936dc0ea5016c64a73d87a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::max_align_t&lt;/code&gt; is usually synonymous with the largest scalar type, which is &lt;code&gt;long double&lt;/code&gt; on most platforms, and its alignment requirement is either 8 or 16.</source>
          <target state="translated">&lt;code&gt;std::max_align_t&lt;/code&gt; 는 일반적으로 가장 큰 스칼라 유형과 동의어이며 대부분의 플랫폼에서 &lt;code&gt;long double&lt;/code&gt; 되며 정렬 요구 사항은 8 또는 16입니다.</target>
        </trans-unit>
        <trans-unit id="250616309b32d57f9c4f54607c0d6adeac132d82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::mem_fn&lt;/code&gt; returns a call wrapper of unspecified type that has the following members:</source>
          <target state="translated">&lt;code&gt;std::mem_fn&lt;/code&gt; 은 다음 멤버를 갖는 지정되지 않은 유형의 호출 래퍼를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="019539277e675b31ee3787a2ae6f6741a1f927c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::memcpy&lt;/code&gt; is meant to be the fastest library routine for memory-to-memory copy. It is usually more efficient than &lt;code&gt;&lt;a href=&quot;strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt;, which must scan the data it copies or &lt;code&gt;&lt;a href=&quot;memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;, which must take precautions to handle overlapping inputs.</source>
          <target state="translated">&lt;code&gt;std::memcpy&lt;/code&gt; 는 메모리 간 복사를위한 가장 빠른 라이브러리 루틴입니다. 일반적으로 &lt;code&gt;&lt;a href=&quot;strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt; 보다 효율적입니다.이 데이터는 복사하는 데이터 또는 &lt;code&gt;&lt;a href=&quot;memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; 스캔 해야하며, 중복 된 입력을 처리하기 위해주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="2118ff9fcca45263d25b203070d19f43992cc2ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::memory_order&lt;/code&gt; specifies how memory accesses, including regular, non-atomic memory accesses, are to be ordered around an atomic operation. Absent any constraints on a multi-core system, when multiple threads simultaneously read and write to several variables, one thread can observe the values change in an order different from the order another thread wrote them. Indeed, the apparent order of changes can even differ among multiple reader threads. Some similar effects can occur even on uniprocessor systems due to compiler transformations allowed by the memory model.</source>
          <target state="translated">&lt;code&gt;std::memory_order&lt;/code&gt; 는 일반적인 비 원자 메모리 액세스를 포함하여 메모리 액세스가 원자 연산을 중심으로 정렬되는 방법을 지정합니다. 다중 코어 시스템에 제약 조건이 없으면 여러 스레드가 동시에 여러 변수를 읽고 쓰는 경우 한 스레드가 다른 스레드가 쓴 순서와 다른 순서로 값이 변경되는 것을 관찰 할 수 있습니다. 실제로, 명백한 변경 순서는 여러 판독기 스레드마다 다를 수 있습니다. 메모리 모델에서 허용하는 컴파일러 변환으로 인해 단일 프로세서 시스템에서도 비슷한 효과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a7564b150268b029471f79e561f7972a4703c6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::memset&lt;/code&gt; may be optimized away (under the &lt;a href=&quot;../../language/as_if&quot;&gt;as-if&lt;/a&gt; rules) if the object modified by this function is not accessed again for the rest of its lifetime (e.g. &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8537&quot;&gt;gcc bug 8537&lt;/a&gt;). For that reason, this function cannot be used to scrub memory (e.g. to fill an array that stored a password with zeroes). Solutions for that include &lt;a href=&quot;../../algorithm/fill&quot;&gt;&lt;code&gt;std::fill&lt;/code&gt;&lt;/a&gt; with volatile pointers, C11 &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/memset.html&quot;&gt;&lt;code&gt;memset_s&lt;/code&gt;&lt;/a&gt;, FreeBSD &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=explicit_bzero&quot;&gt;explicit_bzero&lt;/a&gt; or Microsoft &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366877.aspx&quot;&gt;SecureZeroMemory&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::memset&lt;/code&gt; 은이 기능으로 수정 된 객체가 남은 수명 동안 다시 액세스하지 않으면 (있는 &lt;a href=&quot;../../language/as_if&quot;&gt;경우&lt;/a&gt; 규칙에 따라) 최적화 될 수 있습니다 (예 : &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8537&quot;&gt;gcc bug 8537&lt;/a&gt; ). 따라서이 기능을 사용하여 메모리를 스크러빙 할 수 없습니다 (예 : 암호를 저장 한 어레이를 0으로 채우는 데 사용). 이를위한 솔루션에는 휘발성 포인터 가 포함 된 &lt;a href=&quot;../../algorithm/fill&quot;&gt; &lt;code&gt;std::fill&lt;/code&gt; &lt;/a&gt; , C11 &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/memset.html&quot;&gt; &lt;code&gt;memset_s&lt;/code&gt; &lt;/a&gt; , FreeBSD &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=explicit_bzero&quot;&gt;explicit_bzero&lt;/a&gt; 또는 Microsoft &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366877.aspx&quot;&gt;SecureZeroMemory가 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="37d85ef2212e37f34c3209150c0bbbf80edfa8c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::messages_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;messages&quot;&gt;std::messages&lt;/a&gt;&lt;/code&gt; facet which encapsulates retrieval of strings from message catalogs of the locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::messages_byname&lt;/code&gt; 은 구성시 지정된 로케일의 메시지 카탈로그에서 문자열 검색을 캡슐화 하는 &lt;code&gt;&lt;a href=&quot;messages&quot;&gt;std::messages&lt;/a&gt;&lt;/code&gt; 패싯입니다.</target>
        </trans-unit>
        <trans-unit id="33c8225db603dfa739b0e05e20477d0f83922789" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::moneypunct_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; facet which encapsulates monetary formatting preferences of a locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::moneypunct_byname&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; 패싯으로, 구성시 지정된 로케일의 통화 형식 환경 설정을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="efbca6737e4ba6c8e9dd65c08620ae6de6752df0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move(x)&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt;, depending on exception guarantees.</source>
          <target state="translated">&lt;code&gt;std::move(x)&lt;/code&gt; 예외 보장에 따라 std :: move (x) 또는 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7de0377c2783e738adfca256a11f333e74b0abef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move&lt;/code&gt; is used to</source>
          <target state="translated">&lt;code&gt;std::move&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="57df1e08f7a50f846a44df6e8661f68fa099d33f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move_iterator&lt;/code&gt; is an iterator adaptor which behaves exactly like the underlying iterator (which must be at least an &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;), except that dereferencing converts the value returned by the underlying iterator into an rvalue. If this iterator is used as an input iterator, the effect is that the values are moved from, rather than copied from.</source>
          <target state="translated">&lt;code&gt;std::move_iterator&lt;/code&gt; 는 역 참조가 기본 반복자가 리턴 한 값을 rvalue로 변환한다는 점을 제외하고 는 기본 반복자와 정확히 동일하게 작동하는 반복자 어댑터입니다 (적어도 &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator 여야 함&lt;/a&gt; ). 이 반복자를 입력 반복자로 사용하면 값이 복사되지 않고 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="b9911341852a0dfa39ac8efe01699ab44e9ef543" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::multimap::value_compare&lt;/code&gt; is a function object that compares objects of type &lt;code&gt;std::multimap::value_type&lt;/code&gt; (key-value pairs) by comparing of the first components of the pairs.</source>
          <target state="translated">&lt;code&gt;std::multimap::value_compare&lt;/code&gt; 는 쌍의 첫 번째 구성 요소를 비교하여 &lt;code&gt;std::multimap::value_type&lt;/code&gt; (키-값 쌍) 유형의 오브젝트를 비교하는 함수 오브젝트입니다 .</target>
        </trans-unit>
        <trans-unit id="96ab8f5decbb67bb55ce6193967b8c257928ef8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::multimap&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::multimap&lt;/code&gt; 은 &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; , &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; 및 &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; 의 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="9f752bf59adb24e8616e43fbea77f42838db6858" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::multiset&lt;/code&gt; is an associative container that contains a sorted set of objects of type Key. Unlike set, multiple keys with equivalent values are allowed. Sorting is done using the key comparison function Compare. Search, insertion, and removal operations have logarithmic complexity.</source>
          <target state="translated">&lt;code&gt;std::multiset&lt;/code&gt; 은 Key 형식의 정렬 된 개체 집합을 포함하는 연관 컨테이너입니다. 설정과 달리 동등한 값을 가진 여러 키가 허용됩니다. 키 비교 기능 비교를 사용하여 정렬이 수행됩니다. 검색, 삽입 및 제거 작업에는 로그가 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="086e94514b0cdda6b7633c56cf601a40382a11cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::multiset&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::multiset&lt;/code&gt; 은 &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; , &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; 및 &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; 의 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="e96493daf69bb9a9ead26df58b81f61e6c62e6ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::mutex&lt;/code&gt; is neither copyable nor movable.</source>
          <target state="translated">&lt;code&gt;std::mutex&lt;/code&gt; 는 복사하거나 이동할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="05b0d7c6eb2399ec5b7b4c3e31db6b51b12be1c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::mutex&lt;/code&gt; is usually not accessed directly: &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;,  or &lt;code&gt;std::scoped_lock&lt;/code&gt;(since C++17) manage locking in a more exception-safe manner.</source>
          <target state="translated">&lt;code&gt;std::mutex&lt;/code&gt; 는 일반적으로 직접 액세스되지 않습니다. &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;std::scoped_lock&lt;/code&gt; (C ++ 17부터)은보다 예외적으로 안전한 방식으로 잠금을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="cc0d7eecfb40eeab627189c04ee7371985b6d0d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::negative_binomial_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::negative_binomial_distribution&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution을&lt;/a&gt; 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="356015a256f665f8a44e6d1e549d4cef107b40ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nested_exception&lt;/code&gt; is a polymorphic mixin class which can capture and store the current exception, making it possible to nest exceptions of arbitrary types within each other.</source>
          <target state="translated">&lt;code&gt;std::nested_exception&lt;/code&gt; 은 현재 예외를 캡처하고 저장할 수있는 다형성 mixin 클래스로, 임의 유형의 예외를 서로 중첩시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9714f66f30044372b37d250de64fe0d3c1071a2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::new_handler&lt;/code&gt; is the function pointer type (pointer to function that takes no arguments and returns void), which is used by the functions &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::new_handler&lt;/code&gt; 는 함수 포인터 유형 (인수를 취하지 않고 void를 반환하는 함수를 가리키는 포인터)이며 &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt; 함수에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a851774dbb169de3b43d1480564d86976d5d760a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::normal_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::normal_distribution&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution의&lt;/a&gt; 모든 요구 사항을 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="6bbdbd6056802e22d2dfcad3cce3c52c0a59507e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::not1&lt;/code&gt; returns an object of type &lt;code&gt;&lt;a href=&quot;unary_negate&quot;&gt;std::unary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt;, constructed with &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::not1&lt;/code&gt; 은 &lt;code&gt;pred&lt;/code&gt; 로 구성된 &lt;code&gt;&lt;a href=&quot;unary_negate&quot;&gt;std::unary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt; 유형의 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1e7ef35eea64883819b88f9a89de62f625607241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::not2&lt;/code&gt; returns an object of type &lt;code&gt;&lt;a href=&quot;binary_negate&quot;&gt;std::binary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt;, constructed with &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::not2&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;binary_negate&quot;&gt;std::binary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt; 유형의 오브젝트 를 &lt;code&gt;pred&lt;/code&gt; 로 구성하여 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f70f4db2af2af44f2a7ba7b47013286ed6c35fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nothrow&lt;/code&gt; is a constant of type &lt;code&gt;&lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;&lt;/code&gt; used to disambiguate the overloads of throwing and non-throwing &lt;a href=&quot;operator_new&quot;&gt;allocation functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::nothrow&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;&lt;/code&gt; 유형의 상수로 , 던지고 던지지 않는 &lt;a href=&quot;operator_new&quot;&gt;할당 함수&lt;/a&gt; 의 과부하를 명확하게하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7cda3e5771a651d7ac8313fe2f3aa00ac56c2106" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nothrow_t&lt;/code&gt; is an empty class type used to disambiguate the overloads of throwing and non-throwing &lt;a href=&quot;operator_new&quot;&gt;allocation functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::nothrow_t&lt;/code&gt; 는 throw 및 non-throwing &lt;a href=&quot;operator_new&quot;&gt;할당 함수&lt;/a&gt; 의 과부하를 명확하게하는 데 사용되는 빈 클래스 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="85ab32f61c86e1fe107572929e50efe8ee81c122" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nullopt&lt;/code&gt; is a constant of type &lt;code&gt;&lt;a href=&quot;nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; that is used to indicate &lt;code&gt;optional&lt;/code&gt; type with uninitialized state.</source>
          <target state="translated">&lt;code&gt;std::nullopt&lt;/code&gt; 유형의 상수는 &lt;code&gt;&lt;a href=&quot;nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; 표시하는 데 사용되는 &lt;code&gt;optional&lt;/code&gt; 초기화되지 않은 상태 유형입니다.</target>
        </trans-unit>
        <trans-unit id="02049de6eda615290c2b319f76d165fe688eb7d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nullopt_t&lt;/code&gt; is an empty class type used to indicate &lt;code&gt;optional&lt;/code&gt; type with uninitialized state. In particular, &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; has a constructor with &lt;code&gt;nullopt_t&lt;/code&gt; as a single argument, which creates an optional that does not contain a value.</source>
          <target state="translated">&lt;code&gt;std::nullopt_t&lt;/code&gt; 는 초기화되지 않은 상태의 &lt;code&gt;optional&lt;/code&gt; 유형 을 나타내는 데 사용되는 빈 클래스 유형 입니다. 특히, &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; 에는 &lt;code&gt;nullopt_t&lt;/code&gt; 를 단일 인수로 사용하는 생성자가 있으므로 값을 포함하지 않는 선택적을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3f1013d2e1cbbed3314f41f8281dd0590dff1883" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nullopt_t&lt;/code&gt; must be a non-aggregate &lt;a href=&quot;../../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; and cannot have a default constructor or an initializer-list constructor.</source>
          <target state="translated">&lt;code&gt;std::nullopt_t&lt;/code&gt; 해야 비 집계 &lt;a href=&quot;../../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; 및 기본 생성자 또는 초기화리스트 생성자를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfbb1c354a43470e1d88908e8209e04392aa55ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nullptr_t&lt;/code&gt; is the type of the null pointer literal, &lt;a href=&quot;../language/nullptr&quot;&gt;&lt;code&gt;nullptr&lt;/code&gt;&lt;/a&gt;. It is a distinct type that is not itself a pointer type or a pointer to member type.</source>
          <target state="translated">&lt;code&gt;std::nullptr_t&lt;/code&gt; 는 널 포인터 리터럴 인 &lt;a href=&quot;../language/nullptr&quot;&gt; &lt;code&gt;nullptr&lt;/code&gt; &lt;/a&gt; 의 유형입니다 . 포인터 유형이나 멤버 유형에 대한 포인터가 아닌 고유 한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e2e770b2f25bf1be459bc0ab1b7aa9828614268d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::numpunct_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;numpunct&quot;&gt;std::numpunct&lt;/a&gt;&lt;/code&gt; facet which encapsulates numeric punctuation preferences of a locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::numpunct_byname&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;numpunct&quot;&gt;std::numpunct&lt;/a&gt;&lt;/code&gt; 패싯으로 구성시 지정된 로케일의 숫자 문장 부호 환경 설정을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="c2f1976e55e2fa1e62abc4428973a4a9531f2f1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::once_flag&lt;/code&gt; is neither copyable nor movable.</source>
          <target state="translated">&lt;code&gt;std::once_flag&lt;/code&gt; 는 복사 가능하거나 이동할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dc46da909485bc2d93323c2c6ff124bedb3ce7fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ostream_iterator&lt;/code&gt; is a single-pass &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that writes successive objects of type &lt;code&gt;T&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; object for which it was constructed, using &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;. Optional delimiter string is written to the output stream after every write operation. The write operation is performed when the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::ostream_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::ostream_iterator&lt;/code&gt; 는 단일 패스 &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; 로 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 사용하여 &lt;code&gt;T&lt;/code&gt; 유형의 연속적인 객체 를 생성 된 &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 객체에 씁니다 . 선택적 구분 기호 문자열은 모든 쓰기 작업 후에 출력 스트림에 기록됩니다. 반복자 (역 참조 여부에 관계없이)가 할당되면 쓰기 작업이 수행됩니다. 증가 &lt;code&gt;std::ostream_iterator&lt;/code&gt; 조작은 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="777e432c8143a3737cc1c5cb394e70c18a51c20c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; is a single-pass &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that writes successive characters into the &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; object for which it was constructed. The actual write operation is performed when the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; 는 생성 된 &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 객체에 연속 문자를 쓰는 단일 패스 &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; 입니다 . 실제 쓰기 조작은 반복자 (역 참조 여부에 관계없이)가 지정 될 때 수행됩니다. 증가 &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; 조작은 행해지 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc1abd29bb8831f4698cdb1094a6ca7e562e49e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pair&lt;/code&gt; is a struct template that provides a way to store two heterogeneous objects as a single unit. A pair is a specific case of a &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; with two elements.</source>
          <target state="translated">&lt;code&gt;std::pair&lt;/code&gt; 는 두 개의 이기종 객체를 단일 단위로 저장하는 방법을 제공하는 구조체 템플릿입니다. 쌍은 &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 의 특정 경우입니다. 두 요소를 가진 .</target>
        </trans-unit>
        <trans-unit id="ea8dd13c2816204756416ea997c79ecf7f5dc04b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is equivalent to &lt;code&gt;b&lt;/code&gt; (&lt;code&gt;-0 &amp;lt;=&amp;gt; +0&lt;/code&gt; is equivalent)</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; 동등 &lt;code&gt;b&lt;/code&gt; ( &lt;code&gt;-0 &amp;lt;=&amp;gt; +0&lt;/code&gt; 은 같습니다)</target>
        </trans-unit>
        <trans-unit id="371bc87e88fad51bc0750025291273ab879059d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::greater&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is greater than &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::greater&lt;/code&gt; 경우 &lt;code&gt;a&lt;/code&gt; 보다 큰 &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c84a2e8316193f31e89963f9aecf5bee5195fb95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::less&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is less than &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::less&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;b&lt;/code&gt; 보다 경우</target>
        </trans-unit>
        <trans-unit id="40941de7130d4d5cf67a40eab0dc365768ccaeff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::less&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;std::partial_ordering::greater&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, &lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equal&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::less&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 것입니다 &lt;code&gt;less&lt;/code&gt; , &lt;code&gt;std::partial_ordering::greater&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; , &lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 있다 &lt;code&gt;equal&lt;/code&gt; 또는 &lt;code&gt;equivalent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f755b7dc0cfdc44f45a2b4967b0e34b372b2c615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::less&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;std::partial_ordering::greater&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, &lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equivalent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::less&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 것입니다 &lt;code&gt;less&lt;/code&gt; , &lt;code&gt;std::partial_ordering::greater&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 인 &lt;code&gt;greater&lt;/code&gt; , &lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; 경우 &lt;code&gt;v&lt;/code&gt; 있다 &lt;code&gt;equivalent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29e17d41a2e0da1646d774fd033ea7297c0c1823" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::unordered&lt;/code&gt; (&lt;code&gt;NaN &amp;lt;=&amp;gt; anything&lt;/code&gt; is unordered)</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::unordered&lt;/code&gt; ( &lt;code&gt;NaN &amp;lt;=&amp;gt; anything&lt;/code&gt; 정렬되지 )</target>
        </trans-unit>
        <trans-unit id="78e4fca92581bdc680ad0458a9583ac6d73d4986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering&lt;/code&gt; is implicitly-convertible to &lt;code&gt;std::weak_equality&lt;/code&gt;, while both &lt;code&gt;std::strong_ordering&lt;/code&gt; and &lt;code&gt;std::weak_ordering&lt;/code&gt; are implicitly-convertible to &lt;code&gt;partial_ordering&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::partial_ordering&lt;/code&gt; 은 &lt;code&gt;std::weak_equality&lt;/code&gt; 로 암시 적으로 변환 가능 하지만 &lt;code&gt;std::strong_ordering&lt;/code&gt; 및 &lt;code&gt;std::weak_ordering&lt;/code&gt; 은 &lt;code&gt;partial_ordering&lt;/code&gt; 으로 암시 적으로 변환 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="d9adc5c14a63be0c211528ab8475e8423b5ff9b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::path&lt;/code&gt; class and &lt;a href=&quot;filesystem&quot;&gt; supporting functions&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;std::path&lt;/code&gt; 클래스 및 &lt;a href=&quot;filesystem&quot;&gt;지원 함수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dea6211e610d9276a290efcf3829502f2aa014dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_constant_distribution&lt;/code&gt; produces random floating-point numbers, which are uniformly distributed within each of the several subintervals [b</source>
          <target state="translated">&lt;code&gt;std::piecewise_constant_distribution&lt;/code&gt; 은 임의의 부동 소수점 수를 생성하며, 이는 여러 하위 간격 각각에 균일하게 분포됩니다. [b</target>
        </trans-unit>
        <trans-unit id="43981d3cf9fce583c6f001f7d756c2307dfe7dcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_constant_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::piecewise_constant_distribution&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution의&lt;/a&gt; 모든 요구 사항을 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="1464d46a8a5b70bd224518f0ebc1bcbe92b2a5ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_construct_t&lt;/code&gt; is an empty struct tag type used to disambiguate between different functions that take two tuple arguments.</source>
          <target state="translated">&lt;code&gt;std::piecewise_construct_t&lt;/code&gt; 는 두 개의 튜플 인수를 취하는 다른 함수를 명확하게하는 데 사용되는 빈 구조체 태그 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1589591342e4d9b49b177cc62e6708def043ee9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_linear_distribution&lt;/code&gt; produces random floating-point numbers, which are distributed according to a linear probability density function within each of the several subintervals [b</source>
          <target state="translated">&lt;code&gt;std::piecewise_linear_distribution&lt;/code&gt; 은 임의의 부동 소수점 수를 생성합니다.이 부동 소수점 수는 여러 하위 간격 각각의 선형 확률 ​​밀도 함수에 따라 분포됩니다</target>
        </trans-unit>
        <trans-unit id="6d24b546da04ae6083af433d420f1dfdb16622bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_linear_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::piecewise_linear_distribution&lt;/code&gt; 은 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution의&lt;/a&gt; 모든 요구 사항을 충족 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5263eace8b3cd417f114a0429efd9c8136337a84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;char&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;char&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="04b0e71ade467ccdc8596cd285211653c3c4181d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;char16_t&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;char16_t&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="94c428b37d8b4967659c14af5dd6202e16b2d9ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;char32_t&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;char32_t&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="ac9449917132480eccdf004e14b3b3160c633149" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;char8_t&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;char8_t&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="07fb229870f46d1589fd827d7de6d407555b9a2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;wchar_t&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;wchar_t&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="a6ef8419a0f8f749d4b0898782b436f2688af048" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::cmatch&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::cmatch&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="2c1d8a2f1dae6d653b3d33d171a915438c729345" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::pool_options&lt;/code&gt; is a set of constructor options for pool resources including &lt;code&gt;&lt;a href=&quot;synchronized_pool_resource&quot;&gt;std::pmr::synchronized_pool_resource&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;unsynchronized_pool_resource&quot;&gt;std::pmr::unsynchronized_pool_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::pmr::pool_options&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;synchronized_pool_resource&quot;&gt;std::pmr::synchronized_pool_resource&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;unsynchronized_pool_resource&quot;&gt;std::pmr::unsynchronized_pool_resource&lt;/a&gt;&lt;/code&gt; 포함하여 풀 자원에 대한 생성자 옵션 세트입니다 .</target>
        </trans-unit>
        <trans-unit id="67af5bb43cec2dbc73e627d1f1b17685d821bdca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::smatch&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::smatch&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="ef61b23247e7c1bc5b192f4736b9280dc1125a43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::string&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::string&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="2f11f3c27c774ff34d4b096a46d172154a5427d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::u16string&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::u16string&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="fa425397581319f321b29dd377b961ea0133f7bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::u32string&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::u32string&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="b090acc3f6ab9d6b5a4bd4de89335d0125925c67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::u8string&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;std::pmr::u8string&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="a17934a01dbbcf98ddbb9d5caa50058446ce333c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::wcmatch&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::wcmatch&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="61828bbf68f417f4ded0154a94206ec249a946db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::wsmatch&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::wsmatch&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="b2e1399a9d01238f9ffc356412c4548413318ab1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::wstring&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::wstring&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="544a2203d7964b1cf3eb3f59b1daa5161af63173" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pointer_to_binary_function&lt;/code&gt; is a function object that acts as a wrapper around a binary function.</source>
          <target state="translated">&lt;code&gt;std::pointer_to_binary_function&lt;/code&gt; 은 이진 함수를 둘러싸는 래퍼 역할을하는 함수 객체입니다.</target>
        </trans-unit>
        <trans-unit id="68456b56f45eef4590adfe58b554b4aee2b82297" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pointer_to_unary_function&lt;/code&gt; is a function object that acts as a wrapper around a unary function.</source>
          <target state="translated">&lt;code&gt;std::pointer_to_unary_function&lt;/code&gt; 은 단항 함수 주위의 래퍼 역할을하는 함수 객체입니다.</target>
        </trans-unit>
        <trans-unit id="6c4a6649cb227401ea0fd4a3eae9fa3c98459c78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::poisson_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::poisson_distribution&lt;/code&gt; 은 RandomNumberDistribution을 충족 &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fff6237f139ed8631e6228d9bc6dc7571a699631" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ptrdiff_t&lt;/code&gt; is the signed integer type of the result of subtracting two pointers.</source>
          <target state="translated">&lt;code&gt;std::ptrdiff_t&lt;/code&gt; 는 두 개의 포인터를 뺀 결과의 부호있는 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bc3d3a0faaa081042eac5d79ba2d90b165298d55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ptrdiff_t&lt;/code&gt; is used for &lt;a href=&quot;../language/operator_arithmetic#Additive_operators&quot;&gt;pointer arithmetic&lt;/a&gt; and array indexing, if negative values are possible. Programs that use other types, such as &lt;code&gt;int&lt;/code&gt;, may fail on, e.g. 64-bit systems when the index exceeds &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or if it relies on 32-bit modular arithmetic.</source>
          <target state="translated">&lt;code&gt;std::ptrdiff_t&lt;/code&gt; 는 음수 값이 가능한 경우 &lt;a href=&quot;../language/operator_arithmetic#Additive_operators&quot;&gt;포인터 산술&lt;/a&gt; 및 배열 인덱싱에 사용됩니다. &lt;code&gt;int&lt;/code&gt; 와 같은 다른 유형을 사용하는 프로그램 은 인덱스가 &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 를 초과 하거나 32 비트 모듈 식 산술에 의존하는 경우 64 비트 시스템에서 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac06d091aeafa710860b79da85a4289003f2e0d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::random_device&lt;/code&gt; is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.</source>
          <target state="translated">&lt;code&gt;std::random_device&lt;/code&gt; 는 비 결정적 난수를 생성하는 균일하게 분포 된 정수 난수 생성기입니다.</target>
        </trans-unit>
        <trans-unit id="b78d53dcaf5721417ff464f5dc1b01db5da3e66e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::random_device&lt;/code&gt; may be implemented in terms of an implementation-defined pseudo-random number engine if a non-deterministic source (e.g. a hardware device) is not available to the implementation. In this case each &lt;code&gt;std::random_device&lt;/code&gt; object may generate the same number sequence.</source>
          <target state="translated">&lt;code&gt;std::random_device&lt;/code&gt; 는 비 결정적 소스 (예 : 하드웨어 장치)를 구현에 사용할 수없는 경우 구현 정의 의사 난수 엔진의 관점에서 구현 될 수 있습니다. 이 경우 각 &lt;code&gt;std::random_device&lt;/code&gt; 객체는 동일한 번호 시퀀스를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="733d010e28fb65a97f04138cd398414c0b48b706" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ratio&amp;lt;1, 1000000000000000000000&amp;gt;&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; can represent the denominator</source>
          <target state="translated">&lt;code&gt;std::ratio&amp;lt;1, 1000000000000000000000&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 가 분모를 나타낼 수있는 경우</target>
        </trans-unit>
        <trans-unit id="21491fc755d5ba9791f6cacc8c43d1f42d070141" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ratio&amp;lt;1, 1000000000000000000000000&amp;gt;&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; can represent the denominator</source>
          <target state="translated">&lt;code&gt;std::ratio&amp;lt;1, 1000000000000000000000000&amp;gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 가 분모를 나타낼 수있는 경우 std :: ratio &amp;lt;1, 1000000000000000000000000&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cef43fbd2779ce1f8654b5f38187591e6ca329ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ratio&amp;lt;1000000000000000000000, 1&amp;gt;&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; can represent the numerator</source>
          <target state="translated">&lt;code&gt;std::ratio&amp;lt;1000000000000000000000, 1&amp;gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 가 분자를 나타낼 수있는 경우 std :: ratio &amp;lt;1000000000000000000000, 1&amp;gt;</target>
        </trans-unit>
        <trans-unit id="68ad18182f2c368fdb975c210404ad0c9e06d4c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ratio&amp;lt;1000000000000000000000000, 1&amp;gt;&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; can represent the numerator</source>
          <target state="translated">&lt;code&gt;std::ratio&amp;lt;1000000000000000000000000, 1&amp;gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 가 분자를 나타낼 수있는 경우 std :: ratio &amp;lt;1000000000000000000000000, 1&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9c98cc470e8b16991d06d8bc751dbdd401256821" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reference_wrapper&lt;/code&gt; is a class template that wraps a reference in a copyable, assignable object. It is frequently used as a mechanism to store references inside standard containers (like &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;) which cannot normally hold references.</source>
          <target state="translated">&lt;code&gt;std::reference_wrapper&lt;/code&gt; 는 참조를 복사 가능하고 할당 가능한 객체로 래핑하는 클래스 템플릿입니다. 일반적으로 참조를 보유 할 수없는 표준 컨테이너 ( &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; ) 내에 참조를 저장하는 메커니즘으로 자주 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="af9950592969ef1f447e03a8e3965b2efd182067" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reference_wrapper&lt;/code&gt; is also used to pass objects by reference to &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, the constructor of &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;, or the helper functions &lt;code&gt;&lt;a href=&quot;../pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::reference_wrapper&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 의 생성자 또는 도우미 함수 &lt;code&gt;&lt;a href=&quot;../pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;&lt;/code&gt; 을 참조하여 객체를 전달하는 데에도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="22aa124fedb12c1ebec2890071b10e4252dc0665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reference_wrapper&lt;/code&gt; is guaranteed to be &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::reference_wrapper&lt;/code&gt; 는 &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e00c06df8463f4c62b5c854d2d046dfde8ce082d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::regex_iterator&lt;/code&gt; is a read-only iterator that accesses the individual matches of a regular expression within the underlying character sequence. It meets the requirements of a &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, except that for dereferenceable values &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; with &lt;code&gt;a == b&lt;/code&gt;, &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; will not be bound to the same object.</source>
          <target state="translated">&lt;code&gt;std::regex_iterator&lt;/code&gt; 는 기본 문자 시퀀스 내에서 정규 표현식의 개별 일치 항목에 액세스하는 읽기 전용 반복기입니다. 역 참조 가능한 값 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;a == b&lt;/code&gt; 경우 &lt;code&gt;*a&lt;/code&gt; 및 &lt;code&gt;*b&lt;/code&gt; 가 동일한 객체에 바인딩되지 않는다는 점을 제외 하면 &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; 의 요구 사항을 충족 합니다.</target>
        </trans-unit>
        <trans-unit id="ee427776b3ed6eca5825984efc250d1c3eb23dfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::regex_token_iterator&lt;/code&gt; is a read-only &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; that accesses the individual sub-matches of every match of a regular expression within the underlying character sequence. It can also be used to access the parts of the sequence that were not matched by the given regular expression (e.g. as a tokenizer).</source>
          <target state="translated">&lt;code&gt;std::regex_token_iterator&lt;/code&gt; 는 읽기 전용 &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator로&lt;/a&gt; , 기본 문자 시퀀스 내에서 정규 표현식의 모든 일치 항목에 대한 개별 하위 일치 항목에 액세스합니다. 주어진 정규 표현식과 일치하지 않는 시퀀스 부분 (예 : 토크 나이저)에 액세스하는 데에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67f2f3cf0fd664c7dfb87b979c353b536d657206" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::regex_traits::char_class_type&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;std::regex_traits::char_class_type&lt;/code&gt; (C ++ 11부터)</target>
        </trans-unit>
        <trans-unit id="8a7c1a8e462c9be7b58d511576da4998a286bbdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reverse_iterator&lt;/code&gt; does not work with iterators that return a reference to a member object (so-called &quot;stashing iterators&quot;). An example of stashing iterator is &lt;a href=&quot;../filesystem/path#Member_types_and_constants&quot;&gt;&lt;code&gt;std::filesystem::path::iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::reverse_iterator&lt;/code&gt; 는 멤버 객체 ( &quot;stashing iterators&quot;라고 함)에 대한 참조를 반환하는 반복자에서는 작동하지 않습니다. 숨김 반복기의 예는 &lt;a href=&quot;../filesystem/path#Member_types_and_constants&quot;&gt; &lt;code&gt;std::filesystem::path::iterator&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8bc574a36f080c60bc0dcdc67f6fbe182967c6a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reverse_iterator&lt;/code&gt; is an iterator adaptor that reverses the direction of a given iterator. In other words, when provided with a bidirectional iterator, &lt;code&gt;std::reverse_iterator&lt;/code&gt; produces a new iterator that moves from the end to the beginning of the sequence defined by the underlying bidirectional iterator.</source>
          <target state="translated">&lt;code&gt;std::reverse_iterator&lt;/code&gt; 는 주어진 반복자의 방향을 바꾸는 반복자 어댑터입니다. 즉, 양방향 반복기가 제공되면 &lt;code&gt;std::reverse_iterator&lt;/code&gt; 는 기본 양방향 반복기에 의해 정의 된 시퀀스의 끝에서 시작으로 이동하는 새로운 반복기를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="06e6eb01ef0888fc5786006b255e0262355a35cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::rotate&lt;/code&gt; is a common building block in many algorithms. This example demonstrates insertion sort:</source>
          <target state="translated">&lt;code&gt;std::rotate&lt;/code&gt; 는 많은 알고리즘에서 공통적 인 구성 요소입니다. 이 예제는 삽입 정렬을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f441eb26d364454c44afbcadef7f5d66d2c48d76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::seed_seq&lt;/code&gt; consumes a sequence of integer-valued data and produces a requested number of unsigned integer values &lt;code&gt;i&lt;/code&gt;, 0 &amp;le; i &amp;lt; 232</source>
          <target state="translated">&lt;code&gt;std::seed_seq&lt;/code&gt; 는 일련의 정수 값 데이터를 소비하고 요청 된 수의 부호없는 정수 값 &lt;code&gt;i&lt;/code&gt; , 0 &amp;le; i &amp;lt;232를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9c2a99a1055ff146aefbad3ed9afa018825c25dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::seed_seq&lt;/code&gt; meets the requirements of &lt;a href=&quot;../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::seed_seq&lt;/code&gt; 의 요구 사항을 충족 &lt;a href=&quot;../../named_req/seedsequence&quot;&gt;SeedSequence을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4c8bb8b1657216775cfa8413677c1cdf341b425" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::set&lt;/code&gt; is an associative container that contains a sorted set of unique objects of type &lt;code&gt;Key&lt;/code&gt;. Sorting is done using the key comparison function &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt;. Search, removal, and insertion operations have logarithmic complexity. Sets are usually implemented as &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;red-black trees&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::set&lt;/code&gt; 은 &lt;code&gt;Key&lt;/code&gt; 유형의 정렬 된 고유 오브젝트 세트를 포함하는 연관 컨테이너입니다 . 키 비교 기능인 &lt;a href=&quot;../named_req/compare&quot;&gt;Compare를&lt;/a&gt; 사용하여 정렬합니다 . 검색, 제거 및 삽입 작업에는 로그가 복잡합니다. 세트는 일반적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;빨강-검은 나무&lt;/a&gt; 로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2c918ca952dcd23d77f536141c1af09ae7aa661" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::set&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::set&lt;/code&gt; 은 &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; , &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; , &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; 및 &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; 의 요구 사항을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="cd33c830f9ff0669a2f536be537d8c93a0a03b50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::shared_ptr&lt;/code&gt; is a smart pointer that retains shared ownership of an object through a pointer. Several &lt;code&gt;shared_ptr&lt;/code&gt; objects may own the same object. The object is destroyed and its memory deallocated when either of the following happens:</source>
          <target state="translated">&lt;code&gt;std::shared_ptr&lt;/code&gt; 은 포인터를 통해 객체의 공유 소유권을 유지하는 스마트 포인터입니다. 여러 &lt;code&gt;shared_ptr&lt;/code&gt; 객체는 동일한 객체를 소유 할 수 있습니다. 다음 중 하나가 발생하면 객체가 삭제되고 메모리 할당이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="fabbfc740b8d37fb726de4a43248fcefc33b4a9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::shared_ptr&lt;/code&gt; may be used with an &lt;a href=&quot;../language/incomplete_type&quot;&gt;incomplete type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;. However, the constructor from a raw pointer (&lt;code&gt;template&amp;lt;class Y&amp;gt; shared_ptr(Y*)&lt;/code&gt;) and the &lt;code&gt;template&amp;lt;class Y&amp;gt; void reset(Y*)&lt;/code&gt; member function may only be called with a pointer to a complete type (note that &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; may be constructed from a raw pointer to an incomplete type).</source>
          <target state="translated">&lt;code&gt;std::shared_ptr&lt;/code&gt; 은 &lt;a href=&quot;../language/incomplete_type&quot;&gt;불완전한 유형 &lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 와 함께 사용될 수 있습니다 . 그러나 원시 포인터 ( &lt;code&gt;template&amp;lt;class Y&amp;gt; shared_ptr(Y*)&lt;/code&gt; ) 및 &lt;code&gt;template&amp;lt;class Y&amp;gt; void reset(Y*)&lt;/code&gt; 멤버 함수 의 생성자 는 완전한 유형에 대한 포인터로만 호출 할 수 있습니다 ( &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 은 원시 포인터에서 불완전한 유형으로 구성 될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="03a4c722a55044327e4cfffa724449a4b88da0ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::signal&lt;/code&gt; with the first argument being the number of the signal currently handled (async handler can re-register itself, but not other signals).</source>
          <target state="translated">&lt;code&gt;std::signal&lt;/code&gt; 첫 번째 인수는 현재 처리 된 신호의 수입니다 (비동기 처리기는 자체 재 등록 할 수 있지만 다른 신호는 재 등록 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="c2254b3548faa8b27fc548641136852a0c03336b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::signal&lt;/code&gt; with the first argument being the number of the signal currently handled (signal handler can re-register itself, but not other signals).</source>
          <target state="translated">&lt;code&gt;std::signal&lt;/code&gt; 첫 번째 인수는 현재 처리 된 신호의 번호입니다 (신호 핸들러는 다른 신호는 재 등록 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="ca1e54b99db001a5b4190a0c7f3d8fffb71fc24f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::size_t&lt;/code&gt; can store the maximum size of a theoretically possible object of any type (including array). A type whose size cannot be represented by &lt;code&gt;std::size_t&lt;/code&gt; is ill-formed(since C++14) On many platforms (an exception is systems with segmented addressing) &lt;code&gt;std::size_t&lt;/code&gt; can safely store the value of any non-member pointer, in which case it is synonymous with &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::uintptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::size_t&lt;/code&gt; 는 이론적으로 가능한 모든 유형 (배열 포함)의 최대 크기를 저장할 수 있습니다. &lt;code&gt;std::size_t&lt;/code&gt; 로 크기를 표현할 수없는 유형 은 잘못 구성되어 있습니다 (C ++ 14부터). 많은 플랫폼에서 (세그먼트 된 주소 지정이있는 시스템은 예외입니다) &lt;code&gt;std::size_t&lt;/code&gt; 는 비 멤버 포인터의 값을 안전하게 저장할 수 있습니다 이 경우 &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::uintptr_t&lt;/a&gt;&lt;/code&gt; 와 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="290cfac85ab67a680f302b6463b3fa047ee441eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::size_t&lt;/code&gt; is commonly used for array indexing and loop counting. Programs that use other types, such as &lt;code&gt;unsigned int&lt;/code&gt;, for array indexing may fail on, e.g. 64-bit systems when the index exceeds &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;UINT_MAX&lt;/a&gt;&lt;/code&gt; or if it relies on 32-bit modular arithmetic.</source>
          <target state="translated">&lt;code&gt;std::size_t&lt;/code&gt; 는 일반적으로 배열 인덱싱 및 루프 카운팅에 사용됩니다. 배열 인덱싱에 &lt;code&gt;unsigned int&lt;/code&gt; 와 같은 다른 유형을 사용하는 프로그램 은 인덱스가 &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;UINT_MAX&lt;/a&gt;&lt;/code&gt; 를 초과 하거나 32 비트 모듈 식 산술에 의존하는 경우 64 비트 시스템에서 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="056a9dc0cc03d5b2db95e167d1072f198456cc3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::size_t&lt;/code&gt; is the unsigned integer type of the result of the &lt;a href=&quot;../language/sizeof&quot;&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/a&gt; operator as well as the &lt;a href=&quot;../language/sizeof...&quot;&gt;&lt;code&gt;sizeof...&lt;/code&gt;&lt;/a&gt; operator and the &lt;a href=&quot;../language/alignof&quot;&gt;&lt;code&gt;alignof&lt;/code&gt;&lt;/a&gt; operator(since C++11).</source>
          <target state="translated">&lt;code&gt;std::size_t&lt;/code&gt; 는 &lt;a href=&quot;../language/sizeof&quot;&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;/a&gt; 연산자와 &lt;a href=&quot;../language/sizeof...&quot;&gt; &lt;code&gt;sizeof...&lt;/code&gt; &lt;/a&gt; 연산자 및 &lt;a href=&quot;../language/alignof&quot;&gt; &lt;code&gt;alignof&lt;/code&gt; &lt;/a&gt; 연산자 (C ++ 11부터) 의 결과에 대한 부호없는 정수 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="47242d9af8e0da2cd80e37ba7d69dc7cc3832e0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::slice&lt;/code&gt; is the selector class that identifies a subset of &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; similar to &lt;a href=&quot;https://en.wikipedia.org/wiki/BLAS&quot;&gt;BLAS&lt;/a&gt; slice. An object of type &lt;code&gt;std::slice&lt;/code&gt; holds three values: the starting index, the stride, and the total number of values in the subset. Objects of type &lt;code&gt;std::slice&lt;/code&gt; can be used as indexes with valarray's &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::slice&lt;/code&gt; 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/BLAS&quot;&gt;BLAS&lt;/a&gt; 슬라이스 와 유사한 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 의 하위 집합을 식별하는 선택기 클래스입니다 . &lt;code&gt;std::slice&lt;/code&gt; 유형의 오브젝트 에는 세 가지 값 (시작 색인, 보폭 및 서브 세트의 총 값 수)이 있습니다. &lt;code&gt;std::slice&lt;/code&gt; 유형의 객체는 valarray의 &lt;code&gt;operator[]&lt;/code&gt; 사용하여 인덱스로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc6ba21c4316c6b51a3cf612a94f1cb6a3023448" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::slice_array&lt;/code&gt; is a helper template used by &lt;code&gt;&lt;a href=&quot;slice&quot;&gt;std::slice&lt;/a&gt;&lt;/code&gt; subscript operator. It has reference semantics to a subset of the array specified by the &lt;code&gt;std::slice&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;std::slice_array&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;slice&quot;&gt;std::slice&lt;/a&gt;&lt;/code&gt; 첨자 연산자가 사용하는 도우미 템플릿 입니다. &lt;code&gt;std::slice&lt;/code&gt; 객체로 지정된 배열의 하위 집합에 대한 참조 의미가 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
