<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="e9ad164a9bae7d10fe5fec949515a05485fa2d71" translate="yes" xml:space="preserve">
          <source>The supplied version of the header &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; shall declare at least the functions &lt;code&gt;&lt;a href=&quot;utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;utility/program/quick_exit&quot;&gt;std::quick_exit&lt;/a&gt;&lt;/code&gt;(since C++11).</source>
          <target state="translated">&lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; 헤더의 제공된 버전은 최소한 &lt;code&gt;&lt;a href=&quot;utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/program/at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;utility/program/quick_exit&quot;&gt;std::quick_exit&lt;/a&gt;&lt;/code&gt; 함수를 선언해야합니다 (C ++ 11부터).</target>
        </trans-unit>
        <trans-unit id="5b99d0c2b824af433d36c158441c754d3faf4148" translate="yes" xml:space="preserve">
          <source>The swap functions do not invalidate any of the iterators inside the container, but they do invalidate the iterator marking the end of the swap region.</source>
          <target state="translated">스왑 함수는 컨테이너 내부의 반복자를 무효화하지 않지만 스왑 영역의 끝을 표시하는 반복자를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="21c84344f10b85ba83941112b65c0b80df28cba9" translate="yes" xml:space="preserve">
          <source>The synchronization is established only between the threads</source>
          <target state="translated">스레드간에 만 동기화가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="af5a157ab893f882387e99debe5b0576aec5458b" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;T object();&lt;/code&gt; does not initialize an object; it declares a function that takes no arguments and returns &lt;code&gt;T&lt;/code&gt;. The way to value-initialize a named variable before C++11 was &lt;code&gt;T object = T();&lt;/code&gt;, which value-initializes a temporary and then copy-initializes the object: most compilers &lt;a href=&quot;copy_elision&quot;&gt;optimize out the copy&lt;/a&gt; in this case.</source>
          <target state="translated">구문 &lt;code&gt;T object();&lt;/code&gt; 객체를 초기화하지 않습니다. 인수를 취하지 않고 &lt;code&gt;T&lt;/code&gt; 를 반환하는 함수를 선언합니다 . C ++ 11 이전에 명명 된 변수를 값으로 초기화하는 방법은 &lt;code&gt;T object = T();&lt;/code&gt; 임시 값을 초기화 한 다음 객체를 복사 초기화합니다. 대부분의 컴파일러 는이 경우 &lt;a href=&quot;copy_elision&quot;&gt;복사본&lt;/a&gt; 을 최적화합니다 .</target>
        </trans-unit>
        <trans-unit id="ae224bb840d8d7b9d78b650bc1b03492b672c0b6" translate="yes" xml:space="preserve">
          <source>The syntax forms (3,4) are known as designated initializers: each designator must name a direct non-static data members of T, and all designators used in the expression must appear in the same order as the data members of T.</source>
          <target state="translated">구문 형식 (3,4)은 지정된 이니셜 라이저로 알려져 있습니다. 각 지정자는 T의 직접 비 정적 데이터 멤버의 이름을 지정해야하며 표현식에 사용 된 모든 지정자는 T의 데이터 멤버와 동일한 순서로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="f00bfbaecf20babfadbc5e22b52d48a548c5a848" translate="yes" xml:space="preserve">
          <source>The syntax of</source>
          <target state="translated">문법</target>
        </trans-unit>
        <trans-unit id="6f89d606c1975f38aa5544527e8e97e16b6bb96a" translate="yes" xml:space="preserve">
          <source>The syntax of a function-like macro invocation is similar to the syntax of a function call: each instance of the macro name followed by a &lt;code&gt;(&lt;/code&gt; as the next preprocessing token introduces the sequence of tokens that is replaced by the replacement-list. The sequence is terminated by the matching &lt;code&gt;)&lt;/code&gt; token, skipping intervening matched pairs of left and right parentheses.</source>
          <target state="translated">함수와 유사한 매크로 호출의 구문은 함수 호출의 구문과 유사합니다. 매크로 이름의 각 인스턴스 뒤에 &lt;code&gt;(&lt;/code&gt; 다음 전처리 토큰이 대체 목록으로 대체되는 토큰 시퀀스를 소개하므로) 일치하는 &lt;code&gt;)&lt;/code&gt; 토큰으로 종료되고 일치하는 왼쪽 및 오른쪽 괄호 쌍을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="9bcf66af5c16c1977a2766c06868ed208b549d02" translate="yes" xml:space="preserve">
          <source>The syntax of a user-defined deduction guide is the syntax of a function declaration with a trailing return type, except that it uses the name of a class template as the function name:</source>
          <target state="translated">사용자 정의 추론 안내서의 구문은 클래스 템플릿의 이름을 함수 이름으로 사용한다는 점을 제외하고 후행 반환 유형의 함수 선언 구문입니다.</target>
        </trans-unit>
        <trans-unit id="de7f5913c9173da622b172081363583fac269c9b" translate="yes" xml:space="preserve">
          <source>The syntax of an individual capture in captures is.</source>
          <target state="translated">캡처에서 개별 캡처의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="702f4bc2e64078809bb1b5388513237231aab2e6" translate="yes" xml:space="preserve">
          <source>The system-supplied locales normally do not collate two strings as equivalent (&lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; does not return &lt;code&gt;​0​&lt;/code&gt;) if &lt;a href=&quot;../../string/basic_string/operator_cmp&quot;&gt;&lt;code&gt;basic_string::operator==&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;, but a user-installed &lt;code&gt;&lt;a href=&quot;../collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet may provide different collation rules, for example, it may treat strings as equivalent if they have the same Unicode normalized form.</source>
          <target state="translated">시스템 제공 로케일은 일반적으로 (동등하지 부씩 두 개의 문자열을 &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; 반환하지 않습니다 &lt;code&gt;​0​&lt;/code&gt; ) 경우 &lt;a href=&quot;../../string/basic_string/operator_cmp&quot;&gt; &lt;code&gt;basic_string::operator==&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;false&lt;/code&gt; 하지만 사용자가 설치 한 &lt;code&gt;&lt;a href=&quot;../collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; ,면 다른 조합 규칙을 제공 할 수있다 예를 들어, 동일한 유니 코드 정규화 형식을 가진 문자열을 동등한 것으로 취급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48237f3ec26215b3606e67c0e6d68687b01822f6" translate="yes" xml:space="preserve">
          <source>The target of the symlink (which may not necessarily exist).</source>
          <target state="translated">심볼릭 링크의 대상 (필수하지 않을 수도 있음)</target>
        </trans-unit>
        <trans-unit id="676256b3d34d8447f5998ce9c718f12a262b3700" translate="yes" xml:space="preserve">
          <source>The template argument that can be used with a non-type template parameter can be any &lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of the type of the template parameter.</source>
          <target state="translated">비 유형 템플릿 매개 변수와 함께 사용할 수있는 템플릿 인수는 템플릿 매개 변수 유형의 &lt;a href=&quot;constant_expression&quot;&gt;변환 된 상수 식일&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50cbc99825f7a6c9a124b9687858d33d44b2131c" translate="yes" xml:space="preserve">
          <source>The template can be specialized for user-defined iterators so that the information about the iterator can be retrieved even if the type does not provide the usual typedefs.</source>
          <target state="translated">유형이 일반적인 typedef를 제공하지 않더라도 반복자에 대한 정보를 검색 할 수 있도록 템플리트를 사용자 정의 반복기에 특화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="557201976e8a00a9ece65cd2feec4760fa0f5cd2" translate="yes" xml:space="preserve">
          <source>The template function &lt;code&gt;async&lt;/code&gt; runs the function &lt;code&gt;f&lt;/code&gt; asynchronously (potentially in a separate thread which may be part of a thread pool) and returns a &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; that will eventually hold the result of that function call.</source>
          <target state="translated">템플릿 함수 &lt;code&gt;async&lt;/code&gt; 는 함수 &lt;code&gt;f&lt;/code&gt; 를 비동기식으로 (잠재적으로 스레드 풀의 일부일 수있는 별도의 스레드에서) 실행하고 결국 해당 함수 호출의 결과를 보유 할 &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eff5e7944f6337f3549b2f87230ec73fcb57ba24" translate="yes" xml:space="preserve">
          <source>The template may be specialized for any user-defined &lt;code&gt;T&lt;/code&gt; type: the specialization must satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">템플릿은 사용자 정의에 대한 전문 될 수 있습니다 &lt;code&gt;T&lt;/code&gt; 의 유형 : 전문화가 만족해야 &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait을&lt;/a&gt; 함께</target>
        </trans-unit>
        <trans-unit id="57234bb7a67c620ea3f65bd79181da8581f11c93" translate="yes" xml:space="preserve">
          <source>The template parameter &lt;code&gt;TimeZonePtr&lt;/code&gt; allows users to supply their own time zone pointer types and further customize the behavior of &lt;code&gt;zoned_time&lt;/code&gt; via &lt;code&gt;std::chrono::zoned_traits&lt;/code&gt;. Custom time zone types need not support all the operations supported by &lt;code&gt;std::chrono::time_zone&lt;/code&gt;, only those used by the functions actually called on the &lt;code&gt;zoned_time&lt;/code&gt;.</source>
          <target state="translated">템플릿 매개 변수 &lt;code&gt;TimeZonePtr&lt;/code&gt; 을 사용하면 사용자가 고유 한 시간대 포인터 유형을 제공하고 &lt;code&gt;std::chrono::zoned_traits&lt;/code&gt; 를 통해 &lt;code&gt;zoned_time&lt;/code&gt; 의 동작을 추가로 사용자 정의 할 수 있습니다 . 사용자 정의 시간대 유형은 &lt;code&gt;std::chrono::time_zone&lt;/code&gt; 에서 지원하는 모든 조작을 지원할 필요는 없으며 &lt;code&gt;zoned_time&lt;/code&gt; 에서 실제로 호출 된 함수에서만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="976e95956188ddd1cc5dc013bb47e40cd53b4619" translate="yes" xml:space="preserve">
          <source>The template parameter list and the template argument list of a member of a partial specialization must match the parameter list and the argument list of the partial specialization.</source>
          <target state="translated">부분 특수화 구성원의 템플리트 매개 변수 목록 및 템플리트 인수 목록은 매개 변수 목록 및 부분 특수화의 인수 목록과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="35c19ab099f7c63eddf13b79738caebc5d6c5994" translate="yes" xml:space="preserve">
          <source>The template parameter list may be followed by an optional &lt;a href=&quot;constraints#Requires_clauses&quot;&gt;requires-clause&lt;/a&gt; that specifies the &lt;a href=&quot;constraints&quot;&gt;constraints&lt;/a&gt; on the template arguments.</source>
          <target state="translated">템플리트 매개 변수 목록 다음에 는 템플리트 인수에 대한 &lt;a href=&quot;constraints&quot;&gt;제한 조건&lt;/a&gt; 을 지정 하는 선택적 &lt;a href=&quot;constraints#Requires_clauses&quot;&gt;require-clause&lt;/a&gt; 가 올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e09d82796b1385db8c4e7f7eb0aae7cb58e1066" translate="yes" xml:space="preserve">
          <source>The template parameter lists of template template parameters can have their own default arguments, which are only in effect where the template template parameter itself is in scope:</source>
          <target state="translated">템플리트 템플리트 매개 변수의 템플리트 매개 변수 목록에는 고유 한 기본 인수가있을 수 있으며 이는 템플리트 템플리트 매개 변수 자체가 범위 내에있는 경우에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b6ab43de318de05ac5e805e82ee83900637e335" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; class allows users to obtain hashes of the identifiers of threads.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; 클래스에 대한 &lt;code&gt;&lt;a href=&quot;../../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 스레드 식별자의 해시를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1617c98734849159498d6d58c8ee6130545cbbf2" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5b98ae6aa533d3d486ad6a1f3c3dd5a2a2cc3c3" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="189f220de4b5df21be91fb36e6e09506d95caaf2" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; &amp;lt;T&amp;gt;에 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; &amp;lt;T&amp;gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fa82fede24ddf383b749f64c40120c7a6b969fc" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e08e96dcabc0ff66b712bd52aab0a0c10bbb4f5" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; &amp;lt;T, Deleter&amp;gt;에 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; &amp;lt;T, Deleter&amp;gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c9f3d1ec6cfcd95caae7ac3bda8cf8e03255245" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; &amp;lt;bool&amp;gt;에 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 특수화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; &amp;lt;bool&amp;gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d968cfa6e1f3e875e46aac917073ba195240e6bb" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; &amp;lt;N&amp;gt;에 대한 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 전문화를 통해 사용자는 &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; &amp;lt;N&amp;gt; 유형의 오브젝트 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce7952ddebf3c0d01e620facea4a820fd43fa101" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; class allows users to obtain hashes of the values contained in &lt;code&gt;optional&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; 클래스에 대한 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플리트 특수화를 통해 사용자는 &lt;code&gt;optional&lt;/code&gt; 오브젝트에 포함 된 값의 해시를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db5007b65d07bfed77b8824218281a413afda965" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; template allows users to obtain hashes of &lt;code&gt;variant&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; 템플릿에 대한 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플릿 전문화를 통해 &lt;code&gt;variant&lt;/code&gt; 객체의 해시를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ddcabf8bbccc8b0c948a37b70ba7a9f9c022693" translate="yes" xml:space="preserve">
          <source>The template specializations of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the various string classes allow users to obtain hashes of strings.</source>
          <target state="translated">다양한 문자열 클래스에 대한 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 의 템플릿 전문화를 통해 사용자는 문자열 해시를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="584921a66a2cf4fe71de6a59a91614782dd86242" translate="yes" xml:space="preserve">
          <source>The template version of this assignment operator in the specialization for arrays, &lt;code&gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt; behaves the same as in the primary template, except that will only participate in overload resolution if all of the following is true:</source>
          <target state="translated">배열 전문 &lt;code&gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt; 에서이 대입 연산자의 템플릿 버전은 기본 템플릿과 동일하게 동작하지만 다음 사항이 모두 참일 경우에만 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="0ac5be2688655da010f5c804e64763bf5f3459f9" translate="yes" xml:space="preserve">
          <source>The template version of this assignment operator only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not an array type and &lt;code&gt;unique_ptr&amp;lt;U,E&amp;gt;::pointer&lt;/code&gt; is implicitly convertible to &lt;code&gt;pointer&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;Deleter&amp;amp;, E&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;(since C++17).</source>
          <target state="translated">경우이 할당 연산자의 템플릿 버전은 오버로드 확인에 참여 &lt;code&gt;U&lt;/code&gt; 가 배열 형과 아닌 &lt;code&gt;unique_ptr&amp;lt;U,E&amp;gt;::pointer&lt;/code&gt; 로 암시 적으로 변환 가능한 &lt;code&gt;pointer&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;Deleter&amp;amp;, E&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; ( C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="22030dbd3e1d3908354d7549e8f30d9f71beae72" translate="yes" xml:space="preserve">
          <source>The templated class &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; generalizes how sequences of characters are manipulated and stored. String creation, manipulation, and destruction are all handled by a convenient set of class methods and related functions.</source>
          <target state="translated">템플릿 클래스 &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 은 일련의 문자를 조작하고 저장하는 방법을 일반화합니다. 문자열 생성, 조작 및 소멸은 모두 편리한 클래스 메소드 및 관련 함수 세트로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ae2a3669d2ccc3c953612c7002da0c5821d0cf01" translate="yes" xml:space="preserve">
          <source>The templated class &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; provides a lightweight object that offers read-only access to a string or a part of a string using an interface similar to the interface of &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">템플릿 기반 클래스는 &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; 이벤트의 인터페이스와 유사한 인터페이스를 사용하여 문자열 또는 문자열의 일부에 대한 읽기 전용 액세스하는 경량 객체 제공하는 &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5938eb91acf69026cdeecae1d1a114be0e7c8cbb" translate="yes" xml:space="preserve">
          <source>The temporary object is constructed from the function argument or return value, respectively, and the function's parameter or return object is initialized as if by using the non-deleted trivial constructor to copy the temporary (even if that constructor is inaccessible or would not be selected by overload resolution to perform a copy or move of the object).</source>
          <target state="translated">임시 객체는 각각 함수 인수 또는 반환 값으로 구성되며, 삭제되지 않은 간단한 생성자를 사용하여 임시를 복사하는 것처럼 (해당 생성자가 액세스 할 수 없거나 선택되지 않은 경우에도) 함수의 매개 변수 또는 반환 객체가 초기화됩니다. 오버로드 해상도로 복사 또는 개체 이동).</target>
        </trans-unit>
        <trans-unit id="d35cf85afe81dba05bfcd30078a13ec4b61a6248" translate="yes" xml:space="preserve">
          <source>The terminating null character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 의 종료 널 문자 는 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b502a26934eaa1380b44846902030ef133c5174" translate="yes" xml:space="preserve">
          <source>The terminating null character is considered to be a part of the string and can be found if searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">종료 널 문자는 문자열의 일부로 간주되며 &lt;code&gt;'\0'&lt;/code&gt; 검색하면 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e942509d6816ccf9d123b1cf1595fd4cb7dbdb4" translate="yes" xml:space="preserve">
          <source>The terminating null wide character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 의 종료 널 와이드 문자 는 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f64c2cf450c071f73e284e57290f6f2917e30baf" translate="yes" xml:space="preserve">
          <source>The test &lt;code&gt;ptr-&amp;gt;weak_this.expired()&lt;/code&gt; in the exposition code above makes sure that &lt;code&gt;weak_this&lt;/code&gt; is not reassigned if it already indicates an owner. This test is required as of C++17.</source>
          <target state="translated">위의 박람회 코드에서 테스트 &lt;code&gt;ptr-&amp;gt;weak_this.expired()&lt;/code&gt; 는 &lt;code&gt;weak_this&lt;/code&gt; 가 이미 소유자를 나타내는 경우 재 할당되지 않도록합니다 . 이 테스트는 C ++ 17부터 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a76ffdb1119a59ee47d50b27acec60df78d37530" translate="yes" xml:space="preserve">
          <source>The textual representation is written with &lt;code&gt;os.fmtflags&lt;/code&gt; set to &lt;code&gt;ios_base::dec&lt;/code&gt;|&lt;code&gt;ios_base::left&lt;/code&gt; and the fill character set to the space character. The textual representation of the engine's internal state is a set of decimal numbers separated by spaces.</source>
          <target state="translated">텍스트 표현은 &lt;code&gt;os.fmtflags&lt;/code&gt; 를 &lt;code&gt;ios_base::dec&lt;/code&gt; | &lt;code&gt;ios_base::left&lt;/code&gt; 및 채우기 문자는 공백 문자로 설정됩니다. 엔진 내부 상태의 텍스트 표현은 공백으로 구분 된 십진수 세트입니다.</target>
        </trans-unit>
        <trans-unit id="a79d1b4a44870cfcd4b53d3f95a0c8fcc074b16b" translate="yes" xml:space="preserve">
          <source>The textual representation of &lt;code&gt;A&lt;/code&gt; includes the textual representation of &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">의 텍스트 표현 &lt;code&gt;A&lt;/code&gt; 는 의 텍스트 표현을 포함하는 &lt;code&gt;B&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="484f772cf54bb66a16db5954b6b4e3c3d93ea751" translate="yes" xml:space="preserve">
          <source>The thread that intends to modify the variable has to.</source>
          <target state="translated">변수를 수정하려는 스레드가해야합니다.</target>
        </trans-unit>
        <trans-unit id="e07534c510b6011cf58e1ef843a07565960e50d4" translate="yes" xml:space="preserve">
          <source>The three-way comparison operator expressions have the form.</source>
          <target state="translated">3 방향 비교 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab243e4025d54ef42cc354407fff2484190465e4" translate="yes" xml:space="preserve">
          <source>The throw-expression &lt;code&gt;throw &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;;&lt;/code&gt; is not guaranteed to be matched by a pointer catch clause, because the exception object type may be &lt;code&gt;int&lt;/code&gt;, but &lt;code&gt;throw nullptr;&lt;/code&gt; is assuredly matched by any pointer or pointer-to-member catch clause.</source>
          <target state="translated">throw-expression &lt;code&gt;throw &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;;&lt;/code&gt; 예외 객체 유형이 &lt;code&gt;int&lt;/code&gt; 일 수 있지만 &lt;code&gt;throw nullptr;&lt;/code&gt; 때문에 포인터 catch 절과 일치한다고 보장되지 않습니다 . 모든 포인터 또는 포인터 대 구성원 catch 절과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7ac8ab79b96ed80e6fe4f38b7019eb38273067c1" translate="yes" xml:space="preserve">
          <source>The throw-expression is classified as &lt;a href=&quot;value_category&quot;&gt;prvalue expression&lt;/a&gt; of type &lt;code&gt;void&lt;/code&gt;. Like any other expression, it may be a sub-expression in another expression, most commonly in the &lt;a href=&quot;operator_other#Conditional_operator&quot;&gt;conditional operator&lt;/a&gt;:</source>
          <target state="translated">throw-expression은 &lt;code&gt;void&lt;/code&gt; 유형의 &lt;a href=&quot;value_category&quot;&gt;prvalue expression&lt;/a&gt; 으로 분류됩니다 . 다른 표현식과 마찬가지로 다른 표현식의 하위 표현식 일 수 있습니다. 가장 일반적으로 &lt;a href=&quot;operator_other#Conditional_operator&quot;&gt;조건부 연산자에서는&lt;/a&gt; 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f868d34253cbb949d0014de0f9071a9627d84ee5" translate="yes" xml:space="preserve">
          <source>The throwing overload is additionally specified to throw &lt;code&gt;&lt;a href=&quot;filesystem_error&quot;&gt;std::filesystem::filesystem_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;status(p)&lt;/code&gt; would throw.</source>
          <target state="translated">&lt;code&gt;status(p)&lt;/code&gt; 가 발생하면 &lt;code&gt;&lt;a href=&quot;filesystem_error&quot;&gt;std::filesystem::filesystem_error&lt;/a&gt;&lt;/code&gt; 발생 시키도록 발생하는 과부하가 추가로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc934bec30518ea798c5b7ac6343fa0fedd9880c" translate="yes" xml:space="preserve">
          <source>The tick period of the clock in seconds.</source>
          <target state="translated">시계의 틱 기간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="2af4361db95a4cd97928b9e845816898c3e9820b" translate="yes" xml:space="preserve">
          <source>The tied stream, or a null pointer if there was no tied stream.</source>
          <target state="translated">연결된 스트림 또는 연결된 스트림이없는 경우 null 포인터.</target>
        </trans-unit>
        <trans-unit id="a5636311e3a8dbe661c517df9ff905b4bc0cff87" translate="yes" xml:space="preserve">
          <source>The time input manipulator &lt;code&gt;&lt;a href=&quot;../manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; (technically, &lt;a href=&quot;../../locale/time_get/get&quot;&gt;&lt;code&gt;time_get::get&lt;/code&gt;&lt;/a&gt; it calls), if the input cannot be unambiguously parsed as a time value according to the given format string.</source>
          <target state="translated">입력 을 주어진 형식 문자열에 따라 시간 값으로 명확하게 구문 분석 할 수없는 경우 시간 입력 조작기 &lt;code&gt;&lt;a href=&quot;../manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; (기술적으로 &lt;a href=&quot;../../locale/time_get/get&quot;&gt; &lt;code&gt;time_get::get&lt;/code&gt; &lt;/a&gt; 호출)입니다.</target>
        </trans-unit>
        <trans-unit id="9fa1c3ac8a91c2dbb258d7d0b1ca35724a76b047" translate="yes" xml:space="preserve">
          <source>The timeout has expired</source>
          <target state="translated">시간 초과가 만료되었습니다</target>
        </trans-unit>
        <trans-unit id="cda93e07e16d4fa1f6f842ae631aef263d983dc5" translate="yes" xml:space="preserve">
          <source>The top-level scope of a translation unit (&quot;file scope&quot; or &quot;global scope&quot;) is also a namespace and is properly called &quot;global namespace scope&quot;. The potential scope of any entity declared in the global namespace scope begins at the declaration and continues to the end of the translation unit.</source>
          <target state="translated">번역 단위의 최상위 범위 ( &quot;파일 범위&quot;또는 &quot;전역 범위&quot;)도 네임 스페이스이며 &quot;글로벌 네임 스페이스 범위&quot;라고합니다. 글로벌 네임 스페이스 범위에 선언 된 엔터티의 잠재적 범위는 선언에서 시작하여 번역 단위의 끝까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b95d9b7d4331d266dae2fa32fe8fccb817c35a" translate="yes" xml:space="preserve">
          <source>The trait &lt;code&gt;std::is_copy_assignable&lt;/code&gt; is less strict than &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; because it does not check the type of the result of the assignment (which, for a &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; type, must be an lvalue of type &lt;code&gt;T&lt;/code&gt;) and does not check the semantic requirement that the argument expression remains unchanged. It also does not check that &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, which is required of all &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; types.</source>
          <target state="translated">특성 &lt;code&gt;std::is_copy_assignable&lt;/code&gt; 은 할당 결과의 유형을 검사하지 않으므로 ( &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 유형의 경우 &lt;code&gt;T&lt;/code&gt; 유형의 lvalue 여야 함 ) 인수가 의미하는 의미 요구 사항을 검사하지 않기 때문에 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 보다 덜 엄격 합니다. 표현은 변하지 않습니다. 또한 &lt;code&gt;T&lt;/code&gt; 가 모든 &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; 유형에 필요한 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable을&lt;/a&gt; 충족 하는지 확인하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="31f748256061c85c5babfc77d3f3bd56ed39666b" translate="yes" xml:space="preserve">
          <source>The trait &lt;code&gt;std::is_move_assignable&lt;/code&gt; is less strict than &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; because it does not check the type of the result of the assignment (which, for a &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; type, must be &lt;code&gt;T&amp;amp;&lt;/code&gt;), nor the semantic requirement that the target's value after the assignment is equivalent to the source's value before the assignment.</source>
          <target state="translated">&lt;code&gt;std::is_move_assignable&lt;/code&gt; 특성 은 할당 결과의 유형 ( &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 유형의 경우 &lt;code&gt;T&amp;amp;&lt;/code&gt; 이어야 함 ) 또는 할당 후 대상 값이 동일한 의미 론적 요구 사항을 확인하지 않기 때문에 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 보다 덜 엄격 합니다. 할당 전에 소스 값으로.</target>
        </trans-unit>
        <trans-unit id="c13322dcd5d602786d0d4da2697757a492c38ddc" translate="yes" xml:space="preserve">
          <source>The transformed type is a publicly accessible nested type named &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">변환 된 유형은 공개적으로 액세스 가능한 중첩 유형 인 &lt;code&gt;type&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd0c6a8d80fefbf063a7c6fc4d41e35477e554e0" translate="yes" xml:space="preserve">
          <source>The transition algorithm of the LCG function is x</source>
          <target state="translated">LCG 함수의 전이 알고리즘은 x입니다.</target>
        </trans-unit>
        <trans-unit id="ed030a839d21fbb758c903e3966139f3e58ea684" translate="yes" xml:space="preserve">
          <source>The tuple need not be &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, and instead may be anything that supports &lt;code&gt;std::get&lt;/code&gt; and &lt;code&gt;std::tuple_size&lt;/code&gt;; in particular, &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">튜플은 &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 일 필요는 없으며 대신 &lt;code&gt;std::get&lt;/code&gt; 및 &lt;code&gt;std::tuple_size&lt;/code&gt; 를 지원하는 것이 될 수 있습니다 . 특히, &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 가 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faab3655bae1576862bf3243d78b803053240daa" translate="yes" xml:space="preserve">
          <source>The tuple-like interpretation is always used if &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; is a complete type, even if that would cause the program to be ill-formed:</source>
          <target state="translated">튜플과 같은 해석은 &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; 가 완전한 유형 인 경우 프로그램이 잘못 구성 되더라도 항상 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="280f7270ad4976a06da0f10d73ed8109ee8c86a2" translate="yes" xml:space="preserve">
          <source>The two overloads are distinct because the types of the parameter &lt;code&gt;func&lt;/code&gt; are distinct (&lt;a href=&quot;../../language/language_linkage&quot;&gt;language linkage&lt;/a&gt; is part of its type).</source>
          <target state="translated">매개 변수 &lt;code&gt;func&lt;/code&gt; 의 유형이 다르기 때문에 두 개의 과부하가 서로 다릅니다 ( &lt;a href=&quot;../../language/language_linkage&quot;&gt;언어 연결&lt;/a&gt; 은 해당 유형의 일부 임).</target>
        </trans-unit>
        <trans-unit id="ced307005cb72698444581ef51d2ce693acf63e2" translate="yes" xml:space="preserve">
          <source>The two overloads provided by the C++ standard library are distinct because the types of the parameter &lt;code&gt;comp&lt;/code&gt; are distinct (&lt;a href=&quot;../language/language_linkage&quot;&gt;language linkage&lt;/a&gt; is part of its type).</source>
          <target state="translated">매개 변수 &lt;code&gt;comp&lt;/code&gt; 의 유형이 다르기 때문에 C ++ 표준 라이브러리에서 제공하는 두 개의 오버 로드 는 서로 다릅니다 ( &lt;a href=&quot;../language/language_linkage&quot;&gt;언어 연결&lt;/a&gt; 은 해당 유형의 일부 임).</target>
        </trans-unit>
        <trans-unit id="7e0c402d18cba21bbc3c62ac427b669b87db8687" translate="yes" xml:space="preserve">
          <source>The two-way comparison operator expressions have the form.</source>
          <target state="translated">양방향 비교 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b32340d0d14dfd5d1c51dde23771404f36595788" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="e3e4f9ee4f9a6dc679b68e252ddbe4d829628a2f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;D&lt;/code&gt; satisfies RandomNumberDistribution if.</source>
          <target state="translated">유형 &lt;code&gt;D&lt;/code&gt; 는 다음 경우 RandomNumberDistribution을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="9d9d3aa5279931f61ae09ea879f4c70a82c6ceaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;G&lt;/code&gt; satisfies UniformRandomBitGenerator if.</source>
          <target state="translated">유형 &lt;code&gt;G&lt;/code&gt; 는 UniformRandomBitGenerator를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="c21b37c97960f36e90434bac25ddcd2dc1e68569" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; 만족 &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2dca3e5d709f32f44d0ddfe5eab719ca4892184c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, and</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable을&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="23ab122f56da738cdd552f61aadec9d1cd833ab0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, and</source>
          <target state="translated">형식 &lt;code&gt;It&lt;/code&gt; &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible을&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="b6b3d6cdd7d4f3c9acce01cee40f271ece634a18" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; 만족 &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252d2ffb66f7d81557faa1f7f4f4ea09867d93b2" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; &lt;a href=&quot;destructible&quot;&gt;Destructible을&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="4b8f1bcfc4815dc189422b13e3981c0b3806ab7c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; 만족 &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable로&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7e27b1e0bc61deba4ad72e16345b7759b232775" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;It&lt;/code&gt; &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator를&lt;/a&gt; 만족시키는 유형</target>
        </trans-unit>
        <trans-unit id="8e98de10f38832410717d032044fe5876aae1620" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;It&lt;/code&gt; &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator를&lt;/a&gt; 만족시키는 유형</target>
        </trans-unit>
        <trans-unit id="19b959ec118b4fc4e346a0c4b3066583c69eb391" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; 만족 &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e6b1f70b5515f9b7f9ece951c8b0565a4faeae3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies ConstexprIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; ConstexprIterator를 충족시키는 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="99ec40230a473cc7e644a50a1f568278d332cce3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyBidirectionalIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; LegacyBidirectionalIterator를 충족시키는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="fb470c2619e1df677c704caef889c4118fc3151e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyContiguousIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; LegacyContiguousIterator를 충족시키는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="630cbbc2820c720d8b04165d105e0a9744bea443" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyForwardIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; LegacyForwardIterator를 충족시키는 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="0ffbcd885e9525a21db6be67dd85f4aff0c605f1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyInputIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; LegacyInputIterator를 충족시키는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="98c67370e8cebdd88c142031ae165afb773d121a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; LegacyIterator를 충족시키는 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="685b9ef2517672d40d4de466c9757d30ae0a366e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyRandomAccessIterator if.</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; LegacyRandomAccessIterator를 충족시키는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="c0271171a00bcc035de12ccb951df5f4eb58be30" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies some iterator requirements MeowIterator</source>
          <target state="translated">유형 &lt;code&gt;It&lt;/code&gt; 만족 일부 반복자 요구 사항을 MeowIterator</target>
        </trans-unit>
        <trans-unit id="3fa432a57da4f847b5c070a3bfc7c01c5763011a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">타입 &lt;code&gt;Ret&lt;/code&gt; 타입의 객체되도록 있어야 &lt;code&gt;ForwardIt&lt;/code&gt; 는 역 참조와 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3a1ebcc723e658952997b5498f82af157e85e51" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">유형 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체되도록 있어야 &lt;code&gt;OutputIt&lt;/code&gt; 는 역 참조와 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="949b21cde2cc2392d063407c9e220c78be2ec5c8" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;CopyInsertable&lt;/strong&gt; into the container &lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; into &lt;code&gt;X&lt;/code&gt;, and, given.</source>
          <target state="translated">타입 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;strong&gt;CopyInsertable&lt;/strong&gt; 용기에 &lt;code&gt;X&lt;/code&gt; 누구 &lt;code&gt;value_type&lt;/code&gt; 동일 &lt;code&gt;T&lt;/code&gt; 경우 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;a href=&quot;moveinsertable&quot;&gt;MoveInsertable를&lt;/a&gt; 로 &lt;code&gt;X&lt;/code&gt; 및 주어진.</target>
        </trans-unit>
        <trans-unit id="3d96c921cf6324f16eef56dd97bb17fac1318864" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;DefaultInsertable&lt;/strong&gt; into the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">타입 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;strong&gt;DefaultInsertable&lt;/strong&gt; 에 &lt;a href=&quot;container&quot;&gt;컨테이너 &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; &lt;code&gt;value_type&lt;/code&gt; 동일 &lt;code&gt;T&lt;/code&gt; 주어진 경우.</target>
        </trans-unit>
        <trans-unit id="4a2192b55df7721f52fc4a376a8910667373086e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;EmplaceConstructible&lt;/strong&gt; into the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; (whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt;) from the arguments &lt;code&gt;args&lt;/code&gt; if, given.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 주어진 경우 인수 &lt;code&gt;args&lt;/code&gt; 에서 &lt;a href=&quot;container&quot;&gt;컨테이너 &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; 에 대한 &lt;strong&gt;EmplaceConstructible입니다&lt;/strong&gt; ( &lt;code&gt;value_type&lt;/code&gt; 은 &lt;code&gt;T&lt;/code&gt; 와 동일 ) .</target>
        </trans-unit>
        <trans-unit id="5237f2595087683918faff0e0fb827167c77ec98" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;Erasable&lt;/strong&gt; from the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">타입 &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;strong&gt;소거&lt;/strong&gt; 로부터 &lt;a href=&quot;container&quot;&gt;컨테이너 &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; 그의 &lt;code&gt;value_type&lt;/code&gt; 동일 &lt;code&gt;T&lt;/code&gt; 주어진 경우.</target>
        </trans-unit>
        <trans-unit id="7c4f49cd45501a79870e1b3afa64d91ff0308500" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;MoveInsertable&lt;/strong&gt; into the container &lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 주어진 경우 &lt;code&gt;value_type&lt;/code&gt; 이 &lt;code&gt;T&lt;/code&gt; 와 동일한 컨테이너 &lt;code&gt;X&lt;/code&gt; 로 &lt;strong&gt;MoveInsertable&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e41120cbb6ece4723895cfa12eeda9a968c6032" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is not allowed to be an &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, even if the size or internal structure of &lt;code&gt;T&lt;/code&gt; is never used, as in &lt;code&gt;&amp;amp;x[0]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;x[0]&lt;/code&gt; 에서처럼 &lt;code&gt;T&lt;/code&gt; 의 크기 또는 내부 구조를 사용하지 않은 경우에도 &lt;code&gt;T&lt;/code&gt; 유형 은 &lt;a href=&quot;incomplete_type&quot;&gt;불완전한 유형&lt;/a&gt; 이 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="94188845ce20ed55f2a876e3342aa84bc7330295" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt;, and</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형 은 &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate를&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="4d4404ddfa538ff7555e67eecb1dbcc3ff5cdc1a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt;, &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형 은 &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt; , &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt; 및</target>
        </trans-unit>
        <trans-unit id="0db4b9570ecd95be9606704e9f21eff1149143a0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, and</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형 은 &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable을&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="6647adc652b8dbbc01016470d35eed7d2fe7e630" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;, and</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형 은 &lt;a href=&quot;moveconstructible&quot;&gt;MoveConstructible을&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="4262127f8a223198cec9f54e58d1717c6a50c453" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;code&gt;&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object&lt;/a&gt;&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형 은 &lt;code&gt;&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object&lt;/a&gt;&lt;/code&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="3f046e47e7505811e9555f3b245d7d20697f7a3e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Callable if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 호출 가능 if를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="49e6eff2866df130bb7fd318296a16096d51e92f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Compare if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 비교 경우를 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="66ff21aa578ecf4f62632269d8614fbe18a110bb" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies CopyAssignable if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 다음과 같은 경우 CopyAssignable을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="0ad2a77779033cb383bdf5ceddef00240ba13b76" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies CopyConstructible if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 다음과 같은 경우 CopyConstructible을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="2e05ec58d3dab38ca771379d16b2fe5adee88104" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies DefaultConstructible if.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형 은 DefaultConstructible if를 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="cc55fbe4fbf6e0f85ba467734b5b915583f84e1b" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Destructible if.</source>
          <target state="translated">타입 &lt;code&gt;T&lt;/code&gt; 는 파괴 가능한 경우를 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="dfe96628803d13e4d50a5465ce9ed6a67992a048" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies EqualityComparable if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 EqualityComparable if를 충족합니다.</target>
        </trans-unit>
        <trans-unit id="41ee5c2d1ddb0009a5b5ac10f88ce89d5cc10e9a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies FunctionObject if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 다음 경우에 FunctionObject를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="3ae67a347ab32c589872346530c83699208f4eaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Hash if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 해시를 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="9d2af4bf93a9ceba9a70379149efdadf03a56bc7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies LessThanComparable if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 LessThanComparable if를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="52a749029f41bfcab44646101c78f08a559bdcdd" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies MoveAssignable if.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 는 MoveAssignable을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="aaf38d3e0ca9bb3163280eb3190656f5f78d0b7e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies MoveConstructible if.</source>
          <target state="translated">타입 &lt;code&gt;T&lt;/code&gt; 는 MoveConstructible if를 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="3c095863553c4d9f9528e17b876f6565ea71dc1e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;TC::time_point::clock&lt;/code&gt; meets the TrivialClock requirements, recursively.</source>
          <target state="translated">&lt;code&gt;TC::time_point::clock&lt;/code&gt; 유형 은 재귀 적으로 TrivialClock 요구 사항을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="8c5bdf5c0ebdfaea70c628010c98d8c02bdb6a1e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">타입 &lt;code&gt;Type1&lt;/code&gt; 타입의 객체 있도록해야합니다 &lt;code&gt;ForwardIt&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type1&lt;/code&gt; . 유형 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야 &lt;code&gt;T&lt;/code&gt; 는 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76589c2d20456a54480cd63abef696cc4671a0d0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">타입 &lt;code&gt;Type1&lt;/code&gt; 유형의 객체 있도록해야 &lt;code&gt;T&lt;/code&gt; 는 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type1&lt;/code&gt; . 유형 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야합니다 &lt;code&gt;ForwardIt&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e15c34b8b5699cfcccd67dddcde261f5330e1e3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">타입 &lt;code&gt;Type1&lt;/code&gt; 유형의 객체 있도록해야 &lt;code&gt;T&lt;/code&gt; 는 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type1&lt;/code&gt; . 유형 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야합니다 &lt;code&gt;InputIt&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type2&lt;/code&gt; . 유형 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체되도록 있어야 &lt;code&gt;T&lt;/code&gt; 이 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c7c828977f3aee5181d50399292252dea34b2f7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">타입 &lt;code&gt;Type1&lt;/code&gt; 형식의 개체가되도록해야합니다 &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type1&lt;/code&gt; . 유형 &lt;code&gt;Type2&lt;/code&gt; 형식의 개체 있도록해야합니다 &lt;code&gt;InputIt&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type2&lt;/code&gt; . 유형 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체가되도록 있어야 &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="446f611669a83b2fef5ed0fe51541c392716bba5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">유형의 &lt;code&gt;Type&lt;/code&gt; 유형의 객체 있도록해야합니다 &lt;code&gt;InputIt&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a83e5bd1fdfaaf9d85e03162ceb874df7fc25ab" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">유형의 &lt;code&gt;Type&lt;/code&gt; 유형의 객체 있도록해야합니다 &lt;code&gt;InputIt&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type&lt;/code&gt; . 유형 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체되도록 있어야 &lt;code&gt;OutputIt&lt;/code&gt; 는 역 참조와 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f2ee2c7e39e16c2fc94f6e2cd419b938a6ba925" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;double&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;double&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">유형의 &lt;code&gt;Type&lt;/code&gt; 유형의 객체가되도록해야합니다 &lt;code&gt;double&lt;/code&gt; 역 참조 할 수 다음 암시 적 변환 &lt;code&gt;Type&lt;/code&gt; . 유형 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체되도록 있어야 &lt;code&gt;double&lt;/code&gt; 역 참조와 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b435ca7efbcb7d3a69a4c425c8166ae1ecf9b3b8" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 타입 은 &lt;a href=&quot;container&quot;&gt;컨테이너를&lt;/a&gt; 만족합니다</target>
        </trans-unit>
        <trans-unit id="51c4cd0302a38d9ca2d378e53146319f03ed2267" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;, and</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 유형 은 &lt;a href=&quot;container&quot;&gt;Container를&lt;/a&gt; 충족 하고</target>
        </trans-unit>
        <trans-unit id="6607d21d863fd1139823f255f3616f78582f1b99" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 유형 은 &lt;a href=&quot;iterator&quot;&gt;LegacyIterator를&lt;/a&gt; 충족합니다</target>
        </trans-unit>
        <trans-unit id="fd2220d4e7d2be0a6e2436dc20ed5fc81f925717" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies ContiguousContainer if.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 유형 은 ContiguousContainer를 만족시킵니다.</target>
        </trans-unit>
        <trans-unit id="9c59f17268ae0799c6c9ad4a2f510730b7974007" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies LegacyOutputIterator if.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 유형 은 다음 경우에 LegacyOutputIterator를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="4ce304e60343f172de9a358f8aec0594d119616e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies SequenceContainer if.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 유형 은 SequenceContainer를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="0b0a4238d5b55da548fec0c52f2f145ef62aca2f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; supports &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 유형 은 &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators를&lt;/a&gt; 지원합니다</target>
        </trans-unit>
        <trans-unit id="9c91c4098ab4ce6057b1eb103c2691ca5d989b78" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt; must be exactly</source>
          <target state="translated">유형의 &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt; 정확하게해야합니다</target>
        </trans-unit>
        <trans-unit id="3d90dab02f7f3b6e43e81a90b17cf46259c35fe4" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::negation&amp;lt;B&amp;gt;&lt;/code&gt; is a &lt;a href=&quot;../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with a BaseCharacteristic of &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::bool_constant&lt;/a&gt;&amp;lt;!bool(B::value)&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::negation&amp;lt;B&amp;gt;&lt;/code&gt; 유형 은 &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::bool_constant&lt;/a&gt;&amp;lt;!bool(B::value)&amp;gt;&lt;/code&gt; &amp;lt;! bool (B :: value)&amp;gt; 의 &lt;a href=&quot;../named_req/unarytypetrait&quot;&gt;BaseCharacteristic&lt;/a&gt; 을 가진 UnaryTypeTrait입니다 .</target>
        </trans-unit>
        <trans-unit id="83883f03d07c1a12ee9dfb5e67e0fc6f4a49f177" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::partial_ordering&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">&lt;code&gt;std::partial_ordering&lt;/code&gt; 유형 에는 네 가지 유효한 값이 있으며 해당 유형의 const 정적 데이터 멤버로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="baf068b5f9f0a2f3a687379dab87c44a84ac79f2" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::streamoff&lt;/code&gt; is a signed integral type of sufficient size to represent the maximum possible file size supported by the operating system. Typically, this is a typedef to &lt;code&gt;long long&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;std::streamoff&lt;/code&gt; 운영 체제에서 지원 가능한 최대 파일 크기를 표현하기에 충분한 크기의 서명 필수 유형입니다. 일반적으로 &lt;code&gt;long long&lt;/code&gt; 에 대한 typedef 입니다 .</target>
        </trans-unit>
        <trans-unit id="081a86b87857472711ceb628824320cbad10918c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::streamsize&lt;/code&gt; is a signed integral type used to represent the number of characters transferred in an I/O operation or the size of an I/O buffer. It is used as a signed counterpart of &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, similar to the POSIX type &lt;code&gt;ssize_t&lt;/code&gt;.</source>
          <target state="translated">타입 &lt;code&gt;std::streamsize&lt;/code&gt; 의 I / O 동작에 전송 문자 수 또는 I / O 버퍼의 크기를 나타내는 데 사용되는 서명 일체형이다. POSIX 유형 &lt;code&gt;ssize_t&lt;/code&gt; 와 유사하게 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 의 서명 된 대응 물로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="35bd4cec907f3b6ac35655e3dc99fe6dc74b2c63" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::strong_equality&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">&lt;code&gt;std::strong_equality&lt;/code&gt; 유형 에는 4 개의 유효한 값이 있으며 해당 유형의 const 정적 데이터 멤버로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="d1fa9bb7b57f78a76b739de735267fbd796b77b7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::strong_ordering&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">&lt;code&gt;std::strong_ordering&lt;/code&gt; 유형 에는 다음 유형의 const 정적 데이터 멤버로 구현 된 4 개의 유효한 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="caaff90770bed5d2d4f0c217a33a582a915365ac" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::weak_equality&lt;/code&gt; has only two valid values, implemented as const static data members of its type: &lt;code&gt;std::weak_equality::equivalent&lt;/code&gt; and &lt;code&gt;std::weak_equality::nonequivalent&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;std::weak_equality&lt;/code&gt; 유형 에는 두 개의 유효한 값만 있으며 해당 유형의 const 정적 데이터 멤버로 구현됩니다. &lt;code&gt;std::weak_equality::equivalent&lt;/code&gt; 및 &lt;code&gt;std::weak_equality::nonequivalent&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5b1a20430a83aa89500e66ebd1c9900c5d380b9b" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::weak_ordering&lt;/code&gt; has three valid values, implemented as const static data members of its type:</source>
          <target state="translated">&lt;code&gt;std::weak_ordering&lt;/code&gt; 유형 에는 세 가지 유효한 값이 있으며 해당 유형의 const 정적 데이터 멤버로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="eea5d0d3527e4ae7b88635106c278af003375133" translate="yes" xml:space="preserve">
          <source>The type T may be an incomplete type.</source>
          <target state="translated">유형 T는 불완전한 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47e3c39ad9f26d80f148e942aab053b6361ba66e" translate="yes" xml:space="preserve">
          <source>The type allows subnormal values</source>
          <target state="translated">이 유형은 비정규 값을 허용합니다</target>
        </trans-unit>
        <trans-unit id="89d3d7da193a1958b43f17239e6e96abc49dd3f5" translate="yes" xml:space="preserve">
          <source>The type and value category of the conditional expression &lt;code&gt;E1 ? E2 : E3&lt;/code&gt; are determined according to the following rules:</source>
          <target state="translated">조건식 &lt;code&gt;E1 ? E2 : E3&lt;/code&gt; 의 유형 및 값 범주 ? E2 : E3 는 다음 규칙에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="b0032656c660ab91cfc9f1912ec36a11287348d7" translate="yes" xml:space="preserve">
          <source>The type deduced by these deduction guides may change in a later standard revision (in particular, this might happen if &lt;code&gt;noexcept&lt;/code&gt; support is added to &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; in a later standard).</source>
          <target state="translated">이러한 추론 가이드에 의해 추론 된 유형은 이후 표준 개정에서 변경 될 수 있습니다 (특히, 이후 표준에서 &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 에 지원을 추가 하지 &lt;code&gt;noexcept&lt;/code&gt; 경우 발생할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="8dcc1ea760f892b4e6eddb08b2acf9f9c879aeb1" translate="yes" xml:space="preserve">
          <source>The type defined by &lt;code&gt;std::aligned_storage&amp;lt;&amp;gt;::type&lt;/code&gt; can be used to create uninitialized memory blocks suitable to hold the objects of given type, optionally aligned stricter than their natural alignment requirement, for example on a cache or page boundary.</source>
          <target state="translated">&lt;code&gt;std::aligned_storage&amp;lt;&amp;gt;::type&lt;/code&gt; 의해 정의 된 유형 은 주어진 유형의 오브젝트를 보유하기에 적합한 초기화되지 않은 메모리 블록을 작성하는 데 사용될 수 있으며, 선택적으로 캐시 또는 페이지 경계에서 자연 정렬 요구 사항보다 엄격하게 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="015fb8d559015f4868df42502a384ec989660bc6" translate="yes" xml:space="preserve">
          <source>The type does not have to implement &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operator&lt;/a&gt; in order to satisfy this type requirement: a &lt;a href=&quot;../language/as_operator&quot;&gt;copy assignment operator&lt;/a&gt; that takes its parameter by value or as a &lt;code&gt;const Type&amp;amp;&lt;/code&gt;, will bind to rvalue argument.</source>
          <target state="translated">유형은 이 유형 요구 사항을 충족시키기 위해 &lt;a href=&quot;../language/move_operator&quot;&gt;이동 할당 연산자&lt;/a&gt; 를 구현할 필요가 없습니다 . 매개 변수를 값으로 또는 &lt;code&gt;const Type&amp;amp;&lt;/code&gt; 로 취하는 &lt;a href=&quot;../language/as_operator&quot;&gt;복사 할당 연산자&lt;/a&gt; 는 rvalue 인수에 바인드됩니다.</target>
        </trans-unit>
        <trans-unit id="4ee6bc4a29e09101e3ca894cf68274fb41416543" translate="yes" xml:space="preserve">
          <source>The type does not have to implement a &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operator&lt;/a&gt; in order to satisfy this trait; see &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; for details.</source>
          <target state="translated">유형은 이 특성을 만족시키기 위해 &lt;a href=&quot;../language/move_operator&quot;&gt;이동 할당 연산자&lt;/a&gt; 를 구현할 필요는 없습니다 . 자세한 내용은 &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="71c7ef3196579896dbcb86da29f6c58aaeef4821" translate="yes" xml:space="preserve">
          <source>The type does not support subnormal values</source>
          <target state="translated">유형이 비정규 값을 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="c0aefe5f52f0c91ab7dcca87fc13463e2b84f15b" translate="yes" xml:space="preserve">
          <source>The type mbstate_t is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. Zero-initialized value of &lt;code&gt;mbstate_t&lt;/code&gt; represents the initial conversion state, although other values of &lt;code&gt;mbstate_t&lt;/code&gt; may exist that also represent the initial conversion state.</source>
          <target state="translated">mbstate_t 유형은 구현 정의 된 지원되는 멀티 바이트 문자 인코딩 규칙 세트에서 발생할 수있는 변환 상태를 나타낼 수있는 간단한 비 배열 유형입니다. &lt;code&gt;mbstate_t&lt;/code&gt; 의 0으로 초기화 된 값은 초기 변환 상태를 나타내지 만, &lt;code&gt;mbstate_t&lt;/code&gt; 의 다른 값은 초기 변환 상태를 나타내기도합니다.</target>
        </trans-unit>
        <trans-unit id="ee6f31452577bc5b29d1b96501ba9c9ead4fd373" translate="yes" xml:space="preserve">
          <source>The type must meet &lt;a href=&quot;clock&quot;&gt;Clock&lt;/a&gt; requirements.</source>
          <target state="translated">유형은 &lt;a href=&quot;clock&quot;&gt;시계&lt;/a&gt; 요구 사항을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="417fa810ac7b429d2e715174963cd48512430822" translate="yes" xml:space="preserve">
          <source>The type must meet all of the following requirements:</source>
          <target state="translated">유형은 다음 요구 사항을 모두 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="5fe47f690f454a471c8cf3ffe3e0c793213ba10d" translate="yes" xml:space="preserve">
          <source>The type must satisfy the following additional expressions, given two values &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; that are of the type, and that &lt;code&gt;np&lt;/code&gt; is a value of &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; type (possibly &lt;code&gt;const&lt;/code&gt; qualified):</source>
          <target state="translated">유형은 두 개의 값 &lt;code&gt;p&lt;/code&gt; 와 &lt;code&gt;q&lt;/code&gt; 가 있고, &lt;code&gt;np&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 유형 의 값 ( &lt;code&gt;const&lt;/code&gt; 한정) 일 경우, 다음 추가 표현식을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="369901cace11f8d9f2b85e35e2783ef729d22cb1" translate="yes" xml:space="preserve">
          <source>The type must work with &amp;lt; operator and the result should have standard semantics.</source>
          <target state="translated">형식은 &amp;lt;연산자와 함께 작동해야하며 결과에는 표준 의미가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8ccea44fbb2fd126230d043404a673c987073e90" translate="yes" xml:space="preserve">
          <source>The type must work with == operator and the result should have standard semantics.</source>
          <target state="translated">형식은 == 연산자와 함께 작동해야하며 결과에는 표준 의미가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a401af7b772905929e6c578148662943f7e9b5a8" translate="yes" xml:space="preserve">
          <source>The type need not be &lt;a href=&quot;incomplete_type&quot;&gt;complete&lt;/a&gt; or have an available &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;, and can be &lt;a href=&quot;abstract_class&quot;&gt;abstract&lt;/a&gt;. This rule doesn't apply to sub-expressions: in &lt;code&gt;decltype(f(g()))&lt;/code&gt;, &lt;code&gt;g()&lt;/code&gt; must have a complete type, but &lt;code&gt;f()&lt;/code&gt; need not.</source>
          <target state="translated">타입이 &lt;a href=&quot;incomplete_type&quot;&gt;완전&lt;/a&gt; 하거나 사용 가능한 &lt;a href=&quot;destructor&quot;&gt;소멸자를&lt;/a&gt; 가질 필요 는 없으며 &lt;a href=&quot;abstract_class&quot;&gt;추상적&lt;/a&gt; 일 수 있습니다 . 이 규칙은 하위 표현식에는 적용되지 않습니다. &lt;code&gt;decltype(f(g()))&lt;/code&gt; 에서 &lt;code&gt;g()&lt;/code&gt; 는 완전한 유형을 가져야하지만 &lt;code&gt;f()&lt;/code&gt; 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c83f8d22479920f797dda997ec4470602b5cb196" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;E&lt;/code&gt; after substitution must be exactly &lt;code&gt;bool&lt;/code&gt;. No conversion is permitted:</source>
          <target state="translated">치환 후 &lt;code&gt;E&lt;/code&gt; 유형은 정확히 &lt;code&gt;bool&lt;/code&gt; 이어야합니다 . 전환이 허용되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="092bcee309aef84863a0a22c05df0ff5cc2306f8" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;N&lt;/code&gt; in the type &lt;code&gt;T[N]&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T[N]&lt;/code&gt; 유형의 &lt;code&gt;N&lt;/code&gt; 유형 은 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e00aa691520243fc7bb95963a65a42850ff0ee2d" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;replacement&lt;/code&gt; is &lt;code&gt;std::filesystem::path&lt;/code&gt; even though it is not intended to represent an object on the file system in order to correctly account for the filesystem character encoding.</source>
          <target state="translated">의 유형 &lt;code&gt;replacement&lt;/code&gt; 입니다 &lt;code&gt;std::filesystem::path&lt;/code&gt; 올바르게 파일 시스템의 문자 인코딩을 설명하기 위해 파일 시스템에서 개체를 나타 내기위한되지 않더라도.</target>
        </trans-unit>
        <trans-unit id="73ef25a9616ca1a936ee4e3bf75aad3a667fbb50" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;this&lt;/code&gt; in a member function of class &lt;code&gt;X&lt;/code&gt; is &lt;code&gt;X*&lt;/code&gt; (pointer to X). If the member function is &lt;a href=&quot;member_functions&quot;&gt;cv-qualified&lt;/a&gt;, the type of &lt;code&gt;this&lt;/code&gt; is &lt;code&gt;cv X*&lt;/code&gt; (pointer to identically cv-qualified X). Since constructors and destructors cannot be cv-qualified, the type of &lt;code&gt;this&lt;/code&gt; in them is always &lt;code&gt;X*&lt;/code&gt;, even when constructing or destroying a const object.</source>
          <target state="translated">클래스 &lt;code&gt;X&lt;/code&gt; 의 멤버 함수 &lt;code&gt;this&lt;/code&gt; 유형 은 &lt;code&gt;X*&lt;/code&gt; (X에 대한 포인터)입니다. 멤버 함수가 &lt;a href=&quot;member_functions&quot;&gt;cv-qualified&lt;/a&gt; 인 &lt;code&gt;this&lt;/code&gt; 유형 은 &lt;code&gt;cv X*&lt;/code&gt; (동일하게 cv-qualified X를 가리키는 포인터)입니다. 생성자와 소멸자는 이력서 자격이 될 수 없기 때문에, 유형 &lt;code&gt;this&lt;/code&gt; 그들은 항상 &lt;code&gt;X*&lt;/code&gt; 건설 또는 CONST 오브젝트를 파괴해도.</target>
        </trans-unit>
        <trans-unit id="4a3330b556852ca71717541f2c81d240e408418f" translate="yes" xml:space="preserve">
          <source>The type of a &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; appearing in an alias template declaration is different between instantiations of that template, even when the lambda expression is not dependent.</source>
          <target state="translated">별칭 템플릿 선언에 나타나는 &lt;a href=&quot;lambda&quot;&gt;람다 식&lt;/a&gt; 의 유형은 람다식이 종속되지 않은 경우에도 해당 템플릿의 인스턴스화마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1c03df0e9a6c3883eefceaf776f001998a556f7d" translate="yes" xml:space="preserve">
          <source>The type of a bit field can only be integral or enumeration type.</source>
          <target state="translated">비트 필드의 유형은 정수 또는 열거 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e828f47acdf8dd1be944f104aebcd681e249b7b" translate="yes" xml:space="preserve">
          <source>The type of a non-type template parameter may be deduced if it includes a placeholder type (&lt;code&gt;auto&lt;/code&gt;, a placeholder for a deduced class type(since C++20), or &lt;code&gt;decltype(auto)&lt;/code&gt;). The deduction is performed as if by deducing the type of the variable &lt;code&gt;x&lt;/code&gt; in the invented declaration &lt;code&gt;T x = template-argument;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the declared type of the template parameter. If the deduced type is not permitted for a non-type template parameter, the program is ill-formed.</source>
          <target state="translated">비 유형 템플릿 매개 변수의 유형은 자리 표시 자 유형 ( &lt;code&gt;auto&lt;/code&gt; , 추론 된 클래스 유형의 자리 표시 자 (C ++ 20 이후) 또는 &lt;code&gt;decltype(auto)&lt;/code&gt; )을 포함하는 경우 추론 될 수 있습니다 . 추론 은 발명 된 선언에서 변수 &lt;code&gt;x&lt;/code&gt; 의 유형을 추론하는 것처럼 수행된다. &lt;code&gt;T x = template-argument;&lt;/code&gt; 여기서 &lt;code&gt;T&lt;/code&gt; 는 템플릿 매개 변수의 선언 된 유형입니다. 비 유형 템플릿 매개 변수에 추론 된 유형이 허용되지 않으면 프로그램이 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9f077ca46cbdc83666da091d5f4c5c63b8be8535" translate="yes" xml:space="preserve">
          <source>The type of a pointer to array of unknown bound, or of a type defined by a &lt;code&gt;typedef&lt;/code&gt; declaration to be an array of unknown bound, cannot be completed.</source>
          <target state="translated">알 수없는 바운드의 배열에 대한 포인터 유형 또는 알 수없는 바운드의 배열로 &lt;code&gt;typedef&lt;/code&gt; 선언으로 정의 된 유형의 유형을 완료 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e1654f0998b812161591ecd53f879aa981b5cfa6" translate="yes" xml:space="preserve">
          <source>The type of an expression that results from the compile-time analysis of the program is known as the</source>
          <target state="translated">프로그램의 컴파일 타임 분석 결과 식의 유형은</target>
        </trans-unit>
        <trans-unit id="dc3ab407bca97dd7b2182e8d6089591cbf78c0f6" translate="yes" xml:space="preserve">
          <source>The type of each data member is the type of the corresponding captured entity, except if the entity has reference type (in that case, references to functions are captured as lvalue references to the referenced functions, and references to objects are captured as copies of the referenced objects).</source>
          <target state="translated">각 데이터 멤버의 유형은 엔티티에 참조 유형이있는 경우를 제외하고 해당 캡처 된 엔티티의 유형입니다 (이 경우 함수에 대한 참조는 참조 된 함수에 대한 lvalue 참조로 캡처되고 오브젝트에 대한 참조는 참조 된 개체).</target>
        </trans-unit>
        <trans-unit id="85801fe2a975f6f74abeb5935ecc5a8cbc8a24c1" translate="yes" xml:space="preserve">
          <source>The type of each function parameter in the parameter list is determined according to the following rules:</source>
          <target state="translated">매개 변수 목록의 각 기능 매개 변수 유형은 다음 규칙에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="14480ff70d6d9671051d3a3bebfef0ffda9aa55c" translate="yes" xml:space="preserve">
          <source>The type of function callbacks that can be registered using &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; to be called on specific events.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; 을 사용하여 등록 하여 특정 이벤트에서 호출 할 수있는 함수 콜백 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="16e7bff806ed1fa4ab8073e5ade6ccec0c8f929f" translate="yes" xml:space="preserve">
          <source>The type of the</source>
          <target state="translated">의 유형</target>
        </trans-unit>
        <trans-unit id="b1b79e1851bb8cd4e0abe53b7badea94acb8b63a" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array must be a &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">배열 요소의 유형은 &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt; 이어야합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a440bce9393578dcc59e67d819369eb6fff9dc5" translate="yes" xml:space="preserve">
          <source>The type of the elements.</source>
          <target state="translated">요소의 유형</target>
        </trans-unit>
        <trans-unit id="39cb107adf449bbc790a8800f9b0f24f9bbe1ba6" translate="yes" xml:space="preserve">
          <source>The type of the function being declared is composed from the</source>
          <target state="translated">선언되는 함수의 유형은</target>
        </trans-unit>
        <trans-unit id="9bbb6b4e7d477a9cc16a3aa9d6f2075047c3171b" translate="yes" xml:space="preserve">
          <source>The type of the integer literal is the first type in which the value can fit, from the list of types which depends on which numeric base and which integer-suffix was used.</source>
          <target state="translated">정수 리터럴의 유형은 사용 된 숫자 기수와 정수 접미사에 따라 유형 목록에서 값이 들어갈 수있는 첫 번째 유형입니다.</target>
        </trans-unit>
        <trans-unit id="68e06d906da63b0e924e6b7c9ec59a39e6b3cb3e" translate="yes" xml:space="preserve">
          <source>The type of the literal</source>
          <target state="translated">리터럴의 유형</target>
        </trans-unit>
        <trans-unit id="66d91e0faa820f737700bea3d6d88e6c67abbd4b" translate="yes" xml:space="preserve">
          <source>The type of the stored elements. The behavior is undefined if &lt;code&gt;T&lt;/code&gt; is not the same type as &lt;code&gt;Container::value_type&lt;/code&gt;.(since C++17)</source>
          <target state="translated">저장된 요소의 유형입니다. &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Container::value_type&lt;/code&gt; 과 동일한 유형이 아닌 경우 동작이 정의되지 않습니다 (C ++ 17부터).</target>
        </trans-unit>
        <trans-unit id="1cefc4c9c8c79e1f5ffc310e3b76ce47f7f95b53" translate="yes" xml:space="preserve">
          <source>The type of the underlying container to use to store the elements. The container must satisfy the requirements of &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;, and its iterators must satisfy the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;. Additionally, it must provide the following functions with the usual semantics:</source>
          <target state="translated">요소를 저장하는 데 사용할 기본 컨테이너의 유형입니다. 컨테이너는 &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; 의 요구 사항을 충족해야하며 해당 반복자는 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 의 요구 사항을 충족해야합니다 . 또한 일반적인 의미 체계와 함께 다음 기능을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="42baf44de229b353e2dc10d945c14ad4f7f1e2dd" translate="yes" xml:space="preserve">
          <source>The type of the underlying container to use to store the elements. The container must satisfy the requirements of &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;. Additionally, it must provide the following functions with the usual semantics:</source>
          <target state="translated">요소를 저장하는 데 사용할 기본 컨테이너의 유형입니다. 컨테이너는 &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; 의 요구 사항을 충족해야합니다 . 또한 일반적인 의미 체계와 함께 다음 기능을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b1400789f4da2eef8d9f804a8241c3f62471b09" translate="yes" xml:space="preserve">
          <source>The type produced when specializing an alias template is not allowed to directly or indirectly make use of its own type:</source>
          <target state="translated">별명 템플리트를 특수화 할 때 생성 된 유형은 직접 또는 간접적으로 자체 유형을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="447849d54c1d67d6b61329201208de7c3155cd27" translate="yes" xml:space="preserve">
          <source>The type representing all floating-point status flags collectively</source>
          <target state="translated">모든 부동 소수점 상태 플래그를 집합 적으로 나타내는 유형</target>
        </trans-unit>
        <trans-unit id="66cad8bd68a6349c324c8b818f25bd23910481f3" translate="yes" xml:space="preserve">
          <source>The type representing the entire floating-point environment</source>
          <target state="translated">전체 부동 소수점 환경을 나타내는 유형</target>
        </trans-unit>
        <trans-unit id="e0d3b983420a08441dc26163e85fa14573af6da4" translate="yes" xml:space="preserve">
          <source>The type trait template &lt;code&gt;regex_traits&lt;/code&gt; supplies &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; with the set of types and functions necessary to operate on the type &lt;code&gt;CharT&lt;/code&gt;.</source>
          <target state="translated">유형 특성 템플릿 &lt;code&gt;regex_traits&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;CharT&lt;/code&gt; 유형에서 작동하는 데 필요한 유형 및 함수 세트를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a7ff3701335c6b61f893828424d0d4397e6f94e7" translate="yes" xml:space="preserve">
          <source>The type, value, and value category of the result of the comma expression are exactly the type, value, and value category of the second operand, &lt;code&gt;E2&lt;/code&gt;. If &lt;code&gt;E2&lt;/code&gt; is a temporary expression(since C++17), the result of the expression is that temporary expression(since C++17). If &lt;code&gt;E2&lt;/code&gt; is a bit-field, the result is a bit-field.</source>
          <target state="translated">쉼표 표현식 결과의 유형, 값 및 값 범주는 정확히 두 번째 피연산자 &lt;code&gt;E2&lt;/code&gt; 의 유형, 값 및 값 범주입니다 . 경우 &lt;code&gt;E2&lt;/code&gt; 는 (C ++ 17 이후) 식의 결과가 일시적 발현 (이후는 C ++ 17)는 임시 식입니다. 경우 &lt;code&gt;E2&lt;/code&gt; 는 비트 필드, 결과는 비트 필드입니다.</target>
        </trans-unit>
        <trans-unit id="201b401441e563392e93db134426f0b5823a14fe" translate="yes" xml:space="preserve">
          <source>The type-based overloads (5-12) fail to compile if the types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are the same.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 가 동일한 경우 유형 기반 과부하 (5-12)가 컴파일되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a8ad5442d02de3fb2204cec5285533422e5d8a60" translate="yes" xml:space="preserve">
          <source>The typedef-names are aliases for existing types, and are not declarations of new types. Typedef cannot be used to change the meaning of an existing type name (including a typedef-name). Once declared, a typedef-name may only be redeclared to refer to the same type again. Typedef names are only in effect in the scope where they are visible: different functions or class declarations may define identically-named types with different meaning.</source>
          <target state="translated">typedef-names는 기존 유형의 별명이며 새 유형의 선언이 아닙니다. Typedef를 사용하여 기존 유형 이름 (typedef-name 포함)의 의미를 변경할 수 없습니다. 선언되면 typedef-name은 같은 유형을 다시 참조하도록 다시 선언 될 수 있습니다. Typedef 이름은 보이는 범위에서만 유효합니다. 다른 함수 또는 클래스 선언은 다른 이름으로 동일한 이름을 가진 유형을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="208a0dcd155f30aca58e4747af4e8c084fcc2a94" translate="yes" xml:space="preserve">
          <source>The typeid expression is an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; which refers to an object with &lt;a href=&quot;static&quot;&gt;static storage duration&lt;/a&gt;, of the polymorphic type &lt;code&gt;const &lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; or of some type derived from it.</source>
          <target state="translated">typeid 표현식은 &lt;a href=&quot;static&quot;&gt;정적 스토리지 기간&lt;/a&gt; , 다형성 유형 &lt;code&gt;const &lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../types/type_info&quot;&gt;std :: type_info&lt;/a&gt; 또는 파생 된 일부 유형 의 오브젝트를 나타내는 &lt;a href=&quot;value_category&quot;&gt;lvalue 표현식&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7e208b7b23417d25a7cf6cca148a35ee8446742b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;TC::rep&lt;/code&gt;, &lt;code&gt;TC::duration&lt;/code&gt;, and &lt;code&gt;TC::time_point&lt;/code&gt; satisfy the requirements of &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;, &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and &lt;a href=&quot;numerictype&quot;&gt;NumericType&lt;/a&gt;.</source>
          <target state="translated">유형 &lt;code&gt;TC::rep&lt;/code&gt; , &lt;code&gt;TC::duration&lt;/code&gt; 및 &lt;code&gt;TC::time_point&lt;/code&gt; 의 요구 사항을 만족 &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable로&lt;/a&gt; , &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; , &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; , &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; , &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , &lt;a href=&quot;destructible&quot;&gt;파괴 가능한&lt;/a&gt; 및 &lt;a href=&quot;numerictype&quot;&gt;NumericType을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61760bebb6411fc7a1b89f4a6a4d2b47b837a78f" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;BidirIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야합니다 &lt;code&gt;BidirIt&lt;/code&gt; 가 역 참조하고 암시 적으로 둘 다 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10efac4cd9ec3d4ae0fd700440a7ab91e4529fc8" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야합니다 &lt;code&gt;ForwardIt&lt;/code&gt; 가 역 참조하고 암시 적으로 둘 다 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb5cffb02876fdfc335e83f9d620b313612c1b0" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야합니다 &lt;code&gt;InputIt&lt;/code&gt; 가 역 참조하고 암시 적으로 둘 다 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c179ed315abab6c17ee556701b26c5d282772f2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;RandomIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야합니다 &lt;code&gt;RandomIt&lt;/code&gt; 가 역 참조하고 암시 적으로 둘 다 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="193be796c5e76cc692dcacf4d03a9c74c36dcc11" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;, and an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야 &lt;code&gt;T&lt;/code&gt; 는 암시 적으로 모두 변환 할 수있는 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 와 타입의 객체 &lt;code&gt;ForwardIt&lt;/code&gt; 역 참조 할 수 다음 암시 적으로 모두 변환 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4447fe84d3b9ebfd730e495965e02d0c7f2a157" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to both of them. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야 &lt;code&gt;T&lt;/code&gt; 는 암시 적으로 둘 다 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55aca5b917e7d46505eef0c5864d5092e23045de" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;forward_list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야합니다 &lt;code&gt;forward_list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; 역 참조하고 암시 적으로 둘 다 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2c308d3a55373567a39aa9cf81fb0182d8c2878" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be implicitly converted to both of them. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체가되도록해야합니다 &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; 암시 적으로 둘 다 변환 할 수 있습니다. 유형 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체되도록 있어야 &lt;code&gt;OutputIt&lt;/code&gt; 는 역 참조와 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86218894e5a217ad2ba71c5d5b88c13c7c91af26" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 타입의 객체 있도록해야합니다 &lt;code&gt;list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; 역 참조하고 암시 적으로 둘 다 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="255e7b7cb8a9a07dcebb8ff409c528b78435bb0c" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 유형의 객체 있도록해야 &lt;code&gt;ForwardIt1&lt;/code&gt; 및 &lt;code&gt;ForwardIt2&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="8bf40db03397e57c92c014d425524b6be371768c" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 종류의 객체 있도록해야 &lt;code&gt;InputIt1&lt;/code&gt; 및 &lt;code&gt;InputIt2&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 각각. 유형 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체되도록 있어야 &lt;code&gt;OutputIt&lt;/code&gt; 는 역 참조와 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea66afd749f321b8a7fbd2dfec0b25993b20d429" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;Type3&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 종류의 객체 있도록해야 &lt;code&gt;InputIt1&lt;/code&gt; 및 &lt;code&gt;InputIt2&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 각각. 타입 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체되도록 있어야 &lt;code&gt;Type3&lt;/code&gt; 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="697ca99a8e5d22b550dc1162bfdf3113cb87ca5b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 유형의 객체 있도록해야 &lt;code&gt;InputIt1&lt;/code&gt; 및 &lt;code&gt;InputIt2&lt;/code&gt; 가 역 참조하고 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="c5097f11a8110609e26afb57ed62da129a5503cf" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 유형의 객체 있도록해야 &lt;code&gt;InputIt1&lt;/code&gt; 및 &lt;code&gt;InputIt2&lt;/code&gt; 가 역 참조하고 암시 적으로 모두 전환 될 수 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c30caab1908aa629ad3fea15c152763576c8875" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;Type3&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">종류 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 유형의 객체 있도록해야 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;Type3&lt;/code&gt; 암시 적으로 변환 할 수 있습니다 &lt;code&gt;Type1&lt;/code&gt; 과 &lt;code&gt;Type2&lt;/code&gt; 각각. 유형 &lt;code&gt;Ret&lt;/code&gt; 유형의 객체되도록 있어야 &lt;code&gt;T&lt;/code&gt; 이 타입의 값이 할당 될 수 &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50e24e2bc41cc279e1a3c9515fef0b78775237a9" translate="yes" xml:space="preserve">
          <source>The types in the parameter pack &lt;code&gt;T&lt;/code&gt; shall each be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound. Otherwise, the behavior is undefined.</source>
          <target state="translated">파라미터 팩 &lt;code&gt;T&lt;/code&gt; 의 타입은 각각 완전한 타입, (cv-qualified) &lt;code&gt;void&lt;/code&gt; 또는 알 수없는 바인딩의 배열 이어야합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa81b9c4cb4ce5f942c1234f0bfa8aee24861f94" translate="yes" xml:space="preserve">
          <source>The types of the placeholder objects are &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, their default copy/move constructors do not throw exceptions, and for any placeholder &lt;code&gt;_N&lt;/code&gt;, the type &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;decltype(_N)&amp;gt;&lt;/code&gt; is defined and is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, N&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">플레이스 홀더 객체의 유형은 &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; 및 &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; 이며, 기본 복사 / 이동 생성자는 예외를 발생시키지 않으며, 플레이스 홀더 &lt;code&gt;_N&lt;/code&gt; 의 경우 &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;decltype(_N)&amp;gt;&lt;/code&gt; 이 정의되고 &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, N&amp;gt;&lt;/code&gt; 에서 파생됩니다. &amp;lt;int, N&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="75478ba3404fb0cfdef1c92955897a42cd9e34cf" translate="yes" xml:space="preserve">
          <source>The types used to determine the order depend on the context:</source>
          <target state="translated">순서를 결정하는 데 사용되는 유형은 상황에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="81e4b2422bd4fd5cd5d02082af7aa37f47bd2430" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;istrstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;istrstream&lt;/code&gt; 의 일반적인 구현에는 파생되지 않은 데이터 멤버가 하나만 있습니다 : &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 유형의 오브젝트 .</target>
        </trans-unit>
        <trans-unit id="48a376de82dbe48c2684a6707ba9148135410249" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;ostrstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ostrstream&lt;/code&gt; 의 일반적인 구현에는 파생되지 않은 데이터 멤버가 하나만 있습니다 : &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 유형의 오브젝트 .</target>
        </trans-unit>
        <trans-unit id="4926fe384c3bbd6e8ecfe4635962d969889b9270" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;strstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strstream&lt;/code&gt; 의 일반적인 구현에는 파생되지 않은 데이터 멤버가 하나만 있습니다. &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 유형의 오브젝트입니다 .</target>
        </trans-unit>
        <trans-unit id="8b6e26a516b34b7af57fc7012be60e25328df076" translate="yes" xml:space="preserve">
          <source>The unary arithmetic operator expressions have the form.</source>
          <target state="translated">단항 산술 연산자 식의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b22b858c0fd42effe64ef379a02aba7e1e499dac" translate="yes" xml:space="preserve">
          <source>The unary operator &lt;code&gt;co_await&lt;/code&gt; suspends a coroutine and returns control to the caller. Its operand is an expression whose type must either define &lt;code&gt;operator co_await&lt;/code&gt;, or be convertible to such type by means of the current coroutine's &lt;code&gt;Promise::await_transform&lt;/code&gt;.</source>
          <target state="translated">단항 연산자 &lt;code&gt;co_await&lt;/code&gt; 는 코 루틴을 일시 중단하고 제어를 호출자에게 반환합니다. 피연산자는 유형이 &lt;code&gt;operator co_await&lt;/code&gt; 를 정의 하거나 현재 코 루틴의 &lt;code&gt;Promise::await_transform&lt;/code&gt; 을 사용하여 해당 유형으로 변환 할 수 있는 표현식입니다 .</target>
        </trans-unit>
        <trans-unit id="36a5614de76d4b58b628c43d48b3afb8e58937c2" translate="yes" xml:space="preserve">
          <source>The unary predicate type must define a member type, &lt;code&gt;argument_type&lt;/code&gt;, that is convertible to the predicate's parameter type. The unary function objects obtained from &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;, or from another call to &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; have this type defined, as are function objects derived from the deprecated &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">단항 술어 유형은 술어의 매개 변수 유형으로 변환 할 수있는 멤버 유형 &lt;code&gt;argument_type&lt;/code&gt; 을 정의해야합니다 . 단항 함수 객체는 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; 다른 호출에서 얻은 더 이상 사용되지 않는 &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt; 에서 파생 된 함수 객체와 마찬가지로이 유형을 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c177ac717f26cdcf71092d833a69d98891213b9" translate="yes" xml:space="preserve">
          <source>The unary predicate type must define a member type, &lt;code&gt;argument_type&lt;/code&gt;, that is convertible to the predicate's parameter type. The unary function objects obtained from &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;, or from another call to &lt;code&gt;std::not1&lt;/code&gt; have this type defined, as are function objects derived from the deprecated &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">단항 술어 유형은 술어의 매개 변수 유형으로 변환 할 수있는 멤버 유형 &lt;code&gt;argument_type&lt;/code&gt; 을 정의해야합니다 . 단항 함수 객체는 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;std::not1&lt;/code&gt; 다른 호출에서 얻은 더 이상 사용되지 않는 &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt; 에서 파생 된 함수 객체와 마찬가지로이 유형을 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a8868abcc7899aa017c841a57e1f892c57cdec6" translate="yes" xml:space="preserve">
          <source>The underlying array is a &lt;a href=&quot;../language/implicit_cast#Temporary_materialization&quot;&gt;temporary&lt;/a&gt; array of type &lt;code&gt;const T[N]&lt;/code&gt;, in which each element is &lt;a href=&quot;../language/copy_initialization&quot;&gt;copy-initialized&lt;/a&gt; (except that narrowing conversions are invalid) from the corresponding element of the original initializer list. The lifetime of the underlying array is the same as any other &lt;a href=&quot;../language/lifetime#Temporary_object_lifetime&quot;&gt;temporary object&lt;/a&gt;, except that initializing an initializer_list object from the array extends the lifetime of the array exactly like &lt;a href=&quot;../language/reference_initialization#Lifetime_of_a_temporary&quot;&gt;binding a reference to a temporary&lt;/a&gt; (with the same exceptions, such as for initializing a non-static class member). The underlying array may be allocated in read-only memory.</source>
          <target state="translated">기본 배열은 &lt;code&gt;const T[N]&lt;/code&gt; 유형 의 &lt;a href=&quot;../language/implicit_cast#Temporary_materialization&quot;&gt;임시&lt;/a&gt; 배열이며 , 여기서 각 요소는 원래 이니셜 라이저 목록의 해당 요소에서 &lt;a href=&quot;../language/copy_initialization&quot;&gt;복사 초기화&lt;/a&gt; (좁은 변환이 유효하지 않은 경우 제외)됩니다. 기본 어레이의 수명은 다른 모든 것과 동일한 &lt;a href=&quot;../language/lifetime#Temporary_object_lifetime&quot;&gt;임시 객체&lt;/a&gt; 어레이에서 initializer_list 객체를 초기화하는 똑같이 어레이의 수명은 연장하는 것을 제외하고 &lt;a href=&quot;../language/reference_initialization#Lifetime_of_a_temporary&quot;&gt;일시적으로 참조 결합&lt;/a&gt; 등 이외의 초기화에 관해서는, 동일한 예외 ( -정적 클래스 멤버). 기본 배열은 읽기 전용 메모리에 할당 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4eb3a7f051a86b23a775a499c1446a22117e43f7" translate="yes" xml:space="preserve">
          <source>The underlying array is not guaranteed to exist after the lifetime of the original initializer list object has ended. The storage for &lt;code&gt;std::initializer_list&lt;/code&gt; is unspecified (i.e. it could be automatic, temporary, or static read-only memory, depending on the situation).</source>
          <target state="translated">원래 이니셜 라이저 목록 객체의 수명이 종료 된 후에는 기본 배열이 존재하지 않을 수 있습니다. &lt;code&gt;std::initializer_list&lt;/code&gt; 대한 스토리지 가 지정되지 않았습니다 (즉, 상황에 따라 자동, 임시 또는 정적 읽기 전용 메모리 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="7eadf4d50d87bb977c930c01738a9f8d29a30fb0" translate="yes" xml:space="preserve">
          <source>The underlying engine.</source>
          <target state="translated">기본 엔진.</target>
        </trans-unit>
        <trans-unit id="97e77189c09808726f0123e32d74be4afcdbd112" translate="yes" xml:space="preserve">
          <source>The underlying iterator is assigned the value of the underlying iterator of &lt;code&gt;other&lt;/code&gt;, i.e. &lt;code&gt;other.base()&lt;/code&gt;.</source>
          <target state="translated">기본 이터레이터에는 &lt;code&gt;other&lt;/code&gt; 의 기본 이터레이터 , 즉 &lt;code&gt;other.base()&lt;/code&gt; 의 값이 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="b646602f4defaa19568e9e4e03c04b49576b8ef7" translate="yes" xml:space="preserve">
          <source>The underlying iterator.</source>
          <target state="translated">기본 반복자.</target>
        </trans-unit>
        <trans-unit id="79cf0218a59dc2d4dbf82fe2261c98e6c65758c3" translate="yes" xml:space="preserve">
          <source>The unevaluated operands are considered to be</source>
          <target state="translated">평가되지 않은 피연산자는</target>
        </trans-unit>
        <trans-unit id="979a12b00a42a8fc276019493ceedcb85eb1918e" translate="yes" xml:space="preserve">
          <source>The unformatted input functions &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;basic_istream::get&lt;/code&gt;&lt;/a&gt; if they fails to extract any characters.</source>
          <target state="translated">형식화되지 않은 입력 함수 &lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;basic_istream::get&lt;/code&gt; &lt;/a&gt; 이 문자를 추출하지 못하면</target>
        </trans-unit>
        <trans-unit id="abe9991ee5e0486321d659e85ed0325fe1bbb797" translate="yes" xml:space="preserve">
          <source>The unformatted input functions &lt;a href=&quot;../basic_istream/read&quot;&gt;&lt;code&gt;basic_istream::read&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;basic_istream::get&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../basic_istream/peek&quot;&gt;&lt;code&gt;basic_istream::peek&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../basic_istream/getline&quot;&gt;&lt;code&gt;basic_istream::getline&lt;/code&gt;&lt;/a&gt;, when reaching the end of the stream.</source>
          <target state="translated">형식화되지 않은 입력 함수 는 스트림의 끝에 도달 할 때 &lt;a href=&quot;../basic_istream/read&quot;&gt; &lt;code&gt;basic_istream::read&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;basic_istream::get&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../basic_istream/peek&quot;&gt; &lt;code&gt;basic_istream::peek&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../basic_istream/getline&quot;&gt; &lt;code&gt;basic_istream::getline&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e384fd665d52aa51e3748fff4ef48a28e7937c70" translate="yes" xml:space="preserve">
          <source>The union is only as big as necessary to hold its largest data member. The other data members are allocated in the same bytes as part of that largest member. The details of that allocation are implementation-defined, and it's undefined behavior to read from the member of the union that wasn't most recently written. Many compilers implement, as a non-standard language extension, the ability to read inactive members of a union.</source>
          <target state="translated">노조는 최대 규모의 데이터 멤버를 보유하는 데 필요한만큼만 규모가 큽니다. 다른 데이터 멤버는 가장 큰 멤버의 일부와 동일한 바이트로 할당됩니다. 해당 할당의 세부 사항은 구현에 따라 정의되며 가장 최근에 작성되지 않은 통합 멤버에서 읽는 것은 정의되지 않은 동작입니다. 많은 컴파일러는 비표준 언어 확장으로 비활성 멤버를 읽을 수있는 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e952952a6e837db3083d43ddef77a18d33df5f91" translate="yes" xml:space="preserve">
          <source>The unordered associative containers &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; use specializations of the template &lt;code&gt;std::hash&lt;/code&gt; as the default hash function.</source>
          <target state="translated">정렬되지 않은 연관 컨테이너 &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;std::hash&lt;/code&gt; 템플리트의 특수화를 기본 해시 함수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fb9ee6c51de186554c2e06f60fe8377ba45da283" translate="yes" xml:space="preserve">
          <source>The upper bound of the largest range beginning at &lt;code&gt;first&lt;/code&gt; in which the elements are sorted in ascending order. That is, the last iterator &lt;code&gt;it&lt;/code&gt; for which range &lt;code&gt;[first, it)&lt;/code&gt; is sorted.</source>
          <target state="translated">은 상부의 큰 범위의 시작의 경계 &lt;code&gt;first&lt;/code&gt; 요소가 오름차순으로 정렬되는. 즉, 마지막 반복기 &lt;code&gt;it&lt;/code&gt; 되는 범위 &lt;code&gt;[first, it)&lt;/code&gt; 정렬된다.</target>
        </trans-unit>
        <trans-unit id="153cc2e9c85ca94fbb56ca3af1786c3042753255" translate="yes" xml:space="preserve">
          <source>The upper bound of the largest range beginning at &lt;code&gt;first&lt;/code&gt; which is a</source>
          <target state="translated">는 상부의 큰 범위의 시작의 경계 &lt;code&gt;first&lt;/code&gt; A는 어느</target>
        </trans-unit>
        <trans-unit id="0a7c6b2e95b8914f758d75e392b6d55f793089e4" translate="yes" xml:space="preserve">
          <source>The use of the class key &lt;code&gt;union&lt;/code&gt; results in a &lt;a href=&quot;union&quot;&gt;union definition&lt;/a&gt;, which defines a class that holds only one of its data members at a time.</source>
          <target state="translated">클래스 키 &lt;code&gt;union&lt;/code&gt; 하면 한 번에 데이터 멤버 중 하나만 보유하는 클래스를 &lt;a href=&quot;union&quot;&gt;정의&lt;/a&gt; 하는 공용체 정의 가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7c930b3ae6f3ca4c4f3a29eb336a3a8321980de8" translate="yes" xml:space="preserve">
          <source>The user-defined callback function is not allowed to throw exceptions.</source>
          <target state="translated">사용자 정의 콜백 함수는 예외를 던질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7440e695d7d2b47e772a3f0ba0922c8f1015cfd1" translate="yes" xml:space="preserve">
          <source>The user-defined conversion functions are considered to be members of the</source>
          <target state="translated">사용자 정의 변환 함수는</target>
        </trans-unit>
        <trans-unit id="a2449ea9418355b1634632974372ad5423959cfe" translate="yes" xml:space="preserve">
          <source>The using-directive &lt;code&gt;using namespace std;&lt;/code&gt; at any namespace scope introduces every name from the namespace &lt;code&gt;std&lt;/code&gt; into the global namespace (since the global namespace is the nearest namespace that contains both &lt;code&gt;std&lt;/code&gt; and any user-declared namespace), which may lead to undesirable name collisions. This, and other using directives are generally considered bad practice at file scope of a header file.</source>
          <target state="translated">using 지시문 &lt;code&gt;using namespace std;&lt;/code&gt; 모든 네임 스페이스 범위에서 네임 스페이스 &lt;code&gt;std&lt;/code&gt; 에서 전역 네임 스페이스로 모든 이름이 도입됩니다 (글로벌 네임 스페이스는 &lt;code&gt;std&lt;/code&gt; 및 사용자가 선언 한 네임 스페이스를 모두 포함하는 가장 가까운 네임 스페이스이므로 ). 이는 바람직하지 않은 이름 충돌을 일으킬 수 있습니다. 이것과 다른 using 지시문은 일반적으로 헤더 파일의 파일 범위에서 나쁜 습관으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a0a29bcf7f924ca3c9afb16892af9ad80008618f" translate="yes" xml:space="preserve">
          <source>The usual rules for reference-binding to temporaries (including lifetime-extension) apply if a ref-operator is present and the expression is a prvalue. In those cases the hidden variable &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is a reference that binds to the temporary variable &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from the prvalue expression, extending its lifetime. As usual, the binding will fail if &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is a non-const lvalue reference:</source>
          <target state="translated">ref-operator가 있고 표현식이 prvalue 인 경우 임시에 대한 참조 바인딩 (lifetime-extension 포함) 규칙이 적용됩니다. 이 경우 숨겨진 변수 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; 는 prvalue 표현식에서 &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;구체화&lt;/a&gt; 된 임시 변수에 바인딩되어 수명이 연장되는 참조입니다 . 평소와 같이 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; 가 상수가 아닌 lvalue 참조 인 경우 바인딩이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="d143db4cb73d031e48783561f534e5977a6951dc" translate="yes" xml:space="preserve">
          <source>The utility functions &lt;code&gt;std::make_obj_using_allocator&lt;/code&gt;, and &lt;code&gt;std::uninitialized_construct_using_allocator&lt;/code&gt; may be used to explicitly create an object following the above protocol, and &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; can be used to prepare the argument list that matches the flavor of uses-allocator construction expected by the type.</source>
          <target state="translated">유틸리티 함수 &lt;code&gt;std::make_obj_using_allocator&lt;/code&gt; 및 &lt;code&gt;std::uninitialized_construct_using_allocator&lt;/code&gt; 사용하여 위 프로토콜에 따라 오브젝트를 명시 적으로 작성할 수 있으며 &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; 를 사용하여 예상되는 사용 할당 기 구성의 취향과 일치하는 인수 목록을 준비 할 수 있습니다. 유형.</target>
        </trans-unit>
        <trans-unit id="fe1efdbf774195a43f57a666949496b9864e4331" translate="yes" xml:space="preserve">
          <source>The valid values (inherited from &lt;code&gt;&lt;a href=&quot;../time_base&quot;&gt;std::time_base&lt;/a&gt;&lt;/code&gt;) are:</source>
          <target state="translated">유효한 값 ( &lt;code&gt;&lt;a href=&quot;../time_base&quot;&gt;std::time_base&lt;/a&gt;&lt;/code&gt; 에서 상 속됨 )은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea8585806be7732f5b1559533a0afabee4e31468" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;false&lt;/code&gt; (the default) indicates that any flush will be postponed until a call to emit.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 값 (기본값)은 호출 호출을 할 때까지 플러시가 연기됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bec74bfd762b8f94824661d08795516a39875971" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;std::codecvt_base::partial&lt;/code&gt; is used to indicate that either the destination range is too short to receive the results of the conversion or the input is truncated in the middle of an otherwise valid multibyte character.</source>
          <target state="translated">&lt;code&gt;std::codecvt_base::partial&lt;/code&gt; 값 은 대상 범위가 너무 짧아 변환 결과를 수신 할 수 없거나 입력이 다른 유효한 멀티 바이트 문자 중간에서 잘리는 것을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b59da2ec2014ac9c518b1aadf220e6d3e58b2e01" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;true&lt;/code&gt; makes flushes apply immediately.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 값 은 플러시를 즉시 적용합니다.</target>
        </trans-unit>
        <trans-unit id="b297662cf0a9d877fef1ea088b887dc762885510" translate="yes" xml:space="preserve">
          <source>The value category of a function call expression is lvalue if the function returns an lvalue reference or an rvalue reference to function, is an xvalue if the function returns an rvalue reference to object, and is a prvalue otherwise. If the function call expression is a prvalue of object type, it must have complete type except when the prvalue is not materialized, such as(since C++17) when used as the operand of &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; (or as the right operand of a &lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;built-in comma operator expression&lt;/a&gt; that is the operand of &lt;code&gt;decltype&lt;/code&gt;).</source>
          <target state="translated">함수 호출 표현식의 값 범주는 함수가 함수에 대한 lvalue 참조 또는 rvalue 참조를 리턴하면 lvalue이고, 함수가 오브젝트에 대한 rvalue 참조를 리턴하면 xvalue이고 그렇지 않으면 prvalue입니다. 함수 호출 표현식이 객체 유형의 prvalue 인 경우, &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; 의 피연산자 (또는 &lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;내장&lt;/a&gt; 의 오른쪽 피연산자로 사용되는 경우 C ++ 17부터)와 같이 prvalue가 구체화되지 않은 경우를 제외하고 완전한 유형을 가져야합니다. -in 쉼표 연산자 식 ( &lt;code&gt;decltype&lt;/code&gt; 의 피연산자 ).</target>
        </trans-unit>
        <trans-unit id="67e47b55490dd997d102458418a048c6890cf272" translate="yes" xml:space="preserve">
          <source>The value comparison function object.</source>
          <target state="translated">값 비교 함수 객체.</target>
        </trans-unit>
        <trans-unit id="e3315b1caebdb1fc309be2d0ec78502282dc56fc" translate="yes" xml:space="preserve">
          <source>The value computed by the three-argument version of this function is the distance of the point &lt;code&gt;(x,y,z)&lt;/code&gt; from the origin &lt;code&gt;(0,0,0)&lt;/code&gt;.</source>
          <target state="translated">이 함수의 3 인수 버전으로 계산 된 값 은 원점 &lt;code&gt;(0,0,0)&lt;/code&gt; 으로부터 점 &lt;code&gt;(x,y,z)&lt;/code&gt; 의 거리입니다 .</target>
        </trans-unit>
        <trans-unit id="f316342cf5de6fdab5febb1bc73226832477d458" translate="yes" xml:space="preserve">
          <source>The value computed by the two-argument version of this function is the length of the hypotenuse of a right-angled triangle with sides of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or the distance of the point &lt;code&gt;(x,y)&lt;/code&gt; from the origin &lt;code&gt;(0,0)&lt;/code&gt;, or the magnitude of a complex number &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt;.</source>
          <target state="translated">이 함수의 2 인수 버전으로 계산 된 값은 길이 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 변이있는 직각 삼각형의 빗변의 길이 이거나 원점 &lt;code&gt;(0,0)&lt;/code&gt; &lt;code&gt;(x,y)&lt;/code&gt; 으로부터 점 (x, y) 의 거리입니다. ) 또는 복소수 &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt; 의 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="7044fe5027fd6004978c59ea869f2af588568b11" translate="yes" xml:space="preserve">
          <source>The value held previously by the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">이전에 &lt;code&gt;obj&lt;/code&gt; 가 가리키는 원자 객체가 보유한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="5b53ba13c1b7ad772fd50ae6d7f505fae71221a4" translate="yes" xml:space="preserve">
          <source>The value immediately preceding the effects of this function in the &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">이 값은 바로이 함수의 효과 항 &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;수정 순&lt;/a&gt; 의 &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21ba436ae4d60c1b3df6f313a5e847a739f28e04" translate="yes" xml:space="preserve">
          <source>The value immediately preceding the effects of this function in the &lt;a href=&quot;memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*obj&lt;/code&gt;.</source>
          <target state="translated">이 값은 바로이 함수의 효과 항 &lt;a href=&quot;memory_order#Modification_order&quot;&gt;수정 순&lt;/a&gt; 의 &lt;code&gt;*obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ad12bc074bf532e8969a9847c8c0936a889cc81" translate="yes" xml:space="preserve">
          <source>The value obtained is the number of successes in a sequence of t yes/no experiments, each of which succeeds with probability p.</source>
          <target state="translated">획득 한 값은 t yes / no 실험 순서에서의 성공 횟수이며, 각각은 확률 p로 성공합니다.</target>
        </trans-unit>
        <trans-unit id="33a4fa47add8b297d431d6dce6cb94e9aeac4af7" translate="yes" xml:space="preserve">
          <source>The value obtained is the probability of exactly i occurrences of a random event if the expected,</source>
          <target state="translated">획득 한 값은 예상 한 경우 임의 이벤트가 정확히 i 일 확률입니다.</target>
        </trans-unit>
        <trans-unit id="873f84075d8ee3fa467aeba44e733298e1a32864" translate="yes" xml:space="preserve">
          <source>The value obtained is the time/distance until the next random event if random events occur at constant rate &amp;lambda; per unit of time/distance. For example, this distribution describes the time between the clicks of a Geiger counter or the distance between point mutations in a DNA strand.</source>
          <target state="translated">임의의 이벤트가 시간 / 거리 단위당 일정한 비율 &amp;lambda;에서 발생하는 경우 다음 랜덤 이벤트까지의 시간 / 거리가 획득됩니다. 예를 들어,이 분포는 가이거 계수기 클릭 사이의 시간 또는 DNA 가닥에서 점 돌연변이 사이의 거리를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="baf914d043e381313277e30f951edd923276b030" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits10&lt;/code&gt; is the number of base-10 digits that can be represented by the type &lt;code&gt;T&lt;/code&gt; without change, that is, any number with this many significant decimal digits can be converted to a value of type &lt;code&gt;T&lt;/code&gt; and back to decimal form, without change due to rounding or overflow. For base-&lt;a href=&quot;radix&quot;&gt;radix&lt;/a&gt; types, it is the value of &lt;a href=&quot;digits&quot;&gt;digits&lt;/a&gt; (&lt;code&gt;digits-1&lt;/code&gt; for floating-point types) multiplied by log</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits10&lt;/code&gt; 의 값은 변경없이 &lt;code&gt;T&lt;/code&gt; 유형으로 표시 할 수있는 10 진수의 자릿수입니다 . 즉,이 10 진수가 많은이 숫자는 다음의 값으로 변환 될 수 있습니다. 반올림 또는 오버플로로 인한 변경없이 &lt;code&gt;T&lt;/code&gt; 를 입력 하고 10 진수 형식으로 되돌립니다. 베이스 - 들어 &lt;a href=&quot;radix&quot;&gt;기수&lt;/a&gt; 유형은의 값 &lt;a href=&quot;digits&quot;&gt;자리&lt;/a&gt; ( &lt;code&gt;digits-1&lt;/code&gt; 의 부동 소수점 타입) 로그 승산</target>
        </trans-unit>
        <trans-unit id="c32d6df5f25bd1c67469d66fa412b07db9fb23e7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits&lt;/code&gt; is the number of digits in base-&lt;a href=&quot;radix&quot;&gt;radix&lt;/a&gt; that can be represented by the type &lt;code&gt;T&lt;/code&gt; without change. For integer types, this is the number of bits not counting the sign bit and the padding bits (if any). For floating-point types, this is the number of digits in the mantissa.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits&lt;/code&gt; 의 값은 &lt;a href=&quot;radix&quot;&gt;기수&lt;/a&gt; 의 자릿수이며 변경없이 &lt;code&gt;T&lt;/code&gt; 유형으로 표시 할 수 있습니다 . 정수 유형의 경우 부호 비트와 패딩 비트 (있는 경우)를 계산하지 않는 비트 수입니다. 부동 소수점 유형의 경우 가수의 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="0efce6844d5328b9d552d5e22fa416002bf69dda" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm&lt;/code&gt; identifies the floating-point types that support &lt;a href=&quot;https://en.wikipedia.org/wiki/Denormal_number&quot;&gt;subnormal values&lt;/a&gt;.</source>
          <target state="translated">값 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm&lt;/code&gt; 지지하는 것을 식별 부동 소수점 형식 &lt;a href=&quot;https://en.wikipedia.org/wiki/Denormal_number&quot;&gt;비정규 값&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="818565d8873864260ed4bd3755ec119254a0a789" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm_loss&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; that detect loss of precision when creating a subnormal number as denormalization loss rather than as inexact result (see below).</source>
          <target state="translated">값 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm_loss&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 모든 부동 소수점 형식의 &lt;code&gt;T&lt;/code&gt; 역 정규화 손실 비정규 번호를 생성하는 대신 부정확 한 결과 (아래 참조) 때의 정밀도의 손실을 검출한다.</target>
        </trans-unit>
        <trans-unit id="49fe53c8f4920123566acbcd270a4d7a6cb8ff5d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the positive infinity as a distinct special value. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">의 값을 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; 것입니다 &lt;code&gt;true&lt;/code&gt; 모든 종류의 &lt;code&gt;T&lt;/code&gt; 별개의 특수한 값으로 무한대를 표시 할 수. 이 상수는 모든 부동 소수점 유형에 대한 의미 및 보장되는 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72efab69a379a3baec3c747ef72e6384302c8f11" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the special value &quot;Quiet &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;Not-A-Number&lt;/a&gt;&quot;. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">의 값 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; 모든 유형의 &lt;code&gt;T&lt;/code&gt; 특수 값을 표시 할 수는 &quot;조용히 &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;하지-A-번호&lt;/a&gt; &quot;. 이 상수는 모든 부동 소수점 유형에 대한 의미 및 보장되는 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13d78c72e37aa6610d8da4c27392455c38353258" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the special value &quot;Signaling &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;Not-A-Number&lt;/a&gt;&quot;. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">의 값 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; 모든 종류의 &lt;code&gt;T&lt;/code&gt; &quot;시그널링 특수 값 표시 할 수 &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;없음-A-번호&lt;/a&gt; &quot;. 이 상수는 모든 부동 소수점 유형에 대한 의미 및 보장되는 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f98212fab0bd1fe8a4594e818456712a7e96f5af" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_bounded&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that represent a finite set of values. While all fundamental types are bounded, this constant would be &lt;code&gt;false&lt;/code&gt; in a specialization of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; for a library-provided arbitrary precision arithmetic type.</source>
          <target state="translated">값 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_bounded&lt;/code&gt; IS &lt;code&gt;true&lt;/code&gt; 모든 산술 타입 &lt;code&gt;T&lt;/code&gt; 값들의 유한 집합을 나타낸다. 모든 기본 유형이 제한되어 있지만 라이브러리가 제공하는 임의의 정밀 산술 유형에 대한 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; 전문화 에서이 상수는 &lt;code&gt;false&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="a3bc9c048c67471591b1728199b12d7c643bc09a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that use exact representation.</source>
          <target state="translated">의 값을 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact&lt;/code&gt; IS &lt;code&gt;true&lt;/code&gt; 모든 산술 유형의 &lt;code&gt;T&lt;/code&gt; 정확한 표현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0de1e0807da9a49f5b6ab2b0b1d4bdf3282315d4" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; which fulfill the requirements of IEC 559 (&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754&lt;/a&gt;) standard. If &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; are also &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">의 값을 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; 것입니다 &lt;code&gt;true&lt;/code&gt; 모든 부동 소수점 유형에 대한 &lt;code&gt;T&lt;/code&gt; IEC 559 (의 요구 사항을 충족 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754&lt;/a&gt; ) 표준을. 만약 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; , 다음 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; 있는도를 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5566e2270326a63be00f7caa114991c2e742497" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_integer&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all integer arithmetic types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; otherwise. This constant is meaningful for all specializations.</source>
          <target state="translated">의 값을 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_integer&lt;/code&gt; 입니다 &lt;code&gt;true&lt;/code&gt; 모든 정수 연산 유형 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;false&lt;/code&gt; 이 없습니다. 이 상수는 모든 전문 분야에 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="658be2ec18bfcdb89b874906fd0e9a2788a963dc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_modulo&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that are possible to (until C++11)handle overflows with modulo arithmetic, that is, if the result of addition, subtraction, multiplication, or division of this type would fall outside the range &lt;code&gt;[min(), max()]&lt;/code&gt;, the value returned by such operation differs from the expected value by a multiple of &lt;code&gt;max()-min()+1&lt;/code&gt;.</source>
          <target state="translated">값 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_modulo&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 모든 산술 타입 &lt;code&gt;T&lt;/code&gt; 에 가능 손잡이 즉, 모듈러 산술 오버플 (C ++ 11까지), 만일 가산 결과, 뺄셈, 곱셈, 또는이 유형의 나누기가 &lt;code&gt;[min(), max()]&lt;/code&gt; 범위를 벗어나는 경우 이러한 연산에 의해 반환되는 값은 &lt;code&gt;max()-min()+1&lt;/code&gt; 의 배수에 의해 예상 값과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="31c7c70df24e3cc025f30c7660467183acd0bc12" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_signed&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all signed arithmetic types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; for the unsigned types. This constant is meaningful for all specializations.</source>
          <target state="translated">의 값을 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_signed&lt;/code&gt; IS &lt;code&gt;true&lt;/code&gt; 모든 서명 산술 유형 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;false&lt;/code&gt; 서명되지 않은 유형. 이 상수는 모든 전문 분야에 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c387cb47b15566bbeed0c9ac97ac7422cc757b9c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_specialized&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T&lt;/code&gt; for which there exists a specialization of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">의 값을 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_specialized&lt;/code&gt; IS &lt;code&gt;true&lt;/code&gt; 모두를위한 &lt;code&gt;T&lt;/code&gt; 의 전문성이 존재하는 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a6c251458907976d9505f9f19b57f15d678ee8d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_digits10&lt;/code&gt; is the number of base-10 digits that are necessary to uniquely represent all distinct values of the type &lt;code&gt;T&lt;/code&gt;, such as necessary for serialization/deserialization to text. This constant is meaningful for all floating-point types.</source>
          <target state="translated">값 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_digits10&lt;/code&gt; 고유의 형태의 별개의 값을 나타내는 데 필요한베이스 10의 자리수 &lt;code&gt;T&lt;/code&gt; 를 텍스트로 직렬화 / 역 직렬화하기 위해 필요한대로. 이 상수는 모든 부동 소수점 유형에 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ede15e1ccfe9c08910652785a578f9aff770fc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent10&lt;/code&gt; is the largest positive number &lt;code&gt;n&lt;/code&gt; such that 10n</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent10&lt;/code&gt; 의 값은 10n과 같이 가장 큰 양수 &lt;code&gt;n&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4428910011b11510b83f35d9325633de507bd21f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent&lt;/code&gt; is the largest positive number &lt;code&gt;n&lt;/code&gt; such that rn-1</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent&lt;/code&gt; 의 값은 rn-1과 같이 가장 큰 양수 &lt;code&gt;n&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a8e50309322655b0b34d76c3ee924a26b2a1631" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent10&lt;/code&gt; is the lowest negative number &lt;code&gt;n&lt;/code&gt; such that 10n</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent10&lt;/code&gt; 의 값은 10n과 같이 가장 작은 음수 &lt;code&gt;n&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7d35efd9d6ad828da236c558d6eb68513df2887" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent&lt;/code&gt; is the lowest negative number &lt;code&gt;n&lt;/code&gt; such that rn-1</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent&lt;/code&gt; 의 값은 rn-1과 같이 가장 작은 음수 &lt;code&gt;n&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="67d3622bd53f05bb8c505d5f1632f3a6e465c7e7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::radix&lt;/code&gt; is the base of the number system used in the representation of the type. It is 2 for all binary numeric types, but it may be, for example, 10 for IEEE 754 &lt;a href=&quot;https://en.wikipedia.org/wiki/Decimal64_floating-point_format&quot;&gt;decimal floating-point types&lt;/a&gt; or for third-party &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;binary-coded decimal&lt;/a&gt; integers. This constant is meaningful for all specializations.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::radix&lt;/code&gt; 의 값은 유형을 표현하는 데 사용되는 숫자 시스템의 기본입니다. 모든 이진 숫자 유형의 경우 2이지만 IEEE 754 &lt;a href=&quot;https://en.wikipedia.org/wiki/Decimal64_floating-point_format&quot;&gt;10 진수 부동 소수점 유형의 경우&lt;/a&gt; 또는 타사 &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;이진 코드 10 진&lt;/a&gt; 정수의 경우 10 일 수 있습니다. 이 상수는 모든 전문 분야에 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad3e3b6d189c403f77654a78e8b8fce06565fd64" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::round_style&lt;/code&gt; identifies the rounding style used by the floating-point type &lt;code&gt;T&lt;/code&gt; whenever a value that is not one of the exactly repesentable values of &lt;code&gt;T&lt;/code&gt; is stored in an object of that type.</source>
          <target state="translated">값 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::round_style&lt;/code&gt; 식별 부동 소수점 형식으로 사용하는 반올림 스타일 &lt;code&gt;T&lt;/code&gt; 의 정확히 repesentable 값 중 하나가 아닌 값마다 &lt;code&gt;T&lt;/code&gt; 는 그 타입의 객체에 저장된다.</target>
        </trans-unit>
        <trans-unit id="929804192ce1c0c75b72779392cd6ef40eb4db5c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::tinyness_before&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; that test results of floating-point expressions for underflow before rounding.</source>
          <target state="translated">의 값을 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::tinyness_before&lt;/code&gt; IS &lt;code&gt;true&lt;/code&gt; 모든 부동 소수점 유형에 대한 &lt;code&gt;T&lt;/code&gt; 그 반올림 전에 언더 플로우에 대한 부동 소수점 표현의 테스트 결과.</target>
        </trans-unit>
        <trans-unit id="f1ed74039ebf1d42dca61166c833be8f6cd7f491" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::traps&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that have at least one value that, if used as an argument to an arithmetic operation, will generate a &lt;a href=&quot;https://en.wikipedia.org/wiki/Trap_(computing)&quot;&gt;trap&lt;/a&gt;.</source>
          <target state="translated">값 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::traps&lt;/code&gt; IS &lt;code&gt;true&lt;/code&gt; 모든 산술 타입 &lt;code&gt;T&lt;/code&gt; 의 연산을 인수로 사용하는 경우 발생되며, 적어도 하나 개의 값이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Trap_(computing)&quot;&gt;트랩&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7772c8f78a06c27107be30f83bed9d48e68fe602" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;T(rv)&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the initialization.</source>
          <target state="translated">값 &lt;code&gt;T(rv)&lt;/code&gt; 값에 해당 &lt;code&gt;rv&lt;/code&gt; 초기화 전에.</target>
        </trans-unit>
        <trans-unit id="e603736762efe81e0cad9751283ad8e5a1c288ee" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;T(v)&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">값 &lt;code&gt;T(v)&lt;/code&gt; 값에 해당 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ede44778ad8d0c527731cf4a992de2cbbc6337" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is a/2b</source>
          <target state="translated">&lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; 의 값 은 a / 2b입니다.</target>
        </trans-unit>
        <trans-unit id="0e75326e3adb574a4a577f0c6f90eb22555c8d18" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is the unique value congruent to a * 2b</source>
          <target state="translated">&lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; 의 값은 a * 2b와 일치하는 고유 한 값입니다.</target>
        </trans-unit>
        <trans-unit id="74363b0d87e71eb3303d92bd255f435d2a3c664f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;base&lt;/code&gt; if successful, zero otherwise.</source>
          <target state="translated">성공하면 &lt;code&gt;base&lt;/code&gt; 값 , 그렇지 않으면 0</target>
        </trans-unit>
        <trans-unit id="56ee130795a5dbf75897c6a6783296c3ad1b779f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;errno&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt; at program startup, and although library functions are allowed to write positive integers to &lt;code&gt;errno&lt;/code&gt; whether or not an error occurred, library functions never store &lt;code&gt;​0​&lt;/code&gt; in &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">값 &lt;code&gt;errno&lt;/code&gt; 것이다 &lt;code&gt;​0​&lt;/code&gt; 프로그램을 시작할 때, 라이브러리 함수는 양의 정수로 쓸 수있다하더라도 &lt;code&gt;errno&lt;/code&gt; 에 에러가 발생하는지 여부를, 라이브러리 함수는 결코 저장되지 &lt;code&gt;​0​&lt;/code&gt; 에서 &lt;code&gt;errno&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da2294d8108c3a6f801f89b03514268af0f31351" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;math_errhandling&lt;/code&gt; indicates the type of error handling that is performed by the floating-point operators and &lt;a href=&quot;../math&quot;&gt;functions&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;math_errhandling&lt;/code&gt; 값은 부동 소수점 연산자 및 &lt;a href=&quot;../math&quot;&gt;함수&lt;/a&gt; 가 수행하는 오류 처리 유형을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7588ffd7a3be6d286f7a94c5cb61054a64fe7ac0" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;required_alignment&lt;/code&gt; is the required alignment for an object to be referenced by an atomic reference, which is at least &lt;code&gt;alignof(T)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;required_alignment&lt;/code&gt; 의 값은 원자 참조에 의해 참조 될 객체에 대한 필수 정렬이며, 적어도 &lt;code&gt;alignof(T)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a34573176a6c9f015786e0ff510ba4a79a46897b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;t&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">값 &lt;code&gt;t&lt;/code&gt; 는 의 값과 동일하다 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="236ee56b867559bead4e59b54a4e12b218879b5a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;u&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the initialization.</source>
          <target state="translated">값 &lt;code&gt;u&lt;/code&gt; 의 값과 동일하다 &lt;code&gt;rv&lt;/code&gt; 초기화 전에.</target>
        </trans-unit>
        <trans-unit id="29aad058a8f1625b999d87663e4e7194ff6bfb72" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;u&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">값 &lt;code&gt;u&lt;/code&gt; 의 값과 동일하다 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c88528c3373936092717d4d0ad525f88f8c4c725" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;v&lt;/code&gt; is unchanged.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 값 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e00c73d0ffbf3ea2f54f0b446263ab8f6d39011" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;std::contract_violation&lt;/code&gt; argument passed to the violation handler is otherwise implementation-defined.</source>
          <target state="translated">위반 핸들러에 전달 된 &lt;code&gt;std::contract_violation&lt;/code&gt; 인수 의 값은 구현 정의입니다.</target>
        </trans-unit>
        <trans-unit id="50fc3e65512141062b28f772c21ab1b1ae455710" translate="yes" xml:space="preserve">
          <source>The value of the atomic variable before the call.</source>
          <target state="translated">호출 전 원자 변수의 값입니다.</target>
        </trans-unit>
        <trans-unit id="a3e86cc39cfa2d8064dc4c87f48911c38b5823b0" translate="yes" xml:space="preserve">
          <source>The value of the character pointed to by the</source>
          <target state="translated">에 의해 지적 된 문자의 가치</target>
        </trans-unit>
        <trans-unit id="a2c309bf2bbc046c6f48e885d2ea4de4c5bf6803" translate="yes" xml:space="preserve">
          <source>The value of the character that was pointed to by the</source>
          <target state="translated">에 의해 지적 된 문자의 가치</target>
        </trans-unit>
        <trans-unit id="1d70250e3d2b884af86af7d39be631bda55177ff" translate="yes" xml:space="preserve">
          <source>The value of the character that was read and consumed in case of success, or &lt;code&gt;Traits::eof()&lt;/code&gt; in case of failure.</source>
          <target state="translated">성공한 경우 읽고 소비 한 문자 값 또는 실패한 경우 &lt;code&gt;Traits::eof()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f39527ddfa65bb2b87383657aeac9ba9fbcb938" translate="yes" xml:space="preserve">
          <source>The value of the device entropy, or zero if not applicable.</source>
          <target state="translated">장치 엔트로피 값 또는 적용 할 수없는 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="9650465fffa6e1c6a542896eedb2d7c139c42b4e" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;std::ilogb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;std::ilogb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">&lt;code&gt;std::ilogb&lt;/code&gt; 의해 리턴 된 지수의 값은 다른 정규화 요구 사항 때문에 &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; 의해 재조정 된 지수보다 항상 1보다 작습니다. &lt;code&gt;std::ilogb&lt;/code&gt; 의해 리턴 된 지수 &lt;code&gt;e&lt;/code&gt; 의 경우 , | arg * re</target>
        </trans-unit>
        <trans-unit id="296087b3564287e313cec1b7f024f1690f7740f9" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;std::logb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;std::logb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">&lt;code&gt;std::logb&lt;/code&gt; 의해 리턴 된 지수의 값은 다른 정규화 요구 사항으로 인해 &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; 의해 재조정 된 지수보다 항상 1보다 작습니다. &lt;code&gt;std::logb&lt;/code&gt; 의해 리턴 된 지수 &lt;code&gt;e&lt;/code&gt; 의 경우 , | arg * re</target>
        </trans-unit>
        <trans-unit id="1875dc13670139d279ca0c0bbdce2d158a5cdbab" translate="yes" xml:space="preserve">
          <source>The value of the next character. If the input sequence has been exhausted, &lt;code&gt;Traits::eof()&lt;/code&gt; is returned.</source>
          <target state="translated">다음 문자의 값입니다. 입력 시퀀스가 ​​소진되면 &lt;code&gt;Traits::eof()&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="753fa9ec46bd8acaa1bc2b9508919ca2004c1c39" translate="yes" xml:space="preserve">
          <source>The value of the parameter is passed to the object at the construction time and stored within the object. Whenever the function object is invoked though &lt;code&gt;operator()&lt;/code&gt;, the stored value is passed as one of the arguments, the other argument is passed as an argument of &lt;code&gt;operator()&lt;/code&gt;. The resulting function object is an unary function.</source>
          <target state="translated">매개 변수의 값은 구성 시간에 오브젝트에 전달되어 오브젝트 내에 저장됩니다. &lt;code&gt;operator()&lt;/code&gt; 통해 함수 객체가 호출 될 때마다 저장된 값이 인수 중 하나로 전달되고 다른 인수는 &lt;code&gt;operator()&lt;/code&gt; 의 인수로 전달됩니다 . 결과 함수 객체는 단항 함수입니다.</target>
        </trans-unit>
        <trans-unit id="fba7a209e09ccfdda21dc54ae2df8a504208cb4c" translate="yes" xml:space="preserve">
          <source>The value of the referenced object before the call.</source>
          <target state="translated">호출 전 참조 된 객체의 값입니다.</target>
        </trans-unit>
        <trans-unit id="579ea98c704ce031e4e668b7afec012ffc8fd162" translate="yes" xml:space="preserve">
          <source>The value of the referenced object, immediately preceding the effects of this function.</source>
          <target state="translated">이 함수의 영향 직전에 참조 된 객체의 값.</target>
        </trans-unit>
        <trans-unit id="7e259073fe670a628dfb34370ab4b87683b659c4" translate="yes" xml:space="preserve">
          <source>The value of this constant is consistent with both the macro &lt;code&gt;ATOMIC_xxx_LOCK_FREE&lt;/code&gt;, where defined, with the member function &lt;code&gt;is_lock_free&lt;/code&gt; and non-member function &lt;code&gt;&lt;a href=&quot;../atomic_is_lock_free&quot;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 정의 된 매크로 &lt;code&gt;ATOMIC_xxx_LOCK_FREE&lt;/code&gt; 매크로 와 멤버 함수 &lt;code&gt;is_lock_free&lt;/code&gt; 및 비 멤버 함수 &lt;code&gt;&lt;a href=&quot;../atomic_is_lock_free&quot;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="50845a026f496d39a63c3b0808c04361d0c8d58a" translate="yes" xml:space="preserve">
          <source>The value of this constant is consistent with the result of member function &lt;code&gt;is_lock_free&lt;/code&gt;.</source>
          <target state="translated">이 상수의 값은 멤버 함수 &lt;code&gt;is_lock_free&lt;/code&gt; 의 결과와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="3403e199b11ef7fa0931fa58eddb8861252d4576" translate="yes" xml:space="preserve">
          <source>The value of type &lt;code&gt;char_type&lt;/code&gt; to use as the decimal separator. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;L'.'&lt;/code&gt;.</source>
          <target state="translated">소수점 구분 기호로 사용할 &lt;code&gt;char_type&lt;/code&gt; 유형의 값입니다 . &lt;code&gt;std::numpunct&lt;/code&gt; 의 표준 전문화는 &lt;code&gt;'.'&lt;/code&gt; 을 리턴 합니다. 그리고 &lt;code&gt;L'.'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d17479026d3ea907d688db9d63f82d0f2b54dabe" translate="yes" xml:space="preserve">
          <source>The value or reference, if any, returned by the above call to &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Container::emplace_back&lt;/code&gt; 에 대한 위의 호출에 의해 반환 된 값 또는 참조입니다 (있는 경우) .</target>
        </trans-unit>
        <trans-unit id="c811b075e6e49eb2c35eb490d71ce4d51653f77f" translate="yes" xml:space="preserve">
          <source>The value previously held by the flag pointed to by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 가 가리키는 플래그가 이전에 보유한 값 .</target>
        </trans-unit>
        <trans-unit id="2e567269120efb53b09110c26a8c4b9df966cef5" translate="yes" xml:space="preserve">
          <source>The value represented by the digit &lt;code&gt;c&lt;/code&gt; in base &lt;code&gt;I&lt;/code&gt; if the character &lt;code&gt;c&lt;/code&gt; is a valid digit in base &lt;code&gt;I&lt;/code&gt;</source>
          <target state="translated">문자 &lt;code&gt;c&lt;/code&gt; 가 기본 &lt;code&gt;I&lt;/code&gt; 의 유효한 숫자 인 경우 기본 &lt;code&gt;I&lt;/code&gt; 의 숫자 &lt;code&gt;c&lt;/code&gt; 로 표시되는 값</target>
        </trans-unit>
        <trans-unit id="6f109c11a81bea0070c0d68dbb9891509f2180fe" translate="yes" xml:space="preserve">
          <source>The value represents the number of failures in a series of independent yes/no trials (each succeeds with probability p), before exactly k successes occur.</source>
          <target state="translated">이 값은 정확히 k 개의 성공이 발생하기 전에 일련의 독립적 인 예 / 아니오 시도 (각각 확률 p로 성공)에서 실패 횟수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8e434c235337a8e747f5dea3bd883fac3c017159" translate="yes" xml:space="preserve">
          <source>The value represents the number of yes/no trials (each succeeding with probability p) which are necessary to obtain a single success.</source>
          <target state="translated">이 값은 단일 성공을 얻는 데 필요한 예 / 아니오 시행 횟수 (각각 확률 p로 성공)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bf46f4d3ca59d9f0505163079a8aeb0e0dc873f3" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;clock()&lt;/code&gt; may wrap around on some implementations. For example, on a machine with 32-bit &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt;, it wraps after 2147 seconds or 36 minutes.</source>
          <target state="translated">&lt;code&gt;clock()&lt;/code&gt; 의해 리턴 된 값 은 일부 구현에서 랩 어라운드 될 수 있습니다. 예를 들어, 32 비트 &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; 있는 시스템에서는 2147 초 또는 36 분 후에 랩핑됩니다.</target>
        </trans-unit>
        <trans-unit id="ad4cdd680a12e6dfddb5ab5b51fcd6bb72586940" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">이 값에 의해 리턴 &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f06ccf9b4233e6226d4ee4962b6bec1aa785187" translate="yes" xml:space="preserve">
          <source>The value returned by the called function.</source>
          <target state="translated">호출 된 함수가 반환 한 값입니다.</target>
        </trans-unit>
        <trans-unit id="601b8abd8b6436ee946fa9803b76f69133a0a540" translate="yes" xml:space="preserve">
          <source>The value returned by this conversion function is a pointer to a function with C++ &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; that, when invoked, has the same effect as invoking the closure object's function call operator directly.</source>
          <target state="translated">이 변환 함수에 의해 리턴되는 값은 호출 될 때 클로저 오브젝트의 함수 호출 연산자를 직접 호출하는 것과 동일한 효과를 갖는 C ++ &lt;a href=&quot;language_linkage&quot;&gt;언어 링크&lt;/a&gt; 가있는 함수에 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="fdd035144b0ab851484c1c365e56cbd1dcc1b54a" translate="yes" xml:space="preserve">
          <source>The value returned shall be independent of the case of the characters in the sequence.</source>
          <target state="translated">반환 된 값은 시퀀스의 문자와 무관해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7fb32b3c03551e69bd2a36e0056ba4535fa1910" translate="yes" xml:space="preserve">
          <source>The value that is held by the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 가리키는 원자 객체가 보유하는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="833d5a34e8e09458e1d01611adfdc9d19f4256ea" translate="yes" xml:space="preserve">
          <source>The value that results from assigning or initializing a signed bit field with a value out of range, or from incrementing a signed bit field past its range.</source>
          <target state="translated">범위를 벗어난 값으로 부호있는 비트 필드를 할당하거나 초기화하거나 범위를 지나서 부호있는 비트 필드를 증가 시켜서 발생하는 값입니다.</target>
        </trans-unit>
        <trans-unit id="da945c5370b89f1c8352311f12a54ddba345a51b" translate="yes" xml:space="preserve">
          <source>The value type of &lt;code&gt;RandomIt1&lt;/code&gt; must be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">의 값 유형 &lt;code&gt;RandomIt1&lt;/code&gt; 이 있어야합니다 &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; , &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible (복사 가능 생성자)&lt;/a&gt; 와 &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf2f9d6307fbcb0677baa700e9f0dbc912c45998" translate="yes" xml:space="preserve">
          <source>The value zero (for integral, floating-point, and unscoped enumeration) and the null pointer and the null pointer-to-member values become &lt;code&gt;false&lt;/code&gt;. All other values become &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">값 0 (정수, 부동 소수점 및 범위가없는 열거의 경우)과 널 포인터 및 널 포인터 대 멤버 값은 &lt;code&gt;false&lt;/code&gt; 가 됩니다. 다른 모든 값은 &lt;code&gt;true&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="7ba8effa4c27f0ba732998c45f3421c98781d70d" translate="yes" xml:space="preserve">
          <source>The values in the returned struct may differ from those supplied to the constructor in the following ways:</source>
          <target state="translated">반환 된 구조체의 값은 다음과 같은 방식으로 생성자에 제공된 값과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a76aed414f920671ac2d5636063f80c02930b91" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sep_by_space&lt;/code&gt;, &lt;code&gt;n_sep_by_space&lt;/code&gt;, &lt;code&gt;int_p_sep_by_space&lt;/code&gt;, &lt;code&gt;int_n_sep_by_space&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">&lt;code&gt;p_sep_by_space&lt;/code&gt; , &lt;code&gt;n_sep_by_space&lt;/code&gt; , &lt;code&gt;int_p_sep_by_space&lt;/code&gt; , &lt;code&gt;int_n_sep_by_space&lt;/code&gt; 의 값은 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="77672f917a9b339a086c2698e191450e19cf6727" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sign_posn&lt;/code&gt;, &lt;code&gt;n_sign_posn&lt;/code&gt;, &lt;code&gt;int_p_sign_posn&lt;/code&gt;, &lt;code&gt;int_n_sign_posn&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">&lt;code&gt;p_sign_posn&lt;/code&gt; , &lt;code&gt;n_sign_posn&lt;/code&gt; , &lt;code&gt;int_p_sign_posn&lt;/code&gt; , &lt;code&gt;int_n_sign_posn&lt;/code&gt; 의 값은 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="33abc0ae5b48791fecb22e74c9f73d03bb18aa24" translate="yes" xml:space="preserve">
          <source>The values of the member typedefs are as follows.</source>
          <target state="translated">멤버 typedef의 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9fe6d1f76a572b29a8d3484a98866cb41ec603b" translate="yes" xml:space="preserve">
          <source>The values of these macros (except for &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;) remain constant throughout the translation unit. Attempts to redefine or undefine these macros result in undefined behavior.</source>
          <target state="translated">이러한 매크로의 값 ( &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__LINE__&lt;/code&gt; 제외 )은 변환 단위 전체에서 일정하게 유지됩니다. 이러한 매크로를 재정의하거나 정의를 취소하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="98bfbbcd22ae41d5573869cfcb9522362b10fb4c" translate="yes" xml:space="preserve">
          <source>The version of this function provided in the standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; does the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; 의 표준 라이브러리 전문화에서 제공되는이 함수의 버전은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a622961aafca050ec72f078b30740b239e4cfd26" translate="yes" xml:space="preserve">
          <source>The versions (1-4) are implicitly declared in each translation unit even if the &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; header is not included. Versions (1-8) are</source>
          <target state="translated">&lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; 헤더가 포함되지 않은 경우에도 버전 (1-4)은 각 번역 단위에 암시 적으로 선언 됩니다. 버전 (1-8)은</target>
        </trans-unit>
        <trans-unit id="b0b7d7c2aa828b9a641d26b6867ec8872ed88500" translate="yes" xml:space="preserve">
          <source>The weak forms ((1) and (3)) of the functions are allowed to fail spuriously, that is, act as if &lt;code&gt;*obj != *expected&lt;/code&gt; even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.</source>
          <target state="translated">함수의 약한 형태 ((1) 및 (3))는 허위로 실패 할 수 있습니다. 즉, &lt;code&gt;*obj != *expected&lt;/code&gt; 가 같더라도 예상대로 작동 합니다. 비교 및 교환이 반복되는 경우 약한 버전은 일부 플랫폼에서 더 나은 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="053ece5439dd03785d396cff64f13b7779aae0c4" translate="yes" xml:space="preserve">
          <source>The weak forms (1-2) of the functions are allowed to fail spuriously, that is, act as if &lt;code&gt;*this != expected&lt;/code&gt; even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.</source>
          <target state="translated">함수의 약한 형태 (1-2)는 허위로 실패 할 수 있습니다. 즉, &lt;code&gt;*this != expected&lt;/code&gt; 가 같더라도 예상되는 것처럼 작동 합니다. 비교 및 교환이 반복되는 경우 약한 버전은 일부 플랫폼에서 더 나은 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="61282ad563d58ac6dca223420c82a6fda52cb8a1" translate="yes" xml:space="preserve">
          <source>The weakest alignment (the smallest alignment requirement) is the alignment of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt;, which equals 1; the largest</source>
          <target state="translated">가장 약한 정렬 (가장 작은 정렬 요구 사항)은 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;signed char&lt;/code&gt; 및 &lt;code&gt;unsigned char&lt;/code&gt; 의 정렬입니다 ( 1). 가장 큰</target>
        </trans-unit>
        <trans-unit id="6636ab7a40ed20b3758bf9d6aa3f53a69dfb3fd6" translate="yes" xml:space="preserve">
          <source>The weekday value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 저장된 요일 값 .</target>
        </trans-unit>
        <trans-unit id="147c41b97d63a5ff943a4dff64e656850433bca6" translate="yes" xml:space="preserve">
          <source>The whitespace skipping is performed by the constructor of &lt;code&gt;&lt;a href=&quot;../basic_istream/sentry&quot;&gt;std::basic_istream::sentry&lt;/a&gt;&lt;/code&gt;, which reads and discards the characters classified as whitespace by the &lt;code&gt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet of the stream's imbued locale.</source>
          <target state="translated">공백 건너 뛰기는 &lt;code&gt;&lt;a href=&quot;../basic_istream/sentry&quot;&gt;std::basic_istream::sentry&lt;/a&gt;&lt;/code&gt; 의 생성자에 의해 수행되며 , 스트림에 포함 된 로케일의 &lt;code&gt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 패싯에 의해 공백으로 분류 된 문자를 읽고 버립니다 .</target>
        </trans-unit>
        <trans-unit id="28861a2e9cac8a64e7e6c9de02d8f4ad1d432f65" translate="yes" xml:space="preserve">
          <source>The width property of the stream will be reset to zero (meaning &quot;unspecified&quot;) if any of the following functions are called:</source>
          <target state="translated">다음 함수 중 하나가 호출되면 스트림의 너비 속성이 0으로 재설정됩니다 ( &quot;지정되지 않음&quot;).</target>
        </trans-unit>
        <trans-unit id="75482b7330efd238856a66fa9534aa457b8aac86" translate="yes" xml:space="preserve">
          <source>The written character, converted to &lt;code&gt;int_type&lt;/code&gt; with &lt;code&gt;Traits::to_int_type(ch)&lt;/code&gt; on success.</source>
          <target state="translated">작성된 문자 는 성공시 &lt;code&gt;Traits::to_int_type(ch)&lt;/code&gt; 를 사용 하여 &lt;code&gt;int_type&lt;/code&gt; 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="1270ca56a41a6e7f02e1f97ce0b715f2fb7199a2" translate="yes" xml:space="preserve">
          <source>The year value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 에 저장된 연도 값 .</target>
        </trans-unit>
        <trans-unit id="d323f4076e0841438d41510cd53cbcfb9286a841" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;replacement&lt;/code&gt; is appended as if by &lt;code&gt;operator+=(replacement)&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;operator+=(replacement)&lt;/code&gt; 에 의해 &lt;code&gt;replacement&lt;/code&gt; 가 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="373a08cad37838d1afc67f2d26d81125cf6dd627" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;std::launder(p)&lt;/code&gt; returns a value of type &lt;code&gt;T*&lt;/code&gt; that points to the object &lt;code&gt;X&lt;/code&gt;. Otherwise, the behavior is undefined.</source>
          <target state="translated">그런 다음 &lt;code&gt;std::launder(p)&lt;/code&gt; 는 객체 &lt;code&gt;X&lt;/code&gt; 를 가리키는 &lt;code&gt;T*&lt;/code&gt; 유형의 값을 반환합니다 . 그렇지 않으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8cef55836d6512dfe4dc252602d2fb2a942c56d" translate="yes" xml:space="preserve">
          <source>Then converts the argument &lt;code&gt;dir&lt;/code&gt; to a value &lt;code&gt;whence&lt;/code&gt; of type &lt;code&gt;int&lt;/code&gt; as follows:</source>
          <target state="translated">그런 다음 인수로 변환 &lt;code&gt;dir&lt;/code&gt; 값을 &lt;code&gt;whence&lt;/code&gt; 타입의 &lt;code&gt;int&lt;/code&gt; 다음과 같이 :</target>
        </trans-unit>
        <trans-unit id="d114c31b8c85d68931469ea5e0153732743033d0" translate="yes" xml:space="preserve">
          <source>Then for the expression &lt;code&gt;w1 == w2&lt;/code&gt; and &lt;code&gt;w1 != w2&lt;/code&gt; either or both objects may be replaced by an</source>
          <target state="translated">그런 다음 &lt;code&gt;w1 == w2&lt;/code&gt; 및 &lt;code&gt;w1 != w2&lt;/code&gt; 표현식의 경우 두 오브젝트 중 하나 또는 둘 다</target>
        </trans-unit>
        <trans-unit id="5664e9f77aa6963c92dfdd8b0b7e6f96d1c31677" translate="yes" xml:space="preserve">
          <source>Then performs move-assignment by moving all contents from &lt;code&gt;other&lt;/code&gt;, including the temporary storage, the wrapped stream pointer, policy, and all other state (such as the mutex pointer). After move, &lt;code&gt;other&lt;/code&gt; is not associated with a stream, and &lt;code&gt;other.get_wrapped()==nullptr&lt;/code&gt;. The put area member pointers of the base class &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;other&lt;/code&gt; are guaranteed to be null. Destroying a moved-from &lt;code&gt;other&lt;/code&gt; will not produce any output.</source>
          <target state="translated">그런 다음 임시 저장소, 래핑 된 스트림 포인터, 정책 및 기타 모든 상태 (예 : 뮤텍스 포인터)를 포함한 &lt;code&gt;other&lt;/code&gt; 의 모든 내용을 이동하여 이동 할당을 수행합니다 . 전진 한 후, &lt;code&gt;other&lt;/code&gt; 스트림과 연관되지 않고 &lt;code&gt;other.get_wrapped()==nullptr&lt;/code&gt; . &lt;code&gt;other&lt;/code&gt; 기본 클래스 &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 의 풋 영역 멤버 포인터는 널 (null)임을 보장합니다. &lt;code&gt;other&lt;/code&gt; 으로 이동 한 것을 제거해 도 출력이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="688a34f8e387e542a111a325ed5ac02b72fbb6e9" translate="yes" xml:space="preserve">
          <source>Then repositions the file pointer, as if by calling &lt;code&gt;&lt;a href=&quot;../c/fsetpos&quot;&gt;std::fsetpos()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;../c/fsetpos&quot;&gt;std::fsetpos()&lt;/a&gt;&lt;/code&gt; 호출하여 파일 포인터를 재배치합니다 .</target>
        </trans-unit>
        <trans-unit id="7c6cd6761eff74a4e8721e60e098e84a0745d88f" translate="yes" xml:space="preserve">
          <source>Then stores each character from the resulting sequence (the contents of &lt;code&gt;str&lt;/code&gt; plus padding) to the output stream &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; 을 호출 하여 결과 시퀀스 ( &lt;code&gt;str&lt;/code&gt; + padding 의 내용 )에서 출력 스트림 &lt;code&gt;os&lt;/code&gt; 로 각 문자를 저장합니다 . 여기서 &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt; &lt;a href=&quot;../../algorithm/max&quot;&gt;std :: max&lt;/a&gt; (os.width (), str.size ()) .</target>
        </trans-unit>
        <trans-unit id="89dd54897998475390b292a027e7346fd0e80fba" translate="yes" xml:space="preserve">
          <source>Then stores each character from the resulting sequence (the contents of &lt;code&gt;v&lt;/code&gt; plus padding) to the output stream &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; 을 호출 하여 결과 시퀀스 ( &lt;code&gt;v&lt;/code&gt; 와 padding 의 내용 )에서 출력 스트림 &lt;code&gt;os&lt;/code&gt; 로 각 문자를 저장합니다 . 여기서 &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt; &lt;a href=&quot;../../algorithm/max&quot;&gt;std :: max&lt;/a&gt; (os.width (), str.size ()) .</target>
        </trans-unit>
        <trans-unit id="b71560ffb9f745af8a0de8c02270fff34828d1a4" translate="yes" xml:space="preserve">
          <source>Then template-1 is more specialized than template-2. If the conditions above are true after switching template order, than template-2 is more specialized than template-1. Otherwise, neither template is more specialized than the other. In case of a tie, if one function template has a trailing parameter pack and the other does not, the one with the omitted parameter is considered to be more specialized than the one with the empty parameter pack.</source>
          <target state="translated">그런 다음 template-1이 template-2보다 더 전문화됩니다. 템플릿 순서를 전환 한 후 위의 조건이 적용되는 경우 템플릿 2보다 템플릿 2가 더 전문화됩니다. 그렇지 않으면 어떤 템플릿도 다른 템플릿보다 더 전문화되지 않습니다. 동점 인 경우, 하나의 기능 템플릿에 후행 매개 변수 팩이 있고 다른 기능 템플릿에 포함되지 않은 경우, 매개 변수가 생략 된 기능은 빈 매개 변수 팩이있는 것보다 더 특수한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d3271caf912e95526fbf0f4e50e8dacc62c22392" translate="yes" xml:space="preserve">
          <source>Then the function behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, if any &lt;code&gt;ios_base::iostate&lt;/code&gt; flags are set, the function sets &lt;code&gt;failbit&lt;/code&gt; and returns. Otherwise, calls &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt;.</source>
          <target state="translated">그런 다음 함수는 &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction으로&lt;/a&gt; 동작합니다 . 센트리 객체를 구성하고 확인한 후 &lt;code&gt;ios_base::iostate&lt;/code&gt; 플래그가 설정되면이 함수는 &lt;code&gt;failbit&lt;/code&gt; 설정 하고 반환합니다. 그렇지 않으면 &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="36f34a067b6d5809ad8db68785a0d829422e3317" translate="yes" xml:space="preserve">
          <source>Then this function in the class &lt;code&gt;Derived&lt;/code&gt; is also</source>
          <target state="translated">그런 다음 &lt;code&gt;Derived&lt;/code&gt; 클래스의이 함수 는</target>
        </trans-unit>
        <trans-unit id="7f48f8e860002b0a6fca10b3b58cdef248ff8167" translate="yes" xml:space="preserve">
          <source>Then, &lt;code&gt;awaiter.await_ready()&lt;/code&gt; is called (this is a short-cut to avoid the cost of suspension if it's known that the result is ready or can be completed synchronously). If its result, contextually-converted to bool is &lt;code&gt;false&lt;/code&gt; then.</source>
          <target state="translated">그런 다음 &lt;code&gt;awaiter.await_ready()&lt;/code&gt; 가 호출됩니다 (결과가 준비되었거나 동 기적으로 완료 될 수 있다고 알려진 경우 정지 비용을 피하기위한 지름길입니다). 결과가 문맥 상으로 bool로 변환되면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8f56bc35fde57e5d45735f7118718bf8634008b7" translate="yes" xml:space="preserve">
          <source>Then, a dot character is appended to the generic-format view of the pathname, if &lt;code&gt;replacement&lt;/code&gt; is not empty or does not begin with a dot character.</source>
          <target state="translated">그런 다음 &lt;code&gt;replacement&lt;/code&gt; 가 비어 있지 않거나 점 문자로 시작하지 않으면 점 문자가 경로 이름의 일반 형식보기에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a8ce560ef479ac7bd437cfaae9fee813911dce4" translate="yes" xml:space="preserve">
          <source>Then, closes the file as if by calling &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;, regardless of whether any of the preceding calls succeeded or failed.</source>
          <target state="translated">그런 다음 앞의 호출 중 어느 것이 성공했는지 실패했는지에 관계없이 &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; 를 호출하여 파일을 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="bb70360ec88c4bb9dac2644a98645695f52f42d5" translate="yes" xml:space="preserve">
          <source>Then, for the expressions &lt;code&gt;p1 == p2&lt;/code&gt;, &lt;code&gt;p1 != p2&lt;/code&gt;, &lt;code&gt;p1 &amp;lt; p2&lt;/code&gt;&lt;code&gt;p1 &amp;lt;= p2&lt;/code&gt;, &lt;code&gt;p1 &amp;gt;= p2&lt;/code&gt;, &lt;code&gt;p1 &amp;gt; p2&lt;/code&gt;, &lt;code&gt;p1 - p2&lt;/code&gt;} either or both objects may be replaced by an</source>
          <target state="translated">그런 다음 표현식 &lt;code&gt;p1 == p2&lt;/code&gt; , &lt;code&gt;p1 != p2&lt;/code&gt; , &lt;code&gt;p1 &amp;lt; p2&lt;/code&gt; &lt;code&gt;p1 &amp;lt;= p2&lt;/code&gt; , &lt;code&gt;p1 &amp;gt;= p2&lt;/code&gt; , &lt;code&gt;p1 &amp;gt; p2&lt;/code&gt; , &lt;code&gt;p1 - p2&lt;/code&gt; } 중 하나 또는 두 객체가 모두</target>
        </trans-unit>
        <trans-unit id="03792c753032d7cb9233d55af244f2b35fa6ba5a" translate="yes" xml:space="preserve">
          <source>Then, if &lt;code&gt;seq.size() &amp;lt; out.width()&lt;/code&gt;, adds &lt;code&gt;out.width()-seq.size()&lt;/code&gt; copies of the fill character &lt;code&gt;out.fill()&lt;/code&gt; either at the end of the sequence (if &lt;code&gt;ios_base::left&lt;/code&gt; is set in &lt;code&gt;out.flags()&lt;/code&gt;) or at the beginning of the sequence (in all other cases).</source>
          <target state="translated">그런 다음 &lt;code&gt;seq.size() &amp;lt; out.width()&lt;/code&gt; 인 경우 시퀀스 끝에서 &lt;code&gt;ios_base::left&lt;/code&gt; 경우 채우기 문자 &lt;code&gt;out.fill()&lt;/code&gt; 의 &lt;code&gt;out.width()-seq.size()&lt;/code&gt; 사본을 추가합니다. 설정된다 &lt;code&gt;out.flags()&lt;/code&gt; ) 또는 다른 모든 경우에서의 시퀀스의 시작 (AT).</target>
        </trans-unit>
        <trans-unit id="9b66cf1ae7e463d5761dc0c8e4b85c87a42f6ae4" translate="yes" xml:space="preserve">
          <source>Then, if the character encoding is fixed-width (&lt;code&gt;codecvt::encoding()&lt;/code&gt; returns some positive number &lt;code&gt;width&lt;/code&gt;, moves the file pointer as if by &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, width*off, whence)&lt;/code&gt;.</source>
          <target state="translated">그런 다음 문자 인코딩이 고정 너비 인 경우 ( &lt;code&gt;codecvt::encoding()&lt;/code&gt; 은 양수 &lt;code&gt;width&lt;/code&gt; 를 반환 하면 &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, width*off, whence)&lt;/code&gt; 의해 파일 포인터를 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="1588837f0abae43644f6a59f2a7e9d05829935b3" translate="yes" xml:space="preserve">
          <source>Then, if the current emit-on-sync policy is &lt;code&gt;true&lt;/code&gt;, makes a call to &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그런 다음 현재 emit-on-sync 정책이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="e328ed3f5e3fe95a687636b98322058fa4cd84c4" translate="yes" xml:space="preserve">
          <source>Then, move-assigns the wrapped &lt;code&gt;std::basic_syncbuf&lt;/code&gt; from the corresponding member of &lt;code&gt;other&lt;/code&gt; (after this move-assignment, &lt;code&gt;other.get_wrapped()&lt;/code&gt; returns a null pointer and destruction of &lt;code&gt;other&lt;/code&gt; produces no output) and &lt;a href=&quot;../basic_ostream/operator=&quot;&gt;move-assigns&lt;/a&gt; the base &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; (this swaps all stream state variables except for &lt;code&gt;rdbuf&lt;/code&gt; between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;).</source>
          <target state="translated">그런 다음 래핑 된 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 를 &lt;code&gt;other&lt;/code&gt; 멤버의 해당 멤버에서 이동 할당하고 &lt;code&gt;other.get_wrapped()&lt;/code&gt; 이 이동 할당 후 other.get_wrapped () 는 널 포인터를 반환하고 &lt;code&gt;other&lt;/code&gt; 소멸 하면 출력이 생성되지 않음) 기본 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../basic_ostream/operator=&quot;&gt; 이동 할당합니다&lt;/a&gt; . basic_ostream ( &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 사이의 &lt;code&gt;rdbuf&lt;/code&gt; 를 제외한 모든 스트림 상태 변수를 바꿉니다 ).</target>
        </trans-unit>
        <trans-unit id="cac51d51872e9519bbc0bc669f0606d196b2f4a3" translate="yes" xml:space="preserve">
          <source>Then, the awaiter object is obtained, as follows:</source>
          <target state="translated">그러면 다음과 같이 awaiter 오브젝트가 확보됩니다.</target>
        </trans-unit>
        <trans-unit id="6b9e0d6ed6f7b1751b629f6e3ddc80ecb32c6693" translate="yes" xml:space="preserve">
          <source>Then, whether &lt;code&gt;to&lt;/code&gt; already existed or was just created, iterates over the files contained in &lt;code&gt;from&lt;/code&gt; as if by &lt;code&gt;for (const &lt;a href=&quot;directory_entry&quot;&gt;std::filesystem::directory_entry&lt;/a&gt;&amp;amp; x : &lt;a href=&quot;directory_iterator&quot;&gt;std::filesystem::directory_iterator&lt;/a&gt;(from))&lt;/code&gt; and for each directory entry, recursively calls &lt;code&gt;copy(x.path(), to/x.path().filename(), options | in-recursive-copy)&lt;/code&gt;, where</source>
          <target state="translated">그런 다음 여부 &lt;code&gt;to&lt;/code&gt; 이미 존재하거나 생성, 파일을 반복은 포함의 &lt;code&gt;from&lt;/code&gt; 와 같은 경우로 &lt;code&gt;for (const &lt;a href=&quot;directory_entry&quot;&gt;std::filesystem::directory_entry&lt;/a&gt;&amp;amp; x : &lt;a href=&quot;directory_iterator&quot;&gt;std::filesystem::directory_iterator&lt;/a&gt;(from))&lt;/code&gt; 및 각 디렉토리 엔트리 , 재귀 적으로 &lt;code&gt;copy(x.path(), to/x.path().filename(), options | in-recursive-copy)&lt;/code&gt; . 여기서</target>
        </trans-unit>
        <trans-unit id="e9125d469bb8f6aff93d3721871c0958a43dafdd" translate="yes" xml:space="preserve">
          <source>Then, x1 and x2 are</source>
          <target state="translated">그러면 x1과 x2는</target>
        </trans-unit>
        <trans-unit id="c5bb0afc7219a935f5a73b87436c78d57282e9f3" translate="yes" xml:space="preserve">
          <source>Then.</source>
          <target state="translated">Then.</target>
        </trans-unit>
        <trans-unit id="dcb618e3bc4e6760e6d24a1d8c4732cdb2523ec0" translate="yes" xml:space="preserve">
          <source>Theoretical maximum allocation size.</source>
          <target state="translated">이론상 최대 할당 크기.</target>
        </trans-unit>
        <trans-unit id="7dcca98b4934dc33e5546547c327611fcc667809" translate="yes" xml:space="preserve">
          <source>There are alternative spellings for several operators and other tokens that use non-ISO646 characters. In all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the &lt;a href=&quot;../preprocessor/replace&quot;&gt;stringification operator&lt;/a&gt; can make the spelling visible). The two-letter alternative tokens are sometimes called &quot;digraphs&quot;</source>
          <target state="translated">비 ISO646 문자를 사용하는 여러 연산자 및 기타 토큰에 대한 대체 철자가 있습니다. 언어와 관련하여 모든 대체 토큰은 철자를 제외하고 기본 토큰과 정확히 동일하게 작동합니다 ( &lt;a href=&quot;../preprocessor/replace&quot;&gt;문자열 연산자&lt;/a&gt; 는 철자를 표시 할 수 있음). 2 글자 대체 토큰은 때때로 &quot;digraphs&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="8e6f3eaebb9a3927bc985adcb62df7d15d191025" translate="yes" xml:space="preserve">
          <source>There are compiler extensions that may be used to generate C++ exceptions automatically whenever a floating-point exception is raised:</source>
          <target state="translated">부동 소수점 예외가 발생할 때마다 C ++ 예외를 자동으로 생성하는 데 사용할 수있는 컴파일러 확장이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f225f0e74f08c0d0f2caf0e296a39e971ff8239" translate="yes" xml:space="preserve">
          <source>There are five available return types:</source>
          <target state="translated">5 가지 반품 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8b561cc0eef33e481077a8d77db9eb795dcf585" translate="yes" xml:space="preserve">
          <source>There are five(until C++17)six(since C++17) kinds of iterators: &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, &lt;a href=&quot;named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, &lt;a href=&quot;named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, and &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;(since C++17).</source>
          <target state="translated">C (C ++ 17부터) C ++ 17까지 6 가지 종류의 반복자가 있습니다 : &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; , &lt;a href=&quot;named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , &lt;a href=&quot;named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; , &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; (C ++ 17 이후).</target>
        </trans-unit>
        <trans-unit id="9778100d7798733f17cf489450cafd2088023fa7" translate="yes" xml:space="preserve">
          <source>There are many different NaN values with different sign bits and payloads, see &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;std::nan&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits/quiet_nan&quot;&gt;std::numeric_limits::quiet_NaN&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">부호 비트와 페이로드가 다른 여러 NaN 값이 있습니다 ( &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;std::nan&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits/quiet_nan&quot;&gt;std::numeric_limits::quiet_NaN&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e03334de5cfa0b9f96707c08d7bef755bc11a3c" translate="yes" xml:space="preserve">
          <source>There are many different NaN values, differentiated by their payloads and their sign bits. The contents of the payload and the sign bit of the NaN generated by the macro &lt;code&gt;NAN&lt;/code&gt; are implementation-defined.</source>
          <target state="translated">페이로드와 부호 비트로 구별되는 다양한 NaN 값이 있습니다. 매크로 &lt;code&gt;NAN&lt;/code&gt; 에 의해 생성 된 페이로드의 내용 및 NaN의 부호 비트 는 구현 정의된다.</target>
        </trans-unit>
        <trans-unit id="a956cc8cb0205c1b4676cee813cb10d9f4679af6" translate="yes" xml:space="preserve">
          <source>There are many types for which equality makes sense, but not less-than ordering: a common example are the complex numbers, or any pair of numbers in general:</source>
          <target state="translated">평등이 의미가 있지만 순서가 아닌 여러 유형이 있습니다. 일반적인 예는 복소수 또는 일반적으로 모든 숫자 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="694fc92221739aa50089385fa6fdb3ce4ff4a1f6" translate="yes" xml:space="preserve">
          <source>There are no &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt; for bit fields: &lt;code&gt;int b : 1 = 0;&lt;/code&gt; and &lt;code&gt;int b : 1 {0}&lt;/code&gt; are ill-formed.</source>
          <target state="translated">비트 필드 에는 &lt;a href=&quot;data_members#Member_initialization&quot;&gt;기본 멤버 이니셜 라이저&lt;/a&gt; 가 없습니다 . &lt;code&gt;int b : 1 = 0;&lt;/code&gt; 및 &lt;code&gt;int b : 1 {0}&lt;/code&gt; 잘못 형성된다.</target>
        </trans-unit>
        <trans-unit id="db2de29aa1d33752b78c0dd7d6ec96850ff5a7be" translate="yes" xml:space="preserve">
          <source>There are no arrays of references or arrays of functions.</source>
          <target state="translated">참조 배열이나 함수 배열이 없습니다.</target>
        </trans-unit>
        <trans-unit id="37439af54c020a64a12e9c758da796ee25c34c35" translate="yes" xml:space="preserve">
          <source>There are no bit field &lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt;: lvalue-to-rvalue conversion always produces an object of the underlying type of the bit field.</source>
          <target state="translated">비트 필드 &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; 는 없습니다 . lvalue-to-rvalue 변환은 항상 비트 필드의 기본 유형의 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f39ab94881006d285c7e811db2e42c17ba7a7d98" translate="yes" xml:space="preserve">
          <source>There are no guarantees as to the quality of the random sequence produced. In the past, some implementations of &lt;code&gt;rand()&lt;/code&gt; have had serious shortcomings in the randomness, distribution and period of the sequence produced (in one well-known example, the low-order bit simply alternated between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; between calls).</source>
          <target state="translated">생성 된 랜덤 시퀀스의 품질에 대한 보장은 없습니다. 과거에는 &lt;code&gt;rand()&lt;/code&gt; 의 일부 구현 에서 생성 된 시퀀스의 무작위성, 분포 및 기간에 심각한 결점이있었습니다 (잘 알려진 한 예에서 하위 비트는 단순히 호출 간에 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;0&lt;/code&gt; 사이에서 번갈아 나타남).</target>
        </trans-unit>
        <trans-unit id="991d3d81eb996d06aa3347bc77bacaef91a6483e" translate="yes" xml:space="preserve">
          <source>There are no negative integer literals. Expressions such as &lt;code&gt;-1&lt;/code&gt; apply the &lt;a href=&quot;operator_arithmetic&quot;&gt;unary minus operator&lt;/a&gt; to the value represented by the literal, which may involve implicit type conversions.</source>
          <target state="translated">음의 정수 리터럴이 없습니다. &lt;code&gt;-1&lt;/code&gt; 과 같은 식은 &lt;a href=&quot;operator_arithmetic&quot;&gt;단항 빼기 연산자&lt;/a&gt; 를 리터럴이 나타내는 값에 적용합니다 . 여기에는 암시 적 형식 변환이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcb7f46103fbd100a4f9cb6ff99abb2c28199213" translate="yes" xml:space="preserve">
          <source>There are no optional references; a program is ill-formed if it instantiates an &lt;code&gt;optional&lt;/code&gt; with a reference type. Alternatively, an &lt;code&gt;optional&lt;/code&gt; of a &lt;code&gt;&lt;a href=&quot;functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; may be used to hold a reference. In addition, a program is ill-formed if it instantiates an &lt;code&gt;optional&lt;/code&gt; with the tag types &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;in_place&quot;&gt;std::in_place_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">선택적 참조는 없습니다. 프로그램이 참조 유형으로 &lt;code&gt;optional&lt;/code&gt; 을 인스턴스화하면 프로그램이 잘못 구성됩니다 . 대안 적으로, 타입 &lt;code&gt;T&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;optional&lt;/code&gt; 은 참조 를 유지하는데 사용될 수있다. 또한 태그 유형 &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;in_place&quot;&gt;std::in_place_t&lt;/a&gt;&lt;/code&gt; 하여 &lt;code&gt;optional&lt;/code&gt; 을 인스턴스화하면 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8419f6809e1cf19b6fb3b6a22f4638d4c5849b20" translate="yes" xml:space="preserve">
          <source>There are no overload for pointers to non-static member, pointers to volatile, or function pointers (other than the ones with signatures accepted by the (10-12) overloads). Attempting to output such objects invokes implicit conversion to &lt;code&gt;bool&lt;/code&gt;, and, for any non-null pointer value, the value &lt;code&gt;1&lt;/code&gt; is printed (unless &lt;code&gt;boolalpha&lt;/code&gt; was set, in which case &lt;code&gt;true&lt;/code&gt; is printed).</source>
          <target state="translated">비 정적 멤버에 대한 포인터, 휘발성에 대한 포인터 또는 함수 포인터 ((10-12) 과부하에 의해 서명이 허용 된 포인터 제외)에는 과부하가 없습니다. 이러한 객체를 출력하려고하면 &lt;code&gt;bool&lt;/code&gt; 로의 암시 적 변환이 호출 되고 널이 아닌 포인터 값의 경우 값 &lt;code&gt;1&lt;/code&gt; 이 인쇄됩니다 ( &lt;code&gt;boolalpha&lt;/code&gt; 가 설정되어 있지 않은 경우 &lt;code&gt;true&lt;/code&gt; 가 인쇄 되지 않은 경우 ).</target>
        </trans-unit>
        <trans-unit id="3e3662fa8ed3550ea700d26fee022c4ac95bb7d6" translate="yes" xml:space="preserve">
          <source>There are no pointers to &lt;a href=&quot;reference&quot;&gt;references&lt;/a&gt; and there are no pointers to &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;. Typically, mentions of &quot;pointers&quot; without elaboration do not include pointers to (non-static) members.</source>
          <target state="translated">&lt;a href=&quot;reference&quot;&gt;참조에&lt;/a&gt; 대한 포인터 가없고 &lt;a href=&quot;bit_field&quot;&gt;비트 필드에&lt;/a&gt; 대한 포인터가 없습니다 . 일반적으로 정교함이없는 &quot;포인터&quot;는 정적이 아닌 멤버에 대한 포인터를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="337c29a8a2b7567bb32c86a4abf4bf2501e7a2ab" translate="yes" xml:space="preserve">
          <source>There are no references to &lt;code&gt;void&lt;/code&gt; and no references to references.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 에 대한 참조가없고 참조에 대한 참조가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1deb84f794c63103b9555294bae8bd9107563871" translate="yes" xml:space="preserve">
          <source>There are no standard complexity guarantees, typical implementations behave similar to &lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;.</source>
          <target state="translated">표준 복잡성 보장은 없으며 일반적인 구현은 &lt;a href=&quot;../../container/vector/insert&quot;&gt;std :: vector :: insert&lt;/a&gt; 와 유사하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="5ef11a32cf3433c799eb8a56e867da73440715a2" translate="yes" xml:space="preserve">
          <source>There are non-member function template equivalents for all member functions of &lt;code&gt;std::atomic&lt;/code&gt;. Those non-member functions may be additionally overloaded for types that are not specializations of &lt;code&gt;std::atomic&lt;/code&gt;, but are able to guarantee atomicity. The only such type in the standard library is &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::atomic&lt;/code&gt; 의 모든 멤버 함수에 해당하는 멤버가 아닌 함수 템플리트가 있습니다. 이러한 비 멤버 함수는 &lt;code&gt;std::atomic&lt;/code&gt; 전문화되지 않지만 원 자성을 보장 할 수있는 유형에 대해 추가로 오버로드 될 수 있습니다 . 표준 라이브러리에서 이러한 유형은 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7e79772c53f1ce2b7a68f39acb9950fc2f71b6e0" translate="yes" xml:space="preserve">
          <source>There are special rules for unqualified name lookup for class members when virtual inheritance is involved (sometimes referred to as the rules of dominance), see &lt;a href=&quot;unqualified_lookup#Member_function_definition&quot;&gt;unqualified_lookup#Member_function_definition&lt;/a&gt;.</source>
          <target state="translated">가상 상속이 관련 될 때 (때로는 지배 규칙이라고도 함) 클래스 멤버의 규정되지 않은 이름 조회에 대한 특수 규칙이 있습니다 ( &lt;a href=&quot;unqualified_lookup#Member_function_definition&quot;&gt;unqualified_lookup # Member_function_definition&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="9a402f4ecfc55e94136a1e80cc1d6a5286b19956" translate="yes" xml:space="preserve">
          <source>There are still a few inaccuracies in this section, refer to individual member function pages for more detail.</source>
          <target state="translated">이 섹션에는 여전히 몇 가지 부정확 한 부분이 있습니다. 자세한 내용은 개별 멤버 기능 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="941295990d20765c0666a8c77b5e2c06086eb3fc" translate="yes" xml:space="preserve">
          <source>There are still a few inaccuracies in this section. Refer to individual member function pages for more detail.</source>
          <target state="translated">이 섹션에는 여전히 몇 가지 부정확 한 부분이 있습니다. 자세한 내용은 개별 멤버 기능 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fbc45885aff604aaea2abb7208dd0c18b8bc3d95" translate="yes" xml:space="preserve">
          <source>There are three conventions of passing an allocator &lt;code&gt;alloc&lt;/code&gt; to a constructor of some type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">할당 자 &lt;code&gt;alloc&lt;/code&gt; 을 &lt;code&gt;T&lt;/code&gt; 타입의 생성자에 전달하는 세 가지 규칙이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb2f200b57b0d8a9c6686c50668bd2b80b8b6b29" translate="yes" xml:space="preserve">
          <source>There are three types of constraints:</source>
          <target state="translated">제약에는 세 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f09bbf4176190877beb129c86ae3e9c8e358d71" translate="yes" xml:space="preserve">
          <source>There are three types of null-terminated strings:</source>
          <target state="translated">null로 끝나는 문자열에는 세 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c2a33396de83eb35e9628e69e71f05f450481e2" translate="yes" xml:space="preserve">
          <source>There are two distinct kinds of enumerations:</source>
          <target state="translated">열거에는 두 가지 종류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f669e5024934effcd4278fb23f0f95ad252bc52" translate="yes" xml:space="preserve">
          <source>There are two exceptions from that:</source>
          <target state="translated">그로부터 두 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="36231641abbbc5cce8b62cf3185cc936bfddd00e" translate="yes" xml:space="preserve">
          <source>There are two kinds of implementations defined by the C++ standard:</source>
          <target state="translated">C ++ 표준에 의해 정의 된 두 가지 종류의 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e504119c92fe73e0c1cae5141f8e4e4cd1909108" translate="yes" xml:space="preserve">
          <source>There are two versions of &lt;code&gt;std::unique_ptr&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; 의 두 가지 버전이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31bf78ac4643c55ed74c0dfba62be6194d38f599" translate="yes" xml:space="preserve">
          <source>There can be more than one definition in a program, as long as each definition appears in a different translation unit, of each of the following: class type, enumeration type, inline function with external linkage inline variable with external linkage(since C++17), class template, non-static function template, static data member of a class template, member function of a class template, partial template specialization, &lt;a href=&quot;constraints&quot;&gt;concept&lt;/a&gt;,(since C++20) as long as all of the following is true:</source>
          <target state="translated">클래스 타입, 열거 타입, 외부 링크가있는 인라인 함수 외부 링크가있는 인라인 변수 (C ++ 이후) 각 정의가 다른 변환 단위에 나타나는 한 프로그램에 하나 이상의 정의가있을 수 있습니다. 17), 클래스 템플릿, 비 정적 함수 템플릿, 클래스 템플릿의 정적 데이터 멤버, 클래스 템플릿의 멤버 함수, 부분 템플릿 전문화, &lt;a href=&quot;constraints&quot;&gt;개념&lt;/a&gt; (C ++ 20부터)</target>
        </trans-unit>
        <trans-unit id="3787f2ae99932166a7dcbb82d18d8948ed35d334" translate="yes" xml:space="preserve">
          <source>There exists an atomic object M,</source>
          <target state="translated">원자 객체 M이 있고</target>
        </trans-unit>
        <trans-unit id="79c74ac70167e62133877fbfab7ff339ffa4b43b" translate="yes" xml:space="preserve">
          <source>There exists an atomic read Y (with any memory order) in thread B</source>
          <target state="translated">스레드 B에 원자 적 읽기 Y (메모리 순서가 있음)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b325c9ba4bba31055eea3a7f3839a38f5af398a" translate="yes" xml:space="preserve">
          <source>There exists an atomic write X (with any memory order) that modifies M in thread A</source>
          <target state="translated">스레드 A에서 M을 수정하는 원자 쓰기 X (메모리 순서가 있음)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5311041dd1561f12757a5b111f905e8cf9ceb71" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple &lt;code&gt;%n&lt;/code&gt; results in the same variable or, as an edge case, printing a string modified by an earlier &lt;code&gt;%n&lt;/code&gt; within the same call.</source>
          <target state="translated">각 변환 지정자의 조치 후에 &lt;a href=&quot;../../language/eval_order&quot;&gt;시퀀스 포인트&lt;/a&gt; 가 있습니다 . 이렇게하면 여러 &lt;code&gt;%n&lt;/code&gt; 결과를 동일한 변수에 저장하거나 가장자리의 경우 같은 호출 내에서 이전 &lt;code&gt;%n&lt;/code&gt; 의해 수정 된 문자열을 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3baee1a6a7acc4dbecfba1cab14149a6beefecea" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple fields in the same &quot;sink&quot; variable.</source>
          <target state="translated">각 변환 지정자의 조치 후에 &lt;a href=&quot;../../language/eval_order&quot;&gt;시퀀스 포인트&lt;/a&gt; 가 있습니다 . 이를 통해 동일한 &quot;싱크&quot;변수에 여러 필드를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab3c5acf0d5e4ba77cc962cd2ce83a7c967eb424" translate="yes" xml:space="preserve">
          <source>There is a non-standard function named &lt;code&gt;gamma&lt;/code&gt; in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;lgamma&lt;/code&gt;, but 4.4BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;tgamma&lt;/code&gt;.</source>
          <target state="translated">다양한 구현에 &lt;code&gt;gamma&lt;/code&gt; 라는 비표준 함수가 있지만 그 정의가 일치하지 않습니다. 예를 들어, glibc 및 4.2BSD 버전의 &lt;code&gt;gamma&lt;/code&gt; &lt;code&gt;lgamma&lt;/code&gt; 를 실행 하지만 4.4BSD 버전의 &lt;code&gt;gamma&lt;/code&gt; &lt;code&gt;tgamma&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="b9f50508274427b995c9b808fe7d2253e68aed64" translate="yes" xml:space="preserve">
          <source>There is a single total order S on all &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operations, including fences, that satisfies the following constraints:</source>
          <target state="translated">펜스를 포함하여 모든 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 작업에는 다음과 같은 제약 조건을 충족 하는 단일 총 차수 S가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4002dc28152d428b1e9f887a2afb18cb864b3ff" translate="yes" xml:space="preserve">
          <source>There is a special case for a zero-length array (&lt;code&gt;N == 0&lt;/code&gt;). In that case, &lt;code&gt;array.begin() == array.end()&lt;/code&gt;, which is some unique value. The effect of calling &lt;code&gt;front()&lt;/code&gt; or &lt;code&gt;back()&lt;/code&gt; on a zero-sized array is undefined.</source>
          <target state="translated">길이가 0 인 배열 ( &lt;code&gt;N == 0&lt;/code&gt; ) 에는 특별한 경우가 있습니다 . 이 경우 &lt;code&gt;array.begin() == array.end()&lt;/code&gt; 는 고유 한 값입니다. 크기가 0 인 배열에서 &lt;code&gt;front()&lt;/code&gt; 또는 &lt;code&gt;back()&lt;/code&gt; 을 호출하는 효과 는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c58212f0810e755496085c2333304612a8c9ba1" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from lvalues and rvalues of array type to rvalues of pointer type: it constructs a pointer to the first element of an array. This conversion is used whenever arrays appear in context where arrays are not expected, but pointers are:</source>
          <target state="translated">가 &lt;a href=&quot;implicit_cast&quot;&gt;암시 적 변환&lt;/a&gt; lvalues 포인터 유형의 우변에 어레이 형의 우변에서 : 그것은 어레이의 첫 번째 요소에 대한 포인터를 생성한다. 이 변환은 배열이 예상되지 않는 상황에서 배열이 나타날 때마다 사용되지만 포인터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="adb96efa8dd15697ca7b238b3ac30f5bc2029721" translate="yes" xml:space="preserve">
          <source>There is no &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt; from pointer type because it is impossible to distinguish a pointer obtained from array and non-array forms of &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">더 없습니다 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;클래스 템플릿 인수 공제&lt;/a&gt; 가의 배열 및 배열이 아닌 형태에서 얻은 포인터를 구별하는 것은 불가능하기 때문에 포인터 타입에서 &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b717a5566f4d275ca27affef23f0b5a37db23c45" translate="yes" xml:space="preserve">
          <source>There is no alternative spelling (such as &lt;code&gt;eq&lt;/code&gt;) for the equality operator &lt;code&gt;==&lt;/code&gt; because the character &lt;code&gt;=&lt;/code&gt; was present in all supported charsets.</source>
          <target state="translated">문자 &lt;code&gt;=&lt;/code&gt; 가 지원되는 모든 문자 세트에 있기 때문에 등호 연산자 &lt;code&gt;==&lt;/code&gt; 에 대한 대체 철자 (예 : &lt;code&gt;eq&lt;/code&gt; ) 는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6359bb2da55b35e94c9ad0b9d3423bdf850ab557" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the same &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; instance will be referred to by all evaluations of the typeid expression on the same type, although &lt;code&gt;&lt;a href=&quot;../types/type_info/hash_code&quot;&gt;std::type_info::hash_code&lt;/a&gt;&lt;/code&gt; of those type_info objects would be identical, as would be their &lt;code&gt;&lt;a href=&quot;../types/type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동일한 &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 인스턴스가 동일한 유형에 대한 typeid 표현식의 모든 평가에 의해 참조 될 것이라는 보장은 없지만 , 해당 type_info 오브젝트의 &lt;code&gt;&lt;a href=&quot;../types/type_info/hash_code&quot;&gt;std::type_info::hash_code&lt;/a&gt;&lt;/code&gt; 는 std 와 동일하지만 동일합니다 &lt;code&gt;&lt;a href=&quot;../types/type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46c70b420b1fd4cd4eb814c6e21ea48fec268ba0" translate="yes" xml:space="preserve">
          <source>There is no move constructor: moving from an object derived from &lt;code&gt;shared_from_this&lt;/code&gt; does not transfer its shared identity.</source>
          <target state="translated">이동 생성자가 없습니다. &lt;code&gt;shared_from_this&lt;/code&gt; 에서 파생 된 객체에서 이동하면 공유 ID가 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c081f6007cfe842825dd149d42264efa0313278f" translate="yes" xml:space="preserve">
          <source>There is no non-member function equivalent of this static member constant because non-member functions take pointers to atomic types, and therefore aren't as useful in &lt;a href=&quot;../../language/constant_expression&quot;&gt;constant expressions&lt;/a&gt;.</source>
          <target state="translated">멤버가 아닌 함수는 원자 유형에 대한 포인터를 사용하므로 &lt;a href=&quot;../../language/constant_expression&quot;&gt;상수 표현식&lt;/a&gt; 에는 유용하지 않기 때문에이 정적 멤버 상수에 해당하는 멤버가 아닌 함수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b70d83494235e850b17f2e48a3299bb098ff2e94" translate="yes" xml:space="preserve">
          <source>There is no portable way to define primary sort key in terms of &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; since the conversion from the collation key returned by &lt;code&gt;std::collate::transform()&lt;/code&gt; to the primary equivalence key is locale-specific, and if the user replaces the &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet, that conversion is no longer known to the standard library's &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt;. Standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; return an empty string unless the &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet of the currently-imbued locale was not replaced by the user, and still matches the system-supplied &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet), in which case &lt;code&gt;&lt;a href=&quot;../../locale/collate_byname&quot;&gt;std::collate_byname&lt;/a&gt;&amp;lt;charT&amp;gt;::transform(first, last)&lt;/code&gt; is executed and the sort key it produces is converted to the expected primary sort key using a locale-specific conversion.</source>
          <target state="translated">&lt;code&gt;std::collate::transform()&lt;/code&gt; 에 의해 리턴 된 데이터 정렬 키 에서 기본 동등성 키로의 변환 이 로케일마다 다르며 사용자가 대체하는 경우 &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; 관점에서 기본 정렬 키를 정의하는 이식 가능한 방법이 없습니다. &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; 면이, 그 변환은 더 이상 표준 라이브러리의 알려진되지 않은 &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; 의 표준 라이브러리 특수화는 현재 임베드 된 로케일 의 &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; 패싯이 사용자로 대체되지 않고 여전히 시스템 제공 &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; 패싯 과 일치 하지 않는 한 빈 문자열을 리턴합니다 .이 경우 &lt;code&gt;&lt;a href=&quot;../../locale/collate_byname&quot;&gt;std::collate_byname&lt;/a&gt;&amp;lt;charT&amp;gt;::transform(first, last)&lt;/code&gt; &amp;lt;charT&amp;gt; :: transform (처음, 마지막) 로케일 별 변환을 사용하여 생성 된 정렬 키가 예상 된 기본 정렬 키로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3f7acf604b21fa7efd6ebb9fae0bd32cd0e76516" translate="yes" xml:space="preserve">
          <source>There is no separate tag for &lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator에&lt;/a&gt; 대한 별도의 태그가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="cb42e4a03c1413932f97ef53ea3df59cf6f0618f" translate="yes" xml:space="preserve">
          <source>There is no specialization for C strings. &lt;code&gt;std::hash&amp;lt;const char*&amp;gt;&lt;/code&gt; produces a hash of the value of the pointer (the memory address), it does not examine the contents of any character array.</source>
          <target state="translated">C 문자열에 대한 전문화는 없습니다. &lt;code&gt;std::hash&amp;lt;const char*&amp;gt;&lt;/code&gt; 는 포인터 값 (메모리 주소)의 해시를 생성하며 문자 배열의 내용을 검사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="932b5b0c5bba8ae4965a8c49c5fcc30eedb86b32" translate="yes" xml:space="preserve">
          <source>There is no standard-compliant way for the user to construct a &lt;code&gt;future_error&lt;/code&gt; prior to C++17. C++11 and C++14 depict an exposition-only public constructor taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;, and some implementations provide such a constructor.</source>
          <target state="translated">C ++ 17 이전 에는 사용자가 &lt;code&gt;future_error&lt;/code&gt; 를 구성 할 수있는 표준 호환 방법이 없습니다 . C ++ 11 및 C ++ 14는 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 사용하는 박람회 전용 공용 생성자를 나타내고 일부 구현에서는 이러한 생성자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1a76b382fdb365f1f430efc3fd3ffef21f74d56b" translate="yes" xml:space="preserve">
          <source>There is no way to explicitly specify template arguments to &lt;a href=&quot;operators&quot;&gt;overloaded operators&lt;/a&gt;, &lt;a href=&quot;cast_operator&quot;&gt;conversion functions&lt;/a&gt;, and constructors, because they are called without the use of the function name.</source>
          <target state="translated">&lt;a href=&quot;operators&quot;&gt;오버로드 된 연산자&lt;/a&gt; , &lt;a href=&quot;cast_operator&quot;&gt;변환 함수&lt;/a&gt; 및 생성자에 템플릿 인수를 명시 적으로 지정할 수있는 방법은 없습니다 . 함수 이름을 사용하지 않고 호출되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="cfe1eeb34c7bedb3e0ea6d678c0bd6012a61623b" translate="yes" xml:space="preserve">
          <source>There is one exception: an erasure which deletes the last element of a &lt;code&gt;&lt;a href=&quot;container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">한가지 예외가있다 : &lt;code&gt;&lt;a href=&quot;container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 의 마지막 요소를 삭제하는 삭제</target>
        </trans-unit>
        <trans-unit id="341db5eb1053e74392cf71602cdbdbaadad998bb" translate="yes" xml:space="preserve">
          <source>There is partial ordering of cv-qualifiers by the order of increasing restrictions. The type can be said</source>
          <target state="translated">제한이 커지는 순서에 따라 cv-qualifier의 부분 순서가 있습니다. 유형은 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="89bd5d5858a6e7136749a6ba025c5ec9f6ed276d" translate="yes" xml:space="preserve">
          <source>There's no way to access the time zone pointer when &lt;code&gt;TimeZonePtr&lt;/code&gt; is a move-only type.</source>
          <target state="translated">&lt;code&gt;TimeZonePtr&lt;/code&gt; 이 이동 전용 유형 인 경우 시간대 포인터에 액세스 할 수있는 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e85687808f760523e3241d93ae510041ac781f16" translate="yes" xml:space="preserve">
          <source>Therefore, private members can be transferred to implementation as-is, and push_back can forward to an implementation that does not use T in the interface either:</source>
          <target state="translated">따라서 개인 멤버는있는 그대로 구현으로 전달할 수 있으며 push_back은 인터페이스에서 T를 사용하지 않는 구현으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d6d9ce6d1c6685dc210a906c540e2a567fe084" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; are provided for unordered_map to allow deduction from an iterator range (overloads (1,3-5)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,6-8)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 안내서&lt;/a&gt; 는 반복자 범위 (과부하 (1,3-5)) 및 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (과부하 ( 2,6-8))에서 추론 할 수 있도록 unorder_map에 제공 됩니다. 경우 이러한 과부하는 오버로드 확인에 참여 &lt;code&gt;InputIt&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; , 어느 &lt;code&gt;Hash&lt;/code&gt; 도 &lt;code&gt;Pred&lt;/code&gt; 를 가산 충족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; , 및 &lt;code&gt;Hash&lt;/code&gt; 중요한 형식이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d838aa17089c69886e8a6da521887bdae3d66e6e" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; are provided for unordered_multimap to allow deduction from an iterator range (overloads (1,3-5)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,6-8)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 안내서&lt;/a&gt; 는 반복자 범위 (과부하 (1,3-5)) 및 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (과부하 ( 2,6-8))에서 추론 할 수 있도록 unorder_multimap에 제공 됩니다. 경우 이러한 과부하는 오버로드 확인에 참여 &lt;code&gt;InputIt&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; , 어느 &lt;code&gt;Hash&lt;/code&gt; 도 &lt;code&gt;Pred&lt;/code&gt; 를 가산 충족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; , 및 &lt;code&gt;Hash&lt;/code&gt; 중요한 형식이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="71a2bff7b98f49c9c4e24066b486d0981c520060" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../priority_queue&quot;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt; to allow deduction from underlying container type (overloads (1,3)) and from an iterator range (overload (2)) This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;code&gt;Allocator&lt;/code&gt;, &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (3), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Alloc&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이러한 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드가&lt;/a&gt; 제공되는 &lt;code&gt;&lt;a href=&quot;../priority_queue&quot;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt; (과부하 (1,3)) 및 반복자 범위에서 컨테이너 타입을 기초로 추론 할 수 있도록 (과부하 (2))이 과부하은 과부하 해상도에 참여하는 경우 &lt;code&gt;InputIt&lt;/code&gt; 을 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Alloc&amp;gt;&lt;/code&gt; &amp;lt;Container, Alloc&amp;gt; 가 &lt;code&gt;true&lt;/code&gt; 이면&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , &lt;code&gt;Comp&lt;/code&gt; 는 &lt;code&gt;Allocator&lt;/code&gt; 를 만족시키지 못하고 , &lt;code&gt;Container&lt;/code&gt; 는 &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator를&lt;/a&gt; 만족시키지 않으며 , 과부하 (3)에 대해 입니다 .</target>
        </trans-unit>
        <trans-unit id="8e10d57340ef11936ebd04620951a44a41b981f3" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; to account for the edge cases missed by the implicit deduction guides.</source>
          <target state="translated">이러한 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 에 제공 되어 암시 적 추론 가이드에서 놓친 가장 중요한 사례를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="12b353145b514386eb3d03070811d07e0bad084c" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; to account for the edge cases missed by the implicit deduction guides, in particular, non-copyable arguments and array to pointer conversion.</source>
          <target state="translated">이러한 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 암시 적 추론 가이드에서 누락 된 에지 사례, 특히 복사 할 수없는 인수 및 배열에서 포인터로의 변환을 설명하기 위해 &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="0d7729eb7a1438721d7721c8ec45ca17c31eb830" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for multiset to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 반복자 범위 (과부하 (1,3)) 및 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (과부하 (2,4)) 에서 추론 할 수 있도록 멀티 세트에 제공됩니다 . 경우 이러한 과부하는 오버로드 확인에 참여 &lt;code&gt;InputIt&lt;/code&gt; 의 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; , 및 &lt;code&gt;Comp&lt;/code&gt; 없습니다 충족하지 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70a6bdbef179c3a4732cac088b62e8b6f4ff8948" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for queue to allow deduction from underlying container type. This overload only participates in overload resolution if &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (2), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 기본 컨테이너 유형에서 추론 할 수 있도록 대기열에 제공됩니다. 이 과부하는 &lt;code&gt;Alloc&lt;/code&gt; 이&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator를&lt;/a&gt; 만족 하고 &lt;code&gt;Container&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator를&lt;/a&gt; 만족하지 않고 과부하 (2)에 대해 &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="5d564ca21e1c30be4928dd9500b875ed1d963057" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for set to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 반복자 범위 (과부하 (1,3))와 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (과부하 (2,4)) 에서 추론 할 수 있도록 설정되었습니다 . 경우 이러한 과부하는 오버로드 확인에 참여 &lt;code&gt;InputIt&lt;/code&gt; 의 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; , 및 &lt;code&gt;Comp&lt;/code&gt; 없습니다 충족하지 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13ef785aba459afe56d345cd56062fe469f5d0da" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for stack to allow deduction from underlying container type. This overload only participates in overload resolution if &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (2), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 기본 컨테이너 유형에서 추론 할 수 있도록 스택 용으로 제공됩니다. 이 과부하는 &lt;code&gt;Alloc&lt;/code&gt; 이&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator를&lt;/a&gt; 만족 하고 &lt;code&gt;Container&lt;/code&gt; 가 &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator를&lt;/a&gt; 만족하지 않고 과부하 (2)에 대해 &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="4dafdd32c659086dffb3edda268826ae9c158e33" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for unordered_multiset to allow deduction from an iterator range (overloads (1,3,4)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,5.6)). This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 반복자 범위 (과부하 (1,3,4)) 및 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (과부하 (2,5.6)) 에서 추론 할 수 있도록 unorder_multiset에 제공됩니다. 경우에 과부하는 오버로드 확인에 참여 &lt;code&gt;InputIt&lt;/code&gt; 의 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator는&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자가&lt;/a&gt; , 어느 &lt;code&gt;Hash&lt;/code&gt; 도 &lt;code&gt;Pred&lt;/code&gt; 를 가산 충족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자는&lt;/a&gt; , &lt;code&gt;Hash&lt;/code&gt; 중요한 형식이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9bb6043ae0763bf108698a03aeb652cc5820df07" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for unordered_set to allow deduction from an iterator range (overloads (1,3,4)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,5.6)). This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 반복자 범위 (과부하 (1,3,4)) 및 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (과부하 (2,5.6)) 에서 추론 할 수 있도록 unorder_set에 제공됩니다. 경우에 과부하는 오버로드 확인에 참여 &lt;code&gt;InputIt&lt;/code&gt; 의 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator는&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자가&lt;/a&gt; , 어느 &lt;code&gt;Hash&lt;/code&gt; 도 &lt;code&gt;Pred&lt;/code&gt; 를 가산 충족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자는&lt;/a&gt; , &lt;code&gt;Hash&lt;/code&gt; 중요한 형식이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="998a40ef4627e5e01e4248114651ccad38e51377" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;operator/&lt;/code&gt; overloads provide a conventional syntax for the creation of Gregorian calendar dates.</source>
          <target state="translated">이 &lt;code&gt;operator/&lt;/code&gt; 오버로드는 Gregorian 달력 날짜 작성을위한 일반적인 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="74e2c10444921183c350121d5ff7c2b2d260e16b" translate="yes" xml:space="preserve">
          <source>These algorithms cannot be used with associative containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; because ForwardIt does not dereference to a MoveAssignable type (the keys in these containers are not modifiable).</source>
          <target state="translated">이 알고리즘은 &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; 과 같은 연관 컨테이너와 함께 사용할 수 없습니다. ForwardItign이 MoveAssignable 유형을 참조하지 않기 때문입니다 (이 컨테이너의 키는 수정할 수 없음).</target>
        </trans-unit>
        <trans-unit id="dc6f538fd8e7e831a029d42e6c3295c5ce6547d3" translate="yes" xml:space="preserve">
          <source>These are the directives defined by the standard. The standard does not define behavior for other directives: they might be ignored, have some useful meaning, or cause a compile-time error. Even if otherwise ignored, they are removed from the source code when the preprocessor is done. A common non-standard extension is the directive &lt;code&gt;#warning&lt;/code&gt; which emits a user-defined message during compilation.</source>
          <target state="translated">이것들은 표준에 의해 정의 된 지시어입니다. 이 표준은 다른 지시문에 대한 동작을 정의하지 않습니다.이 지시문은 무시되거나 유용한 의미가 있거나 컴파일 타임 오류가 발생할 수 있습니다. 달리 무시하더라도, 전처리 기가 완료되면 소스 코드에서 제거됩니다. 일반적인 비표준 확장은 컴파일 중 사용자 정의 메시지를 생성하는 지시문 &lt;code&gt;#warning&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ec4ebc2b939ff4d66f10267f6f032b0dd31634b9" translate="yes" xml:space="preserve">
          <source>These are type categories defined by the core language. They are included here as named requirements only for consistency.</source>
          <target state="translated">핵심 언어로 정의 된 유형 범주입니다. 일관성을 위해서만 명명 된 요구 사항으로 여기에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="41f69a0ad4c5384189f3c5f07ef1de6088dafb43" translate="yes" xml:space="preserve">
          <source>These attributes may be applied to labels and statements (other than declaration-statements). They may not be simultaneously applied to the same label or statement.</source>
          <target state="translated">이러한 속성은 선언문 이외의 레이블 및 명령문에 적용될 수 있습니다. 동일한 라벨이나 명세서에 동시에 적용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1b3468a96579cdd8f43ddee81097dc1e729403b" translate="yes" xml:space="preserve">
          <source>These bullets describe situations that cannot arise in C++ and therefore are omitted from the discussion above. In C, aggregate copy and assignment access the aggregate object as a whole. But in C++ such actions are always performed through a member function call, which accesses the individual subobjects rather than the entire object (or, in the case of unions, copies the object representation, i.e., via &lt;code&gt;unsigned char&lt;/code&gt;). See &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2051&quot;&gt;core issue 2051&lt;/a&gt;.</source>
          <target state="translated">이 글 머리 기호는 C ++에서 발생할 수없는 상황을 설명하므로 위의 설명에서 생략합니다. C에서 집계 복사 및 할당은 집계 개체 전체에 액세스합니다. 그러나 C ++에서 이러한 작업은 항상 전체 객체가 아닌 개별 하위 객체에 액세스하는 멤버 함수 호출을 통해 수행됩니다 (또는 통합의 경우 객체 표현을 복사합니다 (즉, &lt;code&gt;unsigned char&lt;/code&gt; )). &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2051&quot;&gt;핵심 문제 2051을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e2e85ea89bf8851056faa66c86c8a89f763163c" translate="yes" xml:space="preserve">
          <source>These classes encapsulate a regular expression and the results of matching a regular expression within a target sequence of characters.</source>
          <target state="translated">이 클래스는 정규식과 대상 시퀀스의 문자 내에서 정규식과 일치하는 결과를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="5187a740adf841afb17f5f37d5efc0eafaa7fbe7" translate="yes" xml:space="preserve">
          <source>These constants are duplicated from &lt;code&gt;std::regex_constants&lt;/code&gt;:</source>
          <target state="translated">이 상수는 &lt;code&gt;std::regex_constants&lt;/code&gt; 중복됩니다 .</target>
        </trans-unit>
        <trans-unit id="19ba3734849d9efa52a071b6c74031883732795a" translate="yes" xml:space="preserve">
          <source>These constants provide a portable way to access the L1 data cache line size.</source>
          <target state="translated">이 상수는 L1 데이터 캐시 라인 크기에 액세스 할 수있는 이식 가능한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5aeef84fd68b04dfd62540295b4e58ffbc1ad7c5" translate="yes" xml:space="preserve">
          <source>These constructors additionally do not participate in overload resolution if the expression &lt;code&gt;d(ptr)&lt;/code&gt; is not well-formed, or if &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이러한 생성자는 &lt;code&gt;d(ptr)&lt;/code&gt; 표현식의 형식 이 올바르지 않거나 &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 추가로 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2cd12e66c1b571e2605eacf313edfc5ca3855042" translate="yes" xml:space="preserve">
          <source>These constructors are typically called by the constructors of &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 생성자는 일반적으로 &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; 의 생성자가 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7ee89583b6197fe5f3d8e0eab3b74e26c4d4069c" translate="yes" xml:space="preserve">
          <source>These conversions are purely lexical. They do not check that the paths exist, do not follow symlinks, and do not access the filesystem at all. For symlink-following counterparts of &lt;code&gt;lexically_relative&lt;/code&gt; and &lt;code&gt;lexically_proximate&lt;/code&gt;, see &lt;a href=&quot;../relative&quot;&gt;&lt;code&gt;relative&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../relative&quot;&gt;&lt;code&gt;proximate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 변환은 순전히 어휘입니다. 경로가 존재하는지 확인하지 않고 심볼릭 링크를 따르지 않으며 파일 시스템에 전혀 액세스하지 않습니다. &lt;code&gt;lexically_relative&lt;/code&gt; 및 &lt;code&gt;lexically_proximate&lt;/code&gt; 의 symlink-following 대응 부분 은 &lt;a href=&quot;../relative&quot;&gt; &lt;code&gt;relative&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../relative&quot;&gt; &lt;code&gt;proximate&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b066eecc1428c4afc05b8473b0ce8b6682781dc" translate="yes" xml:space="preserve">
          <source>These conversions model the type conversion applied to all function arguments when passed by value.</source>
          <target state="translated">이러한 변환은 값으로 전달 될 때 모든 함수 인수에 적용되는 유형 변환을 모델링합니다.</target>
        </trans-unit>
        <trans-unit id="1f828b6e7c5612d3683245cf9a5d3fa76a3dbee3" translate="yes" xml:space="preserve">
          <source>These fictional constructors are public members of the hypothetical class type. They are explicit if the guide was formed from an explicit constructor. If overload resolution fails, the program is ill-formed. Otherwise, the return type of the selected &lt;code&gt;F&lt;/code&gt; template specialization becomes the deduced class template specialization.</source>
          <target state="translated">이 가상의 생성자는 가상 클래스 유형의 공용 멤버입니다. 가이드가 명시 적 생성자에서 작성된 경우 명시 적입니다. 과부하 해결에 실패하면 프로그램이 잘못 구성됩니다. 그렇지 않으면 선택한 &lt;code&gt;F&lt;/code&gt; 템플릿 전문화 의 반환 유형 이 추론 된 클래스 템플릿 전문화가됩니다.</target>
        </trans-unit>
        <trans-unit id="9e1185e2ec5ad6dc826827fc0bc8b26aeb766d26" translate="yes" xml:space="preserve">
          <source>These function templates are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt; , and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">이 기능 템플릿은 일반에게 표시되지 않습니다 &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;비정규&lt;/a&gt; 또는 &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;자격 조회&lt;/a&gt; , 만 찾을 수 있습니다 &lt;a href=&quot;../../language/adl&quot;&gt;인수 종속적 조회&lt;/a&gt; 할 때 &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; 인수 연관된 클래스입니다. 이렇게하면 &lt;code&gt;using namespace std::filesystem;&lt;/code&gt; 이있는 경우 바람직하지 않은 변환이 방지됩니다 .</target>
        </trans-unit>
        <trans-unit id="043baecb502250e4140c666b26e06dd43b796356" translate="yes" xml:space="preserve">
          <source>These function templates are optional: an implementation may choose to instead provide &lt;code&gt;to_sys&lt;/code&gt; and &lt;code&gt;from_sys&lt;/code&gt;.</source>
          <target state="translated">이 함수 템플릿은 선택 사항입니다. 구현에서 대신 &lt;code&gt;to_sys&lt;/code&gt; 및 &lt;code&gt;from_sys&lt;/code&gt; 를 제공하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7805c9adadba15da9ce1789282d1fdeae7db0ab" translate="yes" xml:space="preserve">
          <source>These function templates are optional: an implementation may choose to instead provide &lt;code&gt;to_utc&lt;/code&gt; and &lt;code&gt;from_utc&lt;/code&gt;.</source>
          <target state="translated">이 함수 템플릿은 선택 사항입니다. 구현에서 대신 &lt;code&gt;to_utc&lt;/code&gt; 및 &lt;code&gt;from_utc&lt;/code&gt; 를 제공하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7487a9c951b04abd0ea64aae0657bd6c80e75211" translate="yes" xml:space="preserve">
          <source>These function templates behave as if they.</source>
          <target state="translated">이 함수 템플릿은 마치 마치 동작합니다.</target>
        </trans-unit>
        <trans-unit id="419d5c3b82807fda6edd67b01bc6da49f1a27023" translate="yes" xml:space="preserve">
          <source>These functions are defined in terms of member functions of &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 의 멤버 함수로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="706bfb2aebd27a90d3a3878dfe394992ff31ffb1" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt; , and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">이러한 기능은 보통 볼 수없는 &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;비정규&lt;/a&gt; 또는 &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;자격 조회&lt;/a&gt; , 만 찾을 수 있습니다 &lt;a href=&quot;../../language/adl&quot;&gt;인수 종속적 조회&lt;/a&gt; 할 때 &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; 인수 연관된 클래스입니다. 이렇게하면 &lt;code&gt;using namespace std::filesystem;&lt;/code&gt; 이있는 경우 바람직하지 않은 변환이 방지됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f3e6ab375e463f1612d61a87d214ea836c037d5" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::basic_string_view&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">이러한 기능은 보통 볼 수없는 &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;비정규&lt;/a&gt; 또는 &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;자격 조회&lt;/a&gt; , 만 찾을 수 있습니다 &lt;a href=&quot;../../language/adl&quot;&gt;인수 종속적 조회&lt;/a&gt; 할 때 &lt;code&gt;std::basic_string_view&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; 인수 연관된 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="71d3bc1bc9cc67bb93448628acb0478629973b75" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::span&amp;lt;T, Extent&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">이러한 기능은 통상적으로 표시되지 &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;비정규&lt;/a&gt; 이나 &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;정규화 조회&lt;/a&gt; 하고 만 발견 될 수 &lt;a href=&quot;../../language/adl&quot;&gt;인자 의존적 조회&lt;/a&gt; 할 때 &lt;code&gt;std::span&amp;lt;T, Extent&amp;gt;&lt;/code&gt; 인수 연관된 클래스이다.</target>
        </trans-unit>
        <trans-unit id="9cafa0c4c816e506567effd571a10a76ae52acd3" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::ranges::empty_view&amp;lt;T&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">이러한 기능은 보통 볼 수없는 &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;비정규&lt;/a&gt; 또는 &lt;a href=&quot;../language/qualified_lookup&quot;&gt;자격 조회&lt;/a&gt; , 만 찾을 수 있습니다 &lt;a href=&quot;../language/adl&quot;&gt;인수 종속적 조회&lt;/a&gt; 할 때 &lt;code&gt;std::ranges::empty_view&amp;lt;T&amp;gt;&lt;/code&gt; 인수 된 관련 클래스를.</target>
        </trans-unit>
        <trans-unit id="13ae74af435260e5a8fc58a9b3b8f8b649c48761" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::ranges::ref_view&amp;lt;R&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">이러한 기능은 통상적으로 표시되지 &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;규정되지 않은&lt;/a&gt; 또는 &lt;a href=&quot;../language/qualified_lookup&quot;&gt;정규화 조회&lt;/a&gt; 하고 만 발견 될 수 &lt;a href=&quot;../language/adl&quot;&gt;인자 의존적 조회&lt;/a&gt; 할 때 &lt;code&gt;std::ranges::ref_view&amp;lt;R&amp;gt;&lt;/code&gt; 인수 연관된 클래스이다.</target>
        </trans-unit>
        <trans-unit id="96489aaabbabce3adba15d3840295fb8191f8911" translate="yes" xml:space="preserve">
          <source>These functions are provided to make &lt;code&gt;span&lt;/code&gt; rvalues work with &lt;code&gt;std::ranges::begin&lt;/code&gt; and &lt;code&gt;std::ranges::end&lt;/code&gt;, which reject rvalue arguments by default in order to prevent dangling iterator.</source>
          <target state="translated">이러한 기능은 수 있도록 제공되는 &lt;code&gt;span&lt;/code&gt; 우변이 작업 &lt;code&gt;std::ranges::begin&lt;/code&gt; 및 &lt;code&gt;std::ranges::end&lt;/code&gt; , 위해 기본적를 rvalue 인수를 거부 반복자를 매달려 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f45f69461ef9381b69148d33ccefcd3eafb9116" translate="yes" xml:space="preserve">
          <source>These functions are provided to make &lt;code&gt;string_view&lt;/code&gt; rvalues work with &lt;code&gt;std::ranges::begin&lt;/code&gt; and &lt;code&gt;std::ranges::end&lt;/code&gt;, which reject rvalue arguments by default in order to prevent dangling iterator.</source>
          <target state="translated">이러한 함수는 &lt;code&gt;string_view&lt;/code&gt; rvalue 가 &lt;code&gt;std::ranges::begin&lt;/code&gt; 및 &lt;code&gt;std::ranges::end&lt;/code&gt; 와 함께 작동 하도록 제공되어 댕글 링 반복자를 방지하기 위해 기본적으로 rvalue 인수를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="be2ae68f22369098426dd815dea838deb2f9b140" translate="yes" xml:space="preserve">
          <source>These functions are typically implemented using mutexes, stored in a global hash table where the pointer value is used as the key.</source>
          <target state="translated">이러한 함수는 일반적으로 포인터 값이 키로 사용되는 전역 해시 테이블에 저장된 뮤텍스를 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="326f105b45787866cfe222f982d0d9e27243f9ff" translate="yes" xml:space="preserve">
          <source>These functions are used to apply the regular expression encapsulated in a regex to a target sequence of characters.</source>
          <target state="translated">이 함수는 정규식으로 캡슐화 된 정규식을 대상 문자 시퀀스에 적용하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7585335f42669921d2b1bf3e543316f127948a1e" translate="yes" xml:space="preserve">
          <source>These functions do not participate in overload resolution (or, for the copy assignment operator, is defined as deleted) if any required assignment operation is invalid or if there is a size mismatch. Specifically:</source>
          <target state="translated">필요한 할당 작업이 유효하지 않거나 크기가 일치하지 않으면 이러한 기능은 과부하 해결에 참여하지 않습니다 (또는 복사 할당 연산자의 경우 삭제 된 것으로 정의 됨). 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="d30d68da83412d7ae98ce606334319e3d70b73d8" translate="yes" xml:space="preserve">
          <source>These functions do not participate in overload resolution (or, for the copy assignment operator, is defined as deleted) if any required assignment operation is invalid. Specifically:</source>
          <target state="translated">필요한 할당 작업이 유효하지 않은 경우 이러한 기능은 과부하 해결에 참여하지 않습니다 (또는 복사 할당 연산자의 경우 삭제 된 것으로 정의 됨). 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="cafe750e84a77bd66ed9b0e48c90443f0b94fd28" translate="yes" xml:space="preserve">
          <source>These functions do not throw exceptions.</source>
          <target state="translated">이 함수는 예외를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ee20f7717337989ef84b3eb0d3af4c0f3efbcb1" translate="yes" xml:space="preserve">
          <source>These functions effectively yield an approximation of the meaning of the argument path &lt;code&gt;p&lt;/code&gt; in an environment where &lt;code&gt;*this&lt;/code&gt; is the starting directory.</source>
          <target state="translated">이 함수 는 &lt;code&gt;*this&lt;/code&gt; 시작 디렉토리 인 환경에서 인수 경로 &lt;code&gt;p&lt;/code&gt; 의 의미를 대략적으로 산출합니다 .</target>
        </trans-unit>
        <trans-unit id="b7da2559e16d851f64895f9b8ce4e64008d143d3" translate="yes" xml:space="preserve">
          <source>These functions provide access to the program-wide time zone database.</source>
          <target state="translated">이러한 기능은 프로그램 전체 시간대 데이터베이스에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e5ab52d07da85043f4b5804364445cb1d17fd3ed" translate="yes" xml:space="preserve">
          <source>These functions take a result of 3-way comparison and convert it to the result of one of the six relational operators.</source>
          <target state="translated">이 함수는 3 방향 비교 결과를 가져 와서 6 개의 관계 연산자 중 하나의 결과로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="09dc533f744ccd968da17e107b1a623a70147eb2" translate="yes" xml:space="preserve">
          <source>These functions were deprecated in favor of the specializations of the &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; template: &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 템플리트 의 전문화를 위해 사용되지 않습니다 : &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8ebef2701474b9ea6a2624b079221ae9fed097b" translate="yes" xml:space="preserve">
          <source>These hashes equal the hashes of corresponding &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; classes: If S is one of the standard basic_string types, SV is the corresponding string view type, and s is an object of type S, then &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt;.</source>
          <target state="translated">이 해시는 해당 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 클래스 의 해시와 같습니다. S가 표준 basic_string 유형 중 하나 인 경우 SV는 해당 문자열보기 유형이고 s는 S 유형의 오브젝트이고 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04c0518ba136c51c78f2d27b7888f66813a53b9f" translate="yes" xml:space="preserve">
          <source>These hashes equal the hashes of corresponding &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; classes: If S is one of these string types, SV is the corresponding string view type, and s is an object of type S, then &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt;.</source>
          <target state="translated">이 해시는 해당 &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; 클래스 의 해시와 같습니다. S가이 문자열 유형 중 하나 인 경우 SV는 해당 문자열보기 유형이고 s는 S 유형의 오브젝트이고 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="378bbcb4a72a73dada77e96ee58fc0765cdcf81d" translate="yes" xml:space="preserve">
          <source>These headers are allowed to also declare the same names in the &lt;code&gt;std&lt;/code&gt; namespace, and the corresponding &lt;code&gt;cxxx&lt;/code&gt; headers are allowed to also declare the same names in the global namespace: including &amp;lt;cstdlib&amp;gt; definitely provides &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; and may also provide &lt;code&gt;::malloc&lt;/code&gt;. Including &amp;lt;stdlib.h&amp;gt; definitely provides &lt;code&gt;::malloc&lt;/code&gt; and may also provide &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;. This applies even to functions and function overloads that are not part of C standard library.</source>
          <target state="translated">이 헤더는 &lt;code&gt;std&lt;/code&gt; 네임 스페이스 에서 동일한 이름을 선언 할 수 있으며, 해당 &lt;code&gt;cxxx&lt;/code&gt; 헤더는 글로벌 네임 스페이스에서 동일한 이름을 선언 할 수 있습니다. &amp;lt;cstdlib&amp;gt; 포함은 &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; 을 제공하며 &lt;code&gt;::malloc&lt;/code&gt; . &amp;lt;stdlib.h&amp;gt;를 포함하면 &lt;code&gt;::malloc&lt;/code&gt; 이 제공되고 &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; 제공 될 수도 있습니다 . 이는 C 표준 라이브러리의 일부가 아닌 함수 및 함수 오버로드에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9c301ca8ee91cc2dc03b93b934d87b55d872e6ac" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;../iterator/iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 멤버 유형은 &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;../iterator/iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt; 에서 상속하여 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="269f91543a7d747d3318687896f196744a919ccf" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt; &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::iterator_category&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::value_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::difference_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::pointer&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::reference&lt;br/&gt; &amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 멤버 유형은 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt; &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::iterator_category&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::value_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::difference_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::pointer&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::reference&lt;br/&gt; &amp;gt;&lt;/code&gt; 에서 상속하여 가져와야 합니다. :: iterator_traits &amp;lt;Iter&amp;gt; :: pointer , std :: iterator_traits &amp;lt;Iter&amp;gt; :: reference &amp;gt; .</target>
        </trans-unit>
        <trans-unit id="b52b486a05c84f8a4581d34abd369500f9977646" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, CharT, Traits::off_type, /* unspecified, usually CharT* */, CharT&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 멤버 유형은 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, CharT, Traits::off_type, /* unspecified, usually CharT* */, CharT&amp;gt;&lt;/code&gt; 에서 상속하여 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="a01f1d5ca0fbf0d6be5d6ec44fedf3a57f36c70d" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, T, Distance, const T*, const T&amp;amp;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 멤버 유형은 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, T, Distance, const T*, const T&amp;amp;&amp;gt;&lt;/code&gt; 에서 상속하여 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="ae3da083cb674670645135b104ff6e1e31af7384" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 멤버 유형은 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt; 에서 상속하여 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="6dd91df6ca3cc382c9fe0e450bbf5c087b01c8bc" translate="yes" xml:space="preserve">
          <source>These non-member functions enable the use of &lt;code&gt;directory_iterator&lt;/code&gt;s with range-based for loops.</source>
          <target state="translated">이러한 비 멤버 함수 는 범위 기반 for 루프와 함께 &lt;code&gt;directory_iterator&lt;/code&gt; 를 사용할 수있게합니다 .</target>
        </trans-unit>
        <trans-unit id="d44ff77d7541183f5d7e43423582626b5049a546" translate="yes" xml:space="preserve">
          <source>These non-member functions enable the use of &lt;code&gt;recursive_directory_iterator&lt;/code&gt;s with range-based for loops.</source>
          <target state="translated">이러한 비 멤버 함수 는 범위 기반 for 루프와 함께 &lt;code&gt;recursive_directory_iterator&lt;/code&gt; 를 사용할 수있게합니다 .</target>
        </trans-unit>
        <trans-unit id="f216125f2ad7bca05acbed754c42e867a1a09cab" translate="yes" xml:space="preserve">
          <source>These non-member functions provide a generic interface for containers, plain arrays, and &lt;code&gt;&lt;a href=&quot;utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 비 멤버 함수는 컨테이너, 일반 배열 및 &lt;code&gt;&lt;a href=&quot;utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 대한 일반 인터페이스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b6245e0fb4125a31e0f987895270819c57ced919" translate="yes" xml:space="preserve">
          <source>These objects are guaranteed to be initialized during or before the first time an object of type &lt;code&gt;&lt;a href=&quot;ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; is constructed and are available for use in the constructors and destructors of static objects with &lt;a href=&quot;../language/initialization#Non-local_variables&quot;&gt;ordered initialization&lt;/a&gt; (as long as &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; is included before the object is defined).</source>
          <target state="translated">이러한 객체는 &lt;code&gt;&lt;a href=&quot;ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; 유형의 객체가 처음 또는 초기화되기 전에 초기화되도록 보장됩니다 ( &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; 이 (가)있는 한 &lt;a href=&quot;../language/initialization#Non-local_variables&quot;&gt;초기화 된 정렬 된&lt;/a&gt; 정적 객체의 생성자 및 소멸자에서 사용할 수 있음 ) 객체가 정의되기 전에 포함됨).</target>
        </trans-unit>
        <trans-unit id="e1ea5b16593fd62c406fa74578d8a51e69297d84" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::chrono_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;chrono_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt;.</source>
          <target state="translated">이러한 연산자는 네임 스페이스 선언은 &lt;code&gt;std::literals::chrono_literals&lt;/code&gt; 모두, &lt;code&gt;literals&lt;/code&gt; 및 &lt;code&gt;chrono_literals&lt;/code&gt; 가 인라인 네임 스페이스됩니다. &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt; 및 &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt; 를 사용하여 이러한 연산자에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c775ca0f064f8efbb0eebd72489c895fca0cd5d9" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::complex_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;complex_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::complex_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::complex_literals&lt;/code&gt;.</source>
          <target state="translated">이러한 연산자는 네임 스페이스 선언은 &lt;code&gt;std::literals::complex_literals&lt;/code&gt; 모두, &lt;code&gt;literals&lt;/code&gt; 및 &lt;code&gt;complex_literals&lt;/code&gt; 가 인라인 네임 스페이스됩니다. &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::complex_literals&lt;/code&gt; 및 &lt;code&gt;using namespace std::literals::complex_literals&lt;/code&gt; 를 사용 하면 이러한 연산자에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23ceae8d0ac1ad1f53f34bde5fef4212a07b1d5a" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::string_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;string_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::string_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::string_literals&lt;/code&gt;.</source>
          <target state="translated">이러한 연산자는 네임 스페이스 선언은 &lt;code&gt;std::literals::string_literals&lt;/code&gt; 모두, &lt;code&gt;literals&lt;/code&gt; 및 &lt;code&gt;string_literals&lt;/code&gt; 가 인라인 네임 스페이스됩니다. &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::string_literals&lt;/code&gt; 및 &lt;code&gt;using namespace std::literals::string_literals&lt;/code&gt; 를 사용 하면 이러한 연산자에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37f431af515778abb156bc8a341491c98c563acc" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::string_view_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;string_view_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::string_view_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::string_view_literals&lt;/code&gt;.</source>
          <target state="translated">이러한 연산자는 네임 스페이스 선언은 &lt;code&gt;std::literals::string_view_literals&lt;/code&gt; 모두, &lt;code&gt;literals&lt;/code&gt; 및 &lt;code&gt;string_view_literals&lt;/code&gt; 가 인라인 네임 스페이스됩니다. &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::string_view_literals&lt;/code&gt; 및 &lt;code&gt;using namespace std::literals::string_view_literals&lt;/code&gt; 를 사용하여 이러한 연산자에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be85bd7cbe4be2517bbbe6791661ad5c07a4cbe3" translate="yes" xml:space="preserve">
          <source>These operators are sometimes implemented as &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt;.</source>
          <target state="translated">이러한 연산자는 때때로 &lt;a href=&quot;friend&quot;&gt;친구 기능으로&lt;/a&gt; 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="71b614f00aac3b3aedb1ef8cf1ee4d989be39411" translate="yes" xml:space="preserve">
          <source>These operators were not &lt;code&gt;constexpr&lt;/code&gt; in C++11, this was corrected in C++14.</source>
          <target state="translated">이 연산자는 C ++ 11에서 &lt;code&gt;constexpr&lt;/code&gt; 이 아니 었으며 C ++ 14에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="86bd9326b779710e8e7e30da617be0d3ac76c4df" translate="yes" xml:space="preserve">
          <source>These overloads do not participate in overload resolution unless the following conditions are met:</source>
          <target state="translated">이러한 과부하는 다음 조건이 충족되지 않으면 과부하 해결에 참여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e48cfeb3277137050ec5b9718b8d37fe7f54cb7e" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;Deleter&lt;/code&gt; is not a pointer type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;Deleter&lt;/code&gt; 가 포인터 유형이 아닌 경우 이러한 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="88f134a2bed08d434e838bcdda34ccb397f8eca8" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if the corresponding &lt;code&gt;from_stream&lt;/code&gt; expression is well-formed.</source>
          <target state="translated">해당 &lt;code&gt;from_stream&lt;/code&gt; 표현식의 형식이 올바른 경우 이러한 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="a2d116b1f38656e4ef14e8e4c82c85d94f84a468" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if.</source>
          <target state="translated">이러한 과부하는 과부하 해결에만 참여합니다.</target>
        </trans-unit>
        <trans-unit id="78f7dc8ed866031cd5d45fb8e30c10dc7cab0d38" translate="yes" xml:space="preserve">
          <source>These pair-wise comparisons are applied to all viable functions. If exactly one viable function is better than all others, overload resolution succeeds and this function is called. Otherwise, compilation fails.</source>
          <target state="translated">이러한 쌍별 비교는 모든 실행 가능한 기능에 적용됩니다. 정확히 하나의 실행 가능한 함수가 다른 함수보다 낫다면 과부하 해결에 성공하고이 함수가 호출됩니다. 그렇지 않으면 컴파일이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="87d3e33f926d43ebf3e0bc3d2ed5785d5f7e359f" translate="yes" xml:space="preserve">
          <source>These pointer arithmetic operators allow pointers to satisfy the &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; requirements.</source>
          <target state="translated">이러한 포인터 산술 연산자를 사용하면 포인터가 &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; 요구 사항 을 충족 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91cc6d32c62a3af187353d24cb8355a046134850" translate="yes" xml:space="preserve">
          <source>These specializations make it possible to use &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::wregex&lt;/a&gt;&lt;/code&gt;). To use &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; with other character types (for example, &lt;code&gt;char32_t&lt;/code&gt;), a user-provided trait class must be used.</source>
          <target state="translated">이러한 전문화를 통해 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; (일명 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt; ) 및 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; (일명 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::wregex&lt;/a&gt;&lt;/code&gt; )를 사용할 수 있습니다. 다른 문자 유형 (예 : &lt;code&gt;char32_t&lt;/code&gt; ) 과 함께 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; 를 사용하려면 사용자 제공 특성 클래스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8fb1d3f8496237287e2630d9516276eb8186eeef" translate="yes" xml:space="preserve">
          <source>These transformation traits were required</source>
          <target state="translated">이러한 형질 전환 특성이 필요했습니다</target>
        </trans-unit>
        <trans-unit id="25f1f4bdd72a09c080801d8fffb8ec4bf62a753c" translate="yes" xml:space="preserve">
          <source>These two alias templates are used by some &lt;a href=&quot;../algorithm/ranges&quot;&gt;constrained algorithms&lt;/a&gt; to avoid returning potentially dangling iterators or views.</source>
          <target state="translated">이 두 개의 별명 ​​템플리트는 일부 &lt;a href=&quot;../algorithm/ranges&quot;&gt;제한 알고리즘&lt;/a&gt; 에 의해 사용되어 잠재적으로 매달려있는 반복자 또는보기가 리턴되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="c7a8b1fbd19de341e5ad49bc78a2acbfda770aec" translate="yes" xml:space="preserve">
          <source>These type transformations honor reference collapse rules:</source>
          <target state="translated">이러한 유형 변환은 참조 축소 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="dbcace5dd757886bde993d55984f6189eef2a5ad" translate="yes" xml:space="preserve">
          <source>These values are constants, and do not reflect the changes to the rounding made by &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt;. The changed values may be obtained from &lt;code&gt;&lt;a href=&quot;../climits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fegetround&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 값은 상수이며 &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; 가 수행 한 반올림의 변경 사항을 반영하지 않습니다 . 변경된 값은 &lt;code&gt;&lt;a href=&quot;../climits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fegetround&lt;/a&gt;&lt;/code&gt; 에서 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce671f14cf50f53efd465a7781656ad990f4484e" translate="yes" xml:space="preserve">
          <source>They are commonly used as a convenient shortcut for long or deeply-nested namespaces.</source>
          <target state="translated">그것들은 일반적으로 길거나 깊이 중첩 된 네임 스페이스에 대한 편리한 바로 가기로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c8a84aed3ced580611d15354b0869a722fa11d7" translate="yes" xml:space="preserve">
          <source>They are used to specify locking strategies for &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; 대한 잠금 전략을 지정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="11cfa3f63f9b9843169a75987765b90b1df36aef" translate="yes" xml:space="preserve">
          <source>They can also be used to implement pass-by-reference semantics in function calls:</source>
          <target state="translated">또한 함수 호출에서 참조 별 전달 시맨틱을 구현하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="404264233979032de1c13fb29f764da6094435a2" translate="yes" xml:space="preserve">
          <source>Third version</source>
          <target state="translated">세번째 버전</target>
        </trans-unit>
        <trans-unit id="674677ba31e30e4e6af559bc6fc67687b54c0a70" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; to allow deduction from an iterator range.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; 에 제공되어 반복자 범위에서 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c01d9032d07a333deef547c5311682cb32b0369" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; to allow deduction from array and size (note that deduction from pointer and size is covered by the implicit guides).</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 에 제공되어 배열과 크기에서 추론 할 수 있습니다 (포인터와 크기에서 추론은 암시 적 안내서에 포함됨).</target>
        </trans-unit>
        <trans-unit id="080faae34fcef190f2de9f444682b5ad95d98c79" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for deque to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 반복자 범위에서 추론 할 수 있도록 deque에 제공됩니다. 오버로드 확인하는 경우에이 과부하에만 참여하는 &lt;code&gt;InputIt&lt;/code&gt; 의 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; 및 &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a6452884a208e722e9625cf9199c504d50511f4" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for forward_list to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 순회 자 범위에서 추론 할 수 있도록 forward_list에 제공됩니다. 오버로드 확인하는 경우에이 과부하에만 참여하는 &lt;code&gt;InputIt&lt;/code&gt; 의 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; 및 &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="491ded200502330a3077bffc8f20aba48e33a32f" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for list to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 반복자 범위에서 추론 할 수 있도록 목록으로 제공됩니다. 오버로드 확인하는 경우에이 과부하에만 참여하는 &lt;code&gt;InputIt&lt;/code&gt; 의 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; 및 &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d250c6703a67ce4010a480cdc0512de03c8d6af8" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for map to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 반복자 범위 (과부하 (1,3))와 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (과부하 (2,4)) 에서 추론 할 수 있도록 맵에 제공됩니다 . 경우 이러한 과부하는 오버로드 확인에 참여 &lt;code&gt;InputIt&lt;/code&gt; 의 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; , 및 &lt;code&gt;Comp&lt;/code&gt; 없습니다 충족하지 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="472f8efb63db0b27b39e33719d752a5b58fa4ac0" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for multimap to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 안내서&lt;/a&gt; 는 반복자 범위 (과부하 (1,3)) 및 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (과부하 (2,4)) 에서 추론 할 수 있도록 멀티 맵에 제공됩니다 . 경우 이러한 과부하는 오버로드 확인에 참여 &lt;code&gt;InputIt&lt;/code&gt; 의 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; , 및 &lt;code&gt;Comp&lt;/code&gt; 없습니다 충족하지 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="404371bbe2687bcdbddb8c17f22af8568b34d514" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for vector to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;추론 가이드&lt;/a&gt; 는 반복자 범위에서 추론 할 수 있도록 벡터 용으로 제공됩니다. 오버로드 확인하는 경우에이 과부하에만 참여하는 &lt;code&gt;InputIt&lt;/code&gt; 의 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; 및 &lt;code&gt;Alloc&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/allocator&quot;&gt;할당 자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d19a67c2a590fb3edea166f3993c75495030081" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; is only defined if the capture list of the lambda-expression is empty. It is a public, constexpr,(since C++17) non-virtual, non-explicit, const noexcept(since C++14) member function of the closure object. It is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the function call operator of the lambda is an immediate function.(since C++20).</source>
          <target state="translated">이 &lt;a href=&quot;cast_operator&quot;&gt;사용자 정의 변환 함수&lt;/a&gt; 는 람다 식의 캡처 목록이 비어있는 경우에만 정의됩니다. 클로저 객체의 공개, constexpr, (C ++ 17부터) 비가 상적이고, 명시 적이 지 않은 const noexcept (C ++ 14부터) 멤버 함수입니다. 그것은 인 &lt;a href=&quot;consteval&quot;&gt;즉시 함수&lt;/a&gt; 람다의 함수 호출 조작자가 즉시인지 기능. (사람은 C ++ 20).</target>
        </trans-unit>
        <trans-unit id="9dd4d9a7e5470c751564a0b43d9bb48488ca73ae" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is primarily intended for debugging use. For control over formatting, use &lt;code&gt;std::chrono::format&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 는 주로 디버깅 용도로 사용됩니다. 형식을 제어하려면 &lt;code&gt;std::chrono::format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdeeb8bd8306a58bb3de2426d5fca261070137d1" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is primarily intended for debugging use. When used with non-default stream flags, the output may be surprising:</source>
          <target state="translated">이 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 는 주로 디버깅 용도로 사용됩니다. 기본이 아닌 스트림 플래그와 함께 사용하면 출력이 놀라 울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45d5bafe4e82677bb34e8489531cf8b9395463b2" translate="yes" xml:space="preserve">
          <source>This algorithm is a more general form of &lt;code&gt;&lt;a href=&quot;lower_bound&quot;&gt;std::lower_bound&lt;/a&gt;&lt;/code&gt;, which can be expressed in terms of &lt;code&gt;std::partition_point&lt;/code&gt; with the predicate &lt;code&gt;[&amp;amp;](auto const&amp;amp; e) { return e &amp;lt; value; });&lt;/code&gt;.</source>
          <target state="translated">이 알고리즘은 &lt;code&gt;&lt;a href=&quot;lower_bound&quot;&gt;std::lower_bound&lt;/a&gt;&lt;/code&gt; 의보다 일반적인 형식 으로, 술어를 사용하여 &lt;code&gt;std::partition_point&lt;/code&gt; 로 표현할 수 있습니다. &lt;code&gt;[&amp;amp;](auto const&amp;amp; e) { return e &amp;lt; value; });&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="823f5a9d51f4a4e6c775e32f3efd9551b4b6ecbf" translate="yes" xml:space="preserve">
          <source>This algorithm is different from &lt;code&gt;&lt;a href=&quot;../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(&lt;a href=&quot;min_element&quot;&gt;std::min_element&lt;/a&gt;(), &lt;a href=&quot;max_element&quot;&gt;std::max_element&lt;/a&gt;())&lt;/code&gt;, not only in efficiency, but also in that this algorithm finds the</source>
          <target state="translated">이 알고리즘은 &lt;code&gt;&lt;a href=&quot;../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(&lt;a href=&quot;min_element&quot;&gt;std::min_element&lt;/a&gt;(), &lt;a href=&quot;max_element&quot;&gt;std::max_element&lt;/a&gt;())&lt;/code&gt; 와 다르며 효율성뿐만 아니라이 알고리즘이</target>
        </trans-unit>
        <trans-unit id="25bb18b7071a3878825d2611ae20fefcf112dcd2" translate="yes" xml:space="preserve">
          <source>This algorithm performs a similar task as &lt;code&gt;&lt;a href=&quot;merge&quot;&gt;std::merge&lt;/a&gt;&lt;/code&gt; does. Both consume two sorted input ranges and produce a sorted output with elements from both inputs. The difference between these two algorithms is with handling values from both input ranges which compare equivalent (see notes on &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;). If any equivalent values appeared &lt;code&gt;n&lt;/code&gt; times in the first range and &lt;code&gt;m&lt;/code&gt; times in the second, &lt;code&gt;std::merge&lt;/code&gt; would output all &lt;code&gt;n+m&lt;/code&gt; occurrences whereas &lt;code&gt;std::set_union&lt;/code&gt; would output &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; ones only. So &lt;code&gt;std::merge&lt;/code&gt; outputs exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; values and &lt;code&gt;std::set_union&lt;/code&gt; may produce less.</source>
          <target state="translated">이 알고리즘은 &lt;code&gt;&lt;a href=&quot;merge&quot;&gt;std::merge&lt;/a&gt;&lt;/code&gt; 와 비슷한 작업을 수행합니다 . 둘 다 정렬 된 두 입력 범위를 사용하고 두 입력의 요소를 사용하여 정렬 된 출력을 생성합니다. 이 두 알고리즘의 차이점은 동등한 입력을 비교하는 두 입력 범위의 값을 처리하는 것입니다 ( &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LesThanComparable에&lt;/a&gt; 대한 참고 사항 참조 ). 동일한 범위의 값 이 첫 번째 범위에서 &lt;code&gt;n&lt;/code&gt; 번, 두 번째 범위에서 &lt;code&gt;m&lt;/code&gt; 번 나타나는 경우 &lt;code&gt;std::merge&lt;/code&gt; 는 모든 &lt;code&gt;n+m&lt;/code&gt; 항목 을 출력 하지만 &lt;code&gt;std::set_union&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; 만 출력 합니다. 그래서 &lt;code&gt;std::merge&lt;/code&gt; 출력이 정확히 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; 값과 &lt;code&gt;std::set_union&lt;/code&gt; 은 더 적게 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d29fc2206a5224dabc98e893d9a9b64464432d3" translate="yes" xml:space="preserve">
          <source>This algorithm performs a similar task as &lt;code&gt;&lt;a href=&quot;set_union&quot;&gt;std::set_union&lt;/a&gt;&lt;/code&gt; does. Both consume two sorted input ranges and produce a sorted output with elements from both inputs. The difference between these two algorithms is with handling values from both input ranges which compare equivalent (see notes on &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;). If any equivalent values appeared &lt;code&gt;n&lt;/code&gt; times in the first range and &lt;code&gt;m&lt;/code&gt; times in the second, &lt;code&gt;std::merge&lt;/code&gt; would output all &lt;code&gt;n+m&lt;/code&gt; occurrences whereas &lt;code&gt;std::set_union&lt;/code&gt; would output &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; ones only. So &lt;code&gt;std::merge&lt;/code&gt; outputs exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; values and &lt;code&gt;std::set_union&lt;/code&gt; may produce fewer.</source>
          <target state="translated">이 알고리즘은 &lt;code&gt;&lt;a href=&quot;set_union&quot;&gt;std::set_union&lt;/a&gt;&lt;/code&gt; 과 비슷한 작업을 수행합니다 . 둘 다 정렬 된 두 입력 범위를 사용하고 두 입력의 요소를 사용하여 정렬 된 출력을 생성합니다. 이 두 알고리즘의 차이점은 동등한 입력을 비교하는 두 입력 범위의 값을 처리하는 것입니다 ( &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LesThanComparable에&lt;/a&gt; 대한 참고 사항 참조 ). 동일한 범위의 값 이 첫 번째 범위에서 &lt;code&gt;n&lt;/code&gt; 번, 두 번째 범위에서 &lt;code&gt;m&lt;/code&gt; 번 나타나는 경우 &lt;code&gt;std::merge&lt;/code&gt; 는 모든 &lt;code&gt;n+m&lt;/code&gt; 항목 을 출력 하지만 &lt;code&gt;std::set_union&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; 만 출력 합니다. 그래서 &lt;code&gt;std::merge&lt;/code&gt; 출력이 정확히 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; 값 및 &lt;code&gt;std::set_union&lt;/code&gt; 은 더 적은 수를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67039572a7b1266afd41cb596fd8e9903073b309" translate="yes" xml:space="preserve">
          <source>This allows &lt;a href=&quot;move_constructor&quot;&gt;move constructors&lt;/a&gt;, &lt;a href=&quot;move_operator&quot;&gt;move assignment&lt;/a&gt; operators, and other move-aware functions (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back()&lt;/a&gt;&lt;/code&gt;) to be automatically selected when suitable.</source>
          <target state="translated">이를 통해 &lt;a href=&quot;move_constructor&quot;&gt;이동 생성자&lt;/a&gt; , &lt;a href=&quot;move_operator&quot;&gt;이동 할당&lt;/a&gt; 연산자 및 기타 이동 인식 함수 (예 : &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back()&lt;/a&gt;&lt;/code&gt; )를 자동으로 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b23439395d3de2ec476135a3b042e5160bd72c2" translate="yes" xml:space="preserve">
          <source>This allows objects of small class types, such as &lt;code&gt;&lt;a href=&quot;../numeric/complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;std::span&lt;/code&gt;, to be passed to or returned from functions in registers.</source>
          <target state="translated">이를 통해 &lt;code&gt;&lt;a href=&quot;../numeric/complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;std::span&lt;/code&gt; 과 같은 작은 클래스 유형의 오브젝트를 레지스터의 함수로 전달하거나 함수에서 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ba1397263db3733d0fec3f4eee183f7dd40c32d" translate="yes" xml:space="preserve">
          <source>This also makes it possible to capture by const reference, with &lt;code&gt;&amp;amp;cr = &lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;(x)&lt;/code&gt; or similar.</source>
          <target state="translated">또한 &lt;code&gt;&amp;amp;cr = &lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;(x)&lt;/code&gt; 또는 이와 유사한 const 참조로 캡처 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b270e0b13927c9c7d55e1dcef0f35f6860aa9231" translate="yes" xml:space="preserve">
          <source>This applies even to variants of non-class types:</source>
          <target state="translated">이것은 클래스가 아닌 유형의 변형에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c7b69ba009614b0512956cea74a4d37944d632b2" translate="yes" xml:space="preserve">
          <source>This applies to the members of the class template: unless the member is used in the program, it is not instantiated, and does not require a definition.</source>
          <target state="translated">이는 클래스 템플릿의 멤버에 적용됩니다. 멤버가 프로그램에서 사용되지 않으면 인스턴스화되지 않으며 정의가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="afda8940351e810bc83ac7a0844c6ee697d190f3" translate="yes" xml:space="preserve">
          <source>This attribute applies to the name of the function being declared in function declarations only. The behavior is undefined if the function with this attribute actually returns.</source>
          <target state="translated">이 속성은 함수 선언에서만 선언되는 함수의 이름에 적용됩니다. 이 속성을 가진 함수가 실제로 리턴하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6310c0c875c2cc4202df04650e9b8684a1ea09d" translate="yes" xml:space="preserve">
          <source>This attribute can appear in the declaration of the following entities:</source>
          <target state="translated">이 속성은 다음 엔티티의 선언에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48e9f5d2fd561ba7f787f00554eb0339866d9697" translate="yes" xml:space="preserve">
          <source>This attribute is allowed in declarations of the following names or entities:</source>
          <target state="translated">이 속성은 다음 이름 또는 엔티티의 선언에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc9a88af611a842f4ad52d91eb1d0dc9725b08e4" translate="yes" xml:space="preserve">
          <source>This attribute may appear in two situations:</source>
          <target state="translated">이 속성은 두 가지 상황에서 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="492617afde39ac181a5c63ce324178dcbd2c9236" translate="yes" xml:space="preserve">
          <source>This attribute must appear on the first declaration of a function or one of its parameters in any translation unit. If it is not used on the first declaration of a function or one of its parameters in another translation unit, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">이 속성은 변환 단위에서 함수의 첫 번째 선언 또는 해당 매개 변수 중 하나에 나타나야합니다. 다른 변환 단위에서 함수의 첫 번째 선언이나 매개 변수 중 하나에 사용되지 않으면 프로그램이 잘못 작성됩니다. 진단이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da819209a9e30721dffd50c194d372495640b66c" translate="yes" xml:space="preserve">
          <source>This class defines the type of objects thrown as exceptions to report errors from the regular expressions library.</source>
          <target state="translated">이 클래스는 일반 표현식 라이브러리에서 오류를보고하기 위해 예외로 발생 된 객체 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d05fe9ff7a9efe7a6be4213effba38b5678ca3d8" translate="yes" xml:space="preserve">
          <source>This class is designed for use as key in associative containers, both ordered and unordered.</source>
          <target state="translated">이 클래스는 주문형 및 비 순차 형 연관 컨테이너의 키로 사용하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="c77922f02193571f4c08570b0423206a1a325b4d" translate="yes" xml:space="preserve">
          <source>This class is used to ensure that the default C++ streams (&lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, etc.) are properly initialized and destructed. The class tracks how many instances of it are created and initializes the C++ streams when the first instance is constructed as well as flushes the output streams when the last instance is destructed.</source>
          <target state="translated">이 클래스는 기본 C ++ 스트림 ( &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; 등)이 올바르게 초기화되고 소멸 되도록하는 데 사용됩니다 . 이 클래스는 생성 된 인스턴스 수를 추적하고 첫 번째 인스턴스가 생성 될 때 C ++ 스트림을 초기화하고 마지막 인스턴스가 소멸 될 때 출력 스트림을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="4782fa86482a6f5000533d5566f5443e1b31c285" translate="yes" xml:space="preserve">
          <source>This class template is the preferred comparison predicate when building associative containers with &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; as keys, that is,</source>
          <target state="translated">이 클래스 템플리트는 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 을 키로 사용 하여 연관 컨테이너를 빌드 할 때 선호하는 비교 술어 입니다.</target>
        </trans-unit>
        <trans-unit id="d4129ee928b19fe777216b3fc0a11eb88a14da35" translate="yes" xml:space="preserve">
          <source>This class template makes the implicit character conversion functionality of &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; available for any &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 클래스 템플리트는 &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 의 암시 적 문자 변환 기능 을 모든 &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 사용할 수있게합니다 .</target>
        </trans-unit>
        <trans-unit id="67af0e94f21d7e3028f080552ccfa30f81f3903f" translate="yes" xml:space="preserve">
          <source>This classification allows the following errors to be detected at the point of template definition (rather than instantiation):</source>
          <target state="translated">이 분류를 통해 인스턴스화가 아닌 템플릿 정의 시점에서 다음 오류를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58ce9513b35dc96e87c0d70ac154af849efb1443" translate="yes" xml:space="preserve">
          <source>This constructor does not participate in overload resolution if &lt;code&gt;std::decay_t&amp;lt;Function&amp;gt;&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::decay_t&amp;lt;Function&amp;gt;&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 와 동일한 유형 인 경우이 생성자는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a905969e8e69e6e88d275ad307f8717581731297" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;deque(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">이 생성자는 &lt;code&gt;InputIt&lt;/code&gt; 이 정수 유형 인 경우 &lt;code&gt;deque(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; 와 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="7a2d779c18396eab1ee0e06cc486a3335e7edd14" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;forward_list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">이 생성자는 &lt;code&gt;InputIt&lt;/code&gt; 이 정수 유형 인 경우 &lt;code&gt;forward_list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; 와 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="11411ad8214fe6e6c7202887522fc136fe3e90db" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">이 생성자는 &lt;code&gt;InputIt&lt;/code&gt; 이 정수 유형 인 경우 &lt;code&gt;list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; 와 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="d0215f7826bd287562237b0c5f6bbd13fcaf0661" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;vector(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">이 생성자는 입력이 정수 유형 인 경우 &lt;code&gt;vector(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; 와 동일한 효과를 &lt;code&gt;InputIt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16d9b8332d1923e6161015fdc9a2cff3bdfaa0b6" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;constexpr&lt;/code&gt; if every operation it performs is &lt;code&gt;constexpr&lt;/code&gt;. For the empty tuple &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;&lt;/code&gt;, it is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="translated">수행하는 모든 작업 이 &lt;code&gt;constexpr&lt;/code&gt; 인 경우이 생성자는 &lt;code&gt;constexpr&lt;/code&gt; 입니다. 빈 튜플 &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;&lt;/code&gt; 경우 &lt;code&gt;constexpr&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="39b96837fbee6ff8b11f2afbe55d19be8b5237f0" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const Ti&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for at least one &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">이 생성자는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const Ti&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; &amp;lt;const Ti &amp;amp;, Ti&amp;gt; :: value 가 하나 이상의 &lt;code&gt;i&lt;/code&gt; 에 대해 &lt;code&gt;false&lt;/code&gt; 인 경우에만 &lt;code&gt;explicit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="533bf2fceb953a9339da3a3efe2403151289bf62" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U&amp;amp;&amp;amp;, T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U&amp;amp;&amp;amp;, T&amp;gt;&lt;/code&gt; &amp;lt;U &amp;amp;&amp;amp;, T&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 이 생성자가 &lt;code&gt;explicit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="956eea7f4a03a0995417ca7671e86890da8c691a" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U1&amp;amp;&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U2&amp;amp;&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U1&amp;amp;&amp;amp;, first_type&amp;gt;&lt;/code&gt; &amp;lt;U1 &amp;amp;&amp;amp;, first_type&amp;gt; 이 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U2&amp;amp;&amp;amp;, second_type&amp;gt;&lt;/code&gt; &amp;lt;U2 &amp;amp;&amp;amp;, second_type&amp;gt; 이 &lt;code&gt;false&lt;/code&gt; 인 경우에만 이 생성자가 &lt;code&gt;explicit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="00d14d163d5ca5d7a526cb55477d4d3d44718aa1" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U&amp;amp;, T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U&amp;amp;, T&amp;gt;&lt;/code&gt; &amp;lt;const U &amp;amp;, T&amp;gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우에만 이 생성자가 &lt;code&gt;explicit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="703819705f083463e0d7af074684609042e9b532" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U1&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U2&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U1&amp;amp;, first_type&amp;gt;&lt;/code&gt; &amp;lt;const U1 &amp;amp;, first_type&amp;gt; 이 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U2&amp;amp;, second_type&amp;gt;&lt;/code&gt; &amp;lt;const U2 &amp;amp;, second_type&amp;gt; 이 &lt;code&gt;false&lt;/code&gt; 인 경우에만 이 생성자가 &lt;code&gt;explicit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b2d388bc3de25d32e823ab3902c5cb2c7f0bb128" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const first_type&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const second_type&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const first_type&amp;amp;, first_type&amp;gt;&lt;/code&gt; &amp;lt;const first_type &amp;amp;, first_type&amp;gt; 이 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const second_type&amp;amp;, second_type&amp;gt;&lt;/code&gt; &amp;lt;const second_type &amp;amp;, second_type&amp;gt; 이 &lt;code&gt;false&lt;/code&gt; 인 경우에만 이 생성자가 &lt;code&gt;explicit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7c083a7d9073cd96386cc41c8aa08c4631002fa1" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if either &lt;code&gt;first_type&lt;/code&gt; or &lt;code&gt;second_type&lt;/code&gt; is not implicitly default-constructible.</source>
          <target state="translated">&lt;code&gt;first_type&lt;/code&gt; 또는 &lt;code&gt;second_type&lt;/code&gt; 이 암시 적으로 기본 구성 가능하지 않은 경우에만 이 생성자가 &lt;code&gt;explicit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9e3f4b55350fb3f6d920bcec2b1f50c5260e2934" translate="yes" xml:space="preserve">
          <source>This constructor is ill-formed if &lt;code&gt;Deleter&lt;/code&gt; is of pointer or reference type.</source>
          <target state="translated">&lt;code&gt;Deleter&lt;/code&gt; 가 포인터 또는 참조 유형 인 경우이 생성자가 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f4ffe9c6a9e19f1b0de1f70aa1c6912c5d13790" translate="yes" xml:space="preserve">
          <source>This constructor only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">이 생성자는 경우에만 오버로드 확인에 참여 &lt;code&gt;InputIt&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6429d3c8a00cca9524476fd5e7bc85b284721fa1" translate="yes" xml:space="preserve">
          <source>This constructor only participates in overload resolution if all of the following is true:</source>
          <target state="translated">이 생성자는 다음 사항이 모두 충족되는 경우에만 과부하 해결에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="5189004f2798523a38b087278bd624f438a82960" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 생성자는 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; 가 모두 &lt;code&gt;true&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="4726fe3e137ecc9cfdc444c3524298098da680a8" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, const U1&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, const U2&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 생성자는 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, const U1&amp;amp;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, const U2&amp;amp;&amp;gt;&lt;/code&gt; 가 모두 &lt;code&gt;true&lt;/code&gt; 인 경우에만 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="b97d7fbb9211117804e8e5c015e20e35239347ae" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; 이 모두 &lt;code&gt;true&lt;/code&gt; 인 경우에만이 생성자가 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="efe7ac6a6eaa86bb5c97cb1a9afabf3305f77bd2" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; 이 모두 &lt;code&gt;true&lt;/code&gt; 인 경우에만이 생성자가 과부하 해결에 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="a9636e46cd99b7aa6a5346c674ec8170c547d2f3" translate="yes" xml:space="preserve">
          <source>This container is an aggregate type with the same semantics as a struct holding a &lt;a href=&quot;../language/array&quot;&gt;C-style array&lt;/a&gt;&lt;code&gt;T[N]&lt;/code&gt; as its only non-static data member. Unlike a C-style array, it doesn't decay to &lt;code&gt;T*&lt;/code&gt; automatically. As an aggregate type, it can be initialized with &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialization&lt;/a&gt; given at most &lt;code&gt;N&lt;/code&gt; initializers that are convertible to &lt;code&gt;T&lt;/code&gt;: &lt;code&gt;std::array&amp;lt;int, 3&amp;gt; a = {1,2,3};&lt;/code&gt;.</source>
          <target state="translated">이 컨테이너는 정적이 아닌 데이터 멤버로 &lt;a href=&quot;../language/array&quot;&gt;C 스타일 배열 &lt;/a&gt; &lt;code&gt;T[N]&lt;/code&gt; 을 보유하는 구조체와 동일한 의미를 갖는 집계 유형입니다 . C 스타일 배열과 달리 &lt;code&gt;T*&lt;/code&gt; 자동 감쇠되지 않습니다 . 집계 유형으로서, &lt;code&gt;T&lt;/code&gt; 로 변환 가능한 대부분의 &lt;code&gt;N&lt;/code&gt; 이니셜 &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;라이저에&lt;/a&gt; 주어진 집계 초기화로 초기화 될 수 있습니다 . &lt;code&gt;std::array&amp;lt;int, 3&amp;gt; a = {1,2,3};&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bf0aa51a2fd1da025ddbd712b50083980038a0d" translate="yes" xml:space="preserve">
          <source>This conversion models the act of reading a value from a memory location into a CPU register.</source>
          <target state="translated">이 변환은 메모리 위치에서 CPU 레지스터로 값을 읽는 동작을 모델링합니다.</target>
        </trans-unit>
        <trans-unit id="486e8ea678d2260d566d72fdb476e2364e350e4a" translate="yes" xml:space="preserve">
          <source>This declaration may declare &lt;a href=&quot;static&quot;&gt;static&lt;/a&gt; and non-static &lt;a href=&quot;data_members&quot;&gt;data members&lt;/a&gt; and &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;, member &lt;a href=&quot;typedef&quot;&gt;typedefs&lt;/a&gt;, member &lt;a href=&quot;enum&quot;&gt;enumerations&lt;/a&gt;, and &lt;a href=&quot;nested_classes&quot;&gt;nested classes&lt;/a&gt;. It may also be a &lt;a href=&quot;friend&quot;&gt;friend declaration&lt;/a&gt;.</source>
          <target state="translated">이 선언은 &lt;a href=&quot;static&quot;&gt;정적&lt;/a&gt; 및 비 정적 &lt;a href=&quot;data_members&quot;&gt;데이터 멤버&lt;/a&gt; 와 &lt;a href=&quot;member_functions&quot;&gt;멤버 함수&lt;/a&gt; , 멤버 &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; , 멤버 &lt;a href=&quot;enum&quot;&gt;열거&lt;/a&gt; 및 &lt;a href=&quot;nested_classes&quot;&gt;중첩 클래스를&lt;/a&gt; 선언 할 수 있습니다 . &lt;a href=&quot;friend&quot;&gt;친구 선언&lt;/a&gt; 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="790f40ee47446044b6d23c3286797ccea1e6e155" translate="yes" xml:space="preserve">
          <source>This declaration must declare a constructor, destructor, or user-defined type &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt;. It can only be used as part of a &lt;a href=&quot;templates&quot;&gt;template declaration&lt;/a&gt;, &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt;, or explicit instantiation.</source>
          <target state="translated">이 선언은 생성자, 소멸자 또는 사용자 정의 형식 &lt;a href=&quot;cast_operator&quot;&gt;변환 함수를&lt;/a&gt; 선언해야합니다 . &lt;a href=&quot;templates&quot;&gt;템플릿 선언&lt;/a&gt; , &lt;a href=&quot;template_specialization&quot;&gt;명시 적 전문화&lt;/a&gt; 또는 명시 적 인스턴스화의 일부로 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b21c4afc7d9f44a231494182ce929f3873dbd60e" translate="yes" xml:space="preserve">
          <source>This definition is treated as a definition of a namespace with unique name and a</source>
          <target state="translated">이 정의는 고유 한 이름과 이름을 가진 네임 스페이스의 정의로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="f5d805f6f41052ad913a678cd3a3f6f56d5cd6ca" translate="yes" xml:space="preserve">
          <source>This destruction is empty: the members of this &lt;code&gt;basic_streambuf&lt;/code&gt; (the pointers and the locale) are destructed in accordance with the usual object destruction sequence after this destructor returns. However, since it is declared public virtual, it allows the objects that are derived from &lt;code&gt;std::basic_streambuf&lt;/code&gt; to be deleted through a pointer to base class.</source>
          <target state="translated">이 소멸은 비어 있습니다.이 &lt;code&gt;basic_streambuf&lt;/code&gt; (포인터 및 로케일) 의 멤버는 이 소멸자가 리턴 한 후 일반적인 오브젝트 소멸 순서에 따라 소멸됩니다. 그러나 공용 가상으로 선언 &lt;code&gt;std::basic_streambuf&lt;/code&gt; 에서 파생 된 객체 를 기본 클래스에 대한 포인터를 통해 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="566d630222759bb1a22c3aebcb32a3363161c684" translate="yes" xml:space="preserve">
          <source>This destructor does not perform any operation on the underlying stream buffer (&lt;code&gt;rdbuf()&lt;/code&gt;): the destructors of the derived streams such as &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; are responsible for calling the destructors of the stream buffers.</source>
          <target state="translated">이 소멸자는 기본 스트림 버퍼 ( &lt;code&gt;rdbuf()&lt;/code&gt; ) 에서 조작을 수행하지 않습니다 . &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; 과 같은 파생 스트림 의 소멸자는 스트림 버퍼의 소멸자를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="131f49f893678b58d7f7539c38777963fe7160b1" translate="yes" xml:space="preserve">
          <source>This destructor does not perform any operation on the underlying streambuffer (&lt;code&gt;rdbuf()&lt;/code&gt;): the destructors of the derived input streams such as &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; are responsible for calling the destructors of the streambuffers.</source>
          <target state="translated">이 소멸자는 기본 스트림 &lt;code&gt;rdbuf()&lt;/code&gt; ( rdbuf () ) 에서 작업을 수행하지 않습니다 . &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; 과 같은 파생 된 입력 스트림의 소멸자는 스트림 버퍼 의 소멸자를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1b99959c6ca09f07071faff9ad3d0e8aafb11452" translate="yes" xml:space="preserve">
          <source>This destructor is &lt;code&gt;virtual&lt;/code&gt; because the base class destructor, &lt;a href=&quot;../ios_base/~ios_base&quot;&gt;&lt;code&gt;ios_base::~ios_base&lt;/code&gt;&lt;/a&gt; is virtual.</source>
          <target state="translated">이 소멸자는 &lt;code&gt;virtual&lt;/code&gt; 기본 클래스 소멸자 때문에 &lt;a href=&quot;../ios_base/~ios_base&quot;&gt; &lt;code&gt;ios_base::~ios_base&lt;/code&gt; &lt;/a&gt; 가상이다.</target>
        </trans-unit>
        <trans-unit id="e7593a44c2d3c23ae4a80ac5cc6624863832641b" translate="yes" xml:space="preserve">
          <source>This destructor is trivial if &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Types...&lt;/code&gt; 모든 &lt;code&gt;T_i&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 인경우이 소멸자는 사소합니다 .</target>
        </trans-unit>
        <trans-unit id="6df8c5501bb72be0811f778d216bdc599b74a410" translate="yes" xml:space="preserve">
          <source>This destructor is typically called by the destructor of &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 소멸자는 일반적으로 &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; 의 소멸자에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb5e9bde864785c69be529012ab31825d767db62" translate="yes" xml:space="preserve">
          <source>This directive is used by some automatic code generation tools which produce C++ source files from a file written in another language. In that case, &lt;code&gt;#line&lt;/code&gt; directives may be inserted in the generated C++ file referencing line numbers and the file name of the original (human-editable) source file.</source>
          <target state="translated">이 지시문은 다른 언어로 작성된 파일에서 C ++ 소스 파일을 생성하는 일부 자동 코드 생성 도구에서 사용됩니다. 이 경우 &lt;code&gt;#line&lt;/code&gt; 지시문은 생성 된 C ++ 파일 참조 행 번호 및 원본 (사람이 편집 가능한) 소스 파일의 파일 이름에 삽입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2160c0fc9b1d6f99749583e4a431b1db823b687a" translate="yes" xml:space="preserve">
          <source>This element acts as a placeholder; attempting to access it results in undefined behavior.</source>
          <target state="translated">이 요소는 자리 표시 자 역할을합니다. 액세스하려고하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e1d92326ee038395416fb47c3929e52bba4b4b4a" translate="yes" xml:space="preserve">
          <source>This example demonistrates how to apply monetary formatting rules of another language without changing the rest of the locale.</source>
          <target state="translated">이 예는 나머지 로케일을 변경하지 않고 다른 언어의 통화 형식화 규칙을 적용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="699b77b3a2b284060799465bf0aef3eb6c604dfb" translate="yes" xml:space="preserve">
          <source>This example demonistrates how to apply numeric punctuation rules of another language without changing the rest of the locale.</source>
          <target state="translated">이 예제는 나머지 로케일을 변경하지 않고 다른 언어의 숫자 문장 부호 규칙을 적용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="03a8f1b5ffb01757d8be09e129dc569a5400d2fc" translate="yes" xml:space="preserve">
          <source>This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; to observe changes to the atomics &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; in opposite order.</source>
          <target state="translated">이 예는 순차적 순서가 필요한 상황을 보여줍니다. 스레드 &lt;code&gt;c&lt;/code&gt; 와 &lt;code&gt;d&lt;/code&gt; 가 원자 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 변화를 반대 순서 로 관찰 할 수 있기 때문에 다른 순서로 어설 션을 트리거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c12e1f3885c29be2bfca0cfe53639bf6159022e" translate="yes" xml:space="preserve">
          <source>This example demonstrates dependency-ordered synchronization for pointer-mediated publication: the integer data is not related to the pointer to string by a data-dependency relationship, thus its value is undefined in the consumer.</source>
          <target state="translated">이 예는 포인터 매개 게시에 대한 종속성 순서 동기화를 보여줍니다. 정수 데이터는 데이터 종속성 관계에 의해 문자열에 대한 포인터와 관련이 없으므로 소비자에서 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b01d954af477e04c266f80ede6e5280ccdc0a60" translate="yes" xml:space="preserve">
          <source>This example demonstrates perfect forwarding of the parameter(s) to the argument of the constructor of class &lt;code&gt;T&lt;/code&gt;. Also, perfect forwarding of parameter packs is demonstrated.</source>
          <target state="translated">이 예제는 매개 변수를 클래스 &lt;code&gt;T&lt;/code&gt; 생성자의 인수로 완벽하게 전달하는 방법을 보여줍니다 . 또한 매개 변수 팩의 완벽한 전달에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="41d2d00ba30c148282801448fd5c841e57daf05e" translate="yes" xml:space="preserve">
          <source>This example demonstrates reading a GB18030-encoded file using the codecvt facet from a GB18030-aware locale.</source>
          <target state="translated">이 예는 GB18030 인식 로케일에서 codecvt 패싯을 사용하여 GB18030 인코딩 파일을 읽는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4d303a5fae16ce79fa6d0c697ce2d0fc19b5301e" translate="yes" xml:space="preserve">
          <source>This example demonstrates the Euler's identity ei&amp;pi;</source>
          <target state="translated">이 예는 오일러의 정체성 ei&amp;pi;를 보여줍니다</target>
        </trans-unit>
        <trans-unit id="076b866beacb08cccde9a7cbeb026a03c41cdec2" translate="yes" xml:space="preserve">
          <source>This example demonstrates the difference between clock() time and real time.</source>
          <target state="translated">이 예제는 clock () 시간과 실시간의 차이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ec322c19fb258d9310f125341429ba2dbaa4630e" translate="yes" xml:space="preserve">
          <source>This example displays information about the execution time of a function call:</source>
          <target state="translated">이 예는 함수 호출의 실행 시간에 대한 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b6a1d0dea16b8362b800d36d34e475e44374f92b" translate="yes" xml:space="preserve">
          <source>This example measures the execution time of a function.</source>
          <target state="translated">이 예제는 함수의 실행 시간을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="f9f8065b3b5128d3a408cb9f21a45bf456306b8f" translate="yes" xml:space="preserve">
          <source>This example prints current time using the &quot;C&quot; locale with the time_put facet replaced by various time_put_byname facets.</source>
          <target state="translated">이 예에서는 &quot;C&quot;로캘을 사용하여 time_put 패싯을 다양한 time_put_byname 패싯으로 바꾼 현재 시간을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4b380662a79a86a43a8e6ddbc4fae89b7137cd02" translate="yes" xml:space="preserve">
          <source>This example shows a 10 seconds block.</source>
          <target state="translated">이 예는 10 초 블록을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="68e2616f4fe4dbb587d170dace9a4de7c97af570" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;unlock&lt;/code&gt; can be used to protect shared data.</source>
          <target state="translated">이 예는 &lt;code&gt;lock&lt;/code&gt; 및 &lt;code&gt;unlock&lt;/code&gt; 를 사용하여 공유 데이터를 보호 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="b265f51b6f5d54fac0a395f6360e177b329bb440" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;promise&amp;lt;int&amp;gt;&lt;/code&gt; can be used as signals between threads.</source>
          <target state="translated">이 예제는 &lt;code&gt;promise&amp;lt;int&amp;gt;&lt;/code&gt; 를 스레드 간 신호로 사용 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="7e9ee0c7c7b464f5720460296151cb05bd7054a5" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;promise&amp;lt;void&amp;gt;&lt;/code&gt; can be used as signals between threads.</source>
          <target state="translated">이 예는 &lt;code&gt;promise&amp;lt;void&amp;gt;&lt;/code&gt; 를 스레드 간 신호로 사용 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="9cc1e77d4a4ec9dcaa9ce1202b289473c0fe3f32" translate="yes" xml:space="preserve">
          <source>This example shows how a &lt;code&gt;mutex&lt;/code&gt; can be used to protect a &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; shared between two threads.</source>
          <target state="translated">이 예제는 &lt;code&gt;mutex&lt;/code&gt; 를 사용하여 두 스레드간에 공유 되는 &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; 을 보호하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="648fa6a16a6dcfeed9894c57ffbd6224f1ffea42" translate="yes" xml:space="preserve">
          <source>This example shows how to define several custom duration types and convert between types:</source>
          <target state="translated">이 예제는 여러 가지 사용자 정의 기간 유형을 정의하고 유형 간 변환 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0af6770609a4caa5cf880a836ce6717cfed6d527" translate="yes" xml:space="preserve">
          <source>This example shows how to pass a lambda to a generic algorithm and how objects resulting from a lambda declaration can be stored in &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; objects.</source>
          <target state="translated">이 예제는 람다를 일반 알고리즘에 전달하는 방법과 람다 선언으로 생성 된 객체를 &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 객체에 저장하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ccfdcc1737a5e9e6732e2a5414a8ae4ca8c5cc92" translate="yes" xml:space="preserve">
          <source>This example shows how to use a namespace to create a class that already has been named in the &lt;code&gt;std&lt;/code&gt; namespace.</source>
          <target state="translated">이 예제는 네임 스페이스를 사용하여 &lt;code&gt;std&lt;/code&gt; 네임 스페이스 에 이미 이름이 지정된 클래스를 만드는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="4812778eaab911430b4291ca314167dcaef2c221" translate="yes" xml:space="preserve">
          <source>This exception is thrown by &lt;code&gt;&lt;a href=&quot;../../utility/bitset/bitset&quot;&gt;std::bitset::bitset&lt;/a&gt;&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stof&lt;/a&gt;&lt;/code&gt; families of functions.</source>
          <target state="translated">이 예외는 &lt;code&gt;&lt;a href=&quot;../../utility/bitset/bitset&quot;&gt;std::bitset::bitset&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stof&lt;/a&gt;&lt;/code&gt; stof 함수 패밀리에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a6233e2c685f108dd3cbe5ebed91c5d014b2b2b2" translate="yes" xml:space="preserve">
          <source>This exception is thrown by &lt;code&gt;std::chrono::time_zone::to_sys&lt;/code&gt; and functions that call it (such as the constructors of &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; that takes a &lt;code&gt;std::chrono::local_time&lt;/code&gt;).</source>
          <target state="translated">이 예외는 &lt;code&gt;std::chrono::time_zone::to_sys&lt;/code&gt; 및이를 호출하는 함수 (예 &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; 을 취하는 &lt;code&gt;std::chrono::local_time&lt;/code&gt; )에 의해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d06332298cae245fc7de591665ed289988d734a8" translate="yes" xml:space="preserve">
          <source>This exception is thrown by member functions of &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../container/vector/reserve&quot;&gt;std::vector::reserve&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예외는 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../container/vector/reserve&quot;&gt;std::vector::reserve&lt;/a&gt;&lt;/code&gt; 의 멤버 함수에 의해 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="61d73663b9152dc36fe73750ad1a87fd639e49c2" translate="yes" xml:space="preserve">
          <source>This feature is used in template metaprogramming.</source>
          <target state="translated">이 기능은 템플릿 메타 프로그래밍에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ebe57327a03912c16a8791570ac9fd18d3a3f421" translate="yes" xml:space="preserve">
          <source>This form automatically provides &lt;a href=&quot;exceptions&quot;&gt;strong exception guarantee&lt;/a&gt;, but prohibits resource reuse.</source>
          <target state="translated">이 양식은 자동으로 &lt;a href=&quot;exceptions&quot;&gt;강력한 예외 보증을&lt;/a&gt; 제공 하지만 자원 재사용을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="a5c081dc7229ad13536ca7204c599487bcfa19aa" translate="yes" xml:space="preserve">
          <source>This function (for double argument) behaves as if (except for the freedom to not raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;) implemented by the following code:</source>
          <target state="translated">이 함수 (이중 인수의 경우 )는 다음 코드로 구현 된 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 를 발생시키지 않는 자유 제외) 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="6a68eec804ec3c10883600f6bcfaeb90b1f9c1d6" translate="yes" xml:space="preserve">
          <source>This function and the related types are deprecated as of C++11 in favor of the more general &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, both of which create callable adapter-compatible function objects from plain functions.</source>
          <target state="translated">이 함수 및 관련 유형은 일반적인 &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 호출 가능한 어댑터 호환 함수 객체를 생성 하는보다 일반적인 std :: function 및 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; 를 위해 C ++ 11부터 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8855f9b9dc1d262207716dd8128c053ea2ad8bb0" translate="yes" xml:space="preserve">
          <source>This function and the related types were deprecated in C++11 and removed in C++17 in favor of the more general &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, both of which create callable adapter-compatible function objects from member functions.</source>
          <target state="translated">이 함수 및 관련 유형은 C ++ 11에서 더 이상 사용되지 않으며보다 일반적인 &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 를 위해 C ++ 17에서 제거되었습니다 . 둘 다 멤버 함수에서 호출 가능한 어댑터 호환 함수 오브젝트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9d11c6f40fc460580b4545f369d83a5f3011308f" translate="yes" xml:space="preserve">
          <source>This function attempts to allocate a temporary buffer equal in size to the sequence to be sorted. If the allocation fails, the less efficient algorithm is chosen.</source>
          <target state="translated">이 함수는 정렬 할 시퀀스와 크기가 동일한 임시 버퍼를 할당하려고 시도합니다. 할당이 실패하면 덜 효율적인 알고리즘이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="0dc2280353aa9f39b639bbe5806d955bd65f2c7d" translate="yes" xml:space="preserve">
          <source>This function attempts to allocate a temporary buffer. If the allocation fails, the less efficient algorithm is chosen.</source>
          <target state="translated">이 함수는 임시 버퍼 할당을 시도합니다. 할당이 실패하면 덜 효율적인 알고리즘이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="56dabe59df1e13c9e7227a371ae542e03583d74a" translate="yes" xml:space="preserve">
          <source>This function behaves as if implemented as follows:</source>
          <target state="translated">이 기능은 다음과 같이 구현 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e024c278b12913b9314d8bc74236e17366fbdd60" translate="yes" xml:space="preserve">
          <source>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by &lt;code&gt;ptr&lt;/code&gt; is smaller than &lt;code&gt;count&lt;/code&gt;, but the match is found within the array, the behavior is well-defined.</source>
          <target state="translated">이 함수는 문자를 순차적으로 읽고 일치하는 문자를 찾 자마자 멈추는 것처럼 동작합니다. &lt;code&gt;ptr&lt;/code&gt; 이 가리키는 배열 이 &lt;code&gt;count&lt;/code&gt; 보다 작지만 일치하는 것이 배열 내에 있으면 동작이 잘 정의 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="70a20794d71c34f9a147e7b2e7b15ccb7dd382d5" translate="yes" xml:space="preserve">
          <source>This function can be used when implementing &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operators&lt;/a&gt; and &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructors&lt;/a&gt;:</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../language/move_operator&quot;&gt;이동 할당 연산자&lt;/a&gt; 와 &lt;a href=&quot;../language/move_constructor&quot;&gt;이동 생성자를&lt;/a&gt; 구현할 때 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="074233c87f0a8381f8c33e772677b1882b2b89cc" translate="yes" xml:space="preserve">
          <source>This function can make a write position available if the stringbuf is open for output (&lt;code&gt;mode &amp;amp; ios_base::out) != 0&lt;/code&gt;): in this case, it reallocates (or initially allocates) the buffer big enough to hold the entire current buffer plus at least one more character. If the stringbuf is also open for input (&lt;code&gt;(mode &amp;amp; ios_base::in) != 0&lt;/code&gt;), then &lt;code&gt;overflow&lt;/code&gt; also increases the size of the get area by moving &lt;code&gt;egptr()&lt;/code&gt; to point just past the new write position.</source>
          <target state="translated">이 함수는 stringbuf가 출력을 위해 열려있는 경우 쓰기 위치를 사용 가능하게 할 수 있습니다 ( &lt;code&gt;mode &amp;amp; ios_base::out) != 0&lt;/code&gt; ) :이 경우 전체 현재 버퍼를 보유 할만큼 충분히 큰 버퍼를 재 할당 (또는 초기에 할당)합니다 적어도 하나 이상의 캐릭터. stringbuf도 입력을 위해 열려 있으면 ( &lt;code&gt;(mode &amp;amp; ios_base::in) != 0&lt;/code&gt; ) &lt;code&gt;overflow&lt;/code&gt; 는 &lt;code&gt;egptr()&lt;/code&gt; 을 이동 하여 새 쓰기 위치를 지나서 가져 오기 영역의 크기를 늘 립니다.</target>
        </trans-unit>
        <trans-unit id="80dad3848a318d7ecb43c15430bc70acc0b353eb" translate="yes" xml:space="preserve">
          <source>This function detects the sign bit of zeroes, infinities, and NaNs. Along with &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;std::copysign&lt;/a&gt;&lt;/code&gt;, std::signbit is one of the only two portable ways to examine the sign of a NaN.</source>
          <target state="translated">이 함수는 0, 무한대 및 NaN의 부호 비트를 감지합니다. &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;std::copysign&lt;/a&gt;&lt;/code&gt; 과 함께 std :: signbit는 NaN의 부호를 검사 할 수있는 유일한 두 가지 휴대용 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="8e1aa01daec415e7f5af69e6b0d04848557bd2e6" translate="yes" xml:space="preserve">
          <source>This function does not call constructors or initialize memory in any way. There are no ready-to-use smart pointers that could guarantee that the matching deallocation function is called. The preferred method of memory allocation in C++ is using RAII-ready functions &lt;code&gt;&lt;a href=&quot;../unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt;, container constructors, etc, and, in low-level library code, &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt;.</source>
          <target state="translated">이 함수는 생성자를 호출하거나 메모리를 초기화하지 않습니다. 일치하는 할당 해제 기능을 호출 할 수있는 바로 사용할 수있는 스마트 포인터가 없습니다. C ++에서 선호되는 메모리 할당 방법은 RAII 준비 함수 &lt;code&gt;&lt;a href=&quot;../unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; , 컨테이너 생성자 등을 사용하는 것입니다. 그리고 하위 수준 라이브러리 코드에서는 &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4587b2ca7a4f0c1305b825fddf8669b0a594052" translate="yes" xml:space="preserve">
          <source>This function does not commit any changes to the filesystem.</source>
          <target state="translated">이 함수는 파일 시스템에 대한 변경 사항을 커밋하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a9157bc8e19134921e346295ad23635f0edc637" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; 가 true가 아니면이 함수는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="34f86c4c962be5f53b674478758ba7b4aac25784" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt; is true for all i from 0 to &lt;code&gt;sizeof...(Types)&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt; 가 0에서 &lt;code&gt;sizeof...(Types)&lt;/code&gt; 까지의 모든 i에 대해 true가 아니면 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="430ec4ee0ab3ae68ef199618d00c231487c566a4" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;first_type&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;first_type&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 가 아니면이 함수는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="93f49364b5d0b6ce3643e79ff41e9aa02af91573" translate="yes" xml:space="preserve">
          <source>This function exploits the signature compatibility between hinted insert for associative containers (such as &lt;code&gt;&lt;a href=&quot;../../container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt;) and positional insert for sequential containers (such as &lt;code&gt;&lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">이 함수는 연관 컨테이너에 대한 힌트 삽입 (예 : &lt;code&gt;&lt;a href=&quot;../../container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt; )과 순차적 컨테이너에 대한 위치 삽입 ( &lt;code&gt;&lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt; ) 사이의 서명 호환성을 활용합니다 .</target>
        </trans-unit>
        <trans-unit id="77f1becd52cdb4bb82d9005b4cfb7fd4243343b4" translate="yes" xml:space="preserve">
          <source>This function has no effect. Memory used by a &lt;code&gt;monotonic_buffer_resource&lt;/code&gt;, as its name indicates, increases monotonically until the resource is destroyed.</source>
          <target state="translated">이 기능은 효과가 없습니다. 이름에서 알 수 있듯이 &lt;code&gt;monotonic_buffer_resource&lt;/code&gt; 가 사용하는 메모리 는 리소스가 파괴 될 때까지 단조 증가합니다.</target>
        </trans-unit>
        <trans-unit id="003c7fca2e592f4d453e6d2795ce41a60cc8ae9a" translate="yes" xml:space="preserve">
          <source>This function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex is not currenly exclusively locked by any other thread.</source>
          <target state="translated">이 함수는 뮤텍스가 현재 다른 스레드에 의해 독점적으로 잠기지 않은 경우에도 가짜로 실패하고 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4aff8f3ce667147891a0800fe1ffe344229b2457" translate="yes" xml:space="preserve">
          <source>This function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex is not currently locked by any other thread.</source>
          <target state="translated">이 함수는 뮤텍스가 현재 다른 스레드에 의해 잠겨 있지 않은 경우에도 가짜로 실패하고 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="581170c63a0c34f4d8ef486e52f25f659195a185" translate="yes" xml:space="preserve">
          <source>This function is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the function call operator (or specialization, for generic lambdas) is an immediate function.</source>
          <target state="translated">이 함수는이다 &lt;a href=&quot;consteval&quot;&gt;즉시 기능&lt;/a&gt; (일반 람다 또는 전문화) 함수 호출 연산자는 즉시 기능입니다 경우.</target>
        </trans-unit>
        <trans-unit id="7d1b9d31c1cd20909db730ecb0adb4933d6936b7" translate="yes" xml:space="preserve">
          <source>This function is called (through &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt;) by any allocator-aware object, such as &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::pmr::vector&lt;/a&gt;&lt;/code&gt; (or another &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; that was given a &lt;code&gt;std::std::polymorphic_allocator&lt;/code&gt; as the allocator to use).</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::pmr::vector&lt;/a&gt;&lt;/code&gt; (또는 &lt;code&gt;std::std::polymorphic_allocator&lt;/code&gt; 에 지정된 할당 자로 제공된 다른 &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 와 같은 할당 자 인식 객체에 의해 ( &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; 통해) 호출 됩니다. ).</target>
        </trans-unit>
        <trans-unit id="f22521ea8de0d211401620c2c0ceeebcc98c2413" translate="yes" xml:space="preserve">
          <source>This function is called (through &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt;) by any allocator-aware object, such as &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, that was given a &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; as the allocator to use. Since &lt;code&gt;inner_allocator&lt;/code&gt; is itself an instance of &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt;, this function will also be called when the allocator-aware objects constructed through this function start constructing their own members.</source>
          <target state="translated">이 기능은 (통해 호출 &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; 등 모든 할당 인식 객체에 의해), &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 주어진 된, &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; 사용에 할당 등을. 이후 &lt;code&gt;inner_allocator&lt;/code&gt; 는 자체의 인스턴스 &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; 이 기능을 통해 구축 된 할당-인식 개체가 자신의 회원을 구성 시작할 때,이 함수는 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1604a10d0bd65894de0fdd375bd44a25850704e0" translate="yes" xml:space="preserve">
          <source>This function is called automatically when swapping &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::fstream&lt;/a&gt;&lt;/code&gt; objects, it is rarely necessary to call it directly.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::fstream&lt;/a&gt;&lt;/code&gt; 객체를 교체 할 때 자동으로 호출되므로 직접 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e78d40edd5ecace775e3b468b3346c7031f470e" translate="yes" xml:space="preserve">
          <source>This function is called automatically when swapping &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::stringstream&lt;/a&gt;&lt;/code&gt; objects, it is rarely necessary to call it directly.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::stringstream&lt;/a&gt;&lt;/code&gt; 객체를 바꿀 때 자동으로 호출되므로 직접 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4734f8a6748c0cb4415534ce967c7c8880cdda2" translate="yes" xml:space="preserve">
          <source>This function is called by &lt;code&gt;std::basic_filebuf::close()&lt;/code&gt; and in other situations when finalizing a state-dependent multibyte character sequence.</source>
          <target state="translated">이 함수는 &lt;code&gt;std::basic_filebuf::close()&lt;/code&gt; 의해 호출되며 다른 상황에서는 상태 종속 멀티 바이트 문자 시퀀스를 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32de367add154511d8a09e86e9af636ea74ff7b5" translate="yes" xml:space="preserve">
          <source>This function is called by the constructor of &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; when given an &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc&lt;/a&gt;&lt;/code&gt; 인수가 주어지면 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 의 생성자에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="cbcb817100be7c6ebcd72951487118723a0a15af" translate="yes" xml:space="preserve">
          <source>This function is called by the copy constructors of all standard library containers. It allows the allocator used by the constructor's argument to become aware that the container is being copied and modify state if necessary.</source>
          <target state="translated">이 함수는 모든 표준 라이브러리 컨테이너의 복사 생성자에 의해 호출됩니다. 생성자의 인수가 사용하는 할당자가 컨테이너가 복사되고 있음을 인식하고 필요한 경우 상태를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb34e88abba67d43669caa31797e35aed808cba" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_fstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">이 함수는 스트림 객체가 범위를 벗어날 때 basic_fstream의 소멸자에 의해 호출되며 일반적으로 직접 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9586654e6d5f24f563ef041033abacd3e6aaef3e" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_ifstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">이 함수는 스트림 객체가 범위를 벗어날 때 basic_ifstream의 소멸자에 의해 호출되며 일반적으로 직접 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b0b9fa6d17fdf350f225d78773a873a4f6a210f" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_ofstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">이 함수는 스트림 객체가 범위를 벗어날 때 basic_ofstream의 소멸자에 의해 호출되며 일반적으로 직접 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae182d564b01a9cc3f1cbb5dd2383b385c515a22" translate="yes" xml:space="preserve">
          <source>This function is constexpr if the function call operator (or specialization, for generic lambdas) is constexpr.</source>
          <target state="translated">이 함수는 함수 호출 연산자 (또는 일반 람다의 특수화)가 constexpr 인 경우 constexpr입니다.</target>
        </trans-unit>
        <trans-unit id="6cb839c1449d28abb8b1ad7d5627544f12403184" translate="yes" xml:space="preserve">
          <source>This function is designed to be called multiple times to obtain successive tokens from the same string.</source>
          <target state="translated">이 함수는 동일한 문자열에서 연속적인 토큰을 얻기 위해 여러 번 호출되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="db0f3821e4deee5da8554e13cdcbbb92c017d0a9" translate="yes" xml:space="preserve">
          <source>This function is designed to be called multiples times to obtain successive tokens from the same string.</source>
          <target state="translated">이 함수는 동일한 문자열에서 연속적인 토큰을 얻기 위해 여러 번 호출되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="776743886aba3fc5ea926a51a096528c0531353d" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a &lt;a href=&quot;../../language/string_literal&quot;&gt;string literal&lt;/a&gt; cannot be used as the first argument of &lt;code&gt;strtok&lt;/code&gt;.</source>
          <target state="translated">이 함수는 파괴적입니다 : 문자열 &lt;code&gt;str&lt;/code&gt; 의 요소에 &lt;code&gt;'\0'&lt;/code&gt; 문자를 씁니다 . 특히 &lt;a href=&quot;../../language/string_literal&quot;&gt;문자열 리터럴&lt;/a&gt; 을 &lt;code&gt;strtok&lt;/code&gt; 의 첫 번째 인수로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="aaae01573deddc58b640a93ca69e57c3af20acb3" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;L'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a wide string literal cannot be used as the first argument of &lt;code&gt;std::wcstok&lt;/code&gt;.</source>
          <target state="translated">이 함수는 파괴적입니다 : 문자열 &lt;code&gt;str&lt;/code&gt; 의 요소에 &lt;code&gt;L'\0'&lt;/code&gt; 문자를 씁니다 . 특히 넓은 문자열 리터럴은 &lt;code&gt;std::wcstok&lt;/code&gt; 의 첫 번째 인수로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ae117e98847c242edb80799fb082fc22f8c51c75" translate="yes" xml:space="preserve">
          <source>This function is different from a typical &lt;code&gt;overflow()&lt;/code&gt; which moves the contents of the buffer to the associated character sequence because for a &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;, the buffer and the associated sequence are one and the same.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; 의 경우 버퍼와 관련 시퀀스가 ​​동일 하고 버퍼의 내용을 관련 문자 시퀀스로 이동 하는 일반적인 &lt;code&gt;overflow()&lt;/code&gt; 와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="bf7eaed7da997c4b5d39d94135b3ff5c00bc6632" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; for some hidden object &lt;code&gt;internal&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;, except that the expression &lt;code&gt;ps&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">이 함수 호출에 등가 인 &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; 일부 숨겨진 개체 &lt;code&gt;internal&lt;/code&gt; 유형의 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 발현하는 것을 제외하고, &lt;code&gt;ps&lt;/code&gt; 한번만 평가된다.</target>
        </trans-unit>
        <trans-unit id="9101f15eeb95d6b33b0fdb8d4808ce7c08cccbd4" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt;, except that conversion state of &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; is unaffected.</source>
          <target state="translated">이 함수 호출에 해당 &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt; 의 해당 변환 상태를 제외하고 &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; 영향을받지 않는다.</target>
        </trans-unit>
        <trans-unit id="1963bc98196193cc320458fc455ddd3e328dde8a" translate="yes" xml:space="preserve">
          <source>This function is infrequently used directly by application code. Instead, one of the non-member comparison operators are used.</source>
          <target state="translated">이 기능은 응용 프로그램 코드에서 자주 사용되지 않습니다. 대신 비 멤버 비교 연산자 중 하나가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="403f2759a06c2803350631fa5d221bae46fd2b6b" translate="yes" xml:space="preserve">
          <source>This function is inherently racy if the managed object is shared among threads. In particular, a false result may become stale before it can be used. A true result is reliable.</source>
          <target state="translated">관리 대상 객체가 스레드간에 공유되는 경우이 기능은 본질적으로 불쾌합니다. 특히, 잘못된 결과를 사용하기 전에 부실하게 될 수 있습니다. 진정한 결과는 신뢰할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="452207e6d60059763d001256a30bc736ba869131" translate="yes" xml:space="preserve">
          <source>This function is intended to replace &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;. Unlike std::bind, it does not support arbitrary argument rearrangement and has no special treatment for nested bind-expressions. On the other hand, it pays attention to the value category of the call wrapper object and propagates exception specification of the underlying call operator.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 를 대체하기위한 것 입니다. std :: bind와 달리 임의의 인수 재 배열을 지원하지 않으며 중첩 된 바인드 표현식에 대한 특별한 처리가 없습니다. 반면에, 이는 호출 랩퍼 오브젝트의 값 카테고리에주의를 기울이고 기본 호출 연산자의 예외 스펙을 전파합니다.</target>
        </trans-unit>
        <trans-unit id="bc919d55a6f87a71a7f9eff45b45a6e0e62a8ce5" translate="yes" xml:space="preserve">
          <source>This function is not expected to be called directly: it is called through &lt;a href=&quot;../basic_osyncstream/get_wrapped&quot;&gt;&lt;code&gt;std::basic_osyncstream::get_wrapped&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 직접 호출 될 필요는 없습니다 . &lt;a href=&quot;../basic_osyncstream/get_wrapped&quot;&gt; &lt;code&gt;std::basic_osyncstream::get_wrapped&lt;/code&gt; &lt;/a&gt; 통해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="57e7dd85f600e213ae40f7d97225e1e1697e505f" translate="yes" xml:space="preserve">
          <source>This function is not fully implemented in some standard libraries. For example, &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master/src/random.cpp#L174&quot;&gt;LLVM libc++&lt;/a&gt; always returns zero even though the device is non-deterministic. In comparison, Microsoft Visual C++ implementation always returns 32, and &lt;a href=&quot;https://github.com/boostorg/random/blob/master/src/random_device.cpp#L242&quot;&gt;boost.random&lt;/a&gt; returns 10.</source>
          <target state="translated">이 기능은 일부 표준 라이브러리에서 완전히 구현되지 않았습니다. 예를 들어, &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master/src/random.cpp#L174&quot;&gt;LLVM libc ++&lt;/a&gt; 는 장치가 결정적이지 않더라도 항상 0을 반환합니다. 이에 비해 Microsoft Visual C ++ 구현은 항상 32를 반환하고 &lt;a href=&quot;https://github.com/boostorg/random/blob/master/src/random_device.cpp#L242&quot;&gt;boost.random&lt;/a&gt; 은 10을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf2280640237c525c2d62eefb26aff9f2856c11f" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it copies: nulls as well as invalid characters are copied too.</source>
          <target state="translated">이 함수는 로케일에 민감하지 않으며 복사 하는 &lt;code&gt;wchar_t&lt;/code&gt; 오브젝트 의 값에주의를 기울이지 않습니다. 유효하지 않은 문자뿐만 아니라 널도 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="67fe14d7992c12e6d5c157b600ec2cde52ad0774" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it examines: nulls as well as invalid wide characters are compared too.</source>
          <target state="translated">이 함수는 로케일에 민감하지 않으며 검사 하는 &lt;code&gt;wchar_t&lt;/code&gt; 오브젝트 의 값에주의를 기울이지 않습니다 . 널 (NULL) 및 유효하지 않은 와이드 문자도 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="9c3cb718222d314cabd06a082b4892a3a4ab3e26" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it writes: nulls as well as invalid wide characters are written too.</source>
          <target state="translated">이 함수는 로케일에 민감하지 않으며 작성 하는 &lt;code&gt;wchar_t&lt;/code&gt; 오브젝트 의 값에주의를 기울이지 않습니다 . 널 (NULL) 및 유효하지 않은 와이드 문자도 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="cc19c16caa38c36df06e04a2db5301e73e2f5836" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, and the order may not be meaningful when characters from different Unicode blocks are used together or when the order of code units does not match collation order.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt; 과 달리 로케일에 민감 하지 않으며 다른 유니 코드 블록의 문자를 함께 사용하거나 코드 단위의 순서가 데이터 정렬 순서와 일치하지 않으면 순서가 의미가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="743f719e1c7876947aef41d3da4d327b2152c1ab" translate="yes" xml:space="preserve">
          <source>This function is not overloaded for the types &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, unlike the formatted &lt;a href=&quot;operator_ltlt2&quot;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;</source>
          <target state="translated">형식이 지정된 &lt;a href=&quot;operator_ltlt2&quot;&gt;연산자&lt;/a&gt; 와 달리 &lt;code&gt;signed char&lt;/code&gt; 또는 &lt;code&gt;unsigned char&lt;/code&gt; 유형에는이 함수가 오버로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3b72d4451a67b0f8e9ff04bab97998d9cac5a6e" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then +0 is returned.</source>
          <target state="translated">일부 구현에서는 한 인수가 +0이고 다른 인수가 -0이면 +0이 리턴되도록 추가로 시행하지만이 함수는 0의 부호에 민감하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="1e7653f07d484a2f1a2819f2a881f15b3743184c" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then -0 is returned.</source>
          <target state="translated">일부 구현에서는 한 인수가 +0이고 다른 인수가 -0이면 -0이 리턴되도록 추가로 시행하지만이 함수는 0의 부호에 민감하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="63ff1f7a80d3a2498f6c2c57080a31e1fe86d34e" translate="yes" xml:space="preserve">
          <source>This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</source>
          <target state="translated">이 기능은 스레드로부터 안전하지 않아도됩니다. getenv에 대한 다른 호출과 POSIX 함수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv ()&lt;/a&gt; , &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv ()&lt;/a&gt; 및 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv ()&lt;/a&gt; 에 대한 호출은 이전 호출에서 리턴 된 포인터를 무효화하거나 이전 호출에서 얻은 문자열을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="681d635b8b9b9b5848473256fcd251c20f009b9c" translate="yes" xml:space="preserve">
          <source>This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78d178d130886a2b5afb503f15940c3ad73bbf9" translate="yes" xml:space="preserve">
          <source>This function is not subject to any errors specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에는 &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 에 지정된 오류가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a2abffafc50a2795cbfb3627bf5fb2f042437061" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the error conditions specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에는 &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 에 지정된 오류 조건이 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e653a40d5b5f3d4ecc32e287a36ac0f0a3489976" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the errors specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수에는 &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 에 지정된 오류가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="da22a8cee5382549c532104db50c4ef68f7574e4" translate="yes" xml:space="preserve">
          <source>This function is not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">이 기능은 보통 볼 수없는 &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;비정규&lt;/a&gt; 또는 &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;자격 조회&lt;/a&gt; , 만 찾을 수 있습니다 &lt;a href=&quot;../../language/adl&quot;&gt;인수 종속적 조회&lt;/a&gt; 할 때 &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; 인수 연관된 클래스입니다. 이렇게하면 &lt;code&gt;using namespace std::filesystem;&lt;/code&gt; 이있는 경우 바람직하지 않은 변환이 방지됩니다 .</target>
        </trans-unit>
        <trans-unit id="356a2955e71eb2ff664ad638e29c0c881711ba2c" translate="yes" xml:space="preserve">
          <source>This function is optional, it may return &lt;code&gt;no_order&lt;/code&gt; in every case.</source>
          <target state="translated">이 함수는 선택 사항이며 모든 경우에 &lt;code&gt;no_order&lt;/code&gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ffa5bc6979d4d788a32f52d1a8c3d6238bb88fba" translate="yes" xml:space="preserve">
          <source>This function is optional. If not implemented, this function returns &lt;code&gt;​0​&lt;/code&gt; (since the base class version &lt;code&gt;std::basic_streambuf::showmanyc&lt;/code&gt; gets called).</source>
          <target state="translated">이 기능은 옵션입니다. 구현되지 않은 경우,이 함수는 반환 &lt;code&gt;​0​&lt;/code&gt; (기본 클래스 버전 이후 &lt;code&gt;std::basic_streambuf::showmanyc&lt;/code&gt; 호출된다).</target>
        </trans-unit>
        <trans-unit id="94f083987e438e8f45398655d60ea441662342f7" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::basic_filebuf&lt;/code&gt;.</source>
          <target state="translated">이 함수는 가상으로 보호되며 &lt;code&gt;pubsetbuf()&lt;/code&gt; 또는 &lt;code&gt;std::basic_filebuf&lt;/code&gt; 에서 파생 된 사용자 정의 클래스의 멤버 함수 를 통해서만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e90def3890bd5c122a703d2eae4d728a21e862ac" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::basic_stringbuf&lt;/code&gt;.</source>
          <target state="translated">이 함수는 가상으로 보호되며 &lt;code&gt;pubsetbuf()&lt;/code&gt; 또는 &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 에서 파생 된 사용자 정의 클래스의 멤버 함수 에서만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7f492276aa00c278aeca31b34dc935f13689be2" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::strstreambuf&lt;/code&gt;.</source>
          <target state="translated">이 함수는 가상으로 보호되며 &lt;code&gt;pubsetbuf()&lt;/code&gt; 또는 &lt;code&gt;std::strstreambuf&lt;/code&gt; 에서 파생 된 사용자 정의 클래스의 멤버 함수 를 통해서만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="503edf2bb2eb0295ac5dcd3fad68fe3498303d2a" translate="yes" xml:space="preserve">
          <source>This function is provided for compatibility with C. If the compatibility is not required, &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; may be initialized through their non-default constructors.</source>
          <target state="translated">이 함수는 C와의 호환성을 위해 제공됩니다. 호환성이 필요하지 않은 경우 기본이 아닌 생성자를 통해 &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 이 초기화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0233eac438664696f470dcb4a6305de8bdfaa672" translate="yes" xml:space="preserve">
          <source>This function is thread-safe (calling it from multiple threads does not introduce a data race) as long as no other function modifies the host environment. In particular, the POSIX functions &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; would introduce a data race if called without synchronization.</source>
          <target state="translated">다른 함수가 호스트 환경을 수정하지 않는 한이 함수는 스레드로부터 안전합니다 (여러 스레드에서 호출하면 데이터 경쟁이 발생하지 않습니다). 특히 POSIX 함수 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv ()&lt;/a&gt; , &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv ()&lt;/a&gt; 및 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv ()&lt;/a&gt; 는 동기화없이 호출되면 데이터 경쟁을 일으 킵니다 .</target>
        </trans-unit>
        <trans-unit id="c77ec9cdb8ff1e7489c1293af187dff2039fb586" translate="yes" xml:space="preserve">
          <source>This function is thread-safe (calling it from multiple threads does not introduce a data race) as long as no other function modifies the host environment. In particular, the POSIX functions &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; would introduce a data race if called without synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a752e45b1c1e76a0bf7ba715c5f6c403c0eed278" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::pmr::set_default_resource&lt;/code&gt;</source>
          <target state="translated">이 기능은 스레드로부터 안전합니다. &lt;code&gt;std::pmr::set_default_resource&lt;/code&gt; 모든 호출</target>
        </trans-unit>
        <trans-unit id="a166d5bd1c79123ccec86898cc471f7c6a1e389e" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_new_handler&lt;/code&gt;</source>
          <target state="translated">이 기능은 스레드로부터 안전합니다. &lt;code&gt;std::set_new_handler&lt;/code&gt; 모든 호출</target>
        </trans-unit>
        <trans-unit id="0f8d53be444102a8285b0653a05c85e675ae55c4" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_terminate&lt;/code&gt;</source>
          <target state="translated">이 기능은 스레드로부터 안전합니다. &lt;code&gt;std::set_terminate&lt;/code&gt; 모든 호출</target>
        </trans-unit>
        <trans-unit id="2c7aea13c02b97924864411502ae4053e055e059" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_unexpected&lt;/code&gt;</source>
          <target state="translated">이 기능은 스레드로부터 안전합니다. &lt;code&gt;std::set_unexpected&lt;/code&gt; 모든 호출</target>
        </trans-unit>
        <trans-unit id="12d270b8becf9b193ce734289e056a679cfdfc26" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Previous call to &lt;code&gt;&lt;a href=&quot;set_default_resource&quot;&gt;std::pmr::set_default_resource&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">이 기능은 스레드로부터 안전합니다. &lt;code&gt;&lt;a href=&quot;set_default_resource&quot;&gt;std::pmr::set_default_resource&lt;/a&gt;&lt;/code&gt; 이전 호출</target>
        </trans-unit>
        <trans-unit id="b1ab230cef40ffc4e792b092936b1dc96c9a5607" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Previous call to &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">이 기능은 스레드로부터 안전합니다. &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt; 이전 호출</target>
        </trans-unit>
        <trans-unit id="419521c15e45c9bfd4ee0de0dfa28aaf76875995" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Prior call to &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">이 기능은 스레드로부터 안전합니다. &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt; 사전 호출</target>
        </trans-unit>
        <trans-unit id="991dd801c88141cd8662fd187f9759911775d74d" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Prior call to &lt;code&gt;std::set_unexpected&lt;/code&gt;</source>
          <target state="translated">이 기능은 스레드로부터 안전합니다. &lt;code&gt;std::set_unexpected&lt;/code&gt; 사전 호출</target>
        </trans-unit>
        <trans-unit id="b2b7ba4b79851f8176eac8ec16e5a1575927b2d7" translate="yes" xml:space="preserve">
          <source>This function is thread-safe; concurrent access by multiple threads does not result in a data race.(since C++14).</source>
          <target state="translated">이 기능은 스레드로부터 안전합니다. 여러 스레드에 의한 동시 액세스로 인해 데이터 경쟁이 발생하지 않습니다 (C ++ 14부터).</target>
        </trans-unit>
        <trans-unit id="6c9ad1a43ed57cf75b0c052d412e9c8c3e821c79" translate="yes" xml:space="preserve">
          <source>This function is typically accessed through &lt;code&gt;std::basic_stringstream::str()&lt;/code&gt;.</source>
          <target state="translated">이 함수는 일반적으로 &lt;code&gt;std::basic_stringstream::str()&lt;/code&gt; 통해 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="8638be2f7c43a80edc7dee020c03393b731e9858" translate="yes" xml:space="preserve">
          <source>This function is typically called by &lt;code&gt;&lt;a href=&quot;../basic_fstream/is_open&quot;&gt;std::basic_fstream::is_open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 일반적으로 &lt;code&gt;&lt;a href=&quot;../basic_fstream/is_open&quot;&gt;std::basic_fstream::is_open()&lt;/a&gt;&lt;/code&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="db17dd608d932664bed4bd45648d18848b7cdb88" translate="yes" xml:space="preserve">
          <source>This function is typically called through the &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">이 함수는 일반적으로 &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; 인터페이스를 통해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b70e23981de2eddfb5cf1b279f2272ffbaab4c5" translate="yes" xml:space="preserve">
          <source>This function is used by the standard library containers when inserting, copying, or moving elements.</source>
          <target state="translated">이 함수는 요소를 삽입, 복사 또는 이동할 때 표준 라이브러리 컨테이너에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c6ccf8ad1ccab32debfac40525ef074436c2ec6" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same string or set of strings, because it is more efficient to use &lt;code&gt;std::strxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::strxfrm&lt;/code&gt; 을 사용 하여 모든 문자열을 한 번만 변환 한 다음 변환 된 문자열을 &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; 와 비교하는 것이 더 효율적 이므로이 함수는 동일한 문자열 또는 문자열 세트를 사용하여 여러 로케일 종속 비교를 수행 할 때 사용됩니다. .</target>
        </trans-unit>
        <trans-unit id="ca9d1d936d9fcef21052e9b31a8d09c354e45148" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same wide string or set of wide strings, because it is more efficient to use &lt;code&gt;std::wcsxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed wide strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::wcsxfrm&lt;/code&gt; 을 사용 하여 모든 문자열을 한 번만 변환하고 변환 된 와이드 문자열을 &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; 와 비교하는 것이 더 효율적 이므로이 함수는 동일한 와이드 문자열 또는 와이드 문자열 세트를 사용하여 여러 로케일 종속 비교를 수행 할 때 사용됩니다. :: wcscmp .</target>
        </trans-unit>
        <trans-unit id="5926d0f12bf7b7909e57150c062279d2ee706942" translate="yes" xml:space="preserve">
          <source>This function is useful in generic programming, since it uses &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; as fallbacks when &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; is not available.</source>
          <target state="translated">이 함수는 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 를 사용할 수없는 경우 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;==&lt;/code&gt; 를 대체로 사용하므로 일반 프로그래밍에 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="be58b3707f3fcdf36615b4d19faec6a6dc05f29c" translate="yes" xml:space="preserve">
          <source>This function is useful when implementing periodic functions with the period exactly representable as a floating-point value: when calculating sin(&amp;pi;x) for a very large &lt;code&gt;x&lt;/code&gt;, calling &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; directly may result in a large error, but if the function argument is first reduced with &lt;code&gt;std::remquo&lt;/code&gt;, the low-order bits of the quotient may be used to determine the sign and the octant of the result within the period, while the remainder may be used to calculate the value with high precision.</source>
          <target state="translated">이 함수는주기를 부동 소수점 값으로 정확하게 표현할 수있는주기 함수를 구현할 때 유용합니다. 매우 큰 &lt;code&gt;x&lt;/code&gt; 에 대해 sin (&amp;pi;x)을 계산할 때 &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; 직접 호출 하면 큰 오류가 발생할 수 있지만 함수 인수가 &lt;code&gt;std::remquo&lt;/code&gt; 로 먼저 감소 하면 몫의 하위 비트는 기간 내 결과의 부호와 8 위를 결정하는 데 사용될 수 있으며 나머지는 높은 정밀도로 값을 계산하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9314ee2e726c67b60305538d50add991082d26bc" translate="yes" xml:space="preserve">
          <source>This function is usually case-insensitive.</source>
          <target state="translated">이 기능은 일반적으로 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c9ee1f3188431817a670ceef41258274cd55d11" translate="yes" xml:space="preserve">
          <source>This function may be used as an alternative to &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt;. The trade-offs are:</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt; 대신 사용할 수 있습니다 . 장단점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0255ee7edd077c96e23883d7db760fc3da2e3d71" translate="yes" xml:space="preserve">
          <source>This function may be used e.g. in the implementation of &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/underflow&quot;&gt;std::basic_filebuf::underflow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/overflow&quot;&gt;std::basic_filebuf::overflow&lt;/a&gt;&lt;/code&gt; to use bulk character copy instead of calling &lt;code&gt;&lt;a href=&quot;in&quot;&gt;std::codecvt::in&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; if it is known that the locale imbued in the &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; does not perform any conversions.</source>
          <target state="translated">이 기능의 구현에 사용 예를 들어있을 수 있습니다 &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/underflow&quot;&gt;std::basic_filebuf::underflow&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/overflow&quot;&gt;std::basic_filebuf::overflow&lt;/a&gt;&lt;/code&gt; 대량 문자를 사용하는 대신 호출하는 복사 &lt;code&gt;&lt;a href=&quot;in&quot;&gt;std::codecvt::in&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; 그것을 경우 &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 에 포함 된 로케일 은 변환을 수행하지 않는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="332c6aa9bcea925b9a927e3ad7173bbcf6a2f86d" translate="yes" xml:space="preserve">
          <source>This function may be used in the beginning of a subroutine that must hide the floating-point exceptions it may raise from the caller. If only some exceptions must be suppressed, while others must be reported, the non-stop mode is usually ended with a call to &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; after clearing the unwanted exceptions.</source>
          <target state="translated">이 함수는 호출자로부터 발생할 수있는 부동 소수점 예외를 숨겨야하는 서브 루틴의 시작에서 사용될 수 있습니다. 일부 예외 만 억제해야하고 다른 예외 만보고해야하는 경우 비 정지 모드는 일반적으로 원치 않는 예외를 지운 후 &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; 호출하여 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="653f6e88a7890bf08216060f0a91617ba728c746" translate="yes" xml:space="preserve">
          <source>This function may be used to end the non-stop mode established by an earlier call to &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;std::feholdexcept&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;std::feholdexcept&lt;/a&gt;&lt;/code&gt; 에 대한 이전 호출로 설정된 논스톱 모드를 종료하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23b1aaf9597250b14a85a5f063ebcaa36211aeee" translate="yes" xml:space="preserve">
          <source>This function may be used to output object representations, i.e. binary output.</source>
          <target state="translated">이 함수는 객체 표현, 즉 이진 출력을 출력하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="856950bcb4c9f3dcc5895c41de9e090f268e6ccd" translate="yes" xml:space="preserve">
          <source>This function may block for longer than &lt;code&gt;sleep_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">이 기능은 예약 또는 리소스 경합 지연으로 인해 &lt;code&gt;sleep_duration&lt;/code&gt; 보다 오래 차단 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c2d0b323f5f9df1da55d663b9642600ad42960c" translate="yes" xml:space="preserve">
          <source>This function may block for longer than &lt;code&gt;timeout_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">이 기능은 스케줄링 또는 리소스 경합 지연으로 인해 &lt;code&gt;timeout_duration&lt;/code&gt; 보다 오래 차단 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88aa144342c719b2d0cf02f7ae6cd001dc8b8b1c" translate="yes" xml:space="preserve">
          <source>This function may implement selection sampling or reservoir sampling.</source>
          <target state="translated">이 기능은 선택 샘플링 또는 저장소 샘플링을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6b6f1463d12ffb2bc42127132a8ac643fc238fe" translate="yes" xml:space="preserve">
          <source>This function may not be thread-safe.</source>
          <target state="translated">이 기능은 스레드로부터 안전하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4a88b9d5b7b6f8931799bf82d9c71dd06343e4a" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;std::setvbuf&lt;/code&gt;).</source>
          <target state="translated">이 함수는 &lt;code&gt;stream&lt;/code&gt; 이 열린 파일과 연결된 후에 만 가능 하지만 &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;std::setvbuf&lt;/code&gt; 대한 호출 실패 이외의 다른 작업 전에 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19731f6b76843a49446fd5784cfb942c7dfca160" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;std::setbuf&lt;/code&gt;/&lt;code&gt;std::setvbuf&lt;/code&gt;).</source>
          <target state="translated">이 함수는 &lt;code&gt;stream&lt;/code&gt; 이 열린 파일과 연결된 후에 만 가능 하지만 &lt;code&gt;std::setbuf&lt;/code&gt; / &lt;code&gt;std::setvbuf&lt;/code&gt; 대한 호출 실패 이외의 다른 작업 전에 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="717983186dc4c6865ae3eed7bfe5f5461be1682a" translate="yes" xml:space="preserve">
          <source>This function moves the &lt;code&gt;src&lt;/code&gt; pointer to the end of the converted multibyte string. This doesn't happen if &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;src&lt;/code&gt; 포인터를 변환 된 멀티 바이트 문자열의 끝으로 이동 합니다. &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 경우에는 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="53568c58dccc50911b4df0d8fe32be0fd89e385d" translate="yes" xml:space="preserve">
          <source>This function never modifies the file, only the get area of the in-memory buffer.</source>
          <target state="translated">이 함수는 파일을 수정하지 않고 인 메모리 버퍼의 가져 오기 영역 만 수정합니다.</target>
        </trans-unit>
        <trans-unit id="a3149df38d014eb7ad815af8ec580ac7ae565936" translate="yes" xml:space="preserve">
          <source>This function object provides owner-based (as opposed to value-based) mixed-type ordering of both &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;. The order is such that two smart pointers compare equivalent only if they are both empty or if they share ownership, even if the values of the raw pointers obtained by &lt;code&gt;get()&lt;/code&gt; are different (e.g. because they point at different subobjects within the same object).</source>
          <target state="translated">이 함수 객체는 &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 소유자 기반 (값 기반이 아닌) 혼합 유형 순서를 제공 합니다. 순서는 두 스마트 포인터가 &lt;code&gt;get()&lt;/code&gt; 의해 얻은 원시 포인터의 값 이 다른 경우에도 (예 : 동일한 오브젝트 내에서 다른 하위 오브젝트를 가리 키기 때문에 ) 비어 있거나 소유권을 공유하는 경우에만 동등하게 비교 합니다. .</target>
        </trans-unit>
        <trans-unit id="501340bd50fbe27100db1419cc8b73a966d53dac" translate="yes" xml:space="preserve">
          <source>This function only reports the stream state as reported by the most recent I/O operation, it does not examine the associated data source. For example, if the most recent I/O was a &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt;, which returned the last byte of a file, &lt;code&gt;std::feof&lt;/code&gt; returns zero. The next &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; fails and changes the stream state to</source>
          <target state="translated">이 기능은 가장 최근의 I / O 작업에서보고 된 스트림 상태 만보고하며 연결된 데이터 소스는 검사하지 않습니다. 예를 들어, 가장 최근의 I / O가 &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; 이고 파일의 마지막 바이트를 리턴 한 경우 &lt;code&gt;std::feof&lt;/code&gt; 는 0을 리턴합니다. 다음 &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; 가 실패하고 스트림 상태가</target>
        </trans-unit>
        <trans-unit id="7ad9af23b2df5c7bd59daf117807cb419335155c" translate="yes" xml:space="preserve">
          <source>This function only reports the stream state as set by the most recent I/O operation; it does not examine the associated data source. For example, if the most recent I/O was a &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; which returned the last byte of a file, &lt;code&gt;eof()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. The next &lt;code&gt;get()&lt;/code&gt; fails to read anything and sets the &lt;code&gt;eofbit&lt;/code&gt;. Only then does &lt;code&gt;eof()&lt;/code&gt; return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 기능은 가장 최근의 I / O 작업으로 설정된 스트림 상태 만보고합니다. 연관된 데이터 소스를 검사하지 않습니다. 예를 들어, 가장 최근의 I / O가 파일의 마지막 바이트를 리턴 한 &lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;code&gt;eof()&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 . 다음 &lt;code&gt;get()&lt;/code&gt; 은 아무것도 읽지 못하고 &lt;code&gt;eofbit&lt;/code&gt; 를 설정 합니다 . 그런 다음에 만 &lt;code&gt;eof()&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="982c99a7d72d510dc31dfb3379380b9b994f3b5b" translate="yes" xml:space="preserve">
          <source>This function reads &lt;a href=&quot;../../language/objects&quot;&gt;object representations&lt;/a&gt;, not the object values, and is typically only meaningful for trivially-copyable objects with no padding. For example, &lt;code&gt;memcmp()&lt;/code&gt; between two objects of type &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; will not compare their contents, and &lt;code&gt;memcmp()&lt;/code&gt; between two objects of type &lt;code&gt;struct{char c; int n;}&lt;/code&gt; will compare the padding bytes whose values may differ when the values of &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are the same.</source>
          <target state="translated">이 함수 는 객체 값이 아닌 &lt;a href=&quot;../../language/objects&quot;&gt;객체 표현을&lt;/a&gt; 읽고 일반적으로 패딩이없는 사소하게 복사 가능한 객체에만 의미가 있습니다. 예를 들어, &lt;code&gt;memcmp()&lt;/code&gt; 형의 두 개체 사이의 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 내용을 비교하지 않으며, &lt;code&gt;memcmp()&lt;/code&gt; 형의 두 개체 사이의 &lt;code&gt;struct{char c; int n;}&lt;/code&gt; 은 &lt;code&gt;c&lt;/code&gt; 와 &lt;code&gt;n&lt;/code&gt; 의 값이 같을 때 값이 다를 수있는 패딩 바이트를 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="3b2572fd11a91d196e72bf228b8fdec17f7a295e" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;true&lt;/code&gt; immediately after construction or an increment. Recursion can be disabled via &lt;code&gt;&lt;a href=&quot;disable_recursion_pending&quot;&gt;disable_recursion_pending()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 생성 또는 증분 직후에 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . &lt;code&gt;&lt;a href=&quot;disable_recursion_pending&quot;&gt;disable_recursion_pending()&lt;/a&gt;&lt;/code&gt; 통해 재귀를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36528001254a3bd82486f8ac96e239eda107e919" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to static data and is not thread-safe. In addition, it modifies the static &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object which may be shared with &lt;code&gt;&lt;a href=&quot;gmtime&quot;&gt;std::gmtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;std::localtime&lt;/a&gt;&lt;/code&gt;. POSIX marks this function obsolete and recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 정적 데이터에 대한 포인터를 반환하며 스레드로부터 안전하지 않습니다. 또한 &lt;code&gt;&lt;a href=&quot;gmtime&quot;&gt;std::gmtime&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;std::localtime&lt;/a&gt;&lt;/code&gt; 과 공유 될 수 있는 정적 &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 객체를 수정합니다 . POSIX는이 기능이 더 이상 사용되지 않으며 대신 &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="b1f290d85406220b6b3adbcd72ba71618d9d4c4a" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to static data and is not thread-safe. POSIX marks this function obsolete and recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 함수는 정적 데이터에 대한 포인터를 반환하며 스레드로부터 안전하지 않습니다. POSIX는이 기능이 더 이상 사용되지 않으며 대신 &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="2c08549c92d5f75cd55b61fde267f92bfcf2bd81" translate="yes" xml:space="preserve">
          <source>This function template does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 가 모두 &lt;code&gt;true&lt;/code&gt; 가 아닌 한이 함수 템플리트는 과부하 해결에 참여하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e017cba1b1d7f0a849984253cc947eb2d5f913c0" translate="yes" xml:space="preserve">
          <source>This function template is &lt;code&gt;constexpr&lt;/code&gt; if and only if each of &lt;code&gt;To&lt;/code&gt;, &lt;code&gt;From&lt;/code&gt; and the types of all subobjects of &lt;code&gt;To&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt;:</source>
          <target state="translated">이 함수 템플릿은 각 &lt;code&gt;To&lt;/code&gt; , &lt;code&gt;From&lt;/code&gt; 및 &lt;code&gt;To&lt;/code&gt; 및 &lt;code&gt;From&lt;/code&gt; 의 모든 하위 객체 유형 인 경우에만 &lt;code&gt;constexpr&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="d23f50db250e473fa7ba998015f5ef4335528d35" translate="yes" xml:space="preserve">
          <source>This function was deprecated in C++17 and removed in C++20 because &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; is only an approximation in multithreaded environment (see Notes in &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; 는 멀티 스레드 환경에서 근사치 이므로이 함수는 C ++ 17에서 더 이상 사용되지 않고 C ++ 20에서 제거되었습니다 ( &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; 의 참고 사항 참조 ).</target>
        </trans-unit>
        <trans-unit id="c95a6c84f8a7a3d63141f96f96d764fc5141f797" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization as a shortcut to avoid having to rebind from &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt;, and having to call &lt;code&gt;allocate&lt;/code&gt;, &lt;code&gt;construct&lt;/code&gt;, and &lt;code&gt;deallocate&lt;/code&gt; individually.</source>
          <target state="translated">이 함수는 완전히 특수화 된 할당 자 &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; 와 함께 사용하기 위해 도입 되었지만 &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt; &lt;code&gt;deallocate&lt;/code&gt; 개별적으로 &lt;code&gt;allocate&lt;/code&gt; , &lt;code&gt;construct&lt;/code&gt; 및 할당 해제 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cdecbddba7a122a33bb2e1a5f3720fe34c7dff59" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization as a shortcut to avoid having to rebind from &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 완전히 특수화 된 할당 자 &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; 와 함께 사용하기 위해 도입 되었지만 &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ae120608bb11c2db86fc6eaad00ab05ea738813" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization.</source>
          <target state="translated">이 함수는 완전히 특수화 된 할당 자 &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; 와 함께 사용하기 위해 도입 되었지만 모든 전문화에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afc3c5ff95ee968755d1d67223367b55662ab586" translate="yes" xml:space="preserve">
          <source>This function's analog for byte strings is &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;std::strncpy&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">바이트 문자열에 대한이 함수의 아날로그는 &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt; 아니라 std :: &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;std::strncpy&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a2cb86dd21cb66b4b0098463876ae7c777232781" translate="yes" xml:space="preserve">
          <source>This function, if defined, is the inverse of &lt;code&gt;pointer_to&lt;/code&gt;, and exists as the customization point to be called by &lt;a href=&quot;../to_address&quot;&gt;&lt;code&gt;std::to_address&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 정의 된 경우 &lt;code&gt;pointer_to&lt;/code&gt; 의 역수이며 &lt;a href=&quot;../to_address&quot;&gt; &lt;code&gt;std::to_address&lt;/code&gt; &lt;/a&gt; 의해 호출 될 사용자 정의 지점으로 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="2345f7fbcd183e468d0ac0a235350d0b6c2895ee" translate="yes" xml:space="preserve">
          <source>This functions invalidates all pointers and references to elements in the array.</source>
          <target state="translated">이 함수는 배열의 요소에 대한 모든 포인터와 참조를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="5e4969b70b796f9ee282c9f3e8a0064ce14f7b5c" translate="yes" xml:space="preserve">
          <source>This header contains forward declarations for the &lt;a href=&quot;../io&quot;&gt;Input/output&lt;/a&gt; library.</source>
          <target state="translated">이 헤더에는 &lt;a href=&quot;../io&quot;&gt;입 / 출력&lt;/a&gt; 라이브러리에 대한 순방향 선언이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9faf08967a6670c687da4edbcf69fb38e394a6f" translate="yes" xml:space="preserve">
          <source>This header is for &lt;a href=&quot;../string/byte&quot;&gt;C-style null-terminated byte strings&lt;/a&gt;.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../string/byte&quot;&gt;C 스타일의 널 종료 바이트 문자열&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="15d0710db508b245029a9ef7a8057846c8c18ceb" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../algorithm&quot;&gt;algorithm&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../algorithm&quot;&gt;알고리즘&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="58c127bf99321a87db0770e187db96005473b488" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../atomic&quot;&gt;atomic operations&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../atomic&quot;&gt;원자 연산&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="e7de3a818aa933f4120df06f08cef712f022314a" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../chrono&quot;&gt;date and time&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../chrono&quot;&gt;날짜 및 시간&lt;/a&gt; 라이브러리 의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="7df038a6142795810cf58cc3edc5892a6604ef81" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../chrono/c&quot;&gt;C-style date and time&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../chrono/c&quot;&gt;C 스타일 날짜 및 시간&lt;/a&gt; 라이브러리의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="fc145a04217e02f635144bea666233647838e7fd" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../concepts&quot;&gt;concepts&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../concepts&quot;&gt;개념&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="920e039f9619877e9581d36218e4eb4ba48fec2f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../container&quot;&gt;container&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../container&quot;&gt;컨테이너&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="acbb3dd4e1d46d22f68d17b978a7136be93e2436" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../container&quot;&gt;containers&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../container&quot;&gt;컨테이너&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="6b732c1d1cd4791f71bccf52bcce002f80d4d61f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../error&quot;&gt;error handling&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../error&quot;&gt;오류 처리&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="d135ae9415d668b3740baa8d1c6202b3114e61db" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../filesystem&quot;&gt;filesystem support&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../filesystem&quot;&gt;파일 시스템 지원&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="a2b0a9ff42b16169188356ee975f844196e0ec79" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;Input/Output&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../io&quot;&gt;입 / 출력&lt;/a&gt; 라이브러리 의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="b25ea2a66813773c5a403aa1ec3e976f8574b721" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;Input/output&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../io&quot;&gt;입 / 출력&lt;/a&gt; 라이브러리 의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="0686693c4046ba7c301b43bc07e6f7bdc8f026ab" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;input/output&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../io&quot;&gt;입 / 출력&lt;/a&gt; 라이브러리 의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="5dc95614835592456bfaab6702f6224650e49b18" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io/c&quot;&gt;C-style input/output&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../io/c&quot;&gt;C 스타일 입 / 출력&lt;/a&gt; 라이브러리의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="741ade6dc30c88b9370c305e6f3e63644225b886" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io/manip&quot;&gt;Input/output manipulators&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../io/manip&quot;&gt;입 / 출력 조작기&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="7cb909214b55ea54c4a3636e2ff95e66a61c1e7b" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../iterator&quot;&gt;iterator&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../iterator&quot;&gt;반복자&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="09eabf0e3af531f8459c8a3e9d34d078049d494f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../locale&quot;&gt;Localization&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../locale&quot;&gt;지역화&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="e0027a344c3001e03b17fff554e048e844e18b05" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../locale&quot;&gt;localization&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../locale&quot;&gt;현지화&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="1909ccb2df983190ad8b340b81a78cddcac0bc66" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../memory&quot;&gt;dynamic memory management&lt;/a&gt; library, in particular provides &lt;a href=&quot;../memory/new&quot;&gt;low level memory management&lt;/a&gt; features.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../memory&quot;&gt;동적 메모리 관리&lt;/a&gt; 라이브러리 의 일부이며, 특히 &lt;a href=&quot;../memory/new&quot;&gt;저수준 메모리 관리&lt;/a&gt; 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="923f654a5fb3f2b4a9e337168f6734bf9fb2d4f9" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../memory&quot;&gt;dynamic memory management&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../memory&quot;&gt;동적 메모리 관리&lt;/a&gt; 라이브러리 의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="dbf3371c4bdf5d7b9e212f0bbd00a12907e1875c" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric&quot;&gt;numeric&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../numeric&quot;&gt;숫자&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="83d799881dc970620d81655aaa5b6c445cc22101" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../numeric/fenv&quot;&gt;부동 소수점 환경&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="5ec3ff74347947b9a2d2ce7512f774f5d52354a7" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/random&quot;&gt;pseudo-random number generation&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../numeric/random&quot;&gt;의사 난수 생성&lt;/a&gt; 라이브러리의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="732e0c7c47f9d69b203e65c610a0bfd158dff524" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/ratio&quot;&gt;compile-time rational arithmetic&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../numeric/ratio&quot;&gt;컴파일 타임 합리적인 산술&lt;/a&gt; 라이브러리의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="c1ad47862381ddb91c08db8090600c5d4bf4e4dc" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../ranges&quot;&gt;ranges&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../ranges&quot;&gt;범위&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="d97fc3d50637471b41b3efb43e5a6b0e3a2b4a01" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../regex&quot;&gt;regular expressions&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../regex&quot;&gt;정규식&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="a2342c5c0987e5fec030e1218936937ec44df653" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string&quot;&gt;strings&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../string&quot;&gt;문자열&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="92a5be8272a47414f0e0bdc904667ee202af3267" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/byte&quot;&gt;null-terminated byte strings&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../string/byte&quot;&gt;널 종료 바이트 문자열&lt;/a&gt; 라이브러리의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="15b12e7c5f34f001bead642c260ad11a6ffaa39d" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/multibyte&quot;&gt;null-terminated multibyte strings&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../string/multibyte&quot;&gt;널 종료 멀티 바이트 문자열&lt;/a&gt; 라이브러리의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="2c42908621e154cf0ec843b46350efa2d0035aee" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/wide&quot;&gt;C-style null-terminated wide strings&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../string/wide&quot;&gt;C 스타일 널 종료 와이드 문자열&lt;/a&gt; 라이브러리의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="1fa75679068a99053300a010d141f6d8edb54561" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../thread&quot;&gt;thread support&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../thread&quot;&gt;스레드 지원&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="5d0c64faa54ec66b25a58a11c78064009bdd8b01" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library, in particular it's part of the &lt;a href=&quot;../types/climits&quot;&gt;C numeric limits interface&lt;/a&gt;.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../types&quot;&gt;유형 지원&lt;/a&gt; 라이브러리의 일부이며, 특히 &lt;a href=&quot;../types/climits&quot;&gt;C 숫자 제한 인터페이스&lt;/a&gt; 의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="65d3f063deae384355d6746093849a4b449165a4" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library, providing &lt;a href=&quot;../types/integer&quot;&gt;fixed width integer types&lt;/a&gt; and part of &lt;a href=&quot;../types/climits&quot;&gt;C numeric limits interface&lt;/a&gt;.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../types&quot;&gt;유형 지원&lt;/a&gt; 라이브러리의 일부이며 &lt;a href=&quot;../types/integer&quot;&gt;고정 너비 정수 유형&lt;/a&gt; 및 &lt;a href=&quot;../types/climits&quot;&gt;C 숫자 제한 인터페이스의&lt;/a&gt; 일부를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="436886a411e9e8d5ffe11352a732faef34f88757" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../types&quot;&gt;유형 지원&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="7edf0c9c8e7cef800a48133a201ddbc070132a48" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;types support&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../types&quot;&gt;유형 지원&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="58facb47ff5cf9d880e42e8852e016436ed3f78a" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility&quot;&gt;general utility&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../utility&quot;&gt;일반 유틸리티&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="31843b16c0e12afb62de520dcdac5733f6cee8c2" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility&quot;&gt;utility&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../utility&quot;&gt;유틸리티&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="b3ee827480d7d8d279e03c27c6ed6cca87cad739" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility#Language_support&quot;&gt;language support&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../utility#Language_support&quot;&gt;언어 지원&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="a4ff4d258bc17960105e2ea2601ffd3a5889df5f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility/functional&quot;&gt;function objects&lt;/a&gt; library and provides the standard &lt;a href=&quot;../utility/hash&quot;&gt;hash function&lt;/a&gt;.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../utility/functional&quot;&gt;함수 객체&lt;/a&gt; 라이브러리의 일부이며 표준 &lt;a href=&quot;../utility/hash&quot;&gt;해시 함수를&lt;/a&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9ac972c91cec61981b8a812ec6acfd57ff806586" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility/program&quot;&gt;program support&lt;/a&gt; library.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../utility/program&quot;&gt;프로그램 지원&lt;/a&gt; 라이브러리의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="e22299e67c4b7f2d10a4eb976dbfff224a6c2122" translate="yes" xml:space="preserve">
          <source>This header is part of the null-terminated &lt;a href=&quot;../string/wide&quot;&gt;wide&lt;/a&gt; and &lt;a href=&quot;../string/multibyte&quot;&gt;multibyte&lt;/a&gt; strings libraries. It also provides some &lt;a href=&quot;../io/c&quot;&gt;C-style I/O&lt;/a&gt; functions and conversion from &lt;a href=&quot;../chrono/c&quot;&gt;C-style Date&lt;/a&gt;.</source>
          <target state="translated">이 헤더는 널 종료 &lt;a href=&quot;../string/wide&quot;&gt;와이드&lt;/a&gt; 및 &lt;a href=&quot;../string/multibyte&quot;&gt;멀티 바이트&lt;/a&gt; 문자열 라이브러리의 일부입니다. 또한 일부 &lt;a href=&quot;../io/c&quot;&gt;C 스타일 I / O&lt;/a&gt; 함수 및 &lt;a href=&quot;../chrono/c&quot;&gt;C 스타일 Date&lt;/a&gt; 에서 변환을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="d0be451883776fa4f5f243412345fc9b51386469" translate="yes" xml:space="preserve">
          <source>This header provides miscellaneous utilities. Symbols defined here are used by several library components.</source>
          <target state="translated">이 헤더는 기타 유틸리티를 제공합니다. 여기에 정의 된 기호는 여러 라이브러리 구성 요소에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3d8521103b2fed33ffe104b06e729876d4b7f2c8" translate="yes" xml:space="preserve">
          <source>This header provides support for &lt;a href=&quot;../utility/variadic&quot;&gt;C-style variadic functions&lt;/a&gt;.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;../utility/variadic&quot;&gt;C 스타일의 가변 함수를&lt;/a&gt; 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="1f5444765226ce0bdb5af9dadf8c355721e6f565" translate="yes" xml:space="preserve">
          <source>This header supplies implementation-dependent information about the standard library (such as implementation-specific library version macros).</source>
          <target state="translated">이 헤더는 표준 라이브러리에 대한 구현 종속 정보 (예 : 구현 특정 라이브러리 버전 매크로)를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e3d2a98c9481a36d1f279d320f5b70a26a7e3330" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="9a392d9aa2ebe01e48b3d01961d845f5d0588e04" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="21d14ed988bc023e0af2e53864603e6cda2885be" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="68c78f91644f281b447ad60cdbb1634c09a9119a" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="02e483f5fd629df3b87fff596e49a80d8b8c0425" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="e6e03bbb8695dbcceecc16e98c0e964b5fefd852" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="d59783125b891e429043f2f2d5f576fd72a06c1c" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="02fccbdf35494b28df2accdc8d41b5a89580c3c0" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="db14ba2bad874c7dde2374ac32527f2c381efc33" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="53af078bd74b84f0423e1e9211b917adea77b920" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="4fc6197b328bad98f05fff68010e58025c14a9b1" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="98d8ce7d2ea217c30464e6a8895e55e50e6eb6dd" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="4db152ded5e9f8b82696d238d20533a05044bdc8" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="dbf2ebc0d4f0372f0d23dcfc1ff48e2cc5e172fa" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="552c8fb5c454bd957020620ff32c98f913c6ec6f" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="f1fc778831b537c9627fb3177ad740d51c764464" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="ea55cad81c5a499ab61c2f336f793e79c2cde22b" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="c4e4679e2a1edfcea3588f047e41db14f9335c2e" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="b100c9fc2e0568f0798665b7418667c38edba953" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="f9724180e3c20c4e3ccde319664bad3907db8ef2" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="6d57c16a998701ee531191c284ccfc0598fb9ad8" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="aeb4dad38844729f6a773adfa6b26a2500e3724e" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="78466c124900e096d16d9eac15396f90464c889b" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="1bc1e66e0693def74a913c9f83e9fd4b6579b986" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="a2e4ff735f64305108a77807fb191c4cc62d9e14" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="16d7a74374a4accebff96ae1f6f2de097d3b0cae" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 헤더는 원래 C 표준 라이브러리에 &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="aedb64fc9e75ef3b36a2ef43e03fc20db3e03e5b" translate="yes" xml:space="preserve">
          <source>This holds for every objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; that are not aliases of one another.</source>
          <target state="translated">이것은 서로의 별칭이 아닌 모든 객체 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 에 대해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="05ebbbf417474068cc1404af21d2b363f30ea1c1" translate="yes" xml:space="preserve">
          <source>This implies that the class has no &lt;a href=&quot;../language/virtual&quot;&gt;virtual functions&lt;/a&gt; or &lt;a href=&quot;../language/derived_class#Virtual_base_classes&quot;&gt;virtual base classes&lt;/a&gt;.</source>
          <target state="translated">이것은 클래스에 &lt;a href=&quot;../language/virtual&quot;&gt;가상 함수&lt;/a&gt; 나 &lt;a href=&quot;../language/derived_class#Virtual_base_classes&quot;&gt;가상 기본 클래스&lt;/a&gt; 가 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="2f0ae52b3b410d1e9be7d3f883c6f57fc4873c3a" translate="yes" xml:space="preserve">
          <source>This includes &lt;a href=&quot;type-id&quot;&gt;integral types&lt;/a&gt;, &lt;a href=&quot;pointer&quot;&gt;pointer types&lt;/a&gt;, &lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;pointer to member type&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, as well as enumeration types with no custom &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; overload, but excludes floating-point types.</source>
          <target state="translated">여기에는 &lt;a href=&quot;type-id&quot;&gt;정수 유형&lt;/a&gt; , &lt;a href=&quot;pointer&quot;&gt;포인터 유형&lt;/a&gt; , &lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;멤버 &lt;/a&gt;유형 에 대한 포인터 , &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 및 사용자 정의 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 과부하 가없는 열거 유형이 포함 되지만 부동 소수점 유형은 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="d9b2e0a6f64a6667926bbe46e5290f95959e8907" translate="yes" xml:space="preserve">
          <source>This information is provided via specializations of the &lt;code&gt;numeric_limits&lt;/code&gt; template. The standard library makes available specializations for all arithmetic types:</source>
          <target state="translated">이 정보는 &lt;code&gt;numeric_limits&lt;/code&gt; 템플리트의 전문화를 통해 제공됩니다 . 표준 라이브러리는 모든 산술 유형에 대한 전문화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="30fa8f162edae84e00655c850b76032946d786f6" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;V&lt;/code&gt; models &lt;a href=&quot;bidirectionalrange&quot;&gt;&lt;code&gt;BidirectionalRange&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;V&lt;/code&gt; models &lt;a href=&quot;forwardrange&quot;&gt;&lt;code&gt;ForwardRange&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">이것은이다 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;BidirectionalIterator&lt;/code&gt; &lt;/a&gt; 의 경우 &lt;code&gt;V&lt;/code&gt; 의 모델 &lt;a href=&quot;bidirectionalrange&quot;&gt; &lt;code&gt;BidirectionalRange&lt;/code&gt; &lt;/a&gt; 하는 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;ForwardIterator&lt;/code&gt; &lt;/a&gt; 의 경우 &lt;code&gt;V&lt;/code&gt; 의 모델 &lt;a href=&quot;forwardrange&quot;&gt; &lt;code&gt;ForwardRange&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;InputIterator&lt;/code&gt; &lt;/a&gt; 달리.</target>
        </trans-unit>
        <trans-unit id="8b29d4dc98b35c7b6aae2a923e6c330c4c737570" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models _Advanceable, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models _Decrementable, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Incrementable&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Incrementable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">이것은이다 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;RandomAccessIterator&lt;/code&gt; &lt;/a&gt; 경우 &lt;code&gt;W&lt;/code&gt; 모델 _Advanceable하는 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;BidirectionalIterator&lt;/code&gt; &lt;/a&gt; 경우 &lt;code&gt;W&lt;/code&gt; 모델 _Decrementable하는 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;ForwardIterator&lt;/code&gt; &lt;/a&gt; 경우 &lt;code&gt;W&lt;/code&gt; 모델 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Incrementable&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Incrementable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;InputIterator&lt;/code&gt; &lt;/a&gt; 달리.</target>
        </trans-unit>
        <trans-unit id="ab311fc847c477a15d5b1d9860db2b6b4cc68c90" translate="yes" xml:space="preserve">
          <source>This is a copy of the the private mutable &lt;code&gt;weak_ptr&lt;/code&gt; member that is part of &lt;code&gt;enable_shared_from_this&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;enable_shared_from_this&lt;/code&gt; 의 일부인 private mutable &lt;code&gt;weak_ptr&lt;/code&gt; 멤버 의 사본입니다 .</target>
        </trans-unit>
        <trans-unit id="9c2a70dd0a39c1457e77f347c24e87c6d5cad7cb" translate="yes" xml:space="preserve">
          <source>This is a list of reserved keywords in C++. Since they are used by the language, these keywords are not available for re-definition or overloading.</source>
          <target state="translated">C ++에서 예약 된 키워드 목록입니다. 언어에서 사용되므로 이러한 키워드는 재정의 나 과부하에 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="317fe1d241fce7e8d40b91008c64f80e35d56f6c" translate="yes" xml:space="preserve">
          <source>This is a low-level data structure; typical conversions from &lt;code&gt;local_time&lt;/code&gt; to &lt;code&gt;sys_time&lt;/code&gt; will use it implicitly rather than explicitly.</source>
          <target state="translated">이것은 저수준 데이터 구조입니다. 에서 전형적인 변환 &lt;code&gt;local_time&lt;/code&gt; 에 &lt;code&gt;sys_time&lt;/code&gt; 명시 적으로보다 암시가 아니라 그것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="06fb932be30caede5a481a8189299e404a6d4974" translate="yes" xml:space="preserve">
          <source>This is a reference of the core C++ language constructs.</source>
          <target state="translated">이것은 핵심 C ++ 언어 구문에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="e31b548ee1fbca7fa6d3494affb746a0a1a2457c" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the largest value representable by the type &lt;code&gt;std::size_t&lt;/code&gt;, used as the return type of &lt;code&gt;index()&lt;/code&gt; when &lt;code&gt;valueless_by_exception()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::size_t&lt;/code&gt; 유형으로 표시 할 수있는 가장 큰 값과 동일한 특수 값으로 &lt;code&gt;valueless_by_exception()&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 일 때 &lt;code&gt;index()&lt;/code&gt; 의 리턴 유형으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a39c0c855473751858895d7068c8ca7b082d5f62" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the maximum value representable by the type &lt;code&gt;size_type&lt;/code&gt;. The exact meaning depends on context, but it is generally used either as end of string indicator by the functions that expect a string index or as the error indicator by the functions that return a string index.</source>
          <target state="translated">&lt;code&gt;size_type&lt;/code&gt; 유형으로 표시 할 수있는 최대 값과 동일한 특수 값 입니다. 정확한 의미는 컨텍스트에 따라 다르지만 일반적으로 문자열 인덱스를 예상하는 함수의 문자열 끝 표시기 또는 문자열 인덱스를 반환하는 함수의 오류 표시기로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef208e1bc26501dbfeecb667b7796cbd9eef4a6" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the maximum value representable by the type &lt;code&gt;size_type&lt;/code&gt;. The exact meaning depends on context, but it is generally used either as end of view indicator by the functions that expect a view index or as the error indicator by the functions that return a view index.</source>
          <target state="translated">이것은 &lt;code&gt;size_type&lt;/code&gt; 유형으로 표시 할 수있는 최대 값과 동일한 특수 값 입니다. 정확한 의미는 컨텍스트에 따라 다르지만 일반적으로 뷰 인덱스를 예상하는 함수의 뷰 종료 표시기 또는 뷰 인덱스를 반환하는 함수의 오류 표시기로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d9f89f3207c56d0f6ab075de354388d63d28553" translate="yes" xml:space="preserve">
          <source>This is a specialized allocator-aware container. It can only be default created, obtained from &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt;, or modified by &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt;. Because &lt;code&gt;std::match_results&lt;/code&gt; holds &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;es, each of which is a pair of iterators into the original character sequence that was matched, it's undefined behavior to examine &lt;code&gt;std::match_results&lt;/code&gt; if the original character sequence was destroyed or iterators to it were invalidated for other reasons.</source>
          <target state="translated">특수 할당 자 인식 컨테이너입니다. &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; 에서 가져 오거나 &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; 수정하여 기본값 만 만들 수 있습니다 . 왜냐하면 &lt;code&gt;std::match_results&lt;/code&gt; 보유 &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; ES, 일치 된 일본어 문자 시퀀스로 반복자 쌍 각각, 그 조사하기 정의되지 않은 동작의 &lt;code&gt;std::match_results&lt;/code&gt; 말하자면 원래 문자 시퀀스가 파괴 또는 반복자되었는지 다른 이유로 무효화되었습니다.</target>
        </trans-unit>
        <trans-unit id="dcbd4929cfc88985415e596c60e165a57a093570" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::fixed&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::scientific&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이는 I / O 조절기는 그것과 같은 식으로 호출 될 수있다 &lt;code&gt;out &amp;lt;&amp;lt; std::fixed&lt;/code&gt; 임의위한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 또는 식과 같은 &lt;code&gt;in &amp;gt;&amp;gt; std::scientific&lt;/code&gt; 임의 대 &lt;code&gt;in&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="937bf19df4c0af79385dda35f013197f369e8f37" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::noskipws&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::noskipws&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이는 I / O 조절기는 그것과 같은 식으로 호출 될 수있다 &lt;code&gt;out &amp;lt;&amp;lt; std::noskipws&lt;/code&gt; 임의위한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 등 또는 식 &lt;code&gt;in &amp;gt;&amp;gt; std::noskipws&lt;/code&gt; 임의위한 &lt;code&gt;in&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="b42315a6cd8a7f333df8749952b733651d2fec90" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showbase&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showbase&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이는 I / O 조절기는 그것과 같은 식으로 호출 할 수도있다 &lt;code&gt;out &amp;lt;&amp;lt; std::showbase&lt;/code&gt; 임의위한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 또는 식 같은 &lt;code&gt;in &amp;gt;&amp;gt; std::showbase&lt;/code&gt; 임의위한 &lt;code&gt;in&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="70463fd9c90aded7947bc0ce3158695492cf938d" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showpoint&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showpoint&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이는 I / O 조절기는 그것과 같은 식으로 호출 할 수도있다 &lt;code&gt;out &amp;lt;&amp;lt; std::showpoint&lt;/code&gt; 임의위한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 또는와 같은 식 &lt;code&gt;in &amp;gt;&amp;gt; std::showpoint&lt;/code&gt; 모든 대 &lt;code&gt;in&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf76b611f62f218dd5340fb19c1a0b0493038e0e" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showpos&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showpos&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이는 I / O 조절기는 그것과 같은 식으로 호출 될 수있다 &lt;code&gt;out &amp;lt;&amp;lt; std::showpos&lt;/code&gt; 임의위한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 등 또는 식 &lt;code&gt;in &amp;gt;&amp;gt; std::showpos&lt;/code&gt; 임의위한 &lt;code&gt;in&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b963cb12fe265e17a4ede1e827c0c6875636dad" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::unitbuf&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::unitbuf&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이는 I / O 조절기는 그것과 같은 식으로 호출 될 수있다 &lt;code&gt;out &amp;lt;&amp;lt; std::unitbuf&lt;/code&gt; 대한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 또는 식 등으로 &lt;code&gt;in &amp;gt;&amp;gt; std::unitbuf&lt;/code&gt; 모든 대 &lt;code&gt;in&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc0de5a017268c93f9adb1760286b7389369587a" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::uppercase&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::uppercase&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은, 그것과 같은 식을 가진 I / O 매니퓰레이터 호출 할 수있다 &lt;code&gt;out &amp;lt;&amp;lt; std::uppercase&lt;/code&gt; 대한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 또는 식 등으로 &lt;code&gt;in &amp;gt;&amp;gt; std::uppercase&lt;/code&gt; 모든 대 &lt;code&gt;in&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="daf2205ff27f5d190edd20850443509692eb70e0" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator. It may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::hex&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::hex&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 I / O 조작기입니다. 그것과 같은 식으로 호출 할 수 &lt;code&gt;out &amp;lt;&amp;lt; std::hex&lt;/code&gt; 임의위한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 등의 발현 또는과 &lt;code&gt;in &amp;gt;&amp;gt; std::hex&lt;/code&gt; 어떤을위한 &lt;code&gt;in&lt;/code&gt; 유형의 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9f3502e7e7df95e12c9da2ae171edd9ba6a04db" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator. It may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::left&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::left&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 I / O 조작기입니다. 그것과 같은 식으로 호출 할 수 &lt;code&gt;out &amp;lt;&amp;lt; std::left&lt;/code&gt; 있는 위해 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 또는 식 등 &lt;code&gt;in &amp;gt;&amp;gt; std::left&lt;/code&gt; 임의위한 &lt;code&gt;in&lt;/code&gt; 유형의 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c0b02e3721ebe7f5ac3c4b5ffc6c0f2d28f4fc9" translate="yes" xml:space="preserve">
          <source>This is an N:M conversion facet, and cannot be used with &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; (which only permits 1:N conversions, such as UTF-32/UTF-8, between the internal and the external encodings). This facet can be used with &lt;code&gt;&lt;a href=&quot;wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 N : M 변환 패싯이며 &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 와 함께 사용할 수 없습니다 (내부 및 외부 인코딩간에 UTF-32 / UTF-8과 같은 1 : N 변환 만 허용 함). 이 패싯은 &lt;code&gt;&lt;a href=&quot;wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt; 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f532dd6dda7ce4e7fef9024ca6a90c38fdddd97" translate="yes" xml:space="preserve">
          <source>This is an input-only I/O manipulator, it may be called with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::ws&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은, 그것과 같은 식으로 호출 할 수있는 입력 전용 I / O 매니퓰레이터이다 &lt;code&gt;in &amp;gt;&amp;gt; std::ws&lt;/code&gt; 어떤 용 &lt;code&gt;in&lt;/code&gt; 형을 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e42acc2eabf231ad6ab330a8662f12700cd267a5" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::emit_on_flush&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은은과 같은 식으로 호출 될 수 있고, 출력 - 전용 I / O 매니퓰레이터이다 &lt;code&gt;out &amp;lt;&amp;lt; std::emit_on_flush&lt;/code&gt; 임의위한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60e12fb0d661bde8d9b081c1cd879d866b874d0f" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::endl&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은은과 같은 식으로 호출 될 수 있고, 출력 - 전용 I / O 매니퓰레이터이다 &lt;code&gt;out &amp;lt;&amp;lt; std::endl&lt;/code&gt; 임의위한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="651708b37cd7ae8cdbb511a6453c7ac66edb7063" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::ends&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은은과 같은 식으로 호출 될 수 있고, 출력 - 전용 I / O 매니퓰레이터이다 &lt;code&gt;out &amp;lt;&amp;lt; std::ends&lt;/code&gt; 임의위한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb0b93b12bb860d769cac7587fe1bddc043d0e17" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::flush&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은은과 같은 식으로 호출 될 수 있고, 출력 - 전용 I / O 매니퓰레이터이다 &lt;code&gt;out &amp;lt;&amp;lt; std::flush&lt;/code&gt; 임의위한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="297f17cae564feba63e3617363eb17ca7ff29374" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::flush_emit&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은은과 같은 식으로 호출 될 수 있고, 출력 - 전용 I / O 매니퓰레이터이다 &lt;code&gt;out &amp;lt;&amp;lt; std::flush_emit&lt;/code&gt; 임의위한 &lt;code&gt;out&lt;/code&gt; 형의 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="042aa022f3538e0380d9238f1617babc4f91044d" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; 및 &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; 를 호출하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d1a687deef64a2de24aab2940536db537dc7c30" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; 및 &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; 를 호출하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8519863f445ff4dc4073c63885010fc835c9d17f" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; 및 &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; 를 호출하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="36ff5f6b7bbdd8db83afcceb063e1cc859a416c7" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; 및 &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; 를 호출하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="82ad146be2cb4f18f794320cb99236e3f0e5a7de" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; 및 &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; 를 호출하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="786b3029313db82a7b7425ea04d749d77cb88554" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; 및 &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; 를 호출하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="acd8409ce8140988c0f9cd5273c17f072a8e1133" translate="yes" xml:space="preserve">
          <source>This is no longer allowed in C++17. Instead the array form &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; should be used.</source>
          <target state="translated">C ++ 17에서는 더 이상 사용할 수 없습니다. 대신 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; 형식의 배열을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="873c5086291117573f8d6d6edce6a8a27dcea191" translate="yes" xml:space="preserve">
          <source>This is the case only for futures that were not default-constructed or moved from (i.e. returned by &lt;code&gt;&lt;a href=&quot;../promise/get_future&quot;&gt;std::promise::get_future()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../packaged_task/get_future&quot;&gt;std::packaged_task::get_future()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async()&lt;/a&gt;&lt;/code&gt;) until the first time &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;share&quot;&gt;share()&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">이 내용은 기본 - 건설 또는에서 이동하지 않은 선물의 경우 (즉,은에 의해 반환 된 &lt;code&gt;&lt;a href=&quot;../promise/get_future&quot;&gt;std::promise::get_future()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../packaged_task/get_future&quot;&gt;std::packaged_task::get_future()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async()&lt;/a&gt;&lt;/code&gt; ) 처음 할 때까지 시간 &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;share&quot;&gt;share()&lt;/a&gt;&lt;/code&gt; 호출된다.</target>
        </trans-unit>
        <trans-unit id="cf0f969d26a72355354c117d383b2d725eed3830" translate="yes" xml:space="preserve">
          <source>This is the case only for futures that were not default-constructed or moved from. Unlike &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::shared_future&lt;/code&gt;'s shared state is not invalidated when &lt;code&gt;get()&lt;/code&gt; is called.</source>
          <target state="translated">이것은 기본적으로 구성되거나 이전되지 않은 선물의 경우에만 해당됩니다. 달리 &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::shared_future&lt;/code&gt; 의 공유 상태가 될 때 무효화되지 &lt;code&gt;get()&lt;/code&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="654479f728093b995df666411bdb28aa8834e6ea" translate="yes" xml:space="preserve">
          <source>This is the class returned by the &lt;a href=&quot;../language/typeid&quot;&gt; typeid&lt;/a&gt; operator.</source>
          <target state="translated">이것은 &lt;a href=&quot;../language/typeid&quot;&gt;typeid&lt;/a&gt; 연산자가 반환 한 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="a54fb420dbec256007f5b5fe39b66f1e973e225c" translate="yes" xml:space="preserve">
          <source>This is the class returned by the &lt;a href=&quot;language/typeid&quot;&gt; typeid&lt;/a&gt; operator.</source>
          <target state="translated">이것은 &lt;a href=&quot;language/typeid&quot;&gt;typeid&lt;/a&gt; 연산자가 반환 한 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="b68e57b066a7bc6709ae7f2c462030b2b3f61772" translate="yes" xml:space="preserve">
          <source>This is the continuous counterpart of &lt;code&gt;&lt;a href=&quot;geometric_distribution&quot;&gt;std::geometric_distribution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;geometric_distribution&quot;&gt;std::geometric_distribution&lt;/a&gt;&lt;/code&gt; 의 연속적인 대응입니다 .</target>
        </trans-unit>
        <trans-unit id="4bd023e111f5d2be5d722aa1cd31d0bb87464c42" translate="yes" xml:space="preserve">
          <source>This is the initialization performed when a variable is constructed with an empty initializer.</source>
          <target state="translated">이것은 빈 이니셜 라이저로 변수를 구성 할 때 수행되는 초기화입니다.</target>
        </trans-unit>
        <trans-unit id="e592a74f67ac1f9613e037ec54f2110302e91afd" translate="yes" xml:space="preserve">
          <source>This is the initialization performed when a variable is constructed with no initializer.</source>
          <target state="translated">초기화자가없는 변수가 생성 될 때 수행되는 초기화입니다.</target>
        </trans-unit>
        <trans-unit id="df01ca6b36b691a562048440349e8dc25830ccb7" translate="yes" xml:space="preserve">
          <source>This is the iterator returned by member functions &lt;code&gt;rbegin()&lt;/code&gt; and &lt;code&gt;rend()&lt;/code&gt; of the standard library containers.</source>
          <target state="translated">표준 라이브러리 컨테이너의 멤버 함수 &lt;code&gt;rbegin()&lt;/code&gt; 및 &lt;code&gt;rend()&lt;/code&gt; 에 의해 리턴되는 반복자 입니다.</target>
        </trans-unit>
        <trans-unit id="f5ad9a77cced8620a8dd7901ec2fb07df1c2718e" translate="yes" xml:space="preserve">
          <source>This is the only publicly accessible and defined constructor.</source>
          <target state="translated">이것은 공개적으로 액세스 가능하고 정의 된 유일한 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="678d1fe5005da438d1e76e438f6b694064724ab0" translate="yes" xml:space="preserve">
          <source>This is the only way to initialize &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to a definite value: the value held after any other initialization is unspecified.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 를 명확한 값 으로 초기화하는 유일한 방법 입니다. 다른 초기화 후 보유 된 값은 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="812af2a36c3f95774b9b7221df53591bbffef4a8" translate="yes" xml:space="preserve">
          <source>This is typically possible for the characters from the ASCII character set, since most multibyte encodings (such as UTF-8) use single bytes to encode those characters.</source>
          <target state="translated">UTF-8과 같은 대부분의 멀티 바이트 인코딩은 단일 문자를 사용하여 해당 문자를 인코딩하므로 일반적으로 ASCII 문자 집합의 문자에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4d2e82e79a4c00e49cbeb6cd456e401a3f7c67b6" translate="yes" xml:space="preserve">
          <source>This is used to capture move-only types with a capture such as &lt;code&gt;x = std::move(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x = std::move(x)&lt;/code&gt; 와 같은 캡처로 이동 전용 유형을 캡처하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0d03b82ce1e09a94b53a9663441cf142803eed2e" translate="yes" xml:space="preserve">
          <source>This is used, for example, by &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt;, which may have to allocate new storage and then move or copy elements from old storage to new storage. If an exception occurs during this operation, &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; undoes everything it did to this point, which is only possible if &lt;code&gt;std::move_if_noexcept&lt;/code&gt; was used to decide whether to use move construction or copy construction. (unless copy constructor is not available, in which case move constructor is used either way and the strong exception guarantee may be waived).</source>
          <target state="translated">예를 들어 &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; 의해 사용됩니다. 새 저장소를 할당 한 다음 요소를 이전 저장소에서 새 저장소로 이동하거나 복사해야 할 수 있습니다. 이 작업 중에 예외가 발생하면 &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; 는이 시점까지 수행 한 모든 작업을 취소합니다. 이는 &lt;code&gt;std::move_if_noexcept&lt;/code&gt; 를 사용하여 이동 구성을 사용할지 또는 복사 구성을 사용할지를 결정하는 경우에만 가능합니다 . (복사 생성자를 사용할 수없는 경우 이동 생성자를 사용하고 강력한 예외 보증을 포기할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="65497cbcaeca38825fa3feca97f3678010e28f07" translate="yes" xml:space="preserve">
          <source>This lookup with the reversed arguments order makes it possible to write just one &lt;code&gt;operatror&amp;lt;=&amp;gt;(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;, const char*)&lt;/code&gt; to generate all comparisons between &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;const char*&lt;/code&gt;, both ways. See &lt;a href=&quot;default_comparisons&quot;&gt;default comparisons&lt;/a&gt; for more detail.</source>
          <target state="translated">인수 순서가 반대로 된이 조회는 단 하나의 &lt;code&gt;operatror&amp;lt;=&amp;gt;(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;, const char*)&lt;/code&gt; 을 작성하여 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;const char*&lt;/code&gt; 사이의 모든 비교를 생성 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;default_comparisons&quot;&gt;기본 비교&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c00bd2988f8e6fd1c69153710829dd41df339f1" translate="yes" xml:space="preserve">
          <source>This macro is primarily provided for compatibility with C; it behaves the same as the constructor of &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 매크로는 주로 C와의 호환성을 위해 제공됩니다. &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 의 생성자와 동일하게 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="69dae22caf55af4023255754b9c726f9f5527dad" translate="yes" xml:space="preserve">
          <source>This makes it possible to introduce new integer types (e.g. SafeInt) that enjoy the same existing calling conventions as their underlying integer types, even on ABIs that penalize passing/returning structures by value.</source>
          <target state="translated">따라서 통과 / 반환 구조에 값을 부과하는 ABI에서도 기본 정수 유형과 동일한 기존 호출 규칙을 사용하는 새로운 정수 유형 (예 : SafeInt)을 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fced9487368a0914863ecd65a116e588baecbc7" translate="yes" xml:space="preserve">
          <source>This makes it possible to move out of an object in scope that is no longer needed:</source>
          <target state="translated">이를 통해 더 이상 필요하지 않은 범위에서 객체를 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c4ec0eda49a5a6eec06bfb350abc5e50dec706c" translate="yes" xml:space="preserve">
          <source>This manipulator is typically used with &lt;code&gt;&lt;a href=&quot;../ostrstream&quot;&gt;std::ostrstream&lt;/a&gt;&lt;/code&gt;, when the associated output buffer needs to be null-terminated to be processed as a C string.</source>
          <target state="translated">이 조작자는 일반적으로 &lt;code&gt;&lt;a href=&quot;../ostrstream&quot;&gt;std::ostrstream&lt;/a&gt;&lt;/code&gt; 과 함께 사용되며 , 연관된 출력 버퍼를 C 문자열로 처리하기 위해 null로 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d033cddb2872a1515d402a6be03415f6aa84c5a" translate="yes" xml:space="preserve">
          <source>This manipulator may be used to produce a line of output immediately, e.g. when displaying output from a long-running process, logging activity of multiple threads or logging activity of a program that may crash unexpectedly. An explicit flush of &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; is also necessary before a call to &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt;, if the spawned process performs any screen I/O. In most other usual interactive I/O scenarios, &lt;code&gt;std::endl&lt;/code&gt; is redundant when used with &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; because any input from &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, output to &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, or program termination forces a call to &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt;. Use of &lt;code&gt;std::endl&lt;/code&gt; in place of &lt;code&gt;'\n'&lt;/code&gt;, encouraged by some sources, may significantly degrade output performance.</source>
          <target state="translated">이 조작기는 장기 실행 프로세스의 출력을 표시 할 때, 여러 스레드의 활동을 로깅하거나 예기치 않게 충돌 할 수있는 프로그램의 활동을 기록 할 때 즉시 출력 라인을 생성하는 데 사용될 수 있습니다. 생성 된 프로세스가 화면 I / O를 수행하는 경우 &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt; 호출하기 전에 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; 의 명시 적 플러시 도 필요 합니다. 대부분의 다른 일반적인 대화 형 I / O 시나리오에서, &lt;code&gt;std::endl&lt;/code&gt; IS 중복와 함께 사용하면 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; 하기 때문에 어떠한 입력 &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; , 출력 &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; , 또는 프로그램 종료 세력의 호출에 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; .flush () . &lt;code&gt;'\n'&lt;/code&gt; 대신 &lt;code&gt;std::endl&lt;/code&gt; 사용일부 소스에서 권장하는 경우 출력 성능이 크게 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4f2d1bbb43a26f1c14fa7b3e243baca9ad4d3dc" translate="yes" xml:space="preserve">
          <source>This manipulator may be used to produce an incomplete line of output immediately, e.g. when displaying output from a long-running process, logging activity of multiple threads or logging activity of a program that may crash unexpectedly. An explicit flush of &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; is also necessary before a call to &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt;, if the spawned process performs any screen I/O (a common example is &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;(&quot;pause&quot;)&lt;/code&gt; on Windows). In most other usual interactive I/O scenarios, &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; is redundant when used with &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; because any input from &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, output to &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, or program termination forces a call to &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt;.</source>
          <target state="translated">이 조작기는 예를 들어 장기 실행 프로세스의 출력을 표시 할 때, 여러 스레드의 활동을 기록하거나 예기치 않게 충돌 할 수있는 프로그램의 활동을 기록 할 때 불완전한 출력 라인을 즉시 생성하는 데 사용될 수 있습니다. 스폰 된 프로세스가 화면 I / O를 수행하는 경우 &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt; 호출하기 전에 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; 명시 적으로 플러시 해야합니다 (일반적인 예는 Windows에서 &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;(&quot;pause&quot;)&lt;/code&gt; ( &quot;pause&quot;) ). 대부분의 다른 일반적인 대화 형 I / O 시나리오에서, &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; IS 중복와 함께 사용하면 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; 하기 때문에 어떠한 입력 &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; , 출력 &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; , 또는 프로그램 종료 세력의 호출에 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; .플러시().</target>
        </trans-unit>
        <trans-unit id="b8bc45ac3ed46d59a0178ef3c27e45979eabda25" translate="yes" xml:space="preserve">
          <source>This may be used to avoid unnecessary &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; fences when the dependency chain leaves function scope (and the function does not have the &lt;code&gt;[[&lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carries_dependency&lt;/a&gt;]]&lt;/code&gt; attribute).</source>
          <target state="translated">이것은 의존성 체인이 함수 범위를 &lt;code&gt;[[&lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carries_dependency&lt;/a&gt;]]&lt;/code&gt; 때 불필요한 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; 펜스 를 피하기 위해 사용될 수 있습니다 (그리고 함수에 [[ carry_dependency ]] 속성이 없습니다).</target>
        </trans-unit>
        <trans-unit id="56eb878738bcafe0dda45a9b25b2771a66434232" translate="yes" xml:space="preserve">
          <source>This may happen if the pointer is assigned to:</source>
          <target state="translated">포인터가 다음에 할당 된 경우 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="263227da37307b0a3267455a4c633b69bc493839" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;match[i].position()&lt;/code&gt; gives the offset from the beginning of the target sequence, which is often not the same as the offset from the sequence passed in the call to &lt;code&gt;regex_search&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;match[i].position()&lt;/code&gt; 은 대상 시퀀스의 시작 부분에서 오프셋을 제공합니다. 이는 종종 &lt;code&gt;regex_search&lt;/code&gt; 호출에 전달 된 시퀀스의 오프셋과 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2cdccbba38d49dbd4067105548f38475359bb552" translate="yes" xml:space="preserve">
          <source>This means that in a conforming implementation, including this header has no effect.</source>
          <target state="translated">이는이 헤더를 포함하여 적합한 구현에서 효과가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="558bc6404fe9a7280ef6a558ff20ea8606c413a8" translate="yes" xml:space="preserve">
          <source>This means that there are no aliases in the elements and this property can be used to perform some kinds of optimization.</source>
          <target state="translated">이는 요소에 별명이없고이 특성을 사용하여 일부 최적화를 수행 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="81b15552e359daa797fa96a9d36a5f3772826f69" translate="yes" xml:space="preserve">
          <source>This mechanism makes it possible to use template operators, since there is no syntax to specify template arguments for an operator other than by re-writing it as a function call expression.</source>
          <target state="translated">이 메커니즘을 사용하면 템플릿 연산자를 함수 호출 표현식으로 다시 쓰는 것 외에 연산자에 대한 템플릿 인수를 지정하는 구문이 없으므로 템플릿 연산자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baabe2e811ea477176a6b1ba57aacf61a6c0bf94" translate="yes" xml:space="preserve">
          <source>This mechanism makes it possible to use template operators, since there is no syntax to specify template arguments for an operator other than by re-writing it as a function call expression:</source>
          <target state="translated">이 메커니즘은 템플릿 연산자를 함수 호출 표현식으로 다시 쓰는 것 외에 연산자에 대한 템플릿 인수를 지정하는 구문이 없으므로 템플릿 연산자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="631b5699cc80fd8b4a70a5399e59151e856f7a18" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the constructors of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; once the associated stream buffer is known. Until this function is called, every member function (including the destructor) of the default-constructed &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; invokes undefined behavior. Note that &lt;code&gt;basic_ios&lt;/code&gt; is a virtual base class, and therefore its constructor is not called by the constructors of those directly derived classes, which is why two-stage initialization is necessary.</source>
          <target state="translated">이 멤버 함수는 보호됩니다. 연결된 스트림 버퍼가 알려지면 파생 스트림 클래스 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 의 생성자가 호출합니다 . 이 함수가 호출 될 때까지 기본 구성 &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; 모든 멤버 함수 (소멸자를 포함) 는 정의되지 않은 동작을 호출합니다. 참고 &lt;code&gt;basic_ios&lt;/code&gt; 것은 가상 기본 클래스이므로, 생성자는 두 단계의 초기화가 필요한 이유는 바로 이러한 파생 클래스의 생성자에 의해 호출되지 않는다.</target>
        </trans-unit>
        <trans-unit id="9ff0b24c8b1bcff91c847b5b05e80e90bc1f2ed8" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the move constructors of the derived streams such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, as the final step after constructing the base class and after moving the stream buffer: only the most derived stream class knows how to correctly move the stream buffer, but &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; needs to be made aware of the stream's new location so that its public member functions can access it.</source>
          <target state="translated">이 멤버 함수는 보호됩니다. 기본 클래스를 생성 한 후 스트림 버퍼를 이동 한 후 마지막 단계 로 &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; 과 같은 파생 스트림의 이동 생성자에 의해 호출 됩니다. 가장 파생 된 스트림 만 클래스는 스트림 버퍼를 올바르게 이동하는 방법을 알고 있지만 공개 멤버 함수가 액세스 할 수 있도록 &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; 에 스트림의 새 위치를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="9c3c6a60b1284f57464c304d4f49e3141a9265a5" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the protected move constructors of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;, which, in turn, are called by the public move constructors of the further derived stream classes such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly move the associated streambuffer.</source>
          <target state="translated">이 멤버 함수는 보호됩니다. 파생 된 스트림 클래스 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 의 보호 된 이동 생성자에 의해 호출되며 , 이는 &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 와 같은 추가 파생 스트림 클래스의 공용 이동 생성자에 의해 호출됩니다. :: basic_ofstream : 연결된 스트림 버퍼 를 올바르게 이동시키는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6018aedea85c8af7152a8d08f9289d2de94a185f" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the swap member functions of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated stream buffers.</source>
          <target state="translated">이 멤버 함수는 보호됩니다. 파생 된 스트림 클래스 &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 의 스왑 멤버 함수에 의해 호출되며 관련 스트림 버퍼를 올바르게 스왑하는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="194eca0c3ce225b7c17b35f16086bbd18ea24522" translate="yes" xml:space="preserve">
          <source>This metafunction is a convenient way to leverage &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; to conditionally remove functions from &lt;a href=&quot;../language/overload_resolution&quot;&gt;overload resolution&lt;/a&gt; based on type traits and to provide separate function overloads and specializations for different type traits. &lt;code&gt;std::enable_if&lt;/code&gt; can be used as an additional function argument (not applicable to operator overloads), as a return type (not applicable to constructors and destructors), or as a class template or function template parameter.</source>
          <target state="translated">이 메타 함수는 &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; 를 활용 하여 유형 특성을 기반으로 &lt;a href=&quot;../language/overload_resolution&quot;&gt;과부하 해결&lt;/a&gt; 에서 기능을 조건부로 제거 하고 다른 유형 특성에 대해 별도의 기능 과부하 및 특수화를 제공 하는 편리한 방법 입니다. &lt;code&gt;std::enable_if&lt;/code&gt; 는 추가 함수 인수 (연산자 오버로드에는 적용되지 않음), 반환 유형 (생성자 및 소멸자에는 적용되지 않음) 또는 클래스 템플릿 또는 함수 템플릿 매개 변수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1422282434c61f7b9a780c953c50b153fde9dfb" translate="yes" xml:space="preserve">
          <source>This metafunction is used in template metaprogramming to detect ill-formed types in SFINAE context:</source>
          <target state="translated">이 메타 함수는 SFINAE 컨텍스트에서 잘못된 형식의 유형을 감지하기 위해 템플릿 메타 프로그래밍에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a68dc4a214d5a2f0c86986f5fcbb662600bbbaa" translate="yes" xml:space="preserve">
          <source>This only applies if the arithmetic is two's complement which is only required for the &lt;a href=&quot;../types/integer&quot;&gt;exact-width integer types&lt;/a&gt;. Note, however, that at the moment all platforms with a C++ compiler use two's complement arithmetic</source>
          <target state="translated">이는 산술이 2의 보수이며 &lt;a href=&quot;../types/integer&quot;&gt;정확한 너비 정수 유형&lt;/a&gt; 에만 필요한 경우에만 적용됩니다 . 그러나 현재 C ++ 컴파일러가있는 모든 플랫폼은 2의 보수 산술을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="28bba53040cc59e4ebfb5e6b23947d5f3e555523" translate="yes" xml:space="preserve">
          <source>This operation</source>
          <target state="translated">이 작업</target>
        </trans-unit>
        <trans-unit id="ee376cb133ce3fa6134bf19377f3a3fc9a03d186" translate="yes" xml:space="preserve">
          <source>This operation is commonly implemented in hardware as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;fused multiply-add&lt;/a&gt; CPU instruction. If supported by hardware, the appropriate &lt;code&gt;FP_FAST_FMA*&lt;/code&gt; macros are expected to be defined, but many implementations make use of the CPU instruction even when the macros are not defined.</source>
          <target state="translated">이 작업은 일반적으로 하드웨어에 &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;fused multiply-add&lt;/a&gt; CPU 명령 으로 구현됩니다 . 하드웨어가 지원하는 경우 적절한 &lt;code&gt;FP_FAST_FMA*&lt;/code&gt; 매크로가 정의 될 것으로 예상되지만 매크로가 정의되지 않은 경우에도 많은 구현에서 CPU 명령어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="677f69ad7dd084269c9619b79f0d75fdd900458e" translate="yes" xml:space="preserve">
          <source>This operation is stable: for equivalent elements in the two lists, the elements from &lt;code&gt;*this&lt;/code&gt; shall always precede the elements from &lt;code&gt;other&lt;/code&gt;, and the order of equivalent elements of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; does not change.</source>
          <target state="translated">이 작업은 안정적입니다. 두 목록에있는 동등한 요소의 경우 &lt;code&gt;*this&lt;/code&gt; 의 요소는 항상 &lt;code&gt;other&lt;/code&gt; 의 요소보다 우선하며 &lt;code&gt;*this&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 의 동등한 요소의 순서는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1a54e7ed923b5cbda29b41bb3cef5210c3e3c16" translate="yes" xml:space="preserve">
          <source>This operator does not check whether the optional contains a value! You can do so manually by using &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;has_value()&lt;/a&gt;&lt;/code&gt; or simply &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;operator bool()&lt;/a&gt;&lt;/code&gt;. Alternatively, if checked access is needed, &lt;code&gt;&lt;a href=&quot;value&quot;&gt;value()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;value_or&quot;&gt;value_or()&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">이 연산자는 옵션에 값이 포함되어 있는지 확인하지 않습니다! &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;has_value()&lt;/a&gt;&lt;/code&gt; 또는 단순히 &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;operator bool()&lt;/a&gt;&lt;/code&gt; 를 사용하여 수동으로 수행 할 수 있습니다 . 또는 확인 된 액세스가 필요한 경우 &lt;code&gt;&lt;a href=&quot;value&quot;&gt;value()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;value_or&quot;&gt;value_or()&lt;/a&gt;&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76837e505361cd0d1e62fe926fca10a41668aadc" translate="yes" xml:space="preserve">
          <source>This operator is declared in the namespace &lt;code&gt;std::literals::chrono_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;chrono_literals&lt;/code&gt; are inline namespaces. Access to this operator can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt;.</source>
          <target state="translated">이 연산자는 네임 스페이스 선언은 &lt;code&gt;std::literals::chrono_literals&lt;/code&gt; 모두, &lt;code&gt;literals&lt;/code&gt; 및 &lt;code&gt;chrono_literals&lt;/code&gt; 가 인라인 네임 스페이스됩니다. &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt; 및 &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt; 를 사용 하면이 연산자에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c90a4015c270f47b35bf150eaa6f8ff8b7041fe0" translate="yes" xml:space="preserve">
          <source>This operator makes it possible to use streams and functions that return references to streams as loop conditions, resulting in the idiomatic C++ input loops such as &lt;code&gt;while(stream &amp;gt;&amp;gt; value) {...}&lt;/code&gt; or &lt;code&gt;while(getline(stream, string)){...}&lt;/code&gt;. Such loops execute the loop's body only if the input operation succeeded.</source>
          <target state="translated">이 연산자를 사용하면 스트림에 대한 참조를 루프 조건으로 리턴하는 스트림 및 함수를 사용할 수 있으며 &lt;code&gt;while(stream &amp;gt;&amp;gt; value) {...}&lt;/code&gt; 또는 &lt;code&gt;while(getline(stream, string)){...}&lt;/code&gt; 과 같은 관용적 C ++ 입력 루프가 생성됩니다. {...} . 이러한 루프는 입력 작업이 성공한 경우에만 루프 본문을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="70eb80993771f43d98c8f63a162d2abf81c3b412" translate="yes" xml:space="preserve">
          <source>This order determines the order in which constraints are instantiated when checking for satisfaction.</source>
          <target state="translated">이 순서는 만족도를 확인할 때 제약 조건이 생성되는 순서를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="ebf5e8fbc6ec56b576aeb159cdeac4bba0a41f70" translate="yes" xml:space="preserve">
          <source>This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through &lt;code&gt;&lt;a href=&quot;../owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 순서는 공유 및 약한 포인터를 연관 컨테이너에서 일반적으로 &lt;code&gt;&lt;a href=&quot;../owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt; 통해 키로 사용할 수 있도록하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1a82251ba96a19d119ca9bfa58e9f2f497a9f62" translate="yes" xml:space="preserve">
          <source>This overload does not subtract the parsed offset (if any) from the parsed timestamp, unlike the &lt;code&gt;from_stream&lt;/code&gt; overloads for the &lt;code&gt;time_point&lt;/code&gt; of other clocks.</source>
          <target state="translated">다른 클럭 의 &lt;code&gt;time_point&lt;/code&gt; 에 대한 &lt;code&gt;from_stream&lt;/code&gt; 오버로드 와 달리이 오버로드 는 구문 분석 된 타임 스탬프에서 구문 분석 된 오프셋 (있는 경우)을 빼지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4bf7c4e2eb5387c99cb1a1ffeb6f0e5e88754a17" translate="yes" xml:space="preserve">
          <source>This overload doesn't participate in overload resolution if &lt;code&gt;std::unique_ptr&amp;lt;Y, Deleter&amp;gt;::pointer&lt;/code&gt; is not</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&amp;lt;Y, Deleter&amp;gt;::pointer&lt;/code&gt; 가 아닌 경우이 과부하는 과부하 해결에 참여 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc6f7584722885d728d6854cb8736855f9270a48" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (1) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">이 과부하는 &lt;code&gt;InputIt&lt;/code&gt; 이 정수 유형 인 경우 과부하 (1)와 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="1fa4602d949f8f6973ff6fea1f4b9e68fc722e4c" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (3) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; 이 정수형 인 경우이 과부하는 과부하 (3)와 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="7a8485de9a7d7bca2cd829541418ca26242baca3" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (6) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; 이 정수형 인 경우이 과부하는 과부하 (6)와 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="70e5d40a020e1e29942bf932764b7fdcf68a80bf" translate="yes" xml:space="preserve">
          <source>This overload is necessary because &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; does not have a member function &lt;code&gt;rbegin&lt;/code&gt;. No overload is needed for &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::crbegin&lt;/a&gt;&lt;/code&gt; because it is implemented in terms of &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; &lt;code&gt;rbegin&lt;/code&gt; 멤버 함수가 없으므로이 과부하가 필요 합니다. &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; 측면에서 구현되므로 &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::crbegin&lt;/a&gt;&lt;/code&gt; 에는 과부하가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ade89453e12ddb644d64137481026bf6616fd814" translate="yes" xml:space="preserve">
          <source>This overload is necessary because &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; does not have a member function &lt;code&gt;rend&lt;/code&gt;. No overload is needed for &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::crend&lt;/a&gt;&lt;/code&gt; because it is implemented in terms of &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 에 멤버 함수 &lt;code&gt;rend&lt;/code&gt; 가 없기 때문에이 과부하가 필요 합니다. &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; 관점에서 구현되므로 &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::crend&lt;/a&gt;&lt;/code&gt; 과부하가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="83116be95b91d59c09d4b41fc31292dca9c27808" translate="yes" xml:space="preserve">
          <source>This overload makes it possible to forward a result of an expression (such as function call), which may be rvalue or lvalue, as the original value category of a forwarding reference argument.</source>
          <target state="translated">이 오버로드를 통해 전달 참조 인수의 원래 값 범주로 rvalue 또는 lvalue 일 수있는 표현식 (예 : 함수 호출)의 결과를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="814368a4e79aa44fdd2b8a96b22ebf135a87ef17" translate="yes" xml:space="preserve">
          <source>This overload may be used to ignore spurious awakenings while waiting for a specific condition to become true.  Note that &lt;code&gt;lock&lt;/code&gt; must be acquired before entering this method, and it is reacquired after &lt;code&gt;wait(lock)&lt;/code&gt; exits, which means that &lt;code&gt;lock&lt;/code&gt; can be used to guard access to &lt;code&gt;pred()&lt;/code&gt;.</source>
          <target state="translated">이 과부하는 특정 조건이 충족되기를 기다리는 동안 가짜 각성을 무시하는 데 사용될 수 있습니다. 참고 &lt;code&gt;lock&lt;/code&gt; 이 방법에 들어가기 전에 취득해야하고,이 후에 재 취득되는 &lt;code&gt;wait(lock)&lt;/code&gt; 것을 의미 이탈, &lt;code&gt;lock&lt;/code&gt; 로 보호 액세스하는 데 사용할 수 &lt;code&gt;pred()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8eb3282f5afae84e29833c36cc610e1de569a0" translate="yes" xml:space="preserve">
          <source>This overload may be used to ignore spurious wakeups.</source>
          <target state="translated">이 과부하는 가짜 웨이크 업을 무시하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c7c9be7921bc5aca3e14ee52c3bb2b260dbf024" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if</source>
          <target state="translated">이 과부하는 다음과 같은 경우에만 과부하 해결에 참여합니다</target>
        </trans-unit>
        <trans-unit id="337c9fa9042558efca853cc7d8b71cfcdf68fa7c" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;Deleter&lt;/code&gt; is not a pointer type. The program is ill-formed if this constructor is selected by &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;Deleter&lt;/code&gt; 가 포인터 유형이 아닌 경우이 과부하는 과부하 해결에만 참여 합니다. 이 생성자가 &lt;a href=&quot;../../language/deduction_guide&quot;&gt;클래스 템플릿 인수 deduction에&lt;/a&gt; 의해 선택되면 프로그램이 잘못 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="bdb1577a846fa638ef9c34146d7b837c8cfaff57" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; 가 모든 &lt;code&gt;i&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 인 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="a2aee11b4d79b3a5270ceef56a825350cf5c37c2" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Compare&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Compare&amp;gt;::value&lt;/code&gt; 가 모두 &lt;code&gt;true&lt;/code&gt; 인경우이 과부하는 과부하 해결에만 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="f2c027e2ce963431b11c8b99a81bfd995a2cc23b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인경우이 과부하는 과부하 해결에만 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="687473bac79368096aa9ed3ccf13fad71a9af81b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; 이 true 인 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="1224a3aab62459562f6b5317091c0ef8684c06e6" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; qualifies as &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, to avoid ambiguity with the overload (3).</source>
          <target state="translated">이 과부하 는 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;InputIt이 &lt;/a&gt; &lt;code&gt;InputIt&lt;/code&gt; 자격이되는 경우에만 과부하 해결에 참여하여 과부하 에 대한 모호성을 피합니다 (3).</target>
        </trans-unit>
        <trans-unit id="4a089419777f0efe565129e644b4712117969f47" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; qualifies as an &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">이 오버로드는 경우에만 오버로드 확인에 참여 &lt;code&gt;InputIt&lt;/code&gt; 의 자격 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a09d792b815aa7158d605c39a17d568db1e73837" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, to avoid ambiguity with the overload (2).</source>
          <target state="translated">이 과부하 는 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;InputIt&lt;/a&gt; 이 &lt;code&gt;InputIt&lt;/code&gt; 충족시키는 경우에만 과부하 해결에 참여하여 과부하 에 대한 모호성을 피합니다 (2).</target>
        </trans-unit>
        <trans-unit id="f321cae2fd6e4fe1eb7c60fdcbc221e29351732f" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">이 오버로드는 경우에만 오버로드 확인에 참여 &lt;code&gt;InputIt&lt;/code&gt; 만족 &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84fbda8e9476b834f4eff0a23e019d728cbe538b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;N == 0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;N == 0&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인경우이 과부하는 과부하 해결에만 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="5843b6cae5eeb5b966317747e078206da1c4f50c" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;T&lt;/code&gt; is an unsigned integer type (that is, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, or an extended unsigned integer type).</source>
          <target state="translated">이 오버로드 는 &lt;code&gt;T&lt;/code&gt; 가 부호없는 정수 유형 (즉, &lt;code&gt;unsigned char&lt;/code&gt; , &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;unsigned long long&lt;/code&gt; 또는 확장 된 부호없는 정수 유형) 인 경우에만 과부하 해결에 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="c6e60dbde6c8fbc3507ef1d94ecfd0c08c022a59" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 의 전문화가 아닌 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="29384bbe452ccd42b0340a2c398a159c418dc484" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;is_move_constructible_v&amp;lt;T_i&amp;gt;&lt;/code&gt; and &lt;code&gt;is_swappable_v&amp;lt;T_i&amp;gt;&lt;/code&gt; are both true for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is_move_constructible_v&amp;lt;T_i&amp;gt;&lt;/code&gt; 및 &lt;code&gt;is_swappable_v&amp;lt;T_i&amp;gt;&lt;/code&gt; 가 &lt;code&gt;Types...&lt;/code&gt; 모든 &lt;code&gt;T_i&lt;/code&gt; 에 대해 모두 참인 경우이 과부하는 과부하 해결에만 참여 합니다 .</target>
        </trans-unit>
        <trans-unit id="dc0ee950915984baafe9981e2de7fbbd58afb03e" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;os &amp;lt;&amp;lt; p.get()&lt;/code&gt; is a valid expression.</source>
          <target state="translated">&lt;code&gt;os &amp;lt;&amp;lt; p.get()&lt;/code&gt; 이 유효한 표현식 인 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="213ea4feb3d364f895c517e5bb074dd31d585156" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof(To) == sizeof(From)&lt;/code&gt; and both &lt;code&gt;To&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt; are &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types.</source>
          <target state="translated">&lt;code&gt;sizeof(To) == sizeof(From)&lt;/code&gt; 및 &lt;code&gt;To&lt;/code&gt; 와 &lt;code&gt;From&lt;/code&gt; 이 모두 &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;간단하게 복사 가능한&lt;/a&gt; 유형 인 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="114c800d36b0c72a9adfc7fc9888fa4bbb2bb7e2" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; 가 모든 &lt;code&gt;i&lt;/code&gt; 에 대해 &lt;code&gt;true&lt;/code&gt; 인경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="47f721ed5d5ad88fd42fa2395ca7086485e17473" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 가 모두 &lt;code&gt;true&lt;/code&gt; 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="2f1425caf63dd41a44a75daddc54c5b669d9e819" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0,const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0,const U1&amp;amp;&amp;gt;::value&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; 가 모두 &lt;code&gt;true&lt;/code&gt; 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="db813f0c83ff1627df30808c046963cca19b044a" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; and &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; and &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; 이고 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우이 과부하는 과부하 해결에만 참여 합니다. 모두 &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfc7e8a0241026e6c0b8875fd31fd121edcd01be" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;typename Duration::rep&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;Duration(1) &amp;lt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;typename Duration::rep&amp;gt;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 이고 &lt;code&gt;Duration(1) &amp;lt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(1)&lt;/code&gt; 경우이 과부하는 과부하 해결에만 참여 합니다.</target>
        </trans-unit>
        <trans-unit id="bea87dfd18560dbaabd48c593a450285fb991964" translate="yes" xml:space="preserve">
          <source>This page describes the core language feature adopted for C++20. For named type requirements used in the specification of the standard library, see &lt;a href=&quot;../named_req&quot;&gt;named requirements&lt;/a&gt;. For the Concepts TS version of this feature, see &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/constraints&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 C ++ 20에 채택 된 핵심 언어 기능을 설명합니다. 표준 라이브러리 사양에 사용되는 명명 된 유형 요구 사항은 &lt;a href=&quot;../named_req&quot;&gt;명명 된 요구 사항을&lt;/a&gt; 참조하십시오 . 이 기능의 Concepts TS 버전은 &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/constraints&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="88455b072941af9e8a59177f52c213a26676d97c" translate="yes" xml:space="preserve">
          <source>This partial code fragment illustrates how &lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; can be used to avoid accessing data that depends on thread locals while those thread locals are in the process of being destructed:</source>
          <target state="translated">이 부분 코드 조각은 &lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; 를 사용하여 스레드 로컬에 의존하는 데이터에 액세스하지 않고 스레드 로컬이 파괴되는 과정을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7c5fecf341fbcf23eb1c8bab2cc52b3d4ac7b65d" translate="yes" xml:space="preserve">
          <source>This problem may be worked around using init-statement:</source>
          <target state="translated">이 문제는 init-statement를 사용하여 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fb590b83ec483a8b56a2365c3f69fb2ed4d882e" translate="yes" xml:space="preserve">
          <source>This process is called</source>
          <target state="translated">이 과정을</target>
        </trans-unit>
        <trans-unit id="a7c693f3363fc29f57e0a818f5fcc2fa68ec620d" translate="yes" xml:space="preserve">
          <source>This program determines the longest substring that is simultaneously found at the very beginning of the given string and at the very end of it, in reverse order (possibly overlapping).</source>
          <target state="translated">이 프로그램은 주어진 문자열의 맨 처음과 맨 끝에서 동시에 발견되는 가장 긴 하위 문자열을 역순으로 결정합니다 (겹칠 수 있음).</target>
        </trans-unit>
        <trans-unit id="eafef78a966daecd6d7bcd73bf31b0e1e5ad496e" translate="yes" xml:space="preserve">
          <source>This program simulates throwing 6-sided dice.</source>
          <target state="translated">이 프로그램은 6면 주사위 던지기를 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="2ea85151fe97fd5e5b0aa44d16e405ebe318a32c" translate="yes" xml:space="preserve">
          <source>This protected virtual function is called by the public functions &lt;a href=&quot;../basic_streambuf/sungetc&quot;&gt;&lt;code&gt;basic_streambuf::sungetc&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_streambuf/sputbackc&quot;&gt;&lt;code&gt;basic_streambuf::sputbackc&lt;/code&gt;&lt;/a&gt; (which, in turn, are called by &lt;a href=&quot;../basic_istream/unget&quot;&gt;&lt;code&gt;basic_istream::unget&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_istream/putback&quot;&gt;&lt;code&gt;basic_istream::putback&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 보호 된 가상 함수는 공용 함수 &lt;a href=&quot;../basic_streambuf/sungetc&quot;&gt; &lt;code&gt;basic_streambuf::sungetc&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../basic_streambuf/sputbackc&quot;&gt; &lt;code&gt;basic_streambuf::sputbackc&lt;/code&gt; &lt;/a&gt; (차례로, &lt;a href=&quot;../basic_istream/unget&quot;&gt; &lt;code&gt;basic_istream::unget&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../basic_istream/putback&quot;&gt; &lt;code&gt;basic_istream::putback&lt;/code&gt; &lt;/a&gt; 의해 호출 됨)에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="996fa56c79f2b555734e9e9593669a195ee9fc8b" translate="yes" xml:space="preserve">
          <source>This protected virtual function is called by the public functions &lt;code&gt;&lt;a href=&quot;sungetc&quot;&gt;sungetc()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sputbackc&quot;&gt;sputbackc()&lt;/a&gt;&lt;/code&gt; (which, in turn, are called by &lt;a href=&quot;../basic_istream/unget&quot;&gt;&lt;code&gt;basic_istream::unget&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_istream/putback&quot;&gt;&lt;code&gt;basic_istream::putback&lt;/code&gt;&lt;/a&gt;) when either:</source>
          <target state="translated">이 보호 된 가상 기능은 공공 기능에 의해 호출됩니다 &lt;code&gt;&lt;a href=&quot;sungetc&quot;&gt;sungetc()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;sputbackc&quot;&gt;sputbackc()&lt;/a&gt;&lt;/code&gt; (차례로 호출되는, &lt;a href=&quot;../basic_istream/unget&quot;&gt; &lt;code&gt;basic_istream::unget&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../basic_istream/putback&quot;&gt; &lt;code&gt;basic_istream::putback&lt;/code&gt; &lt;/a&gt; 경우 중 하나) :</target>
        </trans-unit>
        <trans-unit id="01f04b9a6bf8f295e5a70f9d8714851ba0b2aba1" translate="yes" xml:space="preserve">
          <source>This regenerates the hash table.</source>
          <target state="translated">해시 테이블이 재생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2062b86cfcefc181f616f82dcb480679b9c947da" translate="yes" xml:space="preserve">
          <source>This rule also appears in the C++ Core Guidelines as &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-zero&quot;&gt;C.20: If you can avoid defining default operations, do&lt;/a&gt;.</source>
          <target state="translated">이 규칙은 C ++ 핵심 지침에 &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-zero&quot;&gt;C.20&lt;/a&gt; 으로도 나타납니다 . 기본 작업을 정의하지 않으려면을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ac284d6084ae4faac12c7c88cba2efd5c565f23" translate="yes" xml:space="preserve">
          <source>This rule applies during overload resolution of function templates: When &lt;a href=&quot;function_template#Template_argument_substitution&quot;&gt;substituting&lt;/a&gt; the explicitly specified or &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced type&lt;/a&gt; for the template parameter fails, the specialization is discarded from the &lt;a href=&quot;overload_resolution&quot;&gt;overload set&lt;/a&gt; instead of causing a compile error.</source>
          <target state="translated">이 규칙은 함수 템플릿의 오버로드 확인 중에 적용됩니다 . 템플릿 매개 변수에 명시 적으로 지정되거나 &lt;a href=&quot;template_argument_deduction&quot;&gt;추론 된 유형&lt;/a&gt; 을 &lt;a href=&quot;function_template#Template_argument_substitution&quot;&gt;대체&lt;/a&gt; 하지 못하면 컴파일 오류 대신 &lt;a href=&quot;overload_resolution&quot;&gt;오버로드 세트&lt;/a&gt; 에서 전문화가 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7cbe3e2801d332154dbf0acb579c831d5324d92" translate="yes" xml:space="preserve">
          <source>This rule enables type-based alias analysis, in which a compiler assumes that the value read through a glvalue of one type is not modified by a write to a glvalue of a different type (subject to the exceptions noted above).</source>
          <target state="translated">이 규칙은 유형 기반 별칭 분석을 활성화합니다. 컴파일러는 한 유형의 glvalue를 통해 읽은 값이 다른 유형의 glvalue에 대한 쓰기로 수정되지 않는다고 가정합니다 (위의 예외에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="0ed01ea49dcd8fc7a8834c7e1f6f57d09b9ceaaf" translate="yes" xml:space="preserve">
          <source>This section provides definitions for the specific terminology and the concepts used when describing the C++ programming language.</source>
          <target state="translated">이 섹션에서는 특정 용어에 대한 정의와 C ++ 프로그래밍 언어를 설명 할 때 사용되는 개념을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="28ad28e60d5a5cc2b8a106dc95cfe732a7105f9e" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; informs other library components that all objects of type &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; support</source>
          <target state="translated">이 전문화 &lt;code&gt;&lt;a href=&quot;../../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; 정보 용 다른 라이브러리 구성 요소 유형의 모든 개체가 &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 지원</target>
        </trans-unit>
        <trans-unit id="8c6b990eab9edf93292f6979537f3edb00a094bd" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; informs other library components that values of type &lt;code&gt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc&lt;/a&gt;&lt;/code&gt; are enumerations that hold error codes, which makes them implicitly convertible and assignable to objects of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 전문화 &lt;code&gt;&lt;a href=&quot;../../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; 정보 용 유형의 값이 있다는 다른 라이브러리 구성 요소 &lt;code&gt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc&lt;/a&gt;&lt;/code&gt; 열거되는 타입의 객체들을 암시 적으로 변환하고 할당하게 홀드 오류 코드, &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdc8c9de3fc6d0e6ce5408d37d8e773fda6b9547" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; informs other library components that tuples support</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; 의이 전문화는 튜플을 지원하는 다른 라이브러리 구성 요소에 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="038a0d1d441b9b41c30e5117e6ae3ac1df058c8d" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; encapsulates character classification features for type &lt;code&gt;char&lt;/code&gt;. Unlike general-purpose &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt;, which uses virtual functions, this specialization uses table lookup to classify characters (which is generally faster).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 의이 특수화는 &lt;code&gt;char&lt;/code&gt; 유형의 문자 분류 기능을 캡슐화합니다 . 가상 함수를 사용하는 범용 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 과 달리이 전문화에서는 테이블 조회를 사용하여 문자를 분류합니다 (일반적으로 더 빠름).</target>
        </trans-unit>
        <trans-unit id="fe9803ffee86bd599903f2123e0bb2aa07aae79a" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; encapsulates character classification features for type &lt;code&gt;char&lt;/code&gt;. Like its base class &lt;code&gt;std::ctype&amp;lt;char&amp;gt;&lt;/code&gt; and unlike general-purpose &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt;, table lookup is used to classify characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; 의이 특수화는 &lt;code&gt;char&lt;/code&gt; 유형의 문자 분류 기능을 캡슐화합니다 . 기본 클래스 &lt;code&gt;std::ctype&amp;lt;char&amp;gt;&lt;/code&gt; 과 마찬가지로 범용 &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; 과 달리 테이블 조회는 문자를 분류하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ddf81e9b15f2fdf0bb22d822a3952f3ead8b84b" translate="yes" xml:space="preserve">
          <source>This specification may appear only on lambda-declarator or on a function declarator that is the top-level(until C++17) declarator of a function, variable, or non-static data member, whose type is a function type, a pointer to function type, a reference to function type, a pointer to member function type. It may appear on the declarator of a parameter or on the declarator of a return type.</source>
          <target state="translated">이 스펙은 람다 선언자 또는 함수, 변수 또는 비 정적 데이터 멤버의 최상위 레벨 (C ++ 17까지) 선언자인 함수 선언자에만 나타날 수 있습니다. 함수 유형, 함수 유형에 대한 참조, 멤버 함수 유형에 대한 포인터. 매개 변수의 선언자 또는 리턴 유형의 선언자에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95164148c00adc35d63c91ae48d3bfe549e3eabc" translate="yes" xml:space="preserve">
          <source>This swap function is protected: it is called by the swap member functions of the derived stream classes such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated streambuffers.</source>
          <target state="translated">이 스왑 함수는 보호됩니다. 연결된 스트림 &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 를 올바르게 바꾸는 방법을 알고있는 std :: basic_ofstream 또는 &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; 과 같은 파생 스트림 클래스의 스왑 멤버 함수에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="203ee242898fb95403122a811df27a6f5e11668f" translate="yes" xml:space="preserve">
          <source>This syntax for variadic arguments was introduced in 1983 C++ without the comma before the ellipsis. When C89 adopted function prototypes from C++, it replaced the syntax with one requiring the comma. For compatibility, C++98 accepts both C++-style &lt;code&gt;f(int n...)&lt;/code&gt; and C-style &lt;code&gt;f(int n, ...)&lt;/code&gt;.</source>
          <target state="translated">가변성 인수에 대한이 구문은 줄임표 앞에 쉼표없이 1983 C ++에 도입되었습니다. C89가 C ++의 함수 프로토 타입을 채택 할 때 구문을 쉼표가 필요한 구문으로 대체했습니다. 호환성을 위해 C ++ 98은 C ++ 스타일 &lt;code&gt;f(int n...)&lt;/code&gt; 및 C 스타일 &lt;code&gt;f(int n, ...)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="90ab5c64e037f5bd0606d3f5a893f7a9a8254324" translate="yes" xml:space="preserve">
          <source>This technical specification is supported by GCC as of version 6.1 (requires &lt;code&gt;-fgnu-tm&lt;/code&gt; to enable). An older variant of this specification was &lt;a href=&quot;http://www-users.cs.umn.edu/~boutcher/stm/&quot;&gt;supported in GCC&lt;/a&gt; as of 4.7.</source>
          <target state="translated">이 기술 사양은 버전 6.1부터 GCC에서 지원합니다 ( 활성화 하려면 &lt;code&gt;-fgnu-tm&lt;/code&gt; 필요 ). 이 사양의 이전 버전 은 4.7 &lt;a href=&quot;http://www-users.cs.umn.edu/~boutcher/stm/&quot;&gt;부터 GCC&lt;/a&gt; 에서 지원되었습니다 .</target>
        </trans-unit>
        <trans-unit id="419df6ad5807d184b62cd3a9400a351c6d85612c" translate="yes" xml:space="preserve">
          <source>This technique is used to construct C++ library interfaces with stable ABI and to reduce compile-time dependencies.</source>
          <target state="translated">이 기술은 안정적인 ABI로 C ++ 라이브러리 인터페이스를 구성하고 컴파일 타임 종속성을 줄이는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a685713d9d750fdc943f666575768010c6772551" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type &lt;code&gt;T&lt;/code&gt; to implement &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">이 템플릿은 사용자 정의 형에 특화된 할 수있다 &lt;code&gt;T&lt;/code&gt; 구현하는 &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait을&lt;/a&gt; 함께</target>
        </trans-unit>
        <trans-unit id="25830dd69fe1f966afb7508601b149f9651d15fd" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type to indicate that the type is eligible for &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; automatic conversions.</source>
          <target state="translated">이 템플릿은 유형이 &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 적합 함을 나타 내기 위해 사용자 정의 유형에 특화 될 수 있습니다. 및 &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 자동 변환에 .</target>
        </trans-unit>
        <trans-unit id="921636ccd7ae628df6b1d450ba1978e54fd38c56" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type to indicate that the type is eligible for &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; automatic conversions.</source>
          <target state="translated">이 템플릿은 유형이 적합하다는 것을 나타 내기 위해 사용자 정의 유형에 특화 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 자동 변환에.</target>
        </trans-unit>
        <trans-unit id="f8d9894e4d5b931e86a98ac460a720072feb42c9" translate="yes" xml:space="preserve">
          <source>This trait does not check anything outside the immediate context of the assignment expression: if the use of &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual assignment may not compile even if &lt;code&gt;std::is_assignable&amp;lt;T,U&amp;gt;::value&lt;/code&gt; compiles and evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 특성은 대입 표현식의 즉각적인 컨텍스트 외부에서는 아무것도 확인하지 않습니다. &lt;code&gt;T&lt;/code&gt; 또는 &lt;code&gt;U&lt;/code&gt; 를 사용하여 템플리트 특수화, 내재적으로 정의 된 특수 멤버 함수 생성 등이 있고 오류가있는 경우 실제 대입은 컴파일되지 않을 수 있습니다. &lt;code&gt;std::is_assignable&amp;lt;T,U&amp;gt;::value&lt;/code&gt; 컴파일하고 &lt;code&gt;true&lt;/code&gt; 로 평가 합니다 .</target>
        </trans-unit>
        <trans-unit id="eb8840cec417013032e8555b42ffbfcba15618b0" translate="yes" xml:space="preserve">
          <source>This trait does not check anything outside the immediate context of the swap expressions: if the use of &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual swap may not compile even if &lt;code&gt;std::is_swappable_with&amp;lt;T,U&amp;gt;::value&lt;/code&gt; compiles and evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 특성은 스왑 표현식의 즉각적인 컨텍스트 외부에서는 아무것도 확인하지 않습니다. &lt;code&gt;T&lt;/code&gt; 또는 &lt;code&gt;U&lt;/code&gt; 를 사용하여 템플리트 특수화, 내재적으로 정의 된 특수 멤버 함수 생성 등이 발생하고 오류가있는 경우 실제 스왑은 컴파일되지 않을 수 있습니다. &lt;code&gt;std::is_swappable_with&amp;lt;T,U&amp;gt;::value&lt;/code&gt; 컴파일되어 &lt;code&gt;true&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="98c54288dcf9d77d236eeecd6daa6884dc0b5970" translate="yes" xml:space="preserve">
          <source>This trait was introduced to make it possible to determine whether a type can be correctly hashed by hashing its object representation as a byte array.</source>
          <target state="translated">이 특성은 객체 표현을 바이트 배열로 해싱하여 유형을 올바르게 해시 할 수 있는지 여부를 판별 할 수 있도록하기 위해 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="aea90bedb8f6381211ab3408991531636fb5ffc1" translate="yes" xml:space="preserve">
          <source>This type can be specialized if the representation &lt;code&gt;Rep&lt;/code&gt; requires a specific implementation to return these duration objects.</source>
          <target state="translated">이 유형은 표현이 전문화 될 수 있습니다 &lt;code&gt;Rep&lt;/code&gt; 에 이러한 지속 기간 객체를 반환하기 위해 특정 구현이 필요한 .</target>
        </trans-unit>
        <trans-unit id="0087c0a1dcbf0b0f0625fe12349f4e248d5e9491" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the &lt;a href=&quot;copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;copy_file&quot;&gt;&lt;code&gt;copy_file()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 유형은 사용할 수의 동작을 제어하는 옵션 나타내는 &lt;a href=&quot;copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt; 와&lt;a href=&quot;copy_file&quot;&gt; &lt;code&gt;copy_file()&lt;/code&gt; &lt;/a&gt; 함수.</target>
        </trans-unit>
        <trans-unit id="9e417e5db45320da2073da483bb3a5847a750f26" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the &lt;a href=&quot;directory_iterator&quot;&gt;&lt;code&gt;directory_iterator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;recursive_directory_iterator&quot;&gt;&lt;code&gt;recursive_directory_iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;directory_iterator&quot;&gt; &lt;code&gt;directory_iterator&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;recursive_directory_iterator&quot;&gt; &lt;code&gt;recursive_directory_iterator&lt;/code&gt; &lt;/a&gt; 의 동작을 제어하는 ​​사용 가능한 옵션을 나타냅니다. .</target>
        </trans-unit>
        <trans-unit id="ed15c087ab4da8efef6f8cef5da62d8cc51d1d4d" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the function &lt;a href=&quot;permissions&quot;&gt;&lt;code&gt;permissions()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형은 함수 &lt;a href=&quot;permissions&quot;&gt; &lt;code&gt;permissions()&lt;/code&gt; &lt;/a&gt; 의 동작을 제어하는 ​​사용 가능한 옵션을 나타냅니다. .</target>
        </trans-unit>
        <trans-unit id="19b6990a7534cc1c45af33110b91b0350924b0e8" translate="yes" xml:space="preserve">
          <source>This type represents file access permissions. &lt;code&gt;perms&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type).</source>
          <target state="translated">이 유형은 파일 액세스 권한을 나타냅니다. &lt;code&gt;perms&lt;/code&gt; 는 &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; 의 요구 사항을 충족합니다 (비트 연산자 &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;operator|&lt;/code&gt; , &lt;code&gt;operator^&lt;/code&gt; , &lt;code&gt;operator~&lt;/code&gt; , &lt;code&gt;operator&amp;amp;=&lt;/code&gt; , &lt;code&gt;operator|=&lt;/code&gt; 및 &lt;code&gt;operator^=&lt;/code&gt; 는이 유형에 대해 정의 됨).</target>
        </trans-unit>
        <trans-unit id="157a64e0ec4c85a12b01b53324ef0dcdfb157238" translate="yes" xml:space="preserve">
          <source>This type requirement is deprecated in the C++ standard. All of its uses have been replaced by the more refined type requirements, such as &lt;a href=&quot;trivialtype&quot;&gt;TrivialType&lt;/a&gt;.</source>
          <target state="translated">이 유형 요구 사항은 C ++ 표준에서 더 이상 사용되지 않습니다. 모든 사용이 &lt;a href=&quot;trivialtype&quot;&gt;TrivialType&lt;/a&gt; 과 같이보다 세련된 유형 요구 사항으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="23b4cbf67168a660a04e5a36fcd5bf13a48ffa59" translate="yes" xml:space="preserve">
          <source>This type trait is used by &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt;. It may also be used by custom allocators or wrapper types to determine whether the object or member being constructed is itself capable of using an allocator (e.g. is a container), in which case an allocator should be passed to its constructor.</source>
          <target state="translated">이 유형 특성은 &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt; 됩니다. 또한 사용자 지정 할당 자 또는 랩퍼 유형에서 구성중인 오브젝트 또는 멤버 자체가 할당 자 (예 : 컨테이너)를 사용할 수 있는지 여부를 판별 할 수 있으며,이 경우 할당자는 해당 생성자에게 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="99d2afd28d674bc31d956763a004b7cd9b730d51" translate="yes" xml:space="preserve">
          <source>This type trait may be specialized for user-provided types that may be used as iterators. The standard library provides two partial specializations for pointer types T*, which makes it possible to use all iterator-based algorithms with raw pointers.</source>
          <target state="translated">이 유형 특성은 반복자로 사용될 수있는 사용자 제공 유형에 특화 될 수 있습니다. 표준 라이브러리는 포인터 유형 T *에 대해 두 가지 부분 특수화를 제공하므로 모든 반복자 기반 알고리즘을 원시 포인터와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5c25f5c1d60bf97a090f5b80fe5a2c0ab183ce7" translate="yes" xml:space="preserve">
          <source>This type trait predates the &lt;a href=&quot;../language/alignof&quot;&gt;alignof keyword&lt;/a&gt;, which can be used to obtain the same value with less verbosity.</source>
          <target state="translated">이 유형 특성은 &lt;a href=&quot;../language/alignof&quot;&gt;alignof 키워드&lt;/a&gt; 보다 우선합니다. alignof keyword 는 덜 자세한 표시로 동일한 값을 얻는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0410ce23d7ebcff7e3be952fdf86650da4cb323" translate="yes" xml:space="preserve">
          <source>This value typically reflects the theoretical limit on the size of the container, at most &lt;code&gt;std::numeric_limits&amp;lt;difference_type&amp;gt;::max()&lt;/code&gt;. At runtime, the size of the container may be limited to a value smaller than &lt;code&gt;max_size()&lt;/code&gt; by the amount of RAM available.</source>
          <target state="translated">이 값은 일반적으로 최대 &lt;code&gt;std::numeric_limits&amp;lt;difference_type&amp;gt;::max()&lt;/code&gt; 컨테이너의 크기에 대한 이론적 한계를 반영합니다 . 런타임에 컨테이너의 크기는 &lt;code&gt;max_size()&lt;/code&gt; 보다 작은 값으로 제한 될 수 있습니다 사용 가능한 RAM의 양에 의해 있습니다.</target>
        </trans-unit>
        <trans-unit id="277c3ad089ba0f3cf12d3db7126822c9d80a4896" translate="yes" xml:space="preserve">
          <source>This variable has block scope and static storage duration:</source>
          <target state="translated">이 변수에는 블록 범위와 정적 저장 기간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fae180c729e28c3be7b371f92b90451d0013d47d" translate="yes" xml:space="preserve">
          <source>Those data members that correspond to captures without initializers are &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; when the lambda-expression is evaluated. Those that correspond to captures with initializers are initialized as the initializer requires (could be copy- or direct-initialization). If an array is captured, array elements are direct-initialized in increasing index order. The order in which the data members are initialized is the order in which they are declared (which is unspecified).</source>
          <target state="translated">초기화가없는 캡처에 해당하는 데이터 멤버 는 람다식이 평가 될 때 &lt;a href=&quot;direct_initialization&quot;&gt;직접 초기화&lt;/a&gt; 됩니다. 이니셜 라이저를 사용한 캡처에 해당하는 것은 이니셜 라이저가 요구하는대로 초기화됩니다 (복사 또는 직접 초기화 일 수 있음). 배열이 캡처되면 배열 요소는 색인 순서에 따라 직접 초기화됩니다. 데이터 멤버가 초기화되는 순서는 선언 된 순서입니다 (지정되지 않음).</target>
        </trans-unit>
        <trans-unit id="f4a567a9b52d0caa922bc0235781e01fdf5d4c89" translate="yes" xml:space="preserve">
          <source>Thousands separator and decimal point characters are inserted as required by &lt;code&gt;mp.grouping()&lt;/code&gt;, &lt;code&gt;mp.frac_digits()&lt;/code&gt;, &lt;code&gt;mp.decimal_point()&lt;/code&gt;, and &lt;code&gt;mp.thousands_sep()&lt;/code&gt;, and the resulting string is placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;value&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">수천 세퍼레이터 소수점 자에 의해 요구되는 삽입 &lt;code&gt;mp.grouping()&lt;/code&gt; , &lt;code&gt;mp.frac_digits()&lt;/code&gt; , &lt;code&gt;mp.decimal_point()&lt;/code&gt; 및 &lt;code&gt;mp.thousands_sep()&lt;/code&gt; , 생성 된 문자열은 여기서 출력 시퀀스에 위치 &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;value&lt;/a&gt;&lt;/code&gt; 이 나타날에 형식화 패턴</target>
        </trans-unit>
        <trans-unit id="d0cef5deb223649da3c92e68bafacf5c8ccd785e" translate="yes" xml:space="preserve">
          <source>Thread safety</source>
          <target state="translated">스레드 안전</target>
        </trans-unit>
        <trans-unit id="604ac3e54d45a1053374b3b32afdb7b25fbf1ed4" translate="yes" xml:space="preserve">
          <source>Thread support</source>
          <target state="translated">스레드 지원</target>
        </trans-unit>
        <trans-unit id="e2d8ff11421f3eaf1af17a9be19957f5569bce89" translate="yes" xml:space="preserve">
          <source>Thread support library</source>
          <target state="translated">스레드 지원 라이브러리</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="e7a80c12335015336479b7097a8b8db3ed660872" translate="yes" xml:space="preserve">
          <source>Threads and data races</source>
          <target state="translated">스레드와 데이터 레이스</target>
        </trans-unit>
        <trans-unit id="c1492359cb9886c9909e1a4316a9b1847c65e9e9" translate="yes" xml:space="preserve">
          <source>Threads begin execution immediately upon construction of the associated thread object (pending any OS scheduling delays), starting at the top-level function provided as a &lt;a href=&quot;thread/thread&quot;&gt;constructor argument&lt;/a&gt;. The return value of the top-level function is ignored and if it terminates by throwing an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. The top-level function may communicate its return value or an exception to the caller via &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or by modifying shared variables (which may require synchronization, see &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">스레드는 &lt;a href=&quot;thread/thread&quot;&gt;생성자 인수&lt;/a&gt; 로 제공된 최상위 함수에서 시작하여 관련 스레드 개체가 생성되면 (OS 스케줄링 지연에 따라) 즉시 실행을 시작합니다 . 최상위 함수의 반환 값은 무시되며 예외를 throw하여 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 되면 std :: terminate 가 호출됩니다. 최상위 함수는 &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; 를 통해 또는 공유 변수 수정 (동기화가 필요할 수 있음 &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 참조)을 통해 호출자에게 반환 값 또는 예외를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4eb730a2ea2fcff234ce55322a48d3d91657b7e" translate="yes" xml:space="preserve">
          <source>Threads enable programs to execute across several processor cores.</source>
          <target state="translated">스레드는 프로그램이 여러 프로세서 코어에서 실행될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="a246e49f5181769dcbe8963551805985ea8e8c89" translate="yes" xml:space="preserve">
          <source>Three conditions where &lt;code&gt;std::bad_array_new_length&lt;/code&gt; should be thrown:</source>
          <target state="translated">&lt;code&gt;std::bad_array_new_length&lt;/code&gt; 가 발생해야하는 세 가지 조건 :</target>
        </trans-unit>
        <trans-unit id="b9e36378830759894e6fe278bd9aa261b8ff8830" translate="yes" xml:space="preserve">
          <source>Three-way comparison</source>
          <target state="translated">3 방향 비교</target>
        </trans-unit>
        <trans-unit id="762d1a20f1e0eccc439b6c76140f77d0e64ffbd4" translate="yes" xml:space="preserve">
          <source>Three-way comparison can be automatically generated for class types, see &lt;a href=&quot;default_comparisons&quot;&gt;default comparisons&lt;/a&gt;.</source>
          <target state="translated">클래스 유형에 대해 3 방향 비교가 자동으로 생성 될 수 있습니다 ( &lt;a href=&quot;default_comparisons&quot;&gt;기본 비교&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="89dc893d701abc8f17f1b70a529a23fb35201ff0" translate="yes" xml:space="preserve">
          <source>Throughout the standard library, bitwise shift operators are commonly overloaded with I/O stream (&lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&amp;amp;&lt;/code&gt; or one of the classes derived from it) as both the left operand and return type. Such operators are known as</source>
          <target state="translated">표준 라이브러리 전체에서 비트 단위 시프트 연산자는 일반적으로 왼쪽 피연산자 및 반환 유형 으로 I / O 스트림 ( &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&amp;amp;&lt;/code&gt; 이 클래스에서 파생 된 클래스 중 하나) 으로 오버로드됩니다 . 이러한 연산자는</target>
        </trans-unit>
        <trans-unit id="f13c54f785e2da5ceb32427977752efac6c1f5cc" translate="yes" xml:space="preserve">
          <source>Throw any exception thrown by the currently installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">현재 설치된 &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; 의해 발생 된 예외를 처리하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ab6516c23d4a4cf955f60f3139340567e17455c" translate="yes" xml:space="preserve">
          <source>Throwing an exception is used to signal errors from functions, where &quot;errors&quot; are typically limited to only the following&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;exceptions#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;exceptions#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;exceptions#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;:</source>
          <target state="translated">예외를 던지면 함수의 오류를 알리는 데 사용됩니다. 여기서 &quot;오류&quot;는 일반적으로 다음 &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;exceptions#cite_note-1&quot;&gt;[1] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;exceptions#cite_note-2&quot;&gt;[2] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;exceptions#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt; 으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c890cb1e360c745fea29256ca1365d6a4c1baf1" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;n &amp;gt; SIZE_MAX / sizeof(T)&lt;/code&gt;; may also any exceptions thrown by the call to &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n &amp;gt; SIZE_MAX / sizeof(T)&lt;/code&gt; 이면 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; 던집니다 . &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt; 호출로 인해 예외가 발생할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef7207c238414b15063664465aad815055211c96" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;new_cap&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; 경우 &lt;code&gt;new_cap&lt;/code&gt; 이 보다 큰 &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31e238d5140b17c25d7cced51cc7d8f65270714a" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if the length of the constructed string would exceed &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; (for example, if &lt;code&gt;count &amp;gt; max_size()&lt;/code&gt; for (2)). Calls to &lt;code&gt;Allocator::allocate&lt;/code&gt; may throw.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; 구성된 문자열의 길이를 초과 할 경우, &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; (예를 들어, &lt;code&gt;count &amp;gt; max_size()&lt;/code&gt; 에 대한이 (2)). &lt;code&gt;Allocator::allocate&lt;/code&gt; 호출이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bd5e3a71ffb663ec4af5da4ee91146199c73db9" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pos &amp;gt;= size()&lt;/code&gt; 경우 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; throw 합니다.</target>
        </trans-unit>
        <trans-unit id="0988508382bdadbf64519b871fd4199f1f7e88db" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; if no such &lt;code&gt;time_zone&lt;/code&gt; can be found.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; 그런 경우 &lt;code&gt;time_zone&lt;/code&gt; 발견 할 수있다.</target>
        </trans-unit>
        <trans-unit id="0b00d37fc6c817e49da501c1d4283379499ed17c" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; when errors occur, including errors from the underlying operating system that would prevent &lt;code&gt;lock&lt;/code&gt; from meeting its specifications. The mutex is not locked in the case of any exception being thrown.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 방지 할 기본 운영 체제에서 오류를 포함하여 오류가 발생, &lt;code&gt;lock&lt;/code&gt; 사양을 충족에서합니다. 예외가 발생하는 경우 뮤텍스가 잠기지 않습니다.</target>
        </trans-unit>
        <trans-unit id="442b654cd69e928843823a7f4be327a06a469dea" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with error condition &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; if the launch policy equals &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; and the implementation is unable to start a new thread (if the policy is &lt;code&gt;async|deferred&lt;/code&gt; or has additional bits set, it will fall back to deferred or the implementation-defined policies in this case), or &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory for the internal data structures could not be allocated.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 오류 조건을 &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; 발사 정책이 동일한 경우 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; 하고 구현은 정책이있는 경우 (새 스레드를 시작할 수 없습니다 &lt;code&gt;async|deferred&lt;/code&gt; 또는 추가 비트가 설정되어 내부 데이터 구조에 대한 메모리를 할당 할 수없는 경우 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 또는이 경우 구현 정의 정책으로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="7fd45fe2a76b5c26edcf480fd318099061d96452" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; throws.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 하는 경우 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 던진다.</target>
        </trans-unit>
        <trans-unit id="61e7abab0e5d103b8f9ee327388ae0a478e7343f" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if allocation fails.</source>
          <target state="translated">할당이 실패하면 &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="610b978856ae75c3eef4b6f3051d9b89a88b02ba" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; if any variant in &lt;code&gt;vars&lt;/code&gt; is &lt;a href=&quot;valueless_by_exception&quot;&gt;&lt;code&gt;valueless_by_exception&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">예외 &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; 의 모든 변종 경우 &lt;code&gt;vars&lt;/code&gt; 있다 &lt;a href=&quot;valueless_by_exception&quot;&gt; &lt;code&gt;valueless_by_exception&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ccf84cf2370a76be5d96fc6954ac7aa274274a8" translate="yes" xml:space="preserve">
          <source>Throws an exception if storage of the requested size and alignment cannot be obtained.</source>
          <target state="translated">요청 된 크기 및 정렬을 저장할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="78d4655bb8c331d30d35c5dca21382a3023d8907" translate="yes" xml:space="preserve">
          <source>Throws an implementation-defined exception derived from &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; if a random number could not be generated.</source>
          <target state="translated">난수를 생성 할 수없는 경우 &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; 에서 파생 된 구현 정의 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c71eb890289859862d506be6577481a6155d7187" translate="yes" xml:space="preserve">
          <source>Throws an implementation-defined exceptions derived from &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">실패시 &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; 에서 파생 된 구현 정의 예외 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="7035dd91c99b009a7736d3114cd02d3205a59146" translate="yes" xml:space="preserve">
          <source>Throws any exception thrown by &lt;code&gt;T&lt;/code&gt;'s constructor. If an exception is thrown, the previously contained object (if any) has been destroyed, and &lt;code&gt;*this&lt;/code&gt; does not contain a value.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 생성자에 의해 발생 된 예외를 처리합니다 . 예외가 발생하면 이전에 포함 된 오브젝트 (있는 경우)가 소멸되고 &lt;code&gt;*this&lt;/code&gt; 값을 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4b5347955a68d7b49fb60df96bc4c1fe1be392e" translate="yes" xml:space="preserve">
          <source>Throws any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 생성자가 던진 예외를 모두 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="62b00b9bd5afe726c1c402b63375bc4866d56f7c" translate="yes" xml:space="preserve">
          <source>Throws no exceptions, unless the construction of &lt;code&gt;fd&lt;/code&gt; throws.</source>
          <target state="translated">&lt;code&gt;fd&lt;/code&gt; throw 구성이 아닌 한 예외는 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2e4fed0e085b765b71b25a3a55fd75c68b497a32" translate="yes" xml:space="preserve">
          <source>Throws no exceptions.</source>
          <target state="translated">예외는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c77dbbe1f17eaa70afe33271369b7e39a68c956a" translate="yes" xml:space="preserve">
          <source>Throws nothing unless calling &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource throws.</source>
          <target state="translated">업스트림 메모리 리소스에서 assign &lt;code&gt;allocate()&lt;/code&gt; 을 호출하지 않으면 아무것도 throw되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3473cebcbcfaf057526db12532a7e05950b9a394" translate="yes" xml:space="preserve">
          <source>Throws nothing.</source>
          <target state="translated">아무것도 던지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d36a7251aa285e37e60059fda10d55905771330c" translate="yes" xml:space="preserve">
          <source>Throws only if an operation on &lt;code&gt;dest&lt;/code&gt; throws.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 대한 작업이 발생한 경우에만 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="1ec2a611e5f00a6feb428658f1aa68f1b6da7754" translate="yes" xml:space="preserve">
          <source>Throws the previously captured exception object, referred to by the exception pointer &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">예외 포인터 &lt;code&gt;p&lt;/code&gt; 에 의해 참조 된, 이전에 캡처 된 예외 오브젝트를 던집니다 .</target>
        </trans-unit>
        <trans-unit id="bcec7ea351c0f526e56ea2d8f983f85ec1b9038a" translate="yes" xml:space="preserve">
          <source>Thus, replacing the throwing single object deallocation functions (1,3) is sufficient to handle all deallocations.</source>
          <target state="translated">따라서 던지는 단일 객체 할당 해제 함수 (1,3)를 교체하면 모든 할당 해제를 처리하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="c43feecba43a30ac9fc0c134e6e8cb0382c660f2" translate="yes" xml:space="preserve">
          <source>Time manipulation</source>
          <target state="translated">시간 조작</target>
        </trans-unit>
        <trans-unit id="6a48c0a81754a0e5cd402f2b5b7b65e0802b3ae0" translate="yes" xml:space="preserve">
          <source>Time of day</source>
          <target state="translated">시간</target>
        </trans-unit>
        <trans-unit id="848d63dd0e0417a6a6d0653d6feba98b946a8d6e" translate="yes" xml:space="preserve">
          <source>Time point</source>
          <target state="translated">시점</target>
        </trans-unit>
        <trans-unit id="99536a3f0c0c578df6810c5e30a06d3b2da45179" translate="yes" xml:space="preserve">
          <source>Time point (a &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;duration&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">시점 ( &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;duration&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b99a31f7aded92da84e5f21bdba7429ff03b583d" translate="yes" xml:space="preserve">
          <source>Time point family</source>
          <target state="translated">시점 가족</target>
        </trans-unit>
        <trans-unit id="3e17e972e7d70a2b0ea19965e0edbbdd317996ef" translate="yes" xml:space="preserve">
          <source>Time since epoch as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; object on success or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;time&lt;/code&gt; cannot be represented as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; object.</source>
          <target state="translated">시간 A와 시대 이후 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; 성공 개체 또는 &lt;code&gt;-1&lt;/code&gt; 경우 &lt;code&gt;time&lt;/code&gt; A와 표시 할 수없는 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="baff479affe7646bf932c42ec983a595bbc4b1cf" translate="yes" xml:space="preserve">
          <source>Time tracking (e.g. &lt;code&gt;&lt;a href=&quot;chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;), C-style date and time (e.g. &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/c/clock&quot;&gt;std::clock&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">시간 추적 (예 : &lt;code&gt;&lt;a href=&quot;chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;chrono/duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; ), C 스타일 날짜 및 시간 (예 : &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;chrono/c/clock&quot;&gt;std::clock&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="eea79afd832854a3b24153b928ee9c62c7457dbe" translate="yes" xml:space="preserve">
          <source>Time zone</source>
          <target state="translated">시간대</target>
        </trans-unit>
        <trans-unit id="932d3e6f9a587b1ed93ccda36b7118239840479f" translate="yes" xml:space="preserve">
          <source>Time zone pointer (denoted &lt;code&gt;zone&lt;/code&gt;)</source>
          <target state="translated">시간대 포인터 ( &lt;code&gt;zone&lt;/code&gt; 표시 )</target>
        </trans-unit>
        <trans-unit id="40349a8ed2b426d8558214c08ff878c9b7836d5c" translate="yes" xml:space="preserve">
          <source>TimedLockable</source>
          <target state="translated">TimedLockable</target>
        </trans-unit>
        <trans-unit id="7a1979526d24991a3fdc66189422c80b7c9499d1" translate="yes" xml:space="preserve">
          <source>TimedMutex</source>
          <target state="translated">TimedMutex</target>
        </trans-unit>
        <trans-unit id="3d854366021896ce0345060f9138ad581720da11" translate="yes" xml:space="preserve">
          <source>To access the variadic arguments from the function body, the following library facilities are provided:</source>
          <target state="translated">함수 본문에서 variadic 인수에 액세스하기 위해 다음 라이브러리 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2c3649f8d8e3f7fb8fa9a2e0b81692c7c0d56f26" translate="yes" xml:space="preserve">
          <source>To avoid data races, once a shared pointer is passed to any of these functions, it cannot be accessed non-atomically. In particular, you cannot dereference such a shared_ptr without first atomically loading it into another shared_ptr object, and then dereferencing through the second object.</source>
          <target state="translated">데이터 경쟁을 피하기 위해 일단 공유 포인터가 이러한 함수 중 하나로 전달되면 비원 자적으로 액세스 할 수 없습니다. 특히, 이러한 shared_ptr을 먼저 다른 shared_ptr 오브젝트에 원자 적으로로드 한 다음 두 번째 오브젝트를 통해 역 참조하지 않으면 이러한 shared_ptr을 역 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c35636471d229cbd245a9382f85e9b6dce24337" translate="yes" xml:space="preserve">
          <source>To avoid these quirks, &lt;code&gt;result_of&lt;/code&gt; is often used with reference types as &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;Args...&lt;/code&gt;. For example:</source>
          <target state="translated">이러한 단점을 피하기 위해 &lt;code&gt;result_of&lt;/code&gt; 는 종종 참조 유형과 함께 &lt;code&gt;F&lt;/code&gt; 및 &lt;code&gt;Args...&lt;/code&gt; 와 함께 사용됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9af4209978b81d53f6e3f0d4dfaa5d56a5095a25" translate="yes" xml:space="preserve">
          <source>To avoid unnecessary copying of the exception object and object slicing, the best practice for catch clauses is to catch by reference.&lt;sup id=&quot;cite_ref-10&quot;&gt;&lt;a href=&quot;exceptions#cite_note-10&quot;&gt;[10]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-11&quot;&gt;&lt;a href=&quot;exceptions#cite_note-11&quot;&gt;[11]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-12&quot;&gt;&lt;a href=&quot;exceptions#cite_note-12&quot;&gt;[12]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-13&quot;&gt;&lt;a href=&quot;exceptions#cite_note-13&quot;&gt;[13]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">예외 객체와 객체 슬라이싱의 불필요한 복사를 피하기 위해 catch 절에 대한 모범 사례는 참조로 포착하는 것입니다. &lt;sup id=&quot;cite_ref-10&quot;&gt;&lt;a href=&quot;exceptions#cite_note-10&quot;&gt;[10] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-11&quot;&gt;&lt;a href=&quot;exceptions#cite_note-11&quot;&gt;[11] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-12&quot;&gt;&lt;a href=&quot;exceptions#cite_note-12&quot;&gt;[12] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-13&quot;&gt;&lt;a href=&quot;exceptions#cite_note-13&quot;&gt;[13]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32227a48661c43cebdc36000ab948c6c4f0e7732" translate="yes" xml:space="preserve">
          <source>To be included in the set of viable functions, the candidate function must satisfy the following:</source>
          <target state="translated">실행 가능한 기능 세트에 포함 되려면 후보 기능이 다음을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d9269c47d9ba025b6ff347184af6dae00b4781f" translate="yes" xml:space="preserve">
          <source>To call the function,</source>
          <target state="translated">함수를 호출하려면</target>
        </trans-unit>
        <trans-unit id="3e00e2418f0d13b96de319ccb14e33b157fe6ecf" translate="yes" xml:space="preserve">
          <source>To compile a call to a function template, the compiler has to decide between non-template overloads, template overloads, and the specializations of the template overloads.</source>
          <target state="translated">함수 템플릿에 대한 호출을 컴파일하려면 컴파일러가 템플릿이 아닌 오버로드, 템플릿 오버로드 및 템플릿 오버로드의 특수화 중에서 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="648fa0a42ad74259537f74f99862470566d205e4" translate="yes" xml:space="preserve">
          <source>To convert a reference or a pointer to a cv-qualified type to a reference or pointer to a</source>
          <target state="translated">cv-qualified 형식에 대한 참조 또는 포인터를 a에 대한 참조 또는 포인터로 변환하려면</target>
        </trans-unit>
        <trans-unit id="479a613a1f4b0b411389efeda8d5cbee450b5792" translate="yes" xml:space="preserve">
          <source>To create a distribution over the closed interval [a,b], &lt;code&gt;&lt;a href=&quot;../../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; may be used as the second parameter.</source>
          <target state="translated">닫힌 간격 [a, b]에 대한 분포를 만들려면 &lt;code&gt;&lt;a href=&quot;../../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; 두 번째 매개 변수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d960d66e52b0039243dd579fef5b5e0189abe40c" translate="yes" xml:space="preserve">
          <source>To create a distribution over the closed interval [a,b], &lt;code&gt;&lt;a href=&quot;../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; may be used as the second parameter.</source>
          <target state="translated">닫힌 간격 [a, b]에 대한 분포를 만들려면 &lt;code&gt;&lt;a href=&quot;../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; 두 번째 매개 변수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99e393ae840d4dfdfd8ab0ea9c4989b21f3b3380" translate="yes" xml:space="preserve">
          <source>To declare a variadic function, an ellipsis is used as the last parameter, e.g. &lt;code&gt;int printf(const char* format, ...);&lt;/code&gt;. See &lt;a href=&quot;../language/variadic_arguments&quot;&gt;Variadic arguments&lt;/a&gt; for additional detail on the syntax, automatic argument conversions and the alternatives.</source>
          <target state="translated">variadic 함수를 선언하기 위해 생략 부호가 마지막 매개 변수로 사용됩니다 &lt;code&gt;int printf(const char* format, ...);&lt;/code&gt; 예 : int printf (const char * format, ...); . 구문, 자동 인수 변환 및 대안에 대한 자세한 내용은 &lt;a href=&quot;../language/variadic_arguments&quot;&gt;가변 인수&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22cd3be1d2fb287ce824540ee1391a62cb561144" translate="yes" xml:space="preserve">
          <source>To ensure that the program benefits from the optimizations enabled by &lt;code&gt;assume_aligned&lt;/code&gt;, it is important to access the object via its return value:</source>
          <target state="translated">&lt;code&gt;assume_aligned&lt;/code&gt; 에 의해 활성화 된 최적화를 통해 프로그램의 이점을 얻으려면 반환 값을 통해 객체에 액세스하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="525fd31bb668048344f8a31de0c1142305eb7415" translate="yes" xml:space="preserve">
          <source>To generate enough entropy, &lt;code&gt;generate_canonical()&lt;/code&gt; will call &lt;code&gt;g()&lt;/code&gt; exactly k times, where \(k = max(1, \lceil \frac{b}{log_2 R} \rceil)\)k = max(1, &amp;lceil; b / log</source>
          <target state="translated">충분한 엔트로피를 생성하기 위해 generate_canonical &lt;code&gt;generate_canonical()&lt;/code&gt; 은 &lt;code&gt;g()&lt;/code&gt; 정확히 k 번 호출합니다 . 여기서 \ (k = max (1, \ lceil \ frac {b} {log_2 R} \ rceil) \) k = max (1, &amp;lceil; b / 로그</target>
        </trans-unit>
        <trans-unit id="2c0e3e28251239ee8bfb2240bdd1fc0f1ed54c3c" translate="yes" xml:space="preserve">
          <source>To grant access to additional functions or classes to protected or private members, a &lt;a href=&quot;friend&quot;&gt;friendship declaration&lt;/a&gt; may be used.</source>
          <target state="translated">보호 또는 개인 회원에게 추가 기능이나 클래스에 대한 액세스 권한을 부여하기 위해 &lt;a href=&quot;friend&quot;&gt;우정 선언을&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="878939687f32a6c24537c7a73b290843588b7164" translate="yes" xml:space="preserve">
          <source>To initialize a pointer to null or to assign the null value to an existing pointer, the null pointer literal &lt;code&gt;nullptr&lt;/code&gt;, the null pointer constant &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, or the &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from the integer value &lt;code&gt;​0​&lt;/code&gt; may be used.</source>
          <target state="translated">널 포인터를 초기화하거나 기존 포인터 NULL 값을 할당하는, 널 포인터 리터럴 &lt;code&gt;nullptr&lt;/code&gt; , 널 포인터 상수의 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 또는 &lt;a href=&quot;implicit_cast&quot;&gt;암시 적 변환이&lt;/a&gt; 정수 값에서 &lt;code&gt;​0​&lt;/code&gt; 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="e3122235602ec384e5e6446cb56e5141efaef34c" translate="yes" xml:space="preserve">
          <source>To iterate over the current directory, construct the iterator as &lt;code&gt;directory_iterator(&quot;.&quot;)&lt;/code&gt; instead of &lt;code&gt;directory_iterator(&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">현재 디렉토리를 반복으로 반복자를 구축하기 위해 &lt;code&gt;directory_iterator(&quot;.&quot;)&lt;/code&gt; 대신 &lt;code&gt;directory_iterator(&quot;&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="724317f9ed9523d1d5aa4de4bf63c61feb5cf73f" translate="yes" xml:space="preserve">
          <source>To make ADL examine a user-defined namespace, either &lt;code&gt;std::vector&lt;/code&gt; should be replaced by a user-defined class or its element type should be a user-defined class:</source>
          <target state="translated">ADL이 사용자 정의 네임 스페이스를 검사하도록하려면 &lt;code&gt;std::vector&lt;/code&gt; 를 사용자 정의 클래스로 바꾸거나 요소 유형을 사용자 정의 클래스로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9dacb8ab35ec1963dda5bb3c402d87f89eb9adc7" translate="yes" xml:space="preserve">
          <source>To make strong exception guarantee possible, user-defined move constructors should not throw exceptions. For example, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; relies on &lt;code&gt;&lt;a href=&quot;../utility/move_if_noexcept&quot;&gt;std::move_if_noexcept&lt;/a&gt;&lt;/code&gt; to choose between move and copy when the elements need to be relocated.</source>
          <target state="translated">강력한 예외 보장을 가능하게하기 위해 사용자 정의 이동 생성자는 예외를 발생시키지 않아야합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../utility/move_if_noexcept&quot;&gt;std::move_if_noexcept&lt;/a&gt;&lt;/code&gt; 를 사용하여 요소를 재배치해야 할 때 이동 및 복사 중에서 선택합니다.</target>
        </trans-unit>
        <trans-unit id="fbaf135ff4214aca3306677fb2ad01282f0bd0a8" translate="yes" xml:space="preserve">
          <source>To match a template template argument &lt;code&gt;A&lt;/code&gt; to a template template parameter &lt;code&gt;P&lt;/code&gt;, each of the template parameters of &lt;code&gt;A&lt;/code&gt; must match corresponding template parameters of &lt;code&gt;P&lt;/code&gt; exactly(until C++17)&lt;code&gt;P&lt;/code&gt; must be at least as specialized as &lt;code&gt;A&lt;/code&gt;(since C++17). If &lt;code&gt;P&lt;/code&gt;'s parameter list includes a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt;, zero or more template parameters (or parameter packs) from &lt;code&gt;A&lt;/code&gt;'s template parameter list are matched by it.</source>
          <target state="translated">템플릿 템플릿 인수 &lt;code&gt;A&lt;/code&gt; 를 템플릿 템플릿 매개 변수 &lt;code&gt;P&lt;/code&gt; 에 일치 시키려면 각 템플릿 매개 변수는 &lt;code&gt;A&lt;/code&gt; 의 템플릿 매개 변수에 대응 일치해야 &lt;code&gt;P&lt;/code&gt; 를 정확히 (C ++ 17까지) &lt;code&gt;P&lt;/code&gt; 가 같은 전문으로 이상이어야합니다 C 이후 (++ 17). 경우 &lt;code&gt;P&lt;/code&gt; 의 파라미터리스트가 포함하는 &lt;a href=&quot;parameter_pack&quot;&gt;파라미터 팩&lt;/a&gt; 에서 0 개 이상의 템플릿 파라미터 (또는 파라미터 팩) 의 템플릿 파라미터리스트 '그것과 일치한다. &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1653fef798170fad22ce8f246671d9967ebf88bf" translate="yes" xml:space="preserve">
          <source>To provide multidimensional array access semantics, e.g. to implement a 3D array access &lt;code&gt;a[i][j][k] = x;&lt;/code&gt;, operator[] has to return a reference to a 2D plane, which has to have its own operator[] which returns a reference to a 1D row, which has to have operator[] which returns a reference to the element. To avoid this complexity, some libraries opt for overloading &lt;code&gt;operator()&lt;/code&gt; instead, so that 3D access expressions have the Fortran-like syntax &lt;code&gt;a(i, j, k) = x;&lt;/code&gt;</source>
          <target state="translated">다차원 어레이 액세스 시맨틱을 제공하기 위해, 예를 들어 3D 어레이 액세스를 구현하기 위해 &lt;code&gt;a[i][j][k] = x;&lt;/code&gt; , operator []는 2D 평면에 대한 참조를 반환해야합니다. 2D 평면에는 1D 행에 대한 참조를 반환하는 자체 operator []가 있어야하며 요소에 대한 참조를 반환하는 operator []가 있어야합니다. 이러한 복잡성을 피하기 위해 일부 라이브러리는 대신 &lt;code&gt;operator()&lt;/code&gt; 오버로드를 선택하여 3D 액세스 표현식에 포트란 유사 구문 &lt;code&gt;a(i, j, k) = x;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="106dedcf05132b51eabb9b06f962997250951fc9" translate="yes" xml:space="preserve">
          <source>To refer to a static member &lt;code&gt;m&lt;/code&gt; of class &lt;code&gt;T&lt;/code&gt;, two forms may be used: qualified name &lt;code&gt;T::m&lt;/code&gt; or member access expression &lt;code&gt;E.m&lt;/code&gt; or &lt;code&gt;E-&amp;gt;m&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression that evaluates to &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt; respectively. When in the same class scope, the qualification is unnecessary:</source>
          <target state="translated">클래스 &lt;code&gt;T&lt;/code&gt; 의 정적 멤버 &lt;code&gt;m&lt;/code&gt; 을 참조하기 위해 규정 된 이름 &lt;code&gt;T::m&lt;/code&gt; 또는 멤버 액세스 표현식의 두 가지 형식을 사용할 수 있습니다. &lt;code&gt;E.m&lt;/code&gt; 또는 &lt;code&gt;E-&amp;gt;m&lt;/code&gt; 의 여기서 &lt;code&gt;E&lt;/code&gt; 는 각각 &lt;code&gt;T&lt;/code&gt; 또는 &lt;code&gt;T*&lt;/code&gt; 평가되는 표현식입니다 . 동일한 수업 범위에있을 경우 자격이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3726bd5210fa66b99d1405f1d23513ff4e9a847a" translate="yes" xml:space="preserve">
          <source>To reopen an existing namespace (formally, to be an</source>
          <target state="translated">기존 네임 스페이스를 다시 열려면 (공식적으로</target>
        </trans-unit>
        <trans-unit id="6766595568bdee575215126dcd221dc1330e2532" translate="yes" xml:space="preserve">
          <source>To replace the managed object while supplying a new deleter as well, move assignment operator may be used.</source>
          <target state="translated">새 삭제기를 제공하는 동안 관리 대상 객체를 바꾸려면 이동 할당 연산자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f22138cc2032a2d9e0e8461eb5887bb980094c3c" translate="yes" xml:space="preserve">
          <source>To satisfy this requirement, types that do not have built-in &lt;a href=&quot;../language/operator_comparison&quot;&gt;comparison operators&lt;/a&gt; have to provide a &lt;a href=&quot;../language/operators&quot;&gt;user-defined operator==&lt;/a&gt;.</source>
          <target state="translated">이 요구 사항을 충족하려면 내장 &lt;a href=&quot;../language/operator_comparison&quot;&gt;비교 연산자&lt;/a&gt; 가 없는 유형 은 &lt;a href=&quot;../language/operators&quot;&gt;사용자 정의 연산자 ==&lt;/a&gt; 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="129c710e9009508a2e1a7fdb48457bda967c930d" translate="yes" xml:space="preserve">
          <source>To satisfy this requirement, types that do not have built-in &lt;a href=&quot;../language/operator_comparison&quot;&gt;comparison operators&lt;/a&gt; have to provide a &lt;a href=&quot;../language/operators#Relational_operators&quot;&gt;user-defined operator&amp;lt;&lt;/a&gt;</source>
          <target state="translated">이 요구 사항을 충족하려면 내장 &lt;a href=&quot;../language/operator_comparison&quot;&gt;비교 연산자&lt;/a&gt; 가 없는 유형 은 &lt;a href=&quot;../language/operators#Relational_operators&quot;&gt;사용자 정의 연산자&lt;/a&gt; 를 제공해야합니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="17417ca14266e537b698e5e14276654d4c17a975" translate="yes" xml:space="preserve">
          <source>To satisfy thread safety requirements, the reference counters are typically incremented using an equivalent of &lt;code&gt;&lt;a href=&quot;../atomic/atomic/fetch_add&quot;&gt;std::atomic::fetch_add&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; (decrementing requires stronger ordering to safely destroy the control block).</source>
          <target state="translated">스레드 안전 요구 사항을 충족시키기 위해 참조 카운터는 일반적으로 &lt;code&gt;&lt;a href=&quot;../atomic/atomic/fetch_add&quot;&gt;std::atomic::fetch_add&lt;/a&gt;&lt;/code&gt; 해당하는 값으로 증가합니다. &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; 와 함께 std :: 를 합니다 (감소하려면 제어 블록을 안전하게 파괴하기 위해 더 강한 순서가 필요합니다).</target>
        </trans-unit>
        <trans-unit id="8878bda84316e640272f36cf3fc4a73005bafae8" translate="yes" xml:space="preserve">
          <source>To simplify management of dynamically-allocated objects, the result of a new-expression is often stored in a</source>
          <target state="translated">동적으로 할당 된 객체의 관리를 단순화하기 위해 새로운 표현식의 결과는 종종</target>
        </trans-unit>
        <trans-unit id="72759510b678f958968f4cb0b51ad3056400cce9" translate="yes" xml:space="preserve">
          <source>To test the last two conditions, compilers may first perform a trial constant evaluation of the initializers. It is not recommended to depend on the result in this case.</source>
          <target state="translated">마지막 두 조건을 테스트하기 위해 컴파일러는 먼저 이니셜 라이저에 대한 시험 상수 평가를 수행 할 수 있습니다. 이 경우 결과에 의존하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2ef767a66957791708ed92649c40f252de18b675" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; (&lt;/code&gt;arg1, arg2, ...&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt; (&lt;/code&gt; arg1, arg2, ... &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fd5e6c8eaf332caffe8f6fbe44a90cd7d1b98a0" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; {&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;=&lt;/code&gt;arg1&lt;code&gt;,&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;{&lt;/code&gt;arg2&lt;code&gt;} &lt;/code&gt;... &lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt; {&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; 부호 &lt;code&gt;=&lt;/code&gt; ARG1 &lt;code&gt;,&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; 지정자 &lt;code&gt;{&lt;/code&gt; arg2 &lt;code&gt;} &lt;/code&gt; ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8524224705b06e86014d7113489a9fa766f785d6" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; {&lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt; {&lt;/code&gt; arg1, arg2, ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fa04374ca1b3d5854920daae3a860b764cf4bc1" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;( &lt;/code&gt;arg1, arg2, ...&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;( &lt;/code&gt; arg1, arg2, ... &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad21f03c3b6e98547a57e446e234ea4a3bc549c4" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;( &lt;/code&gt;arg&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;( &lt;/code&gt; arg &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73dc4cf67a69ee8abf0145c5834683df2e89c44e" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8be85a4e1d42709d6cc3339f92d0ed646df7afbf" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;= {&lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;= {&lt;/code&gt; arg1, arg2, ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="749c4b6dafadee83198511f34995fe4793451e2c" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;&lt;code&gt; {&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;=&lt;/code&gt;arg1&lt;code&gt;,&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;{&lt;/code&gt;arg2&lt;code&gt;} &lt;/code&gt;... &lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;=&lt;/code&gt; &lt;code&gt; {&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; 부호 &lt;code&gt;=&lt;/code&gt; ARG1 &lt;code&gt;,&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; 지정자 &lt;code&gt;{&lt;/code&gt; arg2 &lt;code&gt;} &lt;/code&gt; ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66d34b7b6a63046c11e32cb28d0bfdc320edb9c6" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;other&lt;code&gt;} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;=&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; 기타 &lt;code&gt;} &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca0bdecf7ffe3b07ea0bd6237e1e29b32609b1b3" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;=&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="709755aaf5485c722f9b0e75a1395ff736803b24" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;{ &lt;/code&gt; arg1, arg2, ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61782cc12972859d36df728c91f3cae207b1187e" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{ &lt;/code&gt;arg&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;{ &lt;/code&gt; arg &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f01015bfa0f56ac60d1e5a7cf450991d276e29b7" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{};&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;{};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ddb24f2589165d45d6ccb527543d8886fc657afc" translate="yes" xml:space="preserve">
          <source>Together with identifiers they are known as</source>
          <target state="translated">식별자와 함께</target>
        </trans-unit>
        <trans-unit id="3eff2f682c2bec3252c55e73a2e17235c924d9ac" translate="yes" xml:space="preserve">
          <source>Toggles each &lt;code&gt;bool&lt;/code&gt; in the vector (replaces with its opposite value).</source>
          <target state="translated">벡터의 각 &lt;code&gt;bool&lt;/code&gt; 을 토글합니다 (반대 값으로 대체).</target>
        </trans-unit>
        <trans-unit id="f77fbd9a82d243179f6ff219e1e46df3d7caa6d5" translate="yes" xml:space="preserve">
          <source>Too many files open in system</source>
          <target state="translated">시스템에 너무 많은 파일이 열려 있습니다</target>
        </trans-unit>
        <trans-unit id="2e0d2eef3cc8719301cd02a8aeecb9e956e88cf1" translate="yes" xml:space="preserve">
          <source>Too many levels of symbolic links</source>
          <target state="translated">너무 많은 수준의 심볼릭 링크</target>
        </trans-unit>
        <trans-unit id="4113b4c9ebd053469430304ab17dc16ea1d01df9" translate="yes" xml:space="preserve">
          <source>Too many links</source>
          <target state="translated">너무 많은 링크</target>
        </trans-unit>
        <trans-unit id="171702bf2e722b21f3bd6c8ccb2927b1ba5f9e5e" translate="yes" xml:space="preserve">
          <source>Total ordering relation opposite to &lt;code&gt;a &amp;lt; b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a &amp;lt; b&lt;/code&gt; 와 반대되는 총 주문 관계</target>
        </trans-unit>
        <trans-unit id="00914541a4417609db5b497e533746eecb783cd5" translate="yes" xml:space="preserve">
          <source>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.</source>
          <target state="translated">전체 순차 주문에는 모든 멀티 코어 시스템에서 전체 메모리 펜스 CPU 명령이 필요합니다. 영향을받는 메모리 액세스가 모든 코어에 전파되도록하기 때문에 성능 병목 현상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dad674e48704a92597b8a13244ba1d8ca29324b7" translate="yes" xml:space="preserve">
          <source>Trade-offs</source>
          <target state="translated">Trade-offs</target>
        </trans-unit>
        <trans-unit id="ef3b5b7a3bf5164b6e6ee23c058ba72528930808" translate="yes" xml:space="preserve">
          <source>Trade-offs / usage notes</source>
          <target state="translated">트레이드 오프 / 사용 메모</target>
        </trans-unit>
        <trans-unit id="7cf26da75debf6bbf1e4104795dc48892c4d5484" translate="yes" xml:space="preserve">
          <source>Trailing return type, useful if the return type depends on argument names, such as &lt;code&gt;template &amp;lt;class T, class U&amp;gt; auto add(T t, U u) -&amp;gt; decltype(t + u);&lt;/code&gt; or is complicated, such as in &lt;code&gt;auto fpif(int)-&amp;gt;int(*)(int)&lt;/code&gt;</source>
          <target state="translated">후행 리턴 유형. 리턴 유형이 &lt;code&gt;template &amp;lt;class T, class U&amp;gt; auto add(T t, U u) -&amp;gt; decltype(t + u);&lt;/code&gt; 과 같은 인수 이름에 의존하는 경우에 유용합니다 . 또는 &lt;code&gt;auto fpif(int)-&amp;gt;int(*)(int)&lt;/code&gt; 와 같이 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="d1a616085a1a99a58e14bafaa350abc6783a3160" translate="yes" xml:space="preserve">
          <source>Traits</source>
          <target state="translated">Traits</target>
        </trans-unit>
        <trans-unit id="cd91d96e3393ae0f62bad1c5ed125449050e450f" translate="yes" xml:space="preserve">
          <source>Transaction-safe functions</source>
          <target state="translated">거래 안전 기능</target>
        </trans-unit>
        <trans-unit id="79ed6ec4dd6c977b5231ac5a3a3185c0bc9188fd" translate="yes" xml:space="preserve">
          <source>Transaction-safe virtual functions</source>
          <target state="translated">트랜잭션 안전 가상 기능</target>
        </trans-unit>
        <trans-unit id="28bf6d401ae77b97e36abdf2221c6cfe2e85fc1e" translate="yes" xml:space="preserve">
          <source>Transactional memory</source>
          <target state="translated">트랜잭션 메모리</target>
        </trans-unit>
        <trans-unit id="76f8221e9e089679019e2f0fa532136f150e6dc7" translate="yes" xml:space="preserve">
          <source>Transactional memory is a concurrency synchronization mechanism that combines groups of statements in transactions, that are.</source>
          <target state="translated">트랜잭션 메모리는 트랜잭션에서 명령문 그룹을 결합하는 동시성 동기화 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="6b317497e33c505c0091e508e0f819e953607bb9" translate="yes" xml:space="preserve">
          <source>Transfers control to one of the several statements, depending on the value of a condition.</source>
          <target state="translated">조건 값에 따라 여러 명령문 중 하나로 제어를 전송합니다.</target>
        </trans-unit>
        <trans-unit id="3ae0e89e8b68942479d9172eed374b0285eee3cc" translate="yes" xml:space="preserve">
          <source>Transfers control unconditionally.</source>
          <target state="translated">무조건 제어를 전송합니다.</target>
        </trans-unit>
        <trans-unit id="1f702e1322ae9e879ee08e3f62c5bdb1e12300d8" translate="yes" xml:space="preserve">
          <source>Transfers elements from one list to another.</source>
          <target state="translated">한 목록에서 다른 목록으로 요소를 전송합니다.</target>
        </trans-unit>
        <trans-unit id="3de309422c516a3c7cf8622a78d8e35f6e1be1eb" translate="yes" xml:space="preserve">
          <source>Transfers the shared state of &lt;code&gt;*this&lt;/code&gt;, if any, to a &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; object. Multiple &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; objects may reference the same shared state, which is not possible with &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">전송의 공유 상태 &lt;code&gt;*this&lt;/code&gt; 하는에있는 경우 &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; 객체입니다. 여러 &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; 객체가 동일한 공유 상태를 참조 할 수 있으며 &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 에서는 불가능합니다 .</target>
        </trans-unit>
        <trans-unit id="17a159e3083a2a40c26d036cc1b99d55a3a0d7c4" translate="yes" xml:space="preserve">
          <source>Transform the elements of the output range according to the following algorithm:</source>
          <target state="translated">다음 알고리즘에 따라 출력 범위의 요소를 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="0d2ad20c7dacbba2fdbdd4ce378e8828c433c3a1" translate="yes" xml:space="preserve">
          <source>TransformationTrait</source>
          <target state="translated">TransformationTrait</target>
        </trans-unit>
        <trans-unit id="7bfde37a73ea6090d21989590088e7aade736914" translate="yes" xml:space="preserve">
          <source>TransformationTraits Redux</source>
          <target state="translated">TransformationTraits Redux</target>
        </trans-unit>
        <trans-unit id="4ce48d092354c3cfaf58f19e47f595e8893390a1" translate="yes" xml:space="preserve">
          <source>Transforms each element in the range &lt;code&gt;[first, last)&lt;/code&gt; with &lt;code&gt;unary_op&lt;/code&gt;, then computes an exclusive prefix sum operation using &lt;code&gt;binary_op&lt;/code&gt; over the resulting range, with &lt;code&gt;init&lt;/code&gt; as the initial value, and writes the results to the range beginning at &lt;code&gt;d_first&lt;/code&gt;. &quot;exclusive&quot; means that the i-th input element is not included in the i-th sum.</source>
          <target state="translated">범위 &lt;code&gt;[first, last)&lt;/code&gt; 범위의 각 요소 를 &lt;code&gt;unary_op&lt;/code&gt; 로 변환 한 다음 결과 범위에서 &lt;code&gt;binary_op&lt;/code&gt; 를 사용하여 &lt;code&gt;init&lt;/code&gt; 를 초기 값으로 사용하여 독점 접두사 합계 연산을 계산 하고 결과를 &lt;code&gt;d_first&lt;/code&gt; 에서 시작하는 범위에 씁니다 . &quot;배타적&quot;은 i 번째 입력 요소가 i 번째 합계에 포함되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="76499db2839b046f9ef84418dd0b227738ab59b2" translate="yes" xml:space="preserve">
          <source>Transforms each element in the range &lt;code&gt;[first, last)&lt;/code&gt; with &lt;code&gt;unary_op&lt;/code&gt;, then computes an inclusive prefix sum operation using &lt;code&gt;binary_op&lt;/code&gt; over the resulting range, optionally with &lt;code&gt;init&lt;/code&gt; as the initial value, and writes the results to the range beginning at &lt;code&gt;d_first&lt;/code&gt;. &quot;inclusive&quot; means that the i-th input element is included in the i-th sum.</source>
          <target state="translated">변환 범위의 각 요소 &lt;code&gt;[first, last)&lt;/code&gt; 와 &lt;code&gt;unary_op&lt;/code&gt; 는 , 다음 사용을 포함 프리픽스 총 운전 계산 &lt;code&gt;binary_op&lt;/code&gt; 을 선택적으로 생성 범위를 &lt;code&gt;init&lt;/code&gt; 초기 값으로하고있는 범위의 처음에 그 결과를 기록 &lt;code&gt;d_first&lt;/code&gt; . &quot;포함&quot;은 i 번째 입력 요소가 i 번째 합계에 포함됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1c65f6d1ba0f638d5024c5624db7ea27406001c1" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 널 종료 바이트 문자열을 구현 정의 양식으로 변환하여 두 개의 변환 된 문자열을 &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; 와 비교 하면 현재 C 로케일에서 원래 문자열을 &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt; 과 비교하는 것과 동일한 결과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b23c453442ba4c19cf270e32634b19b7e31b8f29" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated wide string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 가 가리키는 널 종료 와이드 문자열을 구현 정의 양식으로 변환하여 두 개의 변환 된 문자열을 &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; 와 비교 하면 현재 C 로케일에서 원래 문자열을 &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt; 과 비교하는 것과 동일한 결과를 얻습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
