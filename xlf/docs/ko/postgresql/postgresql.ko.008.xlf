<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d06f9c00387f2a47db4df9d5fd9d29afd85a64d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.60. General-Purpose Window Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.60. 범용 윈도우 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a7332511d931adb3973faa13e02e9a2f58c70fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.61. Series Generating Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.61. 시리즈 생성 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09c4a37f6c6f303582adee38d96973e59b8f1d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.62. Subscript Generating Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.62. 첨자 생성 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2135932869620b53f88c3e6313d35e2e57eb9554" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.63. Session Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.63. 세션 정보 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39be6ee87ea95e25c83a72d132334349eca53d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.64. Access Privilege Inquiry Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.64. 액세스 권한 조회 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f88ee46d75d93ee18420ab0ac7544df7b69f3ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.65. &lt;code&gt;aclitem&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.65. &lt;code&gt;aclitem&lt;/code&gt; 운영자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bff51c4fac1999b618aa6e81c66b1e1f53e8a09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.66. &lt;code&gt;aclitem&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.66. &lt;code&gt;aclitem&lt;/code&gt; 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6ba9eacd371b2f2875e8cef1278fb77ebcd99c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.67. Schema Visibility Inquiry Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.67. 스키마 가시성 조회 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47c6aca319addf46ce6b419f1af927dda7149772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.68. System Catalog Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.68. 시스템 카탈로그 정보 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="59944c027b46284746c3c0d85e815a750a8891d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.69. Index Column Properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.69. 인덱스 열 속성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1714aed665ee3ec122913f297f2add6146e8617b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.7. Trigonometric Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.7. 삼각 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1931873243f7b29fd60849cb0265f82b1b3daa21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.70. Index Properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.70. 인덱스 속성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="494455ae6249fdb9eaf4bc96c399bcc0b3287c53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.71. Index Access Method Properties&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.71. 인덱스 액세스 방법 속성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d4a0d7f19cdaf9dd206d8238d622ef290fa34c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.72. Object Information and Addressing Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.72. 객체 정보 및 주소 지정 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2397166ddbff9e584fb4c1463d367dec3f650e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.73. Comment Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.73. 코멘트 정보 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a9e98e7f47369de4f674860d137be126fa8ff10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.74. Transaction ID and Snapshot Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.74. Transaction ID and Snapshot Information Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80e1c97f51ff6d0e29990ff06de5f0ff4842e1bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.74. Transaction IDs and Snapshots&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.74. 거래 ID 및 스냅 샷&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9297bd2822b43f167f4851fa970b2be7bc55e646" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.75. Snapshot Components&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.75. 스냅 샷 구성 요소&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9fe3f4e24a04a45285feb4f7f3c39797576ff14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.76. Committed Transaction Information&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.76. 커밋 된 거래 정보&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec457094df6650e5b59b2d695b38d59162000858" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.76. Deprecated Transaction ID and Snapshot Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.76. Deprecated Transaction ID and Snapshot Information Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="037beea666806eb579eb1e15cade8169bb088d22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.77. Committed Transaction Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.77. Committed Transaction Information Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22faf23155a7f6cdba38cb993e993be8e97bdafa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.77. Control Data Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.77. 제어 데이터 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10369b4d2384de89827853c38a3dbb088df94279" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.78. &lt;code&gt;pg_control_checkpoint&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.78. &lt;code&gt;pg_control_checkpoint&lt;/code&gt; 열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4c03e3db71b0f0e87bd2ea049915cd526ae3e4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.78. Control Data Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.78. Control Data Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a853addac70ca1f81119d41bef07e20f8877b599" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.79. &lt;code&gt;pg_control_checkpoint&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.79. &lt;code&gt;pg_control_checkpoint&lt;/code&gt; Output Columns&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be67b2ae4fcc41758e4db5cec6bff447ce947830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.79. &lt;code&gt;pg_control_system&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.79. &lt;code&gt;pg_control_system&lt;/code&gt; 열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc142fb66ffa0a6f7f6394c00a57cfad199c4be9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.8. Hyperbolic Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.8. 쌍곡선 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="69d99a933c31e93d42b87a8d05638885de6cef43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.80. &lt;code&gt;pg_control_init&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.80. &lt;code&gt;pg_control_init&lt;/code&gt; 열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f8b6c4cc1095d92081bffbb653c34b6d02d3743" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.80. &lt;code&gt;pg_control_system&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.80. &lt;code&gt;pg_control_system&lt;/code&gt; Output Columns&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a173f9966d00cc18bb434a3a4ab064b9459dfff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.81. &lt;code&gt;pg_control_init&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.81. &lt;code&gt;pg_control_init&lt;/code&gt; Output Columns&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="efe7424b608f8ebbc9334ad7d348b73c225f8065" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.81. &lt;code&gt;pg_control_recovery&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.81. &lt;code&gt;pg_control_recovery&lt;/code&gt; 열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a159d3ea3ae4f3ccfc518444dfa8484fdb024615" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.82. &lt;code&gt;pg_control_recovery&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.82. &lt;code&gt;pg_control_recovery&lt;/code&gt; Output Columns&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="258d4eca1eec881df06fbf6eb5c508a7eb4defe6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.82. Configuration Settings Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.82. 구성 설정 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e119847bd2faa7c76a5c66565911ba36a9ec0410" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.83. Configuration Settings Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.83. Configuration Settings Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="af63c82b09a5fd893d3cbed8d4c9b65a84c8cc49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.83. Server Signaling Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.83. 서버 신호 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e11c93734b157fd8c86baa8c5096f64613f03240" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.84. Backup Control Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.84. 백업 제어 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2acca3a24f9bc4df489286e833e69b95dc624f3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.84. Server Signaling Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.84. Server Signaling Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d2eccbc931adbf83e2e35ba4730cc92f21be424" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.85. Backup Control Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.85. Backup Control Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c1cf89f9807ef48af5dc5feac483e531ed89fb76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.85. Recovery Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.85. 복구 정보 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eb7192e9cdc53717cb1d3a3d7a47063c367c5fd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.86. Recovery Control Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.86. 복구 제어 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="18d1b2e85a47e7957190d7b5366cb8b95a8619e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.86. Recovery Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.86. Recovery Information Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c22940566328cfb562e298f923b5c5b854ba617" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.87. Recovery Control Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.87. Recovery Control Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cc57c799c7d7ee53ed8b4b0bf37c2b80ea6845e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.87. Snapshot Synchronization Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.87. 스냅 샷 동기화 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56158ae74f61cf23e3e86908ca0820720f4c8518" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.88. Replication SQL Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.88. 복제 SQL 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e4a778f3f4aea3b01888a18431c4aec5450cf91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.88. Snapshot Synchronization Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.88. Snapshot Synchronization Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53a72ba96b99dede4aa68dbbb8f2f4f443280905" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.89. Database Object Size Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.89. 데이터베이스 객체 크기 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c7eb24e29872bb8ce841d184195dca28e365a088" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.89. Replication Management Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.89. Replication Management Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0821b82f66d9f4a6e0cd038e52ed04c3f7a05a58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.9. SQL String Functions and Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.9. SQL 문자열 함수 및 연산자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8690793f9807c3f5f8ee02a7cc52f489067f885d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.90. Database Object Location Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.90. 데이터베이스 객체 위치 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57f81cd7ef731234c1aa58e5ac57c4b20d50b59f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.90. Database Object Size Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.90. Database Object Size Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1dac1ecbd39f8f56220a662263d1df23c3bd1d5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.91. Collation Management Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.91. 데이터 정렬 관리 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="648f3f86b8b877c2a7cf1d1174a61e4e892421ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.91. Database Object Location Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.91. Database Object Location Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75784f3209f818a7b4abe3d1335fa8a55370c481" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.92. Collation Management Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.92. Collation Management Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1d40194ab60a69acde4e12b20bea43def6aedf5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.92. Partitioning Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.92. 분할 정보 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c370022e15dfd2d0b3991d342e19956b98c04f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.93. Index Maintenance Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.93. 인덱스 유지 보수 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2937ed5c90d57a915d7a2b0a154f93953f850843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.93. Partitioning Information Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.93. Partitioning Information Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8379ad039963b5ac568013d446df9562b67c6abc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.94. Generic File Access Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.94. 일반 파일 액세스 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42b95f05574afc667abf5b3192f21fdebd527e31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.94. Index Maintenance Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.94. Index Maintenance Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c5e2d3bc1f47aa4a1635eb7f3cff3425017bca1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.95. Advisory Lock Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 9.95. 자문 잠금 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3110ab11d26d5acb24d0ef4008dbf1062e59f19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.95. Generic File Access Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.95. Generic File Access Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="669703497d2e61484f74a9f852b77c7dbe96af61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table 9.96. Advisory Lock Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table 9.96. Advisory Lock Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd947ce6d00206881c9746604187286ad479d127" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table A.1. PostgreSQL Error Codes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 A.1. PostgreSQL 오류 코드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a05dac2107a5f9f2ac31f3b94de8292ede9abce7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table B.1. Month Names&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 B.1. 월 이름&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d0ce6d7b1e15e8e01aa65312fb0df9adeaf930d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table B.2. Day of the Week Names&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 B.2. 요일 이름&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4035fdc79af664ad037421045dfc08f552eb1aa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table B.3. Date/Time Field Modifiers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 B.3. 날짜 / 시간 필드 수정 자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="559edd83cb5073785f38017209bf4a3b36ac0ed6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table C.1. SQL Key Words&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 C.1. SQL 키워드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8d10534ea211538918961793e09cac043e6061f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.1. &lt;code&gt;adminpack&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.1. &lt;code&gt;adminpack&lt;/code&gt; 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b519c1bf6f735544d2045d66c60755bcd006027" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.10. &lt;code&gt;intarray&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.10. &lt;code&gt;intarray&lt;/code&gt; 연산자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c07b2821b106599e7e19c067ef0623853754e74b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.11. &lt;code&gt;isn&lt;/code&gt; Data Types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.11. &lt;code&gt;isn&lt;/code&gt; 데이터 유형&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9de57df1bb6bd0b8cf1c93e4ac13f3f2cd6cec28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.12. &lt;code&gt;isn&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.12. &lt;code&gt;isn&lt;/code&gt; 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5fc76943f1f53439b794c832fa0195dc25753eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.13. &lt;code&gt;ltree&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.13. &lt;code&gt;ltree&lt;/code&gt; 연산자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f47dedf5cd81c558ae828df89aeceeffbcca4ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.14. &lt;code&gt;ltree&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.14. &lt;code&gt;ltree&lt;/code&gt; 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db1ea3c10d5f847276d5255278d415ebe4cfbb7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.15. &lt;code&gt;pg_buffercache&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.15. &lt;code&gt;pg_buffercache&lt;/code&gt; 열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bb70b4765f6524df3f91e44d66f42eb9ce59f1f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.16. Supported Algorithms for &lt;code&gt;crypt()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.16. &lt;code&gt;crypt()&lt;/code&gt; 지원되는 알고리즘&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="74efd3a20d0a5ca77d9ec0d65a88482478d0db59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.17. Iteration Counts for &lt;code&gt;crypt()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.17. &lt;code&gt;crypt()&lt;/code&gt; 반복 횟수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e16082250b8218899af06afb261507b192bd2a3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.18. Hash Algorithm Speeds&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.18. 해시 알고리즘 속도&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="023c35c98f9f91629573b50cb356cd985b32d53d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.19. Summary of Functionality with and without OpenSSL&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.19. OpenSSL 유무에 따른 기능 요약&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="97b5d7566b2274950bfb99f59140174951e32afe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.2. Cube External Representations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.2. 큐브 외부 표현&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="31519ff8934e1c9d30bb975be3e1d15050040610" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.20. &lt;code&gt;pgrowlocks&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.20. &lt;code&gt;pgrowlocks&lt;/code&gt; 출력 열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40ee7b256a4076cfeae51995de13c374ee02588a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.21. &lt;code&gt;pg_stat_statements&lt;/code&gt; Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.21. &lt;code&gt;pg_stat_statements&lt;/code&gt; 열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2bf9da321dec29d80c37b3aec85adcfd8d4e6ca7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.22. &lt;code&gt;pgstattuple&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.22. &lt;code&gt;pgstattuple&lt;/code&gt; 출력 열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36d397f9b671a3e1925bb2eb0936f8f0832e9789" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.23. &lt;code&gt;pgstattuple_approx&lt;/code&gt; Output Columns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.23. &lt;code&gt;pgstattuple_approx&lt;/code&gt; 출력 열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c437a7af148f8e8389f5c7449218ce3b637fba68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.24. &lt;code&gt;pg_trgm&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.24. &lt;code&gt;pg_trgm&lt;/code&gt; 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76d05073c0bf7063af3660fac90eb31ef8a83d22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.25. &lt;code&gt;pg_trgm&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.25. &lt;code&gt;pg_trgm&lt;/code&gt; 연산자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b53fc25e7d7cf3149fa7d701cb97669cc4302291" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.26. &lt;code&gt;seg&lt;/code&gt; External Representations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.26. &lt;code&gt;seg&lt;/code&gt; 외부 표현&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fce95711636b8b7c0ab0c8c90a10676ec4c5dd99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.27. Examples of Valid &lt;code&gt;seg&lt;/code&gt; Input&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.27. 유효한 &lt;code&gt;seg&lt;/code&gt; 입력의 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0703329077e17e37589124cf687bfbdb4ff5f02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.28. Seg GiST Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.28. 세그먼트 GiST 연산자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7efb677aa5a54059bffe378ceabe3ff851dc97be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.29. Sepgsql Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.29. Sepgsql 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3a4b5bfe663b6c86554a4fe157eb1e9883705ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.3. Cube Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.3. 큐브 연산자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2f068919e3f99a106ec1019bd78e8bde34335d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.30. &lt;code&gt;tablefunc&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.30. &lt;code&gt;tablefunc&lt;/code&gt; 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c27a41af6ae7cee6f4a14c9d9a0b8aef27e683da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.31. &lt;code&gt;connectby&lt;/code&gt; Parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.31. &lt;code&gt;connectby&lt;/code&gt; 매개 변수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eccc0fa14874dcf09c6ccf36766eb1c65d7a9d87" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.32. Functions for UUID Generation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.32 UUID 생성을위한 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="285949d92f8186403bfcd2046f6dcc6813339504" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.33. Functions Returning UUID Constants&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.33. UUID 상수를 반환하는 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce4775173e0a8d85b3a4c68976acfaac26cdbeba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.34. &lt;code&gt;xml2&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Table F.34. &lt;code&gt;xml2&lt;/code&gt; Functions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b2710d2338031518ccc53baf6792d41b5ad8f677" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.34. Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.34. 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e4038c34dc95dfcc18297824a175effec134055" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.35. &lt;code&gt;xpath_table&lt;/code&gt; Parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.35. &lt;code&gt;xpath_table&lt;/code&gt; 매개 변수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42b35f9c6abb36ad8fc92db8bdc01beb1c4250a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.4. Cube Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.4. 큐브 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e92b11d7884dfede47b04bfcbf5a41bf72e63d9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.5. Cube-Based Earthdistance Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.5. 큐브 기반 지구 거리 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e051b81229455604f98408865a6ac1b4addebbc2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.6. Point-Based Earthdistance Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.6. 점 기반 지구 거리 연산자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="abcf169338c4abfd8292e2d9fff28e5b2b09033c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.7. &lt;code&gt;hstore&lt;/code&gt; Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.7. &lt;code&gt;hstore&lt;/code&gt; 연산자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40c6e68eca0fdcd7802454203dbb36dbc3ddb825" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.8. &lt;code&gt;hstore&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.8. &lt;code&gt;hstore&lt;/code&gt; 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1d86c143b9375e6f997fb5dadf92e3e129f96c3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table F.9. &lt;code&gt;intarray&lt;/code&gt; Functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 F.9. &lt;code&gt;intarray&lt;/code&gt; 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d890fb1a42200a1b33e3307e2ccd5c9035ab6794" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table K.1. PostgreSQL Limitations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표 K.1. PostgreSQL 제한&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="696c4ceafbfe949ae4e1ac9f260a8e4f375683bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table of Contents&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;목차&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1bf69c48186996b82fe7b81247ad9250cfca6c96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table-Level Lock Modes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;테이블 레벨 잠금 모드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be38ff52aef87b71c69cb929026cdf03c79939a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Type Resolution for &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;CASE&lt;/code&gt;, and Related Constructs&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;CASE&lt;/code&gt; 및 관련 구문의 유형 확인&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5460fb3b002cb82e36bdab3a44937749c957abe2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Upgrade streaming replication and log-shipping standby servers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;스트리밍 복제 및 로그 전달 대기 서버 업그레이드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a0c5de3159b80d3a3ca8692e2ddf1964928d7107" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;split&lt;/code&gt;. &lt;/strong&gt; The &lt;code&gt;split&lt;/code&gt; command allows you to split the output into smaller files that are acceptable in size to the underlying file system. For example, to make chunks of 1 megabyte:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;split&lt;/code&gt; 을 사용하십시오 . &lt;/strong&gt; &lt;code&gt;split&lt;/code&gt; 명령은 기본 파일 시스템의 크기와 허용되는 작은 파일로 출력을 분할 할 수 있습니다. 예를 들어, 1MB의 청크를 만들려면</target>
        </trans-unit>
        <trans-unit id="1a80b9aa68fb3c8b73036c3ce7eec622afb708fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use compressed dumps. &lt;/strong&gt; You can use your favorite compression program, for example gzip:</source>
          <target state="translated">&lt;strong&gt;압축 덤프를 사용하십시오. &lt;/strong&gt;좋아하는 압축 프로그램 (예 : gzip)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1abab695321f295c720b6c84d1b5599f942c1413" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use pg_dump's custom dump format. &lt;/strong&gt; If PostgreSQL was built on a system with the zlib compression library installed, the custom dump format will compress data as it writes it to the output file. This will produce dump file sizes similar to using &lt;code&gt;gzip&lt;/code&gt;, but it has the added advantage that tables can be restored selectively. The following command dumps a database using the custom dump format:</source>
          <target state="translated">&lt;strong&gt;pg_dump의 커스텀 덤프 형식을 사용하십시오. &lt;/strong&gt;zlib 압축 라이브러리가 설치된 시스템에서 PostgreSQL을 빌드 한 경우 사용자 정의 덤프 형식은 출력 파일에 데이터를 쓸 때 데이터를 압축합니다. 이것은 &lt;code&gt;gzip&lt;/code&gt; 을 사용하는 것과 유사한 덤프 파일 크기를 생성 하지만 테이블을 선택적으로 복원 할 수 있다는 추가 이점이 있습니다. 다음 명령은 사용자 정의 덤프 형식을 사용하여 데이터베이스를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="cbfe9fc7a7a29e0a0178f83061d2c90c3e3b191c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use pg_dump's parallel dump feature. &lt;/strong&gt; To speed up the dump of a large database, you can use pg_dump's parallel mode. This will dump multiple tables at the same time. You can control the degree of parallelism with the &lt;code&gt;-j&lt;/code&gt; parameter. Parallel dumps are only supported for the &quot;directory&quot; archive format.</source>
          <target state="translated">&lt;strong&gt;pg_dump의 병렬 덤프 기능을 사용하십시오. &lt;/strong&gt;큰 데이터베이스의 덤프 속도를 높이기 위해 pg_dump의 병렬 모드를 사용할 수 있습니다. 동시에 여러 테이블을 덤프합니다. &lt;code&gt;-j&lt;/code&gt; 매개 변수를 사용하여 병렬 처리 수준을 제어 할 수 있습니다 . 병렬 덤프는 &quot;디렉토리&quot;아카이브 형식에 대해서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="edfa928646e2342a7f8cd8c011c0572d9d895659" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Value Storage Type Conversion&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가치 저장 유형 변환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf7bb1fedc9115854eb42fd28c3bf8a588f25119" translate="yes" xml:space="preserve">
          <source>@ 1 year 2 mons</source>
          <target state="translated">@ 1 년 2 개월</target>
        </trans-unit>
        <trans-unit id="03555338c898371183a9886d4e4b1c92f3732990" translate="yes" xml:space="preserve">
          <source>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</source>
          <target state="translated">@ 1 년 2 개월 -3 일 4 시간 5 분 6 초 전</target>
        </trans-unit>
        <trans-unit id="81d943392746fd8a7d1a28c6c2928f65ea407380" translate="yes" xml:space="preserve">
          <source>@ 3 days 4 hours 5 mins 6 secs</source>
          <target state="translated">@ 3 일 4 시간 5 분 6 초</target>
        </trans-unit>
        <trans-unit id="bf2057e4a34b0143c5ca30f416938d0496f64cf4" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;from SQL&amp;rdquo; function that converts the type from the SQL environment to the language. This function will be invoked on the arguments of a function written in the language.</source>
          <target state="translated">SQL 환경에서 언어로 유형을 변환하는 &quot;from SQL&quot;기능. 이 함수는 언어로 작성된 함수의 인수에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5d8d466be36923654e1e5048281d3752210ffa26" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;nil&amp;rdquo; UUID constant, which does not occur as a real UUID.</source>
          <target state="translated">&quot;nil&quot;UUID 상수로 실제 UUID로는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2762eb369c90d7266035a7f6c6fc6bc10aa918a6" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;search&amp;rdquo; operator entry indicates that an index of this operator family can be searched to find all rows satisfying &lt;code&gt;WHERE&lt;/code&gt;&lt;code&gt;indexed_column&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Obviously, such an operator must return &lt;code&gt;boolean&lt;/code&gt;, and its left-hand input type must match the index's column data type.</source>
          <target state="translated">&quot;검색&quot;연산자 항목은이 연산자 패밀리의 색인을 검색하여 &lt;code&gt;WHERE&lt;/code&gt; &lt;code&gt;indexed_column&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; 를 만족시키는 모든 행을 찾을 수 있음을 나타냅니다 . 분명히 이러한 연산자는 &lt;code&gt;boolean&lt;/code&gt; 을 반환해야 하며 왼쪽 입력 유형은 인덱스의 열 데이터 유형과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb8c23a8cc28795360368ac535c18eb45a0b60b7" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;to SQL&amp;rdquo; function that converts the type from the language to the SQL environment. This function will be invoked on the return value of a function written in the language.</source>
          <target state="translated">유형을 언어에서 SQL 환경으로 변환하는 &quot;to SQL&quot;기능. 이 함수는 언어로 작성된 함수의 반환 값에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3ae930caf5146f65e1ff7504137e6bf65415863f" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;user logging out&amp;rdquo; might happen as part of a maintenance job or manually when an administrator logs in as the &lt;code&gt;postgres&lt;/code&gt; user or something similar, so it is hard to prevent in general.</source>
          <target state="translated">&quot;사용자 로그 아웃&quot;은 유지 관리 작업의 일부로 또는 관리자가 &lt;code&gt;postgres&lt;/code&gt; 사용자 또는 이와 유사한 것으로 로그인 할 때 수동으로 발생할 수 있으므로 일반적으로 방지하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="1ff3ebb0f8189d5c79fdc8dc5893085ae875532b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; that is paired with a &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;primary&lt;/a&gt; database and is maintaining a copy of some or all of the primary database's data. The foremost reasons for doing this are to allow for greater access to that data, and to maintain availability of the data in the event that the &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;primary&lt;/a&gt; becomes unavailable.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; that is paired with a &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;primary&lt;/a&gt; database and is maintaining a copy of some or all of the primary database's data. The foremost reasons for doing this are to allow for greater access to that data, and to maintain availability of the data in the event that the &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;primary&lt;/a&gt; becomes unavailable.</target>
        </trans-unit>
        <trans-unit id="3b194a0aad401cf33db00ac53a2bc3183f5f056e" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;cluster&lt;/a&gt;'s storage space comprises the data directory plus any additional tablespaces.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;cluster&lt;/a&gt;'s storage space comprises the data directory plus any additional tablespaces.</target>
        </trans-unit>
        <trans-unit id="4c2f7268e91d10d9931079a4060abb1b24912d62" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; that combines (&lt;em&gt;aggregates&lt;/em&gt;) multiple input values, for example by counting, averaging or adding, yielding a single output value.</source>
          <target state="translated">A &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; that combines (&lt;em&gt;aggregates&lt;/em&gt;) multiple input values, for example by counting, averaging or adding, yielding a single output value.</target>
        </trans-unit>
        <trans-unit id="b8de6f610e2bf77390b8a376c81b44793683355f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; which can be defined to execute whenever a certain operation (&lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;) is applied to a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;. A trigger executes within the same &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt; as the statement which invoked it, and if the function fails, then the invoking statement also fails.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;함수&lt;/a&gt; 특정 조작 (마다 정의 될 수 실행할 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;TRUNCATE&lt;/code&gt; 가 ) (A)에인가되는 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; . 트리거는 트리거 를 호출 한 명령문 과 동일한 &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;트랜잭션&lt;/a&gt; 내에서 실행 되며 함수가 실패하면 호출 명령문도 실패합니다.</target>
        </trans-unit>
        <trans-unit id="0e2fccb32e2fa61d4f930e061e62abd8488bb50a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that contains data derived from a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or &lt;a href=&quot;glossary#GLOSSARY-MATERIALIZED-VIEW&quot;&gt;materialized view&lt;/a&gt;. Its internal structure supports fast retrieval of and access to the original data.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 또는 &lt;a href=&quot;glossary#GLOSSARY-MATERIALIZED-VIEW&quot;&gt;구체화 된 뷰&lt;/a&gt; 에서 파생 된 데이터를 포함 하는 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; . 내부 구조는 원본 데이터의 빠른 검색 및 액세스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="584813927fa0b70a127a5ac34c88fc5f5c387c54" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is defined by a &lt;code&gt;SELECT&lt;/code&gt; statement (just like a &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;view&lt;/a&gt;), but stores data in the same way that a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; does. It cannot be modified via &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; operations.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 문에 의해 정의 되지만 ( &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;view&lt;/a&gt; 와 마찬가지로 ) &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 과 동일한 방식으로 데이터를 저장 하는 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; 입니다 . &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 작업을 통해 수정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="389fa46ef8422aab8a4910b862a288c61f74078c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is defined by a &lt;code&gt;SELECT&lt;/code&gt; statement, but has no storage of its own. Any time a query references a view, the definition of the view is substituted into the query as if the user had typed it as a subquery instead of the name of the view.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; a로 정의된다 &lt;code&gt;SELECT&lt;/code&gt; 문하지만, 자신의 어떤 기억이 없습니다. 쿼리가 뷰를 참조 할 때마다 사용자가 뷰 이름 대신 하위 쿼리로 입력 한 것처럼 뷰의 정의가 쿼리로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="53c9b267d1a3c53d206839f21ecc0e74a5743f97" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that is in semantic terms the same as a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, but whose storage is distributed across several &lt;a href=&quot;glossary#GLOSSARY-PARTITION&quot;&gt;partitions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; 론적 측면에서와 동일한 &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블을&lt;/a&gt; 가진 기억 여러 분산되어 있지만, &lt;a href=&quot;glossary#GLOSSARY-PARTITION&quot;&gt;파티션&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4beb53d2dd032e24132f47b79c4ab9ee08f60da3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; transmitted from a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend process&lt;/a&gt; to a &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client&lt;/a&gt; upon the completion of an SQL command, usually a &lt;code&gt;SELECT&lt;/code&gt; but it can be an &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; command if the &lt;code&gt;RETURNING&lt;/code&gt; clause is specified.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관련하여&lt;/a&gt; A로부터 전송 된 &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;백엔드 프로세스&lt;/a&gt; A와 &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;클라이언트&lt;/a&gt; SQL 명령의 완료시는, 일반적으로 &lt;code&gt;SELECT&lt;/code&gt; 하지만 그것은 할 수 있습니다 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , 또는 &lt;code&gt;DELETE&lt;/code&gt; 경우 생성 명령 &lt;code&gt;RETURNING&lt;/code&gt; 절을 지정한다.</target>
        </trans-unit>
        <trans-unit id="15e75dd492c3448df99f37b47329397dc097e33f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which appears to have &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;columns&lt;/a&gt; similar to a regular &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, but will forward requests for data through its &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt;, which will return &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;result sets&lt;/a&gt; structured according to the definition of the &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; 가 보인다 &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;행&lt;/a&gt; 과 &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;열&lt;/a&gt; 정규 유사한 &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 있지만 통해 데이터 요청을 전달한다 &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;외국 데이터 래퍼&lt;/a&gt; 반환, &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;결과 집합&lt;/a&gt; 의 정의에 따른 구조화 &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;외부 테이블&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2896c9fab918dbff2c145f3310c61dcc0ebaadf8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;role&lt;/a&gt; that has the &lt;code&gt;LOGIN&lt;/code&gt; privilege.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;역할&lt;/a&gt; 이 &lt;code&gt;LOGIN&lt;/code&gt; 권한을.</target>
        </trans-unit>
        <trans-unit id="e0269b93f9965a7efd0bd4de79b884ef8ce24927" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; is considered &lt;a href=&quot;glossary#GLOSSARY-LOGGED&quot;&gt;logged&lt;/a&gt; if changes to it are sent to the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt;. By default, all regular tables are logged. A table can be specified as &lt;a href=&quot;glossary#GLOSSARY-UNLOGGED&quot;&gt;unlogged&lt;/a&gt; either at creation time or via the &lt;code&gt;ALTER TABLE&lt;/code&gt; command.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 에 대한 변경 사항이 &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt; 로 전송되면 테이블 이 &lt;a href=&quot;glossary#GLOSSARY-LOGGED&quot;&gt;기록 된&lt;/a&gt; 것으로 간주됩니다 . 기본적으로 모든 일반 테이블이 기록됩니다. 테이블은 생성시 또는 &lt;code&gt;ALTER TABLE&lt;/code&gt; 명령을 통해 &lt;a href=&quot;glossary#GLOSSARY-UNLOGGED&quot;&gt;로그되지 않은&lt;/a&gt; 것으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87f22694b8568dac5808dc2163d1d852566c139b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command which will provide the columns and rows of the view.</source>
          <target state="translated">뷰의 열과 행을 제공 하는 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 또는 &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="f5f1049f4109dc5db352ab8d92ece996eabd228c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command which will provide the rows to be returned by the cursor.</source>
          <target state="translated">커서가 리턴 할 행을 제공 하는 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 또는 &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="b8b71200935bf14bcaf475eabe324c9a915be563" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt;, or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command, or an &lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt; command that runs a prepared &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;TABLE&lt;/code&gt;, or &lt;code&gt;VALUES&lt;/code&gt; query.</source>
          <target state="translated">&lt;a href=&quot;sql-select&quot;&gt;SELECT는&lt;/a&gt; , &lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt; , 또는 &lt;a href=&quot;sql-values&quot;&gt;VALUES는&lt;/a&gt; 명령, 또는이 &lt;a href=&quot;sql-execute&quot;&gt;EXECUTE&lt;/a&gt; 준비된 실행 명령 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;TABLE&lt;/code&gt; 을 , 또는 &lt;code&gt;VALUES&lt;/code&gt; 쿼리를.</target>
        </trans-unit>
        <trans-unit id="b516d250c25b6e73cb44ebe944600ea4dcdfab57" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt;, or &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command. This query will run within a security-restricted operation; in particular, calls to functions that themselves create temporary tables will fail.</source>
          <target state="translated">&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; , &lt;a href=&quot;sql-select#SQL-TABLE&quot;&gt;TABLE&lt;/a&gt; , 또는 &lt;a href=&quot;sql-values&quot;&gt;VALUES는&lt;/a&gt; 명령. 이 쿼리는 보안이 제한된 작업 내에서 실행됩니다. 특히 자체적으로 임시 테이블을 작성하는 함수에 대한 호출이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="4c32cd6f04f46fa40c66ced5598180206388bcb3" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt;, &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; command whose results are to be copied. Note that parentheses are required around the query.</source>
          <target state="translated">&lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; , &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; , &lt;a href=&quot;sql-insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;sql-update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;sql-delete&quot;&gt;DELETE&lt;/a&gt; 그 결과입니다 복사 할 명령. 쿼리 주위에 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3aac443fc49c397d670128be5de3b30376a87d25" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;&lt;/code&gt; operator must be a strong ordering relation; that is, for all non-null values &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; 연산자는 강력한 주문과 관련하여해야합니다; 즉, 널이 아닌 모든 값 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="819a83c6160f87b8fbe9b47f7e8c2fcb8b3441e2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CASE&lt;/code&gt; construct used in this fashion will defeat optimization attempts, so it should only be done when necessary. (In this particular example, it would be better to sidestep the problem by writing &lt;code&gt;y &amp;gt; 1.5*x&lt;/code&gt; instead.)</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; 최적화 시도를 물리 칠 것입니다 이런 식으로 사용하는 구조는, 그래서 필요한 경우에만 수행해야합니다. (이 특정 예에서는 &lt;code&gt;y &amp;gt; 1.5*x&lt;/code&gt; 대신 써서 문제를 회피하는 것이 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="6247b7100ee328df210a70a605d94770307d4618" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CASE&lt;/code&gt; expression does not evaluate any subexpressions that are not needed to determine the result. For example, this is a possible way of avoiding a division-by-zero failure:</source>
          <target state="translated">&lt;code&gt;CASE&lt;/code&gt; 표현식은 결과를 결정하는 데 필요하지 않은 표현식을 평가하지 않습니다. 예를 들어, 이것은 0으로 나누기 실패를 피하는 가능한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="99c1d2ec7824e3f9be873b53497fbe438c59e00f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CREATE FUNCTION&lt;/code&gt; command is defined in the SQL standard. The PostgreSQL version is similar but not fully compatible. The attributes are not portable, neither are the different available languages.</source>
          <target state="translated">A는 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; 명령은 SQL 표준에 정의되어 있습니다. PostgreSQL 버전은 비슷하지만 완전히 호환되지는 않습니다. 속성은 이식 가능하지 않으며 사용 가능한 언어가 다릅니다.</target>
        </trans-unit>
        <trans-unit id="72fba28ad575d8675106f7a64f95b2cad77d64bd" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; command is defined in the SQL standard. The PostgreSQL version is similar but not fully compatible. For details see also &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt;.</source>
          <target state="translated">A는 &lt;code&gt;CREATE PROCEDURE&lt;/code&gt; 명령은 SQL 표준에 정의되어 있습니다. PostgreSQL 버전은 비슷하지만 완전히 호환되지는 않습니다. 자세한 내용은 &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d8bad9823a1eeb3d425248ce5d647ad68ad9035" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DELETE&lt;/code&gt; policy cannot have a &lt;code&gt;WITH CHECK&lt;/code&gt; expression, as it only applies in cases where records are being deleted from the relation, so that there is no new row to check.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; 정책은있을 수 없습니다 &lt;code&gt;WITH CHECK&lt;/code&gt; 에만 기록이 관계에서 삭제되는 경우에 적용되는 확인 할 새 행이없는 그래서, 식입니다.</target>
        </trans-unit>
        <trans-unit id="ffed91b9d2e2689c8f9096a3b8e654e3487952c0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;JOIN&lt;/code&gt; clause combines two &lt;code&gt;FROM&lt;/code&gt; items, which for convenience we will refer to as &amp;ldquo;tables&amp;rdquo;, though in reality they can be any type of &lt;code&gt;FROM&lt;/code&gt; item. Use parentheses if necessary to determine the order of nesting. In the absence of parentheses, &lt;code&gt;JOIN&lt;/code&gt;s nest left-to-right. In any case &lt;code&gt;JOIN&lt;/code&gt; binds more tightly than the commas separating &lt;code&gt;FROM&lt;/code&gt;-list items.</source>
          <target state="translated">A는 &lt;code&gt;JOIN&lt;/code&gt; 조항을 결합이 &lt;code&gt;FROM&lt;/code&gt; 현실에서 그들이 어떤 유형이 될 수 있지만 편의를 위해 우리는 &quot;테이블&quot;로 참조 할 항목, &lt;code&gt;FROM&lt;/code&gt; 항목을 선택합니다. 필요한 경우 괄호를 사용하여 중첩 순서를 결정하십시오. 괄호가 없으면 &lt;code&gt;JOIN&lt;/code&gt; 은 왼쪽에서 오른쪽으로 중첩됩니다. 어쨌든 &lt;code&gt;JOIN&lt;/code&gt; 은 &lt;code&gt;FROM&lt;/code&gt; -list 항목을 구분하는 쉼표보다 더 밀접하게 바인딩 됩니다.</target>
        </trans-unit>
        <trans-unit id="22a84ad9de4a47f15eabedf603ec63031e192119" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;LATERAL&lt;/code&gt; item can appear at top level in the &lt;code&gt;FROM&lt;/code&gt; list, or within a &lt;code&gt;JOIN&lt;/code&gt; tree. In the latter case it can also refer to any items that are on the left-hand side of a &lt;code&gt;JOIN&lt;/code&gt; that it is on the right-hand side of.</source>
          <target state="translated">&lt;code&gt;LATERAL&lt;/code&gt; 항목은 최고 수준에서 나타날 수 &lt;code&gt;FROM&lt;/code&gt; 목록 또는 내 &lt;code&gt;JOIN&lt;/code&gt; 트리. 후자의 경우에는 오른쪽에있는 &lt;code&gt;JOIN&lt;/code&gt; 의 왼쪽에있는 모든 항목을 나타낼 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8ae34e725d60cc08b18c4661033d9a5986eedac" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SECURITY DEFINER&lt;/code&gt; procedure cannot execute transaction control statements (for example, &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;, depending on the language).</source>
          <target state="translated">&lt;code&gt;SECURITY DEFINER&lt;/code&gt; 의 절차 (예를 들어, 트랜잭션 제어 문을 실행할 수 없습니다 &lt;code&gt;COMMIT&lt;/code&gt; 및 &lt;code&gt;ROLLBACK&lt;/code&gt; 언어에 따라).</target>
        </trans-unit>
        <trans-unit id="24640de38cd7e79e6c26b95c139e86bc1984a68f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SELECT&lt;/code&gt; sub-query that produces as many output columns as are listed in the parenthesized column list preceding it. The sub-query must yield no more than one row when executed. If it yields one row, its column values are assigned to the target columns; if it yields no rows, NULL values are assigned to the target columns. The sub-query can refer to old values of the current row of the table being updated.</source>
          <target state="translated">괄호로 묶은 열 목록에 나열된 수만큼 출력 열을 생성 하는 &lt;code&gt;SELECT&lt;/code&gt; 하위 쿼리입니다. 하위 쿼리는 실행될 때 하나 이상의 행을 생성하지 않아야합니다. 하나의 행을 생성하면 해당 열 값이 대상 열에 할당됩니다. 행을 생성하지 않으면 대상 열에 NULL 값이 할당됩니다. 하위 쿼리는 업데이트중인 테이블의 현재 행의 이전 값을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f32387ffee5e380629abaa1525601dc9d6facaf" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ShareLock&lt;/code&gt; is required on the target index by &lt;code&gt;bt_index_parent_check&lt;/code&gt; (a &lt;code&gt;ShareLock&lt;/code&gt; is also acquired on the heap relation). These locks prevent concurrent data modification from &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; commands. The locks also prevent the underlying relation from being concurrently processed by &lt;code&gt;VACUUM&lt;/code&gt;, as well as all other utility commands. Note that the function holds locks only while running, not for the entire transaction.</source>
          <target state="translated">&lt;code&gt;ShareLock&lt;/code&gt; 을 통한 대상 인덱스에 필요한 &lt;code&gt;bt_index_parent_check&lt;/code&gt; (a &lt;code&gt;ShareLock&lt;/code&gt; 은 또한 힙 관계를 취득한다). 이러한 잠금은 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 명령 에서 동시 데이터 수정을 방지 합니다. 잠금은 또한 &lt;code&gt;VACUUM&lt;/code&gt; 및 기타 모든 유틸리티 명령 이 기본 관계를 동시에 처리하지 못하게 합니다. 함수는 전체 트랜잭션이 아닌 실행 중에 만 잠금을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="f5a2d75bff2c30ff411c224c9fe1259bed07345e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TABLESAMPLE&lt;/code&gt; clause after a &lt;code&gt;table_name&lt;/code&gt; indicates that the specified &lt;code&gt;sampling_method&lt;/code&gt; should be used to retrieve a subset of the rows in that table. This sampling precedes the application of any other filters such as &lt;code&gt;WHERE&lt;/code&gt; clauses. The standard PostgreSQL distribution includes two sampling methods, &lt;code&gt;BERNOULLI&lt;/code&gt; and &lt;code&gt;SYSTEM&lt;/code&gt;, and other sampling methods can be installed in the database via extensions.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; 뒤 의 &lt;code&gt;TABLESAMPLE&lt;/code&gt; 절 은 지정된 &lt;code&gt;sampling_method&lt;/code&gt; 를 사용하여 해당 테이블에서 행의 서브 세트를 검색해야 함을 나타냅니다 . 이 샘플링은 &lt;code&gt;WHERE&lt;/code&gt; 절 과 같은 다른 필터의 적용보다 우선합니다 . 표준 PostgreSQL 배포에는 &lt;code&gt;BERNOULLI&lt;/code&gt; 및 &lt;code&gt;SYSTEM&lt;/code&gt; 의 두 가지 샘플링 방법이 포함 되며 확장을 통해 다른 샘플링 방법을 데이터베이스에 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e67a4c57a74dd900aa610f5f6c701a6078b7404" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TZH&lt;/code&gt; template pattern can match a signed number. Without the &lt;code&gt;FX&lt;/code&gt; option, minus signs may be ambiguous, and could be interpreted as a separator. This ambiguity is resolved as follows: If the number of separators before &lt;code&gt;TZH&lt;/code&gt; in the template string is less than the number of separators before the minus sign in the input string, the minus sign is interpreted as part of &lt;code&gt;TZH&lt;/code&gt;. Otherwise, the minus sign is considered to be a separator between values. For example, &lt;code&gt;to_timestamp('2000 -10', 'YYYY TZH')&lt;/code&gt; matches &lt;code&gt;-10&lt;/code&gt; to &lt;code&gt;TZH&lt;/code&gt;, but &lt;code&gt;to_timestamp('2000 -10', 'YYYY&amp;nbsp;&amp;nbsp;TZH')&lt;/code&gt; matches &lt;code&gt;10&lt;/code&gt; to &lt;code&gt;TZH&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TZH&lt;/code&gt; 의 템플릿 패턴은 서명 숫자를 일치시킬 수 있습니다. &lt;code&gt;FX&lt;/code&gt; 옵션이 없으면 빼기 부호가 모호 할 수 있으며 구분 기호로 해석 될 수 있습니다. 이 모호성은 다음과 같이 해결됩니다. 템플리트 문자열에서 &lt;code&gt;TZH&lt;/code&gt; 앞의 구분 기호 수가 입력 문자열에서 빼기 기호 앞의 구분 기호 수보다 작은 경우 빼기 기호는 &lt;code&gt;TZH&lt;/code&gt; 의 일부로 해석됩니다 . 그렇지 않으면 빼기 기호는 값 사이의 구분 기호로 간주됩니다. 예를 들어 &lt;code&gt;to_timestamp('2000 -10', 'YYYY TZH')&lt;/code&gt; 는 &lt;code&gt;-10&lt;/code&gt; ~ &lt;code&gt;TZH&lt;/code&gt; 와 일치 하지만 &lt;code&gt;to_timestamp('2000 -10', 'YYYY&amp;nbsp;&amp;nbsp;TZH')&lt;/code&gt; 는 &lt;code&gt;10&lt;/code&gt; ~ &lt;code&gt;TZH&lt;/code&gt; 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="975d4d7cc350f909c3d56a227d26009cd1f3f678" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;WITH&lt;/code&gt; query is referenced by writing its name, just as though the query's name were a table name. (In fact, the &lt;code&gt;WITH&lt;/code&gt; query hides any real table of the same name for the purposes of the primary query. If necessary, you can refer to a real table of the same name by schema-qualifying the table's name.) An alias can be provided in the same way as for a table.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 의 쿼리는 쿼리의 이름은 테이블 이름 그랬던 것처럼, 이름을 작성하여 참조됩니다. 실제로 &lt;code&gt;WITH&lt;/code&gt; 쿼리는 기본 쿼리를 위해 동일한 이름의 실제 테이블을 숨 깁니다. 필요한 경우 테이블 이름을 스키마로 한정하여 동일한 이름의 실제 테이블을 참조 할 수 있습니다. 별칭은 다음과 같습니다. 테이블과 같은 방식으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ff3f18d6b0d0d8ef8e261f092333e8ac1a83778d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;bloom&lt;/code&gt; index accepts the following parameters in its &lt;code&gt;WITH&lt;/code&gt; clause:</source>
          <target state="translated">&lt;code&gt;bloom&lt;/code&gt; 인덱스는에서 다음 매개 변수 받아 &lt;code&gt;WITH&lt;/code&gt; 의 절을 :</target>
        </trans-unit>
        <trans-unit id="4c2361c26a25ed37192ff6822eb9815e6a1bb350" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;default_expression&lt;/code&gt;, rather than being evaluated immediately when &lt;code&gt;xmltable&lt;/code&gt; is called, is evaluated each time a default is needed for the column. If the expression qualifies as stable or immutable, the repeat evaluation may be skipped. This means that you can usefully use volatile functions like &lt;code&gt;nextval&lt;/code&gt; in &lt;code&gt;default_expression&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;default_expression&lt;/code&gt; 이 아닌 경우 즉시 평가되고 &lt;code&gt;xmltable&lt;/code&gt; 라고, 기본이 열 필요 때마다 평가됩니다. 표현식이 안정적이거나 불변 인 것으로 평가되면 반복 평가를 건너 뛸 수 있습니다. 이것은 &lt;code&gt;default_expression&lt;/code&gt; 에서 &lt;code&gt;nextval&lt;/code&gt; 과 같은 휘발성 함수를 유용하게 사용할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="6a8d6c448f4256c5739e1f342a948208b8ac9336" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;dict_xsyn&lt;/code&gt; dictionary accepts the following options:</source>
          <target state="translated">&lt;code&gt;dict_xsyn&lt;/code&gt; 의 사전은 다음과 같은 옵션을 적용합니다</target>
        </trans-unit>
        <trans-unit id="4731474e93af48b3b039ee433573b761b490ebba" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;frame_start&lt;/code&gt; of &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; means that the frame starts with the first row of the partition, and similarly a &lt;code&gt;frame_end&lt;/code&gt; of &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; means that the frame ends with the last row of the partition.</source>
          <target state="translated">&lt;code&gt;frame_start&lt;/code&gt; 의 &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 수단은 상기 프레임 파티션의 첫 행부터 시작하고, 마찬가지로 &lt;code&gt;frame_end&lt;/code&gt; 의 &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; 의 수단 파티션의 마지막 행과 프레임 종료한다.</target>
        </trans-unit>
        <trans-unit id="ba67bfc07bc1375b67a77983258edd014dff690f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;money&lt;/code&gt; value can be cast to &lt;code&gt;numeric&lt;/code&gt; without loss of precision. Conversion to other types could potentially lose precision, and must also be done in two stages:</source>
          <target state="translated">&lt;code&gt;money&lt;/code&gt; 값에 캐스트 할 수있는 &lt;code&gt;numeric&lt;/code&gt; 정밀도의 손실없이. 다른 유형으로 변환하면 정밀도가 떨어질 수 있으며 다음 두 단계로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="00e1eada317c8cafe63dee1a39dd2ab5032af82d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;pg_default_acl&lt;/code&gt; entry shows the initial privileges to be assigned to an object belonging to the indicated user. There are currently two types of entry: &amp;ldquo;global&amp;rdquo; entries with &lt;code&gt;defaclnamespace&lt;/code&gt; = 0, and &amp;ldquo;per-schema&amp;rdquo; entries that reference a particular schema. If a global entry is present then it &lt;em&gt;overrides&lt;/em&gt; the normal hard-wired default privileges for the object type. A per-schema entry, if present, represents privileges to be &lt;em&gt;added to&lt;/em&gt; the global or hard-wired default privileges.</source>
          <target state="translated">&lt;code&gt;pg_default_acl&lt;/code&gt; 의 항목은 초기 특권 표시된 사용자에 속하는 객체에 할당 될 나타낸다. 현재 두 가지 유형의 항목이 있습니다 : &lt;code&gt;defaclnamespace&lt;/code&gt; = 0 인 &quot;글로벌&quot;항목 및 특정 스키마를 참조하는 &quot;스키마 별&quot;항목. 전역 항목이 있으면 개체 유형에 대한 일반적인 고정 배선 기본 권한을 &lt;em&gt;무시&lt;/em&gt; 합니다. 스키마 별 항목 (있는 경우) 은 전역 또는 유선 기본 권한에 &lt;em&gt;추가 할&lt;/em&gt; 권한을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1cb2939b4b6d4ddce66b3a2e4882d5e2fd0717d0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;pg_ident.conf&lt;/code&gt; file that could be used in conjunction with the &lt;code&gt;pg_hba.conf&lt;/code&gt; file in &lt;a href=&quot;auth-pg-hba-conf#EXAMPLE-PG-HBA.CONF&quot;&gt;Example 20.1&lt;/a&gt; is shown in &lt;a href=&quot;auth-username-maps#EXAMPLE-PG-IDENT.CONF&quot;&gt;Example 20.2&lt;/a&gt;. In this example, anyone logged in to a machine on the 192.168 network that does not have the operating system user name &lt;code&gt;bryanh&lt;/code&gt;, &lt;code&gt;ann&lt;/code&gt;, or &lt;code&gt;robert&lt;/code&gt; would not be granted access. Unix user &lt;code&gt;robert&lt;/code&gt; would only be allowed access when he tries to connect as PostgreSQL user &lt;code&gt;bob&lt;/code&gt;, not as &lt;code&gt;robert&lt;/code&gt; or anyone else. &lt;code&gt;ann&lt;/code&gt; would only be allowed to connect as &lt;code&gt;ann&lt;/code&gt;. User &lt;code&gt;bryanh&lt;/code&gt; would be allowed to connect as either &lt;code&gt;bryanh&lt;/code&gt; or as &lt;code&gt;guest1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_ident.conf&lt;/code&gt; 의 와 함께 사용될 수있는 파일 &lt;code&gt;pg_hba.conf&lt;/code&gt; 의 파일 &lt;a href=&quot;auth-pg-hba-conf#EXAMPLE-PG-HBA.CONF&quot;&gt;실시 예 20.1은&lt;/a&gt; 같다 &lt;a href=&quot;auth-username-maps#EXAMPLE-PG-IDENT.CONF&quot;&gt;예 20.2&lt;/a&gt; . 이 예에서 운영 체제 사용자 이름 &lt;code&gt;bryanh&lt;/code&gt; , &lt;code&gt;ann&lt;/code&gt; 또는 &lt;code&gt;robert&lt;/code&gt; 가없는 192.168 네트워크의 시스템에 로그인 한 사용자 에게는 액세스 권한이 부여되지 않습니다. 유닉스 사용자 &lt;code&gt;robert&lt;/code&gt; 은 &lt;code&gt;robert&lt;/code&gt; 나 다른 사람이 아닌 PostgreSQL 사용자 &lt;code&gt;bob&lt;/code&gt; 으로 연결하려고 할 때만 액세스가 허용됩니다 . &lt;code&gt;ann&lt;/code&gt; 전용으로 연결이 허용 될 것이다 &lt;code&gt;ann&lt;/code&gt; . 사용자 &lt;code&gt;bryanh&lt;/code&gt; &lt;code&gt;bryanh&lt;/code&gt; 또는 &lt;code&gt;guest1&lt;/code&gt; 로 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="421151d14aecca0c09fe097c61a7a69cad0ef7d4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;sort_expression&lt;/code&gt; can also be the column label or number of an output column, as in:</source>
          <target state="translated">&lt;code&gt;sort_expression&lt;/code&gt; 는 도 마찬가지로 출력 열의 열 라벨이나 번호 일 수있다 :</target>
        </trans-unit>
        <trans-unit id="2b23f0024d2472dff4bba030a8daa989f120d9ef" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsquery&lt;/code&gt; value stores lexemes that are to be searched for, and can combine them using the Boolean operators &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), &lt;code&gt;|&lt;/code&gt; (OR), and &lt;code&gt;!&lt;/code&gt; (NOT), as well as the phrase search operator &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY). There is also a variant &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; of the FOLLOWED BY operator, where &lt;code&gt;N&lt;/code&gt; is an integer constant that specifies the distance between the two lexemes being searched for. &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; is equivalent to &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; 에 있는 값을 저장 어휘가 검색 될 및 부울 연산자 사용하여 결합 할 수 있습니다 &lt;code&gt;&amp;amp;&lt;/code&gt; (AND), &lt;code&gt;|&lt;/code&gt; (OR),와 &lt;code&gt;!&lt;/code&gt; (NOT) 및 구문 검색 연산자 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY). FOLLOWED BY 연산자의 변형 &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 도 있습니다. 여기서 &lt;code&gt;N&lt;/code&gt; 은 검색중인 두 룩스 사이의 거리를 지정하는 정수 상수입니다. &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&amp;lt;1&amp;gt;&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1488cfe9583a001f3966c381b957f6eda3c9c49c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsvector&lt;/code&gt; value is a sorted list of distinct &lt;em&gt;lexemes&lt;/em&gt;, which are words that have been &lt;em&gt;normalized&lt;/em&gt; to merge different variants of the same word (see &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for details). Sorting and duplicate-elimination are done automatically during input, as shown in this example:</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 의 값은 별개의 정렬 된 목록입니다 &lt;em&gt;어휘&lt;/em&gt; 된 단어, &lt;em&gt;정규화&lt;/em&gt; 같은 단어 (참조의 다른 변종을 병합 &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;12 장&lt;/a&gt; 자세한 내용을). 다음 예와 같이 입력하는 동안 정렬 및 복제 제거가 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="558bdfda3afcef5f29f3f2e8969b74e0c735aa26" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsvector&lt;/code&gt; value is a sorted list of distinct &lt;em&gt;lexemes&lt;/em&gt;, which are words that have been &lt;em&gt;normalized&lt;/em&gt; to merge different variants of the same word (see &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for details). Sorting and duplicate-elimination are done automatically during input, as shown in this example:</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 의 값은 별개의 정렬 된 목록입니다 &lt;em&gt;어휘&lt;/em&gt; 된 단어, &lt;em&gt;정규화&lt;/em&gt; 같은 단어 (참조의 다른 변종을 병합 &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;12 장&lt;/a&gt; 자세한 내용을). 다음 예와 같이 정렬 및 중복 제거는 입력 중에 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="72b056d2deaf1866d999d56f9aac903ec6223482" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;zone_abbreviation&lt;/code&gt; is just the abbreviation being defined. An &lt;code&gt;offset&lt;/code&gt; is an integer giving the equivalent offset in seconds from UTC, positive being east from Greenwich and negative being west. For example, -18000 would be five hours west of Greenwich, or North American east coast standard time. &lt;code&gt;D&lt;/code&gt; indicates that the zone name represents local daylight-savings time rather than standard time.</source>
          <target state="translated">&lt;code&gt;zone_abbreviation&lt;/code&gt; 은 단지 약어 정의되고있다. &lt;code&gt;offset&lt;/code&gt; UTC, 그리니치에서 긍정적 인 존재의 동쪽과 부정적 서쪽에서 초 오프셋 상당을주는 정수이다. 예를 들어, -18000은 그리니치에서 서쪽으로 5 시간 또는 북미 동부 해안 표준시입니다. &lt;code&gt;D&lt;/code&gt; 는 영역 이름이 표준 시간이 아닌 현지 일광 절약 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f4943bcbca867f42994cb13fee08c8f711efae46" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;back reference&lt;/em&gt; (&lt;code&gt;\&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;) matches the same string matched by the previous parenthesized subexpression specified by the number &lt;code&gt;n&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;Table 9.22&lt;/a&gt;). For example, &lt;code&gt;([bc])\1&lt;/code&gt; matches &lt;code&gt;bb&lt;/code&gt; or &lt;code&gt;cc&lt;/code&gt; but not &lt;code&gt;bc&lt;/code&gt; or &lt;code&gt;cb&lt;/code&gt;. The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions.</source>
          <target state="translated">&lt;em&gt;다시 참조&lt;/em&gt; ( &lt;code&gt;\&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 은 ) 숫자로 지정 이전 괄호 표현식 일치 동일한 문자열 일치 &lt;code&gt;n&lt;/code&gt; (참조 &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;표를 9.22&lt;/a&gt; ). 예를 들어 &lt;code&gt;([bc])\1&lt;/code&gt; 은 &lt;code&gt;bb&lt;/code&gt; 또는 &lt;code&gt;cc&lt;/code&gt; 와 일치 하지만 &lt;code&gt;bc&lt;/code&gt; 또는 &lt;code&gt;cb&lt;/code&gt; 와는 일치 하지 않습니다 . 하위 표현식은 RE에서 역 참조보다 전적으로 선행해야합니다. 하위 표현식은 선행 괄호 순서로 번호가 매겨집니다. 비 캡처 괄호는 하위 표현식을 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0a817aa5725f2f76fa3ba34527c18e8ded1f121f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;back reference&lt;/em&gt; (&lt;code&gt;\&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;) matches the same string matched by the previous parenthesized subexpression specified by the number &lt;code&gt;n&lt;/code&gt; (see &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;Table 9.23&lt;/a&gt;). For example, &lt;code&gt;([bc])\1&lt;/code&gt; matches &lt;code&gt;bb&lt;/code&gt; or &lt;code&gt;cc&lt;/code&gt; but not &lt;code&gt;bc&lt;/code&gt; or &lt;code&gt;cb&lt;/code&gt;. The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions.</source>
          <target state="translated">&lt;em&gt;다시 참조&lt;/em&gt; ( &lt;code&gt;\&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 은 ) 숫자로 지정 이전 괄호 표현식 일치 동일한 문자열 일치 &lt;code&gt;n&lt;/code&gt; (참조 &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-BACKREF-TABLE&quot;&gt;표 9.23&lt;/a&gt; ). 예를 들어, &lt;code&gt;([bc])\1&lt;/code&gt; 은 &lt;code&gt;bb&lt;/code&gt; 또는 &lt;code&gt;cc&lt;/code&gt; 와 일치 하지만 &lt;code&gt;bc&lt;/code&gt; 또는 &lt;code&gt;cb&lt;/code&gt; 와는 일치 하지 않습니다 . 하위 표현식은 RE에서 역 참조 앞에 완전히 와야합니다. 하위 표현식은 선행 괄호 순서대로 번호가 지정됩니다. 비 캡처 괄호는 하위 표현식을 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6718ca8fb4d919393e897bdec5fb4459615fdc4d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;bracket expression&lt;/em&gt; is a list of characters enclosed in &lt;code&gt;[]&lt;/code&gt;. It normally matches any single character from the list (but see below). If the list begins with &lt;code&gt;^&lt;/code&gt;, it matches any single character &lt;em&gt;not&lt;/em&gt; from the rest of the list. If two characters in the list are separated by &lt;code&gt;-&lt;/code&gt;, this is shorthand for the full range of characters between those two (inclusive) in the collating sequence, e.g., &lt;code&gt;[0-9]&lt;/code&gt; in ASCII matches any decimal digit. It is illegal for two ranges to share an endpoint, e.g., &lt;code&gt;a-c-e&lt;/code&gt;. Ranges are very collating-sequence-dependent, so portable programs should avoid relying on them.</source>
          <target state="translated">&lt;em&gt;브래킷 식&lt;/em&gt; 안에 문자의 목록입니다 &lt;code&gt;[]&lt;/code&gt; . 일반적으로 목록의 단일 문자와 일치합니다 (하지만 아래 참조). 목록이 &lt;code&gt;^&lt;/code&gt; 로 시작 하면 나머지 목록이 &lt;em&gt;아닌&lt;/em&gt; 단일 문자와 일치 합니다. 목록의 두 문자가 &lt;code&gt;-&lt;/code&gt; 로 분리 된 경우 데이터 정렬 시퀀스에서 두 문자 (포함) 사이의 전체 문자 범위를 나타내는 약어입니다. 예를 들어 ASCII의 &lt;code&gt;[0-9]&lt;/code&gt; 는 10 진수와 일치합니다. 두 범위가 엔드 포인트 (예 : &lt;code&gt;a-c-e&lt;/code&gt; 를 공유하는 것은 불법입니다 . 범위는 배열 순서에 따라 매우 다르므로 이식 가능한 프로그램은 범위에 의존하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e492c903d1ba7fa2a18a8ea616f7ebd7783cffa9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;composite type&lt;/em&gt; represents the structure of a row or record; it is essentially just a list of field names and their data types. PostgreSQL allows composite types to be used in many of the same ways that simple types can be used. For example, a column of a table can be declared to be of a composite type.</source>
          <target state="translated">&lt;em&gt;복합 타입은&lt;/em&gt; 행 또는 레코드의 구조를 나타내고; 본질적으로 필드 이름과 해당 데이터 유형의 목록 일뿐입니다. PostgreSQL을 사용하면 간단한 유형을 사용할 수있는 것과 동일한 방식으로 복합 유형을 사용할 수 있습니다. 예를 들어, 테이블의 열은 복합 유형으로 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e860f367bba9069717fd9b941470c654d2b4f8d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint escape&lt;/em&gt; is a constraint, matching the empty string if specific conditions are met, written as an escape. They are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.21&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;제약 이스케이프는&lt;/em&gt; 특정 조건이 탈출로 작성, 충족되는 경우 빈 문자열을 일치 제약이다. &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;표 9.21&lt;/a&gt; 에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d0f2ee8729573804e315b4c91c82a2c28f8ca2d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint escape&lt;/em&gt; is a constraint, matching the empty string if specific conditions are met, written as an escape. They are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;Table 9.22&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;제약 이스케이프는&lt;/em&gt; 특정 조건이 탈출로 작성, 충족되는 경우 빈 문자열을 일치 제약이다. &lt;a href=&quot;functions-matching#POSIX-CONSTRAINT-ESCAPES-TABLE&quot;&gt;표 9.22&lt;/a&gt; 에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="39ce7ea4252d54e37a3de7de04c14f271d76b823" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint&lt;/em&gt; matches an empty string, but matches only when specific conditions are met. A constraint can be used where an atom could be used, except it cannot be followed by a quantifier. The simple constraints are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;Table 9.18&lt;/a&gt;; some more constraints are described later.</source>
          <target state="translated">&lt;em&gt;제약은&lt;/em&gt; 빈 문자열을 일치하지만 특정 조건이 충족 될 경우에만 일치합니다. 원자가 사용될 수있는 곳에서는 제한자가 뒤따를 수 없다는 점을 제외하고는 제한 조건이 사용될 수 있습니다. 간단한 제약 조건은 &lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;표 9.18&lt;/a&gt; 에 나와 있습니다 . 더 많은 제약이 나중에 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="41327cfa5680423eea0edd7f46f2cf61b64b967b" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;constraint&lt;/em&gt; matches an empty string, but matches only when specific conditions are met. A constraint can be used where an atom could be used, except it cannot be followed by a quantifier. The simple constraints are shown in &lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;Table 9.19&lt;/a&gt;; some more constraints are described later.</source>
          <target state="translated">&lt;em&gt;제약은&lt;/em&gt; 빈 문자열을 일치하지만 특정 조건이 충족 될 경우에만 일치합니다. 한정자가 뒤에 올 수 없다는 점을 제외하고는 원자를 사용할 수있는 곳에 제약 조건을 사용할 수 있습니다. 간단한 제약은 &lt;a href=&quot;functions-matching#POSIX-CONSTRAINTS-TABLE&quot;&gt;표 9.19&lt;/a&gt; 에 나와 있습니다 . 더 많은 제약은 나중에 설명합니다.</target>
        </trans-unit>
        <trans-unit id="82adef88e441ec735dafa62739629a93a7d0b236" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;document&lt;/em&gt; is the unit of searching in a full text search system; for example, a magazine article or email message. The text search engine must be able to parse documents and store associations of lexemes (key words) with their parent document. Later, these associations are used to search for documents that contain query words.</source>
          <target state="translated">&lt;em&gt;문서는&lt;/em&gt; 전체 텍스트 검색 시스템에서 검색의 단위; 예를 들어 잡지 기사 또는 전자 메일 메시지입니다. 텍스트 검색 엔진은 문서를 구문 분석 할 수 있고 상위 문서와 어휘 (키워드)의 연관을 저장할 수 있어야합니다. 나중에 이러한 연결은 쿼리 단어가 포함 된 문서를 검색하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d539733e585980e704da973d01ffd68041e9bbe5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;domain&lt;/em&gt; is a user-defined data type that is based on another &lt;em&gt;underlying type&lt;/em&gt;. Optionally, it can have constraints that restrict its valid values to a subset of what the underlying type would allow. Otherwise it behaves like the underlying type &amp;mdash; for example, any operator or function that can be applied to the underlying type will work on the domain type. The underlying type can be any built-in or user-defined base type, enum type, array type, composite type, range type, or another domain.</source>
          <target state="translated">&lt;em&gt;도메인은&lt;/em&gt; 서로에 기초한 사용자 정의 데이터 타입 &lt;em&gt;내부 형식&lt;/em&gt; . 선택적으로 유효한 값을 기본 유형이 허용하는 것의 하위 집합으로 제한하는 제약 조건이있을 수 있습니다. 그렇지 않으면 기본 유형처럼 작동합니다. 예를 들어 기본 유형에 적용 할 수있는 모든 연산자 또는 함수는 도메인 유형에서 작동합니다. 기본 유형은 내장 또는 사용자 정의 기본 유형, 열거 형, 배열 유형, 복합 유형, 범위 유형 또는 다른 도메인 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c13def52e60f456d21c22d940b5598ad3aba92f3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label path&lt;/em&gt; is a sequence of zero or more labels separated by dots, for example &lt;code&gt;L1.L2.L3&lt;/code&gt;, representing a path from the root of a hierarchical tree to a particular node. The length of a label path cannot exceed 65535 labels.</source>
          <target state="translated">&lt;em&gt;레이블 경로는&lt;/em&gt; 0 개 이상의 라벨들의 시퀀스는, 예를 들면 도트로 구분 &lt;code&gt;L1.L2.L3&lt;/code&gt; 특정 노드에 대한 계층 적 트리의 루트에서 경로를 나타내는. 레이블 경로의 길이는 65535 개의 레이블을 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e800c3197134211f2433e1a5e7b9939eb18274d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label path&lt;/em&gt; is a sequence of zero or more labels separated by dots, for example &lt;code&gt;L1.L2.L3&lt;/code&gt;, representing a path from the root of a hierarchical tree to a particular node. The length of a label path must be less than 65kB, but keeping it under 2kB is preferable.</source>
          <target state="translated">&lt;em&gt;레이블 경로는&lt;/em&gt; 0 개 이상의 라벨들의 시퀀스는, 예를 들면 도트로 구분 &lt;code&gt;L1.L2.L3&lt;/code&gt; 특정 노드에 대한 계층 적 트리의 루트에서 경로를 나타내는. 레이블 경로의 길이는 65kB보다 작아야하지만 2kB 이하로 유지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b787370839fd1f05141e9721dfa970b29907a8f6" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label&lt;/em&gt; is a sequence of alphanumeric characters and underscores (for example, in C locale the characters &lt;code&gt;A-Za-z0-9_&lt;/code&gt; are allowed). Labels must be less than 256 bytes long.</source>
          <target state="translated">&lt;em&gt;라벨&lt;/em&gt; (예를 들어, C의 문자 로케일 영숫자와 밑줄 시퀀스 인 &lt;code&gt;A-Za-z0-9_&lt;/code&gt; 허용에게). 레이블은 256 바이트보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="599ffa36e210ea0adb3274124904be22bf966667" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;label&lt;/em&gt; is a sequence of alphanumeric characters and underscores (for example, in C locale the characters &lt;code&gt;A-Za-z0-9_&lt;/code&gt; are allowed). Labels must be less than 256 characters long.</source>
          <target state="translated">&lt;em&gt;라벨&lt;/em&gt; (예를 들어, C의 문자 로케일 영숫자와 밑줄 시퀀스 인 &lt;code&gt;A-Za-z0-9_&lt;/code&gt; 허용에게). 라벨은 256 자 미만이어야합니다.</target>
        </trans-unit>
        <trans-unit id="53ce2d4eb014bcb723a4d1641a42edaac349db30" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;partial index&lt;/em&gt; is an index built over a subset of a table; the subset is defined by a conditional expression (called the &lt;em&gt;predicate&lt;/em&gt; of the partial index). The index contains entries only for those table rows that satisfy the predicate. Partial indexes are a specialized feature, but there are several situations in which they are useful.</source>
          <target state="translated">&lt;em&gt;부분 인덱스는&lt;/em&gt; 테이블의 부분 집합에 구축되는 인덱스입니다; 서브 세트는 조건식 ( 부분 인덱스 의 &lt;em&gt;술어&lt;/em&gt; 라고 함)에 의해 정의됩니다 . 인덱스는 술어를 만족시키는 테이블 행에 대한 항목 만 포함합니다. 부분 인덱스는 특수한 기능이지만 유용한 몇 가지 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="17789413b2495753606375a6dc95de535511eb7a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;publication&lt;/em&gt; can be defined on any physical replication master. The node where a publication is defined is referred to as &lt;em&gt;publisher&lt;/em&gt;. A publication is a set of changes generated from a table or a group of tables, and might also be described as a change set or replication set. Each publication exists in only one database.</source>
          <target state="translated">&lt;em&gt;간행물은&lt;/em&gt; 물리적 복제 마스터에서 정의 할 수 있습니다. 발행이 정의 된 노드를 &lt;em&gt;publisher&lt;/em&gt; 라고합니다 . 게시는 테이블 또는 테이블 그룹에서 생성 된 변경 집합이며 변경 집합 또는 복제 집합으로 설명 될 수도 있습니다. 각 발행물은 하나의 데이터베이스에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="bad628aabb95be8473994dba34d6d8a1a5004186" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;subscription&lt;/em&gt; is the downstream side of logical replication. The node where a subscription is defined is referred to as the &lt;em&gt;subscriber&lt;/em&gt;. A subscription defines the connection to another database and set of publications (one or more) to which it wants to subscribe.</source>
          <target state="translated">&lt;em&gt;구독&lt;/em&gt; 논리적 복제의 하류 측이다. 구독이 정의 된 노드를 &lt;em&gt;구독자&lt;/em&gt; 라고합니다 . 구독은 구독하려는 다른 데이터베이스 및 발행물 세트 (하나 이상)에 대한 연결을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="fa797af3b3f4fb2b2ac87bf17e6b99f0b17a6828" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;table expression&lt;/em&gt; computes a table. The table expression contains a &lt;code&gt;FROM&lt;/code&gt; clause that is optionally followed by &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses. Trivial table expressions simply refer to a table on disk, a so-called base table, but more complex expressions can be used to modify or combine base tables in various ways.</source>
          <target state="translated">&lt;em&gt;테이블 식&lt;/em&gt; 테이블을 계산한다. 테이블 표현식에는 선택적으로 &lt;code&gt;WHERE&lt;/code&gt; , &lt;code&gt;GROUP BY&lt;/code&gt; 및 &lt;code&gt;HAVING&lt;/code&gt; 절이 오는 &lt;code&gt;FROM&lt;/code&gt; 절이 포함 됩니다. 간단한 테이블 표현식은 단순히 소위 기본 테이블 인 디스크의 테이블을 참조하지만보다 복잡한 표현식을 사용하여 다양한 방법으로 기본 테이블을 수정하거나 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fefdb2ebab2d34cbdb1f2805b62ff07fe84dbed" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window function call&lt;/em&gt; represents the application of an aggregate-like function over some portion of the rows selected by a query. Unlike non-window aggregate calls, this is not tied to grouping of the selected rows into a single output row &amp;mdash; each row remains separate in the query output. However the window function has access to all the rows that would be part of the current row's group according to the grouping specification (&lt;code&gt;PARTITION BY&lt;/code&gt; list) of the window function call. The syntax of a window function call is one of the following:</source>
          <target state="translated">&lt;em&gt;윈도우 함수 호출은&lt;/em&gt; 쿼리에 의해 선택된 행의 일부 위에 집합 형 함수의 적용을 나타낸다. 비 창구 집계 호출과 달리, 이것은 선택된 행을 단일 출력 행으로 그룹화하는 것과 관련이 없습니다. 각 행은 쿼리 출력에서 ​​분리되어 유지됩니다. 그러나 창 함수는 창 함수 호출 의 그룹화 스펙 ( &lt;code&gt;PARTITION BY&lt;/code&gt; 목록)에 따라 현재 행 그룹의 일부인 모든 행에 액세스 할 수 있습니다 . 윈도우 함수 호출 구문은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="387625f992bcdbcffbfd0633e6c6c1c4ef1ce98e" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;window function&lt;/em&gt; performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. However, window functions do not cause rows to become grouped into a single output row like non-window aggregate calls would. Instead, the rows retain their separate identities. Behind the scenes, the window function is able to access more than just the current row of the query result.</source>
          <target state="translated">&lt;em&gt;윈도우 함수&lt;/em&gt; 든 현재 행에 관련된 테이블 행의 세트에 걸쳐 계산을 수행한다. 이것은 집계 함수로 수행 할 수있는 계산 유형과 비슷합니다. 그러나 창 함수는 창 비 집계 호출과 같이 행을 단일 출력 행으로 그룹화하지 않습니다. 대신 행은 별도의 ID를 유지합니다. 장면 뒤에서 창 함수는 쿼리 결과의 현재 행 이상을 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e933097e94c165163135c375f18dec5b954f260" translate="yes" xml:space="preserve">
          <source>A Bloom filter is a space-efficient data structure that is used to test whether an element is a member of a set. In the case of an index access method, it allows fast exclusion of non-matching tuples via signatures whose size is determined at index creation.</source>
          <target state="translated">블룸 필터는 요소가 집합의 멤버인지 테스트하는 데 사용되는 공간 효율적인 데이터 구조입니다. 인덱스 액세스 방법의 경우 인덱스 생성시 크기가 결정된 서명을 통해 일치하지 않는 튜플을 빠르게 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7133145b9a1efb20311e9b66542c47e33e3b0d76" translate="yes" xml:space="preserve">
          <source>A Boolean expression that determines whether the trigger function will actually be executed. If &lt;code&gt;WHEN&lt;/code&gt; is specified, the function will only be called if the &lt;code&gt;condition&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. In &lt;code&gt;FOR EACH ROW&lt;/code&gt; triggers, the &lt;code&gt;WHEN&lt;/code&gt; condition can refer to columns of the old and/or new row values by writing &lt;code&gt;OLD.column_name&lt;/code&gt; or &lt;code&gt;NEW.column_name&lt;/code&gt; respectively. Of course, &lt;code&gt;INSERT&lt;/code&gt; triggers cannot refer to &lt;code&gt;OLD&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; triggers cannot refer to &lt;code&gt;NEW&lt;/code&gt;.</source>
          <target state="translated">트리거 함수가 실제로 실행 될지 여부를 결정하는 부울 표현식입니다. 경우 &lt;code&gt;WHEN&lt;/code&gt; 지정된 경우 함수는 호출 될 &lt;code&gt;condition&lt;/code&gt; 반환 &lt;code&gt;true&lt;/code&gt; . 에서는 &lt;code&gt;FOR EACH ROW&lt;/code&gt; 트리거는 &lt;code&gt;WHEN&lt;/code&gt; 조건을 작성함으로써, 이전 및 / 또는 새로운 행 값의 열을 참조 할 수 &lt;code&gt;OLD.column_name&lt;/code&gt; 또는 &lt;code&gt;NEW.column_name&lt;/code&gt; 을 각각. 물론, &lt;code&gt;INSERT&lt;/code&gt; 트리거는 참조 할 수 없습니다 &lt;code&gt;OLD&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 트리거는 참조 할 수 없습니다 &lt;code&gt;NEW&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f47409118dd85d31d6d901173cd234a285d215a5" translate="yes" xml:space="preserve">
          <source>A GIN index stores a set of (key, posting list) pairs, where a &lt;em&gt;posting list&lt;/em&gt; is a set of row IDs in which the key occurs. The same row ID can appear in multiple posting lists, since an item can contain more than one key. Each key value is stored only once, so a GIN index is very compact for cases where the same key appears many times.</source>
          <target state="translated">GIN 색인은 일련의 (키, 게시 목록) 쌍을 저장합니다. 여기서 &lt;em&gt;게시 목록&lt;/em&gt; 은 키가 발생하는 행 ID 세트입니다. 항목에 둘 이상의 키가 포함될 수 있으므로 동일한 행 ID가 여러 게시 목록에 나타날 수 있습니다. 각 키 값은 한 번만 저장되므로 동일한 키가 여러 번 나타나는 경우 GIN 색인이 매우 간결합니다.</target>
        </trans-unit>
        <trans-unit id="77d714896b96774f11d4e02f2da31afcf21ba9b4" translate="yes" xml:space="preserve">
          <source>A GiST index can be covering, i.e. use the &lt;code&gt;INCLUDE&lt;/code&gt; clause. Included columns can have data types without any GiST operator class. Included attributes will be stored uncompressed.</source>
          <target state="translated">GiST 인덱스를 포함 할 수 있습니다 (예 : &lt;code&gt;INCLUDE&lt;/code&gt; 절 사용). 포함 된 열은 GiST 연산자 클래스없이 데이터 유형을 가질 수 있습니다. 포함 된 속성은 압축되지 않은 상태로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="efe49aa51c5c238e7d22d9c414bebd48d8a0f792" translate="yes" xml:space="preserve">
          <source>A GiST index can be covering, i.e., use the &lt;code&gt;INCLUDE&lt;/code&gt; clause. Included columns can have data types without any GiST operator class. Included attributes will be stored uncompressed.</source>
          <target state="translated">GiST 인덱스는 포함 할 수 있습니다. 즉, &lt;code&gt;INCLUDE&lt;/code&gt; 절을 사용합니다 . 포함 된 열은 GiST 연산자 클래스없이 데이터 유형을 가질 수 있습니다. 포함 된 속성은 압축되지 않은 상태로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="686f7293e72b8ed4fbfb23d13f584165b259d7cc" translate="yes" xml:space="preserve">
          <source>A GiST index is &lt;em&gt;lossy&lt;/em&gt;, meaning that the index might produce false matches, and it is necessary to check the actual table row to eliminate such false matches. (PostgreSQL does this automatically when needed.) GiST indexes are lossy because each document is represented in the index by a fixed-length signature. The signature is generated by hashing each word into a single bit in an n-bit string, with all these bits OR-ed together to produce an n-bit document signature. When two words hash to the same bit position there will be a false match. If all words in the query have matches (real or false) then the table row must be retrieved to see if the match is correct.</source>
          <target state="translated">GiST 인덱스는 &lt;em&gt;lossy&lt;/em&gt; 이므로 인덱스가 잘못된 일치를 생성 할 수 있으므로 이러한 잘못된 일치를 제거하려면 실제 테이블 행을 확인해야합니다. (PostgreSQL은 필요할 때 자동으로이를 수행합니다.) GiST 색인은 각 문서가 색인에서 고정 길이 서명으로 표시되기 때문에 손실됩니다. 서명은 각 단어를 n 비트 문자열의 단일 비트로 해싱하여 생성되며,이 모든 비트를 함께 OR 처리하여 n 비트 문서 서명을 생성합니다. 두 단어가 동일한 비트 위치로 해시되면 일치하지 않습니다. 쿼리의 모든 단어가 일치하거나 (실제 또는 거짓) 일치하는 경우 테이블 행을 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="19939a4fce59080d1c44ab5da5d78d68dd79f01b" translate="yes" xml:space="preserve">
          <source>A GiST index is &lt;em&gt;lossy&lt;/em&gt;, meaning that the index might produce false matches, and it is necessary to check the actual table row to eliminate such false matches. (PostgreSQL does this automatically when needed.) GiST indexes are lossy because each document is represented in the index by a fixed-length signature. The signature length in bytes is determined by the value of the optional integer parameter &lt;code&gt;siglen&lt;/code&gt;. The default signature length (when &lt;code&gt;siglen&lt;/code&gt; is not specified) is 124 bytes, the maximum signature length is 2024 bytes. The signature is generated by hashing each word into a single bit in an n-bit string, with all these bits OR-ed together to produce an n-bit document signature. When two words hash to the same bit position there will be a false match. If all words in the query have matches (real or false) then the table row must be retrieved to see if the match is correct. Longer signatures lead to a more precise search (scanning a smaller fraction of the index and fewer heap pages), at the cost of a larger index.</source>
          <target state="translated">GiST 인덱스는 &lt;em&gt;손실이 있습니다&lt;/em&gt; . 즉, 인덱스가 잘못된 일치를 생성 할 수 있으며 이러한 잘못된 일치를 제거하기 위해 실제 테이블 행을 확인해야합니다. (PostgreSQL은 필요할 때이 작업을 자동으로 수행합니다.) GiST 인덱스는 각 문서가 고정 길이 서명으로 인덱스에 표시되기 때문에 손실이 발생합니다. 서명 길이 (바이트)는 선택적 정수 매개 변수 &lt;code&gt;siglen&lt;/code&gt; 의 값에 의해 결정됩니다 . 기본 서명 길이 (시 &lt;code&gt;siglen&lt;/code&gt; 지정되지 않음) 124 바이트, 최대 서명 길이는 2024 바이트입니다. 서명은 각 단어를 n 비트 문자열의 단일 비트로 해싱하여 생성되며, 이러한 모든 비트를 OR로 결합하여 n 비트 문서 서명을 생성합니다. 두 단어가 동일한 비트 위치로 해시되면 잘못된 일치가 발생합니다. 쿼리의 모든 단어가 일치하는 경우 (실수 또는 거짓) 일치가 올바른지 확인하기 위해 테이블 ​​행을 검색해야합니다. 더 긴 서명은 더 큰 인덱스의 비용으로 더 정확한 검색 (인덱스의 작은 부분과 더 적은 힙 페이지 스캔)으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="4859377c56a7f4250fc7928febe82211450cf591" translate="yes" xml:space="preserve">
          <source>A GiST or SP-GiST index can accelerate queries involving these range operators: &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;lt;@&lt;/code&gt;, &lt;code&gt;@&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;-|-&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt;, and &lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt; (see &lt;a href=&quot;functions-range#RANGE-OPERATORS-TABLE&quot;&gt;Table 9.53&lt;/a&gt; for more information).</source>
          <target state="translated">GiST 또는 SP-GiST 인덱스는 &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;&amp;lt;@&lt;/code&gt; , &lt;code&gt;@&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;-|-&lt;/code&gt; , &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&amp;gt;&lt;/code&gt; 범위 연산자와 관련된 쿼리를 가속화 할 수 있습니다 ( 자세한 내용 은 &lt;a href=&quot;functions-range#RANGE-OPERATORS-TABLE&quot;&gt;표 9.53&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5052f6936540d438e9a8f74a835240911affa68e" translate="yes" xml:space="preserve">
          <source>A JIT provider is loaded by dynamically loading the named shared library. The normal library search path is used to locate the library. To provide the required JIT provider callbacks and to indicate that the library is actually a JIT provider, it needs to provide a C function named &lt;code&gt;_PG_jit_provider_init&lt;/code&gt;. This function is passed a struct that needs to be filled with the callback function pointers for individual actions:</source>
          <target state="translated">명명 된 공유 라이브러리를 동적으로로드하여 JIT 제공자를로드합니다. 라이브러리를 찾는 데 일반 라이브러리 검색 경로가 사용됩니다. 필요한 JIT 제공자 콜백을 제공하고 라이브러리가 실제로 JIT 제공자 &lt;code&gt;_PG_jit_provider_init&lt;/code&gt; 라는 C 함수를 제공해야합니다 . 이 함수에는 개별 액션에 대한 콜백 함수 포인터로 채워 져야하는 구조체가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f096d1aabaef04fadfbfc0905d4cc493f3ce419f" translate="yes" xml:space="preserve">
          <source>A JSON null value is converted to a SQL null in all cases.</source>
          <target state="translated">JSON null 값은 모든 경우에 SQL null로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="989ddd2bcb5960954e9e78a9c33e2efbc341a60e" translate="yes" xml:space="preserve">
          <source>A POSIX time zone specification has the form</source>
          <target state="translated">POSIX 시간대 사양은 다음과 같은 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="90da68c2f0311ac40f24046e1fc30e1392f07dc8" translate="yes" xml:space="preserve">
          <source>A PostgreSQL database cluster contains one or more named databases. Roles and a few other object types are shared across the entire cluster. A client connection to the server can only access data in a single database, the one specified in the connection request.</source>
          <target state="translated">PostgreSQL 데이터베이스 클러스터에는 하나 이상의 명명 된 데이터베이스가 포함됩니다. 역할 및 몇 가지 다른 개체 유형은 전체 클러스터에서 공유됩니다. 서버에 대한 클라이언트 연결은 연결 요청에 지정된 단일 데이터베이스의 데이터에만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c15132a79db70b0e2b3cdb81cbd574f378944491" translate="yes" xml:space="preserve">
          <source>A PostgreSQL database cluster contains one or more named databases. Users and groups of users are shared across the entire cluster, but no other data is shared across databases. Any given client connection to the server can access only the data in a single database, the one specified in the connection request.</source>
          <target state="translated">PostgreSQL 데이터베이스 클러스터에는 하나 이상의 명명 된 데이터베이스가 포함됩니다. 사용자 및 사용자 그룹은 전체 클러스터에서 공유되지만 다른 데이터는 데이터베이스에서 공유되지 않습니다. 서버에 대한 지정된 클라이언트 연결은 연결 요청에 지정된 단일 데이터베이스의 데이터에만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d33772a25bf4dd8b6ca0ae7bbd6d891d7102d71" translate="yes" xml:space="preserve">
          <source>A Snowball dictionary recognizes everything, whether or not it is able to simplify the word, so it should be placed at the end of the dictionary list. It is useless to have it before any other dictionary because a token will never pass through it to the next dictionary.</source>
          <target state="translated">Snowball 사전은 단어를 단순화 할 수 있는지 여부에 관계없이 모든 것을 인식하므로 사전 목록의 끝에 배치해야합니다. 토큰이 토큰을 다음 사전으로 전달하지 않기 때문에 다른 사전보다 먼저 사용하는 것은 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="72bd8340532262887cb9ae14aa89845f88df9078" translate="yes" xml:space="preserve">
          <source>A UUID is written as a sequence of lower-case hexadecimal digits, in several groups separated by hyphens, specifically a group of 8 digits followed by three groups of 4 digits followed by a group of 12 digits, for a total of 32 digits representing the 128 bits. An example of a UUID in this standard form is:</source>
          <target state="translated">UUID는 하이픈으로 구분 된 여러 그룹, 특히 8 자리 그룹 뒤에 4 자리 그룹 3 개, 12 자리 그룹 뒤에 총 32 자리 숫자를 나타내는 일련의 소문자 16 진수로 기록됩니다. 128 비트 이 표준 양식의 UUID의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99a2ddaed13b4fa5189155f796c23cd0b85b2037" translate="yes" xml:space="preserve">
          <source>A bare &lt;code&gt;VALUES&lt;/code&gt; command:</source>
          <target state="translated">베어 &lt;code&gt;VALUES&lt;/code&gt; 명령 :</target>
        </trans-unit>
        <trans-unit id="d1c75bcd54e5d624eb16ebfaf6893165bef4c000" translate="yes" xml:space="preserve">
          <source>A better approach is to send the server's stderr output to some type of log rotation program. There is a built-in log rotation facility, which you can use by setting the configuration parameter &lt;code&gt;logging_collector&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;. The control parameters for this program are described in &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;Section 19.8.1&lt;/a&gt;. You can also use this approach to capture the log data in machine readable CSV (comma-separated values) format.</source>
          <target state="translated">더 나은 방법은 서버의 stderr 출력을 일부 유형의 로그 회전 프로그램으로 보내는 것입니다. &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 &lt;code&gt;logging_collector&lt;/code&gt; 구성 매개 변수 를 &lt;code&gt;true&lt;/code&gt; 로 설정하여 사용할 수있는 로그 로테이션 기능이 내장되어 있습니다 . 이 프로그램의 제어 파라미터는 &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-WHERE&quot;&gt;19.8.1 장에&lt;/a&gt; 설명되어 있습니다. 이 방법을 사용하여 로그 데이터를 시스템에서 읽을 수있는 CSV (쉼표로 구분 된 값) 형식으로 캡처 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebc700417ea8062cbc2133cca40c230572b19efd" translate="yes" xml:space="preserve">
          <source>A better solution is this:</source>
          <target state="translated">더 나은 해결책은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b5297ccac9bf406cd190777b88e363b006c5135" translate="yes" xml:space="preserve">
          <source>A binary string is a sequence of octets (or bytes). Binary strings are distinguished from character strings in two ways. First, binary strings specifically allow storing octets of value zero and other &amp;ldquo;non-printable&amp;rdquo; octets (usually, octets outside the decimal range 32 to 126). Character strings disallow zero octets, and also disallow any other octet values and sequences of octet values that are invalid according to the database's selected character set encoding. Second, operations on binary strings process the actual bytes, whereas the processing of character strings depends on locale settings. In short, binary strings are appropriate for storing data that the programmer thinks of as &amp;ldquo;raw bytes&amp;rdquo;, whereas character strings are appropriate for storing text.</source>
          <target state="translated">이진 문자열은 일련의 옥텟 (또는 바이트)입니다. 이진 문자열은 두 가지 방법으로 문자열과 구별됩니다. 첫째, 이진 문자열은 특히 값이 0 인 옥텟과 다른 &quot;인쇄 불가능한&quot;옥텟 (보통 32에서 126의 10 진수 범위를 벗어난 옥텟)을 저장할 수 있습니다. 문자열은 옥텟 0을 허용하지 않으며 데이터베이스의 선택된 문자 세트 인코딩에 따라 유효하지 않은 다른 옥텟 값 및 옥텟 값 시퀀스도 허용하지 않습니다. 둘째, 이진 문자열 작업은 실제 바이트를 처리하는 반면 문자열 처리는 로캘 설정에 따라 다릅니다. 간단히 말해서, 이진 문자열은 프로그래머가 &quot;원시 바이트&quot;로 생각하는 데이터를 저장하는 데 적합한 반면, 문자열은 텍스트를 저장하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f9eaea7144ed65ec693bd5b0921667ccf802b3ac" translate="yes" xml:space="preserve">
          <source>A bit string value requires 1 byte for each group of 8 bits, plus 5 or 8 bytes overhead depending on the length of the string (but long values may be compressed or moved out-of-line, as explained in &lt;a href=&quot;datatype-character&quot;&gt;Section 8.3&lt;/a&gt; for character strings).</source>
          <target state="translated">비트 스트링 값은 각 8 비트 그룹에 대해 1 바이트가 필요하고 스트링 길이에 따라 5 또는 8 바이트의 오버 헤드가 필요합니다 (그러나 문자열의 &lt;a href=&quot;datatype-character&quot;&gt;8.3 절에&lt;/a&gt; 설명 된대로 긴 값은 압축되거나 라인 외부로 이동할 수 있습니다) ).</target>
        </trans-unit>
        <trans-unit id="731f4887b94e6b2c73ac23722091bfbfd646df88" translate="yes" xml:space="preserve">
          <source>A bracket expression &lt;code&gt;[...]&lt;/code&gt; specifies a character class, just as in POSIX regular expressions.</source>
          <target state="translated">대괄호 표현식 &lt;code&gt;[...]&lt;/code&gt; 은 POSIX 정규 표현식에서와 같이 문자 클래스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="accb592fdd062757612f62053a65bd65ef084e6d" translate="yes" xml:space="preserve">
          <source>A branch &amp;mdash; that is, an RE that has no top-level &lt;code&gt;|&lt;/code&gt; operator &amp;mdash; has the same greediness as the first quantified atom in it that has a greediness attribute.</source>
          <target state="translated">분기 &amp;ndash; 즉 최상위 레벨이없는 RE &lt;code&gt;|&lt;/code&gt; operator (연산자) &amp;mdash; 탐욕 속성을 갖는 첫 번째 정량화 된 원자와 동일한 탐욕을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="1e93e1b748baa49f966038b6b801bfe31bf0d6a1" translate="yes" xml:space="preserve">
          <source>A branch is zero or more &lt;em&gt;quantified atoms&lt;/em&gt; or &lt;em&gt;constraints&lt;/em&gt;, concatenated. It matches a match for the first, followed by a match for the second, etc; an empty branch matches the empty string.</source>
          <target state="translated">분기는 0 개 이상의 &lt;em&gt;정량화 된 원자&lt;/em&gt; 또는 &lt;em&gt;구속 조건&lt;/em&gt; 으로 연결됩니다. 첫 번째와 일치하고 두 번째와 일치합니다. 빈 분기는 빈 문자열과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2afc09a0dce3701a8ab0f81442e2374a5fdfb59a" translate="yes" xml:space="preserve">
          <source>A brief description of the parameter</source>
          <target state="translated">매개 변수에 대한 간단한 설명</target>
        </trans-unit>
        <trans-unit id="531e171813e0ccf35b132f56c05f84b2c29d4251" translate="yes" xml:space="preserve">
          <source>A brief example of using the extension follows.</source>
          <target state="translated">확장 기능을 사용하는 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98ac6e951a01b0cf91beea39451931792f189912" translate="yes" xml:space="preserve">
          <source>A call &lt;code&gt;foo(10)&lt;/code&gt; will fail due to the ambiguity about which function should be called.</source>
          <target state="translated">어떤 함수를 호출해야하는지 모호하기 때문에 &lt;code&gt;foo(10)&lt;/code&gt; 호출 이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f4fd0d041b9fc5d4d7e64ce01b658bcce1a5ce19" translate="yes" xml:space="preserve">
          <source>A cascading standby sends not only WAL records received from the master but also those restored from the archive. So even if the replication connection in some upstream connection is terminated, streaming replication continues downstream for as long as new WAL records are available.</source>
          <target state="translated">계단식 대기는 마스터에서받은 WAL 레코드뿐만 아니라 아카이브에서 복원 된 WAL 레코드도 보냅니다. 따라서 일부 업스트림 연결에서 복제 연결이 종료 되더라도 새로운 WAL 레코드를 사용할 수있는 한 스트리밍 복제는 다운 스트림에서 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="8b122451af392bc569e4090bc6ac8841aa8dd655" translate="yes" xml:space="preserve">
          <source>A case similar to filter conditions occurs with &amp;ldquo;lossy&amp;rdquo; index scans. For example, consider this search for polygons containing a specific point:</source>
          <target state="translated">필터 조건과 유사한 경우 &quot;손실&quot;인덱스 스캔이 발생합니다. 예를 들어, 다음과 같은 특정 점을 포함하는 다각형을 검색해보십시오.</target>
        </trans-unit>
        <trans-unit id="1483859001ccf841f9287a26876bc89e5ac64726" translate="yes" xml:space="preserve">
          <source>A cast to or from a domain type currently has no effect. Casting to or from a domain uses the casts associated with its underlying type.</source>
          <target state="translated">도메인 유형에 대한 캐스트는 현재 효과가 없습니다. 도메인으로 또는 도메인에서 캐스트 할 때는 기본 유형과 관련된 캐스트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee03111f55078d640fb1865535e64f9dbf42c86a" translate="yes" xml:space="preserve">
          <source>A catalog row appearing in the initial data can be given a manually-assigned OID by writing an &lt;code&gt;oid =&amp;gt; nnnn&lt;/code&gt; metadata field. Furthermore, if an OID is assigned, a C macro for that OID can be created by writing an &lt;code&gt;oid_symbol =&amp;gt; name&lt;/code&gt; metadata field.</source>
          <target state="translated">&lt;code&gt;oid =&amp;gt; nnnn&lt;/code&gt; 메타 데이터 필드 를 작성하여 초기 데이터에 나타나는 카탈로그 행에 수동으로 할당 된 OID를 제공 할 수 있습니다 . 또한 OID가 할당되면 &lt;code&gt;oid_symbol =&amp;gt; name&lt;/code&gt; 메타 데이터 필드 를 작성하여 해당 OID에 대한 C 매크로를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="322518448cbeae5586806e5aaaa6dbbaaee252c8" translate="yes" xml:space="preserve">
          <source>A change in collation definitions can lead to corrupt indexes and other problems because the database system relies on stored objects having a certain sort order. Generally, this should be avoided, but it can happen in legitimate circumstances, such as when using &lt;code&gt;pg_upgrade&lt;/code&gt; to upgrade to server binaries linked with a newer version of ICU. When this happens, all objects depending on the collation should be rebuilt, for example, using &lt;code&gt;REINDEX&lt;/code&gt;. When that is done, the collation version can be refreshed using the command &lt;code&gt;ALTER COLLATION ... REFRESH VERSION&lt;/code&gt;. This will update the system catalog to record the current collator version and will make the warning go away. Note that this does not actually check whether all affected objects have been rebuilt correctly.</source>
          <target state="translated">데이터 정렬 정의가 변경되면 데이터베이스 시스템이 특정 정렬 순서를 가진 저장된 오브젝트에 의존하기 때문에 인덱스 및 기타 문제점이 손상 될 수 있습니다. 일반적으로 이것은 피해야하지만 &lt;code&gt;pg_upgrade&lt;/code&gt; 를 사용하여 최신 버전의 ICU와 연결된 서버 바이너리로 업그레이드 할 때와 같은 합법적 인 상황에서 발생할 수 있습니다 . 이 경우 데이터 정렬에 따라 모든 오브젝트를 다시 빌드해야합니다 (예 : &lt;code&gt;REINDEX&lt;/code&gt; 사용) . 완료되면 &lt;code&gt;ALTER COLLATION ... REFRESH VERSION&lt;/code&gt; 명령을 사용하여 데이터 정렬 버전을 새로 고칠 수 있습니다 . 현재 카탈로그 버전을 기록하기 위해 시스템 카탈로그가 업데이트되고 경고가 사라집니다. 실제로 영향을받는 모든 개체가 올바르게 다시 작성되었는지 여부는 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f4a0879a18199d5f077ec0ff2e180faddd77063" translate="yes" xml:space="preserve">
          <source>A check constraint can also refer to several columns. Say you store a regular price and a discounted price, and you want to ensure that the discounted price is lower than the regular price:</source>
          <target state="translated">점검 제한 조건은 여러 열을 참조 할 수도 있습니다. 일반 가격과 할인 가격을 저장하고 할인 된 가격이 일반 가격보다 낮은 지 확인하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="5fb12afa94e8bc72660d65f619fede9431dd8e90" translate="yes" xml:space="preserve">
          <source>A check constraint is the most generic constraint type. It allows you to specify that the value in a certain column must satisfy a Boolean (truth-value) expression. For instance, to require positive product prices, you could use:</source>
          <target state="translated">점검 제한 조건이 가장 일반적인 제한 조건 유형입니다. 특정 열의 값이 부울 (진정 값) 표현식을 만족해야 함을 지정할 수 있습니다. 예를 들어, 긍정적 인 제품 가격을 요구하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9805d0aa6ddc05f9bc01627befe8b2b8532cb45" translate="yes" xml:space="preserve">
          <source>A checkpoint is a point in the write-ahead log sequence at which all data files have been updated to reflect the information in the log. All data files will be flushed to disk. Refer to &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt; for more details about what happens during a checkpoint.</source>
          <target state="translated">체크 포인트는 미리 쓰기 로그 시퀀스에서 모든 데이터 파일이 로그의 정보를 반영하도록 업데이트 된 지점입니다. 모든 데이터 파일이 디스크로 플러시됩니다. 체크 포인트 동안 일어나는 일에 대한 자세한 내용은 &lt;a href=&quot;wal-configuration&quot;&gt;29.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a7d37eff183865f5e0589720c997a7480356b5f" translate="yes" xml:space="preserve">
          <source>A checkpoint is also the act of carrying out all the actions that are necessary to reach a checkpoint as defined above. This process is initiated when predefined conditions are met, such as a specified amount of time has passed, or a certain volume of records has been written; or it can be invoked by the user with the command &lt;code&gt;CHECKPOINT&lt;/code&gt;.</source>
          <target state="translated">체크 포인트는 위에 정의 된 체크 포인트에 도달하는 데 필요한 모든 작업을 수행하는 행위이기도합니다. 이 프로세스는 지정된 시간이 경과했거나 특정 양의 레코드가 기록 된 경우와 같이 미리 정의 된 조건이 충족 될 때 시작됩니다. 또는 &lt;code&gt;CHECKPOINT&lt;/code&gt; 명령을 사용하여 사용자가 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e10395ea67c519738bcfedd97fec8b7a98e77981" translate="yes" xml:space="preserve">
          <source>A clause of the form</source>
          <target state="translated">양식의 절</target>
        </trans-unit>
        <trans-unit id="d3d17faa1f9b24f81d090c43c22a75e3dfd2f4a5" translate="yes" xml:space="preserve">
          <source>A clause of the form &lt;code&gt;USING ( a, b, ... )&lt;/code&gt; is shorthand for &lt;code&gt;ON left_table.a = right_table.a AND left_table.b = right_table.b ...&lt;/code&gt;. Also, &lt;code&gt;USING&lt;/code&gt; implies that only one of each pair of equivalent columns will be included in the join output, not both.</source>
          <target state="translated">&lt;code&gt;USING ( a, b, ... )&lt;/code&gt; 형식의 절은 &lt;code&gt;ON left_table.a = right_table.a AND left_table.b = right_table.b ...&lt;/code&gt; 약어입니다 . 또한 &lt;code&gt;USING&lt;/code&gt; 은 각 동등한 열 쌍 중 하나만 조인 출력에 포함되며 둘 다가 아니라는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2d0bfde758816d57c2adc33132d231587021c551" translate="yes" xml:space="preserve">
          <source>A closely related issue that affects planning time is collapsing of subqueries into their parent query. For example, consider:</source>
          <target state="translated">계획 시간에 영향을 미치는 밀접한 관련 문제는 하위 쿼리가 상위 쿼리에 축소되는 것입니다. 예를 들어, 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ca452f51e79db640e56e4f9925aa0048af9d720d" translate="yes" xml:space="preserve">
          <source>A code defining the specific semantics of this dependency relationship; see text</source>
          <target state="translated">이 의존 관계의 특정 의미를 정의하는 코드. 텍스트 참조</target>
        </trans-unit>
        <trans-unit id="2ca8fb5b99b4bb7400bad4589e85235d85b8712a" translate="yes" xml:space="preserve">
          <source>A code defining the type of initial privilege of this object; see text</source>
          <target state="translated">이 객체의 초기 권한 유형을 정의하는 코드. 텍스트 참조</target>
        </trans-unit>
        <trans-unit id="f7f2588e77da5e4feafd01ab8f374851f37bddfd" translate="yes" xml:space="preserve">
          <source>A code number indicating the kind of statistics stored in the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo; of the &lt;code&gt;pg_statistic&lt;/code&gt; row.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; 행 의 &lt;code&gt;N&lt;/code&gt; 번째 &quot;슬롯&quot;에 저장된 통계 종류를 나타내는 코드 번호 입니다.</target>
        </trans-unit>
        <trans-unit id="f423b7df9b88ecbf124e9ccab75b7d879dc4cca0" translate="yes" xml:space="preserve">
          <source>A collation expression</source>
          <target state="translated">콜 레이션 표현식</target>
        </trans-unit>
        <trans-unit id="9c0dd05ad8edff154a8e6c9ab1b14bf3a7460e7c" translate="yes" xml:space="preserve">
          <source>A collation is an SQL schema object that maps an SQL name to locales provided by libraries installed in the operating system. A collation definition has a &lt;em&gt;provider&lt;/em&gt; that specifies which library supplies the locale data. One standard provider name is &lt;code&gt;libc&lt;/code&gt;, which uses the locales provided by the operating system C library. These are the locales that most tools provided by the operating system use. Another provider is &lt;code&gt;icu&lt;/code&gt;, which uses the external ICU library. ICU locales can only be used if support for ICU was configured when PostgreSQL was built.</source>
          <target state="translated">데이터 정렬은 운영 체제에 설치된 라이브러리에서 제공하는 로캘에 SQL 이름을 매핑하는 SQL 스키마 개체입니다. 데이터 정렬 정의에는 로캘 데이터를 제공하는 라이브러리를 지정 하는 &lt;em&gt;공급자&lt;/em&gt; 가 있습니다. 하나의 표준 제공자 이름은 &lt;code&gt;libc&lt;/code&gt; 이며 운영 체제 C 라이브러리가 제공하는 로케일을 사용합니다. 운영 체제에서 제공하는 대부분의 도구가 사용하는 로캘입니다. 다른 제공자는 외부 ICU 라이브러리를 사용하는 &lt;code&gt;icu&lt;/code&gt; 입니다. ICU 로케일은 PostgreSQL을 빌드 할 때 ICU 지원이 구성된 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd492bf97f6c0e26453468337ad19bf874c44502" translate="yes" xml:space="preserve">
          <source>A collation is either &lt;em&gt;deterministic&lt;/em&gt; or &lt;em&gt;nondeterministic&lt;/em&gt;. A deterministic collation uses deterministic comparisons, which means that it considers strings to be equal only if they consist of the same byte sequence. Nondeterministic comparison may determine strings to be equal even if they consist of different bytes. Typical situations include case-insensitive comparison, accent-insensitive comparison, as well as comparison of strings in different Unicode normal forms. It is up to the collation provider to actually implement such insensitive comparisons; the deterministic flag only determines whether ties are to be broken using bytewise comparison. See also &lt;a href=&quot;https://unicode.org/reports/tr10&quot;&gt;Unicode Technical Standard 10&lt;/a&gt; for more information on the terminology.</source>
          <target state="translated">데이터 정렬 중 하나입니다 &lt;em&gt;결정적&lt;/em&gt; 또는 &lt;em&gt;비 결정적&lt;/em&gt; . 결정 론적 데이터 정렬은 결정 론적 비교를 사용합니다. 즉, 문자열이 동일한 바이트 시퀀스로 구성된 경우에만 문자열을 동일하게 간주합니다. 비 결정적 비교는 문자열이 서로 다른 바이트로 구성되어 있어도 문자열이 동일한 것으로 결정할 수 있습니다. 일반적인 상황에는 대소 문자를 구분하지 않는 비교, 악센트를 구분하지 않는 비교 및 ​​다른 유니 코드 일반 형식의 문자열 비교가 포함됩니다. 실제로 이러한 무감각 비교를 구현하는 것은 데이터 정렬 제공자의 책임입니다. 결정적 플래그는 바이트 단위 비교를 사용하여 타이를 끊을 지 여부 만 결정합니다. 용어에 대한 자세한 내용은 &lt;a href=&quot;https://unicode.org/reports/tr10&quot;&gt;유니 코드 기술 표준 10&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="585469a73deac416236caf1e82c0a86b85aed8e2" translate="yes" xml:space="preserve">
          <source>A collation is either &lt;em&gt;deterministic&lt;/em&gt; or &lt;em&gt;nondeterministic&lt;/em&gt;. A deterministic collation uses deterministic comparisons, which means that it considers strings to be equal only if they consist of the same byte sequence. Nondeterministic comparison may determine strings to be equal even if they consist of different bytes. Typical situations include case-insensitive comparison, accent-insensitive comparison, as well as comparison of strings in different Unicode normal forms. It is up to the collation provider to actually implement such insensitive comparisons; the deterministic flag only determines whether ties are to be broken using bytewise comparison. See also &lt;a href=&quot;https://www.unicode.org/reports/tr10&quot;&gt;Unicode Technical Standard 10&lt;/a&gt; for more information on the terminology.</source>
          <target state="translated">데이터 정렬 중 하나입니다 &lt;em&gt;결정적&lt;/em&gt; 또는 &lt;em&gt;비 결정적&lt;/em&gt; . 결정적 데이터 정렬은 결정적 비교를 사용합니다. 즉, 동일한 바이트 시퀀스로 구성된 경우에만 문자열이 동일하다고 간주합니다. 비 결정적 비교는 문자열이 서로 다른 바이트로 구성되어 있어도 동일하다고 결정할 수 있습니다. 일반적인 상황에는 대소 문자를 구분하지 않는 비교, 악센트를 구분하지 않는 비교, 다른 유니 코드 일반 형식의 문자열 비교가 포함됩니다. 이러한 무감각 한 비교를 실제로 구현하는 것은 데이터 정렬 공급자에게 달려 있습니다. 결정적 플래그는 바이트 비교를 사용하여 동점을 끊을 지 여부 만 결정합니다. 용어에 대한 자세한 내용은 &lt;a href=&quot;https://www.unicode.org/reports/tr10&quot;&gt;유니 코드 기술 표준 10&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9ebffe965dbfb2b402733d22f1b65d8768ef66b6" translate="yes" xml:space="preserve">
          <source>A collation object provided by &lt;code&gt;icu&lt;/code&gt; maps to a named collator provided by the ICU library. ICU does not support separate &amp;ldquo;collate&amp;rdquo; and &amp;ldquo;ctype&amp;rdquo; settings, so they are always the same. Also, ICU collations are independent of the encoding, so there is always only one ICU collation of a given name in a database.</source>
          <target state="translated">&lt;code&gt;icu&lt;/code&gt; 에서 제공 한 데이터 정렬 객체 는 ICU 라이브러리에서 제공하는 명명 된 콜 레이터에 매핑됩니다. ICU는 별도의 &quot;콜레이트&quot;및 &quot;ctype&quot;설정을 지원하지 않으므로 항상 동일합니다. 또한 ICU 데이터 정렬은 인코딩과 무관하므로 데이터베이스에는 항상 지정된 이름의 ICU 데이터 정렬이 하나만 있습니다.</target>
        </trans-unit>
        <trans-unit id="67e66134fe986b5a1161f010ed997e5c29515718" translate="yes" xml:space="preserve">
          <source>A collation object provided by &lt;code&gt;libc&lt;/code&gt; maps to a combination of &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; settings, as accepted by the &lt;code&gt;setlocale()&lt;/code&gt; system library call. (As the name would suggest, the main purpose of a collation is to set &lt;code&gt;LC_COLLATE&lt;/code&gt;, which controls the sort order. But it is rarely necessary in practice to have an &lt;code&gt;LC_CTYPE&lt;/code&gt; setting that is different from &lt;code&gt;LC_COLLATE&lt;/code&gt;, so it is more convenient to collect these under one concept than to create another infrastructure for setting &lt;code&gt;LC_CTYPE&lt;/code&gt; per expression.) Also, a &lt;code&gt;libc&lt;/code&gt; collation is tied to a character set encoding (see &lt;a href=&quot;multibyte&quot;&gt;Section 23.3&lt;/a&gt;). The same collation name may exist for different encodings.</source>
          <target state="translated">&lt;code&gt;libc&lt;/code&gt; 가 제공하는 데이터 정렬 오브젝트 는 &lt;code&gt;setlocale()&lt;/code&gt; 시스템 라이브러리 호출에 의해 허용되는 &lt;code&gt;LC_COLLATE&lt;/code&gt; 및 &lt;code&gt;LC_CTYPE&lt;/code&gt; 설정 의 조합으로 맵핑됩니다 . (이름에서 알 수 있듯이 데이터 정렬의 주요 목적은 정렬 순서를 제어하는 &lt;code&gt;LC_COLLATE&lt;/code&gt; 를 설정 하는 것이지만 실제로 &lt;code&gt;LC_COLLATE&lt;/code&gt; 와 다른 &lt;code&gt;LC_CTYPE&lt;/code&gt; 설정 을 갖는 것이 거의 필요하지 않으므로 이러한 데이터를 수집하는 것이 더 편리합니다 표현 &lt;code&gt;LC_CTYPE&lt;/code&gt; 을 설정하기위한 다른 인프라를 작성하는 것보다 하나의 개념하에 있습니다 .) 또한 &lt;code&gt;libc&lt;/code&gt; 데이터 정렬은 문자 세트 인코딩에 연결됩니다 ( &lt;a href=&quot;multibyte&quot;&gt;섹션 23.3&lt;/a&gt; 참조).). 다른 인코딩에 대해 동일한 데이터 정렬 이름이 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbd951bae781e6ca52e1aa0ea05378979fbabbd4" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; in a fixed order. That order may be defined by the &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; (or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;) where the tuple is contained, in which case the tuple is often called a &lt;em&gt;row&lt;/em&gt;. It may also be defined by the structure of a result set, in which case it is sometimes called a &lt;em&gt;record&lt;/em&gt;.</source>
          <target state="translated">고정 된 순서 의 &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;속성&lt;/a&gt; 모음입니다 . 그 순서는 튜플이 포함 된 &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; (또는 다른 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; )에 의해 정의 될 수 있으며 ,이 경우 튜플을 종종 &lt;em&gt;행&lt;/em&gt; 이라고합니다 . 결과 세트의 구조로 정의 될 수도 있으며이 경우 &lt;em&gt;레코드&lt;/em&gt; 라고도합니다 .</target>
        </trans-unit>
        <trans-unit id="c1d02a0633df2ef26eee92135725af62089ef8cb" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;tables&lt;/a&gt; which describe the structure of all &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt; of the instance. The system catalog resides in the schema &lt;code&gt;pg_catalog&lt;/code&gt;. These tables contain data in internal representation and are not typically considered useful for user examination; a number of user-friendlier &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;views&lt;/a&gt;, also in schema &lt;code&gt;pg_catalog&lt;/code&gt;, offer more convenient access to some of that information, while additional tables and views exist in schema &lt;code&gt;information_schema&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/information-schema.html&quot;&gt;Chapter 36&lt;/a&gt;) that expose some of the same and additional information as mandated by the &lt;a href=&quot;glossary#GLOSSARY-SQL-STANDARD&quot;&gt;SQL standard&lt;/a&gt;.</source>
          <target state="translated">인스턴스 의 모든 &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL 개체&lt;/a&gt; 의 구조를 설명하는 &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 모음입니다 . 시스템 카탈로그는 &lt;code&gt;pg_catalog&lt;/code&gt; 스키마에 있습니다. 이 테이블은 내부 표현의 데이터를 포함하며 일반적으로 사용자 검사에 유용하지 않은 것으로 간주됩니다. &lt;code&gt;pg_catalog&lt;/code&gt; 스키마에서도 사용자에게 친숙한 여러 &lt;a href=&quot;glossary#GLOSSARY-VIEW&quot;&gt;뷰&lt;/a&gt; 는 해당 정보 중 일부에 대한보다 편리한 액세스를 제공하는 반면, 추가 테이블과 뷰는 스키마 &lt;code&gt;information_schema&lt;/code&gt; 스키마 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/information-schema.html&quot;&gt;36 장&lt;/a&gt; 참조)에 존재 합니다. &lt;a href=&quot;glossary#GLOSSARY-SQL-STANDARD&quot;&gt;SQL 표준&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b63b111cc045d92308ab6bb0ff812b8d4531fcd" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuples&lt;/a&gt; having a common data structure (the same number of &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt;, in the same order, having the same name and type per position). A table is the most common form of &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; in PostgreSQL.</source>
          <target state="translated">공통 데이터 구조를 갖는 &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;튜플&lt;/a&gt; 모음 ( 동일한 순서로 동일한 수의 &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;속성&lt;/a&gt; , 위치 당 동일한 이름 및 유형). 테이블은 PostgreSQL에서 가장 일반적인 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="85e16773e18c89eb8dbf7379d075c0ed8024236a" translate="yes" xml:space="preserve">
          <source>A collection of access privileges to the &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;instance&lt;/a&gt;. Roles are themselves a privilege that can be granted to other roles. This is often done for convenience or to ensure completeness when multiple &lt;a href=&quot;glossary#GLOSSARY-USER&quot;&gt;users&lt;/a&gt; need the same privileges.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;인스턴스&lt;/a&gt; 에 대한 액세스 권한 모음입니다 . 역할 자체는 다른 역할에 부여 할 수있는 권한입니다. 이는 편의를 위해 또는 여러 &lt;a href=&quot;glossary#GLOSSARY-USER&quot;&gt;사용자&lt;/a&gt; 가 동일한 권한을 필요로 할 때 완전성을 보장하기 위해 수행되는 경우가 많습니다 .</target>
        </trans-unit>
        <trans-unit id="81b0b809d9ea56c7639bef5d5e043207a72e42ff" translate="yes" xml:space="preserve">
          <source>A collection of databases and global SQL objects, and their common static and dynamic metadata. Sometimes referred to as a &lt;em&gt;cluster&lt;/em&gt;.</source>
          <target state="translated">데이터베이스 및 전역 SQL 개체, 공통 정적 및 동적 메타 데이터 모음입니다. &lt;em&gt;클러스터&lt;/em&gt; 라고도 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="243ac044c18a03ce7230410123ce180ce925ca61" translate="yes" xml:space="preserve">
          <source>A column can be assigned a default value. When a new row is created and no values are specified for some of the columns, those columns will be filled with their respective default values. A data manipulation command can also request explicitly that a column be set to its default value, without having to know what that value is. (Details about data manipulation commands are in &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt;.)</source>
          <target state="translated">열에 기본값을 할당 할 수 있습니다. 새 행이 작성되고 일부 열에 값이 지정되지 않으면 해당 열은 각각의 기본값으로 채워집니다. 데이터 조작 명령은 또한 값이 무엇인지 몰라도 열이 기본값으로 설정되도록 명시 적으로 요청할 수 있습니다. (데이터 조작 명령에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;6 장에&lt;/a&gt; 있습니다.)</target>
        </trans-unit>
        <trans-unit id="728c6855211584a9477504f501bcae575c68f1dd" translate="yes" xml:space="preserve">
          <source>A column can be assigned a default value. When a new row is created and no values are specified for some of the columns, those columns will be filled with their respective default values. A data manipulation command can also request explicitly that a column be set to its default value, without having to know what that value is. (Details about data manipulation commands are in &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;Chapter 6&lt;/a&gt;.)</source>
          <target state="translated">열에 기본값을 할당 할 수 있습니다. 새 행이 생성되고 일부 열에 값이 지정되지 않은 경우 해당 열은 각각의 기본값으로 채워집니다. 데이터 조작 명령은 값이 무엇인지 알 필요없이 열을 기본값으로 설정하도록 명시 적으로 요청할 수도 있습니다. (데이터 조작 명령에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;6 장에&lt;/a&gt; 있습니다.)</target>
        </trans-unit>
        <trans-unit id="a303981025d3fba2a49b2d8afa067fd02f82810b" translate="yes" xml:space="preserve">
          <source>A column can be referenced in the form:</source>
          <target state="translated">열은 다음 형식으로 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e814702f2c68b1dd74624138092e2f2dac25d61" translate="yes" xml:space="preserve">
          <source>A column marked &lt;code&gt;FOR ORDINALITY&lt;/code&gt; will be populated with row numbers, starting with 1, in the order of nodes retrieved from the &lt;code&gt;row_expression&lt;/code&gt;'s result node-set. At most one column may be marked &lt;code&gt;FOR ORDINALITY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FOR ORDINALITY&lt;/code&gt; 로 표시된 열 은 &lt;code&gt;row_expression&lt;/code&gt; 의 결과 노드 세트 에서 검색된 노드 순서대로 1부터 시작하여 행 번호로 채워집니다 . 최대 하나의 열은 &lt;code&gt;FOR ORDINALITY&lt;/code&gt; 로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12e0d49f86838408b879ad07c7e5231286011142" translate="yes" xml:space="preserve">
          <source>A column of a foreign table created using this wrapper can have the following options:</source>
          <target state="translated">이 랩퍼를 사용하여 작성된 외부 테이블의 열에는 다음 옵션이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc14af77e732b86dd798941f4129e5ffc051f3d7" translate="yes" xml:space="preserve">
          <source>A column reference</source>
          <target state="translated">열 참조</target>
        </trans-unit>
        <trans-unit id="43fad0f566cbecaf300364b0a3a7343007869d54" translate="yes" xml:space="preserve">
          <source>A column-specific trigger (one defined using the &lt;code&gt;UPDATE OF column_name&lt;/code&gt; syntax) will fire when any of its columns are listed as targets in the &lt;code&gt;UPDATE&lt;/code&gt; command's &lt;code&gt;SET&lt;/code&gt; list. It is possible for a column's value to change even when the trigger is not fired, because changes made to the row's contents by &lt;code&gt;BEFORE UPDATE&lt;/code&gt; triggers are not considered. Conversely, a command such as &lt;code&gt;UPDATE ... SET x = x ...&lt;/code&gt; will fire a trigger on column &lt;code&gt;x&lt;/code&gt;, even though the column's value did not change.</source>
          <target state="translated">열 특정 트리거 ( &lt;code&gt;UPDATE OF column_name&lt;/code&gt; 구문을 사용하여 정의 된 트리거)는 열 중 하나 가 &lt;code&gt;UPDATE&lt;/code&gt; 명령의 &lt;code&gt;SET&lt;/code&gt; 목록에 대상으로 나열되면 시작 됩니다. &lt;code&gt;BEFORE UPDATE&lt;/code&gt; 트리거에 의한 행 내용 변경은 고려되지 않기 때문에 트리거가 시작되지 않더라도 열 값이 변경 될 수 있습니다 . 반대로 &lt;code&gt;UPDATE ... SET x = x ...&lt;/code&gt; 와 같은 명령 은 열 값이 변경되지 않았더라도 &lt;code&gt;x&lt;/code&gt; 열에서 트리거를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="e7ce99ce6bf9fda66b89c10600a10dba3a88bd33" translate="yes" xml:space="preserve">
          <source>A combination of commands that must act as a single &lt;a href=&quot;glossary#GLOSSARY-ATOMIC&quot;&gt;atomic&lt;/a&gt; command: they all succeed or all fail as a single unit, and their effects are not visible to other &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;sessions&lt;/a&gt; until the transaction is complete, and possibly even later, depending on the isolation level.</source>
          <target state="translated">단일 &lt;a href=&quot;glossary#GLOSSARY-ATOMIC&quot;&gt;원자 적&lt;/a&gt; 명령 으로 작동해야하는 명령의 조합 : 모두 성공하거나 모두 단일 단위로 실패하며 트랜잭션이 완료 될 때까지 다른 &lt;a href=&quot;glossary#GLOSSARY-SESSION&quot;&gt;세션에서&lt;/a&gt; 그 효과를 볼 수 없으며 격리 수준에 따라 나중에는 가능할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f697bbd81557d764888518e1af36278f9c8d3579" translate="yes" xml:space="preserve">
          <source>A combination of dynamic domain transition and trusted procedure enables an interesting use case that fits the typical process life-cycle of connection pooling software. Even if your connection pooling software is not allowed to run most of SQL commands, you can allow it to switch the security label of the client using the &lt;code&gt;sepgsql_setcon()&lt;/code&gt; function from within a trusted procedure; that should take some credential to authorize the request to switch the client label. After that, this session will have the privileges of the target user, rather than the connection pooler. The connection pooler can later revert the security label change by again using &lt;code&gt;sepgsql_setcon()&lt;/code&gt; with &lt;code&gt;NULL&lt;/code&gt; argument, again invoked from within a trusted procedure with appropriate permissions checks. The point here is that only the trusted procedure actually has permission to change the effective security label, and only does so when given proper credentials. Of course, for secure operation, the credential store (table, procedure definition, or whatever) must be protected from unauthorized access.</source>
          <target state="translated">동적 도메인 전환과 신뢰할 수있는 절차를 결합하면 연결 풀링 소프트웨어의 일반적인 프로세스 수명주기에 맞는 흥미로운 사용 사례가 가능합니다. 연결 풀링 소프트웨어에서 대부분의 SQL 명령을 실행할 수없는 경우에도 신뢰할 수있는 프로 시저 내에서 &lt;code&gt;sepgsql_setcon()&lt;/code&gt; 함수를 사용하여 클라이언트의 보안 레이블을 전환 할 수 있습니다. 클라이언트 레이블 전환 요청을 승인하려면 몇 가지 자격 증명이 필요합니다. 그 후에이 세션은 연결 풀러가 아닌 대상 사용자의 권한을 갖습니다. 연결 풀러는 나중에 &lt;code&gt;sepgsql_setcon()&lt;/code&gt; 을 &lt;code&gt;NULL&lt;/code&gt; 로 사용하여 보안 레이블 변경 사항을 다시 되돌릴 수 있습니다.적절한 권한 검사를 통해 신뢰할 수있는 프로 시저 내에서 다시 호출됩니다. 여기서 중요한 점은 신뢰할 수있는 절차 만 실제로 효과적인 보안 레이블을 변경할 수있는 권한이 있으며 적절한 자격 증명이 제공된 경우에만 해당됩니다. 물론 안전한 운영을 위해 자격 증명 저장소 (테이블, 프로 시저 정의 등)는 무단 액세스로부터 보호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2911cc608e469494b5712a777002f2e21913d79f" translate="yes" xml:space="preserve">
          <source>A command to execute. In &lt;code&gt;COPY FROM&lt;/code&gt;, the input is read from standard output of the command, and in &lt;code&gt;COPY TO&lt;/code&gt;, the output is written to the standard input of the command.</source>
          <target state="translated">실행할 명령입니다. 에서는 &lt;code&gt;COPY FROM&lt;/code&gt; , 입력 명령은 표준 출력으로부터 판독되고,에 &lt;code&gt;COPY TO&lt;/code&gt; 출력 명령의 표준 입력에 기록된다.</target>
        </trans-unit>
        <trans-unit id="b8b60faef517b04517cdc32cdeaec6d45d821a98" translate="yes" xml:space="preserve">
          <source>A command to prevent access to a named set of &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; objects for a named list of &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;roles&lt;/a&gt;.</source>
          <target state="translated">명명 된 &lt;a href=&quot;glossary#GLOSSARY-ROLE&quot;&gt;역할&lt;/a&gt; 목록에 대해 명명 된 &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;데이터베이스&lt;/a&gt; 개체 집합에 대한 액세스를 방지하는 명령 입니다.</target>
        </trans-unit>
        <trans-unit id="432b06e57f9235552442ece4a5144f1741f08cf9" translate="yes" xml:space="preserve">
          <source>A command to undo all of the operations performed since the beginning of a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;트랜잭션&lt;/a&gt; 시작 이후 수행 된 모든 작업을 실행 취소하는 명령 입니다.</target>
        </trans-unit>
        <trans-unit id="dfeede7bacbce2d25ad1c8afefcc0d73e7394ef6" translate="yes" xml:space="preserve">
          <source>A comment is a sequence of characters beginning with double dashes and extending to the end of the line, e.g.:</source>
          <target state="translated">주석은 이중 대시로 시작하고 줄 끝까지 확장되는 일련의 문자입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="3eb6cee486403a5e9f022d4d86b027a6b1d863bd" translate="yes" xml:space="preserve">
          <source>A comment is removed from the input stream before further syntax analysis and is effectively replaced by whitespace.</source>
          <target state="translated">주석은 추가 구문 분석 전에 입력 스트림에서 제거되며 효과적으로 공백으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="fd4ff7f9082f219e362f6b80b3a0778be34303a7" translate="yes" xml:space="preserve">
          <source>A completely empty field value (no characters at all between the commas or parentheses) represents a NULL. To write a value that is an empty string rather than NULL, write &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">완전히 비어있는 필드 값 (쉼표 또는 괄호 사이에 문자가 전혀 없음)은 NULL을 나타냅니다. NULL이 아닌 빈 문자열 인 값을 쓰려면 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="bc479538bc2519f6be7743a108e2d4369ba071e0" translate="yes" xml:space="preserve">
          <source>A computer on which PostgreSQL &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instances&lt;/a&gt; run. The term &lt;em&gt;server&lt;/em&gt; denotes real hardware, a container, or a &lt;em&gt;virtual machine&lt;/em&gt;.</source>
          <target state="translated">PostgreSQL &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;인스턴스가&lt;/a&gt; 실행 되는 컴퓨터 . &lt;em&gt;서버&lt;/em&gt; 라는 용어는 실제 하드웨어, 컨테이너 또는 &lt;em&gt;가상 머신을&lt;/em&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="712b440e19e5b1db615da5ae01b27ee905115fec" translate="yes" xml:space="preserve">
          <source>A computer that communicates with other computers over a network. This is sometimes used as a synonym for &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt;. It is also used to refer to a computer where &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;client processes&lt;/a&gt; run.</source>
          <target state="translated">네트워크를 통해 다른 컴퓨터와 통신하는 컴퓨터입니다. 이것은 때때로 &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; 의 동의어로 사용됩니다 . &lt;a href=&quot;glossary#GLOSSARY-CLIENT&quot;&gt;클라이언트 프로세스가&lt;/a&gt; 실행 되는 컴퓨터를 가리키는데도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b2c2b765e8d46a4effd9275029b3ac9ce35557f" translate="yes" xml:space="preserve">
          <source>A concept of non-existence that is a central tenet of relational database theory. It represents the absence of a definite value.</source>
          <target state="translated">관계형 데이터베이스 이론의 중심 신조 인 비 존재의 개념. 명확한 값이 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="db43da6a754b048f8c15b9fee6431ce49e646a6c" translate="yes" xml:space="preserve">
          <source>A conflict will produce an error and will stop the replication; it must be resolved manually by the user. Details about the conflict can be found in the subscriber's server log.</source>
          <target state="translated">충돌로 인해 오류가 발생하고 복제가 중지됩니다. 사용자가 수동으로 해결해야합니다. 충돌에 대한 자세한 내용은 가입자의 서버 로그에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6de61942e5889f7081d4c447f2d861f6661580c6" translate="yes" xml:space="preserve">
          <source>A connection from an application program to the PostgreSQL server has to be established. The application program transmits a query to the server and waits to receive the results sent back by the server.</source>
          <target state="translated">응용 프로그램에서 PostgreSQL 서버로의 연결이 설정되어 있어야합니다. 응용 프로그램은 서버로 조회를 전송하고 서버가 보낸 결과를 수신하기를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="ff27f94049d4acbe17b6492b665c173de57c0e06" translate="yes" xml:space="preserve">
          <source>A constant of an &lt;em&gt;arbitrary&lt;/em&gt; type can be entered using any one of the following notations:</source>
          <target state="translated">다음 표기법 중 하나를 사용하여 &lt;em&gt;임의&lt;/em&gt; 유형 의 상수를 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="def2a00f2b728102b713698dbaec6bf7d1b1ba45" translate="yes" xml:space="preserve">
          <source>A constant or expression to compute and insert at the indicated place in the resulting table (set of rows). In a &lt;code&gt;VALUES&lt;/code&gt; list appearing at the top level of an &lt;code&gt;INSERT&lt;/code&gt;, an &lt;code&gt;expression&lt;/code&gt; can be replaced by &lt;code&gt;DEFAULT&lt;/code&gt; to indicate that the destination column's default value should be inserted. &lt;code&gt;DEFAULT&lt;/code&gt; cannot be used when &lt;code&gt;VALUES&lt;/code&gt; appears in other contexts.</source>
          <target state="translated">결과 테이블의 표시된 위치 (행 세트)에서 계산하고 삽입 할 상수 또는 표현식입니다. A의 &lt;code&gt;VALUES&lt;/code&gt; 의 의 최상위에 나타나는 목록 &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;expression&lt;/code&gt; 으로 대체 될 수 &lt;code&gt;DEFAULT&lt;/code&gt; 대상 컬럼의 디폴트 값이 삽입되어야 함을 나타냅니다. 다른 컨텍스트에 &lt;code&gt;VALUES&lt;/code&gt; 가 나타나면 &lt;code&gt;DEFAULT&lt;/code&gt; 를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f51660594b80d9306c037e5807f00beb6e91d699" translate="yes" xml:space="preserve">
          <source>A constant or literal value</source>
          <target state="translated">상수 또는 리터럴 값</target>
        </trans-unit>
        <trans-unit id="cf8fda03118cc7add18d0baf25c70ed12492a1c1" translate="yes" xml:space="preserve">
          <source>A constraint marked with &lt;code&gt;NO INHERIT&lt;/code&gt; will not propagate to child tables.</source>
          <target state="translated">&lt;code&gt;NO INHERIT&lt;/code&gt; 로 표시된 제한 조건은 하위 테이블로 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8913bbb8fb57baf6761a820445fb91f212ee581b" translate="yes" xml:space="preserve">
          <source>A convention often used is to write key words in upper case and names in lower case, e.g.:</source>
          <target state="translated">자주 사용되는 규칙은 키워드를 대문자로 쓰고 이름을 소문자로 쓰는 것입니다. 예 :</target>
        </trans-unit>
        <trans-unit id="270045f32202a02af54823e311103963348c2e0e" translate="yes" xml:space="preserve">
          <source>A conversion of a &lt;a href=&quot;glossary#GLOSSARY-DATUM&quot;&gt;datum&lt;/a&gt; from its current data type to another data type.</source>
          <target state="translated">(A)의 변환 &lt;a href=&quot;glossary#GLOSSARY-DATUM&quot;&gt;데이텀&lt;/a&gt; 다른 데이터 형식으로 현재 데이터 유형에서.</target>
        </trans-unit>
        <trans-unit id="fee55ddb20eb8d0ea230a86a3979ff4c9211fbe9" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;pg_type.typalign&lt;/code&gt; of this column's type</source>
          <target state="translated">이 열 유형 의 &lt;code&gt;pg_type.typalign&lt;/code&gt; 사본</target>
        </trans-unit>
        <trans-unit id="16520694e80b09447c7974353ea21a94aea9b85b" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;pg_type.typbyval&lt;/code&gt; of this column's type</source>
          <target state="translated">이 열 유형 의 &lt;code&gt;pg_type.typbyval&lt;/code&gt; 사본</target>
        </trans-unit>
        <trans-unit id="469c374912ca15a938f750a67728c2d10a7ddd2a" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;pg_type.typlen&lt;/code&gt; of this column's type</source>
          <target state="translated">이 열 유형 의 &lt;code&gt;pg_type.typlen&lt;/code&gt; 사본</target>
        </trans-unit>
        <trans-unit id="64372429a7f7ff378ebe32047bb948215d6fc9f3" translate="yes" xml:space="preserve">
          <source>A cursor has an associated position, which is used by &lt;code&gt;FETCH&lt;/code&gt;. The cursor position can be before the first row of the query result, on any particular row of the result, or after the last row of the result. When created, a cursor is positioned before the first row. After fetching some rows, the cursor is positioned on the row most recently retrieved. If &lt;code&gt;FETCH&lt;/code&gt; runs off the end of the available rows then the cursor is left positioned after the last row, or before the first row if fetching backward. &lt;code&gt;FETCH ALL&lt;/code&gt; or &lt;code&gt;FETCH BACKWARD ALL&lt;/code&gt; will always leave the cursor positioned after the last row or before the first row.</source>
          <target state="translated">커서는 연관된 위치를 가지며, 이는 &lt;code&gt;FETCH&lt;/code&gt; 에 의해 사용됩니다 . 커서 위치는 쿼리 결과의 첫 번째 행 앞, 결과의 특정 행 또는 마지막 행 뒤에있을 수 있습니다. 작성되면 커서가 첫 번째 행 앞에 위치합니다. 일부 행을 페치 한 후 커서는 가장 최근에 검색된 행에 위치합니다. 경우 &lt;code&gt;FETCH&lt;/code&gt; 뒤로 가져 오는 경우 다음 커서가 왼쪽 마지막 행 후 또는 첫 번째 행 앞에 위치 가능한 행의 마지막을 지나고 실행됩니다. &lt;code&gt;FETCH ALL&lt;/code&gt; 또는 &lt;code&gt;FETCH BACKWARD ALL&lt;/code&gt; 은 항상 마지막 행 뒤에 또는 첫 번째 행 앞에 커서를 둡니다.</target>
        </trans-unit>
        <trans-unit id="ca84330d2df84d2fb3203c9d1abd5c728ed51c45" translate="yes" xml:space="preserve">
          <source>A custom-format dump is not a script for psql, but instead must be restored with pg_restore, for example:</source>
          <target state="translated">사용자 정의 형식 덤프는 psql 용 스크립트가 아니라 pg_restore로 복원해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac05a9e40c0d434aa68a1851fc9e7d6d26043953" translate="yes" xml:space="preserve">
          <source>A data type &lt;code&gt;tsvector&lt;/code&gt; is provided for storing preprocessed documents, along with a type &lt;code&gt;tsquery&lt;/code&gt; for representing processed queries (&lt;a href=&quot;datatype-textsearch&quot;&gt;Section 8.11&lt;/a&gt;). There are many functions and operators available for these data types (&lt;a href=&quot;functions-textsearch&quot;&gt;Section 9.13&lt;/a&gt;), the most important of which is the match operator &lt;code&gt;@@&lt;/code&gt;, which we introduce in &lt;a href=&quot;textsearch-intro#TEXTSEARCH-MATCHING&quot;&gt;Section 12.1.2&lt;/a&gt;. Full text searches can be accelerated using indexes (&lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;).</source>
          <target state="translated">처리 된 쿼리를 나타내는 &lt;code&gt;tsquery&lt;/code&gt; 유형과 함께 사전 처리 된 문서를 저장하기 위해 데이터 유형 &lt;code&gt;tsvector&lt;/code&gt; 가 제공됩니다 ( &lt;a href=&quot;datatype-textsearch&quot;&gt;8.11 절&lt;/a&gt; ). 이러한 데이터 유형에 사용할 수있는 많은 함수와 연산자가 있으며 ( &lt;a href=&quot;functions-textsearch&quot;&gt;섹션 9.13&lt;/a&gt; ), 가장 중요한 것은 &lt;a href=&quot;textsearch-intro#TEXTSEARCH-MATCHING&quot;&gt;12.1.2&lt;/a&gt; 에서 소개 하는 일치 연산자 &lt;code&gt;@@&lt;/code&gt; 입니다. 색인을 사용하여 전체 텍스트 검색을 가속화 할 수 있습니다 ( &lt;a href=&quot;textsearch-indexes&quot;&gt;12.9 절&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c829ffd204fab8f2c9ec9a14aa40a4d117b945a" translate="yes" xml:space="preserve">
          <source>A data-only dump will still use &lt;code&gt;COPY&lt;/code&gt;, but it does not drop or recreate indexes, and it does not normally touch foreign keys. &lt;a href=&quot;#ftn.id-1.5.13.7.11.4.2&quot;&gt;&lt;sup id=&quot;id-1.5.13.7.11.4.2&quot;&gt;[13]&lt;/sup&gt;&lt;/a&gt; So when loading a data-only dump, it is up to you to drop and recreate indexes and foreign keys if you wish to use those techniques. It's still useful to increase &lt;code&gt;max_wal_size&lt;/code&gt; while loading the data, but don't bother increasing &lt;code&gt;maintenance_work_mem&lt;/code&gt;; rather, you'd do that while manually recreating indexes and foreign keys afterwards. And don't forget to &lt;code&gt;ANALYZE&lt;/code&gt; when you're done; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">데이터 전용 덤프는 여전히 &lt;code&gt;COPY&lt;/code&gt; 를 사용 하지만 인덱스를 삭제하거나 다시 만들지 않으며 일반적으로 외래 키를 건드리지 않습니다. &lt;a href=&quot;#ftn.id-1.5.13.7.11.4.2&quot;&gt;&lt;sup id=&quot;id-1.5.13.7.11.4.2&quot;&gt;[13]&lt;/sup&gt;&lt;/a&gt; 따라서 데이터 전용 덤프를로드 할 때 이러한 기술을 사용하려면 인덱스와 외래 키를 삭제하고 다시 작성해야합니다. 데이터를로드하는 동안 &lt;code&gt;max_wal_size&lt;/code&gt; 를 늘리는 것이 여전히 유용 하지만 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 을 늘리는 것을 방해하지는 않습니다 . 오히려 나중에 인덱스와 외래 키를 수동으로 다시 만드는 동안 그렇게 할 것입니다. 그리고 당신이 끝나면 &lt;code&gt;ANALYZE&lt;/code&gt; 하는 것을 잊지 마십시오 ; 참조 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;섹션 24.1.3&lt;/a&gt; 및 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;섹션 24.1.6을&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="a7efff5b8bc220045364eeb6371d5a7d0adfbf4d" translate="yes" xml:space="preserve">
          <source>A database contains one or more named &lt;em&gt;schemas&lt;/em&gt;, which in turn contain tables. Schemas also contain other kinds of named objects, including data types, functions, and operators. The same object name can be used in different schemas without conflict; for example, both &lt;code&gt;schema1&lt;/code&gt; and &lt;code&gt;myschema&lt;/code&gt; can contain tables named &lt;code&gt;mytable&lt;/code&gt;. Unlike databases, schemas are not rigidly separated: a user can access objects in any of the schemas in the database they are connected to, if they have privileges to do so.</source>
          <target state="translated">데이터베이스에는 하나 이상의 명명 된 &lt;em&gt;스키마&lt;/em&gt; 가 포함되며, 여기에는 테이블이 포함됩니다. 스키마에는 데이터 유형, 함수 및 연산자를 포함한 다른 종류의 명명 된 객체도 포함됩니다. 충돌없이 다른 스키마에서 동일한 객체 이름을 사용할 수 있습니다. 예를 들어 &lt;code&gt;schema1&lt;/code&gt; 과 &lt;code&gt;myschema&lt;/code&gt; 모두 &lt;code&gt;mytable&lt;/code&gt; 이라는 테이블을 포함 할 수 있습니다 . 데이터베이스와 달리 스키마는 엄격하게 분리되지 않습니다. 사용자는 연결된 데이터베이스의 스키마에있는 개체에 액세스 할 수있는 권한이있는 개체에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ebb2f86492fa3a77fa0db26d0c30c86dff05744" translate="yes" xml:space="preserve">
          <source>A database is a named collection of SQL objects (&amp;ldquo;database objects&amp;rdquo;). Generally, every database object (tables, functions, etc.) belongs to one and only one database. (However there are a few system catalogs, for example &lt;code&gt;pg_database&lt;/code&gt;, that belong to a whole cluster and are accessible from each database within the cluster.) More accurately, a database is a collection of schemas and the schemas contain the tables, functions, etc. So the full hierarchy is: server, database, schema, table (or some other kind of object, such as a function).</source>
          <target state="translated">데이터베이스는 명명 된 SQL 객체 모음 (&amp;ldquo;데이터베이스 객체&amp;rdquo;)입니다. 일반적으로 모든 데이터베이스 개체 (테이블, 함수 등)는 하나의 데이터베이스에만 속합니다. (그러나 전체 클러스터에 속하고 클러스터 내의 각 데이터베이스에서 액세스 할 수 있는 몇 개의 시스템 카탈로그 (예 : &lt;code&gt;pg_database&lt;/code&gt; )가 있습니다.)보다 정확하게는 데이터베이스는 스키마의 모음이며 스키마에는 테이블, 함수 등이 포함됩니다. 따라서 전체 계층 구조는 서버, 데이터베이스, 스키마, 테이블 (또는 함수와 같은 다른 종류의 객체)입니다.</target>
        </trans-unit>
        <trans-unit id="c7d2c9abe130147ea353b9080d406b7f3bf3c1ff" translate="yes" xml:space="preserve">
          <source>A database role can have a number of attributes that define its privileges and interact with the client authentication system.</source>
          <target state="translated">데이터베이스 역할에는 권한을 정의하고 클라이언트 인증 시스템과 상호 작용하는 많은 속성이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3022f04bd927ba344f6e517eda753ede33a9966" translate="yes" xml:space="preserve">
          <source>A database superuser bypasses all permission checks, except the right to log in. This is a dangerous privilege and should not be used carelessly; it is best to do most of your work as a role that is not a superuser. To create a new database superuser, use &lt;code&gt;CREATE ROLE name SUPERUSER&lt;/code&gt;. You must do this as a role that is already a superuser.</source>
          <target state="translated">데이터베이스 수퍼 유저는 로그인 권한을 제외한 모든 권한 검사를 무시합니다. 이는 위험한 권한이므로 부주의하게 사용해서는 안됩니다. 수퍼 유저가 아닌 역할로 대부분의 작업을 수행하는 것이 가장 좋습니다. 새 데이터베이스 수퍼 유저를 작성하려면 &lt;code&gt;CREATE ROLE name SUPERUSER&lt;/code&gt; 를 사용하십시오 . 이미 수퍼 유저 인 역할로이 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="a652bebb73f376f1df0ca8598fee059cf76fc365" translate="yes" xml:space="preserve">
          <source>A default value can be specified, in case a user wants columns of the data type to default to something other than the null value. Specify the default with the &lt;code&gt;DEFAULT&lt;/code&gt; key word. (Such a default can be overridden by an explicit &lt;code&gt;DEFAULT&lt;/code&gt; clause attached to a particular column.)</source>
          <target state="translated">사용자가 데이터 유형의 열을 널 (null) 이외의 값으로 기본값으로 설정하려는 경우 기본값을 지정할 수 있습니다. &lt;code&gt;DEFAULT&lt;/code&gt; 키워드로 기본값을 지정하십시오 . (이러한 기본값은 특정 열에 첨부 된 명시 적 &lt;code&gt;DEFAULT&lt;/code&gt; 절로 재정의 될 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="260245ca0f51394bde912da70513f69a2611aadc" translate="yes" xml:space="preserve">
          <source>A defined set of instructions stored in the database system that can be invoked for execution. A routine can be written in a variety of programming languages. Routines can be &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;functions&lt;/a&gt; (including set-returning functions and &lt;a href=&quot;glossary#GLOSSARY-TRIGGER&quot;&gt;trigger functions&lt;/a&gt;), &lt;a href=&quot;glossary#GLOSSARY-AGGREGATE&quot;&gt;aggregate functions&lt;/a&gt;, and &lt;a href=&quot;glossary#GLOSSARY-PROCEDURE&quot;&gt;procedures&lt;/a&gt;.</source>
          <target state="translated">실행을 위해 호출 할 수있는 데이터베이스 시스템에 저장된 정의 된 명령어 세트입니다. 루틴은 다양한 프로그래밍 언어로 작성 될 수 있습니다. 루틴은 &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;함수&lt;/a&gt; (세트 반환 함수 및 &lt;a href=&quot;glossary#GLOSSARY-TRIGGER&quot;&gt;트리거 함수 포함&lt;/a&gt; ), &lt;a href=&quot;glossary#GLOSSARY-AGGREGATE&quot;&gt;집계 함수&lt;/a&gt; 및 &lt;a href=&quot;glossary#GLOSSARY-PROCEDURE&quot;&gt;프로 시저 일 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c1f42cac75263776f033d6ed34f1fbc16bad9be" translate="yes" xml:space="preserve">
          <source>A delay of this many seconds occurs when a new server process is started, after it conducts the authentication procedure. This is intended to give an opportunity to attach to the server process with a debugger.</source>
          <target state="translated">인증 절차를 수행 한 후 새 서버 프로세스가 시작되면이 몇 초의 지연이 발생합니다. 이것은 디버거를 사용하여 서버 프로세스에 연결할 수있는 기회를 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd25a0e450014180419d77ce403bad9e20cb5564" translate="yes" xml:space="preserve">
          <source>A detailed description of bison or the grammar rules given in &lt;code&gt;gram.y&lt;/code&gt; would be beyond the scope of this paper. There are many books and documents dealing with flex and bison. You should be familiar with bison before you start to study the grammar given in &lt;code&gt;gram.y&lt;/code&gt; otherwise you won't understand what happens there.</source>
          <target state="translated">&lt;code&gt;gram.y&lt;/code&gt; 에 제시된 들소 또는 문법 규칙에 대한 자세한 설명 은이 문서의 범위를 벗어납니다. 플렉스와 들소를 다루는 많은 책과 문서가 있습니다. &lt;code&gt;gram.y&lt;/code&gt; 에 주어진 문법을 공부하기 전에 들소에 대해 잘 알고 있어야합니다. 그렇지 않으면 거기서 일어나는 일을 이해할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf3c5419b01f42e467232a91a0454e478bf36293" translate="yes" xml:space="preserve">
          <source>A dictionary is a program that accepts a token as input and returns:</source>
          <target state="translated">사전은 토큰을 입력으로 받아들이고 다음을 반환하는 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="28559b5d13d6b8ce91e33b4017f8d681ab5ce5fe" translate="yes" xml:space="preserve">
          <source>A different approach to redirecting inserts into the appropriate child table is to set up rules, instead of a trigger, on the master table. For example:</source>
          <target state="translated">적절한 하위 테이블로 삽입을 리디렉션하는 다른 방법은 마스터 테이블에서 트리거 대신 규칙을 설정하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="92dd343b65d278a179ec5a3ad694901513c02d90" translate="yes" xml:space="preserve">
          <source>A different setting might be appropriate when doing synchronous logical replication. The logical replication workers report the positions of writes and flushes to the publisher, and when using synchronous replication, the publisher will wait for the actual flush. This means that setting &lt;code&gt;synchronous_commit&lt;/code&gt; for the subscriber to &lt;code&gt;off&lt;/code&gt; when the subscription is used for synchronous replication might increase the latency for &lt;code&gt;COMMIT&lt;/code&gt; on the publisher. In this scenario, it can be advantageous to set &lt;code&gt;synchronous_commit&lt;/code&gt; to &lt;code&gt;local&lt;/code&gt; or higher.</source>
          <target state="translated">동기식 논리적 복제를 수행 할 때 다른 설정이 적절할 수 있습니다. 논리적 복제 작업자는 쓰기 및 플러시 위치를 게시자에게보고하고 동기 복제를 사용하는 경우 게시자는 실제 플러시를 기다립니다. 그 설정이 수단 &lt;code&gt;synchronous_commit&lt;/code&gt; 을 에 가입자 &lt;code&gt;off&lt;/code&gt; 구독이의 대기 시간을 증가시킬 수 동기식 복제에 사용되는 &lt;code&gt;COMMIT&lt;/code&gt; 게시자에. 이 시나리오에서는 &lt;code&gt;synchronous_commit&lt;/code&gt; 을 &lt;code&gt;local&lt;/code&gt; 이상 으로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="77b0f5ef06846b6f2b1bf89e5b5dc745a05b482a" translate="yes" xml:space="preserve">
          <source>A disadvantage of the &lt;code&gt;jsonb_path_ops&lt;/code&gt; approach is that it produces no index entries for JSON structures not containing any values, such as &lt;code&gt;{&quot;a&quot;: {}}&lt;/code&gt;. If a search for documents containing such a structure is requested, it will require a full-index scan, which is quite slow. &lt;code&gt;jsonb_path_ops&lt;/code&gt; is therefore ill-suited for applications that often perform such searches.</source>
          <target state="translated">&lt;code&gt;jsonb_path_ops&lt;/code&gt; 접근법 의 단점은 &lt;code&gt;{&quot;a&quot;: {}}&lt;/code&gt; 와 같은 값을 포함하지 않는 JSON 구조에 대한 색인 항목을 생성하지 않는다는 것 입니다. 이러한 구조를 포함하는 문서에 대한 검색이 요청되면 전체 색인 스캔이 필요하며 이는 상당히 느립니다. 따라서 &lt;code&gt;jsonb_path_ops&lt;/code&gt; 는 종종 그러한 검색을 수행하는 응용 프로그램에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="436fb2bab58d12b2362059406a336206c3d00306" translate="yes" xml:space="preserve">
          <source>A discrete range is one whose element type has a well-defined &amp;ldquo;step&amp;rdquo;, such as &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;date&lt;/code&gt;. In these types two elements can be said to be adjacent, when there are no valid values between them. This contrasts with continuous ranges, where it's always (or almost always) possible to identify other element values between two given values. For example, a range over the &lt;code&gt;numeric&lt;/code&gt; type is continuous, as is a range over &lt;code&gt;timestamp&lt;/code&gt;. (Even though &lt;code&gt;timestamp&lt;/code&gt; has limited precision, and so could theoretically be treated as discrete, it's better to consider it continuous since the step size is normally not of interest.)</source>
          <target state="translated">불연속 범위는 요소 유형에 &lt;code&gt;integer&lt;/code&gt; 또는 &lt;code&gt;date&lt;/code&gt; 와 같이 잘 정의 된 &quot;단계&quot;가있는 범위입니다 . 이 유형에서 두 요소 사이에 유효한 값이 없으면 두 요소가 인접한다고 할 수 있습니다. 이것은 연속 범위와 대조되며, 주어진 두 값 사이에서 다른 요소 값을 식별하는 것이 항상 가능하거나 거의 항상 가능합니다. 예를 들어, &lt;code&gt;numeric&lt;/code&gt; 유형에 대한 범위는 시간 &lt;code&gt;timestamp&lt;/code&gt; 대한 범위와 같이 연속적 입니다. ( &lt;code&gt;timestamp&lt;/code&gt; 정밀도는 제한되어 있지만 이론적으로는 이산 형으로 취급 될 수 있지만 단계 크기는 일반적으로 관심이 없기 때문에 연속적으로 고려하는 것이 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="a23c5cb9993deaf1311e315f3014f146e372868a" translate="yes" xml:space="preserve">
          <source>A discrete range type should have a &lt;em&gt;canonicalization&lt;/em&gt; function that is aware of the desired step size for the element type. The canonicalization function is charged with converting equivalent values of the range type to have identical representations, in particular consistently inclusive or exclusive bounds. If a canonicalization function is not specified, then ranges with different formatting will always be treated as unequal, even though they might represent the same set of values in reality.</source>
          <target state="translated">이산 범위 유형 에는 요소 유형에 대해 원하는 단계 크기를 인식 하는 &lt;em&gt;정규화&lt;/em&gt; 기능이 있어야합니다. 정규화 함수는 범위 유형의 동등한 값을 동일한 표현, 특히 일관되게 포함 또는 배타적 경계로 변환합니다. 정규화 함수를 지정하지 않으면 실제로 동일한 형식의 값을 나타낼 수 있지만 형식이 다른 범위는 항상 동일하지 않은 것으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="52cd489229e47470dc581e1d13cab54fdd7f5f6e" translate="yes" xml:space="preserve">
          <source>A dollar sign (&lt;code&gt;$&lt;/code&gt;) followed by digits is used to represent a positional parameter in the body of a function definition or a prepared statement. In other contexts the dollar sign can be part of an identifier or a dollar-quoted string constant.</source>
          <target state="translated">함수 정의 또는 준비된 명령문의 본문에서 위치 매개 변수를 나타내는 데 달러 기호 ( &lt;code&gt;$&lt;/code&gt; ) 뒤에 숫자가 사용됩니다. 다른 맥락에서, 달러 부호는 식별자 또는 달러 인용 문자열 상수의 일부일 수있다.</target>
        </trans-unit>
        <trans-unit id="85726c6c75380e885546cdf31fee2dad70737f00" translate="yes" xml:space="preserve">
          <source>A dollar-quoted string that follows a keyword or identifier must be separated from it by whitespace; otherwise the dollar quoting delimiter would be taken as part of the preceding identifier.</source>
          <target state="translated">키워드 또는 식별자 뒤에 오는 달러 인용 문자열은 공백으로 구분해야합니다. 그렇지 않으면 달러 인용 구분 기호가 선행 식별자의 일부로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="483ea815eb464b44ff5ffec5d8ce0005d215accd" translate="yes" xml:space="preserve">
          <source>A duplicate is a leaf page tuple (a tuple that points to a table row) where &lt;em&gt;all&lt;/em&gt; indexed key columns have values that match corresponding column values from at least one other leaf page tuple in the same index. Duplicate tuples are quite common in practice. B-Tree indexes can use a special, space-efficient representation for duplicates when an optional technique is enabled: &lt;em&gt;deduplication&lt;/em&gt;.</source>
          <target state="translated">중복은 리프 페이지 튜플 (테이블 행을 가리키는 튜플)이며, &lt;em&gt;모든&lt;/em&gt; 인덱싱 된 키 열에는 동일한 인덱스에있는 하나 이상의 다른 리프 페이지 튜플의 해당 열 값과 일치하는 값이 있습니다. 중복 튜플은 실제로 매우 일반적입니다. B- 트리 인덱스는 선택적 기술인 &lt;em&gt;중복 제거&lt;/em&gt; 가 활성화 된 경우 중복에 대해 특수하고 공간 효율적인 표현을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cee3f5330478a7b8687aa435c97bcf37602fa11b" translate="yes" xml:space="preserve">
          <source>A failure message indicating inability to bind to a port might indicate that that port is already in use by some non-PostgreSQL process. You might also get this error if you terminate &lt;code&gt;postgres&lt;/code&gt; and immediately restart it using the same port; in this case, you must simply wait a few seconds until the operating system closes the port before trying again. Finally, you might get this error if you specify a port number that your operating system considers to be reserved. For example, many versions of Unix consider port numbers under 1024 to be &amp;ldquo;trusted&amp;rdquo; and only permit the Unix superuser to access them.</source>
          <target state="translated">포트에 바인딩 할 수 없음을 나타내는 실패 메시지는 일부 PostgreSQL 이외의 프로세스에서 포트를 이미 사용하고 있음을 나타낼 수 있습니다. &lt;code&gt;postgres&lt;/code&gt; 를 종료 하고 동일한 포트를 사용하여 즉시 다시 시작 하면이 오류가 발생할 수도 있습니다 . 이 경우 운영 체제가 포트를 닫을 때까지 몇 초만 기다려야 다시 시도 할 수 있습니다. 마지막으로 운영 체제에서 예약 된 것으로 간주되는 포트 번호를 지정하면이 오류가 발생할 수 있습니다. 예를 들어, 많은 버전의 Unix는 1024 미만의 포트 번호를 &quot;신뢰할 수있는&quot;것으로 간주하고 Unix 수퍼 유저 만 액세스 할 수 있도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6c9a12fdfac03387393cfa5d605bafff7741fcf8" translate="yes" xml:space="preserve">
          <source>A failure message mentioning &lt;code&gt;semget&lt;/code&gt; or &lt;code&gt;shmget&lt;/code&gt; probably indicates you need to configure your kernel to provide adequate shared memory and semaphores. For more discussion see &lt;a href=&quot;kernel-resources&quot;&gt;Section 18.4&lt;/a&gt;. You might be able to postpone reconfiguring your kernel by decreasing &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; to reduce the shared memory consumption of PostgreSQL, and/or by reducing &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; to reduce the semaphore consumption.</source>
          <target state="translated">&lt;code&gt;semget&lt;/code&gt; 또는 &lt;code&gt;shmget&lt;/code&gt; 을 언급하는 실패 메시지 는 적절한 공유 메모리 및 세마포어를 제공하도록 커널을 구성해야 함을 나타냅니다. 자세한 내용은 &lt;a href=&quot;kernel-resources&quot;&gt;섹션 18.4를&lt;/a&gt; 참조하십시오 . PostgreSQL의 공유 메모리 소비를 줄이기 위해 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; 를 줄이거 나 세마포어 소비를 줄이기 위해 &lt;a href=&quot;runtime-config-connection#GUC-MAX-CONNECTIONS&quot;&gt;max_connections&lt;/a&gt; 를 줄임으로써 커널 재구성을 연기 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6441f31b6574d318eb87a3d59abc87efb6583505" translate="yes" xml:space="preserve">
          <source>A failure message suggesting that another server is already running should be checked carefully, for example by using the command</source>
          <target state="translated">다른 서버가 이미 실행 중임을 나타내는 오류 메시지는 예를 들어 다음 명령을 사용하여 신중하게 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d9edc129f87c5a3cfe93256806f12763480e5e4" translate="yes" xml:space="preserve">
          <source>A few of the catalogs are so fundamental that they can't even be created by the BKI &lt;code&gt;create&lt;/code&gt; command that's used for most catalogs, because that command needs to write information into these catalogs to describe the new catalog. These are called &lt;em&gt;bootstrap&lt;/em&gt; catalogs, and defining one takes a lot of extra work: you have to manually prepare appropriate entries for them in the pre-loaded contents of &lt;code&gt;pg_class&lt;/code&gt; and &lt;code&gt;pg_type&lt;/code&gt;, and those entries will need to be updated for subsequent changes to the catalog's structure. (Bootstrap catalogs also need pre-loaded entries in &lt;code&gt;pg_attribute&lt;/code&gt;, but fortunately &lt;code&gt;genbki.pl&lt;/code&gt; handles that chore nowadays.) Avoid making new catalogs be bootstrap catalogs if at all possible.</source>
          <target state="translated">일부 카탈로그는 매우 기본적이어서 대부분의 카탈로그에 사용되는 BKI &lt;code&gt;create&lt;/code&gt; 명령으로 작성할 수 없습니다. 이 명령은 새 카탈로그를 설명하기 위해 이러한 카탈로그에 정보를 작성해야하기 때문입니다. 이를 &lt;em&gt;부트 스트랩&lt;/em&gt; 카탈로그 라고하며 ,이를 정의하는 데는 많은 추가 작업 이 필요 &lt;code&gt;pg_type&lt;/code&gt; &lt;code&gt;pg_class&lt;/code&gt; 및 pg_type 의 사전로드 된 컨텐츠에서 적절한 항목을 수동으로 준비 해야하며, 카탈로그에 대한 후속 변경 사항을 위해 해당 항목을 업데이트해야합니다. 구조. (부트 스트랩 카탈로그에는 &lt;code&gt;pg_attribute&lt;/code&gt; 에 사전로드 된 항목이 필요 하지만 다행히 &lt;code&gt;genbki.pl&lt;/code&gt; 요즘 가장 번거로운 핸들입니다.) 가능하면 새 카탈로그를 부트 스트랩 카탈로그로 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="491372897d998156eaa18d8e18156aea1cce4b05" translate="yes" xml:space="preserve">
          <source>A field selection expression</source>
          <target state="translated">필드 선택 표현식</target>
        </trans-unit>
        <trans-unit id="7c39dad2086ca141110bdca18a2eda32e161292b" translate="yes" xml:space="preserve">
          <source>A file containing the major version number of PostgreSQL</source>
          <target state="translated">PostgreSQL의 주요 버전 번호를 포함하는 파일</target>
        </trans-unit>
        <trans-unit id="6d87ef4157174eec7539a1a8a3467ba85faf286d" translate="yes" xml:space="preserve">
          <source>A file recording the command-line options the server was last started with</source>
          <target state="translated">서버가 마지막으로 시작된 명령 행 옵션을 기록하는 파일</target>
        </trans-unit>
        <trans-unit id="329de4f43c6fb34276fdedd0bdd8b0f19adeca12" translate="yes" xml:space="preserve">
          <source>A file used for storing configuration parameters that are set by &lt;code&gt;ALTER SYSTEM&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ALTER SYSTEM&lt;/code&gt; 에서 설정 한 구성 매개 변수를 저장하는 데 사용되는 파일</target>
        </trans-unit>
        <trans-unit id="d60f29dfa94fb158cf5e58302f68dd9e477b3bca" translate="yes" xml:space="preserve">
          <source>A filtering dictionary can be placed anywhere in the list, except at the end where it'd be useless. Filtering dictionaries are useful to partially normalize words to simplify the task of later dictionaries. For example, a filtering dictionary could be used to remove accents from accented letters, as is done by the &lt;a href=&quot;unaccent&quot;&gt;unaccent&lt;/a&gt; module.</source>
          <target state="translated">필터링 사전은 쓸모없는 끝을 제외하고 목록의 어느 곳에 나 배치 할 수 있습니다. 필터링 사전은 단어를 부분적으로 정규화하여 이후 사전의 작업을 단순화하는 데 유용합니다. 예를 들어, 필터링 사전을 사용하여 &lt;a href=&quot;unaccent&quot;&gt;악센트가없는&lt;/a&gt; 모듈 에서와 같이 악센트 문자에서 악센트를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61b8bbc2eb9fadf3683e04ebbb9e129815f5ed02" translate="yes" xml:space="preserve">
          <source>A final identifier type used by the system is &lt;code&gt;tid&lt;/code&gt;, or tuple identifier (row identifier). This is the data type of the system column &lt;code&gt;ctid&lt;/code&gt;. A tuple ID is a pair (block number, tuple index within block) that identifies the physical location of the row within its table.</source>
          <target state="translated">시스템에서 사용하는 최종 식별자 유형은 &lt;code&gt;tid&lt;/code&gt; 또는 튜플 식별자 (행 식별자)입니다. 이것이 시스템 열 &lt;code&gt;ctid&lt;/code&gt; 의 데이터 유형입니다 . 튜플 ID는 테이블 내 행의 물리적 위치를 식별하는 쌍 (블록 번호, 블록 내 튜플 인덱스)입니다.</target>
        </trans-unit>
        <trans-unit id="9534174e684925e17ef91bf3e3714ca6759242b6" translate="yes" xml:space="preserve">
          <source>A fine point of the above example is that the &lt;code&gt;WITH&lt;/code&gt; clause is attached to the &lt;code&gt;INSERT&lt;/code&gt;, not the sub-&lt;code&gt;SELECT&lt;/code&gt; within the &lt;code&gt;INSERT&lt;/code&gt;. This is necessary because data-modifying statements are only allowed in &lt;code&gt;WITH&lt;/code&gt; clauses that are attached to the top-level statement. However, normal &lt;code&gt;WITH&lt;/code&gt; visibility rules apply, so it is possible to refer to the &lt;code&gt;WITH&lt;/code&gt; statement's output from the sub-&lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">위의 예에서의 좋은 점이이다 &lt;code&gt;WITH&lt;/code&gt; 절이에 부착 &lt;code&gt;INSERT&lt;/code&gt; 아니라는 서브 &lt;code&gt;SELECT&lt;/code&gt; 내에 &lt;code&gt;INSERT&lt;/code&gt; . 데이터 수정 명령문은 최상위 레벨 명령문에 첨부 된 &lt;code&gt;WITH&lt;/code&gt; 절 에서만 허용되므로 필요 합니다. 그러나 정상적인 &lt;code&gt;WITH&lt;/code&gt; 가시성 규칙이 적용되므로 하위 &lt;code&gt;SELECT&lt;/code&gt; 의 &lt;code&gt;WITH&lt;/code&gt; 문 출력 을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d04dea72f91d057a2ddbc23d00826a2d1a1c915a" translate="yes" xml:space="preserve">
          <source>A first pass to build the index is done for each new index. Once the index is built, its flag &lt;code&gt;pg_index.indisready&lt;/code&gt; is switched to &amp;ldquo;true&amp;rdquo; to make it ready for inserts, making it visible to other sessions once the transaction that performed the build is finished. This step is done in a separate transaction for each index.</source>
          <target state="translated">인덱스를 빌드하기위한 첫 번째 패스는 각각의 새 인덱스에 대해 수행됩니다. 인덱스가 작성되면 &lt;code&gt;pg_index.indisready&lt;/code&gt; 플래그 가 &quot;true&quot;로 전환되어 삽입 준비가되어 빌드를 수행 한 트랜잭션이 완료되면 다른 세션에서 볼 수 있습니다. 이 단계는 각 인덱스마다 별도의 트랜잭션으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a130458680bbe29e1418dce659480b6f78389bae" translate="yes" xml:space="preserve">
          <source>A foreign key can also constrain and reference a group of columns. As usual, it then needs to be written in table constraint form. Here is a contrived syntax example:</source>
          <target state="translated">외래 키는 열 그룹을 제한하고 참조 할 수도 있습니다. 평소와 같이 테이블 제약 조건 형식으로 작성해야합니다. 다음은 고안된 구문 예입니다.</target>
        </trans-unit>
        <trans-unit id="7935e3b9aa49c2d43f16cbf75e1d409bba02665a" translate="yes" xml:space="preserve">
          <source>A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. We say this maintains the &lt;em&gt;referential integrity&lt;/em&gt; between two related tables.</source>
          <target state="translated">외래 키 제약 조건은 열 (또는 열 그룹)의 값이 다른 테이블의 일부 행에 나타나는 값과 일치해야 함을 지정합니다. 우리는 이것이 두 개의 관련 테이블 사이 의 &lt;em&gt;참조 무결성을&lt;/em&gt; 유지한다고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="dec7e4504b0a144e3a3d9b45cbf1480f1f8aba04" translate="yes" xml:space="preserve">
          <source>A foreign key must reference columns that either are a primary key or form a unique constraint. This means that the referenced columns always have an index (the one underlying the primary key or unique constraint); so checks on whether a referencing row has a match will be efficient. Since a &lt;code&gt;DELETE&lt;/code&gt; of a row from the referenced table or an &lt;code&gt;UPDATE&lt;/code&gt; of a referenced column will require a scan of the referencing table for rows matching the old value, it is often a good idea to index the referencing columns too. Because this is not always needed, and there are many choices available on how to index, declaration of a foreign key constraint does not automatically create an index on the referencing columns.</source>
          <target state="translated">외래 키는 기본 키이거나 고유 제약 조건 인 열을 참조해야합니다. 이는 참조 된 열에 항상 색인 (기본 키 또는 고유 제한 조건의 기본 색인)이 있음을 의미합니다. 따라서 참조 행이 일치하는지 확인하십시오. 때문에 &lt;code&gt;DELETE&lt;/code&gt; 참조 테이블에서 행 또는의 &lt;code&gt;UPDATE&lt;/code&gt; 기존의 값과 일치하는 행을 참조하는 테이블의 스캔을 필요로하는 참조 열, 그것은 자주 참조하는 열이 너무 인덱스 좋은 아이디어이다. 이것이 항상 필요한 것은 아니며, 색인화 방법에 대한 많은 선택 사항이 있기 때문에 외래 키 제약 조건의 선언이 참조 열에 색인을 자동으로 작성하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ae80fcdea6bfacfb223ea7833eb93180e9021f3" translate="yes" xml:space="preserve">
          <source>A foreign server typically encapsulates connection information that a foreign-data wrapper uses to access an external data resource. Additional user-specific connection information may be specified by means of user mappings.</source>
          <target state="translated">외부 서버는 일반적으로 외부 데이터 래퍼가 외부 데이터 리소스에 액세스하는 데 사용하는 연결 정보를 캡슐화합니다. 추가 사용자 별 연결 정보는 사용자 매핑을 통해 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a9b5927e002630605d5343a34d0cf4f9f180fe0" translate="yes" xml:space="preserve">
          <source>A foreign server using the &lt;code&gt;postgres_fdw&lt;/code&gt; foreign data wrapper can have the same options that libpq accepts in connection strings, as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;, except that these options are not allowed:</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 외부 데이터 래퍼를 사용하는 외부 서버 는 &lt;a href=&quot;https://www.postgresql.org/docs/12/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;33.1.2 절&lt;/a&gt; 에서 설명한 것처럼 libpq가 연결 문자열에서 허용하는 것과 동일한 옵션을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="badba5a356d62e1cd053d7b73d8fe2b817602f47" translate="yes" xml:space="preserve">
          <source>A foreign server using the &lt;code&gt;postgres_fdw&lt;/code&gt; foreign data wrapper can have the same options that libpq accepts in connection strings, as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;Section 33.1.2&lt;/a&gt;, except that these options are not allowed or have special handling:</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 외부 데이터 래퍼를 사용하는 외부 서버 는 &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-connect.html#LIBPQ-PARAMKEYWORDS&quot;&gt;섹션 33.1.2에&lt;/a&gt; 설명 된대로 libpq가 연결 문자열에서 허용하는 것과 동일한 옵션을 가질 수 있습니다. 단, 이러한 옵션은 허용되지 않거나 특수 처리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1be8aee5fcb016100bb8dc793de4e631744baeb3" translate="yes" xml:space="preserve">
          <source>A foreign table created using this wrapper can have the following options:</source>
          <target state="translated">이 랩퍼를 사용하여 작성된 외부 테이블에는 다음 옵션이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53f8f23c4cbab938356aea7eedc9b0a745c3d640" translate="yes" xml:space="preserve">
          <source>A foreign-data wrapper handler is declared to return &lt;code&gt;fdw_handler&lt;/code&gt;.</source>
          <target state="translated">외부 데이터 랩퍼 핸들러는 &lt;code&gt;fdw_handler&lt;/code&gt; 를 리턴 하도록 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d69f8188280c90b11c42fae9d5a6f62a34fa828" translate="yes" xml:space="preserve">
          <source>A full list of &lt;code&gt;tsvector&lt;/code&gt;-related functions is available in &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-TABLE&quot;&gt;Table 9.42&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 관련 함수 의 전체 목록은 &lt;a href=&quot;functions-textsearch#TEXTSEARCH-FUNCTIONS-TABLE&quot;&gt;표 9.42에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="65e83897f69ea1032a4c6125df7aec06ca7e6f69" translate="yes" xml:space="preserve">
          <source>A full time zone name, for example &lt;code&gt;America/New_York&lt;/code&gt;. The recognized time zone names are listed in the &lt;code&gt;pg_timezone_names&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-names&quot;&gt;Section 51.92&lt;/a&gt;). PostgreSQL uses the widely-used IANA time zone data for this purpose, so the same time zone names are also recognized by other software.</source>
          <target state="translated">예를 들어 전체 시간대 이름, &lt;code&gt;America/New_York&lt;/code&gt; . 인식 된 시간대 이름은 &lt;code&gt;pg_timezone_names&lt;/code&gt; 보기에 나열됩니다 ( &lt;a href=&quot;view-pg-timezone-names&quot;&gt;섹션 51.92&lt;/a&gt; 참조 ). PostgreSQL은 이러한 목적으로 널리 사용되는 IANA 시간대 데이터를 사용하므로 다른 소프트웨어에서도 동일한 시간대 이름을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="ca3257c97b3a14d468e354dcf32c96f8c18bebc4" translate="yes" xml:space="preserve">
          <source>A function call</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="29b8eafb6b7c2b2b298c30410ef6e0e704d3c56b" translate="yes" xml:space="preserve">
          <source>A function can be represented by its &lt;code&gt;proname&lt;/code&gt;, if that is unique among the &lt;code&gt;pg_proc.dat&lt;/code&gt; entries (this works like regproc input). Otherwise, write it as &lt;code&gt;proname(argtypename,argtypename,...)&lt;/code&gt;, like regprocedure. The argument type names must be spelled exactly as they are in the &lt;code&gt;pg_proc.dat&lt;/code&gt; entry's &lt;code&gt;proargtypes&lt;/code&gt; field. Do not insert any spaces.</source>
          <target state="translated">&lt;code&gt;pg_proc.dat&lt;/code&gt; 항목 중에서 고유 한 함수 인 경우 &lt;code&gt;proname&lt;/code&gt; 으로 함수를 표시 할 수 있습니다 (regproc 입력처럼 작동 함). 그렇지 않으면, regprocedure와 같이 &lt;code&gt;proname(argtypename,argtypename,...)&lt;/code&gt; 으로 작성하십시오 . 인수 유형 이름은 &lt;code&gt;pg_proc.dat&lt;/code&gt; 항목의 &lt;code&gt;proargtypes&lt;/code&gt; 필드 에있는 그대로 입력해야 합니다. 공백을 넣지 마십시오.</target>
        </trans-unit>
        <trans-unit id="665c5d40faa1c27c6639ca8ba23f82787f2ca582" translate="yes" xml:space="preserve">
          <source>A function that takes a single argument of composite type can optionally be called using field-selection syntax, and conversely field selection can be written in functional style. That is, the notations &lt;code&gt;col(table)&lt;/code&gt; and &lt;code&gt;table.col&lt;/code&gt; are interchangeable. This behavior is not SQL-standard but is provided in PostgreSQL because it allows use of functions to emulate &amp;ldquo;computed fields&amp;rdquo;. For more information see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;.</source>
          <target state="translated">복합 유형의 단일 인수를 사용하는 함수는 필드 선택 구문을 사용하여 선택적으로 호출 할 수 있으며 반대로 필드 선택은 기능적 스타일로 작성할 수 있습니다. 즉, 표기법 &lt;code&gt;col(table)&lt;/code&gt; 과 &lt;code&gt;table.col&lt;/code&gt; 은 서로 바꿔 사용할 수 있습니다. 이 동작은 SQL 표준은 아니지만 &quot;계산 된 필드&quot;를 에뮬레이트하는 함수를 사용할 수 있으므로 PostgreSQL에서 제공됩니다. 자세한 정보는 &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;8.16.5 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7f8fec4e5b8f079531cd32a009d627206c65e10" translate="yes" xml:space="preserve">
          <source>A generated column cannot be part of a partition key.</source>
          <target state="translated">생성 된 컬럼은 파티션 키의 일부가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e0ac9eba09cfa3c9dbd2d45d33c0ab9b56aec7dc" translate="yes" xml:space="preserve">
          <source>A generated column cannot be written to directly. In &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; commands, a value cannot be specified for a generated column, but the keyword &lt;code&gt;DEFAULT&lt;/code&gt; may be specified.</source>
          <target state="translated">생성 된 열은 직접 쓸 수 없습니다. 에서는 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 명령 값은 생성 된 열을 위해 지정 될 수 있지만, 키워드 &lt;code&gt;DEFAULT&lt;/code&gt; 가 지정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="a974e7fa8fff8257dce1404630bd9e17704afbe0" translate="yes" xml:space="preserve">
          <source>A generated column cannot have a column default or an identity definition.</source>
          <target state="translated">생성 된 열은 열 기본값 또는 아이디 정의를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1dbf7e263f1354b2b93387f1bfe3cc26e77a333d" translate="yes" xml:space="preserve">
          <source>A generated column is a special column that is always computed from other columns. Thus, it is for columns what a view is for tables. There are two kinds of generated columns: stored and virtual. A stored generated column is computed when it is written (inserted or updated) and occupies storage as if it were a normal column. A virtual generated column occupies no storage and is computed when it is read. Thus, a virtual generated column is similar to a view and a stored generated column is similar to a materialized view (except that it is always updated automatically). PostgreSQL currently implements only stored generated columns.</source>
          <target state="translated">생성 된 열은 항상 다른 열에서 계산되는 특수 열입니다. 따라서 테이블에 대한 뷰는 열에 대한 것입니다. 생성 된 열에는 저장 및 가상의 두 가지 종류가 있습니다. 저장된 생성 열은 기록 (삽입 또는 업데이트) 될 때 계산되며 일반 열인 것처럼 스토리지를 차지합니다. 가상 생성 열은 스토리지를 차지하지 않으며 읽을 때 계산됩니다. 따라서 가상 생성 열은 뷰와 유사하고 저장된 생성 열은 구체화 된 뷰와 유사합니다 (항상 자동으로 업데이트되는 것을 제외하고). PostgreSQL은 현재 저장된 생성 열만 구현합니다.</target>
        </trans-unit>
        <trans-unit id="be4467cb35124e2c3c1d0bf937b508ea68a8aa1a" translate="yes" xml:space="preserve">
          <source>A generation expression cannot reference a system column, except &lt;code&gt;tableoid&lt;/code&gt;.</source>
          <target state="translated">생성 표현식은 &lt;code&gt;tableoid&lt;/code&gt; 를 제외하고 시스템 열을 참조 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4e7a5a9dc2e173ff254950537b52dfc433ffc740" translate="yes" xml:space="preserve">
          <source>A generation expression cannot reference another generated column.</source>
          <target state="translated">생성 표현식은 다른 생성 된 열을 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cddf5b488fdbb3769abd336844e34805f857556c" translate="yes" xml:space="preserve">
          <source>A group of backend and auxiliary processes that communicate using a common shared memory area. One &lt;a href=&quot;glossary#GLOSSARY-POSTMASTER&quot;&gt;postmaster process&lt;/a&gt; manages the instance; one instance manages exactly one &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;database cluster&lt;/a&gt; with all its databases. Many instances can run on the same &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;server&lt;/a&gt; as long as their TCP ports do not conflict.</source>
          <target state="translated">공통 공유 메모리 영역을 사용하여 통신하는 백엔드 및 보조 프로세스 그룹입니다. 하나의 &lt;a href=&quot;glossary#GLOSSARY-POSTMASTER&quot;&gt;포스트 마스터 프로세스&lt;/a&gt; 가 인스턴스를 관리합니다. 하나의 인스턴스는 모든 &lt;a href=&quot;glossary#GLOSSARY-DB-CLUSTER&quot;&gt;데이터베이스가있는&lt;/a&gt; 정확히 하나의 데이터베이스 클러스터 를 관리 합니다. TCP 포트가 충돌하지 않는 한 많은 인스턴스가 동일한 &lt;a href=&quot;glossary#GLOSSARY-SERVER&quot;&gt;서버&lt;/a&gt; 에서 실행될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5204280cf84852f809b22497f5b5b7223747d56b" translate="yes" xml:space="preserve">
          <source>A heap page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. For example:</source>
          <target state="translated">&lt;code&gt;get_raw_page&lt;/code&gt; 로 얻은 힙 페이지 이미지 는 인수로 전달되어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="852fc3cf5ee76f5f80b4e90d90cfd5ea3f69f788" translate="yes" xml:space="preserve">
          <source>A helpful trick for testing queries when you are not certain if they might loop is to place a &lt;code&gt;LIMIT&lt;/code&gt; in the parent query. For example, this query would loop forever without the &lt;code&gt;LIMIT&lt;/code&gt;:</source>
          <target state="translated">루프가 확실하지 않은 경우 쿼리를 테스트하는 유용한 방법 은 부모 쿼리에 &lt;code&gt;LIMIT&lt;/code&gt; 를 배치하는 것 입니다. 예를 &lt;code&gt;LIMIT&lt;/code&gt; 쿼리는 LIMIT 없이 영원히 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="83afefe0fbb71aaede7acaeb0c43f98d93c15f12" translate="yes" xml:space="preserve">
          <source>A high schedule lag time is an indication that the system cannot process transactions at the specified rate, with the chosen number of clients and threads. When the average transaction execution time is longer than the scheduled interval between each transaction, each successive transaction will fall further behind, and the schedule lag time will keep increasing the longer the test run is. When that happens, you will have to reduce the specified transaction rate.</source>
          <target state="translated">스케줄 지연 시간이 높다는 것은 선택한 클라이언트 및 스레드 수로 시스템이 지정된 비율로 트랜잭션을 처리 할 수 ​​없음을 나타냅니다. 평균 트랜잭션 실행 시간이 각 트랜잭션 사이의 예약 된 간격보다 길면 각 후속 트랜잭션이 더 뒤쳐지고 스케줄 지연 시간이 테스트 실행 시간이 길어질수록 계속 증가합니다. 이 경우 지정된 트랜잭션 속도를 줄여야합니다.</target>
        </trans-unit>
        <trans-unit id="61cac6a1eeedd7da0737519022c8bf6afc564b8b" translate="yes" xml:space="preserve">
          <source>A histogram of the counts of distinct non-null element values within the values of the column, followed by the average number of distinct non-null elements. (Null for scalar types.)</source>
          <target state="translated">열 값 내의 고유 한 널이 아닌 요소 값의 수에 대한 히스토그램, 그 뒤에는 널이 아닌 고유 한 요소의 평균 수가옵니다. 스칼라 유형의 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="e17cd8aa619245cf1ec3d376e7b36d9afdaa66d4" translate="yes" xml:space="preserve">
          <source>A host name specification that starts with a dot (&lt;code&gt;.&lt;/code&gt;) matches a suffix of the actual host name. So &lt;code&gt;.example.com&lt;/code&gt; would match &lt;code&gt;foo.example.com&lt;/code&gt; (but not just &lt;code&gt;example.com&lt;/code&gt;).</source>
          <target state="translated">점 ( &lt;code&gt;.&lt;/code&gt; )으로 시작하는 호스트 이름 사양 은 실제 호스트 이름의 접미사와 일치합니다. 따라서 &lt;code&gt;.example.com&lt;/code&gt; 은 &lt;code&gt;foo.example.com&lt;/code&gt; 과 일치 하지만 &lt;code&gt;example.com&lt;/code&gt; 과는 일치 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="16a83f51a8f292b8e135eff3bc4b49e6a7b0c8c1" translate="yes" xml:space="preserve">
          <source>A joined table is a table derived from two other (real or derived) tables according to the rules of the particular join type. Inner, outer, and cross-joins are available. The general syntax of a joined table is</source>
          <target state="translated">결합 된 테이블은 특정 결합 유형의 규칙에 따라 두 개의 다른 (실제 또는 파생 된) 테이블에서 파생 된 테이블입니다. 내부, 외부 및 교차 결합을 사용할 수 있습니다. 조인 된 테이블의 일반적인 구문은</target>
        </trans-unit>
        <trans-unit id="c38978f6d39cb114e0bbdd4555f08d4137a6d679" translate="yes" xml:space="preserve">
          <source>A key feature of psql variables is that you can substitute (&amp;ldquo;interpolate&amp;rdquo;) them into regular SQL statements, as well as the arguments of meta-commands. Furthermore, psql provides facilities for ensuring that variable values used as SQL literals and identifiers are properly quoted. The syntax for interpolating a value without any quoting is to prepend the variable name with a colon (&lt;code&gt;:&lt;/code&gt;). For example,</source>
          <target state="translated">psql 변수의 주요 기능은 메타 명령의 인수뿐만 아니라 일반 SQL 문으로 변수를 대체 ( &quot;보간&quot;) 할 수 있다는 것입니다. 또한 psql은 SQL 리터럴 및 식별자로 사용되는 변수 값이 올바르게 인용되도록하는 기능을 제공합니다. 어떠한 인용없이 값을 보간하기위한 구문은 콜론 변수 이름 앞에 추가한다 ( &lt;code&gt;:&lt;/code&gt; ). 예를 들어</target>
        </trans-unit>
        <trans-unit id="82961127c30e9d99b0606fff4408183ed9cb0961" translate="yes" xml:space="preserve">
          <source>A key property of &lt;code&gt;WITH&lt;/code&gt; queries is that they are normally evaluated only once per execution of the primary query, even if the primary query refers to them more than once. In particular, data-modifying statements are guaranteed to be executed once and only once, regardless of whether the primary query reads all or any of their output.</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 쿼리 의 주요 속성은 기본 쿼리가 기본 쿼리를 두 번 이상 참조하더라도 기본 쿼리 실행 당 한 번만 평가된다는 것입니다. 특히, 데이터 수정 명령문은 기본 조회가 모든 출력을 읽든지 출력을 읽든 상관없이 한 번만 실행되도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="61ba864342105e7de2a1c4f77ad3ea649ab3dd8e" translate="yes" xml:space="preserve">
          <source>A larger setting would be appropriate if other programs on the machine also need huge pages. Don't forget to add this setting to &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; so that it will be reapplied after reboots.</source>
          <target state="translated">머신의 다른 프로그램에도 큰 페이지가 필요한 경우 더 큰 설정이 적합합니다. 재부팅 후 다시 적용되도록 이 설정을 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 에 추가하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="740fc98f7710c6fce519cc7ddb08e68b536ff0d4" translate="yes" xml:space="preserve">
          <source>A less-oversimplified example of a &lt;code&gt;subtype_diff&lt;/code&gt; function is:</source>
          <target state="translated">&lt;code&gt;subtype_diff&lt;/code&gt; 함수 의 단순화되지 않은 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15b979d3d44d76b40d5152f1d019597a03929970" translate="yes" xml:space="preserve">
          <source>A limitation of pgbench is that it can itself become the bottleneck when trying to test a large number of client sessions. This can be alleviated by running pgbench on a different machine from the database server, although low network latency will be essential. It might even be useful to run several pgbench instances concurrently, on several client machines, against the same database server.</source>
          <target state="translated">pgbench의 한계는 많은 클라이언트 세션을 테스트하려고 할 때 병목 현상이 발생할 수 있다는 것입니다. 낮은 네트워크 대기 시간이 필요하지만 데이터베이스 서버와 다른 시스템에서 pgbench를 실행하면이를 완화 할 수 있습니다. 동일한 데이터베이스 서버에 대해 여러 클라이언트 시스템에서 여러 pgbench 인스턴스를 동시에 실행하는 것이 유용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab2d89a97d20a5efbc73683817ba2ff464b9a103" translate="yes" xml:space="preserve">
          <source>A limitation of these built-in triggers is that they treat all the input columns alike. To process columns differently &amp;mdash; for example, to weight title differently from body &amp;mdash; it is necessary to write a custom trigger. Here is an example using PL/pgSQL as the trigger language:</source>
          <target state="translated">이러한 내장 트리거의 한계는 모든 입력 열을 동일하게 취급한다는 것입니다. 제목을 본문과 다르게 가중치를 지정하는 등 열을 다르게 처리하려면 사용자 지정 트리거를 작성해야합니다. 다음은 PL / pgSQL을 트리거 언어로 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="f76857de86cd4afe434d4b21d9313477ab29ebe7" translate="yes" xml:space="preserve">
          <source>A limitation of this feature is that an &lt;code&gt;ORDER BY&lt;/code&gt; clause applying to the result of a &lt;code&gt;UNION&lt;/code&gt;, &lt;code&gt;INTERSECT&lt;/code&gt;, or &lt;code&gt;EXCEPT&lt;/code&gt; clause can only specify an output column name or number, not an expression.</source>
          <target state="translated">이 기능의 제한 사항은 &lt;code&gt;UNION&lt;/code&gt; , &lt;code&gt;INTERSECT&lt;/code&gt; 또는 &lt;code&gt;EXCEPT&lt;/code&gt; 절의 결과에 적용 되는 &lt;code&gt;ORDER BY&lt;/code&gt; 절 은 표현식이 아니라 출력 열 이름 또는 숫자 만 지정할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e332e0f99b25d5ac06d1f211aa0eb2e56e7af5e" translate="yes" xml:space="preserve">
          <source>A list of NULL flags for the most common combinations of values. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">가장 일반적인 값 조합에 대한 NULL 플래그 목록입니다. &lt;code&gt;most_common_vals&lt;/code&gt; 가 null이면 null 입니다.</target>
        </trans-unit>
        <trans-unit id="faedcc532ba9e80276afc21b0d135826be8f1422" translate="yes" xml:space="preserve">
          <source>A list of non-null element values most often appearing within values of the column. (Null for scalar types.)</source>
          <target state="translated">널이 아닌 요소 값의 목록은 열의 값 내에 가장 자주 나타납니다. 스칼라 유형의 경우 널입니다.</target>
        </trans-unit>
        <trans-unit id="9222c144bac210ee75eb7f8e023e5b70c063c9b1" translate="yes" xml:space="preserve">
          <source>A list of table expressions, allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition and the update expressions. This is similar to the list of tables that can be specified in the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; of a &lt;code&gt;SELECT&lt;/code&gt; statement. Note that the target table must not appear in the &lt;code&gt;from_list&lt;/code&gt;, unless you intend a self-join (in which case it must appear with an alias in the &lt;code&gt;from_list&lt;/code&gt;).</source>
          <target state="translated">다른 테이블의 열이 &lt;code&gt;WHERE&lt;/code&gt; 조건 및 업데이트 식 에 나타날 수있는 테이블 식 목록입니다 . 이것은 &lt;code&gt;SELECT&lt;/code&gt; 문의 &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 절&lt;/a&gt; 에 지정할 수있는 테이블 목록과 유사 합니다. 자체 조인을 의도하지 않는 한 대상 테이블은 &lt;code&gt;from_list&lt;/code&gt; 에 나타나지 않아야합니다 (이 경우 &lt;code&gt;from_list&lt;/code&gt; 에 별명으로 표시되어야 함 ).</target>
        </trans-unit>
        <trans-unit id="a5ec616bf7215f2b568c6fa91ae40cb63c46d2ff" translate="yes" xml:space="preserve">
          <source>A list of table expressions, allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition. This is similar to the list of tables that can be specified in the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table in the &lt;code&gt;using_list&lt;/code&gt;, unless you wish to set up a self-join.</source>
          <target state="translated">다른 테이블의 열이 &lt;code&gt;WHERE&lt;/code&gt; 조건 에 나타날 수있는 테이블 표현식 목록 . 이것은 지정할 수 있습니다 테이블 목록과 유사 &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 절&lt;/a&gt; (A)의 &lt;code&gt;SELECT&lt;/code&gt; 문; 예를 들어, 테이블 이름의 별명을 지정할 수 있습니다. 자체 조인을 설정하지 않으려면 &lt;code&gt;using_list&lt;/code&gt; 에서 대상 테이블을 반복하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="4a9f5b6a7fa98f13d9b0649d9b104ce5e824c915" translate="yes" xml:space="preserve">
          <source>A list of the base frequencies of the most common combinations, i.e., product of per-value frequencies. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">가장 일반적인 조합의 기본 주파수 목록, 즉 값당 주파수의 곱. &lt;code&gt;most_common_vals&lt;/code&gt; 가 null이면 null 입니다.</target>
        </trans-unit>
        <trans-unit id="c0a9903e8f4ef251af0eff5fa2455e175a7548a4" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common combinations, i.e., number of occurrences of each divided by total number of rows. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">가장 일반적인 조합의 빈도 목록, 즉 각 발생 횟수를 총 행 수로 나눈 값입니다. &lt;code&gt;most_common_vals&lt;/code&gt; 가 null이면 null 입니다.</target>
        </trans-unit>
        <trans-unit id="527238c1ce219277abbb45386e199364181b4e39" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common element values, i.e., the fraction of rows containing at least one instance of the given value. Two or three additional values follow the per-element frequencies; these are the minimum and maximum of the preceding per-element frequencies, and optionally the frequency of null elements. (Null when &lt;code&gt;most_common_elems&lt;/code&gt; is.)</source>
          <target state="translated">가장 일반적인 요소 값의 빈도 목록, 즉 주어진 값의 하나 이상의 인스턴스를 포함하는 행의 비율. 요소 당 주파수는 2 개 또는 3 개의 추가 값입니다. 이들은 요소 별 주파수의 최소값과 최대 값이며 선택적으로 null 요소의 주파수입니다. &lt;code&gt;most_common_elems&lt;/code&gt; 가 null 인 경우 null 입니다.</target>
        </trans-unit>
        <trans-unit id="6973fe18397e6786beffdd562ca0c447ef38be82" translate="yes" xml:space="preserve">
          <source>A list of the frequencies of the most common values, i.e., number of occurrences of each divided by total number of rows. (Null when &lt;code&gt;most_common_vals&lt;/code&gt; is.)</source>
          <target state="translated">가장 일반적인 값의 빈도 목록, 즉 각 발생 횟수를 총 행 수로 나눈 값입니다. &lt;code&gt;most_common_vals&lt;/code&gt; 가 null이면 null 입니다.</target>
        </trans-unit>
        <trans-unit id="f63bcd58b43a4c5b783b6642ba5709e3ccbcb180" translate="yes" xml:space="preserve">
          <source>A list of the most common combinations of values in the columns. (Null if no combinations seem to be more common than any others.)</source>
          <target state="translated">열에서 가장 일반적인 값 조합 목록입니다. (다른 조합보다 일반적인 조합이없는 경우 널입니다.)</target>
        </trans-unit>
        <trans-unit id="7e7a21f80a86cbb3d663d9a6c19c5698cb32c935" translate="yes" xml:space="preserve">
          <source>A list of the most common values in the column. (Null if no values seem to be more common than any others.)</source>
          <target state="translated">열에서 가장 일반적인 값의 목록입니다. (다른 값보다 일반적인 값이없는 경우 널입니다.)</target>
        </trans-unit>
        <trans-unit id="f5ec309be4a2c82919d5db6bbf83466f9afb0124" translate="yes" xml:space="preserve">
          <source>A list of values for the associated &lt;code&gt;filter_variable&lt;/code&gt; for which the trigger should fire. For &lt;code&gt;TAG&lt;/code&gt;, this means a list of command tags (e.g. &lt;code&gt;'DROP FUNCTION'&lt;/code&gt;).</source>
          <target state="translated">트리거가 발생해야하는 연관된 &lt;code&gt;filter_variable&lt;/code&gt; 의 값 목록입니다 . 들어 &lt;code&gt;TAG&lt;/code&gt; ,이 명령 태그 목록 (예를 들면 의미 &lt;code&gt;'DROP FUNCTION'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ff968df28749e5bcff327cac21b38ab15e60f682" translate="yes" xml:space="preserve">
          <source>A list of values for the associated &lt;code&gt;filter_variable&lt;/code&gt; for which the trigger should fire. For &lt;code&gt;TAG&lt;/code&gt;, this means a list of command tags (e.g., &lt;code&gt;'DROP FUNCTION'&lt;/code&gt;).</source>
          <target state="translated">트리거가 실행되어야 하는 관련 &lt;code&gt;filter_variable&lt;/code&gt; 의 값 목록입니다 . 들어 &lt;code&gt;TAG&lt;/code&gt; ,이 명령 태그 목록 (예를 들어, 의미 &lt;code&gt;'DROP FUNCTION'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6e4fe90764276ed140f41c638b69ba17b32d691f" translate="yes" xml:space="preserve">
          <source>A list of values that divide the column's values into groups of approximately equal population. The values in &lt;code&gt;most_common_vals&lt;/code&gt;, if present, are omitted from this histogram calculation. (This column is null if the column data type does not have a &lt;code&gt;&amp;lt;&lt;/code&gt; operator or if the &lt;code&gt;most_common_vals&lt;/code&gt; list accounts for the entire population.)</source>
          <target state="translated">열 값을 대략 동일한 모집단 그룹으로 나누는 값 목록입니다. &lt;code&gt;most_common_vals&lt;/code&gt; 의 값이 있으면이 히스토그램 계산에서 생략됩니다. (열 데이터 유형에 &lt;code&gt;&amp;lt;&lt;/code&gt; 연산자가 없거나 &lt;code&gt;most_common_vals&lt;/code&gt; 목록이 전체 모집단을 설명하는 경우이 열은 널 입니다.)</target>
        </trans-unit>
        <trans-unit id="ed9c3dd9d41fb7cb75cda90adbcd956a0d568298" translate="yes" xml:space="preserve">
          <source>A lock file recording the current postmaster process ID (PID), cluster data directory path, postmaster start timestamp, port number, Unix-domain socket directory path (could be empty), first valid listen_address (IP address or &lt;code&gt;*&lt;/code&gt;, or empty if not listening on TCP), and shared memory segment ID (this file is not present after server shutdown)</source>
          <target state="translated">현재 포스트 마스터 프로세스 ID (PID), 클러스터 데이터 디렉토리 경로, 포스트 마스터 시작 타임 스탬프, 포트 번호, Unix 도메인 소켓 디렉토리 경로 (비어있을 수 있음), 첫 번째 유효한 listen_address (IP 주소 또는 &lt;code&gt;*&lt;/code&gt; 또는 그렇지 않은 경우 비어 있음)를 기록하는 잠금 파일 TCP에서 수신) 및 공유 메모리 세그먼트 ID (이 파일은 서버 종료 후에 존재하지 않음)</target>
        </trans-unit>
        <trans-unit id="a40d49086dbccf43760fcf28e8592fb7682d6120" translate="yes" xml:space="preserve">
          <source>A lock file recording the current postmaster process ID (PID), cluster data directory path, postmaster start timestamp, port number, Unix-domain socket directory path (empty on Windows), first valid listen_address (IP address or &lt;code&gt;*&lt;/code&gt;, or empty if not listening on TCP), and shared memory segment ID (this file is not present after server shutdown)</source>
          <target state="translated">현재 전자 메일 관리자 프로세스 ID (PID), 클러스터 데이터 디렉토리 경로, 전자 메일 관리자 시작 타임 스탬프, 포트 번호, 유닉스 도메인 소켓의 디렉토리 경로 (Windows에서 비어 있음), 첫 번째 유효한 listen_address (IP 주소 또는 기록 잠금 파일 &lt;code&gt;*&lt;/code&gt; , 또는 그렇지 않으면 비워을 TCP에서 수신 대기) 및 공유 메모리 세그먼트 ID (이 파일은 서버 종료 후 존재하지 않습니다)</target>
        </trans-unit>
        <trans-unit id="66a4816dba1f7f218c3433fca4faabe3c13b10b2" translate="yes" xml:space="preserve">
          <source>A logical replication subscription can be a standby for synchronous replication (see &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;Section 26.2.8&lt;/a&gt;). The standby name is by default the subscription name. An alternative name can be specified as &lt;code&gt;application_name&lt;/code&gt; in the connection information of the subscription.</source>
          <target state="translated">논리적 복제 가입은 동기 복제를위한 대기가 될 수 있습니다 ( &lt;a href=&quot;warm-standby#SYNCHRONOUS-REPLICATION&quot;&gt;26.2.8 절&lt;/a&gt; 참조 ). 대기 이름은 기본적으로 구독 이름입니다. 구독의 연결 정보에서 대체 이름을 &lt;code&gt;application_name&lt;/code&gt; 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fcc633543c398580321199fbfe8326677176cedc" translate="yes" xml:space="preserve">
          <source>A logical replication worker will be started to replicate data for the new subscription at the commit of the transaction where this command is run.</source>
          <target state="translated">이 명령이 실행되는 트랜잭션이 커밋 될 때 새 구독에 대한 데이터를 복제하기 위해 논리적 복제 작업자가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="0ff838ef761258a1112513121456f0155f8255d4" translate="yes" xml:space="preserve">
          <source>A low-level description of an individual data change. It contains sufficient information for the data change to be re-executed (&lt;em&gt;replayed&lt;/em&gt;) in case a system failure causes the change to be lost. WAL records use a non-printable binary format.</source>
          <target state="translated">개별 데이터 변경에 대한 낮은 수준의 설명입니다. 시스템 장애로 인해 변경 사항이 손실되는 경우 데이터 변경을 다시 실행 ( &lt;em&gt;재생&lt;/em&gt; ) 할 수있는 충분한 정보가 포함되어 있습니다. WAL 레코드는 인쇄 할 수없는 바이너리 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="60aa88a1c8ef8747220ad187c41c4e1174fc8b76" translate="yes" xml:space="preserve">
          <source>A master-standby replication setup sends all data modification queries to the master server. The master server asynchronously sends data changes to the standby server. The standby can answer read-only queries while the master server is running. The standby server is ideal for data warehouse queries.</source>
          <target state="translated">마스터 대기 복제 설정은 모든 데이터 수정 쿼리를 마스터 서버로 보냅니다. 마스터 서버는 비동기 적으로 데이터 변경 사항을 대기 서버로 보냅니다. 마스터 서버가 실행중인 동안 대기는 읽기 전용 조회에 응답 할 수 있습니다. 대기 서버는 데이터웨어 하우스 쿼리에 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="bb03b0cc86a8c8af01abf7c3fc42f075822f31ef" translate="yes" xml:space="preserve">
          <source>A means of identifying a &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;row&lt;/a&gt; within a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; by values contained within one or more &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; in that relation.</source>
          <target state="translated">해당 관계의 하나 이상의 &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;속성&lt;/a&gt; 에 포함 된 값 으로 &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 또는 기타 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; 내의 &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;행&lt;/a&gt; 을 식별하는 수단입니다 .</target>
        </trans-unit>
        <trans-unit id="030845a8e99966136eb3e489c254a79843ff0977" translate="yes" xml:space="preserve">
          <source>A means of representing data that is not contained in the local &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; so that it appears as if were in local &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table(s)&lt;/a&gt;. With a foreign data wrapper it is possible to define a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-SERVER&quot;&gt;foreign server&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt;.</source>
          <target state="translated">로컬 &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 에있는 것처럼 보이도록 로컬 &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;데이터베이스에&lt;/a&gt; 포함되지 않은 데이터를 나타내는 수단입니다 . 외부 데이터 래퍼를 사용하면 &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-SERVER&quot;&gt;외부 서버&lt;/a&gt; 와 &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;외부 테이블&lt;/a&gt; 을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5439dc35c023b011f3a3c74704c816d5906e3290" translate="yes" xml:space="preserve">
          <source>A means of restricting data in one &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; by a &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-KEY&quot;&gt;foreign key&lt;/a&gt; so that it must have matching data in another &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;.</source>
          <target state="translated">하나 개의 데이터를 제한하는 수단 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; 바이 &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-KEY&quot;&gt;외부 키&lt;/a&gt; 는 다른 데이터와 일치되도록 있어야 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90a6939174ae7d3834abe5ab38f570dcd2acae81" translate="yes" xml:space="preserve">
          <source>A mechanism by which large attributes of table rows are split and stored in a secondary table, called the &lt;em&gt;TOAST table&lt;/em&gt;. Each relation with large attributes has its own TOAST table.</source>
          <target state="translated">테이블 행의 큰 속성을 분할하여 &lt;em&gt;TOAST 테이블&lt;/em&gt; 이라고하는 보조 테이블에 저장하는 메커니즘 입니다. 큰 속성을 가진 각 관계에는 자체 TOAST 테이블이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0378f878c1722be034fadd027bbbb3d7983fc4d" translate="yes" xml:space="preserve">
          <source>A mechanism designed to allow several &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transactions&lt;/a&gt; to be reading and writing the same rows without one process causing other processes to stall. In PostgreSQL, MVCC is implemented by creating copies (&lt;em&gt;versions&lt;/em&gt;) of &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;tuples&lt;/a&gt; as they are modified; after transactions that can see the old versions terminate, those old versions need to be removed.</source>
          <target state="translated">한 프로세스가 다른 프로세스를 중단시키지 않고 여러 &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;트랜잭션&lt;/a&gt; 이 동일한 행을 읽고 쓸 수 있도록 설계된 메커니즘입니다 . PostgreSQL에서 MVCC는 수정 된 &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;튜플의&lt;/a&gt; 복사본 ( &lt;em&gt;버전&lt;/em&gt; )을 생성하여 구현됩니다 . 이전 버전을 볼 수있는 트랜잭션이 종료되면 해당 이전 버전을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="19c544cc7b4fa2f30c5d33aa71e0de0990d629df" translate="yes" xml:space="preserve">
          <source>A mechanism that allows a process to limit or prevent simultaneous access to a resource.</source>
          <target state="translated">프로세스가 리소스에 대한 동시 액세스를 제한하거나 방지 할 수있는 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="df6419859ed47f78b720bf1d7b110d267f1953f4" translate="yes" xml:space="preserve">
          <source>A message like:</source>
          <target state="translated">다음과 같은 메시지 :</target>
        </trans-unit>
        <trans-unit id="917ffeb96cdfecb3f8736cd3bea86dd56c48ad27" translate="yes" xml:space="preserve">
          <source>A minimal sequence for creating a new procedural language is:</source>
          <target state="translated">새 절차 언어를 만드는 최소 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0390b8c07f298b04ffb62c09de627ab67ceed13" translate="yes" xml:space="preserve">
          <source>A modified version of shared hardware functionality is file system replication, where all changes to a file system are mirrored to a file system residing on another computer. The only restriction is that the mirroring must be done in a way that ensures the standby server has a consistent copy of the file system &amp;mdash; specifically, writes to the standby must be done in the same order as those on the master. DRBD is a popular file system replication solution for Linux.</source>
          <target state="translated">공유 하드웨어 기능의 수정 된 버전은 파일 시스템 복제이며, 파일 시스템의 모든 변경 사항은 다른 컴퓨터에있는 파일 시스템에 미러링됩니다. 유일한 제한은 대기 서버가 파일 시스템의 일관된 사본을 갖도록하는 방식으로 미러링을 수행해야한다는 것입니다. 특히 대기에 대한 쓰기는 마스터와 동일한 순서로 수행되어야합니다. DRBD는 널리 사용되는 Linux 용 파일 시스템 복제 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="eaf74e8b7bd2011db8b23c31e08c4d8c5dc7b496" translate="yes" xml:space="preserve">
          <source>A more complete example, which is directly useful for most European languages, can be found in &lt;code&gt;unaccent.rules&lt;/code&gt;, which is installed in &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; when the &lt;code&gt;unaccent&lt;/code&gt; module is installed. This rules file translates characters with accents to the same characters without accents, and it also expands ligatures into the equivalent series of simple characters (for example, &amp;AElig; to AE).</source>
          <target state="translated">대부분의 유럽 언어에 대한 직접 유용 더 완벽한 예는,에서 찾을 수 있습니다 &lt;code&gt;unaccent.rules&lt;/code&gt; 에 설치되어, &lt;code&gt;$SHAREDIR/tsearch_data/&lt;/code&gt; 때 &lt;code&gt;unaccent&lt;/code&gt; 모듈이 설치됩니다. 이 규칙 파일은 악센트가있는 문자를 악센트가없는 동일한 문자로 변환하고 합자를 일련의 간단한 문자 (예 : &amp;AElig;에서 AE로)로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="e62513d51117a7629a102ebbc4e62bd57c604e14" translate="yes" xml:space="preserve">
          <source>A more complex example is to select the ten most recent documents that contain &lt;code&gt;create&lt;/code&gt; and &lt;code&gt;table&lt;/code&gt; in the &lt;code&gt;title&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt;:</source>
          <target state="translated">보다 복잡한 예는 &lt;code&gt;title&lt;/code&gt; 또는 &lt;code&gt;body&lt;/code&gt; 에 &lt;code&gt;create&lt;/code&gt; 및 &lt;code&gt;table&lt;/code&gt; 이 포함 된 가장 최근 10 개의 문서를 선택하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a65faa0d2e1360aa9fc34743f49ee685ce803abe" translate="yes" xml:space="preserve">
          <source>A more complex view that does not satisfy all these conditions is read-only by default: the system will not allow an insert, update, or delete on the view. You can get the effect of an updatable view by creating &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers on the view, which must convert attempted inserts, etc. on the view into appropriate actions on other tables. For more information see &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;. Another possibility is to create rules (see &lt;a href=&quot;sql-createrule&quot;&gt;CREATE RULE&lt;/a&gt;), but in practice triggers are easier to understand and use correctly.</source>
          <target state="translated">이러한 모든 조건을 만족하지 않는보다 복잡한보기는 기본적으로 읽기 전용입니다. 시스템은보기에서 삽입, 업데이트 또는 삭제를 허용하지 않습니다. 뷰에서 &lt;code&gt;INSTEAD OF&lt;/code&gt; 트리거를 작성 하여 뷰에서 시도 된 삽입 등을 다른 테이블의 적절한 조치로 변환해야 업데이트 가능한 뷰의 효과를 얻을 수 있습니다 . 자세한 정보는 &lt;a href=&quot;sql-createtrigger&quot;&gt;CREATE TRIGGER를&lt;/a&gt; 참조하십시오 . 다른 가능성은 규칙을 작성하는 것 ( &lt;a href=&quot;sql-createrule&quot;&gt;CREATE RULE&lt;/a&gt; 참조 )이지만 실제로 트리거를 이해하고 올바르게 사용하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="21c69ec8617bd0a23e27b4a22f876578e2ac2724" translate="yes" xml:space="preserve">
          <source>A multicharacter operator name cannot end in &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, unless the name also contains at least one of these characters:</source>
          <target state="translated">이름 에 다음 문자 중 하나 이상이 포함되어 있지 않으면 다중 문자 연산자 이름은 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 로 끝날 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="763ddc64feb8cdfed8680a02b945f082cacaa6b2" translate="yes" xml:space="preserve">
          <source>A multicolumn B-tree index can be used with query conditions that involve any subset of the index's columns, but the index is most efficient when there are constraints on the leading (leftmost) columns. The exact rule is that equality constraints on leading columns, plus any inequality constraints on the first column that does not have an equality constraint, will be used to limit the portion of the index that is scanned. Constraints on columns to the right of these columns are checked in the index, so they save visits to the table proper, but they do not reduce the portion of the index that has to be scanned. For example, given an index on &lt;code&gt;(a, b, c)&lt;/code&gt; and a query condition &lt;code&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/code&gt;, the index would have to be scanned from the first entry with &lt;code&gt;a&lt;/code&gt; = 5 and &lt;code&gt;b&lt;/code&gt; = 42 up through the last entry with &lt;code&gt;a&lt;/code&gt; = 5. Index entries with &lt;code&gt;c&lt;/code&gt; &amp;gt;= 77 would be skipped, but they'd still have to be scanned through. This index could in principle be used for queries that have constraints on &lt;code&gt;b&lt;/code&gt; and/or &lt;code&gt;c&lt;/code&gt; with no constraint on &lt;code&gt;a&lt;/code&gt; &amp;mdash; but the entire index would have to be scanned, so in most cases the planner would prefer a sequential table scan over using the index.</source>
          <target state="translated">다중 열 B- 트리 인덱스는 인덱스 열의 하위 집합을 포함하는 쿼리 조건과 함께 사용할 수 있지만 선행 (가장 왼쪽) 열에 제약 조건이있는 경우 인덱스가 가장 효율적입니다. 정확한 규칙은 선행 열에 대한 동등 제한 조건과 동등 제한 조건이없는 첫 번째 열에 대한 부등식 제한 조건이 스캔되는 인덱스의 일부를 제한하는 데 사용된다는 것입니다. 이 열의 오른쪽에있는 열에 대한 제약 조건이 인덱스에서 확인되므로 테이블 방문을 적절하게 저장하지만 스캔해야하는 인덱스 부분을 줄이지 않습니다. 예를 들어, 인덱스에 &lt;code&gt;(a, b, c)&lt;/code&gt; 및 쿼리 조건 &lt;code&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/code&gt; 을 지정하면 첫 번째 항목에서 &lt;code&gt;a&lt;/code&gt; 를 사용 하여 인덱스를 스캔해야합니다 .= 5와 &lt;code&gt;b&lt;/code&gt; 와 마지막 항목을 통해 = 42 최대 와 = 5. 인덱스 항목 &lt;code&gt;c&lt;/code&gt; &amp;gt; = 77 생략 될 수 있지만,이 여전히 통해 스캔해야 할 것이다. 이 인덱스는 원칙에 제약이 쿼리에 사용될 수 &lt;code&gt;b&lt;/code&gt; 및 / 또는 &lt;code&gt;c&lt;/code&gt; 에 아무런 제약 조건 그래서 대부분의 경우 플래너는 인덱스를 사용을 통해 순차적 테이블 스캔을 선호하지만, 전체 인덱스 스캔되어야 할 것이다 - . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5fc5434281e629991ee555ca6201f316515a8d25" translate="yes" xml:space="preserve">
          <source>A multicolumn BRIN index can be used with query conditions that involve any subset of the index's columns. Like GIN and unlike B-tree or GiST, index search effectiveness is the same regardless of which index column(s) the query conditions use. The only reason to have multiple BRIN indexes instead of one multicolumn BRIN index on a single table is to have a different &lt;code&gt;pages_per_range&lt;/code&gt; storage parameter.</source>
          <target state="translated">다중 컬럼 BRIN 인덱스는 인덱스 열의 서브 세트를 포함하는 쿼리 조건과 함께 사용할 수 있습니다. GIN과 마찬가지로 B-tree 또는 GiST와 달리 인덱스 검색 효과는 쿼리 조건이 사용하는 인덱스 열에 관계없이 동일합니다. 단일 테이블에 하나의 다중 &lt;code&gt;pages_per_range&lt;/code&gt; 인덱스 대신 여러 BRIN 인덱스가있는 유일한 이유는 다른 pages_per_range 스토리지 매개 변수를 갖기 위해서 입니다.</target>
        </trans-unit>
        <trans-unit id="04d3a962116670f39174cfb6d475fa11fdc7b880" translate="yes" xml:space="preserve">
          <source>A multicolumn GIN index can be used with query conditions that involve any subset of the index's columns. Unlike B-tree or GiST, index search effectiveness is the same regardless of which index column(s) the query conditions use.</source>
          <target state="translated">다중 열 GIN 인덱스는 인덱스 열의 하위 집합을 포함하는 쿼리 조건과 함께 사용할 수 있습니다. B- 트리 또는 GiST와 달리, 인덱스 검색 효과는 쿼리 조건이 사용하는 인덱스 열에 관계없이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a40f443a6350a7a3a7b742a42955a0061cf6840b" translate="yes" xml:space="preserve">
          <source>A multicolumn GiST index can be used with query conditions that involve any subset of the index's columns. Conditions on additional columns restrict the entries returned by the index, but the condition on the first column is the most important one for determining how much of the index needs to be scanned. A GiST index will be relatively ineffective if its first column has only a few distinct values, even if there are many distinct values in additional columns.</source>
          <target state="translated">다중 열 GiST 인덱스는 인덱스 열의 하위 집합을 포함하는 쿼리 조건과 함께 사용할 수 있습니다. 추가 열의 조건은 인덱스에서 반환되는 항목을 제한하지만 첫 번째 열의 조건은 인덱스를 얼마나 많이 스캔해야하는지 결정하는 데 가장 중요합니다. 추가 열에 많은 고유 값이 있어도 첫 번째 열에 몇 개의 고유 값만있는 경우 GiST 인덱스는 상대적으로 효과적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61e3a968ac084ffcdbf2ee57ee023225a4c61ed4" translate="yes" xml:space="preserve">
          <source>A multiple-character operator name cannot end in &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, unless the name also contains at least one of these characters:</source>
          <target state="translated">이름 에 다음 문자 중 하나 이상이 포함되어 있지 않으면 여러 문자 연산자 이름은 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 로 끝날 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c34267e8f8081ad131049e90185ef07a4a593a2c" translate="yes" xml:space="preserve">
          <source>A name (without schema qualification) must be specified for each &lt;code&gt;WITH&lt;/code&gt; query. Optionally, a list of column names can be specified; if this is omitted, the column names are inferred from the subquery.</source>
          <target state="translated">각 &lt;code&gt;WITH&lt;/code&gt; 조회 마다 이름 (스키마 규정이없는)을 지정해야합니다 . 선택적으로 열 이름 목록을 지정할 수 있습니다. 이것이 생략되면, 열 이름은 부속 조회에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf463ff31beb31d0372f0b1e73503dfa89eeca4" translate="yes" xml:space="preserve">
          <source>A name to use for a returned column.</source>
          <target state="translated">반환 된 열에 사용할 이름입니다.</target>
        </trans-unit>
        <trans-unit id="272bf486701f1c7737a7b79a5df1a6cc7e2d076e" translate="yes" xml:space="preserve">
          <source>A named collection of &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;foreign tables&lt;/a&gt; which all use the same &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;foreign data wrapper&lt;/a&gt; and have other configuration values in common.</source>
          <target state="translated">모두 동일한 &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-DATA-WRAPPER&quot;&gt;외부 데이터 래퍼를 사용&lt;/a&gt; 하고 다른 구성 값을 공통으로 갖는 명명 된 &lt;a href=&quot;glossary#GLOSSARY-FOREIGN-TABLE&quot;&gt;외부 테이블&lt;/a&gt; 모음입니다 .</target>
        </trans-unit>
        <trans-unit id="39c6fcfc35cb51a17f46343c3f38d154442e2627" translate="yes" xml:space="preserve">
          <source>A named collection of &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;local SQL objects&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;로컬 SQL 개체&lt;/a&gt; 의 명명 된 모음입니다 .</target>
        </trans-unit>
        <trans-unit id="14bebfb5283ed66820e63249347863d7698ec1a3" translate="yes" xml:space="preserve">
          <source>A named location on the server file system. All &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt; which require storage beyond their definition in the &lt;a href=&quot;glossary#GLOSSARY-SYSTEM-CATALOG&quot;&gt;system catalog&lt;/a&gt; must belong to a single tablespace. Initially, a database cluster contains a single usable tablespace which is used as the default for all SQL objects, called &lt;code&gt;pg_default&lt;/code&gt;.</source>
          <target state="translated">서버 파일 시스템의 명명 된 위치입니다. &lt;a href=&quot;glossary#GLOSSARY-SYSTEM-CATALOG&quot;&gt;시스템 카탈로그&lt;/a&gt; 의 정의를 넘어서는 스토리지가 필요한 모든 &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL 객체&lt;/a&gt; 는 단일 테이블 스페이스에 속해야합니다. 처음에 데이터베이스 클러스터에는 &lt;code&gt;pg_default&lt;/code&gt; 라는 모든 SQL 객체의 기본값으로 사용되는 사용 가능한 단일 테이블 스페이스가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="c05611b43715c57dcc82e9a73dc2d7f3d8e3a806" translate="yes" xml:space="preserve">
          <source>A named variable. Its value can be set by the parameter &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; of several JSON processing functions. See &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;Table 9.47&lt;/a&gt; and its notes for details.</source>
          <target state="translated">명명 된 변수. 여러 JSON 처리 함수 의 매개 &lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt; 로 값을 설정할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;표 9.47&lt;/a&gt; 및 해당 노트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="74fdd4598f86747d21b59f0ff46b91f71c06f897" translate="yes" xml:space="preserve">
          <source>A named variable. Its value can be set by the parameter &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; of several JSON processing functions; see &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;Table 9.47&lt;/a&gt; for details.</source>
          <target state="translated">명명 된 변수. 그 값 은 여러 JSON 처리 함수 의 매개 &lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt; 로 설정할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;functions-json#FUNCTIONS-JSON-PROCESSING-TABLE&quot;&gt;표 9.47&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a91a5ad7df4feb45e2e64cef1252fbd5ff25b557" translate="yes" xml:space="preserve">
          <source>A new database object basically inherits the security label of the parent object, except when the security policy has special rules known as type-transition rules, in which case a different label may be applied. For schemas, the parent object is the current database; for tables, sequences, views, and functions, it is the containing schema; for columns, it is the containing table.</source>
          <target state="translated">보안 정책에 유형 전환 규칙이라는 특수 규칙이있는 경우를 제외하고 새 데이터베이스 객체는 기본적으로 상위 객체의 보안 레이블을 상속합니다.이 경우 다른 레이블이 적용될 수 있습니다. 스키마의 경우 상위 개체는 현재 데이터베이스입니다. 테이블, 시퀀스, 뷰 및 함수의 경우 포함 스키마입니다. 열의 경우 포함 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="a69d7af9d66bab695fb9262e5704599a7bd6821d" translate="yes" xml:space="preserve">
          <source>A new heap entry is made before making its index entries. (Therefore a concurrent index scan is likely to fail to see the heap entry. This is okay because the index reader would be uninterested in an uncommitted row anyway. But see &lt;a href=&quot;index-unique-checks&quot;&gt;Section 61.5&lt;/a&gt;.)</source>
          <target state="translated">색인 항목을 작성하기 전에 새 힙 항목이 작성됩니다. (따라서 동시 인덱스 스캔은 힙 항목을 보지 못할 수 있습니다. 어쨌든 인덱스 리더가 커밋되지 않은 행에 관심이 없기 때문에 괜찮습니다. 그러나 &lt;a href=&quot;index-unique-checks&quot;&gt;섹션 61.5를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="e9bfb94dcc9a12b2e365d8f54e18e6c8a60beb96" translate="yes" xml:space="preserve">
          <source>A new random session key is generated.</source>
          <target state="translated">새로운 임의 세션 키가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="cd5509bd2e57840414a4b31d4dcfe1a53cd60297" translate="yes" xml:space="preserve">
          <source>A new temporary index definition is added to the catalog &lt;code&gt;pg_index&lt;/code&gt;. This definition will be used to replace the old index. A &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock at session level is taken on the indexes being reindexed as well as their associated tables to prevent any schema modification while processing.</source>
          <target state="translated">새로운 임시 색인 정의가 &lt;code&gt;pg_index&lt;/code&gt; 카탈로그에 추가됩니다 . 이 정의는 이전 색인을 대체하는 데 사용됩니다. 세션 레벨 의 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금은 처리 중에 스키마 수정을 방지하기 위해 다시 색인화되는 색인 및 연관된 테이블에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e67b7984583e1c4ea079d2de00a7015a2704c63b" translate="yes" xml:space="preserve">
          <source>A new transient index definition is added to the catalog &lt;code&gt;pg_index&lt;/code&gt;. This definition will be used to replace the old index. A &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock at session level is taken on the indexes being reindexed as well as their associated tables to prevent any schema modification while processing.</source>
          <target state="translated">새로운 임시 인덱스 정의가 &lt;code&gt;pg_index&lt;/code&gt; 카탈로그에 추가됩니다 . 이 정의는 이전 색인을 대체하는 데 사용됩니다. &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 의 세션 수준에서 잠금 처리하는 동안 스키마 변경을 방지하기 위해 인덱스 색인이뿐만 아니라 관련 테이블되고 촬영됩니다.</target>
        </trans-unit>
        <trans-unit id="10ddb11c7f41b9fc173a0daee9b22a0046a88a72" translate="yes" xml:space="preserve">
          <source>A non-XML result assigned to an &lt;code&gt;xml&lt;/code&gt; output column produces content, a single text node with the string value of the result. An XML result assigned to a column of any other type may not have more than one node, or an error is raised. If there is exactly one node, the column will be set as if by assigning the node's string value (as defined for the XPath 1.0 &lt;code&gt;string&lt;/code&gt; function) to the PostgreSQL type.</source>
          <target state="translated">&lt;code&gt;xml&lt;/code&gt; 출력 열에 지정된 비 XML 결과 는 결과의 문자열 값이있는 단일 텍스트 노드 인 컨텐츠를 생성합니다. 다른 유형의 열에 지정된 XML 결과에는 둘 이상의 노드가 없거나 오류가 발생합니다. 정확히 하나의 노드가있는 경우 XPath 1.0 &lt;code&gt;string&lt;/code&gt; 함수에 정의 된대로 노드의 문자열 값 을 PostgreSQL 유형 에 할당하여 열이 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="473219c281a2d874786237c92b0fcf8169682ead" translate="yes" xml:space="preserve">
          <source>A non-exclusive low level backup is one that allows other concurrent backups to be running (both those started using the same backup API and those started using &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup&lt;/a&gt;).</source>
          <target state="translated">비 독점 하위 수준 백업은 다른 동시 백업을 실행할 수있는 백업입니다 (동일한 백업 API를 사용하여 시작한 백업과 &lt;a href=&quot;app-pgbasebackup&quot;&gt;pg_basebackup을&lt;/a&gt; 사용하여 시작된 백업 ).</target>
        </trans-unit>
        <trans-unit id="401550561965c2499f16ad6fd4b31c047d5f304a" translate="yes" xml:space="preserve">
          <source>A normal relationship between separately-created objects. The dependent object can be dropped without affecting the referenced object. The referenced object can only be dropped by specifying &lt;code&gt;CASCADE&lt;/code&gt;, in which case the dependent object is dropped, too. Example: a table column has a normal dependency on its data type.</source>
          <target state="translated">별도로 만든 객체 간의 정상적인 관계입니다. 참조 된 개체에 영향을주지 않고 종속 개체를 삭제할 수 있습니다. &lt;code&gt;CASCADE&lt;/code&gt; 를 지정해야만 참조 된 오브젝트를 삭제할 수 있으며 ,이 경우 종속 오브젝트도 삭제됩니다. 예 : 테이블 열의 데이터 형식에 대한 일반적인 종속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4e6fa0c13024f923c36983ca255cb802f2a15dc" translate="yes" xml:space="preserve">
          <source>A not-null constraint is always written as a column constraint. A not-null constraint is functionally equivalent to creating a check constraint &lt;code&gt;CHECK (column_name IS NOT NULL)&lt;/code&gt;, but in PostgreSQL creating an explicit not-null constraint is more efficient. The drawback is that you cannot give explicit names to not-null constraints created this way.</source>
          <target state="translated">널이 아닌 제한 조건은 항상 열 제한 조건으로 작성됩니다. null이 아닌 제약 조건은 기능적으로 검사 제약 조건 &lt;code&gt;CHECK (column_name IS NOT NULL)&lt;/code&gt; 를 만드는 것과 동일 하지만 PostgreSQL에서는 명시적인 null이 아닌 제약 조건을 만드는 것이 더 효율적입니다. 단점은 이런 식으로 생성 된 null이 아닌 제약 조건에 명시적인 이름을 지정할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="29e3f0f63dd403df874ec2bd2e2e99cfcbefc40b" translate="yes" xml:space="preserve">
          <source>A not-null constraint simply specifies that a column must not assume the null value. A syntax example:</source>
          <target state="translated">널이 아닌 제한 조건은 단순히 열이 널값을 가정해서는 안됨을 지정합니다. 구문 예 :</target>
        </trans-unit>
        <trans-unit id="38f215d8dff9a872adcc025cd248723a7de60a09" translate="yes" xml:space="preserve">
          <source>A number of probes or trace points are already inserted into the source code. These probes are intended to be used by database developers and administrators. By default the probes are not compiled into PostgreSQL; the user needs to explicitly tell the configure script to make the probes available.</source>
          <target state="translated">많은 프로브 또는 추적 점이 이미 소스 코드에 삽입되어 있습니다. 이 프로브는 데이터베이스 개발자 및 관리자가 사용하도록 설계되었습니다. 기본적으로 프로브는 PostgreSQL로 컴파일되지 않습니다. 사용자는 프로브를 사용 가능하게하려면 구성 스크립트에 명시 적으로 지시해야합니다.</target>
        </trans-unit>
        <trans-unit id="62bf9b2e29dd2eab9640de99e0e28efaa651fde7" translate="yes" xml:space="preserve">
          <source>A number of standard probes are provided in the source code, as shown in &lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;Table 27.28&lt;/a&gt;; &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;Table 27.29&lt;/a&gt; shows the types used in the probes. More probes can certainly be added to enhance PostgreSQL's observability.</source>
          <target state="translated">&lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;표 27.28에&lt;/a&gt; 표시된 것처럼 많은 표준 프로브가 소스 코드에 제공됩니다 . &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;표 27.29&lt;/a&gt; 는 프로브에 사용 된 유형을 보여줍니다. PostgreSQL의 관찰 성을 향상시키기 위해 더 많은 프로브를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae551e6f1a5e0e884b3ccb3cbfaaaffb2764ba8e" translate="yes" xml:space="preserve">
          <source>A number of standard probes are provided in the source code, as shown in &lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;Table 27.42&lt;/a&gt;; &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;Table 27.43&lt;/a&gt; shows the types used in the probes. More probes can certainly be added to enhance PostgreSQL's observability.</source>
          <target state="translated">&lt;a href=&quot;dynamic-trace#DTRACE-PROBE-POINT-TABLE&quot;&gt;표 27.42에&lt;/a&gt; 표시된 것처럼 소스 코드에 여러 표준 프로브가 제공됩니다 . &lt;a href=&quot;dynamic-trace#TYPEDEFS-TABLE&quot;&gt;표 27.43&lt;/a&gt; 은 프로브에 사용되는 유형을 보여줍니다. PostgreSQL의 관찰 가능성을 향상시키기 위해 더 많은 프로브를 확실히 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83f77be94ef3c8feb2e598e753ef0750ef27c239" translate="yes" xml:space="preserve">
          <source>A number of these variables are treated specially by psql. They represent certain option settings that can be changed at run time by altering the value of the variable, or in some cases represent changeable state of psql. By convention, all specially treated variables' names consist of all upper-case ASCII letters (and possibly digits and underscores). To ensure maximum compatibility in the future, avoid using such variable names for your own purposes.</source>
          <target state="translated">이러한 변수 중 다수는 psql에 의해 특별히 처리됩니다. 변수 값을 변경하여 런타임시 변경 될 수있는 특정 옵션 설정을 나타내거나 경우에 따라 psql의 변경 가능한 상태를 나타냅니다. 일반적으로 특수하게 처리 된 모든 변수 이름은 모든 대문자 ASCII 문자 (및 숫자와 밑줄)로 구성됩니다. 나중에 최대한의 호환성을 유지하려면 자신의 목적으로 이러한 변수 이름을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9671dc450d1031cf1ea5da7434a9e12abf1e8725" translate="yes" xml:space="preserve">
          <source>A numeric constant that contains neither a decimal point nor an exponent is initially presumed to be type &lt;code&gt;integer&lt;/code&gt; if its value fits in type &lt;code&gt;integer&lt;/code&gt; (32 bits); otherwise it is presumed to be type &lt;code&gt;bigint&lt;/code&gt; if its value fits in type &lt;code&gt;bigint&lt;/code&gt; (64 bits); otherwise it is taken to be type &lt;code&gt;numeric&lt;/code&gt;. Constants that contain decimal points and/or exponents are always initially presumed to be type &lt;code&gt;numeric&lt;/code&gt;.</source>
          <target state="translated">소수점이나 지수를 포함하지 않는 숫자 상수 는 값이 &lt;code&gt;integer&lt;/code&gt; 유형 (32 비트)에 맞는 경우 처음에는 &lt;code&gt;integer&lt;/code&gt; 유형으로 간주됩니다 . 그렇지 않으면 값이 &lt;code&gt;bigint&lt;/code&gt; 유형 (64 비트)에 맞는 경우 &lt;code&gt;bigint&lt;/code&gt; 유형으로 간주됩니다 . 그렇지 않으면 &lt;code&gt;numeric&lt;/code&gt; 유형으로 간주됩니다 . 소수점 및 / 또는 지수를 포함하는 상수는 항상 초기에 &lt;code&gt;numeric&lt;/code&gt; 유형 인 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="28053ae7864d70a55d085c051398ee367a8ba696" translate="yes" xml:space="preserve">
          <source>A numeric constant that specifies the length in bytes of the new type's internal representation. The default assumption is that it is variable-length.</source>
          <target state="translated">새 유형의 내부 표현 길이를 바이트 단위로 지정하는 숫자 상수입니다. 기본 가정은 가변 길이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="458377c420bfcead4a575e16d3cb5a525edf744e" translate="yes" xml:space="preserve">
          <source>A one-dimensional interval starting at &lt;code&gt;x&lt;/code&gt; and ending at &lt;code&gt;y&lt;/code&gt; or vice versa; the order does not matter</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에서 시작 하여 &lt;code&gt;y&lt;/code&gt; 에서 끝나 거나 그 반대로 끝나는 1 차원 간격 ; 순서는 중요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="258b20d113a4ac0002010f6811f02c8de89d74bf" translate="yes" xml:space="preserve">
          <source>A one-dimensional point (or, zero-length one-dimensional interval)</source>
          <target state="translated">1 차원 점 (또는 길이가 0 인 1 차원 간격)</target>
        </trans-unit>
        <trans-unit id="bc1071526f0987dbc584cef038787a5b04285bb1" translate="yes" xml:space="preserve">
          <source>A page image obtained with &lt;code&gt;get_raw_page&lt;/code&gt; should be passed as argument. For example:</source>
          <target state="translated">&lt;code&gt;get_raw_page&lt;/code&gt; 로 얻은 페이지 이미지 는 인수로 전달되어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d8915a6b0933e1f5dc0f9cee0ae40fe953639a8" translate="yes" xml:space="preserve">
          <source>A parent table cannot be dropped while any of its children remain. Neither can columns or check constraints of child tables be dropped or altered if they are inherited from any parent tables. If you wish to remove a table and all of its descendants, one easy way is to drop the parent table with the &lt;code&gt;CASCADE&lt;/code&gt; option (see &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt;).</source>
          <target state="translated">자식이 남아있는 동안 부모 테이블을 삭제할 수 없습니다. 하위 테이블의 컬럼 또는 점검 제한 조건이 상위 테이블에서 상속 된 경우 삭제되거나 변경 될 수 없습니다. 테이블과 모든 하위 항목을 제거하려면 &lt;code&gt;CASCADE&lt;/code&gt; 옵션을 사용하여 상위 테이블을 삭제하는 것이 가장 쉬운 방법입니다 ( &lt;a href=&quot;ddl-depend&quot;&gt;섹션 5.14&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b87d25eb2f25d2d484b24b9f4a15020854de03d4" translate="yes" xml:space="preserve">
          <source>A parent table to associate or de-associate with this foreign table.</source>
          <target state="translated">이 외부 테이블과 연관 시키거나 연관 해제 할 상위 테이블.</target>
        </trans-unit>
        <trans-unit id="9038188b4e1e4e207e5656bab49c0b4bbe2840fb" translate="yes" xml:space="preserve">
          <source>A parent table to associate or de-associate with this table.</source>
          <target state="translated">이 테이블과 연관 시키거나 연관 해제 할 상위 테이블.</target>
        </trans-unit>
        <trans-unit id="bef9303e674e1152b39759a3ac4a051765f051a5" translate="yes" xml:space="preserve">
          <source>A partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints will be inherited automatically by every partition, but an individual partition may specify additional &lt;code&gt;CHECK&lt;/code&gt; constraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition.</source>
          <target state="translated">파티션은 파티션이 속한 파티션 된 테이블과 동일한 컬럼 이름 및 유형을 가져야합니다. 파티션 된 테이블의 컬럼 이름 또는 유형을 수정하면 모든 파티션에 자동으로 전파됩니다. &lt;code&gt;CHECK&lt;/code&gt; 제약 조건은 모든 파티션에 의해 자동으로 상속되지만 개별 파티션은 추가 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건을 지정할 수 있습니다 . 부모에서와 동일한 이름과 조건을 가진 추가 제한 조건은 부모 제한 조건과 병합됩니다. 각 파티션마다 기본값을 별도로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b0fee0af770b0e2b7c1779ad6d02cf3f6e73981" translate="yes" xml:space="preserve">
          <source>A partition must have the same column names and types as the partitioned table to which it belongs. Modifications to the column names or types of a partitioned table will automatically propagate to all partitions. &lt;code&gt;CHECK&lt;/code&gt; constraints will be inherited automatically by every partition, but an individual partition may specify additional &lt;code&gt;CHECK&lt;/code&gt; constraints; additional constraints with the same name and condition as in the parent will be merged with the parent constraint. Defaults may be specified separately for each partition. But note that a partition's default value is not applied when inserting a tuple through a partitioned table.</source>
          <target state="translated">파티션은 자신이 속한 파티션을 나눈 테이블과 동일한 열 이름 및 유형을 가져야합니다. 파티션을 나눈 테이블의 열 이름 또는 유형에 대한 수정 사항은 모든 파티션에 자동으로 전파됩니다. &lt;code&gt;CHECK&lt;/code&gt; 제약 조건은 모든 파티션에서 자동으로 상속되지만 개별 파티션은 추가 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건을 지정할 수 있습니다 . 부모와 동일한 이름과 조건을 가진 추가 제약은 부모 제약과 병합됩니다. 기본값은 각 파티션에 대해 별도로 지정할 수 있습니다. 그러나 파티션 된 테이블을 통해 튜플을 삽입 할 때는 파티션의 기본값이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="753a83c5b7fc1757da85bcf15b0058b4367b5ffe" translate="yes" xml:space="preserve">
          <source>A partition using &lt;code&gt;FOR VALUES&lt;/code&gt; uses same syntax for &lt;code&gt;partition_bound_spec&lt;/code&gt; as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all the &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints of the target table. Currently &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered. &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints from the parent table will be created in the partition, if they don't already exist. If any of the &lt;code&gt;CHECK&lt;/code&gt; constraints of the table being attached are marked &lt;code&gt;NO INHERIT&lt;/code&gt;, the command will fail; such constraints must be recreated without the &lt;code&gt;NO INHERIT&lt;/code&gt; clause.</source>
          <target state="translated">사용하는 파티션 &lt;code&gt;FOR VALUES&lt;/code&gt; 에 대한 동일한 구문 사용 &lt;code&gt;partition_bound_spec&lt;/code&gt; 로 &lt;a href=&quot;sql-createtable&quot;&gt;테이블 만들기를&lt;/a&gt; . 파티션 바운드 스펙은 대상 테이블의 파티션 전략 및 파티션 키와 일치해야합니다. 첨부 할 테이블에는 대상 테이블과 동일한 열이 있어야하며 더 이상 없어야합니다. 또한 열 유형도 일치해야합니다. 또한 대상 테이블의 모든 &lt;code&gt;NOT NULL&lt;/code&gt; 및 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건이 있어야합니다. 현재 &lt;code&gt;FOREIGN KEY&lt;/code&gt; 제약 조건은 고려되지 않습니다. 부모 테이블의 &lt;code&gt;UNIQUE&lt;/code&gt; 및 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 제약 조건이 아직 존재하지 않는 경우 파티션에 생성됩니다. &lt;code&gt;CHECK&lt;/code&gt; 중 하나라도첨부되는 테이블의 제약 조건이 &lt;code&gt;NO INHERIT&lt;/code&gt; 로 표시 되면 명령이 실패합니다. 이러한 제약 조건은 &lt;code&gt;NO INHERIT&lt;/code&gt; 절 없이 다시 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2265efb683514f071f0b16aed28cd3bcc5853f6a" translate="yes" xml:space="preserve">
          <source>A partition using &lt;code&gt;FOR VALUES&lt;/code&gt; uses same syntax for &lt;code&gt;partition_bound_spec&lt;/code&gt; as &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. The partition bound specification must correspond to the partitioning strategy and partition key of the target table. The table to be attached must have all the same columns as the target table and no more; moreover, the column types must also match. Also, it must have all the &lt;code&gt;NOT NULL&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; constraints of the target table. Currently &lt;code&gt;FOREIGN KEY&lt;/code&gt; constraints are not considered. &lt;code&gt;UNIQUE&lt;/code&gt; and &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraints from the parent table will be created in the partition, if they don't already exist. If any of the &lt;code&gt;CHECK&lt;/code&gt; constraints of the table being attached is marked &lt;code&gt;NO INHERIT&lt;/code&gt;, the command will fail; such constraints must be recreated without the &lt;code&gt;NO INHERIT&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;FOR VALUES&lt;/code&gt; 를 사용 하는 파티션 은 &lt;code&gt;partition_bound_spec&lt;/code&gt; 에 대해 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 과 동일한 구문을 사용합니다 . 파티션 바인드 스펙은 대상 테이블의 파티션 전략 및 파티션 키와 일치해야합니다. 첨부 할 테이블은 목표 테이블과 동일한 열을 가져야하며 더 이상 열을 가져서는 안됩니다. 또한 열 유형도 일치해야합니다. 또한 목표 테이블의 모든 &lt;code&gt;NOT NULL&lt;/code&gt; 및 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건이 있어야합니다. 현재 &lt;code&gt;FOREIGN KEY&lt;/code&gt; 제약 조건은 고려되지 않습니다. 부모 테이블의 &lt;code&gt;UNIQUE&lt;/code&gt; 및 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 제약 조건이 아직없는 경우 파티션에 생성됩니다. &lt;code&gt;CHECK&lt;/code&gt; 중 하나라도첨부되는 테이블의 제한 조건이 &lt;code&gt;NO INHERIT&lt;/code&gt; 로 표시 되면 명령이 실패합니다. 이러한 제한 조건은 &lt;code&gt;NO INHERIT&lt;/code&gt; 절 없이 다시 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="02bfa1f4284b2b7254a60122f0ece5c14ca3baa1" translate="yes" xml:space="preserve">
          <source>A partitioned table is divided into sub-tables (called partitions), which are created using separate &lt;code&gt;CREATE TABLE&lt;/code&gt; commands. The partitioned table is itself empty. A data row inserted into the table is routed to a partition based on the value of columns or expressions in the partition key. If no existing partition matches the values in the new row, an error will be reported.</source>
          <target state="translated">파티션 된 테이블은 별도의 &lt;code&gt;CREATE TABLE&lt;/code&gt; 명령을 사용하여 작성되는 서브 테이블 (파티션이라고 함)로 나뉩니다 . 파티션 된 테이블 자체가 비어 있습니다. 테이블에 삽입 된 데이터 행은 파티션 키의 열 또는 표현식 값에 따라 파티션으로 라우팅됩니다. 기존 파티션이 새 행의 값과 일치하지 않으면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="47bfb6365d874606167f5297b7825760e1b94998" translate="yes" xml:space="preserve">
          <source>A password is only significant if the client authentication method requires the user to supply a password when connecting to the database. The &lt;code&gt;password&lt;/code&gt; and &lt;code&gt;md5&lt;/code&gt; authentication methods make use of passwords. Database passwords are separate from operating system passwords. Specify a password upon role creation with &lt;code&gt;CREATE ROLE name PASSWORD 'string'&lt;/code&gt;.</source>
          <target state="translated">클라이언트 인증 방법으로 데이터베이스에 연결할 때 사용자가 비밀번호를 제공해야하는 경우에만 비밀번호가 중요합니다. &lt;code&gt;password&lt;/code&gt; 와 &lt;code&gt;md5&lt;/code&gt; 인증 방법은 암호를 사용합니다. 데이터베이스 비밀번호는 운영 체제 비밀번호와 다릅니다. 역할을 작성할 때 &lt;code&gt;CREATE ROLE name PASSWORD 'string'&lt;/code&gt; 으로 비밀번호를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="35958631e7f174f767add77cc9815bb09387d918" translate="yes" xml:space="preserve">
          <source>A password that does not follow either of those formats is assumed to be unencrypted.</source>
          <target state="translated">이러한 형식 중 하나를 따르지 않는 암호는 암호화되지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ab9b8b43d3aed0e06f19d1971e9a5e5fb76320e8" translate="yes" xml:space="preserve">
          <source>A path expression can be a Boolean predicate, although the SQL/JSON standard allows predicates only in filters. This is necessary for implementation of the &lt;code&gt;@@&lt;/code&gt; operator. For example, the following &lt;code&gt;jsonpath&lt;/code&gt; expression is valid in PostgreSQL:</source>
          <target state="translated">SQL / JSON 표준은 필터에서만 술어를 허용하지만 경로 표현식은 부울 술어 일 수 있습니다. &lt;code&gt;@@&lt;/code&gt; 연산자 를 구현하는 데 필요합니다 . 예를 들어, 다음 &lt;code&gt;jsonpath&lt;/code&gt; 표현식은 PostgreSQL에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="630b9b00d6c7d46f1803db83394a9ee4f3b0c93b" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of elements allowed by the &lt;code&gt;jsonpath&lt;/code&gt; data type. The path expression is evaluated from left to right, but you can use parentheses to change the order of operations. If the evaluation is successful, a sequence of SQL/JSON items (&lt;em&gt;SQL/JSON sequence&lt;/em&gt;) is produced, and the evaluation result is returned to the JSON query function that completes the specified computation.</source>
          <target state="translated">경로 표현식은 &lt;code&gt;jsonpath&lt;/code&gt; 데이터 유형에 의해 허용되는 일련의 요소로 구성됩니다 . 경로 식은 왼쪽에서 오른쪽으로 평가되지만 괄호를 사용하여 작업 순서를 변경할 수 있습니다. 평가에 성공하면 일련의 SQL / JSON 항목 ( &lt;em&gt;SQL / JSON sequence&lt;/em&gt; )이 생성되고 평가 결과가 지정된 계산을 완료하는 JSON 조회 함수로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="87f4c54faa8f7479fd0c8926b062c01e3b7b2498" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of elements allowed by the &lt;code&gt;jsonpath&lt;/code&gt; data type. The path expression is normally evaluated from left to right, but you can use parentheses to change the order of operations. If the evaluation is successful, a sequence of JSON items is produced, and the evaluation result is returned to the JSON query function that completes the specified computation.</source>
          <target state="translated">경로 표현식은 &lt;code&gt;jsonpath&lt;/code&gt; 데이터 유형 에서 허용하는 일련의 요소로 구성됩니다 . 경로 표현식은 일반적으로 왼쪽에서 오른쪽으로 평가되지만 괄호를 사용하여 작업 순서를 변경할 수 있습니다. 평가가 성공하면 일련의 JSON 항목이 생성되고 지정된 계산을 완료하는 JSON 쿼리 함수에 평가 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="419a53a9c84f96a1644ee859a8c3c016a2c745c2" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of path elements, which can be any of the following:</source>
          <target state="translated">경로 표현식은 일련의 경로 요소로 구성되며 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b906a3261066476a4e478667be529d451288613" translate="yes" xml:space="preserve">
          <source>A path expression consists of a sequence of path elements, which can be the following:</source>
          <target state="translated">경로 식은 다음과 같은 일련의 경로 요소로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="46a75a9a8ee3f1ff5de45744e068475e9be0d81b" translate="yes" xml:space="preserve">
          <source>A pattern that contains a dot (&lt;code&gt;.&lt;/code&gt;) is interpreted as a schema name pattern followed by an object name pattern. For example, &lt;code&gt;\dt foo*.*bar*&lt;/code&gt; displays all tables whose table name includes &lt;code&gt;bar&lt;/code&gt; that are in schemas whose schema name starts with &lt;code&gt;foo&lt;/code&gt;. When no dot appears, then the pattern matches only objects that are visible in the current schema search path. Again, a dot within double quotes loses its special meaning and is matched literally.</source>
          <target state="translated">점 ( &lt;code&gt;.&lt;/code&gt; ) 을 포함하는 패턴 은 스키마 이름 패턴과 오브젝트 이름 패턴으로 해석됩니다. 예를 들어, &lt;code&gt;\dt foo*.*bar*&lt;/code&gt; 는 스키마 이름이 &lt;code&gt;foo&lt;/code&gt; 로 시작하는 스키마에 있는 테이블 이름에 &lt;code&gt;bar&lt;/code&gt; 가 포함 된 모든 테이블을 표시합니다 . 점이 나타나지 않으면 패턴은 현재 스키마 검색 경로에 보이는 객체 만 일치합니다. 다시 한 번 큰 따옴표 안에있는 점은 특별한 의미를 잃고 문자 그대로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e2fdd324df9af943d98a0446644b1732be556666" translate="yes" xml:space="preserve">
          <source>A physical file which stores data for a given &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt;. File segments are limited in size by a configuration value (typically 1 gigabyte), so if a relation exceeds that size, it is split into multiple segments.</source>
          <target state="translated">주어진 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계에&lt;/a&gt; 대한 데이터를 저장하는 실제 파일 . 파일 세그먼트는 구성 값 (일반적으로 1GB)에 의해 크기가 제한되므로 관계가 해당 크기를 초과하면 여러 세그먼트로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="5474357c1efadc094c42e8ca5e1d158c9c8724d2" translate="yes" xml:space="preserve">
          <source>A plain integer denotes a day of the year, counting from zero to 364, or to 365 in leap years.</source>
          <target state="translated">일반 정수는 1 년 중 1 일을 나타내며 0에서 364까지 또는 윤년에서 365까지 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="7897c4bbe5ec9cccaaddf1f6c43de7d3f2aaad08" translate="yes" xml:space="preserve">
          <source>A point in n-dimensional space, represented internally as a zero-volume cube</source>
          <target state="translated">내부적으로 제로 볼륨 큐브로 표시되는 n 차원 공간의 점</target>
        </trans-unit>
        <trans-unit id="45445178529cbc6647ad679b1b5ca9fd7c3a49b9" translate="yes" xml:space="preserve">
          <source>A point in the &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt; sequence at which it is guaranteed that the heap and index data files have been updated with all information from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; modified before that checkpoint; a &lt;em&gt;checkpoint record&lt;/em&gt; is written and flushed to WAL to mark that point.</source>
          <target state="translated">힙 및 인덱스 데이터 파일이 해당 체크 포인트 이전에 수정 된 &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;공유 메모리의&lt;/a&gt; 모든 정보로 업데이트되었음을 ​​보장하는 &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;WAL&lt;/a&gt; 시퀀스 의 지점입니다 . &lt;em&gt;검사 점 레코드가&lt;/em&gt; 기록 된 그 지점을 표시 WAL에 플러시됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b4b7209c416eb8b0cd4ad3c6e895e2f5e59edbd1" translate="yes" xml:space="preserve">
          <source>A policy grants the permission to select, insert, update, or delete rows that match the relevant policy expression. Existing table rows are checked against the expression specified in &lt;code&gt;USING&lt;/code&gt;, while new rows that would be created via &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; are checked against the expression specified in &lt;code&gt;WITH CHECK&lt;/code&gt;. When a &lt;code&gt;USING&lt;/code&gt; expression returns true for a given row then that row is visible to the user, while if false or null is returned then the row is not visible. When a &lt;code&gt;WITH CHECK&lt;/code&gt; expression returns true for a row then that row is inserted or updated, while if false or null is returned then an error occurs.</source>
          <target state="translated">정책은 관련 정책 표현식과 일치하는 행을 선택, 삽입, 업데이트 또는 삭제할 수있는 권한을 부여합니다. 기존 테이블 행은 &lt;code&gt;USING&lt;/code&gt; 에 지정된 표현식과 비교하여 검사 되는 반면, &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 를 통해 작성된 새 행 은 &lt;code&gt;WITH CHECK&lt;/code&gt; 에 지정된 표현식과 비교하여 점검 됩니다. 주어진 행에 대해 &lt;code&gt;USING&lt;/code&gt; 표현식이 true를 리턴 하면 해당 행이 사용자에게 표시되고 false 또는 null이 리턴되면 행이 표시되지 않습니다. &lt;code&gt;WITH CHECK&lt;/code&gt; 표현식이 행에 대해 true를 리턴 하면 해당 행이 삽입되거나 갱신되는 반면 false 또는 null이 리턴되면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f8e613dc0d26e68918f83658070562d9898412d1" translate="yes" xml:space="preserve">
          <source>A position normally indicates the source word's location in the document. Positional information can be used for &lt;em&gt;proximity ranking&lt;/em&gt;. Position values can range from 1 to 16383; larger numbers are silently set to 16383. Duplicate positions for the same lexeme are discarded.</source>
          <target state="translated">위치는 일반적으로 문서에서 소스 단어의 위치를 ​​나타냅니다. 위치 정보는 &lt;em&gt;근접성 순위에&lt;/em&gt; 사용될 수 있습니다 . 위치 값의 범위는 1-16383입니다. 더 큰 숫자는 자동으로 16383으로 설정됩니다. 동일한 넥서스에 대한 중복 위치는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="8124e08cb675a3763a841977baebeafd4db084c2" translate="yes" xml:space="preserve">
          <source>A positional parameter reference is used to indicate a value that is supplied externally to an SQL statement. Parameters are used in SQL function definitions and in prepared queries. Some client libraries also support specifying data values separately from the SQL command string, in which case parameters are used to refer to the out-of-line data values. The form of a parameter reference is:</source>
          <target state="translated">위치 매개 변수 참조는 SQL 문 외부에 제공되는 값을 표시하는 데 사용됩니다. 매개 변수는 SQL 함수 정의 및 준비된 쿼리에 사용됩니다. 일부 클라이언트 라이브러리는 또한 SQL 명령 문자열과 별도로 데이터 값 지정을 지원합니다.이 경우 매개 변수는 라인 외부 데이터 값을 참조하는 데 사용됩니다. 매개 변수 참조의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3833bdb7ea9a948094cad484b196a53403718838" translate="yes" xml:space="preserve">
          <source>A positional parameter reference, in the body of a function definition or prepared statement</source>
          <target state="translated">함수 정의 본문 또는 준비된 명령문의 본문에있는 위치 매개 변수 참조</target>
        </trans-unit>
        <trans-unit id="0f115ce95e27f153df6502e75df85ece7a17f10c" translate="yes" xml:space="preserve">
          <source>A positive number giving the estimated execution cost for the function, in units of &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;. If the function returns a set, this is the cost per returned row. If the cost is not specified, 1 unit is assumed for C-language and internal functions, and 100 units for functions in all other languages. Larger values cause the planner to try to avoid evaluating the function more often than necessary.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt; 단위로 함수의 예상 실행 비용을 제공하는 양수 입니다. 함수가 집합을 반환하면 반환 된 행당 비용입니다. 비용을 지정하지 않으면 C 언어 및 내부 기능에 대해 1 단위, 다른 모든 언어에서 기능에 대해서는 100 단위로 가정됩니다. 값이 클수록 플래너는 함수를 필요 이상으로 자주 평가하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="30c1a79cbb9484177e363d4544efe87e3e39ffa7" translate="yes" xml:space="preserve">
          <source>A positive number giving the estimated number of rows that the planner should expect the function to return. This is only allowed when the function is declared to return a set. The default assumption is 1000 rows.</source>
          <target state="translated">플래너가 함수가 리턴 할 것으로 예상해야하는 예상 행 수를 제공하는 양수. 함수가 집합을 반환하도록 선언 된 경우에만 허용됩니다. 기본 가정은 1000 행입니다.</target>
        </trans-unit>
        <trans-unit id="02f79e462db5425b448e96c1072a3f594c31942d" translate="yes" xml:space="preserve">
          <source>A possible query to use this index would be:</source>
          <target state="translated">이 인덱스를 사용하는 가능한 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a46068a086ffe6678122c2b4a804a11dab670aaa" translate="yes" xml:space="preserve">
          <source>A prepared statement can be executed with either a &lt;em&gt;generic plan&lt;/em&gt; or a &lt;em&gt;custom plan&lt;/em&gt;. A generic plan is the same across all executions, while a custom plan is generated for a specific execution using the parameter values given in that call. Use of a generic plan avoids planning overhead, but in some situations a custom plan will be much more efficient to execute because the planner can make use of knowledge of the parameter values. (Of course, if the prepared statement has no parameters, then this is moot and a generic plan is always used.)</source>
          <target state="translated">준비된 명령문은 &lt;em&gt;일반 계획&lt;/em&gt; 또는 &lt;em&gt;사용자 정의 계획&lt;/em&gt; 으로 실행할 수 있습니다 . 일반 계획은 모든 실행에서 동일하지만 해당 호출에 지정된 매개 변수 값을 사용하여 특정 실행에 대해 사용자 정의 계획이 생성됩니다. 일반 계획을 사용하면 계획 오버 헤드가 발생하지 않지만 일부 상황에서는 계획자가 매개 변수 값에 대한 지식을 활용할 수 있으므로 사용자 정의 계획이 훨씬 효율적으로 실행됩니다. (물론, 준비된 명령문에 매개 변수가없는 경우 이는 무의미하며 일반 계획이 항상 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="13348ea1ec457fbeed4d2620cc50c2e7f85fa0ae" translate="yes" xml:space="preserve">
          <source>A primary key constraint indicates that a column, or group of columns, can be used as a unique identifier for rows in the table. This requires that the values be both unique and not null. So, the following two table definitions accept the same data:</source>
          <target state="translated">기본 키 제약 조건은 열 또는 열 그룹이 테이블의 행에 대한 고유 식별자로 사용될 수 있음을 나타냅니다. 이를 위해서는 값이 고유하고 널이 아니어야합니다. 따라서 다음 두 테이블 정의는 동일한 데이터를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="3f893762c520af1aa49b543485b038d4cb74971c" translate="yes" xml:space="preserve">
          <source>A procedural language call handler is declared to return &lt;code&gt;language_handler&lt;/code&gt;.</source>
          <target state="translated">절차 언어 호출 핸들러는 &lt;code&gt;language_handler&lt;/code&gt; 를 리턴하도록 선언 됩니다 .</target>
        </trans-unit>
        <trans-unit id="85b471a8bbdcb0184dcaf026b542b9d1c7608b3f" translate="yes" xml:space="preserve">
          <source>A process that saves copies of &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt; for the purpose of creating backups or keeping &lt;a href=&quot;glossary#GLOSSARY-REPLICA&quot;&gt;replicas&lt;/a&gt; current.</source>
          <target state="translated">백업을 생성하거나 &lt;a href=&quot;glossary#GLOSSARY-REPLICA&quot;&gt;복제본을&lt;/a&gt; 최신 상태로 유지하기 위해 &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL 파일의&lt;/a&gt; 복사본을 저장하는 프로세스입니다 .</target>
        </trans-unit>
        <trans-unit id="68348e6f47688291dbdf76ea9ce04384d5ed5818" translate="yes" xml:space="preserve">
          <source>A process that writes &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL records&lt;/a&gt; from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; to &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL files&lt;/a&gt;.</source>
          <target state="translated">쓰는 과정 &lt;a href=&quot;glossary#GLOSSARY-WAL-RECORD&quot;&gt;WAL 레코드&lt;/a&gt; 에서 &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;공유 메모리&lt;/a&gt; 에 &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL 파일&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df87a47e5d11566e3968df708fe83a96d24cbb48" translate="yes" xml:space="preserve">
          <source>A process that writes dirty &lt;a href=&quot;glossary#GLOSSARY-DATA-PAGE&quot;&gt;data pages&lt;/a&gt; from &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;shared memory&lt;/a&gt; to the file system. It wakes up periodically, but works only for a short period in order to distribute its expensive I/O activity over time to avoid generating larger I/O peaks which could block other processes.</source>
          <target state="translated">더러운 쓰는 과정 &lt;a href=&quot;glossary#GLOSSARY-DATA-PAGE&quot;&gt;데이터 페이지&lt;/a&gt; 에서 &lt;a href=&quot;glossary#GLOSSARY-SHARED-MEMORY&quot;&gt;공유 메모리&lt;/a&gt; 파일 시스템. 주기적으로 깨어나지 만 시간이 지남에 따라 값 비싼 I / O 활동을 분산시키기 위해 짧은 기간 동안 만 작동하여 다른 프로세스를 차단할 수있는 더 큰 I / O 피크 생성을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="b598946555659e8de8862e7df2ae169d900a0d4a" translate="yes" xml:space="preserve">
          <source>A publication can only be dropped by its owner or a superuser.</source>
          <target state="translated">게시는 소유자 또는 수퍼 유저 만 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba53206c029e2edfae51f727e267685bcdf05085" translate="yes" xml:space="preserve">
          <source>A publication is created using the &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt; command and may later be altered or dropped using corresponding commands.</source>
          <target state="translated">발행물은 &lt;a href=&quot;sql-createpublication&quot;&gt;CREATE PUBLICATION&lt;/a&gt; 명령을 사용하여 작성되며 나중에 해당 명령을 사용하여 변경하거나 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9ab2d1b430251390fd77666a59dc72c11f11cfe" translate="yes" xml:space="preserve">
          <source>A publication is essentially a group of tables whose data changes are intended to be replicated through logical replication. See &lt;a href=&quot;logical-replication-publication&quot;&gt;Section 30.1&lt;/a&gt; for details about how publications fit into the logical replication setup.</source>
          <target state="translated">게시는 기본적으로 논리적 복제를 통해 데이터 변경 내용을 복제하려는 테이블 그룹입니다. 게시가 논리적 복제 설정에 어떻게 적용되는지에 대한 자세한 내용 &lt;a href=&quot;logical-replication-publication&quot;&gt;은 30.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2338433bd110932bcc29150142a24f592f4dfbb" translate="yes" xml:space="preserve">
          <source>A published table must have a &amp;ldquo;replica identity&amp;rdquo; configured in order to be able to replicate &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; operations, so that appropriate rows to update or delete can be identified on the subscriber side. By default, this is the primary key, if there is one. Another unique index (with certain additional requirements) can also be set to be the replica identity. If the table does not have any suitable key, then it can be set to replica identity &amp;ldquo;full&amp;rdquo;, which means the entire row becomes the key. This, however, is very inefficient and should only be used as a fallback if no other solution is possible. If a replica identity other than &amp;ldquo;full&amp;rdquo; is set on the publisher side, a replica identity comprising the same or fewer columns must also be set on the subscriber side. See &lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt;&lt;code&gt;REPLICA IDENTITY&lt;/code&gt;&lt;/a&gt; for details on how to set the replica identity. If a table without a replica identity is added to a publication that replicates &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations then subsequent &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt; operations will cause an error on the publisher. &lt;code&gt;INSERT&lt;/code&gt; operations can proceed regardless of any replica identity.</source>
          <target state="translated">게시 된 테이블에는 &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 작업 을 복제 할 수 있도록 &quot;복제본 ID&quot;가 구성되어 있어야 구독자 쪽에서 업데이트하거나 삭제할 적절한 행을 식별 할 수 있습니다. 기본 키는 기본 키입니다 (있는 경우). 또 다른 고유 인덱스 (특정 추가 요구 사항 포함)를 복제본 ID로 설정할 수도 있습니다. 테이블에 적합한 키가 없으면 ID를 &quot;full&quot;로 복제하도록 설정하면 전체 행이 키가됩니다. 그러나 이는 매우 비효율적이며 다른 솔루션이없는 경우에만 대체로 사용해야합니다. &quot;전체&quot;이외의 복제본 ID가 게시자 측에 설정된 경우 동일하거나 더 적은 수의 열을 포함하는 복제본 ID도 가입자 측에 설정해야합니다. 보다&lt;a href=&quot;sql-altertable#SQL-CREATETABLE-REPLICA-IDENTITY&quot;&gt; &lt;code&gt;REPLICA IDENTITY&lt;/code&gt; &lt;/a&gt;복제본 ID를 설정하는 방법에 대한 자세한 내용은 REPLICA IDENTITY 를 참조하십시오. 복제본 ID가없는 테이블이 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 작업을복제하는 게시에 추가되면후속 &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 작업으로 인해 게시자에서 오류가 발생합니다. &lt;code&gt;INSERT&lt;/code&gt; 작업은 복제본 ID에 관계없이 진행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fa8cd1ec75091ae1b152072de83438ac13c7ac1" translate="yes" xml:space="preserve">
          <source>A quantified atom is an &lt;em&gt;atom&lt;/em&gt; possibly followed by a single &lt;em&gt;quantifier&lt;/em&gt;. Without a quantifier, it matches a match for the atom. With a quantifier, it can match some number of matches of the atom. An &lt;em&gt;atom&lt;/em&gt; can be any of the possibilities shown in &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;Table 9.16&lt;/a&gt;. The possible quantifiers and their meanings are shown in &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;Table 9.17&lt;/a&gt;.</source>
          <target state="translated">정량화 된 원자는 가능한 한 개의 &lt;em&gt;정량 자&lt;/em&gt; 뒤에 오는 &lt;em&gt;원자&lt;/em&gt; 입니다. 수량자가 없으면 원자와 일치합니다. 수량자를 사용하면 원자의 일부 일치와 일치 할 수 있습니다. &lt;em&gt;원자&lt;/em&gt; 에 도시 된 가능성 중 하나 일 수 &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;표 9.16&lt;/a&gt; . 가능한 수량 자와 그 의미는 &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;표 9.17&lt;/a&gt; 에 나와 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc21709c3a9df27bc9570d7ce18a8b13da68c2a0" translate="yes" xml:space="preserve">
          <source>A quantified atom is an &lt;em&gt;atom&lt;/em&gt; possibly followed by a single &lt;em&gt;quantifier&lt;/em&gt;. Without a quantifier, it matches a match for the atom. With a quantifier, it can match some number of matches of the atom. An &lt;em&gt;atom&lt;/em&gt; can be any of the possibilities shown in &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;Table 9.17&lt;/a&gt;. The possible quantifiers and their meanings are shown in &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;Table 9.18&lt;/a&gt;.</source>
          <target state="translated">수량화 된 원자는 단일 &lt;em&gt;수량자가&lt;/em&gt; 뒤에 올 수 있는 &lt;em&gt;원자&lt;/em&gt; 입니다. 수량자가 없으면 원자와 일치합니다. 수량자를 사용하면 원자의 일부 일치 항목과 일치 할 수 있습니다. &lt;em&gt;원자&lt;/em&gt; 에 도시 된 가능성 중 하나 일 수 &lt;a href=&quot;functions-matching#POSIX-ATOMS-TABLE&quot;&gt;표 9.17&lt;/a&gt; . 가능한 수량 자와 그 의미는 &lt;a href=&quot;functions-matching#POSIX-QUANTIFIERS-TABLE&quot;&gt;표 9.18&lt;/a&gt; 에 나와 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14b90372a7f382e1ebe5fbc1067a98d78caf7059" translate="yes" xml:space="preserve">
          <source>A quantified atom with a fixed-repetition quantifier (&lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; or &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;}?&lt;/code&gt;) has the same greediness (possibly none) as the atom itself.</source>
          <target state="translated">고정 반복 수량 화기 ( &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; 또는 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;}?&lt;/code&gt; )가있는 정량화 된 원자는 원자 자체와 동일한 탐욕을 가질 수 있습니다 (아마도 없음).</target>
        </trans-unit>
        <trans-unit id="d2086c7d3f841e613b77902ebf9e5b97e2cde610" translate="yes" xml:space="preserve">
          <source>A quantified atom with a non-greedy quantifier (including &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;}?&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; equal to &lt;code&gt;n&lt;/code&gt;) is non-greedy (prefers shortest match).</source>
          <target state="translated">(포함하는 비 탐욕 정량으로 정량화 원자 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;}?&lt;/code&gt; 와 &lt;code&gt;m&lt;/code&gt; 은 동일한 &lt;code&gt;n&lt;/code&gt; ) (최단 매치를 선호하는) 비 탐욕이다.</target>
        </trans-unit>
        <trans-unit id="044befe289d741f6adb775e3119a52c47ef4c4c1" translate="yes" xml:space="preserve">
          <source>A quantified atom with other normal quantifiers (including &lt;code&gt;{&lt;/code&gt;&lt;code&gt;m&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;n&lt;/code&gt;&lt;code&gt;}&lt;/code&gt; with &lt;code&gt;m&lt;/code&gt; equal to &lt;code&gt;n&lt;/code&gt;) is greedy (prefers longest match).</source>
          <target state="translated">(다른 정상 포함 한정사와 정량 원자 &lt;code&gt;{&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; &lt;code&gt;}&lt;/code&gt; 와 &lt;code&gt;m&lt;/code&gt; 은 동일한 &lt;code&gt;n&lt;/code&gt; ) (최장 매치를 선호) 욕심.</target>
        </trans-unit>
        <trans-unit id="b0376c8a695cc9a8414ca39502c5036b915645c0" translate="yes" xml:space="preserve">
          <source>A quantifier cannot immediately follow another quantifier, e.g., &lt;code&gt;**&lt;/code&gt; is invalid. A quantifier cannot begin an expression or subexpression or follow &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">수량 자는 다른 수량자를 즉시 ​​따라갈 수 없습니다 (예 : &lt;code&gt;**&lt;/code&gt; 가 유효하지 않음) . 수량자는 표현식이나 하위 표현식을 시작할 수 없거나 &lt;code&gt;^&lt;/code&gt; 또는 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4fb059cdfd53bb422968b17a105f57bd04f411c" translate="yes" xml:space="preserve">
          <source>A query (&lt;code&gt;SELECT&lt;/code&gt; statement) that supplies the rows to be inserted. Refer to the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; statement for a description of the syntax.</source>
          <target state="translated">삽입 될 행을 제공 하는 조회 ( &lt;code&gt;SELECT&lt;/code&gt; 문). 구문에 대한 설명은 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 문을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6cba9f4354114ea501407f47fa13c76eb60151c" translate="yes" xml:space="preserve">
          <source>A query can be &amp;ldquo;qualified&amp;rdquo; by adding a &lt;code&gt;WHERE&lt;/code&gt; clause that specifies which rows are wanted. The &lt;code&gt;WHERE&lt;/code&gt; clause contains a Boolean (truth value) expression, and only rows for which the Boolean expression is true are returned. The usual Boolean operators (&lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, and &lt;code&gt;NOT&lt;/code&gt;) are allowed in the qualification. For example, the following retrieves the weather of San Francisco on rainy days:</source>
          <target state="translated">원하는 행을 지정 하는 &lt;code&gt;WHERE&lt;/code&gt; 절을 추가하여 쿼리를 &quot;규격화&quot;할 수 있습니다 . &lt;code&gt;WHERE&lt;/code&gt; 절은 부울 식을 반환 true 인 부울 (진리 값) 표현 만 행이 포함되어 있습니다. 규정에 일반적인 부울 연산자 ( &lt;code&gt;AND&lt;/code&gt; , &lt;code&gt;OR&lt;/code&gt; 및 &lt;code&gt;NOT&lt;/code&gt; )가 허용됩니다. 예를 들어 다음은 비오는 날 샌프란시스코의 날씨를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="a3f98fa3c0d12a208eadd01d5ce05b0ffde908aa" translate="yes" xml:space="preserve">
          <source>A read-only SQL transaction cannot alter non-temporary tables. This parameter controls the default read-only status of each new transaction. The default is &lt;code&gt;off&lt;/code&gt; (read/write).</source>
          <target state="translated">읽기 전용 SQL 트랜잭션은 비 임시 테이블을 변경할 수 없습니다. 이 매개 변수는 각 새 트랜잭션의 기본 읽기 전용 상태를 제어합니다. 기본값은 &lt;code&gt;off&lt;/code&gt; (읽기 / 쓰기).</target>
        </trans-unit>
        <trans-unit id="4a7841fe30d1103325f6249de23cba34804bfa4e" translate="yes" xml:space="preserve">
          <source>A reader should report an error if a field-count word is neither -1 nor the expected number of columns. This provides an extra check against somehow getting out of sync with the data.</source>
          <target state="translated">필드 개수 단어가 -1도 아니고 예상되는 열 수도 아닌 경우 오류를보고해야합니다. 이것은 어떻게 든 데이터와 동기화되지 않는지에 대한 추가 검사를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fddf89d1b48df3d1a7d816db398c1f9bc279cad0" translate="yes" xml:space="preserve">
          <source>A record can have one of the seven formats</source>
          <target state="translated">레코드는 7 가지 형식 중 하나를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="755da3745b4f352a5f0983d774febfd9dd4f8a2e" translate="yes" xml:space="preserve">
          <source>A record can have several formats:</source>
          <target state="translated">레코드는 여러 형식을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b600abb4523a0f2e29ac983d05c8a91aade45f9" translate="yes" xml:space="preserve">
          <source>A recursive &lt;code&gt;DROP COLUMN&lt;/code&gt; operation will remove a descendant table's column only if the descendant does not inherit that column from any other parents and never had an independent definition of the column. A nonrecursive &lt;code&gt;DROP COLUMN&lt;/code&gt; (i.e., &lt;code&gt;ALTER TABLE ONLY ... DROP COLUMN&lt;/code&gt;) never removes any descendant columns, but instead marks them as independently defined rather than inherited. A nonrecursive &lt;code&gt;DROP COLUMN&lt;/code&gt; command will fail for a partitioned table, because all partitions of a table must have the same columns as the partitioning root.</source>
          <target state="translated">재귀 &lt;code&gt;DROP COLUMN&lt;/code&gt; 작업은 하위 항목이 다른 상위 항목에서 해당 열을 상속하지 않고 해당 열에 대한 독립적 인 정의가없는 경우에만 하위 테이블의 열을 제거합니다. 비 재귀 &lt;code&gt;DROP COLUMN&lt;/code&gt; (즉, &lt;code&gt;ALTER TABLE ONLY ... DROP COLUMN&lt;/code&gt; )은 하위 열을 제거하지 않고 상속되지 않고 독립적으로 정의 된 것으로 표시합니다. 재귀 &lt;code&gt;DROP COLUMN&lt;/code&gt; 테이블의 모든 파티션은 파티션 루트와 같은 열이 있어야하기 때문에 명령은, 파티션 테이블에 대한 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c8e116c04f64e1769d84da7554d28932fe4d3963" translate="yes" xml:space="preserve">
          <source>A regular expression is a character sequence that is an abbreviated definition of a set of strings (a &lt;em&gt;regular set&lt;/em&gt;). A string is said to match a regular expression if it is a member of the regular set described by the regular expression. As with &lt;code&gt;LIKE&lt;/code&gt;, pattern characters match string characters exactly unless they are special characters in the regular expression language &amp;mdash; but regular expressions use different special characters than &lt;code&gt;LIKE&lt;/code&gt; does. Unlike &lt;code&gt;LIKE&lt;/code&gt; patterns, a regular expression is allowed to match anywhere within a string, unless the regular expression is explicitly anchored to the beginning or end of the string.</source>
          <target state="translated">정규식은 문자열 집합 ( &lt;em&gt;일반 집합&lt;/em&gt; ) 의 약어 정의 인 문자 시퀀스입니다 . 문자열은 정규식으로 설명 된 정규 세트의 멤버 인 경우 정규식과 일치한다고합니다. &lt;code&gt;LIKE&lt;/code&gt; 와 마찬가지로 패턴 문자는 정규식 언어의 특수 문자가 아닌 한 문자열 문자와 정확히 일치하지만 정규식은 &lt;code&gt;LIKE&lt;/code&gt; 와 다른 특수 문자를 사용 합니다. &lt;code&gt;LIKE&lt;/code&gt; 패턴 과 달리 정규식이 문자열의 시작 또는 끝에 명시 적으로 고정되어 있지 않은 경우 정규식은 문자열 내 어디에서나 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bcf2029d3dfa5827a2882665f99b1d027b1662c" translate="yes" xml:space="preserve">
          <source>A regular expression is defined as one or more &lt;em&gt;branches&lt;/em&gt;, separated by &lt;code&gt;|&lt;/code&gt;. It matches anything that matches one of the branches.</source>
          <target state="translated">정규식은 하나 이상의 &lt;em&gt;분기&lt;/em&gt; 로 정의 되며 &lt;code&gt;|&lt;/code&gt; . 가지 중 하나와 일치하는 항목과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3ee887f7d2952dfa9f7859c97d7cc185154f3579" translate="yes" xml:space="preserve">
          <source>A request sent by a client to a &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;backend&lt;/a&gt;, usually to return results or to modify data on the database.</source>
          <target state="translated">일반적으로 결과를 반환하거나 데이터베이스의 데이터를 수정하기 위해 클라이언트가 &lt;a href=&quot;glossary#GLOSSARY-BACKEND&quot;&gt;백엔드로&lt;/a&gt; 보내는 요청 입니다.</target>
        </trans-unit>
        <trans-unit id="55280929ef651951f4ea5727fbd13d553ba423e3" translate="yes" xml:space="preserve">
          <source>A restriction on the values of data allowed within a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;, or in attributes of a &lt;em&gt;domain&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 또는 &lt;em&gt;도메인&lt;/em&gt; 속성에서 허용되는 데이터 값에 대한 제한입니다 .</target>
        </trans-unit>
        <trans-unit id="6f4f1bec4e67db6d8c109c21ce30fc24feb18e6d" translate="yes" xml:space="preserve">
          <source>A rich set of functions and operators is available to perform various geometric operations such as scaling, translation, rotation, and determining intersections. They are explained in &lt;a href=&quot;functions-geometry&quot;&gt;Section 9.11&lt;/a&gt;.</source>
          <target state="translated">스케일링, 변환, 회전 및 교차점 결정과 같은 다양한 형상 작업을 수행 할 수있는 다양한 기능과 연산자를 사용할 수 있습니다. 그것들은 &lt;a href=&quot;functions-geometry&quot;&gt;섹션 9.11&lt;/a&gt; 에서 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd3e55f45b03c0434f66fdb4c772115d77e89a86" translate="yes" xml:space="preserve">
          <source>A role can also have role-specific defaults for many of the run-time configuration settings described in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. For example, if for some reason you want to disable index scans (hint: not a good idea) anytime you connect, you can use:</source>
          <target state="translated">역할은 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장에&lt;/a&gt; 설명 된 많은 런타임 구성 설정에 대한 역할 별 기본값을 가질 수도 있습니다 . 예를 들어, 어떤 이유로 든 연결할 때마다 인덱스 스캔을 비활성화하려면 (힌트 : 좋지 않은 아이디어) 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f70d4edcc88d0b7db0593c0dc96e77fa856833c" translate="yes" xml:space="preserve">
          <source>A role can also have role-specific defaults for many of the run-time configuration settings described in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;. For example, if for some reason you want to disable index scans (hint: not a good idea) anytime you connect, you can use:</source>
          <target state="translated">역할은 &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;19 장에&lt;/a&gt; 설명 된 많은 런타임 구성 설정에 대한 역할 별 기본값을 가질 수도 있습니다 . 예를 들어, 어떤 이유로 연결할 때마다 인덱스 스캔을 비활성화하려는 경우 (힌트 : 좋지 않음) 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1819e27998d44ae23e1be32dd84afd40392e29ad" translate="yes" xml:space="preserve">
          <source>A role cannot be removed if it is still referenced in any database of the cluster; an error will be raised if so. Before dropping the role, you must drop all the objects it owns (or reassign their ownership) and revoke any privileges the role has been granted on other objects. The &lt;a href=&quot;sql-reassign-owned&quot;&gt;REASSIGN OWNED&lt;/a&gt; and &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; commands can be useful for this purpose; see &lt;a href=&quot;role-removal&quot;&gt;Section 21.4&lt;/a&gt; for more discussion.</source>
          <target state="translated">클러스터의 데이터베이스에서 여전히 참조되는 역할은 제거 할 수 없습니다. 그렇다면 오류가 발생합니다. 역할을 삭제하기 전에 자신이 소유 한 모든 개체를 삭제 (또는 소유권을 다시 할당)하고 다른 개체에 역할이 부여한 권한을 취소해야합니다. &lt;a href=&quot;sql-reassign-owned&quot;&gt;재 할당 소유&lt;/a&gt; 및 &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP 소유&lt;/a&gt; 명령은이 목적을 위해 유용 할 수있다; 자세한 내용 &lt;a href=&quot;role-removal&quot;&gt;은 21.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca7ed328c6182a99c2ad02ba1bf771cc523959b3" translate="yes" xml:space="preserve">
          <source>A role must be explicitly given permission to create databases (except for superusers, since those bypass all permission checks). To create such a role, use &lt;code&gt;CREATE ROLE name CREATEDB&lt;/code&gt;.</source>
          <target state="translated">데이터베이스를 생성 할 수있는 권한을 명시 적으로 부여해야합니다 (슈퍼 유저는 모든 권한 검사를 무시하므로). 이러한 역할을 작성하려면 &lt;code&gt;CREATE ROLE name CREATEDB&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d62d4d6cefafa0c4a7b229d226042d5cdbe21812" translate="yes" xml:space="preserve">
          <source>A role must be explicitly given permission to create more roles (except for superusers, since those bypass all permission checks). To create such a role, use &lt;code&gt;CREATE ROLE name CREATEROLE&lt;/code&gt;. A role with &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can alter and drop other roles, too, as well as grant or revoke membership in them. However, to create, alter, drop, or change membership of a superuser role, superuser status is required; &lt;code&gt;CREATEROLE&lt;/code&gt; is insufficient for that.</source>
          <target state="translated">역할에는 더 많은 역할을 생성 할 수있는 권한이 명시 적으로 부여되어야합니다 (수퍼 유저는 모든 권한 검사를 무시하므로 제외). 이러한 역할을 작성하려면 &lt;code&gt;CREATE ROLE name CREATEROLE&lt;/code&gt; . &lt;code&gt;CREATEROLE&lt;/code&gt; 권한이 있는 역할은 다른 역할도 변경 및 삭제하고 구성원 자격을 부여하거나 취소 할 수 있습니다. 그러나 수퍼 유저 역할의 멤버 자격을 생성, 변경, 삭제 또는 변경하려면 수퍼 유저 상태가 필요합니다. &lt;code&gt;CREATEROLE&lt;/code&gt; 로는 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17ba5cb05b3fc9de95da7091b339d5cf7b10fc50" translate="yes" xml:space="preserve">
          <source>A role must explicitly be given permission to initiate streaming replication (except for superusers, since those bypass all permission checks). A role used for streaming replication must have &lt;code&gt;LOGIN&lt;/code&gt; permission as well. To create such a role, use &lt;code&gt;CREATE ROLE name REPLICATION LOGIN&lt;/code&gt;.</source>
          <target state="translated">스트리밍 복제를 시작할 수있는 권한이 명시 적으로 부여되어야합니다 (슈퍼 유저는 모든 권한 검사를 무시하므로). 스트리밍 복제에 사용되는 역할에는 &lt;code&gt;LOGIN&lt;/code&gt; 권한도 있어야합니다 . 이러한 역할을 작성하려면 &lt;code&gt;CREATE ROLE name REPLICATION LOGIN&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="94be28bc6eb3b4ca303ced8b07cef3c876649a6d" translate="yes" xml:space="preserve">
          <source>A role's attributes can be modified after creation with &lt;code&gt;ALTER ROLE&lt;/code&gt;. See the reference pages for the &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; and &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; commands for details.</source>
          <target state="translated">&lt;code&gt;ALTER ROLE&lt;/code&gt; 로 생성 한 후 역할 속성을 수정할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;sql-createrole&quot;&gt;CREATE ROLE&lt;/a&gt; 및 &lt;a href=&quot;sql-alterrole&quot;&gt;ALTER ROLE&lt;/a&gt; 명령에 대한 참조 페이지를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="081acf24bd36c70b53212a425e34d472f83362f1" translate="yes" xml:space="preserve">
          <source>A row constructor</source>
          <target state="translated">행 생성자</target>
        </trans-unit>
        <trans-unit id="22f30213b82e4ac8580d06b76fb30db617ce4ae6" translate="yes" xml:space="preserve">
          <source>A row constructor can include the syntax &lt;code&gt;rowvalue&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt;, which will be expanded to a list of the elements of the row value, just as occurs when the &lt;code&gt;.*&lt;/code&gt; syntax is used at the top level of a &lt;code&gt;SELECT&lt;/code&gt; list (see &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt;). For example, if table &lt;code&gt;t&lt;/code&gt; has columns &lt;code&gt;f1&lt;/code&gt; and &lt;code&gt;f2&lt;/code&gt;, these are the same:</source>
          <target state="translated">행 생성자는 &lt;code&gt;.*&lt;/code&gt; 구문이 &lt;code&gt;SELECT&lt;/code&gt; 목록 의 최상위 레벨에서 사용될 때 발생하는 것과 같이 행 값의 요소 목록으로 확장되는 &lt;code&gt;rowvalue&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; 구문을 포함 할 수 있습니다 ( &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;8.16.5 절&lt;/a&gt; 참조). ). 예를 들어, 테이블 &lt;code&gt;t&lt;/code&gt; 에 열 &lt;code&gt;f1&lt;/code&gt; 및 &lt;code&gt;f2&lt;/code&gt; 가 있으면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f65566297d0cf76754b5ffd2e69f3d748460cda5" translate="yes" xml:space="preserve">
          <source>A row constructor is an expression that builds a row value (also called a composite value) using values for its member fields. A row constructor consists of the key word &lt;code&gt;ROW&lt;/code&gt;, a left parenthesis, zero or more expressions (separated by commas) for the row field values, and finally a right parenthesis. For example:</source>
          <target state="translated">행 생성자는 멤버 필드의 값을 사용하여 행 값 (복합 값이라고도 함)을 작성하는 표현식입니다. 행 생성자는 키워드 &lt;code&gt;ROW&lt;/code&gt; , 왼쪽 괄호, 행 필드 값에 대한 0 개 이상의 표현식 (쉼표로 구분) 및 마지막으로 오른쪽 괄호로 구성됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e083a9bfabe61aa93820ae695a4040f7ab7fb65b" translate="yes" xml:space="preserve">
          <source>A rule has significantly more overhead than a trigger, but the overhead is paid once per query rather than once per row, so this method might be advantageous for bulk-insert situations. In most cases, however, the trigger method will offer better performance.</source>
          <target state="translated">규칙은 트리거보다 상당히 많은 오버 헤드를 갖지만 오버 헤드는 행당 한 번이 아니라 쿼리 당 한 번 지불되므로이 방법은 대량 삽입 상황에 유리할 수 있습니다. 그러나 대부분의 경우 트리거 방법이 더 나은 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3a8ed465468f0b09e900dc84f22e1ad03222e742" translate="yes" xml:space="preserve">
          <source>A safe value can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_multixact/members&lt;/code&gt; under the data directory, adding one, and then multiplying by 52352 (0xCC80). The file names are in hexadecimal. There is no simple recipe such as the ones for other options of appending zeroes.</source>
          <target state="translated">데이터 디렉토리 아래의 &lt;code&gt;pg_multixact/members&lt;/code&gt; 디렉토리에서 숫자가 가장 큰 파일 이름을 찾아서 하나를 추가 한 다음 52352 (0xCC80)를 곱하여 안전한 값을 판별 할 수 있습니다 . 파일 이름은 16 진수입니다. 0을 추가하는 다른 옵션과 같은 간단한 레시피는 없습니다.</target>
        </trans-unit>
        <trans-unit id="427cc987ada87144cf5033e51fd5ca57fac98875" translate="yes" xml:space="preserve">
          <source>A safe value can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_xact&lt;/code&gt; under the data directory, adding one, and then multiplying by 1048576 (0x100000). Note that the file names are in hexadecimal. It is usually easiest to specify the option value in hexadecimal too. For example, if &lt;code&gt;0011&lt;/code&gt; is the largest entry in &lt;code&gt;pg_xact&lt;/code&gt;, &lt;code&gt;-x 0x1200000&lt;/code&gt; will work (five trailing zeroes provide the proper multiplier).</source>
          <target state="translated">데이터 디렉토리 아래의 &lt;code&gt;pg_xact&lt;/code&gt; 디렉토리에서 가장 큰 파일 이름을 찾아서 하나를 추가 한 다음 1048576 (0x100000)을 곱하여 안전한 값을 판별 할 수 있습니다 . 파일 이름은 16 진수입니다. 일반적으로 옵션 값을 16 진수로 지정하는 것이 가장 쉽습니다. 예를 들어, &lt;code&gt;0011&lt;/code&gt; 에서 가장 큰 엔트리이다 &lt;code&gt;pg_xact&lt;/code&gt; , &lt;code&gt;-x 0x1200000&lt;/code&gt; (다섯 후미 제로 적절한 배율을 제공하는 것) 일 것이다.</target>
        </trans-unit>
        <trans-unit id="cb05b109b960491956518dbc25a95b68a60bb5b7" translate="yes" xml:space="preserve">
          <source>A safe value for the next multitransaction ID (first part) can be determined by looking for the numerically largest file name in the directory &lt;code&gt;pg_multixact/offsets&lt;/code&gt; under the data directory, adding one, and then multiplying by 65536 (0x10000). Conversely, a safe value for the oldest multitransaction ID (second part of &lt;code&gt;-m&lt;/code&gt;) can be determined by looking for the numerically smallest file name in the same directory and multiplying by 65536. The file names are in hexadecimal, so the easiest way to do this is to specify the option value in hexadecimal and append four zeroes.</source>
          <target state="translated">다음 멀티 &lt;code&gt;pg_multixact/offsets&lt;/code&gt; ID (첫 번째 파트)의 안전한 값 은 데이터 디렉토리 아래의 pg_multixact / offsets 디렉토리에서 숫자가 가장 큰 파일 이름을 찾고 하나를 추가 한 후 65536 (0x10000)을 곱하여 판별 할 수 있습니다 . 반대로, 가장 오래된 다중 트랜잭션 ID ( &lt;code&gt;-m&lt;/code&gt; 의 두 번째 부분)의 안전한 값 은 같은 디렉토리에서 가장 작은 파일 이름을 찾고 65536을 곱하여 판별 할 수 있습니다. 파일 이름은 16 진법이므로 가장 쉬운 방법입니다. 옵션 값을 16 진수로 지정하고 4 개의 0을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="210bab91fc67894e59300e346dd93bb05146f64b" translate="yes" xml:space="preserve">
          <source>A safe value for the oldest transaction ID for which the commit time can be retrieved (first part) can be determined by looking for the numerically smallest file name in the directory &lt;code&gt;pg_commit_ts&lt;/code&gt; under the data directory. Conversely, a safe value for the newest transaction ID for which the commit time can be retrieved (second part) can be determined by looking for the numerically greatest file name in the same directory. The file names are in hexadecimal.</source>
          <target state="translated">커밋 시간을 검색 할 수있는 가장 오래된 트랜잭션 ID의 안전한 값 (첫 번째 부분)은 데이터 디렉토리 아래의 &lt;code&gt;pg_commit_ts&lt;/code&gt; 디렉토리에서 가장 작은 파일 이름을 찾아서 확인할 수 있습니다 . 반대로, 커밋 시간을 검색 할 수있는 최신 트랜잭션 ID의 안전한 값 (두 번째 부분)은 동일한 디렉토리에서 가장 큰 파일 이름을 찾아서 결정할 수 있습니다. 파일 이름은 16 진수입니다.</target>
        </trans-unit>
        <trans-unit id="8c66ea914339b5b34a8487aab28576ebc5ca45da" translate="yes" xml:space="preserve">
          <source>A savepoint is a special mark inside a transaction that allows all commands that are executed after it was established to be rolled back, restoring the transaction state to what it was at the time of the savepoint.</source>
          <target state="translated">저장 점은 트랜잭션 내부에있는 특수 표시로, 설정된 후 실행 된 모든 명령을 롤백하여 트랜잭션 상태를 저장 점 당시의 상태로 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7568eb3ea7434ae7b0d16a00f453676381b783a8" translate="yes" xml:space="preserve">
          <source>A scalar subquery</source>
          <target state="translated">스칼라 하위 쿼리</target>
        </trans-unit>
        <trans-unit id="81af8f2f005c91eb2539d9bedb25765441d8772a" translate="yes" xml:space="preserve">
          <source>A scalar subquery is an ordinary &lt;code&gt;SELECT&lt;/code&gt; query in parentheses that returns exactly one row with one column. (See &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt; for information about writing queries.) The &lt;code&gt;SELECT&lt;/code&gt; query is executed and the single returned value is used in the surrounding value expression. It is an error to use a query that returns more than one row or more than one column as a scalar subquery. (But if, during a particular execution, the subquery returns no rows, there is no error; the scalar result is taken to be null.) The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery. See also &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.22&lt;/a&gt; for other expressions involving subqueries.</source>
          <target state="translated">스칼라 하위 쿼리는 괄호로 묶인 일반적인 &lt;code&gt;SELECT&lt;/code&gt; 쿼리로 한 열로 정확히 하나의 행을 반환합니다. 쿼리 작성에 대한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;7 장을&lt;/a&gt; 참조하십시오 . &lt;code&gt;SELECT&lt;/code&gt; 쿼리가 실행되고 단일 반환 값이 주변 값 식에 사용됩니다. 스칼라 서브 쿼리로 둘 이상의 행 또는 둘 이상의 열을 리턴하는 쿼리를 사용하는 것은 오류입니다. 그러나 특정 실행 중에 하위 쿼리가 행을 반환하지 않으면 오류가 없습니다. 스칼라 결과는 null로 간주됩니다. 하위 쿼리 서브 쿼리와 관련된 다른 표현에 대해서는 &lt;a href=&quot;functions-subquery&quot;&gt;9.22 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0ba5f6cf2c1fcbf75fbd9fbfb66a812b9004a7f" translate="yes" xml:space="preserve">
          <source>A scalar subquery is an ordinary &lt;code&gt;SELECT&lt;/code&gt; query in parentheses that returns exactly one row with one column. (See &lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;Chapter 7&lt;/a&gt; for information about writing queries.) The &lt;code&gt;SELECT&lt;/code&gt; query is executed and the single returned value is used in the surrounding value expression. It is an error to use a query that returns more than one row or more than one column as a scalar subquery. (But if, during a particular execution, the subquery returns no rows, there is no error; the scalar result is taken to be null.) The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery. See also &lt;a href=&quot;functions-subquery&quot;&gt;Section 9.23&lt;/a&gt; for other expressions involving subqueries.</source>
          <target state="translated">스칼라 하위 쿼리는 하나의 열이있는 정확히 하나의 행을 반환하는 괄호 안의 일반 &lt;code&gt;SELECT&lt;/code&gt; 쿼리입니다. ( 쿼리 작성에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;7 장을&lt;/a&gt; 참조하십시오 .) &lt;code&gt;SELECT&lt;/code&gt; 쿼리가 실행되고 단일 반환 값이 주변 값 표현식에 사용됩니다. 둘 이상의 행 또는 둘 이상의 열을 스칼라 하위 쿼리로 반환하는 쿼리를 사용하는 것은 오류입니다. (그러나 특정 실행 중에 하위 쿼리가 행을 반환하지 않으면 오류가 없습니다. 스칼라 결과는 null로 간주됩니다.) 하위 쿼리는 주변 쿼리의 변수를 참조 할 수 있으며, 이는 하나의 평가 중에 상수로 작동합니다. 하위 쿼리의. 하위 쿼리와 관련된 다른 표현식 은 &lt;a href=&quot;functions-subquery&quot;&gt;섹션 9.23&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22189bcf116df43b441c919d8d32eb0f9603b0c4" translate="yes" xml:space="preserve">
          <source>A scan key is the internal representation of a &lt;code&gt;WHERE&lt;/code&gt; clause of the form &lt;code&gt;index_key&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;, where the index key is one of the columns of the index and the operator is one of the members of the operator family associated with that index column. An index scan has zero or more scan keys, which are implicitly ANDed &amp;mdash; the returned tuples are expected to satisfy all the indicated conditions.</source>
          <target state="translated">스캔 키는 &lt;code&gt;index_key&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; 형식 의 &lt;code&gt;WHERE&lt;/code&gt; 절을 내부적으로 표현한 것으로 , 인덱스 키는 인덱스의 열 중 하나이고 연산자는 해당 인덱스 열과 연관된 연산자 패밀리의 멤버 중 하나입니다. 인덱스 스캔에는 0 개 이상의 스캔 키가 있으며 암시 적으로 AND됩니다. 리턴 된 튜플은 표시된 모든 조건을 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="f42378ba798baf455e1545f6ed59407d2afa77b9" translate="yes" xml:space="preserve">
          <source>A schema can only be dropped by its owner or a superuser. Note that the owner can drop the schema (and thereby all contained objects) even if they do not own some of the objects within the schema.</source>
          <target state="translated">스키마는 소유자 또는 수퍼 유저 만 삭제할 수 있습니다. 소유자는 스키마 내에서 일부 오브젝트를 소유하지 않아도 스키마 (및 포함 된 모든 오브젝트)를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="254b4940dad1d633556557588b281f41f26bbd38" translate="yes" xml:space="preserve">
          <source>A schema is a namespace for &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL objects&lt;/a&gt;, which all reside in the same &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt;. Each SQL object must reside in exactly one schema.</source>
          <target state="translated">스키마는 모두 동일한 &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;데이터베이스에&lt;/a&gt; 상주하는 &lt;a href=&quot;glossary#GLOSSARY-SQL-OBJECT&quot;&gt;SQL 개체&lt;/a&gt; 의 네임 스페이스입니다 . 각 SQL 개체는 정확히 하나의 스키마에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6403de1aa8d8ec1e90672c217c0a1e9ee16c135" translate="yes" xml:space="preserve">
          <source>A schema is essentially a namespace: it contains named objects (tables, data types, functions, and operators) whose names can duplicate those of other objects existing in other schemas. Named objects are accessed either by &amp;ldquo;qualifying&amp;rdquo; their names with the schema name as a prefix, or by setting a search path that includes the desired schema(s). A &lt;code&gt;CREATE&lt;/code&gt; command specifying an unqualified object name creates the object in the current schema (the one at the front of the search path, which can be determined with the function &lt;code&gt;current_schema&lt;/code&gt;).</source>
          <target state="translated">스키마는 본질적으로 네임 스페이스입니다. 여기에는 이름이 다른 스키마에 존재하는 다른 개체의 이름과 중복 될 수있는 명명 된 개체 (테이블, 데이터 형식, 함수 및 연산자)가 포함됩니다. 명명 된 개체는 스키마 이름을 접두사로 사용하여 이름을 &quot;자격&quot;하거나 원하는 스키마를 포함하는 검색 경로를 설정하여 액세스 할 수 있습니다. &lt;code&gt;CREATE&lt;/code&gt; 규정되지 않은 오브젝트 이름을 지정하는 명령은 현재 스키마의 객체 (함수로 측정 할 수있는 탐색 경로의 앞에 하나 생성 &lt;code&gt;current_schema&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="896efd5a8d00dc02d53497ffb75c3ac39fb5a4a6" translate="yes" xml:space="preserve">
          <source>A script file contains one or more SQL commands terminated by semicolons. Empty lines and lines beginning with &lt;code&gt;--&lt;/code&gt; are ignored. Script files can also contain &amp;ldquo;meta commands&amp;rdquo;, which are interpreted by pgbench itself, as described below.</source>
          <target state="translated">스크립트 파일에는 세미콜론으로 끝나는 하나 이상의 SQL 명령이 포함됩니다. 빈 줄과 &lt;code&gt;--&lt;/code&gt; 으로 시작하는 줄 은 무시됩니다. 스크립트 파일은 또한 &quot;메타 명령&quot;을 포함 할 수 있으며, 이는 아래 설명 된대로 pgbench 자체에서 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="c4717af9b4226f3b00d724aebfdacf0ab19f7c65" translate="yes" xml:space="preserve">
          <source>A second database, &lt;code&gt;template1&lt;/code&gt;, is also created during database cluster initialization. Whenever a new database is created within the cluster, &lt;code&gt;template1&lt;/code&gt; is essentially cloned. This means that any changes you make in &lt;code&gt;template1&lt;/code&gt; are propagated to all subsequently created databases. Because of this, avoid creating objects in &lt;code&gt;template1&lt;/code&gt; unless you want them propagated to every newly created database. More details appear in &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt;.</source>
          <target state="translated">데이터베이스 클러스터 초기화 중에 두 번째 데이터베이스 인 &lt;code&gt;template1&lt;/code&gt; 도 작성됩니다. 클러스터 내에서 새 데이터베이스가 작성 될 때마다 &lt;code&gt;template1&lt;/code&gt; 이 본질적으로 복제됩니다. 즉, &lt;code&gt;template1&lt;/code&gt; 에서 변경 한 내용 은 이후에 생성 된 모든 데이터베이스에 전파됩니다. 이 때문에 &lt;code&gt;template1&lt;/code&gt; 에서 개체를 새로 생성 된 모든 데이터베이스에 전파하지 않으려면 개체를 만들지 마십시오 . 자세한 내용 &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;은 22.3 절에 나와&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0553fb63d3a8d00dba1af17146ccb321bca9edc" translate="yes" xml:space="preserve">
          <source>A separator (a space or non-letter/non-digit character) in the template string of &lt;code&gt;to_timestamp&lt;/code&gt; and &lt;code&gt;to_date&lt;/code&gt; matches any single separator in the input string or is skipped, unless the &lt;code&gt;FX&lt;/code&gt; option is used. For example, &lt;code&gt;to_timestamp('2000JUN', 'YYYY///MON')&lt;/code&gt; and &lt;code&gt;to_timestamp('2000/JUN', 'YYYY MON')&lt;/code&gt; work, but &lt;code&gt;to_timestamp('2000//JUN', 'YYYY/MON')&lt;/code&gt; returns an error because the number of separators in the input string exceeds the number of separators in the template.</source>
          <target state="translated">&lt;code&gt;to_timestamp&lt;/code&gt; 및 &lt;code&gt;to_date&lt;/code&gt; 의 템플릿 문자열에서 구분 기호 (공백 또는 문자가 아닌 문자 또는 숫자가 아닌 문자) 는 &lt;code&gt;FX&lt;/code&gt; 옵션을 사용 하지 않는 한 입력 문자열의 단일 구분자와 일치하거나 건너 뜁니다 . 예를 들어, &lt;code&gt;to_timestamp('2000JUN', 'YYYY///MON')&lt;/code&gt; 및 &lt;code&gt;to_timestamp('2000/JUN', 'YYYY MON')&lt;/code&gt; 작동하지만 &lt;code&gt;to_timestamp('2000//JUN', 'YYYY/MON')&lt;/code&gt; 는 입력 문자열의 구분 기호 수가 템플릿의 구분 기호 수를 초과하기 때문에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="11592b154f9e554cd84c7343d4d02f52f502b436" translate="yes" xml:space="preserve">
          <source>A sequential scan over this large table takes a long time:</source>
          <target state="translated">이 큰 테이블에 대한 순차적 스캔에는 시간이 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="79af3c162f9318c384ae01ff487ce072e1768dfe" translate="yes" xml:space="preserve">
          <source>A sequential scan will always necessitate a relation-level predicate lock. This can result in an increased rate of serialization failures. It may be helpful to encourage the use of index scans by reducing &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt; and/or increasing &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost&lt;/a&gt;. Be sure to weigh any decrease in transaction rollbacks and restarts against any overall change in query execution time.</source>
          <target state="translated">순차 스캔에는 항상 관계 레벨 술어 잠금이 필요합니다. 이로 인해 직렬화 실패 비율이 증가 할 수 있습니다. 줄여 인덱스 스캔의 사용을 장려하기 위해 도움이 될 수 &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost을&lt;/a&gt; 및 / 또는 증가 &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost을&lt;/a&gt; . 쿼리 실행 시간의 전반적인 변경에 대비하여 트랜잭션 롤백 및 재시작의 감소를 측정하십시오.</target>
        </trans-unit>
        <trans-unit id="c996ff6e0403a4fb8e72d039c933ec1c36020db2" translate="yes" xml:space="preserve">
          <source>A series of documents that define the SQL language.</source>
          <target state="translated">SQL 언어를 정의하는 일련의 문서입니다.</target>
        </trans-unit>
        <trans-unit id="1bfa1c21333697528077114ccbfbc09a0f9f978f" translate="yes" xml:space="preserve">
          <source>A serious limitation of the inheritance feature is that indexes (including unique constraints) and foreign key constraints only apply to single tables, not to their inheritance children. This is true on both the referencing and referenced sides of a foreign key constraint. Thus, in the terms of the above example:</source>
          <target state="translated">상속 기능의 심각한 제한 사항은 인덱스 (고유 제약 조건 포함)와 외래 키 제약 조건이 상속 자식이 아닌 단일 테이블에만 적용된다는 것입니다. 외래 키 제약 조건의 참조 및 참조 측면 모두에 해당됩니다. 따라서 위 예제와 관련하여</target>
        </trans-unit>
        <trans-unit id="b2bd01559e686b7857df249c11b785bd65be39d9" translate="yes" xml:space="preserve">
          <source>A server process, which manages the database files, accepts connections to the database from client applications, and performs database actions on behalf of the clients. The database server program is called &lt;code&gt;postgres&lt;/code&gt;.</source>
          <target state="translated">데이터베이스 파일을 관리하고 클라이언트 응용 프로그램에서 데이터베이스로의 연결을 승인하고 클라이언트 대신 데이터베이스 조치를 수행하는 서버 프로세스. 데이터베이스 서버 프로그램을 &lt;code&gt;postgres&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="eda9a27048331b66fd1707531a40ce77f3ddd8c9" translate="yes" xml:space="preserve">
          <source>A session can be unregistered for a given notification channel with the &lt;code&gt;UNLISTEN&lt;/code&gt; command. A session's listen registrations are automatically cleared when the session ends.</source>
          <target state="translated">&lt;code&gt;UNLISTEN&lt;/code&gt; 명령 을 사용하여 지정된 알림 채널에 대해 세션을 등록 취소 할 수 있습니다 . 세션의 청취 등록은 세션이 종료되면 자동으로 지워집니다.</target>
        </trans-unit>
        <trans-unit id="2159dca873e4422248b8b886c40fce3f04eaaa4b" translate="yes" xml:space="preserve">
          <source>A session running a &lt;code id=&quot;serializable&quot;&gt;SERIALIZABLE&lt;/code&gt; transaction blocks a &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; transaction from acquiring a snapshot until the latter determines that it is safe to avoid taking any predicate locks. See &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt; for more information about serializable and deferrable transactions.</source>
          <target state="translated">&lt;code id=&quot;serializable&quot;&gt;SERIALIZABLE&lt;/code&gt; 트랜잭션을 실행하는 세션 은 &lt;code&gt;SERIALIZABLE READ ONLY DEFERRABLE&lt;/code&gt; 트랜잭션이 조건 자 잠금을 사용하지 않는 것이 안전하다고 판단 할 때까지 스냅 샷을 획득하지 못하도록 차단합니다. 직렬화 가능 및 지연 가능 트랜잭션에 대한 자세한 정보는 &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;13.2.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75b584c1806aab227b279342fcda898366eb0bc1" translate="yes" xml:space="preserve">
          <source>A session will allocate temporary buffers as needed up to the limit given by &lt;code&gt;temp_buffers&lt;/code&gt;. The cost of setting a large value in sessions that do not actually need many temporary buffers is only a buffer descriptor, or about 64 bytes, per increment in &lt;code&gt;temp_buffers&lt;/code&gt;. However if a buffer is actually used an additional 8192 bytes will be consumed for it (or in general, &lt;code&gt;BLCKSZ&lt;/code&gt; bytes).</source>
          <target state="translated">세션은 &lt;code&gt;temp_buffers&lt;/code&gt; 에 의해 제공된 한계까지 필요한만큼 임시 버퍼를 할당 합니다. 실제로 많은 임시 버퍼를 필요로하지 않는 세션에서 큰 값을 설정하는 비용은 &lt;code&gt;temp_buffers&lt;/code&gt; 단위로 버퍼 설명자 또는 약 64 바이트 입니다 . 그러나 실제로 버퍼가 사용되는 경우 추가 8192 바이트 (또는 일반적으로 &lt;code&gt;BLCKSZ&lt;/code&gt; 바이트) 가 추가로 소비됩니다 .</target>
        </trans-unit>
        <trans-unit id="1986f4a7eb9ec7c322dfb6c9c6e1924b057be9e0" translate="yes" xml:space="preserve">
          <source>A set of background processes that routinely perform &lt;a href=&quot;glossary#GLOSSARY-VACUUM&quot;&gt;vacuum&lt;/a&gt; and &lt;a href=&quot;glossary#GLOSSARY-ANALYZE&quot;&gt;analyze&lt;/a&gt; operations.</source>
          <target state="translated">정기적으로 수행 백그라운드 프로세스의 집합 &lt;a href=&quot;glossary#GLOSSARY-VACUUM&quot;&gt;진공&lt;/a&gt; 및 &lt;a href=&quot;glossary#GLOSSARY-ANALYZE&quot;&gt;분석&lt;/a&gt; 작업.</target>
        </trans-unit>
        <trans-unit id="78d05cbafd4652352f5f70c34a9c2c9722aea37c" translate="yes" xml:space="preserve">
          <source>A set of functions and function-like expressions are available for producing XML content from SQL data. As such, they are particularly suitable for formatting query results into XML documents for processing in client applications.</source>
          <target state="translated">SQL 데이터에서 XML 컨텐츠를 생성하기 위해 함수 및 함수 유사 표현식 세트를 사용할 수 있습니다. 따라서 클라이언트 응용 프로그램에서 처리하기 위해 쿼리 결과를 XML 문서로 형식화하는 데 특히 적합합니다.</target>
        </trans-unit>
        <trans-unit id="db5cffdfcc14ae057b50bf32801b87510be72218" translate="yes" xml:space="preserve">
          <source>A set of functions and function-like expressions is available for producing XML content from SQL data. As such, they are particularly suitable for formatting query results into XML documents for processing in client applications.</source>
          <target state="translated">SQL 데이터에서 XML 콘텐츠를 생성하는 데 함수 및 함수와 유사한 식 집합을 사용할 수 있습니다. 따라서 클라이언트 애플리케이션에서 처리하기 위해 쿼리 결과를 XML 문서로 형식화하는 데 특히 적합합니다.</target>
        </trans-unit>
        <trans-unit id="675287b9d3c5bb2ab0654e84d04004c09628b2e2" translate="yes" xml:space="preserve">
          <source>A shorthand notation is provided for specifying two common types of grouping set. A clause of the form</source>
          <target state="translated">두 가지 공통 유형의 그룹화 세트를 지정하기위한 축약 표기법이 제공됩니다. 양식의 절</target>
        </trans-unit>
        <trans-unit id="4eb84b728058fd55ea25770f3f034fccfd80efda" translate="yes" xml:space="preserve">
          <source>A shorthand version of &lt;code&gt;get_raw_page&lt;/code&gt;, for reading from the main fork. Equivalent to &lt;code&gt;get_raw_page(relname, 'main', blkno)&lt;/code&gt;</source>
          <target state="translated">기본 포크에서 읽기위한 &lt;code&gt;get_raw_page&lt;/code&gt; 의 축약 버전입니다 . 상당 &lt;code&gt;get_raw_page(relname, 'main', blkno)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf3b68bae267e9ec8dc713868f0cc42a385b1b59" translate="yes" xml:space="preserve">
          <source>A sign formatted using &lt;code&gt;SG&lt;/code&gt;, &lt;code&gt;PL&lt;/code&gt;, or &lt;code&gt;MI&lt;/code&gt; is not anchored to the number; for example, &lt;code&gt;to_char(-12, 'MI9999')&lt;/code&gt; produces &lt;code&gt;'-&amp;nbsp;&amp;nbsp;12'&lt;/code&gt; but &lt;code&gt;to_char(-12, 'S9999')&lt;/code&gt; produces &lt;code&gt;'&amp;nbsp;&amp;nbsp;-12'&lt;/code&gt;. (The Oracle implementation does not allow the use of &lt;code&gt;MI&lt;/code&gt; before &lt;code&gt;9&lt;/code&gt;, but rather requires that &lt;code&gt;9&lt;/code&gt; precede &lt;code&gt;MI&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;SG&lt;/code&gt; , &lt;code&gt;PL&lt;/code&gt; 또는 &lt;code&gt;MI&lt;/code&gt; 를 사용하여 서식이 지정된 부호 는 숫자에 고정되지 않습니다. 예를 들어, &lt;code&gt;to_char(-12, 'MI9999')&lt;/code&gt; 발생 &lt;code&gt;'-&amp;nbsp;&amp;nbsp;12'&lt;/code&gt; 이지만 &lt;code&gt;to_char(-12, 'S9999')&lt;/code&gt; 생성 &lt;code&gt;'&amp;nbsp;&amp;nbsp;-12'&lt;/code&gt; . (Oracle 구현에서는 &lt;code&gt;9&lt;/code&gt; 이전 에 &lt;code&gt;MI&lt;/code&gt; 를 사용할 수 없지만 오히려 &lt;code&gt;9&lt;/code&gt; 보다 먼저 &lt;code&gt;MI&lt;/code&gt; 를 사용해야합니다 .)</target>
        </trans-unit>
        <trans-unit id="28f22335db260bb1a77d3874ff5a159c8ea0367a" translate="yes" xml:space="preserve">
          <source>A signature is a lossy representation of the indexed attribute(s), and as such is prone to reporting false positives; that is, it may be reported that an element is in the set, when it is not. So index search results must always be rechecked using the actual attribute values from the heap entry. Larger signatures reduce the odds of a false positive and thus reduce the number of useless heap visits, but of course also make the index larger and hence slower to scan.</source>
          <target state="translated">서명은 인덱싱 된 속성을 손실로 표현한 것으로 오 탐지를보고하기 쉽습니다. 즉, 요소가없는 경우 요소가 세트에 있다고보고 될 수 있습니다. 따라서 색인 검색 결과는 항상 힙 항목의 실제 속성 값을 사용하여 다시 확인해야합니다. 시그니처가 클수록 오 탐지 확률이 줄어들어 쓸모없는 힙 방문 횟수가 줄어들지 만 물론 인덱스가 더 커져서 스캔 속도가 느려집니다.</target>
        </trans-unit>
        <trans-unit id="32035573077f021fbb97ad61e501af43e164ab91" translate="yes" xml:space="preserve">
          <source>A similar approach is used in most non-fiction books: terms and concepts that are frequently looked up by readers are collected in an alphabetic index at the end of the book. The interested reader can scan the index relatively quickly and flip to the appropriate page(s), rather than having to read the entire book to find the material of interest. Just as it is the task of the author to anticipate the items that readers are likely to look up, it is the task of the database programmer to foresee which indexes will be useful.</source>
          <target state="translated">대부분의 픽션이 아닌 책에서도 비슷한 방법이 사용됩니다. 독자가 자주 찾는 용어와 개념은 책 끝에 알파벳 순서로 수집됩니다. 관심있는 독자는 관심있는 자료를 찾기 위해 전체 책을 읽을 필요없이 인덱스를 비교적 빠르게 스캔하고 적절한 페이지로 넘길 수 있습니다. 독자가 찾아보기 쉬운 항목을 예상하는 것은 저자의 작업 인 것처럼 데이터베이스 프로그래머가 어떤 인덱스가 유용 할지를 예측하는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="0ce67715832ac88218d019874223da06f72da1b1" translate="yes" xml:space="preserve">
          <source>A similar command will be generated for each new file to be archived.</source>
          <target state="translated">아카이브 할 새 파일마다 유사한 명령이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="3786a908833219f288eb01ce7bf3707543bec989" translate="yes" xml:space="preserve">
          <source>A similar problem occurs with estimation of the cardinality of sets of multiple columns, such as the number of groups that would be generated by a &lt;code&gt;GROUP BY&lt;/code&gt; clause. When &lt;code&gt;GROUP BY&lt;/code&gt; lists a single column, the n-distinct estimate (which is visible as the estimated number of rows returned by the HashAggregate node) is very accurate:</source>
          <target state="translated">&lt;code&gt;GROUP BY&lt;/code&gt; 절에 의해 생성 될 그룹 수와 같이 여러 열 세트의 카디널리티를 추정 할 때도 비슷한 문제가 발생합니다 . 경우 &lt;code&gt;GROUP BY&lt;/code&gt; 는 단일 열로 나열합니다 (HashAggregate 노드에 의해 반환 된 행의 추정값으로서 표시됨)의 n 구별 추정이 매우 정확하다 :</target>
        </trans-unit>
        <trans-unit id="5d9a6505729509f95a09312b10bc6d90c22cf17c" translate="yes" xml:space="preserve">
          <source>A similar result could be accomplished with a join:</source>
          <target state="translated">조인으로 비슷한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37fd7a4a35913776332656300b6e6e873ef35bb0" translate="yes" xml:space="preserve">
          <source>A simple GIN index on the &lt;code&gt;jdoc&lt;/code&gt; column can support this query. But note that such an index will store copies of every key and value in the &lt;code&gt;jdoc&lt;/code&gt; column, whereas the expression index of the previous example stores only data found under the &lt;code&gt;tags&lt;/code&gt; key. While the simple-index approach is far more flexible (since it supports queries about any key), targeted expression indexes are likely to be smaller and faster to search than a simple index.</source>
          <target state="translated">&lt;code&gt;jdoc&lt;/code&gt; 열의 간단한 GIN 인덱스 가이 쿼리를 지원할 수 있습니다. 그러나 이러한 색인은 모든 키와 값의 사본을 &lt;code&gt;jdoc&lt;/code&gt; 열에 저장하지만 이전 예제의 표현식 색인은 &lt;code&gt;tags&lt;/code&gt; 키 에서 찾은 데이터 만 저장합니다 . 단순 인덱스 방식은 키에 대한 쿼리를 지원하기 때문에 훨씬 유연하지만 대상 표현식 인덱스는 단순 인덱스보다 작고 검색 속도가 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="1dca6bdccd192c38f7d0a54b1d6c641ecfc4dd07" translate="yes" xml:space="preserve">
          <source>A simple aggregate function is made from one or two ordinary functions: a state transition function &lt;code&gt;sfunc&lt;/code&gt;, and an optional final calculation function &lt;code&gt;ffunc&lt;/code&gt;. These are used as follows:</source>
          <target state="translated">간단한 집계 함수는 하나 또는 두 개의 일반 함수, 상태 전이 함수 &lt;code&gt;sfunc&lt;/code&gt; 및 선택적 최종 계산 함수 &lt;code&gt;ffunc&lt;/code&gt; 로 만들어집니다 . 이들은 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="92c5b995463bf0dd676bdb47c7d11c8b07e323eb" translate="yes" xml:space="preserve">
          <source>A simple example of configuration is:</source>
          <target state="translated">간단한 구성 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0929a1c1d2dae1cb142a133fc2a8d2f50ec36161" translate="yes" xml:space="preserve">
          <source>A simple example of these rules is</source>
          <target state="translated">이러한 규칙의 간단한 예는</target>
        </trans-unit>
        <trans-unit id="a7391df0d455f9692788470d09f0d785e12ddd80" translate="yes" xml:space="preserve">
          <source>A simple kind of query has the form:</source>
          <target state="translated">간단한 쿼리 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9cf93d0e888ede997ab50815543f2f23545f52a" translate="yes" xml:space="preserve">
          <source>A single index scan can only use query clauses that use the index's columns with operators of its operator class and are joined with &lt;code&gt;AND&lt;/code&gt;. For example, given an index on &lt;code&gt;(a, b)&lt;/code&gt; a query condition like &lt;code&gt;WHERE a = 5 AND b = 6&lt;/code&gt; could use the index, but a query like &lt;code&gt;WHERE a = 5 OR b = 6&lt;/code&gt; could not directly use the index.</source>
          <target state="translated">단일 인덱스 스캔은 인덱스의 열을 연산자 클래스의 연산자와 함께 사용하고 &lt;code&gt;AND&lt;/code&gt; 와 결합 된 쿼리 절만 사용할 수 있습니다 . 예를 들어, &lt;code&gt;(a, b)&lt;/code&gt; 에 대한 색인에서 &lt;code&gt;WHERE a = 5 AND b = 6&lt;/code&gt; 같은 조회 조건 은 색인을 사용할 수 있지만 &lt;code&gt;WHERE a = 5 OR b = 6&lt;/code&gt; 과 같은 조회 는 색인을 직접 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="867794d10e104f13c9e8cf27b9206d3b607f31d5" translate="yes" xml:space="preserve">
          <source>A single operator is provided, shown in &lt;a href=&quot;earthdistance#EARTHDISTANCE-POINT-OPERATORS&quot;&gt;Table F.6&lt;/a&gt;.</source>
          <target state="translated">단일 연산자가 &lt;a href=&quot;earthdistance#EARTHDISTANCE-POINT-OPERATORS&quot;&gt;표 F.6&lt;/a&gt; 에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ecaee1e3e7fc4cc75092b8ce7abdaa9285ac3ce" translate="yes" xml:space="preserve">
          <source>A small number of objects, like role, database, and tablespace names, are defined at the cluster level and stored in the &lt;code&gt;pg_global&lt;/code&gt; tablespace. Inside the cluster are multiple databases, which are isolated from each other but can access cluster-level objects. Inside each database are multiple schemas, which contain objects like tables and functions. So the full hierarchy is: cluster, database, schema, table (or some other kind of object, such as a function).</source>
          <target state="translated">역할, 데이터베이스 및 테이블 스페이스 이름과 같은 적은 수의 객체가 클러스터 수준에서 정의되고 &lt;code&gt;pg_global&lt;/code&gt; 테이블 스페이스에 저장됩니다 . 클러스터 내부에는 서로 격리되어 있지만 클러스터 수준 개체에 액세스 할 수있는 여러 데이터베이스가 있습니다. 각 데이터베이스에는 테이블 및 함수와 같은 개체를 포함하는 여러 스키마가 있습니다. 따라서 전체 계층 구조는 클러스터, 데이터베이스, 스키마, 테이블 (또는 함수와 같은 다른 종류의 개체)입니다.</target>
        </trans-unit>
        <trans-unit id="07b58acc01d25d1802019308ca111c48a0d1dd06" translate="yes" xml:space="preserve">
          <source>A software add-on package that can be installed on an &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;instance&lt;/a&gt; to get extra features.</source>
          <target state="translated">추가 기능을 얻기 위해 &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;인스턴스&lt;/a&gt; 에 설치할 수있는 소프트웨어 애드온 패키지입니다 .</target>
        </trans-unit>
        <trans-unit id="5d707a25df7385c415429f55133f3338c29d9eb5" translate="yes" xml:space="preserve">
          <source>A sorting operator. For details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;&lt;code&gt;ORDER BY&lt;/code&gt; Clause&lt;/a&gt;.</source>
          <target state="translated">정렬 연산자 자세한 내용은 &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt; &lt;code&gt;ORDER BY&lt;/code&gt; 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d3b735b7f3eb84460aea32d14769c9c3214fb68" translate="yes" xml:space="preserve">
          <source>A sorting operator. For details see &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY Clause&lt;/a&gt; in the &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; documentation.</source>
          <target state="translated">정렬 연산자. 자세한 내용은 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 문서 의 &lt;a href=&quot;sql-select#SQL-ORDERBY&quot;&gt;ORDER BY 절&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7cf7b59bf27af641775e9434a262775adcfc35c9" translate="yes" xml:space="preserve">
          <source>A special case of a &lt;a href=&quot;glossary#GLOSSARY-UNIQUE-CONSTRAINT&quot;&gt;unique constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; or other &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; that also guarantees that all of the &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt; within the &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-KEY&quot;&gt;primary key&lt;/a&gt; do not have &lt;a href=&quot;glossary#GLOSSARY-NULL&quot;&gt;null&lt;/a&gt; values. As the name implies, there can be only one primary key per table, though it is possible to have multiple unique constraints that also have no null-capable attributes.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-PRIMARY-KEY&quot;&gt;기본 키&lt;/a&gt; 내의 모든 &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;속성에 &lt;/a&gt;&lt;a href=&quot;glossary#GLOSSARY-NULL&quot;&gt;널값&lt;/a&gt; 이 없음을 보장 하는 &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 또는 기타 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; 에 정의 된 &lt;a href=&quot;glossary#GLOSSARY-UNIQUE-CONSTRAINT&quot;&gt;고유 제한 조건&lt;/a&gt; 의 특수한 경우입니다 . 이름에서 알 수 있듯이 테이블 당 하나의 기본 키만있을 수 있지만 널 허용 속성이없는 여러 고유 제한 조건을 가질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c36087e3651816803cdd143451424471a45426ba" translate="yes" xml:space="preserve">
          <source>A special case that's sometimes useful is that &lt;code&gt;&amp;lt;0&amp;gt;&lt;/code&gt; can be used to require that two patterns match the same word.</source>
          <target state="translated">때때로 유용한 특별한 경우는 &lt;code&gt;&amp;lt;0&amp;gt;&lt;/code&gt; 을 사용하여 두 단어가 동일한 단어와 일치하도록 요구할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="80f2af404248705306ef790e8642f0ac8c9028d1" translate="yes" xml:space="preserve">
          <source>A special heuristic is applied to determine whether a deduplication pass in a unique index should take place. It can often skip straight to splitting a leaf page, avoiding a performance penalty from wasting cycles on unhelpful deduplication passes. If you're concerned about the overhead of deduplication, consider setting &lt;code&gt;deduplicate_items = off&lt;/code&gt; selectively. Leaving deduplication enabled in unique indexes has little downside.</source>
          <target state="translated">고유 인덱스에서 중복 제거가 수행되어야하는지 여부를 결정하기 위해 특수 휴리스틱이 적용됩니다. 종종 리프 페이지 분할로 바로 건너 뛸 수 있으므로 도움이되지 않는 중복 제거 단계에서주기 낭비로 인한 성능 저하를 방지 할 수 있습니다. 중복 제거의 오버 헤드가 염려되는 경우 &lt;code&gt;deduplicate_items = off&lt;/code&gt; 선택적으로 설정하는 것이 좋습니다. 고유 인덱스에서 중복 제거를 활성화하면 단점이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="bae37c740b6d35e6443717335fb07bf95869ce22" translate="yes" xml:space="preserve">
          <source>A special mark in the sequence of steps in a &lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;transaction&lt;/a&gt;. Data modifications after this point in time may be reverted to the time of the savepoint.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TRANSACTION&quot;&gt;트랜잭션&lt;/a&gt; 단계 시퀀스의 특수 표시 . 이 시점 이후의 데이터 수정은 저장 점의 시간으로 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50e32359cf0b0268eacae302550072c34383af98" translate="yes" xml:space="preserve">
          <source>A specialized process responsible for executing checkpoints.</source>
          <target state="translated">체크 포인트 실행을 담당하는 특수 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="3a70bf6435ed23a7c676143743be435f017bc889" translate="yes" xml:space="preserve">
          <source>A standby acting as both a receiver and a sender is known as a cascading standby. Standbys that are more directly connected to the master are known as upstream servers, while those standby servers further away are downstream servers. Cascading replication does not place limits on the number or arrangement of downstream servers, though each standby connects to only one upstream server which eventually links to a single master/primary server.</source>
          <target state="translated">수신자와 송신자 모두로 작동하는 대기를 계단식 대기라고합니다. 마스터에 더 직접 연결된 대기를 업스트림 서버라고하며, 대기 서버는 더 멀리 다운 스트림 서버입니다. 계단식 복제는 다운 스트림 서버의 수나 배열에 제한을 두지 않지만 각 대기는 하나의 업스트림 서버에만 연결되어 결국 단일 마스터 / 기본 서버에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="94007c63f83c2bc9effa88a81f497e0678595186" translate="yes" xml:space="preserve">
          <source>A standby server can be implemented using file-based log shipping (&lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;) or streaming replication (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;Section 26.2.5&lt;/a&gt;), or a combination of both. For information on hot standby, see &lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt;.</source>
          <target state="translated">대기 서버는 파일 기반 로그 전달 ( &lt;a href=&quot;warm-standby&quot;&gt;섹션 26.2&lt;/a&gt; ) 또는 스트리밍 복제 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION&quot;&gt;섹션 26.2.5&lt;/a&gt; 참조 ) 또는이 둘의 조합을 사용하여 구현할 수 있습니다 . 핫 스탠바이에 대한 내용은 &lt;a href=&quot;hot-standby&quot;&gt;섹션 26.5를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="326a3efd4c9e08bc49a95748f894324f178b3b88" translate="yes" xml:space="preserve">
          <source>A state that allows a client and a backend to interact, communicating over a &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;connection&lt;/a&gt;.</source>
          <target state="translated">클라이언트와 백엔드가 상호 작용하고 &lt;a href=&quot;glossary#GLOSSARY-CONNECTION&quot;&gt;연결을&lt;/a&gt; 통해 통신 할 수있는 상태입니다 .</target>
        </trans-unit>
        <trans-unit id="4eb6647573ef74b2ae4f7352625efc1c166ad8a5" translate="yes" xml:space="preserve">
          <source>A statement can only see rows committed before it began. This is the default.</source>
          <target state="translated">명령문은 시작하기 전에 커밋 된 행만 볼 수 있습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="4a7d12fc82f3d9f19299237c20a3b225478fd75c" translate="yes" xml:space="preserve">
          <source>A statistics kind to be computed in this statistics object. Currently supported kinds are &lt;code&gt;ndistinct&lt;/code&gt;, which enables n-distinct statistics, &lt;code&gt;dependencies&lt;/code&gt;, which enables functional dependency statistics, and &lt;code&gt;mcv&lt;/code&gt; which enables most-common values lists. If this clause is omitted, all supported statistics kinds are included in the statistics object. For more information, see &lt;a href=&quot;planner-stats#PLANNER-STATS-EXTENDED&quot;&gt;Section 14.2.2&lt;/a&gt; and &lt;a href=&quot;multivariate-statistics-examples&quot;&gt;Section 70.2&lt;/a&gt;.</source>
          <target state="translated">이 통계 개체에서 계산할 통계 종류입니다. 현재 지원되는 종류가 &lt;code&gt;ndistinct&lt;/code&gt; ndistinct 통계를 가능하게하는, &lt;code&gt;dependencies&lt;/code&gt; 함수 종속성 통계를 가능하게하는, 및 &lt;code&gt;mcv&lt;/code&gt; 가장 일반적인 값 목록을 할 수 있습니다. 이 절을 생략하면 지원되는 모든 통계 종류가 통계 개체에 포함됩니다. 자세한 정보는 &lt;a href=&quot;planner-stats#PLANNER-STATS-EXTENDED&quot;&gt;섹션 14.2.2&lt;/a&gt; 및 &lt;a href=&quot;multivariate-statistics-examples&quot;&gt;섹션 70.2를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7afb9dfc5301530890be994c8fdaea740d424bc6" translate="yes" xml:space="preserve">
          <source>A storage structure that keeps metadata about each data page of a table's main fork. The free space map entry for each page stores the amount of free space that's available for future tuples, and is structured to be efficiently searched for available space for a new tuple of a given size.</source>
          <target state="translated">테이블 메인 포크의 각 데이터 페이지에 대한 메타 데이터를 보관하는 스토리지 구조입니다. 각 페이지의 여유 공간 맵 항목은 향후 튜플에 사용할 수있는 여유 공간의 양을 저장하며 지정된 크기의 새 튜플에 대해 사용 가능한 공간을 효율적으로 검색하도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="92d5e9e679ad2ea336688f58c0cc38f17ebb2361" translate="yes" xml:space="preserve">
          <source>A storage structure that keeps metadata about each data page of a table's main fork. The visibility map entry for each page stores two bits: the first one (&lt;code&gt;all-visible&lt;/code&gt;) indicates that all tuples in the page are visible to all transactions. The second one (&lt;code&gt;all-frozen&lt;/code&gt;) indicates that all tuples in the page are marked frozen.</source>
          <target state="translated">테이블 메인 포크의 각 데이터 페이지에 대한 메타 데이터를 보관하는 스토리지 구조입니다. 각 페이지의 가시성 맵 항목은 2 비트를 저장합니다. 첫 번째 비트 ( &lt;code&gt;all-visible&lt;/code&gt; )는 페이지의 모든 튜플이 모든 트랜잭션에 표시됨을 나타냅니다. 두 번째 항목 ( &lt;code&gt;all-frozen&lt;/code&gt; )은 페이지의 모든 튜플이 고정 된 것으로 표시됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="069a72422c3cc6a607349a4e700ca343dee3bf3a" translate="yes" xml:space="preserve">
          <source>A stored array value can be enlarged by assigning to elements not already present. Any positions between those previously present and the newly assigned elements will be filled with nulls. For example, if array &lt;code&gt;myarray&lt;/code&gt; currently has 4 elements, it will have six elements after an update that assigns to &lt;code&gt;myarray[6]&lt;/code&gt;; &lt;code&gt;myarray[5]&lt;/code&gt; will contain null. Currently, enlargement in this fashion is only allowed for one-dimensional arrays, not multidimensional arrays.</source>
          <target state="translated">존재하지 않는 요소에 할당하여 저장된 배열 값을 확대 할 수 있습니다. 이전에 존재했던 요소와 새로 할당 된 요소 사이의 위치는 널로 채워집니다. 예를 들어, 배열 &lt;code&gt;myarray&lt;/code&gt; 에 현재 4 개의 요소가있는 경우 업데이트 후 &lt;code&gt;myarray[6]&lt;/code&gt; 할당 된 6 개의 요소가 있습니다 . &lt;code&gt;myarray[5]&lt;/code&gt; 는 null을 포함합니다. 현재이 방식으로 확대하는 것은 다차원 배열이 아닌 1 차원 배열에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="dffe36d8e51b4ef2ab1fe0c1b3e201415f713820" translate="yes" xml:space="preserve">
          <source>A string constant defining the function; the meaning depends on the language. It can be an internal function name, the path to an object file, an SQL command, or text in a procedural language.</source>
          <target state="translated">함수를 정의하는 문자열 상수. 그 의미는 언어에 따라 다릅니다. 내부 함수 이름, 오브젝트 파일의 경로, SQL 명령 또는 절차 언어의 텍스트 일 ​​수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbfdac594b047310ca108ad639b27f52bf3906ca" translate="yes" xml:space="preserve">
          <source>A string constant defining the procedure; the meaning depends on the language. It can be an internal procedure name, the path to an object file, an SQL command, or text in a procedural language.</source>
          <target state="translated">프로 시저를 정의하는 문자열 상수. 그 의미는 언어에 따라 다릅니다. 내부 프로 시저 이름, 오브젝트 파일의 경로, SQL 명령 또는 절차 언어의 텍스트 일 ​​수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2a8b822478dd09960c81d58138d7e54120409b2" translate="yes" xml:space="preserve">
          <source>A string constant in SQL is an arbitrary sequence of characters bounded by single quotes (&lt;code&gt;'&lt;/code&gt;), for example &lt;code&gt;'This is a string'&lt;/code&gt;. To include a single-quote character within a string constant, write two adjacent single quotes, e.g., &lt;code&gt;'Dianne''s horse'&lt;/code&gt;. Note that this is &lt;em&gt;not&lt;/em&gt; the same as a double-quote character (&lt;code&gt;&quot;&lt;/code&gt;).</source>
          <target state="translated">SQL의 문자열 상수는 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; )로 묶인 임의의 문자 시퀀스입니다 ( 예 : &lt;code&gt;'This is a string'&lt;/code&gt; . 문자열 상수 내에 작은 따옴표 문자를 포함 시키려면 두 개의 인접한 작은 따옴표 (예 : &lt;code&gt;'Dianne''s horse'&lt;/code&gt; 쓰십시오 . 이것은 큰 따옴표 문자 ( &lt;code&gt;&quot;&lt;/code&gt; ) 와 동일 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9740675c09c16dac87aea8ba937f0db10ddc9e95" translate="yes" xml:space="preserve">
          <source>A string literal representing the textual label associated with one value of an enum type.</source>
          <target state="translated">열거 형 유형의 하나의 값과 연관된 텍스트 레이블을 나타내는 문자열 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="349698cab225818ce6aaeac8a591649416d8d5ab" translate="yes" xml:space="preserve">
          <source>A string of the form &lt;code&gt;&lt;em&gt;n&lt;/em&gt;$&lt;/code&gt; where &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; is the index of the argument to print. Index 1 means the first argument after &lt;em&gt;&lt;code&gt;formatstr&lt;/code&gt;&lt;/em&gt;. If the &lt;em&gt;&lt;code&gt;position&lt;/code&gt;&lt;/em&gt; is omitted, the default is to use the next argument in sequence.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;n&lt;/em&gt;$&lt;/code&gt; 형식의 문자열. 여기서 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; 은 인쇄 할 인수의 인덱스입니다. 인덱스 1은 &lt;em&gt; &lt;code&gt;formatstr&lt;/code&gt; &lt;/em&gt; 다음의 첫 번째 인수를 의미합니다 . 상기 중간 &lt;em&gt; &lt;code&gt;position&lt;/code&gt; &lt;/em&gt; 생략, 기본은 순서대로 다음 인수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b5b7ed5b9f283f907a7fca459d4258127f634e3" translate="yes" xml:space="preserve">
          <source>A string of the form &lt;code&gt;n$&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the index of the argument to print. Index 1 means the first argument after &lt;code&gt;formatstr&lt;/code&gt;. If the &lt;code&gt;position&lt;/code&gt; is omitted, the default is to use the next argument in sequence.</source>
          <target state="translated">&lt;code&gt;n$&lt;/code&gt; 형식의 문자열. 여기서 &lt;code&gt;n&lt;/code&gt; 은 인쇄 할 인수의 인덱스입니다. 인덱스 1은 &lt;code&gt;formatstr&lt;/code&gt; 다음의 첫 번째 인수를 의미합니다 . 상기 중간 &lt;code&gt;position&lt;/code&gt; 생략, 기본은 순서대로 다음 인수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ddfb60a35b54b4a543c700ebe6924626aa1923e3" translate="yes" xml:space="preserve">
          <source>A string-like syntax is used for working with string types and for working with complex extension types. Strings with unspecified type are matched with likely operator candidates.</source>
          <target state="translated">문자열 형식의 구문은 문자열 형식 작업 및 복잡한 확장 형식 작업에 사용됩니다. 지정되지 않은 유형의 문자열은 가능한 연산자 후보와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1cc21b370e49b36cc3877fbc8b204fee390f5ba0" translate="yes" xml:space="preserve">
          <source>A sub-&lt;code&gt;SELECT&lt;/code&gt; can appear in the &lt;code&gt;FROM&lt;/code&gt; clause. This acts as though its output were created as a temporary table for the duration of this single &lt;code&gt;SELECT&lt;/code&gt; command. Note that the sub-&lt;code&gt;SELECT&lt;/code&gt; must be surrounded by parentheses, and an alias &lt;em&gt;must&lt;/em&gt; be provided for it. A &lt;a href=&quot;sql-values&quot;&gt;VALUES&lt;/a&gt; command can also be used here.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절 에 하위 &lt;code&gt;SELECT&lt;/code&gt; 가 나타날 수 있습니다 . 이는 단일 &lt;code&gt;SELECT&lt;/code&gt; 명령 동안 출력이 임시 테이블로 작성된 것처럼 작동합니다 . 하위 &lt;code&gt;SELECT&lt;/code&gt; 는 괄호로 묶어야하며 별명 &lt;em&gt;을&lt;/em&gt; 제공 &lt;em&gt;해야&lt;/em&gt; 합니다. &lt;a href=&quot;sql-values&quot;&gt;VALUES의&lt;/a&gt; 명령은 여기에도 사용할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="20d744869b3f288cd0f4b443c304ea51738904ae" translate="yes" xml:space="preserve">
          <source>A subquery can also be a &lt;code&gt;VALUES&lt;/code&gt; list:</source>
          <target state="translated">하위 쿼리는 &lt;code&gt;VALUES&lt;/code&gt; 목록 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="467730923a1355f01d0ecc067917a4e744b3c1af" translate="yes" xml:space="preserve">
          <source>A subscriber node may have multiple subscriptions if desired. It is possible to define multiple subscriptions between a single publisher-subscriber pair, in which case care must be taken to ensure that the subscribed publication objects don't overlap.</source>
          <target state="translated">원하는 경우 가입자 노드는 다수의 가입을 가질 수있다. 단일 게시자-가입자 쌍간에 여러 구독을 정의 할 수 있습니다.이 경우 구독 한 게시 개체가 겹치지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3b9d35fca34aebbff75a223845b5323b4b90739" translate="yes" xml:space="preserve">
          <source>A subscripted expression</source>
          <target state="translated">첨 자식</target>
        </trans-unit>
        <trans-unit id="e3de42d209ab44c2b82ef6de9aa6e4c065c039e8" translate="yes" xml:space="preserve">
          <source>A subscription can only be dropped by a superuser.</source>
          <target state="translated">수퍼 유저 만 구독을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aba51cc9b50b3a680d08e5aa1b132f7c7c53586" translate="yes" xml:space="preserve">
          <source>A substitute name for &lt;code&gt;table_name&lt;/code&gt;. When an alias is provided, it completely hides the actual name of the table. This is particularly useful when &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; targets a table named &lt;code&gt;excluded&lt;/code&gt;, since that will otherwise be taken as the name of the special table representing rows proposed for insertion.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; 의 대체 이름입니다 . 별칭이 제공되면 테이블의 실제 이름이 완전히 숨겨집니다. 이것은 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 가 &lt;code&gt;excluded&lt;/code&gt; 라는 테이블을 대상으로 할 때 특히 유용합니다. 그렇지 않으면 삽입을 위해 제안 된 행을 나타내는 특수 테이블의 이름으로 사용되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1a3b95411aa0d3922856aa0c08c5b45d4d583913" translate="yes" xml:space="preserve">
          <source>A substitute name for the &lt;code&gt;FROM&lt;/code&gt; item containing the alias. An alias is used for brevity or to eliminate ambiguity for self-joins (where the same table is scanned multiple times). When an alias is provided, it completely hides the actual name of the table or function; for example given &lt;code&gt;FROM foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;SELECT&lt;/code&gt; must refer to this &lt;code&gt;FROM&lt;/code&gt; item as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;. If an alias is written, a column alias list can also be written to provide substitute names for one or more columns of the table.</source>
          <target state="translated">별명을 포함하는 &lt;code&gt;FROM&lt;/code&gt; 항목 의 대체 이름입니다 . 별명은 간결성을 위해 또는 동일한 테이블이 여러 번 스캔되는 자체 조인의 모호성을 제거하는 데 사용됩니다. 별명을 제공하면 테이블 또는 함수의 실제 이름이 완전히 숨겨집니다. 예를 들어 , &lt;code&gt;FROM foo AS f&lt;/code&gt; 가 주어지면 &lt;code&gt;SELECT&lt;/code&gt; 의 나머지 부분은 이 &lt;code&gt;FROM&lt;/code&gt; 항목을 &lt;code&gt;foo&lt;/code&gt; 가 아닌 &lt;code&gt;f&lt;/code&gt; 로 참조해야합니다 . 별명이 작성되면 열 별명리스트를 작성하여 테이블의 하나 이상의 열에 대한 대체 이름을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b6a0087f5676053b92594d5853d2ef232106666" translate="yes" xml:space="preserve">
          <source>A substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, given &lt;code&gt;DELETE FROM foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;DELETE&lt;/code&gt; statement must refer to this table as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">대상 테이블의 대체 이름입니다. 별칭이 제공되면 테이블의 실제 이름이 완전히 숨겨집니다. 예를 들어, &lt;code&gt;DELETE FROM foo AS f&lt;/code&gt; 가 주어지면 나머지 &lt;code&gt;DELETE&lt;/code&gt; 문은이 테이블을 &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt; 로 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4c430b6c82238597e098d25669857d482151c353" translate="yes" xml:space="preserve">
          <source>A substitute name for the target table. When an alias is provided, it completely hides the actual name of the table. For example, given &lt;code&gt;UPDATE foo AS f&lt;/code&gt;, the remainder of the &lt;code&gt;UPDATE&lt;/code&gt; statement must refer to this table as &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">대상 테이블의 대체 이름입니다. 별칭이 제공되면 테이블의 실제 이름이 완전히 숨겨집니다. 예를 들어, &lt;code&gt;UPDATE foo AS f&lt;/code&gt; 가 주어지면 나머지 &lt;code&gt;UPDATE&lt;/code&gt; 문은이 테이블을 &lt;code&gt;f&lt;/code&gt; not &lt;code&gt;foo&lt;/code&gt; 로 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="79a0d38239253966494c7a744510fc637f363e29" translate="yes" xml:space="preserve">
          <source>A successful run will exit with status 0. Exit status 1 indicates static problems such as invalid command-line options. Errors during the run such as database errors or problems in the script will result in exit status 2. In the latter case, pgbench will print partial results.</source>
          <target state="translated">성공적인 실행은 상태 0으로 종료됩니다. 종료 상태 1은 유효하지 않은 명령 행 옵션과 같은 정적 문제를 나타냅니다. 데이터베이스 오류나 스크립트 문제와 같은 실행 중 오류가 발생하면 종료 상태 2가됩니다. 후자의 경우 pgbench는 부분 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="81738814316428e9e33dbf3e06dfac5985eb834b" translate="yes" xml:space="preserve">
          <source>A superuser may override this check on a per-user-mapping basis by setting the user mapping option &lt;code&gt;password_required 'false'&lt;/code&gt;, e.g.,</source>
          <target state="translated">수퍼 유저는 사용자 매핑 옵션 &lt;code&gt;password_required 'false'&lt;/code&gt; 를 설정하여 사용자 별 매핑 기준으로이 검사를 무시할 수 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="00a652a2bcf1b7844eb4e57bf495f13644006240" translate="yes" xml:space="preserve">
          <source>A synchronous replica receiving changes via logical decoding will work in the scope of a single database. Since, in contrast to that, &lt;em&gt;&lt;code&gt;synchronous_standby_names&lt;/code&gt;&lt;/em&gt; currently is server wide, this means this technique will not work properly if more than one database is actively used.</source>
          <target state="translated">논리적 디코딩을 통해 변경 사항을 수신하는 동기 복제본은 단일 데이터베이스 범위에서 작동합니다. 이와는 대조적으로, &lt;em&gt; &lt;code&gt;synchronous_standby_names&lt;/code&gt; 는&lt;/em&gt; 현재 서버 범위이므로 둘 이상의 데이터베이스가 활발하게 사용되는 경우이 기술이 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53732038fc5add15dbcd0175e133d7a901f6ac5b" translate="yes" xml:space="preserve">
          <source>A synchronous standby can be a physical replication standby or a logical replication subscriber. It can also be any other physical or logical WAL replication stream consumer that knows how to send the appropriate feedback messages. Besides the built-in physical and logical replication systems, this includes special programs such as &lt;code&gt;pg_receivewal&lt;/code&gt; and &lt;code&gt;pg_recvlogical&lt;/code&gt; as well as some third-party replication systems and custom programs. Check the respective documentation for details on synchronous replication support.</source>
          <target state="translated">동기 대기는 물리적 복제 대기 또는 논리적 복제 구독자 일 수 있습니다. 적절한 피드백 메시지를 보내는 방법을 알고있는 다른 물리적 또는 논리적 WAL 복제 스트림 소비자 일 수도 있습니다. 내장 된 물리적 및 논리적 복제 시스템 외에도 &lt;code&gt;pg_receivewal&lt;/code&gt; 및 &lt;code&gt;pg_recvlogical&lt;/code&gt; 과 같은 특수 프로그램과 일부 타사 복제 시스템 및 사용자 정의 프로그램이 포함됩니다. 동기식 복제 지원에 대한 자세한 내용은 해당 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ac835affae95f586b86b74d66f86a082fb9c7b5d" translate="yes" xml:space="preserve">
          <source>A table access method handler function must be declared to accept a single argument of type &lt;code&gt;internal&lt;/code&gt; and to return the pseudo-type &lt;code&gt;table_am_handler&lt;/code&gt;. The argument is a dummy value that simply serves to prevent handler functions from being called directly from SQL commands. The result of the function must be a pointer to a struct of type &lt;code&gt;TableAmRoutine&lt;/code&gt;, which contains everything that the core code needs to know to make use of the table access method. The return value needs to be of server lifetime, which is typically achieved by defining it as a &lt;code&gt;static const&lt;/code&gt; variable in global scope. The &lt;code&gt;TableAmRoutine&lt;/code&gt; struct, also called the access method's &lt;em&gt;API struct&lt;/em&gt;, defines the behavior of the access method using callbacks. These callbacks are pointers to plain C functions and are not visible or callable at the SQL level. All the callbacks and their behavior is defined in the &lt;code&gt;TableAmRoutine&lt;/code&gt; structure (with comments inside the struct defining the requirements for callbacks). Most callbacks have wrapper functions, which are documented from the point of view of a user (rather than an implementor) of the table access method. For details, please refer to the &lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/tableam.h;hb=HEAD&quot;&gt;&lt;code&gt;src/include/access/tableam.h&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">&lt;code&gt;internal&lt;/code&gt; 유형의 단일 인수를 승인 하고 의사 유형 &lt;code&gt;table_am_handler&lt;/code&gt; 를 리턴하려면 테이블 액세스 메소드 핸들러 함수를 선언해야합니다 . 인수는 단순히 핸들러 함수가 SQL 명령에서 직접 호출되지 않도록하는 더미 값입니다. 함수의 결과는 &lt;code&gt;TableAmRoutine&lt;/code&gt; 유형의 구조체에 대한 포인터 여야하며 , 여기에는 코어 코드가 테이블 액세스 방법을 사용하기 위해 알아야하는 모든 것이 포함됩니다. 반환 값은 일반적으로 전역 범위에서 &lt;code&gt;static const&lt;/code&gt; 변수 로 정의하여 서버 수명이어야합니다 . &lt;code&gt;TableAmRoutine&lt;/code&gt; 의 구조체, 또한 액세스 메소드의 호출 &lt;em&gt;API 구조체&lt;/em&gt;콜백을 사용하여 액세스 방법의 동작을 정의합니다. 이 콜백은 일반 C 함수에 대한 포인터이며 SQL 수준에서는 표시되거나 호출 할 수 없습니다. 모든 콜백과 그 동작은 &lt;code&gt;TableAmRoutine&lt;/code&gt; 구조에 정의되어 있습니다 (콜백 요구 사항을 정의하는 구조체 안에 주석 포함). 대부분의 콜백에는 랩퍼 함수가 있으며 이는 테이블 액세스 방법의 사용자가 아닌 구현 자의 관점에서 문서화됩니다. 자세한 내용은 &lt;a href=&quot;https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/include/access/tableam.h;hb=HEAD&quot;&gt; &lt;code&gt;src/include/access/tableam.h&lt;/code&gt; &lt;/a&gt; 파일을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="419d15e411a83cc5bd408b7d5b9d3b39c40e3df3" translate="yes" xml:space="preserve">
          <source>A table access method handler is declared to return &lt;code&gt;table_am_handler&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;table_am_handler&lt;/code&gt; 를 반환하도록 테이블 액세스 메서드 처리기가 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ff995032ef85b617d95b6ca1e8cb93045b2fac9" translate="yes" xml:space="preserve">
          <source>A table can have at most one primary key. (There can be any number of unique and not-null constraints, which are functionally almost the same thing, but only one can be identified as the primary key.) Relational database theory dictates that every table must have a primary key. This rule is not enforced by PostgreSQL, but it is usually best to follow it.</source>
          <target state="translated">테이블에는 최대 하나의 기본 키가있을 수 있습니다. (기능적으로 거의 동일한 고유하지만 널이 아닌 제한 조건이 많을 수 있지만, 기본 키로 하나만 식별 될 수 있습니다.) 관계형 데이터베이스 이론에 따르면 모든 테이블에 기본 키가 있어야합니다. 이 규칙은 PostgreSQL에 의해 적용되지 않지만 일반적으로 따르는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a5dd3a29c662f0d5a9fc9f1c03648ba7178abbb4" translate="yes" xml:space="preserve">
          <source>A table can have more than one foreign key constraint. This is used to implement many-to-many relationships between tables. Say you have tables about products and orders, but now you want to allow one order to contain possibly many products (which the structure above did not allow). You could use this table structure:</source>
          <target state="translated">테이블에는 둘 이상의 외래 키 제약 조건이있을 수 있습니다. 테이블 간 다 대다 관계를 구현하는 데 사용됩니다. 제품 및 주문에 대한 테이블이 있지만 이제는 하나의 주문에 많은 제품이 포함될 수 있습니다 (위의 구조에서는 허용되지 않음). 이 테이블 구조를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea2feaef62849b073ab499dff5691a69fec6f5f4" translate="yes" xml:space="preserve">
          <source>A table can inherit from more than one parent table, in which case it has the union of the columns defined by the parent tables. Any columns declared in the child table's definition are added to these. If the same column name appears in multiple parent tables, or in both a parent table and the child's definition, then these columns are &amp;ldquo;merged&amp;rdquo; so that there is only one such column in the child table. To be merged, columns must have the same data types, else an error is raised. Inheritable check constraints and not-null constraints are merged in a similar fashion. Thus, for example, a merged column will be marked not-null if any one of the column definitions it came from is marked not-null. Check constraints are merged if they have the same name, and the merge will fail if their conditions are different.</source>
          <target state="translated">테이블은 둘 이상의 부모 테이블에서 상속 할 수 있으며,이 경우 부모 테이블에 의해 정의 된 열의 합집합이 있습니다. 자식 테이블 정의에 선언 된 모든 열이 여기에 추가됩니다. 동일한 열 이름이 여러 부모 테이블 또는 부모 테이블과 자식 정의 모두에 나타나는 경우 이러한 열은 &quot;병합&quot;되어 자식 테이블에 해당 열이 하나만있게됩니다. 병합하려면 열의 데이터 형식이 같아야합니다. 그렇지 않으면 오류가 발생합니다. 상속 가능한 검사 제한 조건과 널이 아닌 제한 조건이 유사한 방식으로 병합됩니다. 예를 들어, 병합 된 컬럼은 컬럼 정의 중 하나가 널이 아닌 것으로 표시되면 널이 아닌 것으로 표시됩니다. 이름이 동일한 검사 제한 조건이 병합되고 조건이 다른 경우 병합이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b60ab6e47e92c777a5fb70888a73042517cd9738" translate="yes" xml:space="preserve">
          <source>A table cannot have more than 1600 columns. (In practice, the effective limit is usually lower because of tuple-length constraints.)</source>
          <target state="translated">테이블의 열은 1600 개를 초과 할 수 없습니다. 실제로는 유효 길이가 튜플 길이 제약 조건으로 인해 일반적으로 낮습니다.</target>
        </trans-unit>
        <trans-unit id="d9a20219501c53fe0d9df9736a36bbb3c0e01830" translate="yes" xml:space="preserve">
          <source>A table expression allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition and update expressions. This uses the same syntax as the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/a&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table as a &lt;code&gt;from_item&lt;/code&gt; unless you intend a self-join (in which case it must appear with an alias in the &lt;code&gt;from_item&lt;/code&gt;).</source>
          <target state="translated">다른 테이블의 열이 &lt;code&gt;WHERE&lt;/code&gt; 조건 에 나타나고 식을 업데이트 할 수있는 테이블 식입니다. 이것은 &lt;code&gt;SELECT&lt;/code&gt; 문의 &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; &lt;/a&gt; 절과 동일한 구문을 사용합니다 . 예를 들어, 테이블 이름의 별명을 지정할 수 있습니다. 자체 조인을 의도하지 않는 한 대상 테이블을 &lt;code&gt;from_item&lt;/code&gt; 으로 반복하지 마십시오 (이 경우 &lt;code&gt;from_item&lt;/code&gt; 에 별칭과 함께 나타나야 함 ).</target>
        </trans-unit>
        <trans-unit id="9427796f4e0c19b3da10d1c29ad2a87a93a84b6f" translate="yes" xml:space="preserve">
          <source>A table expression allowing columns from other tables to appear in the &lt;code&gt;WHERE&lt;/code&gt; condition. This uses the same syntax as the &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/a&gt; clause of a &lt;code&gt;SELECT&lt;/code&gt; statement; for example, an alias for the table name can be specified. Do not repeat the target table as a &lt;code&gt;from_item&lt;/code&gt; unless you wish to set up a self-join (in which case it must appear with an alias in the &lt;code&gt;from_item&lt;/code&gt;).</source>
          <target state="translated">다른 테이블의 열이 &lt;code&gt;WHERE&lt;/code&gt; 조건 에 표시되도록 허용하는 테이블 식 입니다. 이것은 &lt;code&gt;SELECT&lt;/code&gt; 문의 &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; &lt;/a&gt; 절과 동일한 구문을 사용합니다 . 예를 들어, 테이블 이름의 별명을 지정할 수 있습니다. 자체 조인을 설정하지 않으려면 &lt;code&gt;from_item&lt;/code&gt; 으로 대상 테이블을 반복하지 마십시오 (이 경우 &lt;code&gt;from_item&lt;/code&gt; 에 별칭과 함께 나타나야 함 ).</target>
        </trans-unit>
        <trans-unit id="40d4dec2662223321ee541222a2fb74e1b35e9b6" translate="yes" xml:space="preserve">
          <source>A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable &amp;mdash; it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. This is covered in &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;Chapter 7&lt;/a&gt;. Furthermore, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table. This is a consequence of the mathematical model that underlies SQL but is usually not desirable. Later in this chapter we will see how to deal with this issue.</source>
          <target state="translated">관계형 데이터베이스의 테이블은 종이의 테이블과 매우 유사합니다. 행과 열로 구성됩니다. 열의 수와 순서는 고정되어 있으며 각 열에는 이름이 있습니다. 행 수는 가변적이며 주어진 순간에 저장되는 데이터 양을 반영합니다. SQL은 테이블의 행 순서를 보증하지 않습니다. 테이블을 읽을 때 정렬이 명시 적으로 요청되지 않으면 행이 지정되지 않은 순서로 나타납니다. 이에 대해서는 &lt;a href=&quot;https://www.postgresql.org/docs/12/queries.html&quot;&gt;7 장&lt;/a&gt; 에서 다룹니다 . 또한 SQL은 고유 식별자를 행에 할당하지 않으므로 테이블에 완전히 동일한 행이 여러 개있을 수 있습니다. 이는 SQL의 기초가되는 수학적 모델의 결과이지만 일반적으로 바람직하지 않습니다. 이 장의 뒷부분에서이 문제를 해결하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="d3a09d1c3ee1c32fce111e8e9a61e27e850dce55" translate="yes" xml:space="preserve">
          <source>A table in a relational database is much like a table on paper: It consists of rows and columns. The number and order of the columns is fixed, and each column has a name. The number of rows is variable &amp;mdash; it reflects how much data is stored at a given moment. SQL does not make any guarantees about the order of the rows in a table. When a table is read, the rows will appear in an unspecified order, unless sorting is explicitly requested. This is covered in &lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;Chapter 7&lt;/a&gt;. Furthermore, SQL does not assign unique identifiers to rows, so it is possible to have several completely identical rows in a table. This is a consequence of the mathematical model that underlies SQL but is usually not desirable. Later in this chapter we will see how to deal with this issue.</source>
          <target state="translated">관계형 데이터베이스의 테이블은 종이 위의 테이블과 매우 유사합니다. 행과 열로 구성됩니다. 열의 수와 순서는 고정되어 있으며 각 열에는 이름이 있습니다. 행 수는 가변적이며 주어진 순간에 저장되는 데이터의 양을 반영합니다. SQL은 테이블의 행 순서를 보장하지 않습니다. 테이블을 읽을 때 정렬이 명시 적으로 요청되지 않는 한 행은 지정되지 않은 순서로 나타납니다. 이것은 &lt;a href=&quot;https://www.postgresql.org/docs/13/queries.html&quot;&gt;7 장&lt;/a&gt; 에서 다룹니다 . 또한 SQL은 행에 고유 식별자를 할당하지 않으므로 테이블에 완전히 동일한 행을 여러 개 가질 수 있습니다. 이것은 SQL의 기초가되는 수학적 모델의 결과이지만 일반적으로 바람직하지 않습니다. 이 장의 뒷부분에서이 문제를 다루는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0b7ed2eab9cf794fb325a1b40465300bd26db30b" translate="yes" xml:space="preserve">
          <source>A table reference can be a table name (possibly schema-qualified), or a derived table such as a subquery, a &lt;code&gt;JOIN&lt;/code&gt; construct, or complex combinations of these. If more than one table reference is listed in the &lt;code&gt;FROM&lt;/code&gt; clause, the tables are cross-joined (that is, the Cartesian product of their rows is formed; see below). The result of the &lt;code&gt;FROM&lt;/code&gt; list is an intermediate virtual table that can then be subject to transformations by the &lt;code&gt;WHERE&lt;/code&gt;, &lt;code&gt;GROUP BY&lt;/code&gt;, and &lt;code&gt;HAVING&lt;/code&gt; clauses and is finally the result of the overall table expression.</source>
          <target state="translated">테이블 참조는 테이블 이름 (아마도 스키마 한정)이거나 하위 쿼리, &lt;code&gt;JOIN&lt;/code&gt; 구문 또는 이들의 복잡한 조합 과 같은 파생 테이블 일 수 있습니다. &lt;code&gt;FROM&lt;/code&gt; 절 에 둘 이상의 테이블 참조가 나열 되면 테이블이 교차 결합됩니다 (즉, 행의 카티 전 곱이 형성됨 (아래 참조)). &lt;code&gt;FROM&lt;/code&gt; 목록 의 결과는 &lt;code&gt;WHERE&lt;/code&gt; , &lt;code&gt;GROUP BY&lt;/code&gt; 및 &lt;code&gt;HAVING&lt;/code&gt; 절에 의해 변환 될 수있는 중간 가상 테이블 이며 최종적으로 전체 테이블 표현식의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="8ea15f1133af85b529e072e262c881e0f91d10ea" translate="yes" xml:space="preserve">
          <source>A table that has columns with potentially large entries will have an associated &lt;em&gt;TOAST&lt;/em&gt; table, which is used for out-of-line storage of field values that are too large to keep in the table rows proper. &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltoastrelid&lt;/code&gt; links from a table to its TOAST table, if any. See &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; for more information.</source>
          <target state="translated">잠재적으로 큰 항목이있는 열이있는 테이블 에는 연관된 &lt;em&gt;TOAST&lt;/em&gt; 테이블이 있으며,이 테이블은 테이블 행에 적절하게 유지하기에는 너무 큰 필드 값의 라인 외부 저장에 사용됩니다. &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;reltoastrelid&lt;/code&gt; 는 테이블에서 TOAST 테이블 (있는 경우)로 링크합니다. 자세한 정보는 &lt;a href=&quot;storage-toast&quot;&gt;68.2 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4c16bcd4cf40264715bc5e3b5d07ef4d9afb5816" translate="yes" xml:space="preserve">
          <source>A tablesample method handler is declared to return &lt;code&gt;tsm_handler&lt;/code&gt;.</source>
          <target state="translated">테이블 샘플 메소드 핸들러는 &lt;code&gt;tsm_handler&lt;/code&gt; 를 리턴 하도록 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="816a4cd8c0ed513824b7c88b1bb7cf4571478fb1" translate="yes" xml:space="preserve">
          <source>A tablespace allows superusers to define an alternative location on the file system where the data files containing database objects (such as tables and indexes) can reside.</source>
          <target state="translated">테이블 공간을 통해 수퍼 유저는 파일 및 데이터베이스 개체 (예 : 테이블 및 인덱스)를 포함하는 데이터 파일이 상주 할 수있는 대체 위치를 파일 시스템에서 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="820b586a949a1d02483ccf3a6e05f26f2fdbeced" translate="yes" xml:space="preserve">
          <source>A tablespace can only be dropped by its owner or a superuser. The tablespace must be empty of all database objects before it can be dropped. It is possible that objects in other databases might still reside in the tablespace even if no objects in the current database are using the tablespace. Also, if the tablespace is listed in the &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; setting of any active session, the &lt;code&gt;DROP&lt;/code&gt; might fail due to temporary files residing in the tablespace.</source>
          <target state="translated">테이블 스페이스는 소유자 또는 수퍼 유저 만 삭제할 수 있습니다. 테이블 스페이스는 삭제하기 전에 모든 데이터베이스 오브젝트에서 비어 있어야합니다. 현재 데이터베이스의 오브젝트가 테이블 스페이스를 사용하고 있지 않더라도 다른 데이터베이스의 오브젝트가 여전히 테이블 스페이스에있을 수 있습니다. 또한 테이블 스페이스가 활성 세션 의 &lt;a href=&quot;runtime-config-client#GUC-TEMP-TABLESPACES&quot;&gt;temp_tablespaces&lt;/a&gt; 설정에 나열되면 테이블 스페이스에있는 임시 파일로 인해 &lt;code&gt;DROP&lt;/code&gt; 이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d48bc9df0b7c8031d0790b2f1fc9c85172017b3e" translate="yes" xml:space="preserve">
          <source>A tablespace cannot be used independently of the cluster in which it is defined; see &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;Section 22.6&lt;/a&gt;.</source>
          <target state="translated">테이블 스페이스는 테이블 스페이스가 정의 된 클러스터와 독립적으로 사용될 수 없습니다. &lt;a href=&quot;manage-ag-tablespaces&quot;&gt;섹션 22.6&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="d579dc88e9cdf352d2f344d0841a4b50c6608379" translate="yes" xml:space="preserve">
          <source>A tablespace parameter to be set or reset. Currently, the only available parameters are &lt;code&gt;seq_page_cost&lt;/code&gt;, &lt;code&gt;random_page_cost&lt;/code&gt; and &lt;code&gt;effective_io_concurrency&lt;/code&gt;. Setting either value for a particular tablespace will override the planner's usual estimate of the cost of reading pages from tables in that tablespace, as established by the configuration parameters of the same name (see &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt;). This may be useful if one tablespace is located on a disk which is faster or slower than the remainder of the I/O subsystem.</source>
          <target state="translated">설정하거나 재설정 할 테이블 스페이스 매개 변수입니다. 현재 사용 가능한 유일한 매개 변수는 &lt;code&gt;seq_page_cost&lt;/code&gt; , &lt;code&gt;random_page_cost&lt;/code&gt; 및 &lt;code&gt;effective_io_concurrency&lt;/code&gt; 입니다. 특정 테이블 스페이스에 대한 값을 설정하면 동일한 이름의 구성 매개 변수에 의해 설정된대로 해당 테이블 스페이스의 테이블에서 페이지를 읽는 비용에 대한 플래너의 일반적인 예상 비용이 대체됩니다 ( &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt; , &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt; , &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency 참조&lt;/a&gt; ). 이것은 하나의 테이블 스페이스가 디스크에 위치하여 나머지 I / O 서브 시스템보다 빠르거나 느린 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4c99f85ae41b2644b7b55fc1d2d2a8d62880eaa2" translate="yes" xml:space="preserve">
          <source>A tablespace parameter to be set or reset. Currently, the only available parameters are &lt;code&gt;seq_page_cost&lt;/code&gt;, &lt;code&gt;random_page_cost&lt;/code&gt;, &lt;code&gt;effective_io_concurrency&lt;/code&gt; and &lt;code&gt;maintenance_io_concurrency&lt;/code&gt;. Setting these values for a particular tablespace will override the planner's usual estimate of the cost of reading pages from tables in that tablespace, and the executor's prefetching behavior, as established by the configuration parameters of the same name (see &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt;, &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-IO-CONCURRENCY&quot;&gt;maintenance_io_concurrency&lt;/a&gt;). This may be useful if one tablespace is located on a disk which is faster or slower than the remainder of the I/O subsystem.</source>
          <target state="translated">설정하거나 재설정 할 테이블 스페이스 매개 변수입니다. 현재 사용 가능한 유일한 매개 변수는 &lt;code&gt;seq_page_cost&lt;/code&gt; , &lt;code&gt;random_page_cost&lt;/code&gt; , &lt;code&gt;effective_io_concurrency&lt;/code&gt; 및 &lt;code&gt;maintenance_io_concurrency&lt;/code&gt; 입니다. 특정 테이블 스페이스에 대해 이러한 값을 설정하면 해당 테이블 스페이스의 테이블에서 페이지를 읽는 데 드는 플래너의 일반적인 예상 비용과 동일한 이름의 구성 매개 변수에 의해 설정된 실행 프로그램의 프리 페치 동작이 &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;재정의됩니다&lt;/a&gt; ( seq_page_cost , &lt;a href=&quot;runtime-config-query#GUC-RANDOM-PAGE-COST&quot;&gt;random_page_cost&lt;/a&gt; , &lt;a href=&quot;runtime-config-resource#GUC-EFFECTIVE-IO-CONCURRENCY&quot;&gt;effective_io_concurrency&lt;/a&gt; , &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-IO-CONCURRENCY&quot;&gt;maintenance_io_concurrency 참조).&lt;/a&gt;). 이것은 하나의 테이블 스페이스가 나머지 I / O 하위 시스템보다 빠르거나 느린 디스크에있는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ac97e0fad0b28b51a14115817e32577fe4a0b90" translate="yes" xml:space="preserve">
          <source>A temporary name can be given to tables and complex table references to be used for references to the derived table in the rest of the query. This is called a &lt;em&gt;table alias&lt;/em&gt;.</source>
          <target state="translated">쿼리의 나머지 부분에서 파생 테이블에 대한 참조에 사용되도록 테이블 및 복합 테이블 참조에 임시 이름을 지정할 수 있습니다. 이것을 &lt;em&gt;테이블 별명&lt;/em&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="154e0fcec698de6b2015fa25f68088725ba8e1d2" translate="yes" xml:space="preserve">
          <source>A text search configuration binds a parser together with a set of dictionaries to process the parser's output tokens. For each token type that the parser can return, a separate list of dictionaries is specified by the configuration. When a token of that type is found by the parser, each dictionary in the list is consulted in turn, until some dictionary recognizes it as a known word. If it is identified as a stop word, or if no dictionary recognizes the token, it will be discarded and not indexed or searched for. Normally, the first dictionary that returns a non-&lt;code&gt;NULL&lt;/code&gt; output determines the result, and any remaining dictionaries are not consulted; but a filtering dictionary can replace the given word with a modified word, which is then passed to subsequent dictionaries.</source>
          <target state="translated">텍스트 검색 구성은 구문 분석기의 출력 토큰을 처리하기 위해 구문 분석기를 사전 세트와 함께 바인드합니다. 파서가 반환 할 수있는 각 토큰 유형에 대해 별도의 사전 목록이 구성에 의해 지정됩니다. 파서가 해당 유형의 토큰을 찾으면 일부 사전이이를 알려진 단어로 인식 할 때까지 목록의 각 사전이 차례로 참조됩니다. 중지 단어로 식별되거나 사전이 토큰을 인식하지 않으면 삭제되고 색인화되거나 검색되지 않습니다. 일반적으로 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 출력 을 반환하는 첫 번째 사전이 결과를 결정하고 나머지 사전은 참조하지 않습니다. 그러나 필터링 사전은 주어진 단어를 수정 된 단어로 대체 한 다음 후속 사전으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b660e99784a0c9ca392fa9c70b6890953f937efa" translate="yes" xml:space="preserve">
          <source>A text search configuration specifies all options necessary to transform a document into a &lt;code&gt;tsvector&lt;/code&gt;: the parser to use to break text into tokens, and the dictionaries to use to transform each token into a lexeme. Every call of &lt;code&gt;to_tsvector&lt;/code&gt; or &lt;code&gt;to_tsquery&lt;/code&gt; needs a text search configuration to perform its processing. The configuration parameter &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; specifies the name of the default configuration, which is the one used by text search functions if an explicit configuration parameter is omitted. It can be set in &lt;code&gt;postgresql.conf&lt;/code&gt;, or set for an individual session using the &lt;code&gt;SET&lt;/code&gt; command.</source>
          <target state="translated">텍스트 검색 구성은 문서를 &lt;code&gt;tsvector&lt;/code&gt; 로 변환하는 데 필요한 모든 옵션, 즉 텍스트를 토큰으로 나누는 데 사용하는 구문 분석기와 각 토큰을 렉 세어 로 변환하는 데 사용하는 사전을 지정합니다. &lt;code&gt;to_tsvector&lt;/code&gt; 또는 &lt;code&gt;to_tsquery&lt;/code&gt; 의 모든 호출은 처리를 수행하기 위해 텍스트 검색 구성이 필요합니다. 구성 매개 변수 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; 는 기본 구성의 이름을 지정하는데, 이는 명시 적 구성 매개 변수가 생략 된 경우 텍스트 검색 기능에서 사용되는 이름입니다. &lt;code&gt;postgresql.conf&lt;/code&gt; 에서 설정하거나 &lt;code&gt;SET&lt;/code&gt; 명령을 사용하여 개별 세션에 대해 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbb87e15ef4cfdfbfbbdeb4da5c6a41f2a086081" translate="yes" xml:space="preserve">
          <source>A thesaurus dictionary (sometimes abbreviated as TZ) is a collection of words that includes information about the relationships of words and phrases, i.e., broader terms (BT), narrower terms (NT), preferred terms, non-preferred terms, related terms, etc.</source>
          <target state="translated">동의어 사전 (TZ로 축약 됨)은 단어와 구의 관계에 대한 정보를 포함하는 단어 모음입니다. 즉, 더 넓은 용어 (BT), 더 좁은 용어 (NT), 선호하는 용어, 비선호 용어, 관련 용어, 기타</target>
        </trans-unit>
        <trans-unit id="657570ff202cabc5e9df7f56f8f1f48bd50b5f6f" translate="yes" xml:space="preserve">
          <source>A thesaurus dictionary uses a &lt;em&gt;subdictionary&lt;/em&gt; (which is specified in the dictionary's configuration) to normalize the input text before checking for phrase matches. It is only possible to select one subdictionary. An error is reported if the subdictionary fails to recognize a word. In that case, you should remove the use of the word or teach the subdictionary about it. You can place an asterisk (&lt;code&gt;*&lt;/code&gt;) at the beginning of an indexed word to skip applying the subdictionary to it, but all sample words &lt;em&gt;must&lt;/em&gt; be known to the subdictionary.</source>
          <target state="translated">시소러스 사전이 사용 &lt;em&gt;subdictionary&lt;/em&gt; 구문 일치 검사 전에 입력 텍스트를 정규화 (사전의 구성에 지정된다). 하나의 하위 사전 만 선택할 수 있습니다. 대체 어가 단어를 인식하지 못하면 오류가보고됩니다. 이 경우 단어의 사용을 제거하거나 그 단어에 대한 사전을 가르쳐야합니다. 색인 단어의 시작 부분에 별표 ( &lt;code&gt;*&lt;/code&gt; )를 붙여서 해당 사전을 적용하는 것을 건너 뛸 수 있지만 모든 샘플 단어 &lt;em&gt;를&lt;/em&gt; 해당 사전에 알고 &lt;em&gt;있어야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="555f5a4dff77bb6e52e02e4204a9cef467ac2510" translate="yes" xml:space="preserve">
          <source>A third identifier type used by the system is &lt;code&gt;cid&lt;/code&gt;, or command identifier. This is the data type of the system columns &lt;code&gt;cmin&lt;/code&gt; and &lt;code&gt;cmax&lt;/code&gt;. Command identifiers are also 32-bit quantities.</source>
          <target state="translated">시스템에서 사용하는 세 번째 식별자 유형은 &lt;code&gt;cid&lt;/code&gt; 또는 명령 식별자입니다. 이 시스템 컬럼의 데이터 유형 &lt;code&gt;cmin&lt;/code&gt; 와 &lt;code&gt;cmax&lt;/code&gt; . 명령 식별자도 32 비트입니다.</target>
        </trans-unit>
        <trans-unit id="ea6ae6aa8002700db2a8dea433bfc36222024c69" translate="yes" xml:space="preserve">
          <source>A third possible use for partial indexes does not require the index to be used in queries at all. The idea here is to create a unique index over a subset of a table, as in &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3&lt;/a&gt;. This enforces uniqueness among the rows that satisfy the index predicate, without constraining those that do not.</source>
          <target state="translated">부분 인덱스에 대한 세 번째 가능한 사용은 인덱스가 쿼리에 전혀 사용될 필요가 없습니다. 여기서 아이디어는 &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX3&quot;&gt;Example 11.3&lt;/a&gt; 과 같이 테이블의 하위 집합에 대해 고유 인덱스를 만드는 것 입니다. 이렇게하면 인덱스 술어를 만족시키는 행 중에서 고유하지 않은 행을 제한하지 않고 고유성을 강제합니다.</target>
        </trans-unit>
        <trans-unit id="47db754740c9f2ded7d303bbef7ae69f38fb4dbf" translate="yes" xml:space="preserve">
          <source>A time zone abbreviation, for example &lt;code&gt;PST&lt;/code&gt;. Such a specification merely defines a particular offset from UTC, in contrast to full time zone names which can imply a set of daylight savings transition rules as well. The recognized abbreviations are listed in the &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;Section 51.91&lt;/a&gt;). You cannot set the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; to a time zone abbreviation, but you can use abbreviations in date/time input values and with the &lt;code&gt;AT TIME ZONE&lt;/code&gt; operator.</source>
          <target state="translated">시간대 약어 (예 : &lt;code&gt;PST&lt;/code&gt; ) . 이러한 사양은 일광 절약 전환 규칙 집합을 암시 할 수있는 전체 시간대 이름과 달리 UTC에서 특정 오프셋을 정의 할뿐입니다. 인식 된 약어는 &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; 뷰에 나열됩니다 ( &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;섹션 51.91&lt;/a&gt; 참조 ). 구성 매개 변수 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; 을 시간대 약어로 설정할 수 없지만 날짜 / 시간 입력 값 및 &lt;code&gt;AT TIME ZONE&lt;/code&gt; 연산자 와 함께 약어를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd6336e70f63a890b86a6cdbf6ec2c2a9832cb6d" translate="yes" xml:space="preserve">
          <source>A time zone abbreviation, for example &lt;code&gt;PST&lt;/code&gt;. Such a specification merely defines a particular offset from UTC, in contrast to full time zone names which can imply a set of daylight savings transition-date rules as well. The recognized abbreviations are listed in the &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; view (see &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;Section 51.91&lt;/a&gt;). You cannot set the configuration parameters &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; or &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; to a time zone abbreviation, but you can use abbreviations in date/time input values and with the &lt;code&gt;AT TIME ZONE&lt;/code&gt; operator.</source>
          <target state="translated">예를 들어, 표준 시간대 약어, &lt;code&gt;PST&lt;/code&gt; . 이러한 사양은 일광 절약 시간제 전환 날짜 규칙 세트를 암시 할 수있는 전체 시간대 이름과 달리 UTC에서 특정 오프셋을 정의합니다. 인식되는 약어는 &lt;code&gt;pg_timezone_abbrevs&lt;/code&gt; 보기에 나열됩니다 ( 51.91 &lt;a href=&quot;view-pg-timezone-abbrevs&quot;&gt;절&lt;/a&gt; 참조 ). 구성 매개 변수 &lt;a href=&quot;runtime-config-client#GUC-TIMEZONE&quot;&gt;TimeZone&lt;/a&gt; 또는 &lt;a href=&quot;runtime-config-logging#GUC-LOG-TIMEZONE&quot;&gt;log_timezone&lt;/a&gt; 을 표준 시간대 약어로 설정할 수 없지만 날짜 / 시간 입력 값 및 &lt;code&gt;AT TIME ZONE&lt;/code&gt; 연산자 와 함께 약어를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c1c7cede62c34481ae2c11f0263c23892006d69" translate="yes" xml:space="preserve">
          <source>A time zone cannot be specified when processing &lt;code&gt;timestamp without time zone&lt;/code&gt; or &lt;code&gt;interval&lt;/code&gt; inputs. These are always taken at face value.</source>
          <target state="translated">&lt;code&gt;timestamp without time zone&lt;/code&gt; 또는 &lt;code&gt;interval&lt;/code&gt; 입력 없이 타임 스탬프를 처리 할 때는 시간대를 지정할 수 없습니다 . 이들은 항상 액면가로 취합니다.</target>
        </trans-unit>
        <trans-unit id="f8aefcc9f6e4a3be95cca7cfd42df6a2625d531c" translate="yes" xml:space="preserve">
          <source>A timezone abbreviation file can contain blank lines and comments beginning with &lt;code&gt;#&lt;/code&gt;. Non-comment lines must have one of these formats:</source>
          <target state="translated">시간대 약어 파일에는 빈 줄과 &lt;code&gt;#&lt;/code&gt; 으로 시작하는 주석이 포함될 수 있습니다 . 주석이 아닌 행은 다음 형식 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="61f64c13915c0871a3186bb5a87ae1ae25b54733" translate="yes" xml:space="preserve">
          <source>A token can be a &lt;em&gt;key word&lt;/em&gt;, an &lt;em&gt;identifier&lt;/em&gt;, a &lt;em&gt;quoted identifier&lt;/em&gt;, a &lt;em&gt;literal&lt;/em&gt; (or constant), or a special character symbol. Tokens are normally separated by whitespace (space, tab, newline), but need not be if there is no ambiguity (which is generally only the case if a special character is adjacent to some other token type).</source>
          <target state="translated">토큰은 &lt;em&gt;키워드&lt;/em&gt; , &lt;em&gt;식별자&lt;/em&gt; , &lt;em&gt;따옴표 붙은 식별자&lt;/em&gt; , &lt;em&gt;리터럴&lt;/em&gt; (또는 상수) 또는 특수 문자 기호 일 수 있습니다. 토큰은 일반적으로 공백 (공백, 탭, 개행)으로 구분되지만 모호성이없는 경우 (일반적으로 특수 문자가 다른 토큰 유형에 인접한 경우에만 해당) 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8690158fd0b251c00dae6dfc7ede983456ddc45f" translate="yes" xml:space="preserve">
          <source>A token type emitted by the configuration's parser</source>
          <target state="translated">구성 파서가 생성 한 토큰 유형</target>
        </trans-unit>
        <trans-unit id="c55f58174d7a27cababe64df945ac6699fb690f5" translate="yes" xml:space="preserve">
          <source>A transaction can also see its own statistics (as yet untransmitted to the collector) in the views &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt;, &lt;code&gt;pg_stat_xact_sys_tables&lt;/code&gt;, &lt;code&gt;pg_stat_xact_user_tables&lt;/code&gt;, and &lt;code&gt;pg_stat_xact_user_functions&lt;/code&gt;. These numbers do not act as stated above; instead they update continuously throughout the transaction.</source>
          <target state="translated">트랜잭션은 또한 &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt; , &lt;code&gt;pg_stat_xact_sys_tables&lt;/code&gt; , &lt;code&gt;pg_stat_xact_user_tables&lt;/code&gt; 및 &lt;code&gt;pg_stat_xact_user_functions&lt;/code&gt; 뷰에서 자체 통계 (컬렉터로 아직 전송되지 않은)를 볼 수 있습니다 . 이 숫자는 위에서 언급 한대로 작동하지 않습니다. 대신 트랜잭션 전체에서 지속적으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="014bab7370933e95d60b2fbeb6b4ddd7ac675ebb" translate="yes" xml:space="preserve">
          <source>A transaction can export more than one snapshot, if needed. Note that doing so is only useful in &lt;code&gt;READ COMMITTED&lt;/code&gt; transactions, since in &lt;code&gt;REPEATABLE READ&lt;/code&gt; and higher isolation levels, transactions use the same snapshot throughout their lifetime. Once a transaction has exported any snapshots, it cannot be prepared with &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt;.</source>
          <target state="translated">트랜잭션은 필요한 경우 둘 이상의 스냅 샷을 내보낼 수 있습니다. 이렇게하면 &lt;code&gt;READ COMMITTED&lt;/code&gt; 트랜잭션 에서만 유용합니다. &lt;code&gt;REPEATABLE READ&lt;/code&gt; 이상 격리 수준에서는 트랜잭션이 수명 내내 동일한 스냅 샷을 사용하기 때문입니다. 트랜잭션이 스냅 샷을 내 보낸 후에는 &lt;a href=&quot;sql-prepare-transaction&quot;&gt;PREPARE TRANSACTION&lt;/a&gt; 으로 준비 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1d7c34d636397a5326ca01bffe81c685d0466ea6" translate="yes" xml:space="preserve">
          <source>A transaction re-executes a query returning a set of rows that satisfy a search condition and finds that the set of rows satisfying the condition has changed due to another recently-committed transaction.</source>
          <target state="translated">트랜잭션은 검색 조건을 만족하는 행 집합을 반환하는 쿼리를 다시 실행하고 조건을 만족하는 행 집합이 최근에 커밋 된 다른 트랜잭션으로 인해 변경된 것을 발견합니다.</target>
        </trans-unit>
        <trans-unit id="f8c2fd7479305ce91383c02d70969dd66b2acddb" translate="yes" xml:space="preserve">
          <source>A transaction re-reads data it has previously read and finds that data has been modified by another transaction (that committed since the initial read).</source>
          <target state="translated">트랜잭션은 이전에 읽은 데이터를 다시 읽고 다른 트랜잭션 (초기 읽기 이후 커밋 된)에 의해 데이터가 수정 된 것을 발견합니다.</target>
        </trans-unit>
        <trans-unit id="c3382e299466bb042feceee6752ca8ef0259c657" translate="yes" xml:space="preserve">
          <source>A transaction reads data written by a concurrent uncommitted transaction.</source>
          <target state="translated">트랜잭션은 커밋되지 않은 동시 트랜잭션이 쓴 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="f339f7f826bbe705459f4d6147b96402061e9382" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;LISTEN&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">&lt;code&gt;LISTEN&lt;/code&gt; 을 실행 한 트랜잭션은 2 단계 커밋을 준비 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d0230fafa23fc125f62b605c5c7adbafb550941" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;NOTIFY&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">&lt;code&gt;NOTIFY&lt;/code&gt; 를 실행 한 트랜잭션은 2 단계 커밋을 준비 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6073bbb0958767b4f02cfd2e64c1259376f80a5e" translate="yes" xml:space="preserve">
          <source>A transaction that has executed &lt;code&gt;UNLISTEN&lt;/code&gt; cannot be prepared for two-phase commit.</source>
          <target state="translated">&lt;code&gt;UNLISTEN&lt;/code&gt; 을 실행 한 트랜잭션은 2 단계 커밋을 준비 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fbb0eb006f978734fefdbee822c93e37ab76e793" translate="yes" xml:space="preserve">
          <source>A transform specifies how to adapt a data type to a procedural language. For example, when writing a function in PL/Python using the &lt;code&gt;hstore&lt;/code&gt; type, PL/Python has no prior knowledge how to present &lt;code&gt;hstore&lt;/code&gt; values in the Python environment. Language implementations usually default to using the text representation, but that is inconvenient when, for example, an associative array or a list would be more appropriate.</source>
          <target state="translated">변환은 데이터 유형을 절차 언어에 적용하는 방법을 지정합니다. 예를 들어, &lt;code&gt;hstore&lt;/code&gt; 유형을 사용하여 PL / Python에서 함수를 작성할 때 PL / Python은 Python 환경에서 &lt;code&gt;hstore&lt;/code&gt; 값을 표시하는 방법에 대한 사전 지식이 없습니다 . 언어 구현은 일반적으로 텍스트 표현을 사용하는 것이 기본이지만, 예를 들어 연관 배열이나 목록이 더 적합 할 때는 불편합니다.</target>
        </trans-unit>
        <trans-unit id="8c2b373e9fbb9296093271c1db45ed67d33a82b6" translate="yes" xml:space="preserve">
          <source>A transform specifies two functions:</source>
          <target state="translated">변환은 두 가지 기능을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="0c9fe367d63aa8028ded2402f8662551682fdc1d" translate="yes" xml:space="preserve">
          <source>A trigger function is declared to return &lt;code&gt;trigger.&lt;/code&gt;</source>
          <target state="translated">트리거 함수는 트리거를 반환하도록 선언됩니다 &lt;code&gt;trigger.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7aece537a33eef527a0311c288ac02d9c4de009" translate="yes" xml:space="preserve">
          <source>A trigger that is marked &lt;code&gt;FOR EACH ROW&lt;/code&gt; is called once for every row that the operation modifies. For example, a &lt;code&gt;DELETE&lt;/code&gt; that affects 10 rows will cause any &lt;code&gt;ON DELETE&lt;/code&gt; triggers on the target relation to be called 10 separate times, once for each deleted row. In contrast, a trigger that is marked &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; only executes once for any given operation, regardless of how many rows it modifies (in particular, an operation that modifies zero rows will still result in the execution of any applicable &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; triggers).</source>
          <target state="translated">&lt;code&gt;FOR EACH ROW&lt;/code&gt; 로 표시된 트리거 는 조작이 수정하는 모든 행에 대해 한 번 호출됩니다. 예를 들어, &lt;code&gt;DELETE&lt;/code&gt; 10 행에 영향을 미치는 그 어떤 원인이됩니다 &lt;code&gt;ON DELETE&lt;/code&gt; 대상 관계에 트리거가 한 번 삭제 된 각 행에 대해, 10 별도 번 호출 할 수 있습니다. 반대로, &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; 로 표시된 트리거는 수정하는 행 수에 관계없이 특정 작업에 대해 한 번만 실행됩니다 (특히, 0 개의 행을 수정하는 작업은 여전히 ​​적용 가능한 &lt;code&gt;FOR EACH STATEMENT&lt;/code&gt; 트리거를 실행합니다) .</target>
        </trans-unit>
        <trans-unit id="7eef7b97e3bd1ce7b7ee3cef5b1119d2228d0033" translate="yes" xml:space="preserve">
          <source>A trigram is a group of three consecutive characters taken from a string. We can measure the similarity of two strings by counting the number of trigrams they share. This simple idea turns out to be very effective for measuring the similarity of words in many natural languages.</source>
          <target state="translated">트라이 그램은 문자열에서 가져온 세 개의 연속 문자 그룹입니다. 두 줄이 공유하는 트라이 그램 수를 세어 두 문자열의 유사성을 측정 할 수 있습니다. 이 간단한 아이디어는 많은 자연 언어에서 단어의 유사성을 측정하는 데 매우 효과적이라는 것이 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="a08b1cdf2b0b095b9d5863bddf7e5d8e3d7c32c3" translate="yes" xml:space="preserve">
          <source>A trivial example of &lt;code&gt;LATERAL&lt;/code&gt; is</source>
          <target state="translated">의 사소한 예 &lt;code&gt;LATERAL&lt;/code&gt; 인</target>
        </trans-unit>
        <trans-unit id="e8e38ccfb8ee20281247054f727fc62c3822f6eb" translate="yes" xml:space="preserve">
          <source>A type cast</source>
          <target state="translated">캐스트</target>
        </trans-unit>
        <trans-unit id="3a3537ff39dd61d4d97ae8731a9b41e347a01f70" translate="yes" xml:space="preserve">
          <source>A type cast specifies a conversion from one data type to another. PostgreSQL accepts two equivalent syntaxes for type casts:</source>
          <target state="translated">유형 캐스트는 한 데이터 유형에서 다른 데이터 유형으로의 변환을 지정합니다. PostgreSQL은 유형 캐스트에 대해 두 가지 동등한 구문을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="191f8bc0dbd057f5d062293ad47b726e2c4bd97b" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which restricts the values allowed in one or a combination of columns so that each value or combination of values can only appear once in the relation &amp;mdash; that is, no other row in the relation contains values that are equal to those.</source>
          <target state="translated">각 값 또는 값 조합이 관계에 한 번만 나타날 수 있도록 하나 또는 열 조합에 허용되는 값을 제한 하는 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; 에 정의 된 &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;제약&lt;/a&gt; 유형입니다. 즉, 관계의 다른 행에는 동일한 값이 포함되지 않습니다. 그들에게.</target>
        </trans-unit>
        <trans-unit id="47769c3fbebe762aaf5ca2f230501fed1e2e6077" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraint&lt;/a&gt; defined on a &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relation&lt;/a&gt; which restricts the values allowed in one or more &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;attributes&lt;/a&gt;. The check constraint can make reference to any attribute of the same row in the relation, but cannot reference other rows of the same relation or other relations.</source>
          <target state="translated">하나 이상의 &lt;a href=&quot;glossary#GLOSSARY-ATTRIBUTE&quot;&gt;속성에&lt;/a&gt; 허용되는 값을 제한 하는 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계에&lt;/a&gt; 정의 된 &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;제약&lt;/a&gt; 유형입니다 . 검사 제약 조건은 관계에서 동일한 행의 속성을 참조 할 수 있지만 동일한 관계 또는 다른 관계의 다른 행을 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4e0d1fa65cb5707a942beda0ba4cefcb538e80bc" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraint&lt;/a&gt; defined on one or more &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;columns&lt;/a&gt; in a &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; which requires the value(s) in those &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;columns&lt;/a&gt; to identify zero or one &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;row&lt;/a&gt; in another (or, infrequently, the same) &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt;.</source>
          <target state="translated">A 형의 &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;제약&lt;/a&gt; 중 하나 개 이상에 정의 된 &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;컬럼&lt;/a&gt; (A)에 &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 이들의 값은 필요 &lt;a href=&quot;glossary#GLOSSARY-COLUMN&quot;&gt;열에는&lt;/a&gt; 0 또는 1 식별 &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;행&lt;/a&gt; (드물게는 동일하거나)에 다른 &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d90f0d3baf2cdb5f8ece9a12f549c13ec0fed9a9" translate="yes" xml:space="preserve">
          <source>A type of &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;function&lt;/a&gt; used in a &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;query&lt;/a&gt; that applies to a &lt;a href=&quot;glossary#GLOSSARY-PARTITION&quot;&gt;partition&lt;/a&gt; of the query's &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;result set&lt;/a&gt;; the function's result is based on values found in &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;rows&lt;/a&gt; of the same partition or frame.</source>
          <target state="translated">쿼리 &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;결과 집합&lt;/a&gt; 의 &lt;a href=&quot;glossary#GLOSSARY-PARTITION&quot;&gt;파티션&lt;/a&gt; 에 적용되는 &lt;a href=&quot;glossary#GLOSSARY-QUERY&quot;&gt;쿼리에&lt;/a&gt; 사용되는 &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;함수&lt;/a&gt; 유형입니다 . 함수의 결과는 동일한 파티션 또는 프레임의 &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;행&lt;/a&gt; 에서 찾은 값을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="cf5a2e79c8fc1633f97f91eb24cc9a0675c7c13b" translate="yes" xml:space="preserve">
          <source>A type of relation that is used to generate values. Typically the generated values are sequential non-repeating numbers. They are commonly used to generate surrogate &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-KEY&quot;&gt;primary key&lt;/a&gt; values.</source>
          <target state="translated">값을 생성하는 데 사용되는 관계 유형입니다. 일반적으로 생성 된 값은 반복되지 않는 순차적 인 숫자입니다. 일반적으로 서로 게이트 &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-KEY&quot;&gt;기본 키&lt;/a&gt; 값 을 생성하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="d6c0d0a70cc72776a389a8d07d0b7fa59473f06b" translate="yes" xml:space="preserve">
          <source>A type of routine that receives zero or more arguments, returns zero or more output values, and is constrained to run within one transaction. Functions are invoked as part of a query, for example via &lt;code&gt;SELECT&lt;/code&gt;. Certain functions can return &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;sets&lt;/a&gt;; those are called &lt;em&gt;set-returning functions&lt;/em&gt;.</source>
          <target state="translated">0 개 이상의 인수를 받고 0 개 이상의 출력 값을 반환하며 한 트랜잭션 내에서 실행되도록 제한되는 루틴 유형입니다. 함수는 예를 들어 &lt;code&gt;SELECT&lt;/code&gt; 를 통해 쿼리의 일부로 호출됩니다 . 특정 함수는 &lt;a href=&quot;glossary#GLOSSARY-RESULT-SET&quot;&gt;집합&lt;/a&gt; 을 반환 할 수 있습니다 . 이를 &lt;em&gt;세트 반환 함수&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="103d10d7e532eccef03717f65e1f2bc653ed5156" translate="yes" xml:space="preserve">
          <source>A type of routine. Their distinctive qualities are that they do not return values, and that they are allowed to make transactional statements such as &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;. They are invoked via the &lt;code&gt;CALL&lt;/code&gt; command.</source>
          <target state="translated">일종의 루틴. 고유 한 특성은 값을 반환하지 않으며 &lt;code&gt;COMMIT&lt;/code&gt; 및 &lt;code&gt;ROLLBACK&lt;/code&gt; 과 같은 트랜잭션 문을 만들 수 있다는 것 입니다. &lt;code&gt;CALL&lt;/code&gt; 명령을 통해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2685b870f0e5693341cc020b2215b601f4f13b60" translate="yes" xml:space="preserve">
          <source>A typical application of table aliases is to assign short identifiers to long table names to keep the join clauses readable. For example:</source>
          <target state="translated">테이블 별칭의 일반적인 응용 프로그램은 조인 절을 읽을 수 있도록 긴 테이블 이름에 짧은 식별자를 할당하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53e9ce7093c6b3d709e92599c2e63f01a872a533" translate="yes" xml:space="preserve">
          <source>A typical cost estimator will proceed as follows:</source>
          <target state="translated">일반적인 비용 견적 도구는 다음과 같이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="0dc6b779feedceaca26b9995072395fe22118094" translate="yes" xml:space="preserve">
          <source>A typical observed effect when this setting is on is that shared memory objects used for parallel query execution are removed at apparently random times, leading to errors and warnings while attempting to open and remove them, like</source>
          <target state="translated">이 설정이 켜져있을 때 일반적으로 관찰되는 효과는 병렬 쿼리 실행에 사용되는 공유 메모리 개체가 명백하게 임의의 시간에 제거되어 열고 제거하려고 시도하는 동안 오류 및 경고가 발생한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8d74e530024da711c01ee4999c6bbacc75f1477" translate="yes" xml:space="preserve">
          <source>A typical observed effect when this setting is on is that the semaphore objects used by a PostgreSQL server are removed at apparently random times, leading to the server crashing with log messages like</source>
          <target state="translated">이 설정이 켜져있을 때 일반적으로 관찰되는 효과는 PostgreSQL 서버에서 사용하는 세마포어 개체가 임의의 시간에 제거되어 서버가 다음과 같은 로그 메시지와 충돌하는 것입니다</target>
        </trans-unit>
        <trans-unit id="3fc9f5b992a80655782589dd8a0df2c7a647d35a" translate="yes" xml:space="preserve">
          <source>A typical query that can use this index would be:</source>
          <target state="translated">이 인덱스를 사용할 수있는 일반적인 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0521362e3f43575ffcfbc899da16b98a9800ce48" translate="yes" xml:space="preserve">
          <source>A typical use is in reading the current value of the sequence for an identity or serial column, for example:</source>
          <target state="translated">일반적인 용도는 ID 또는 직렬 열에 대한 시퀀스의 현재 값을 읽는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="169a523c2d612c2511933ebb2897995bb069e2f2" translate="yes" xml:space="preserve">
          <source>A unique, cluster-wide identifier for the replication origin. Should never leave the system.</source>
          <target state="translated">복제 원본에 대한 고유 한 클러스터 전체 식별자입니다. 시스템을 떠나지 마십시오.</target>
        </trans-unit>
        <trans-unit id="47f21621fe9103c27d1085b3377ce1e6907d3fec" translate="yes" xml:space="preserve">
          <source>A unique, cluster-wide identifier for the replication slot</source>
          <target state="translated">복제 슬롯에 대한 고유 한 클러스터 전체 식별자</target>
        </trans-unit>
        <trans-unit id="5d4bfd425f4eb16bbefa46dacd068b22bd41528d" translate="yes" xml:space="preserve">
          <source>A useful property of &lt;code&gt;WITH&lt;/code&gt; queries is that they are normally evaluated only once per execution of the parent query, even if they are referred to more than once by the parent query or sibling &lt;code&gt;WITH&lt;/code&gt; queries. Thus, expensive calculations that are needed in multiple places can be placed within a &lt;code&gt;WITH&lt;/code&gt; query to avoid redundant work. Another possible application is to prevent unwanted multiple evaluations of functions with side-effects. However, the other side of this coin is that the optimizer is not able to push restrictions from the parent query down into a multiply-referenced &lt;code&gt;WITH&lt;/code&gt; query, since that might affect all uses of the &lt;code&gt;WITH&lt;/code&gt; query's output when it should affect only one. The multiply-referenced &lt;code&gt;WITH&lt;/code&gt; query will be evaluated as written, without suppression of rows that the parent query might discard afterwards. (But, as mentioned above, evaluation might stop early if the reference(s) to the query demand only a limited number of rows.)</source>
          <target state="translated">&lt;code&gt;WITH&lt;/code&gt; 쿼리 의 유용한 속성은 부모 쿼리 또는 형제 &lt;code&gt;WITH&lt;/code&gt; 쿼리에 의해 두 번 이상 참조 되더라도 일반적으로 부모 쿼리 실행 당 한 번만 평가된다는 것 입니다. 따라서 중복 작업을 피하기 위해 여러 위치에 필요한 값 비싼 계산을 &lt;code&gt;WITH&lt;/code&gt; 쿼리 내에 배치 할 수 있습니다 . 또 다른 가능한 응용은 부작용으로 기능의 원치 않는 다중 평가를 방지하는 것입니다. 그러나이 코인의 다른 측면은 최적화 프로그램이 상위 쿼리의 제한을 다중 참조 &lt;code&gt;WITH&lt;/code&gt; 쿼리 로 푸시 다운 할 수 없다는 것입니다. 이는 하나의 쿼리에만 영향을 미치면 &lt;code&gt;WITH&lt;/code&gt; 쿼리 출력의 모든 사용에 영향을 줄 수 있기 때문입니다 . 곱하기 참조 &lt;code&gt;WITH&lt;/code&gt; 쿼리는 나중에 상위 쿼리가 버릴 수있는 행을 억제하지 않고 작성된 것으로 평가됩니다. 그러나 위에서 언급 한 것처럼 쿼리에 대한 참조에 제한된 수의 행만 필요한 경우 평가가 일찍 중지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46f8eb17a4dc6792884149cbde1b901dd618e58c" translate="yes" xml:space="preserve">
          <source>A user able to modify the schema of subscriber-side tables can execute arbitrary code as a superuser. Limit ownership and &lt;code&gt;TRIGGER&lt;/code&gt; privilege on such tables to roles that superusers trust. Moreover, if untrusted users can create tables, use only publications that list tables explicitly. That is to say, create a subscription &lt;code&gt;FOR ALL TABLES&lt;/code&gt; only when superusers trust every user permitted to create a non-temp table on the publisher or the subscriber.</source>
          <target state="translated">가입자 측 테이블의 스키마를 수정할 수있는 사용자는 수퍼 유저로서 임의의 코드를 실행할 수 있습니다. 이러한 테이블에 대한 소유권 및 &lt;code&gt;TRIGGER&lt;/code&gt; 권한을 수퍼 유저가 신뢰하는 역할로 제한하십시오 . 또한 신뢰할 수없는 사용자가 테이블을 만들 수있는 경우 테이블을 명시 적으로 나열하는 게시 만 사용하십시오. 즉, 수퍼 유저가 게시자 또는 구독자에서 임시 테이블이 아닌 테이블을 만들 수 있도록 허용 된 모든 사용자를 신뢰하는 경우에만 &lt;code&gt;FOR ALL TABLES&lt;/code&gt; 대한 구독 을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="624d70f8d00542243273d8f95b839148832783a9" translate="yes" xml:space="preserve">
          <source>A user can also be allowed to create objects in someone else's schema. To allow that, the &lt;code&gt;CREATE&lt;/code&gt; privilege on the schema needs to be granted. Note that by default, everyone has &lt;code&gt;CREATE&lt;/code&gt; and &lt;code&gt;USAGE&lt;/code&gt; privileges on the schema &lt;code&gt;public&lt;/code&gt;. This allows all users that are able to connect to a given database to create objects in its &lt;code&gt;public&lt;/code&gt; schema. Some &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;usage patterns&lt;/a&gt; call for revoking that privilege:</source>
          <target state="translated">사용자는 다른 사람의 스키마에서 객체를 만들 수도 있습니다. 이를 위해서는 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이 부여되어야합니다. 기본적으로 모든 사람은 &lt;code&gt;public&lt;/code&gt; 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 및 &lt;code&gt;USAGE&lt;/code&gt; 권한을 갖습니다 . 이를 통해 주어진 데이터베이스에 연결할 수있는 모든 사용자가 &lt;code&gt;public&lt;/code&gt; 스키마 에서 오브젝트를 작성할 수 있습니다 . 일부 &lt;a href=&quot;ddl-schemas#DDL-SCHEMAS-PATTERNS&quot;&gt;사용 패턴&lt;/a&gt; 은 해당 권한을 취소해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9aa765822babac771b767a7977f197f0cfd20dc" translate="yes" xml:space="preserve">
          <source>A user can only revoke privileges that were granted directly by that user. If, for example, user A has granted a privilege with grant option to user B, and user B has in turn granted it to user C, then user A cannot revoke the privilege directly from C. Instead, user A could revoke the grant option from user B and use the &lt;code&gt;CASCADE&lt;/code&gt; option so that the privilege is in turn revoked from user C. For another example, if both A and B have granted the same privilege to C, A can revoke their own grant but not B's grant, so C will still effectively have the privilege.</source>
          <target state="translated">사용자는 해당 사용자가 직접 부여한 권한 만 취소 할 수 있습니다. 예를 들어, 사용자 A가 사용자 B에게 권한 부여 옵션이있는 권한을 부여하고 사용자 B가 사용자 C에게 권한을 부여한 경우 사용자 A는 C에서 직접 권한을 취소 할 수 없습니다. 대신 사용자 A가 권한 부여 옵션을 취소 할 수 있습니다. 사용자 B에서와 사용 &lt;code&gt;CASCADE&lt;/code&gt; 의 특권이 차례로 다른 예를 들어 사용자 C.에서 취소되도록 A와 B 모두 C에 동일한 권한을 부여한 경우, 옵션을, A는 자신의 부여하지만 B의 부여를 취소 C 그렇게 할 수 있습니다 여전히 효과적으로 권한을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="9eef0500388438dcdd883438e62adfff2b4c59d7" translate="yes" xml:space="preserve">
          <source>A user mapping, defined with &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING&lt;/a&gt;, is needed as well to identify the role that will be used on the remote server:</source>
          <target state="translated">원격 서버에서 사용될 역할을 식별하려면 &lt;a href=&quot;sql-createusermapping&quot;&gt;CREATE USER MAPPING으로&lt;/a&gt; 정의 된 사용자 맵핑 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cd811596f6c21fd6820e0962c95748afb5dd8832" translate="yes" xml:space="preserve">
          <source>A user may perform &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, etc. on a column if they hold that privilege for either the specific column or its whole table. Granting the privilege at the table level and then revoking it for one column will not do what one might wish: the table-level grant is unaffected by a column-level operation.</source>
          <target state="translated">사용자가 특정 열 또는 전체 테이블에 대해 해당 권한을 보유한 경우 열에서 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; 등을 수행 할 수 있습니다 . 테이블 레벨에서 특권을 부여한 후 한 컬럼에 대해 권한을 취소하면 원하는대로 수행되지 않습니다. 테이블 레벨 권한 부여는 컬럼 레벨 조작의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d16a3b790258dd6e7bcb147ac82c63396f9dabe" translate="yes" xml:space="preserve">
          <source>A user with appropriate privileges can pass &lt;code&gt;tablespace_name&lt;/code&gt; to &lt;code&gt;CREATE DATABASE&lt;/code&gt;, &lt;code&gt;CREATE TABLE&lt;/code&gt;, &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; to have the data files for these objects stored within the specified tablespace.</source>
          <target state="translated">적절한 권한이있는 사용자는 &lt;code&gt;tablespace_name&lt;/code&gt; 을 &lt;code&gt;CREATE DATABASE&lt;/code&gt; , &lt;code&gt;CREATE TABLE&lt;/code&gt; , &lt;code&gt;CREATE INDEX&lt;/code&gt; 또는 &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; 로 전달하여 지정된 테이블 스페이스 내에 이러한 오브젝트에 대한 데이터 파일을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb5146129674511426d710b87f38fac56dd128fd" translate="yes" xml:space="preserve">
          <source>A user-supplied function that is declared as taking no argument and returning type &lt;code&gt;event_trigger&lt;/code&gt;.</source>
          <target state="translated">인수를 사용하지 않고 &lt;code&gt;event_trigger&lt;/code&gt; 유형을 리턴하는 것으로 선언 된 사용자 제공 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="944b09ef2e50c44bc480f5f428bf817a45e1996f" translate="yes" xml:space="preserve">
          <source>A user-supplied function that is declared as taking no arguments and returning type &lt;code&gt;trigger&lt;/code&gt;, which is executed when the trigger fires.</source>
          <target state="translated">인수를 취하지 않고 트리거가 트리거 될 때 실행되는 &lt;code&gt;trigger&lt;/code&gt; 유형을 리턴하는 것으로 선언 된 사용자 제공 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="3c03a8192bb8c460f615ba363c0076eb7beddfc8" translate="yes" xml:space="preserve">
          <source>A validator function would typically inspect the function body for syntactical correctness, but it can also look at other properties of the function, for example if the language cannot handle certain argument types. To signal an error, the validator function should use the &lt;code&gt;ereport()&lt;/code&gt; function. The return value of the function is ignored.</source>
          <target state="translated">유효성 검사기 함수는 일반적으로 함수 본문에서 구문의 정확성을 검사하지만 언어가 특정 인수 유형을 처리 할 수없는 경우와 같이 함수의 다른 속성을 볼 수도 있습니다. 오류를 &lt;code&gt;ereport()&lt;/code&gt; 위해 유효성 검증기 함수는 ereport () 함수를 사용해야합니다 . 함수의 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb559a62e1812965348b9dc25a132908d898b4a" translate="yes" xml:space="preserve">
          <source>A value (but not a key) can be an SQL &lt;code&gt;NULL&lt;/code&gt;. For example:</source>
          <target state="translated">값 (키는 아님)은 SQL &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f11b15a75cd7fa69b386c1868dbf1a5bd1c71215" translate="yes" xml:space="preserve">
          <source>A value expression is one of the following:</source>
          <target state="translated">값 표현식은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="15f463c504877012fea738b4b0d0b079a3d4f123" translate="yes" xml:space="preserve">
          <source>A value inserted into the referencing column(s) is matched against the values of the referenced table and referenced columns using the given match type. There are three match types: &lt;code&gt;MATCH FULL&lt;/code&gt;, &lt;code&gt;MATCH PARTIAL&lt;/code&gt;, and &lt;code&gt;MATCH SIMPLE&lt;/code&gt; (which is the default). &lt;code&gt;MATCH FULL&lt;/code&gt; will not allow one column of a multicolumn foreign key to be null unless all foreign key columns are null; if they are all null, the row is not required to have a match in the referenced table. &lt;code&gt;MATCH SIMPLE&lt;/code&gt; allows any of the foreign key columns to be null; if any of them are null, the row is not required to have a match in the referenced table. &lt;code&gt;MATCH PARTIAL&lt;/code&gt; is not yet implemented. (Of course, &lt;code&gt;NOT NULL&lt;/code&gt; constraints can be applied to the referencing column(s) to prevent these cases from arising.)</source>
          <target state="translated">참조 열에 삽입 된 값은 지정된 일치 유형을 사용하여 참조 테이블 및 참조 열의 값과 일치합니다. &lt;code&gt;MATCH FULL&lt;/code&gt; , &lt;code&gt;MATCH PARTIAL&lt;/code&gt; 및 &lt;code&gt;MATCH SIMPLE&lt;/code&gt; 의 세 가지 일치 유형이 있습니다 (기본값). &lt;code&gt;MATCH FULL&lt;/code&gt; 은 모든 외래 키 열이 null이 아니면 다중 열 외래 키의 한 열이 null이 될 수 없습니다. 모두 널인 경우 행은 참조 된 테이블에서 일치하지 않아도됩니다. &lt;code&gt;MATCH SIMPLE&lt;/code&gt; 을 사용하면 외래 키 열을 null로 지정할 수 있습니다. 이들 중 하나가 널인 경우 행은 참조 된 테이블에서 일치하지 않아도됩니다. &lt;code&gt;MATCH PARTIAL&lt;/code&gt; 은 아직 구현되지 않았습니다. (물론 &lt;code&gt;NOT NULL&lt;/code&gt; 이러한 경우가 발생하지 않도록 참조 열에 제약 조건을 적용 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="d3f19f348507a8389d8d149cdf77d56e254062cd" translate="yes" xml:space="preserve">
          <source>A variable representing the JSON text to be queried (the &lt;em&gt;context item&lt;/em&gt;).</source>
          <target state="translated">쿼리 할 JSON 텍스트를 나타내는 변수 ( &lt;em&gt;컨텍스트 항목&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="ad2426a5221bd13cdbc6ec097f91418bf9cf0787" translate="yes" xml:space="preserve">
          <source>A variable representing the JSON value being queried (the &lt;em&gt;context item&lt;/em&gt;).</source>
          <target state="translated">쿼리되는 JSON 값을 나타내는 변수 ( &lt;em&gt;컨텍스트 항목&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="6b7ff43247d2073dd8c93ef6f893b8751eb3e7bd" translate="yes" xml:space="preserve">
          <source>A variable representing the result of path evaluation in filter expressions.</source>
          <target state="translated">필터 표현식에서 경로 평가 결과를 나타내는 변수입니다.</target>
        </trans-unit>
        <trans-unit id="156f0d479c5cbda4c018211d44db7834d2c5eaed" translate="yes" xml:space="preserve">
          <source>A variant of quoted identifiers allows including escaped Unicode characters identified by their code points. This variant starts with &lt;code&gt;U&amp;amp;&lt;/code&gt; (upper or lower case U followed by ampersand) immediately before the opening double quote, without any spaces in between, for example &lt;code&gt;U&amp;amp;&quot;foo&quot;&lt;/code&gt;. (Note that this creates an ambiguity with the operator &lt;code&gt;&amp;amp;&lt;/code&gt;. Use spaces around the operator to avoid this problem.) Inside the quotes, Unicode characters can be specified in escaped form by writing a backslash followed by the four-digit hexadecimal code point number or alternatively a backslash followed by a plus sign followed by a six-digit hexadecimal code point number. For example, the identifier &lt;code&gt;&quot;data&quot;&lt;/code&gt; could be written as</source>
          <target state="translated">따옴표 붙은 식별자의 변형으로 코드 포인트로 식별 된 이스케이프 된 유니 코드 문자를 포함 할 수 있습니다. 이 변형은 여는 큰 따옴표 바로 앞의 &lt;code&gt;U&amp;amp;&lt;/code&gt; (대문자 U와 소문자 U 뒤에 앰퍼샌드)로 시작합니다 (예 : &lt;code&gt;U&amp;amp;&quot;foo&quot;&lt;/code&gt; . (주이 운영자와의 모호성 만드는 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 . 사용 공간을 운영자 주위에이 문제를 방지 할 수 있습니다.) 따옴표 내부 유니 코드 문자는 4 자리의 16 진수 코드 포인트 번호 또는 뒤에 백 슬래시를 작성하여 탈출 형태로 지정 될 수 있습니다 또는 백 슬래시와 더하기 부호, 6 자리 16 진수 코드 포인트 번호가 뒤 따릅니다. 예를 들어 식별자 &lt;code&gt;&quot;data&quot;&lt;/code&gt; 는 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acdae0bdc3109dd35a6d548731ba6bb6d6a12b1e" translate="yes" xml:space="preserve">
          <source>A variant of the above query is</source>
          <target state="translated">위 쿼리의 변형은</target>
        </trans-unit>
        <trans-unit id="86b56417739883cc59cc6c063327a17fce9dbe75" translate="yes" xml:space="preserve">
          <source>A view column name list must be specified for a recursive view.</source>
          <target state="translated">재귀 적 뷰에 대해 뷰 열 이름 목록을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="85b3bfd48768285b52ad306ba0d6292137e9c9f1" translate="yes" xml:space="preserve">
          <source>A view that is simple enough to be automatically updatable (see &lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEW&lt;/a&gt;) does not require a user-created rule in order to be updatable. While you can create an explicit rule anyway, the automatic update transformation will generally outperform an explicit rule.</source>
          <target state="translated">자동으로 업데이트 할 수있을 정도로 간단한 뷰 ( &lt;a href=&quot;sql-createview&quot;&gt;CREATE VIEW&lt;/a&gt; 참조 )는 업데이트 할 수 있도록 사용자가 만든 규칙이 필요하지 않습니다. 어쨌든 명시 적 규칙을 만들 수는 있지만 자동 업데이트 변환은 일반적으로 명시 적 규칙보다 성능이 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="b5c5c1bad9d2f71be50a1fcf23b697eb7750bb21" translate="yes" xml:space="preserve">
          <source>A window function call</source>
          <target state="translated">윈도우 함수 호출</target>
        </trans-unit>
        <trans-unit id="014e860f54b04147bfef99f64476d36d0f965833" translate="yes" xml:space="preserve">
          <source>A window function call always contains an &lt;code&gt;OVER&lt;/code&gt; clause directly following the window function's name and argument(s). This is what syntactically distinguishes it from a normal function or non-window aggregate. The &lt;code&gt;OVER&lt;/code&gt; clause determines exactly how the rows of the query are split up for processing by the window function. The &lt;code&gt;PARTITION BY&lt;/code&gt; clause within &lt;code&gt;OVER&lt;/code&gt; divides the rows into groups, or partitions, that share the same values of the &lt;code&gt;PARTITION BY&lt;/code&gt; expression(s). For each row, the window function is computed across the rows that fall into the same partition as the current row.</source>
          <target state="translated">윈도우 함수 호출에는 항상 윈도우 함수의 이름과 인수 바로 뒤에 &lt;code&gt;OVER&lt;/code&gt; 절이 포함 됩니다. 이것이 구문 상으로 일반 함수 또는 비 창구 집계와 구별됩니다. &lt;code&gt;OVER&lt;/code&gt; 의 절은 쿼리의 행이 윈도우 함수에 의해 처리 분할 정확하게 방법을 결정합니다. &lt;code&gt;PARTITION BY&lt;/code&gt; 내의 절 &lt;code&gt;OVER&lt;/code&gt; 는 그 주의 동일한 값, 그룹 또는 파티션으로 나누어 행 &lt;code&gt;PARTITION BY&lt;/code&gt; 식 (S). 각 행에 대해 창 함수는 현재 행과 동일한 파티션에 속하는 행에서 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="69ff975e62e5e9881d6e40cfa6394518b64c0b59" translate="yes" xml:space="preserve">
          <source>A word is defined as in the specification of &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; and &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; above. Constraint escapes are illegal within bracket expressions.</source>
          <target state="translated">단어는 위의 &lt;code&gt;[[:&amp;lt;:]]&lt;/code&gt; 및 &lt;code&gt;[[:&amp;gt;:]]&lt;/code&gt; 사양에서와 같이 정의됩니다 . 제약 조건 이스케이프는 대괄호 표현식 내에서 불법입니다.</target>
        </trans-unit>
        <trans-unit id="e7b5c134c4da8e8da4908f5aacc24a6aa1409eb3" translate="yes" xml:space="preserve">
          <source>A working example of a waiting &lt;code&gt;restore_command&lt;/code&gt; is provided in the &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module. It should be used as a reference on how to correctly implement the logic described above. It can also be extended as needed to support specific configurations and environments.</source>
          <target state="translated">대기중인 &lt;code&gt;restore_command&lt;/code&gt; 의 실제 예제 는 &lt;a href=&quot;https://www.postgresql.org/docs/12/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; 모듈 에서 제공됩니다 . 위에서 설명한 논리를 올바르게 구현하는 방법에 대한 참조로 사용해야합니다. 특정 구성 및 환경을 지원하기 위해 필요에 따라 확장 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="94040fbf2d2ff3dac676f0671c8578ae0488b46e" translate="yes" xml:space="preserve">
          <source>A working example of a waiting &lt;code&gt;restore_command&lt;/code&gt; is provided in the &lt;a href=&quot;https://www.postgresql.org/docs/13/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; module. It should be used as a reference on how to correctly implement the logic described above. It can also be extended as needed to support specific configurations and environments.</source>
          <target state="translated">대기중인 &lt;code&gt;restore_command&lt;/code&gt; 의 작동 예 는 &lt;a href=&quot;https://www.postgresql.org/docs/13/pgstandby.html&quot;&gt;pg_standby&lt;/a&gt; 모듈에 제공됩니다 . 위에서 설명한 논리를 올바르게 구현하는 방법에 대한 참조로 사용해야합니다. 특정 구성 및 환경을 지원하기 위해 필요에 따라 확장 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d87e11b3c84c752269b580bca5caeedfc37d702" translate="yes" xml:space="preserve">
          <source>A write transaction has more than 64 subtransactions</source>
          <target state="translated">쓰기 트랜잭션에는 64 개 이상의 서브 트랜잭션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbd57cfd9437b3c9c1c3ce7cb0fb7a7b8366940a" translate="yes" xml:space="preserve">
          <source>ABORT</source>
          <target state="translated">ABORT</target>
        </trans-unit>
        <trans-unit id="7a0ffd6011b0a819cbe07ec59ab6319e323b19e8" translate="yes" xml:space="preserve">
          <source>ABORT &amp;mdash; abort the current transaction</source>
          <target state="translated">ABORT &amp;mdash; 현재 거래 중단</target>
        </trans-unit>
        <trans-unit id="e3a56e2d83c5cd3911209ecd97318531d89949dd" translate="yes" xml:space="preserve">
          <source>ACCESS EXCLUSIVE</source>
          <target state="translated">독점 액세스</target>
        </trans-unit>
        <trans-unit id="236082e0393025e2b67ccb853e349993a3e685de" translate="yes" xml:space="preserve">
          <source>ACCESS SHARE</source>
          <target state="translated">액세스 쉐어</target>
        </trans-unit>
        <trans-unit id="d4c15b3f603d1252b36800551086669559ae86a4" translate="yes" xml:space="preserve">
          <source>ACID</source>
          <target state="translated">ACID</target>
        </trans-unit>
        <trans-unit id="41f215a6d36c7782875bfb5d6d290ebb1e7961df" translate="yes" xml:space="preserve">
          <source>AES</source>
          <target state="translated">AES</target>
        </trans-unit>
        <trans-unit id="7cd735bc88414abeac25ef102606e6871aeba944" translate="yes" xml:space="preserve">
          <source>AIX</source>
          <target state="translated">AIX</target>
        </trans-unit>
        <trans-unit id="d3f3cb97007280f4a9b1e690872959eda00344a5" translate="yes" xml:space="preserve">
          <source>ALTER AGGREGATE</source>
          <target state="translated">대체 집계</target>
        </trans-unit>
        <trans-unit id="ed3d1c36faecc14690efbf5d3029f3dd4930091a" translate="yes" xml:space="preserve">
          <source>ALTER AGGREGATE &amp;mdash; change the definition of an aggregate function</source>
          <target state="translated">ALTER AGGREGATE &amp;mdash; 집계 함수의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="a11472b885174cf0a5b8f565bbd9df33d5c63d9f" translate="yes" xml:space="preserve">
          <source>ALTER COLLATION</source>
          <target state="translated">대체 컬렉션</target>
        </trans-unit>
        <trans-unit id="56c3d4607ffe2e71e2c5f2646969f8ca0df737b4" translate="yes" xml:space="preserve">
          <source>ALTER COLLATION &amp;mdash; change the definition of a collation</source>
          <target state="translated">ALTER COLLATION &amp;mdash; 데이터 정렬의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="41b42a1cc1e0f91fde1b7c9e18dfe7b36339b901" translate="yes" xml:space="preserve">
          <source>ALTER CONVERSION</source>
          <target state="translated">변환 변경</target>
        </trans-unit>
        <trans-unit id="ccebf78a2dc7b51b4b857717880c57e697294e8c" translate="yes" xml:space="preserve">
          <source>ALTER CONVERSION &amp;mdash; change the definition of a conversion</source>
          <target state="translated">ALTER CONVERSION &amp;mdash; 전환 정의 변경</target>
        </trans-unit>
        <trans-unit id="00ca4087b8df03743dae97498c53fb19953638fa" translate="yes" xml:space="preserve">
          <source>ALTER DATABASE</source>
          <target state="translated">데이터베이스 변경</target>
        </trans-unit>
        <trans-unit id="bea7726d13edb6ca210b4e6c9e61ad1bc910bed8" translate="yes" xml:space="preserve">
          <source>ALTER DATABASE &amp;mdash; change a database</source>
          <target state="translated">ALTER DATABASE &amp;mdash; 데이터베이스 변경</target>
        </trans-unit>
        <trans-unit id="2d6bcd612a3e7b99bb9476838637e9b5438e3634" translate="yes" xml:space="preserve">
          <source>ALTER DEFAULT PRIVILEGES</source>
          <target state="translated">기본 실무 변경</target>
        </trans-unit>
        <trans-unit id="d8ff7f2d5af359b01a54f95e0ec2fd521bd7747c" translate="yes" xml:space="preserve">
          <source>ALTER DEFAULT PRIVILEGES &amp;mdash; define default access privileges</source>
          <target state="translated">DEFAULT PRIVILEGES ALTER DEFAULT PRIVILEGES &amp;mdash; 기본 액세스 권한을 정의합니다</target>
        </trans-unit>
        <trans-unit id="3f3cf48aa306a7a17143c18f42b0b45f1ba91588" translate="yes" xml:space="preserve">
          <source>ALTER DOMAIN</source>
          <target state="translated">도메인 변경</target>
        </trans-unit>
        <trans-unit id="535f7dde2f03c36ca7629e33ff7b1217df1764aa" translate="yes" xml:space="preserve">
          <source>ALTER DOMAIN &amp;mdash; change the definition of a domain</source>
          <target state="translated">ALTER DOMAIN &amp;mdash; 도메인 정의 변경</target>
        </trans-unit>
        <trans-unit id="20933ed39426b19f4475367266e6e6f9a626ffa6" translate="yes" xml:space="preserve">
          <source>ALTER EVENT TRIGGER</source>
          <target state="translated">이벤트 트리거 변경</target>
        </trans-unit>
        <trans-unit id="10dfbf336834913b8615fd608fa879b835569269" translate="yes" xml:space="preserve">
          <source>ALTER EVENT TRIGGER &amp;mdash; change the definition of an event trigger</source>
          <target state="translated">ALTER EVENT TRIGGER &amp;mdash; 이벤트 트리거의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="0800582e9a19732ccd7ede52083d298eb7e533f7" translate="yes" xml:space="preserve">
          <source>ALTER EXTENSION</source>
          <target state="translated">교체 연장</target>
        </trans-unit>
        <trans-unit id="fceab1548e1fa0086ad916c8c58c48d5f822b214" translate="yes" xml:space="preserve">
          <source>ALTER EXTENSION &amp;mdash; change the definition of an extension</source>
          <target state="translated">ALTER EXTENSION &amp;mdash; 확장 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="1845d1a7f6884f411e6b6fe79fb5470d0541e6de" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN DATA WRAPPER</source>
          <target state="translated">외국 데이터 랩터 변경</target>
        </trans-unit>
        <trans-unit id="81f39fe099a4b1e8700a250047ab0bd19b916bbd" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN DATA WRAPPER &amp;mdash; change the definition of a foreign-data wrapper</source>
          <target state="translated">ALTER FOREIGN DATA WRAPPER &amp;mdash; 외부 데이터 래퍼의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="a09c3d2b46b06da9b27051fbdd7021dbe016aef6" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN TABLE</source>
          <target state="translated">외국 테이블 변경</target>
        </trans-unit>
        <trans-unit id="8624b9015bf6424468dfa21128e81480cb2172bb" translate="yes" xml:space="preserve">
          <source>ALTER FOREIGN TABLE &amp;mdash; change the definition of a foreign table</source>
          <target state="translated">ALTER FOREIGN TABLE &amp;mdash; 외래 테이블의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="6f1e4d41d93587f0bfc00e49946d0343d91452a6" translate="yes" xml:space="preserve">
          <source>ALTER FUNCTION</source>
          <target state="translated">기능 변경</target>
        </trans-unit>
        <trans-unit id="0d8b2dd3aa8516a6e8465a116eb3a3088efc3943" translate="yes" xml:space="preserve">
          <source>ALTER FUNCTION &amp;mdash; change the definition of a function</source>
          <target state="translated">ALTER FUNCTION &amp;mdash; 함수의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="1d015a780bf1ecbd73d8b159554c5fb6595a8014" translate="yes" xml:space="preserve">
          <source>ALTER GROUP</source>
          <target state="translated">대체 그룹</target>
        </trans-unit>
        <trans-unit id="8b6db204989799abd80f3151dc7f1e0c1b92ec62" translate="yes" xml:space="preserve">
          <source>ALTER GROUP &amp;mdash; change role name or membership</source>
          <target state="translated">ALTER GROUP &amp;mdash; 역할 이름 또는 멤버십 변경</target>
        </trans-unit>
        <trans-unit id="48c2e5d4cd7c661c29fd2888d9f2286c8fc0c6bf" translate="yes" xml:space="preserve">
          <source>ALTER INDEX</source>
          <target state="translated">인덱스 변경</target>
        </trans-unit>
        <trans-unit id="7af8592c9de99cba72394d1922b6e193f563c137" translate="yes" xml:space="preserve">
          <source>ALTER INDEX &amp;mdash; change the definition of an index</source>
          <target state="translated">ALTER INDEX &amp;mdash; 색인 정의 변경</target>
        </trans-unit>
        <trans-unit id="1593f1abf4a97117a0be55f5da7d21f597c8c250" translate="yes" xml:space="preserve">
          <source>ALTER LANGUAGE</source>
          <target state="translated">언어 변경</target>
        </trans-unit>
        <trans-unit id="2d47f4538397cbf8b0a1e802f6dfa7cb56556115" translate="yes" xml:space="preserve">
          <source>ALTER LANGUAGE &amp;mdash; change the definition of a procedural language</source>
          <target state="translated">ALTER LANGUAGE &amp;mdash; 절차 언어의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="b8e23037908ab469bed89826c20ecdd2b7ec5245" translate="yes" xml:space="preserve">
          <source>ALTER LARGE OBJECT</source>
          <target state="translated">큰 목표 변경</target>
        </trans-unit>
        <trans-unit id="d01f8e01043a2f37f9bf2b4fbe638ce531bf573c" translate="yes" xml:space="preserve">
          <source>ALTER LARGE OBJECT &amp;mdash; change the definition of a large object</source>
          <target state="translated">ALTER LARGE OBJECT &amp;mdash; 대형 객체의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="acf3facbc79c94e9820cd014a83e0c3bffc8d33e" translate="yes" xml:space="preserve">
          <source>ALTER MATERIALIZED VIEW</source>
          <target state="translated">대체 재료보기</target>
        </trans-unit>
        <trans-unit id="ff19a08e1cc705b85f737d7d03bbe11848829b1c" translate="yes" xml:space="preserve">
          <source>ALTER MATERIALIZED VIEW &amp;mdash; change the definition of a materialized view</source>
          <target state="translated">ALTER MATERIALIZED VIEW &amp;mdash; 구체화 된 뷰의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="dce6c5285005edbbb84e2318b05691c4b30c9b74" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR</source>
          <target state="translated">운영자 변경</target>
        </trans-unit>
        <trans-unit id="7dafb4a30aeb9191e7113acec86c091ff802f404" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR &amp;mdash; change the definition of an operator</source>
          <target state="translated">ALTER OPERATOR &amp;mdash; 운영자 정의 변경</target>
        </trans-unit>
        <trans-unit id="a0e738cb1034a6c7d40880b830a0d0aabd9fe44b" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR CLASS</source>
          <target state="translated">운영자 클래스 변경</target>
        </trans-unit>
        <trans-unit id="cb0f6723f3b16452ec4b0d07ef7fe014b4a43893" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR CLASS &amp;mdash; change the definition of an operator class</source>
          <target state="translated">ALTER OPERATOR CLASS &amp;mdash; 연산자 클래스의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="0ba7fb1c4beddce29550f5cb8b66990a01471bb0" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR FAMILY</source>
          <target state="translated">운영자 가족 변경</target>
        </trans-unit>
        <trans-unit id="b145c0d850ce88d5e3be9bd1acd90a4f15ebe361" translate="yes" xml:space="preserve">
          <source>ALTER OPERATOR FAMILY &amp;mdash; change the definition of an operator family</source>
          <target state="translated">ALTER OPERATOR FAMILY &amp;mdash; 운영자 제품군의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="88b3b91499f373dcdd877e9ff64364e5e7e60e0e" translate="yes" xml:space="preserve">
          <source>ALTER POLICY</source>
          <target state="translated">정책 변경</target>
        </trans-unit>
        <trans-unit id="833f3039623c0b1cb3fef4e1e4f83cc843bd962e" translate="yes" xml:space="preserve">
          <source>ALTER POLICY &amp;mdash; change the definition of a row level security policy</source>
          <target state="translated">ALTER POLICY &amp;mdash; 행 수준 보안 정책의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="6a0674112110b72195624944bfa13c57d5d82cb7" translate="yes" xml:space="preserve">
          <source>ALTER PROCEDURE</source>
          <target state="translated">절차 변경</target>
        </trans-unit>
        <trans-unit id="43575de59088420331627e718ac08acff025d18b" translate="yes" xml:space="preserve">
          <source>ALTER PROCEDURE &amp;mdash; change the definition of a procedure</source>
          <target state="translated">ALTER PROCEDURE &amp;mdash; 절차 정의 변경</target>
        </trans-unit>
        <trans-unit id="54107fe026e19d4f5a11e4537d44c6b6d22b8b09" translate="yes" xml:space="preserve">
          <source>ALTER PUBLICATION</source>
          <target state="translated">출판사 변경</target>
        </trans-unit>
        <trans-unit id="9597d926bb8a9acc34d0e5930cb8d7cd0d4f568f" translate="yes" xml:space="preserve">
          <source>ALTER PUBLICATION &amp;mdash; change the definition of a publication</source>
          <target state="translated">ALTER PUBLICATION &amp;mdash; 출판물의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="8d50cc704f5e61444d52d138269e970c84c316a9" translate="yes" xml:space="preserve">
          <source>ALTER ROLE</source>
          <target state="translated">역할 변경</target>
        </trans-unit>
        <trans-unit id="12cc26ef42f3af7ca4348ac6467248637f685960" translate="yes" xml:space="preserve">
          <source>ALTER ROLE &amp;mdash; change a database role</source>
          <target state="translated">ALTER ROLE &amp;mdash; 데이터베이스 역할 변경</target>
        </trans-unit>
        <trans-unit id="4dcea8729953c25416c614a8e9dd74665955b163" translate="yes" xml:space="preserve">
          <source>ALTER ROUTINE</source>
          <target state="translated">대체 루틴</target>
        </trans-unit>
        <trans-unit id="41b74c3c2f66a654560a7c52136c27e28aece24f" translate="yes" xml:space="preserve">
          <source>ALTER ROUTINE &amp;mdash; change the definition of a routine</source>
          <target state="translated">ALTER ROUTINE-루틴 정의 변경</target>
        </trans-unit>
        <trans-unit id="a0e0dff76fa934f2bd1deef6694b1932d808504f" translate="yes" xml:space="preserve">
          <source>ALTER RULE</source>
          <target state="translated">규칙 변경</target>
        </trans-unit>
        <trans-unit id="2fc7414dfcf68c3ac031a4421e6842e26618ab9c" translate="yes" xml:space="preserve">
          <source>ALTER RULE &amp;mdash; change the definition of a rule</source>
          <target state="translated">ALTER RULE &amp;mdash; 규칙의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="d6fc95f83521d1f149e5c2d72ccf2e6275ceff58" translate="yes" xml:space="preserve">
          <source>ALTER SCHEMA</source>
          <target state="translated">ALTER SCHEMA</target>
        </trans-unit>
        <trans-unit id="a9c6d7baa1a1fa5c1ea1e4302e14b9b0b1cbc91f" translate="yes" xml:space="preserve">
          <source>ALTER SCHEMA &amp;mdash; change the definition of a schema</source>
          <target state="translated">ALTER SCHEMA &amp;mdash; 스키마 정의 변경</target>
        </trans-unit>
        <trans-unit id="e0ff1dd3b5bc12676f75f802c39fe58d3f568b91" translate="yes" xml:space="preserve">
          <source>ALTER SEQUENCE</source>
          <target state="translated">순서 변경</target>
        </trans-unit>
        <trans-unit id="75ca9fc88afe8b3a138533f529504e99e65095c7" translate="yes" xml:space="preserve">
          <source>ALTER SEQUENCE &amp;mdash; change the definition of a sequence generator</source>
          <target state="translated">ALTER SEQUENCE &amp;mdash; 시퀀스 생성기의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="4e991c23674edbbd034fbea9f95fd5732fde6594" translate="yes" xml:space="preserve">
          <source>ALTER SERVER</source>
          <target state="translated">대체 서버</target>
        </trans-unit>
        <trans-unit id="9097ec6c4fcb5127ed5acb37df744bf114c59cf4" translate="yes" xml:space="preserve">
          <source>ALTER SERVER &amp;mdash; change the definition of a foreign server</source>
          <target state="translated">ALTER SERVER &amp;mdash; 외부 서버의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="339516769622a8fe113a08ac4316402cbf0b0186" translate="yes" xml:space="preserve">
          <source>ALTER STATISTICS</source>
          <target state="translated">통계 변경</target>
        </trans-unit>
        <trans-unit id="08e64dea134c405908e303c3bf604acf6999c23f" translate="yes" xml:space="preserve">
          <source>ALTER STATISTICS &amp;mdash; change the definition of an extended statistics object</source>
          <target state="translated">ALTER STATISTICS &amp;mdash; 확장 통계 개체의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="10579de4cfd80edf9752f883f553b098d07c2351" translate="yes" xml:space="preserve">
          <source>ALTER SUBSCRIPTION</source>
          <target state="translated">대체 가입</target>
        </trans-unit>
        <trans-unit id="3088c38bfc4248dd70925edc22aa9e03938a70b2" translate="yes" xml:space="preserve">
          <source>ALTER SUBSCRIPTION &amp;mdash; change the definition of a subscription</source>
          <target state="translated">ALTER SUBSCRIPTION &amp;mdash; 구독 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="b751196563736994d3b141da4e3359399f7784c1" translate="yes" xml:space="preserve">
          <source>ALTER SYSTEM</source>
          <target state="translated">시스템 변경</target>
        </trans-unit>
        <trans-unit id="43121748c757e8121439597a27c3d6de3f1df5e0" translate="yes" xml:space="preserve">
          <source>ALTER SYSTEM &amp;mdash; change a server configuration parameter</source>
          <target state="translated">ALTER SYSTEM &amp;mdash; 서버 구성 매개 변수 변경</target>
        </trans-unit>
        <trans-unit id="fcdc3e679260efe34d4720e54eb086a76a15f687" translate="yes" xml:space="preserve">
          <source>ALTER TABLE</source>
          <target state="translated">테이블 변경</target>
        </trans-unit>
        <trans-unit id="afe4c7733f05b900cf17777f836ea5b6c85eae68" translate="yes" xml:space="preserve">
          <source>ALTER TABLE &amp;mdash; change the definition of a table</source>
          <target state="translated">ALTER TABLE &amp;mdash; 테이블 정의 변경</target>
        </trans-unit>
        <trans-unit id="c9732ec2c1c41131709b9ec601102740f5d08528" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE</source>
          <target state="translated">테이블 스페이스 변경</target>
        </trans-unit>
        <trans-unit id="e3e82c20f13259759fc74c305fcf89694aa71e4c" translate="yes" xml:space="preserve">
          <source>ALTER TABLESPACE &amp;mdash; change the definition of a tablespace</source>
          <target state="translated">ALTER TABLESPACE &amp;mdash; 테이블 스페이스의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="ab1241fdf0558dac3416642b6e5e2afa08edd357" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH CONFIGURATION</source>
          <target state="translated">텍스트 검색 구성 변경</target>
        </trans-unit>
        <trans-unit id="2a241bc8e97bcb10c517130c630f0f5969d5e473" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH CONFIGURATION &amp;mdash; change the definition of a text search configuration</source>
          <target state="translated">텍스트 검색 구성 변경 &amp;mdash; 텍스트 검색 구성의 정의를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="a62239565ecd2214c8d0dc9fde76b1033be6c2fc" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH DICTIONARY</source>
          <target state="translated">텍스트 검색 사전</target>
        </trans-unit>
        <trans-unit id="13998d90641b194774e8f12cf56ab5eaead8a314" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH DICTIONARY &amp;mdash; change the definition of a text search dictionary</source>
          <target state="translated">텍스트 검색 사전 변경 &amp;mdash; 텍스트 검색 사전의 정의를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="8179411a0a3b868da4b4880988c7d06f086d844e" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH PARSER</source>
          <target state="translated">텍스트 검색 파서 변경</target>
        </trans-unit>
        <trans-unit id="b487f243ff77599a0ebe244a83985f8acf1c14ea" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH PARSER &amp;mdash; change the definition of a text search parser</source>
          <target state="translated">텍스트 검색 파서 변경 &amp;mdash; 텍스트 검색 파서의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="03386acc96b981e6c35c90b75e2cec735105ea3c" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH TEMPLATE</source>
          <target state="translated">텍스트 검색 템플릿 변경</target>
        </trans-unit>
        <trans-unit id="285dbc8186deb64394ffb30b6e1363ad0dbe6498" translate="yes" xml:space="preserve">
          <source>ALTER TEXT SEARCH TEMPLATE &amp;mdash; change the definition of a text search template</source>
          <target state="translated">텍스트 검색 템플릿 변경 &amp;mdash; 텍스트 검색 템플릿의 정의를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f6742edfb2c8b1a8d27beb1bba87153804373be5" translate="yes" xml:space="preserve">
          <source>ALTER TRIGGER</source>
          <target state="translated">대체 트리거</target>
        </trans-unit>
        <trans-unit id="485c6a654f45ba69729bdbf15496fe29a444d1e3" translate="yes" xml:space="preserve">
          <source>ALTER TRIGGER &amp;mdash; change the definition of a trigger</source>
          <target state="translated">ALTER TRIGGER &amp;mdash; 트리거의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="b8549a9a7b44242713f7d48704380ebba425b154" translate="yes" xml:space="preserve">
          <source>ALTER TYPE</source>
          <target state="translated">대체 유형</target>
        </trans-unit>
        <trans-unit id="2921b9477c2e093e0ed29e1dc88121fdd946417d" translate="yes" xml:space="preserve">
          <source>ALTER TYPE &amp;mdash; change the definition of a type</source>
          <target state="translated">ALTER TYPE &amp;mdash; 유형의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="0f0117db55477563e4484d9879a151cbea4a27fc" translate="yes" xml:space="preserve">
          <source>ALTER USER</source>
          <target state="translated">사용자 변경</target>
        </trans-unit>
        <trans-unit id="dc349b6f52ce0d7d5bb23382932a5eb2f67eac63" translate="yes" xml:space="preserve">
          <source>ALTER USER &amp;mdash; change a database role</source>
          <target state="translated">ALTER USER &amp;mdash; 데이터베이스 역할 변경</target>
        </trans-unit>
        <trans-unit id="a375773515175c08cd7fc8e357c209c60d07f13e" translate="yes" xml:space="preserve">
          <source>ALTER USER MAPPING</source>
          <target state="translated">사용자 매핑 변경</target>
        </trans-unit>
        <trans-unit id="84dbc6c571c120a8defca7e0a6c086e648f98854" translate="yes" xml:space="preserve">
          <source>ALTER USER MAPPING &amp;mdash; change the definition of a user mapping</source>
          <target state="translated">ALTER USER MAPPING &amp;mdash; 사용자 매핑의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="219d78bab64e4f5637643b61ce738d2b84487f00" translate="yes" xml:space="preserve">
          <source>ALTER VIEW</source>
          <target state="translated">변경보기</target>
        </trans-unit>
        <trans-unit id="d3ae485ff52fa79c183c7d3ce9f751addfed0468" translate="yes" xml:space="preserve">
          <source>ALTER VIEW &amp;mdash; change the definition of a view</source>
          <target state="translated">ALTER VIEW &amp;mdash;보기의 정의를 변경합니다</target>
        </trans-unit>
        <trans-unit id="caadd138e6e8d1596eda80c0f51c856600e89f65" translate="yes" xml:space="preserve">
          <source>ANALYZE</source>
          <target state="translated">ANALYZE</target>
        </trans-unit>
        <trans-unit id="21b8417695362cfdc412c95c44c48fa648556dd9" translate="yes" xml:space="preserve">
          <source>ANALYZE &amp;mdash; collect statistics about a database</source>
          <target state="translated">분석 &amp;mdash; 데이터베이스에 대한 통계 수집</target>
        </trans-unit>
        <trans-unit id="e2f2d6cea163ef0dacf4540366528f7c7edd61f2" translate="yes" xml:space="preserve">
          <source>AND &lt;code&gt;tsquery&lt;/code&gt;s together</source>
          <target state="translated">AND &lt;code&gt;tsquery&lt;/code&gt; 함께</target>
        </trans-unit>
        <trans-unit id="8824eb37da0438275c17449687050c5930f6be40" translate="yes" xml:space="preserve">
          <source>ANDs two &lt;code&gt;tsquery&lt;/code&gt;s together, producing a query that matches documents that match both input queries.</source>
          <target state="translated">두 개의 &lt;code&gt;tsquery&lt;/code&gt; 를 AND로 연결 하여 두 입력 쿼리와 일치하는 문서와 일치하는 쿼리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="09b52ce6d8d3ca14c041a1ecfe44ca34c84c93c5" translate="yes" xml:space="preserve">
          <source>ANSI</source>
          <target state="translated">ANSI</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="94090230b1f8c256f7ac5dc5a70bd3b20ee4ff15" translate="yes" xml:space="preserve">
          <source>ASCII</source>
          <target state="translated">ASCII</target>
        </trans-unit>
        <trans-unit id="5fb9ba93128c23898a1b0a61ebd44810a0c6b606" translate="yes" xml:space="preserve">
          <source>ASCII code of the first character of the argument. For UTF8 returns the Unicode code point of the character. For other multibyte encodings, the argument must be an ASCII character.</source>
          <target state="translated">인수의 첫 문자의 ASCII 코드 UTF8의 경우 문자의 유니 코드 코드 포인트를 리턴합니다. 다른 멀티 바이트 인코딩의 경우 인수는 ASCII 문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7647bd700c1c10eb12b5de06bf40a88672e3451d" translate="yes" xml:space="preserve">
          <source>Aaron D. Gifford</source>
          <target state="translated">아론 디.</target>
        </trans-unit>
        <trans-unit id="cd437865cbac7655f8b86519aea764f378093804" translate="yes" xml:space="preserve">
          <source>Abbreviation</source>
          <target state="translated">Abbreviation</target>
        </trans-unit>
        <trans-unit id="1bb9eda0dcf4611f958758d0ccd51e13bf341710" translate="yes" xml:space="preserve">
          <source>Abbreviation (for Pacific Standard Time)</source>
          <target state="translated">약어 (태평양 표준시)</target>
        </trans-unit>
        <trans-unit id="a90aba13b6feb8ff1a5141d94cb1fc2fe96e9477" translate="yes" xml:space="preserve">
          <source>Abbreviations</source>
          <target state="translated">Abbreviations</target>
        </trans-unit>
        <trans-unit id="c5fd5b17ae3c41e41caede4fa07a5960ba1a5f2d" translate="yes" xml:space="preserve">
          <source>Abort any statement that takes more than the specified amount of time. If &lt;code&gt;log_min_error_statement&lt;/code&gt; is set to &lt;code&gt;ERROR&lt;/code&gt; or lower, the statement that timed out will also be logged. If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">지정된 시간보다 오래 걸리는 문장을 중단하십시오. &lt;code&gt;log_min_error_statement&lt;/code&gt; 가 &lt;code&gt;ERROR&lt;/code&gt; 이하 로 설정 되면 시간 종료 된 명령문도 로그됩니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 값이 0 (기본값)이면 시간 초과가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6c33aee3e89187438edae43ea18855e5962050c2" translate="yes" xml:space="preserve">
          <source>Abort any statement that waits longer than the specified amount of time while attempting to acquire a lock on a table, index, row, or other database object. The time limit applies separately to each lock acquisition attempt. The limit applies both to explicit locking requests (such as &lt;code&gt;LOCK TABLE&lt;/code&gt;, or &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; without &lt;code&gt;NOWAIT&lt;/code&gt;) and to implicitly-acquired locks. If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.</source>
          <target state="translated">테이블, 인덱스, 행 또는 기타 데이터베이스 오브젝트에 대한 잠금을 확보하려고 시도하는 동안 지정된 시간보다 오래 기다리는 명령문을 중단하십시오. 시간 제한은 각 잠금 획득 시도에 별도로 적용됩니다. 제한은 명시 적 잠금 요청 ( &lt;code&gt;LOCK TABLE&lt;/code&gt; 또는 &lt;code&gt;NOWAIT&lt;/code&gt; 없이 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 와 같은 ) 및 내재적으로 획득 된 잠금 모두에 적용됩니다. 이 값을 단위없이 지정하면 밀리 초로 간주됩니다. 값이 0 (기본값)이면 시간 초과가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="82c17c3ccfec7ab27999f74c3eae394cb4e66713" translate="yes" xml:space="preserve">
          <source>Above, since there is no &lt;code&gt;ORDER BY&lt;/code&gt; in the &lt;code&gt;OVER&lt;/code&gt; clause, the window frame is the same as the partition, which for lack of &lt;code&gt;PARTITION BY&lt;/code&gt; is the whole table; in other words each sum is taken over the whole table and so we get the same result for each output row. But if we add an &lt;code&gt;ORDER BY&lt;/code&gt; clause, we get very different results:</source>
          <target state="translated">위 의 &lt;code&gt;OVER&lt;/code&gt; 절 에 &lt;code&gt;ORDER BY&lt;/code&gt; 가 없기 때문에 창 프레임은 파티션과 동일하며 &lt;code&gt;PARTITION BY&lt;/code&gt; 가 없으면 전체 테이블입니다. 다시 말해 각 합계는 전체 테이블에 적용되므로 각 출력 행에 대해 동일한 결과를 얻습니다. 그러나 &lt;code&gt;ORDER BY&lt;/code&gt; 절을 추가하면 매우 다른 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="35e4a1a9ace5e53c1521b13130f3b1fce0bb312b" translate="yes" xml:space="preserve">
          <source>Absolute value</source>
          <target state="translated">절대 값</target>
        </trans-unit>
        <trans-unit id="ecc48669a5f045e0b1c73515a6a06d3751ca7ca3" translate="yes" xml:space="preserve">
          <source>Absolute value of the SQL/JSON number</source>
          <target state="translated">SQL / JSON 번호의 절대 값</target>
        </trans-unit>
        <trans-unit id="adaf687cef3a864875d03ee7f1764cbc49564164" translate="yes" xml:space="preserve">
          <source>Absolute value of the given number</source>
          <target state="translated">주어진 숫자의 절대 값</target>
        </trans-unit>
        <trans-unit id="95ecf27dff51c67220f14d51d8af97b6912bfba7" translate="yes" xml:space="preserve">
          <source>Access Exclusive locks taken on the primary server, including both explicit &lt;code&gt;LOCK&lt;/code&gt; commands and various DDL actions, conflict with table accesses in standby queries.</source>
          <target state="translated">명시 적 &lt;code&gt;LOCK&lt;/code&gt; 명령과 다양한 DDL 작업을 포함하여 기본 서버에서 수행되는 독점 잠금 은 대기 쿼리의 테이블 액세스와 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="446d3f34dfbff4e7c337ef9e7b895902f1dba9ef" translate="yes" xml:space="preserve">
          <source>Access methods that always return entries in the natural ordering of their data (such as btree) should set &lt;code&gt;amcanorder&lt;/code&gt; to true. Currently, such access methods must use btree-compatible strategy numbers for their equality and ordering operators.</source>
          <target state="translated">데이터의 자연 순서 (예 : btree)로 항목을 항상 반환하는 액세스 방법은 &lt;code&gt;amcanorder&lt;/code&gt; 를 true로 설정해야 합니다. 현재 이러한 액세스 방법은 동등성 및 순서 연산자에 대해 btree 호환 전략 번호를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0e23c5a90203bbd16a6b86de50258944a0ed57a" translate="yes" xml:space="preserve">
          <source>Access methods that support ordered scans must support &amp;ldquo;marking&amp;rdquo; a position in a scan and later returning to the marked position. The same position might be restored multiple times. However, only one position need be remembered per scan; a new &lt;code&gt;ammarkpos&lt;/code&gt; call overrides the previously marked position. An access method that does not support ordered scans need not provide &lt;code&gt;ammarkpos&lt;/code&gt; and &lt;code&gt;amrestrpos&lt;/code&gt; functions in &lt;code&gt;IndexAmRoutine&lt;/code&gt;; set those pointers to NULL instead.</source>
          <target state="translated">정렬 된 스캔을 지원하는 액세스 방법은 스캔에서 위치를 &quot;마킹&quot;하고 나중에 표시된 위치로 돌아 오는 것을 지원해야합니다. 동일한 위치가 여러 번 복원 될 수 있습니다. 그러나 스캔 당 하나의 위치 만 기억하면됩니다. 새로운 &lt;code&gt;ammarkpos&lt;/code&gt; 호출은 이전에 표시된 위치를 대체합니다. 제공하지 않아도 주문 스캔을 지원하지 않는 액세스 방법 &lt;code&gt;ammarkpos&lt;/code&gt; 및 &lt;code&gt;amrestrpos&lt;/code&gt; 의 기능을 &lt;code&gt;IndexAmRoutine&lt;/code&gt; 을 ; 대신 포인터를 NULL로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0fdc357a629c5f7047a03e768a0792d5cbb44b9a" translate="yes" xml:space="preserve">
          <source>Access methods that support ordering operators should implement &lt;code&gt;AMPROP_DISTANCE_ORDERABLE&lt;/code&gt; property testing, as the core code does not know how to do that and will return NULL. It may also be advantageous to implement &lt;code&gt;AMPROP_RETURNABLE&lt;/code&gt; testing, if that can be done more cheaply than by opening the index and calling &lt;code&gt;amcanreturn&lt;/code&gt;, which is the core code's default behavior. The default behavior should be satisfactory for all other standard properties.</source>
          <target state="translated">순서 연산자를 지원하는 액세스 메소드는 &lt;code&gt;AMPROP_DISTANCE_ORDERABLE&lt;/code&gt; 특성 테스트를 구현해야 합니다. 코어 코드는이를 수행하는 방법을 모르고 NULL을 리턴하기 때문입니다. 인덱스를 열고 코어 코드의 기본 동작 인 &lt;code&gt;amcanreturn&lt;/code&gt; 을 호출하는 것보다 저렴하게 수행 할 수있는 경우 &lt;code&gt;AMPROP_RETURNABLE&lt;/code&gt; 테스트 를 구현하는 것이 유리할 수도 있습니다 . 기본 동작은 다른 모든 표준 속성에 만족해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec93e5f340df1c63a8b7900c8c64d2c56b99c607" translate="yes" xml:space="preserve">
          <source>Access methods that support ordering operators should set &lt;code&gt;amcanorderbyop&lt;/code&gt; to true. This indicates that the index is capable of returning entries in an order satisfying &lt;code&gt;ORDER BY&lt;/code&gt;&lt;code&gt;index_key&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;constant&lt;/code&gt;. Scan modifiers of that form can be passed to &lt;code&gt;amrescan&lt;/code&gt; as described previously.</source>
          <target state="translated">순서 연산자를 지원하는 액세스 방법은 &lt;code&gt;amcanorderbyop&lt;/code&gt; 을 true로 설정해야 합니다. 이것은 인덱스가 &lt;code&gt;ORDER BY&lt;/code&gt; &lt;code&gt;index_key&lt;/code&gt; &lt;code&gt;operator&lt;/code&gt; &lt;code&gt;constant&lt;/code&gt; 만족하는 순서로 항목을 리턴 할 수 있음을 나타냅니다 . 해당 양식의 스캔 수정자는 앞에서 설명한대로 &lt;code&gt;amrescan&lt;/code&gt; 으로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d5da75b46e072ddd4591be60d218524fe1f309e" translate="yes" xml:space="preserve">
          <source>Access privileges for template (not actually used)</source>
          <target state="translated">템플릿에 대한 액세스 권한 (실제로는 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="85f3b04d8d02176eeb1578817040415abfa34698" translate="yes" xml:space="preserve">
          <source>Access privileges that this type of object should have on creation</source>
          <target state="translated">이 유형의 객체가 작성시 가져야하는 액세스 권한</target>
        </trans-unit>
        <trans-unit id="3d73c85183e638c3a5d257c026ae2497dddb1f32" translate="yes" xml:space="preserve">
          <source>Access privileges; see &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for details</source>
          <target state="translated">접근 권한; 자세한 내용 &lt;a href=&quot;ddl-priv&quot;&gt;은 5.7 절&lt;/a&gt; 을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="02bbd73371e69fa85fa69f734c586e2358313738" translate="yes" xml:space="preserve">
          <source>Access to tables referenced in the view is determined by permissions of the view owner. In some cases, this can be used to provide secure but restricted access to the underlying tables. However, not all views are secure against tampering; see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for details. Functions called in the view are treated the same as if they had been called directly from the query using the view. Therefore the user of a view must have permissions to call all functions used by the view.</source>
          <target state="translated">뷰에서 참조 된 테이블에 대한 액세스는 뷰 소유자의 권한에 의해 결정됩니다. 경우에 따라 기본 테이블에 대한 안전하지만 제한된 액세스를 제공하는 데 사용할 수 있습니다. 그러나 모든 견해가 변조에 대해 안전한 것은 아닙니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;섹션 40.5&lt;/a&gt; 를 참조하십시오. 뷰에서 호출 된 함수는 뷰를 사용하여 쿼리에서 직접 호출 된 것처럼 동일하게 취급됩니다. 따라서 뷰 사용자에게는 뷰에서 사용하는 모든 함수를 호출 할 수있는 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c4369eb157086a70b7378313eb6ff8fc4fe92c26" translate="yes" xml:space="preserve">
          <source>Access to tables referenced in the view is determined by permissions of the view owner. In some cases, this can be used to provide secure but restricted access to the underlying tables. However, not all views are secure against tampering; see &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt; for details. Functions called in the view are treated the same as if they had been called directly from the query using the view. Therefore the user of a view must have permissions to call all functions used by the view.</source>
          <target state="translated">뷰에서 참조되는 테이블에 대한 액세스는 뷰 소유자의 권한에 따라 결정됩니다. 어떤 경우에는 기본 테이블에 대한 안전하지만 제한된 액세스를 제공하는 데 사용할 수 있습니다. 그러나 모든 뷰가 변조에 대해 안전한 것은 아닙니다. 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;섹션 40.5&lt;/a&gt; 를 참조하십시오. 뷰에서 호출 된 함수는 뷰를 사용하여 쿼리에서 직접 호출 된 것과 동일하게 처리됩니다. 따라서보기의 사용자는보기에서 사용하는 모든 함수를 호출 할 수있는 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ea538985d43ba38411a22fc78790edc64739cd94" translate="yes" xml:space="preserve">
          <source>Access to the column &lt;code&gt;subconninfo&lt;/code&gt; is revoked from normal users, because it could contain plain-text passwords.</source>
          <target state="translated">&lt;code&gt;subconninfo&lt;/code&gt; 열에 대한 액세스 는 일반 텍스트 비밀번호를 포함 할 수 있기 때문에 일반 사용자로부터 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="709b98ad6555808775120e3c01cba15666c7c18d" translate="yes" xml:space="preserve">
          <source>Access to the table &lt;code&gt;pg_statistic&lt;/code&gt; is restricted to superusers, so that ordinary users cannot learn about the contents of the tables of other users from it. Some selectivity estimation functions will use a user-provided operator (either the operator appearing in the query or a related operator) to analyze the stored statistics. For example, in order to determine whether a stored most common value is applicable, the selectivity estimator will have to run the appropriate &lt;code&gt;=&lt;/code&gt; operator to compare the constant in the query to the stored value. Thus the data in &lt;code&gt;pg_statistic&lt;/code&gt; is potentially passed to user-defined operators. An appropriately crafted operator can intentionally leak the passed operands (for example, by logging them or writing them to a different table), or accidentally leak them by showing their values in error messages, in either case possibly exposing data from &lt;code&gt;pg_statistic&lt;/code&gt; to a user who should not be able to see it.</source>
          <target state="translated">&lt;code&gt;pg_statistic&lt;/code&gt; 테이블에 대한 액세스 는 수퍼 유저로 제한되므로 일반 사용자는 다른 사용자의 테이블 내용을 알 수 없습니다. 일부 선택성 추정 함수는 사용자 제공 연산자 (조회에 나타나는 연산자 또는 관련 연산자)를 사용하여 저장된 통계를 분석합니다. 예를 들어, 저장된 가장 일반적인 값이 적용 가능한지 확인하려면 선택성 추정기는 쿼리의 상수를 저장된 값과 비교하기 위해 적절한 &lt;code&gt;=&lt;/code&gt; 연산자를 실행해야 합니다. 따라서 &lt;code&gt;pg_statistic&lt;/code&gt; 의 데이터잠재적으로 사용자 정의 연산자로 전달됩니다. 적절하게 조작 된 연산자는 전달 된 피연산자를 의도적으로 유출하거나 (예 : 기록하거나 다른 테이블에 기록) 실수로 &lt;code&gt;pg_statistic&lt;/code&gt; 에서 사용자에게 데이터를 노출시키는 경우 오류 메시지에 값을 표시하여 실수로 유출 할 수 있습니다. 그것을 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a19557158b233d91213a81525eeee59ee4fa2d0a" translate="yes" xml:space="preserve">
          <source>Access-method-specific options, as &amp;ldquo;keyword=value&amp;rdquo; strings</source>
          <target state="translated">&amp;ldquo;키워드 = 값&amp;rdquo;문자열과 같은 액세스 방법 별 옵션</target>
        </trans-unit>
        <trans-unit id="bdebd3af85014736552b079e90a39e39b6b4b3f6" translate="yes" xml:space="preserve">
          <source>Accessing remote data may require authenticating to the external data source. This information can be provided by a &lt;em&gt;user mapping&lt;/em&gt;, which can provide additional data such as user names and passwords based on the current PostgreSQL role.</source>
          <target state="translated">원격 데이터에 액세스하려면 외부 데이터 소스에 대한 인증이 필요할 수 있습니다. 이 정보는 현재 PostgreSQL 역할에 따라 사용자 이름 및 비밀번호와 같은 추가 데이터를 제공 할 수 있는 &lt;em&gt;사용자 매핑을&lt;/em&gt; 통해 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52fe1ef73da9bdc5400467df47e965d263b34732" translate="yes" xml:space="preserve">
          <source>Accessor Operator</source>
          <target state="translated">접근 자 연산자</target>
        </trans-unit>
        <trans-unit id="af39d0c333f65451fb8a7cecb17f3d648babe73c" translate="yes" xml:space="preserve">
          <source>Accessor operators listed in &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;Table 8.25&lt;/a&gt;.</source>
          <target state="translated">에 나열된 접근 사업자 &lt;a href=&quot;datatype-json#TYPE-JSONPATH-ACCESSORS&quot;&gt;표 8.25&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a90102b6831b1be9c270ce8e277051052e425746" translate="yes" xml:space="preserve">
          <source>According to the SQL standard all fields of an interval value must have the same sign, so a leading negative sign applies to all fields; for example the negative sign in the interval literal &lt;code&gt;'-1 2:03:04'&lt;/code&gt; applies to both the days and hour/minute/second parts. PostgreSQL allows the fields to have different signs, and traditionally treats each field in the textual representation as independently signed, so that the hour/minute/second part is considered positive in this example. If &lt;code&gt;IntervalStyle&lt;/code&gt; is set to &lt;code&gt;sql_standard&lt;/code&gt; then a leading sign is considered to apply to all fields (but only if no additional signs appear). Otherwise the traditional PostgreSQL interpretation is used. To avoid ambiguity, it's recommended to attach an explicit sign to each field if any field is negative.</source>
          <target state="translated">SQL 표준에 따르면 간격 값의 모든 필드는 동일한 부호를 가져야하므로 선행 음수 부호가 모든 필드에 적용됩니다. 예를 들어 간격 리터럴 &lt;code&gt;'-1 2:03:04'&lt;/code&gt; 의 음수 부호 는 일 및시 / 분 / 초 부분에 모두 적용됩니다. PostgreSQL은 필드가 서로 다른 부호를 가질 수있게하며 전통적으로 텍스트 표현의 각 필드를 독립적으로 부호가있는 것으로 취급하므로이 예제에서는 시간 / 분 / 초 부분이 양수로 간주됩니다. &lt;code&gt;IntervalStyle&lt;/code&gt; 이 &lt;code&gt;sql_standard&lt;/code&gt; 로 설정된 경우그런 다음 선행 기호는 모든 필드에 적용되는 것으로 간주됩니다 (단, 추가 기호가 나타나지 않는 경우에만). 그렇지 않으면 전통적인 PostgreSQL 해석이 사용됩니다. 모호성을 피하려면 필드가 음수이면 각 필드에 명시 적 부호를 첨부하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3aa4c2f095ab9191962811c65fa85311b6575f00" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, grant options can be granted to &lt;code&gt;PUBLIC&lt;/code&gt;; PostgreSQL only supports granting grant options to roles.</source>
          <target state="translated">SQL 표준에 따라 권한 부여 옵션을 &lt;code&gt;PUBLIC&lt;/code&gt; 에 부여 할 수 있습니다 . PostgreSQL은 역할에 부여 옵션 부여 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1ead55767cf3a2e09a221c81670b8f16ce3da10d" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, omitting &lt;code&gt;ESCAPE&lt;/code&gt; means there is no escape character (rather than defaulting to a backslash), and a zero-length &lt;code&gt;ESCAPE&lt;/code&gt; value is disallowed. PostgreSQL's behavior in this regard is therefore slightly nonstandard.</source>
          <target state="translated">SQL 표준에 따르면 &lt;code&gt;ESCAPE&lt;/code&gt; 를 생략하면 이스케이프 문자가없고 (기본값은 백 슬래시가 아님), 길이가 0 인 &lt;code&gt;ESCAPE&lt;/code&gt; 값은 허용되지 않습니다. 따라서 이와 관련하여 PostgreSQL의 동작은 약간 비표준입니다.</target>
        </trans-unit>
        <trans-unit id="b56b4e7b5de2231618fd8815a2cda445e53356b4" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, specifying either &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; is required in a &lt;code&gt;DROP&lt;/code&gt; command. No database system actually enforces that rule, but whether the default behavior is &lt;code&gt;RESTRICT&lt;/code&gt; or &lt;code&gt;CASCADE&lt;/code&gt; varies across systems.</source>
          <target state="translated">SQL 표준에 따르면 &lt;code&gt;DROP&lt;/code&gt; 명령 에 &lt;code&gt;RESTRICT&lt;/code&gt; 또는 &lt;code&gt;CASCADE&lt;/code&gt; 를 지정 해야합니다 . 실제로 해당 규칙을 적용하는 데이터베이스 시스템은 없지만 기본 동작이 &lt;code&gt;RESTRICT&lt;/code&gt; 인지 &lt;code&gt;CASCADE&lt;/code&gt; 인지 는 시스템마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2656819b0489db63b95d67c6ca681b0ebbff6d9d" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the &lt;code&gt;PRIVILEGES&lt;/code&gt; key word in &lt;code&gt;ALL PRIVILEGES&lt;/code&gt; is required. The SQL standard does not support setting the privileges on more than one object per command.</source>
          <target state="translated">SQL 표준에 따르면 &lt;code&gt;ALL PRIVILEGES&lt;/code&gt; 의 &lt;code&gt;PRIVILEGES&lt;/code&gt; 키워드 가 필요합니다. SQL 표준은 명령 당 둘 이상의 오브젝트에 대한 권한 설정을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63bbcd2e4bc83757343815f2d0c5cf6131ae122b" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the command to set this option is</source>
          <target state="translated">SQL 표준에 따르면이 옵션을 설정하는 명령은</target>
        </trans-unit>
        <trans-unit id="4b8f45ef50c256265d9c97855d8b0d2a0f3dde8f" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the expressions in the output list should be computed before applying &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt;, or &lt;code&gt;LIMIT&lt;/code&gt;. This is obviously necessary when using &lt;code&gt;DISTINCT&lt;/code&gt;, since otherwise it's not clear what values are being made distinct. However, in many cases it is convenient if output expressions are computed after &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt;; particularly if the output list contains any volatile or expensive functions. With that behavior, the order of function evaluations is more intuitive and there will not be evaluations corresponding to rows that never appear in the output. PostgreSQL will effectively evaluate output expressions after sorting and limiting, so long as those expressions are not referenced in &lt;code&gt;DISTINCT&lt;/code&gt;, &lt;code&gt;ORDER BY&lt;/code&gt; or &lt;code&gt;GROUP BY&lt;/code&gt;. (As a counterexample, &lt;code&gt;SELECT f(x) FROM tab ORDER BY 1&lt;/code&gt; clearly must evaluate &lt;code&gt;f(x)&lt;/code&gt; before sorting.) Output expressions that contain set-returning functions are effectively evaluated after sorting and before limiting, so that &lt;code&gt;LIMIT&lt;/code&gt; will act to cut off the output from a set-returning function.</source>
          <target state="translated">SQL 표준에 따르면 &lt;code&gt;DISTINCT&lt;/code&gt; , &lt;code&gt;ORDER BY&lt;/code&gt; 또는 &lt;code&gt;LIMIT&lt;/code&gt; 를 적용하기 전에 출력 목록의 표현식을 계산해야합니다 . &lt;code&gt;DISTINCT&lt;/code&gt; 를 사용할 때 분명히 필요합니다. 그렇지 않으면 어떤 값이 구별되는지 명확하지 않기 때문입니다. 그러나 많은 경우에 &lt;code&gt;ORDER BY&lt;/code&gt; 및 &lt;code&gt;LIMIT&lt;/code&gt; 후에 출력 표현식이 계산되는 것이 편리합니다.; 특히 출력 목록에 휘발성 또는 고가의 기능이 포함 된 경우. 이 동작을 사용하면 함수 평가 순서가보다 직관적이며 출력에 절대 나타나지 않는 행에 해당하는 평가는 없습니다. PostgreSQL은 &lt;code&gt;DISTINCT&lt;/code&gt; , &lt;code&gt;ORDER BY&lt;/code&gt; 또는 &lt;code&gt;GROUP BY&lt;/code&gt; 에서 해당 표현식이 참조되지 않는 한 정렬 및 제한 후 출력 표현식을 효과적으로 평가합니다 . (반대 예로서, &lt;code&gt;SELECT f(x) FROM tab ORDER BY 1&lt;/code&gt; 은 정렬하기 전에 &lt;code&gt;f(x)&lt;/code&gt; 를 명확하게 평가해야합니다 .) set-returning 함수를 포함하는 출력 표현식은 정렬 후 및 제한 전에 효과적으로 평가되므로 &lt;code&gt;LIMIT&lt;/code&gt; set-returning 기능에서 출력을 차단하는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="6db467e85d8317c698e30a66a7291c8eafa6149b" translate="yes" xml:space="preserve">
          <source>According to the SQL standard, the owner of a schema always owns all objects within it. PostgreSQL allows schemas to contain objects owned by users other than the schema owner. This can happen only if the schema owner grants the &lt;code&gt;CREATE&lt;/code&gt; privilege on their schema to someone else, or a superuser chooses to create objects in it.</source>
          <target state="translated">SQL 표준에 따르면 스키마 소유자는 항상 스키마 내의 모든 개체를 소유합니다. PostgreSQL을 사용하면 스키마 소유자 이외의 사용자가 소유 한 객체를 스키마에 포함 할 수 있습니다. 스키마 소유자 가 자신의 스키마에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한을 다른 사람 에게 부여 하거나 수퍼 유저가 개체를 만들도록 선택한 경우에만 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b39ba80593aea6c161c39dff62ffc2f0348762e" translate="yes" xml:space="preserve">
          <source>According to the comp.ai.genetic FAQ it cannot be stressed too strongly that a GA is not a pure random search for a solution to a problem. A GA uses stochastic processes, but the result is distinctly non-random (better than random).</source>
          <target state="translated">comp.ai.genetic FAQ에 따르면 GA가 문제에 대한 해결책을 찾기위한 순수한 무작위 검색이 아니라고 너무 강조 할 수는 없습니다. GA는 확률 적 프로세스를 사용하지만 결과는 임의적이지 않습니다 (무작위보다 낫습니다).</target>
        </trans-unit>
        <trans-unit id="2666b06563be42700b836e6d4059dfb52c4a608d" translate="yes" xml:space="preserve">
          <source>According to the standard, the first two characters of an error code denote a class of errors, while the last three characters indicate a specific condition within that class. Thus, an application that does not recognize the specific error code might still be able to infer what to do from the error class.</source>
          <target state="translated">표준에 따르면 오류 코드의 처음 두 문자는 오류 클래스를 나타내고 마지막 세 문자는 해당 클래스 내의 특정 조건을 나타냅니다. 따라서 특정 오류 코드를 인식하지 못하는 응용 프로그램은 여전히 ​​오류 클래스에서 수행 할 작업을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61abcddacf93fafde9cc0a4bb6f9d2b6e919d03c" translate="yes" xml:space="preserve">
          <source>According to the standard, the source value for a parenthesized sub-list of target column names can be any row-valued expression yielding the correct number of columns. PostgreSQL only allows the source value to be a &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;row constructor&lt;/a&gt; or a sub-&lt;code&gt;SELECT&lt;/code&gt;. An individual column's updated value can be specified as &lt;code&gt;DEFAULT&lt;/code&gt; in the row-constructor case, but not inside a sub-&lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">표준에 따르면 대상 열 이름의 괄호로 묶인 하위 목록의 소스 값은 올바른 열 수를 생성하는 행 값 식일 수 있습니다. PostgreSQL에서는 소스 값만 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ROW-CONSTRUCTORS&quot;&gt;행 생성자&lt;/a&gt; 또는 하위 &lt;code&gt;SELECT&lt;/code&gt; 가 될 수 있습니다 . 행 생성자의 경우 개별 열의 업데이트 된 값을 &lt;code&gt;DEFAULT&lt;/code&gt; 로 지정할 수 있지만 하위 &lt;code&gt;SELECT&lt;/code&gt; 안에는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0980056b7787afbd8fbd30571ba2c45b1dbaa749" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;CREATE INDEX&lt;/code&gt; (without &lt;code&gt;CONCURRENTLY&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; 에 의해 획득 ( &lt;code&gt;CONCURRENTLY&lt;/code&gt; 없이 ).</target>
        </trans-unit>
        <trans-unit id="e44eba7914f83fb7f73f8f0a727d44ad52ee7677" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;CREATE TRIGGER&lt;/code&gt; and some forms of &lt;code&gt;ALTER TABLE&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;CREATE TRIGGER&lt;/code&gt; 및 일부 &lt;code&gt;ALTER TABLE&lt;/code&gt; 형식으로 획득합니다 ( &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c03704a90b839a00364666b3432c1fe877f7cfa4" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;REFRESH MATERIALIZED VIEW CONCURRENTLY&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;REFRESH MATERIALIZED VIEW CONCURRENTLY&lt;/code&gt; 통해 획득했습니다 .</target>
        </trans-unit>
        <trans-unit id="35b293b84736887604a4df3e4f117c1dcc96bdfc" translate="yes" xml:space="preserve">
          <source>Acquired by &lt;code&gt;VACUUM&lt;/code&gt; (without &lt;code&gt;FULL&lt;/code&gt;), &lt;code&gt;ANALYZE&lt;/code&gt;, &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt;, &lt;code&gt;CREATE STATISTICS&lt;/code&gt;, and certain &lt;code&gt;ALTER INDEX&lt;/code&gt; and &lt;code&gt;ALTER TABLE&lt;/code&gt; variants (for full details see &lt;a href=&quot;sql-alterindex&quot;&gt;ALTER INDEX&lt;/a&gt; and &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; ( &lt;code&gt;FULL&lt;/code&gt; 없이 ), &lt;code&gt;ANALYZE&lt;/code&gt; , &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; , &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; , &lt;code&gt;CREATE STATISTICS&lt;/code&gt; 및 특정 &lt;code&gt;ALTER INDEX&lt;/code&gt; 및 &lt;code&gt;ALTER TABLE&lt;/code&gt; 변형에 의해 획득됩니다 ( 자세한 내용은 &lt;a href=&quot;sql-alterindex&quot;&gt;ALTER INDEX&lt;/a&gt; 및 &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4a64648cce36216f47287c3873ec5299a8307659" translate="yes" xml:space="preserve">
          <source>Acquired by the &lt;code&gt;DROP TABLE&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt;, &lt;code&gt;VACUUM FULL&lt;/code&gt;, and &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; (without &lt;code&gt;CONCURRENTLY&lt;/code&gt;) commands. Many forms of &lt;code&gt;ALTER INDEX&lt;/code&gt; and &lt;code&gt;ALTER TABLE&lt;/code&gt; also acquire a lock at this level. This is also the default lock mode for &lt;code&gt;LOCK TABLE&lt;/code&gt; statements that do not specify a mode explicitly.</source>
          <target state="translated">&lt;code&gt;DROP TABLE&lt;/code&gt; , &lt;code&gt;TRUNCATE&lt;/code&gt; , &lt;code&gt;REINDEX&lt;/code&gt; , &lt;code&gt;CLUSTER&lt;/code&gt; , &lt;code&gt;VACUUM FULL&lt;/code&gt; 및 &lt;code&gt;REFRESH MATERIALIZED VIEW&lt;/code&gt; ( &lt;code&gt;CONCURRENTLY&lt;/code&gt; 없이 ) 명령으로 획득 합니다. 여러 형태의 &lt;code&gt;ALTER INDEX&lt;/code&gt; 및 &lt;code&gt;ALTER TABLE&lt;/code&gt; 도이 수준에서 잠금을 획득합니다. 또한 명시 적으로 모드를 지정하지 않은 &lt;code&gt;LOCK TABLE&lt;/code&gt; 문의 기본 잠금 모드입니다 .</target>
        </trans-unit>
        <trans-unit id="116672ae6ceb211b89b5cc24d53045f44bb76b12" translate="yes" xml:space="preserve">
          <source>Acronyms</source>
          <target state="translated">Acronyms</target>
        </trans-unit>
        <trans-unit id="a43a7e7ff4a4d6f955aa729ae7ff758305e7b11f" translate="yes" xml:space="preserve">
          <source>Active txids at the time of the snapshot. The list includes only those active txids between &lt;code&gt;xmin&lt;/code&gt; and &lt;code&gt;xmax&lt;/code&gt;; there might be active txids higher than &lt;code&gt;xmax&lt;/code&gt;. A txid that is &lt;code&gt;xmin &amp;lt;= txid &amp;lt; xmax&lt;/code&gt; and not in this list was already completed at the time of the snapshot, and thus either visible or dead according to its commit status. The list does not include txids of subtransactions.</source>
          <target state="translated">스냅 샷 시점의 활성 txid 이 목록에는 &lt;code&gt;xmin&lt;/code&gt; 과 &lt;code&gt;xmax&lt;/code&gt; 사이의 활성 txid 만 포함됩니다 . &lt;code&gt;xmax&lt;/code&gt; 보다 높은 활성 txid가있을 수 있습니다 . TxID 삽입 즉 &lt;code&gt;xmin &amp;lt;= txid &amp;lt; xmax&lt;/code&gt; 그 상태를 커밋이 목록에 이미 스냅 숏시에 완료되므로 어느 보이거나 죽은있어서 아니었다. 리스트에는 서브 트랜잭션의 txid가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="409557212ade1f78b39e4494cd71d7a5778b675f" translate="yes" xml:space="preserve">
          <source>Activity status of the WAL receiver process</source>
          <target state="translated">WAL 수신자 프로세스의 활동 상태</target>
        </trans-unit>
        <trans-unit id="5074d759e3f5dbe3c6aa005b1369aadfa7087d57" translate="yes" xml:space="preserve">
          <source>Actual data stored in the large object. This will never be more than &lt;code&gt;LOBLKSIZE&lt;/code&gt; bytes and might be less.</source>
          <target state="translated">큰 객체에 저장된 실제 데이터. 이 값은 &lt;code&gt;LOBLKSIZE&lt;/code&gt; 바이트 보다 크지 않으며 더 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cef4a325f0a5fb8a611f2f24f0d274a093ec734" translate="yes" xml:space="preserve">
          <source>Actually the preceding paragraph is an oversimplification: there are two cases in which a function-call construct will be treated as a cast request without having matched it to an actual function. If a function call &lt;code&gt;name&lt;/code&gt;(&lt;code&gt;x&lt;/code&gt;) does not exactly match any existing function, but &lt;code&gt;name&lt;/code&gt; is the name of a data type and &lt;code&gt;pg_cast&lt;/code&gt; provides a binary-coercible cast to this type from the type of &lt;code&gt;x&lt;/code&gt;, then the call will be construed as a binary-coercible cast. This exception is made so that binary-coercible casts can be invoked using functional syntax, even though they lack any function. Likewise, if there is no &lt;code&gt;pg_cast&lt;/code&gt; entry but the cast would be to or from a string type, the call will be construed as an I/O conversion cast. This exception allows I/O conversion casts to be invoked using functional syntax.</source>
          <target state="translated">실제로 이전 단락은 지나치게 단순화 된 것입니다. 함수 호출 구문이 실제 함수와 일치하지 않고 캐스트 요청으로 처리되는 두 가지 경우가 있습니다. 함수 호출 &lt;code&gt;name&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; )이 기존 함수와 정확히 일치하지 않지만 &lt;code&gt;name&lt;/code&gt; 이 데이터 유형의 이름이고 &lt;code&gt;pg_cast&lt;/code&gt; 가 &lt;code&gt;x&lt;/code&gt; 유형에서이 유형으로 이진 강제 변환을 제공하는 경우 호출은 다음과 같이 해석됩니다. 이진 보자 형 캐스트. 이 예외는 바이너리 강제 변환 캐스트가 함수 구문이 없어도 함수 구문을 사용하여 호출 할 수 있도록하기위한 것입니다. 마찬가지로 &lt;code&gt;pg_cast&lt;/code&gt; 가 없으면캐스트가 문자열 유형에 대한 것이거나 캐스트 유형 인 경우 호출은 I / O 변환 캐스트로 해석됩니다. 이 예외는 기능적 구문을 사용하여 I / O 변환 캐스트를 호출 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="99bd76b2471dd3de3de3ab7c1c222041031e9e64" translate="yes" xml:space="preserve">
          <source>Actually, each &amp;ldquo;character&amp;rdquo; can be any string not containing whitespace, so &lt;code&gt;unaccent&lt;/code&gt; dictionaries could be used for other sorts of substring substitutions besides diacritic removal.</source>
          <target state="translated">실제로, 각&amp;ldquo;문자&amp;rdquo;는 공백을 포함하지 않는 문자열 일 수 있으므로 분음 부호 제거 외에 다른 종류의 하위 문자열 대체에 &lt;code&gt;unaccent&lt;/code&gt; 사전을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb4a150119fee7c38df2ebe67adb1f04cd8a1672" translate="yes" xml:space="preserve">
          <source>Actually, in these example queries, &lt;code&gt;coalesce&lt;/code&gt; should be used to prevent a single &lt;code&gt;NULL&lt;/code&gt; attribute from causing a &lt;code&gt;NULL&lt;/code&gt; result for the whole document.</source>
          <target state="translated">실제로 이러한 예제 쿼리에서 단일 &lt;code&gt;NULL&lt;/code&gt; 속성 이 전체 문서에 대해 &lt;code&gt;NULL&lt;/code&gt; 결과를 발생 시키지 않도록 &lt;code&gt;coalesce&lt;/code&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8f0894c46fc9b6047265c297cf124917360edc17" translate="yes" xml:space="preserve">
          <source>Actually, the even more general syntax</source>
          <target state="translated">사실, 훨씬 더 일반적인 문법</target>
        </trans-unit>
        <trans-unit id="9d49dccdc43481d06a4ef58b29107551c088b828" translate="yes" xml:space="preserve">
          <source>Adaptive?</source>
          <target state="translated">Adaptive?</target>
        </trans-unit>
        <trans-unit id="4415296784c0ee879898fb9df132309b61a61a7c" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; to &lt;code&gt;INSERT&lt;/code&gt; commands. This option is not valid unless &lt;code&gt;--inserts&lt;/code&gt; or &lt;code&gt;--column-inserts&lt;/code&gt; is also specified.</source>
          <target state="translated">추가 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; 에 &lt;code&gt;INSERT&lt;/code&gt; 명령. &lt;code&gt;--inserts&lt;/code&gt; 또는 &lt;code&gt;--column-inserts&lt;/code&gt; 도 지정 하지 않으면이 옵션은 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6e9832f60aad6d89585289ea2e0edf7fc9e5b79b" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; to &lt;code&gt;INSERT&lt;/code&gt; commands. This option is not valid unless &lt;code&gt;--inserts&lt;/code&gt;, &lt;code&gt;--column-inserts&lt;/code&gt; or &lt;code&gt;--rows-per-insert&lt;/code&gt; is also specified.</source>
          <target state="translated">추가 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; 에 &lt;code&gt;INSERT&lt;/code&gt; 명령. &lt;code&gt;--inserts&lt;/code&gt; , &lt;code&gt;--column-inserts&lt;/code&gt; 또는 &lt;code&gt;--rows-per-insert&lt;/code&gt; 도 지정 하지 않으면이 옵션은 유효하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="df59723089709ab5e5075047c1ac7d254b3f6b22" translate="yes" xml:space="preserve">
          <source>Add a key, or update an existing key with a new value:</source>
          <target state="translated">키를 추가하거나 기존 키를 새 값으로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="7a5572f228e469f1c2f4cd272c7b0cda74e7acf6" translate="yes" xml:space="preserve">
          <source>Add a number of days to a date</source>
          <target state="translated">날짜에 일수 추가</target>
        </trans-unit>
        <trans-unit id="f0f3c97b278869eab76434c25a08bb2d9b563aa2" translate="yes" xml:space="preserve">
          <source>Add a time-of-day to a date</source>
          <target state="translated">날짜에 시간 추가</target>
        </trans-unit>
        <trans-unit id="bacadfab25c06160832a539f1c1f1901edb824fd" translate="yes" xml:space="preserve">
          <source>Add a transaction script read from &lt;code&gt;filename&lt;/code&gt; to the list of executed scripts. An optional integer weight after &lt;code&gt;@&lt;/code&gt; allows to adjust the probability of drawing the test. See below for details.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 에서 읽은 트랜잭션 스크립트 를 실행 된 스크립트 목록에 추가하십시오 . &lt;code&gt;@&lt;/code&gt; 뒤에 선택적 정수 가중치를 사용하면 테스트를 그릴 확률을 조정할 수 있습니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e386cb056d908799805563d1ba2a71ca187f495b" translate="yes" xml:space="preserve">
          <source>Add an interval to a date</source>
          <target state="translated">날짜에 간격 추가</target>
        </trans-unit>
        <trans-unit id="30629dc5115a69a1747c013e1cc5a69e275df7a1" translate="yes" xml:space="preserve">
          <source>Add an interval to a time</source>
          <target state="translated">시간에 간격 추가</target>
        </trans-unit>
        <trans-unit id="cc1ce74f84bf95ea154baff4f8c09c2914ce6d50" translate="yes" xml:space="preserve">
          <source>Add an interval to a timestamp</source>
          <target state="translated">타임 스탬프에 간격 추가</target>
        </trans-unit>
        <trans-unit id="b612d09d7cda7883ad9f9c1e74b2026a76de08a5" translate="yes" xml:space="preserve">
          <source>Add columns</source>
          <target state="translated">열 추가</target>
        </trans-unit>
        <trans-unit id="fdd20704520d17d4473df8ba637e593e3c1e9d32" translate="yes" xml:space="preserve">
          <source>Add constraints</source>
          <target state="translated">구속 조건 추가</target>
        </trans-unit>
        <trans-unit id="7b67cedcfe4d56f7816bcfdf431ad5afd738eb2a" translate="yes" xml:space="preserve">
          <source>Add intervals</source>
          <target state="translated">간격 추가</target>
        </trans-unit>
        <trans-unit id="7ee44cc339a6c285bac845e10d98461ab1145004" translate="yes" xml:space="preserve">
          <source>Add non-overlapping table constraints to the child tables to define the allowed key values in each.</source>
          <target state="translated">겹치지 않는 테이블 제약 조건을 자식 테이블에 추가하여 각각에 허용 된 키 값을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="48999cb16b06daffee5cbba84a68d9e3c43940fe" translate="yes" xml:space="preserve">
          <source>Add or change the assignment to be made to a configuration parameter when the function is called. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the function-local setting is removed, so that the function executes with the value present in its environment. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all function-local settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;ALTER FUNCTION&lt;/code&gt; is executed as the value to be applied when the function is entered.</source>
          <target state="translated">함수가 호출 될 때 구성 매개 변수에 지정할 지정을 추가하거나 변경하십시오. 경우 &lt;code&gt;value&lt;/code&gt; 인 &lt;code&gt;DEFAULT&lt;/code&gt; 또는 등가 &lt;code&gt;RESET&lt;/code&gt; 가 사용되는 함수 로컬 설정이 제거되므로, 그 환경에서 본 값으로 함수를 실행한다. 모든 기능 로컬 설정을 지우려면 &lt;code&gt;RESET ALL&lt;/code&gt; 을 사용하십시오 . &lt;code&gt;SET FROM CURRENT&lt;/code&gt; 는 &lt;code&gt;ALTER FUNCTION&lt;/code&gt; 이 실행될 때 현재 매개 변수 의 값을 기능 입력시 적용될 값으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="741a6eebd9634b6405712ee7bced8a90249de64a" translate="yes" xml:space="preserve">
          <source>Add or change the assignment to be made to a configuration parameter when the procedure is called. If &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;DEFAULT&lt;/code&gt; or, equivalently, &lt;code&gt;RESET&lt;/code&gt; is used, the procedure-local setting is removed, so that the procedure executes with the value present in its environment. Use &lt;code&gt;RESET ALL&lt;/code&gt; to clear all procedure-local settings. &lt;code&gt;SET FROM CURRENT&lt;/code&gt; saves the value of the parameter that is current when &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; is executed as the value to be applied when the procedure is entered.</source>
          <target state="translated">프로 시저가 호출 될 때 구성 매개 변수에 지정할 지정을 추가하거나 변경하십시오. 경우 &lt;code&gt;value&lt;/code&gt; 인 &lt;code&gt;DEFAULT&lt;/code&gt; 또는 등가 &lt;code&gt;RESET&lt;/code&gt; 가 사용되는 절차 로컬 설정이 제거되므로, 그 환경에서의 값과 현재의 절차를 실행한다. 모든 절차 로컬 설정을 지우려면 &lt;code&gt;RESET ALL&lt;/code&gt; 을 사용하십시오 . &lt;code&gt;SET FROM CURRENT&lt;/code&gt; 는 &lt;code&gt;ALTER PROCEDURE&lt;/code&gt; 가 실행될 때 현재 매개 변수 값을 프로 시저가 입력 될 때 적용되는 값으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="3e939370f13d4d6648fdf6ebce042de2b0c8b35d" translate="yes" xml:space="preserve">
          <source>Add some tables to the publication:</source>
          <target state="translated">발행물에 몇 가지 테이블을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0adf6644f343dab5da55bc308f3c6ee3087cbd49" translate="yes" xml:space="preserve">
          <source>Add the new column, with a default, to &lt;code&gt;pg_proc.h&lt;/code&gt;:</source>
          <target state="translated">새 열을 기본값으로 &lt;code&gt;pg_proc.h&lt;/code&gt; 에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="752268a69e3b24883f304a215dae5d50dea7c0b0" translate="yes" xml:space="preserve">
          <source>Add the probe definition to &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;:</source>
          <target state="translated">프로브 정의를 &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt; 에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce0fb0fdfabd7e1bdcafb562c60398cbe55ebe0d" translate="yes" xml:space="preserve">
          <source>Add the probe definitions to &lt;code&gt;src/backend/utils/probes.d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;src/backend/utils/probes.d&lt;/code&gt; 에 프로브 정의를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4acf1110e0d52a03ba3a64c356b491cd2bd51279" translate="yes" xml:space="preserve">
          <source>Add the specified built-in script to the list of executed scripts. An optional integer weight after &lt;code&gt;@&lt;/code&gt; allows to adjust the probability of drawing the script. If not specified, it is set to 1. Available built-in scripts are: &lt;code&gt;tpcb-like&lt;/code&gt;, &lt;code&gt;simple-update&lt;/code&gt; and &lt;code&gt;select-only&lt;/code&gt;. Unambiguous prefixes of built-in names are accepted. With special name &lt;code&gt;list&lt;/code&gt;, show the list of built-in scripts and exit immediately.</source>
          <target state="translated">지정된 내장 스크립트를 실행 된 스크립트 목록에 추가하십시오. &lt;code&gt;@&lt;/code&gt; 뒤에 선택적 정수 가중치를 사용하면 스크립트를 그릴 확률을 조정할 수 있습니다. 지정하지 않으면 1로 설정됩니다. 사용 가능한 내장 스크립트는 &lt;code&gt;tpcb-like&lt;/code&gt; , &lt;code&gt;simple-update&lt;/code&gt; 및 &lt;code&gt;select-only&lt;/code&gt; 입니다. 내장 이름의 명확한 접두사가 허용됩니다. 특수 이름 &lt;code&gt;list&lt;/code&gt; 로 내장 스크립트 목록을 표시하고 즉시 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="c0ab5a63742ff89241c46899c37233e1df7c86b0" translate="yes" xml:space="preserve">
          <source>Add users to a group:</source>
          <target state="translated">그룹에 사용자를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8caea2f156f156f661ed21fc3f27f4bbd2fa80f2" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;NOT NULL&lt;/code&gt; constraint requires scanning the table to verify that existing rows meet the constraint, but does not require a table rewrite.</source>
          <target state="translated">&lt;code&gt;CHECK&lt;/code&gt; 또는 &lt;code&gt;NOT NULL&lt;/code&gt; 제약 조건을 추가 하려면 기존 행이 제약 조건을 충족하는지 확인하기 위해 테이블을 검색해야하지만 테이블을 다시 쓰지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="cffe5a53117b776e99930ab76048f8855b384b5a" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause allows a list of columns to be specified which will be included in the non-key portion of the index. Although uniqueness is not enforced on the included columns, the constraint still depends on them. Consequently, some operations on the included columns (e.g. &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">&lt;code&gt;PRIMARY KEY&lt;/code&gt; 제약 조건을 추가하면 제약 조건에 사용 된 열 또는 열 그룹에 고유 한 btree 인덱스가 자동으로 생성됩니다. 선택적 &lt;code&gt;INCLUDE&lt;/code&gt; 절을 사용하면 색인의 키가 아닌 부분에 포함될 열 목록을 지정할 수 있습니다. 포함 된 열에는 고유성이 적용되지 않지만 제약 조건은 여전히 ​​열에 따라 다릅니다. 결과적으로 포함 된 열 (예 : &lt;code&gt;DROP COLUMN&lt;/code&gt; ) 에 대한 일부 작업은 계단식 제약 조건 및 인덱스 삭제를 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e3b837b83f00305a477861a47c68fa313f35aa1" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;PRIMARY KEY&lt;/code&gt; constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional &lt;code&gt;INCLUDE&lt;/code&gt; clause allows a list of columns to be specified which will be included in the non-key portion of the index. Although uniqueness is not enforced on the included columns, the constraint still depends on them. Consequently, some operations on the included columns (e.g., &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">&lt;code&gt;PRIMARY KEY&lt;/code&gt; 제약 조건을 추가하면 제약 조건에 사용 된 열 또는 열 그룹에 고유 한 btree 인덱스가 자동으로 생성됩니다. 선택적 &lt;code&gt;INCLUDE&lt;/code&gt; 절을 사용하면 인덱스의 키가 아닌 부분에 포함될 열 목록을 지정할 수 있습니다. 포함 된 열에는 고유성이 적용되지 않지만 제약 조건은 여전히 ​​열에 따라 다릅니다. 따라서 포함 된 열에 대한 일부 작업 (예 : &lt;code&gt;DROP COLUMN&lt;/code&gt; )은 계단식 제약 조건 및 인덱스 삭제를 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c642f86413e7e0c5d8cf9f40dd1b146f4c06e416" translate="yes" xml:space="preserve">
          <source>Adding a column with a volatile &lt;code&gt;DEFAULT&lt;/code&gt; or changing the type of an existing column will require the entire table and its indexes to be rewritten. As an exception, when changing the type of an existing column, if the &lt;code&gt;USING&lt;/code&gt; clause does not change the column contents and the old type is either binary coercible to the new type or an unconstrained domain over the new type, a table rewrite is not needed; but any indexes on the affected columns must still be rebuilt. Table and/or index rebuilds may take a significant amount of time for a large table; and will temporarily require as much as double the disk space.</source>
          <target state="translated">일시적인 &lt;code&gt;DEFAULT&lt;/code&gt; 가 있는 열을 추가 하거나 기존 열의 유형을 변경하면 전체 테이블과 해당 인덱스를 다시 작성해야합니다. 예외로, 기존 컬럼의 유형을 변경할 때 &lt;code&gt;USING&lt;/code&gt; 절이 컬럼 컨텐츠를 변경하지 않고 이전 유형이 새 유형에 대해 강제 변환 가능하거나 새 유형에 대해 제한되지 않은 도메인 인 경우 테이블을 다시 쓸 필요가 없습니다. ; 그러나 영향을받는 열의 인덱스는 여전히 다시 작성해야합니다. 테이블 및 / 또는 인덱스 재 구축은 큰 테이블의 경우 상당한 시간이 걸릴 수 있습니다. 일시적으로 디스크 공간의 두 배가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c58efc1059381c4bf8b362143436cd8c4af55346" translate="yes" xml:space="preserve">
          <source>Adding a constraint using an existing index can be helpful in situations where a new constraint needs to be added without blocking table updates for a long time. To do that, create the index using &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt;, and then install it as an official constraint using this syntax. See the example below.</source>
          <target state="translated">기존 인덱스를 사용하여 제약 조건을 추가하면 테이블 업데이트를 오랫동안 차단하지 않고 새로운 제약 조건을 추가해야하는 상황에서 유용 할 수 있습니다. 이를 수행하려면 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; 를 사용하여 색인을 작성한 후이 구문을 사용하여 공식 제한 조건으로 설치하십시오. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c57d929aced463125ab8b2f66f31b21a04522c5d" translate="yes" xml:space="preserve">
          <source>Adding a primary key will automatically create a unique B-tree index on the column or group of columns listed in the primary key, and will force the column(s) to be marked &lt;code&gt;NOT NULL&lt;/code&gt;.</source>
          <target state="translated">기본 키를 추가하면 기본 키에 나열된 열 또는 열 그룹에 고유 한 B- 트리 인덱스가 자동으로 생성되고 열이 &lt;code&gt;NOT NULL&lt;/code&gt; 로 표시 됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ee5dc2437e432908c48ca918b4296acc2f6a028" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique B-tree index on the column or group of columns listed in the constraint. A uniqueness restriction covering only some rows cannot be written as a unique constraint, but it is possible to enforce such a restriction by creating a unique &lt;a href=&quot;indexes-partial&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">고유 제약 조건을 추가하면 제약 조건에 나열된 열 또는 열 그룹에 고유 B- 트리 인덱스가 자동으로 생성됩니다. 일부 행만 포함하는 고유성 제한은 고유 제한 조건으로 작성할 수 없지만 고유 &lt;a href=&quot;indexes-partial&quot;&gt;부분 인덱스를&lt;/a&gt; 작성하여 이러한 제한을 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e5ef315a51bb0b0043f1a6d7277abada165d078" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional clause &lt;code&gt;INCLUDE&lt;/code&gt; adds to that index one or more columns on which the uniqueness is not enforced. Note that although the constraint is not enforced on the included columns, it still depends on them. Consequently, some operations on these columns (e.g. &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">고유 제약 조건을 추가하면 제약 조건에 사용 된 열 또는 열 그룹에 고유 한 btree 인덱스가 자동으로 생성됩니다. 선택적 절 &lt;code&gt;INCLUDE&lt;/code&gt; 는 고유성이 적용되지 않은 하나 이상의 열을 해당 색인에 추가합니다. 포함 된 열에 제약 조건이 적용되지 않더라도 여전히 열에 따라 달라집니다. 결과적으로 이러한 열에 대한 일부 작업 (예 : &lt;code&gt;DROP COLUMN&lt;/code&gt; )은 계단식 제약 조건 및 인덱스 삭제를 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa8235a384df080ad3fe537c45554b56b2b4ea42" translate="yes" xml:space="preserve">
          <source>Adding a unique constraint will automatically create a unique btree index on the column or group of columns used in the constraint. The optional clause &lt;code&gt;INCLUDE&lt;/code&gt; adds to that index one or more columns on which the uniqueness is not enforced. Note that although the constraint is not enforced on the included columns, it still depends on them. Consequently, some operations on these columns (e.g., &lt;code&gt;DROP COLUMN&lt;/code&gt;) can cause cascaded constraint and index deletion.</source>
          <target state="translated">고유 제약 조건을 추가하면 제약 조건에 사용 된 열 또는 열 그룹에 고유 한 btree 인덱스가 자동으로 생성됩니다. 선택적 절 &lt;code&gt;INCLUDE&lt;/code&gt; 는 고유성이 적용되지 않는 하나 이상의 열을 해당 인덱스에 추가합니다. 제약 조건이 포함 된 열에 적용되지는 않지만 여전히 해당 열에 따라 다릅니다. 결과적으로 이러한 열에 대한 일부 작업 (예 : &lt;code&gt;DROP COLUMN&lt;/code&gt; )은 계단식 제약 조건 및 인덱스 삭제를 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bcad53930a4507d157767aa00d4a8d4f833266c" translate="yes" xml:space="preserve">
          <source>Adding an exclusion constraint will automatically create an index of the type specified in the constraint declaration.</source>
          <target state="translated">제외 제약 조건을 추가하면 제약 조건 선언에 지정된 유형의 인덱스가 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7173dacda23801ef619f4e60a2645585a6fe0048" translate="yes" xml:space="preserve">
          <source>Adding parentheses around an RE does not change its greediness.</source>
          <target state="translated">RE 주위에 괄호를 추가해도 욕심은 변하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="65d284b9baecd42d63cb154eecd228122b272bd2" translate="yes" xml:space="preserve">
          <source>Addition of a foreign key constraint requires a &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; lock on the referenced table, in addition to the lock on the table receiving the constraint.</source>
          <target state="translated">외래 키 제약 조건 을 추가하려면 제약 조건을받는 테이블의 잠금 외에 참조 된 테이블에 대한 &lt;code&gt;SHARE ROW EXCLUSIVE&lt;/code&gt; 잠금이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2025ebd7978991464bc4c04e553287e1846aa3ca" translate="yes" xml:space="preserve">
          <source>Additional Features</source>
          <target state="translated">추가 기능</target>
        </trans-unit>
        <trans-unit id="15680ea5248b05a075106e29ed181bc54958d717" translate="yes" xml:space="preserve">
          <source>Additional binary string manipulation functions are available and are listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;Table 9.12&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Table 9.11&lt;/a&gt;.</source>
          <target state="translated">추가 2 진 문자열 조작 함수를 사용할 수 있으며 &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;표 9.12에&lt;/a&gt; 나열되어 있습니다. 이들 중 일부는 &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Table 9.11에&lt;/a&gt; 나열된 SQL 표준 문자열 함수를 구현하기 위해 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="89c24238b1c616d3f7452d5dd9217a02ce8ecaf1" translate="yes" xml:space="preserve">
          <source>Additional binary string manipulation functions are available and are listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;Table 9.13&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Table 9.12&lt;/a&gt;.</source>
          <target state="translated">추가 이진 문자열 조작 기능을 사용할 수 있으며 &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;표 9.13에&lt;/a&gt; 나열되어 있습니다. 이들 중 일부는 &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;표 9.12에&lt;/a&gt; 나열된 SQL 표준 문자열 함수를 구현하기 위해 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e5fd4e93e599bcb1fb3d2db4b33749ab6dcc12b" translate="yes" xml:space="preserve">
          <source>Additional considerations apply to the use of generated columns.</source>
          <target state="translated">생성 된 컬럼 사용시 추가 고려 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa325cbf6ead34348f2e89548944a03a6c03ebc9" translate="yes" xml:space="preserve">
          <source>Additional discussion and practical examples can be found in &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt;.</source>
          <target state="translated">추가적인 논의와 실제적인 예는 &lt;a href=&quot;ddl-rowsecurity&quot;&gt;섹션 5.8&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fbe8c837563c2f0daf28f682cb1a5ab1ec6f6fe" translate="yes" xml:space="preserve">
          <source>Additional enhancements by Andrew Gierth &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:andrew@tao11.riddles.org.uk&quot;&gt;andrew@tao11.riddles.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt;, United Kingdom</source>
          <target state="translated">Andrew Gierth의 추가 향상 기능 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:andrew@tao11.riddles.org.uk&quot;&gt;andrew@tao11.riddles.org.uk&lt;/a&gt;&amp;gt;&lt;/code&gt; , 영국</target>
        </trans-unit>
        <trans-unit id="0ef08f4faa1371707ef2f6feef718bf54953d0e6" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;hstore&lt;/code&gt; type for the languages PL/Perl and PL/Python. The extensions for PL/Perl are called &lt;code&gt;hstore_plperl&lt;/code&gt; and &lt;code&gt;hstore_plperlu&lt;/code&gt;, for trusted and untrusted PL/Perl. If you install these transforms and specify them when creating a function, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Perl hashes. The extensions for PL/Python are called &lt;code&gt;hstore_plpythonu&lt;/code&gt;, &lt;code&gt;hstore_plpython2u&lt;/code&gt;, and &lt;code&gt;hstore_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Python dictionaries.</source>
          <target state="translated">PL / Perl 및 PL / Python 언어 의 &lt;code&gt;hstore&lt;/code&gt; 유형에 대한 변환을 구현하는 추가 확장을 사용할 수 있습니다 . 신뢰할 수 있고 신뢰할 수없는 PL / Perl을 위해 PL / Perl의 확장명을 &lt;code&gt;hstore_plperl&lt;/code&gt; 및 &lt;code&gt;hstore_plperlu&lt;/code&gt; 라고 합니다. 이러한 변환을 설치하고 함수를 작성할 때이를 지정하면 &lt;code&gt;hstore&lt;/code&gt; 값이 Perl 해시에 맵핑됩니다. PL / Python의 확장은 &lt;code&gt;hstore_plpythonu&lt;/code&gt; , &lt;code&gt;hstore_plpython2u&lt;/code&gt; 및 &lt;code&gt;hstore_plpython3u&lt;/code&gt; 입니다 ( PL / Python 명명 규칙 &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;은 45.1 절&lt;/a&gt; 참조 ). 이를 사용하면 &lt;code&gt;hstore&lt;/code&gt; 값이 Python 사전에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="17bd8a6e2056a675b0fbad2a48d38ec5e91b9a37" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;hstore&lt;/code&gt; type for the languages PL/Perl and PL/Python. The extensions for PL/Perl are called &lt;code&gt;hstore_plperl&lt;/code&gt; and &lt;code&gt;hstore_plperlu&lt;/code&gt;, for trusted and untrusted PL/Perl. If you install these transforms and specify them when creating a function, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Perl hashes. The extensions for PL/Python are called &lt;code&gt;hstore_plpythonu&lt;/code&gt;, &lt;code&gt;hstore_plpython2u&lt;/code&gt;, and &lt;code&gt;hstore_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you use them, &lt;code&gt;hstore&lt;/code&gt; values are mapped to Python dictionaries.</source>
          <target state="translated">PL / Perl 및 PL / Python 언어 의 &lt;code&gt;hstore&lt;/code&gt; 유형에 대한 변환을 구현하는 추가 확장을 사용할 수 있습니다 . PL / Perl의 확장은 신뢰할 수있는 PL / Perl의 경우 &lt;code&gt;hstore_plperl&lt;/code&gt; 및 &lt;code&gt;hstore_plperlu&lt;/code&gt; 라고 합니다. 이러한 변환을 설치하고 함수를 만들 때 지정하면 &lt;code&gt;hstore&lt;/code&gt; 값이 Perl 해시에 매핑됩니다. PL / Python의 확장은 &lt;code&gt;hstore_plpythonu&lt;/code&gt; , &lt;code&gt;hstore_plpython2u&lt;/code&gt; 및 &lt;code&gt;hstore_plpython3u&lt;/code&gt; 라고 합니다 (PL / Python 명명 규칙 은 &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;섹션 45.1&lt;/a&gt; 참조 ). 이를 사용하면 &lt;code&gt;hstore&lt;/code&gt; 값이 Python 사전에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="d6954bc39f2ef60e2e03ec59460cfa1e30432da9" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;jsonb&lt;/code&gt; type for different procedural languages.</source>
          <target state="translated">다른 절차 언어에 대한 &lt;code&gt;jsonb&lt;/code&gt; 유형의 변환을 구현하는 추가 확장을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="041eecca386b7ca679e006e4c9dbf17a8a23f03a" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;ltree&lt;/code&gt; type for PL/Python. The extensions are called &lt;code&gt;ltree_plpythonu&lt;/code&gt;, &lt;code&gt;ltree_plpython2u&lt;/code&gt;, and &lt;code&gt;ltree_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you install these transforms and specify them when creating a function, &lt;code&gt;ltree&lt;/code&gt; values are mapped to Python lists. (The reverse is currently not supported, however.)</source>
          <target state="translated">PL / Python 의 &lt;code&gt;ltree&lt;/code&gt; 유형에 대한 변환을 구현하는 추가 확장을 사용할 수 있습니다 . 확장을 &lt;code&gt;ltree_plpythonu&lt;/code&gt; , &lt;code&gt;ltree_plpython2u&lt;/code&gt; 및 &lt;code&gt;ltree_plpython3u&lt;/code&gt; 라고 합니다 (PL / Python 명명 규칙 &lt;a href=&quot;https://www.postgresql.org/docs/12/plpython-python23.html&quot;&gt;은 45.1 절&lt;/a&gt; 참조 ). 함수를 생성 할 때 이러한 변환을 설치하고 지정하면 &lt;code&gt;ltree&lt;/code&gt; 값이 Python 목록에 매핑됩니다. (그러나 그 반대는 현재 지원되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="5a2588f70de7908623c3d75b4d858ce4b4c9f548" translate="yes" xml:space="preserve">
          <source>Additional extensions are available that implement transforms for the &lt;code&gt;ltree&lt;/code&gt; type for PL/Python. The extensions are called &lt;code&gt;ltree_plpythonu&lt;/code&gt;, &lt;code&gt;ltree_plpython2u&lt;/code&gt;, and &lt;code&gt;ltree_plpython3u&lt;/code&gt; (see &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;Section 45.1&lt;/a&gt; for the PL/Python naming convention). If you install these transforms and specify them when creating a function, &lt;code&gt;ltree&lt;/code&gt; values are mapped to Python lists. (The reverse is currently not supported, however.)</source>
          <target state="translated">PL / Python 의 &lt;code&gt;ltree&lt;/code&gt; 유형에 대한 변환을 구현하는 추가 확장을 사용할 수 있습니다 . 확장은 &lt;code&gt;ltree_plpythonu&lt;/code&gt; , &lt;code&gt;ltree_plpython2u&lt;/code&gt; , &lt;code&gt;ltree_plpython3u&lt;/code&gt; 입니다 ( PL / Python 명명 규칙 은 &lt;a href=&quot;https://www.postgresql.org/docs/13/plpython-python23.html&quot;&gt;섹션 45.1&lt;/a&gt; 참조 ). 이러한 변환을 설치하고 함수를 만들 때 지정하면 &lt;code&gt;ltree&lt;/code&gt; 값이 Python 목록에 매핑됩니다. (현재 그 반대는 지원되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="848e3ef5eb869b4a42890d26de458d77b4145059" translate="yes" xml:space="preserve">
          <source>Additional functions related to statistics collection are listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;Table 27.20&lt;/a&gt;.</source>
          <target state="translated">통계 수집과 관련된 추가 기능은 &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;표 27.20에&lt;/a&gt; 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="efb9efc34358e145f231e909fca0c910acaa66eb" translate="yes" xml:space="preserve">
          <source>Additional functions related to statistics collection are listed in &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;Table 27.30&lt;/a&gt;.</source>
          <target state="translated">통계 수집과 관련된 추가 기능은 &lt;a href=&quot;monitoring-stats#MONITORING-STATS-FUNCS-TABLE&quot;&gt;표 27.30에&lt;/a&gt; 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="77a49395f2c7e958118c2da8e1de4c14e6b60602" translate="yes" xml:space="preserve">
          <source>Additional information about how to invoke the function. Again, the interpretation is language-specific.</source>
          <target state="translated">함수를 호출하는 방법에 대한 추가 정보. 다시 말하지만 해석은 언어마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="284dcb5991a8da2d3edb0ed1251edf3e8b725229" translate="yes" xml:space="preserve">
          <source>Additional information about subscriptions and logical replication as a whole is available at &lt;a href=&quot;logical-replication-subscription&quot;&gt;Section 30.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">가입 및 논리적 복제에 대한 추가 정보는 &lt;a href=&quot;logical-replication-subscription&quot;&gt;30.2 절&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/logical-replication.html&quot;&gt;30 장&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="031701e67cc64e29e0f780df4ac7b24959b2258c" translate="yes" xml:space="preserve">
          <source>Additional information about subscriptions and logical replication as a whole is available at &lt;a href=&quot;logical-replication-subscription&quot;&gt;Section 30.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;Chapter 30&lt;/a&gt;.</source>
          <target state="translated">전체적으로 구독 및 논리적 복제에 대한 추가 정보는 &lt;a href=&quot;logical-replication-subscription&quot;&gt;섹션 30.2&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/13/logical-replication.html&quot;&gt;30 장&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9eacaa0140464ef9b6f84f47defe84ade132e976" translate="yes" xml:space="preserve">
          <source>Additional options controlling how the format specifier's output is formatted. Currently the only supported flag is a minus sign (&lt;code&gt;-&lt;/code&gt;) which will cause the format specifier's output to be left-justified. This has no effect unless the &lt;code&gt;width&lt;/code&gt; field is also specified.</source>
          <target state="translated">형식 지정자의 출력 형식을 제어하는 ​​추가 옵션. 현재 지원되는 유일한 플래그는 빼기 부호 ( &lt;code&gt;-&lt;/code&gt; )이며 형식 지정자의 출력이 왼쪽 정렬됩니다. &lt;code&gt;width&lt;/code&gt; 필드도 지정 하지 않으면 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b2569d5e654fdba9e13f3a3587c2c0d71e119a8f" translate="yes" xml:space="preserve">
          <source>Additional options controlling how the format specifier's output is formatted. Currently the only supported flag is a minus sign (&lt;code&gt;-&lt;/code&gt;) which will cause the format specifier's output to be left-justified. This has no effect unless the &lt;em&gt;&lt;code&gt;width&lt;/code&gt;&lt;/em&gt; field is also specified.</source>
          <target state="translated">형식 지정자의 출력 형식을 제어하는 ​​추가 옵션입니다. 현재 지원되는 유일한 플래그는 형식 지정자의 출력이 왼쪽 정렬되도록 하는 빼기 기호 ( &lt;code&gt;-&lt;/code&gt; )입니다. &lt;em&gt; &lt;code&gt;width&lt;/code&gt; &lt;/em&gt; 필드도 지정 하지 않으면 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2fdddce1ec06b246bce73843e8826c300263ddb0" translate="yes" xml:space="preserve">
          <source>Additional restrictions apply when unique indexes are applied to partitioned tables; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">고유 인덱스가 파티션 된 테이블에 적용될 때 추가 제한 사항이 적용됩니다. &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9379cab208a52cab9a14d1960740e0e9980c40a5" translate="yes" xml:space="preserve">
          <source>Additional restrictions apply when unique or primary key constraints are added to partitioned tables; see &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;. Also, foreign key constraints on partitioned tables may not be declared &lt;code&gt;NOT VALID&lt;/code&gt; at present.</source>
          <target state="translated">고유 또는 기본 키 제한 조건이 파티션 된 테이블에 추가 될 때 추가 제한 사항이 적용됩니다. &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE을&lt;/a&gt; 참조하십시오 . 또한 파티션 된 테이블에 대한 외래 키 제약 조건 은 현재 &lt;code&gt;NOT VALID&lt;/code&gt; 로 선언 되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8765f8e8e885763ce10457dabe0ae485bb31d5b" translate="yes" xml:space="preserve">
          <source>Additional string manipulation functions are available and are listed in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;Table 9.10&lt;/a&gt;. Some of them are used internally to implement the SQL-standard string functions listed in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Table 9.9&lt;/a&gt;.</source>
          <target state="translated">추가 문자열 조작 기능을 사용할 수 있으며 &lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;표 9.10에&lt;/a&gt; 나열되어 있습니다. 이들 중 일부는 &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;표 9.9에&lt;/a&gt; 나열된 SQL 표준 문자열 함수를 구현하기 위해 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="010f13497a3e5b588a77355b773385544bc33904" translate="yes" xml:space="preserve">
          <source>Additional updates were made by Joshua Reich &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:josh@root.net&quot;&gt;josh@root.net&lt;/a&gt;&amp;gt;&lt;/code&gt; in July 2006. These include &lt;code&gt;cube(float8[], float8[])&lt;/code&gt; and cleaning up the code to use the V1 call protocol instead of the deprecated V0 protocol.</source>
          <target state="translated">추가 업데이트는 2006 년 7 월 Joshua Reich &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:josh@root.net&quot;&gt;josh@root.net&lt;/a&gt;&amp;gt;&lt;/code&gt; 에 의해 이루어졌습니다 . 여기에는 &lt;code&gt;cube(float8[], float8[])&lt;/code&gt; 및 더 이상 사용되지 않는 V0 프로토콜 대신 V1 호출 프로토콜을 사용하도록 코드 정리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a5f30130c7eb4575fcc776243da7a4179d9cf6f4" translate="yes" xml:space="preserve">
          <source>Additional, more detailed, description of the parameter</source>
          <target state="translated">매개 변수에 대한 추가적이고 자세한 설명</target>
        </trans-unit>
        <trans-unit id="f10aed98f8a0fbbcdcab810e37d64419e4b89806" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;em&gt;comments&lt;/em&gt; can occur in SQL input. They are not tokens, they are effectively equivalent to whitespace.</source>
          <target state="translated">또한 SQL 입력에서 &lt;em&gt;주석&lt;/em&gt; 이 발생할 수 있습니다. 그것들은 토큰이 아니며 효과적으로 공백과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ce7d7c047715fd1454a60e6f8ab9c8a858ce3b2" translate="yes" xml:space="preserve">
          <source>Additionally, an alias is required if the table reference is a subquery (see &lt;a href=&quot;queries-table-expressions#QUERIES-SUBQUERIES&quot;&gt;Section 7.2.1.3&lt;/a&gt;).</source>
          <target state="translated">또한 테이블 참조가 하위 쿼리 인 경우 별칭이 필요합니다 ( &lt;a href=&quot;queries-table-expressions#QUERIES-SUBQUERIES&quot;&gt;섹션 7.2.1.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2987436262917a5192b10eeed405ee0544038a4c" translate="yes" xml:space="preserve">
          <source>Additionally, if a query usually requires an implicit conversion for a function, and if then the user defines a new function with the correct argument types, the parser should use this new function and no longer do implicit conversion to use the old function.</source>
          <target state="translated">또한 쿼리에 일반적으로 함수에 대한 암시 적 변환이 필요한 경우 사용자가 올바른 인수 유형으로 새 함수를 정의하면 파서는이 새로운 함수를 사용해야하며 더 이상 기존 함수를 사용하기 위해 암시 적 변환을 수행하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="0a6ee1654a9731eebc2384fd193841ff3bb1bd0e" translate="yes" xml:space="preserve">
          <source>Additionally, if you are running PostgreSQL inside a zone, you may need to raise the zone resource usage limits as well. See &quot;Chapter2: Projects and Tasks&quot; in the &lt;em&gt;System Administrator's Guide&lt;/em&gt; for more information on &lt;code&gt;projects&lt;/code&gt; and &lt;code&gt;prctl&lt;/code&gt;.</source>
          <target state="translated">또한 영역 내에서 PostgreSQL을 실행중인 경우 영역 리소스 사용 제한도 높여야 할 수 있습니다. &lt;code&gt;projects&lt;/code&gt; 및 &lt;code&gt;prctl&lt;/code&gt; 에 대한 자세한 내용 은 &lt;em&gt;시스템 관리자 안내서의&lt;/em&gt; &quot;2 장 : 프로젝트 및 작업&quot; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0aee321f704c4c1848fccdf5704c469a83987cc5" translate="yes" xml:space="preserve">
          <source>Additionally, refresh options as described under &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; may be specified.</source>
          <target state="translated">또한 &lt;code&gt;REFRESH PUBLICATION&lt;/code&gt; 에 설명 된대로 새로 고침 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78567ce71a3b54c604529593f06074abcf105927" translate="yes" xml:space="preserve">
          <source>Additionally, the SQL standard collation name &lt;code&gt;ucs_basic&lt;/code&gt; is available for encoding &lt;code&gt;UTF8&lt;/code&gt;. It is equivalent to &lt;code&gt;C&lt;/code&gt; and sorts by Unicode code point.</source>
          <target state="translated">또한 SQL 표준 데이터 정렬 이름 &lt;code&gt;ucs_basic&lt;/code&gt; 을 &lt;code&gt;UTF8&lt;/code&gt; 인코딩에 사용할 수 있습니다 . &lt;code&gt;C&lt;/code&gt; 와 동일하며 유니 코드 코드 포인트별로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="53f8119d06cd2559361245d09ce9820bdfc91e36" translate="yes" xml:space="preserve">
          <source>Adds an offset to an address.</source>
          <target state="translated">주소에 오프셋을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d5aedd449033d6b8107ae365cb24a243a1adca0c" translate="yes" xml:space="preserve">
          <source>Adds collations to the system catalog &lt;code&gt;pg_collation&lt;/code&gt; based on all the locales it finds in the operating system. This is what &lt;code&gt;initdb&lt;/code&gt; uses; see &lt;a href=&quot;collation#COLLATION-MANAGING&quot;&gt;Section 23.2.2&lt;/a&gt; for more details. If additional locales are installed into the operating system later on, this function can be run again to add collations for the new locales. Locales that match existing entries in &lt;code&gt;pg_collation&lt;/code&gt; will be skipped. (But collation objects based on locales that are no longer present in the operating system are not removed by this function.) The &lt;em&gt;&lt;code&gt;schema&lt;/code&gt;&lt;/em&gt; parameter would typically be &lt;code&gt;pg_catalog&lt;/code&gt;, but that is not a requirement; the collations could be installed into some other schema as well. The function returns the number of new collation objects it created.</source>
          <target state="translated">운영 체제에서 찾은 모든 로케일을 기반으로 시스템 카탈로그 &lt;code&gt;pg_collation&lt;/code&gt; 에 데이터 정렬을 추가합니다 . 이것이 &lt;code&gt;initdb&lt;/code&gt; 가 사용하는 것입니다. 자세한 내용 은 &lt;a href=&quot;collation#COLLATION-MANAGING&quot;&gt;섹션 23.2.2&lt;/a&gt; 를 참조하십시오. 나중에 추가 로케일이 운영 체제에 설치되면이 기능을 다시 실행하여 새 로케일에 대한 데이터 정렬을 추가 할 수 있습니다. &lt;code&gt;pg_collation&lt;/code&gt; 의 기존 항목과 일치하는 로케일은 건너 뜁니다. (그러나 운영 체제에 더 이상 존재하지 않는 로케일을 기반으로하는 데이터 정렬 객체는이 함수에 의해 제거되지 않습니다.) &lt;em&gt; &lt;code&gt;schema&lt;/code&gt; &lt;/em&gt; 매개 변수는 일반적으로 &lt;code&gt;pg_catalog&lt;/code&gt; 입니다., 그러나 이는 필수 사항이 아닙니다. 데이터 정렬은 다른 스키마에도 설치할 수 있습니다. 이 함수는 자신이 만든 새 데이터 정렬 개체의 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e874368d9d21cc7beffa67760d80cf1b272a6209" translate="yes" xml:space="preserve">
          <source>Adds element to end of array.</source>
          <target state="translated">배열 끝에 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="36522cf2f752a15facac71afeb7f67a4b36db952" translate="yes" xml:space="preserve">
          <source>Adds the coordinates of the second &lt;code&gt;point&lt;/code&gt; to those of each point of the first argument, thus performing translation. Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">두 번째 &lt;code&gt;point&lt;/code&gt; 의 좌표를 첫 번째 인수의 각 점의 좌표에 더하여 변환을 수행합니다. 가능 &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;path&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3c767351a24f76f0563dcac6f0be4bd35c8869c" translate="yes" xml:space="preserve">
          <source>Adjust interval so 24-hour time periods are represented as days</source>
          <target state="translated">24 시간 기간이 일로 표시되도록 간격을 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="7279c011b0d2f4cdb22e6caf6d21633e1e395dfa" translate="yes" xml:space="preserve">
          <source>Adjust interval so 30-day time periods are represented as months</source>
          <target state="translated">30 일 기간이 월로 표시되도록 간격을 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="0d09f290462815bf94d7d19b5220a29471c8dd87" translate="yes" xml:space="preserve">
          <source>Adjust interval using &lt;code&gt;justify_days&lt;/code&gt; and &lt;code&gt;justify_hours&lt;/code&gt;, with additional sign adjustments</source>
          <target state="translated">추가적인 부호 조정으로 &lt;code&gt;justify_days&lt;/code&gt; 및 &lt;code&gt;justify_hours&lt;/code&gt; 를 사용하여 간격을 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="d5274237f32eaf0cd335b0f45d9e9e406fe2937c" translate="yes" xml:space="preserve">
          <source>Adjust temperature entries and reset precipitation to its default value in one row of the table &lt;code&gt;weather&lt;/code&gt;:</source>
          <target state="translated">테이블 &lt;code&gt;weather&lt;/code&gt; 의 한 행에서 온도 입력을 조정하고 강수량을 기본값으로 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="597cf96132dd221de223e71df7ddc2feda8ca0e0" translate="yes" xml:space="preserve">
          <source>Adjustable printing options are:</source>
          <target state="translated">조정 가능한 인쇄 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="25a6044596d068aa8f0b03a3756a046b4662f84e" translate="yes" xml:space="preserve">
          <source>Administration Functions</source>
          <target state="translated">관리 기능</target>
        </trans-unit>
        <trans-unit id="9ff417ada04d397f658792af845a2743c3df515c" translate="yes" xml:space="preserve">
          <source>Administrators can grant access to these roles to users using the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command, for example:</source>
          <target state="translated">관리자는 &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; 명령을 사용하여 사용자에게 이러한 역할에 대한 액세스 권한을 부여 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5748ca9fbce0c666d06fe84d7811e46cfd6b343d" translate="yes" xml:space="preserve">
          <source>Advance sequence and return new value</source>
          <target state="translated">사전 순서와 새로운 가치를 반환</target>
        </trans-unit>
        <trans-unit id="4d638e9190ad6b08f1c75c8684e03ac19dde11c0" translate="yes" xml:space="preserve">
          <source>Advance the sequence object to its next value and return that value. This is done atomically: even if multiple sessions execute &lt;code&gt;nextval&lt;/code&gt; concurrently, each will safely receive a distinct sequence value.</source>
          <target state="translated">시퀀스 객체를 다음 값으로 전진시키고 해당 값을 반환합니다. 이 원자 적으로 수행됩니다 여러 세션을 실행할 경우에도 &lt;code&gt;nextval&lt;/code&gt; 동시에, 각 안전하게 별개의 시퀀스 값을 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="05743e363937b509ed8a8c4f9befec86cf089852" translate="yes" xml:space="preserve">
          <source>Advanced Configuration and Power Interface (ACPI) provides a Power Management (PM) Timer, which Linux refers to as the acpi_pm. The clock derived from acpi_pm will at best provide 300 nanosecond resolution.</source>
          <target state="translated">ACPI (Advanced Configuration and Power Interface)는 Linux가 acpi_pm이라고하는 전원 관리 (PM) 타이머를 제공합니다. acpi_pm에서 파생 된 클럭은 기껏해야 300 나노초의 해상도를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="96731dbaea6a5720dd33b64dc334ff765eec736a" translate="yes" xml:space="preserve">
          <source>Advanced Features</source>
          <target state="translated">고급 기능</target>
        </trans-unit>
        <trans-unit id="40fdbd870880a4ac68ea44233cfb9a2306bc99de" translate="yes" xml:space="preserve">
          <source>Advanced users can use regular-expression notations such as character classes, for example &lt;code&gt;[0-9]&lt;/code&gt; to match any digit. All regular expression special characters work as specified in &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;, except for &lt;code&gt;.&lt;/code&gt; which is taken as a separator as mentioned above, &lt;code&gt;*&lt;/code&gt; which is translated to the regular-expression notation &lt;code&gt;.*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; which is translated to &lt;code&gt;.&lt;/code&gt;, and &lt;code&gt;$&lt;/code&gt; which is matched literally. You can emulate these pattern characters at need by writing &lt;code&gt;?&lt;/code&gt; for &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;(R+|)&lt;/code&gt; for &lt;code&gt;R*&lt;/code&gt;, or &lt;code&gt;(R|)&lt;/code&gt; for &lt;code&gt;R?&lt;/code&gt;. &lt;code&gt;$&lt;/code&gt; is not needed as a regular-expression character since the pattern must match the whole name, unlike the usual interpretation of regular expressions (in other words, &lt;code&gt;$&lt;/code&gt; is automatically appended to your pattern). Write &lt;code&gt;*&lt;/code&gt; at the beginning and/or end if you don't wish the pattern to be anchored. Note that within double quotes, all regular expression special characters lose their special meanings and are matched literally. Also, the regular expression special characters are matched literally in operator name patterns (i.e., the argument of &lt;code&gt;\do&lt;/code&gt;).</source>
          <target state="translated">고급 사용자는 문자 클래스와 같은 정규식 표기법 (예 : &lt;code&gt;[0-9]&lt;/code&gt; ) 을 사용하여 모든 숫자와 일치시킬 수 있습니다. 를 제외한 모든 정규 표현식 특수 문자는 &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;9.7.3 절에&lt;/a&gt; 지정된대로 작동 합니다 &lt;code&gt;.&lt;/code&gt; 이는 전술 한 바와 같이 세퍼레이터로한다 &lt;code&gt;*&lt;/code&gt; 정규 표현식 표기로 변환된다 &lt;code&gt;.*&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; 로 번역됩니다 &lt;code&gt;.&lt;/code&gt; , 및 &lt;code&gt;$&lt;/code&gt; 는 문자 그대로 일치합니다. 필요한 경우 이러한 패턴 문자를 에뮬레이션 할 수 &lt;code&gt;?&lt;/code&gt; 에 대한 &lt;code&gt;.&lt;/code&gt; , &lt;code&gt;(R+|)&lt;/code&gt; 에 대한 &lt;code&gt;R*&lt;/code&gt; , 또는 &lt;code&gt;(R|)&lt;/code&gt; 에 대한 &lt;code&gt;R?&lt;/code&gt; . &lt;code&gt;$&lt;/code&gt; 정규식의 일반적인 해석과 달리 패턴이 전체 이름과 일치해야하므로 $ 는 정규식 문자로 필요하지 않습니다 (즉, &lt;code&gt;$&lt;/code&gt; 가 자동으로 패턴에 추가됨). 패턴을 고정하지 않으려면 시작 및 / 또는 끝에 &lt;code&gt;*&lt;/code&gt; 를 쓰십시오 . 큰 따옴표 내에서 모든 정규식 특수 문자는 특수 의미를 잃고 문자 그대로 일치합니다. 또한 정규 표현식 특수 문자는 문자 그대로 연산자 이름 패턴에서 일치합니다 (예 : &lt;code&gt;\do&lt;/code&gt; 인수 ).</target>
        </trans-unit>
        <trans-unit id="ae1d5d5862d5067d5253f55fa2d10173937d4fc6" translate="yes" xml:space="preserve">
          <source>Advances the current confirmed position of a replication slot named &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;. The slot will not be moved backwards, and it will not be moved beyond the current insert location. Returns name of the slot and real position to which it was advanced to.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;slot_name&lt;/code&gt; &lt;/em&gt; 이라는 복제 슬롯의 현재 확인 된 위치를 진행시킵니다 . 슬롯은 뒤로 이동하지 않으며 현재 인서트 위치를 넘어서 이동하지 않습니다. 슬롯 이름과 슬롯이 진행된 실제 위치를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d5aab029628974dd5c58605edc8a94526445808" translate="yes" xml:space="preserve">
          <source>Advances the current confirmed position of a replication slot named &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;. The slot will not be moved backwards, and it will not be moved beyond the current insert location. Returns the name of the slot and the actual position that it was advanced to. The updated slot position information is written out at the next checkpoint if any advancing is done. So in the event of a crash, the slot may return to an earlier position.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;slot_name&lt;/code&gt; &lt;/em&gt; 이라는 복제 슬롯의 현재 확인 된 위치를 이동합니다 . 슬롯은 뒤로 이동하지 않으며 현재 삽입 위치를 벗어나지 않습니다. 슬롯의 이름과 진행된 실제 위치를 반환합니다. 진행이 완료되면 업데이트 된 슬롯 위치 정보가 다음 체크 포인트에 기록됩니다. 따라서 충돌이 발생하면 슬롯이 이전 위치로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58c81d024a1ba21f51051976ec1e66bb25143e15" translate="yes" xml:space="preserve">
          <source>Advances the sequence object to its next value and returns that value. This is done atomically: even if multiple sessions execute &lt;code&gt;nextval&lt;/code&gt; concurrently, each will safely receive a distinct sequence value. If the sequence object has been created with default parameters, successive &lt;code&gt;nextval&lt;/code&gt; calls will return successive values beginning with 1. Other behaviors can be obtained by using appropriate parameters in the &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; command.</source>
          <target state="translated">시퀀스 개체를 다음 값으로 이동하고 해당 값을 반환합니다. 이것은 원자 적으로 수행됩니다. 여러 세션이 동시에 &lt;code&gt;nextval&lt;/code&gt; 을 실행하더라도 각 세션 은 고유 한 시퀀스 값을 안전하게받습니다. 시퀀스 개체가 기본 매개 변수로 생성 된 경우 연속적인 &lt;code&gt;nextval&lt;/code&gt; 호출은 1로 시작하는 연속 값을 반환합니다. 다른 동작은 &lt;a href=&quot;sql-createsequence&quot;&gt;CREATE SEQUENCE&lt;/a&gt; 명령 에서 적절한 매개 변수를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d323581d870eb70c61501cdd5933132dd855a86" translate="yes" xml:space="preserve">
          <source>Advisory locks can be acquired on keys consisting of either a single &lt;code&gt;bigint&lt;/code&gt; value or two integer values. A &lt;code&gt;bigint&lt;/code&gt; key is displayed with its high-order half in the &lt;code&gt;classid&lt;/code&gt; column, its low-order half in the &lt;code&gt;objid&lt;/code&gt; column, and &lt;code&gt;objsubid&lt;/code&gt; equal to 1. The original &lt;code&gt;bigint&lt;/code&gt; value can be reassembled with the expression &lt;code&gt;(classid::bigint &amp;lt;&amp;lt; 32) | objid::bigint&lt;/code&gt;. Integer keys are displayed with the first key in the &lt;code&gt;classid&lt;/code&gt; column, the second key in the &lt;code&gt;objid&lt;/code&gt; column, and &lt;code&gt;objsubid&lt;/code&gt; equal to 2. The actual meaning of the keys is up to the user. Advisory locks are local to each database, so the &lt;code&gt;database&lt;/code&gt; column is meaningful for an advisory lock.</source>
          <target state="translated">단일 &lt;code&gt;bigint&lt;/code&gt; 값 또는 두 개의 정수 값 으로 구성된 키에 대해 권고 잠금을 얻을 수 있습니다 . &lt;code&gt;bigint&lt;/code&gt; 키는 그것의 상위 절반 표시 &lt;code&gt;classid&lt;/code&gt; 칼럼의 하위 상기 반 &lt;code&gt;objid&lt;/code&gt; 열 및 &lt;code&gt;objsubid&lt;/code&gt; 1. 동일한 원래 &lt;code&gt;bigint&lt;/code&gt; 값이 식으로 재 조립 될 수있다 &lt;code&gt;(classid::bigint &amp;lt;&amp;lt; 32) | objid::bigint&lt;/code&gt; 입니다. 정수 키는 &lt;code&gt;classid&lt;/code&gt; 열의 첫 번째 키 , &lt;code&gt;objid&lt;/code&gt; 열의 두 번째 키 및 &lt;code&gt;objsubid&lt;/code&gt; 가 2 와 함께 표시됩니다. 키 의 실제 의미는 사용자에게 달려 있습니다. 권고 잠금은 각 데이터베이스에 대해 로컬이므로 &lt;code&gt;database&lt;/code&gt; 열은 권고 잠금에 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6c29c3eec39081073449cf551f29f5ff2063ec1" translate="yes" xml:space="preserve">
          <source>Advisory locks work normally in recovery, including deadlock detection. Note that advisory locks are never WAL logged, so it is impossible for an advisory lock on either the primary or the standby to conflict with WAL replay. Nor is it possible to acquire an advisory lock on the primary and have it initiate a similar advisory lock on the standby. Advisory locks relate only to the server on which they are acquired.</source>
          <target state="translated">권고 잠금은 교착 상태 감지를 포함하여 복구시 정상적으로 작동합니다. 권고 잠금은 절대 WAL로 기록되지 않으므로 기본 또는 대기에 대한 권고 잠금이 WAL 재생과 충돌하는 것은 불가능합니다. 또한 기본에서 권고 잠금을 획득하고 대기에서 유사한 권고 잠금을 시작하도록 할 수도 없습니다. 권고 잠금은 획득 한 서버에만 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="87db6f29dc76387bbaab5ded1909ba41ea3e370f" translate="yes" xml:space="preserve">
          <source>After a checkpoint has been made and the log flushed, the checkpoint's position is saved in the file &lt;code&gt;pg_control&lt;/code&gt;. Therefore, at the start of recovery, the server first reads &lt;code&gt;pg_control&lt;/code&gt; and then the checkpoint record; then it performs the REDO operation by scanning forward from the log location indicated in the checkpoint record. Because the entire content of data pages is saved in the log on the first page modification after a checkpoint (assuming &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is not disabled), all pages changed since the checkpoint will be restored to a consistent state.</source>
          <target state="translated">검사 점이 만들어지고 로그가 플러시되면 검사 점의 위치가 &lt;code&gt;pg_control&lt;/code&gt; 파일에 저장됩니다 . 따라서 복구 시작시 서버는 먼저 &lt;code&gt;pg_control&lt;/code&gt; 을 읽은 다음 검사 점 레코드를 읽습니다 . 그런 다음 검사 점 레코드에 표시된 로그 위치에서 앞으로 스캔하여 REDO 작업을 수행합니다. &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; 가 비활성화되지 않았다고 가정하면 검사 점 이후 첫 페이지 수정시 데이터 페이지의 전체 내용이 로그에 저장 되므로 검사 점 이후 변경된 모든 페이지는 일관성있는 상태로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="c70bb87984515ab084a4a6675924bc032765ff87" translate="yes" xml:space="preserve">
          <source>After a commit record has been written to disk on the primary, the WAL record is then sent to the standby. The standby sends reply messages each time a new batch of WAL data is written to disk, unless &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; is set to zero on the standby. In the case that &lt;code&gt;synchronous_commit&lt;/code&gt; is set to &lt;code&gt;remote_apply&lt;/code&gt;, the standby sends reply messages when the commit record is replayed, making the transaction visible. If the standby is chosen as a synchronous standby, according to the setting of &lt;code&gt;synchronous_standby_names&lt;/code&gt; on the primary, the reply messages from that standby will be considered along with those from other synchronous standbys to decide when to release transactions waiting for confirmation that the commit record has been received. These parameters allow the administrator to specify which standby servers should be synchronous standbys. Note that the configuration of synchronous replication is mainly on the master. Named standbys must be directly connected to the master; the master knows nothing about downstream standby servers using cascaded replication.</source>
          <target state="translated">커밋 레코드가 기본의 디스크에 기록 된 후 WAL 레코드가 대기로 전송됩니다. 대기에서 &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; 이 0으로 설정되어 있지 않으면 대기는 새 WAL 데이터 배치를 디스크에 쓸 때마다 응답 메시지를 보냅니다 . &lt;code&gt;synchronous_commit&lt;/code&gt; 이 &lt;code&gt;remote_apply&lt;/code&gt; 로 설정된 경우 대기는 커밋 레코드가 재생 될 때 응답 메시지를 보내 트랜잭션을 볼 수있게합니다. 이 대기의 설정에 따라 동기 대기로 선택되면 &lt;code&gt;synchronous_standby_names&lt;/code&gt; 기본에서 해당 대기의 응답 메시지는 다른 동기 대기의 응답 메시지와 함께 고려되어 커미트 레코드가 수신되었다는 확인을 기다리는 트랜잭션을 릴리스 할시기를 결정합니다. 이 매개 변수를 사용하여 관리자는 동기 대기 여야하는 대기 서버를 지정할 수 있습니다. 동기식 복제 구성은 주로 마스터에 있습니다. 명명 된 대기는 마스터에 직접 연결해야합니다. 마스터는 계단식 복제를 사용하는 다운 스트림 대기 서버에 대해 아무것도 모릅니다.</target>
        </trans-unit>
        <trans-unit id="94241391dfbbfde4a951b39750ed3743aeb3267e" translate="yes" xml:space="preserve">
          <source>After a query has produced an output table (after the select list has been processed) it can optionally be sorted. If sorting is not chosen, the rows will be returned in an unspecified order. The actual order in that case will depend on the scan and join plan types and the order on disk, but it must not be relied on. A particular output ordering can only be guaranteed if the sort step is explicitly chosen.</source>
          <target state="translated">조회가 출력 테이블을 생성 한 후 (선택 목록이 처리 된 후) 선택적으로 정렬 될 수 있습니다. 정렬을 선택하지 않으면 행이 지정되지 않은 순서로 반환됩니다. 이 경우 실제 순서는 스캔 및 결합 계획 유형 및 디스크 순서에 따라 달라 지지만 의존해서는 안됩니다. 정렬 단계가 명시 적으로 선택된 경우에만 특정 출력 순서를 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b97640c2ecb0afe6be98ec8bef630298c29b1bf" translate="yes" xml:space="preserve">
          <source>After a sequence is created, you use the functions &lt;code&gt;nextval&lt;/code&gt;, &lt;code&gt;currval&lt;/code&gt;, and &lt;code&gt;setval&lt;/code&gt; to operate on the sequence. These functions are documented in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt;.</source>
          <target state="translated">시퀀스가 작성된 후 &lt;code&gt;nextval&lt;/code&gt; , &lt;code&gt;currval&lt;/code&gt; 및 &lt;code&gt;setval&lt;/code&gt; 함수를 사용 하여 시퀀스에서 작동합니다. 이 기능은 &lt;a href=&quot;functions-sequence&quot;&gt;9.16 절&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff749f2ca9f8a705af6bd96ce00013a3fb590b4b" translate="yes" xml:space="preserve">
          <source>After a sequence is created, you use the functions &lt;code&gt;nextval&lt;/code&gt;, &lt;code&gt;currval&lt;/code&gt;, and &lt;code&gt;setval&lt;/code&gt; to operate on the sequence. These functions are documented in &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt;.</source>
          <target state="translated">시퀀스가 생성 된 후 &lt;code&gt;nextval&lt;/code&gt; , &lt;code&gt;currval&lt;/code&gt; 및 &lt;code&gt;setval&lt;/code&gt; 함수를 사용 하여 시퀀스에서 작동합니다. 이러한 기능은 &lt;a href=&quot;functions-sequence&quot;&gt;섹션 9.17에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc6fe30bfc047dc5821b58053e75c58c27a7d060" translate="yes" xml:space="preserve">
          <source>After a successful rewind, the state of the target data directory is analogous to a base backup of the source data directory. Unlike taking a new base backup or using a tool like rsync, pg_rewind does not require comparing or copying unchanged relation blocks in the cluster. Only changed blocks from existing relation files are copied; all other files, including new relation files, configuration files, and WAL segments, are copied in full. As such the rewind operation is significantly faster than other approaches when the database is large and only a small fraction of blocks differ between the clusters.</source>
          <target state="translated">되감기 성공 후 대상 데이터 디렉터리의 상태는 소스 데이터 디렉터리의 기본 백업과 유사합니다. 새로운 기본 백업을 수행하거나 rsync와 같은 도구를 사용하는 것과 달리 pg_rewind는 클러스터에서 변경되지 않은 관계 블록을 비교하거나 복사 할 필요가 없습니다. 기존 관계 파일에서 변경된 블록 만 복사됩니다. 새 관계 파일, 구성 파일 및 WAL 세그먼트를 포함한 다른 모든 파일은 전체적으로 복사됩니다. 따라서 되감기 작업은 데이터베이스가 크고 클러스터간에 블록의 일부만 다를 때 다른 접근 방식보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="bc113f99607193995354648154db9d5489f2fd2b" translate="yes" xml:space="preserve">
          <source>After an index is created, the system has to keep it synchronized with the table. This adds overhead to data manipulation operations. Therefore indexes that are seldom or never used in queries should be removed.</source>
          <target state="translated">인덱스가 작성된 후 시스템은 테이블과 동기화 된 상태를 유지해야합니다. 이것은 데이터 조작 작업에 오버 헤드를 추가합니다. 따라서 드물거나 쿼리에 사용되지 않은 인덱스는 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="07e3f54a730eab0090b9f9763615353b60509ba8" translate="yes" xml:space="preserve">
          <source>After completing the tests, it's recommended you disable the &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; parameter:</source>
          <target state="translated">테스트를 완료 한 후 &lt;code&gt;sepgsql_regression_test_mode&lt;/code&gt; 매개 변수 를 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b07e5c0448618c87913bcee1323b05d5b460e37c" translate="yes" xml:space="preserve">
          <source>After creating partitions of &lt;code&gt;measurement_y2006m02&lt;/code&gt;, any data inserted into &lt;code&gt;measurement&lt;/code&gt; that is mapped to &lt;code&gt;measurement_y2006m02&lt;/code&gt; (or data that is directly inserted into &lt;code&gt;measurement_y2006m02&lt;/code&gt;, provided it satisfies its partition constraint) will be further redirected to one of its partitions based on the &lt;code&gt;peaktemp&lt;/code&gt; column. The partition key specified may overlap with the parent's partition key, although care should be taken when specifying the bounds of a sub-partition such that the set of data it accepts constitutes a subset of what the partition's own bounds allows; the system does not try to check whether that's really the case.</source>
          <target state="translated">의 파티션을 생성 한 후 &lt;code&gt;measurement_y2006m02&lt;/code&gt; 을 , 데이터가 삽입 &lt;code&gt;measurement&lt;/code&gt; 에 매핑 &lt;code&gt;measurement_y2006m02&lt;/code&gt; (또는 직접 삽입 데이터 &lt;code&gt;measurement_y2006m02&lt;/code&gt; 를 , 그것을 만족 그 파티션 제약 제공) 상기 기반으로 파티션 중 하나에 리다이렉트한다 &lt;code&gt;peaktemp&lt;/code&gt; 의 칼럼. 지정된 파티션 키는 부모의 파티션 키와 겹칠 수 있지만 하위 파티션의 경계를 지정할 때는주의해야합니다. 따라서 허용되는 데이터 세트가 파티션 자체의 경계가 허용하는 것의 일부를 구성합니다. 시스템은 실제로 그런지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db536621da1a6c52f06af534df944428be135246" translate="yes" xml:space="preserve">
          <source>After creating the function, we create a trigger which calls the trigger function:</source>
          <target state="translated">함수를 만든 후 트리거 함수를 호출하는 트리거를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c393be77ecb9862e06e4a42080ca1b8d309670b1" translate="yes" xml:space="preserve">
          <source>After modifying that file, a reboot is required for the new settings to take effect.</source>
          <target state="translated">해당 파일을 수정 한 후 새 설정을 적용하려면 재부팅해야합니다.</target>
        </trans-unit>
        <trans-unit id="c876187243218ed419e1b156be87fd9454c80ab8" translate="yes" xml:space="preserve">
          <source>After passing the &lt;code&gt;WHERE&lt;/code&gt; filter, the derived input table might be subject to grouping, using the &lt;code&gt;GROUP BY&lt;/code&gt; clause, and elimination of group rows using the &lt;code&gt;HAVING&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 필터를 전달하면 파생 된 입력 테이블이 &lt;code&gt;GROUP BY&lt;/code&gt; 절을 사용하여 그룹화 되고 &lt;code&gt;HAVING&lt;/code&gt; 절을 사용하여 그룹 행이 제거 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="476a32ba88141aeb970e81601edc2ee511e8c4b9" translate="yes" xml:space="preserve">
          <source>After reaching the end of valid WAL, keep polling once per second for new WAL to appear.</source>
          <target state="translated">유효한 WAL의 끝에 도달 한 후 새 WAL이 나타나도록 초당 폴링을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="fd721ac53a17faa8b9db323757ed059c923d71fc" translate="yes" xml:space="preserve">
          <source>After recompiling and running the new binary, check that your newly added probe is available by executing the following DTrace command. You should see similar output:</source>
          <target state="translated">새 바이너리를 다시 컴파일하고 실행 한 후 다음 DTrace 명령을 실행하여 새로 추가 된 프로브를 사용할 수 있는지 확인하십시오. 비슷한 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c206de8ceae00b19b0bbd697b5fe278bf3d62023" translate="yes" xml:space="preserve">
          <source>After restoring a backup, it is wise to run &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; on each database so the query optimizer has useful statistics; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information. For more advice on how to load large amounts of data into PostgreSQL efficiently, refer to &lt;a href=&quot;populate&quot;&gt;Section 14.4&lt;/a&gt;.</source>
          <target state="translated">백업을 복원 한 후 각 데이터베이스 에서 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 실행 하여 쿼리 최적화 프로그램이 유용한 통계를 얻는 것이 좋습니다 . 참조 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;섹션 24.1.3&lt;/a&gt; 및 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;섹션 24.1.6을&lt;/a&gt; 자세한 내용은. PostgreSQL에 대량의 데이터를 효율적으로로드하는 방법에 대한 자세한 내용 &lt;a href=&quot;populate&quot;&gt;은 14.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="417976bf060ad8e20656ba39a451c14e19b1e474" translate="yes" xml:space="preserve">
          <source>After rolling back to a savepoint, it continues to be defined, so you can roll back to it several times. Conversely, if you are sure you won't need to roll back to a particular savepoint again, it can be released, so the system can free some resources. Keep in mind that either releasing or rolling back to a savepoint will automatically release all savepoints that were defined after it.</source>
          <target state="translated">저장 점으로 롤백 한 후에는 저장 점이 계속 정의되므로 여러 번 롤백 할 수 있습니다. 반대로, 특정 세이브 포인트로 다시 롤백 할 필요가 없다고 확신하면이를 해제하여 시스템이 일부 자원을 해제 할 수 있습니다. 저장 점을 해제하거나 롤백하면 롤백 후에 정의 된 모든 저장 점이 자동으로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="39ee00792319dcfa46ab74c067181f9cb4e42b47" translate="yes" xml:space="preserve">
          <source>After running pg_rewind, WAL replay needs to complete for the data directory to be in a consistent state. When the target server is started again it will enter archive recovery and replay all WAL generated in the source server from the last checkpoint before the point of divergence. If some of the WAL was no longer available in the source server when pg_rewind was run, and therefore could not be copied by the pg_rewind session, it must be made available when the target server is started. This can be done by creating a &lt;code&gt;recovery.signal&lt;/code&gt; file in the target data directory and by configuring a suitable &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; in &lt;code&gt;postgresql.conf&lt;/code&gt;.</source>
          <target state="translated">pg_rewind를 실행 한 후 데이터 디렉토리가 일관된 상태가 되려면 WAL 재생을 완료해야합니다. 대상 서버가 다시 시작되면 아카이브 복구로 들어가고 발산 지점 이전의 마지막 체크 포인트에서 소스 서버에서 생성 된 모든 WAL을 재생합니다. pg_rewind가 실행될 때 소스 서버에서 일부 WAL을 더 이상 사용할 수 없어서 pg_rewind 세션에서 복사 할 수없는 경우 대상 서버가 시작될 때 사용할 수 있어야합니다. 대상 데이터 디렉토리에 &lt;code&gt;recovery.signal&lt;/code&gt; 파일 을 생성하고 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 적절한 &lt;a href=&quot;runtime-config-wal#GUC-RESTORE-COMMAND&quot;&gt;restore_command&lt;/a&gt; 를 구성하여 이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2cf5063e2afd451a505eeabbaaa31e6dea2f166" translate="yes" xml:space="preserve">
          <source>After running this command, it should be possible to start the server, but bear in mind that the database might contain inconsistent data due to partially-committed transactions. You should immediately dump your data, run &lt;code&gt;initdb&lt;/code&gt;, and reload. After reload, check for inconsistencies and repair as needed.</source>
          <target state="translated">이 명령을 실행 한 후에는 서버를 시작할 수 있지만 부분적으로 커밋 된 트랜잭션으로 인해 데이터베이스에 일치하지 않는 데이터가 포함될 수 있습니다. 즉시 데이터를 덤프 하고 &lt;code&gt;initdb&lt;/code&gt; 를 실행 한 후 다시로드해야합니다. 다시로드 한 후 불일치를 확인하고 필요에 따라 복구하십시오.</target>
        </trans-unit>
        <trans-unit id="f1751e378d5c61831bc66381dd026a28d4a7604f" translate="yes" xml:space="preserve">
          <source>After the &lt;code&gt;auth-method&lt;/code&gt; field, there can be field(s) of the form &lt;code&gt;name&lt;/code&gt;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; that specify options for the authentication method. Details about which options are available for which authentication methods appear below.</source>
          <target state="translated">&lt;code&gt;auth-method&lt;/code&gt; 필드 뒤에는 인증 방법에 대한 옵션을 지정하는 &lt;code&gt;name&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 형식의 필드가있을 수 있습니다 . 어떤 인증 방법에 사용할 수있는 옵션에 대한 자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="129d74f6272df45af1d745e991e7a73feebafe5a" translate="yes" xml:space="preserve">
          <source>After the processing of the &lt;code&gt;FROM&lt;/code&gt; clause is done, each row of the derived virtual table is checked against the search condition. If the result of the condition is true, the row is kept in the output table, otherwise (i.e., if the result is false or null) it is discarded. The search condition typically references at least one column of the table generated in the &lt;code&gt;FROM&lt;/code&gt; clause; this is not required, but otherwise the &lt;code&gt;WHERE&lt;/code&gt; clause will be fairly useless.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절 처리 가 완료되면 파생 된 가상 테이블의 각 행이 검색 조건과 비교하여 점검됩니다. 조건의 결과가 true이면 행이 출력 테이블에 유지되고, 그렇지 않으면 (예 : 결과가 false 또는 null 인 경우) 삭제됩니다. 검색 조건은 일반적으로 &lt;code&gt;FROM&lt;/code&gt; 절 에서 생성 된 테이블의 하나 이상의 열을 참조합니다 . 이것은 필수는 아니지만 &lt;code&gt;WHERE&lt;/code&gt; 절은 상당히 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7afbd68cfd57086d9de66444e71b66bfaedc388a" translate="yes" xml:space="preserve">
          <source>After the select list has been processed, the result table can optionally be subject to the elimination of duplicate rows. The &lt;code&gt;DISTINCT&lt;/code&gt; key word is written directly after &lt;code&gt;SELECT&lt;/code&gt; to specify this:</source>
          <target state="translated">선택 목록이 처리 된 후 결과 테이블에 선택적으로 중복 행이 제거 될 수 있습니다. &lt;code&gt;DISTINCT&lt;/code&gt; 키워드는 바로 후 작성 &lt;code&gt;SELECT&lt;/code&gt; 는 이를 지정할 수 :</target>
        </trans-unit>
        <trans-unit id="6f94a805413e3bb85d7fa38665d29205c38f9186" translate="yes" xml:space="preserve">
          <source>After this command is executed, the index is &amp;ldquo;owned&amp;rdquo; by the constraint, in the same way as if the index had been built by a regular &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; or &lt;code&gt;ADD UNIQUE&lt;/code&gt; command. In particular, dropping the constraint will make the index disappear too.</source>
          <target state="translated">이 명령이 실행 된 후에는 색인이 일반 &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; 또는 &lt;code&gt;ADD UNIQUE&lt;/code&gt; 명령으로 작성된 것과 같은 방식으로 제한 조건이 색인을 &quot;소유&quot;합니다 . 특히 제약 조건을 삭제하면 인덱스도 사라집니다.</target>
        </trans-unit>
        <trans-unit id="5a54a1d7a070e112cd3e777d9befed8de7b72e73" translate="yes" xml:space="preserve">
          <source>Again connect to the database as a user with rights to run pg_stop_backup (superuser, or a user who has been granted EXECUTE on the function), and issue the command:</source>
          <target state="translated">pg_stop_backup (수퍼 유저 또는 함수에서 EXECUTE가 부여 된 사용자)을 실행할 권한이있는 사용자로 데이터베이스에 다시 연결하고 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="89c328b5eae1533574b7b6b9cb4641c91474c438" translate="yes" xml:space="preserve">
          <source>Again the planner examines the &lt;code&gt;WHERE&lt;/code&gt; clause condition and looks up the selectivity function for &lt;code&gt;=&lt;/code&gt;, which is &lt;code&gt;eqsel&lt;/code&gt;. For equality estimation the histogram is not useful; instead the list of &lt;em&gt;most common values&lt;/em&gt; (MCVs) is used to determine the selectivity. Let's have a look at the MCVs, with some additional columns that will be useful later:</source>
          <target state="translated">다시 플래너는 &lt;code&gt;WHERE&lt;/code&gt; 절 조건을 검사하고 &lt;code&gt;=&lt;/code&gt; 에 대한 선택성 함수 인 &lt;code&gt;eqsel&lt;/code&gt; 을 찾습니다 . 등식 추정을 위해 히스토그램은 유용하지 않습니다. 대신에 &lt;em&gt;가장 일반적인 값&lt;/em&gt; (MCV) 목록이 선택성을 결정하는 데 사용됩니다. 나중에 유용 할 몇 가지 추가 열이있는 MCV를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4c27783eb44bcd1d4c219fa9ccfc28e663471099" translate="yes" xml:space="preserve">
          <source>Again, a more realistic example:</source>
          <target state="translated">다시 한 번 더 현실적인 예 :</target>
        </trans-unit>
        <trans-unit id="6c1eea13275ab96326295feeff11f71292c224b0" translate="yes" xml:space="preserve">
          <source>Again, a table alias is required. Assigning alias names to the columns of the &lt;code&gt;VALUES&lt;/code&gt; list is optional, but is good practice. For more information see &lt;a href=&quot;queries-values&quot;&gt;Section 7.7&lt;/a&gt;.</source>
          <target state="translated">다시 테이블 별칭이 필요합니다. &lt;code&gt;VALUES&lt;/code&gt; 목록 의 열에 별명을 지정하는 것은 선택 사항이지만 좋은 방법입니다. 자세한 정보는 &lt;a href=&quot;queries-values&quot;&gt;7.7 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa2e8717405811a7aefb85de6cf3250083c52ac2" translate="yes" xml:space="preserve">
          <source>Again, note that some of these commands are actually allowed during &quot;read only&quot; mode transactions on the primary.</source>
          <target state="translated">다시 말하지만,이 명령 중 일부는 기본에서 &quot;읽기 전용&quot;모드 트랜잭션 중에 실제로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d75929b4f5b2f824a7a07da4899bf1820357b131" translate="yes" xml:space="preserve">
          <source>Again, see &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for more detail.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;12 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8820b9fd552bc40289d6bbf23d466ae2aeb85fb1" translate="yes" xml:space="preserve">
          <source>Again, see &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for more detail.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;12 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="73c2d4672afb28ef558326e3d56d8e571d70b6fe" translate="yes" xml:space="preserve">
          <source>Again, the argument &lt;code&gt;uppercase&lt;/code&gt; was omitted so it is set to &lt;code&gt;false&lt;/code&gt; implicitly. One advantage of using named notation is that the arguments may be specified in any order, for example:</source>
          <target state="translated">다시, &lt;code&gt;uppercase&lt;/code&gt; 는 생략되었으므로 암시 적 으로 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 . 명명 된 표기법을 사용하면 다음과 같은 순서로 인수를 지정할 수 있다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="558d7aad6e94b62a3c3d222979b260b60b6db7d2" translate="yes" xml:space="preserve">
          <source>Aggregate Functions</source>
          <target state="translated">집계 함수</target>
        </trans-unit>
        <trans-unit id="644f8b99c4c1166b7dd3dea3ff097223a8e3390b" translate="yes" xml:space="preserve">
          <source>Aggregate function (routine)</source>
          <target state="translated">집계 함수 (루틴)</target>
        </trans-unit>
        <trans-unit id="78066b1c350419b50af4d9f199ab1be3ff9a7bd9" translate="yes" xml:space="preserve">
          <source>Aggregate functions are an extension.</source>
          <target state="translated">집계 함수는 확장입니다.</target>
        </trans-unit>
        <trans-unit id="871c4bc7e83d3ebb5166fa9fb4f5c7870dcdec31" translate="yes" xml:space="preserve">
          <source>Aggregate functions that support &lt;em&gt;Partial Mode&lt;/em&gt; are eligible to participate in various optimizations, such as parallel aggregation.</source>
          <target state="translated">&lt;em&gt;부분 모드&lt;/em&gt; 를 지원하는 집계 함수는 병렬 집계와 같은 다양한 최적화에 참여할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41c2d9b93a1fb3de5a512eb3000462da32b26df8" translate="yes" xml:space="preserve">
          <source>Aggregate functions which support &lt;em&gt;Partial Mode&lt;/em&gt; are eligible to participate in various optimizations, such as parallel aggregation.</source>
          <target state="translated">&lt;em&gt;부분 모드&lt;/em&gt; 를 지원하는 집계 함수 는 병렬 집계와 같은 다양한 최적화에 참여할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90d68cd3e256fbe87b23e489f9c82e0bca666a22" translate="yes" xml:space="preserve">
          <source>Aggregate functions, if any are used, are computed across all rows making up each group, producing a separate value for each group. (If there are aggregate functions but no &lt;code&gt;GROUP BY&lt;/code&gt; clause, the query is treated as having a single group comprising all the selected rows.) The set of rows fed to each aggregate function can be further filtered by attaching a &lt;code&gt;FILTER&lt;/code&gt; clause to the aggregate function call; see &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;Section 4.2.7&lt;/a&gt; for more information. When a &lt;code&gt;FILTER&lt;/code&gt; clause is present, only those rows matching it are included in the input to that aggregate function.</source>
          <target state="translated">집계 함수 (있는 경우)는 각 그룹을 구성하는 모든 행에서 계산되어 각 그룹에 대해 별도의 값을 생성합니다. 집계 함수가 있지만 &lt;code&gt;GROUP BY&lt;/code&gt; 절이 없는 경우 쿼리는 선택한 모든 행을 포함하는 단일 그룹을 갖는 것으로 처리됩니다. 각 집계 함수에 공급되는 행 세트는 집계 함수에 &lt;code&gt;FILTER&lt;/code&gt; 절을 첨부하여 추가로 필터링 할 수 있습니다. 요구; 참조 &lt;a href=&quot;sql-expressions#SYNTAX-AGGREGATES&quot;&gt;섹션 4.2.7을&lt;/a&gt; 자세한 내용은. 때 &lt;code&gt;FILTER&lt;/code&gt; 절이이를 일치 행만 그 집계 함수에 대한 입력으로 포함된다.</target>
        </trans-unit>
        <trans-unit id="cbff25b6bf81504908e5320d1af957a7ec74d3b6" translate="yes" xml:space="preserve">
          <source>Aggregate kind: &lt;code&gt;n&lt;/code&gt; for &amp;ldquo;normal&amp;rdquo; aggregates, &lt;code&gt;o&lt;/code&gt; for &amp;ldquo;ordered-set&amp;rdquo; aggregates, or &lt;code&gt;h&lt;/code&gt; for &amp;ldquo;hypothetical-set&amp;rdquo; aggregates</source>
          <target state="translated">집계 종류 : &lt;code&gt;n&lt;/code&gt; &quot;정상적인&quot;집계에 대한 &lt;code&gt;o&lt;/code&gt; &quot;주문 - 세트&quot;에 대한 집계, 또는 &lt;code&gt;h&lt;/code&gt; &quot;가상 세트&quot;골재</target>
        </trans-unit>
        <trans-unit id="113588f464cd4fe7bfbc7d7c65d0648a3eeb21d0" translate="yes" xml:space="preserve">
          <source>Aggregate: *</source>
          <target state="translated">집계 : *</target>
        </trans-unit>
        <trans-unit id="d76c0a0d13e4564f62e4ef32c8d0ac5d3a9bd1e2" translate="yes" xml:space="preserve">
          <source>Aggregate: GROUP BY</source>
          <target state="translated">집계 : GROUP BY</target>
        </trans-unit>
        <trans-unit id="67fa6b402dc45ed045bd73c615623304375dc24b" translate="yes" xml:space="preserve">
          <source>Aggregate: GROUPING</source>
          <target state="translated">집계 : 그룹화</target>
        </trans-unit>
        <trans-unit id="bf655ffdd9634b84bf30927558cadb22681f9bbb" translate="yes" xml:space="preserve">
          <source>Aggregate: WITHIN GROUP</source>
          <target state="translated">집계 : 그룹 내</target>
        </trans-unit>
        <trans-unit id="e7717151bc6adba0544d963b5ecd779cf9aefbe1" translate="yes" xml:space="preserve">
          <source>Aggregate: array_agg</source>
          <target state="translated">집계 : array_agg</target>
        </trans-unit>
        <trans-unit id="7671fe3f4aa646a763a41cd74b0f33b4d9825d22" translate="yes" xml:space="preserve">
          <source>Aggregate: avg</source>
          <target state="translated">집계 : 평균</target>
        </trans-unit>
        <trans-unit id="9464ad790968a8c3f29976c4cecb93cf8cb97818" translate="yes" xml:space="preserve">
          <source>Aggregate: bit_and</source>
          <target state="translated">집계 : bit_and</target>
        </trans-unit>
        <trans-unit id="f4ff9c9094ce1f94db13530e24012163b5e11d40" translate="yes" xml:space="preserve">
          <source>Aggregate: bit_or</source>
          <target state="translated">집계 : bit_or</target>
        </trans-unit>
        <trans-unit id="b9c262247be1030665a29ac642cf245ebfafdc8c" translate="yes" xml:space="preserve">
          <source>Aggregate: bool_and</source>
          <target state="translated">집계 : bool_and</target>
        </trans-unit>
        <trans-unit id="a36b04811f8dfcb04687f062eee53e188ba68218" translate="yes" xml:space="preserve">
          <source>Aggregate: bool_or</source>
          <target state="translated">집계 : bool_or</target>
        </trans-unit>
        <trans-unit id="6b938ae10da8a5049736d651f7bdf37fa7dd2ec6" translate="yes" xml:space="preserve">
          <source>Aggregate: corr</source>
          <target state="translated">집계 : corr</target>
        </trans-unit>
        <trans-unit id="f67c8e60c07fff9ff21ed59ebe5883cf64966901" translate="yes" xml:space="preserve">
          <source>Aggregate: count</source>
          <target state="translated">집계 : 개수</target>
        </trans-unit>
        <trans-unit id="a535e7f27744a217a4b4ebbcc5ce09395054c24d" translate="yes" xml:space="preserve">
          <source>Aggregate: covar_pop</source>
          <target state="translated">집계 : covar_pop</target>
        </trans-unit>
        <trans-unit id="e42952cf656ba58f6dfa69af76b03eb6f4865935" translate="yes" xml:space="preserve">
          <source>Aggregate: covar_samp</source>
          <target state="translated">집계 : covar_samp</target>
        </trans-unit>
        <trans-unit id="fc5ea10421b5c30ba97731125807dc2645fb9fc1" translate="yes" xml:space="preserve">
          <source>Aggregate: cume_dist</source>
          <target state="translated">집계 : cume_dist</target>
        </trans-unit>
        <trans-unit id="affa989634b7b7f9316e718975ac524915a80100" translate="yes" xml:space="preserve">
          <source>Aggregate: cume_dist WITHIN GROUP</source>
          <target state="translated">집계 : cume_dist WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="5413552564b5ce9858645aad9d11f00224935ffb" translate="yes" xml:space="preserve">
          <source>Aggregate: dense_rank</source>
          <target state="translated">집계 : density_rank</target>
        </trans-unit>
        <trans-unit id="3ff732a0c7e39824a92acd57f902391a878f3abf" translate="yes" xml:space="preserve">
          <source>Aggregate: dense_rank WITHIN GROUP</source>
          <target state="translated">집계 : 그룹 내에서 dense_rank</target>
        </trans-unit>
        <trans-unit id="8dc8d8ebf59b788e17565bab2f4948b36d249316" translate="yes" xml:space="preserve">
          <source>Aggregate: every</source>
          <target state="translated">집계 : 모든</target>
        </trans-unit>
        <trans-unit id="cb574ceb369d625e53cf66f30a46474ab01c8d22" translate="yes" xml:space="preserve">
          <source>Aggregate: json_agg</source>
          <target state="translated">집계 : json_agg</target>
        </trans-unit>
        <trans-unit id="5daf429a167bfb1204d6816cc327273b7dff3d24" translate="yes" xml:space="preserve">
          <source>Aggregate: json_object_agg</source>
          <target state="translated">집계 : json_object_agg</target>
        </trans-unit>
        <trans-unit id="146ad7890c6afaeaa83cf4ce928bc658120656b5" translate="yes" xml:space="preserve">
          <source>Aggregate: jsonb_agg</source>
          <target state="translated">집계 : jsonb_agg</target>
        </trans-unit>
        <trans-unit id="6f7d6e6ca2d445820090cd7f314ec40d5730bd62" translate="yes" xml:space="preserve">
          <source>Aggregate: jsonb_object_agg</source>
          <target state="translated">집계 : jsonb_object_agg</target>
        </trans-unit>
        <trans-unit id="65e31a82796d0cddf371f7a0ba43aa2ede594f67" translate="yes" xml:space="preserve">
          <source>Aggregate: max</source>
          <target state="translated">집계 : 최대</target>
        </trans-unit>
        <trans-unit id="36d81566b6da93dc64aade9617077054e335a89e" translate="yes" xml:space="preserve">
          <source>Aggregate: min</source>
          <target state="translated">집계 : 분</target>
        </trans-unit>
        <trans-unit id="4eb5d44d93ed2f2a9cdcc0ef1679955c52d6f77c" translate="yes" xml:space="preserve">
          <source>Aggregate: mode</source>
          <target state="translated">집계 : 모드</target>
        </trans-unit>
        <trans-unit id="7c96cf40a4dc1d8d1ea12a0b1f5bcf59364dc827" translate="yes" xml:space="preserve">
          <source>Aggregate: mode WITHIN GROUP</source>
          <target state="translated">집계 : 그룹 내 모드</target>
        </trans-unit>
        <trans-unit id="3827ba089152343be605c81a6829b3adfab7a03f" translate="yes" xml:space="preserve">
          <source>Aggregate: percent_rank</source>
          <target state="translated">집계 : percent_rank</target>
        </trans-unit>
        <trans-unit id="34b5e1912aa5215dcec451af73485fcbfd34b50f" translate="yes" xml:space="preserve">
          <source>Aggregate: percent_rank WITHIN GROUP</source>
          <target state="translated">집계 : 그룹 내에서 percent_rank</target>
        </trans-unit>
        <trans-unit id="4071198c9c5d51f5904da94e25f898d0927a065a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_cont</source>
          <target state="translated">집계 : percentile_cont</target>
        </trans-unit>
        <trans-unit id="1d40010d0c71e89dc5a258e985609a24fad7370a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_cont WITHIN GROUP</source>
          <target state="translated">집계 : percentile_cont WITHIN GROUP</target>
        </trans-unit>
        <trans-unit id="221d8437a4694e24ecacfafa477406400d56070a" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_disc</source>
          <target state="translated">집계 : percentile_disc</target>
        </trans-unit>
        <trans-unit id="9c269fdb441e6262d2a37b019da9d266f3b3b083" translate="yes" xml:space="preserve">
          <source>Aggregate: percentile_disc WITHIN GROUP</source>
          <target state="translated">집계 : 그룹 내에서 percentile_disc</target>
        </trans-unit>
        <trans-unit id="780b4bfa2df2c728976c6499686f1e45a03cae9d" translate="yes" xml:space="preserve">
          <source>Aggregate: rank</source>
          <target state="translated">집계 : 순위</target>
        </trans-unit>
        <trans-unit id="66604fc6a8764a0b6d82483c45c9ff5043d563ce" translate="yes" xml:space="preserve">
          <source>Aggregate: rank WITHIN GROUP</source>
          <target state="translated">집계 : 그룹 내 순위</target>
        </trans-unit>
        <trans-unit id="08db334b9f771618e8d9956b3a35006958baa8aa" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_avgx</source>
          <target state="translated">집계 : regr_avgx</target>
        </trans-unit>
        <trans-unit id="f813e6eb9f1bd8f18122c9d3100e3e1329000930" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_avgy</source>
          <target state="translated">집계 : regr_avgy</target>
        </trans-unit>
        <trans-unit id="db3268966df89189e65fd222205de0442daba3c2" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_count</source>
          <target state="translated">집계 : regr_count</target>
        </trans-unit>
        <trans-unit id="4489b8487a16a39dde1e4d8b5fcd20f0950266f5" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_intercept</source>
          <target state="translated">집계 : regr_intercept</target>
        </trans-unit>
        <trans-unit id="17dd93536539876bbf56b59964ca4c7379d9ef8f" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_r2</source>
          <target state="translated">집계 : regr_r2</target>
        </trans-unit>
        <trans-unit id="bbd0902e24a6b13aeeb42be12d4c6ac689ac39d4" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_slope</source>
          <target state="translated">집계 : regr_slope</target>
        </trans-unit>
        <trans-unit id="83dbb5beff01870dc33ceaa7278e2d80cc920457" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_sxx</source>
          <target state="translated">집계 : regr_sxx</target>
        </trans-unit>
        <trans-unit id="ec7ca11bda1c42f1ba07c7f1bd8a0c3296064181" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_sxy</source>
          <target state="translated">집계 : regr_sxy</target>
        </trans-unit>
        <trans-unit id="f14b071a16428ce5a21dc895086399aaadc762a3" translate="yes" xml:space="preserve">
          <source>Aggregate: regr_syy</source>
          <target state="translated">집계 : regr_syy</target>
        </trans-unit>
        <trans-unit id="c004eede3fbd79af583dbd185f768dfae4d466a6" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev</source>
          <target state="translated">집계 : stddev</target>
        </trans-unit>
        <trans-unit id="1d5e80f190137dd3cac84ce1a78d10780d5bce34" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev_pop</source>
          <target state="translated">집계 : stddev_pop</target>
        </trans-unit>
        <trans-unit id="d3b157c6a46f69b3887530f9f9b22d6b9cb4a16e" translate="yes" xml:space="preserve">
          <source>Aggregate: stddev_samp</source>
          <target state="translated">집계 : stddev_samp</target>
        </trans-unit>
        <trans-unit id="2974203e91cce11e66f9221d5ec28297655cd0a8" translate="yes" xml:space="preserve">
          <source>Aggregate: string_agg</source>
          <target state="translated">집계 : string_agg</target>
        </trans-unit>
        <trans-unit id="ee008bd21c90b91f02271735e82b4e05772fdd98" translate="yes" xml:space="preserve">
          <source>Aggregate: sum</source>
          <target state="translated">집계 : 합계</target>
        </trans-unit>
        <trans-unit id="7f9f090a85b6cef6189e9f1f572af2d4232d4c63" translate="yes" xml:space="preserve">
          <source>Aggregate: sum/N</source>
          <target state="translated">집계 : 합계 / N</target>
        </trans-unit>
        <trans-unit id="42f2801430c2438881499cac7d09362a7b44215e" translate="yes" xml:space="preserve">
          <source>Aggregate: to_json</source>
          <target state="translated">집계 : to_json</target>
        </trans-unit>
        <trans-unit id="56a46ffd3d158ae27b092ee54bfe3724f518b2f3" translate="yes" xml:space="preserve">
          <source>Aggregate: var_pop</source>
          <target state="translated">집계 : var_pop</target>
        </trans-unit>
        <trans-unit id="3c7dc337d4d493d0b8b497185b09dab2dd6b0e40" translate="yes" xml:space="preserve">
          <source>Aggregate: var_samp</source>
          <target state="translated">집계 : var_samp</target>
        </trans-unit>
        <trans-unit id="51e197a4c87920c56f05e65ce1ba4b227834b071" translate="yes" xml:space="preserve">
          <source>Aggregate: variance</source>
          <target state="translated">집계 : 분산</target>
        </trans-unit>
        <trans-unit id="a2fb0accd998c64e0241184b4242d48e43957e30" translate="yes" xml:space="preserve">
          <source>Aggregate: xmlagg</source>
          <target state="translated">집계 : xmlagg</target>
        </trans-unit>
        <trans-unit id="576d72bc3c483daa9c7746a2659f34dd5176aed8" translate="yes" xml:space="preserve">
          <source>Aggregated Argument Type(s)</source>
          <target state="translated">집계 된 인수 유형</target>
        </trans-unit>
        <trans-unit id="425a801b77a97dcec7fa5fa5f67892cad03a7787" translate="yes" xml:space="preserve">
          <source>Aggregated Logging</source>
          <target state="translated">집계 로깅</target>
        </trans-unit>
        <trans-unit id="604697606446ca85390963f1caeb65a8c41712bd" translate="yes" xml:space="preserve">
          <source>Aggregates are also very useful in combination with &lt;code&gt;GROUP BY&lt;/code&gt; clauses. For example, we can get the maximum low temperature observed in each city with:</source>
          <target state="translated">집계는 &lt;code&gt;GROUP BY&lt;/code&gt; 절 과 함께 사용하면 매우 유용 합니다. 예를 들어, 각 도시에서 관찰되는 최대 저온을 다음과 같이 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a83bb8f12f58dc63f8d8450952fc03b0bc1ffde" translate="yes" xml:space="preserve">
          <source>Aggregates that behave like &lt;code&gt;MIN&lt;/code&gt; or &lt;code&gt;MAX&lt;/code&gt; can sometimes be optimized by looking into an index instead of scanning every input row. If this aggregate can be so optimized, indicate it by specifying a &lt;em&gt;sort operator&lt;/em&gt;. The basic requirement is that the aggregate must yield the first element in the sort ordering induced by the operator; in other words:</source>
          <target state="translated">&lt;code&gt;MIN&lt;/code&gt; 또는 &lt;code&gt;MAX&lt;/code&gt; 처럼 동작하는 집계는 모든 입력 행을 스캔하는 대신 인덱스를 조사하여 최적화 할 수 있습니다. 이 집계를 최적화 할 수 있으면 &lt;em&gt;정렬 연산자&lt;/em&gt; 를 지정하여 표시하십시오 . 기본 요구 사항은 집계가 연산자에 의해 유도 된 정렬 순서의 첫 번째 요소를 산출해야한다는 것입니다. 다시 말해:</target>
        </trans-unit>
        <trans-unit id="7ec048891025aea562b86e815620f42ae7adb619" translate="yes" xml:space="preserve">
          <source>Aggressive &lt;code&gt;VACUUM&lt;/code&gt; scans, regardless of what causes them, enable advancing the value for that table. Eventually, as all tables in all databases are scanned and their oldest multixact values are advanced, on-disk storage for older multixacts can be removed.</source>
          <target state="translated">원인이 무엇이든 관계없이 적극적인 &lt;code&gt;VACUUM&lt;/code&gt; 스캔은 해당 테이블의 값을 향상시킬 수 있습니다. 결국 모든 데이터베이스의 모든 테이블이 스캔되고 가장 오래된 multixact 값이 향상됨에 따라 오래된 multixact에 대한 디스크상의 스토리지를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="121abf3940fab2d8dbe9b94bbd289148bc06a85b" translate="yes" xml:space="preserve">
          <source>Aggressively &amp;ldquo;freeze&amp;rdquo; tuples.</source>
          <target state="translated">튜플을 적극적으로 &quot;동결&quot;시킵니다.</target>
        </trans-unit>
        <trans-unit id="bcb017abcff2696033726df1d1faa6140cda30fa" translate="yes" xml:space="preserve">
          <source>Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Moscow, Postgres Professional, Russia</source>
          <target state="translated">Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , 모스크바, Postgres Professional, 러시아</target>
        </trans-unit>
        <trans-unit id="aa44f40c0080e2d8f22aa729bc2aa695de07bb55" translate="yes" xml:space="preserve">
          <source>Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Postgres Professional, Moscow, Russia</source>
          <target state="translated">Alexander Korotkov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:a.korotkov@postgrespro.ru&quot;&gt;a.korotkov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , Postgres Professional, 모스크바, 러시아</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="04259816ace1ebe56c853a8763558570c008514a" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="9e3800ae71f3a62322201681fab38592cc7aac5f" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;glossary#GLOSSARY-AGGREGATE&quot;&gt;aggregate functions&lt;/a&gt; can be used as window functions, but window functions can also be used to, for example, give ranks to each of the rows in the partition. Also known as &lt;em&gt;analytic functions&lt;/em&gt;.</source>
          <target state="translated">모든 &lt;a href=&quot;glossary#GLOSSARY-AGGREGATE&quot;&gt;집계 함수&lt;/a&gt; 는 창 함수로 사용할 수 있지만 창 함수는 예를 들어 파티션의 각 행에 순위를 부여하는 데 사용할 수도 있습니다. &lt;em&gt;분석 함수&lt;/em&gt; 라고도 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1238bd88f43030284835da146c8f594a6e3253c8" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;pgcrypto&lt;/code&gt; functions run inside the database server. That means that all the data and passwords move between &lt;code&gt;pgcrypto&lt;/code&gt; and client applications in clear text. Thus you must:</source>
          <target state="translated">모든 &lt;code&gt;pgcrypto&lt;/code&gt; 기능은 데이터베이스 서버 내에서 실행됩니다. 즉, 모든 데이터와 비밀번호 는 일반 텍스트로 &lt;code&gt;pgcrypto&lt;/code&gt; 와 클라이언트 애플리케이션 간에 이동 합니다. 따라서 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b67ddd3a2de73817c7543968b2cc085a1a78542" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;storage&lt;/code&gt; values other than &lt;code&gt;plain&lt;/code&gt; imply that the functions of the data type can handle values that have been &lt;em&gt;toasted&lt;/em&gt;, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt;. The specific other value given merely determines the default TOAST storage strategy for columns of a toastable data type; users can pick other strategies for individual columns using &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; 이외의 모든 &lt;code&gt;storage&lt;/code&gt; 값 은 &lt;a href=&quot;storage-toast&quot;&gt;섹션 68.2&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/xtypes.html#XTYPES-TOAST&quot;&gt;섹션 37.13.1에&lt;/a&gt; 설명 &lt;em&gt;된&lt;/em&gt; 대로 데이터 유형의 기능이 &lt;em&gt;토스트 된&lt;/em&gt; 값을 처리 할 수 ​​있음을 의미합니다 . 주어진 다른 특정 값은 단순히 토스트 가능한 데이터 유형의 열에 대한 기본 TOAST 스토리지 전략을 결정합니다. 사용자는 &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt; 를 사용하여 개별 열에 대한 다른 전략을 선택할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f8dfd6e92427babe1e9a096720e962dca35e82cb" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;storage&lt;/code&gt; values other than &lt;code&gt;plain&lt;/code&gt; imply that the functions of the data type can handle values that have been &lt;em&gt;toasted&lt;/em&gt;, as described in &lt;a href=&quot;storage-toast&quot;&gt;Section 68.2&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html#XTYPES-TOAST&quot;&gt;Section 37.13.1&lt;/a&gt;. The specific other value given merely determines the default TOAST storage strategy for columns of a toastable data type; users can pick other strategies for individual columns using &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; &lt;code&gt;storage&lt;/code&gt; 값 이외의 모든 저장 값 은 &lt;a href=&quot;storage-toast&quot;&gt;섹션 68.2&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/13/xtypes.html#XTYPES-TOAST&quot;&gt;섹션 37.13.1에&lt;/a&gt; 설명 &lt;em&gt;된&lt;/em&gt; 대로 데이터 유형의 함수가 &lt;em&gt;토스트 된&lt;/em&gt; 값을 처리 할 수 ​​있음을 의미합니다 . 주어진 다른 특정 값은 토스트 가능한 데이터 유형의 열에 대한 기본 TOAST 스토리지 전략을 결정합니다. 사용자는 &lt;code&gt;ALTER TABLE SET STORAGE&lt;/code&gt; 를 사용하여 개별 열에 대해 다른 전략을 선택할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10d6e0687d278d53588734a1b582257aaee1502f" translate="yes" xml:space="preserve">
          <source>All Privileges</source>
          <target state="translated">모든 권한</target>
        </trans-unit>
        <trans-unit id="bf637fbee55bb9d868af3ee61e448c31817bc7e1" translate="yes" xml:space="preserve">
          <source>All UPC, ISBN, ISMN and ISSN numbers can be represented as EAN13 numbers.</source>
          <target state="translated">모든 UPC, ISBN, ISMN 및 ISSN 번호는 EAN13 번호로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f057cd68ee57e6fcf443add2a601584e9abb4486" translate="yes" xml:space="preserve">
          <source>All WAL records required for the backup must contain sufficient full-page writes, which requires you to enable &lt;code&gt;full_page_writes&lt;/code&gt; on the master and not to use a tool like pg_compresslog as &lt;code&gt;archive_command&lt;/code&gt; to remove full-page writes from WAL files.</source>
          <target state="translated">백업에 필요한 모든 WAL 레코드에는 충분한 전체 페이지 쓰기가 포함되어 있어야 하므로 마스터에서 &lt;code&gt;full_page_writes&lt;/code&gt; 를 활성화 하고 pg_compresslog와 같은 도구를 &lt;code&gt;archive_command&lt;/code&gt; 로 사용하여 WAL 파일에서 전체 페이지 쓰기를 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="32451a83c5b4d59ae6ed31b28d945b83e60fefc2" translate="yes" xml:space="preserve">
          <source>All WAL records required for the backup must contain sufficient full-page writes, which requires you to enable &lt;code&gt;full_page_writes&lt;/code&gt; on the primary and not to use a tool like pg_compresslog as &lt;code&gt;archive_command&lt;/code&gt; to remove full-page writes from WAL files.</source>
          <target state="translated">백업에 필요한 모든 WAL 레코드에는 충분한 전체 페이지 쓰기가 포함되어야합니다. 그러려면 기본에서 &lt;code&gt;full_page_writes&lt;/code&gt; 를 활성화 하고 pg_compresslog와 같은 도구를 &lt;code&gt;archive_command&lt;/code&gt; 로 사용하여 WAL 파일에서 전체 페이지 쓰기를 제거 하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="841cc9e5c025174354644ed418b19ab2df80e067" translate="yes" xml:space="preserve">
          <source>All arguments are specified in order. The result is upper case since &lt;code&gt;uppercase&lt;/code&gt; is specified as &lt;code&gt;true&lt;/code&gt;. Another example is:</source>
          <target state="translated">모든 인수는 순서대로 지정됩니다. &lt;code&gt;uppercase&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 지정 되므로 결과는 대문자 입니다 . 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64cfac4af128aada4a6d6bb5c11a90e45ce7a24e" translate="yes" xml:space="preserve">
          <source>All check constraints and not-null constraints on a parent table are automatically inherited by its children, unless explicitly specified otherwise with &lt;code&gt;NO INHERIT&lt;/code&gt; clauses. Other types of constraints (unique, primary key, and foreign key constraints) are not inherited.</source>
          <target state="translated">&lt;code&gt;NO INHERIT&lt;/code&gt; 절로 명시 적으로 지정하지 않는 한 상위 테이블의 모든 점검 제한 조건 및 널이 아닌 제한 조건은 해당 하위 테이블에서 자동으로 상속됩니다 . 다른 유형의 제약 조건 (고유, 기본 키 및 외래 키 제약 조건)은 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="337d6bdce5b053fd7a1885beaee3b7d63bb8f598" translate="yes" xml:space="preserve">
          <source>All columns will be filled with their default values, as if &lt;code&gt;DEFAULT&lt;/code&gt; were explicitly specified for each column. (An &lt;code&gt;OVERRIDING&lt;/code&gt; clause is not permitted in this form.)</source>
          <target state="translated">&lt;code&gt;DEFAULT&lt;/code&gt; 가 각 열에 대해 명시 적으로 지정된 것처럼 모든 열은 기본값으로 채워집니다 . ( 이 양식에서는 &lt;code&gt;OVERRIDING&lt;/code&gt; 절이 허용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="89f96ca727311b0e1e924639300601036b23919a" translate="yes" xml:space="preserve">
          <source>All columns will be filled with their default values. (An &lt;code&gt;OVERRIDING&lt;/code&gt; clause is not permitted in this form.)</source>
          <target state="translated">모든 열은 기본값으로 채워집니다. ( 이 양식에서는 &lt;code&gt;OVERRIDING&lt;/code&gt; 절이 허용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="44d64899ac94e8442ee1baa672497f8a2ca162b4" translate="yes" xml:space="preserve">
          <source>All constraints on all children of the parent table are examined during constraint exclusion, so large numbers of children are likely to increase query planning time considerably. So the legacy inheritance based partitioning will work well with up to perhaps a hundred child tables; don't try to use many thousands of children.</source>
          <target state="translated">제약 조건 제외 중에 부모 테이블의 모든 자식에 대한 모든 제약 조건이 검사되므로 많은 수의 자식이 쿼리 계획 시간을 상당히 늘릴 수 있습니다. 따라서 레거시 상속 기반 파티셔닝은 최대 100 개의 자식 테이블과 잘 작동합니다. 수천 명의 아이들을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="153c80dc5116feea616ba3928be18ab8586f5a93" translate="yes" xml:space="preserve">
          <source>All current listen registrations for this session are cleared.</source>
          <target state="translated">이 세션에 대한 모든 현재 청취 등록이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="e559ad46dfb12176f9ab6a5068fbbc335264dacf" translate="yes" xml:space="preserve">
          <source>All currently available prepared transactions are listed in the &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt;&lt;code&gt;pg_prepared_xacts&lt;/code&gt;&lt;/a&gt; system view.</source>
          <target state="translated">현재 사용 가능한 모든 준비된 트랜잭션이 &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt; &lt;code&gt;pg_prepared_xacts&lt;/code&gt; &lt;/a&gt; 시스템보기에 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="2778b518fdc9b5356b12e2a79dd08d30844b8366" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;FROM&lt;/code&gt; list are computed. (Each element in the &lt;code&gt;FROM&lt;/code&gt; list is a real or virtual table.) If more than one element is specified in the &lt;code&gt;FROM&lt;/code&gt; list, they are cross-joined together. (See &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;&lt;code&gt;FROM&lt;/code&gt; Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 목록의 모든 요소 가 계산됩니다. ( &lt;code&gt;FROM&lt;/code&gt; 목록의 각 요소 는 실제 또는 가상 테이블입니다.) &lt;code&gt;FROM&lt;/code&gt; 목록 에 둘 이상의 요소가 지정된 경우 서로 결합됩니다. (아래의 &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt; &lt;code&gt;FROM&lt;/code&gt; 절&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="14481956ddccdbae880b961dfaa2429f752c35d7" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;FROM&lt;/code&gt; list are computed. (Each element in the &lt;code&gt;FROM&lt;/code&gt; list is a real or virtual table.) If more than one element is specified in the &lt;code&gt;FROM&lt;/code&gt; list, they are cross-joined together. (See &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;FROM Clause&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 목록의 모든 요소 가 계산됩니다. ( &lt;code&gt;FROM&lt;/code&gt; 목록의 각 요소 는 실제 또는 가상 테이블입니다.) &lt;code&gt;FROM&lt;/code&gt; 목록 에 둘 이상의 요소가 지정되어 있으면 서로 교차 결합됩니다. (아래의 &lt;a href=&quot;sql-select#SQL-FROM&quot;&gt;FROM 절을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="3978f2f6a0fc6fd4b0827f0ebd212e7bcc3552c2" translate="yes" xml:space="preserve">
          <source>All failure, rebuild, and reindex cases will be reported by pg_upgrade if they affect your installation; post-upgrade scripts to rebuild tables and indexes will be generated automatically. If you are trying to automate the upgrade of many clusters, you should find that clusters with identical database schemas require the same post-upgrade steps for all cluster upgrades; this is because the post-upgrade steps are based on the database schemas, and not user data.</source>
          <target state="translated">설치에 영향을주는 경우 모든 실패, 재 구축 및 재 인덱싱 사례가 pg_upgrade에 의해보고됩니다. 테이블 및 인덱스를 다시 빌드하기위한 업그레이드 후 스크립트가 자동으로 생성됩니다. 많은 클러스터의 업그레이드를 자동화하려는 경우 데이터베이스 스키마가 동일한 클러스터는 모든 클러스터 업그레이드에 대해 동일한 업그레이드 후 단계가 필요합니다. 업그레이드 후 단계는 사용자 데이터가 아닌 데이터베이스 스키마를 기반으로하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2887bc873471e44a6e402dab0ddec69892effbd0" translate="yes" xml:space="preserve">
          <source>All functions and operators used in an index definition must be &amp;ldquo;immutable&amp;rdquo;, that is, their results must depend only on their arguments and never on any outside influence (such as the contents of another table or the current time). This restriction ensures that the behavior of the index is well-defined. To use a user-defined function in an index expression or &lt;code&gt;WHERE&lt;/code&gt; clause, remember to mark the function immutable when you create it.</source>
          <target state="translated">인덱스 정의에 사용 된 모든 함수와 연산자는 &quot;불변&quot;이어야합니다. 즉, 결과는 인수에만 의존해야하며 외부 영향 (예 : 다른 테이블의 내용 또는 현재 시간)에 의존해서는 안됩니다. 이 제한은 인덱스의 동작이 잘 정의되도록합니다. 인덱스 표현식 또는 &lt;code&gt;WHERE&lt;/code&gt; 절 에서 사용자 정의 함수를 사용하려면 함수를 작성할 때 변경 불가능한 것으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="3ef17a42f49f1b90a3d376b9b52494437e996867" translate="yes" xml:space="preserve">
          <source>All indexes in PostgreSQL are &lt;em&gt;secondary&lt;/em&gt; indexes, meaning that each index is stored separately from the table's main data area (which is called the table's &lt;em&gt;heap&lt;/em&gt; in PostgreSQL terminology). This means that in an ordinary index scan, each row retrieval requires fetching data from both the index and the heap. Furthermore, while the index entries that match a given indexable &lt;code&gt;WHERE&lt;/code&gt; condition are usually close together in the index, the table rows they reference might be anywhere in the heap. The heap-access portion of an index scan thus involves a lot of random access into the heap, which can be slow, particularly on traditional rotating media. (As described in &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;Section 11.5&lt;/a&gt;, bitmap scans try to alleviate this cost by doing the heap accesses in sorted order, but that only goes so far.)</source>
          <target state="translated">PostgreSQL의 모든 인덱스는 &lt;em&gt;보조&lt;/em&gt; 인덱스이므로 각 인덱스는 테이블의 기본 데이터 영역 ( PostgreSQL 용어 에서는 테이블 &lt;em&gt;힙&lt;/em&gt; 이라고 함)과 별도로 저장됩니다 . 즉, 일반 인덱스 스캔에서 각 행 검색에는 인덱스와 힙 모두에서 데이터를 가져와야합니다. 또한 주어진 색인 작성 가능 &lt;code&gt;WHERE&lt;/code&gt; 조건 과 일치하는 색인 ​​항목 은 일반적으로 색인에서 서로 가깝지만 참조하는 테이블 행은 힙의 어느 곳에 나있을 수 있습니다. 따라서 인덱스 스캔의 힙 액세스 부분은 힙에 대한 많은 임의 액세스를 포함하며, 이는 특히 전통적인 회전 미디어에서 느릴 수 있습니다. ( &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;11.5 절에&lt;/a&gt; 설명 된대로비트 맵 스캔은 힙 액세스를 정렬 된 순서대로 수행하여이 비용을 완화하려고하지만 지금까지만 진행됩니다.)</target>
        </trans-unit>
        <trans-unit id="db79cd41caf099a5fc97eb22b9bdb081eeb2153e" translate="yes" xml:space="preserve">
          <source>All it takes to get a BRIN access method working is to implement a few user-defined methods, which define the behavior of summary values stored in the index and the way they interact with scan keys. In short, BRIN combines extensibility with generality, code reuse, and a clean interface.</source>
          <target state="translated">BRIN 액세스 방법을 작동시키기 위해서는 인덱스에 저장된 요약 값의 동작과 스캔 키와의 상호 작용 방식을 정의하는 몇 가지 사용자 정의 방법을 구현해야합니다. 간단히 말해 BRIN은 확장 성과 일반성, 코드 재사용 및 깔끔한 인터페이스를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="6e1a7f84a08ba9a0c97ee25a9736132689a50678" translate="yes" xml:space="preserve">
          <source>All it takes to get a GIN access method working is to implement a few user-defined methods, which define the behavior of keys in the tree and the relationships between keys, indexed items, and indexable queries. In short, GIN combines extensibility with generality, code reuse, and a clean interface.</source>
          <target state="translated">GIN 액세스 방법을 작동시키기 위해서는 트리에서 키의 동작과 키, 인덱싱 된 항목 및 인덱싱 가능한 쿼리 간의 관계를 정의하는 몇 가지 사용자 정의 방법을 구현해야합니다. 간단히 말해 GIN은 확장 성과 일반성, 코드 재사용 및 깔끔한 인터페이스를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="932e4d059724c2d4b8d21124cf86633cf4ac8541" translate="yes" xml:space="preserve">
          <source>All it takes to get a GiST access method up and running is to implement several user-defined methods, which define the behavior of keys in the tree. Of course these methods have to be pretty fancy to support fancy queries, but for all the standard queries (B-trees, R-trees, etc.) they're relatively straightforward. In short, GiST combines extensibility along with generality, code reuse, and a clean interface.</source>
          <target state="translated">GiST 액세스 방법을 시작하고 실행하는 데 필요한 것은 트리에서 키의 동작을 정의하는 몇 가지 사용자 정의 방법을 구현하는 것입니다. 물론 이러한 메소드는 멋진 쿼리를 지원하기에는 꽤 멋지지만 모든 표준 쿼리 (B- 트리, R- 트리 등)는 비교적 간단합니다. 간단히 말해, GiST는 확장 성과 일반성, 코드 재사용 및 깔끔한 인터페이스를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="f6f094a1f0d931ca3f860e1e2d7b887c4d3d20bd" translate="yes" xml:space="preserve">
          <source>All messages emitted by the PostgreSQL server are assigned five-character error codes that follow the SQL standard's conventions for &amp;ldquo;SQLSTATE&amp;rdquo; codes. Applications that need to know which error condition has occurred should usually test the error code, rather than looking at the textual error message. The error codes are less likely to change across PostgreSQL releases, and also are not subject to change due to localization of error messages. Note that some, but not all, of the error codes produced by PostgreSQL are defined by the SQL standard; some additional error codes for conditions not defined by the standard have been invented or borrowed from other databases.</source>
          <target state="translated">PostgreSQL 서버에서 생성 된 모든 메시지에는 &quot;SQLSTATE&quot;코드에 대한 SQL 표준 규칙을 따르는 5 자리 오류 코드가 할당됩니다. 어떤 오류 조건이 발생했는지 알아야하는 응용 프로그램은 일반적으로 텍스트 오류 메시지를 보지 않고 오류 코드를 테스트해야합니다. 오류 코드는 PostgreSQL 릴리스에서 변경 될 가능성이 적으며 오류 메시지의 현지화로 인해 변경되지 않을 수도 있습니다. PostgreSQL에 의해 생성 된 일부는 아니지만 일부 오류 코드는 SQL 표준에 의해 정의됩니다. 표준에 의해 정의되지 않은 조건에 대한 일부 추가 오류 코드는 다른 데이터베이스에서 발명되었거나 빌려 왔습니다.</target>
        </trans-unit>
        <trans-unit id="5f17dc4d29230530f8f45813d17f855f136a3816" translate="yes" xml:space="preserve">
          <source>All multixact IDs before this one have been replaced by a transaction ID in this table. This is used to track whether the table needs to be vacuumed in order to prevent multixact ID wraparound or to allow &lt;code&gt;pg_multixact&lt;/code&gt; to be shrunk. Zero (&lt;code&gt;InvalidMultiXactId&lt;/code&gt;) if the relation is not a table.</source>
          <target state="translated">이 전에 모든 멀티 플렉스 ID는이 테이블에서 트랜잭션 ID로 대체되었습니다. 멀티 플렉스 ID 랩 어라운드를 방지하거나 &lt;code&gt;pg_multixact&lt;/code&gt; 를 축소 하기 위해 테이블을 정리해야하는지 여부를 추적하는 데 사용됩니다 . 관계가 테이블이 아닌 경우 0 ( &lt;code&gt;InvalidMultiXactId&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="2dede7220bdd3e91dec2b9b6615dd35bb3933921" translate="yes" xml:space="preserve">
          <source>All multixact IDs before this one have been replaced with a transaction ID in this database. This is used to track whether the database needs to be vacuumed in order to prevent multixact ID wraparound or to allow &lt;code&gt;pg_multixact&lt;/code&gt; to be shrunk. It is the minimum of the per-table &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relminmxid&lt;/code&gt; values.</source>
          <target state="translated">이 ID 이전의 모든 멀티 플렉스 ID는이 데이터베이스에서 트랜잭션 ID로 대체되었습니다. 멀티 플렉스 ID 랩 어라운드를 방지하거나 &lt;code&gt;pg_multixact&lt;/code&gt; 를 축소 하기 위해 데이터베이스를 정리해야하는지 여부를 추적하는 데 사용됩니다 . 테이블 당 &lt;code&gt;pg_class&lt;/code&gt; 의 최소값입니다 . &lt;code&gt;relminmxid&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="b6a1ec7b62542588df77c091f76d37462abbe3bd" translate="yes" xml:space="preserve">
          <source>All of the OID alias types for objects grouped by namespace accept schema-qualified names, and will display schema-qualified names on output if the object would not be found in the current search path without being qualified. The &lt;code&gt;regproc&lt;/code&gt; and &lt;code&gt;regoper&lt;/code&gt; alias types will only accept input names that are unique (not overloaded), so they are of limited use; for most uses &lt;code&gt;regprocedure&lt;/code&gt; or &lt;code&gt;regoperator&lt;/code&gt; are more appropriate. For &lt;code&gt;regoperator&lt;/code&gt;, unary operators are identified by writing &lt;code&gt;NONE&lt;/code&gt; for the unused operand.</source>
          <target state="translated">네임 스페이스별로 그룹화 된 오브젝트의 모든 OID 별명 유형은 스키마 규정 된 이름을 승인하며, 오브젝트가 규정되지 않고 현재 검색 경로에서 찾을 수없는 경우 출력에 스키마 규정 된 이름을 표시합니다. &lt;code&gt;regproc&lt;/code&gt; 와 &lt;code&gt;regoper&lt;/code&gt; 별칭 유형은 그들 만이 사용이 제한되어 있으므로, (과부하되지 않음) 고유 입력 이름을 받아 들일 것입니다; 대부분의 경우 &lt;code&gt;regprocedure&lt;/code&gt; 또는 &lt;code&gt;regoperator&lt;/code&gt; 가 더 적합합니다. 들어 &lt;code&gt;regoperator&lt;/code&gt; , 단항 연산자는 작성하지에 의해 식별됩니다 &lt;code&gt;NONE&lt;/code&gt; 을 사용하지 않은 피연산자.</target>
        </trans-unit>
        <trans-unit id="37766175956ba6517dd475210dd4e291c6b94f05" translate="yes" xml:space="preserve">
          <source>All of the functions listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt; depend on the sort ordering specified by the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the associated window definition. Rows that are not distinct when considering only the &lt;code&gt;ORDER BY&lt;/code&gt; columns are said to be &lt;em&gt;peers&lt;/em&gt;. The four ranking functions (including &lt;code&gt;cume_dist&lt;/code&gt;) are defined so that they give the same answer for all peer rows.</source>
          <target state="translated">&lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;표 9.60&lt;/a&gt; 에 나열된 모든 함수 는 연관된 창 정의 의 &lt;code&gt;ORDER BY&lt;/code&gt; 절에 지정된 정렬 순서에 따라 다릅니다 . &lt;code&gt;ORDER BY&lt;/code&gt; 열만 고려할 때 고유하지 않은 행은 &lt;em&gt;피어&lt;/em&gt; 라고합니다 . 4 개의 순위 함수 ( &lt;code&gt;cume_dist&lt;/code&gt; 포함 )는 모든 피어 행에 대해 동일한 답변을 제공하도록 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6b3dc7a98e19d74a1c8b693082bcc2b7322b43f8" translate="yes" xml:space="preserve">
          <source>All of the functions listed in &lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;Table 9.60&lt;/a&gt; depend on the sort ordering specified by the &lt;code&gt;ORDER BY&lt;/code&gt; clause of the associated window definition. Rows that are not distinct when considering only the &lt;code&gt;ORDER BY&lt;/code&gt; columns are said to be &lt;em&gt;peers&lt;/em&gt;. The four ranking functions (including &lt;code&gt;cume_dist&lt;/code&gt;) are defined so that they give the same answer for all rows of a peer group.</source>
          <target state="translated">&lt;a href=&quot;functions-window#FUNCTIONS-WINDOW-TABLE&quot;&gt;표 9.60&lt;/a&gt; 에 나열된 모든 함수 는 연관된 창 정의 의 &lt;code&gt;ORDER BY&lt;/code&gt; 절에 지정된 정렬 순서에 따라 다릅니다 . &lt;code&gt;ORDER BY&lt;/code&gt; 열만 고려할 때 구별되지 않는 행을 &lt;em&gt;피어&lt;/em&gt; 라고합니다 . 4 개의 순위 함수 ( &lt;code&gt;cume_dist&lt;/code&gt; 포함 )가 정의되어 피어 그룹의 모든 행에 대해 동일한 답변을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="02fa4b0f473762a8721b052a178d80c186d067cd" translate="yes" xml:space="preserve">
          <source>All of the options except &lt;code&gt;convert-crlf&lt;/code&gt; apply only to encrypt functions. Decrypt functions get the parameters from the PGP data.</source>
          <target state="translated">&lt;code&gt;convert-crlf&lt;/code&gt; 를 제외한 모든 옵션 은 암호화 기능에만 적용됩니다. 암호 해독 기능은 PGP 데이터에서 매개 변수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="592ca33a4522df17e0e57a59e6344510c5d4a80c" translate="yes" xml:space="preserve">
          <source>All of the policies constructed thus far have been permissive policies, meaning that when multiple policies are applied they are combined using the &amp;ldquo;OR&amp;rdquo; Boolean operator. While permissive policies can be constructed to only allow access to rows in the intended cases, it can be simpler to combine permissive policies with restrictive policies (which the records must pass and which are combined using the &amp;ldquo;AND&amp;rdquo; Boolean operator). Building on the example above, we add a restrictive policy to require the administrator to be connected over a local Unix socket to access the records of the &lt;code&gt;passwd&lt;/code&gt; table:</source>
          <target state="translated">지금까지 구성된 모든 정책은 허용 가능한 정책으로, 여러 정책이 적용될 때 &quot;OR&quot;부울 연산자를 사용하여 결합됩니다. 허용되는 정책은 의도 된 경우에만 행에 대한 액세스 만 허용하도록 구성 할 수 있지만 허용 정책을 제한적인 정책 (레코드가 통과해야하고 &quot;AND&quot;부울 연산자를 사용하여 결합 된)과 결합하는 것이 더 간단 할 수 있습니다. 위의 예를 바탕으로 관리자가 로컬 Unix 소켓을 통해 &lt;code&gt;passwd&lt;/code&gt; 테이블 의 레코드에 액세스하도록 제한하는 정책을 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="068ae9ee084ab21fc5a8a7c0060d57cbf4e3473f" translate="yes" xml:space="preserve">
          <source>All of these &lt;code&gt;ORDER BY&lt;/code&gt; clauses specify the row's composite value, resulting in sorting the rows according to the rules described in &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;Section 9.23.6&lt;/a&gt;. However, if &lt;code&gt;inventory_item&lt;/code&gt; contained a column named &lt;code&gt;c&lt;/code&gt;, the first case would be different from the others, as it would mean to sort by that column only. Given the column names previously shown, these queries are also equivalent to those above:</source>
          <target state="translated">이 모든 &lt;code&gt;ORDER BY&lt;/code&gt; 절은 행의 복합 값을 지정하여 &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;9.23.6 절에&lt;/a&gt; 설명 된 규칙에 따라 행을 정렬합니다 . 그러나 &lt;code&gt;inventory_item&lt;/code&gt; 에 &lt;code&gt;c&lt;/code&gt; 라는 열이 포함 된 경우 첫 번째 경우는 해당 열만 기준으로 정렬되므로 다른 경우와 다릅니다. 이전에 표시된 열 이름이 주어지면 이러한 쿼리는 위의 쿼리와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c8391ba1355f7ba958065513e77b352946c8ee3d" translate="yes" xml:space="preserve">
          <source>All of these &lt;code&gt;ORDER BY&lt;/code&gt; clauses specify the row's composite value, resulting in sorting the rows according to the rules described in &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;Section 9.24.6&lt;/a&gt;. However, if &lt;code&gt;inventory_item&lt;/code&gt; contained a column named &lt;code&gt;c&lt;/code&gt;, the first case would be different from the others, as it would mean to sort by that column only. Given the column names previously shown, these queries are also equivalent to those above:</source>
          <target state="translated">이러한 모든 &lt;code&gt;ORDER BY&lt;/code&gt; 절은 행의 복합 값을 지정하여 &lt;a href=&quot;functions-comparisons#COMPOSITE-TYPE-COMPARISON&quot;&gt;섹션 9.24.6에&lt;/a&gt; 설명 된 규칙에 따라 행을 정렬합니다 . 그러나 &lt;code&gt;inventory_item&lt;/code&gt; 에 &lt;code&gt;c&lt;/code&gt; 라는 열이 포함 된 경우 해당 열만 기준으로 정렬한다는 의미이므로 첫 번째 경우는 다른 경우와 다릅니다. 이전에 표시된 열 이름이 주어지면 이러한 쿼리도 위의 쿼리와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="abf3c99355ffd14c50c6d5db9b1b5a423f1e1022" translate="yes" xml:space="preserve">
          <source>All of these fields are optional, except &lt;code&gt;commonName&lt;/code&gt;. It depends entirely on your CA's policy which of them would be included and which wouldn't. The meaning of these fields, however, is strictly defined by the X.500 and X.509 standards, so you cannot just assign arbitrary meaning to them.</source>
          <target state="translated">&lt;code&gt;commonName&lt;/code&gt; 을 제외한 이러한 모든 필드는 선택 사항 입니다. 이는 전적으로 포함되거나 포함되지 않는 CA 정책에 따라 다릅니다. 그러나이 필드의 의미는 X.500 및 X.509 표준에 의해 엄격하게 정의되므로 임의의 의미를 지정할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c6deee271f21fa5ab3c6f7bba891d40136e2c021" translate="yes" xml:space="preserve">
          <source>All of these operations will throw an error if a supplied array contains any NULL elements.</source>
          <target state="translated">제공된 배열에 NULL 요소가 포함되어 있으면 이러한 모든 작업에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d9b92f66d52bf42e15e05f0a8c5cb26f0298b448" translate="yes" xml:space="preserve">
          <source>All other parameters are described in detail under &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt;.</source>
          <target state="translated">다른 모든 매개 변수는 &lt;a href=&quot;sql-select&quot;&gt;SELECT&lt;/a&gt; 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4df9c2d50326edae48634d605dfaf0fbdb01416" translate="yes" xml:space="preserve">
          <source>All parameter names are case-insensitive. Every parameter takes a value of one of five types: boolean, string, integer, floating point, or enumerated (enum). The type determines the syntax for setting the parameter:</source>
          <target state="translated">모든 매개 변수 이름은 대소 문자를 구분하지 않습니다. 모든 매개 변수는 부울, 문자열, 정수, 부동 소수점 또는 열거 형 (열)의 다섯 가지 유형 중 하나의 값을 갖습니다. 유형에 따라 매개 변수 설정 구문이 결정됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
