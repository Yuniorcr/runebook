<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="95363da9cd107f5dcc6d6108200a75dee0fecc9d" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;client_id&lt;/code&gt; indicates which client session ran the transaction, &lt;code&gt;transaction_no&lt;/code&gt; counts how many transactions have been run by that session, &lt;code&gt;time&lt;/code&gt; is the total elapsed transaction time in microseconds, &lt;code&gt;script_no&lt;/code&gt; identifies which script file was used (useful when multiple scripts were specified with &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;-b&lt;/code&gt;), and &lt;code&gt;time_epoch&lt;/code&gt;/&lt;code&gt;time_us&lt;/code&gt; are a Unix-epoch time stamp and an offset in microseconds (suitable for creating an ISO 8601 time stamp with fractional seconds) showing when the transaction completed. The &lt;code&gt;schedule_lag&lt;/code&gt; field is the difference between the transaction's scheduled start time, and the time it actually started, in microseconds. It is only present when the &lt;code&gt;--rate&lt;/code&gt; option is used. When both &lt;code&gt;--rate&lt;/code&gt; and &lt;code&gt;--latency-limit&lt;/code&gt; are used, the &lt;code&gt;time&lt;/code&gt; for a skipped transaction will be reported as &lt;code&gt;skipped&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;client_id&lt;/code&gt; 는 트랜잭션을 실행 한 클라이언트 세션을 나타내고 transaction_no는 해당 세션에서 실행 된 &lt;code&gt;transaction_no&lt;/code&gt; 수를 계산하고, &lt;code&gt;time&lt;/code&gt; 은 총 경과 된 트랜잭션 시간 (마이크로 초)이며 &lt;code&gt;script_no&lt;/code&gt; 는 사용 된 스크립트 파일을 식별합니다 ( &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;-b&lt;/code&gt; ) 및 &lt;code&gt;time_epoch&lt;/code&gt; / &lt;code&gt;time_us&lt;/code&gt; 는 Unix-epoch 타임 스탬프이며 트랜잭션이 완료된 시점을 나타내는 마이크로 초 단위 오프셋 (분수 초로 ISO 8601 타임 스탬프를 만드는 데 적합)입니다. &lt;code&gt;schedule_lag&lt;/code&gt; 필드는 트랜잭션의 예약 된 시작 시간과 실제로 시작된 시간의 차이 (마이크로 초)입니다. &lt;code&gt;--rate&lt;/code&gt; 옵션을 사용 하는 경우에만 존재합니다 . 두 경우 &lt;code&gt;--rate&lt;/code&gt; 및 &lt;code&gt;--latency-limit&lt;/code&gt; 사용의 &lt;code&gt;time&lt;/code&gt; 스킵 거래는 다음과 같이보고됩니다 &lt;code&gt;skipped&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15575bf8bc20a17322a91c6a004375b23fe3bede" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;collation&lt;/code&gt; is a possibly schema-qualified identifier. The &lt;code&gt;COLLATE&lt;/code&gt; clause binds tighter than operators; parentheses can be used when necessary.</source>
          <target state="translated">여기서 &lt;code&gt;collation&lt;/code&gt; 은 스키마로 한정된 식별자 일 수 있습니다. &lt;code&gt;COLLATE&lt;/code&gt; 절은 사업자보다 더 엄격한 결합; 필요한 경우 괄호를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd38ffefd9af14e03f114a3c898a1682942460e2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;condition&lt;/code&gt; is any expression that evaluates to a result of type &lt;code&gt;boolean&lt;/code&gt;. Any row that does not satisfy this condition will be eliminated from the output. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references.</source>
          <target state="translated">여기서 &lt;code&gt;condition&lt;/code&gt; 은 &lt;code&gt;boolean&lt;/code&gt; 유형의 결과로 평가되는 표현식입니다 . 이 조건을 만족하지 않는 행은 출력에서 ​​제거됩니다. 실제 행 값이 변수 참조로 대체 될 때 true를 리턴하면 행이 조건을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="883e212f0298979617ff0fdf44518bd05a084205" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;condition&lt;/code&gt; is any expression that evaluates to a result of type &lt;code&gt;boolean&lt;/code&gt;. Any row that does not satisfy this condition will not be inserted to the table. A row satisfies the condition if it returns true when the actual row values are substituted for any variable references.</source>
          <target state="translated">여기서 &lt;code&gt;condition&lt;/code&gt; 은 &lt;code&gt;boolean&lt;/code&gt; 유형의 결과로 평가되는 표현식입니다 . 이 조건을 만족하지 않는 행은 테이블에 삽입되지 않습니다. 실제 행 값이 변수 참조로 대체 될 때 true를 리턴하면 행이 조건을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="50d757545c644d09173ed3fc8ac85d6de14f6f0b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;condition&lt;/code&gt; is the same as specified for the &lt;code&gt;WHERE&lt;/code&gt; clause.</source>
          <target state="translated">여기서 &lt;code&gt;condition&lt;/code&gt; 은 &lt;code&gt;WHERE&lt;/code&gt; 절에 지정된 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0e39ffa4c4736dc3798858fa334aa10d101b9ea1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;config_name&lt;/code&gt; is a column in the &lt;code&gt;pgweb&lt;/code&gt; table. This allows mixed configurations in the same index while recording which configuration was used for each index entry. This would be useful, for example, if the document collection contained documents in different languages. Again, queries that are meant to use the index must be phrased to match, e.g., &lt;code&gt;WHERE to_tsvector(config_name, body) @@ 'a &amp;amp; b'&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;config_name&lt;/code&gt; 은 &lt;code&gt;pgweb&lt;/code&gt; 테이블 의 열입니다 . 따라서 각 인덱스 항목에 사용 된 구성을 기록하면서 동일한 인덱스에서 혼합 된 구성을 사용할 수 있습니다. 예를 들어 문서 모음에 다른 언어로 된 문서가 포함 된 경우에 유용합니다. 다시, 인덱스를 사용하기위한 쿼리는 일치해야합니다 &lt;code&gt;WHERE to_tsvector(config_name, body) @@ 'a &amp;amp; b'&lt;/code&gt; 예 : WHERE to_tsvector (config_name, body) @@ 'a &amp;amp; b') .</target>
        </trans-unit>
        <trans-unit id="0e33c809b5aed59b29d15e3755cf042bcd7cf972" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;dbname&lt;/code&gt; is the name of the already-created database to test in. (You may also need &lt;code&gt;-h&lt;/code&gt;, &lt;code&gt;-p&lt;/code&gt;, and/or &lt;code&gt;-U&lt;/code&gt; options to specify how to connect to the database server.)</source>
          <target state="translated">여기서 &lt;code&gt;dbname&lt;/code&gt; 은 테스트하기 위해 이미 작성된 데이터베이스의 이름입니다. 데이터베이스 서버에 연결하는 방법을 지정 하려면 &lt;code&gt;-h&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; 및 / 또는 &lt;code&gt;-U&lt;/code&gt; 옵션이 필요할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2efafe66fc0fb01790e7b075da02f4b34a5191f4" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;delim&lt;/code&gt; is the delimiter character for the type, as recorded in its &lt;code&gt;pg_type&lt;/code&gt; entry. Among the standard data types provided in the PostgreSQL distribution, all use a comma (&lt;code&gt;,&lt;/code&gt;), except for type &lt;code&gt;box&lt;/code&gt; which uses a semicolon (&lt;code&gt;;&lt;/code&gt;). Each &lt;code&gt;val&lt;/code&gt; is either a constant of the array element type, or a subarray. An example of an array constant is:</source>
          <target state="translated">여기서 &lt;code&gt;delim&lt;/code&gt; 은 &lt;code&gt;pg_type&lt;/code&gt; 항목에 기록 된 유형의 구분 문자입니다 . PostgreSQL 배포에서 제공되는 표준 데이터 유형 중에서 세미콜론 ( &lt;code&gt;;&lt;/code&gt; ) 을 사용하는 유형 &lt;code&gt;box&lt;/code&gt; 를 제외하고 모두 쉼표 ( &lt;code&gt;,&lt;/code&gt; ) 를 사용합니다 . 각 &lt;code&gt;val&lt;/code&gt; 은 배열 요소 유형의 상수이거나 하위 배열입니다. 배열 상수의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc0c370cc6c4db09350c38f91dbc0ead530523ea" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;digits&lt;/code&gt; is one or more decimal digits (0 through 9). At least one digit must be before or after the decimal point, if one is used. At least one digit must follow the exponent marker (&lt;code&gt;e&lt;/code&gt;), if one is present. There cannot be any spaces or other characters embedded in the constant. Note that any leading plus or minus sign is not actually considered part of the constant; it is an operator applied to the constant.</source>
          <target state="translated">여기서 &lt;code&gt;digits&lt;/code&gt; 은 하나 이상의 10 진수 (0-9)입니다. 소수점을 사용하는 경우 하나 이상의 숫자가 소수점 앞뒤에 있어야합니다. 지수 마커 ( &lt;code&gt;e&lt;/code&gt; )가있는 경우 하나 이상의 숫자가 지수 마커 ( e )를 따라야합니다 . 상수에는 공백이나 다른 문자가 포함될 수 없습니다. 선행 더하기 또는 빼기 기호는 실제로 상수의 일부로 간주되지 않습니다. 상수에 적용되는 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="bfd7fccfedd66d19eee35d6037183fff7ab24667" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;documents&lt;/code&gt; is a table that has a text field &lt;code&gt;bodytext&lt;/code&gt; that we wish to search. The reason for using the &lt;code&gt;simple&lt;/code&gt; configuration with the &lt;code&gt;to_tsvector&lt;/code&gt; function, instead of using a language-specific configuration, is that we want a list of the original (unstemmed) words.</source>
          <target state="translated">여기서 &lt;code&gt;documents&lt;/code&gt; 텍스트 필드가있는 테이블입니다 &lt;code&gt;bodytext&lt;/code&gt; 우리가 검색하고자하는 것으로합니다. 언어 별 구성을 사용하는 대신 &lt;code&gt;to_tsvector&lt;/code&gt; 함수 와 함께 &lt;code&gt;simple&lt;/code&gt; 구성 을 사용하는 이유 는 원래 (비 스테 롬) 단어 목록을 원하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9a039bb227f52a1b9a93d81d62221c9b30047689" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;dumpfile&lt;/code&gt; is the file output by the pg_dump command. The database &lt;code&gt;dbname&lt;/code&gt; will not be created by this command, so you must create it yourself from &lt;code&gt;template0&lt;/code&gt; before executing psql (e.g., with &lt;code&gt;createdb -T template0 dbname&lt;/code&gt;). psql supports options similar to pg_dump for specifying the database server to connect to and the user name to use. See the &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; reference page for more information. Non-text file dumps are restored using the &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; utility.</source>
          <target state="translated">여기서 &lt;code&gt;dumpfile&lt;/code&gt; 은 pg_dump 명령으로 출력 된 파일입니다. 데이터베이스 &lt;code&gt;dbname&lt;/code&gt; 은이 명령으로 작성되지 않으므로 psql을 실행하기 전에 &lt;code&gt;template0&lt;/code&gt; 에서 직접 작성해야합니다 (예 : &lt;code&gt;createdb -T template0 dbname&lt;/code&gt; 사용 ). psql은 연결할 데이터베이스 서버 및 사용할 사용자 이름을 지정하기 위해 pg_dump와 유사한 옵션을 지원합니다. 자세한 내용은 &lt;a href=&quot;app-psql&quot;&gt;psql&lt;/a&gt; 참조 페이지를 참조하십시오. 비 텍스트 파일 덤프는 &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; 유틸리티를 사용하여 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e33127f2af6130f52a3e81c11a87546a1d4d1276" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;frame_start&lt;/code&gt; and &lt;code&gt;frame_end&lt;/code&gt; can be one of</source>
          <target state="translated">여기서 &lt;code&gt;frame_start&lt;/code&gt; 및 &lt;code&gt;frame_end&lt;/code&gt; 는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f4a0bb9f112237b3006e826384b66b73f19342f" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;interval_start&lt;/code&gt; is the start of the interval (as a Unix epoch time stamp), &lt;code&gt;num_transactions&lt;/code&gt; is the number of transactions within the interval, &lt;code&gt;sum_latency&lt;/code&gt; is the sum of the transaction latencies within the interval, &lt;code&gt;sum_latency_2&lt;/code&gt; is the sum of squares of the transaction latencies within the interval, &lt;code&gt;min_latency&lt;/code&gt; is the minimum latency within the interval, and &lt;code&gt;max_latency&lt;/code&gt; is the maximum latency within the interval. The next fields, &lt;code&gt;sum_lag&lt;/code&gt;, &lt;code&gt;sum_lag_2&lt;/code&gt;, &lt;code&gt;min_lag&lt;/code&gt;, and &lt;code&gt;max_lag&lt;/code&gt;, are only present if the &lt;code&gt;--rate&lt;/code&gt; option is used. They provide statistics about the time each transaction had to wait for the previous one to finish, i.e. the difference between each transaction's scheduled start time and the time it actually started. The very last field, &lt;code&gt;skipped&lt;/code&gt;, is only present if the &lt;code&gt;--latency-limit&lt;/code&gt; option is used, too. It counts the number of transactions skipped because they would have started too late. Each transaction is counted in the interval when it was committed.</source>
          <target state="translated">여기서 &lt;code&gt;interval_start&lt;/code&gt; 는 간격 의 시작 (UNIX epoch 시간 소인), &lt;code&gt;num_transactions&lt;/code&gt; 는 간격 내의 트랜잭션 수, &lt;code&gt;sum_latency&lt;/code&gt; 는 간격 내의 트랜잭션 지연 시간 의 합 , &lt;code&gt;sum_latency_2&lt;/code&gt; 는 트랜잭션 지연 시간의 제곱의 합입니다. 간격, &lt;code&gt;min_latency&lt;/code&gt; 는 간격 내 최소 대기 시간이고 &lt;code&gt;max_latency&lt;/code&gt; 는 간격 내 최대 대기 시간입니다. 다음 필드 인 &lt;code&gt;sum_lag&lt;/code&gt; , &lt;code&gt;sum_lag_2&lt;/code&gt; , &lt;code&gt;min_lag&lt;/code&gt; 및 &lt;code&gt;max_lag&lt;/code&gt; 는 &lt;code&gt;--rate&lt;/code&gt; 옵션이 사용됩니다. 각 트랜잭션이 이전 트랜잭션이 완료되기를 기다려야하는 시간, 즉 각 트랜잭션의 예약 된 시작 시간과 실제로 시작된 시간의 차이에 대한 통계를 제공합니다. 마지막 필드 인 &lt;code&gt;skipped&lt;/code&gt; 는 &lt;code&gt;--latency-limit&lt;/code&gt; 옵션을 사용 하는 경우에만 나타납니다 . 너무 늦게 시작되어 건너 뛴 트랜잭션 수를 계산합니다. 각 트랜잭션은 커밋 된 간격으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="21a535125ba922f6008364af8c73fa378c746f74" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;interval_start&lt;/code&gt; is the start of the interval (as a Unix epoch time stamp), &lt;code&gt;num_transactions&lt;/code&gt; is the number of transactions within the interval, &lt;code&gt;sum_latency&lt;/code&gt; is the sum of the transaction latencies within the interval, &lt;code&gt;sum_latency_2&lt;/code&gt; is the sum of squares of the transaction latencies within the interval, &lt;code&gt;min_latency&lt;/code&gt; is the minimum latency within the interval, and &lt;code&gt;max_latency&lt;/code&gt; is the maximum latency within the interval. The next fields, &lt;code&gt;sum_lag&lt;/code&gt;, &lt;code&gt;sum_lag_2&lt;/code&gt;, &lt;code&gt;min_lag&lt;/code&gt;, and &lt;code&gt;max_lag&lt;/code&gt;, are only present if the &lt;code&gt;--rate&lt;/code&gt; option is used. They provide statistics about the time each transaction had to wait for the previous one to finish, i.e., the difference between each transaction's scheduled start time and the time it actually started. The very last field, &lt;code&gt;skipped&lt;/code&gt;, is only present if the &lt;code&gt;--latency-limit&lt;/code&gt; option is used, too. It counts the number of transactions skipped because they would have started too late. Each transaction is counted in the interval when it was committed.</source>
          <target state="translated">where &lt;code&gt;interval_start&lt;/code&gt; is the start of the interval (as a Unix epoch time stamp), &lt;code&gt;num_transactions&lt;/code&gt; is the number of transactions within the interval, &lt;code&gt;sum_latency&lt;/code&gt; is the sum of the transaction latencies within the interval, &lt;code&gt;sum_latency_2&lt;/code&gt; is the sum of squares of the transaction latencies within the interval, &lt;code&gt;min_latency&lt;/code&gt; is the minimum latency within the interval, and &lt;code&gt;max_latency&lt;/code&gt; is the maximum latency within the interval. The next fields, &lt;code&gt;sum_lag&lt;/code&gt; , &lt;code&gt;sum_lag_2&lt;/code&gt; , &lt;code&gt;min_lag&lt;/code&gt; , and &lt;code&gt;max_lag&lt;/code&gt; , are only present if the &lt;code&gt;--rate&lt;/code&gt; option is used. They provide statistics about the time each transaction had to wait for the previous one to finish, i.e., the difference between each transaction's scheduled start time and the time it actually started. The very last field, &lt;code&gt;skipped&lt;/code&gt; , is only present if the &lt;code&gt;--latency-limit&lt;/code&gt; option is used, too. It counts the number of transactions skipped because they would have started too late. Each transaction is counted in the interval when it was committed.</target>
        </trans-unit>
        <trans-unit id="02521c4b560914d5a494676dd3a10eaddf5a2d27" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;label&lt;/code&gt; is any string you want to use to uniquely identify this backup operation. &lt;code&gt;pg_start_backup&lt;/code&gt; creates a &lt;em&gt;backup label&lt;/em&gt; file, called &lt;code&gt;backup_label&lt;/code&gt;, in the cluster directory with information about your backup, including the start time and label string. The function also creates a &lt;em&gt;tablespace map&lt;/em&gt; file, called &lt;code&gt;tablespace_map&lt;/code&gt;, in the cluster directory with information about tablespace symbolic links in &lt;code&gt;pg_tblspc/&lt;/code&gt; if one or more such link is present. Both files are critical to the integrity of the backup, should you need to restore from it.</source>
          <target state="translated">여기서 &lt;code&gt;label&lt;/code&gt; 은이 백업 작업을 고유하게 식별하는 데 사용하려는 문자열입니다. &lt;code&gt;pg_start_backup&lt;/code&gt; 는 생성 &lt;em&gt;백업 레이블&lt;/em&gt; 라는 파일 &lt;code&gt;backup_label&lt;/code&gt; 시작 시간과 레이블 문자열을 포함하여 백업에 대한 정보와 클러스터 디렉토리를. 이 함수는 또한 하나 이상의 이러한 링크가 존재하는 경우 &lt;code&gt;pg_tblspc/&lt;/code&gt; 테이블 스페이스 기호 링크에 대한 정보와 함께 클러스터 디렉토리에 &lt;code&gt;tablespace_map&lt;/code&gt; 이라는 테이블 &lt;em&gt;스페이스 맵&lt;/em&gt; 파일을 작성합니다 . 두 파일 모두 백업 무결성을 위해 중요합니다. 백업에서 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="2632c6a394b4c5afed578e3db6104be70d7c969c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;label&lt;/code&gt; is any string you want to use to uniquely identify this backup operation. The connection calling &lt;code&gt;pg_start_backup&lt;/code&gt; must be maintained until the end of the backup, or the backup will be automatically aborted.</source>
          <target state="translated">여기서 &lt;code&gt;label&lt;/code&gt; 은이 백업 작업을 고유하게 식별하는 데 사용하려는 문자열입니다. &lt;code&gt;pg_start_backup&lt;/code&gt; 을 호출하는 연결 은 백업이 끝날 때까지 유지되어야합니다. 그렇지 않으면 백업이 자동으로 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="14ec95115d9949716f5574166b53e4a99c82ef40" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;lock_strength&lt;/code&gt; can be one of</source>
          <target state="translated">여기서 &lt;code&gt;lock_strength&lt;/code&gt; 는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc24930f3c49a2f1c610c96b58a313a1bb2f6567" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;name&lt;/code&gt; follows the usual rules for SQL identifiers. The current role automatically becomes the owner of the new database. It is the privilege of the owner of a database to remove it later (which also removes all the objects in it, even if they have a different owner).</source>
          <target state="translated">여기서 &lt;code&gt;name&lt;/code&gt; 은 일반적인 SQL 식별자 규칙을 따릅니다. 현재 역할은 자동으로 새 데이터베이스의 소유자가됩니다. 나중에 데이터베이스를 제거하는 것은 데이터베이스 소유자의 특권입니다 (이는 소유자가 다른 경우에도 데이터베이스의 모든 오브젝트를 제거합니다).</target>
        </trans-unit>
        <trans-unit id="2e04d3386ac5dbafbf688329834c2f0edf9b1b29" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;num_sync&lt;/code&gt; is the number of synchronous standbys that transactions need to wait for replies from, and &lt;code&gt;standby_name&lt;/code&gt; is the name of a standby server. &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;ANY&lt;/code&gt; specify the method to choose synchronous standbys from the listed servers.</source>
          <target state="translated">여기서 &lt;code&gt;num_sync&lt;/code&gt; 는 트랜잭션이 응답을 대기해야하는 동기 대기의 수이고 &lt;code&gt;standby_name&lt;/code&gt; 은 대기 서버의 이름입니다. &lt;code&gt;FIRST&lt;/code&gt; 및 &lt;code&gt;ANY&lt;/code&gt; 는 나열된 서버에서 동기 대기를 선택하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="051ce8638a4cb0df58ccc78d0226c857003f3754" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;old_cluster&lt;/code&gt; and &lt;code&gt;new_cluster&lt;/code&gt; are relative to the current directory on the primary, and &lt;code&gt;remote_dir&lt;/code&gt; is &lt;em&gt;above&lt;/em&gt; the old and new cluster directories on the standby. The directory structure under the specified directories on the primary and standbys must match. Consult the rsync manual page for details on specifying the remote directory, e.g.</source>
          <target state="translated">어디 &lt;code&gt;old_cluster&lt;/code&gt; 및 &lt;code&gt;new_cluster&lt;/code&gt; 는 차의 현재 디렉토리를 기준으로하며, &lt;code&gt;remote_dir&lt;/code&gt; 것입니다 &lt;em&gt;위의&lt;/em&gt; 대기에 이전 및 새 클러스터 디렉토리. 기본 및 대기에서 지정된 디렉토리 아래의 디렉토리 구조가 일치해야합니다. 원격 디렉토리 지정에 대한 자세한 내용은 rsync 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7b5550c4042ab7be1b02d82ee60cb4e972c7064" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;old_cluster&lt;/code&gt; and &lt;code&gt;new_cluster&lt;/code&gt; are relative to the current directory on the primary, and &lt;code&gt;remote_dir&lt;/code&gt; is &lt;em&gt;above&lt;/em&gt; the old and new cluster directories on the standby. The directory structure under the specified directories on the primary and standbys must match. Consult the rsync manual page for details on specifying the remote directory, e.g.,</source>
          <target state="translated">where &lt;code&gt;old_cluster&lt;/code&gt; and &lt;code&gt;new_cluster&lt;/code&gt; are relative to the current directory on the primary, and &lt;code&gt;remote_dir&lt;/code&gt; is &lt;em&gt;above&lt;/em&gt; the old and new cluster directories on the standby. The directory structure under the specified directories on the primary and standbys must match. Consult the rsync manual page for details on specifying the remote directory, e.g.,</target>
        </trans-unit>
        <trans-unit id="6995f4e58e8fe029424bd429b077f2eb8c3fe1f6" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;p&lt;/code&gt; is an optional precision specification giving the number of fractional digits in the seconds field. Precision can be specified for &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;timestamp&lt;/code&gt;, and &lt;code&gt;interval&lt;/code&gt; types, and can range from 0 to 6. If no precision is specified in a constant specification, it defaults to the precision of the literal value (but not more than 6 digits).</source>
          <target state="translated">여기서 &lt;code&gt;p&lt;/code&gt; 는 초 필드의 소수 자릿수를 제공하는 선택적 정밀도 사양입니다. 정밀도는 &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;timestamp&lt;/code&gt; 및 &lt;code&gt;interval&lt;/code&gt; 유형에 대해 지정할 수 있으며 범위는 0-6입니다. 상수 스펙에 정밀도가 지정되지 않은 경우 리터럴 값의 정밀도 (기본값은 6 자리 이하)입니다.</target>
        </trans-unit>
        <trans-unit id="3ae43e1773ab7435ea942bef4aab35ea977ed17e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;quantity&lt;/code&gt; is a number (possibly signed); &lt;code&gt;unit&lt;/code&gt; is &lt;code&gt;microsecond&lt;/code&gt;, &lt;code&gt;millisecond&lt;/code&gt;, &lt;code&gt;second&lt;/code&gt;, &lt;code&gt;minute&lt;/code&gt;, &lt;code&gt;hour&lt;/code&gt;, &lt;code&gt;day&lt;/code&gt;, &lt;code&gt;week&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;decade&lt;/code&gt;, &lt;code&gt;century&lt;/code&gt;, &lt;code&gt;millennium&lt;/code&gt;, or abbreviations or plurals of these units; &lt;code&gt;direction&lt;/code&gt; can be &lt;code&gt;ago&lt;/code&gt; or empty. The at sign (&lt;code&gt;@&lt;/code&gt;) is optional noise. The amounts of the different units are implicitly added with appropriate sign accounting. &lt;code&gt;ago&lt;/code&gt; negates all the fields. This syntax is also used for interval output, if &lt;a href=&quot;runtime-config-client#GUC-INTERVALSTYLE&quot;&gt;IntervalStyle&lt;/a&gt; is set to &lt;code&gt;postgres_verbose&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;quantity&lt;/code&gt; 은 숫자입니다 (아마 서명). &lt;code&gt;unit&lt;/code&gt; 는 &lt;code&gt;microsecond&lt;/code&gt; , &lt;code&gt;millisecond&lt;/code&gt; , &lt;code&gt;second&lt;/code&gt; , &lt;code&gt;minute&lt;/code&gt; , &lt;code&gt;hour&lt;/code&gt; , &lt;code&gt;day&lt;/code&gt; , &lt;code&gt;week&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; , &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;decade&lt;/code&gt; , &lt;code&gt;century&lt;/code&gt; , &lt;code&gt;millennium&lt;/code&gt; 또는 이들 단위의 약어 또는 복수이고; &lt;code&gt;direction&lt;/code&gt; 은 &lt;code&gt;ago&lt;/code&gt; 또는 비어 있을 수 있습니다 . at 기호 ( &lt;code&gt;@&lt;/code&gt; )는 선택적인 노이즈입니다. 서로 다른 단위의 금액은 적절한 부호 계산으로 암시 적으로 추가됩니다. &lt;code&gt;ago&lt;/code&gt; 모든 필드를 무효화합니다. &lt;a href=&quot;runtime-config-client#GUC-INTERVALSTYLE&quot;&gt;IntervalStyle&lt;/a&gt; 이 &lt;code&gt;postgres_verbose&lt;/code&gt; 로 설정된 경우이 구문은 간격 출력에도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb85a9d1ba20986c4eabc4c0cc672867a0082382" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;salt&lt;/code&gt;, &lt;code&gt;StoredKey&lt;/code&gt; and &lt;code&gt;ServerKey&lt;/code&gt; are in Base64 encoded format. This format is the same as that specified by RFC 5803.</source>
          <target state="translated">여기서 &lt;code&gt;salt&lt;/code&gt; , &lt;code&gt;StoredKey&lt;/code&gt; 및 &lt;code&gt;ServerKey&lt;/code&gt; 는 Base64로 인코딩 된 형식입니다. 이 형식은 RFC 5803에서 지정한 형식과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="902cd914b55268a7f42373967de3300fb2a6df74" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;search_condition&lt;/code&gt; is any value expression (see &lt;a href=&quot;sql-expressions&quot;&gt;Section 4.2&lt;/a&gt;) that returns a value of type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;search_condition&lt;/code&gt; 은 &lt;code&gt;boolean&lt;/code&gt; 유형의 값을 반환하는 값 식 ( &lt;a href=&quot;sql-expressions&quot;&gt;4.2&lt;/a&gt; 참조 )입니다 .</target>
        </trans-unit>
        <trans-unit id="9cab206ed9f849b266fa8bbb5c105eda41d171c2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;window_definition&lt;/code&gt; has the syntax</source>
          <target state="translated">여기서 &lt;code&gt;window_definition&lt;/code&gt; 에는 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ffcb73100c9208f3d73e7359a7710f21793aea4" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;window_name&lt;/code&gt; is a name that can be referenced from &lt;code&gt;OVER&lt;/code&gt; clauses or subsequent window definitions, and &lt;code&gt;window_definition&lt;/code&gt; is</source>
          <target state="translated">여기서 &lt;code&gt;window_name&lt;/code&gt; 은 &lt;code&gt;OVER&lt;/code&gt; 절 또는 후속 창 정의 에서 참조 할 수있는 이름 이며 &lt;code&gt;window_definition&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="05865f2594ddc7befb862529cd119701ff24e8ac" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are the respective coordinates, as floating-point numbers.</source>
          <target state="translated">여기서 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 부동 소수점 숫자로 각 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="63a67aa07860e75ed55512e599efa11799c590cd" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;x&lt;/code&gt; is a single character with no other significance, matches that character</source>
          <target state="translated">여기서 &lt;code&gt;x&lt;/code&gt; 는 다른 의미가없는 단일 문자이며 해당 문자와 ​​일치합니다.</target>
        </trans-unit>
        <trans-unit id="2cfc72d3af1bb50704e8aee07809af6321faa971" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;xsi&lt;/code&gt; is the XML namespace prefix for XML Schema Instance. An appropriate namespace declaration will be added to the result value. If false, columns containing null values are simply omitted from the output.</source>
          <target state="translated">여기서 &lt;code&gt;xsi&lt;/code&gt; 는 XML 스키마 인스턴스의 XML 네임 스페이스 접두사입니다. 적절한 네임 스페이스 선언이 결과 값에 추가됩니다. false이면 널값을 포함하는 열이 출력에서 ​​생략됩니다.</target>
        </trans-unit>
        <trans-unit id="cbd4a92c9b71cd49ffa17bbdcc8f19ea4f09000a" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;nextval()&lt;/code&gt; function supplies successive values from a &lt;em&gt;sequence object&lt;/em&gt; (see &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.16&lt;/a&gt;). This arrangement is sufficiently common that there's a special shorthand for it:</source>
          <target state="translated">여기서 &lt;code&gt;nextval()&lt;/code&gt; 함수는 &lt;em&gt;시퀀스 객체&lt;/em&gt; 에서 연속적인 값을 제공 &lt;em&gt;합니다&lt;/em&gt; ( &lt;a href=&quot;functions-sequence&quot;&gt;9.16 절&lt;/a&gt; 참조 ). 이 배열은 특별한 약어가 있다는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="7bd08f9310fcb14cbd5436b568512ce2df9ab484" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;nextval()&lt;/code&gt; function supplies successive values from a &lt;em&gt;sequence object&lt;/em&gt; (see &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt;). This arrangement is sufficiently common that there's a special shorthand for it:</source>
          <target state="translated">where the &lt;code&gt;nextval()&lt;/code&gt; function supplies successive values from a &lt;em&gt;sequence object&lt;/em&gt; (see &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt;). This arrangement is sufficiently common that there's a special shorthand for it:</target>
        </trans-unit>
        <trans-unit id="9f13f6d0c9013e1b5a9453aad6e84166421dc49f" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;operator&lt;/code&gt; token follows the syntax rules of &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-OPERATORS&quot;&gt;Section 4.1.3&lt;/a&gt;, or is one of the key words &lt;code&gt;AND&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt;, and &lt;code&gt;NOT&lt;/code&gt;, or is a qualified operator name in the form:</source>
          <target state="translated">여기서 &lt;code&gt;operator&lt;/code&gt; 토큰은 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-OPERATORS&quot;&gt;섹션 4.1.3&lt;/a&gt; 의 구문 규칙을 따르 거나 키워드 &lt;code&gt;AND&lt;/code&gt; , &lt;code&gt;OR&lt;/code&gt; 및 &lt;code&gt;NOT&lt;/code&gt; 중 하나 이거나 형식이 한정된 연산자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8a017c95f90d3833011c4cbc0c74fcbcfe44ef42" translate="yes" xml:space="preserve">
          <source>where the archive directory is physically located on the standby server, so that the &lt;code&gt;archive_command&lt;/code&gt; is accessing it across NFS, but the files are local to the standby. This will:</source>
          <target state="translated">여기서 &lt;code&gt;archive_command&lt;/code&gt; 는 NFS를 통해 디렉토리에 액세스하지만 파일은 대기에 로컬입니다. 이것은 :</target>
        </trans-unit>
        <trans-unit id="a6b4be2958f0bb91c3ed3c4e4583c088a4832f4d" translate="yes" xml:space="preserve">
          <source>where the colon (&lt;code&gt;:&lt;/code&gt;) symbol acts as a delimiter between a phrase and its replacement.</source>
          <target state="translated">여기서, 콜론 ( &lt;code&gt;:&lt;/code&gt; ) 심볼은 구문 및 여분 간의 분리로서 작용한다.</target>
        </trans-unit>
        <trans-unit id="e11e7f071949ee7312e3026921c20a83a618fe45" translate="yes" xml:space="preserve">
          <source>where the comment begins with &lt;code&gt;/*&lt;/code&gt; and extends to the matching occurrence of &lt;code&gt;*/&lt;/code&gt;. These block comments nest, as specified in the SQL standard but unlike C, so that one can comment out larger blocks of code that might contain existing block comments.</source>
          <target state="translated">여기서 주석은 &lt;code&gt;/*&lt;/code&gt; 로 시작 하고 일치하는 &lt;code&gt;*/&lt;/code&gt; 로 확장됩니다 . 이러한 블록 주석은 SQL 표준에 지정되어 있지만 C와 달리 중첩되므로 기존 블록 주석을 포함 할 수있는 더 큰 코드 블록을 주석 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="8e7c67b39887933602dcee06120320113183300a" translate="yes" xml:space="preserve">
          <source>where the component fields are:</source>
          <target state="translated">구성 요소 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a5be562692973652e8751f219be291ae87f74a1" translate="yes" xml:space="preserve">
          <source>where the file name for the source file must be available on the machine running the backend process, not the client, since the backend process reads the file directly. You can read more about the &lt;code&gt;COPY&lt;/code&gt; command in &lt;a href=&quot;sql-copy&quot;&gt;COPY&lt;/a&gt;.</source>
          <target state="translated">백엔드 프로세스가 파일을 직접 읽으므로 소스 파일의 파일 이름은 클라이언트가 아닌 백엔드 프로세스를 실행하는 시스템에서 사용 가능해야합니다. 당신은에 대해 자세히 읽을 수있는 &lt;code&gt;COPY&lt;/code&gt; 의 명령 &lt;a href=&quot;sql-copy&quot;&gt;COPY를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aca0a6010ee58659cb962578b12187acb232c0bd" translate="yes" xml:space="preserve">
          <source>where the format of a table mapping depends on the &lt;em&gt;&lt;code&gt;tableforest&lt;/code&gt;&lt;/em&gt; parameter as explained above.</source>
          <target state="translated">여기서 테이블 매핑 형식은 위에서 설명한 &lt;em&gt; &lt;code&gt;tableforest&lt;/code&gt; &lt;/em&gt; 매개 변수 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="c322d4fb81e0c24a81de070751209570b9a21fe2" translate="yes" xml:space="preserve">
          <source>where the points are the end points of the line segments comprising the boundary of the polygon.</source>
          <target state="translated">여기서 점은 다각형의 경계를 포함하는 선분의 ​​끝점입니다.</target>
        </trans-unit>
        <trans-unit id="f3a39e39e3dc55cc38a327aeb589b6bbda39e7f5" translate="yes" xml:space="preserve">
          <source>where the points are the end points of the line segments comprising the path. Square brackets (&lt;code&gt;[]&lt;/code&gt;) indicate an open path, while parentheses (&lt;code&gt;()&lt;/code&gt;) indicate a closed path. When the outermost parentheses are omitted, as in the third through fifth syntaxes, a closed path is assumed.</source>
          <target state="translated">여기서 포인트는 경로를 포함하는 선분의 ​​끝 포인트입니다. 대괄호 ( &lt;code&gt;[]&lt;/code&gt; )는 열린 경로를 나타내고 괄호 ( &lt;code&gt;()&lt;/code&gt; )는 닫힌 경로를 나타냅니다. 세 번째에서 다섯 번째 구문과 같이 가장 바깥 쪽 괄호를 생략하면 닫힌 경로가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="8b49a312334fd1bdab104f06f0ce7761910dd239" translate="yes" xml:space="preserve">
          <source>where the recursive self-reference must appear on the right-hand side of the &lt;code&gt;UNION&lt;/code&gt;. Only one recursive self-reference is permitted per query. Recursive data-modifying statements are not supported, but you can use the results of a recursive &lt;code&gt;SELECT&lt;/code&gt; query in a data-modifying statement. See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; for an example.</source>
          <target state="translated">여기서 재귀 자기 참조는 &lt;code&gt;UNION&lt;/code&gt; 의 오른쪽에 나타나야합니다 . 쿼리 당 하나의 재귀 자체 참조 만 허용됩니다. 재귀 데이터 수정 문은 지원되지 않지만 데이터 수정 문에서 재귀 &lt;code&gt;SELECT&lt;/code&gt; 쿼리 결과를 사용할 수 있습니다 . 예제는 &lt;a href=&quot;queries-with&quot;&gt;섹션 7.8&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dab6fc9fba9dce67d798f2e3e758f073548c0c8" translate="yes" xml:space="preserve">
          <source>where the schema mapping is as above.</source>
          <target state="translated">여기서 스키마 매핑은 위와 같습니다.</target>
        </trans-unit>
        <trans-unit id="382029671c1699461f42fe369fd317b19afaa4b7" translate="yes" xml:space="preserve">
          <source>where the vacuum base threshold is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt;, the vacuum scale factor is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt;, and the number of tuples is &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltuples&lt;/code&gt;.</source>
          <target state="translated">where the vacuum base threshold is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt;, the vacuum scale factor is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt;, and the number of tuples is &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;reltuples&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e9fff4ccdc17ba4f1e6aa42fae36f876c94b66d" translate="yes" xml:space="preserve">
          <source>where the vacuum base threshold is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt;, the vacuum scale factor is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt;, and the number of tuples is &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reltuples&lt;/code&gt;. The number of obsolete tuples is obtained from the statistics collector; it is a semi-accurate count updated by each &lt;code&gt;UPDATE&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; operation. (It is only semi-accurate because some information might be lost under heavy load.) If the &lt;code&gt;relfrozenxid&lt;/code&gt; value of the table is more than &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; transactions old, an aggressive vacuum is performed to freeze old tuples and advance &lt;code&gt;relfrozenxid&lt;/code&gt;; otherwise, only pages that have been modified since the last vacuum are scanned.</source>
          <target state="translated">여기서 진공베이스 임계 값은 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-THRESHOLD&quot;&gt;autovacuum_vacuum_threshold&lt;/a&gt; 이고, 진공 스케일 계수는 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_scale_factor&lt;/a&gt; 이며 튜플 수는 &lt;code&gt;pg_class&lt;/code&gt; 입니다. &lt;code&gt;reltuples&lt;/code&gt; . 사용되지 않는 튜플의 수는 통계 수집기에서 가져옵니다. 각 &lt;code&gt;UPDATE&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 조작으로 갱신 된 반 정확한 계수 입니다. (로드 가 많은 경우 일부 정보가 손실 될 수 있기 때문에 반 정확성입니다.) 테이블 의 &lt;code&gt;relfrozenxid&lt;/code&gt; 값이 &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; 트랜잭션 보다 오래되면 오래된 튜플을 동결하고 &lt;code&gt;relfrozenxid&lt;/code&gt; 를 진행시키기 위해 적극적인 진공이 수행됩니다.; 그렇지 않으면 마지막 진공 처리 이후 수정 된 페이지 만 스캔됩니다.</target>
        </trans-unit>
        <trans-unit id="2c431885a457348236e447edee84410e42626acc" translate="yes" xml:space="preserve">
          <source>where the vacuum insert base threshold is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-THRESHOLD&quot;&gt;autovacuum_vacuum_insert_threshold&lt;/a&gt;, and vacuum insert scale factor is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_insert_scale_factor&lt;/a&gt;. Such vacuums may allow portions of the table to be marked as &lt;em&gt;all visible&lt;/em&gt; and also allow tuples to be frozen, which can reduce the work required in subsequent vacuums. For tables which receive &lt;code&gt;INSERT&lt;/code&gt; operations but no or almost no &lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt; operations, it may be beneficial to lower the table's &lt;a href=&quot;sql-createtable#RELOPTION-AUTOVACUUM-FREEZE-MIN-AGE&quot;&gt;autovacuum_freeze_min_age&lt;/a&gt; as this may allow tuples to be frozen by earlier vacuums. The number of obsolete tuples and the number of inserted tuples are obtained from the statistics collector; it is a semi-accurate count updated by each &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;INSERT&lt;/code&gt; operation. (It is only semi-accurate because some information might be lost under heavy load.) If the &lt;code&gt;relfrozenxid&lt;/code&gt; value of the table is more than &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; transactions old, an aggressive vacuum is performed to freeze old tuples and advance &lt;code&gt;relfrozenxid&lt;/code&gt;; otherwise, only pages that have been modified since the last vacuum are scanned.</source>
          <target state="translated">where the vacuum insert base threshold is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-THRESHOLD&quot;&gt;autovacuum_vacuum_insert_threshold&lt;/a&gt;, and vacuum insert scale factor is &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-VACUUM-INSERT-SCALE-FACTOR&quot;&gt;autovacuum_vacuum_insert_scale_factor&lt;/a&gt;. Such vacuums may allow portions of the table to be marked as &lt;em&gt;all visible&lt;/em&gt; and also allow tuples to be frozen, which can reduce the work required in subsequent vacuums. For tables which receive &lt;code&gt;INSERT&lt;/code&gt; operations but no or almost no &lt;code&gt;UPDATE&lt;/code&gt; / &lt;code&gt;DELETE&lt;/code&gt; operations, it may be beneficial to lower the table's &lt;a href=&quot;sql-createtable#RELOPTION-AUTOVACUUM-FREEZE-MIN-AGE&quot;&gt;autovacuum_freeze_min_age&lt;/a&gt; as this may allow tuples to be frozen by earlier vacuums. The number of obsolete tuples and the number of inserted tuples are obtained from the statistics collector; it is a semi-accurate count updated by each &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;INSERT&lt;/code&gt; operation. (It is only semi-accurate because some information might be lost under heavy load.) If the &lt;code&gt;relfrozenxid&lt;/code&gt; value of the table is more than &lt;code&gt;vacuum_freeze_table_age&lt;/code&gt; transactions old, an aggressive vacuum is performed to freeze old tuples and advance &lt;code&gt;relfrozenxid&lt;/code&gt; ; otherwise, only pages that have been modified since the last vacuum are scanned.</target>
        </trans-unit>
        <trans-unit id="4e9d5d3d104047e0064d4303bd59ec16810bf890" translate="yes" xml:space="preserve">
          <source>where your own login name is mentioned. This will happen if the administrator has not created a PostgreSQL user account for you. (PostgreSQL user accounts are distinct from operating system user accounts.) If you are the administrator, see &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt; for help creating accounts. You will need to become the operating system user under which PostgreSQL was installed (usually &lt;code&gt;postgres&lt;/code&gt;) to create the first user account. It could also be that you were assigned a PostgreSQL user name that is different from your operating system user name; in that case you need to use the &lt;code&gt;-U&lt;/code&gt; switch or set the &lt;code&gt;PGUSER&lt;/code&gt; environment variable to specify your PostgreSQL user name.</source>
          <target state="translated">자신의 로그인 이름이 언급 된 곳. 관리자가 PostgreSQL 사용자 계정을 생성하지 않은 경우에 발생합니다. PostgreSQL 사용자 계정은 운영 체제 사용자 계정과 다릅니다. 관리자 인 경우 계정 생성에 대한 도움말은 &lt;a href=&quot;https://www.postgresql.org/docs/12/user-manag.html&quot;&gt;21 장을&lt;/a&gt; 참조하십시오 . 첫 번째 사용자 계정을 만들려면 PostgreSQL을 설치 한 운영 체제 사용자 (일반적으로 &lt;code&gt;postgres&lt;/code&gt; )가되어야합니다. 운영 체제 사용자 이름과 다른 PostgreSQL 사용자 이름이 할당되었을 수도 있습니다. 이 경우 &lt;code&gt;-U&lt;/code&gt; 스위치 를 사용 하거나 &lt;code&gt;PGUSER&lt;/code&gt; 환경 변수를 설정하여 PostgreSQL 사용자 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0112d5560695a821c035d2d69c40472d94f7f8cb" translate="yes" xml:space="preserve">
          <source>where your own login name is mentioned. This will happen if the administrator has not created a PostgreSQL user account for you. (PostgreSQL user accounts are distinct from operating system user accounts.) If you are the administrator, see &lt;a href=&quot;https://www.postgresql.org/docs/13/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt; for help creating accounts. You will need to become the operating system user under which PostgreSQL was installed (usually &lt;code&gt;postgres&lt;/code&gt;) to create the first user account. It could also be that you were assigned a PostgreSQL user name that is different from your operating system user name; in that case you need to use the &lt;code&gt;-U&lt;/code&gt; switch or set the &lt;code&gt;PGUSER&lt;/code&gt; environment variable to specify your PostgreSQL user name.</source>
          <target state="translated">where your own login name is mentioned. This will happen if the administrator has not created a PostgreSQL user account for you. (PostgreSQL user accounts are distinct from operating system user accounts.) If you are the administrator, see &lt;a href=&quot;https://www.postgresql.org/docs/13/user-manag.html&quot;&gt;Chapter 21&lt;/a&gt; for help creating accounts. You will need to become the operating system user under which PostgreSQL was installed (usually &lt;code&gt;postgres&lt;/code&gt; ) to create the first user account. It could also be that you were assigned a PostgreSQL user name that is different from your operating system user name; in that case you need to use the &lt;code&gt;-U&lt;/code&gt; switch or set the &lt;code&gt;PGUSER&lt;/code&gt; environment variable to specify your PostgreSQL user name.</target>
        </trans-unit>
        <trans-unit id="8f1cf5f67d7b1357c152874d6df8382f05565c46" translate="yes" xml:space="preserve">
          <source>which displays per-product sales totals in only the top sales regions. The &lt;code&gt;WITH&lt;/code&gt; clause defines two auxiliary statements named &lt;code&gt;regional_sales&lt;/code&gt; and &lt;code&gt;top_regions&lt;/code&gt;, where the output of &lt;code&gt;regional_sales&lt;/code&gt; is used in &lt;code&gt;top_regions&lt;/code&gt; and the output of &lt;code&gt;top_regions&lt;/code&gt; is used in the primary &lt;code&gt;SELECT&lt;/code&gt; query. This example could have been written without &lt;code&gt;WITH&lt;/code&gt;, but we'd have needed two levels of nested sub-&lt;code&gt;SELECT&lt;/code&gt;s. It's a bit easier to follow this way.</source>
          <target state="translated">상위 판매 지역에서만 총 제품 판매량을 표시합니다. &lt;code&gt;WITH&lt;/code&gt; 의 절은 두 개의 보조 문이라는 정의 &lt;code&gt;regional_sales&lt;/code&gt; 및 &lt;code&gt;top_regions&lt;/code&gt; 의 출력, &lt;code&gt;regional_sales&lt;/code&gt; 이 사용된다 &lt;code&gt;top_regions&lt;/code&gt; 와의 출력 &lt;code&gt;top_regions&lt;/code&gt; 이 차에 사용되는 &lt;code&gt;SELECT&lt;/code&gt; 쿼리를. 이 예제는 &lt;code&gt;WITH&lt;/code&gt; 없이 작성 될 수 있었지만 두 가지 수준의 중첩 된 하위 &lt;code&gt;SELECT&lt;/code&gt; 가 필요했습니다 . 이 방법을 따르는 것이 조금 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="bae8a1a20973cccefd7c610839e91bd3974b4005" translate="yes" xml:space="preserve">
          <source>which finds the ten places closest to a given target point. The ability to do this is again dependent on the particular operator class being used. In &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;Table 64.1&lt;/a&gt;, operators that can be used in this way are listed in the column &amp;ldquo;Ordering Operators&amp;rdquo;.</source>
          <target state="translated">주어진 목표 지점에 가장 가까운 열 곳을 찾습니다. 이를 수행하는 기능은 사용중인 특정 연산자 클래스에 따라 다시 달라집니다. 에서 &lt;a href=&quot;gist-builtin-opclasses#GIST-BUILTIN-OPCLASSES-TABLE&quot;&gt;표 64.1&lt;/a&gt; , 이런 식으로 사용할 수있는 연산자는 열 &quot;주문 운영자&quot;에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dfde0f1cc2ebaaf170e42acdfe9b417e65a8fd3" translate="yes" xml:space="preserve">
          <source>which gives us one output row per city. Each aggregate result is computed over the table rows matching that city. We can filter these grouped rows using &lt;code&gt;HAVING&lt;/code&gt;:</source>
          <target state="translated">도시 당 하나의 출력 행을 제공합니다. 각 집계 결과는 해당 도시와 일치하는 테이블 행에 대해 계산됩니다. &lt;code&gt;HAVING&lt;/code&gt; 을 사용하여 그룹화 된 행을 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18b9fcfc65791db8244d0ec78c95baca6172d630" translate="yes" xml:space="preserve">
          <source>which gives us the same results for only the cities that have all &lt;code&gt;temp_lo&lt;/code&gt; values below 40. Finally, if we only care about cities whose names begin with &amp;ldquo;&lt;code&gt;S&lt;/code&gt;&amp;rdquo;, we might do:</source>
          <target state="translated">이는 모든 &lt;code&gt;temp_lo&lt;/code&gt; 값이 40 미만인 도시에 대해서만 동일한 결과를 제공 합니다. 마지막으로 이름이 &quot; &lt;code&gt;S&lt;/code&gt; &quot;로 시작하는 도시 만 신경 쓰면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="689a2e02b1a49db16b3b1be754391d4fc8da64e0" translate="yes" xml:space="preserve">
          <source>which is executed as:</source>
          <target state="translated">이것은 다음과 같이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f15875e884530dd30ab6d27db56535aa74c98f64" translate="yes" xml:space="preserve">
          <source>which obtains the 50th percentile, or median, value of the &lt;code&gt;income&lt;/code&gt; column from table &lt;code&gt;households&lt;/code&gt;. Here, &lt;code&gt;0.5&lt;/code&gt; is a direct argument; it would make no sense for the percentile fraction to be a value varying across rows.</source>
          <target state="translated">이는 테이블 &lt;code&gt;households&lt;/code&gt; 에서 &lt;code&gt;income&lt;/code&gt; 열의 50 번째 백분위 수 또는 중앙값을 얻습니다 . 여기서 &lt;code&gt;0.5&lt;/code&gt; 는 직접적인 논증입니다. 백분위 수 비율이 행마다 다른 값이되는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6ee8c6433c23fa17a7f1946c5c1b26470b55b09" translate="yes" xml:space="preserve">
          <source>which refers to a function with zero arguments, whereas the first variant can refer to a function with any number of arguments, including zero, as long as the name is unique.</source>
          <target state="translated">첫 번째 변형은 이름이 고유 한 한 0을 포함하여 여러 개의 인수가있는 함수를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e899e70b75b90b65729658ed54cd0ca39432992" translate="yes" xml:space="preserve">
          <source>which returns:</source>
          <target state="translated">다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="74cad75d5e4f20aa31f501f8fefdc21abad67352" translate="yes" xml:space="preserve">
          <source>which shows that the planner thinks that sorting &lt;code&gt;onek&lt;/code&gt; by index-scanning is about 12% more expensive than sequential-scan-and-sort. Of course, the next question is whether it's right about that. We can investigate that using &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt;, as discussed below.</source>
          <target state="translated">이는 플래너가 인덱스 스캔으로 &lt;code&gt;onek&lt;/code&gt; 를 정렬 하는 것이 순차 스캔 및 정렬보다 약 12 ​​% 더 비싸다고 생각한다는 것을 보여줍니다 . 물론 다음 질문은 그것이 옳은지 여부입니다. 아래에서 설명하는 것처럼 &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 사용을 조사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c0656a99c8833cfc345dd27d0b6820caa432991" translate="yes" xml:space="preserve">
          <source>which we wish to display like</source>
          <target state="translated">우리가 보여주고 싶은</target>
        </trans-unit>
        <trans-unit id="c282db8639e1ae34ff018f3c72116a8c43100b68" translate="yes" xml:space="preserve">
          <source>which will copy archivable WAL segments to the directory &lt;code&gt;/mnt/server/archivedir&lt;/code&gt;. (This is an example, not a recommendation, and might not work on all platforms.) After the &lt;code&gt;%p&lt;/code&gt; and &lt;code&gt;%f&lt;/code&gt; parameters have been replaced, the actual command executed might look like this:</source>
          <target state="translated">아카이브 가능한 WAL 세그먼트를 &lt;code&gt;/mnt/server/archivedir&lt;/code&gt; 디렉토리에 복사 합니다 . (이것은 권장 사항이 아니며 예제이며 모든 플랫폼에서 작동하지 않을 수 있습니다.) &lt;code&gt;%p&lt;/code&gt; 및 &lt;code&gt;%f&lt;/code&gt; 매개 변수가 교체 된 후 실행 된 실제 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a169e40949af2620c4e85dda15d79975492e73f" translate="yes" xml:space="preserve">
          <source>which will copy previously archived WAL segments from the directory &lt;code&gt;/mnt/server/archivedir&lt;/code&gt;. Of course, you can use something much more complicated, perhaps even a shell script that requests the operator to mount an appropriate tape.</source>
          <target state="translated">이전에 아카이브 된 WAL 세그먼트를 &lt;code&gt;/mnt/server/archivedir&lt;/code&gt; 디렉토리에서 복사 합니다 . 물론 훨씬 더 복잡한 것을 사용할 수 있습니다. 아마도 운영자에게 적절한 테이프를 마운트하도록 요청하는 쉘 스크립트 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="26cd6a2051ea99afa4a27d84b6ed47beb5036a7c" translate="yes" xml:space="preserve">
          <source>which will leave the server running in the foreground. This must be done while logged into the PostgreSQL user account. Without &lt;code&gt;-D&lt;/code&gt;, the server will try to use the data directory named by the environment variable &lt;code&gt;PGDATA&lt;/code&gt;. If that variable is not provided either, it will fail.</source>
          <target state="translated">그러면 서버가 포 그라운드에서 실행됩니다. PostgreSQL 사용자 계정에 로그인 한 상태에서 수행해야합니다. &lt;code&gt;-D&lt;/code&gt; 가 없으면 서버는 환경 변수 &lt;code&gt;PGDATA&lt;/code&gt; 로 명명 된 데이터 디렉토리를 사용하려고합니다 . 해당 변수가 제공되지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c4e8f14819326dd3aae3a2cf53d737470310c24e" translate="yes" xml:space="preserve">
          <source>which will match the stemmed form of &lt;code&gt;postgraduate&lt;/code&gt;.</source>
          <target state="translated">이것은 줄기 형태의 &lt;code&gt;postgraduate&lt;/code&gt; 과 일치 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5ff082187c1d02a1fdad2296ffb917870a45b03c" translate="yes" xml:space="preserve">
          <source>which would allow a box value's component numbers to be accessed by subscripting. Otherwise the type behaves the same as before.</source>
          <target state="translated">첨자에 의해 상자 값의 구성 요소 번호에 액세스 할 수 있습니다. 그렇지 않으면 유형이 이전과 동일하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="df5d2347727e9e14fc56d97420272403e963b0b6" translate="yes" xml:space="preserve">
          <source>which would be a valid value of the &lt;code&gt;inventory_item&lt;/code&gt; type defined above. To make a field be NULL, write no characters at all in its position in the list. For example, this constant specifies a NULL third field:</source>
          <target state="translated">이는 위에서 정의한 &lt;code&gt;inventory_item&lt;/code&gt; 유형 의 유효한 값입니다 . 필드를 NULL로 만들려면 목록에서 해당 위치에 문자를 전혀 쓰지 마십시오. 예를 들어,이 상수는 NULL 세 번째 필드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9a3be0245636efccdc3c57134520df09a0e4a0a4" translate="yes" xml:space="preserve">
          <source>white space and comments cannot appear within multi-character symbols, such as &lt;code&gt;(?:&lt;/code&gt;</source>
          <target state="translated">공백과 주석은 &lt;code&gt;(?:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b43caaeffd6a470ec3896dc284dda83445964f79" translate="yes" xml:space="preserve">
          <source>white space or &lt;code&gt;#&lt;/code&gt; within a bracket expression is retained</source>
          <target state="translated">공백 또는 &lt;code&gt;#&lt;/code&gt; 괄호 표현식 내의 # 는 유지됩니다</target>
        </trans-unit>
        <trans-unit id="52b07ed610fcda069d74b3a411d9e935637def49" translate="yes" xml:space="preserve">
          <source>will be allowed if the cast from type &lt;code&gt;integer&lt;/code&gt; to type &lt;code&gt;text&lt;/code&gt; is marked &lt;code&gt;AS ASSIGNMENT&lt;/code&gt;, otherwise not. (We generally use the term &lt;em&gt;assignment cast&lt;/em&gt; to describe this kind of cast.)</source>
          <target state="translated">유형 &lt;code&gt;integer&lt;/code&gt; 에서 유형 &lt;code&gt;text&lt;/code&gt; 캐스트 가 &lt;code&gt;AS ASSIGNMENT&lt;/code&gt; 로 표시 되면 허용됩니다 . 일반적으로 이러한 유형의 캐스트를 설명하기 위해 &lt;em&gt;할당 캐스트&lt;/em&gt; 라는 용어를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e7b329bd0ae166b219c0dac7856440cebddc7bef" translate="yes" xml:space="preserve">
          <source>will be parsed as:</source>
          <target state="translated">다음과 같이 파싱됩니다.</target>
        </trans-unit>
        <trans-unit id="fcc5b8ad0d43009e11ed531b9ba723b81a61922b" translate="yes" xml:space="preserve">
          <source>will draw an error even though the &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;POSIX&lt;/code&gt; collations have identical behaviors. Mixing stripped and non-stripped collation names is therefore not recommended.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;POSIX&lt;/code&gt; 데이터 정렬의 동작이 동일 하더라도 오류가 발생 합니다. 따라서 잘린 조합 이름과 비 스트립 조합 이름은 혼합하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8ea301593a0a7ff485b37c9d6c155df86be3bfc8" translate="yes" xml:space="preserve">
          <source>will lock only rows having &lt;code&gt;col1 = 5&lt;/code&gt;, even though that condition is not textually within the sub-query.</source>
          <target state="translated">해당 조건이 텍스트로 하위 쿼리 내에 있지 않더라도 &lt;code&gt;col1 = 5&lt;/code&gt; 인 행만 잠급니다 .</target>
        </trans-unit>
        <trans-unit id="b9075f9f3f87909783fee359888bd2c471dea042" translate="yes" xml:space="preserve">
          <source>will only process the master table.</source>
          <target state="translated">마스터 테이블 만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="166a3172a29e9b1013bd7227d7fa350d195805cd" translate="yes" xml:space="preserve">
          <source>will remove the domain part for users with system user names that end with &lt;code&gt;@mydomain.com&lt;/code&gt;, and allow any user whose system name ends with &lt;code&gt;@otherdomain.com&lt;/code&gt; to log in as &lt;code&gt;guest&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@mydomain.com&lt;/code&gt; 끝나는 시스템 사용자 이름을 가진 사용자의 도메인 부분을 제거하고 &lt;code&gt;@otherdomain.com&lt;/code&gt; 으로 끝나는 시스템 이름을 가진 모든 사용자가 &lt;code&gt;guest&lt;/code&gt; 로 로그인 할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="e42965869a7de1a0b4c9e3864a5bad5ded3e3510" translate="yes" xml:space="preserve">
          <source>will require effort proportional to the size of the table: PostgreSQL will need to scan either the entire table or the entirety of an index that includes all rows in the table.</source>
          <target state="translated">will require effort proportional to the size of the table: PostgreSQL will need to scan either the entire table or the entirety of an index that includes all rows in the table.</target>
        </trans-unit>
        <trans-unit id="733025f436e0af6dc9df77a7ba625859cbbf72ca" translate="yes" xml:space="preserve">
          <source>will require effort proportional to the size of the table: PostgreSQL will need to scan either the entire table or the entirety of an index which includes all rows in the table.</source>
          <target state="translated">테이블 크기에 비례하는 노력이 필요합니다. PostgreSQL은 전체 테이블 또는 테이블의 모든 행을 포함하는 인덱스 전체를 스캔해야합니다.</target>
        </trans-unit>
        <trans-unit id="91e07485ce9849ddc161bb7d803839b8f2cfb477" translate="yes" xml:space="preserve">
          <source>will result in the three SQL commands being individually sent to the server, with each one's results being displayed before continuing to the next command. However, a semicolon entered as &lt;code&gt;\;&lt;/code&gt; will not trigger command processing, so that the command before it and the one after are effectively combined and sent to the server in one request. So for example</source>
          <target state="translated">세 개의 SQL 명령이 개별적으로 서버로 전송되고 다음 명령을 계속하기 전에 각 명령의 결과가 표시됩니다. 그러나 세미콜론은 &lt;code&gt;\;&lt;/code&gt; 입력되었습니다 . 명령 처리를 트리거하지 않으므로 명령 전과 명령이 효과적으로 결합되어 한 번의 요청으로 서버로 전송됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="047ba62edd680e2d56a13904abdabc4188cb005b" translate="yes" xml:space="preserve">
          <source>will return a table of two columns and three rows. It's effectively equivalent to:</source>
          <target state="translated">두 개의 열과 세 개의 행으로 구성된 테이블을 반환합니다. 효과적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cf8c1d7fdc60299e5a5cb3f3300a0c91cf43fb7" translate="yes" xml:space="preserve">
          <source>will start the server in the background and put the output into the named log file. The &lt;code&gt;-D&lt;/code&gt; option has the same meaning here as for &lt;code&gt;postgres&lt;/code&gt;. &lt;code&gt;pg_ctl&lt;/code&gt; is also capable of stopping the server.</source>
          <target state="translated">백그라운드에서 서버를 시작하고 출력을 명명 된 로그 파일에 넣습니다. &lt;code&gt;-D&lt;/code&gt; 옵션은 여기에서와 같은 의미를 &lt;code&gt;postgres&lt;/code&gt; . &lt;code&gt;pg_ctl&lt;/code&gt; 은 서버를 중지시킬 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7130bc171fc84062054c81f8bc4460528312537b" translate="yes" xml:space="preserve">
          <source>with hot standby</source>
          <target state="translated">핫 스탠바이</target>
        </trans-unit>
        <trans-unit id="af6d8270bf9a28cb0890365af8ad9fbaf343522d" translate="yes" xml:space="preserve">
          <source>with sync off</source>
          <target state="translated">동기화 해제</target>
        </trans-unit>
        <trans-unit id="3a3cc3c4fb4b36db89f9594987cae52aab437928" translate="yes" xml:space="preserve">
          <source>with sync on</source>
          <target state="translated">동기화를 켠 상태</target>
        </trans-unit>
        <trans-unit id="9370d4f218264e82510fdcf2db2c6328e076bb0c" translate="yes" xml:space="preserve">
          <source>with the default &lt;code&gt;BLCKSZ&lt;/code&gt; of 8192 bytes</source>
          <target state="translated">기본 &lt;code&gt;BLCKSZ&lt;/code&gt; 가 8192 바이트 인</target>
        </trans-unit>
        <trans-unit id="1fcb8a613e6e45488de8c47b5f45118a3ee76969" translate="yes" xml:space="preserve">
          <source>without any precision or scale creates a column in which numeric values of any precision and scale can be stored, up to the implementation limit on precision. A column of this kind will not coerce input values to any particular scale, whereas &lt;code&gt;numeric&lt;/code&gt; columns with a declared scale will coerce input values to that scale. (The SQL standard requires a default scale of 0, i.e., coercion to integer precision. We find this a bit useless. If you're concerned about portability, always specify the precision and scale explicitly.)</source>
          <target state="translated">정밀도 또는 스케일이 없으면 정밀도에 대한 구현 한계까지 모든 정밀도 및 스케일의 숫자 값을 저장할 수있는 열을 작성합니다. 이러한 종류의 열은 입력 값을 특정 스케일로 강제 변환하지 않지만 선언 된 스케일을 가진 &lt;code&gt;numeric&lt;/code&gt; 열은 입력 값을 해당 스케일로 강제 변환합니다. (SQL 표준은 기본 스케일 0, 즉 정수 정밀도에 대한 강제를 요구합니다. 우리는 이것을 조금 쓸모가 없다는 것을 알게되었습니다. 이식성에 대해 염려 할 경우 항상 정밀도와 스케일을 명시 적으로 지정하십시오.)</target>
        </trans-unit>
        <trans-unit id="db48d21b6765af674c2d86f7d7085037c147d319" translate="yes" xml:space="preserve">
          <source>would fail to preserve the &lt;code&gt;FOR UPDATE&lt;/code&gt; lock after the &lt;code&gt;ROLLBACK TO&lt;/code&gt;. This has been fixed in release 9.3.</source>
          <target state="translated">&lt;code&gt;ROLLBACK TO&lt;/code&gt; 후 &lt;code&gt;FOR UPDATE&lt;/code&gt; 잠금 을 유지하지 못했습니다 . 이것은 릴리스 9.3에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="d993c428e713634961b14ab1031f2202eb8ab483" translate="yes" xml:space="preserve">
          <source>would query the table &lt;code&gt;my_table&lt;/code&gt;. Note that this may be unsafe: the value of the variable is copied literally, so it can contain unbalanced quotes, or even backslash commands. You must make sure that it makes sense where you put it.</source>
          <target state="translated">&lt;code&gt;my_table&lt;/code&gt; 테이블을 쿼리합니다 . 이것은 안전하지 않을 수 있습니다. 변수의 값은 문자 그대로 복사되므로 불균형 따옴표 나 백 슬래시 명령을 포함 할 수 있습니다. 어디에 두 었는지 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="4fb1884d01fa0af9488b72c839058eb9b1cd3ec9" translate="yes" xml:space="preserve">
          <source>www.openwall.com</source>
          <target state="translated">www.openwall.com</target>
        </trans-unit>
        <trans-unit id="ee60015c8f586443db97ad8f39f2b79227b8fd01" translate="yes" xml:space="preserve">
          <source>xact</source>
          <target state="translated">xact</target>
        </trans-unit>
        <trans-unit id="30e2ca63aa35fbb6880b2c6d43d8e5e3aa97095e" translate="yes" xml:space="preserve">
          <source>xml2</source>
          <target state="translated">xml2</target>
        </trans-unit>
        <trans-unit id="f94d7d22277dd8bae275a25a490b99203cccb3b3" translate="yes" xml:space="preserve">
          <source>y-intercept of the least-squares-fit linear equation determined by the (&lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;) pairs</source>
          <target state="translated">( &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;Y&lt;/code&gt; ) 쌍으로 결정된 최소 제곱 법 선형 방정식의 y 절편</target>
        </trans-unit>
        <trans-unit id="150f912c47bfa78eaad7a19807fcef6747d4b800" translate="yes" xml:space="preserve">
          <source>year (4 or more digits)</source>
          <target state="translated">연도 (4 자리 이상)</target>
        </trans-unit>
        <trans-unit id="611de26b771af738f57fb9b6c8721bb546f69f99" translate="yes" xml:space="preserve">
          <source>year (4 or more digits) with comma</source>
          <target state="translated">쉼표가있는 연도 (4 자리 이상)</target>
        </trans-unit>
        <trans-unit id="127cd8c2aa50e43e37fcd0ad357fa69ed4e6f270" translate="yes" xml:space="preserve">
          <source>year 99 BC</source>
          <target state="translated">99 년 BC</target>
        </trans-unit>
        <trans-unit id="d468eeeab09a5f89dd95cca8a1d68fbf5b52784a" translate="yes" xml:space="preserve">
          <source>year and day of year</source>
          <target state="translated">년과 일</target>
        </trans-unit>
        <trans-unit id="fb360f9c09ac8c5edb2f18be5de4e80ea4c430d0" translate="yes" xml:space="preserve">
          <source>yes</source>
          <target state="translated">yes</target>
        </trans-unit>
        <trans-unit id="b7caf4dc1da846acd815fdde550fbd1677a60c12" translate="yes" xml:space="preserve">
          <source>yes (Note 1)</source>
          <target state="translated">예 (주 1)</target>
        </trans-unit>
        <trans-unit id="a6e931eb3e1e969efa57eb9a58fd4f25fd4cb2e1" translate="yes" xml:space="preserve">
          <source>you will find that &lt;code&gt;tenk1&lt;/code&gt; has 358 disk pages and 10000 rows. The estimated cost is computed as (disk pages read * &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost&lt;/a&gt;) + (rows scanned * &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost&lt;/a&gt;). By default, &lt;code&gt;seq_page_cost&lt;/code&gt; is 1.0 and &lt;code&gt;cpu_tuple_cost&lt;/code&gt; is 0.01, so the estimated cost is (358 * 1.0) + (10000 * 0.01) = 458.</source>
          <target state="translated">당신은 발견 할 것이다 &lt;code&gt;tenk1&lt;/code&gt; 가 358 디스크 페이지와 10000 개 행이 있습니다. 예상 비용은 다음과 같이 계산 (디스크 페이지 * 읽어 &lt;a href=&quot;runtime-config-query#GUC-SEQ-PAGE-COST&quot;&gt;seq_page_cost를&lt;/a&gt; ) + (행 * 스캔 &lt;a href=&quot;runtime-config-query#GUC-CPU-TUPLE-COST&quot;&gt;cpu_tuple_cost을&lt;/a&gt; ). 기본적으로 &lt;code&gt;seq_page_cost&lt;/code&gt; 는 1.0이고 &lt;code&gt;cpu_tuple_cost&lt;/code&gt; 는 0.01이므로 추정 비용은 (358 * 1.0) + (10000 * 0.01) = 458입니다.</target>
        </trans-unit>
        <trans-unit id="1982d2d3e9d46b67ceb2b6b1086e041a7f7ce8a9" translate="yes" xml:space="preserve">
          <source>zero octet</source>
          <target state="translated">제로 옥텟</target>
        </trans-unit>
        <trans-unit id="5aab974202bf0788f59e7ce97b96b6b4d59e6caf" translate="yes" xml:space="preserve">
          <source>{A,B,C}</source>
          <target state="translated">{A,B,C}</target>
        </trans-unit>
        <trans-unit id="f751f41a86686962c7eb6a6c72d7aead8c2eed66" translate="yes" xml:space="preserve">
          <source>~ ! @ # % ^ &amp;amp; | ` ?</source>
          <target state="translated">~! @ # % ^ &amp;amp; | `?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
