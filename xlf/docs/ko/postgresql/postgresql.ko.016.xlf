<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="d835303635997cc515233b553b202dd2ca61cd9f" translate="yes" xml:space="preserve">
          <source>More generically, a relation is a set of tuples; for example, the result of a query is also a relation.</source>
          <target state="translated">보다 일반적으로 관계는 튜플의 집합입니다. 예를 들어 쿼리 결과도 관계입니다.</target>
        </trans-unit>
        <trans-unit id="e5ff6c49fed97ba21bc443a8e95921cd7fef478d" translate="yes" xml:space="preserve">
          <source>More generically, the term &lt;em&gt;schema&lt;/em&gt; is used to mean all data descriptions (&lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;table&lt;/a&gt; definitions, &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;constraints&lt;/a&gt;, comments, etc) for a given &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;database&lt;/a&gt; or subset thereof.</source>
          <target state="translated">보다 일반적으로 &lt;em&gt;스키마&lt;/em&gt; 라는 용어 는 주어진 &lt;a href=&quot;glossary#GLOSSARY-DATABASE&quot;&gt;데이터베이스&lt;/a&gt; 또는 그 하위 집합에 대한 모든 데이터 설명 ( &lt;a href=&quot;glossary#GLOSSARY-TABLE&quot;&gt;테이블&lt;/a&gt; 정의, &lt;a href=&quot;glossary#GLOSSARY-CONSTRAINT&quot;&gt;제약 조건&lt;/a&gt; , 주석 등) 을 의미하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c771e450e93955920d70db2f3a188ef32edea882" translate="yes" xml:space="preserve">
          <source>More information about partial indexes can be found in &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt;, &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SESHADRI95&quot;&gt;[seshadri95]&lt;/a&gt;.</source>
          <target state="translated">부분 인덱스에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt; , &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/biblio.html#SESHADRI95&quot;&gt;[seshadri95]에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc9aa3892ba23ddac98c416e33335aa51d42e075" translate="yes" xml:space="preserve">
          <source>More information about partial indexes can be found in &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt;, &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt;, and &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#SESHADRI95&quot;&gt;[seshadri95]&lt;/a&gt;.</source>
          <target state="translated">부분 인덱스에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#STON89B&quot;&gt;[ston89b]&lt;/a&gt; , &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#OLSON93&quot;&gt;[olson93]&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/13/biblio.html#SESHADRI95&quot;&gt;[seshadri95]&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9300c1996c675687b056f93327336beacca1fbf" translate="yes" xml:space="preserve">
          <source>More information about the lock modes and locking strategies can be found in &lt;a href=&quot;explicit-locking&quot;&gt;Section 13.3&lt;/a&gt;.</source>
          <target state="translated">잠금 모드 및 잠금 전략에 대한 자세한 내용은 &lt;a href=&quot;explicit-locking&quot;&gt;13.3 절&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef70336c8dc9c2d758937dd2be0326ac89265cd4" translate="yes" xml:space="preserve">
          <source>More information about updating and deleting data is in &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;Chapter 6&lt;/a&gt;. Also see the description of foreign key constraint syntax in the reference documentation for &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">데이터 업데이트 및 삭제에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/dml.html&quot;&gt;6 장을 참조하십시오&lt;/a&gt; . &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 참조 설명서에서 외래 키 제약 조건 구문에 대한 설명도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cadcf76a3de36d133ed36e25753f765d08135f4c" translate="yes" xml:space="preserve">
          <source>More information about updating and deleting data is in &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;Chapter 6&lt;/a&gt;. Also see the description of foreign key constraint syntax in the reference documentation for &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">데이터 업데이트 및 삭제에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/dml.html&quot;&gt;6 장에&lt;/a&gt; 있습니다. 또한 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 에 대한 참조 문서에서 외래 키 제약 조건 구문에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e689fb0c34bef953cc6f900b699843e5aff59cf5" translate="yes" xml:space="preserve">
          <source>More information about window functions can be found in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.21&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="translated">윈도우 기능에 대한 자세한 내용은 &lt;a href=&quot;tutorial-window&quot;&gt;3.5&lt;/a&gt; , &lt;a href=&quot;functions-window&quot;&gt;9.21&lt;/a&gt; 및 &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;7.2.5 섹션을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="910afb407202e4aaa34247efa3cbb1ddac8f9709" translate="yes" xml:space="preserve">
          <source>More information about window functions can be found in &lt;a href=&quot;tutorial-window&quot;&gt;Section 3.5&lt;/a&gt;, &lt;a href=&quot;functions-window&quot;&gt;Section 9.22&lt;/a&gt;, and &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;Section 7.2.5&lt;/a&gt;.</source>
          <target state="translated">창 기능에 대한 자세한 내용은 &lt;a href=&quot;tutorial-window&quot;&gt;섹션 3.5&lt;/a&gt; , &lt;a href=&quot;functions-window&quot;&gt;섹션 9.22&lt;/a&gt; 및 &lt;a href=&quot;queries-table-expressions#QUERIES-WINDOW&quot;&gt;섹션 7.2.5&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b29b35804e6bc278cd58dd861059bfbd8e576bad" translate="yes" xml:space="preserve">
          <source>More specifically, setting this value to &lt;code&gt;on&lt;/code&gt; will add a &lt;code&gt;Gather&lt;/code&gt; node to the top of any query plan for which this appears to be safe, so that the query runs inside of a parallel worker. Even when a parallel worker is not available or cannot be used, operations such as starting a subtransaction that would be prohibited in a parallel query context will be prohibited unless the planner believes that this will cause the query to fail. If failures or unexpected results occur when this option is set, some functions used by the query may need to be marked &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (or, possibly, &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt;).</source>
          <target state="translated">보다 구체적으로,이 값을 설정 &lt;code&gt;on&lt;/code&gt; A가 추가됩니다 &lt;code&gt;Gather&lt;/code&gt; 이 나타납니다이 안전 할 수있는 모든 쿼리 계획의 상단에 노드를 그래서 병렬 노동자의 내부 쿼리가 실행됩니다. 병렬 작업자를 사용할 수 없거나 사용할 수없는 경우에도, 병렬 쿼리 컨텍스트에서 금지 된 서브 트랜잭션 시작과 같은 조작은 계획자가 쿼리 실패로 이어질 것으로 판단하지 않는 한 금지됩니다. 이 옵션이 설정 될 때 실패 또는 예기치 않은 결과가 발생하면 조회에서 사용하는 일부 기능을 &lt;code&gt;PARALLEL UNSAFE&lt;/code&gt; (또는 &lt;code&gt;PARALLEL RESTRICTED&lt;/code&gt; ) 로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bf1a578b87b8dcebec736c6d3df5e511c59a7712" translate="yes" xml:space="preserve">
          <source>More usually, &lt;code&gt;VALUES&lt;/code&gt; is used within a larger SQL command. The most common use is in &lt;code&gt;INSERT&lt;/code&gt;:</source>
          <target state="translated">보다 일반적으로 &lt;code&gt;VALUES&lt;/code&gt; 는 더 큰 SQL 명령 내에서 사용됩니다. 가장 일반적인 용도는 &lt;code&gt;INSERT&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="f34f1661d8425a72a96b8b7cb49353a492e8fe95" translate="yes" xml:space="preserve">
          <source>Moreover, if we have a function that accepts a single argument of a composite type, we can call it with either notation. These queries are all equivalent:</source>
          <target state="translated">또한 복합 유형의 단일 인수를 허용하는 함수가 있으면 두 가지 표기법으로 호출 할 수 있습니다. 이러한 쿼리는 모두 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b6b5cd5fdbfc629a7d3f75be5167b4b144a3f86d" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;pg_ctl&lt;/code&gt; modes require knowing the data directory location; therefore, the &lt;code&gt;-D&lt;/code&gt; option is required unless &lt;code&gt;PGDATA&lt;/code&gt; is set.</source>
          <target state="translated">대부분의 &lt;code&gt;pg_ctl&lt;/code&gt; 모드는 데이터 디렉토리 위치를 알아야합니다. 따라서 &lt;code&gt;PGDATA&lt;/code&gt; 가 설정되어 있지 않으면 &lt;code&gt;-D&lt;/code&gt; 옵션이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="69cf03cafc4ea41c94813d7e422965750bb31a86" translate="yes" xml:space="preserve">
          <source>Most aggregate functions ignore null inputs, so that rows in which one or more of the expression(s) yield null are discarded. This can be assumed to be true, unless otherwise specified, for all built-in aggregates.</source>
          <target state="translated">대부분의 집계 함수는 널 입력을 무시하므로 하나 이상의 표현식에서 널을 생성하는 행은 버려집니다. 별도의 지정이없는 한 모든 내장 집계에 대해 이것이 사실이라고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ba0155b71f54b39b68d7c23be1cc2e11116377b" translate="yes" xml:space="preserve">
          <source>Most atoms, and all constraints, have no greediness attribute (because they cannot match variable amounts of text anyway).</source>
          <target state="translated">대부분의 원자와 모든 제약 조건에는 탐욕 속성이 없습니다 (어쨌든 가변 량의 텍스트와 일치 할 수 없기 때문에).</target>
        </trans-unit>
        <trans-unit id="7f53fad77c0918001bf87e5c2287a1e18f906e5e" translate="yes" xml:space="preserve">
          <source>Most common implementations</source>
          <target state="translated">가장 일반적인 구현</target>
        </trans-unit>
        <trans-unit id="750c1315d8a2e4c64b7b2cf3fe9029ccf298aef6" translate="yes" xml:space="preserve">
          <source>Most kinds of catalog objects are simply referenced by their names. Note that type names must exactly match the referenced &lt;code&gt;pg_type&lt;/code&gt; entry's &lt;code&gt;typname&lt;/code&gt;; you do not get to use any aliases such as &lt;code&gt;integer&lt;/code&gt; for &lt;code&gt;int4&lt;/code&gt;.</source>
          <target state="translated">대부분의 카탈로그 오브젝트는 단순히 이름으로 참조됩니다. 형식 이름은 참조 된 &lt;code&gt;pg_type&lt;/code&gt; 항목의 &lt;code&gt;typname&lt;/code&gt; 과 정확히 일치해야합니다 . 당신은 같은 어떤 별칭을 사용하지 않는 &lt;code&gt;integer&lt;/code&gt; 에 대한 &lt;code&gt;int4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ca0f34a89e8d302478dfd8fb8ad2a79bdc73278" translate="yes" xml:space="preserve">
          <source>Most local objects belong to a specific &lt;a href=&quot;glossary#GLOSSARY-SCHEMA&quot;&gt;schema&lt;/a&gt; in their containing database, such as &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;relations&lt;/a&gt; (all types), &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;routines&lt;/a&gt; (all types), data types, etc. The names of such objects of the same type in the same schema are enforced to be unique.</source>
          <target state="translated">대부분의 로컬 객체는 &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계&lt;/a&gt; (모든 유형), &lt;a href=&quot;glossary#GLOSSARY-FUNCTION&quot;&gt;루틴&lt;/a&gt; (모든 유형), 데이터 유형 등과 같이 포함 된 데이터베이스 의 특정 &lt;a href=&quot;glossary#GLOSSARY-SCHEMA&quot;&gt;스키마&lt;/a&gt; 에 속합니다 . 동일한 스키마에서 동일한 유형의 이러한 객체 이름은 고유하도록 강제 적용됩니다. .</target>
        </trans-unit>
        <trans-unit id="4dbe371d76c6dc7cba4d9098c63670e12f1237d3" translate="yes" xml:space="preserve">
          <source>Most of the functions that reconstruct (decompile) database objects have an optional &lt;em&gt;&lt;code&gt;pretty&lt;/code&gt;&lt;/em&gt; flag, which if &lt;code&gt;true&lt;/code&gt; causes the result to be &amp;ldquo;pretty-printed&amp;rdquo;. Pretty-printing suppresses unnecessary parentheses and adds whitespace for legibility. The pretty-printed format is more readable, but the default format is more likely to be interpreted the same way by future versions of PostgreSQL; so avoid using pretty-printed output for dump purposes. Passing &lt;code&gt;false&lt;/code&gt; for the &lt;em&gt;&lt;code&gt;pretty&lt;/code&gt;&lt;/em&gt; parameter yields the same result as omitting the parameter.</source>
          <target state="translated">데이터베이스 개체를 재구성 (디 컴파일)하는 대부분의 함수에는 선택적인 &lt;em&gt; &lt;code&gt;pretty&lt;/code&gt; &lt;/em&gt; 플래그가 있으며, &lt;code&gt;true&lt;/code&gt; 인 경우 결과가 &quot;예쁘게 인쇄&quot;됩니다. 예쁜 인쇄는 불필요한 괄호를 억제하고 가독성을 위해 공백을 추가합니다. 예쁘게 인쇄 된 형식이 더 읽기 쉽지만 기본 형식은 향후 PostgreSQL 버전에서 동일한 방식으로 해석 될 가능성이 더 높습니다. 따라서 덤프 목적으로 예쁘게 인쇄 된 출력을 사용하지 마십시오. &lt;em&gt; &lt;code&gt;pretty&lt;/code&gt; &lt;/em&gt; 매개 변수에 대해 &lt;code&gt;false&lt;/code&gt; 를 전달 하면 매개 변수를 생략 한 것과 동일한 결과가 생성됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a098765cd76a02dd3c28ed1a2d6ced931f0a323" translate="yes" xml:space="preserve">
          <source>Most queries retrieve only a fraction of the rows in a table, due to &lt;code&gt;WHERE&lt;/code&gt; clauses that restrict the rows to be examined. The planner thus needs to make an estimate of the &lt;em&gt;selectivity&lt;/em&gt; of &lt;code&gt;WHERE&lt;/code&gt; clauses, that is, the fraction of rows that match each condition in the &lt;code&gt;WHERE&lt;/code&gt; clause. The information used for this task is stored in the &lt;a href=&quot;catalog-pg-statistic&quot;&gt;&lt;code&gt;pg_statistic&lt;/code&gt;&lt;/a&gt; system catalog. Entries in &lt;code&gt;pg_statistic&lt;/code&gt; are updated by the &lt;code&gt;ANALYZE&lt;/code&gt; and &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; commands, and are always approximate even when freshly updated.</source>
          <target state="translated">검사 할 행을 제한하는 &lt;code&gt;WHERE&lt;/code&gt; 절로 인해 대부분의 쿼리는 테이블에서 행의 일부만 검색합니다 . 플래너 따라서 추정치해야하기 &lt;em&gt;선택성&lt;/em&gt; 의 &lt;code&gt;WHERE&lt;/code&gt; 이다 조항, 상기 각 조건에 합치 행 분획 &lt;code&gt;WHERE&lt;/code&gt; 절. 이 작업에 사용 된 정보는 &lt;a href=&quot;catalog-pg-statistic&quot;&gt; &lt;code&gt;pg_statistic&lt;/code&gt; &lt;/a&gt; 시스템 카탈로그에 저장됩니다 . &lt;code&gt;pg_statistic&lt;/code&gt; 의 항목 은 &lt;code&gt;ANALYZE&lt;/code&gt; 및 &lt;code&gt;VACUUM ANALYZE&lt;/code&gt; 명령 으로 업데이트되며 새로 업데이트하더라도 항상 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="6eb034f582f8c2b79ea5f1d4aeb8e1cc749b45b2" translate="yes" xml:space="preserve">
          <source>Most scalar data types should have a corresponding array type (that is, a standard varlena array type whose element type is the scalar type, and which is referenced by the &lt;code&gt;typarray&lt;/code&gt; field of the scalar type's &lt;code&gt;pg_type&lt;/code&gt; entry). &lt;code&gt;genbki.pl&lt;/code&gt; is able to generate the &lt;code&gt;pg_type&lt;/code&gt; entry for the array type automatically in most cases.</source>
          <target state="translated">대부분의 스칼라 데이터 유형에는 해당 배열 유형 (즉, 요소 ​​유형이 스칼라 유형이고 스칼라 유형 &lt;code&gt;pg_type&lt;/code&gt; 항목 의 &lt;code&gt;typarray&lt;/code&gt; 필드로 참조되는 표준 varlena 배열 유형)이 있어야 합니다 . &lt;code&gt;genbki.pl&lt;/code&gt; 은 대부분의 경우 배열 유형에 대한 &lt;code&gt;pg_type&lt;/code&gt; 항목을 자동으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8934cf5770ff56a86643f007085fd816b1b58dfa" translate="yes" xml:space="preserve">
          <source>Most system catalogs are copied from the template database during database creation and are thereafter database-specific. A few catalogs are physically shared across all databases in a cluster; these are noted in the descriptions of the individual catalogs.</source>
          <target state="translated">대부분의 시스템 카탈로그는 데이터베이스를 생성하는 동안 템플릿 데이터베이스에서 복사 된 후 데이터베이스에 따라 다릅니다. 일부 카탈로그는 클러스터의 모든 데이터베이스에서 실제로 공유됩니다. 이들은 개별 카탈로그의 설명에 명시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7bd8e4c0ba4c5fef185f840f580e4a5b9a25b96" translate="yes" xml:space="preserve">
          <source>Most types of dictionaries rely on configuration files, such as files of stop words. These files &lt;em&gt;must&lt;/em&gt; be stored in UTF-8 encoding. They will be translated to the actual database encoding, if that is different, when they are read into the server.</source>
          <target state="translated">대부분의 유형의 사전은 중지 단어 파일과 같은 구성 파일에 의존합니다. 이러한 파일 &lt;em&gt;은&lt;/em&gt; UTF-8 인코딩으로 저장 &lt;em&gt;해야합니다&lt;/em&gt; . 서버로 읽을 때 실제 데이터베이스 인코딩으로 다른 경우 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4deea28851a7ae4ce56d6b6d82c468bb35f41bb4" translate="yes" xml:space="preserve">
          <source>Most variables that control psql's behavior cannot be unset; instead, an &lt;code&gt;\unset&lt;/code&gt; command is interpreted as setting them to their default values. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt; below.</source>
          <target state="translated">psql의 동작을 제어하는 ​​대부분의 변수는 설정 해제 할 수 없습니다. 대신 &lt;code&gt;\unset&lt;/code&gt; 명령은 기본값으로 설정하는 것으로 해석됩니다. 아래 &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="473029ab69353e53921e8ecd7440a49c9a86be94" translate="yes" xml:space="preserve">
          <source>Most variables that control psql's behavior cannot be unset; instead, an &lt;code&gt;\unset&lt;/code&gt; command is interpreted as setting them to their default values. See &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;Variables&lt;/a&gt;, below.</source>
          <target state="translated">psql의 동작을 제어하는 ​​대부분의 변수는 설정 해제 할 수 없습니다. 대신 &lt;code&gt;\unset&lt;/code&gt; 명령은 기본값으로 설정하는 것으로 해석됩니다. 아래의 &lt;a href=&quot;app-psql#APP-PSQL-VARIABLES&quot;&gt;변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7293739c8cef6860367bef80e497db37fda337b4" translate="yes" xml:space="preserve">
          <source>Moving an object to a new schema additionally requires &lt;code&gt;remove_name&lt;/code&gt; permission on the old schema and &lt;code&gt;add_name&lt;/code&gt; permission on the new one.</source>
          <target state="translated">개체를 새 스키마로 이동하려면 이전 스키마에 대한 &lt;code&gt;remove_name&lt;/code&gt; 권한과 새 스키마 에 대한 &lt;code&gt;add_name&lt;/code&gt; 권한이 추가로 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="9a676159878bdf52262c05ecb519fb1a7d01d39b" translate="yes" xml:space="preserve">
          <source>Much of the PostgreSQL type system is built around a rich set of functions. Functions can have one or more arguments. Since PostgreSQL permits function overloading, the function name alone does not uniquely identify the function to be called; the parser must select the right function based on the data types of the supplied arguments.</source>
          <target state="translated">대부분의 PostgreSQL 유형 시스템은 다양한 기능을 기반으로 구축되었습니다. 함수는 하나 이상의 인수를 가질 수 있습니다. PostgreSQL은 함수 오버로딩을 허용하므로 함수 이름만으로는 호출 할 함수를 고유하게 식별하지 않습니다. 파서는 제공된 인수의 데이터 유형에 따라 올바른 함수를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="2740f0c680a6e63e450d5b3c062a5229834ae2d2" translate="yes" xml:space="preserve">
          <source>Mule internal code</source>
          <target state="translated">뮬 내부 코드</target>
        </trans-unit>
        <trans-unit id="344fa8c431ce29a1cdabfe9e517c51ceaef15678" translate="yes" xml:space="preserve">
          <source>Multi-Version Concurrency Control</source>
          <target state="translated">다중 버전 동시성 제어</target>
        </trans-unit>
        <trans-unit id="99e2646c11c9e1032892edf955d9bbabc4a055aa" translate="yes" xml:space="preserve">
          <source>Multi-version concurrency control (MVCC)</source>
          <target state="translated">다중 버전 동시성 제어 (MVCC)</target>
        </trans-unit>
        <trans-unit id="384caf1b9fc6ff1244af37a2f4eefa0674d24a27" translate="yes" xml:space="preserve">
          <source>Multicolumn GIN indexes are implemented by building a single B-tree over composite values (column number, key value). The key values for different columns can be of different types.</source>
          <target state="translated">다중 열 GIN 인덱스는 복합 값 (열 번호, 키 값) 위에 단일 B- 트리를 작성하여 구현됩니다. 다른 열의 키 값은 다른 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c159674cdc49534760eb0265af934a2b89d41fe" translate="yes" xml:space="preserve">
          <source>Multicolumn Indexes</source>
          <target state="translated">여러 열 인덱스</target>
        </trans-unit>
        <trans-unit id="2d93cd8bc72bc57af1ba376ce47d069b6c4a937d" translate="yes" xml:space="preserve">
          <source>Multicolumn indexes should be used sparingly. In most situations, an index on a single column is sufficient and saves space and time. Indexes with more than three columns are unlikely to be helpful unless the usage of the table is extremely stylized. See also &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;Section 11.5&lt;/a&gt; and &lt;a href=&quot;indexes-index-only-scans&quot;&gt;Section 11.9&lt;/a&gt; for some discussion of the merits of different index configurations.</source>
          <target state="translated">여러 열 인덱스는 드물게 사용해야합니다. 대부분의 경우 단일 열의 인덱스만으로도 공간과 시간을 절약 할 수 있습니다. 3 개 이상의 열이있는 인덱스는 테이블 사용법이 매우 양식화되어 있지 않으면 도움이되지 않습니다. 다른 인덱스 구성의 장점에 대한 설명은 &lt;a href=&quot;indexes-bitmap-scans&quot;&gt;11.5 절&lt;/a&gt; 및 &lt;a href=&quot;indexes-index-only-scans&quot;&gt;11.9 &lt;/a&gt;절을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b99aa634fe16bee7bdf05b0cf7793d76fb5f12b3" translate="yes" xml:space="preserve">
          <source>Multidimensional array constructor elements can be anything yielding an array of the proper kind, not only a sub-&lt;code&gt;ARRAY&lt;/code&gt; construct. For example:</source>
          <target state="translated">다차원 배열 생성자 요소는 하위 &lt;code&gt;ARRAY&lt;/code&gt; 구문 뿐만 아니라 적절한 종류의 배열을 생성하는 모든 것이 될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5dca66d7f2aee43ef1797a393d0e215db306ea18" translate="yes" xml:space="preserve">
          <source>Multidimensional array values can be built by nesting array constructors. In the inner constructors, the key word &lt;code&gt;ARRAY&lt;/code&gt; can be omitted. For example, these produce the same result:</source>
          <target state="translated">배열 생성자를 중첩하여 다차원 배열 값을 작성할 수 있습니다. 내부 생성자에서 키워드 &lt;code&gt;ARRAY&lt;/code&gt; 는 생략 할 수 있습니다. 예를 들어, 동일한 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b8d7e3b8a7276708d01165024b6293de444e2c11" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays must have matching extents for each dimension. A mismatch causes an error, for example:</source>
          <target state="translated">다차원 배열에는 각 차원에 대해 일치하는 범위가 있어야합니다. 불일치로 인해 오류가 발생합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="b92978283c35094160cf22fc851c3df5bcf7effd" translate="yes" xml:space="preserve">
          <source>Multilingual Emacs</source>
          <target state="translated">다국어 이맥스</target>
        </trans-unit>
        <trans-unit id="da392350dc33944a643a54bf379fde9199e79c15" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;EXCEPT&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless parentheses dictate otherwise. &lt;code&gt;EXCEPT&lt;/code&gt; binds at the same level as &lt;code&gt;UNION&lt;/code&gt;.</source>
          <target state="translated">괄호로 달리 지정하지 않는 한 동일한 &lt;code&gt;SELECT&lt;/code&gt; 문의 여러 &lt;code&gt;EXCEPT&lt;/code&gt; 연산자는 왼쪽에서 오른쪽으로 평가됩니다. &lt;code&gt;EXCEPT&lt;/code&gt; 는 &lt;code&gt;UNION&lt;/code&gt; 과 같은 수준에서 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="545da6f8ee31d7740c9c3d5dad863f020a69eb93" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;INTERSECT&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless parentheses dictate otherwise. &lt;code&gt;INTERSECT&lt;/code&gt; binds more tightly than &lt;code&gt;UNION&lt;/code&gt;. That is, &lt;code&gt;A UNION B INTERSECT C&lt;/code&gt; will be read as &lt;code&gt;A UNION (B INTERSECT C)&lt;/code&gt;.</source>
          <target state="translated">괄호로 달리 지정하지 않는 한 동일한 &lt;code&gt;SELECT&lt;/code&gt; 문의 여러 &lt;code&gt;INTERSECT&lt;/code&gt; 연산자가 왼쪽에서 오른쪽으로 평가됩니다. &lt;code&gt;INTERSECT&lt;/code&gt; 는 &lt;code&gt;UNION&lt;/code&gt; 보다 더 밀접하게 바인딩 됩니다. 즉, &lt;code&gt;A UNION B INTERSECT C&lt;/code&gt; 는 &lt;code&gt;A UNION (B INTERSECT C)&lt;/code&gt; 으로 읽 힙니다 .</target>
        </trans-unit>
        <trans-unit id="44cc99500b8c6afffdf8915313cbba82fb39e906" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;UNION&lt;/code&gt; operators in the same &lt;code&gt;SELECT&lt;/code&gt; statement are evaluated left to right, unless otherwise indicated by parentheses.</source>
          <target state="translated">동일한 &lt;code&gt;SELECT&lt;/code&gt; 문의 여러 &lt;code&gt;UNION&lt;/code&gt; 연산자는 괄호로 표시되지 않는 한 왼쪽에서 오른쪽으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="09ad30df55e0ee1fdeb0db77709134b50e5f6d5c" translate="yes" xml:space="preserve">
          <source>Multiple Identity Columns</source>
          <target state="translated">여러 ID 열</target>
        </trans-unit>
        <trans-unit id="e2933c3051980c1e2e6ec097345b6b77b93e0721" translate="yes" xml:space="preserve">
          <source>Multiple RADIUS servers can be specified, in which case they will be tried sequentially. If a negative response is received from a server, the authentication will fail. If no response is received, the next server in the list will be tried. To specify multiple servers, put the names within quotes and separate the server names with a comma. If multiple servers are specified, all other RADIUS options can also be given as a comma separate list, to apply individual values to each server. They can also be specified as a single value, in which case this value will apply to all servers.</source>
          <target state="translated">여러 개의 RADIUS 서버를 지정할 수 있으며이 경우 순차적으로 시도됩니다. 서버에서 부정적인 응답을 받으면 인증이 실패합니다. 응답이 수신되지 않으면 목록의 다음 서버가 시도됩니다. 여러 서버를 지정하려면 이름을 따옴표로 묶고 서버 이름을 쉼표로 구분하십시오. 여러 서버를 지정하면 다른 모든 RADIUS 옵션을 쉼표로 구분 된 목록으로 제공하여 각 값을 개별 서버에 적용 할 수 있습니다. 단일 값으로 지정할 수도 있습니다.이 경우이 값은 모든 서버에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="52ee8ebc172afa9611da532af89c4c55f27f12a0" translate="yes" xml:space="preserve">
          <source>Multiple RADIUS servers can be specified, in which case they will be tried sequentially. If a negative response is received from a server, the authentication will fail. If no response is received, the next server in the list will be tried. To specify multiple servers, separate the server names with commas and surround the list with double quotes. If multiple servers are specified, the other RADIUS options can also be given as comma-separated lists, to provide individual values for each server. They can also be specified as a single value, in which case that value will apply to all servers.</source>
          <target state="translated">여러 RADIUS 서버를 지정할 수 있으며이 경우 순차적으로 시도됩니다. 서버에서 부정적인 응답을 받으면 인증이 실패합니다. 응답이 수신되지 않으면 목록의 다음 서버가 시도됩니다. 여러 서버를 지정하려면 서버 이름을 쉼표로 구분하고 목록을 큰 따옴표로 묶으십시오. 여러 서버가 지정된 경우 다른 RADIUS 옵션도 쉼표로 구분 된 목록으로 제공하여 각 서버에 대한 개별 값을 제공 할 수 있습니다. 단일 값으로 지정할 수도 있으며이 경우 해당 값이 모든 서버에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="47cf9ecc42c00f97b187ac65e4ad87ed8ddddec7" translate="yes" xml:space="preserve">
          <source>Multiple function calls can be combined into a single &lt;code&gt;FROM&lt;/code&gt;-clause item by surrounding them with &lt;code&gt;ROWS FROM( ... )&lt;/code&gt;. The output of such an item is the concatenation of the first row from each function, then the second row from each function, etc. If some of the functions produce fewer rows than others, null values are substituted for the missing data, so that the total number of rows returned is always the same as for the function that produced the most rows.</source>
          <target state="translated">여러 함수 호출 을 &lt;code&gt;ROWS FROM( ... )&lt;/code&gt; 으로 묶어 단일 &lt;code&gt;FROM&lt;/code&gt; 절 항목 으로 결합 할 수 있습니다 . 이러한 항목의 출력은 각 함수에서 첫 번째 행을 연결 한 다음 각 함수에서 두 번째 행을 연결하는 것입니다. 일부 함수가 다른 함수보다 적은 수의 행을 생성하는 경우 누락 된 데이터에 대해 널 (NULL) 값이 대체되므로 반환 된 총 행 수는 항상 가장 많은 행을 생성 한 함수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cb041e89d71104ed194545d06d97265abcc8ac5c" translate="yes" xml:space="preserve">
          <source>Multiple inheritance via the &lt;code&gt;INHERITS&lt;/code&gt; clause is a PostgreSQL language extension. SQL:1999 and later define single inheritance using a different syntax and different semantics. SQL:1999-style inheritance is not yet supported by PostgreSQL.</source>
          <target state="translated">&lt;code&gt;INHERITS&lt;/code&gt; 절을 통한 다중 상속 은 PostgreSQL 언어 확장입니다. SQL : 1999 이상은 다른 구문과 의미를 사용하여 단일 상속을 정의합니다. PostgreSQL은 SQL : 1999 스타일 상속을 아직 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfc4b99f808466861398cb5089390dbcf8288968" translate="yes" xml:space="preserve">
          <source>Multiple initial administrators, and all the other options of &lt;code&gt;CREATE ROLE&lt;/code&gt;, are PostgreSQL extensions.</source>
          <target state="translated">여러 초기 관리자 및 다른 &lt;code&gt;CREATE ROLE&lt;/code&gt; 옵션 은 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="7023aa5fc8e888d453cd39667bc365999be7e91b" translate="yes" xml:space="preserve">
          <source>Multiple locking clauses can be written if it is necessary to specify different locking behavior for different tables. If the same table is mentioned (or implicitly affected) by more than one locking clause, then it is processed as if it was only specified by the strongest one. Similarly, a table is processed as &lt;code&gt;NOWAIT&lt;/code&gt; if that is specified in any of the clauses affecting it. Otherwise, it is processed as &lt;code&gt;SKIP LOCKED&lt;/code&gt; if that is specified in any of the clauses affecting it.</source>
          <target state="translated">다른 테이블에 대해 다른 잠금 동작을 지정해야하는 경우 여러 잠금 절을 작성할 수 있습니다. 동일한 테이블이 둘 이상의 잠금 절에 의해 언급되거나 암시 적으로 영향을받는 경우 가장 강한 테이블에서만 지정된 것처럼 처리됩니다. 마찬가지로 테이블이 영향을받는 절에 지정된 경우 &lt;code&gt;NOWAIT&lt;/code&gt; 로 테이블이 처리됩니다 . 그렇지 않으면, &lt;code&gt;SKIP LOCKED&lt;/code&gt; 로 영향을주는 조항 중 하나라도 지정되면 SKIP LOCKED 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ff93077b96a2599909c71e452a52b617dcb75f7" translate="yes" xml:space="preserve">
          <source>Multiple-Server Parallel Query Execution</source>
          <target state="translated">다중 서버 병렬 쿼리 실행</target>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="83d4c1590260d359ecbe9f085d559899657ac6eb" translate="yes" xml:space="preserve">
          <source>Multiplies each point of the first argument by the second &lt;code&gt;point&lt;/code&gt; (treating a point as being a complex number represented by real and imaginary parts, and performing standard complex multiplication). If one interprets the second &lt;code&gt;point&lt;/code&gt; as a vector, this is equivalent to scaling the object's size and distance from the origin by the length of the vector, and rotating it counterclockwise around the origin by the vector's angle from the &lt;code&gt;x&lt;/code&gt; axis. Available for &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;,&lt;a href=&quot;#ftn.FUNCTIONS-GEOMETRY-ROTATION-FN&quot;&gt;&lt;sup id=&quot;FUNCTIONS-GEOMETRY-ROTATION-FN&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;&lt;code&gt;path&lt;/code&gt;, &lt;code&gt;circle&lt;/code&gt;.</source>
          <target state="translated">제 곱하여 첫번째 인수의 각 점을 &lt;code&gt;point&lt;/code&gt; (실수 및 허수 부분으로 표시되는 복소수로서 포인트를 처리하고 표준 복소 곱셈을 수행). 두 번째 &lt;code&gt;point&lt;/code&gt; 을 벡터로 해석하는 경우 이는 벡터의 길이에 따라 개체의 크기와 원점으로부터의 거리를 조정하고 &lt;code&gt;x&lt;/code&gt; 축 에서 벡터의 각도만큼 원점을 중심으로 시계 반대 방향으로 회전하는 것과 같습니다 . 가능 &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; , &lt;a href=&quot;#ftn.FUNCTIONS-GEOMETRY-ROTATION-FN&quot;&gt;&lt;sup id=&quot;FUNCTIONS-GEOMETRY-ROTATION-FN&quot;&gt;[A]&lt;/sup&gt;&lt;/a&gt; &lt;code&gt;path&lt;/code&gt; , &lt;code&gt;circle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f690d76a3a6b4f3cf2f400b6a49ebe14dc72a219" translate="yes" xml:space="preserve">
          <source>Multiply an interval by a scalar</source>
          <target state="translated">간격에 스칼라를 곱합니다.</target>
        </trans-unit>
        <trans-unit id="2c0c5f6099e92ebebc75583d550cc71584a93e4c" translate="yes" xml:space="preserve">
          <source>Multiply the number of rows generated by the scale factor. For example, &lt;code&gt;-s 100&lt;/code&gt; will create 10,000,000 rows in the &lt;code&gt;pgbench_accounts&lt;/code&gt; table. Default is 1. When the scale is 20,000 or larger, the columns used to hold account identifiers (&lt;code&gt;aid&lt;/code&gt; columns) will switch to using larger integers (&lt;code&gt;bigint&lt;/code&gt;), in order to be big enough to hold the range of account identifiers.</source>
          <target state="translated">스케일 팩터로 생성 된 행 수를 곱하십시오. 예를 들어, &lt;code&gt;-s 100&lt;/code&gt; 은 &lt;code&gt;pgbench_accounts&lt;/code&gt; 테이블 에 10,000,000 개의 행을 작성 합니다. 기본값은 1입니다. 스케일이 20,000 이상인 경우 계정 식별자를 보유하는 데 사용되는 열 ( &lt;code&gt;aid&lt;/code&gt; 컬럼)은 계정 식별자의 범위를 보유 할 수있을만큼 커지기 위해 더 큰 정수 ( &lt;code&gt;bigint&lt;/code&gt; ) 를 사용하도록 전환됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b63b41e9535d1638fe83e7fb152d39f9e2c71b6" translate="yes" xml:space="preserve">
          <source>Multivariate Statistics Examples</source>
          <target state="translated">다변량 통계 예</target>
        </trans-unit>
        <trans-unit id="67f1e276e130e436d878dd37efbefd858f1a15f3" translate="yes" xml:space="preserve">
          <source>Multivariate correlation can be demonstrated with a very simple data set &amp;mdash; a table with two columns, both containing the same values:</source>
          <target state="translated">다변량 상관은 매우 간단한 데이터 세트 (두 개의 열이 있고 동일한 값을 포함하는 테이블)를 사용하여 입증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68e9ef2c165e4fa8adf23b844de4bcd199158fae" translate="yes" xml:space="preserve">
          <source>MurmurHash2 hash</source>
          <target state="translated">MurmurHash2 해시</target>
        </trans-unit>
        <trans-unit id="1d1a603b8a91745540a0eb62aecc8635b092e498" translate="yes" xml:space="preserve">
          <source>Mutation as genetic operator is deprecated so that no repair mechanisms are needed to generate legal TSP tours.</source>
          <target state="translated">유전자 조작자로서의 돌연변이는 더 이상 사용되지 않으므로 합법적 인 TSP 투어를 생성하기 위해 수리 메커니즘이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="411d403f2e3b649eb2f47189fa6c058b68a3959d" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;), and to his former student Andy Dong for his example written for Illustra. I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">GiST의 요점을 밝히는 Joe Hellerstein 교수 ( &lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt; ) 에게 감사 의 말씀을 전합니다 ( &lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt; ). 전 학생 Andy Dong은 Illustra를 위해 작성된 그의 예를 들었습니다. 또한 현재와 과거의 모든 Postgres 개발자에게 자신의 세계를 만들고 방해받지 않고 살아갈 수있게되어 감사합니다. 데이터베이스 연구에 대한 수년간의 충실한 지원에 대해 Argonne Lab과 미국 에너지 부에 감사의 말씀을 전합니다.</target>
        </trans-unit>
        <trans-unit id="63806797acec7e92b9e9bba40d5e19f39040d989" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;). I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">GiST의 요점을 설명해 주신 Joe Hellerstein 교수 ( &lt;a href=&quot;http://db.cs.berkeley.edu/jmh/&quot;&gt;http://db.cs.berkeley.edu/jmh/&lt;/a&gt; ) 에게 감사 를 표합니다 ( &lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt; ). 또한 현재와 과거의 모든 Postgres 개발자에게 자신의 세계를 만들고 방해받지 않고 살아갈 수있게되어 감사합니다. 데이터베이스 연구에 대한 수년간의 충실한 지원에 대해 Argonne Lab과 미국 에너지 부에 감사의 말씀을 전합니다.</target>
        </trans-unit>
        <trans-unit id="6b165eae6146362f8f4218790f243080eeac62ec" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;https://dsf.berkeley.edu/jmh/&quot;&gt;https://dsf.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;), and to his former student Andy Dong for his example written for Illustra. I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">GiST ( &lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt; ) 의 요지를 설명 해준 Joe Hellerstein 교수 ( &lt;a href=&quot;https://dsf.berkeley.edu/jmh/&quot;&gt;https://dsf.berkeley.edu/jmh/&lt;/a&gt; ) 와 그의 전 학생에게 감사드립니다. Illustra를 위해 작성된 그의 예를 들어 Andy Dong 나는 또한 내 자신의 세계를 만들고 그 안에서 방해받지 않고 살 수있게 해준 현재와 과거의 모든 Postgres 개발자들에게 감사합니다. 그리고 데이터베이스 연구에 대한 성실한 지원에 대해 Argonne Lab과 미국 에너지 부에 감사를 표합니다.</target>
        </trans-unit>
        <trans-unit id="6c665518a6c8a774be8b227ccf9e0e2930a0b4db" translate="yes" xml:space="preserve">
          <source>My thanks are primarily to Prof. Joe Hellerstein (&lt;a href=&quot;https://dsf.berkeley.edu/jmh/&quot;&gt;https://dsf.berkeley.edu/jmh/&lt;/a&gt;) for elucidating the gist of the GiST (&lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt;). I am also grateful to all Postgres developers, present and past, for enabling myself to create my own world and live undisturbed in it. And I would like to acknowledge my gratitude to Argonne Lab and to the U.S. Department of Energy for the years of faithful support of my database research.</source>
          <target state="translated">GiST ( &lt;a href=&quot;http://gist.cs.berkeley.edu/&quot;&gt;http://gist.cs.berkeley.edu/&lt;/a&gt; ) 의 요점을 설명해 주신 Joe Hellerstein 교수 ( &lt;a href=&quot;https://dsf.berkeley.edu/jmh/&quot;&gt;https://dsf.berkeley.edu/jmh/&lt;/a&gt; ) 에게 감사드립니다 . 나는 또한 내 자신의 세계를 만들고 그 안에서 방해받지 않고 살 수있게 해준 현재와 과거의 모든 Postgres 개발자들에게 감사합니다. 그리고 데이터베이스 연구에 대한 성실한 지원에 대해 Argonne Lab과 미국 에너지 부에 감사를 표합니다.</target>
        </trans-unit>
        <trans-unit id="990ae3b2652542659607c20d6be633d0e3b25e79" translate="yes" xml:space="preserve">
          <source>MySpell does not support compound words. Hunspell has sophisticated support for compound words. At present, PostgreSQL implements only the basic compound word operations of Hunspell.</source>
          <target state="translated">MySpell은 복합 단어를 지원하지 않습니다. Hunspell은 복합 단어를 정교하게 지원합니다. 현재 PostgreSQL은 Hunspell의 기본 복합 단어 연산 만 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5e441f15c5e733792befe0ffc73906895c439622" translate="yes" xml:space="preserve">
          <source>MySpell format is a subset of Hunspell. The &lt;code&gt;.affix&lt;/code&gt; file of Hunspell has the following structure:</source>
          <target state="translated">MySpell 형식은 Hunspell의 하위 집합입니다. Hunspell 의 &lt;code&gt;.affix&lt;/code&gt; 파일 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="488df82bbfc103d0d771499379d0ae7070c9580f" translate="yes" xml:space="preserve">
          <source>N-distinct counts for combinations of column values. If greater than zero, the estimated number of distinct values in the combination. If less than zero, the negative of the number of distinct values divided by the number of rows. (The negated form is used when &lt;code&gt;ANALYZE&lt;/code&gt; believes that the number of distinct values is likely to increase as the table grows; the positive form is used when the column seems to have a fixed number of possible values.) For example, -1 indicates a unique combination of columns in which the number of distinct combinations is the same as the number of rows.</source>
          <target state="translated">열 값의 조합에 대한 N 개의 구별 카운트. 0보다 크면 조합에서 추정되는 구별 값의 수입니다. 0보다 작은 경우 고유 값 수의 음수를 행 수로 나눈 값입니다. (거짓된 형식은 &lt;code&gt;ANALYZE&lt;/code&gt; 에서 테이블이 커짐에 따라 고유 한 값의 수가 증가 할 것으로 판단 할 때 사용되며, 양의 형식은 열에 고정 된 수의 가능한 값이있는 경우 사용됩니다.) 예를 들어, -1은 고유 조합 수가 행 수와 동일한 열의 고유 조합.</target>
        </trans-unit>
        <trans-unit id="b9f3788bf337d1fbd1e44a8ca35f9f8dc00922f3" translate="yes" xml:space="preserve">
          <source>N-distinct counts, serialized as &lt;code&gt;pg_ndistinct&lt;/code&gt; type</source>
          <target state="translated">N 개의 고유 카운트, &lt;code&gt;pg_ndistinct&lt;/code&gt; 타입으로 직렬화</target>
        </trans-unit>
        <trans-unit id="df7b392c5a7d73b13e58918e0a512d5732187d0d" translate="yes" xml:space="preserve">
          <source>N.1. When Color is Used</source>
          <target state="translated">N.1. 색상이 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="82b9c07010036ea2172a9c209c09188b295a72b2" translate="yes" xml:space="preserve">
          <source>N.2. Configuring the Colors</source>
          <target state="translated">N.2. 색상 구성</target>
        </trans-unit>
        <trans-unit id="e75dedcc315971ca035b9f33d5ff4a268f0acad9" translate="yes" xml:space="preserve">
          <source>NAS</source>
          <target state="translated">NAS</target>
        </trans-unit>
        <trans-unit id="05c70c4a8ccede51b0f764a8b31b48ffad7c77b1" translate="yes" xml:space="preserve">
          <source>NLS</source>
          <target state="translated">NLS</target>
        </trans-unit>
        <trans-unit id="578dc1c57657369feb194b2bc15910a2480a2342" translate="yes" xml:space="preserve">
          <source>NOT &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">NOT &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="efde75752ab811815325697b4ba90b5afbe2e2a6" translate="yes" xml:space="preserve">
          <source>NOTIFY</source>
          <target state="translated">NOTIFY</target>
        </trans-unit>
        <trans-unit id="3e7d70b52328177b60019485c8ea011b37cce023" translate="yes" xml:space="preserve">
          <source>NOTIFY &amp;mdash; generate a notification</source>
          <target state="translated">NOTIFY &amp;mdash; 알림 생성</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="385a7cff63d2b3c51a6859910c942e284cc2cff9" translate="yes" xml:space="preserve">
          <source>Name of SSL cipher in use, or NULL if SSL is not in use on this connection</source>
          <target state="translated">사용중인 SSL 암호 이름 또는이 연결에서 SSL을 사용하지 않는 경우 NULL</target>
        </trans-unit>
        <trans-unit id="5eaeda54ec9eb68b2072fa5d1feb6c035f44d644" translate="yes" xml:space="preserve">
          <source>Name of a language</source>
          <target state="translated">언어의 이름</target>
        </trans-unit>
        <trans-unit id="0178948b94c691d929c18fcd5464bd15baa26a58" translate="yes" xml:space="preserve">
          <source>Name of a new or existing column.</source>
          <target state="translated">신규 또는 기존 컬럼의 이름.</target>
        </trans-unit>
        <trans-unit id="560c42c98008ce51d03f9d6187d29c37c7009544" translate="yes" xml:space="preserve">
          <source>Name of a new or existing constraint.</source>
          <target state="translated">신규 또는 기존 구속 조건의 이름.</target>
        </trans-unit>
        <trans-unit id="35dcedcca97d439e09701340473e9f3ca046b02c" translate="yes" xml:space="preserve">
          <source>Name of a notification channel (any identifier).</source>
          <target state="translated">알림 채널의 이름 (모든 식별자)</target>
        </trans-unit>
        <trans-unit id="ce514f0b60e997e86128266bb519efbba0a6ff6b" translate="yes" xml:space="preserve">
          <source>Name of a settable configuration parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;.</source>
          <target state="translated">설정 가능한 구성 매개 변수의 이름입니다. 사용 가능한 매개 변수는 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f56681bfb8a12163f30d0b4fed0f1fd757c8babb" translate="yes" xml:space="preserve">
          <source>Name of a settable configuration parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt;.</source>
          <target state="translated">설정 가능한 구성 매개 변수의 이름입니다. 사용 가능한 매개 변수는 &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="954ee074d5be1c36459da8f7253027e56d893199" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and below.</source>
          <target state="translated">설정 가능한 런타임 매개 변수의 이름입니다. 사용 가능한 매개 변수는 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 이하에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a0e3cf73c45665ec4941eb25f3329677ad2c627" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page.</source>
          <target state="translated">설정 가능한 런타임 매개 변수의 이름입니다. 사용 가능한 매개 변수는 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 및 &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; 참조 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5a2c1ef6c12c7af08e5bbbc68b4033b620233cc" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and below.</source>
          <target state="translated">설정 가능한 런타임 매개 변수의 이름입니다. 사용 가능한 매개 변수는 &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 이하에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aafb6ab430fc1bf75e0c604287df03b8d7d814d7" translate="yes" xml:space="preserve">
          <source>Name of a settable run-time parameter. Available parameters are documented in &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; and on the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; reference page.</source>
          <target state="translated">설정 가능한 런타임 매개 변수의 이름입니다. 사용 가능한 매개 변수는 &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 과 &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; 참조 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c2301404426d669bb911593cec730650e2bdbfe" translate="yes" xml:space="preserve">
          <source>Name of a single trigger to disable or enable.</source>
          <target state="translated">비활성화하거나 활성화 할 단일 트리거의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c0e033b344c49040ea83d0610c59dfd1b03a919f" translate="yes" xml:space="preserve">
          <source>Name of an existing column.</source>
          <target state="translated">기존 열의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="231d1ed2d468b8d6e17991509cbba8cadc17e1e5" translate="yes" xml:space="preserve">
          <source>Name of an existing constraint to drop or rename.</source>
          <target state="translated">삭제하거나 이름을 바꿀 기존 구속 조건의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="22745c3446c7c4d17ba8fa32b15b8f7c06992bdd" translate="yes" xml:space="preserve">
          <source>Name of an existing constraint to drop.</source>
          <target state="translated">제거 할 기존 구속 조건의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b073ede31105aa5c1b6f36a11370455d96d537b0" translate="yes" xml:space="preserve">
          <source>Name of an existing table. If &lt;code&gt;ONLY&lt;/code&gt; is specified before the table name, only that table is affected. If &lt;code&gt;ONLY&lt;/code&gt; is not specified, the table and all its descendant tables (if any) are affected. Optionally, &lt;code&gt;*&lt;/code&gt; can be specified after the table name to explicitly indicate that descendant tables are included.</source>
          <target state="translated">기존 테이블의 이름입니다. 테이블 이름 앞에 &lt;code&gt;ONLY&lt;/code&gt; 를 지정 하면 해당 테이블 만 영향을받습니다. 경우 &lt;code&gt;ONLY&lt;/code&gt; 지정되지 않은 테이블과 그 모든 자손 테이블 (있는 경우)의 영향을받습니다. 선택적으로, 테이블 이름 뒤에 &lt;code&gt;*&lt;/code&gt; 를 지정하여 하위 테이블이 포함됨을 명시 적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="694de0e59c53dd44f4f4691acabc413768ef9d9a" translate="yes" xml:space="preserve">
          <source>Name of anonymous-block handler function, or null if none</source>
          <target state="translated">익명 블록 핸들러 함수의 이름.없는 경우 null</target>
        </trans-unit>
        <trans-unit id="5915762ae281a23f2bd1848ce737f5d865ae38a8" translate="yes" xml:space="preserve">
          <source>Name of call handler function</source>
          <target state="translated">호출 핸들러 함수의 이름</target>
        </trans-unit>
        <trans-unit id="206dec00fa32e6c205384b3df437c35f69e88392" translate="yes" xml:space="preserve">
          <source>Name of default version, or &lt;code&gt;NULL&lt;/code&gt; if none is specified</source>
          <target state="translated">기본 버전의 이름 또는 지정되지 않은 경우 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee034d5b0508537af88d7be3d4206b7d9a6f7ace" translate="yes" xml:space="preserve">
          <source>Name of extended statistics</source>
          <target state="translated">확장 통계 이름</target>
        </trans-unit>
        <trans-unit id="987fff60ced95bb42507af7d6f424dce288531b4" translate="yes" xml:space="preserve">
          <source>Name of index</source>
          <target state="translated">색인 이름</target>
        </trans-unit>
        <trans-unit id="b76e90e08249294dc6388d288e0a0ff43959a02e" translate="yes" xml:space="preserve">
          <source>Name of materialized view</source>
          <target state="translated">구체화 된 뷰의 이름</target>
        </trans-unit>
        <trans-unit id="6501e212c15d2fb75aeb9acf75320931a339d605" translate="yes" xml:space="preserve">
          <source>Name of materialized view's owner</source>
          <target state="translated">구체화 된 뷰 소유자의 이름</target>
        </trans-unit>
        <trans-unit id="e6cf10a0a70ad19c5b7371da58941b6c0037ae86" translate="yes" xml:space="preserve">
          <source>Name of policy</source>
          <target state="translated">정책 이름</target>
        </trans-unit>
        <trans-unit id="a146b1bd6e895582068f638a02a8412aaeadca11" translate="yes" xml:space="preserve">
          <source>Name of publication</source>
          <target state="translated">출판 이름</target>
        </trans-unit>
        <trans-unit id="611f97b7cc9cb3302c011583c51a64d361fde262" translate="yes" xml:space="preserve">
          <source>Name of rule</source>
          <target state="translated">규칙의 이름</target>
        </trans-unit>
        <trans-unit id="916daa93b2ab22b09d0d27a6fc75daa92e090cbf" translate="yes" xml:space="preserve">
          <source>Name of schema containing extended statistic</source>
          <target state="translated">확장 된 통계를 포함하는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="b8e23c7699d61150cab192ab08cb0a8c8eff18ba" translate="yes" xml:space="preserve">
          <source>Name of schema containing materialized view</source>
          <target state="translated">구체화 된 뷰를 포함하는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="8a4b8a6f4e6c77468796e3b2343ea829020a1a97" translate="yes" xml:space="preserve">
          <source>Name of schema containing sequence</source>
          <target state="translated">시퀀스를 포함하는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="9330f5310d2e7af8a885aaca54f40c7a5b2e64d8" translate="yes" xml:space="preserve">
          <source>Name of schema containing table</source>
          <target state="translated">테이블을 포함하는 스키마 이름</target>
        </trans-unit>
        <trans-unit id="dd40e81316e76702c45608033ccb5e0f85f3dfea" translate="yes" xml:space="preserve">
          <source>Name of schema containing table and index</source>
          <target state="translated">테이블 및 인덱스를 포함하는 스키마 이름</target>
        </trans-unit>
        <trans-unit id="b025c1d95310dde444c37ad986883a8dee5bb9d3" translate="yes" xml:space="preserve">
          <source>Name of schema containing table policy is on</source>
          <target state="translated">테이블 정책을 포함하는 스키마 이름이 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="651e03eac67fc05e08a5fc3c4b0db8b8a5ca2d70" translate="yes" xml:space="preserve">
          <source>Name of schema containing view</source>
          <target state="translated">뷰를 포함하는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="fd465cc8a117f3266eab848066483930a22454ae" translate="yes" xml:space="preserve">
          <source>Name of sequence</source>
          <target state="translated">시퀀스 이름</target>
        </trans-unit>
        <trans-unit id="f8e19bb0d7e02e23ea651a2fbd412be10bd907ea" translate="yes" xml:space="preserve">
          <source>Name of sequence's owner</source>
          <target state="translated">시퀀스 소유자의 이름</target>
        </trans-unit>
        <trans-unit id="2c617ffcb7fc75270eec292d65c4160eff374b06" translate="yes" xml:space="preserve">
          <source>Name of table</source>
          <target state="translated">테이블 이름</target>
        </trans-unit>
        <trans-unit id="f10df6f392a1568c4d43e34377ec16b2f3a7fa44" translate="yes" xml:space="preserve">
          <source>Name of table policy is on</source>
          <target state="translated">테이블 정책 이름이 켜져 있습니다</target>
        </trans-unit>
        <trans-unit id="c0513b8ba01d1af1c795daf01358ee55cf3296c9" translate="yes" xml:space="preserve">
          <source>Name of table the index is for</source>
          <target state="translated">인덱스가있는 테이블의 이름</target>
        </trans-unit>
        <trans-unit id="d795c0056cb1fd8b2838b400cf90a77a5b34f1c7" translate="yes" xml:space="preserve">
          <source>Name of table the rule is for</source>
          <target state="translated">규칙이 적용되는 테이블 이름</target>
        </trans-unit>
        <trans-unit id="6f44460598242d440e308c5206bbdd4ee6c15df5" translate="yes" xml:space="preserve">
          <source>Name of table's owner</source>
          <target state="translated">테이블 소유자의 이름</target>
        </trans-unit>
        <trans-unit id="cc73fa216f99d868d036ec5fa8be32ea593b2352" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing index (null if default for database)</source>
          <target state="translated">인덱스를 포함하는 테이블 스페이스의 이름 (데이터베이스의 기본값 인 경우 널임)</target>
        </trans-unit>
        <trans-unit id="13a740701fe416ff32d444b4b9dea241f97f8406" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing materialized view (null if default for database)</source>
          <target state="translated">구체화 된 뷰를 포함하는 테이블 스페이스의 이름 (데이터베이스에 대한 기본값 인 경우 널임)</target>
        </trans-unit>
        <trans-unit id="e235059f85c95c9cf0964b16c38689bf7ab5f960" translate="yes" xml:space="preserve">
          <source>Name of tablespace containing table (null if default for database)</source>
          <target state="translated">테이블을 포함하는 테이블 스페이스의 이름 (데이터베이스의 기본값 인 경우 널임)</target>
        </trans-unit>
        <trans-unit id="38df58659a85a8c6be97b9180f6ba3a3db8fd801" translate="yes" xml:space="preserve">
          <source>Name of the SLRU</source>
          <target state="translated">SLRU의 이름</target>
        </trans-unit>
        <trans-unit id="b950b20317e5d48a4d7180b3b67b23925387d954" translate="yes" xml:space="preserve">
          <source>Name of the WAL file of the last failed archival operation</source>
          <target state="translated">마지막으로 실패한 보관 작업의 WAL 파일 이름</target>
        </trans-unit>
        <trans-unit id="50c7ff72173e6a33ac0f4b45d6945424b157e3f8" translate="yes" xml:space="preserve">
          <source>Name of the access method</source>
          <target state="translated">액세스 방법의 이름</target>
        </trans-unit>
        <trans-unit id="42336fd50699db80c8e30a44b238f551cdfe5e05" translate="yes" xml:space="preserve">
          <source>Name of the application that is connected to this WAL sender</source>
          <target state="translated">이 WAL 발신자에 연결된 응용 프로그램 이름</target>
        </trans-unit>
        <trans-unit id="73eb48e900d4da8e91ccec691048b06a84e20927" translate="yes" xml:space="preserve">
          <source>Name of the application that is connected to this backend</source>
          <target state="translated">이 백엔드에 연결된 애플리케이션의 이름</target>
        </trans-unit>
        <trans-unit id="e5622c8d744e74d58e5852a23ea1813374720ca0" translate="yes" xml:space="preserve">
          <source>Name of the column described by this row</source>
          <target state="translated">이 행에서 설명하는 열의 이름</target>
        </trans-unit>
        <trans-unit id="05582534113d6fd58f1c91cf719019de03349552" translate="yes" xml:space="preserve">
          <source>Name of the database in which the transaction was executed</source>
          <target state="translated">트랜잭션이 실행 된 데이터베이스의 이름</target>
        </trans-unit>
        <trans-unit id="3c046694c5a00d97ff6a1379659314bd6a78ef25" translate="yes" xml:space="preserve">
          <source>Name of the database this backend is connected to</source>
          <target state="translated">이 백엔드가 연결된 데이터베이스의 이름</target>
        </trans-unit>
        <trans-unit id="21b466dc28882ad5e606c7e29b3635f8046375c5" translate="yes" xml:space="preserve">
          <source>Name of the database to which this backend is connected.</source>
          <target state="translated">이 백엔드가 연결된 데이터베이스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a4b1ce5ff884a2efdb43d43a59c57f0b4fa4d401" translate="yes" xml:space="preserve">
          <source>Name of the event source for pg_ctl to use for logging to the event log when running as a Windows service. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;. Note that this only controls messages sent from pg_ctl itself; once started, the server will use the event source specified by its &lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt; parameter. Should the server fail very early in startup, before that parameter has been set, it might also log using the default event source name &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">Windows 서비스로 실행할 때 이벤트 로그에 로깅하는 데 사용할 pg_ctl의 이벤트 소스 이름. 기본값은 &lt;code&gt;PostgreSQL&lt;/code&gt; 입니다. 이것은 pg_ctl 자체에서 전송 된 메시지 만 제어합니다. 일단 시작되면, 서버는 &lt;a href=&quot;runtime-config-logging#GUC-EVENT-SOURCE&quot;&gt;event_source&lt;/a&gt; 매개 변수로 지정된 이벤트 소스를 사용합니다 . 서버가 시작 초기에 실패하면 해당 매개 변수를 설정하기 전에 기본 이벤트 소스 이름 &lt;code&gt;PostgreSQL&lt;/code&gt; 을 사용하여 로그 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db2a8ab1c7a6e8e7352acea353746079da1e0da5" translate="yes" xml:space="preserve">
          <source>Name of the extension</source>
          <target state="translated">확장명</target>
        </trans-unit>
        <trans-unit id="b32842559bebdaa75c2073237260c49768556ba4" translate="yes" xml:space="preserve">
          <source>Name of the field to order siblings by (optional)</source>
          <target state="translated">형제를 주문할 필드 이름 (선택 사항)</target>
        </trans-unit>
        <trans-unit id="d305530c62c0c372c9b705ff8915012e6f1258b2" translate="yes" xml:space="preserve">
          <source>Name of the foreign server</source>
          <target state="translated">외부 서버의 이름</target>
        </trans-unit>
        <trans-unit id="59348747feca44834dd28cf94d333b16c8cfbbf0" translate="yes" xml:space="preserve">
          <source>Name of the foreign-data wrapper</source>
          <target state="translated">외부 데이터 랩퍼의 이름</target>
        </trans-unit>
        <trans-unit id="9e20c57335eda37ac38552a55cb17fe874d8fb6b" translate="yes" xml:space="preserve">
          <source>Name of the function</source>
          <target state="translated">기능의 이름</target>
        </trans-unit>
        <trans-unit id="eee39eba3634db32e7cb3a66942216268c13c704" translate="yes" xml:space="preserve">
          <source>Name of the group</source>
          <target state="translated">그룹 이름</target>
        </trans-unit>
        <trans-unit id="e6e050c906fd9fbc0c7b4d3a235e25d068290256" translate="yes" xml:space="preserve">
          <source>Name of the key field</source>
          <target state="translated">키 필드의 이름</target>
        </trans-unit>
        <trans-unit id="b217fce5b600ff5e59a7bde206ff84c6743ebd06" translate="yes" xml:space="preserve">
          <source>Name of the language</source>
          <target state="translated">언어의 이름</target>
        </trans-unit>
        <trans-unit id="999d13acc30868afb96a2061f85f8cfbf835af9a" translate="yes" xml:space="preserve">
          <source>Name of the language this template is for</source>
          <target state="translated">이 템플릿의 언어 이름</target>
        </trans-unit>
        <trans-unit id="c0904d4653e24f5cf40ca0e66167033212dff01e" translate="yes" xml:space="preserve">
          <source>Name of the last WAL file successfully archived</source>
          <target state="translated">성공적으로 아카이브 된 마지막 WAL 파일의 이름</target>
        </trans-unit>
        <trans-unit id="632030382b37c4353da7f8cfd3fb10f03fb4878e" translate="yes" xml:space="preserve">
          <source>Name of the local user to be mapped</source>
          <target state="translated">매핑 할 로컬 사용자의 이름</target>
        </trans-unit>
        <trans-unit id="3283788f7750678653d33179d0a9b570a3fb07a0" translate="yes" xml:space="preserve">
          <source>Name of the lock mode held or desired by this process (see &lt;a href=&quot;explicit-locking#LOCKING-TABLES&quot;&gt;Section 13.3.1&lt;/a&gt; and &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt;)</source>
          <target state="translated">이 프로세스에서 보유하거나 원하는 잠금 모드 이름 ( &lt;a href=&quot;explicit-locking#LOCKING-TABLES&quot;&gt;섹션 13.3.1&lt;/a&gt; 및 &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;섹션 13.2.3 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="bca4b201210cb86555d12a73e7fa1d0df2b4ce1d" translate="yes" xml:space="preserve">
          <source>Name of the namespace</source>
          <target state="translated">네임 스페이스의 이름</target>
        </trans-unit>
        <trans-unit id="116ede6679101b358b013bfe3778515f6a6eb59a" translate="yes" xml:space="preserve">
          <source>Name of the notification channel to be signaled (any identifier).</source>
          <target state="translated">신호를 보낼 알림 채널의 이름 (모든 식별자).</target>
        </trans-unit>
        <trans-unit id="b1846b8dfbb275c5d01dbe581ad89ecd8bd17f99" translate="yes" xml:space="preserve">
          <source>Name of the on-disk file of this relation; zero means this is a &amp;ldquo;mapped&amp;rdquo; relation whose disk file name is determined by low-level state</source>
          <target state="translated">이 관계의 디스크 파일 이름. 0은 디스크 파일 이름이 하위 레벨 상태에 의해 결정되는 &quot;매핑 된&quot;관계임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ffd1b3d5baf3902d7d64e922601a9c11dc846fd8" translate="yes" xml:space="preserve">
          <source>Name of the operator</source>
          <target state="translated">운영자 이름</target>
        </trans-unit>
        <trans-unit id="f362cae832a0a92cf6859f4e3035227030a3fa7e" translate="yes" xml:space="preserve">
          <source>Name of the parent-key field</source>
          <target state="translated">부모 키 필드의 이름</target>
        </trans-unit>
        <trans-unit id="914386f36015301aa42cdc85d2971f37bbd3f6e1" translate="yes" xml:space="preserve">
          <source>Name of the publication</source>
          <target state="translated">출판물의 이름</target>
        </trans-unit>
        <trans-unit id="f8ba7366e5638b5adb85cf058a4f60fc77a1437d" translate="yes" xml:space="preserve">
          <source>Name of the replication slot in the upstream database (also used for the local replication origin name); null represents &lt;code&gt;NONE&lt;/code&gt;</source>
          <target state="translated">업스트림 데이터베이스의 복제 슬롯 이름 (로컬 복제 원본 이름에도 사용됨) null은 &lt;code&gt;NONE&lt;/code&gt; 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="95141217167b4e44530e9c633ef9691ad9e4c7d5" translate="yes" xml:space="preserve">
          <source>Name of the replication slot in the upstream database. Also used for local replication origin name.</source>
          <target state="translated">업스트림 데이터베이스의 복제 슬롯 이름 로컬 복제 오리진 이름에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="48b6dcd7b3f9b0cceabe3c942a0ff0d053cf3051" translate="yes" xml:space="preserve">
          <source>Name of the replication slot to use. The default behavior is to use the name of the subscription for the slot name.</source>
          <target state="translated">사용할 복제 슬롯의 이름입니다. 기본 동작은 슬롯 이름에 구독 이름을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0c22c3cdbc7df0d29a30ef0e5d20c6d53a22aba3" translate="yes" xml:space="preserve">
          <source>Name of the schema that the extension must be installed into, or &lt;code&gt;NULL&lt;/code&gt; if partially or fully relocatable</source>
          <target state="translated">확장을 설치해야하는 스키마 이름 또는 부분적으로 또는 완전히 재배치 가능한 경우 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46b2c8652132c7dc1c02610fe232f22c32a70e49" translate="yes" xml:space="preserve">
          <source>Name of the schema that this table is in</source>
          <target state="translated">이 테이블이있는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="aeed8d4431144cabd5a1127005bce646d16cab11" translate="yes" xml:space="preserve">
          <source>Name of the schema this function is in</source>
          <target state="translated">이 함수가 속한 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="b11dd1fd926881e2c689b2ce026036d1c6bf66aa" translate="yes" xml:space="preserve">
          <source>Name of the schema this index is in</source>
          <target state="translated">이 인덱스가있는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="55e1e35ee330306af1edafba8c0ccceb0641d202" translate="yes" xml:space="preserve">
          <source>Name of the schema this sequence is in</source>
          <target state="translated">이 순서가있는 스키마의 이름</target>
        </trans-unit>
        <trans-unit id="d75b4d0b583232f5341524b6ac4e00946212dc64" translate="yes" xml:space="preserve">
          <source>Name of the source relation</source>
          <target state="translated">소스 관계의 이름</target>
        </trans-unit>
        <trans-unit id="02fe646b94a9a3942519f9c9b3db9e92f9c9c3fd" translate="yes" xml:space="preserve">
          <source>Name of the statistics object</source>
          <target state="translated">통계 개체의 이름</target>
        </trans-unit>
        <trans-unit id="33574f9c61c2e627eb0d3d0f3da70a170678a9ff" translate="yes" xml:space="preserve">
          <source>Name of the subscription</source>
          <target state="translated">구독 이름</target>
        </trans-unit>
        <trans-unit id="90ae080c0a5fc808f5e0a7e8b8cae579504b16d5" translate="yes" xml:space="preserve">
          <source>Name of the system service to register. This name will be used as both the service name and the display name. The default is &lt;code&gt;PostgreSQL&lt;/code&gt;.</source>
          <target state="translated">등록 할 시스템 서비스의 이름입니다. 이 이름은 서비스 이름과 표시 이름으로 사용됩니다. 기본값은 &lt;code&gt;PostgreSQL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f5e271781547e2a1e2376a48974f2d9fab48cde2" translate="yes" xml:space="preserve">
          <source>Name of the table for this index</source>
          <target state="translated">이 인덱스의 테이블 이름</target>
        </trans-unit>
        <trans-unit id="0200e1f7b3df494bd305d84c497873916f941937" translate="yes" xml:space="preserve">
          <source>Name of the table, index, view, etc.</source>
          <target state="translated">테이블 이름, 인덱스, 뷰 등</target>
        </trans-unit>
        <trans-unit id="a1f59b4d65687dc8fe0a85f1b74351b10bfba7a6" translate="yes" xml:space="preserve">
          <source>Name of the user logged into this WAL sender process</source>
          <target state="translated">이 WAL 발신자 프로세스에 로그인 한 사용자 이름</target>
        </trans-unit>
        <trans-unit id="3fe80a85bf2161f51d9c08098d7bfcdedce6c9ee" translate="yes" xml:space="preserve">
          <source>Name of the user logged into this backend</source>
          <target state="translated">이 백엔드에 로그인 한 사용자 이름</target>
        </trans-unit>
        <trans-unit id="04f7b7b315d382679587d80fba309d2bb70b1345" translate="yes" xml:space="preserve">
          <source>Name of the user that executed the transaction</source>
          <target state="translated">트랜잭션을 실행 한 사용자의 이름</target>
        </trans-unit>
        <trans-unit id="c24f99aa0c8caf23a96b75cece5098629fd6a94e" translate="yes" xml:space="preserve">
          <source>Name of this database</source>
          <target state="translated">이 데이터베이스의 이름</target>
        </trans-unit>
        <trans-unit id="2086d14cece3b039e0a515f48cc92518784c4d7a" translate="yes" xml:space="preserve">
          <source>Name of this database, or &lt;code&gt;NULL&lt;/code&gt; for shared objects.</source>
          <target state="translated">이 데이터베이스의 이름 또는 공유 객체의 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="73d6411e8bd4b74b577e7365540cb543464ed926" translate="yes" xml:space="preserve">
          <source>Name of this database, or &lt;code&gt;NULL&lt;/code&gt; for the shared objects.</source>
          <target state="translated">이 데이터베이스의 이름이거나 공유 객체의 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09edc4fe28078a94e956caa9447364b4707b6491" translate="yes" xml:space="preserve">
          <source>Name of this function</source>
          <target state="translated">이 기능의 이름</target>
        </trans-unit>
        <trans-unit id="a2e0e5204a994c27fb6b9e0e825c613dd1c4755e" translate="yes" xml:space="preserve">
          <source>Name of this index</source>
          <target state="translated">이 인덱스의 이름</target>
        </trans-unit>
        <trans-unit id="52256e99af10a92f8d2567b55a83d56fe82e813a" translate="yes" xml:space="preserve">
          <source>Name of this operator class</source>
          <target state="translated">이 연산자 클래스의 이름</target>
        </trans-unit>
        <trans-unit id="8660634803fb7c50b11c80dde370467806dff8e0" translate="yes" xml:space="preserve">
          <source>Name of this operator family</source>
          <target state="translated">이 운영자 제품군의 이름</target>
        </trans-unit>
        <trans-unit id="67e86bea4f13cfb5fdec580a24af26d2de2fdc44" translate="yes" xml:space="preserve">
          <source>Name of this sequence</source>
          <target state="translated">이 순서의 이름</target>
        </trans-unit>
        <trans-unit id="b490c1221b4b64551bfddc6b8b9c77d0ea3870a9" translate="yes" xml:space="preserve">
          <source>Name of this table</source>
          <target state="translated">이 테이블의 이름</target>
        </trans-unit>
        <trans-unit id="79333580b15aa0175b731014d71be95e862ff44a" translate="yes" xml:space="preserve">
          <source>Name of validator function, or null if none</source>
          <target state="translated">유효성 검사기 함수의 이름 또는없는 경우 null</target>
        </trans-unit>
        <trans-unit id="d340979d7f1712dd54645083825a2794537380b7" translate="yes" xml:space="preserve">
          <source>Name of view</source>
          <target state="translated">보기의 이름</target>
        </trans-unit>
        <trans-unit id="ca9987204d1e0d3bf0d8020ca5eccf2de116a77a" translate="yes" xml:space="preserve">
          <source>Name of view's owner</source>
          <target state="translated">뷰 소유자의 이름</target>
        </trans-unit>
        <trans-unit id="715cd77a48eca5f7bbf90153374438716221cbe4" translate="yes" xml:space="preserve">
          <source>Named and mixed call notations currently cannot be used when calling an aggregate function (but they do work when an aggregate function is used as a window function).</source>
          <target state="translated">집계 함수를 호출 할 때는 현재 이름이 지정된 혼합 호출 표기법을 사용할 수 없습니다 (단, 집계 함수가 창 함수로 사용될 때는 작동합니다).</target>
        </trans-unit>
        <trans-unit id="febb13b6b6bedee695a2cdffc8584795987df071" translate="yes" xml:space="preserve">
          <source>Named run-time parameters can be set in either of these styles:</source>
          <target state="translated">명명 된 런타임 매개 변수는 다음 스타일 중 하나로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b335beb0e29ec02f76a030301ce30aec55d10a00" translate="yes" xml:space="preserve">
          <source>Names can be assigned to table constraints in the same way as column constraints:</source>
          <target state="translated">열 제약 조건과 같은 방식으로 테이블 제약 조건에 이름을 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90e76064cba28bce291e20a00492ac8908ed2815" translate="yes" xml:space="preserve">
          <source>Names of prerequisite extensions, or &lt;code&gt;NULL&lt;/code&gt; if none</source>
          <target state="translated">전제 조건 확장명 또는 없는 경우 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="879c37a97f04ee34ad69a53c4aa464879102ff50" translate="yes" xml:space="preserve">
          <source>Names of the columns the extended statistics is defined on</source>
          <target state="translated">확장 통계가 정의 된 열의 이름</target>
        </trans-unit>
        <trans-unit id="774a71278e16cec9ccf959b5bab94713611e399e" translate="yes" xml:space="preserve">
          <source>Names of the publications on the publisher to subscribe to.</source>
          <target state="translated">구독 할 발행인의 발행물 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ef2014703004a1217b3fec5210db4117b70e51de" translate="yes" xml:space="preserve">
          <source>Names or IP addresses of LDAP servers to connect to. Multiple servers may be specified, separated by spaces.</source>
          <target state="translated">연결할 LDAP 서버의 이름 또는 IP 주소입니다. 공백으로 구분하여 여러 서버를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f95be766c8568501a000e46e6894d04ef9f8877" translate="yes" xml:space="preserve">
          <source>Namespace Available to &lt;code&gt;GROUP BY&lt;/code&gt; and &lt;code&gt;ORDER BY&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;GROUP BY&lt;/code&gt; 및 &lt;code&gt;ORDER BY&lt;/code&gt; 에 사용 가능한 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="47230dc537dc21987e746d4c719b4cc41ae69b6a" translate="yes" xml:space="preserve">
          <source>Namespace of this operator class</source>
          <target state="translated">이 연산자 클래스의 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="a230663970531d46658f671326f61bad6755f192" translate="yes" xml:space="preserve">
          <source>Namespace of this operator family</source>
          <target state="translated">이 연산자 제품군의 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="a1c428db5a690b5f5a2a8bbbdfae45bd49175ad0" translate="yes" xml:space="preserve">
          <source>National Language Support</source>
          <target state="translated">자국어 지원</target>
        </trans-unit>
        <trans-unit id="725efb9e43acf1bf580c09d2cb1b0cf911451468" translate="yes" xml:space="preserve">
          <source>National Standard</source>
          <target state="translated">국가 표준</target>
        </trans-unit>
        <trans-unit id="9d1f7ad08bfbe66715ad20935eced5ce9dc0eb67" translate="yes" xml:space="preserve">
          <source>Natural logarithm</source>
          <target state="translated">자연 로그</target>
        </trans-unit>
        <trans-unit id="a9c36a47f8e482a64ff81cd9e84619cb8413e09b" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to argument</source>
          <target state="translated">인수보다 크거나 같은 가장 가까운 정수</target>
        </trans-unit>
        <trans-unit id="68c2729e4aa8267e02a5e14878260b805c76e4f0" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to argument (same as &lt;code&gt;ceil&lt;/code&gt;)</source>
          <target state="translated">인수보다 크거나 같은 가장 가까운 정수 ( &lt;code&gt;ceil&lt;/code&gt; 과 동일 )</target>
        </trans-unit>
        <trans-unit id="333e55744c1836d8e2f747a46f8a58bd387549f7" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to the SQL/JSON number</source>
          <target state="translated">SQL / JSON 수보다 크거나 같은 가장 가까운 정수</target>
        </trans-unit>
        <trans-unit id="3089188f4ef21fadc5a7ae8a8917660ce59f776c" translate="yes" xml:space="preserve">
          <source>Nearest integer greater than or equal to the given number</source>
          <target state="translated">주어진 숫자보다 크거나 같은 가장 가까운 정수</target>
        </trans-unit>
        <trans-unit id="ebc0f09f7738d16783cda39dfae33946b8073a87" translate="yes" xml:space="preserve">
          <source>Nearest integer less than or equal to argument</source>
          <target state="translated">인수보다 작거나 같은 가장 가까운 정수</target>
        </trans-unit>
        <trans-unit id="bee672459bc21a36f5d885e59227b9978e9d1866" translate="yes" xml:space="preserve">
          <source>Nearest integer less than or equal to the SQL/JSON number</source>
          <target state="translated">SQL / JSON 수 이하의 가장 가까운 정수</target>
        </trans-unit>
        <trans-unit id="6a166687429ef42663b71e2fae4f0d6dcf7415c3" translate="yes" xml:space="preserve">
          <source>Nearest integer less than or equal to the given number</source>
          <target state="translated">주어진 숫자보다 작거나 같은 가장 가까운 정수</target>
        </trans-unit>
        <trans-unit id="8e224c76bc25e4149e084462adee5b7564caac26" translate="yes" xml:space="preserve">
          <source>Needless to say, processing XML data with PostgreSQL will be less error-prone and more efficient if the XML data encoding, client encoding, and server encoding are the same. Since XML data is internally processed in UTF-8, computations will be most efficient if the server encoding is also UTF-8.</source>
          <target state="translated">말할 것도없이, PostgreSQL로 XML 데이터를 처리하는 것은 XML 데이터 인코딩, 클라이언트 인코딩 및 서버 인코딩이 동일한 경우 오류가 적고 효율적입니다. XML 데이터는 내부적으로 UTF-8로 처리되므로 서버 인코딩도 UTF-8 인 경우 계산이 가장 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="dfc508fa9ddaeb33e233aa812ebad0ab8c049dd2" translate="yes" xml:space="preserve">
          <source>Negate an interval</source>
          <target state="translated">간격 부정</target>
        </trans-unit>
        <trans-unit id="1b33f9b7a0a4606b4bd747722b21501d99fa70ad" translate="yes" xml:space="preserve">
          <source>Negates a &lt;code&gt;tsquery&lt;/code&gt;, producing a query that matches documents that do not match the input query.</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; 를 부정 하여 입력 쿼리와 일치하지 않는 문서와 일치하는 쿼리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="24048c04eba343a323fecac37d642445c66f6c28" translate="yes" xml:space="preserve">
          <source>Negation</source>
          <target state="translated">Negation</target>
        </trans-unit>
        <trans-unit id="192f6939bf2bfe49ee33bf49687c9297f6c0972d" translate="yes" xml:space="preserve">
          <source>Negation; unlike subtraction, this can iterate over multiple values</source>
          <target state="translated">부정; 빼기와 달리 여러 값을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27cadf6ca95971ac3dd5c11e621924026c16209f" translate="yes" xml:space="preserve">
          <source>Negator of this operator, if any</source>
          <target state="translated">이 연산자의 부정 자 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="cdedd7a3e12a28ecdae254105845f04dc8b7e221" translate="yes" xml:space="preserve">
          <source>Neither sequential scans nor nested-loop joins can be disabled completely; the &lt;code&gt;-fs&lt;/code&gt; and &lt;code&gt;-fn&lt;/code&gt; options simply discourage the optimizer from using those plan types if it has any other alternative.</source>
          <target state="translated">순차적 스캔이나 중첩 루프 조인을 완전히 비활성화 할 수는 없습니다. &lt;code&gt;-fs&lt;/code&gt; 과 &lt;code&gt;-fn&lt;/code&gt; 옵션은 단순히 다른 대안이있는 경우 그 계획 유형을 사용하여 최적화 알고리즘을 억제.</target>
        </trans-unit>
        <trans-unit id="999497fbc59b4c8badf88b3dddf684b5320af0cd" translate="yes" xml:space="preserve">
          <source>Neither the source nor the destination encoding can be &lt;code&gt;SQL_ASCII&lt;/code&gt;, as the server's behavior for cases involving the &lt;code&gt;SQL_ASCII&lt;/code&gt;&amp;ldquo;encoding&amp;rdquo; is hard-wired.</source>
          <target state="translated">&lt;code&gt;SQL_ASCII&lt;/code&gt; &quot;인코딩&quot; 과 관련된 경우에 대한 서버의 동작 이 &lt;code&gt;SQL_ASCII&lt;/code&gt; 되어 있으므로 소스 인코딩과 대상 인코딩 모두 SQL_ASCII 가 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="dc249089e46e70234a72d288cf1c8de145f74bd2" translate="yes" xml:space="preserve">
          <source>Neither timezone names nor abbreviations are hard-wired into the server; they are obtained from configuration files stored under &lt;code&gt;.../share/timezone/&lt;/code&gt; and &lt;code&gt;.../share/timezonesets/&lt;/code&gt; of the installation directory (see &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt;).</source>
          <target state="translated">시간대 이름이나 약어는 서버에 연결되지 않습니다. 설치 디렉토리의 &lt;code&gt;.../share/timezone/&lt;/code&gt; 및 &lt;code&gt;.../share/timezonesets/&lt;/code&gt; 아래에 저장된 구성 파일에서 얻습니다 ( &lt;a href=&quot;datetime-config-files&quot;&gt;섹션 B.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3e9e1f6f189ff8e4d505c81b54a796d5e66a2542" translate="yes" xml:space="preserve">
          <source>NetBSD</source>
          <target state="translated">NetBSD</target>
        </trans-unit>
        <trans-unit id="8d546e29b4f4fdcb009106a5c128188e2431946d" translate="yes" xml:space="preserve">
          <source>NetBSD versions before 5.0 work like old OpenBSD (see below), except that kernel parameters should be set with the keyword &lt;code&gt;options&lt;/code&gt; not &lt;code&gt;option&lt;/code&gt;.</source>
          <target state="translated">5.0 이전의 NetBSD 버전은 이전 OpenBSD처럼 작동하지만 (아래 참조) 커널 매개 변수는 키워드 &lt;code&gt;options&lt;/code&gt; not &lt;code&gt;option&lt;/code&gt; 사용하여 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4970c28f364d041c28f5d5ff2bc88daf1a13ad01" translate="yes" xml:space="preserve">
          <source>Network Address Types</source>
          <target state="translated">네트워크 주소 유형</target>
        </trans-unit>
        <trans-unit id="1aab162fb1d4be431f43c575684b7d8c545c8302" translate="yes" xml:space="preserve">
          <source>Network Address Types: cidr</source>
          <target state="translated">네트워크 주소 유형 : cidr</target>
        </trans-unit>
        <trans-unit id="a0a4631210875f94aba2f16fc813f4614e393764" translate="yes" xml:space="preserve">
          <source>Network Address Types: inet</source>
          <target state="translated">네트워크 주소 유형 : inet</target>
        </trans-unit>
        <trans-unit id="341da3e8cf1498f3f62648168d4190e67f278782" translate="yes" xml:space="preserve">
          <source>Network Address Types: macaddr</source>
          <target state="translated">네트워크 주소 유형 : macaddr</target>
        </trans-unit>
        <trans-unit id="81bbd3c87492587fd7ddfed55118e840abffce9f" translate="yes" xml:space="preserve">
          <source>Network Address Types: macaddr8</source>
          <target state="translated">네트워크 주소 유형 : macaddr8</target>
        </trans-unit>
        <trans-unit id="c5f17a43f889ac0d89795d00fba1671fe47f62f0" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;amp;</source>
          <target state="translated">네트워크 주소: &amp;amp;</target>
        </trans-unit>
        <trans-unit id="3182c01748d8a83efe78a3f4ab6c4e990eacea0c" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;amp;&amp;amp;</source>
          <target state="translated">네트워크 주소: &amp;amp;&amp;amp;</target>
        </trans-unit>
        <trans-unit id="c32091a6107e7e44a68fb436fb33982336ccc452" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;</source>
          <target state="translated">네트워크 주소 :&amp;gt;</target>
        </trans-unit>
        <trans-unit id="86a00c20e3381c9260f079dcb6e41c4262f1ea3a" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;&amp;gt;</source>
          <target state="translated">네트워크 주소 : &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f3736d0bb3a030e00d7114ef9030a0916af6881f" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;&amp;gt;=</source>
          <target state="translated">네트워크 주소 : &amp;gt;&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="b6a612c0f5ca1e234f11a6f50c9a9f41342ace58" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;gt;=</source>
          <target state="translated">네트워크 주소 :&amp;gt; =</target>
        </trans-unit>
        <trans-unit id="0cab881598e19094a73fe2cb680ef2e7600ff52c" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;</source>
          <target state="translated">네트워크 주소 : &amp;lt;</target>
        </trans-unit>
        <trans-unit id="a2a64bdcd407fdda5883dcb3954eb4988b1bf440" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;gt;</source>
          <target state="translated">네트워크 주소 : &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e00740580248e58ab92c3eb2672f19b765c748b0" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;lt;</source>
          <target state="translated">네트워크 주소 : &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1ff901142c2068fe8cf464afe26c9042106af748" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;&amp;lt;=</source>
          <target state="translated">네트워크 주소 : &amp;lt;&amp;lt; =</target>
        </trans-unit>
        <trans-unit id="68fb0bbbf4bee491f6e6bbc78cee804b2462e684" translate="yes" xml:space="preserve">
          <source>Network Address: &amp;lt;=</source>
          <target state="translated">네트워크 주소 : &amp;lt;=</target>
        </trans-unit>
        <trans-unit id="6b9e98c353b63977350c4597ab783ed68802ee56" translate="yes" xml:space="preserve">
          <source>Network Address: +</source>
          <target state="translated">네트워크 주소 : +</target>
        </trans-unit>
        <trans-unit id="39dd97c5cafd7589b71c3638f6bb1482a7b84d8f" translate="yes" xml:space="preserve">
          <source>Network Address: -</source>
          <target state="translated">네트워크 주소: -</target>
        </trans-unit>
        <trans-unit id="777f2ecef47fe73d67412a0b49eb5b48a584a4d2" translate="yes" xml:space="preserve">
          <source>Network Address: 200 + inet &amp;#x27;::ffff:fff0:1&amp;#x27;</source>
          <target state="translated">네트워크 주소 : 200 + inet ':: ffff : fff0 : 1'</target>
        </trans-unit>
        <trans-unit id="4b124004ce04609acad1c95336f7a76fcba56d8c" translate="yes" xml:space="preserve">
          <source>Network Address: 4</source>
          <target state="translated">네트워크 주소 : 4</target>
        </trans-unit>
        <trans-unit id="b43debcb1e648bae4f59d9ad9d57421aa61da314" translate="yes" xml:space="preserve">
          <source>Network Address: =</source>
          <target state="translated">네트워크 주소 : =</target>
        </trans-unit>
        <trans-unit id="f6da4644273b4e1c84158d7bdc34944932533ec4" translate="yes" xml:space="preserve">
          <source>Network Address: abbrev</source>
          <target state="translated">네트워크 주소 : abbrev</target>
        </trans-unit>
        <trans-unit id="c0aa9d1b8f2a11dc8e2d5492bfd563df5e51a186" translate="yes" xml:space="preserve">
          <source>Network Address: broadcast</source>
          <target state="translated">네트워크 주소 : 방송</target>
        </trans-unit>
        <trans-unit id="22c496032e898e93c86c9e0b2d1794774c6cc3b0" translate="yes" xml:space="preserve">
          <source>Network Address: family</source>
          <target state="translated">네트워크 주소 : family</target>
        </trans-unit>
        <trans-unit id="6144652f94deb193ec23e96153e939af827c258d" translate="yes" xml:space="preserve">
          <source>Network Address: host</source>
          <target state="translated">네트워크 주소 : 호스트</target>
        </trans-unit>
        <trans-unit id="60b63d4c005ed64503064242e41d8bfa685a802b" translate="yes" xml:space="preserve">
          <source>Network Address: hostmask</source>
          <target state="translated">네트워크 주소 : hostmask</target>
        </trans-unit>
        <trans-unit id="ed88700d6440e7a05db8038b5e1ae51130f83f6c" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.0.5&amp;#x27; &amp;lt;&amp;lt; inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="translated">네트워크 주소 : inet '192.168.0.5'&amp;lt;&amp;lt; inet '192.168.1 / 24'</target>
        </trans-unit>
        <trans-unit id="0f03ec2774c64bbb3436fa6566e034e58c68aaf6" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.43&amp;#x27; - 36</source>
          <target state="translated">네트워크 주소 : inet '192.168.1.43'-36</target>
        </trans-unit>
        <trans-unit id="6cd543dd857eb909c7c1f144d1c68cc26ed17c84" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.43&amp;#x27; - inet &amp;#x27;192.168.1.19&amp;#x27;</source>
          <target state="translated">네트워크 주소 : inet '192.168.1.43'-inet '192.168.1.19'</target>
        </trans-unit>
        <trans-unit id="cba4aae2f54763673ad24c08605a0dc7418f7e69" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.5&amp;#x27; &amp;lt;&amp;lt; inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="translated">네트워크 주소 : inet '192.168.1.5'&amp;lt;&amp;lt; inet '192.168.1 / 24'</target>
        </trans-unit>
        <trans-unit id="bf25351bf5e670090a9a613676ffca0130707992" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.6&amp;#x27; &amp;amp; inet &amp;#x27;0.0.0.255&amp;#x27;</source>
          <target state="translated">네트워크 주소 : inet '192.168.1.6'및 inet '0.0.0.255'</target>
        </trans-unit>
        <trans-unit id="bb861d30d1aca8b8d63e37fc34ab35aac460d1f8" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.6&amp;#x27; + 25</source>
          <target state="translated">네트워크 주소 : inet '192.168.1.6'+ 25</target>
        </trans-unit>
        <trans-unit id="47709a664ccb6f4f20ab0bedea8e5350679a1107" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1.6&amp;#x27; | inet &amp;#x27;0.0.0.255&amp;#x27;</source>
          <target state="translated">네트워크 주소 : inet '192.168.1.6'| inet '0.0.0.255'</target>
        </trans-unit>
        <trans-unit id="538a8494f874e1b3946b7a79168cf4b1aa49a99c" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;amp;&amp;amp; inet &amp;#x27;192.168.1.80/28&amp;#x27;</source>
          <target state="translated">네트워크 주소 : inet '192.168.1 / 24'&amp;amp;&amp;amp; inet '192.168.1.80/28'</target>
        </trans-unit>
        <trans-unit id="b08083b1369b886565f8ea80c8058e2d3af87577" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;amp;&amp;amp; inet &amp;#x27;192.168.2.0/28&amp;#x27;</source>
          <target state="translated">네트워크 주소 : inet '192.168.1 / 24'&amp;amp;&amp;amp; inet '192.168.2.0/28'</target>
        </trans-unit>
        <trans-unit id="3b9c76f3500e47f384b3cac60e30dacdb3c47029" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;gt;&amp;gt; inet &amp;#x27;192.168.1.5&amp;#x27;</source>
          <target state="translated">네트워크 주소 : inet '192.168.1 / 24'&amp;gt;&amp;gt; inet '192.168.1.5'</target>
        </trans-unit>
        <trans-unit id="c5a7912881770eacd62ec019a35b786530ba8e82" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;gt;&amp;gt;= inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="translated">네트워크 주소 : inet '192.168.1 / 24'&amp;gt;&amp;gt; = inet '192.168.1 / 24'</target>
        </trans-unit>
        <trans-unit id="c3f515856eebe2d81a6af46f2f540cf2ea72af80" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;lt;&amp;lt; inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="translated">네트워크 주소 : inet '192.168.1 / 24'&amp;lt;&amp;lt; inet '192.168.1 / 24'</target>
        </trans-unit>
        <trans-unit id="f49b063066e4c4fbd3500c30f240ef74c750c98e" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;192.168.1/24&amp;#x27; &amp;lt;&amp;lt;= inet &amp;#x27;192.168.1/24&amp;#x27;</source>
          <target state="translated">네트워크 주소 : inet '192.168.1 / 24'&amp;lt;&amp;lt; = inet '192.168.1 / 24'</target>
        </trans-unit>
        <trans-unit id="2e5e1d3f81690c06565afe5ca9d8a5a94ccf4f70" translate="yes" xml:space="preserve">
          <source>Network Address: inet &amp;#x27;::1&amp;#x27; - inet &amp;#x27;::ffff:1&amp;#x27;</source>
          <target state="translated">네트워크 주소 : inet ':: 1'-inet ':: ffff : 1'</target>
        </trans-unit>
        <trans-unit id="d7c102cda170efbd5c926c080194943072fd0080" translate="yes" xml:space="preserve">
          <source>Network Address: inet_merge</source>
          <target state="translated">네트워크 주소 : inet_merge</target>
        </trans-unit>
        <trans-unit id="026b427d2abc32061f460f5004b1e92329b176c3" translate="yes" xml:space="preserve">
          <source>Network Address: inet_same_family</source>
          <target state="translated">네트워크 주소 : inet_same_family</target>
        </trans-unit>
        <trans-unit id="78246e2d890ea6d8b5a4e72ded75baf6bfea7473" translate="yes" xml:space="preserve">
          <source>Network Address: macaddr8_set7bit</source>
          <target state="translated">네트워크 주소 : macaddr8_set7bit</target>
        </trans-unit>
        <trans-unit id="1c089819bd8607b5f9a99695372b4e5df1ae11f3" translate="yes" xml:space="preserve">
          <source>Network Address: masklen</source>
          <target state="translated">네트워크 주소 : masklen</target>
        </trans-unit>
        <trans-unit id="e38c25828a5f421b05060a2505734c3b8ed3c4ff" translate="yes" xml:space="preserve">
          <source>Network Address: netmask</source>
          <target state="translated">네트워크 주소 : 넷 마스크</target>
        </trans-unit>
        <trans-unit id="9e08bb5a4ba97edb3516d3ee46ca743eed995918" translate="yes" xml:space="preserve">
          <source>Network Address: network</source>
          <target state="translated">네트워크 주소 : 네트워크</target>
        </trans-unit>
        <trans-unit id="e7c94e499362212c6e5807040cfed09039e1ec82" translate="yes" xml:space="preserve">
          <source>Network Address: set_masklen</source>
          <target state="translated">네트워크 주소 : set_masklen</target>
        </trans-unit>
        <trans-unit id="0ec1baf847c109f5d8cc27de72a96ec587a99682" translate="yes" xml:space="preserve">
          <source>Network Address: text</source>
          <target state="translated">네트워크 주소 : text</target>
        </trans-unit>
        <trans-unit id="221efaf6a0e58b3e7e632e503daaffa7a1a069d7" translate="yes" xml:space="preserve">
          <source>Network Address: trunc</source>
          <target state="translated">네트워크 주소 : trunc</target>
        </trans-unit>
        <trans-unit id="ab7cd2917681a96bc47067425beee2467a73704d" translate="yes" xml:space="preserve">
          <source>Network Address: |</source>
          <target state="translated">네트워크 주소 : |</target>
        </trans-unit>
        <trans-unit id="83814dd86a48a4c95e9a2274b66946fe0603b1c9" translate="yes" xml:space="preserve">
          <source>Network Address: ~</source>
          <target state="translated">네트워크 주소 : ~</target>
        </trans-unit>
        <trans-unit id="103c5dac467afa451157b604c5b1cc764cc21efb" translate="yes" xml:space="preserve">
          <source>Network Address: ~ inet &amp;#x27;192.168.1.6&amp;#x27;</source>
          <target state="translated">네트워크 주소 : ~ inet '192.168.1.6'</target>
        </trans-unit>
        <trans-unit id="0a2ec6319838e0ec218c4906d73f925465627945" translate="yes" xml:space="preserve">
          <source>Network address types</source>
          <target state="translated">네트워크 주소 유형</target>
        </trans-unit>
        <trans-unit id="424a86543035666947635d11018cbc54c86cb289" translate="yes" xml:space="preserve">
          <source>Never issue a password prompt. If the server requires password authentication and a password is not available by other means such as a &lt;code&gt;.pgpass&lt;/code&gt; file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</source>
          <target state="translated">비밀번호 프롬프트를 발행하지 마십시오. 서버에 비밀번호 인증이 필요하고 &lt;code&gt;.pgpass&lt;/code&gt; 파일 과 같은 다른 방법으로 비밀번호를 사용할 수없는 경우 연결 시도가 실패합니다. 이 옵션은 비밀번호를 입력 할 사용자가없는 배치 작업 및 스크립트에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9093e824038ec1b001eb89049bd2ea01904578a0" translate="yes" xml:space="preserve">
          <source>Never issue a password prompt. If the server requires password authentication and a password is not available from other sources such as a &lt;code&gt;.pgpass&lt;/code&gt; file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</source>
          <target state="translated">암호 프롬프트를 발행하지 마십시오. 서버에 암호 인증이 필요하고 &lt;code&gt;.pgpass&lt;/code&gt; 파일 과 같은 다른 소스에서 암호를 사용할 수없는 경우 연결 시도가 실패합니다. 이 옵션은 암호를 입력 할 사용자가없는 배치 작업 및 스크립트에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d783af92d40765554d538ccb5cb29b09817e84f6" translate="yes" xml:space="preserve">
          <source>New OIDs cannot be assigned, though some UUID generators may still work as long as they do not rely on writing new status to the database.</source>
          <target state="translated">새 UID를 할당 할 수는 없지만 일부 UUID 생성기는 데이터베이스에 새 상태를 작성하지 않는 한 여전히 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1599ff1bdbcb64919583d13e639c6bfaf051dfca" translate="yes" xml:space="preserve">
          <source>New aggregate functions are registered with the &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; command. See &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html&quot;&gt;Section 37.12&lt;/a&gt; for more information about writing aggregate functions and the meaning of the transition functions, etc.</source>
          <target state="translated">새로운 집계 함수는 &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; 명령으로 등록됩니다 . 집계 함수 작성 및 전이 함수의 의미 등에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html&quot;&gt;37.12 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5691f2234d0749ef354ef0f06ef7f16ccef71ffc" translate="yes" xml:space="preserve">
          <source>New aggregate functions are registered with the &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; command. See &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html&quot;&gt;Section 37.12&lt;/a&gt; for more information about writing aggregate functions and the meaning of the transition functions, etc.</source>
          <target state="translated">새 집계 함수는 &lt;a href=&quot;sql-createaggregate&quot;&gt;CREATE AGGREGATE&lt;/a&gt; 명령으로 등록됩니다 . 집계 함수 작성 및 전환 함수의 의미 등에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html&quot;&gt;섹션 37.12&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e31c4f5893b955e11ebf06d3912e5da97f70565f" translate="yes" xml:space="preserve">
          <source>New array values can also be constructed using the concatenation operator, &lt;code&gt;||&lt;/code&gt;:</source>
          <target state="translated">연결 연산자 &lt;code&gt;||&lt;/code&gt; 를 사용하여 새 배열 값을 구성 할 수도 있습니다. :</target>
        </trans-unit>
        <trans-unit id="98e5f0d308c976c18e3e4b7efffa4995977e2612" translate="yes" xml:space="preserve">
          <source>New domain constraint for the domain.</source>
          <target state="translated">도메인에 대한 새로운 도메인 제약.</target>
        </trans-unit>
        <trans-unit id="796d9d5ad0384fcde7a5cdd2291232f588f72876" translate="yes" xml:space="preserve">
          <source>New leaf pages are added to a B-Tree index when an existing leaf page cannot fit an incoming tuple. A &lt;em&gt;page split&lt;/em&gt; operation makes room for items that originally belonged on the overflowing page by moving a portion of the items to a new page. Page splits must also insert a new &lt;em&gt;downlink&lt;/em&gt; to the new page in the parent page, which may cause the parent to split in turn. Page splits &amp;ldquo;cascade upwards&amp;rdquo; in a recursive fashion. When the root page finally cannot fit a new downlink, a &lt;em&gt;root page split&lt;/em&gt; operation takes place. This adds a new level to the tree structure by creating a new root page that is one level above the original root page.</source>
          <target state="translated">기존 리프 페이지가 들어오는 튜플에 맞지 않을 때 새 리프 페이지가 B- 트리 인덱스에 추가됩니다. &lt;em&gt;페이지 분할&lt;/em&gt; 동작은 원래 새로운 페이지 항목의 일부를 이동시켜 넘쳐 페이지에 속한 아이템 공간을 만든다. 페이지 분할은 또한 상위 페이지의 새 페이지에 대한 새 &lt;em&gt;다운 링크&lt;/em&gt; 를 삽입해야 하므로 상위 페이지가 차례로 분할 될 수 있습니다. 페이지는 재귀 적 방식으로 &quot;위로 계단식&quot;으로 분할됩니다. 루트 페이지가 마침내 새 다운 링크에 맞지 않으면 &lt;em&gt;루트 페이지 분할&lt;/em&gt; 작업이 수행됩니다. 이렇게하면 원래 루트 페이지보다 한 수준 위에있는 새 루트 페이지를 만들어 트리 구조에 새 수준을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a12c3795c3d4f4819f76dadf3e557565c057892c" translate="yes" xml:space="preserve">
          <source>New libc collations can be created like this:</source>
          <target state="translated">다음과 같이 새 libc 데이터 정렬을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="650ded8d5d402f503baa0bc831171b9d8bc4272d" translate="yes" xml:space="preserve">
          <source>New major versions also typically introduce some user-visible incompatibilities, so application programming changes might be required. All user-visible changes are listed in the release notes (&lt;a href=&quot;https://www.postgresql.org/docs/12/release.html&quot;&gt;Appendix E&lt;/a&gt;); pay particular attention to the section labeled &quot;Migration&quot;. If you are upgrading across several major versions, be sure to read the release notes for each intervening version.</source>
          <target state="translated">새로운 메이저 버전은 또한 일반적으로 사용자가 볼 수있는 비 호환성을 도입하므로 애플리케이션 프로그래밍 변경이 필요할 수 있습니다. 모든 사용자가 볼 수있는 변경 사항은 릴리스 정보 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/release.html&quot;&gt;부록 E&lt;/a&gt; )에 나열되어 있습니다 . &quot;이주&quot;섹션에 특히주의하십시오. 여러 주요 버전에서 업그레이드하는 경우 각 중간 버전에 대한 릴리스 정보를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="48e034a875ce9ccd77246027f6e0993adbe610b3" translate="yes" xml:space="preserve">
          <source>New major versions also typically introduce some user-visible incompatibilities, so application programming changes might be required. All user-visible changes are listed in the release notes (&lt;a href=&quot;https://www.postgresql.org/docs/13/release.html&quot;&gt;Appendix E&lt;/a&gt;); pay particular attention to the section labeled &quot;Migration&quot;. If you are upgrading across several major versions, be sure to read the release notes for each intervening version.</source>
          <target state="translated">또한 새 주요 버전은 일반적으로 사용자가 볼 수있는 일부 비 호환성을 도입하므로 애플리케이션 프로그래밍 변경이 필요할 수 있습니다. 사용자가 볼 수있는 모든 변경 사항은 릴리스 정보 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/release.html&quot;&gt;부록 E&lt;/a&gt; )에 나열되어 있습니다 . &quot;마이그레이션&quot;이라고 표시된 섹션에 특히주의하십시오. 여러 주요 버전에서 업그레이드하는 경우 각 중간 버전에 대한 릴리스 정보를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="a56ea799e1817e77cfb14f705f9837d87da3531d" translate="yes" xml:space="preserve">
          <source>New name for an existing column.</source>
          <target state="translated">기존 열의 새로운 이름.</target>
        </trans-unit>
        <trans-unit id="b258c013a0b2baff94eb0ca18fab582791cfc317" translate="yes" xml:space="preserve">
          <source>New name for the table.</source>
          <target state="translated">테이블의 새로운 이름.</target>
        </trans-unit>
        <trans-unit id="e2584f9de9d6b68e373738ded405b0367bf25369" translate="yes" xml:space="preserve">
          <source>New probes can be defined within the code wherever the developer desires, though this will require a recompilation. Below are the steps for inserting new probes:</source>
          <target state="translated">개발자가 원하는 곳에서는 코드 내에서 새로운 프로브를 정의 할 수 있지만 재 컴파일이 필요합니다. 다음은 새 프로브를 삽입하는 단계입니다.</target>
        </trans-unit>
        <trans-unit id="9bb5261862459d4fc2f236436c680944b53b22bf" translate="yes" xml:space="preserve">
          <source>New row</source>
          <target state="translated">새로운 행</target>
        </trans-unit>
        <trans-unit id="b1955e711ad4344c38fc8ef166f89eecc1ca6dce" translate="yes" xml:space="preserve">
          <source>New row &lt;a href=&quot;#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup id=&quot;RLS-SELECT-PRIV&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">새 행 &lt;a href=&quot;#ftn.RLS-SELECT-PRIV&quot;&gt;&lt;sup id=&quot;RLS-SELECT-PRIV&quot;&gt;[a]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45bbeac915cddbd627fa355d4df5b9dbbc9336c8" translate="yes" xml:space="preserve">
          <source>New rows are checked against the conditions of the view and all underlying base views. If the &lt;code&gt;CHECK OPTION&lt;/code&gt; is specified, and neither &lt;code&gt;LOCAL&lt;/code&gt; nor &lt;code&gt;CASCADED&lt;/code&gt; is specified, then &lt;code&gt;CASCADED&lt;/code&gt; is assumed.</source>
          <target state="translated">새 행은 뷰의 조건과 모든 기본 뷰에 대해 점검됩니다. 는 IF &lt;code&gt;CHECK OPTION&lt;/code&gt; 지정하고,도 &lt;code&gt;LOCAL&lt;/code&gt; 도 &lt;code&gt;CASCADED&lt;/code&gt; 가 지정하면 &lt;code&gt;CASCADED&lt;/code&gt; 가정한다.</target>
        </trans-unit>
        <trans-unit id="08a4db17fa684c55666b397d42c621a7aaca8bcb" translate="yes" xml:space="preserve">
          <source>New rows are only checked against the conditions defined directly in the view itself. Any conditions defined on underlying base views are not checked (unless they also specify the &lt;code&gt;CHECK OPTION&lt;/code&gt;).</source>
          <target state="translated">새 행은보기 자체에 직접 정의 된 조건에 대해서만 점검됩니다. 기본 기준 뷰에 정의 된 모든 조건은 점검되지 않습니다 ( &lt;code&gt;CHECK OPTION&lt;/code&gt; 도 지정하지 않은 경우 ).</target>
        </trans-unit>
        <trans-unit id="0fffd55cc966a5c918570729a73087e9799e7b21" translate="yes" xml:space="preserve">
          <source>New server version.</source>
          <target state="translated">새로운 서버 버전.</target>
        </trans-unit>
        <trans-unit id="326bf78cdc5261237c497696e2f88d3bf937ac51" translate="yes" xml:space="preserve">
          <source>New table constraint for the foreign table.</source>
          <target state="translated">외부 테이블에 대한 새 테이블 제한 조건.</target>
        </trans-unit>
        <trans-unit id="c7fc18feb54e6ecc777a74b8dce9c763304724d3" translate="yes" xml:space="preserve">
          <source>New table constraint for the table.</source>
          <target state="translated">테이블에 대한 새로운 테이블 제약.</target>
        </trans-unit>
        <trans-unit id="0ef8f5b2618f8741358d2dc6f311e26c77d17c09" translate="yes" xml:space="preserve">
          <source>New value of parameter. Values can be specified as string constants, identifiers, numbers, or comma-separated lists of these, as appropriate for the particular parameter. &lt;code&gt;DEFAULT&lt;/code&gt; can be written to specify resetting the parameter to its default value (that is, whatever value it would have had if no &lt;code&gt;SET&lt;/code&gt; had been executed in the current session).</source>
          <target state="translated">매개 변수의 새로운 값. 값은 특정 매개 변수에 따라 문자열 상수, 식별자, 숫자 또는 쉼표로 구분 된 목록으로 지정할 수 있습니다. &lt;code&gt;DEFAULT&lt;/code&gt; 를 작성하여 매개 변수를 기본값 (즉 , 현재 세션에서 &lt;code&gt;SET&lt;/code&gt; 이 실행 되지 않은 경우의 값)으로 재설정하도록 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74ad18207dee0729707d6021134389a09abbbcf4" translate="yes" xml:space="preserve">
          <source>New value of the parameter. Values can be specified as string constants, identifiers, numbers, or comma-separated lists of these, as appropriate for the particular parameter. &lt;code&gt;DEFAULT&lt;/code&gt; can be written to specify removing the parameter and its value from &lt;code&gt;postgresql.auto.conf&lt;/code&gt;.</source>
          <target state="translated">매개 변수의 새로운 값. 값은 특정 매개 변수에 따라 문자열 상수, 식별자, 숫자 또는 쉼표로 구분 된 목록으로 지정할 수 있습니다. &lt;code&gt;postgresql.auto.conf&lt;/code&gt; 에서 매개 변수 및 해당 값을 제거하도록 지정하기 위해 &lt;code&gt;DEFAULT&lt;/code&gt; 를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f73bcda4d00edad798e144ba44c98c20a80aa1b" translate="yes" xml:space="preserve">
          <source>Newer operating systems may check for the known TSC problems and switch to a slower, more stable clock source when they are seen. If your system supports TSC time but doesn't default to that, it may be disabled for a good reason. And some operating systems may not detect all the possible problems correctly, or will allow using TSC even in situations where it's known to be inaccurate.</source>
          <target state="translated">최신 운영 체제는 알려진 TSC 문제를 확인하고보다 느리고 안정적인 클럭 소스로 전환 할 수 있습니다. 시스템이 TSC 시간을 지원하지만 기본값으로 설정하지 않은 경우에는 적절한 이유로 비활성화 될 수 있습니다. 일부 운영 체제는 가능한 모든 문제를 올바르게 감지하지 못하거나 부정확 한 것으로 알려진 상황에서도 TSC를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91613c0496c344d2d60b757f74e45fc5cc402ce3" translate="yes" xml:space="preserve">
          <source>Newline (ASCII 10)</source>
          <target state="translated">개행 (ASCII 10)</target>
        </trans-unit>
        <trans-unit id="abcfe34ad9620d6f4bc03407b5ef1c1c15fc3d23" translate="yes" xml:space="preserve">
          <source>Newlines are inserted between fields as needed to limit line length to 80 characters, if possible. A newline is also inserted between the metadata fields and the regular fields.</source>
          <target state="translated">가능한 경우 줄 길이를 80 자로 제한하기 위해 필드 사이에 줄 바꾸기가 삽입됩니다. 메타 데이터 필드와 일반 필드 사이에도 줄 바꿈이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="668d132684646785e22fe1441b80ce3d2edabbcd" translate="yes" xml:space="preserve">
          <source>Next field is Julian Date</source>
          <target state="translated">다음 필드는 Julian Date입니다</target>
        </trans-unit>
        <trans-unit id="b894f41f03f11b1ed4f8f278b45d31b30d6d7e9d" translate="yes" xml:space="preserve">
          <source>Next field is time</source>
          <target state="translated">다음 필드는 시간입니다</target>
        </trans-unit>
        <trans-unit id="8bbd06fda45074a003115cb92bcdeae70e3776f1" translate="yes" xml:space="preserve">
          <source>Next let's consider an example with an equality condition in its &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">다음으로 &lt;code&gt;WHERE&lt;/code&gt; 절 에 동등 조건이있는 예제를 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="0accafa67ae47755f44a4c829c06920cf375701d" translate="yes" xml:space="preserve">
          <source>Next the fraction of the histogram occupied by &amp;ldquo;&amp;lt; 1000&amp;rdquo; is worked out. This is the selectivity. The histogram divides the range into equal frequency buckets, so all we have to do is locate the bucket that our value is in and count &lt;em&gt;part&lt;/em&gt; of it and &lt;em&gt;all&lt;/em&gt; of the ones before. The value 1000 is clearly in the second bucket (993&amp;ndash;1997). Assuming a linear distribution of values inside each bucket, we can calculate the selectivity as:</source>
          <target state="translated">다음으로 &quot;&amp;lt;1000&quot;이 차지하는 히스토그램의 비율이 계산됩니다. 이것이 선택성입니다. 히스토그램은 범위를 동일한 주파수 버킷으로 나누기 때문에 값이있는 버킷을 찾고 그 &lt;em&gt;일부&lt;/em&gt; 와 이전의 &lt;em&gt;모든&lt;/em&gt; 버킷을 계산 하기 만하면됩니다. 값 1000은 분명히 두 번째 버킷 (993&amp;ndash;1997)에 있습니다. 각 버킷 내부 값의 선형 분포를 가정하면 선택성을 다음과 같이 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ed06150c503b0381101da4c9e29738d8aede6e0" translate="yes" xml:space="preserve">
          <source>Next the fraction of the histogram occupied by &amp;ldquo;&amp;lt; 1000&amp;rdquo; is worked out. This is the selectivity. The histogram divides the range into equal frequency buckets, so all we have to do is locate the bucket that our value is in and count &lt;em&gt;part&lt;/em&gt; of it and &lt;em&gt;all&lt;/em&gt; of the ones before. The value 1000 is clearly in the second bucket (993-1997). Assuming a linear distribution of values inside each bucket, we can calculate the selectivity as:</source>
          <target state="translated">다음으로&amp;ldquo;&amp;lt;1000&amp;rdquo;이 차지하는 히스토그램의 분수가 계산됩니다. 이것이 선택성입니다. 히스토그램은 범위를 동일한 주파수 버킷으로 나누므로 값이있는 버킷을 찾아서 그 &lt;em&gt;일부&lt;/em&gt; 와 이전의 &lt;em&gt;모든&lt;/em&gt; 버킷을 계산 하기 만하면됩니다. 값 1000은 분명히 두 번째 버킷 (993-1997)에 있습니다. 각 버킷 내에서 값의 선형 분포를 가정하면 선택성을 다음과 같이 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e15fe544e0817c8abcd5bf63590f065c8fda5e8" translate="yes" xml:space="preserve">
          <source>Next we register the Ispell dictionary &lt;code&gt;english_ispell&lt;/code&gt;, which has its own configuration files:</source>
          <target state="translated">다음 으로 자체 구성 파일이 있는 Ispell 사전 &lt;code&gt;english_ispell&lt;/code&gt; 을 등록 합니다.</target>
        </trans-unit>
        <trans-unit id="5d2e580901bf6290e8151d5811cdef90838e8edb" translate="yes" xml:space="preserve">
          <source>Next, &lt;code&gt;pg_verifybackup&lt;/code&gt; will checksum all the files, compare the checksums against the values in the manifest, and emit errors for any files for which the computed checksum does not match the checksum stored in the manifest. This step is not performed for any files which produced errors in the previous step, since they are already known to have problems. Files which were ignored in the previous step are also ignored in this step.</source>
          <target state="translated">다음으로 &lt;code&gt;pg_verifybackup&lt;/code&gt; 은 모든 파일을 체크섬하고, 체크섬을 매니페스트의 값과 비교하고, 계산 된 체크섬이 매니페스트에 저장된 체크섬과 일치하지 않는 모든 파일에 대해 오류를 내 보냅니다 . 이 단계는 이미 문제가있는 것으로 알려져 있기 때문에 이전 단계에서 오류를 생성 한 파일에 대해서는 수행되지 않습니다. 이전 단계에서 무시 된 파일도이 단계에서 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bdb6f7d3081e6797875cb41a13e6c45a3f761bbf" translate="yes" xml:space="preserve">
          <source>Next, create a trigram index on the word column:</source>
          <target state="translated">다음으로 단어 열에 트라이 그램 인덱스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d9e892095e44895492c517f24015243e155c5a35" translate="yes" xml:space="preserve">
          <source>Next, there might be a cache in the disk drive controller; this is particularly common on RAID controller cards. Some of these caches are &lt;em&gt;write-through&lt;/em&gt;, meaning writes are sent to the drive as soon as they arrive. Others are &lt;em&gt;write-back&lt;/em&gt;, meaning data is sent to the drive at some later time. Such caches can be a reliability hazard because the memory in the disk controller cache is volatile, and will lose its contents in a power failure. Better controller cards have &lt;em&gt;battery-backup units&lt;/em&gt; (BBUs), meaning the card has a battery that maintains power to the cache in case of system power loss. After power is restored the data will be written to the disk drives.</source>
          <target state="translated">다음으로 디스크 드라이브 컨트롤러에 캐시가있을 수 있습니다. 이것은 RAID 컨트롤러 카드에서 특히 일반적입니다. 이러한 캐시 중 일부는 &lt;em&gt;연속 기입&lt;/em&gt; 이므로 쓰기가 도착하자마자 드라이브로 전송됩니다. 다른 사람은 &lt;em&gt;다시 쓰기&lt;/em&gt; 일부 나중에 드라이브로 전송되는 데이터를 의미한다. 이러한 캐시는 디스크 컨트롤러 캐시의 메모리가 휘발성이므로 정전시 내용이 손실되므로 안정성이 위험 할 수 있습니다. 더 나은 컨트롤러 카드에는 &lt;em&gt;배터리 백업 장치&lt;/em&gt; (BBU)가 있습니다. 즉, 시스템 전원 손실시 캐시에 전원을 유지하는 배터리가 카드에 있습니다. 전원이 복구되면 데이터가 디스크 드라이브에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="ab63ab43b9cd6b9423e3548d5b6495e55251533e" translate="yes" xml:space="preserve">
          <source>No background workers can be obtained because of the limitation that the total number of background workers cannot exceed &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes&lt;/a&gt;.</source>
          <target state="translated">총 백그라운드 작업자 수가 &lt;a href=&quot;runtime-config-resource#GUC-MAX-WORKER-PROCESSES&quot;&gt;max_worker_processes를&lt;/a&gt; 초과 할 수 없다는 제한으로 인해 백그라운드 작업자를 얻을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1db509e223519bbbe9c20165e8b19fc16220b41f" translate="yes" xml:space="preserve">
          <source>No background workers can be obtained because of the limitation that the total number of background workers launched for purposes of parallel query cannot exceed &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers&lt;/a&gt;.</source>
          <target state="translated">병렬 쿼리를 위해 시작된 총 백그라운드 워커 수가 &lt;a href=&quot;runtime-config-resource#GUC-MAX-PARALLEL-WORKERS&quot;&gt;max_parallel_workers를&lt;/a&gt; 초과 할 수 없다는 제한 때문에 백그라운드 워커를 얻을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="737fbf99fcaacc1c750aa9911a89ba763b4fb6c2" translate="yes" xml:space="preserve">
          <source>No conflict resolution necessary</source>
          <target state="translated">충돌 해결이 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="c4ae42341e7948bd6be9068db7f6b708eab0516f" translate="yes" xml:space="preserve">
          <source>No direct modifications of buffers are allowed! All modifications must be done in copies acquired from &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt;. In other words, code that makes generic WAL records should never call &lt;code&gt;BufferGetPage()&lt;/code&gt; for itself. However, it remains the caller's responsibility to pin/unpin and lock/unlock the buffers at appropriate times. Exclusive lock must be held on each target buffer from before &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; until after &lt;code&gt;GenericXLogFinish()&lt;/code&gt;.</source>
          <target state="translated">버퍼를 직접 수정할 수 없습니다! 모든 수정은 &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; 에서 얻은 사본에서 수행해야합니다 . 즉, 일반 WAL 레코드를 만드는 코드는 절대로 &lt;code&gt;BufferGetPage()&lt;/code&gt; 를 호출해서는 안됩니다 . 그러나 적절한 시간에 버퍼를 고정 / 고정 해제 및 잠금 / 잠금 해제하는 것은 호출자의 책임입니다. &lt;code&gt;GenericXLogRegisterBuffer()&lt;/code&gt; 이전부터 &lt;code&gt;GenericXLogFinish()&lt;/code&gt; 이후까지 각 대상 버퍼에서 독점 잠금을 보유해야합니다 .</target>
        </trans-unit>
        <trans-unit id="59fe225d3b68631dd2336d2bf5588427b3b21997" translate="yes" xml:space="preserve">
          <source>No error concerning corruption raised by &lt;code&gt;amcheck&lt;/code&gt; should ever be a false positive. &lt;code&gt;amcheck&lt;/code&gt; raises errors in the event of conditions that, by definition, should never happen, and so careful analysis of &lt;code&gt;amcheck&lt;/code&gt; errors is often required.</source>
          <target state="translated">&lt;code&gt;amcheck&lt;/code&gt; 에 의해 야기 된 손상에 관한 오류 는 거짓 긍정이 되어서 는 안됩니다. &lt;code&gt;amcheck&lt;/code&gt; 는 정의상 절대로 발생하지 않아야하는 조건에서 오류를 발생 &lt;code&gt;amcheck&lt;/code&gt; 오류를 신중하게 분석 해야하는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b39fb69a71692aa8fa18d1717c1f94f66adfcdf" translate="yes" xml:space="preserve">
          <source>No master server overhead</source>
          <target state="translated">마스터 서버 오버 헤드 없음</target>
        </trans-unit>
        <trans-unit id="69d7c6fd29e6141d46559276ef0d0824b8ca6117" translate="yes" xml:space="preserve">
          <source>No more than 256 positions per lexeme</source>
          <target state="translated">lexeme 당 256 개 이하의 위치</target>
        </trans-unit>
        <trans-unit id="d6105567c57e07dede5d4075af64116a14eb0b4d" translate="yes" xml:space="preserve">
          <source>No particular limit is imposed on the length of REs in this implementation. However, programs intended to be highly portable should not employ REs longer than 256 bytes, as a POSIX-compliant implementation can refuse to accept such REs.</source>
          <target state="translated">이 구현에서 RE의 길이에는 특별한 제한이 없다. 그러나 이식성이 높은 프로그램은 POSIX 호환 구현이 그러한 RE를 수락하는 것을 거부 할 수 있으므로 256 바이트보다 긴 RE를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b403c7e51ec107180064180093a27a248cb9fcae" translate="yes" xml:space="preserve">
          <source>No special action is taken at the ends of transactions. This is the default behavior.</source>
          <target state="translated">거래 종료시 특별한 조치가 취해지지 않습니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="61fdd0ee1a0e012e017d3d0ae54de832b57200e8" translate="yes" xml:space="preserve">
          <source>No special hardware required</source>
          <target state="translated">특별한 하드웨어 불필요</target>
        </trans-unit>
        <trans-unit id="ae79014d45aed5cbc3110d3674ce8fdfb2183d69" translate="yes" xml:space="preserve">
          <source>No support for encryption key as master key. As such practice is generally discouraged, this should not be a problem.</source>
          <target state="translated">마스터 키로 암호화 키를 지원하지 않습니다. 이러한 관행은 일반적으로 권장되지 않으므로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c30a7a5188f10c0ac8624ba81f5e723c5467bcf" translate="yes" xml:space="preserve">
          <source>No support for several subkeys. This may seem like a problem, as this is common practice. On the other hand, you should not use your regular GPG/PGP keys with &lt;code&gt;pgcrypto&lt;/code&gt;, but create new ones, as the usage scenario is rather different.</source>
          <target state="translated">여러 하위 키를 지원하지 않습니다. 이것은 일반적인 관행이므로 문제처럼 보일 수 있습니다. 반면에 &lt;code&gt;pgcrypto&lt;/code&gt; 와 함께 일반 GPG / PGP 키를 사용하지 말고 사용 시나리오가 다소 다르므로 새 키를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9435d4dd42a8ebc8de1b106f0a226340aa75454" translate="yes" xml:space="preserve">
          <source>No support for signing. That also means that it is not checked whether the encryption subkey belongs to the master key.</source>
          <target state="translated">서명을 지원하지 않습니다. 또한 암호화 하위 키가 마스터 키에 속하는지 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0ba19704438347e67d6c41db6384452ae2aa5a4" translate="yes" xml:space="preserve">
          <source>No waiting for multiple servers</source>
          <target state="translated">여러 서버를 기다리지 않음</target>
        </trans-unit>
        <trans-unit id="4b6d8042bc7e3d0b0614251a34971ce673127f09" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;C&lt;/code&gt; and non-&lt;code&gt;POSIX&lt;/code&gt; locales rely on the operating system's collation library for character set ordering. This controls the ordering of keys stored in indexes. For this reason, a cluster cannot switch to an incompatible collation library version, either through snapshot restore, binary streaming replication, a different operating system, or an operating system upgrade.</source>
          <target state="translated">비 &lt;code&gt;C&lt;/code&gt; 및 비 &lt;code&gt;POSIX&lt;/code&gt; 로켈은 문자 집합 순서를 위해 운영 체제의 데이터 정렬 라이브러리를 사용합니다. 인덱스에 저장된 키의 순서를 제어합니다. 이러한 이유로 클러스터는 스냅 샷 복원, 이진 스트리밍 복제, 다른 운영 체제 또는 운영 체제 업그레이드를 통해 호환되지 않는 조합 라이브러리 버전으로 전환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b791053ba5b378d8e57979f3c97566be063ef0d0" translate="yes" xml:space="preserve">
          <source>Non-Deferred Uniqueness Constraints</source>
          <target state="translated">지연되지 않은 고유성 제약</target>
        </trans-unit>
        <trans-unit id="2edd532d90e9a265b3d587446d10683f0ddb82ba" translate="yes" xml:space="preserve">
          <source>Non-Durable Settings</source>
          <target state="translated">내구성이없는 설정</target>
        </trans-unit>
        <trans-unit id="1606d825faba4ca859c553032bca97393df353c3" translate="yes" xml:space="preserve">
          <source>Non-absolute directory names are taken as relative to the directory containing the referencing configuration file. Within the specified directory, only non-directory files whose names end with the suffix &lt;code&gt;.conf&lt;/code&gt; will be included. File names that start with the &lt;code&gt;.&lt;/code&gt; character are also ignored, to prevent mistakes since such files are hidden on some platforms. Multiple files within an include directory are processed in file name order (according to C locale rules, i.e. numbers before letters, and uppercase letters before lowercase ones).</source>
          <target state="translated">절대적이지 않은 디렉토리 이름은 참조 구성 파일이 들어있는 디렉토리를 기준으로합니다. 지정된 디렉토리 내에 이름이 접미사 &lt;code&gt;.conf&lt;/code&gt; 로 끝나는 비 디렉토리 파일 만 포함됩니다. 로 시작하는 파일 이름 &lt;code&gt;.&lt;/code&gt; 일부 플랫폼에서는 이러한 파일이 숨겨져 있기 때문에 실수를 방지하기 위해 문자도 무시됩니다. 포함 디렉토리 내의 여러 파일은 파일 이름 순서로 처리됩니다 (C 로케일 규칙, 즉 문자 앞의 숫자 및 대문자 앞의 소문자에 따라).</target>
        </trans-unit>
        <trans-unit id="375e6f9829aa08a22fb91bd89b1b288cc7a6547e" translate="yes" xml:space="preserve">
          <source>Non-absolute directory names are taken as relative to the directory containing the referencing configuration file. Within the specified directory, only non-directory files whose names end with the suffix &lt;code&gt;.conf&lt;/code&gt; will be included. File names that start with the &lt;code&gt;.&lt;/code&gt; character are also ignored, to prevent mistakes since such files are hidden on some platforms. Multiple files within an include directory are processed in file name order (according to C locale rules, i.e., numbers before letters, and uppercase letters before lowercase ones).</source>
          <target state="translated">절대적이지 않은 디렉토리 이름은 참조하는 구성 파일이 포함 된 디렉토리에 상대적인 것으로 간주됩니다. 지정된 디렉토리 내에서 이름이 &lt;code&gt;.conf&lt;/code&gt; 접미사로 끝나는 비 디렉토리 파일 만 포함됩니다. 로 시작하는 파일 이름 &lt;code&gt;.&lt;/code&gt; 일부 플랫폼에서는 이러한 파일이 숨겨져 있으므로 실수를 방지하기 위해 문자도 무시됩니다. 포함 디렉토리 내의 여러 파일은 파일 이름 순서로 처리됩니다 (예 : 문자 앞의 숫자 및 소문자 앞의 대문자와 같은 C 로케일 규칙에 따라).</target>
        </trans-unit>
        <trans-unit id="b0daa9d12e18919b30fa114566dbfc8fde09c52f" translate="yes" xml:space="preserve">
          <source>Non-equality comparison</source>
          <target state="translated">비동 등 비교</target>
        </trans-unit>
        <trans-unit id="005bf64a001e88d6c5954633016b2d70a8916d20" translate="yes" xml:space="preserve">
          <source>Non-equality operator</source>
          <target state="translated">비 균등 연산자</target>
        </trans-unit>
        <trans-unit id="5d6b03babc67eb26f4a561798892e8e1d042f8b8" translate="yes" xml:space="preserve">
          <source>Non-equality operator (same as &lt;code&gt;!=&lt;/code&gt;)</source>
          <target state="translated">비항 등 연산자 ( &lt;code&gt;!=&lt;/code&gt; 와 동일 )</target>
        </trans-unit>
        <trans-unit id="20c0da4f56e91a8e794e8ad5b40aa2db7a25e473" translate="yes" xml:space="preserve">
          <source>Non-schema objects such as blobs are not dumped when &lt;code&gt;-n&lt;/code&gt; is specified. You can add blobs back to the dump with the &lt;code&gt;--blobs&lt;/code&gt; switch.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; 을 지정 하면 Blob과 같은 비 스키마 개체는 덤프되지 않습니다 . &lt;code&gt;--blobs&lt;/code&gt; 스위치 를 사용하여 덤프에 덤프를 다시 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9caf6bd6e45fde8300143ee2bd8d45d380012859" translate="yes" xml:space="preserve">
          <source>Non-standard syntax for &lt;code&gt;trim()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trim()&lt;/code&gt; 비표준 구문</target>
        </trans-unit>
        <trans-unit id="1b82aac77684b2e34b968be8bab3328cdefd6c87" translate="yes" xml:space="preserve">
          <source>Non-superusers can only apply &lt;code&gt;LOAD&lt;/code&gt; to library files located in &lt;code&gt;$libdir/plugins/&lt;/code&gt; &amp;mdash; the specified &lt;code&gt;filename&lt;/code&gt; must begin with exactly that string. (It is the database administrator's responsibility to ensure that only &amp;ldquo;safe&amp;rdquo; libraries are installed there.)</source>
          <target state="translated">수퍼 유저가 아닌 사용자는 &lt;code&gt;$libdir/plugins/&lt;/code&gt; 에있는 라이브러리 파일 에만 &lt;code&gt;LOAD&lt;/code&gt; 를 적용 할 수 있습니다 . 지정된 &lt;code&gt;filename&lt;/code&gt; 은 정확히 해당 문자열로 시작해야합니다. ( &quot;안전한&quot;라이브러리 만 설치되도록하는 것은 데이터베이스 관리자의 책임입니다.)</target>
        </trans-unit>
        <trans-unit id="33362508c287b322946b88bcd446c4aed0b4f943" translate="yes" xml:space="preserve">
          <source>Non-zero values of this setting add overhead, as PostgreSQL will need to store textual representations of parameter values in memory at the start of each statement, whether or not an error eventually occurs. The overhead is greater when bind parameters are sent in binary form than when they are sent as text, since the former case requires data conversion while the latter only requires copying the string.</source>
          <target state="translated">이 설정의 0이 아닌 값은 오버 헤드를 추가합니다. PostgreSQL은 결국 오류가 발생하는지 여부에 관계없이 각 명령문이 시작될 때 메모리에 매개 변수 값의 텍스트 표현을 저장해야하기 때문입니다. 바인드 매개 변수를 텍스트로 보낼 때보 다 바이너리 형식으로 보낼 때 오버 헤드가 더 큽니다. 전자의 경우 데이터 변환이 필요하고 후자는 문자열 복사 만 필요하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="cdcf35d8373c6ae03dbb38620bdfe970a151c4ed" translate="yes" xml:space="preserve">
          <source>Nondeterministic collations are only supported with the ICU provider.</source>
          <target state="translated">비 결정적 데이터 정렬은 ICU 공급자에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="592caa46c1febc51d4ba97d3f0cb331e0f251855" translate="yes" xml:space="preserve">
          <source>Nonrepeatable Read</source>
          <target state="translated">반복 불가능한 읽기</target>
        </trans-unit>
        <trans-unit id="4cd9a0397eea6fedc043bb59b16fdf2f16c3bc14" translate="yes" xml:space="preserve">
          <source>Nonstandard Clauses</source>
          <target state="translated">비표준 조항</target>
        </trans-unit>
        <trans-unit id="d10c40965cecc5427a7ccc11e532baca90682092" translate="yes" xml:space="preserve">
          <source>Nordic</source>
          <target state="translated">Nordic</target>
        </trans-unit>
        <trans-unit id="5d192ac91d079d3947c34df6ca0da6af270cb95a" translate="yes" xml:space="preserve">
          <source>Normal cursors return data in text format, the same as a &lt;code&gt;SELECT&lt;/code&gt; would produce. The &lt;code&gt;BINARY&lt;/code&gt; option specifies that the cursor should return data in binary format. This reduces conversion effort for both the server and client, at the cost of more programmer effort to deal with platform-dependent binary data formats. As an example, if a query returns a value of one from an integer column, you would get a string of &lt;code&gt;1&lt;/code&gt; with a default cursor, whereas with a binary cursor you would get a 4-byte field containing the internal representation of the value (in big-endian byte order).</source>
          <target state="translated">일반 커서는 &lt;code&gt;SELECT&lt;/code&gt; 에서 생성 한 것과 같은 텍스트 형식으로 데이터를 반환합니다 . &lt;code&gt;BINARY&lt;/code&gt; 옵션의 지정이 커서 바이너리 형식으로 데이터를 반환해야 함. 이렇게하면 플랫폼 종속 바이너리 데이터 형식을 처리하려는 프로그래머의 노력으로 서버와 클라이언트 모두에 대한 변환 노력이 줄어 듭니다. 예를 들어, 쿼리가 정수 열에서 1의 값을 반환하면 기본 커서를 사용하여 문자열 &lt;code&gt;1&lt;/code&gt; 을 얻는 반면 이진 커서를 사용하면 값의 내부 표현을 포함하는 4 바이트 필드를 얻을 수 있습니다 ( 빅 엔디안 바이트 순서로).</target>
        </trans-unit>
        <trans-unit id="e719f066c8f80c3d098dc0de105e52604edf52bd" translate="yes" xml:space="preserve">
          <source>Normally a copy of &lt;code&gt;pg_type.typstorage&lt;/code&gt; of this column's type. For TOAST-able data types, this can be altered after column creation to control storage policy.</source>
          <target state="translated">일반적 으로이 열 유형 의 &lt;code&gt;pg_type.typstorage&lt;/code&gt; 사본입니다 . TOAST 가능 데이터 유형의 경우, 스토리지 정책을 제어하기 위해 컬럼 작성 후이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfefa02592536f045045c313a59b93cf3ea4a182" translate="yes" xml:space="preserve">
          <source>Normally it is better to start &lt;code&gt;postgres&lt;/code&gt; in the background. For this, use the usual Unix shell syntax:</source>
          <target state="translated">일반적으로 백그라운드에서 &lt;code&gt;postgres&lt;/code&gt; 를 시작하는 것이 좋습니다 . 이를 위해 일반적인 Unix 쉘 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eb15db27354b906033434be491a2ae185754105d" translate="yes" xml:space="preserve">
          <source>Normally the set of partitions established when initially defining the table are not intended to remain static. It is common to want to remove old partitions of data and periodically add new partitions for new data. One of the most important advantages of partitioning is precisely that it allows this otherwise painful task to be executed nearly instantaneously by manipulating the partition structure, rather than physically moving large amounts of data around.</source>
          <target state="translated">일반적으로 테이블을 처음 정의 할 때 설정된 파티션 세트는 정적으로 유지되지 않습니다. 오래된 데이터 파티션을 제거하고 주기적으로 새로운 데이터에 대한 새로운 파티션을 추가하는 것이 일반적입니다. 파티셔닝의 가장 중요한 장점 중 하나는 실제로 많은 양의 데이터를 실제로 이동시키는 대신 파티션 구조를 조작하여 고통스러운 작업을 거의 즉시 실행할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fe2f8f91b212090479c992426f90bbd96089fce0" translate="yes" xml:space="preserve">
          <source>Normally the set of partitions established when initially defining the table is not intended to remain static. It is common to want to remove old partitions of data and periodically add new partitions for new data. One of the most important advantages of partitioning is precisely that it allows this otherwise painful task to be executed nearly instantaneously by manipulating the partition structure, rather than physically moving large amounts of data around.</source>
          <target state="translated">일반적으로 테이블을 처음 정의 할 때 설정된 파티션 세트는 정적으로 유지되지 않습니다. 데이터의 오래된 파티션을 제거하고 주기적으로 새 데이터를위한 새 파티션을 추가하는 것이 일반적입니다. 파티셔닝의 가장 중요한 장점 중 하나는 물리적으로 많은 양의 데이터를 이동하는 대신 파티션 구조를 조작하여이 고통스러운 작업을 거의 즉시 실행할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="85e1a3935578c6fbceb8f9dfc1ec7edf36d93788" translate="yes" xml:space="preserve">
          <source>Normally there is one entry, with &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt;, for each table column that has been analyzed. If the table has inheritance children, a second entry with &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; is also created. This row represents the column's statistics over the inheritance tree, i.e., statistics for the data you'd see with &lt;code&gt;SELECT column FROM table*&lt;/code&gt;, whereas the &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; row represents the results of &lt;code&gt;SELECT column FROM ONLY table&lt;/code&gt;.</source>
          <target state="translated">일반적 으로 분석 된 각 테이블 열에 대해 &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 인 항목이 하나 있습니다. 테이블에 상속 하위가 있으면 &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;true&lt;/code&gt; 인 두 번째 항목 도 작성됩니다. 이 행은 상속 트리에 대한 열의 통계, 즉 &lt;code&gt;SELECT column FROM table*&lt;/code&gt; 과 함께 표시되는 데이터에 대한 통계를 나타내는 반면 &lt;code&gt;stainherit&lt;/code&gt; = &lt;code&gt;false&lt;/code&gt; 행은 &lt;code&gt;SELECT column FROM ONLY table&lt;/code&gt; 의 결과를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ef0a797677cd4cd7010abb5ff69a6286820deaa9" translate="yes" xml:space="preserve">
          <source>Normally these parameters are set in &lt;code&gt;postgresql.conf&lt;/code&gt; so that they apply to all server processes, but it is possible to turn them on or off in individual sessions using the &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; command. (To prevent ordinary users from hiding their activity from the administrator, only superusers are allowed to change these parameters with &lt;code&gt;SET&lt;/code&gt;.)</source>
          <target state="translated">일반적으로 이러한 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 에 설정되어 모든 서버 프로세스에 적용되지만 &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; 명령을 사용하여 개별 세션에서 설정 하거나 해제 할 수 있습니다 . 일반 사용자가 자신의 활동을 관리자에게 숨기지 않도록 수퍼 유저 만 &lt;code&gt;SET&lt;/code&gt; 를 사용하여 이러한 매개 변수를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="defa435e9220700a95afbba17bf09c1d280dc0dd" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;EXPLAIN&lt;/code&gt; will display every plan node created by the planner. However, there are cases where the executor can determine that certain nodes need not be executed because they cannot produce any rows, based on parameter values that were not available at planning time. (Currently this can only happen for child nodes of an Append or MergeAppend node that is scanning a partitioned table.) When this happens, those plan nodes are omitted from the &lt;code&gt;EXPLAIN&lt;/code&gt; output and a &lt;code&gt;Subplans Removed: N&lt;/code&gt; annotation appears instead.</source>
          <target state="translated">일반적으로 &lt;code&gt;EXPLAIN&lt;/code&gt; 은 플래너가 생성 한 모든 계획 노드를 표시합니다. 그러나 실행 프로그램은 계획시 사용할 수 없었던 매개 변수 값을 기반으로 행을 생성 할 수 없기 때문에 특정 노드를 실행할 필요가 없다고 결정할 수있는 경우가 있습니다. (현재 이것은 파티션 된 테이블을 스캔하는 Append 또는 MergeAppend 노드의 하위 노드에서만 발생할 수 있습니다.)이 경우 해당 계획 노드가 &lt;code&gt;EXPLAIN&lt;/code&gt; 출력 에서 생략되고 &lt;code&gt;Subplans Removed: N&lt;/code&gt; 주석이 대신 나타납니다.</target>
        </trans-unit>
        <trans-unit id="059b752177da2be76f272de074908dfea33c9049" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;VACUUM&lt;/code&gt; will skip pages based on the &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-VISIBILITY-MAP&quot;&gt;visibility map&lt;/a&gt;. Pages where all tuples are known to be frozen can always be skipped, and those where all tuples are known to be visible to all transactions may be skipped except when performing an aggressive vacuum. Furthermore, except when performing an aggressive vacuum, some pages may be skipped in order to avoid waiting for other sessions to finish using them. This option disables all page-skipping behavior, and is intended to be used only when the contents of the visibility map are suspect, which should happen only if there is a hardware or software issue causing database corruption.</source>
          <target state="translated">일반적으로 &lt;code&gt;VACUUM&lt;/code&gt; 은 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-VISIBILITY-MAP&quot;&gt;가시성 맵을&lt;/a&gt; 기준으로 페이지를 건너 뜁니다 . 모든 튜플이 고정 된 것으로 알려진 페이지는 항상 건너 뛸 수 있으며 모든 튜플이 모든 트랜잭션에 표시되는 것으로 알려진 페이지는 공격적인 진공을 수행 할 때를 제외하고는 건너 뛸 수 있습니다. 또한 적극적인 진공 청소기를 수행하는 경우를 제외하고 다른 세션의 사용이 끝나기를 기다리지 않기 위해 일부 페이지를 건너 뛸 수 있습니다. 이 옵션은 모든 페이지 건너 뛰기 동작을 비활성화하며 가시성 맵의 내용이 의심되는 경우에만 사용하도록되어 있으며 데이터베이스 손상을 일으키는 하드웨어 또는 소프트웨어 문제가있는 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5a28b92dedca807b45d1375cda7834475db13842" translate="yes" xml:space="preserve">
          <source>Normally, a database session will read a dictionary configuration file only once, when it is first used within the session. If you modify a configuration file and want to force existing sessions to pick up the new contents, issue an &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; command on the dictionary. This can be a &amp;ldquo;dummy&amp;rdquo; update that doesn't actually change any parameter values.</source>
          <target state="translated">일반적으로 데이터베이스 세션은 세션 내에서 처음 사용될 때 사전 구성 파일을 한 번만 읽습니다. 구성 파일을 수정하고 기존 세션이 새 컨텐츠를 선택 하도록하려면 사전에서 &lt;code&gt;ALTER TEXT SEARCH DICTIONARY&lt;/code&gt; 명령을 실행하십시오. 이것은 실제로 매개 변수 값을 변경하지 않는 &quot;더미&quot;업데이트 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bffa790046f833c87fae190fc13aecca45c4acb" translate="yes" xml:space="preserve">
          <source>Normally, a referencing row need not satisfy the foreign key constraint if any of its referencing columns are null. If &lt;code&gt;MATCH FULL&lt;/code&gt; is added to the foreign key declaration, a referencing row escapes satisfying the constraint only if all its referencing columns are null (so a mix of null and non-null values is guaranteed to fail a &lt;code&gt;MATCH FULL&lt;/code&gt; constraint). If you don't want referencing rows to be able to avoid satisfying the foreign key constraint, declare the referencing column(s) as &lt;code&gt;NOT NULL&lt;/code&gt;.</source>
          <target state="translated">일반적으로 참조 행이 참조 열이 null 인 경우 참조 행은 외래 키 제약 조건을 충족 할 필요가 없습니다. 경우 &lt;code&gt;MATCH FULL&lt;/code&gt; 는 외래 키 선언에 추가하는 참조 행 (널 (null)이 아닌 null 값의 혼합이 실패 보장되도록 모든 참조 열이 null 경우에만 제약 조건을 만족 기약 &lt;code&gt;MATCH FULL&lt;/code&gt; 의 제약을). 참조 행이 외래 키 제약 조건을 충족시키지 못하도록하려면 참조 열을 &lt;code&gt;NOT NULL&lt;/code&gt; 로 선언하십시오 .</target>
        </trans-unit>
        <trans-unit id="a73d6e4c0676c9748a26df54015a17cf72960f1a" translate="yes" xml:space="preserve">
          <source>Normally, psql will dispatch a SQL command to the server as soon as it reaches the command-ending semicolon, even if more input remains on the current line. Thus for example entering</source>
          <target state="translated">일반적으로 psql은 현재 줄에 더 많은 입력이 남아 있어도 명령 종료 세미콜론에 도달하자마자 서버에 SQL 명령을 발송합니다. 따라서 예를 들어 입력</target>
        </trans-unit>
        <trans-unit id="c995fea5a35dfbddf38f7ea21e264f8ae6030a27" translate="yes" xml:space="preserve">
          <source>Normally, recovery will proceed through all available WAL segments, thereby restoring the database to the current point in time (or as close as possible given the available WAL segments). Therefore, a normal recovery will end with a &amp;ldquo;file not found&amp;rdquo; message, the exact text of the error message depending upon your choice of &lt;code&gt;restore_command&lt;/code&gt;. You may also see an error message at the start of recovery for a file named something like &lt;code&gt;00000001.history&lt;/code&gt;. This is also normal and does not indicate a problem in simple recovery situations; see &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;Section 25.3.5&lt;/a&gt; for discussion.</source>
          <target state="translated">일반적으로 복구는 사용 가능한 모든 WAL 세그먼트를 통해 진행되므로 데이터베이스를 현재 시점으로 (또는 사용 가능한 WAL 세그먼트가 가능한 한 가깝게) 복원합니다. 따라서 정상적인 복구는 &lt;code&gt;restore_command&lt;/code&gt; 의 선택에 따라 오류 메시지의 정확한 텍스트 인&amp;ldquo;file not found&amp;rdquo;메시지로 끝납니다 . 복구 시작시 &lt;code&gt;00000001.history&lt;/code&gt; 와 같은 이름의 파일에 대한 오류 메시지가 표시 될 수도 있습니다 . 이것은 또한 정상적인 현상이며 간단한 복구 상황에서는 문제가되지 않습니다. 자세한 내용 &lt;a href=&quot;continuous-archiving#BACKUP-TIMELINES&quot;&gt;은 25.3.5 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="991460ee5abf98bebd31fd08e1871d36222f94b0" translate="yes" xml:space="preserve">
          <source>Normally, the database user who executes this command becomes the owner of the new database. However, a different owner can be specified via the &lt;code&gt;-O&lt;/code&gt; option, if the executing user has appropriate privileges.</source>
          <target state="translated">일반적으로이 명령을 실행하는 데이터베이스 사용자는 새 데이터베이스의 소유자가됩니다. 그러나 실행중인 사용자에게 적절한 권한이있는 경우 &lt;code&gt;-O&lt;/code&gt; 옵션을 통해 다른 소유자를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cce3fdca736676d73614d21a0ddda63501859fa9" translate="yes" xml:space="preserve">
          <source>Normally, the single-user mode server treats newline as the command entry terminator; there is no intelligence about semicolons, as there is in psql. To continue a command across multiple lines, you must type backslash just before each newline except the last one. The backslash and adjacent newline are both dropped from the input command. Note that this will happen even when within a string literal or comment.</source>
          <target state="translated">일반적으로 단일 사용자 모드 서버는 개행을 명령 입력 종료 자로 처리합니다. psql에있는 것처럼 세미콜론에 대한 정보는 없습니다. 여러 줄에 걸쳐 명령을 계속하려면 마지막 줄을 제외한 각 줄 바꿈 바로 앞에 백 슬래시를 입력해야합니다. 백 슬래시와 인접한 줄 바꿈은 모두 입력 명령에서 삭제됩니다. 이것은 문자열 리터럴 또는 주석 내에있을 때도 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1ab9de63486b486ed7137fde8276d785f144a066" translate="yes" xml:space="preserve">
          <source>Normally, there is a single apply process running for an enabled subscription. A disabled subscription or a crashed subscription will have zero rows in this view. If the initial data synchronization of any table is in progress, there will be additional workers for the tables being synchronized.</source>
          <target state="translated">일반적으로 사용 가능한 구독에 대해 단일 적용 프로세스가 실행 중입니다. 비활성화 된 가입 또는 중단 된 가입은이보기에서 행이 없습니다. 테이블의 초기 데이터 동기화가 진행중인 경우 테이블에 대한 추가 작업자가 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="67e110cfa914197db96be5bd8ad2cb0e12d33a41" translate="yes" xml:space="preserve">
          <source>Normally, this form will cause a scan of the table to verify that all existing rows in the table satisfy the new constraint. But if the &lt;code&gt;NOT VALID&lt;/code&gt; option is used, this potentially-lengthy scan is skipped. The constraint will still be enforced against subsequent inserts or updates (that is, they'll fail unless there is a matching row in the referenced table, in the case of foreign keys, or they'll fail unless the new row matches the specified check condition). But the database will not assume that the constraint holds for all rows in the table, until it is validated by using the &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; option. See &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;Notes&lt;/a&gt; below for more information about using the &lt;code&gt;NOT VALID&lt;/code&gt; option.</source>
          <target state="translated">일반적으로이 양식은 테이블을 스캔하여 테이블의 모든 기존 행이 새 제한 조건을 만족하는지 확인합니다. 그러나 &lt;code&gt;NOT VALID&lt;/code&gt; 옵션을 사용하는 경우이 잠재적으로 긴 스캔을 건너 뜁니다. 이후의 삽입 또는 업데이트에 대해 제약 조건이 계속 적용됩니다. 즉, 외래 키의 경우 참조 테이블에 일치하는 행이 없으면 실패하거나 새 행이 지정된 검사와 일치하지 않으면 실패합니다. 질환). 그러나 데이터베이스는 &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; 옵션 을 사용하여 유효성을 검증 할 때까지 테이블의 모든 행에 대해 제한 조건이 있다고 가정하지 않습니다 . &lt;code&gt;NOT VALID&lt;/code&gt; 옵션 사용에 대한 자세한 내용은 아래 &lt;a href=&quot;sql-altertable#SQL-ALTERTABLE-NOTES&quot;&gt;참고를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01a8f59aaf55d8442cfcf99c35955b402850a73f" translate="yes" xml:space="preserve">
          <source>Normally, you will want to start the database server when the computer boots. Autostart scripts are operating-system-specific. There are a few distributed with PostgreSQL in the &lt;code&gt;contrib/start-scripts&lt;/code&gt; directory. Installing one will require root privileges.</source>
          <target state="translated">일반적으로 컴퓨터가 부팅 될 때 데이터베이스 서버를 시작하려고합니다. 자동 시작 스크립트는 운영 체제에 따라 다릅니다. &lt;code&gt;contrib/start-scripts&lt;/code&gt; 디렉토리에 PostgreSQL과 함께 배포 된 것이 있습니다. 하나를 설치하려면 루트 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6c89afe408dffc3292c4743bcc6ff18a8191e1d0" translate="yes" xml:space="preserve">
          <source>Normally, you will want to start the database server when the computer boots. Autostart scripts are operating-system-specific. There are a few example scripts distributed with PostgreSQL in the &lt;code&gt;contrib/start-scripts&lt;/code&gt; directory. Installing one will require root privileges.</source>
          <target state="translated">일반적으로 컴퓨터가 부팅 될 때 데이터베이스 서버를 시작하려고합니다. 자동 시작 스크립트는 운영 체제별로 다릅니다. &lt;code&gt;contrib/start-scripts&lt;/code&gt; 디렉토리에 PostgreSQL과 함께 배포되는 몇 가지 예제 스크립트가 있습니다 . 설치하려면 루트 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="99872ab32108649405bf8805c9de4baeb85fb7ad" translate="yes" xml:space="preserve">
          <source>North European</source>
          <target state="translated">북유럽</target>
        </trans-unit>
        <trans-unit id="f79ff66cfb084d1746f64ba03a393ded056f91f0" translate="yes" xml:space="preserve">
          <source>Not all client APIs support all the listed character sets. For example, the PostgreSQL JDBC driver does not support &lt;code&gt;MULE_INTERNAL&lt;/code&gt;, &lt;code&gt;LATIN6&lt;/code&gt;, &lt;code&gt;LATIN8&lt;/code&gt;, and &lt;code&gt;LATIN10&lt;/code&gt;.</source>
          <target state="translated">모든 클라이언트 API가 나열된 모든 문자 세트를 지원하지는 않습니다. 예를 들어 PostgreSQL JDBC 드라이버는 &lt;code&gt;MULE_INTERNAL&lt;/code&gt; , &lt;code&gt;LATIN6&lt;/code&gt; , &lt;code&gt;LATIN8&lt;/code&gt; 및 &lt;code&gt;LATIN10&lt;/code&gt; 을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9bacd7c0a9a33892b688e78e77b6ecea0ecffd5d" translate="yes" xml:space="preserve">
          <source>Not all of the requested files will be WAL segment files; you should also expect requests for files with a suffix of &lt;code&gt;.history&lt;/code&gt;. Also be aware that the base name of the &lt;code&gt;%p&lt;/code&gt; path will be different from &lt;code&gt;%f&lt;/code&gt;; do not expect them to be interchangeable.</source>
          <target state="translated">요청 된 파일이 모두 WAL 세그먼트 파일이되는 것은 아닙니다. 접미사가 &lt;code&gt;.history&lt;/code&gt; 인 파일에 대한 요청도 예상해야합니다 . 또한 &lt;code&gt;%p&lt;/code&gt; 경로 의 기본 이름은 &lt;code&gt;%f&lt;/code&gt; 와 다릅니다 . 그것들이 상호 교환 될 것으로 기대하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="91e930192ef14cc5c350419a549c884c45961c36" translate="yes" xml:space="preserve">
          <source>Not between (the negation of &lt;code id=&quot;between&quot;&gt;BETWEEN&lt;/code&gt;).</source>
          <target state="translated">( &lt;code id=&quot;between&quot;&gt;BETWEEN&lt;/code&gt; 의 부정) 사이가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="d5510ea0072017c65967037de500e9abf1a00ab2" translate="yes" xml:space="preserve">
          <source>Not between, after sorting the two endpoint values.</source>
          <target state="translated">두 끝점 값을 정렬 한 후 사이가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6eb5b8bcff17673aebb4af5a3aeb0b4ab1932316" translate="yes" xml:space="preserve">
          <source>Not equal</source>
          <target state="translated">같지 않다</target>
        </trans-unit>
        <trans-unit id="feb1931a7fb65e60520184c9226b83ff8b5335ec" translate="yes" xml:space="preserve">
          <source>Not equal, treating null as a comparable value.</source>
          <target state="translated">같지 않음, null을 비교 가능한 값으로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="6f925a3c210bc672e17b8d68ff775e287c505fff" translate="yes" xml:space="preserve">
          <source>Not every user has authorization to create new databases. If PostgreSQL refuses to create databases for you then the site administrator needs to grant you permission to create databases. Consult your site administrator if this occurs. If you installed PostgreSQL yourself then you should log in for the purposes of this tutorial under the user account that you started the server as. &lt;a href=&quot;#ftn.id-1.4.3.4.10.4&quot;&gt;&lt;sup id=&quot;id-1.4.3.4.10.4&quot;&gt;[1]&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">모든 사용자가 새 데이터베이스를 만들 권한이있는 것은 아닙니다. PostgreSQL이 데이터베이스 생성을 거부하면 사이트 관리자가 데이터베이스 생성 권한을 부여해야합니다. 이 경우 사이트 관리자에게 문의하십시오. PostgreSQL을 직접 설치 한 경우 서버를 시작한 사용자 계정으로이 자습서의 목적으로 로그인해야합니다. &lt;a href=&quot;#ftn.id-1.4.3.4.10.4&quot;&gt;&lt;sup id=&quot;id-1.4.3.4.10.4&quot;&gt;[1]&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7dd5e10546306e9d83ef043283f9c8c8719bbf88" translate="yes" xml:space="preserve">
          <source>Not possible</source>
          <target state="translated">불가능</target>
        </trans-unit>
        <trans-unit id="14141efdb351648cd5997a4ec11511c9b9025f02" translate="yes" xml:space="preserve">
          <source>Not the password (always reads as &lt;code&gt;********&lt;/code&gt;)</source>
          <target state="translated">비밀번호가 아님 (항상 &lt;code&gt;********&lt;/code&gt; 로 읽음 )</target>
        </trans-unit>
        <trans-unit id="5b3582a3ba934510ccb693b77b7924863143d181" translate="yes" xml:space="preserve">
          <source>Notable differences between the existing POSIX-based regular-expression feature and XQuery regular expressions include:</source>
          <target state="translated">기존 POSIX 기반 정규 표현식 기능과 XQuery 정규 표현식의 주요 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="9b3331f6b2637140f06fa920c5a275390198583a" translate="yes" xml:space="preserve">
          <source>Note also that if one is relying on explicit locking to prevent concurrent changes, one should either use Read Committed mode, or in Repeatable Read mode be careful to obtain locks before performing queries. A lock obtained by a repeatable read transaction guarantees that no other transactions modifying the table are still running, but if the snapshot seen by the transaction predates obtaining the lock, it might predate some now-committed changes in the table. A repeatable read transaction's snapshot is actually frozen at the start of its first query or data-modification command (&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;), so it is possible to obtain locks explicitly before the snapshot is frozen.</source>
          <target state="translated">동시 변경을 방지하기 위해 명시 적 잠금에 의존하는 경우 읽기 커밋 모드를 사용하거나 반복 가능한 읽기 모드에서 쿼리를 수행하기 전에 잠금을 얻도록주의해야합니다. 반복 가능한 읽기 트랜잭션에 의해 획득 된 잠금은 테이블을 수정하는 다른 트랜잭션이 아직 실행 중임을 보장하지 않지만, 트랜잭션에 의해 표시된 스냅 샷이 잠금을 획득하기 전에 테이블에서 현재 커밋 된 일부 변경 사항보다 오래 될 수 있습니다. 반복 가능한 읽기 트랜잭션의 스냅 샷은 실제로 첫 번째 쿼리 또는 데이터 수정 명령 ( &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; ) 이 시작될 때 고정 되므로 스냅 샷이 고정되기 전에 명시 적으로 잠금을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7593ffc9010adfe129fd98d3fee440d02e9a7b83" translate="yes" xml:space="preserve">
          <source>Note however that if multiple standby servers are restoring from the same archive directory, you will need to ensure that you do not delete WAL files until they are no longer needed by any of the servers. &lt;code&gt;archive_cleanup_command&lt;/code&gt; would typically be used in a warm-standby configuration (see &lt;a href=&quot;warm-standby&quot;&gt;Section 26.2&lt;/a&gt;). Write &lt;code&gt;%%&lt;/code&gt; to embed an actual &lt;code&gt;%&lt;/code&gt; character in the command.</source>
          <target state="translated">그러나 여러 대기 서버가 동일한 아카이브 디렉토리에서 복원하는 경우 서버에서 더 이상 필요하지 않을 때까지 WAL 파일을 삭제하지 않아야합니다. &lt;code&gt;archive_cleanup_command&lt;/code&gt; 는 일반적으로 웜 스탠바이 구성에 사용됩니다 ( &lt;a href=&quot;warm-standby&quot;&gt;26.2 절&lt;/a&gt; 참조 ). 명령에 실제 &lt;code&gt;%&lt;/code&gt; 문자 를 포함 시키려면 &lt;code&gt;%%&lt;/code&gt; 를 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="a9a98603977441f8554a2833afe694dbcfe6aeee" translate="yes" xml:space="preserve">
          <source>Note however that simple names are matched to column names before table names, so this example works only because there is no column named &lt;code&gt;c&lt;/code&gt; in the query's tables.</source>
          <target state="translated">그러나 단순 이름은 테이블 이름 이전의 열 이름과 일치하므로이 예 는 쿼리 테이블에 &lt;code&gt;c&lt;/code&gt; 라는 열이 없기 때문에 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="90893364f9fe7dce948b26423ee4ecd2e88b2f16" translate="yes" xml:space="preserve">
          <source>Note however that you &lt;em&gt;cannot&lt;/em&gt; accomplish that effect with a command limited to a single schema. This command has no effect, unless it is undoing a matching &lt;code&gt;GRANT&lt;/code&gt;:</source>
          <target state="translated">그러나 단일 스키마로 제한된 명령으로는 이러한 효과 를 얻을 &lt;em&gt;수 없습니다&lt;/em&gt; . 이 명령은 일치하는 &lt;code&gt;GRANT&lt;/code&gt; 를 실행 취소하지 않는 한 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0aef3a8d9770be0e69a039281f14778156239350" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;try all combinations&amp;rdquo; is not a realistic exercise. Usually password cracking is done with the help of dictionaries, which contain both regular words and various mutations of them. So, even somewhat word-like passwords could be cracked much faster than the above numbers suggest, while a 6-character non-word-like password may escape cracking. Or not.</source>
          <target state="translated">&quot;모든 조합을 시도하십시오&quot;는 현실적인 연습이 아닙니다. 일반적으로 비밀번호 크래킹은 사전의 도움으로 이루어지며 여기에는 규칙적인 단어와 다양한 변형이 포함됩니다. 따라서 6 자리가 아닌 단어와 같은 암호는 크랙을 피할 수있는 반면, 단어와 비슷한 암호는 위의 숫자보다 훨씬 빠르게 해독 될 수 있습니다. 아님</target>
        </trans-unit>
        <trans-unit id="00e6a4c57a18e5fbbf85ff612c2a3727ded13249" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;/etc/rc&lt;/code&gt; is usually overwritten by macOS system updates, so you should expect to have to redo these edits after each update.</source>
          <target state="translated">참고 있음 &lt;code&gt;/etc/rc&lt;/code&gt; 각 업데이트 후이 편집을 다시 실행을 감수해야하므로 일반적으로, 맥 OS 시스템 업데이트로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="27a1cfa3bf0ee9c52c7a87330ba166c5fa86db79" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GREATEST&lt;/code&gt; and &lt;code&gt;LEAST&lt;/code&gt; are not in the SQL standard, but are a common extension. Some other databases make them return NULL if any argument is NULL, rather than only when all are NULL.</source>
          <target state="translated">참고 &lt;code&gt;GREATEST&lt;/code&gt; 와 &lt;code&gt;LEAST&lt;/code&gt; 는 SQL 표준에 있지 않은,하지만 일반적인 확장이다. 일부 다른 데이터베이스는 모든 인수가 NULL 일 때가 아니라 인수가 NULL 인 경우 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d1e87e3a532a3c85a5fb7cefcf86b5bd58f7519a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;INSERT&lt;/code&gt; with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; checks &lt;code&gt;INSERT&lt;/code&gt; policies' &lt;code&gt;WITH CHECK&lt;/code&gt; expressions only for rows appended to the relation by the &lt;code&gt;INSERT&lt;/code&gt; path.</source>
          <target state="translated">참고 &lt;code&gt;INSERT&lt;/code&gt; 와 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 검사 &lt;code&gt;INSERT&lt;/code&gt; 의 정책 ' &lt;code&gt;WITH CHECK&lt;/code&gt; 단지로의 관계에 추가 행에 대한 식을 &lt;code&gt;INSERT&lt;/code&gt; 경로.</target>
        </trans-unit>
        <trans-unit id="c319652e77f1cdd2df39e790f0f919f2b95a2486" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;amcheck&lt;/code&gt; examines a page as represented in some shared memory buffer at the time of verification if there is only a shared buffer hit when accessing the block. Consequently, &lt;code&gt;amcheck&lt;/code&gt; does not necessarily examine data read from the file system at the time of verification. Note that when checksums are enabled, &lt;code&gt;amcheck&lt;/code&gt; may raise an error due to a checksum failure when a corrupt block is read into a buffer.</source>
          <target state="translated">참고 &lt;code&gt;amcheck&lt;/code&gt; 이 블록에 액세스하는 경우에만 공유 버퍼 히트가 있는지 확인시 일부 공유 메모리 버퍼에 표시된 바와 같이 페이지를 검사한다. 결과적으로 &lt;code&gt;amcheck&lt;/code&gt; 는 검증시 파일 시스템에서 읽은 데이터를 반드시 검사하지는 않습니다. 체크섬이 활성화 되면 손상된 블록을 버퍼로 읽을 때 체크섬 오류로 인해 &lt;code&gt;amcheck&lt;/code&gt; 에서 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef24e95dba1150cbef958d74c2f80a5630d7740c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;extract&lt;/code&gt;'s day of the week numbering differs from that of the &lt;code&gt;to_char(..., 'D')&lt;/code&gt; function.</source>
          <target state="translated">참고 &lt;code&gt;extract&lt;/code&gt; '의 그것과 다르다 번호 주중의 날 &lt;code&gt;to_char(..., 'D')&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="993b93174865d889f669c89fbc134d310b24fd79" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;first_value&lt;/code&gt;, &lt;code&gt;last_value&lt;/code&gt;, and &lt;code&gt;nth_value&lt;/code&gt; consider only the rows within the &amp;ldquo;window frame&amp;rdquo;, which by default contains the rows from the start of the partition through the last peer of the current row. This is likely to give unhelpful results for &lt;code&gt;last_value&lt;/code&gt; and sometimes also &lt;code&gt;nth_value&lt;/code&gt;. You can redefine the frame by adding a suitable frame specification (&lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;ROWS&lt;/code&gt; or &lt;code&gt;GROUPS&lt;/code&gt;) to the &lt;code&gt;OVER&lt;/code&gt; clause. See &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;Section 4.2.8&lt;/a&gt; for more information about frame specifications.</source>
          <target state="translated">참고 &lt;code&gt;first_value&lt;/code&gt; , &lt;code&gt;last_value&lt;/code&gt; 및 &lt;code&gt;nth_value&lt;/code&gt; 기본적으로 현재 행의 마지막 피어를 통해 파티션의 시작부터 행을 포함하는 &quot;창 프레임&quot;내에서만 행을 고려하십시오. 이것은 인정에 대한 결과를 줄 가능성이 &lt;code&gt;last_value&lt;/code&gt; 때로는 및 &lt;code&gt;nth_value&lt;/code&gt; 을 . 적절한 프레임 스펙 ( &lt;code&gt;RANGE&lt;/code&gt; , &lt;code&gt;ROWS&lt;/code&gt; 또는 &lt;code&gt;GROUPS&lt;/code&gt; )을 &lt;code&gt;OVER&lt;/code&gt; 절 에 추가하여 프레임을 재정의 할 수 있습니다 . 프레임 사양에 대한 자세한 내용은 &lt;a href=&quot;sql-expressions#SYNTAX-WINDOW-FUNCTIONS&quot;&gt;4.2.8 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e089463c04f2f8771502e8d62b431f3c71d88b7d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;m&lt;/code&gt; columns can also be moved out to secondary storage, but only as a last resort (&lt;code&gt;e&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; columns are moved first).</source>
          <target state="translated">참고 &lt;code&gt;m&lt;/code&gt; 의 열은 또한 보조 저장 밖으로 이동 될 수 있지만, 최후로 ( &lt;code&gt;e&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 열이 먼저 이동).</target>
        </trans-unit>
        <trans-unit id="40331004e0ffed62ad250a770b0b797c5ac46ee7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;max_standby_archive_delay&lt;/code&gt; is not the same as the maximum length of time a query can run before cancellation; rather it is the maximum total time allowed to apply any one WAL segment's data. Thus, if one query has resulted in significant delay earlier in the WAL segment, subsequent conflicting queries will have much less grace time.</source>
          <target state="translated">참고 &lt;code&gt;max_standby_archive_delay&lt;/code&gt; 은 쿼리가 취소되기 전에 실행할 수있는 최대 시간과 동일하지 않습니다; 오히려 하나의 WAL 세그먼트 데이터를 적용 할 수있는 최대 총 시간입니다. 따라서 하나의 쿼리로 인해 WAL 세그먼트의 초기에 상당한 지연이 발생하면 후속 충돌 쿼리의 유예 시간이 훨씬 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="d4ea769871b3208ec9bdd68befff4d7903f7eff9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; is not the same as the maximum length of time a query can run before cancellation; rather it is the maximum total time allowed to apply WAL data once it has been received from the primary server. Thus, if one query has resulted in significant delay, subsequent conflicting queries will have much less grace time until the standby server has caught up again.</source>
          <target state="translated">참고 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 은 쿼리가 취소되기 전에 실행할 수있는 최대 시간과 동일하지 않습니다; 오히려 주 서버에서 WAL 데이터를 수신 한 후 적용 할 수있는 최대 총 시간입니다. 따라서 하나의 쿼리로 인해 상당한 지연이 발생하면 대기 서버가 다시 중단 될 때까지 후속 충돌 쿼리의 유예 시간이 훨씬 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="d6596a8da6c53c8c974c373f17703e4e032c6d9e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;plainto_tsquery&lt;/code&gt; will not recognize &lt;code&gt;tsquery&lt;/code&gt; operators, weight labels, or prefix-match labels in its input:</source>
          <target state="translated">참고 &lt;code&gt;plainto_tsquery&lt;/code&gt; 가 인식하지 않습니다 &lt;code&gt;tsquery&lt;/code&gt; 입력 연산자, 체중 레이블 또는 접두사 일치 라벨 :</target>
        </trans-unit>
        <trans-unit id="531e2b77490742cd189acb5bc5e4276f0143a9de" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;postgres_fdw&lt;/code&gt; currently lacks support for &lt;code&gt;INSERT&lt;/code&gt; statements with an &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause. However, the &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; clause is supported, provided a unique index inference specification is omitted. Note also that &lt;code&gt;postgres_fdw&lt;/code&gt; supports row movement invoked by &lt;code&gt;UPDATE&lt;/code&gt; statements executed on partitioned tables, but it currently does not handle the case where a remote partition chosen to insert a moved row into is also an &lt;code&gt;UPDATE&lt;/code&gt; target partition that will be updated later.</source>
          <target state="translated">참고 &lt;code&gt;postgres_fdw&lt;/code&gt; 는 현재에 대한 지원이 부족 &lt;code&gt;INSERT&lt;/code&gt; 와 문 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 절을. 그러나 고유 색인 유추 스펙이 생략 되면 &lt;code&gt;ON CONFLICT DO NOTHING&lt;/code&gt; 절이 지원됩니다. 참고 또한 &lt;code&gt;postgres_fdw&lt;/code&gt; 의 지지체 열 운동에 의해 호출 &lt;code&gt;UPDATE&lt;/code&gt; 파티션 테이블에서 실행 문 있지만 현재로 이동 된 행을 삽입 선택된 원격 파티션도 인 경우에는 처리하지 않는 &lt;code&gt;UPDATE&lt;/code&gt; 이후 업데이트 될 타겟 파티션.</target>
        </trans-unit>
        <trans-unit id="9d0c357cbd644595d94bcf660fedeb383e698ab1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;to_tsquery&lt;/code&gt; will process prefixes in the same way as other words, which means this comparison returns true:</source>
          <target state="translated">참고 &lt;code&gt;to_tsquery&lt;/code&gt; 은 이 비교가 true를 돌려주는 의미의 다른 단어와 같은 방법에 접두사를 처리합니다 :</target>
        </trans-unit>
        <trans-unit id="547e51942705ea4910d562213bfd3cab3c67874d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;wal_receiver_timeout&lt;/code&gt;, &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; and &lt;code&gt;wal_retrieve_retry_interval&lt;/code&gt; configuration parameters affect the logical replication workers as well.</source>
          <target state="translated">참고 &lt;code&gt;wal_receiver_timeout&lt;/code&gt; 을 , &lt;code&gt;wal_receiver_status_interval&lt;/code&gt; 및 &lt;code&gt;wal_retrieve_retry_interval&lt;/code&gt; 구성 매개 변수가 아니라 논리적 복제 노동자에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="e5c3c7860afae265b42af4a1e6e8bf5af951d1e2" translate="yes" xml:space="preserve">
          <source>Note that GIN index build time can often be improved by increasing &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;, while GiST index build time is not sensitive to that parameter.</source>
          <target state="translated">GIN 인덱스 빌드 시간은 종종 &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt; 을 늘려서 향상시킬 수 있지만 GiST 인덱스 빌드 시간은 해당 매개 변수에 민감하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b8a5f57b365044d35823a4b451d18873918bc73" translate="yes" xml:space="preserve">
          <source>Note that XML forests are not valid XML documents if they consist of more than one element, so it might be useful to wrap &lt;code&gt;xmlforest&lt;/code&gt; expressions in &lt;code&gt;xmlelement&lt;/code&gt;.</source>
          <target state="translated">XML 포리스트는 둘 이상의 요소로 구성된 경우 유효한 XML 문서가 아니므로 &lt;code&gt;xmlforest&lt;/code&gt; 식을 &lt;code&gt;xmlelement&lt;/code&gt; 로 감싸는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41bc51ade685b6e9a9074785e60b9928bfbc83ce" translate="yes" xml:space="preserve">
          <source>Note that a file system backup will typically be larger than an SQL dump. (pg_dump does not need to dump the contents of indexes for example, just the commands to recreate them.) However, taking a file system backup might be faster.</source>
          <target state="translated">파일 시스템 백업은 일반적으로 SQL 덤프보다 큽니다. (pg_dump는 인덱스의 내용을 덤프 할 필요가 없습니다. 예를 들어, 인덱스를 다시 작성하는 명령 만 있습니다.) 그러나 파일 시스템 백업을 수행하는 것이 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c32d659dad68b2cd17eab976deb46f2e6ed59ea" translate="yes" xml:space="preserve">
          <source>Note that a foreign table can be declared with fewer columns, or with a different column order, than its underlying remote table has. Matching of columns to the remote table is by name, not position.</source>
          <target state="translated">외부 테이블은 기본 원격 테이블보다 적은 수의 열 또는 다른 열 순서로 선언 될 수 있습니다. 리모트 테이블에 컬럼을 일치시키는 것은 위치가 아니라 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c47a3a43d56fab6f7325c7aa20434bcba1bc9c0b" translate="yes" xml:space="preserve">
          <source>Note that all data types use rather obvious input formats. Constants that are not simple numeric values usually must be surrounded by single quotes (&lt;code&gt;'&lt;/code&gt;), as in the example. The &lt;code&gt;date&lt;/code&gt; type is actually quite flexible in what it accepts, but for this tutorial we will stick to the unambiguous format shown here.</source>
          <target state="translated">모든 데이터 유형은 명백한 입력 형식을 사용합니다. 간단한 숫자 값이 아닌 상수는 일반적으로 예제와 같이 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; )로 묶어야합니다 . &lt;code&gt;date&lt;/code&gt; 형식은 실제로 받아들이는 것에 매우 유연하지만이 튜토리얼 우리는 여기에 표시된 명확한 형식에 충실 할 것이다.</target>
        </trans-unit>
        <trans-unit id="25d42cd6ceef922ecf25e7b24fce40695e12cb56" translate="yes" xml:space="preserve">
          <source>Note that all other sessions will immediately be able to see the data once it has been successfully loaded. This violates the normal rules of MVCC visibility and users specifying should be aware of the potential problems this might cause.</source>
          <target state="translated">다른 모든 세션은 데이터가 성공적으로로드되면 즉시 데이터를 볼 수 있습니다. 이는 일반적인 MVCC 가시성 규칙에 위배되며이를 지정하는 사용자는 이로 인해 발생할 수있는 잠재적 문제를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="df99d378fb51575b390c0b84d9d7987211c8c70b" translate="yes" xml:space="preserve">
          <source>Note that all the solutions described above take care of starting new log files at configurable intervals, but they do not handle deletion of old, no-longer-useful log files. You will probably want to set up a batch job to periodically delete old log files. Another possibility is to configure the rotation program so that old log files are overwritten cyclically.</source>
          <target state="translated">위에서 설명한 모든 솔루션은 구성 가능한 간격으로 새 로그 파일을 시작하는 것을 처리하지만 더 오래 사용되지 않는 오래된 로그 파일의 삭제는 처리하지 않습니다. 오래된 로그 파일을 주기적으로 삭제하도록 배치 작업을 설정하려고 할 수 있습니다. 또 다른 가능성은 회전 로그 프로그램을 구성하여 오래된 로그 파일을 주기적으로 덮어 쓰는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2c87d02f3e8f6257698af02e373aea3121b7dc2e" translate="yes" xml:space="preserve">
          <source>Note that although WAL archiving will allow you to restore any modifications made to the data in your PostgreSQL database, it will not restore changes made to configuration files (that is, &lt;code&gt;postgresql.conf&lt;/code&gt;, &lt;code&gt;pg_hba.conf&lt;/code&gt; and &lt;code&gt;pg_ident.conf&lt;/code&gt;), since those are edited manually rather than through SQL operations. You might wish to keep the configuration files in a location that will be backed up by your regular file system backup procedures. See &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Section 19.2&lt;/a&gt; for how to relocate the configuration files.</source>
          <target state="translated">WAL 아카이브를 사용하면 PostgreSQL 데이터베이스의 데이터에 대한 수정 사항을 복원 할 수 있지만 구성 파일 ( &lt;code&gt;postgresql.conf&lt;/code&gt; , &lt;code&gt;pg_hba.conf&lt;/code&gt; 및 &lt;code&gt;pg_ident.conf&lt;/code&gt; )에 대한 변경 사항은 복원되지 않습니다. SQL 작업 대신 수동으로 편집했습니다. 일반 파일 시스템 백업 절차에 의해 백업 될 위치에 구성 파일을 보관할 수 있습니다. 구성 파일을 재배치하는 방법 &lt;a href=&quot;runtime-config-file-locations&quot;&gt;은 19.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d53090021f825a89df9ea9e9d71eae604c7c4a95" translate="yes" xml:space="preserve">
          <source>Note that an &lt;code&gt;AS&lt;/code&gt; clause is required when &lt;code&gt;VALUES&lt;/code&gt; is used in a &lt;code&gt;FROM&lt;/code&gt; clause, just as is true for &lt;code&gt;SELECT&lt;/code&gt;. It is not required that the &lt;code&gt;AS&lt;/code&gt; clause specify names for all the columns, but it's good practice to do so. (The default column names for &lt;code&gt;VALUES&lt;/code&gt; are &lt;code&gt;column1&lt;/code&gt;, &lt;code&gt;column2&lt;/code&gt;, etc in PostgreSQL, but these names might be different in other database systems.)</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 의 경우와 마찬가지로 &lt;code&gt;FROM&lt;/code&gt; 절 에서 &lt;code&gt;VALUES&lt;/code&gt; 를 사용 하는 경우 &lt;code&gt;AS&lt;/code&gt; 절이 필요합니다 . &lt;code&gt;AS&lt;/code&gt; 절이 모든 열의 이름을 지정할 필요는 없지만 그렇게하는 것이 좋습니다. ( PostgreSQL에서 &lt;code&gt;VALUES&lt;/code&gt; 의 기본 열 이름 은 &lt;code&gt;column1&lt;/code&gt; , &lt;code&gt;column2&lt;/code&gt; 등이지만 다른 데이터베이스 시스템에서는 이름이 다를 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="2b4af4e58c7c07f18643d7fac4e1368ce1d5e583" translate="yes" xml:space="preserve">
          <source>Note that any particular role will have the sum of privileges granted directly to it, privileges granted to any role it is presently a member of, and privileges granted to &lt;code&gt;PUBLIC&lt;/code&gt;. Thus, for example, revoking &lt;code&gt;SELECT&lt;/code&gt; privilege from &lt;code&gt;PUBLIC&lt;/code&gt; does not necessarily mean that all roles have lost &lt;code&gt;SELECT&lt;/code&gt; privilege on the object: those who have it granted directly or via another role will still have it. Similarly, revoking &lt;code&gt;SELECT&lt;/code&gt; from a user might not prevent that user from using &lt;code&gt;SELECT&lt;/code&gt; if &lt;code&gt;PUBLIC&lt;/code&gt; or another membership role still has &lt;code&gt;SELECT&lt;/code&gt; rights.</source>
          <target state="translated">특정 역할에는 해당 역할에 직접 부여 된 권한, 현재 구성원 인 모든 역할에 부여 된 권한 및 &lt;code&gt;PUBLIC&lt;/code&gt; 에 부여 된 권한의 합계가 있습니다 . 예를 들어 &lt;code&gt;PUBLIC&lt;/code&gt; 에서 &lt;code&gt;SELECT&lt;/code&gt; 권한을 취소 한다고해서 모든 역할이 객체에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한을 잃어버린 것은 아닙니다 . 직접 또는 다른 역할을 통해 권한을 부여한 사람에게는 여전히 권한이 있습니다. 마찬가지로 &lt;code&gt;PUBLIC&lt;/code&gt; 또는 다른 멤버십 역할에 여전히 &lt;code&gt;SELECT&lt;/code&gt; 권한 이있는 경우 사용자에서 &lt;code&gt;SELECT&lt;/code&gt; 를 취소 하면 해당 사용자가 &lt;code&gt;SELECT&lt;/code&gt; 를 사용하지 못할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2fd76787f2a53ba7fb758f8a964cdd22772c1d78" translate="yes" xml:space="preserve">
          <source>Note that because &lt;code&gt;recovery.signal&lt;/code&gt; will not be removed when &lt;code&gt;recovery_target_action&lt;/code&gt; is set to &lt;code&gt;shutdown&lt;/code&gt;, any subsequent start will end with immediate shutdown unless the configuration is changed or the &lt;code&gt;recovery.signal&lt;/code&gt; file is removed manually.</source>
          <target state="translated">그 때문에 참고 &lt;code&gt;recovery.signal&lt;/code&gt; 이 때 제거되지 않습니다 &lt;code&gt;recovery_target_action&lt;/code&gt; 이 설정되어 &lt;code&gt;shutdown&lt;/code&gt; 구성이 변경되거나하지 않는 한, 후속 시작은 즉시 종료와 함께 종료됩니다 &lt;code&gt;recovery.signal&lt;/code&gt; 파일을 수동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9c33fcc287f27c5bc2a2b32d53b1b513b1091d88" translate="yes" xml:space="preserve">
          <source>Note that casting to just &amp;ldquo;bit&amp;rdquo; means casting to &lt;code&gt;bit(1)&lt;/code&gt;, and so will deliver only the least significant bit of the integer.</source>
          <target state="translated">&quot;비트&quot;로 캐스팅하는 것은 &lt;code&gt;bit(1)&lt;/code&gt; 캐스팅하는 것을 의미 하므로 정수의 최하위 비트 만 전달합니다.</target>
        </trans-unit>
        <trans-unit id="fd0a0fb6f9e97d5efee795fd874b77207c725a32" translate="yes" xml:space="preserve">
          <source>Note that collecting the additional timing information needed for per-statement latency computation adds some overhead. This will slow average execution speed and lower the computed TPS. The amount of slowdown varies significantly depending on platform and hardware. Comparing average TPS values with and without latency reporting enabled is a good way to measure if the timing overhead is significant.</source>
          <target state="translated">명령문 별 대기 시간 계산에 필요한 추가 타이밍 정보를 수집하면 약간의 오버 헤드가 추가됩니다. 그러면 평균 실행 속도가 느려지고 계산 된 TPS가 낮아집니다. 성능 저하 정도는 플랫폼 및 하드웨어에 따라 크게 다릅니다. 지연 시간보고를 사용하거나 사용하지 않는 평균 TPS 값을 비교하면 타이밍 오버 헤드가 중요한지 측정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46048f7966588bd79b584545411fe217e62e0e87" translate="yes" xml:space="preserve">
          <source>Note that constraints other than &lt;code&gt;NOT NULL&lt;/code&gt; will never be imported from the remote tables. Although PostgreSQL does support &lt;code&gt;CHECK&lt;/code&gt; constraints on foreign tables, there is no provision for importing them automatically, because of the risk that a constraint expression could evaluate differently on the local and remote servers. Any such inconsistency in the behavior of a &lt;code&gt;CHECK&lt;/code&gt; constraint could lead to hard-to-detect errors in query optimization. So if you wish to import &lt;code&gt;CHECK&lt;/code&gt; constraints, you must do so manually, and you should verify the semantics of each one carefully. For more detail about the treatment of &lt;code&gt;CHECK&lt;/code&gt; constraints on foreign tables, see &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;NOT NULL&lt;/code&gt; 이외의 제약 조건 은 원격 테이블에서 가져 오지 않습니다. PostgreSQL은 외부 테이블에 대한 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건을 지원하지만 제약 조건식이 로컬 및 원격 서버에서 다르게 평가 될 위험 때문에 자동으로 가져 오기를 제공 할 수 없습니다. &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 의 동작에 이러한 불일치 가 있으면 쿼리 최적화에서 오류를 감지하기 어려울 수 있습니다. 따라서 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 을 가져 오려면 수동으로 가져와야 하며 각각의 의미를 신중하게 확인해야합니다. 외부 테이블 의 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 처리에 대한 자세한 내용 은 &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="699164176c152ba6b84d675ad75f5ace743cae19" translate="yes" xml:space="preserve">
          <source>Note that cost estimate functions must be written in C, not in SQL or any available procedural language, because they must access internal data structures of the planner/optimizer.</source>
          <target state="translated">비용 산정 함수는 플래너 / 최적화 프로그램의 내부 데이터 구조에 액세스해야하므로 SQL 또는 사용 가능한 절차 언어가 아닌 C로 작성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="06d4a3361a37979804bf5a58a39eb486b3f91ba2" translate="yes" xml:space="preserve">
          <source>Note that deadlocks can also occur as the result of row-level locks (and thus, they can occur even if explicit locking is not used). Consider the case in which two concurrent transactions modify a table. The first transaction executes:</source>
          <target state="translated">교착 상태는 행 수준 잠금의 결과로 발생할 수도 있습니다 (따라서 명시 적 잠금을 사용하지 않더라도 발생할 수 있음). 두 개의 동시 트랜잭션이 테이블을 수정하는 경우를 고려하십시오. 첫 번째 트랜잭션은 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="6082e5afeea05f3f2e208c50995f15f349743dca" translate="yes" xml:space="preserve">
          <source>Note that deduplication is deemed unsafe and cannot be used in the following cases involving semantically significant differences among equal datums:</source>
          <target state="translated">중복 제거는 안전하지 않은 것으로 간주되며 동일한 데이터 간의 의미 상 중요한 차이가 포함 된 다음과 같은 경우에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8001d46d3d20b93246bb06a2398e61902d0e24f2" translate="yes" xml:space="preserve">
          <source>Note that different keys may have the same ID. This is rare but a normal event. The client application should then try to decrypt with each one, to see which fits &amp;mdash; like handling &lt;code&gt;ANYKEY&lt;/code&gt;.</source>
          <target state="translated">다른 키는 동일한 ID를 가질 수 있습니다. 이것은 드물지만 정상적인 사건입니다. 그런 다음 클라이언트 응용 프로그램은 각각을 해독하여 &lt;code&gt;ANYKEY&lt;/code&gt; 처리와 같이 어느 것이 적합한 지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8d9652ff899a1fe6db38db0e7bf8d1018609b472" translate="yes" xml:space="preserve">
          <source>Note that different units are used for the per loop time than the histogram. The loop can have resolution within a few nanoseconds (ns), while the individual timing calls can only resolve down to one microsecond (us).</source>
          <target state="translated">루프 당 시간에는 히스토그램과 다른 단위가 사용됩니다. 루프는 몇 나노초 (ns) 내에서 해상도를 가질 수있는 반면 개별 타이밍 호출은 1 마이크로 초 (us)까지만 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8463fb9b10613a7f093421dc720a6dd930e1df32" translate="yes" xml:space="preserve">
          <source>Note that enabling or disabling group access on an existing cluster requires the cluster to be shut down and the appropriate mode to be set on all directories and files before restarting PostgreSQL. Otherwise, a mix of modes might exist in the data directory. For clusters that allow access only by the owner, the appropriate modes are &lt;code&gt;0700&lt;/code&gt; for directories and &lt;code&gt;0600&lt;/code&gt; for files. For clusters that also allow reads by the group, the appropriate modes are &lt;code&gt;0750&lt;/code&gt; for directories and &lt;code&gt;0640&lt;/code&gt; for files.</source>
          <target state="translated">기존 클러스터에서 그룹 액세스를 활성화 또는 비활성화하려면 PostgreSQL을 다시 시작하기 전에 클러스터를 종료하고 모든 디렉토리와 파일에 적절한 모드를 설정해야합니다. 그렇지 않으면, 혼합 모드가 데이터 디렉토리에 존재할 수 있습니다. 소유자 만 액세스 할 수있는 클러스터의 경우 적합한 모드는 디렉토리의 경우 &lt;code&gt;0700&lt;/code&gt; 이고 파일의 경우 &lt;code&gt;0600&lt;/code&gt; 입니다. 그룹이 읽을 수있는 클러스터의 경우 적절한 모드는 디렉토리의 경우 &lt;code&gt;0750&lt;/code&gt; 이고 파일의 경우 &lt;code&gt;0640&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="836bf1d98935001a9e7ffe81c54955b795aef94c" translate="yes" xml:space="preserve">
          <source>Note that even when this parameter is disabled, the system will launch autovacuum processes if necessary to prevent transaction ID wraparound. See &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;Section 24.1.5&lt;/a&gt; for more information.</source>
          <target state="translated">이 매개 변수가 사용 불가능한 경우에도 시스템은 트랜잭션 ID 랩 어라운드를 방지하기 위해 자동 진공 프로세스를 시작합니다. 자세한 정보는 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-WRAPAROUND&quot;&gt;24.1.5 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f1ea5bec1703e5249cd8348fa7e3e07222422cf" translate="yes" xml:space="preserve">
          <source>Note that exclusion constraints are not supported as arbiters with &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt;. In all cases, only &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; constraints and unique indexes are supported as arbiters.</source>
          <target state="translated">&lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 가있는 중재자로는 제외 제약 조건이 지원되지 않습니다 . 모든 경우에 &lt;code&gt;NOT DEFERRABLE&lt;/code&gt; 제한 조건 및 고유 색인 만 중재자로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8de881cb4486af9a5996e8f814cf056ae7026e35" translate="yes" xml:space="preserve">
          <source>Note that for constraint triggers, evaluation of the &lt;code&gt;WHEN&lt;/code&gt; condition is not deferred, but occurs immediately after the row update operation is performed. If the condition does not evaluate to true then the trigger is not queued for deferred execution.</source>
          <target state="translated">제한 조건 트리거의 경우 &lt;code&gt;WHEN&lt;/code&gt; 조건의 평가는 지연되지 않지만 행 업데이트 조작이 수행 된 직후에 수행됩니다. 조건이 true로 평가되지 않으면 지연된 실행을 위해 트리거가 대기하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0be6e3fd01fb4ed50e92212c3560099998e4c687" translate="yes" xml:space="preserve">
          <source>Note that for historic reasons, the function &lt;code&gt;md5&lt;/code&gt; returns a hex-encoded value of type &lt;code&gt;text&lt;/code&gt; whereas the SHA-2 functions return type &lt;code&gt;bytea&lt;/code&gt;. Use the functions &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; to convert between the two, for example &lt;code&gt;encode(sha256('abc'), 'hex')&lt;/code&gt; to get a hex-encoded text representation.</source>
          <target state="translated">역사적인 이유로 인해 &lt;code&gt;md5&lt;/code&gt; 함수는 16 진수로 인코딩 된 &lt;code&gt;text&lt;/code&gt; 유형의 값을 리턴하고 SHA-2 함수는 유형 &lt;code&gt;bytea&lt;/code&gt; 를 리턴합니다 . &lt;code&gt;encode&lt;/code&gt; 및 &lt;code&gt;decode&lt;/code&gt; 기능을 사용하여 두 가지 사이를 변환하십시오 &lt;code&gt;encode(sha256('abc'), 'hex')&lt;/code&gt; 예 : encode (sha256 ( 'abc'), 'hex')) .</target>
        </trans-unit>
        <trans-unit id="cfe04c8846d33d71c984b2b6f7148e6d08053137" translate="yes" xml:space="preserve">
          <source>Note that foreign tables that use a foreign-data wrapper with no handler cannot be accessed.</source>
          <target state="translated">핸들러없이 외래 데이터 래퍼를 사용하는 외래 테이블에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="02035a3862ae6605e031adf46021fcd89539c880" translate="yes" xml:space="preserve">
          <source>Note that granting users the EXECUTE privilege on &lt;code&gt;pg_read_file()&lt;/code&gt;, or related functions, allows them the ability to read any file on the server that the database server process can read; these functions bypass all in-database privilege checks. This means that, for example, a user with such access is able to read the contents of the &lt;code&gt;pg_authid&lt;/code&gt; table where authentication information is stored, as well as read any table data in the database. Therefore, granting access to these functions should be carefully considered.</source>
          <target state="translated">사용자에게 &lt;code&gt;pg_read_file()&lt;/code&gt; 또는 관련 함수 에 대한 EXECUTE 권한을 부여 하면 데이터베이스 서버 프로세스가 읽을 수있는 서버의 모든 파일을 읽을 수 있습니다. 이러한 함수는 모든 데이터베이스 내 권한 검사를 우회합니다. 예를 들어, 이러한 액세스 권한을 가진 사용자는 인증 정보가 저장된 &lt;code&gt;pg_authid&lt;/code&gt; 테이블 의 내용을 읽을 수있을 뿐만 아니라 데이터베이스의 모든 테이블 데이터를 읽을 수 있습니다. 따라서 이러한 기능에 대한 액세스 권한을 부여하는 것은 신중하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="5453a69c6ad7e7ddfed4130bdc5747df6c5fd62b" translate="yes" xml:space="preserve">
          <source>Note that granting users the EXECUTE privilege on &lt;code&gt;pg_read_file()&lt;/code&gt;, or related functions, allows them the ability to read any file on the server which the database can read and that those reads bypass all in-database privilege checks. This means that, among other things, a user with this access is able to read the contents of the &lt;code&gt;pg_authid&lt;/code&gt; table where authentication information is contained, as well as read any file in the database. Therefore, granting access to these functions should be carefully considered.</source>
          <target state="translated">사용자에게 &lt;code&gt;pg_read_file()&lt;/code&gt; 또는 관련 함수 에 대한 EXECUTE 특권을 부여 하면 데이터베이스에서 읽을 수있는 서버의 모든 파일을 읽을 수 있고 모든 데이터베이스 내 특권 검사를 무시할 수 있습니다. 즉,이 액세스 권한을 가진 사용자는 인증 정보가 포함 된 &lt;code&gt;pg_authid&lt;/code&gt; 테이블 의 내용을 읽을 수있을 뿐만 아니라 데이터베이스의 모든 파일을 읽을 수 있습니다. 따라서 이러한 기능에 대한 액세스 권한 부여를 신중하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd90b8fb5e3c2266322a8f9361a13beecb2d12fc" translate="yes" xml:space="preserve">
          <source>Note that here the &lt;code&gt;field&lt;/code&gt; parameter needs to be a string value, not a name. The valid field names for &lt;code&gt;date_part&lt;/code&gt; are the same as for &lt;code&gt;extract&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;field&lt;/code&gt; 매개 변수는 이름이 아닌 문자열 값이어야합니다. 유효한 필드 이름 &lt;code&gt;date_part&lt;/code&gt; 가 와 동일 &lt;code&gt;extract&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13c19c7fbcb3e2d4787b53bfa2ce9ac2e3e6f680" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;MINVALUE&lt;/code&gt; or &lt;code&gt;MAXVALUE&lt;/code&gt; is used for one column of a partitioning bound, the same value must be used for all subsequent columns. For example, &lt;code&gt;(10, MINVALUE, 0)&lt;/code&gt; is not a valid bound; you should write &lt;code&gt;(10, MINVALUE, MINVALUE)&lt;/code&gt;.</source>
          <target state="translated">분할 경계의 한 열에 &lt;code&gt;MINVALUE&lt;/code&gt; 또는 &lt;code&gt;MAXVALUE&lt;/code&gt; 를 사용 하는 경우 모든 후속 열에 동일한 값을 사용해야합니다. 예를 들어, &lt;code&gt;(10, MINVALUE, 0)&lt;/code&gt; 은 유효한 범위가 아닙니다. &lt;code&gt;(10, MINVALUE, MINVALUE)&lt;/code&gt; 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ba56c2e43467332103da0c13e1894f6a417084e8" translate="yes" xml:space="preserve">
          <source>Note that if a &lt;code&gt;FROM&lt;/code&gt; clause is not specified, the query cannot reference any database tables. For example, the following query is invalid:</source>
          <target state="translated">경우 참고 &lt;code&gt;FROM&lt;/code&gt; 절을 지정하지 쿼리는 데이터베이스 테이블을 참조 할 수 없습니다. 예를 들어 다음 쿼리는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90a3cd6b9233790897980d2c49eb8226596f6f8e" translate="yes" xml:space="preserve">
          <source>Note that if both &lt;code&gt;fields&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; are specified, the &lt;code&gt;fields&lt;/code&gt; must include &lt;code&gt;SECOND&lt;/code&gt;, since the precision applies only to the seconds.</source>
          <target state="translated">두 경우 참고 &lt;code&gt;fields&lt;/code&gt; 와 &lt;code&gt;p&lt;/code&gt; 지정의 &lt;code&gt;fields&lt;/code&gt; 포함해야 &lt;code&gt;SECOND&lt;/code&gt; 를 정밀도가 초 정보만을 적용하기 때문에.</target>
        </trans-unit>
        <trans-unit id="1ee74a393ded0f5a9715105cabc63616fc14f639" translate="yes" xml:space="preserve">
          <source>Note that if extra WAL files which are not required to recover the backup are present, they will not be checked by this tool, although a separate invocation of &lt;code&gt;pg_waldump&lt;/code&gt; could be used for that purpose. Also note that WAL verification is version-specific: you must use the version of &lt;code&gt;pg_verifybackup&lt;/code&gt;, and thus of &lt;code&gt;pg_waldump&lt;/code&gt;, which pertains to the backup being checked. In contrast, the data file integrity checks should work with any version of the server that generates a &lt;code&gt;backup_manifest&lt;/code&gt; file.</source>
          <target state="translated">백업을 복구하는 데 필요하지 않은 추가 WAL 파일이있는 경우 해당 목적 으로 &lt;code&gt;pg_waldump&lt;/code&gt; 를 개별적으로 호출 할 수 있지만이 도구는이 파일을 확인하지 않습니다 . 또한 WAL 확인은 버전에 따라 다릅니다. &lt;code&gt;pg_verifybackup&lt;/code&gt; 버전을 사용해야 하며, 따라서 확인중인 백업과 관련된 &lt;code&gt;pg_waldump&lt;/code&gt; 버전을 사용해야합니다 . 반대로 데이터 파일 무결성 검사는 &lt;code&gt;backup_manifest&lt;/code&gt; 파일 을 생성하는 모든 버전의 서버에서 작동해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a560da48a0c3eebe2ee9e445e8f80b7a7c072449" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand expression yields null, the result of the &lt;code&gt;IN&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">왼쪽 표현식이 널 (null)을 생성하거나 동일한 오른쪽 값이없고 하나 이상의 오른쪽 표현식이 널 (null)을 생성하는 경우 &lt;code&gt;IN&lt;/code&gt; 구문 의 결과는 false가 아니라 null입니다. 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="0c5f4c3fbdd65353e1a71d55f99ee8748d4b0fa1" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand expression yields null, the result of the &lt;code&gt;NOT IN&lt;/code&gt; construct will be null, not true as one might naively expect. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">왼쪽 표현식이 널 (null)을 생성하거나 동일한 오른쪽 값이없고 하나 이상의 오른쪽 표현식이 널 (null)을 생성하는 경우, &lt;code&gt;NOT IN&lt;/code&gt; 구문 의 결과는 순진하게 기대할 수 있으므로 널이 아닙니다. . 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="3770b570045d24672e81b92be3b78c98e0908b47" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand row yields null, the result of the &lt;code&gt;IN&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">왼쪽 표현식이 널을 생성하거나 동일한 오른쪽 값이없고 하나 이상의 오른쪽 행이 널을 생성하는 경우 &lt;code&gt;IN&lt;/code&gt; 구문 의 결과는 거짓이 아니라 널이됩니다. 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="95d9a10f36eb36219f7c3566abef0868c3a7a8f8" translate="yes" xml:space="preserve">
          <source>Note that if the left-hand expression yields null, or if there are no equal right-hand values and at least one right-hand row yields null, the result of the &lt;code&gt;NOT IN&lt;/code&gt; construct will be null, not true. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">왼쪽 표현식이 널 (null)을 생성하거나 동일한 오른쪽 값이없고 하나 이상의 오른쪽 행이 널 (null)을 생성하는 경우 &lt;code&gt;NOT IN&lt;/code&gt; 구문 의 결과는 널이 아니고 참이 아닙니다. 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="b5695d0e24822e1a46463dd2f7c72886d58ca728" translate="yes" xml:space="preserve">
          <source>Note that if there are no successes and at least one right-hand row yields null for the operator's result, the result of the &lt;code&gt;ANY&lt;/code&gt; construct will be null, not false. This is in accordance with SQL's normal rules for Boolean combinations of null values.</source>
          <target state="translated">성공이없고 연산자 결과에 대해 하나 이상의 오른쪽 행이 널을 생성하는 경우 &lt;code&gt;ANY&lt;/code&gt; 구문 의 결과는 거짓이 아니라 널이됩니다. 이는 null 값의 부울 조합에 대한 SQL의 일반 규칙에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="f74d4f9409b75f18ec02eb7363768188eed257dd" translate="yes" xml:space="preserve">
          <source>Note that if you use this option currently, you probably also want the dump be in &lt;code&gt;INSERT&lt;/code&gt; format, as the &lt;code&gt;COPY FROM&lt;/code&gt; during restore does not support row security.</source>
          <target state="translated">현재이 옵션을 사용하는 경우 복원 중 &lt;code&gt;COPY FROM&lt;/code&gt; 이 행 보안을 지원하지 않으므로 덤프를 &lt;code&gt;INSERT&lt;/code&gt; 형식으로 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="76b5be5ae69de8a00f81a37774ba0bddbcd592c1" translate="yes" xml:space="preserve">
          <source>Note that in a standard-conforming string literal, &lt;code&gt;\&lt;/code&gt; just means &lt;code&gt;\&lt;/code&gt; anyway. This parameter only affects the handling of non-standard-conforming literals, including escape string syntax (&lt;code&gt;E'...'&lt;/code&gt;).</source>
          <target state="translated">참고있는 표준 준수 문자열 리터럴에서, &lt;code&gt;\&lt;/code&gt; 단지 수단 &lt;code&gt;\&lt;/code&gt; 어쨌든. 이 매개 변수는 이스케이프 문자열 구문 ( &lt;code&gt;E'...'&lt;/code&gt; )을 포함하여 비표준 준수 리터럴의 처리에만 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="23bc72830133f60c02bed8bfbe946fd178dc8663" translate="yes" xml:space="preserve">
          <source>Note that in some macOS versions, &lt;em&gt;all five&lt;/em&gt; shared-memory parameters must be set in &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;, else the values will be ignored.</source>
          <target state="translated">일부 macOS 버전에서는 &lt;em&gt;5 개의&lt;/em&gt; 공유 메모리 매개 변수를 모두 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 에 설정해야 합니다. . 그렇지 않으면 값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d63d2dbef5cb198e7018e15f160e61a7a98bae4" translate="yes" xml:space="preserve">
          <source>Note that in the latter case the &lt;code&gt;COLLATE&lt;/code&gt; clause is attached to an input argument of the operator we wish to affect. It doesn't matter which argument of the operator or function call the &lt;code&gt;COLLATE&lt;/code&gt; clause is attached to, because the collation that is applied by the operator or function is derived by considering all arguments, and an explicit &lt;code&gt;COLLATE&lt;/code&gt; clause will override the collations of all other arguments. (Attaching non-matching &lt;code&gt;COLLATE&lt;/code&gt; clauses to more than one argument, however, is an error. For more details see &lt;a href=&quot;collation&quot;&gt;Section 23.2&lt;/a&gt;.) Thus, this gives the same result as the previous example:</source>
          <target state="translated">후자의 경우 &lt;code&gt;COLLATE&lt;/code&gt; 절은 우리가 영향을 줄 연산자의 입력 인수에 첨부됩니다. 연산자 또는 함수 에 의해 적용되는 데이터 정렬은 모든 인수를 고려하여 파생되므로 명시 적 &lt;code&gt;COLLATE&lt;/code&gt; 절은 다른 모든 데이터 정렬을 재정의 하므로 &lt;code&gt;COLLATE&lt;/code&gt; 절이 연결된 연산자 또는 함수 호출의 인수는 중요하지 않습니다. 인수. ( 그러나 일치하지 않는 &lt;code&gt;COLLATE&lt;/code&gt; 절을 둘 이상의 인수에 첨부하는 것은 오류입니다. 자세한 내용은 &lt;a href=&quot;collation&quot;&gt;23.2 절을&lt;/a&gt; 참조하십시오 .) 따라서 이전 예제와 동일한 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a84d7bddb80d9016bd6c4bee8fb7ca51415943a4" translate="yes" xml:space="preserve">
          <source>Note that in this mode, the server will apply WAL one file at a time, so if you use the standby server for queries (see Hot Standby), there is a delay between an action in the master and when the action becomes visible in the standby, corresponding the time it takes to fill up the WAL file. &lt;code&gt;archive_timeout&lt;/code&gt; can be used to make that delay shorter. Also note that you can't combine streaming replication with this method.</source>
          <target state="translated">이 모드에서 서버는 한 번에 하나의 파일 만 WAL을 적용하므로 대기 서버를 쿼리에 사용하는 경우 (핫 대기 참조) 마스터의 작업과 작업의 표시가 나타날 때 사이에 지연이 발생합니다. WAL 파일을 채우는 데 걸리는 시간에 해당합니다. &lt;code&gt;archive_timeout&lt;/code&gt; 을 사용하여 지연 시간을 줄일 수 있습니다. 또한 스트리밍 복제를이 방법과 결합 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a1638c843cb47802240a66e163419411cf8f8a8" translate="yes" xml:space="preserve">
          <source>Note that in this mode, the server will apply WAL one file at a time, so if you use the standby server for queries (see Hot Standby), there is a delay between an action in the master and when the action becomes visible in the standby, corresponding to the time it takes to fill up the WAL file. &lt;code&gt;archive_timeout&lt;/code&gt; can be used to make that delay shorter. Also note that you can't combine streaming replication with this method.</source>
          <target state="translated">이 모드에서 서버는 한 번에 하나의 파일 WAL을 적용하므로 쿼리에 대기 서버를 사용하는 경우 (Hot Standby 참조) 마스터의 작업과 해당 작업이 서버에 표시되는 사이에 지연이 있습니다. WAL 파일을 채우는 데 걸리는 시간에 해당합니다. &lt;code&gt;archive_timeout&lt;/code&gt; 을 사용하여 지연 시간을 단축 할 수 있습니다. 또한 스트리밍 복제를이 방법과 결합 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d4405d800f3ae0d5fa272786ae62fc932fc40328" translate="yes" xml:space="preserve">
          <source>Note that in this syntax, &lt;code&gt;BINARY&lt;/code&gt; and &lt;code&gt;CSV&lt;/code&gt; are treated as independent keywords, not as arguments of a &lt;code&gt;FORMAT&lt;/code&gt; option.</source>
          <target state="translated">이 구문에서 &lt;code&gt;BINARY&lt;/code&gt; 및 &lt;code&gt;CSV&lt;/code&gt; 는 &lt;code&gt;FORMAT&lt;/code&gt; 옵션의 인수가 아닌 독립 키워드로 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="a52e8eceb78cffa4749cb6c0e0ac81c842683dee" translate="yes" xml:space="preserve">
          <source>Note that it is currently not supported by &lt;code&gt;postgres_fdw&lt;/code&gt; to prepare the remote transaction for two-phase commit.</source>
          <target state="translated">&lt;code&gt;postgres_fdw&lt;/code&gt; 는 현재 2 단계 커밋을위한 원격 트랜잭션을 준비하는 것을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5bf276b552e113c8aa30767266df52ef9cf60275" translate="yes" xml:space="preserve">
          <source>Note that it is currently not supported for the &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; clause of an &lt;code&gt;INSERT&lt;/code&gt; applied to a partitioned table to update the partition key of a conflicting row such that it requires the row be moved to a new partition.</source>
          <target state="translated">충돌하는 행의 파티션 키를 업데이트하여 행을 새 파티션으로 이동해야하는 경우 파티션 된 테이블에 적용된 &lt;code&gt;INSERT&lt;/code&gt; 의 &lt;code&gt;ON CONFLICT DO UPDATE&lt;/code&gt; 절이 현재 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1def70c0867779a85dc5cf9834ec9df5745ab872" translate="yes" xml:space="preserve">
          <source>Note that it is entirely up to the access method to ensure that it correctly finds all and only the entries passing all the given scan keys. Also, the core system will simply hand off all the &lt;code&gt;WHERE&lt;/code&gt; clauses that match the index keys and operator families, without any semantic analysis to determine whether they are redundant or contradictory. As an example, given &lt;code&gt;WHERE x &amp;gt; 4 AND x &amp;gt; 14&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is a b-tree indexed column, it is left to the b-tree &lt;code&gt;amrescan&lt;/code&gt; function to realize that the first scan key is redundant and can be discarded. The extent of preprocessing needed during &lt;code&gt;amrescan&lt;/code&gt; will depend on the extent to which the index access method needs to reduce the scan keys to a &amp;ldquo;normalized&amp;rdquo; form.</source>
          <target state="translated">주어진 스캔 키를 모두 통과하는 모든 항목 만 올바르게 찾을 수 있도록하는 것은 전적으로 액세스 방법에 달려 있습니다. 또한 핵심 시스템은 의미 론적 분석없이 인덱스 키 및 연산자 패밀리와 일치하는 모든 &lt;code&gt;WHERE&lt;/code&gt; 절을 전달하여 모순인지 여부를 판별합니다. 예를 들어, &lt;code&gt;WHERE x &amp;gt; 4 AND x &amp;gt; 14&lt;/code&gt; 여기서 &lt;code&gt;x&lt;/code&gt; 는 b- 트리 인덱싱 된 열인 경우)는 첫 번째 스캔 키가 중복되어 버릴 수 있음을 인식 하기 위해 b- 트리 &lt;code&gt;amrescan&lt;/code&gt; 기능으로 남겨 집니다. &lt;code&gt;amrescan&lt;/code&gt; 중 필요한 전처리 의 범위는 인덱스 액세스 방법이 스캔 키를 &quot;정규화 된&quot;형식으로 줄여야하는 정도에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="873ebf4f2aa65167f1962a321c4caa0aa6923fed" translate="yes" xml:space="preserve">
          <source>Note that it is permitted for an access method to implement only &lt;code&gt;amgetbitmap&lt;/code&gt; and not &lt;code&gt;amgettuple&lt;/code&gt;, or vice versa, if its internal implementation is unsuited to one API or the other.</source>
          <target state="translated">내부 구현이 한 API에 적합하지 않은 경우 액세스 메소드가 &lt;code&gt;amgetbitmap&lt;/code&gt; 만 구현 하고 &lt;code&gt;amgettuple&lt;/code&gt; 은 구현 하지 않으며 그 반대도 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0eac953a1d1c9a171b24393d7da1daab96fde8aa" translate="yes" xml:space="preserve">
          <source>Note that it is possible that pre-existing options of the foreign-data wrapper, or of dependent servers, user mappings, or foreign tables, are invalid according to the new validator. PostgreSQL does not check for this. It is up to the user to make sure that these options are correct before using the modified foreign-data wrapper. However, any options specified in this &lt;code&gt;ALTER FOREIGN DATA WRAPPER&lt;/code&gt; command will be checked using the new validator.</source>
          <target state="translated">외부 유효성 검사기에 따라 외부 데이터 래퍼 또는 종속 서버, 사용자 매핑 또는 외부 테이블의 기존 옵션이 유효하지 않을 수 있습니다. PostgreSQL은이를 확인하지 않습니다. 수정 된 외부 데이터 래퍼를 사용하기 전에 이러한 옵션이 올바른지 확인하는 것은 사용자의 몫입니다. 그러나이 &lt;code&gt;ALTER FOREIGN DATA WRAPPER&lt;/code&gt; 명령에 지정된 옵션 은 새 유효성 검증기를 사용하여 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="54f1f1ea0bfe92e9a92461b1d9eddd8c8bc5388c" translate="yes" xml:space="preserve">
          <source>Note that it is possible to create array values containing null values even when this variable is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">이 변수가 &lt;code&gt;off&lt;/code&gt; 있어도 널값을 포함하는 배열 값을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e482ec43ca141e91073df95564c36e7944046093" translate="yes" xml:space="preserve">
          <source>Note that it would not make much sense to test a non-schema-qualified type name in this way &amp;mdash; if the name can be recognized at all, it must be visible.</source>
          <target state="translated">이러한 방식으로 스키마에 한정되지 않은 형식 이름을 테스트하는 것은 의미가 없습니다. 이름을 전혀 인식 할 수 없으면 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1aef4a22f764ee40b1bcb8140980923ce0f949fc" translate="yes" xml:space="preserve">
          <source>Note that it's quite possible for two objects to be linked by more than one &lt;code&gt;pg_depend&lt;/code&gt; entry. For example, a child partitioned index would have both a partition-type dependency on its associated partition table, and an auto dependency on each column of that table that it indexes. This sort of situation expresses the union of multiple dependency semantics. A dependent object can be dropped without &lt;code&gt;CASCADE&lt;/code&gt; if any of its dependencies satisfies its condition for automatic dropping. Conversely, all the dependencies' restrictions about which objects must be dropped together must be satisfied.</source>
          <target state="translated">두 개의 객체가 둘 이상의 &lt;code&gt;pg_depend&lt;/code&gt; 항목 으로 연결될 수 있습니다 . 예를 들어, 하위 파티션 된 인덱스는 연관된 파티션 테이블에 대한 파티션 유형 종속성과 색인을 생성하는 해당 테이블의 각 열에 대한 자동 종속성을 모두 갖습니다. 이러한 상황은 다중 종속성 시맨틱의 결합을 나타냅니다. 종속 항목 중 하나라도 자동 삭제 조건을 만족하는 경우 &lt;code&gt;CASCADE&lt;/code&gt; 없이 종속 오브젝트를 삭제할 수 있습니다 . 반대로, 어떤 오브젝트를 함께 삭제해야하는지에 대한 모든 종속성의 제한 사항이 충족되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7a633bec827cd5945acb13add9ef3e8ab355704d" translate="yes" xml:space="preserve">
          <source>Note that late binding was the only behavior supported in PostgreSQL releases before 8.1, so you might need to do this to preserve the semantics of old applications.</source>
          <target state="translated">후기 바인딩은 8.1 이전의 PostgreSQL 릴리스에서 지원되는 유일한 동작이므로 이전 응용 프로그램의 의미를 유지하려면이 작업을 수행해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f498abb4a796a1a75315ef84efac83b6642a42d1" translate="yes" xml:space="preserve">
          <source>Note that libpq uses the SAM-compatible name if no explicit user name is specified. If you use libpq or a driver based on it, you should leave this option disabled or explicitly specify user name in the connection string.</source>
          <target state="translated">명시적인 사용자 이름이 지정되지 않은 경우 libpq는 SAM 호환 이름을 사용합니다. libpq 또는이를 기반으로하는 드라이버를 사용하는 경우이 옵션을 사용하지 않거나 연결 문자열에 사용자 이름을 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="743714bf2d851c6ffde333b305cc76acb3b1f4e3" translate="yes" xml:space="preserve">
          <source>Note that loading a large number of rows using &lt;code&gt;COPY&lt;/code&gt; is almost always faster than using &lt;code&gt;INSERT&lt;/code&gt;, even if &lt;code&gt;PREPARE&lt;/code&gt; is used and multiple insertions are batched into a single transaction.</source>
          <target state="translated">&lt;code&gt;PREPARE&lt;/code&gt; 를 사용하고 여러 삽입을 단일 트랜잭션으로 일괄 처리 하더라도 &lt;code&gt;COPY&lt;/code&gt; 를 사용하여 많은 수의 행을로드하는 것이 &lt;code&gt;INSERT&lt;/code&gt; 를 사용하는 것보다 거의 항상 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="42e8e431b9942cab90fba21d1a0369e9ad613d53" translate="yes" xml:space="preserve">
          <source>Note that locale names are specific to the operating system, so that the above commands might not work in the same way everywhere.</source>
          <target state="translated">로케일 이름은 운영 체제에 따라 다르므로 위의 명령이 모든 곳에서 동일한 방식으로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9b85d99902345f4af7308b01a61dc7702db748b" translate="yes" xml:space="preserve">
          <source>Note that not all SQL commands are able to work on inheritance hierarchies. Commands that are used for data querying, data modification, or schema modification (e.g., &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, most variants of &lt;code&gt;ALTER TABLE&lt;/code&gt;, but not &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt;) typically default to including child tables and support the &lt;code&gt;ONLY&lt;/code&gt; notation to exclude them. Commands that do database maintenance and tuning (e.g., &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;) typically only work on individual, physical tables and do not support recursing over inheritance hierarchies. The respective behavior of each individual command is documented in its reference page (&lt;a href=&quot;https://www.postgresql.org/docs/12/sql-commands.html&quot;&gt;SQL Commands&lt;/a&gt;).</source>
          <target state="translated">모든 SQL 명령이 상속 계층 구조에서 작동 할 수있는 것은 아닙니다. 데이터 조회, 데이터 수정 또는 스키마 수정에 사용되는 명령 (예 : &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;ALTER TABLE&lt;/code&gt; 의 대부분 변형 , &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt; 제외)은 일반적으로 자식 테이블을 포함하고 &lt;code&gt;ONLY&lt;/code&gt; 만 지원합니다. 제외하는 표기법. 데이터베이스 유지 관리 및 조정을 수행하는 명령 (예 : &lt;code&gt;REINDEX&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; )는 일반적으로 개별 물리적 테이블에서만 작동하며 상속 계층 구조에 대한 반복을 지원하지 않습니다. 각 개별 명령의 각 동작은 해당 참조 페이지에 설명되어 있습니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/sql-commands.html&quot;&gt;SQL 명령&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="327ef47ac3644ee0b774c6ef4fdf9e2c60c4fad3" translate="yes" xml:space="preserve">
          <source>Note that not all SQL commands are able to work on inheritance hierarchies. Commands that are used for data querying, data modification, or schema modification (e.g., &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, most variants of &lt;code&gt;ALTER TABLE&lt;/code&gt;, but not &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt;) typically default to including child tables and support the &lt;code&gt;ONLY&lt;/code&gt; notation to exclude them. Commands that do database maintenance and tuning (e.g., &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;VACUUM&lt;/code&gt;) typically only work on individual, physical tables and do not support recursing over inheritance hierarchies. The respective behavior of each individual command is documented in its reference page (&lt;a href=&quot;https://www.postgresql.org/docs/13/sql-commands.html&quot;&gt;SQL Commands&lt;/a&gt;).</source>
          <target state="translated">모든 SQL 명령이 상속 계층에서 작동하는 것은 아닙니다. 데이터 쿼리, 데이터 수정 또는 스키마 수정 (예 : &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , 대부분의 &lt;code&gt;ALTER TABLE&lt;/code&gt; 변형 이지만 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;ALTER TABLE ... RENAME&lt;/code&gt; 아님)에 사용되는 명령은 일반적으로 기본적으로 하위 테이블을 포함하고 &lt;code&gt;ONLY&lt;/code&gt; 를 지원합니다. 제외하는 표기법. 데이터베이스 유지 관리 및 조정을 수행하는 명령 (예 : &lt;code&gt;REINDEX&lt;/code&gt; , &lt;code&gt;VACUUM&lt;/code&gt; ) 일반적으로 개별 물리적 테이블에서만 작동하며 상속 계층 구조에 대한 반복을 지원하지 않습니다. 각 개별 명령의 각 동작은 해당 참조 페이지 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/sql-commands.html&quot;&gt;SQL Commands&lt;/a&gt; )에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a5e9d67d623aca716181f6ec9cb80abc27268bb" translate="yes" xml:space="preserve">
          <source>Note that object keys are compared in their storage order; in particular, since shorter keys are stored before longer keys, this can lead to results that might be unintuitive, such as:</source>
          <target state="translated">객체 키는 저장 순서대로 비교됩니다. 특히 키가 길수록 키가 짧을수록 키가 짧아 지므로 다음과 같은 직관적이지 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b32073b6d3e410922a70ee12709380a01c6753" translate="yes" xml:space="preserve">
          <source>Note that older clients might lack support for the SCRAM authentication mechanism, and hence not work with passwords encrypted with SCRAM-SHA-256. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for more details.</source>
          <target state="translated">이전 클라이언트는 SCRAM 인증 메커니즘을 지원하지 않을 수 있으므로 SCRAM-SHA-256으로 암호화 된 비밀번호로는 작동하지 않습니다. 자세한 내용 &lt;a href=&quot;auth-password&quot;&gt;은 20.5 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a9b3d09d3d6340576d5c998f6421491652b39ecd" translate="yes" xml:space="preserve">
          <source>Note that only updating transactions might need to be retried; read-only transactions will never have serialization conflicts.</source>
          <target state="translated">업데이트 트랜잭션 만 재 시도해야합니다. 읽기 전용 트랜잭션은 직렬화 충돌이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2954af76eca7ba35f68a0a8d801d4249462c8089" translate="yes" xml:space="preserve">
          <source>Note that ordering options apply only to the expression they follow; for example &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; does not mean the same thing as &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt;.</source>
          <target state="translated">순서 옵션은 다음 표현식에만 적용됩니다. 예를 들어 &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; 는 &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; 와 같은 의미가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="b1c2c8127025345a934a6314a2f889673aacbd3b" translate="yes" xml:space="preserve">
          <source>Note that parallel queries may consume very substantially more resources than non-parallel queries, because each worker process is a completely separate process which has roughly the same impact on the system as an additional user session. This should be taken into account when choosing a value for this setting, as well as when configuring other settings that control resource utilization, such as &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt;. Resource limits such as &lt;code&gt;work_mem&lt;/code&gt; are applied individually to each worker, which means the total utilization may be much higher across all processes than it would normally be for any single process. For example, a parallel query using 4 workers may use up to 5 times as much CPU time, memory, I/O bandwidth, and so forth as a query which uses no workers at all.</source>
          <target state="translated">각 작업자 프로세스는 별도의 프로세스이므로 추가 사용자 세션과 시스템에 거의 동일한 영향을 미치기 때문에 병렬 쿼리는 비 병렬 쿼리보다 훨씬 더 많은 리소스를 소비 할 수 있습니다. 이 설정의 값을 선택할 때뿐만 아니라 &lt;a href=&quot;runtime-config-resource#GUC-WORK-MEM&quot;&gt;work_mem&lt;/a&gt; 과 같은 자원 활용을 제어하는 ​​다른 설정을 구성 할 때이 점을 고려해야 합니다. &lt;code&gt;work_mem&lt;/code&gt; 과 같은 자원 제한 은 각 작업자에게 개별적으로 적용됩니다. 즉, 전체 프로세스는 전체 프로세스에서 일반적으로 단일 프로세스보다 훨씬 더 높을 수 있습니다. 예를 들어 작업자 4 명을 사용하는 병렬 쿼리는 작업자를 전혀 사용하지 않는 쿼리로 최대 5 배 많은 CPU 시간, 메모리, I / O 대역폭 등을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03d17cb56c53d9a14510ff412e2277014674b9c7" translate="yes" xml:space="preserve">
          <source>Note that parallel utility commands should not consume substantially more memory than equivalent non-parallel operations. This strategy differs from that of parallel query, where resource limits generally apply per worker process. Parallel utility commands treat the resource limit &lt;code&gt;maintenance_work_mem&lt;/code&gt; as a limit to be applied to the entire utility command, regardless of the number of parallel worker processes. However, parallel utility commands may still consume substantially more CPU resources and I/O bandwidth.</source>
          <target state="translated">병렬 유틸리티 명령은 동등한 비 병렬 작업보다 훨씬 더 많은 메모리를 소비해서는 안됩니다. 이 전략은 일반적으로 작업자 프로세스 당 리소스 제한이 적용되는 병렬 쿼리의 전략과 다릅니다. 병렬 유틸리티 명령은 자원 제한 &lt;code&gt;maintenance_work_mem&lt;/code&gt; 을 병렬 작업자 프로세스 수에 관계없이 전체 유틸리티 명령에 적용되는 제한으로 취급합니다 . 그러나 병렬 유틸리티 명령은 여전히 ​​훨씬 더 많은 CPU 리소스와 I / O 대역폭을 소비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c3896a4097aefd43e61d30f8ed6fc4608d53683" translate="yes" xml:space="preserve">
          <source>Note that partition pruning is driven only by the constraints defined implicitly by the partition keys, not by the presence of indexes. Therefore it isn't necessary to define indexes on the key columns. Whether an index needs to be created for a given partition depends on whether you expect that queries that scan the partition will generally scan a large part of the partition or just a small part. An index will be helpful in the latter case but not the former.</source>
          <target state="translated">파티션 프 루닝은 인덱스의 존재가 아니라 파티션 키에 의해 암시 적으로 정의 된 제한 조건에 의해서만 구동됩니다. 따라서 키 열에 인덱스를 정의 할 필요가 없습니다. 지정된 파티션에 대해 인덱스를 작성해야하는지 여부는 파티션을 스캔하는 쿼리가 일반적으로 파티션의 큰 부분 또는 작은 부분 만 스캔하는지 여부에 따라 다릅니다. 후자의 경우에는 색인이 도움이되지만 전자는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c526234778414186549c3a732294e28ea6360814" translate="yes" xml:space="preserve">
          <source>Note that pg_dump will set &lt;code&gt;row_security&lt;/code&gt; to &lt;code&gt;OFF&lt;/code&gt; by default, to ensure all contents of a table are dumped out. If the user running pg_dump does not have appropriate permissions, an error will be returned. However, superusers and the owner of the table being dumped always bypass RLS.</source>
          <target state="translated">pg_dump는 기본적으로 &lt;code&gt;row_security&lt;/code&gt; 를 &lt;code&gt;OFF&lt;/code&gt; 로 설정하여 테이블의 모든 내용이 덤프되도록합니다. pg_dump를 실행하는 사용자에게 적절한 권한이 없으면 오류가 반환됩니다. 그러나 수퍼 유저와 덤프되는 테이블의 소유자는 항상 RLS를 우회합니다.</target>
        </trans-unit>
        <trans-unit id="8457004be1bd2121d647641e3e2f206401f9ee82" translate="yes" xml:space="preserve">
          <source>Note that revoking this privilege will not alter the existence or location of existing objects.</source>
          <target state="translated">이 권한을 취소해도 기존 개체의 존재 또는 위치는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aed232352821561d7f4d97b0cbed4bb08fe3a2ef" translate="yes" xml:space="preserve">
          <source>Note that roles are defined at the database cluster level, and so are valid in all databases in the cluster.</source>
          <target state="translated">역할은 데이터베이스 클러스터 수준에서 정의되므로 클러스터의 모든 데이터베이스에서 유효합니다.</target>
        </trans-unit>
        <trans-unit id="746fd0d5f2f710a9b186a9ef98779e17d15fa9db" translate="yes" xml:space="preserve">
          <source>Note that tablespace directories are not cleaned up either way.</source>
          <target state="translated">테이블 스페이스 디렉토리는 정리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1d5538437b8defc93f56eee03304e310c0c5042" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;actual time&amp;rdquo; values are in milliseconds of real time, whereas the &lt;code&gt;cost&lt;/code&gt; estimates are expressed in arbitrary units; so they are unlikely to match up. The thing that's usually most important to look for is whether the estimated row counts are reasonably close to reality. In this example the estimates were all dead-on, but that's quite unusual in practice.</source>
          <target state="translated">&quot;실제 시간&quot;값은 실시간으로 밀리 초 단위 인 반면 &lt;code&gt;cost&lt;/code&gt; 추정치는 임의의 단위로 표시됩니다. 그래서 일치하지 않을 것입니다. 일반적으로 가장 중요하게 생각되는 것은 예상 행 개수가 실제에 가까운 지 여부입니다. 이 예에서 추정치는 모두 망가졌지만 실제로는 이례적인 일입니다.</target>
        </trans-unit>
        <trans-unit id="9e220f4fc878ea43d3bad6e0a739b4b79c17d896" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;best match&amp;rdquo; rules are identical for operator and function type resolution. Some examples follow.</source>
          <target state="translated">&quot;최적 일치&quot;규칙은 연산자 및 기능 유형 확인에 동일합니다. 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="ef1701ee0df5df14d039148f316d2e4d2b8aa8fd" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;same as&amp;rdquo; operator, &lt;code&gt;~=&lt;/code&gt;, represents the usual notion of equality for the &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; types. Some of the geometric types also have an &lt;code&gt;=&lt;/code&gt; operator, but &lt;code&gt;=&lt;/code&gt; compares for equal &lt;em&gt;areas&lt;/em&gt; only. The other scalar comparison operators (&lt;code&gt;&amp;lt;=&lt;/code&gt; and so on), where available for these types, likewise compare areas.</source>
          <target state="translated">&quot;same as&quot;연산자 &lt;code&gt;~=&lt;/code&gt; 는 &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; 및 &lt;code&gt;circle&lt;/code&gt; 유형에 대한 일반적인 동일 개념을 나타냅니다 . 일부 기하학적 유형에는 &lt;code&gt;=&lt;/code&gt; 연산자도 있지만 &lt;code&gt;=&lt;/code&gt; 는 동일한 &lt;em&gt;영역에&lt;/em&gt; 대해서만 비교 됩니다. 이러한 유형에 사용할 수 있는 다른 스칼라 비교 연산자 ( &lt;code&gt;&amp;lt;=&lt;/code&gt; 등)도 마찬가지로 영역을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="68a397047ec4388fcee29b79f7e608c05447ff76" translate="yes" xml:space="preserve">
          <source>Note that the &amp;ldquo;same as&amp;rdquo; operator, &lt;code&gt;~=&lt;/code&gt;, represents the usual notion of equality for the &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;box&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;, and &lt;code&gt;circle&lt;/code&gt; types. Some of these types also have an &lt;code&gt;=&lt;/code&gt; operator, but &lt;code&gt;=&lt;/code&gt; compares for equal &lt;em&gt;areas&lt;/em&gt; only. The other scalar comparison operators (&lt;code&gt;&amp;lt;=&lt;/code&gt; and so on) likewise compare areas for these types.</source>
          <target state="translated">&amp;ldquo;같은&amp;rdquo;연산자 &lt;code&gt;~=&lt;/code&gt; 는 &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;box&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; 및 &lt;code&gt;circle&lt;/code&gt; 유형에 대한 평등 개념을 나타냅니다 . 이러한 유형 중 일부에는 &lt;code&gt;=&lt;/code&gt; 연산자가 있지만 &lt;code&gt;=&lt;/code&gt; 는 동일한 &lt;em&gt;영역에&lt;/em&gt; 대해서만 비교 합니다. 다른 스칼라 비교 연산자 ( &lt;code&gt;&amp;lt;=&lt;/code&gt; 등)도 마찬가지로 이러한 유형의 영역을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="3f9568498993be48d548609f8f99b58407bdc0b5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;CHECK OPTION&lt;/code&gt; is only supported on views that are automatically updatable, and do not have &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers or &lt;code&gt;INSTEAD&lt;/code&gt; rules. If an automatically updatable view is defined on top of a base view that has &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers, then the &lt;code&gt;LOCAL CHECK OPTION&lt;/code&gt; may be used to check the conditions on the automatically updatable view, but the conditions on the base view with &lt;code&gt;INSTEAD OF&lt;/code&gt; triggers will not be checked (a cascaded check option will not cascade down to a trigger-updatable view, and any check options defined directly on a trigger-updatable view will be ignored). If the view or any of its base relations has an &lt;code&gt;INSTEAD&lt;/code&gt; rule that causes the &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt; command to be rewritten, then all check options will be ignored in the rewritten query, including any checks from automatically updatable views defined on top of the relation with the &lt;code&gt;INSTEAD&lt;/code&gt; rule.</source>
          <target state="translated">있습니다 &lt;code&gt;CHECK OPTION&lt;/code&gt; 에만 자동으로 업데이트 할 수있는 뷰에 지원되며,이없는 &lt;code&gt;INSTEAD OF&lt;/code&gt; 트리거 또는 &lt;code&gt;INSTEAD&lt;/code&gt; 은 규칙. &lt;code&gt;INSTEAD OF&lt;/code&gt; 트리거 가있는 기본보기 위에 자동 업데이트 가능보기가 정의 된 경우 &lt;code&gt;LOCAL CHECK OPTION&lt;/code&gt; 을 사용하여 자동 업데이트 가능보기의 조건을 확인할 수 있지만 &lt;code&gt;INSTEAD OF&lt;/code&gt; 트리거가 있는 기본보기의 조건 은 그렇지 않습니다. 계단식 검사 옵션은 트리거 업데이트 가능 뷰까지 계단식으로 정렬되지 않으며 트리거 업데이트 가능 뷰에 직접 정의 된 모든 검사 옵션은 무시됩니다. 뷰 또는 기본 관계에 &lt;code&gt;INSTEAD&lt;/code&gt; 규칙이있는 경우 &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; 명령을 다시 작성하면 &lt;code&gt;INSTEAD&lt;/code&gt; 규칙 과의 관계 위에 정의 된 자동 업데이트 가능한 뷰의 확인을 포함하여 모든 확인 옵션이 다시 작성된 쿼리에서 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="048b814d4fde306f95eb514ec96249604d0f3baf" translate="yes" xml:space="preserve">
          <source>Note that the checksum depends on the block number, so matching block numbers should be passed (except when doing esoteric debugging).</source>
          <target state="translated">체크섬은 블록 번호에 따라 다르므로 일치하는 블록 번호를 전달해야합니다 (난해한 디버깅을 수행하는 경우 제외).</target>
        </trans-unit>
        <trans-unit id="8c92d729af687d63d61faa7693bb18cfc4db6007" translate="yes" xml:space="preserve">
          <source>Note that the command is invoked by the shell, so if you need to pass any arguments to shell command that come from an untrusted source, you must be careful to strip or escape any special characters that might have a special meaning for the shell. For security reasons, it is best to use a fixed command string, or at least avoid passing any user input in it.</source>
          <target state="translated">명령은 쉘에 의해 호출되므로, 신뢰할 수없는 소스에서 온 쉘 명령에 인수를 전달해야하는 경우, 쉘에 특별한 의미를 가질 수있는 특수 문자를 제거하거나 이스케이프해야합니다. 보안상의 이유로 고정 명령 문자열을 사용하거나 사용자 입력을 전달하지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="95e2592cd121958603de591b16676dfd151d7385" translate="yes" xml:space="preserve">
          <source>Note that the effects of all per-row &lt;code&gt;BEFORE INSERT&lt;/code&gt; triggers are reflected in &lt;code&gt;excluded&lt;/code&gt; values, since those effects may have contributed to the row being excluded from insertion.</source>
          <target state="translated">모든 당 행의 효과 유의 &lt;code&gt;BEFORE INSERT&lt;/code&gt; 트리거가 반영된다 &lt;code&gt;excluded&lt;/code&gt; 그 효과가 행에 공헌 할 수 있기 때문에, 삽입 값으로부터 제외된다.</target>
        </trans-unit>
        <trans-unit id="5d831510235276a5c3036f14f7c31dd0c8581fc2" translate="yes" xml:space="preserve">
          <source>Note that the first item on any non-rightmost page (any page with a non-zero value in the &lt;code&gt;btpo_next&lt;/code&gt; field) is the page's &amp;ldquo;high key&amp;rdquo;, meaning its &lt;code&gt;data&lt;/code&gt; serves as an upper bound on all items appearing on the page, while its &lt;code&gt;ctid&lt;/code&gt; field does not point to another block. Also, on internal pages, the first real data item (the first item that is not a high key) reliably has every column truncated away, leaving no actual value in its &lt;code&gt;data&lt;/code&gt; field. Such an item does have a valid downlink in its &lt;code&gt;ctid&lt;/code&gt; field, however.</source>
          <target state="translated">&lt;code&gt;btpo_next&lt;/code&gt; 오른쪽이 아닌 페이지 ( btpo_next 필드 에 0이 아닌 값이있는 모든 페이지)의 첫 번째 항목 은 페이지의 &quot;높은 키&quot;입니다. 이는 해당 &lt;code&gt;data&lt;/code&gt; 가 페이지에 나타나는 모든 항목에 대한 상한선 역할을 한다는 것을 의미합니다. 그 &lt;code&gt;ctid&lt;/code&gt; 필드는 다른 블록을 가리 키지 않습니다. 또한 내부 페이지에서 첫 번째 실제 데이터 항목 (높은 키가 아닌 첫 번째 항목)은 모든 열이 잘려서 &lt;code&gt;data&lt;/code&gt; 필드 에 실제 값을 남기지 않습니다 . 그러나 이러한 항목의 &lt;code&gt;ctid&lt;/code&gt; 필드 에는 유효한 다운 링크가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e212873009117f62fcd9c668559d87771494a3ea" translate="yes" xml:space="preserve">
          <source>Note that the first item on any non-rightmost page (any page with a non-zero value in the &lt;code&gt;btpo_next&lt;/code&gt; field) is the page's &amp;ldquo;high key&amp;rdquo;, meaning its &lt;code&gt;data&lt;/code&gt; serves as an upper bound on all items appearing on the page, while its &lt;code&gt;ctid&lt;/code&gt; field is meaningless. Also, on non-leaf pages, the first real data item (the first item that is not a high key) is a &amp;ldquo;minus infinity&amp;rdquo; item, with no actual value in its &lt;code&gt;data&lt;/code&gt; field. Such an item does have a valid downlink in its &lt;code&gt;ctid&lt;/code&gt; field, however.</source>
          <target state="translated">가장 오른쪽이 아닌 페이지의 첫 번째 항목 ( &lt;code&gt;btpo_next&lt;/code&gt; 필드 에 0이 아닌 값을 가진 페이지)은 페이지의 &quot;높은 키&quot;입니다. 즉, 해당 &lt;code&gt;data&lt;/code&gt; 는 페이지에 나타나는 모든 항목의 상한으로 사용됩니다. 그 &lt;code&gt;ctid&lt;/code&gt; 필드는 의미가 없습니다. 또한 리프가 아닌 페이지에서 첫 번째 실제 데이터 항목 (높은 키가 아닌 첫 번째 항목)은 &lt;code&gt;data&lt;/code&gt; 필드 에 실제 값이없는 &quot;빼기 무한대&quot;항목 입니다. 그러나 이러한 항목은 해당 &lt;code&gt;ctid&lt;/code&gt; 필드 에 유효한 다운 링크가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="535954ca2908fbda93be1ed4d604a5a38ff7249d" translate="yes" xml:space="preserve">
          <source>Note that the following sections describe the behavior of the builtin &lt;code&gt;heap&lt;/code&gt;&lt;a href=&quot;tableam&quot;&gt;table access method&lt;/a&gt;, and the builtin &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;index access methods&lt;/a&gt;. Due to the extensible nature of PostgreSQL, other access methods might work differently.</source>
          <target state="translated">다음 섹션에서는 내장 &lt;code&gt;heap&lt;/code&gt; &lt;a href=&quot;tableam&quot;&gt;테이블 액세스 방법&lt;/a&gt; 의 동작 과 내장 &lt;a href=&quot;https://www.postgresql.org/docs/12/indexam.html&quot;&gt;인덱스 액세스 방법에&lt;/a&gt; 대해 설명합니다 . PostgreSQL의 확장 가능한 특성으로 인해 다른 액세스 방법이 다르게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b97c4406cd03632c5651253443e7276d76c22605" translate="yes" xml:space="preserve">
          <source>Note that the following sections describe the behavior of the builtin &lt;code&gt;heap&lt;/code&gt;&lt;a href=&quot;tableam&quot;&gt;table access method&lt;/a&gt;, and the builtin &lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;index access methods&lt;/a&gt;. Due to the extensible nature of PostgreSQL, other access methods might work differently.</source>
          <target state="translated">다음 섹션에서는 내장 &lt;code&gt;heap&lt;/code&gt; &lt;a href=&quot;tableam&quot;&gt;테이블 액세스 방법&lt;/a&gt; 및 내장 &lt;a href=&quot;https://www.postgresql.org/docs/13/indexam.html&quot;&gt;인덱스 액세스 방법&lt;/a&gt; 의 동작을 설명합니다 . PostgreSQL의 확장 가능한 특성으로 인해 다른 액세스 방법은 다르게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ff99b02bab93b2bce6ccdae00e15d7def0f0061" translate="yes" xml:space="preserve">
          <source>Note that the locale behavior of the server is determined by the environment variables seen by the server, not by the environment of any client. Therefore, be careful to configure the correct locale settings before starting the server. A consequence of this is that if client and server are set up in different locales, messages might appear in different languages depending on where they originated.</source>
          <target state="translated">서버의 로케일 동작은 클라이언트의 환경이 아니라 서버에서 볼 수있는 환경 변수에 의해 결정됩니다. 따라서 서버를 시작하기 전에 올바른 로케일 설정을 구성해야합니다. 그 결과 클라이언트와 서버가 서로 다른 로케일로 설정된 경우 메시지가 발생한 위치에 따라 다른 언어로 메시지가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d471153d0c31d19d3a687501b18f85b42ddbd4" translate="yes" xml:space="preserve">
          <source>Note that the only supported &lt;a href=&quot;auth-methods&quot;&gt;authentication methods&lt;/a&gt; for use with GSSAPI encryption are &lt;code&gt;gss&lt;/code&gt;, &lt;code&gt;reject&lt;/code&gt;, and &lt;code&gt;trust&lt;/code&gt;.</source>
          <target state="translated">GSSAPI 암호화에 사용 되는 지원되는 유일한 &lt;a href=&quot;auth-methods&quot;&gt;인증 방법&lt;/a&gt; 은 &lt;code&gt;gss&lt;/code&gt; , &lt;code&gt;reject&lt;/code&gt; 및 &lt;code&gt;trust&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c1ad926ce9c3e21892b3792f7b8c1dbecab3b69d" translate="yes" xml:space="preserve">
          <source>Note that the operator precedence rules also apply to user-defined operators that have the same names as the built-in operators mentioned above. For example, if you define a &amp;ldquo;+&amp;rdquo; operator for some custom data type it will have the same precedence as the built-in &amp;ldquo;+&amp;rdquo; operator, no matter what yours does.</source>
          <target state="translated">연산자 우선 순위 규칙은 위에서 언급 한 내장 연산자와 이름이 같은 사용자 정의 연산자에도 적용됩니다. 예를 들어, 일부 사용자 정의 데이터 유형에 대해 &quot;+&quot;연산자를 정의하면 사용자의 작업에 관계없이 기본 제공 &quot;+&quot;연산자와 동일한 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c8f86dee03c6b505a272324fb9a4a25b4a43909d" translate="yes" xml:space="preserve">
          <source>Note that the ordering options are considered independently for each sort column. For example &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; means &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt;, which is not the same as &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt;.</source>
          <target state="translated">순서 옵션은 각 정렬 열에 대해 독립적으로 고려됩니다. 예를 들어 &lt;code&gt;ORDER BY x, y DESC&lt;/code&gt; 는 &lt;code&gt;ORDER BY x ASC, y DESC&lt;/code&gt; 를 의미하며 &lt;code&gt;ORDER BY x DESC, y DESC&lt;/code&gt; 와 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e2d7f74d4ba0ae61a9bd9e94f45d68a74a955765" translate="yes" xml:space="preserve">
          <source>Note that the parser automatically understands that &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are of type &lt;code&gt;boolean&lt;/code&gt;, but this is not so for &lt;code&gt;NULL&lt;/code&gt; because that can have any type. So in some contexts you might have to cast &lt;code&gt;NULL&lt;/code&gt; to &lt;code&gt;boolean&lt;/code&gt; explicitly, for example &lt;code&gt;NULL::boolean&lt;/code&gt;. Conversely, the cast can be omitted from a string-literal Boolean value in contexts where the parser can deduce that the literal must be of type &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">구문 분석기는 &lt;code&gt;TRUE&lt;/code&gt; 및 &lt;code&gt;FALSE&lt;/code&gt; 유형이 &lt;code&gt;boolean&lt;/code&gt; 유형 이라는 것을 자동으로 이해 하지만 모든 유형을 가질 수 있으므로 &lt;code&gt;NULL&lt;/code&gt; 에는 해당 되지 않습니다 . 따라서 일부 컨텍스트 에서는 &lt;code&gt;NULL::boolean&lt;/code&gt; 과 같이 명시 적으로 &lt;code&gt;NULL&lt;/code&gt; 을 &lt;code&gt;boolean&lt;/code&gt; 로 캐스트해야 할 수도 있습니다 . 반대로, 파서는 리터럴이 &lt;code&gt;boolean&lt;/code&gt; 유형이어야한다고 추론 할 수있는 컨텍스트에서 문자열 리터럴 부울 값에서 캐스트를 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6830af538ea3d4def0017ebca2cb9eb811ef481a" translate="yes" xml:space="preserve">
          <source>Note that the password prompt will occur again for each database to be dumped. Usually, it's better to set up a &lt;code&gt;~/.pgpass&lt;/code&gt; file than to rely on manual password entry.</source>
          <target state="translated">각 데이터베이스를 덤프 할 때마다 비밀번호 프롬프트가 다시 나타납니다. 일반적 으로 수동 비밀번호 입력에 의존하는 것보다 &lt;code&gt;~/.pgpass&lt;/code&gt; 파일 을 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="42ada1c8e6a6026750e361cb5d7ba311ef045adc" translate="yes" xml:space="preserve">
          <source>Note that the query planner does not consider deferring the evaluation of parallel-restricted functions or aggregates involved in the query in order to obtain a superior plan. So, for example, if a &lt;code&gt;WHERE&lt;/code&gt; clause applied to a particular table is parallel restricted, the query planner will not consider performing a scan of that table in the parallel portion of a plan. In some cases, it would be possible (and perhaps even efficient) to include the scan of that table in the parallel portion of the query and defer the evaluation of the &lt;code&gt;WHERE&lt;/code&gt; clause so that it happens above the &lt;code&gt;Gather&lt;/code&gt; node. However, the planner does not do this.</source>
          <target state="translated">쿼리 계획자는 우수한 계획을 얻기 위해 쿼리에 포함 된 병렬 제한 함수 또는 집계의 평가 연기를 고려하지 않습니다. 예를 들어, 특정 테이블에 적용되는 &lt;code&gt;WHERE&lt;/code&gt; 절이 병렬 제한되는 경우 쿼리 플래너는 계획의 병렬 부분에서 해당 테이블의 스캔 수행을 고려하지 않습니다. 경우에 따라 쿼리의 병렬 부분에 해당 테이블의 스캔을 포함시키고 &lt;code&gt;WHERE&lt;/code&gt; 절의 평가를 연기 하여 &lt;code&gt;Gather&lt;/code&gt; 노드 위에서 발생할 수 있습니다. 그러나 플래너는이를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f4f575c0dfc110a613df4c8c43c09b6bc17afc4" translate="yes" xml:space="preserve">
          <source>Note that the single-user mode server does not provide sophisticated line-editing features (no command history, for example). Single-user mode also does not do any background processing, such as automatic checkpoints or replication.</source>
          <target state="translated">단일 사용자 모드 서버는 정교한 라인 편집 기능을 제공하지 않습니다 (예 : 명령 기록 없음). 단일 사용자 모드는 자동 검사 점 또는 복제와 같은 백그라운드 처리도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="542b405bccbd1dfc2248044e2da7018d901a07e8" translate="yes" xml:space="preserve">
          <source>Note that the unique key on this catalog is (&lt;code&gt;collname&lt;/code&gt;, &lt;code&gt;collencoding&lt;/code&gt;, &lt;code&gt;collnamespace&lt;/code&gt;) not just (&lt;code&gt;collname&lt;/code&gt;, &lt;code&gt;collnamespace&lt;/code&gt;). PostgreSQL generally ignores all collations that do not have &lt;code&gt;collencoding&lt;/code&gt; equal to either the current database's encoding or -1, and creation of new entries with the same name as an entry with &lt;code&gt;collencoding&lt;/code&gt; = -1 is forbidden. Therefore it is sufficient to use a qualified SQL name (&lt;code&gt;schema&lt;/code&gt;.&lt;code&gt;name&lt;/code&gt;) to identify a collation, even though this is not unique according to the catalog definition. The reason for defining the catalog this way is that initdb fills it in at cluster initialization time with entries for all locales available on the system, so it must be able to hold entries for all encodings that might ever be used in the cluster.</source>
          <target state="translated">참고이 카탈로그에 고유 키 (이다 &lt;code&gt;collname&lt;/code&gt; , &lt;code&gt;collencoding&lt;/code&gt; , &lt;code&gt;collnamespace&lt;/code&gt; )뿐만 아니라 ( &lt;code&gt;collname&lt;/code&gt; , &lt;code&gt;collnamespace&lt;/code&gt; ). PostgreSQL은 일반적으로 현재 데이터베이스의 인코딩 또는 -1과 같은 &lt;code&gt;collencoding&lt;/code&gt; 이없는 모든 데이터 정렬을 무시 하고 &lt;code&gt;collencoding&lt;/code&gt; = -1 인 항목과 동일한 이름의 새 항목을 만드는 것은 금지됩니다. 따라서 규정 된 SQL 이름 ( &lt;code&gt;schema&lt;/code&gt; . &lt;code&gt;name&lt;/code&gt; ) 을 사용하면 충분합니다 .)가 카탈로그 정의에 따라 고유하지 않더라도 데이터 정렬을 식별합니다. 이 방법으로 카탈로그를 정의하는 이유는 initdb가 클러스터 초기화시 카탈로그를 시스템에서 사용 가능한 모든 로케일의 항목으로 채우므로 클러스터에서 사용될 수있는 모든 인코딩의 항목을 보유 할 수 있어야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="57816233be3efc2c0b4b0cdc3b84a0dda807639d" translate="yes" xml:space="preserve">
          <source>Note that the user performing the insert, update or delete on the view must have the corresponding insert, update or delete privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the update does not need any permissions on the underlying base relations (see &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt;).</source>
          <target state="translated">보기에서 삽입, 업데이트 또는 삭제를 수행하는 사용자에게는보기에 대한 해당 삽입, 업데이트 또는 삭제 권한이 있어야합니다. 또한 뷰의 소유자는 기본 관계에 대한 관련 권한을 가져야하지만 업데이트를 수행하는 사용자는 기본 관계에 대한 권한이 필요하지 않습니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/rules-privileges.html&quot;&gt;40.5 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="52e6a2ffb8f6a4ee70000d58285441af2239687a" translate="yes" xml:space="preserve">
          <source>Note that the user performing the insert, update or delete on the view must have the corresponding insert, update or delete privilege on the view. In addition the view's owner must have the relevant privileges on the underlying base relations, but the user performing the update does not need any permissions on the underlying base relations (see &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;Section 40.5&lt;/a&gt;).</source>
          <target state="translated">보기에서 삽입, 업데이트 또는 삭제를 수행하는 사용자는보기에 대한 해당 삽입, 업데이트 또는 삭제 권한이 있어야합니다. 또한 뷰의 소유자는 기본 기본 관계에 대한 관련 권한이 있어야하지만 업데이트를 수행하는 사용자는 기본 기본 관계에 대한 권한이 필요하지 않습니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/rules-privileges.html&quot;&gt;섹션 40.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7f758ecc8993acb3505a10e1f0f3118a15da20e0" translate="yes" xml:space="preserve">
          <source>Note that the white space on each line is actually a tab character.</source>
          <target state="translated">각 줄의 공백은 실제로 탭 문자입니다.</target>
        </trans-unit>
        <trans-unit id="f2961d22f06a0ed36b2caf77fbad086d6c0a84ff" translate="yes" xml:space="preserve">
          <source>Note that there are some limitations in an online backup from the standby:</source>
          <target state="translated">대기에서의 온라인 백업에는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d288b29e3c118d6d8c73403f59b3896205eea76" translate="yes" xml:space="preserve">
          <source>Note that there are some limitations in taking a backup from a standby:</source>
          <target state="translated">대기 모드에서 백업을 수행하는 데는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad0151522b3b77d6456a32b223d7660f4475e688" translate="yes" xml:space="preserve">
          <source>Note that there is no &lt;code&gt;CREATE ROUTINE&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;CREATE ROUTINE&lt;/code&gt; 명령 은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a1d66a79704a8f138a556c34b5e710e75580d121" translate="yes" xml:space="preserve">
          <source>Note that there needs to be at least one permissive policy to grant access to records before restrictive policies can be usefully used to reduce that access. If only restrictive policies exist, then no records will be accessible. When a mix of permissive and restrictive policies are present, a record is only accessible if at least one of the permissive policies passes, in addition to all the restrictive policies.</source>
          <target state="translated">제한적인 정책을 사용하여 해당 액세스를 줄이는 데 유용하기 전에 레코드에 대한 액세스 권한을 부여하려면 하나 이상의 허용 정책이 있어야합니다. 제한적인 정책 만 있으면 레코드에 액세스 할 수 없습니다. 허용 정책과 제한 정책이 혼합 된 경우 모든 제한 정책과 함께 하나 이상의 허용 정책이 통과하는 경우에만 레코드에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95b9e36ae86d5f4054bebe05afb0d0ec344eb9ad" translate="yes" xml:space="preserve">
          <source>Note that these potentially produce a lot of data, which needs to be built up in memory. When requesting content mappings of large schemas or databases, it might be worthwhile to consider mapping the tables separately instead, possibly even through a cursor.</source>
          <target state="translated">이것들은 잠재적으로 많은 양의 데이터를 생성하므로 메모리에 구축해야합니다. 큰 스키마 또는 데이터베이스의 컨텐츠 맵핑을 요청하는 경우 커서를 통해서도 테이블을 개별적으로 맵핑하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b8effb15698d614b121eab24d0dff7bc4e7c22a6" translate="yes" xml:space="preserve">
          <source>Note that this actually means &amp;ldquo;revoke all privileges that I granted&amp;rdquo;.</source>
          <target state="translated">이것은 실제로 &quot;내가 부여한 모든 권한을 취소합니다&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a377102624b4be7d75b74040aea8858a414e0fc7" translate="yes" xml:space="preserve">
          <source>Note that this behavior is consistent with other popular implementations of host name-based access control, such as the Apache HTTP Server and TCP Wrappers.</source>
          <target state="translated">이 동작은 Apache HTTP Server 및 TCP Wrappers와 같이 널리 사용되는 다른 호스트 이름 기반 액세스 제어 구현과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="765730fc2ec6d6848cd71e4c2044c699075b50df" translate="yes" xml:space="preserve">
          <source>Note that this command is subtly different from the server-side &lt;code&gt;lo_import&lt;/code&gt; because it acts as the local user on the local file system, rather than the server's user and file system.</source>
          <target state="translated">이 명령은 서버의 사용자 및 파일 시스템이 아닌 로컬 파일 시스템의 로컬 사용자 역할을하기 때문에 서버 측 &lt;code&gt;lo_import&lt;/code&gt; 와 미묘하게 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="0f8fb90970b8968e4f7127f317566345b970df55" translate="yes" xml:space="preserve">
          <source>Note that this doesn't affect any existing rows in the table, it just changes the default for future &lt;code&gt;INSERT&lt;/code&gt; commands.</source>
          <target state="translated">이는 테이블의 기존 행에는 영향을 미치지 않으며 향후 &lt;code&gt;INSERT&lt;/code&gt; 명령 의 기본값 만 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="56e3b32d061c366fed83bd98f4d4590767c40034" translate="yes" xml:space="preserve">
          <source>Note that this is different from</source>
          <target state="translated">이것은 다음과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9e5d1d4e065e9c7dc21ef91bf768d68d3c9d8a1d" translate="yes" xml:space="preserve">
          <source>Note that this is not the same as the left-to-right &amp;ldquo;short-circuiting&amp;rdquo; of Boolean operators that is found in some programming languages.</source>
          <target state="translated">이것은 일부 프로그래밍 언어에서 볼 수있는 부울 연산자의 왼쪽에서 오른쪽으로의 &quot;단락&quot;과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca51a28e46507688c57df1dccd9f468de8996aae" translate="yes" xml:space="preserve">
          <source>Note that this option currently also requires the dump be in &lt;code&gt;INSERT&lt;/code&gt; format, as &lt;code&gt;COPY FROM&lt;/code&gt; does not support row security.</source>
          <target state="translated">&lt;code&gt;COPY FROM&lt;/code&gt; 은 행 보안을 지원하지 않으므로이 옵션은 현재 덤프도 &lt;code&gt;INSERT&lt;/code&gt; 형식 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="9da43a46207df32c5bc41dc69140b018443cc610" translate="yes" xml:space="preserve">
          <source>Note that this option is incompatible with the &lt;code&gt;--index&lt;/code&gt; and &lt;code&gt;--system&lt;/code&gt; options.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--index&lt;/code&gt; 및 &lt;code&gt;--system&lt;/code&gt; 옵션 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ddb5224f9cf66b54a71c646c3cd12c1c98805d5f" translate="yes" xml:space="preserve">
          <source>Note that this option only affects the exact form &lt;code&gt;= NULL&lt;/code&gt;, not other comparison operators or other expressions that are computationally equivalent to some expression involving the equals operator (such as &lt;code&gt;IN&lt;/code&gt;). Thus, this option is not a general fix for bad programming.</source>
          <target state="translated">이 옵션은 정확한 형식 &lt;code&gt;= NULL&lt;/code&gt; 에만 영향을 미치며 다른 비교 연산자 나 등호 연산자를 포함하는 일부 표현식 (예 : &lt;code&gt;IN&lt;/code&gt; ) 과 계산적으로 동등한 다른 표현식 에는 영향을 주지 않습니다 . 따라서이 옵션은 잘못된 프로그래밍에 대한 일반적인 해결책이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e47f160f4c862fafa44c7f19b4f7d0d78fd15669" translate="yes" xml:space="preserve">
          <source>Note that this option will remain set for the entire session, and so it affects uses of the meta-command &lt;code&gt;\connect&lt;/code&gt; as well as the initial connection attempt.</source>
          <target state="translated">이 옵션은 전체 세션에 대해 설정된 상태로 유지되므로 초기 연결 시도와 메타 명령 &lt;code&gt;\connect&lt;/code&gt; 의 사용에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="9cb49d36842c28bbc6961c206fc6fb511f408fc8" translate="yes" xml:space="preserve">
          <source>Note that this query cannot use this index:</source>
          <target state="translated">이 쿼리는이 인덱스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eeb09f3d3f513d7242e768b40d1a3d7a48755d6c" translate="yes" xml:space="preserve">
          <source>Note that this setting only affects the main shared memory area. Operating systems such as Linux, FreeBSD, and Illumos can also use huge pages (also known as &amp;ldquo;super&amp;rdquo; pages or &amp;ldquo;large&amp;rdquo; pages) automatically for normal memory allocation, without an explicit request from PostgreSQL. On Linux, this is called &amp;ldquo;transparent huge pages&amp;rdquo; (THP). That feature has been known to cause performance degradation with PostgreSQL for some users on some Linux versions, so its use is currently discouraged (unlike explicit use of &lt;code&gt;huge_pages&lt;/code&gt;).</source>
          <target state="translated">이 설정은 기본 공유 메모리 영역에만 영향을 미칩니다. Linux, FreeBSD 및 Illumos와 같은 운영 체제는 PostgreSQL의 명시적인 요청없이 일반 메모리 할당을 위해 거대한 페이지 ( &quot;슈퍼&quot;페이지 또는 &quot;큰&quot;페이지라고도 함)를 자동으로 사용할 수도 있습니다. Linux에서는이를 &quot;투명 거대한 페이지&quot;(THP)라고합니다. 이 기능은 일부 Linux 버전의 일부 사용자에 대해 PostgreSQL에서 성능 저하를 유발하는 것으로 알려져 있으므로 현재는 사용하지 않는 것이 좋습니다 ( &lt;code&gt;huge_pages&lt;/code&gt; 를 명시 적으로 사용하는 것과는 달리 ).</target>
        </trans-unit>
        <trans-unit id="601d111715a6b1b59291397e0542ab5aa27f6545" translate="yes" xml:space="preserve">
          <source>Note that this view does not include memory allocated using the dynamic shared memory infrastructure.</source>
          <target state="translated">이보기에는 동적 공유 메모리 인프라를 사용하여 할당 된 메모리가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="906c24642d7c9d1ccf94ab876f98cee1fa64d503" translate="yes" xml:space="preserve">
          <source>Note that this way the connection from &lt;code&gt;shell.foo.com&lt;/code&gt; to &lt;code&gt;db.foo.com&lt;/code&gt; will not be encrypted by the SSH tunnel. SSH offers quite a few configuration possibilities when the network is restricted in various ways. Please refer to the SSH documentation for details.</source>
          <target state="translated">이 방법 으로 &lt;code&gt;db.foo.com&lt;/code&gt; 에서 &lt;code&gt;shell.foo.com&lt;/code&gt; 으로의 연결 은 SSH 터널에 의해 암호화되지 않습니다. SSH는 네트워크가 다양한 방식으로 제한 될 때 상당히 많은 구성 가능성을 제공합니다. 자세한 내용은 SSH 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aed9a462aeaf6aae78a53a2e55aac5e3c16613ab" translate="yes" xml:space="preserve">
          <source>Note that this will result in locking all rows of &lt;code&gt;mytable&lt;/code&gt;, whereas &lt;code&gt;FOR UPDATE&lt;/code&gt; at the top level would lock only the actually returned rows. This can make for a significant performance difference, particularly if the &lt;code&gt;ORDER BY&lt;/code&gt; is combined with &lt;code&gt;LIMIT&lt;/code&gt; or other restrictions. So this technique is recommended only if concurrent updates of the ordering columns are expected and a strictly sorted result is required.</source>
          <target state="translated">이렇게하면 &lt;code&gt;mytable&lt;/code&gt; 의 모든 행이 잠기는 반면 최상위 레벨의 &lt;code&gt;FOR UPDATE&lt;/code&gt; 는 실제로 리턴 된 행만 잠급니다. 이는 특히 &lt;code&gt;ORDER BY&lt;/code&gt; 가 &lt;code&gt;LIMIT&lt;/code&gt; 또는 기타 제한 사항 과 결합 된 경우 상당한 성능 차이를 만들 수 있습니다 . 따라서이 기법은 순서 열의 동시 업데이트가 예상되고 엄격하게 정렬 된 결과가 필요한 경우에만 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="59d9533d6b1ff70587da7945ccc9db2ea583f449" translate="yes" xml:space="preserve">
          <source>Note that two rows are displayed for the same column, one corresponding to the complete inheritance hierarchy starting at the &lt;code&gt;road&lt;/code&gt; table (&lt;code&gt;inherited&lt;/code&gt;=&lt;code&gt;t&lt;/code&gt;), and another one including only the &lt;code&gt;road&lt;/code&gt; table itself (&lt;code&gt;inherited&lt;/code&gt;=&lt;code&gt;f&lt;/code&gt;).</source>
          <target state="translated">동일한 열에 대해 두 개의 행이 표시되는데, 하나는 &lt;code&gt;road&lt;/code&gt; 테이블 에서 시작하는 전체 상속 계층 구조 ( &lt;code&gt;inherited&lt;/code&gt; = &lt;code&gt;t&lt;/code&gt; )와 다른 하나는 &lt;code&gt;road&lt;/code&gt; 테이블 자체 ( &lt;code&gt;inherited&lt;/code&gt; = &lt;code&gt;f&lt;/code&gt; )를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="10e9b0e25eb4f44f89bb51356ad1df0c93761c8b" translate="yes" xml:space="preserve">
          <source>Note that unlike most catalogs with a &amp;ldquo;namespace&amp;rdquo; column, &lt;code&gt;extnamespace&lt;/code&gt; is not meant to imply that the extension belongs to that schema. Extension names are never schema-qualified. Rather, &lt;code&gt;extnamespace&lt;/code&gt; indicates the schema that contains most or all of the extension's objects. If &lt;code&gt;extrelocatable&lt;/code&gt; is true, then this schema must in fact contain all schema-qualifiable objects belonging to the extension.</source>
          <target state="translated">&amp;ldquo;네임 스페이스&amp;rdquo;열이있는 대부분의 카탈로그와 달리 &lt;code&gt;extnamespace&lt;/code&gt; 는 확장이 해당 스키마에 속한다는 것을 의미하지는 않습니다. 확장명은 스키마로 정규화되지 않습니다. 오히려 &lt;code&gt;extnamespace&lt;/code&gt; 는 확장 기능의 대부분 또는 전부를 포함하는 스키마를 나타냅니다. 경우 &lt;code&gt;extrelocatable&lt;/code&gt; 이 사실 다음 사실에서이 스키마해야 확장자에 속하는 모든 스키마 qualifiable 개체가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="95d30679c93680a49476e594a17f9119213eea89" translate="yes" xml:space="preserve">
          <source>Note that unlike the &lt;code&gt;cube&lt;/code&gt;-based part of the module, units are hardwired here: changing the &lt;code&gt;earth()&lt;/code&gt; function will not affect the results of this operator.</source>
          <target state="translated">모듈 의 &lt;code&gt;cube&lt;/code&gt; 기반 부분 과 달리 단위는 여기에 고정되어 있습니다. &lt;code&gt;earth()&lt;/code&gt; 함수를 변경해도이 연산자의 결과에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aec424e8783da60644af6ec05ea73b5e181a5ff9" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;ldapscheme&lt;/code&gt; or &lt;code&gt;ldaptls&lt;/code&gt; only encrypts the traffic between the PostgreSQL server and the LDAP server. The connection between the PostgreSQL server and the PostgreSQL client will still be unencrypted unless SSL is used there as well.</source>
          <target state="translated">사용하여 &lt;code&gt;ldapscheme&lt;/code&gt; 또는 &lt;code&gt;ldaptls&lt;/code&gt; 하면 PostgreSQL 서버와 LDAP 서버 간의 트래픽 만 암호화됩니다. SSL을 사용하지 않으면 PostgreSQL 서버와 PostgreSQL 클라이언트 간의 연결은 여전히 ​​암호화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4e11f3a6327ed7b6ce66ef2d86de4e055bd13dd" translate="yes" xml:space="preserve">
          <source>Note that using this mode together with the &lt;code&gt;-f&lt;/code&gt; (&lt;code&gt;FULL&lt;/code&gt;) option might cause deadlock failures if certain system catalogs are processed in parallel.</source>
          <target state="translated">이 모드를 &lt;code&gt;-f&lt;/code&gt; 특정 시스템 카탈로그가 병렬로 처리되는 -f ( &lt;code&gt;FULL&lt;/code&gt; ) 옵션 하면 교착 상태 실패가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f608b76c0c846a43652d18d27b367a743ac19721" translate="yes" xml:space="preserve">
          <source>Note that weight labels apply to &lt;em&gt;positions&lt;/em&gt;, not &lt;em&gt;lexemes&lt;/em&gt;. If the input vector has been stripped of positions then &lt;code&gt;setweight&lt;/code&gt; does nothing.</source>
          <target state="translated">무게 라벨은 &lt;em&gt;위치에&lt;/em&gt; 적용됩니다&lt;em&gt;&lt;/em&gt;&lt;em&gt; lexemes가&lt;/em&gt; 아닌 . 입력 벡터가 위치에서 제거 된 경우 &lt;code&gt;setweight&lt;/code&gt; 는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a501f50ad867471d366c858d1e68c08c9bf71a3b" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;ANALYZE&lt;/code&gt; is run on a partitioned table, all of its partitions are also recursively analyzed as also mentioned in &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt;. In that case, &lt;code&gt;ANALYZE&lt;/code&gt; progress is reported first for the parent table, whereby its inheritance statistics are collected, followed by that for each partition.</source>
          <target state="translated">때 참고 &lt;code&gt;ANALYZE&lt;/code&gt; 분할 된 테이블에서 실행도에 언급 한 바와 같이, 모든 파티션도 반복적으로 분석 &lt;a href=&quot;sql-analyze&quot;&gt;ANALYZE&lt;/a&gt; . 이 경우 &lt;code&gt;ANALYZE&lt;/code&gt; 진행률이 상위 테이블에 대해 먼저보고되고 상속 통계가 수집 된 다음 각 파티션에 대해 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="1fb0133d2b01bcc98921dcbe4b4f3b20ca215976" translate="yes" xml:space="preserve">
          <source>Note that when an ACL entry in another catalog is null, it is taken to represent the hard-wired default privileges for its object, &lt;em&gt;not&lt;/em&gt; whatever might be in &lt;code&gt;pg_default_acl&lt;/code&gt; at the moment. &lt;code&gt;pg_default_acl&lt;/code&gt; is only consulted during object creation.</source>
          <target state="translated">다른 카탈로그의 ACL 항목이 null의 경우, 그 개체에 대한 하드 와이어 기본 권한을 표현하기 위해 촬영 한 것을 참고 &lt;em&gt;하지&lt;/em&gt; 뭐든에있을 수 있습니다 &lt;code&gt;pg_default_acl&lt;/code&gt; 현재 pg_default_acl 에있는 됩니다. &lt;code&gt;pg_default_acl&lt;/code&gt; 은 객체 생성 중에 만 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="2e6cf1460524f06f7b596e4f9001c12f09f21277" translate="yes" xml:space="preserve">
          <source>Note that when autovacuum runs, up to &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;autovacuum_max_workers&lt;/a&gt; times this memory may be allocated, so be careful not to set the default value too high. It may be useful to control for this by separately setting &lt;a href=&quot;runtime-config-resource#GUC-AUTOVACUUM-WORK-MEM&quot;&gt;autovacuum_work_mem&lt;/a&gt;.</source>
          <target state="translated">autovacuum이 실행될 때 최대 &lt;a href=&quot;runtime-config-autovacuum#GUC-AUTOVACUUM-MAX-WORKERS&quot;&gt;&lt;/a&gt; 때이 메모리가 autovacuum_max_workers 배 할당 될 수 있으므로 기본값을 너무 높게 설정하지 않도록주의하십시오. &lt;a href=&quot;runtime-config-resource#GUC-AUTOVACUUM-WORK-MEM&quot;&gt;autovacuum_work_mem&lt;/a&gt; 을 별도로 설정하여이를 제어하는 ​​것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b298d8fd9d5a27445f1547b4987f220ddf522324" translate="yes" xml:space="preserve">
          <source>Note that when multiple rewrite rules are applied in this way, the order of application can be important; so in practice you will want the source query to &lt;code&gt;ORDER BY&lt;/code&gt; some ordering key.</source>
          <target state="translated">이러한 방식으로 여러 번의 다시 쓰기 규칙이 적용되는 경우 응용 순서가 중요 할 수 있습니다. 그래서 실제로 당신은 원본 쿼리를 원할 것입니다 &lt;code&gt;ORDER BY&lt;/code&gt; 일부 주문 키를 누릅니다.</target>
        </trans-unit>
        <trans-unit id="15b117a19d6af07c7a1d926814d3fa7ed429f962" translate="yes" xml:space="preserve">
          <source>Note that when using nondefault WAL segment sizes, the numbers in the WAL file names are different from the LSNs that are reported by system functions and system views. This option takes a WAL file name, not an LSN.</source>
          <target state="translated">기본이 아닌 WAL 세그먼트 크기를 사용하는 경우 WAL 파일 이름의 숫자는 시스템 기능 및 시스템보기에 의해보고되는 LSN과 다릅니다. 이 옵션은 LSN이 아닌 WAL 파일 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5091d99db40796ae0ac6a127a75124d1c7974a77" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;COPY&lt;/code&gt; allows options such as &lt;code&gt;HEADER&lt;/code&gt; to be specified without a corresponding value, the foreign table option syntax requires a value to be present in all cases. To activate &lt;code&gt;COPY&lt;/code&gt; options typically written without a value, you can pass the value TRUE, since all such options are Booleans.</source>
          <target state="translated">동안 참고 &lt;code&gt;COPY&lt;/code&gt; 허용과 같은 옵션 &lt;code&gt;HEADER&lt;/code&gt; 해당 값없이 지정 될 수는 해외 테이블 옵션 구문은 모든 경우에 존재하는 값을 필요로한다. 일반적으로 값없이 작성된 &lt;code&gt;COPY&lt;/code&gt; 옵션 을 활성화하려면 모든 옵션이 부울이므로 TRUE 값을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20e2ed64775c1454506227ebe10642431813ecd2" translate="yes" xml:space="preserve">
          <source>Note that while a table's filenode often matches its OID, this is &lt;em&gt;not&lt;/em&gt; necessarily the case; some operations, like &lt;code&gt;TRUNCATE&lt;/code&gt;, &lt;code&gt;REINDEX&lt;/code&gt;, &lt;code&gt;CLUSTER&lt;/code&gt; and some forms of &lt;code&gt;ALTER TABLE&lt;/code&gt;, can change the filenode while preserving the OID. Avoid assuming that filenode and table OID are the same. Also, for certain system catalogs including &lt;code&gt;pg_class&lt;/code&gt; itself, &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfilenode&lt;/code&gt; contains zero. The actual filenode number of these catalogs is stored in a lower-level data structure, and can be obtained using the &lt;code&gt;pg_relation_filenode()&lt;/code&gt; function.</source>
          <target state="translated">테이블의 파일 노드가 종종 OID와 일치하지만 반드시 그런 것은 &lt;em&gt;아닙니다&lt;/em&gt; . &lt;code&gt;TRUNCATE&lt;/code&gt; , &lt;code&gt;REINDEX&lt;/code&gt; , &lt;code&gt;CLUSTER&lt;/code&gt; 및 일부 &lt;code&gt;ALTER TABLE&lt;/code&gt; 형식과 같은 일부 작업 은 OID를 유지하면서 파일 노드를 변경할 수 있습니다. 파일 노드와 테이블 OID가 동일하다고 가정하지 마십시오. 또한, 포함하여 특정 시스템 카탈로그에 대한 &lt;code&gt;pg_class&lt;/code&gt; 자체 &lt;code&gt;pg_class&lt;/code&gt; . &lt;code&gt;relfilenode&lt;/code&gt; 는 0을 포함합니다. 이러한 카탈로그의 실제 파일 노드 수는 하위 레벨 데이터 구조에 저장되며 다음을 사용하여 얻을 수 있습니다. &lt;code&gt;pg_relation_filenode()&lt;/code&gt; 함수를 .</target>
        </trans-unit>
        <trans-unit id="acd42ff3a7dd119700e6cb55e96c90dc5e6fd840" translate="yes" xml:space="preserve">
          <source>Note that while rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.</source>
          <target state="translated">행을 로컬 파티션에서 외부 테이블 파티션으로 이동할 수 있지만 (외래 데이터 랩퍼가 튜플 라우팅을 지원하는 경우) 외부 테이블 파티션에서 다른 파티션으로 이동할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d8be16bebefaea4da0b18cb12ca9511981a5205" translate="yes" xml:space="preserve">
          <source>Note that while the above will indeed grant all privileges if executed by a superuser or the owner of &lt;code&gt;kinds&lt;/code&gt;, when executed by someone else it will only grant those permissions for which the someone else has grant options.</source>
          <target state="translated">위의 내용은 실제로 수퍼 유저 또는 &lt;code&gt;kinds&lt;/code&gt; 의 소유자가 실행하는 경우 모든 권한을 부여하지만 다른 사람이 실행하는 경우 다른 사람이 권한을 부여한 권한 만 부여합니다.</target>
        </trans-unit>
        <trans-unit id="ec3a83831ac9036a3595c6ce5f5e7350a4e67363" translate="yes" xml:space="preserve">
          <source>Note that while this system allows creating collations that &amp;ldquo;ignore case&amp;rdquo; or &amp;ldquo;ignore accents&amp;rdquo; or similar (using the &lt;code&gt;ks&lt;/code&gt; key), in order for such collations to act in a truly case- or accent-insensitive manner, they also need to be declared as not &lt;em&gt;deterministic&lt;/em&gt; in &lt;code&gt;CREATE COLLATION&lt;/code&gt;; see &lt;a href=&quot;collation#COLLATION-NONDETERMINISTIC&quot;&gt;Section 23.2.2.4&lt;/a&gt;. Otherwise, any strings that compare equal according to the collation but are not byte-wise equal will be sorted according to their byte values.</source>
          <target state="translated">이 시스템에서는 대소 문자를 무시하거나 악센트를 무시하거나 이와 유사한 데이터 정렬을 만들 수 있지만 ( &lt;code&gt;ks&lt;/code&gt; 키를 사용하여 ) 대 / 소문자를 구분하지 않는 방식으로 데이터 정렬을 수행 할 수 있어야합니다. &lt;code&gt;CREATE COLLATION&lt;/code&gt; 에서 &lt;em&gt;결정적&lt;/em&gt; 이지 않은 &lt;em&gt;것으로&lt;/em&gt; 선언되었습니다 . 보다&lt;a href=&quot;collation#COLLATION-NONDETERMINISTIC&quot;&gt; 섹션 23.2.2.4&lt;/a&gt; . 그렇지 않으면 데이터 정렬에 따라 동일하지만 바이트 단위가 아닌 문자열은 바이트 값에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="84595e2b092724cd7800c2af7679de35fbd01caf" translate="yes" xml:space="preserve">
          <source>Note that with any of these methods, attempting to prewarm more blocks than can be cached &amp;mdash; by the OS when using &lt;code&gt;prefetch&lt;/code&gt; or &lt;code&gt;read&lt;/code&gt;, or by PostgreSQL when using &lt;code&gt;buffer&lt;/code&gt; &amp;mdash; will likely result in lower-numbered blocks being evicted as higher numbered blocks are read in. Prewarmed data also enjoys no special protection from cache evictions, so it is possible that other system activity may evict the newly prewarmed blocks shortly after they are read; conversely, prewarming may also evict other data from cache. For these reasons, prewarming is typically most useful at startup, when caches are largely empty.</source>
          <target state="translated">이러한 방법 중 하나를 사용하면 &lt;code&gt;prefetch&lt;/code&gt; 또는 &lt;code&gt;read&lt;/code&gt; 를 사용할 때 OS 또는 &lt;code&gt;buffer&lt;/code&gt; 사용할 때 PostgreSQL에 의해 캐시 될 수있는 것보다 많은 블록을 사전 예열하려고 시도합니다. 번호가 높은 블록을 읽을 때 번호가 낮은 블록이 제거 될 수 있습니다. 사전 예열 된 데이터는 캐시 제거로부터 특별한 보호를받지 않으므로 다른 시스템 활동이 새로 사전 예열 된 블록을 읽은 직후에이를 제거 할 수 있습니다. 반대로 사전 예열은 다른 데이터를 캐시에서 제거 할 수도 있습니다. 이러한 이유로 프리 워밍은 일반적으로 캐시가 거의 비었을 때 시작시 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e25d9c4fc7da6af49acba3a1d74aecf78d61de9d" translate="yes" xml:space="preserve">
          <source>Note that you can name the collation objects in the SQL environment anything you want. In this example, we follow the naming style that the predefined collations use, which in turn also follow BCP 47, but that is not required for user-defined collations.</source>
          <target state="translated">SQL 환경에서 원하는대로 데이터 정렬 오브젝트의 이름을 지정할 수 있습니다. 이 예에서는 미리 정의 된 데이터 정렬이 사용하는 이름 지정 스타일을 따릅니다.이 데이터 정렬은 BCP 47도 따르지만 사용자 정의 데이터 정렬에는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9f6471c0f24b8d6760419402c171355a4484c03" translate="yes" xml:space="preserve">
          <source>Note that you must execute this command while logged into the PostgreSQL user account, which is described in the previous section.</source>
          <target state="translated">이전 섹션에서 설명한 PostgreSQL 사용자 계정에 로그인 한 상태에서이 명령을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb0a6a455313edbad71a60b25303151964bacc15" translate="yes" xml:space="preserve">
          <source>Note that you should also create an index with the default operator class if you want queries involving ordinary &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt; comparisons to use an index. Such queries cannot use the &lt;code&gt;xxx_pattern_ops&lt;/code&gt; operator classes. (Ordinary equality comparisons can use these operator classes, however.) It is possible to create multiple indexes on the same column with different operator classes. If you do use the C locale, you do not need the &lt;code&gt;xxx_pattern_ops&lt;/code&gt; operator classes, because an index with the default operator class is usable for pattern-matching queries in the C locale.</source>
          <target state="translated">일반 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 비교 와 관련된 쿼리가 인덱스를 사용하도록하려면 기본 연산자 클래스를 사용하여 인덱스를 만들어야합니다 . 이러한 쿼리는 &lt;code&gt;xxx_pattern_ops&lt;/code&gt; 연산자 클래스를 사용할 수 없습니다 . 그러나 평등 평등 비교에서는 이러한 연산자 클래스를 사용할 수 있습니다. 연산자 클래스가 다른 동일한 열에서 여러 인덱스를 만들 수 있습니다. C 로캘을 사용하는 경우 기본 연산자 클래스가있는 인덱스를 C 로캘의 패턴 일치 쿼리에 사용할 수 있으므로 &lt;code&gt;xxx_pattern_ops&lt;/code&gt; 연산자 클래스 가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a9ac1561fc3ccdadc787e0b99a4aeb85f57a226f" translate="yes" xml:space="preserve">
          <source>Note that, for the purposes of combining multiple policies, &lt;code&gt;ALL&lt;/code&gt; policies are treated as having the same type as whichever other type of policy is being applied.</source>
          <target state="translated">여러 정책을 결합 할 목적으로 &lt;code&gt;ALL&lt;/code&gt; 정책은 적용되는 다른 유형의 정책과 동일한 유형을 갖는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0ce85a00735b68da34a1fd226cafeaa370c6ae8f" translate="yes" xml:space="preserve">
          <source>Note the relatively large number of false positives: 2439 rows were selected to be visited in the heap, but none actually matched the query. We could reduce that by specifying a larger signature length. In this example, creating the index with &lt;code&gt;length=200&lt;/code&gt; reduced the number of false positives to 55; but it doubled the index size (to 306 MB) and ended up being slower for this query (125 ms overall).</source>
          <target state="translated">상대적으로 많은 오 탐지 수에 유의하십시오. 힙에서 방문하도록 2439 개의 행이 선택되었지만 실제로는 쿼리와 일치하는 것이 없습니다. 더 큰 서명 길이를 지정하여이를 줄일 수 있습니다. 이 예에서 &lt;code&gt;length=200&lt;/code&gt; 인덱스를 만들면 오 탐지 수가 55로 줄었습니다. 그러나 인덱스 크기를 306MB로 두 배로 늘리고이 쿼리의 속도가 느려졌습니다 (전체 125ms).</target>
        </trans-unit>
        <trans-unit id="ad6486d9d7802af73d40de7a1e56de198a7926a1" translate="yes" xml:space="preserve">
          <source>Note the use of the double underline in the probe name. In a DTrace script using the probe, the double underline needs to be replaced with a hyphen, so &lt;code&gt;transaction-start&lt;/code&gt; is the name to document for users.</source>
          <target state="translated">프로브 이름에 이중 밑줄을 사용하십시오. 프로브를 사용하는 DTrace 스크립트에서 이중 밑줄은 하이픈으로 바꿔야하므로 &lt;code&gt;transaction-start&lt;/code&gt; 는 사용자를 위해 문서화 할 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6d65457512b308441a74c7c138c05193c57c7bb6" translate="yes" xml:space="preserve">
          <source>Note there can be ambiguity in the &lt;code&gt;months&lt;/code&gt; field returned by &lt;code&gt;age&lt;/code&gt; because different months have different numbers of days. PostgreSQL's approach uses the month from the earlier of the two dates when calculating partial months. For example, &lt;code&gt;age('2004-06-01', '2004-04-30')&lt;/code&gt; uses April to yield &lt;code&gt;1 mon 1 day&lt;/code&gt;, while using May would yield &lt;code&gt;1 mon 2 days&lt;/code&gt; because May has 31 days, while April has only 30.</source>
          <target state="translated">달마다 달 수가 다르기 때문에 &lt;code&gt;age&lt;/code&gt; 로 반환 된 &lt;code&gt;months&lt;/code&gt; 필드 에는 모호성이있을 수 있습니다 . PostgreSQL의 접근 방식은 부분 월을 계산할 때 두 날짜 중 초기의 월을 사용합니다. 예를 들어 &lt;code&gt;age('2004-06-01', '2004-04-30')&lt;/code&gt; 는 April를 사용하여 &lt;code&gt;1 mon 1 day&lt;/code&gt; 을 생성 하는 반면 5 월을 사용하면 5 월은 31 일이되기 때문에 &lt;code&gt;1 mon 2 days&lt;/code&gt; 생성 하고 4 월은 30 일만 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="1afbaf202c9ac2c26c7604e3bc2b4bbf35293589" translate="yes" xml:space="preserve">
          <source>Note, however, that the SQL/MED functionality as a whole is not yet conforming.</source>
          <target state="translated">그러나 SQL / MED 기능은 전체적으로 아직 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccd71e26f3c643a05b48c9814bdace2e62bf73fd" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;ltxtquery&lt;/code&gt; allows whitespace between symbols, but &lt;code&gt;ltree&lt;/code&gt; and &lt;code&gt;lquery&lt;/code&gt; do not.</source>
          <target state="translated">참고 : &lt;code&gt;ltxtquery&lt;/code&gt; 는 심볼 사이의 공백을 허용하지만, &lt;code&gt;ltree&lt;/code&gt; 및 &lt;code&gt;lquery&lt;/code&gt; 은 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b12db1dd6e1d08b3916e0fb99c42096b024c7157" translate="yes" xml:space="preserve">
          <source>Note: This index type is lossy.</source>
          <target state="translated">참고 :이 색인 유형은 손실되었습니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9128e4dc19fdcbce3767684f6724986d863634bf" translate="yes" xml:space="preserve">
          <source>Notes for Windows Users</source>
          <target state="translated">Windows 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="070bd4d20a16681cab0fd80e64bbfd09232b5422" translate="yes" xml:space="preserve">
          <source>Notice here that we don't need to (and indeed cannot) put parentheses around the column name appearing just after &lt;code&gt;SET&lt;/code&gt;, but we do need parentheses when referencing the same column in the expression to the right of the equal sign.</source>
          <target state="translated">여기서 &lt;code&gt;SET&lt;/code&gt; 바로 뒤에 나타나는 열 이름을 괄호로 묶을 필요는 없으며 실제로 등호 오른쪽의 표현식에서 같은 열을 참조 할 때는 괄호가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4daabf40dd7349fdbfe5f996ee7218e2e875bd85" translate="yes" xml:space="preserve">
          <source>Notice how the &lt;code&gt;AS&lt;/code&gt; clause is used to relabel the output column. (The &lt;code&gt;AS&lt;/code&gt; clause is optional.)</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; 절을 사용하여 출력 열의 레이블을 다시 지정하는 방법에 주목하십시오 . 합니다 ( &lt;code&gt;AS&lt;/code&gt; 의 절은 선택 사항입니다.)</target>
        </trans-unit>
        <trans-unit id="6e1ea47811c08b80c4e6755f65407fcd8d137657" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;BETWEEN&lt;/code&gt; treats the endpoint values as included in the range. &lt;code&gt;BETWEEN SYMMETRIC&lt;/code&gt; is like &lt;code&gt;BETWEEN&lt;/code&gt; except there is no requirement that the argument to the left of &lt;code&gt;AND&lt;/code&gt; be less than or equal to the argument on the right. If it is not, those two arguments are automatically swapped, so that a nonempty range is always implied.</source>
          <target state="translated">것을 알 수 &lt;code&gt;BETWEEN&lt;/code&gt; 취급 엔드 포인트 값이 같은 범위에 포함되어 있습니다. &lt;code&gt;BETWEEN SYMMETRIC&lt;/code&gt; 은 &lt;code&gt;AND&lt;/code&gt; 의 왼쪽에 있는 인수가 오른쪽에있는 인수보다 작거나 같아야 한다는 요구 사항이 없다는 점을 제외하면 &lt;code&gt;BETWEEN&lt;/code&gt; 과 같습니다. 그렇지 않은 경우 두 인수가 자동으로 교체되므로 비어 있지 않은 범위가 항상 내포됩니다.</target>
        </trans-unit>
        <trans-unit id="faa7b0c69e4931a2ff5fa82ad77b7c14b3d74a7b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;BETWEEN&lt;/code&gt; treats the endpoint values as included in the range. &lt;code&gt;NOT BETWEEN&lt;/code&gt; does the opposite comparison:</source>
          <target state="translated">것을 알 수 &lt;code&gt;BETWEEN&lt;/code&gt; 취급 엔드 포인트 값이 같은 범위에 포함되어 있습니다. &lt;code&gt;NOT BETWEEN&lt;/code&gt; 은 반대 비교를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8240947764f6659f2796d4acf4007ac22ad3a1c1" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;supernova star&lt;/code&gt; matches &lt;code&gt;supernovae stars&lt;/code&gt; in &lt;code&gt;thesaurus_astro&lt;/code&gt; because we specified the &lt;code&gt;english_stem&lt;/code&gt; stemmer in the thesaurus definition. The stemmer removed the &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">공지 사항 것을 &lt;code&gt;supernova star&lt;/code&gt; 경기는 &lt;code&gt;supernovae stars&lt;/code&gt; 에 &lt;code&gt;thesaurus_astro&lt;/code&gt; 우리가 지정했기 때문에 &lt;code&gt;english_stem&lt;/code&gt; 의 동의어 사전 정의 형태소 분석기를. 형태소 분석기는 &lt;code&gt;e&lt;/code&gt; 와 &lt;code&gt;s&lt;/code&gt; 를 제거했습니다 .</target>
        </trans-unit>
        <trans-unit id="89eb1ae6972d1166d8e27e8ffc5a4983fca12820" translate="yes" xml:space="preserve">
          <source>Notice that although the recursive view's name is schema-qualified in this &lt;code&gt;CREATE&lt;/code&gt;, its internal self-reference is not schema-qualified. This is because the implicitly-created CTE's name cannot be schema-qualified.</source>
          <target state="translated">이 &lt;code&gt;CREATE&lt;/code&gt; 에서는 재귀 뷰의 이름이 스키마로 규정되어 있지만 내부 자체 참조는 스키마로 규정되지 않습니다. 내재적으로 작성된 CTE의 이름을 스키마로 규정 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c36fb1e9faaa2ef2c027bbd666eb850c4abbeb31" translate="yes" xml:space="preserve">
          <source>Notice that except for the two-argument form of &lt;code&gt;enum_range&lt;/code&gt;, these functions disregard the specific value passed to them; they care only about its declared data type. Either null or a specific value of the type can be passed, with the same result. It is more common to apply these functions to a table column or function argument than to a hardwired type name as suggested by the examples.</source>
          <target state="translated">&lt;code&gt;enum_range&lt;/code&gt; 의 두 인수 형식을 제외 하고 이러한 함수는 전달 된 특정 값을 무시합니다. 선언 된 데이터 유형에만 관심이 있습니다. 동일한 결과로 null 또는 특정 유형의 값을 전달할 수 있습니다. 예제에서 제안한대로 하드 와이어 유형 이름보다는 테이블 열 또는 함수 인수에 이러한 함수를 적용하는 것이 더 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="fb75cf9e722bdf4111edc3be58d21f8a3427f3ff" translate="yes" xml:space="preserve">
          <source>Notice that except for the two-argument form of &lt;code&gt;enum_range&lt;/code&gt;, these functions disregard the specific value passed to them; they care only about its declared data type. Either null or a specific value of the type can be passed, with the same result. It is more common to apply these functions to a table column or function argument than to a hardwired type name as used in the examples.</source>
          <target state="translated">두 인수 형식의 &lt;code&gt;enum_range&lt;/code&gt; 를 제외하고 이러한 함수는 전달 된 특정 값을 무시합니다. 선언 된 데이터 유형에만 관심이 있습니다. 동일한 결과로 널 또는 유형의 특정 값을 전달할 수 있습니다. 이러한 함수를 예제에 사용 된대로 고정 된 유형 이름보다 테이블 열 또는 함수 인수에 적용하는 것이 더 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="3f7db9efeeec80f82f8d01c7d6c915db40d7ca58" translate="yes" xml:space="preserve">
          <source>Notice that here the planner has chosen to &amp;ldquo;materialize&amp;rdquo; the inner relation of the join, by putting a Materialize plan node atop it. This means that the &lt;code&gt;t2&lt;/code&gt; index scan will be done just once, even though the nested-loop join node needs to read that data ten times, once for each row from the outer relation. The Materialize node saves the data in memory as it's read, and then returns the data from memory on each subsequent pass.</source>
          <target state="translated">여기서 플래너는 구체화 계획 노드를 배치하여 결합의 내부 관계를 &quot;구체화&quot;하도록 선택했습니다. 즉 , 중첩 루프 조인 노드가 외부 관계에서 각 행에 대해 한 번씩 해당 데이터를 10 번 읽어야하더라도 &lt;code&gt;t2&lt;/code&gt; 인덱스 스캔은 한 번만 수행됩니다. Materialise 노드는 읽은대로 데이터를 메모리에 저장 한 다음 이후의 각 패스에서 메모리에서 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4bf689adc2caa48f04b5854bba37632c664406c0" translate="yes" xml:space="preserve">
          <source>Notice that in both &lt;code&gt;ROWS&lt;/code&gt; and &lt;code&gt;GROUPS&lt;/code&gt; mode, &lt;code&gt;0 PRECEDING&lt;/code&gt; and &lt;code&gt;0 FOLLOWING&lt;/code&gt; are equivalent to &lt;code&gt;CURRENT ROW&lt;/code&gt;. This normally holds in &lt;code&gt;RANGE&lt;/code&gt; mode as well, for an appropriate data-type-specific meaning of &amp;ldquo;zero&amp;rdquo;.</source>
          <target state="translated">공지 사항은 모두 것을 &lt;code&gt;ROWS&lt;/code&gt; 와 &lt;code&gt;GROUPS&lt;/code&gt; 모드, &lt;code&gt;0 PRECEDING&lt;/code&gt; 와 &lt;code&gt;0 FOLLOWING&lt;/code&gt; 에 해당합니다 &lt;code&gt;CURRENT ROW&lt;/code&gt; . 이것은 일반적으로 &amp;ldquo;제로&amp;rdquo;라는 적절한 데이터 유형별 의미를 위해 &lt;code&gt;RANGE&lt;/code&gt; 모드에서도 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="944ef29330d1f49189c08507e0ff3ef14adbfe93" translate="yes" xml:space="preserve">
          <source>Notice that inside the dollar-quoted string, single quotes can be used without needing to be escaped. Indeed, no characters inside a dollar-quoted string are ever escaped: the string content is always written literally. Backslashes are not special, and neither are dollar signs, unless they are part of a sequence matching the opening tag.</source>
          <target state="translated">달러 인용 문자열 내에서 이스케이프하지 않고 작은 따옴표를 사용할 수 있습니다. 실제로, 달러 인용 문자열 내부의 문자는 이스케이프 처리되지 않습니다. 문자열 내용은 항상 문자 그대로 작성됩니다. 백 슬래시는 특수하지 않으며 시작 태그와 일치하는 시퀀스의 일부가 아닌 한 달러 기호도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f68a4013d1520908a834c3452585e4c0680f0866" translate="yes" xml:space="preserve">
          <source>Notice that placing the restriction in the &lt;code&gt;WHERE&lt;/code&gt; clause produces a different result:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 절에 제한을두면 다른 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d13f7a26b5cfa0ec363a717ba07bad2b152f0f72" translate="yes" xml:space="preserve">
          <source>Notice that the 2-argument version of &lt;code&gt;to_tsvector&lt;/code&gt; is used. Only text search functions that specify a configuration name can be used in expression indexes (&lt;a href=&quot;indexes-expressional&quot;&gt;Section 11.7&lt;/a&gt;). This is because the index contents must be unaffected by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt;. If they were affected, the index contents might be inconsistent because different entries could contain &lt;code&gt;tsvector&lt;/code&gt;s that were created with different text search configurations, and there would be no way to guess which was which. It would be impossible to dump and restore such an index correctly.</source>
          <target state="translated">&lt;code&gt;to_tsvector&lt;/code&gt; 의 2 인수 버전 이 사용됩니다. 구성 이름을 지정하는 텍스트 검색 기능 만 표현식 색인에 사용할 수 있습니다 ( &lt;a href=&quot;indexes-expressional&quot;&gt;11.7 절&lt;/a&gt; ). 인덱스 내용은 &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config의&lt;/a&gt; 영향을받지 않아야하기 때문 입니다. 영향을받는 경우, 다른 항목이 다른 텍스트 검색 구성으로 작성된 &lt;code&gt;tsvector&lt;/code&gt; 를 포함 할 수 있고 어떤 항목을 추측 할 방법이 없기 때문에 색인 내용이 일치하지 않을 수 있습니다 . 그러한 인덱스를 올바르게 덤프 및 복원하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="4b9c07bbe048665c89925c842ae22cd1fc6040f9" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;DROP&lt;/code&gt; syntax only specifies the &amp;ldquo;slot&amp;rdquo; in the operator family, by strategy or support number and input data type(s). The name of the operator or function occupying the slot is not mentioned. Also, for &lt;code&gt;DROP FUNCTION&lt;/code&gt; the type(s) to specify are the input data type(s) the function is intended to support; for GiST, SP-GiST and GIN indexes this might have nothing to do with the actual input argument types of the function.</source>
          <target state="translated">알 &lt;code&gt;DROP&lt;/code&gt; 의 문법 만 전략 또는 지원 번호 입력 데이터 타입 (들)에 의해, 오퍼레이터 가족의 &quot;슬롯&quot;을 지정한다. 슬롯을 점유하는 오퍼레이터 또는 기능의 이름은 언급되지 않았습니다. 또한 &lt;code&gt;DROP FUNCTION&lt;/code&gt; 의 경우 지정할 유형은 입력 데이터 유형이며, 함수가 지원하도록되어 있습니다. GiST, SP-GiST 및 GIN 인덱스의 경우 이는 함수의 실제 입력 인수 유형과 관련이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="051e5841933239126fb981b1dfd93c63aee12913" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;EXPLAIN&lt;/code&gt; output shows the &lt;code&gt;WHERE&lt;/code&gt; clause being applied as a &amp;ldquo;filter&amp;rdquo; condition attached to the Seq Scan plan node. This means that the plan node checks the condition for each row it scans, and outputs only the ones that pass the condition. The estimate of output rows has been reduced because of the &lt;code&gt;WHERE&lt;/code&gt; clause. However, the scan will still have to visit all 10000 rows, so the cost hasn't decreased; in fact it has gone up a bit (by 10000 * &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt;, to be exact) to reflect the extra CPU time spent checking the &lt;code&gt;WHERE&lt;/code&gt; condition.</source>
          <target state="translated">주목하라 그 &lt;code&gt;EXPLAIN&lt;/code&gt; 출력 프로그램을 &lt;code&gt;WHERE&lt;/code&gt; 절은 서열 검사 계획 노드에 부착 된 &quot;필터&quot;상태로 적용된다. 이는 계획 노드가 스캔하는 각 행의 조건을 확인하고 조건을 통과 한 행만 출력 함을 의미합니다. &lt;code&gt;WHERE&lt;/code&gt; 절로 인해 출력 행의 추정치가 줄었습니다 . 그러나 스캔은 여전히 ​​10000 행을 모두 방문해야하므로 비용이 줄어들지 않았습니다. 실제로 &lt;code&gt;WHERE&lt;/code&gt; 조건 을 확인하는 데 소비되는 추가 CPU 시간을 반영하기 위해 비트가 약간 증가했습니다 ( 정확히 10000 * &lt;a href=&quot;runtime-config-query#GUC-CPU-OPERATOR-COST&quot;&gt;cpu_operator_cost&lt;/a&gt; ) .</target>
        </trans-unit>
        <trans-unit id="d34da680054f05253f7563479166aab9f149ee00" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;WITH&lt;/code&gt; query was evaluated only once, so that we got two sets of the same three random values.</source>
          <target state="translated">것을 알 수 &lt;code&gt;WITH&lt;/code&gt; 의 쿼리가 우리가 같은 세 가지 임의의 값의 두 세트를 가지고 그래서, 한 번만 평가 하였다.</target>
        </trans-unit>
        <trans-unit id="51724582644bab73340aa6c622d37155c5257732" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;picksplit&lt;/code&gt; function's result is delivered by modifying the passed-in &lt;code&gt;v&lt;/code&gt; structure. The return value per se is ignored, though it's conventional to pass back the address of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">전달 된 &lt;code&gt;v&lt;/code&gt; 구조를 수정 하면 &lt;code&gt;picksplit&lt;/code&gt; 함수의 결과가 전달됩니다 . &lt;code&gt;v&lt;/code&gt; 의 주소를 다시 전달하는 것이 일반적이지만 반환 값 자체는 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="bf156003e881a5db213ca4ff342d316a104a89cc" translate="yes" xml:space="preserve">
          <source>Notice that the above commands specify copying the &lt;code&gt;template0&lt;/code&gt; database. When copying any other database, the encoding and locale settings cannot be changed from those of the source database, because that might result in corrupt data. For more information see &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;Section 22.3&lt;/a&gt;.</source>
          <target state="translated">위의 명령은 &lt;code&gt;template0&lt;/code&gt; 데이터베이스 복사를 지정 합니다. 다른 데이터베이스를 복사 할 때 인코딩 및 로케일 설정을 소스 데이터베이스의 설정 및 로케일 설정에서 변경할 수 없습니다. 데이터가 손상 될 수 있습니다. 자세한 정보는 &lt;a href=&quot;manage-ag-templatedbs&quot;&gt;섹션 22.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8cdb89e02698866354e5dd11605d6eb9295c222" translate="yes" xml:space="preserve">
          <source>Notice that the array elements are ordinary SQL constants or expressions; for instance, string literals are single quoted, instead of double quoted as they would be in an array literal. The &lt;code&gt;ARRAY&lt;/code&gt; constructor syntax is discussed in more detail in &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ARRAY-CONSTRUCTORS&quot;&gt;Section 4.2.12&lt;/a&gt;.</source>
          <target state="translated">배열 요소는 일반적인 SQL 상수 또는 표현식입니다. 예를 들어, 문자열 리터럴은 배열 리터럴에서와 같이 큰 따옴표 대신 작은 따옴표로 묶습니다. &lt;code&gt;ARRAY&lt;/code&gt; 의 생성자의 구문에서보다 상세히 논의된다 &lt;a href=&quot;sql-expressions#SQL-SYNTAX-ARRAY-CONSTRUCTORS&quot;&gt;섹션 4.2.12&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66469b4e59f919ba275ed4a6fda1a4c5c23cd621" translate="yes" xml:space="preserve">
          <source>Notice that the individual subcommands do not end with semicolons.</source>
          <target state="translated">개별 부속 명령은 세미콜론으로 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3160def781e659e6cdc752185f9870b36c8a345f" translate="yes" xml:space="preserve">
          <source>Notice that the number of rows estimated to be returned from the bitmap index scan reflects only the condition used with the index; this is important since it affects the cost estimate for the subsequent heap fetches.</source>
          <target state="translated">비트 맵 인덱스 스캔에서 리턴 된 것으로 추정되는 행 수는 인덱스와 함께 사용 된 조건 만 반영합니다. 이는 후속 힙 페치에 대한 비용 추정에 영향을주기 때문에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="873a445a12a2fae4f43b1f16da917ba94ef395cb" translate="yes" xml:space="preserve">
          <source>Notice that the owner's implicit grant options are not marked in the access privileges display. A &lt;code&gt;*&lt;/code&gt; will appear only when grant options have been explicitly granted to someone.</source>
          <target state="translated">소유자의 암시 적 부여 옵션은 액세스 권한 표시에 표시되지 않습니다. &lt;code&gt;*&lt;/code&gt; 는 그랜트 옵션이 명시 적으로 누군가에게 부여 된 경우에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="bf407e6deb6991a0a95054bdc8f3340e9ff64b36" translate="yes" xml:space="preserve">
          <source>Notice that the period (&lt;code&gt;.&lt;/code&gt;) is not a metacharacter for &lt;code&gt;SIMILAR TO&lt;/code&gt;.</source>
          <target state="translated">마침표 ( &lt;code&gt;.&lt;/code&gt; )는 &lt;code&gt;SIMILAR TO&lt;/code&gt; 의 메타 문자가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="74768806db56cf6b766037079dc057b3f23de85a" translate="yes" xml:space="preserve">
          <source>Notice that the primary key overlaps with the foreign keys in the last table.</source>
          <target state="translated">기본 키는 마지막 테이블의 외래 키와 겹칩니다.</target>
        </trans-unit>
        <trans-unit id="8e2f5e5785b45b8d6d5aee74a3bd7e8d7b7e0944" translate="yes" xml:space="preserve">
          <source>Notice that this example defines the &lt;code&gt;page_count&lt;/code&gt; result column as an integer. The function deals internally with string representations, so when you say you want an integer in the output, it will take the string representation of the XPath result and use PostgreSQL input functions to transform it into an integer (or whatever type the &lt;code&gt;AS&lt;/code&gt; clause requests). An error will result if it can't do this &amp;mdash; for example if the result is empty &amp;mdash; so you may wish to just stick to &lt;code&gt;text&lt;/code&gt; as the column type if you think your data has any problems.</source>
          <target state="translated">이 예제는 &lt;code&gt;page_count&lt;/code&gt; 결과 열을 정수로 정의합니다 . 이 함수는 내부적으로 문자열 표현을 처리하므로 출력에서 ​​정수를 원할 때 XPath 결과의 문자열 표현을 가져 와서 PostgreSQL 입력 함수를 사용하여 정수로 변환합니다 (또는 &lt;code&gt;AS&lt;/code&gt; 절이 요청 하는 모든 유형 ). . 이 작업을 수행 할 수없는 경우 (예 : 결과가 비어있는 경우) 오류가 발생하므로 데이터에 문제가 있다고 생각되면 &lt;code&gt;text&lt;/code&gt; 를 열 유형으로 고수 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b9217ccd836ba1fba783902d277384da15bf50d" translate="yes" xml:space="preserve">
          <source>Notice that we showed &lt;code&gt;inner_cardinality&lt;/code&gt; as 10000, that is, the unmodified size of &lt;code&gt;tenk2&lt;/code&gt;. It might appear from inspection of the &lt;code&gt;EXPLAIN&lt;/code&gt; output that the estimate of join rows comes from 50 * 1, that is, the number of outer rows times the estimated number of rows obtained by each inner index scan on &lt;code&gt;tenk2&lt;/code&gt;. But this is not the case: the join relation size is estimated before any particular join plan has been considered. If everything is working well then the two ways of estimating the join size will produce about the same answer, but due to round-off error and other factors they sometimes diverge significantly.</source>
          <target state="translated">공지 사항 우리는 보여 주었다 &lt;code&gt;inner_cardinality&lt;/code&gt; 을 ,의 수정되지 않은 크기입니다, 10000로 &lt;code&gt;tenk2&lt;/code&gt; . (가)의이 검사에서 나타날 수 &lt;code&gt;EXPLAIN&lt;/code&gt; 행 가입의 추정치는 50 * (1)로부터 오는 출력 즉, 외부 행 횟수 각 내부 인덱스 스캔에 의해 얻어진 예상 행 번호 &lt;code&gt;tenk2&lt;/code&gt; . 그러나 이것은 사실이 아닙니다. 결합 관계의 크기는 특정 결합 계획이 고려되기 전에 추정됩니다. 모든 것이 잘 작동하면 결합 크기를 추정하는 두 가지 방법으로 거의 같은 대답을 얻을 수 있지만 반올림 오류 및 기타 요인으로 인해 때로는 크게 분기됩니다.</target>
        </trans-unit>
        <trans-unit id="159dfc60dcca0632285615def5fab2a023373a94" translate="yes" xml:space="preserve">
          <source>Notice that while the plain (unaggregated) log file shows which script was used for each transaction, the aggregated log does not. Therefore if you need per-script data, you need to aggregate the data on your own.</source>
          <target state="translated">일반 (집계되지 않은) 로그 파일에는 각 트랜잭션에 사용 된 스크립트가 표시되지만 집계 된 로그는 표시되지 않습니다. 따라서 스크립트 별 데이터가 필요한 경우 자체적으로 데이터를 집계해야합니다.</target>
        </trans-unit>
        <trans-unit id="99369cd02fa72e17001071790856a797298fed53" translate="yes" xml:space="preserve">
          <source>Notice the typical form of recursive queries: an initial condition, followed by &lt;code&gt;UNION&lt;/code&gt;, followed by the recursive part of the query. Be sure that the recursive part of the query will eventually return no tuples, or else the query will loop indefinitely. (See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; for more examples.)</source>
          <target state="translated">재귀 쿼리의 일반적인 형식 인 초기 조건, &lt;code&gt;UNION&lt;/code&gt; , 쿼리의 재귀 부분을 확인하십시오. 쿼리의 재귀 부분이 결국 튜플을 반환하지 않으면 쿼리가 무한 반복됩니다. ( 더 많은 예제는 &lt;a href=&quot;queries-with&quot;&gt;7.8 절을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="085506905d3dc520376505271fd3c45af0c829eb" translate="yes" xml:space="preserve">
          <source>Notice we don't use &lt;code&gt;-C&lt;/code&gt;, and instead connect directly to the database to be restored into. Also note that we clone the new database from &lt;code&gt;template0&lt;/code&gt; not &lt;code&gt;template1&lt;/code&gt;, to ensure it is initially empty.</source>
          <target state="translated">&lt;code&gt;-C&lt;/code&gt; 를 사용하지 않고 대신 복원 할 데이터베이스에 직접 연결하십시오. 또한 &lt;code&gt;template0&lt;/code&gt; 아닌 &lt;code&gt;template1&lt;/code&gt; 에서 새 데이터베이스를 복제하여 처음에 비어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bb9bfefd5391f52be54267e2a938a126661b0ff7" translate="yes" xml:space="preserve">
          <source>Nov</source>
          <target state="translated">Nov</target>
        </trans-unit>
        <trans-unit id="3c5bf776f5efcaa22d6e0fd4839db7d2b83e52be" translate="yes" xml:space="preserve">
          <source>November</source>
          <target state="translated">November</target>
        </trans-unit>
        <trans-unit id="0ffcf97fe0b617e1a1fb0f97e1a88d84bed8f352" translate="yes" xml:space="preserve">
          <source>Now consider the same query, but with a constant that is not in the MCV list:</source>
          <target state="translated">이제 동일한 쿼리를 고려하지만 MCV 목록에없는 상수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1101583b5cab5dfe73a02721963b60a84711fcd9" translate="yes" xml:space="preserve">
          <source>Now it is impossible to create orders with non-NULL &lt;code&gt;product_no&lt;/code&gt; entries that do not appear in the products table.</source>
          <target state="translated">이제 제품 테이블에 나타나지 않는 NULL이 아닌 &lt;code&gt;product_no&lt;/code&gt; 항목으로 주문을 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="05189fbbab4b515fc19f955242b1b42d3dc53c9c" translate="yes" xml:space="preserve">
          <source>Now it is possible to bind the thesaurus dictionary &lt;code&gt;thesaurus_simple&lt;/code&gt; to the desired token types in a configuration, for example:</source>
          <target state="translated">이제 동의어 사전 &lt;code&gt;thesaurus_simple&lt;/code&gt; 동의어 사전 을 구성에서 원하는 토큰 유형에 바인딩 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14b6efa33e8cde1d203d7549fcab8edf43d173c9" translate="yes" xml:space="preserve">
          <source>Now it is possible to create a foreign table with &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt;. In this example we wish to access the table named &lt;code&gt;some_schema.some_table&lt;/code&gt; on the remote server. The local name for it will be &lt;code&gt;foreign_table&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; 을 사용하여 외래 테이블을 만들 수 있습니다 . 이 예에서는 원격 서버의 &lt;code&gt;some_schema.some_table&lt;/code&gt; 테이블에 액세스하려고 합니다. 로컬 이름은 &lt;code&gt;foreign_table&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="dd96a87b36842da43e36de2200fdfc1838f0e684" translate="yes" xml:space="preserve">
          <source>Now let's add another condition to the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">이제 &lt;code&gt;WHERE&lt;/code&gt; 절에 다른 조건을 추가해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="95432c22f405504df2d81a0fb2d4efc9ca2560c4" translate="yes" xml:space="preserve">
          <source>Now let's consider a case with more than one condition in the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">이제 &lt;code&gt;WHERE&lt;/code&gt; 절 에 하나 이상의 조건이있는 경우를 생각해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="f0a0a72cb219eba72676d0750f57b70ee142cf22" translate="yes" xml:space="preserve">
          <source>Now let's modify the query to add a &lt;code&gt;WHERE&lt;/code&gt; condition:</source>
          <target state="translated">이제 쿼리를 수정하여 &lt;code&gt;WHERE&lt;/code&gt; 조건 을 추가하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="47c1122f650e2dbfda8bc7f189317df3657e8635" translate="yes" xml:space="preserve">
          <source>Now look at the table definition again:</source>
          <target state="translated">이제 테이블 정의를 다시 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="d6a6836d17a53567c7bdd65d95a74e120c1311f5" translate="yes" xml:space="preserve">
          <source>Now suppose that &lt;code&gt;alice&lt;/code&gt; wishes to change the &amp;ldquo;slightly secret&amp;rdquo; information, but decides that &lt;code&gt;mallory&lt;/code&gt; should not be trusted with the new content of that row, so she does:</source>
          <target state="translated">이제 가정 &lt;code&gt;alice&lt;/code&gt; 은 &quot;약간 비밀&quot;정보를 변경하고자하지만, 그 결정 &lt;code&gt;mallory&lt;/code&gt; 그녀가 있으므로, 해당 행의 새로운 내용으로 신뢰해서는 안된다 :</target>
        </trans-unit>
        <trans-unit id="9c4ea909bc20a14cf1d5201600f80228a4642b36" translate="yes" xml:space="preserve">
          <source>Now the parenthesized object is correctly interpreted as a reference to the &lt;code&gt;item&lt;/code&gt; column, and then the subfield can be selected from it.</source>
          <target state="translated">이제 괄호로 묶은 객체가 &lt;code&gt;item&lt;/code&gt; 열에 대한 참조로 올바르게 해석 된 후 서브 필드를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="deae757ce21f92bbc32823a914fbc837ca56a164" translate="yes" xml:space="preserve">
          <source>Now this is fine for PostgreSQL-specific applications, but standard code using JDBC or ODBC won't delete the objects, resulting in orphan objects &amp;mdash; objects that are not referenced by anything, and simply occupy disk space.</source>
          <target state="translated">이제 이것은 PostgreSQL 특정 응용 프로그램에는 적합하지만 JDBC 또는 ODBC를 사용하는 표준 코드는 객체를 삭제하지 않으므로 고아 객체 (어떤 것이 참조하지 않는 객체)를 생성하고 단순히 디스크 공간을 차지합니다.</target>
        </trans-unit>
        <trans-unit id="084bd00ac798eb5161b956e1962a53497a37531c" translate="yes" xml:space="preserve">
          <source>Now try inserting an invalid record:</source>
          <target state="translated">이제 잘못된 레코드를 삽입하십시오 :</target>
        </trans-unit>
        <trans-unit id="5458bef284659cf16721d439d4b767332bf554fc" translate="yes" xml:space="preserve">
          <source>Now we are ready to perform a fast full text search:</source>
          <target state="translated">이제 빠른 전체 텍스트 검색을 수행 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="a02f5ffaa75cbfc6c6328ab3a75ec757069f839c" translate="yes" xml:space="preserve">
          <source>Now we can see how it works. &lt;code&gt;ts_lexize&lt;/code&gt; is not very useful for testing a thesaurus, because it treats its input as a single token. Instead we can use &lt;code&gt;plainto_tsquery&lt;/code&gt; and &lt;code&gt;to_tsvector&lt;/code&gt; which will break their input strings into multiple tokens:</source>
          <target state="translated">이제 어떻게 작동하는지 볼 수 있습니다. &lt;code&gt;ts_lexize&lt;/code&gt; 는 입력을 단일 토큰으로 취급하기 때문에 동의어 사전을 테스트하는 데별로 유용하지 않습니다. 대신 &lt;code&gt;plainto_tsquery&lt;/code&gt; 와 &lt;code&gt;to_tsvector&lt;/code&gt; 를 사용 하여 입력 문자열을 여러 토큰으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18b6223b0641dfa27780508785b1cab41976292c" translate="yes" xml:space="preserve">
          <source>Now we can set up the mappings for words in configuration &lt;code&gt;pg&lt;/code&gt;:</source>
          <target state="translated">이제 구성 &lt;code&gt;pg&lt;/code&gt; 에서 단어에 대한 매핑을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b4d3c996fedace29e66a9cecc69860990e5567d4" translate="yes" xml:space="preserve">
          <source>Now we can show some &lt;code&gt;INSERT&lt;/code&gt; statements:</source>
          <target state="translated">이제 몇 가지 &lt;code&gt;INSERT&lt;/code&gt; 문을 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9811d50e24107f487d484ef3d4f8590f2676cba5" translate="yes" xml:space="preserve">
          <source>Now we can test our configuration:</source>
          <target state="translated">이제 구성을 테스트 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ace10f4ace4cfabef3a16f550a37af5ffc6dcce7" translate="yes" xml:space="preserve">
          <source>Now we can test our dictionary:</source>
          <target state="translated">이제 사전을 테스트 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f27c4f52d858064037f2d98b4e6143af1fdd5e4c" translate="yes" xml:space="preserve">
          <source>Now we change the prompt to something more interesting:</source>
          <target state="translated">이제 프롬프트를보다 흥미로운 것으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="d4a301c61d4f0a929427d7399e79093ab65b2312" translate="yes" xml:space="preserve">
          <source>Now we will figure out how we can get the Hayward records back in. What we want the query to do is to scan the &lt;code&gt;weather&lt;/code&gt; table and for each row to find the matching &lt;code&gt;cities&lt;/code&gt; row(s). If no matching row is found we want some &amp;ldquo;empty values&amp;rdquo; to be substituted for the &lt;code&gt;cities&lt;/code&gt; table's columns. This kind of query is called an &lt;em&gt;outer join&lt;/em&gt;. (The joins we have seen so far are inner joins.) The command looks like this:</source>
          <target state="translated">이제 Hayward 레코드를 다시 가져올 수있는 방법을 알아볼 것입니다. 쿼리가 원하는 것은 &lt;code&gt;weather&lt;/code&gt; 테이블 을 스캔하고 각 행이 일치하는 &lt;code&gt;cities&lt;/code&gt; 행 을 찾는 것 입니다. 일치하는 행이 없으면 일부 &quot;빈 값&quot;을 &lt;code&gt;cities&lt;/code&gt; 테이블의 열로 대체하려고합니다 . 이러한 종류의 쿼리를 &lt;em&gt;외부 조인&lt;/em&gt; 이라고합니다 . 지금까지 본 조인은 내부 조인입니다. 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ce7fd7c4c102dd293619badd0d980d7f605bb16" translate="yes" xml:space="preserve">
          <source>Now you are ready to create the foreign data table. Using the &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; command, you will need to define the columns for the table, the CSV file name, and its format:</source>
          <target state="translated">이제 외부 데이터 테이블을 작성할 준비가되었습니다. (가) 사용 &lt;code&gt;CREATE FOREIGN TABLE&lt;/code&gt; 명령을, 테이블, CSV 파일 이름과 형식의 열을 정의해야합니다 :</target>
        </trans-unit>
        <trans-unit id="64a8dd2545b6bf024381f0d92feccb523f90f566" translate="yes" xml:space="preserve">
          <source>Now you need only &lt;code&gt;SELECT&lt;/code&gt; from a foreign table to access the data stored in its underlying remote table. You can also modify the remote table using &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. (Of course, the remote user you have specified in your user mapping must have privileges to do these things.)</source>
          <target state="translated">이제 기본 원격 테이블에 저장된 데이터에 액세스하려면 외부 테이블에서 &lt;code&gt;SELECT&lt;/code&gt; 만 필요 합니다. &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 를 사용하여 원격 테이블을 수정할 수도 있습니다 . 물론 사용자 매핑에 지정한 원격 사용자에게는 이러한 작업을 수행 할 수있는 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="08d3e6ece6ec2bb9a41472c3b51de60739aa48a4" translate="yes" xml:space="preserve">
          <source>Now, a &lt;code&gt;SELECT&lt;/code&gt; query similar to the previous example can be used to suggest spellings for misspelled words in user search terms. A useful extra test is to require that the selected words are also of similar length to the misspelled word.</source>
          <target state="translated">이제 이전 예와 유사한 &lt;code&gt;SELECT&lt;/code&gt; 쿼리를 사용하여 사용자 검색어에서 철자가 틀린 단어의 철자를 제안 할 수 있습니다. 유용한 추가 테스트는 선택한 단어의 철자가 틀린 단어와 비슷한 길이를 요구하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb91f362c7c32cf6e84b89572465a581c06ab515" translate="yes" xml:space="preserve">
          <source>Now, let's make the condition more restrictive:</source>
          <target state="translated">이제 조건을 더 제한적으로 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="fb9ab76d936c6c858686ae054f0811c70819eab5" translate="yes" xml:space="preserve">
          <source>Now, the &lt;code&gt;WHERE&lt;/code&gt; clause &lt;code&gt;jdoc -&amp;gt; 'tags' ? 'qui'&lt;/code&gt; will be recognized as an application of the indexable operator &lt;code&gt;?&lt;/code&gt; to the indexed expression &lt;code&gt;jdoc -&amp;gt; 'tags'&lt;/code&gt;. (More information on expression indexes can be found in &lt;a href=&quot;indexes-expressional&quot;&gt;Section 11.7&lt;/a&gt;.)</source>
          <target state="translated">이제 &lt;code&gt;WHERE&lt;/code&gt; 절 &lt;code&gt;jdoc -&amp;gt; 'tags' ? 'qui'&lt;/code&gt; 는 인덱싱 가능한 연산자의 응용 프로그램으로 인식 &lt;code&gt;?&lt;/code&gt; 색인 된 표현식 &lt;code&gt;jdoc -&amp;gt; 'tags'&lt;/code&gt; . (표현식 인덱스에 대한 자세한 내용 &lt;a href=&quot;indexes-expressional&quot;&gt;은 11.7 절&lt;/a&gt; 에서 찾을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="9343983b435f96d35ab006d0ce2a792fa81e36a3" translate="yes" xml:space="preserve">
          <source>Now, the catalogs also provide a cast from &lt;code&gt;numeric&lt;/code&gt; to &lt;code&gt;integer&lt;/code&gt;. If that cast were marked &lt;code&gt;AS IMPLICIT&lt;/code&gt; &amp;mdash; which it is not &amp;mdash; then the parser would be faced with choosing between the above interpretation and the alternative of casting the &lt;code&gt;numeric&lt;/code&gt; constant to &lt;code&gt;integer&lt;/code&gt; and applying the &lt;code&gt;integer&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;integer&lt;/code&gt; operator. Lacking any knowledge of which choice to prefer, it would give up and declare the query ambiguous. The fact that only one of the two casts is implicit is the way in which we teach the parser to prefer resolution of a mixed &lt;code&gt;numeric&lt;/code&gt;-and-&lt;code&gt;integer&lt;/code&gt; expression as &lt;code&gt;numeric&lt;/code&gt;; there is no built-in knowledge about that.</source>
          <target state="translated">이제 카탈로그는 &lt;code&gt;numeric&lt;/code&gt; 에서 &lt;code&gt;integer&lt;/code&gt; 로 캐스트도 제공합니다 . 만약 그 캐스트가 &lt;code&gt;AS IMPLICIT&lt;/code&gt; 로 표시 되었다면 &amp;ndash; 파서는 위의 해석과 &lt;code&gt;numeric&lt;/code&gt; 상수를 &lt;code&gt;integer&lt;/code&gt; 로 캐스트하는 방법과 &lt;code&gt;integer&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;integer&lt;/code&gt; 연산자를 적용하는 대안 중 하나를 선택 해야 합니다 . 선호하는 선택에 대한 지식이 없기 때문에 쿼리를 모호하게 포기하고 선언합니다. 두 캐스트의 하나가 암시 적 사실은 혼합의 해상도를 선호하는 우리가 파서을 가르 칠하는 방법입니다 &lt;code&gt;numeric&lt;/code&gt; - 및 - &lt;code&gt;integer&lt;/code&gt; 로 표현 &lt;code&gt;numeric&lt;/code&gt; ; 그것에 대한 기본 지식이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e07cf090027f130a2dc1fbc4d060d70553c3b5f" translate="yes" xml:space="preserve">
          <source>Now, the main problem with the btree search is that btree is inefficient when the search conditions do not constrain the leading index column(s). A better strategy for btree is to create a separate index on each column. Then the planner will choose something like this:</source>
          <target state="translated">이제 btree 검색의 주요 문제점은 검색 조건이 선행 색인 열을 제한하지 않는 경우 btree가 비효율적이라는 것입니다. btree에 대한 더 나은 전략은 각 열에 별도의 인덱스를 만드는 것입니다. 그런 다음 플래너는 다음과 같은 것을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="8cf5b756d6afa6277b947e17d815b23a45e8f0cf" translate="yes" xml:space="preserve">
          <source>Now, this methodology can be cumbersome with a very large number of entries in the &lt;code&gt;one_to_many&lt;/code&gt; table. Often, a join like this would result in an index scan and a fetch for each right hand entry in the table for a particular left hand entry. If you have a very dynamic system, there is not much you can do. However, if you have some data which is fairly static, you can create a summary table with the aggregator.</source>
          <target state="translated">이제이 방법론은 &lt;code&gt;one_to_many&lt;/code&gt; 테이블 에 많은 수의 항목이있어 성 가실 수 있습니다 . 종종 이와 같은 조인은 특정 왼쪽 항목에 대한 테이블의 각 오른쪽 항목에 대한 색인 스캔 및 페치가 발생합니다. 매우 역동적 인 시스템이라면 할 수있는 일이 많지 않습니다. 그러나 상당히 정적 인 데이터가있는 경우 수집기를 사용하여 요약 테이블을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="333cddf155e5f6b845810ca1b1ec9493a847d199" translate="yes" xml:space="preserve">
          <source>Now, we can run some queries on the table. First, we show how to access a single element of an array. This query retrieves the names of the employees whose pay changed in the second quarter:</source>
          <target state="translated">이제 테이블에서 몇 가지 쿼리를 실행할 수 있습니다. 먼저 배열의 단일 요소에 액세스하는 방법을 보여줍니다. 이 쿼리는 2 분기에 급여가 변경된 직원의 이름을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="e60c418bd02619354d423e5f131c6effce59534d" translate="yes" xml:space="preserve">
          <source>Now, we have a table &lt;code&gt;test&lt;/code&gt; populated with data describing the hierarchy shown below:</source>
          <target state="translated">이제 아래 표시된 계층 구조를 설명하는 데이터로 채워진 테이블 &lt;code&gt;test&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="abc801eb7aa113d4d373983685ad8e4b411d4462" translate="yes" xml:space="preserve">
          <source>Null values are represented by &lt;code&gt;_null_&lt;/code&gt;. (Note that there is no way to create a value that is just that string.)</source>
          <target state="translated">널값은 &lt;code&gt;_null_&lt;/code&gt; 로 표시됩니다 . 해당 문자열 인 값을 만들 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="71197a0f68656e301e5e80254d15a53eb1f65444" translate="yes" xml:space="preserve">
          <source>Nullness tests</source>
          <target state="translated">Nullness 테스트</target>
        </trans-unit>
        <trans-unit id="bf00f0e98d92759b2ab900b85062ac054ac00545" translate="yes" xml:space="preserve">
          <source>Number of &amp;ldquo;internal&amp;rdquo; (upper-level) pages</source>
          <target state="translated">&amp;ldquo;내부&amp;rdquo;(상위) 페이지 수</target>
        </trans-unit>
        <trans-unit id="766db6ffc20af3c98e8a0c222cc91dcfc261ce82" translate="yes" xml:space="preserve">
          <source>Number of &lt;code&gt;CHECK&lt;/code&gt; constraints on the table; see &lt;a href=&quot;catalog-pg-constraint&quot;&gt;&lt;code&gt;pg_constraint&lt;/code&gt;&lt;/a&gt; catalog</source>
          <target state="translated">테이블 의 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건 수 &lt;a href=&quot;catalog-pg-constraint&quot;&gt; &lt;code&gt;pg_constraint&lt;/code&gt; &lt;/a&gt; 카탈로그를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="f562c8ed4194c0f5d892247c878f35e3b1adf69e" translate="yes" xml:space="preserve">
          <source>Number of WAL files that have been successfully archived</source>
          <target state="translated">성공적으로 아카이브 된 WAL 파일 수</target>
        </trans-unit>
        <trans-unit id="c384981df593e79281c2a20754104f1934f6c9b7" translate="yes" xml:space="preserve">
          <source>Number of argument strings passed to trigger function</source>
          <target state="translated">함수를 트리거하기 위해 전달 된 인수 문자열의 수</target>
        </trans-unit>
        <trans-unit id="686b06e76d78fdcab0c83dfec56d5de3d95d6021" translate="yes" xml:space="preserve">
          <source>Number of arguments that have defaults</source>
          <target state="translated">기본값이있는 인수 수</target>
        </trans-unit>
        <trans-unit id="ad8f1d6b3919325e33519443b298eab45ab86017" translate="yes" xml:space="preserve">
          <source>Number of backends currently connected to this database, or &lt;code&gt;NULL&lt;/code&gt; for shared objects. This is the only column in this view that returns a value reflecting current state; all other columns return the accumulated values since the last reset.</source>
          <target state="translated">현재이 데이터베이스에 연결된 백엔드 수 또는 공유 객체의 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다. 현재 상태를 반영하는 값을 반환하는이보기의 유일한 열입니다. 다른 모든 열은 마지막 재설정 이후 누적 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="646ba2279db42aaed6dee8b8ba74083e8ded4a4e" translate="yes" xml:space="preserve">
          <source>Number of backends currently connected to this database, or &lt;code&gt;NULL&lt;/code&gt; for the shared objects. This is the only column in this view that returns a value reflecting current state; all other columns return the accumulated values since the last reset.</source>
          <target state="translated">이 데이터베이스에 현재 연결된 백엔드 수 또는 공유 객체의 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다. 이 뷰에서 현재 상태를 반영하는 값을 반환하는 유일한 열입니다. 다른 모든 열은 마지막 재설정 이후 누적 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="055e292dc7e47521853b27a0e59b3a6f4ac3517d" translate="yes" xml:space="preserve">
          <source>Number of backends pinning this buffer</source>
          <target state="translated">이 버퍼를 고정하는 백엔드 수</target>
        </trans-unit>
        <trans-unit id="7fc2a68fbd98db7f2b41bb2e743259772026c43c" translate="yes" xml:space="preserve">
          <source>Number of bitmap pages</source>
          <target state="translated">비트 맵 페이지 수</target>
        </trans-unit>
        <trans-unit id="7826db063f5934f4aaa44397cffd4f35886a95d2" translate="yes" xml:space="preserve">
          <source>Number of bits generated for each index column. Each parameter's name refers to the number of the index column that it controls. The default is &lt;code&gt;2&lt;/code&gt; bits and maximum is &lt;code&gt;4095&lt;/code&gt;. Parameters for index columns not actually used are ignored.</source>
          <target state="translated">각 인덱스 열에 대해 생성 된 비트 수 각 매개 변수의 이름은 제어하는 ​​색인 ​​열의 번호를 나타냅니다. 기본값은 &lt;code&gt;2&lt;/code&gt; 비트이며 최대 값은 &lt;code&gt;4095&lt;/code&gt; 입니다. 실제로 사용되지 않는 인덱스 열의 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="33909c2a9901d0948fd89312acfb6d3e292b76cf" translate="yes" xml:space="preserve">
          <source>Number of bits generated for each index column. Each parameter's name refers to the number of the index column that it controls. The default is &lt;code&gt;2&lt;/code&gt; bits and the maximum is &lt;code&gt;4095&lt;/code&gt;. Parameters for index columns not actually used are ignored.</source>
          <target state="translated">각 인덱스 열에 대해 생성 된 비트 수입니다. 각 매개 변수의 이름은 제어하는 ​​색인 ​​열의 번호를 나타냅니다. 기본값은 &lt;code&gt;2&lt;/code&gt; 비트이고 최대 값은 &lt;code&gt;4095&lt;/code&gt; 입니다. 실제로 사용되지 않는 인덱스 열의 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6ee47813de9741b16e5983ad54532485c3f7d8" translate="yes" xml:space="preserve">
          <source>Number of bits in string</source>
          <target state="translated">문자열의 비트 수</target>
        </trans-unit>
        <trans-unit id="1efe22f20b8b3239aa455f2b88a22e48c7032a46" translate="yes" xml:space="preserve">
          <source>Number of bits in the encryption algorithm used, or NULL if SSL is not used on this connection</source>
          <target state="translated">사용 된 암호화 알고리즘의 비트 수 또는이 연결에서 SSL을 사용하지 않는 경우 NULL</target>
        </trans-unit>
        <trans-unit id="0aaa9d047e0edd588ca0e7b28edd0b562bba9543" translate="yes" xml:space="preserve">
          <source>Number of blocks already processed in the current phase.</source>
          <target state="translated">현재 단계에서 이미 처리 된 블록 수</target>
        </trans-unit>
        <trans-unit id="1c4fa9ae3322de072b98477062cf3a411db62a9c" translate="yes" xml:space="preserve">
          <source>Number of blocks checked for existence for this SLRU</source>
          <target state="translated">이 SLRU의 존재 여부를 확인한 블록 수</target>
        </trans-unit>
        <trans-unit id="e601295de63e2a2c268076613ec412bef9974925" translate="yes" xml:space="preserve">
          <source>Number of blocks zeroed during initializations</source>
          <target state="translated">초기화 중 비워진 블록 수</target>
        </trans-unit>
        <trans-unit id="00533abb6601d842f496de1f71453437a6ebdea3" translate="yes" xml:space="preserve">
          <source>Number of bucket pages</source>
          <target state="translated">버킷 페이지 수</target>
        </trans-unit>
        <trans-unit id="5f0a807486a5a6ed87ce1d425faa9e67bccd0b96" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in all indexes on this table</source>
          <target state="translated">이 테이블의 모든 인덱스에서 버퍼 히트 수</target>
        </trans-unit>
        <trans-unit id="e19591b7755dbe90f2648065af697ccee73ba936" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this index</source>
          <target state="translated">이 인덱스의 버퍼 히트 수</target>
        </trans-unit>
        <trans-unit id="7bc9f9ddcb6814f42c1dfcc0f6c3a5f06c83a41c" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this sequence</source>
          <target state="translated">이 순서에서 버퍼 히트 수</target>
        </trans-unit>
        <trans-unit id="1b92c223ff9c814c48eef462cd5d9e3733ab3a60" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table</source>
          <target state="translated">이 테이블의 버퍼 히트 수</target>
        </trans-unit>
        <trans-unit id="fb5ce149dfa5df345dadf32e3e7609e73a91ab4d" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table's TOAST table (if any)</source>
          <target state="translated">이 테이블의 TOAST 테이블에서 버퍼 히트 수 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="23b7daeca394ace2c29173c2e4db7f60e4ffa150" translate="yes" xml:space="preserve">
          <source>Number of buffer hits in this table's TOAST table indexes (if any)</source>
          <target state="translated">이 테이블의 TOAST 테이블 인덱스에서 버퍼 히트 수 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="820cb42f301c46e1dfd210dd8b99d341db358b4e" translate="yes" xml:space="preserve">
          <source>Number of buffers allocated</source>
          <target state="translated">할당 된 버퍼 수</target>
        </trans-unit>
        <trans-unit id="9d5ff89dcfa3fb4035bf4d286f1b89c75201025e" translate="yes" xml:space="preserve">
          <source>Number of buffers written by the background writer</source>
          <target state="translated">백그라운드 작성자가 쓴 버퍼 수</target>
        </trans-unit>
        <trans-unit id="0754f03bfbfe66ccdcb625fa7e3f44aa2c2a10bf" translate="yes" xml:space="preserve">
          <source>Number of buffers written directly by a backend</source>
          <target state="translated">백엔드가 직접 쓴 버퍼 수</target>
        </trans-unit>
        <trans-unit id="5c0d5f7ac01275f2192348fde149f7bc358fa9b2" translate="yes" xml:space="preserve">
          <source>Number of buffers written during checkpoints</source>
          <target state="translated">체크 포인트 동안 기록 된 버퍼 수</target>
        </trans-unit>
        <trans-unit id="07fff57f12d731d3ce6021e11cbee81eeb3c2283" translate="yes" xml:space="preserve">
          <source>Number of bytes in binary string</source>
          <target state="translated">이진 문자열의 바이트 수</target>
        </trans-unit>
        <trans-unit id="776e4abf0d400377907ab4118caf858bc018038c" translate="yes" xml:space="preserve">
          <source>Number of bytes in string</source>
          <target state="translated">문자열의 바이트 수</target>
        </trans-unit>
        <trans-unit id="0c72d2a102dbeffb7f10cf64774275780bc212cb" translate="yes" xml:space="preserve">
          <source>Number of bytes used to store a particular value (possibly compressed)</source>
          <target state="translated">특정 값을 저장하는 데 사용 된 바이트 수 (압축 가능)</target>
        </trans-unit>
        <trans-unit id="c08b0fa84d37e1078db655b5ae7decd119da648e" translate="yes" xml:space="preserve">
          <source>Number of characters in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 의 문자 수&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd2d8b2ef7ef37c5c432bb5b54f4a96fe58d0820" translate="yes" xml:space="preserve">
          <source>Number of characters in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; in the given &lt;em&gt;&lt;code&gt;encoding&lt;/code&gt;&lt;/em&gt;. The &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; must be valid in this encoding.</source>
          <target state="translated">주어진 &lt;em&gt; &lt;code&gt;encoding&lt;/code&gt; &lt;/em&gt; 에서 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 의 문자 수입니다 . &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 이 인코딩에서 유효해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21fa6ae67d156ef97e3bcf08c970e730cf5312e3" translate="yes" xml:space="preserve">
          <source>Number of characters in string</source>
          <target state="translated">문자열의 문자 수</target>
        </trans-unit>
        <trans-unit id="757246d7eeb8dba1a7138e1dc8e8018c67750493" translate="yes" xml:space="preserve">
          <source>Number of child tables scanned. This counter only advances when the phase is &lt;code&gt;acquiring inherited sample rows&lt;/code&gt;.</source>
          <target state="translated">스캔 된 하위 테이블 수입니다. 이 카운터는 단계가 &lt;code&gt;acquiring inherited sample rows&lt;/code&gt; 할 때만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8bd1fcff19995e8c8816753d9ab90a523509512c" translate="yes" xml:space="preserve">
          <source>Number of child tables.</source>
          <target state="translated">자식 테이블 수.</target>
        </trans-unit>
        <trans-unit id="b6c03f4ded52583235611efb49840aea96640208" translate="yes" xml:space="preserve">
          <source>Number of clients simulated, that is, number of concurrent database sessions. Default is 1.</source>
          <target state="translated">시뮬레이션 된 클라이언트 수, 즉 동시 데이터베이스 세션 수 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="85c5091c823d8842dadc7ece08cd606b9ead02d8" translate="yes" xml:space="preserve">
          <source>Number of completed index vacuum cycles.</source>
          <target state="translated">완료된 인덱스 진공 사이클 수</target>
        </trans-unit>
        <trans-unit id="07c0251b99d852d386e6230c7bc68b422860b2c8" translate="yes" xml:space="preserve">
          <source>Number of data page checksum failures detected in this database (or on a shared object), or NULL if data checksums are not enabled.</source>
          <target state="translated">이 데이터베이스 (또는 공유 객체)에서 감지 된 데이터 페이지 체크섬 실패 수 또는 데이터 체크섬이 활성화되지 않은 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="fd10e6b6630a5e0b1a1e37d857ce93abbe92b80c" translate="yes" xml:space="preserve">
          <source>Number of dead tuples</source>
          <target state="translated">죽은 튜플 수</target>
        </trans-unit>
        <trans-unit id="afdac9c7f2737a1b2507732298381e07eead13a4" translate="yes" xml:space="preserve">
          <source>Number of dead tuples (exact)</source>
          <target state="translated">죽은 튜플 수 (정확한)</target>
        </trans-unit>
        <trans-unit id="02be773fcf618322b70d57bc8dd9f3bf3919a6ff" translate="yes" xml:space="preserve">
          <source>Number of dead tuples collected since the last index vacuum cycle.</source>
          <target state="translated">마지막 인덱스 진공 사이클 이후 수집 된 데드 튜플 수입니다.</target>
        </trans-unit>
        <trans-unit id="dfb451e3ffa3210bb1e566dd30fd90934219a10e" translate="yes" xml:space="preserve">
          <source>Number of dead tuples that we can store before needing to perform an index vacuum cycle, based on &lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-resource#GUC-MAINTENANCE-WORK-MEM&quot;&gt;maintenance_work_mem에&lt;/a&gt; 따라 인덱스 진공 사이클을 수행하기 전에 저장할 수있는 데드 튜플 수입니다 .</target>
        </trans-unit>
        <trans-unit id="c4921acfb7b89b906d587e207c982d99387b078d" translate="yes" xml:space="preserve">
          <source>Number of deadlocks detected in this database</source>
          <target state="translated">이 데이터베이스에서 감지 된 교착 상태 수</target>
        </trans-unit>
        <trans-unit id="7cb4a85ff41caf8fe6b956d1175a54bab38b2930" translate="yes" xml:space="preserve">
          <source>Number of deleted pages</source>
          <target state="translated">삭제 된 페이지 수</target>
        </trans-unit>
        <trans-unit id="c3223e4de0ae9c43ca827d1664c98d5d300c8a06" translate="yes" xml:space="preserve">
          <source>Number of dimensions, if the column is an array type; otherwise 0. (Presently, the number of dimensions of an array is not enforced, so any nonzero value effectively means &amp;ldquo;it's an array&amp;rdquo;.)</source>
          <target state="translated">열이 배열 유형 인 경우 차원 수입니다. 그렇지 않으면 0입니다. 현재 배열의 차원 수는 적용되지 않으므로 0이 아닌 값은 사실상 &quot;배열입니다&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2be05a9b990f09033b8618eab5d65ae1aecc4032" translate="yes" xml:space="preserve">
          <source>Number of direct (non-aggregated) arguments of an ordered-set or hypothetical-set aggregate, counting a variadic array as one argument. If equal to &lt;code&gt;pronargs&lt;/code&gt;, the aggregate must be variadic and the variadic array describes the aggregated arguments as well as the final direct arguments. Always zero for normal aggregates.</source>
          <target state="translated">순서 집합 또는 가정 집합 집합의 직접 (집계되지 않은) 인수의 수는 가변 배열을 하나의 인수로 계산합니다. &lt;code&gt;pronargs&lt;/code&gt; 와 동일한 경우 집계는 가변이어야하며, 가변 배열은 최종 인수와 집계 된 인수를 설명합니다. 정규 집계의 경우 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="7aaf798c193e9c02ed1872cdc3758501e3edd2e9" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read for this SLRU</source>
          <target state="translated">이 SLRU에 대해 읽은 디스크 블록 수</target>
        </trans-unit>
        <trans-unit id="32e023d3421063e999e37bd8a8607f9d3b37c25b" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from all indexes on this table</source>
          <target state="translated">이 테이블의 모든 인덱스에서 읽은 디스크 블록 수</target>
        </trans-unit>
        <trans-unit id="5d872dc4357e4133d7ccee125da5dd9ed6f1e23f" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this index</source>
          <target state="translated">이 인덱스에서 읽은 디스크 블록 수</target>
        </trans-unit>
        <trans-unit id="f152a31061ce6ad3788ac1d44859392030a5e387" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this sequence</source>
          <target state="translated">이 순서에서 읽은 디스크 블록 수</target>
        </trans-unit>
        <trans-unit id="5d8a5f136039b36181bc2310abac4c580db63dc6" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table</source>
          <target state="translated">이 테이블에서 읽은 디스크 블록 수</target>
        </trans-unit>
        <trans-unit id="0eec262fa83f105ce7c719197839961c454478bd" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table's TOAST table (if any)</source>
          <target state="translated">이 테이블의 TOAST 테이블에서 읽은 디스크 블록 수 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="c3595c16a4db90858d963b19c02306856a40fc17" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read from this table's TOAST table indexes (if any)</source>
          <target state="translated">이 테이블의 TOAST 테이블 인덱스에서 읽은 디스크 블록 수 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="afcfec9d8002c45f94146f16eeb8704ff31575b1" translate="yes" xml:space="preserve">
          <source>Number of disk blocks read in this database</source>
          <target state="translated">이 데이터베이스에서 읽은 디스크 블록 수</target>
        </trans-unit>
        <trans-unit id="900fa7cb003c1be6f273043153c16b1f15b30466" translate="yes" xml:space="preserve">
          <source>Number of disk blocks written for this SLRU</source>
          <target state="translated">이 SLRU에 대해 기록 된 디스크 블록 수</target>
        </trans-unit>
        <trans-unit id="da37950fc1304c1760a3162855b0cc7eba9abaaf" translate="yes" xml:space="preserve">
          <source>Number of empty pages</source>
          <target state="translated">빈 페이지 수</target>
        </trans-unit>
        <trans-unit id="1eef621006cc03444cdc3f17923c510b432b6ba9" translate="yes" xml:space="preserve">
          <source>Number of entries in semaphore map</source>
          <target state="translated">세마포어 맵의 항목 수</target>
        </trans-unit>
        <trans-unit id="477ceecd337608949a72430b5748c93213cf67af" translate="yes" xml:space="preserve">
          <source>Number of extended statistics computed. This counter only advances when the phase is &lt;code&gt;computing extended statistics&lt;/code&gt;.</source>
          <target state="translated">계산 된 확장 통계 수입니다. 이 카운터는 단계가 &lt;code&gt;computing extended statistics&lt;/code&gt; 때만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="50fbf334710b4f84f1b18744b65687758f7ff55b" translate="yes" xml:space="preserve">
          <source>Number of extended statistics.</source>
          <target state="translated">확장 된 통계 수입니다.</target>
        </trans-unit>
        <trans-unit id="8ad03f1cded443f2951e34811d9b174dcd53e9f1" translate="yes" xml:space="preserve">
          <source>Number of failed attempts for archiving WAL files</source>
          <target state="translated">WAL 파일 보관에 실패한 횟수</target>
        </trans-unit>
        <trans-unit id="83240d945e31782e131edbfaf89add567bc6e877" translate="yes" xml:space="preserve">
          <source>Number of flushes of dirty data for this SLRU</source>
          <target state="translated">이 SLRU에 대한 더티 데이터의 플러시 수</target>
        </trans-unit>
        <trans-unit id="909efe526c9ef59f71379f7b5459201d6e2057fb" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned.</source>
          <target state="translated">스캔 된 힙 블록 수입니다.</target>
        </trans-unit>
        <trans-unit id="db7d7d8e8c6ad921ea1f650987683cdca25be133" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned. Because the &lt;a href=&quot;storage-vm&quot;&gt;visibility map&lt;/a&gt; is used to optimize scans, some blocks will be skipped without inspection; skipped blocks are included in this total, so that this number will eventually become equal to &lt;code&gt;heap_blks_total&lt;/code&gt; when the vacuum is complete. This counter only advances when the phase is &lt;code&gt;scanning heap&lt;/code&gt;.</source>
          <target state="translated">스캔 된 힙 블록 수 &lt;a href=&quot;storage-vm&quot;&gt;가시성 맵&lt;/a&gt; 은 스캔을 최적화하는 데 사용 되므로 일부 블록은 검사없이 건너 뜁니다. 건너 뛴 블록이이 합계에 포함되므로 진공이 완료 될 때이 숫자가 결국 &lt;code&gt;heap_blks_total&lt;/code&gt; 과 같습니다 . 이 카운터는 단계가 &lt;code&gt;scanning heap&lt;/code&gt; 할 때만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8abfe62e8394a6c74c6d4a5a932d175e4675308e" translate="yes" xml:space="preserve">
          <source>Number of heap blocks scanned. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;.</source>
          <target state="translated">스캔 된 힙 블록 수 이 카운터는 단계가 &lt;code&gt;seq scanning heap&lt;/code&gt; 때만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3cc4495fb3d4a190394bf457f27a153df853feb" translate="yes" xml:space="preserve">
          <source>Number of heap blocks vacuumed. Unless the table has no indexes, this counter only advances when the phase is &lt;code&gt;vacuuming heap&lt;/code&gt;. Blocks that contain no dead tuples are skipped, so the counter may sometimes skip forward in large increments.</source>
          <target state="translated">청소 된 힙 블록 수 테이블에 인덱스가없는 경우이 카운터는 단계가 &lt;code&gt;vacuuming heap&lt;/code&gt; 때만 진행됩니다 . 데드 튜플이 포함되지 않은 블록은 건너 뛰므로 카운터가 때때로 크게 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7065ea221f976c9edbd673b5b220f7e3c796ada" translate="yes" xml:space="preserve">
          <source>Number of heap tuples scanned. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;, &lt;code&gt;index scanning heap&lt;/code&gt; or &lt;code&gt;writing new heap&lt;/code&gt;.</source>
          <target state="translated">스캔 한 힙 튜플 수 이 카운터는 단계가 &lt;code&gt;seq scanning heap&lt;/code&gt; , &lt;code&gt;index scanning heap&lt;/code&gt; 또는 &lt;code&gt;writing new heap&lt;/code&gt; 경우에만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="1608d82e7902ccc755c873e18179b75db06e972e" translate="yes" xml:space="preserve">
          <source>Number of heap tuples written. This counter only advances when the phase is &lt;code&gt;seq scanning heap&lt;/code&gt;, &lt;code&gt;index scanning heap&lt;/code&gt; or &lt;code&gt;writing new heap&lt;/code&gt;.</source>
          <target state="translated">쓴 힙 튜플 수 이 카운터는 단계가 &lt;code&gt;seq scanning heap&lt;/code&gt; , &lt;code&gt;index scanning heap&lt;/code&gt; 또는 &lt;code&gt;writing new heap&lt;/code&gt; 경우에만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8a4f5e567445d068c8e050292c1c88bc19074f5" translate="yes" xml:space="preserve">
          <source>Number of index entries returned by scans on this index</source>
          <target state="translated">이 색인에서 스캔이 리턴 한 색인 항목 수</target>
        </trans-unit>
        <trans-unit id="2e47feab593e8d7f11f91aca87244c1647d56eda" translate="yes" xml:space="preserve">
          <source>Number of index scans initiated on this index</source>
          <target state="translated">이 인덱스에서 시작된 인덱스 스캔 수</target>
        </trans-unit>
        <trans-unit id="9740aebc5f5b78757843f388b08b6acf15d45722" translate="yes" xml:space="preserve">
          <source>Number of index scans initiated on this table</source>
          <target state="translated">이 테이블에서 시작된 인덱스 스캔 수</target>
        </trans-unit>
        <trans-unit id="2512b3dbef65d5a2946445bd9f10f953be318af1" translate="yes" xml:space="preserve">
          <source>Number of indexes rebuilt. This counter only advances when the phase is &lt;code&gt;rebuilding index&lt;/code&gt;.</source>
          <target state="translated">재 구축 된 인덱스 수입니다. 이 카운터는 단계가 &lt;code&gt;rebuilding index&lt;/code&gt; 하는 경우에만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c472386046a97dee2b6524340bae3b671c82f90b" translate="yes" xml:space="preserve">
          <source>Number of input arguments</source>
          <target state="translated">입력 인수의 수</target>
        </trans-unit>
        <trans-unit id="2f8814269318ff6e97c5ce39779e7a57b9de7c2a" translate="yes" xml:space="preserve">
          <source>Number of leaf pages</source>
          <target state="translated">리프 페이지 수</target>
        </trans-unit>
        <trans-unit id="09d24d58ee5f9d720e6e82ed3d6f447d63a9f297" translate="yes" xml:space="preserve">
          <source>Number of live rows fetched by index scans</source>
          <target state="translated">인덱스 스캔으로 페치 된 라이브 행 수</target>
        </trans-unit>
        <trans-unit id="7f6337cf0b1025e25455e7f1eb27c447744854cc" translate="yes" xml:space="preserve">
          <source>Number of live rows fetched by sequential scans</source>
          <target state="translated">순차적 스캔으로 페치 된 라이브 행 수</target>
        </trans-unit>
        <trans-unit id="c7bb465c5d5812b8f1ac688b0973b4608d17fc34" translate="yes" xml:space="preserve">
          <source>Number of live rows in the table. This is only an estimate used by the planner. It is updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;.</source>
          <target state="translated">테이블의 라이브 행 수 이것은 플래너가 사용한 추정치 일뿐입니다. &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;ANALYZE&lt;/code&gt; 및 &lt;code&gt;CREATE INDEX&lt;/code&gt; 와 같은 몇 가지 DDL 명령 으로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="6384ca87c928ff5826fd519745a102a2e37dcfdf" translate="yes" xml:space="preserve">
          <source>Number of live table rows fetched by simple index scans using this index</source>
          <target state="translated">이 인덱스를 사용하여 간단한 인덱스 스캔으로 가져온 라이브 테이블 행 수</target>
        </trans-unit>
        <trans-unit id="dd029b3676675a63d87f153e3800676e7c7dd2a6" translate="yes" xml:space="preserve">
          <source>Number of live tuples</source>
          <target state="translated">라이브 튜플 수</target>
        </trans-unit>
        <trans-unit id="d58d2b3f2cd29b1e4cc2b40b834ed9770119552a" translate="yes" xml:space="preserve">
          <source>Number of live tuples (estimated)</source>
          <target state="translated">라이브 튜플 수 (예상)</target>
        </trans-unit>
        <trans-unit id="5571a3a39c2a5eeb8bba94092d426fefd43fd703" translate="yes" xml:space="preserve">
          <source>Number of lockers already waited for.</source>
          <target state="translated">이미 대기 한 사물함 수</target>
        </trans-unit>
        <trans-unit id="11736240ddbd910654d9f20076ce6396954df295" translate="yes" xml:space="preserve">
          <source>Number of overflow pages</source>
          <target state="translated">오버플로 페이지 수</target>
        </trans-unit>
        <trans-unit id="2ef8f42ee9f5e2c4b09ad099506a9000c698f3af" translate="yes" xml:space="preserve">
          <source>Number of pages in the pending list</source>
          <target state="translated">보류 목록의 페이지 수</target>
        </trans-unit>
        <trans-unit id="daa5300000bb09c7a79335a89c2593536d8853e6" translate="yes" xml:space="preserve">
          <source>Number of pages that are marked all-visible in the table's visibility map. This is only an estimate used by the planner. It is updated by &lt;code&gt;VACUUM&lt;/code&gt;, &lt;code&gt;ANALYZE&lt;/code&gt;, and a few DDL commands such as &lt;code&gt;CREATE INDEX&lt;/code&gt;.</source>
          <target state="translated">테이블의 가시성 맵에서 모두 표시 가능한 페이지 수입니다. 이것은 플래너가 사용한 추정치 일뿐입니다. &lt;code&gt;VACUUM&lt;/code&gt; , &lt;code&gt;ANALYZE&lt;/code&gt; 및 &lt;code&gt;CREATE INDEX&lt;/code&gt; 와 같은 몇 가지 DDL 명령 으로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3cf04020ae64faac82b051a0ef081a4ffd60a33" translate="yes" xml:space="preserve">
          <source>Number of points in path or polygon</source>
          <target state="translated">경로 또는 다각형의 포인트 수</target>
        </trans-unit>
        <trans-unit id="544446e4ab9a886e3d43e3c0ad1665073743283d" translate="yes" xml:space="preserve">
          <source>Number of queries canceled due to conflicts with recovery in this database. (Conflicts occur only on standby servers; see &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;&lt;code&gt;pg_stat_database_conflicts&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">이 데이터베이스에서 복구와의 충돌로 인해 취소 된 쿼리 수입니다. (충돌은 대기 서버에서만 발생합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt; &lt;code&gt;pg_stat_database_conflicts&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="59e27e77340db29b89a3fbca8921ff6b082deb57" translate="yes" xml:space="preserve">
          <source>Number of queries canceled due to conflicts with recovery in this database. (Conflicts occur only on standby servers; see &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; for details.)</source>
          <target state="translated">이 데이터베이스의 복구와의 충돌로 인해 취소 된 쿼리 수입니다. 충돌은 대기 서버에서만 발생합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#PG-STAT-DATABASE-CONFLICTS-VIEW&quot;&gt;pg_stat_database_conflicts&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="14b49512f9667544c12ae0c4b4cd966d96369baa" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to deadlocks</source>
          <target state="translated">교착 상태로 인해 취소 된이 데이터베이스의 쿼리 수</target>
        </trans-unit>
        <trans-unit id="2965fecffa2cf1a8144374cd40187c529bd62354" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to dropped tablespaces</source>
          <target state="translated">이 데이터베이스에서 테이블 스페이스 삭제로 인해 취소 된 쿼리 수</target>
        </trans-unit>
        <trans-unit id="285091906a09f767f888d2dff167e4dafef20892" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to lock timeouts</source>
          <target state="translated">이 데이터베이스에서 잠금 시간 종료로 인해 취소 된 쿼리 수</target>
        </trans-unit>
        <trans-unit id="7bd181d498f49b3250f7391fd0a21bf7f1dd7ba8" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to old snapshots</source>
          <target state="translated">이 데이터베이스에서 오래된 스냅 샷으로 인해 취소 된 쿼리 수</target>
        </trans-unit>
        <trans-unit id="a343fc19cbfe51192fb4c899e5aeef503d395f97" translate="yes" xml:space="preserve">
          <source>Number of queries in this database that have been canceled due to pinned buffers</source>
          <target state="translated">고정 된 버퍼로 인해이 데이터베이스에서 취소 된 쿼리 수</target>
        </trans-unit>
        <trans-unit id="0ac9bcd7ffe37a50ba3f5b534d815f116bf780f4" translate="yes" xml:space="preserve">
          <source>Number of requested checkpoints that have been performed</source>
          <target state="translated">수행 된 요청 된 체크 포인트 수</target>
        </trans-unit>
        <trans-unit id="ac10ddd98993ae90bf693c73dcdf8ce8ff50a428" translate="yes" xml:space="preserve">
          <source>Number of rows HOT updated (i.e., with no separate index update required)</source>
          <target state="translated">HOT 업데이트 된 행 수 (즉, 별도의 인덱스 업데이트가 필요하지 않음)</target>
        </trans-unit>
        <trans-unit id="d2766fede1a28c68b26ca72aae563b9c0e3b81e7" translate="yes" xml:space="preserve">
          <source>Number of rows deleted</source>
          <target state="translated">삭제 된 행 수</target>
        </trans-unit>
        <trans-unit id="f34b08643d44d2358187f3d93aedd65adc903d85" translate="yes" xml:space="preserve">
          <source>Number of rows deleted by queries in this database</source>
          <target state="translated">이 데이터베이스에서 쿼리에 의해 삭제 된 행 수</target>
        </trans-unit>
        <trans-unit id="a2b82f360651a017d5888c1a773debe321eb0eb6" translate="yes" xml:space="preserve">
          <source>Number of rows fetched by queries in this database</source>
          <target state="translated">이 데이터베이스에서 쿼리로 가져온 행 수</target>
        </trans-unit>
        <trans-unit id="f45586cda10d5aa205f934dede2f25a7f45e1dde" translate="yes" xml:space="preserve">
          <source>Number of rows inserted</source>
          <target state="translated">삽입 된 행 수</target>
        </trans-unit>
        <trans-unit id="6a09e7859bb80515b532f0be7e2f1d0e3e69ef9b" translate="yes" xml:space="preserve">
          <source>Number of rows inserted by queries in this database</source>
          <target state="translated">이 데이터베이스에서 쿼리에 의해 삽입 된 행 수</target>
        </trans-unit>
        <trans-unit id="df7903056ffeb2c4aeb95ecc376e010c64637c6c" translate="yes" xml:space="preserve">
          <source>Number of rows returned by queries in this database</source>
          <target state="translated">이 데이터베이스의 쿼리에서 반환 된 행 수</target>
        </trans-unit>
        <trans-unit id="323338c3c2a474e71a2da0eb4b11693b9c2f500b" translate="yes" xml:space="preserve">
          <source>Number of rows updated (includes HOT updated rows)</source>
          <target state="translated">업데이트 된 행 수 (HOT 업데이트 된 행 포함)</target>
        </trans-unit>
        <trans-unit id="454a23c41b48acf5b2ccd14833f1fbd50495e2fe" translate="yes" xml:space="preserve">
          <source>Number of rows updated by queries in this database</source>
          <target state="translated">이 데이터베이스에서 쿼리로 업데이트 된 행 수</target>
        </trans-unit>
        <trans-unit id="2ac84789e08f3d81095c6bdcfce3914d10c756d6" translate="yes" xml:space="preserve">
          <source>Number of scheduled checkpoints that have been performed</source>
          <target state="translated">수행 된 예약 된 검사 점 수</target>
        </trans-unit>
        <trans-unit id="70b6c2dc7031b941f16874427081ef44f2d0e18e" translate="yes" xml:space="preserve">
          <source>Number of sequential scans initiated on this table</source>
          <target state="translated">이 테이블에서 시작된 순차 스캔 수</target>
        </trans-unit>
        <trans-unit id="a406439f0d98d84ebcc73a534711b625f34ad9d2" translate="yes" xml:space="preserve">
          <source>Number of tablespaces streamed. This counter only advances when the phase is &lt;code&gt;streaming database files&lt;/code&gt;.</source>
          <target state="translated">스트리밍 된 테이블 스페이스 수입니다. 이 카운터는 단계가 &lt;code&gt;streaming database files&lt;/code&gt; 하는 경우에만 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="db1eaebd91f46f68739419b406f7116ca7278810" translate="yes" xml:space="preserve">
          <source>Number of temporary files created by queries in this database. All temporary files are counted, regardless of why the temporary file was created (e.g., sorting or hashing), and regardless of the &lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files&lt;/a&gt; setting.</source>
          <target state="translated">이 데이터베이스에서 쿼리로 작성된 임시 파일 수 임시 파일이 작성된 이유 (예 : 정렬 또는 해싱)와 &lt;a href=&quot;runtime-config-logging#GUC-LOG-TEMP-FILES&quot;&gt;log_temp_files&lt;/a&gt; 설정에 관계없이 모든 임시 파일이 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="321ef5914a0a09d168438f2273433fc677686e24" translate="yes" xml:space="preserve">
          <source>Number of the log line for each session or process, starting at 1</source>
          <target state="translated">1부터 시작하는 각 세션 또는 프로세스의 로그 라인 수</target>
        </trans-unit>
        <trans-unit id="63fe0ed940b40404d3e8a92d939916a5dc589c9e" translate="yes" xml:space="preserve">
          <source>Number of times a backend had to execute its own &lt;code&gt;fsync&lt;/code&gt; call (normally the background writer handles those even when the backend does its own write)</source>
          <target state="translated">백엔드가 자체 &lt;code&gt;fsync&lt;/code&gt; 호출 을 실행 해야하는 횟수 (일반적으로 백그라운드 작성기는 백엔드가 자체 쓰기를 수행하는 경우에도 처리합니다)</target>
        </trans-unit>
        <trans-unit id="68d8d91d15dbba072e77a826a2320fb4b78552e4" translate="yes" xml:space="preserve">
          <source>Number of times disk blocks were found already in the SLRU, so that a read was not necessary (this only includes hits in the SLRU, not the operating system's file system cache)</source>
          <target state="translated">SLRU에서 디스크 블록이 이미 발견되어 읽기가 필요하지 않은 횟수 (운영 체제의 파일 시스템 캐시가 아닌 SLRU의 적중 만 포함)</target>
        </trans-unit>
        <trans-unit id="a553947fcdc098d224243a39019d65fcd42472fd" translate="yes" xml:space="preserve">
          <source>Number of times disk blocks were found already in the buffer cache, so that a read was not necessary (this only includes hits in the PostgreSQL buffer cache, not the operating system's file system cache)</source>
          <target state="translated">디스크 캐시가 이미 버퍼 캐시에서 발견 된 횟수로 읽기가 필요하지 않음 (운영 체제의 파일 시스템 캐시가 아닌 PostgreSQL 버퍼 캐시의 적중 만 포함)</target>
        </trans-unit>
        <trans-unit id="d7202f6daa9d37d53dc5948cf3ce73b0f377e700" translate="yes" xml:space="preserve">
          <source>Number of times executed</source>
          <target state="translated">실행 횟수</target>
        </trans-unit>
        <trans-unit id="03d48edf24ffbd37a62d6a4ffcfb82831fa45c63" translate="yes" xml:space="preserve">
          <source>Number of times the background writer stopped a cleaning scan because it had written too many buffers</source>
          <target state="translated">백그라운드 작성기가 너무 많은 버퍼를 작성하여 클리닝 스캔을 중지 한 횟수</target>
        </trans-unit>
        <trans-unit id="4ed26fe5383a5798683e9283907335221973e727" translate="yes" xml:space="preserve">
          <source>Number of times the statement was executed</source>
          <target state="translated">명령문이 실행 된 횟수</target>
        </trans-unit>
        <trans-unit id="20347e7e3ba3b446a92ff9a3bd79c5b1d653f5c0" translate="yes" xml:space="preserve">
          <source>Number of times the statement was planned (if &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; is enabled, otherwise zero)</source>
          <target state="translated">문이 계획된 횟수 ( &lt;code&gt;pg_stat_statements.track_planning&lt;/code&gt; 이 활성화 된 경우, 그렇지 않으면 0)</target>
        </trans-unit>
        <trans-unit id="db4c1e8598791346cf7ab2d43ead7da4a1cb087e" translate="yes" xml:space="preserve">
          <source>Number of times this function has been called</source>
          <target state="translated">이 함수가 호출 된 횟수</target>
        </trans-unit>
        <trans-unit id="981adc683189320f78f847f75dfe9f19ed8a5df7" translate="yes" xml:space="preserve">
          <source>Number of times this table has been analyzed by the autovacuum daemon</source>
          <target state="translated">autovacuum 데몬이이 테이블을 분석 한 횟수</target>
        </trans-unit>
        <trans-unit id="b87ae2050cfd76f7faad9ed39e95e377b7ba3065" translate="yes" xml:space="preserve">
          <source>Number of times this table has been manually analyzed</source>
          <target state="translated">이 테이블을 수동으로 분석 한 횟수</target>
        </trans-unit>
        <trans-unit id="86f3157922ed18f5e1cb8cdea053f28b23ec91b9" translate="yes" xml:space="preserve">
          <source>Number of times this table has been manually vacuumed (not counting &lt;code&gt;VACUUM FULL&lt;/code&gt;)</source>
          <target state="translated">이 테이블을 수동으로 진공 청소 한 횟수 ( &lt;code&gt;VACUUM FULL&lt;/code&gt; 을 계산하지 않음 )</target>
        </trans-unit>
        <trans-unit id="7d451fa30c0c321954c3a675d2c5bb4c2d50a932" translate="yes" xml:space="preserve">
          <source>Number of times this table has been vacuumed by the autovacuum daemon</source>
          <target state="translated">autovacuum 데몬이이 테이블을 정리 한 횟수</target>
        </trans-unit>
        <trans-unit id="4c54cfa40fa8364c91aff563ca87ddd6edf318b8" translate="yes" xml:space="preserve">
          <source>Number of transactions each client runs. Default is 10.</source>
          <target state="translated">각 클라이언트가 실행하는 트랜잭션 수 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="3275a376403dc18fc868eeb773fd1acfe4f18aec" translate="yes" xml:space="preserve">
          <source>Number of transactions in this database that have been committed</source>
          <target state="translated">이 데이터베이스에서 커밋 된 트랜잭션 수</target>
        </trans-unit>
        <trans-unit id="5b3dba5ee04dc9d1479c1b216978bf3f1db9f6aa" translate="yes" xml:space="preserve">
          <source>Number of transactions in this database that have been rolled back</source>
          <target state="translated">이 데이터베이스에서 롤백 된 트랜잭션 수</target>
        </trans-unit>
        <trans-unit id="ec735d5660ce6c32dd80bd724ca186e1322664ff" translate="yes" xml:space="preserve">
          <source>Number of truncates for this SLRU</source>
          <target state="translated">이 SLRU에 대한 자르기 수</target>
        </trans-unit>
        <trans-unit id="249fa0ad004c753cb36af02875bc1dafebf2db43" translate="yes" xml:space="preserve">
          <source>Number of tuples already processed in the current phase.</source>
          <target state="translated">현재 단계에서 이미 처리 된 튜플 수</target>
        </trans-unit>
        <trans-unit id="e10a2168070471eb01214b024083f7afd7ad7f4a" translate="yes" xml:space="preserve">
          <source>Number of tuples in the pending list</source>
          <target state="translated">보류 목록의 튜플 수</target>
        </trans-unit>
        <trans-unit id="cf7d86c225385fe6e945a39e465f0448098943a9" translate="yes" xml:space="preserve">
          <source>Number of unused pages</source>
          <target state="translated">사용하지 않은 페이지 수</target>
        </trans-unit>
        <trans-unit id="64210a61d52a14f7a802ee5036f59bb4880be4c1" translate="yes" xml:space="preserve">
          <source>Number of user columns in the relation (system columns not counted). There must be this many corresponding entries in &lt;code&gt;pg_attribute&lt;/code&gt;. See also &lt;code&gt;pg_attribute.attnum&lt;/code&gt;.</source>
          <target state="translated">관계의 사용자 열 수 (시스템 열은 계산되지 않음) &lt;code&gt;pg_attribute&lt;/code&gt; 에 해당하는 많은 항목이 있어야합니다 . &lt;code&gt;pg_attribute.attnum&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5897414fda7aed8102e3f5d6f9e16ee579dd363" translate="yes" xml:space="preserve">
          <source>Number of worker threads within pgbench. Using more than one thread can be helpful on multi-CPU machines. Clients are distributed as evenly as possible among available threads. Default is 1.</source>
          <target state="translated">pgbench 내의 작업자 스레드 수 다중 CPU 시스템에서 둘 이상의 스레드를 사용하면 도움이 될 수 있습니다. 클라이언트는 사용 가능한 스레드간에 최대한 고르게 분배됩니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="cefa5441373f254fdc1cb9fdbc4d9c0c1aa44ee4" translate="yes" xml:space="preserve">
          <source>Numbers with 7 or fewer significant digits retain their original precision. That is, if your query returns 0.00, you will be sure that the trailing zeroes are not the artifacts of formatting: they reflect the precision of the original data. The number of leading zeroes does not affect precision: the value 0.0067 is considered to have just 2 significant digits.</source>
          <target state="translated">유효 숫자가 7 이하인 숫자는 원래 정밀도를 유지합니다. 즉, 쿼리에서 0.00을 반환하면 후행 0이 서식의 인공물이 아닌 것입니다. 원래 데이터의 정밀도를 반영합니다. 선행 0의 수는 정밀도에 영향을 미치지 않습니다. 값 0.0067은 유효 숫자가 2 자리 인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="58224773d7dc5786efbb9bfbfa152b78d5c3ced5" translate="yes" xml:space="preserve">
          <source>Numeric Types</source>
          <target state="translated">숫자 형</target>
        </trans-unit>
        <trans-unit id="f1b55ea9345add00dc53f8d39e821048683ac6ac" translate="yes" xml:space="preserve">
          <source>Numeric Types: bigint</source>
          <target state="translated">숫자 유형 : bigint</target>
        </trans-unit>
        <trans-unit id="34ca1938464846ffd7671c72fe6fcf56ce8ed626" translate="yes" xml:space="preserve">
          <source>Numeric Types: bigserial</source>
          <target state="translated">숫자 유형 : bigserial</target>
        </trans-unit>
        <trans-unit id="4f4c21c7dbf7d3b0ce15752213f48b0ca85c6be6" translate="yes" xml:space="preserve">
          <source>Numeric Types: decimal</source>
          <target state="translated">숫자 유형 : 10 진수</target>
        </trans-unit>
        <trans-unit id="5f39be2adc33677462c0440cd7f421e180a13185" translate="yes" xml:space="preserve">
          <source>Numeric Types: double precision</source>
          <target state="translated">숫자 유형 : 배정도</target>
        </trans-unit>
        <trans-unit id="7d13fe88ea7d98f3a10e5a107a6fb5f2b06420b9" translate="yes" xml:space="preserve">
          <source>Numeric Types: integer</source>
          <target state="translated">숫자 유형 : 정수</target>
        </trans-unit>
        <trans-unit id="589f0dce7263b0f4a4ffcc692a06b6cca5db39a7" translate="yes" xml:space="preserve">
          <source>Numeric Types: numeric</source>
          <target state="translated">숫자 유형 : 숫자</target>
        </trans-unit>
        <trans-unit id="d049c61cbf5f08cf4a2b6ad03914911c2436a250" translate="yes" xml:space="preserve">
          <source>Numeric Types: real</source>
          <target state="translated">숫자 유형 : 실수</target>
        </trans-unit>
        <trans-unit id="017b04d1c97e36f0333abaaf314c6a6c6bbedc30" translate="yes" xml:space="preserve">
          <source>Numeric Types: serial</source>
          <target state="translated">숫자 유형 : serial</target>
        </trans-unit>
        <trans-unit id="9e36bc851d04411f4bd3afa229897af484988fe2" translate="yes" xml:space="preserve">
          <source>Numeric Types: smallint</source>
          <target state="translated">숫자 유형 : smallint</target>
        </trans-unit>
        <trans-unit id="3fa9584c0cd0a43cf41d81cfcfb10456d729bae0" translate="yes" xml:space="preserve">
          <source>Numeric Types: smallserial</source>
          <target state="translated">숫자 유형 : smallserial</target>
        </trans-unit>
        <trans-unit id="a172b52198f27b4b4b6b86a0f1c9b17a17d9bf18" translate="yes" xml:space="preserve">
          <source>Numeric character-entry escapes specifying values outside the ASCII range (0&amp;ndash;127) have meanings dependent on the database encoding. When the encoding is UTF-8, escape values are equivalent to Unicode code points, for example &lt;code&gt;\u1234&lt;/code&gt; means the character &lt;code&gt;U+1234&lt;/code&gt;. For other multibyte encodings, character-entry escapes usually just specify the concatenation of the byte values for the character. If the escape value does not correspond to any legal character in the database encoding, no error will be raised, but it will never match any data.</source>
          <target state="translated">ASCII 범위 (0&amp;ndash;127) 밖의 값을 지정하는 숫자 문자 입력 이스케이프는 데이터베이스 인코딩에 따라 의미가 있습니다. 인코딩이 UTF-8 인 경우 이스케이프 값은 유니 코드 코드 포인트와 동일합니다. 예를 들어 &lt;code&gt;\u1234&lt;/code&gt; 는 문자 &lt;code&gt;U+1234&lt;/code&gt; 를 의미합니다 . 다른 멀티 바이트 인코딩의 경우 문자 입력 이스케이프는 일반적으로 문자에 대한 바이트 값의 연결을 지정합니다. 이스케이프 값이 데이터베이스 인코딩의 유효한 문자와 일치하지 않으면 오류가 발생하지 않지만 데이터와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6907254669bc308bcd96a76901734e20d0b431f6" translate="yes" xml:space="preserve">
          <source>Numeric character-entry escapes specifying values outside the ASCII range (0-127) have meanings dependent on the database encoding. When the encoding is UTF-8, escape values are equivalent to Unicode code points, for example &lt;code&gt;\u1234&lt;/code&gt; means the character &lt;code&gt;U+1234&lt;/code&gt;. For other multibyte encodings, character-entry escapes usually just specify the concatenation of the byte values for the character. If the escape value does not correspond to any legal character in the database encoding, no error will be raised, but it will never match any data.</source>
          <target state="translated">ASCII 범위 (0-127) 이외의 값을 지정하는 숫자 문자 입력 이스케이프는 데이터베이스 인코딩에 따라 의미가 있습니다. 인코딩이 UTF-8 인 경우 이스케이프 값은 유니 코드 코드 포인트와 같습니다. 예를 들어 &lt;code&gt;\u1234&lt;/code&gt; 는 문자 &lt;code&gt;U+1234&lt;/code&gt; 를 의미합니다 . 다른 멀티 바이트 인코딩의 경우 문자 입력 이스케이프는 일반적으로 문자의 바이트 값 연결을 지정합니다. 이스케이프 값이 데이터베이스 인코딩에서 유효한 문자와 일치하지 않으면 오류가 발생하지 않지만 데이터와 일치하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e2759a88d02cd4c49727936e3e39cfce1c8fe1b" translate="yes" xml:space="preserve">
          <source>Numeric constants are accepted in these general forms:</source>
          <target state="translated">숫자 상수는 다음과 같은 일반적인 형식으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="32c0946f98f3a53c7cc5e78bd6ba14716174ad6a" translate="yes" xml:space="preserve">
          <source>Numeric ordering, sorts sequences of digits by their numeric value, for example: &lt;code&gt;A-21&lt;/code&gt; &amp;lt; &lt;code&gt;A-123&lt;/code&gt; (also known as natural sort).</source>
          <target state="translated">숫자 순서는 숫자 값을 기준으로 일련의 숫자를 정렬합니다 (예 : &lt;code&gt;A-21&lt;/code&gt; &amp;lt; &lt;code&gt;A-123&lt;/code&gt; (자연 정렬이라고도 함)).</target>
        </trans-unit>
        <trans-unit id="8d7bc2659eda5afabdbd8dae30a1b10b69aab0fa" translate="yes" xml:space="preserve">
          <source>Numeric transaction identifier of the prepared transaction</source>
          <target state="translated">준비된 거래의 숫자 거래 식별자</target>
        </trans-unit>
        <trans-unit id="d74de684582cb87f5abe203c6987280191b1e915" translate="yes" xml:space="preserve">
          <source>Numeric types</source>
          <target state="translated">숫자 형</target>
        </trans-unit>
        <trans-unit id="bbed1ad8168ad945da348f70d8f35c3aaa2d08ae" translate="yes" xml:space="preserve">
          <source>Numeric types consist of two-, four-, and eight-byte integers, four- and eight-byte floating-point numbers, and selectable-precision decimals. &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;Table 8.2&lt;/a&gt; lists the available types.</source>
          <target state="translated">숫자 유형은 2, 4 및 8 바이트 정수, 4 및 8 바이트 부동 소수점 숫자 및 선택 가능한 정밀도 10 진수로 구성됩니다. 사용 가능한 유형이 &lt;a href=&quot;datatype-numeric#DATATYPE-NUMERIC-TABLE&quot;&gt;표 8.2에&lt;/a&gt; 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae34df1114cf867e5a5e67721782e6b4936cf60a" translate="yes" xml:space="preserve">
          <source>Numeric values are physically stored without any extra leading or trailing zeroes. Thus, the declared precision and scale of a column are maximums, not fixed allocations. (In this sense the &lt;code&gt;numeric&lt;/code&gt; type is more akin to &lt;code&gt;varchar(n)&lt;/code&gt; than to &lt;code&gt;char(n)&lt;/code&gt;.) The actual storage requirement is two bytes for each group of four decimal digits, plus three to eight bytes overhead.</source>
          <target state="translated">숫자 값은 추가 선행 또는 후행 0없이 물리적으로 저장됩니다. 따라서 열의 선언 된 정밀도 및 스케일은 고정 할당이 아니라 최대 값입니다. (이러한 관점에서, &lt;code&gt;numeric&lt;/code&gt; 타입에 더 가깝다 &lt;code&gt;varchar(n)&lt;/code&gt; 보다 &lt;code&gt;char(n)&lt;/code&gt; ). 실제 스토리지 요건 오버 네 십진수의 각 그룹에 대해 2 바이트 플러스 3-8 바이트이다.</target>
        </trans-unit>
        <trans-unit id="1cd1073fd79a8443ea8d6973895d5ee6ffe7cdf9" translate="yes" xml:space="preserve">
          <source>Numerical statistics of the appropriate kind for the &lt;code&gt;N&lt;/code&gt;th &amp;ldquo;slot&amp;rdquo;, or null if the slot kind does not involve numerical values</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 번째 &quot;슬롯&quot;에 적절한 종류의 숫자 통계 또는 슬롯 종류에 숫자 값이 포함되지 않은 경우 null</target>
        </trans-unit>
        <trans-unit id="fb91068c51189c866a8e510b38ba4dfebf5d32bc" translate="yes" xml:space="preserve">
          <source>ODBC</source>
          <target state="translated">ODBC</target>
        </trans-unit>
        <trans-unit id="4d314276ba61e4f3bc6a1b4a234e301a4e785ad9" translate="yes" xml:space="preserve">
          <source>OID</source>
          <target state="translated">OID</target>
        </trans-unit>
        <trans-unit id="725ff3ec092f4de8d511006eba9dfe844003c6f9" translate="yes" xml:space="preserve">
          <source>OID of a database</source>
          <target state="translated">데이터베이스의 OID</target>
        </trans-unit>
        <trans-unit id="f8c02df27c83758b75b440e8700bcc0f8b46a3f0" translate="yes" xml:space="preserve">
          <source>OID of a function</source>
          <target state="translated">함수의 OID</target>
        </trans-unit>
        <trans-unit id="faffc6a7f80d0822867cb82f8a02546997b88ef9" translate="yes" xml:space="preserve">
          <source>OID of a handler function that is responsible for supplying information about the access method</source>
          <target state="translated">액세스 방법에 대한 정보를 제공하는 처리기 함수의 OID</target>
        </trans-unit>
        <trans-unit id="5a4a96aa8d7efd7ac397558d10f843a235a92c88" translate="yes" xml:space="preserve">
          <source>OID of a sequence</source>
          <target state="translated">시퀀스의 OID</target>
        </trans-unit>
        <trans-unit id="996a8d685aef72e0b42d14422b03fa62a0285fd1" translate="yes" xml:space="preserve">
          <source>OID of a table</source>
          <target state="translated">테이블의 OID</target>
        </trans-unit>
        <trans-unit id="90f9df50ed473af29d597298ed5c8caeb84243d2" translate="yes" xml:space="preserve">
          <source>OID of database in which the statement was executed</source>
          <target state="translated">명령문이 실행 된 데이터베이스의 OID</target>
        </trans-unit>
        <trans-unit id="080d0fef7c4d986b1330554caa1d1e593f3124b0" translate="yes" xml:space="preserve">
          <source>OID of session's temporary schema, or 0 if none</source>
          <target state="translated">세션의 임시 스키마의 OID.없는 경우 0</target>
        </trans-unit>
        <trans-unit id="346ed8429eddd05e15627f07718d2d6a7f44eddd" translate="yes" xml:space="preserve">
          <source>OID of the &lt;code&gt;pg_class&lt;/code&gt; entry for this foreign table</source>
          <target state="translated">이 외부 테이블에 대한 &lt;code&gt;pg_class&lt;/code&gt; 항목의 OID</target>
        </trans-unit>
        <trans-unit id="3bcb74cd3805e6c2a6b21b10048ed96a348a5d71" translate="yes" xml:space="preserve">
          <source>OID of the TOAST table associated with this table, 0 if none. The TOAST table stores large attributes &amp;ldquo;out of line&amp;rdquo; in a secondary table.</source>
          <target state="translated">이 테이블과 연관된 TOAST 테이블의 OID.없는 경우 0 TOAST 테이블은 큰 속성 &quot;out of line&quot;을 보조 테이블에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="0087f0d6da4c99ba53f0596b33bf633085b24106" translate="yes" xml:space="preserve">
          <source>OID of the child table currently being scanned. This field is only valid when the phase is &lt;code&gt;acquiring inherited sample rows&lt;/code&gt;.</source>
          <target state="translated">현재 스캔중인 하위 테이블의 OID입니다. 이 필드는 단계가 &lt;code&gt;acquiring inherited sample rows&lt;/code&gt; 경우에만 유효 합니다 .</target>
        </trans-unit>
        <trans-unit id="5cb554635bbb124706c2580bd976000c272a3041" translate="yes" xml:space="preserve">
          <source>OID of the collation used for range comparisons, or 0 if none</source>
          <target state="translated">범위 비교에 사용 된 데이터 정렬의 OID 또는없는 경우 0</target>
        </trans-unit>
        <trans-unit id="1af1844b19464c23fc7fd9fcae9a412bfe3133ff" translate="yes" xml:space="preserve">
          <source>OID of the data type this transform is for</source>
          <target state="translated">이 변환의 데이터 유형에 대한 OID</target>
        </trans-unit>
        <trans-unit id="7be8af1517de8b566e91490637cc744e1bfc4538" translate="yes" xml:space="preserve">
          <source>OID of the database in which the lock target exists, or zero if the target is a shared object, or null if the target is a transaction ID</source>
          <target state="translated">잠금 대상이 존재하는 데이터베이스의 OID. 대상이 공유 오브젝트 인 경우 0 또는 대상이 트랜잭션 ID 인 경우 널</target>
        </trans-unit>
        <trans-unit id="d6eff8fed00f101585817bdde7217d409d0452cb" translate="yes" xml:space="preserve">
          <source>OID of the database this backend is connected to</source>
          <target state="translated">이 백엔드가 연결된 데이터베이스의 OID</target>
        </trans-unit>
        <trans-unit id="c3f83d507478524c5f0343641eaf036c1dd5f6f4" translate="yes" xml:space="preserve">
          <source>OID of the database to which this backend is connected.</source>
          <target state="translated">이 백엔드가 연결된 데이터베이스의 OID</target>
        </trans-unit>
        <trans-unit id="99d858de93dcac0523dbaa414705f17f8ce20935" translate="yes" xml:space="preserve">
          <source>OID of the database which the subscription resides in</source>
          <target state="translated">구독이있는 데이터베이스의 OID</target>
        </trans-unit>
        <trans-unit id="3c094c24ab67863a7765120475d6a2f2e2e272ea" translate="yes" xml:space="preserve">
          <source>OID of the element type (subtype) of this range type</source>
          <target state="translated">이 범위 유형의 요소 유형 (하위 유형)의 OID</target>
        </trans-unit>
        <trans-unit id="91964bc019a248521428ce08554d6e0d30140b28" translate="yes" xml:space="preserve">
          <source>OID of the foreign server for this foreign table</source>
          <target state="translated">이 외부 테이블에 대한 외부 서버의 OID</target>
        </trans-unit>
        <trans-unit id="73727764a13452c62b9dc37a3cc28ff75c10a8fb" translate="yes" xml:space="preserve">
          <source>OID of the foreign-data wrapper of this foreign server</source>
          <target state="translated">이 외부 서버의 외부 데이터 랩퍼의 OID</target>
        </trans-unit>
        <trans-unit id="bef000be97274c50b609e7040996c7f3a74549e7" translate="yes" xml:space="preserve">
          <source>OID of the function</source>
          <target state="translated">기능의 OID</target>
        </trans-unit>
        <trans-unit id="d936ce13d6a2191f0fb1ebd586182169926914bd" translate="yes" xml:space="preserve">
          <source>OID of the function to convert a range value into canonical form, or 0 if none</source>
          <target state="translated">범위 값을 정식 형식으로 변환하는 함수의 OID 또는없는 경우 0</target>
        </trans-unit>
        <trans-unit id="3de3255d0dade1eabbba67bef7bb7de2117ad3f9" translate="yes" xml:space="preserve">
          <source>OID of the function to return the difference between two element values as &lt;code&gt;double precision&lt;/code&gt;, or 0 if none</source>
          <target state="translated">두 요소 값의 차이를 &lt;code&gt;double precision&lt;/code&gt; 로 반환하는 함수의 OID 또는없는 경우 0</target>
        </trans-unit>
        <trans-unit id="04695e3476f4985e5e3d88253bca9d829918ada5" translate="yes" xml:space="preserve">
          <source>OID of the index being created or reindexed. During a non-concurrent &lt;code&gt;CREATE INDEX&lt;/code&gt;, this is 0.</source>
          <target state="translated">작성 또는 재 색인되는 색인의 OID 비 동시 &lt;code&gt;CREATE INDEX&lt;/code&gt; 동안이 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="36fd3faf4abf64d7b63021e96a36b08b96b00ad5" translate="yes" xml:space="preserve">
          <source>OID of the language this transform is for</source>
          <target state="translated">이 변환을위한 언어의 OID</target>
        </trans-unit>
        <trans-unit id="7e460991382ec78ace08e8b50c8809bb0c2a37f4" translate="yes" xml:space="preserve">
          <source>OID of the large object to be altered</source>
          <target state="translated">변경 될 큰 객체의 OID</target>
        </trans-unit>
        <trans-unit id="1d1d811b028d1d43309ac3a6a9795a5474876c40" translate="yes" xml:space="preserve">
          <source>OID of the local role being mapped, 0 if the user mapping is public</source>
          <target state="translated">맵핑되는 로컬 역할의 OID, 사용자 맵핑이 공용 인 경우 0</target>
        </trans-unit>
        <trans-unit id="f6befa197b5efdceb1d6e3e97ba6a7089030d83b" translate="yes" xml:space="preserve">
          <source>OID of the lock target within its system catalog, or null if the target is not a general database object</source>
          <target state="translated">시스템 카탈로그 내에서 잠금 대상의 OID 또는 대상이 일반 데이터베이스 오브젝트가 아닌 경우 널</target>
        </trans-unit>
        <trans-unit id="547ca9a3f91e95b8778cc1a87f9fe368954503d2" translate="yes" xml:space="preserve">
          <source>OID of the operator</source>
          <target state="translated">운영자의 OID</target>
        </trans-unit>
        <trans-unit id="57147e7dec8c6552f43472e577611d734b852d01" translate="yes" xml:space="preserve">
          <source>OID of the parser's headline function</source>
          <target state="translated">파서 헤드 라인 함수의 OID</target>
        </trans-unit>
        <trans-unit id="e75052ec080efa2cb48c4eee33c12247804336c7" translate="yes" xml:space="preserve">
          <source>OID of the parser's lextype function</source>
          <target state="translated">파서의 lextype 함수의 OID</target>
        </trans-unit>
        <trans-unit id="070d9465021b789c1852df9d85e1dab51aa12f2b" translate="yes" xml:space="preserve">
          <source>OID of the parser's next-token function</source>
          <target state="translated">파서의 다음 토큰 기능의 OID</target>
        </trans-unit>
        <trans-unit id="28ddd7cda8c6ae7b671231bc8b5771d3c20a5115" translate="yes" xml:space="preserve">
          <source>OID of the parser's shutdown function</source>
          <target state="translated">파서 종료 기능의 OID</target>
        </trans-unit>
        <trans-unit id="3441d838ae5086ffa5ad3452eab23ff3831aa095" translate="yes" xml:space="preserve">
          <source>OID of the parser's startup function</source>
          <target state="translated">파서 시작 기능의 OID</target>
        </trans-unit>
        <trans-unit id="cf7d55d689e6813249b16676499a1c0b2b7376b1" translate="yes" xml:space="preserve">
          <source>OID of the range type</source>
          <target state="translated">범위 유형의 OID</target>
        </trans-unit>
        <trans-unit id="00bba16646f2a65970a0b9e99737c24fb8db4ee2" translate="yes" xml:space="preserve">
          <source>OID of the relation targeted by the lock, or null if the target is not a relation or part of a relation</source>
          <target state="translated">잠금이 대상으로하는 관계의 OID 또는 대상이 관계 또는 관계의 일부가 아닌 경우 null</target>
        </trans-unit>
        <trans-unit id="10ccac12f9b1c1d8ff7d1e3fe492cab3d5e3c0cd" translate="yes" xml:space="preserve">
          <source>OID of the relation that the worker is synchronizing; null for the main apply worker</source>
          <target state="translated">작업자가 동기화하고있는 관계의 OID; 기본 적용 작업자의 경우 null</target>
        </trans-unit>
        <trans-unit id="64dbbea0aaf12efa0d4ebae8170596e36c349efc" translate="yes" xml:space="preserve">
          <source>OID of the source data type</source>
          <target state="translated">소스 데이터 유형의 OID</target>
        </trans-unit>
        <trans-unit id="4ab6e82967b76a601d959c42c032a9613f62366e" translate="yes" xml:space="preserve">
          <source>OID of the subscription</source>
          <target state="translated">구독의 OID</target>
        </trans-unit>
        <trans-unit id="529393343c510cc7f43e20828d0d63fb68383a2c" translate="yes" xml:space="preserve">
          <source>OID of the subtype's operator class used for range comparisons</source>
          <target state="translated">범위 비교에 사용되는 하위 유형의 연산자 클래스의 OID</target>
        </trans-unit>
        <trans-unit id="633257d0b0d38e2fef790525052ae12fd0314ed1" translate="yes" xml:space="preserve">
          <source>OID of the system catalog containing the lock target, or null if the target is not a general database object</source>
          <target state="translated">잠금 대상을 포함하는 시스템 카탈로그의 OID 또는 대상이 일반 데이터베이스 오브젝트가 아닌 경우 널</target>
        </trans-unit>
        <trans-unit id="6ba91c2dce09309f79136d3e66a8e5ae37f1fe91" translate="yes" xml:space="preserve">
          <source>OID of the table being analyzed.</source>
          <target state="translated">분석중인 테이블의 OID입니다.</target>
        </trans-unit>
        <trans-unit id="6da84f1d83f2a7ebd175fcdf78bf746dff039dba" translate="yes" xml:space="preserve">
          <source>OID of the table being clustered.</source>
          <target state="translated">클러스터중인 테이블의 OID</target>
        </trans-unit>
        <trans-unit id="0e4debb724827a1126e4f0985aac0c3bd73e2728" translate="yes" xml:space="preserve">
          <source>OID of the table being vacuumed.</source>
          <target state="translated">진공 청소중인 테이블의 OID</target>
        </trans-unit>
        <trans-unit id="e9109406be796a3753b7f074b353cc534267a046" translate="yes" xml:space="preserve">
          <source>OID of the table for this index</source>
          <target state="translated">이 인덱스에 대한 테이블의 OID</target>
        </trans-unit>
        <trans-unit id="50e7e1691ddba39a8ac80c840ffce2b6dd3a48c8" translate="yes" xml:space="preserve">
          <source>OID of the table on which the index is being created.</source>
          <target state="translated">인덱스가 작성되는 테이블의 OID</target>
        </trans-unit>
        <trans-unit id="090219832be11fe1619b95babe8e9c1e5e92c437" translate="yes" xml:space="preserve">
          <source>OID of the target data type</source>
          <target state="translated">대상 데이터 유형의 OID</target>
        </trans-unit>
        <trans-unit id="ac66a3e3aabe35420bf2d2c1e94ee59c9c06a065" translate="yes" xml:space="preserve">
          <source>OID of the template's initialization function</source>
          <target state="translated">템플릿 초기화 기능의 OID</target>
        </trans-unit>
        <trans-unit id="50c0da2d8b347f30166307b39f81117e5e35c3ea" translate="yes" xml:space="preserve">
          <source>OID of the template's lexize function</source>
          <target state="translated">템플릿의 lexize 함수의 OID</target>
        </trans-unit>
        <trans-unit id="a8374b131925b37be69ac971d0b27d489ca95329" translate="yes" xml:space="preserve">
          <source>OID of the user logged into this WAL sender process</source>
          <target state="translated">이 WAL 발신자 프로세스에 로그인 한 사용자의 OID</target>
        </trans-unit>
        <trans-unit id="5fe5cd795b2ac38b10709cbfaf75428859cfc40c" translate="yes" xml:space="preserve">
          <source>OID of the user logged into this backend</source>
          <target state="translated">이 백엔드에 로그인 한 사용자의 OID</target>
        </trans-unit>
        <trans-unit id="ac6509d860cce791cfecdfeff54c3c371229705b" translate="yes" xml:space="preserve">
          <source>OID of the user mapping</source>
          <target state="translated">사용자 매핑의 OID</target>
        </trans-unit>
        <trans-unit id="5cb18008fb6941eebe8d741c085bfe9b7fb69a3f" translate="yes" xml:space="preserve">
          <source>OID of this database, or 0 for objects belonging to a shared relation</source>
          <target state="translated">이 데이터베이스의 OID 또는 공유 관계에 속하는 오브젝트의 경우 0</target>
        </trans-unit>
        <trans-unit id="a7af712c7c37a60b529576ed90f30e8cf2d7a00c" translate="yes" xml:space="preserve">
          <source>OID of this index</source>
          <target state="translated">이 인덱스의 OID</target>
        </trans-unit>
        <trans-unit id="d3dd8c985a0eabab21975bbe483a04f61be0cad9" translate="yes" xml:space="preserve">
          <source>OID of user who executed the statement</source>
          <target state="translated">명령문을 실행 한 사용자의 OID</target>
        </trans-unit>
        <trans-unit id="387852e7a1481866714e0a22f56d3c6e25b3ae5f" translate="yes" xml:space="preserve">
          <source>OIDs assigned during normal database operation are constrained to be 16384 or higher. This ensures that the range 10000&amp;mdash;16383 is free for OIDs assigned automatically by &lt;code&gt;genbki.pl&lt;/code&gt; or during bootstrap. These automatically-assigned OIDs are not considered stable, and may change from one installation to another.</source>
          <target state="translated">일반 데이터베이스 작업 중에 할당 된 OID는 16384 이상으로 제한됩니다. 이 보장하는 범위 10000-16383에 의해 자동으로 할당 OID를위한 무료입니다 &lt;code&gt;genbki.pl&lt;/code&gt; 또는 부트 스트랩 중. 이러한 자동 할당 OID는 안정적인 것으로 간주되지 않으며 설치마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a08513f8d6a0456d0e2e3f8053e17f798ea2afa0" translate="yes" xml:space="preserve">
          <source>OLAP</source>
          <target state="translated">OLAP</target>
        </trans-unit>
        <trans-unit id="751cc96735bf8b84aef2fec3e06efb1b1a5b1ccc" translate="yes" xml:space="preserve">
          <source>OLTP</source>
          <target state="translated">OLTP</target>
        </trans-unit>
        <trans-unit id="25e9c7c3a98b268d5dfb9854a9b3f093ee86933f" translate="yes" xml:space="preserve">
          <source>OR &lt;code&gt;tsquery&lt;/code&gt;s together</source>
          <target state="translated">또는 함께 &lt;code&gt;tsquery&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="204bd21a2ea07120bf9aa428b287753e7d9939bc" translate="yes" xml:space="preserve">
          <source>ORDBMS</source>
          <target state="translated">ORDBMS</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">주문</target>
        </trans-unit>
        <trans-unit id="8cd49ef586968599e62519504427958da4d48a39" translate="yes" xml:space="preserve">
          <source>ORs two &lt;code&gt;tsquery&lt;/code&gt;s together, producing a query that matches documents that match either input query.</source>
          <target state="translated">두 개의 &lt;code&gt;tsquery&lt;/code&gt; 를 OR로 연결하여 두 입력 쿼리 중 하나와 일치하는 문서와 일치하는 쿼리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="b77e714dbd01a80315e52e6a9d94c65e9f359c98" translate="yes" xml:space="preserve">
          <source>Object Identifier</source>
          <target state="translated">객체 식별자</target>
        </trans-unit>
        <trans-unit id="2ebed2ba0d6eed2f88e2d3187c0748eee35c9c48" translate="yes" xml:space="preserve">
          <source>Object Identifier Types</source>
          <target state="translated">객체 식별자 유형</target>
        </trans-unit>
        <trans-unit id="690a335354f7107071acc3fa67c016dc6bc384da" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: oid</source>
          <target state="translated">객체 식별자 유형 : OID</target>
        </trans-unit>
        <trans-unit id="0075fd06325f676dff687ca83f8e432afb05cd0a" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regclass</source>
          <target state="translated">객체 식별자 유형 : regclass</target>
        </trans-unit>
        <trans-unit id="47d07e7ec3c2bb281acfd4b09b95c7bd692a6146" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regcollation</source>
          <target state="translated">개체 식별자 유형 : regcollation</target>
        </trans-unit>
        <trans-unit id="9ff60426c655614fda7aef019d73fd45fb97d826" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regconfig</source>
          <target state="translated">객체 식별자 유형 : regconfig</target>
        </trans-unit>
        <trans-unit id="dfaba8ba7726385dd9aaa48834af168d2f9ceedf" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regdictionary</source>
          <target state="translated">객체 식별자 유형 : 등록</target>
        </trans-unit>
        <trans-unit id="cc8674af1caee1212cf1ad2d15d842446e9a98aa" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regnamespace</source>
          <target state="translated">객체 식별자 유형 : regnamespace</target>
        </trans-unit>
        <trans-unit id="c2b56a3df38b329696180cd377e1ed88251bb409" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regoper</source>
          <target state="translated">객체 식별자 유형 : regoper</target>
        </trans-unit>
        <trans-unit id="30c72913cd86047f07f98633a45661ed568c2533" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regoperator</source>
          <target state="translated">객체 식별자 유형 : regoperator</target>
        </trans-unit>
        <trans-unit id="a48a31a0bb9251c420e48d22aa7c1d09ca5723bd" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regproc</source>
          <target state="translated">객체 식별자 유형 : regproc</target>
        </trans-unit>
        <trans-unit id="67cdc0df1aaf8b31658af7a6a45b330191b5746d" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regprocedure</source>
          <target state="translated">객체 식별자 유형 : regprocedure</target>
        </trans-unit>
        <trans-unit id="6c6385e5aae8c21dd4c725971f7b3936a95ef63b" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regrole</source>
          <target state="translated">객체 식별자 유형 : regrole</target>
        </trans-unit>
        <trans-unit id="f7695a1c32f9f4d88fc2778bef31cc0d65aad8a7" translate="yes" xml:space="preserve">
          <source>Object Identifier Types: regtype</source>
          <target state="translated">객체 식별자 유형 : regtype</target>
        </trans-unit>
        <trans-unit id="cadc94239cb6d9721bc9abae7ab74549ddda3fbb" translate="yes" xml:space="preserve">
          <source>Object Type</source>
          <target state="translated">객체 유형</target>
        </trans-unit>
        <trans-unit id="440eaacb05716029aec3d29f1c4c8f8f3cf112cd" translate="yes" xml:space="preserve">
          <source>Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. Type &lt;code&gt;oid&lt;/code&gt; represents an object identifier. There are also several alias types for &lt;code&gt;oid&lt;/code&gt; named &lt;code&gt;regsomething&lt;/code&gt;. &lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;Table 8.26&lt;/a&gt; shows an overview.</source>
          <target state="translated">객체 식별자 (OID)는 PostgreSQL에서 내부적으로 다양한 시스템 테이블의 기본 키로 사용됩니다. 유형 &lt;code&gt;oid&lt;/code&gt; 는 객체 식별자를 나타냅니다. &lt;code&gt;regsomething&lt;/code&gt; 이라는 &lt;code&gt;oid&lt;/code&gt; 에 대한 몇 가지 별칭 유형도 있습니다 . &lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;표 8.26&lt;/a&gt; 은 개요를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="486ece6dd89f3c4ea297334b48675b716e4268bd" translate="yes" xml:space="preserve">
          <source>Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. Type &lt;code&gt;oid&lt;/code&gt; represents an object identifier. There are also several alias types for &lt;code&gt;oid&lt;/code&gt;: &lt;code&gt;regproc&lt;/code&gt;, &lt;code&gt;regprocedure&lt;/code&gt;, &lt;code&gt;regoper&lt;/code&gt;, &lt;code&gt;regoperator&lt;/code&gt;, &lt;code&gt;regclass&lt;/code&gt;, &lt;code&gt;regtype&lt;/code&gt;, &lt;code&gt;regrole&lt;/code&gt;, &lt;code&gt;regnamespace&lt;/code&gt;, &lt;code&gt;regconfig&lt;/code&gt;, and &lt;code&gt;regdictionary&lt;/code&gt;. &lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;Table 8.26&lt;/a&gt; shows an overview.</source>
          <target state="translated">객체 식별자 (OID)는 PostgreSQL에 의해 내부적으로 다양한 시스템 테이블의 기본 키로 사용됩니다. &lt;code&gt;oid&lt;/code&gt; 유형 은 객체 식별자를 나타냅니다. &lt;code&gt;oid&lt;/code&gt; 에 대한 별칭 유형도 있습니다 : &lt;code&gt;regproc&lt;/code&gt; , &lt;code&gt;regprocedure&lt;/code&gt; , &lt;code&gt;regoper&lt;/code&gt; , &lt;code&gt;regoperator&lt;/code&gt; , &lt;code&gt;regclass&lt;/code&gt; , &lt;code&gt;regtype&lt;/code&gt; , &lt;code&gt;regrole&lt;/code&gt; , &lt;code&gt;regnamespace&lt;/code&gt; , &lt;code&gt;regconfig&lt;/code&gt; 및 &lt;code&gt;regdictionary&lt;/code&gt; . &lt;a href=&quot;datatype-oid#DATATYPE-OID-TABLE&quot;&gt;표 8.26&lt;/a&gt; 은 개요를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e6ffe45f664bbe6f6262859df4e3695e1d12153a" translate="yes" xml:space="preserve">
          <source>Object-Relational Database Management System</source>
          <target state="translated">객체 관계형 데이터베이스 관리 시스템</target>
        </trans-unit>
        <trans-unit id="ec90b7e160c78de5740196cc2532f466404d90bc" translate="yes" xml:space="preserve">
          <source>Objects can have initial privileges either by having those privileges set when the system is initialized (by initdb) or when the object is created during a &lt;code&gt;CREATE EXTENSION&lt;/code&gt; and the extension script sets initial privileges using the &lt;code&gt;GRANT&lt;/code&gt; system. Note that the system will automatically handle recording of the privileges during the extension script and that extension authors need only use the &lt;code&gt;GRANT&lt;/code&gt; and &lt;code&gt;REVOKE&lt;/code&gt; statements in their script to have the privileges recorded. The &lt;code&gt;privtype&lt;/code&gt; column indicates if the initial privilege was set by initdb or during a &lt;code&gt;CREATE EXTENSION&lt;/code&gt; command.</source>
          <target state="translated">오브젝트는 시스템이 초기화 될 때 (initdb에 의해) 또는 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 중에 오브젝트가 작성 되고 확장 스크립트가 &lt;code&gt;GRANT&lt;/code&gt; 시스템을 사용하여 초기 권한을 설정할 때 해당 권한을 설정하여 초기 권한을 가질 수 있습니다 . 시스템은 확장 스크립트 중에 권한 기록을 자동으로 처리하며 확장 작성자 는 스크립트에서 &lt;code&gt;GRANT&lt;/code&gt; 및 &lt;code&gt;REVOKE&lt;/code&gt; 문만 사용 하여 권한을 기록해야합니다. &lt;code&gt;privtype&lt;/code&gt; 의 초기 특권은 initdb에 의해 또는시 설정된 경우 열을 나타냅니다 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="8d18be902bfa3d762f98290f3d1e8291c77198c6" translate="yes" xml:space="preserve">
          <source>Objects which have initial privileges set by initdb will have entries where &lt;code&gt;privtype&lt;/code&gt; is &lt;code&gt;'i'&lt;/code&gt;, while objects which have initial privileges set by &lt;code&gt;CREATE EXTENSION&lt;/code&gt; will have entries where &lt;code&gt;privtype&lt;/code&gt; is &lt;code&gt;'e'&lt;/code&gt;.</source>
          <target state="translated">initdb에 의해 초기 권한이 설정된 오브젝트는 &lt;code&gt;privtype&lt;/code&gt; 이 &lt;code&gt;'i'&lt;/code&gt; 인 항목 을 갖는 반면 &lt;code&gt;CREATE EXTENSION&lt;/code&gt; 에 의해 초기 권한이 설정된 오브젝트 는 &lt;code&gt;privtype&lt;/code&gt; 이 &lt;code&gt;'e'&lt;/code&gt; 인 항목을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="8f79c201923795ddf3fc3a390dc899926a81383e" translate="yes" xml:space="preserve">
          <source>Objects with equal numbers of pairs are compared in the order:</source>
          <target state="translated">동일한 수의 쌍을 가진 객체는 순서대로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="40a4edd85bccc1fb19d69c2e2dabe7dd4292f362" translate="yes" xml:space="preserve">
          <source>Observe how in the traditional ICU locale naming system, the root locale is selected by an empty string.</source>
          <target state="translated">전통적인 ICU 로케일 명명 시스템에서 루트 로케일이 빈 문자열로 어떻게 선택되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="82dae9ce3d89138d44c64eb3de8005375bc20848" translate="yes" xml:space="preserve">
          <source>Observe that this kind of partial index requires that the common values be predetermined, so such partial indexes are best used for data distributions that do not change. Such indexes can be recreated occasionally to adjust for new data distributions, but this adds maintenance effort.</source>
          <target state="translated">이러한 종류의 부분 인덱스는 공통 값을 미리 결정해야하므로 이러한 부분 인덱스는 변경되지 않는 데이터 분포에 가장 적합합니다. 이러한 인덱스는 새로운 데이터 배포에 맞게 조정하여 가끔씩 재 작성할 수 있지만 유지 보수 노력이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d607df7ca6e658558b5841d4666abffe49980352" translate="yes" xml:space="preserve">
          <source>Observe that this match would not succeed if written as</source>
          <target state="translated">다음과 같이 쓰면이 경기가 성공하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="d177dde8092a5f060f1495243a63f697a9a17705" translate="yes" xml:space="preserve">
          <source>Observe two things about the result set:</source>
          <target state="translated">결과 집합에 대해 두 가지 사항을 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="4201c9715be128e9359f0f8e049514e18476b73a" translate="yes" xml:space="preserve">
          <source>Obsolete version of &lt;code&gt;crosstab(text)&lt;/code&gt;. The parameter &lt;code&gt;N&lt;/code&gt; is now ignored, since the number of value columns is always determined by the calling query</source>
          <target state="translated">사용되지 않는 버전의 &lt;code&gt;crosstab(text)&lt;/code&gt; . 값 열의 개수는 항상 호출 쿼리에 의해 결정되므로 매개 변수 &lt;code&gt;N&lt;/code&gt; 은 이제 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7df429ce2fd206ab797db57eb8b6b362392f7035" translate="yes" xml:space="preserve">
          <source>Obsolete version of &lt;code&gt;crosstab(text)&lt;/code&gt;. The parameter &lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt; is now ignored, since the number of value columns is always determined by the calling query.</source>
          <target state="translated">&lt;code&gt;crosstab(text)&lt;/code&gt; 의 오래된 버전입니다 . 값 열의 수는 항상 호출 쿼리에 의해 결정되므로 매개 변수 &lt;em&gt; &lt;code&gt;N&lt;/code&gt; &lt;/em&gt; 은 이제 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="11744d185f0b82d838b338e8988d902a0140f6b7" translate="yes" xml:space="preserve">
          <source>Obtain a &lt;code&gt;SHARE&lt;/code&gt; lock on a primary key table when going to perform inserts into a foreign key table:</source>
          <target state="translated">외래 키 테이블에 삽입을 수행 할 때 기본 키 테이블에 대한 &lt;code&gt;SHARE&lt;/code&gt; 잠금을 확보 하십시오.</target>
        </trans-unit>
        <trans-unit id="05c7fc189f9bad2f9b668a2a40c5180d608c005f" translate="yes" xml:space="preserve">
          <source>Obtain exclusive session level advisory lock</source>
          <target state="translated">독점 세션 레벨 자문 잠금 확보</target>
        </trans-unit>
        <trans-unit id="019972b3655998bb11d76b53a542ff72a8b76dca" translate="yes" xml:space="preserve">
          <source>Obtain exclusive session level advisory lock if available</source>
          <target state="translated">가능한 경우 독점 세션 레벨 자문 잠금 확보</target>
        </trans-unit>
        <trans-unit id="cbeca9dbec7784436d93a189577fd29e34a7fe37" translate="yes" xml:space="preserve">
          <source>Obtain exclusive transaction level advisory lock</source>
          <target state="translated">독점적 인 거래 수준 자문 잠금 획득</target>
        </trans-unit>
        <trans-unit id="b51bd7cdf3315df0e1b538d8f77d94955e4c6d83" translate="yes" xml:space="preserve">
          <source>Obtain exclusive transaction level advisory lock if available</source>
          <target state="translated">가능한 경우 독점적 인 거래 수준 자문 잠금 획득</target>
        </trans-unit>
        <trans-unit id="b1ba75ca9786f988af27bd943f8ef875b87406fc" translate="yes" xml:space="preserve">
          <source>Obtain shared session level advisory lock</source>
          <target state="translated">공유 세션 레벨 자문 잠금 확보</target>
        </trans-unit>
        <trans-unit id="4efab6b4a18b953adcf6fcfd9c4e7e2bbeb2b169" translate="yes" xml:space="preserve">
          <source>Obtain shared session level advisory lock if available</source>
          <target state="translated">가능한 경우 공유 세션 레벨 자문 잠금 확보</target>
        </trans-unit>
        <trans-unit id="9524c0b6999d2af997e67edd5b67a8f0eafef7e0" translate="yes" xml:space="preserve">
          <source>Obtain shared transaction level advisory lock</source>
          <target state="translated">공유 트랜잭션 레벨 자문 잠금 확보</target>
        </trans-unit>
        <trans-unit id="36c2761c3324c27688dc73a65bc20a430c91b936" translate="yes" xml:space="preserve">
          <source>Obtain shared transaction level advisory lock if available</source>
          <target state="translated">가능한 경우 공유 트랜잭션 레벨 권고 잠금 확보</target>
        </trans-unit>
        <trans-unit id="443dac9c78b1145631de0395325a4f37cac34453" translate="yes" xml:space="preserve">
          <source>Obtain the client's operating system user name from the operating system and check if it matches the requested database user name. This is only available for local connections. See &lt;a href=&quot;auth-peer&quot;&gt;Section 20.9&lt;/a&gt; for details.</source>
          <target state="translated">운영 체제에서 클라이언트의 운영 체제 사용자 이름을 확보하여 요청 된 데이터베이스 사용자 이름과 일치하는지 확인하십시오. 로컬 연결에서만 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;auth-peer&quot;&gt;섹션 20.9&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0e679373412300b3d7cf749daeaf3997d4726aac" translate="yes" xml:space="preserve">
          <source>Obtain the operating system user name of the client by contacting the ident server on the client and check if it matches the requested database user name. Ident authentication can only be used on TCP/IP connections. When specified for local connections, peer authentication will be used instead. See &lt;a href=&quot;auth-ident&quot;&gt;Section 20.8&lt;/a&gt; for details.</source>
          <target state="translated">클라이언트의 ID 서버에 접속하여 클라이언트의 운영 체제 사용자 이름을 확보하고 요청 된 데이터베이스 사용자 이름과 일치하는지 확인하십시오. ID 인증은 TCP / IP 연결에서만 사용할 수 있습니다. 로컬 연결에 지정된 경우 피어 인증이 대신 사용됩니다. 자세한 내용 &lt;a href=&quot;auth-ident&quot;&gt;은 20.8 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3c565c625c5016da01624ee751e9ac2b988301ee" translate="yes" xml:space="preserve">
          <source>Obtaining the next value is done using the &lt;code&gt;nextval()&lt;/code&gt; function instead of the standard's &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; expression.</source>
          <target state="translated">다음 값을 얻으려면 표준의 &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; 표현식 대신 &lt;code&gt;nextval()&lt;/code&gt; 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="77c27c2e821d493cd41fdb16ddcdf94550584d81" translate="yes" xml:space="preserve">
          <source>Obtains a shared session-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="translated">사용 가능한 경우 공유 세션 레벨 권고 잠금을 얻습니다. 이것은 즉시 잠금을 획득하고 &lt;code&gt;true&lt;/code&gt; 를 반환하거나 잠금을 즉시 획득 할 수없는 경우 기다리지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="63cc890455fd4316e991288e66cd3d2f6153525e" translate="yes" xml:space="preserve">
          <source>Obtains a shared session-level advisory lock, waiting if necessary.</source>
          <target state="translated">공유 세션 레벨 권고 잠금을 확보하고 필요한 경우 대기합니다.</target>
        </trans-unit>
        <trans-unit id="fbea7407ba6bb6ee25b3386cda5d9955692d4486" translate="yes" xml:space="preserve">
          <source>Obtains a shared transaction-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="translated">사용 가능한 경우 공유 트랜잭션 수준 권고 잠금을 얻습니다. 이것은 즉시 잠금을 획득하고 &lt;code&gt;true&lt;/code&gt; 를 반환하거나 잠금을 즉시 획득 할 수없는 경우 기다리지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3514ce32dda0a7ae50b8c2a334a5396bb99040f9" translate="yes" xml:space="preserve">
          <source>Obtains a shared transaction-level advisory lock, waiting if necessary.</source>
          <target state="translated">공유 트랜잭션 레벨 권고 잠금을 확보하고 필요한 경우 대기합니다.</target>
        </trans-unit>
        <trans-unit id="e623c9bebc77403e0def2b4752f5561440ee38bb" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive session-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="translated">사용 가능한 경우 배타적 세션 레벨 권고 잠금을 얻습니다. 이것은 즉시 잠금을 획득하고 &lt;code&gt;true&lt;/code&gt; 를 반환하거나 잠금을 즉시 획득 할 수없는 경우 기다리지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="34d59e1d231b4e0bffcbfc5dcc9980161d2e4fdb" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive session-level advisory lock, waiting if necessary.</source>
          <target state="translated">필요한 경우 대기하면서 배타적 세션 수준 권고 잠금을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="0bbbb737cb62d654d3a0339b01c5ad954c39d181" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive transaction-level advisory lock if available. This will either obtain the lock immediately and return &lt;code&gt;true&lt;/code&gt;, or return &lt;code&gt;false&lt;/code&gt; without waiting if the lock cannot be acquired immediately.</source>
          <target state="translated">사용 가능한 경우 독점 트랜잭션 수준 권고 잠금을 얻습니다. 이것은 즉시 잠금을 획득하고 &lt;code&gt;true&lt;/code&gt; 를 반환하거나 잠금을 즉시 획득 할 수없는 경우 기다리지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ffd08a954b4fc7be94a0c48f352d297308ce7dc5" translate="yes" xml:space="preserve">
          <source>Obtains an exclusive transaction-level advisory lock, waiting if necessary.</source>
          <target state="translated">필요한 경우 대기하면서 독점 트랜잭션 수준 권고 잠금을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="6f2c6c6809790186229da7b012c8919a980f66c8" translate="yes" xml:space="preserve">
          <source>Obviously, indexes with non-default sort orderings are a fairly specialized feature, but sometimes they can produce tremendous speedups for certain queries. Whether it's worth maintaining such an index depends on how often you use queries that require a special sort ordering.</source>
          <target state="translated">기본 정렬 순서가 아닌 인덱스는 상당히 특수한 기능이지만 특정 쿼리에 대해 엄청나게 빠른 속도를 낼 수도 있습니다. 이러한 인덱스를 유지할 가치가 있는지 여부는 특별한 정렬 순서가 필요한 쿼리를 얼마나 자주 사용하는지에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb1f89e656ff03a0a31a91974becb3d200ff4b46" translate="yes" xml:space="preserve">
          <source>Obviously, no one should be accessing the clusters during the upgrade. pg_upgrade defaults to running servers on port 50432 to avoid unintended client connections. You can use the same port number for both clusters when doing an upgrade because the old and new clusters will not be running at the same time. However, when checking an old running server, the old and new port numbers must be different.</source>
          <target state="translated">분명히 업그레이드하는 동안 아무도 클러스터에 액세스하지 않아야합니다. 의도하지 않은 클라이언트 연결을 피하기 위해 pg_upgrade는 기본적으로 포트 50432에서 서버를 실행합니다. 이전 클러스터와 새 클러스터가 동시에 실행되지 않으므로 업그레이드를 수행 할 때 두 클러스터 모두에 동일한 포트 번호를 사용할 수 있습니다. 그러나 이전에 실행중인 서버를 확인할 때는 이전 포트 번호와 새 포트 번호가 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="91a6106fff0646feab85327987f859dce96328f8" translate="yes" xml:space="preserve">
          <source>Obviously, pg_restore cannot restore information that is not present in the archive file. For instance, if the archive was made using the &amp;ldquo;dump data as &lt;code&gt;INSERT&lt;/code&gt; commands&amp;rdquo; option, pg_restore will not be able to load the data using &lt;code&gt;COPY&lt;/code&gt; statements.</source>
          <target state="translated">분명히 pg_restore는 아카이브 파일에없는 정보를 복원 할 수 없습니다. 예를 들어, &quot;덤프 데이터를 &lt;code&gt;INSERT&lt;/code&gt; 명령으로&quot;옵션을 사용하여 아카이브를 만든 경우 pg_restore는 &lt;code&gt;COPY&lt;/code&gt; 문을 사용하여 데이터를로드 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ea9f0a51f8358360ebe5d226327ee6a6dba47689" translate="yes" xml:space="preserve">
          <source>Obviously, two rows are considered distinct if they differ in at least one column value. Null values are considered equal in this comparison.</source>
          <target state="translated">분명히 하나 이상의 열 값이 다르면 두 개의 행이 구별되는 것으로 간주됩니다. 이 비교에서 널값은 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0325b2d5f9478c521e0c1edeceeab6be935d2d2e" translate="yes" xml:space="preserve">
          <source>Occasionally it is useful to mix rules from several locales, e.g., use English collation rules but Spanish messages. To support that, a set of locale subcategories exist that control only certain aspects of the localization rules:</source>
          <target state="translated">때로는 영어 조합 규칙을 사용하지만 스페인어 메시지를 사용하는 등 여러 로케일의 규칙을 혼합하는 것이 유용합니다. 이를 지원하기 위해 현지화 규칙의 특정 측면 만 제어하는 ​​로케일 하위 카테고리 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="51327aef9866e85ef5b5b2294a28494d2715ae59" translate="yes" xml:space="preserve">
          <source>Oct</source>
          <target state="translated">Oct</target>
        </trans-unit>
        <trans-unit id="87206ae2363483496c099f8c3aac5b4a8ae2a66a" translate="yes" xml:space="preserve">
          <source>October</source>
          <target state="translated">October</target>
        </trans-unit>
        <trans-unit id="c07f133434909a3b139ea6fd5087f84900fccadf" translate="yes" xml:space="preserve">
          <source>Of course, a column can have more than one constraint. Just write the constraints one after another:</source>
          <target state="translated">물론 열에는 둘 이상의 제약 조건이있을 수 있습니다. 제약 조건을 하나씩 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="15554cdfd90fe94a0c248e4f64467a3a5d448ea0" translate="yes" xml:space="preserve">
          <source>Of course, each column must be used with operators appropriate to the index type; clauses that involve other operators will not be considered.</source>
          <target state="translated">물론 각 열은 인덱스 유형에 적합한 연산자와 함께 사용해야합니다. 다른 연산자와 관련된 조항은 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cfcf640173f2cee55033307859827db1cc0f9ba" translate="yes" xml:space="preserve">
          <source>Of course, if the remote table is not in fact updatable, an error would occur anyway. Use of this option primarily allows the error to be thrown locally without querying the remote server. Note however that the &lt;code&gt;information_schema&lt;/code&gt; views will report a &lt;code&gt;postgres_fdw&lt;/code&gt; foreign table to be updatable (or not) according to the setting of this option, without any check of the remote server.</source>
          <target state="translated">물론 원격 테이블을 실제로 업데이트 할 수 없으면 오류가 발생합니다. 이 옵션을 사용하면 주로 원격 서버를 조회하지 않고 로컬로 오류가 발생합니다. 그러나 &lt;code&gt;information_schema&lt;/code&gt; 보기는 원격 서버를 확인하지 않고이 옵션의 설정에 따라 &lt;code&gt;postgres_fdw&lt;/code&gt; 외부 테이블을 업데이트 할 수 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="ac88e35965ca0b1056564e9dfa16bc3a086971ee" translate="yes" xml:space="preserve">
          <source>Of course, some SQL database systems might not implement schemas at all, or provide namespace support by allowing (possibly limited) cross-database access. If you need to work with those systems, then maximum portability would be achieved by not using schemas at all.</source>
          <target state="translated">물론 일부 SQL 데이터베이스 시스템은 스키마를 전혀 구현하지 않거나 데이터베이스 간 액세스를 제한하여 네임 스페이스 지원을 제공 할 수 있습니다. 해당 시스템으로 작업해야하는 경우 스키마를 전혀 사용하지 않으면 서 이식성을 극대화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b09f440f59472b164c47e7153b71ff603597271c" translate="yes" xml:space="preserve">
          <source>Of course, the &lt;code&gt;SELECT&lt;/code&gt; statement is compatible with the SQL standard. But there are some extensions and some missing features.</source>
          <target state="translated">물론 &lt;code&gt;SELECT&lt;/code&gt; 문은 SQL 표준과 호환됩니다. 그러나 일부 확장 기능과 누락 된 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b998cb5ccff7c6a6d09f60a802fba18afa38d81f" translate="yes" xml:space="preserve">
          <source>Of course, the argument of a sequence function can be an expression as well as a constant. If it is a text expression then the implicit coercion will result in a run-time lookup.</source>
          <target state="translated">물론, 시퀀스 함수의 인수는 상수 일뿐만 아니라 표현식 일 수 있습니다. 텍스트 표현식 인 경우 내재 된 강제 변환은 런타임 조회를 초래합니다.</target>
        </trans-unit>
        <trans-unit id="c8ec66919586aa50108f55c55fa32064846f02f9" translate="yes" xml:space="preserve">
          <source>Of course, the number and type of the constrained columns need to match the number and type of the referenced columns.</source>
          <target state="translated">물론 제약 된 열의 수와 유형은 참조 된 열의 수와 유형과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="608089afae6cc6682d178112cb3562d38642d49b" translate="yes" xml:space="preserve">
          <source>Of course, the previous example was heavily contrived. Normally, you would give names to your tables and columns that convey what kind of data they store. So let's look at a more realistic example:</source>
          <target state="translated">물론, 이전의 예는 많이 고안되었습니다. 일반적으로 어떤 종류의 데이터를 저장하는지 테이블과 열에 이름을 지정합니다. 보다 현실적인 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="cdf2e77434f0f6336db99d58530ea7e875d07b42" translate="yes" xml:space="preserve">
          <source>Of course, the specific numbers shown here depend on the actual contents of the tables involved. Also note that the numbers, and even the selected query strategy, might vary between PostgreSQL releases due to planner improvements. In addition, the &lt;code&gt;ANALYZE&lt;/code&gt; command uses random sampling to estimate data statistics; therefore, it is possible for cost estimates to change after a fresh run of &lt;code&gt;ANALYZE&lt;/code&gt;, even if the actual distribution of data in the table has not changed.</source>
          <target state="translated">물론 여기에 표시된 특정 숫자는 관련된 테이블의 실제 내용에 따라 다릅니다. 또한 계획 수의 향상으로 인해 PostgreSQL 릴리스마다 숫자와 선택한 쿼리 전략이 다를 수 있습니다. 또한 &lt;code&gt;ANALYZE&lt;/code&gt; 명령은 무작위 샘플링을 사용하여 데이터 통계를 추정합니다. 따라서 테이블에서 데이터의 실제 분배가 변경되지 않은 경우에도 &lt;code&gt;ANALYZE&lt;/code&gt; 를 새로 실행 한 후 비용 추정치가 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a685091dfb5c40427eaec8e993f66849819cf14d" translate="yes" xml:space="preserve">
          <source>Of the character-entry escapes described in &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.19&lt;/a&gt;, XQuery supports only &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, and &lt;code&gt;\t&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;표 9.19에&lt;/a&gt; 설명 된 문자 입력 이스케이프 중 XQuery는 &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; 및 &lt;code&gt;\t&lt;/code&gt; 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="c662143ec7a1becd10a1701782d2d5b95c4d60a8" translate="yes" xml:space="preserve">
          <source>Of the character-entry escapes described in &lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.20&lt;/a&gt;, XQuery supports only &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, and &lt;code&gt;\t&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-matching#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE&quot;&gt;Table 9.20에&lt;/a&gt; 설명 된 문자 입력 이스케이프 중 XQuery는 &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; 및 &lt;code&gt;\t&lt;/code&gt; 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="1a7f91ef8e30ab71323f7f16c956192d29cee4ea" translate="yes" xml:space="preserve">
          <source>Of the two operator classes for type &lt;code&gt;jsonb&lt;/code&gt;, &lt;code&gt;jsonb_ops&lt;/code&gt; is the default. &lt;code&gt;jsonb_path_ops&lt;/code&gt; supports fewer operators but offers better performance for those operators. See &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;Section 8.14.4&lt;/a&gt; for details.</source>
          <target state="translated">형에 대한 두 개의 연산자 클래스 중 &lt;code&gt;jsonb&lt;/code&gt; , &lt;code&gt;jsonb_ops&lt;/code&gt; 은 기본값입니다. &lt;code&gt;jsonb_path_ops&lt;/code&gt; 는 더 적은 연산자를 지원하지만 해당 연산자에 대해 더 나은 성능을 제공합니다. 자세한 내용 &lt;a href=&quot;datatype-json#JSON-INDEXING&quot;&gt;은 8.14.4 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="34c9deaa906dcefa70af958d1df36fd494f6477e" translate="yes" xml:space="preserve">
          <source>Of the two operator classes for type &lt;code&gt;point&lt;/code&gt;, &lt;code&gt;quad_point_ops&lt;/code&gt; is the default. &lt;code&gt;kd_point_ops&lt;/code&gt; supports the same operators but uses a different index data structure that may offer better performance in some applications.</source>
          <target state="translated">형에 대한 두 개의 연산자 클래스 중 &lt;code&gt;point&lt;/code&gt; , &lt;code&gt;quad_point_ops&lt;/code&gt; 은 기본값입니다. &lt;code&gt;kd_point_ops&lt;/code&gt; 는 동일한 연산자를 지원하지만 일부 애플리케이션에서 더 나은 성능을 제공 할 수있는 다른 인덱스 데이터 구조를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="823b07791eec5c49089c2fa31c806093113182bb" translate="yes" xml:space="preserve">
          <source>Of these extensions, &lt;code&gt;jsonb_plperl&lt;/code&gt; is considered &amp;ldquo;trusted&amp;rdquo;, that is, it can be installed by non-superusers who have &lt;code&gt;CREATE&lt;/code&gt; privilege on the current database. The rest require superuser privilege to install.</source>
          <target state="translated">이러한 확장 중 &lt;code&gt;jsonb_plperl&lt;/code&gt; 은 &quot;신뢰할 수있는&quot;것으로 간주 됩니다. 즉, 현재 데이터베이스에 대한 &lt;code&gt;CREATE&lt;/code&gt; 권한이있는 슈퍼 유저가 아닌 사용자가 설치할 수 있습니다 . 나머지는 설치하려면 수퍼 유저 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ae7fdb11d6c25f66601f3fb8a8f5b8fcc9b0822b" translate="yes" xml:space="preserve">
          <source>Offset from UTC (positive means east of Greenwich)</source>
          <target state="translated">UTC로부터 오프셋 (그리니치의 동쪽을 의미 함)</target>
        </trans-unit>
        <trans-unit id="1981d8aed8642cc19a01ec017cd302822eb99a80" translate="yes" xml:space="preserve">
          <source>Offset to end of free space</source>
          <target state="translated">여유 공간 끝까지 오프셋</target>
        </trans-unit>
        <trans-unit id="e27e1909bffb440ac18ed4f49dfc030d3bf289b3" translate="yes" xml:space="preserve">
          <source>Offset to start of free space</source>
          <target state="translated">여유 공간을 시작하기위한 오프셋</target>
        </trans-unit>
        <trans-unit id="96263ee552b7638e48664d80735a522bd69e2d15" translate="yes" xml:space="preserve">
          <source>Offset to start of special space</source>
          <target state="translated">특수 공간의 시작으로 오프셋</target>
        </trans-unit>
        <trans-unit id="7f9b46694e3dc059ec6a436a3380fe755ceb8f95" translate="yes" xml:space="preserve">
          <source>Often you will want to create a schema owned by someone else (since this is one of the ways to restrict the activities of your users to well-defined namespaces). The syntax for that is:</source>
          <target state="translated">종종 다른 사람이 소유 한 스키마를 만들려고 할 것입니다 (이것은 사용자 활동을 잘 정의 된 네임 스페이스로 제한하는 방법 중 하나이기 때문에). 그 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa524be3205ddb773bfe2be8f0cbe395871121b5" translate="yes" xml:space="preserve">
          <source>Okay, the worst has happened and you need to recover from your backup. Here is the procedure:</source>
          <target state="translated">좋습니다. 최악의 상황이 발생하여 백업에서 복구해야합니다. 절차는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16be0330fc822ce35047bcbe410657ce60f50c0e" translate="yes" xml:space="preserve">
          <source>Older Linux kernels do not offer &lt;code&gt;/proc/self/oom_score_adj&lt;/code&gt;, but may have a previous version of the same functionality called &lt;code&gt;/proc/self/oom_adj&lt;/code&gt;. This works the same except the disable value is &lt;code&gt;-17&lt;/code&gt; not &lt;code&gt;-1000&lt;/code&gt;.</source>
          <target state="translated">이전 리눅스 커널은 제공하지 않습니다 &lt;code&gt;/proc/self/oom_score_adj&lt;/code&gt; 만이라는 동일한 기능의 이전 버전있을 수 있습니다 &lt;code&gt;/proc/self/oom_adj&lt;/code&gt; . 비활성화 값은 제외하고이 같은 일 &lt;code&gt;-17&lt;/code&gt; 되지 &lt;code&gt;-1000&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ced6ddc46443201e8e3d960abac900f5903d1b39" translate="yes" xml:space="preserve">
          <source>Older PostgreSQL versions do not have this setting and always use the client's preferences. This setting is mainly for backward compatibility with those versions. Using the server's preferences is usually better because it is more likely that the server is appropriately configured.</source>
          <target state="translated">이전 PostgreSQL 버전에는이 설정이 없으며 항상 클라이언트 기본 설정을 사용합니다. 이 설정은 주로 해당 버전과의 호환성을 위해 사용됩니다. 서버의 환경 설정을 사용하는 것이 서버가 적절하게 구성되어있을 가능성이 높기 때문에 일반적으로 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b76ff612400899f457b05452321eac3486e8a6ab" translate="yes" xml:space="preserve">
          <source>Oldest unpruned XMAX on page, or zero if none</source>
          <target state="translated">페이지에서 정리되지 않은 가장 오래된 XMAX 또는없는 경우 0</target>
        </trans-unit>
        <trans-unit id="794b92ddcf68cabe2809fe5836f4849010daf46d" translate="yes" xml:space="preserve">
          <source>Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:obartunov@postgrespro.ru&quot;&gt;obartunov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt;, Postgres Professional, Moscow, Russia</source>
          <target state="translated">Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:obartunov@postgrespro.ru&quot;&gt;obartunov@postgrespro.ru&lt;/a&gt;&amp;gt;&lt;/code&gt; , Postgres Professional, 모스크바, 러시아</target>
        </trans-unit>
        <trans-unit id="21c3dce2dbff52b671e09984835bd018b576e577" translate="yes" xml:space="preserve">
          <source>Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt;, Moscow, Moscow University, Russia</source>
          <target state="translated">Oleg Bartunov &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:oleg@sai.msu.su&quot;&gt;oleg@sai.msu.su&lt;/a&gt;&amp;gt;&lt;/code&gt; , 러시아 모스크바 대학교 모스크바</target>
        </trans-unit>
        <trans-unit id="c57ccf7fdc0e782593eaa681140c5d9ba28fcdd1" translate="yes" xml:space="preserve">
          <source>Omit the &lt;code&gt;ROW()&lt;/code&gt; syntax in the common case where only one field needs to be checked to recognize a cycle. This allows a simple array rather than a composite-type array to be used, gaining efficiency.</source>
          <target state="translated">사이클을 인식하기 위해 하나의 필드 만 검사해야하는 일반적인 경우 &lt;code&gt;ROW()&lt;/code&gt; 구문을 생략하십시오 . 따라서 복합 형 배열이 아닌 간단한 배열을 사용하여 효율성을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="263c5dac706b853afb054876ee3140dcdc435cf6" translate="yes" xml:space="preserve">
          <source>Omitted &lt;code&gt;FROM&lt;/code&gt; Clauses</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절에서 생략</target>
        </trans-unit>
        <trans-unit id="46b3737570e6db5d4ea7e5047dd8b127387b63f0" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;AS&lt;/code&gt; Key Word</source>
          <target state="translated">&lt;code&gt;AS&lt;/code&gt; 키워드 생략</target>
        </trans-unit>
        <trans-unit id="22a45e27f71c292f06706c737b69fd6802e9347f" translate="yes" xml:space="preserve">
          <source>On FreeBSD, IDE drives can be queried using &lt;code&gt;atacontrol&lt;/code&gt; and write caching turned off using &lt;code&gt;hw.ata.wc=0&lt;/code&gt; in &lt;code&gt;/boot/loader.conf&lt;/code&gt;; SCSI drives can be queried using &lt;code&gt;camcontrol identify&lt;/code&gt;, and the write cache both queried and changed using &lt;code&gt;sdparm&lt;/code&gt; when available.</source>
          <target state="translated">FreeBSD에서 &lt;code&gt;atacontrol&lt;/code&gt; 을 사용하여 IDE 드라이브를 쿼리 하고 &lt;code&gt;/boot/loader.conf&lt;/code&gt; 에서 &lt;code&gt;hw.ata.wc=0&lt;/code&gt; 을 사용하여 쓰기 캐싱을 해제 할 수 있습니다 . &lt;code&gt;camcontrol identify&lt;/code&gt; 사용하여 SCSI 드라이브를 쿼리 할 수 ​​있으며 , 사용 가능한 경우 &lt;code&gt;sdparm&lt;/code&gt; 을 사용하여 쓰기 캐시를 쿼리하고 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="d39ed9f52193cbb9703d5a56c5956b148e841314" translate="yes" xml:space="preserve">
          <source>On Linux 2.6 and later, it is possible to modify the kernel's behavior so that it will not &amp;ldquo;overcommit&amp;rdquo; memory. Although this setting will not prevent the &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM killer&lt;/a&gt; from being invoked altogether, it will lower the chances significantly and will therefore lead to more robust system behavior. This is done by selecting strict overcommit mode via &lt;code&gt;sysctl&lt;/code&gt;:</source>
          <target state="translated">Linux 2.6 이상에서는 커널의 동작을 수정하여 메모리가 &quot;과도 커밋&quot;되지 않도록 할 수 있습니다. 이 설정으로 &lt;a href=&quot;https://lwn.net/Articles/104179/&quot;&gt;OOM 킬러&lt;/a&gt; 가 완전히 호출되는 것을 막을 수는 없지만 기회가 크게 줄어들어보다 강력한 시스템 동작이 가능합니다. &lt;code&gt;sysctl&lt;/code&gt; 을 통해 엄격한 오버 커밋 모드를 선택하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="501ddfe2d2530fe9fcac7688b14da5778270cdb1" translate="yes" xml:space="preserve">
          <source>On Linux &lt;code&gt;/proc/sys/fs/file-max&lt;/code&gt; determines the maximum number of open files that the kernel will support. It can be changed by writing a different number into the file or by adding an assignment in &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;. The maximum limit of files per process is fixed at the time the kernel is compiled; see &lt;code&gt;/usr/src/linux/Documentation/proc.txt&lt;/code&gt; for more information.</source>
          <target state="translated">Linux에서 &lt;code&gt;/proc/sys/fs/file-max&lt;/code&gt; 는 커널이 지원할 최대 열린 파일 수를 결정합니다. 파일에 다른 번호를 쓰거나 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 에 할당을 추가하여 변경할 수 있습니다 . 프로세스 당 파일의 최대 한계는 커널이 컴파일 될 때 고정됩니다. 자세한 내용 은 &lt;code&gt;/usr/src/linux/Documentation/proc.txt&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f009fe3fb04da9e8adcc93565c99cbfd73e2affe" translate="yes" xml:space="preserve">
          <source>On Linux and POSIX platforms &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-FLUSH-AFTER&quot;&gt;checkpoint_flush_after&lt;/a&gt; allows to force the OS that pages written by the checkpoint should be flushed to disk after a configurable number of bytes. Otherwise, these pages may be kept in the OS's page cache, inducing a stall when &lt;code&gt;fsync&lt;/code&gt; is issued at the end of a checkpoint. This setting will often help to reduce transaction latency, but it also can have an adverse effect on performance; particularly for workloads that are bigger than &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;, but smaller than the OS's page cache.</source>
          <target state="translated">Linux 및 POSIX 플랫폼에서 &lt;a href=&quot;runtime-config-wal#GUC-CHECKPOINT-FLUSH-AFTER&quot;&gt;checkpoint_flush_after&lt;/a&gt; 는 구성 가능한 바이트 수 후에 체크 포인트로 작성된 페이지를 디스크로 플러시해야하는 OS를 강제 실행할 수 있습니다. 그렇지 않으면 이러한 페이지가 OS의 페이지 캐시에 유지되어 검사 점 끝에서 &lt;code&gt;fsync&lt;/code&gt; 가 실행될 때 중단 될 수 있습니다. 이 설정은 종종 트랜잭션 대기 시간을 줄이는 데 도움이되지만 성능에 부정적인 영향을 줄 수 있습니다. 특히 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt; 보다 크지 만 OS의 페이지 캐시보다 작은 워크로드의 경우 .</target>
        </trans-unit>
        <trans-unit id="c936f58f7f62e48372e8a8076ff322928b68bb04" translate="yes" xml:space="preserve">
          <source>On Linux or Unix systems, you might use:</source>
          <target state="translated">Linux 또는 Unix 시스템에서는 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f7c8c1bd4d71387a1210efd816cb3bef4ae3f74" translate="yes" xml:space="preserve">
          <source>On Linux systems either add</source>
          <target state="translated">리눅스 시스템에서</target>
        </trans-unit>
        <trans-unit id="dc805fd8588880f607d3f4520d6ee5e450aee68a" translate="yes" xml:space="preserve">
          <source>On Linux, IDE and SATA drives can be queried using &lt;code&gt;hdparm -I&lt;/code&gt;; write caching is enabled if there is a &lt;code&gt;*&lt;/code&gt; next to &lt;code&gt;Write cache&lt;/code&gt;. &lt;code&gt;hdparm -W 0&lt;/code&gt; can be used to turn off write caching. SCSI drives can be queried using &lt;a href=&quot;http://sg.danny.cz/sg/sdparm.html&quot;&gt;sdparm&lt;/a&gt;. Use &lt;code&gt;sdparm --get=WCE&lt;/code&gt; to check whether the write cache is enabled and &lt;code&gt;sdparm --clear=WCE&lt;/code&gt; to disable it.</source>
          <target state="translated">Linux에서 &lt;code&gt;hdparm -I&lt;/code&gt; 를 사용하여 IDE 및 SATA 드라이브를 조회 할 수 있습니다 . 가있는 경우 쓰기 캐싱을 사용할 수 있습니다 &lt;code&gt;*&lt;/code&gt; 이 옆에 &lt;code&gt;Write cache&lt;/code&gt; . &lt;code&gt;hdparm -W 0&lt;/code&gt; 을 사용하여 쓰기 캐싱을 해제 할 수 있습니다. SCSI 드라이브는 &lt;a href=&quot;http://sg.danny.cz/sg/sdparm.html&quot;&gt;sdparm을&lt;/a&gt; 사용하여 쿼리 할 수 ​​있습니다 . 쓰기 캐시가 사용 가능한지 확인 하려면 &lt;code&gt;sdparm --get=WCE&lt;/code&gt; 를 사용하고 사용하지 않으려면 &lt;code&gt;sdparm --clear=WCE&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="55da6c1d848d4260b86ebf92495a2847786e7138" translate="yes" xml:space="preserve">
          <source>On Microsoft Windows, also:</source>
          <target state="translated">Microsoft Windows의 경우 :</target>
        </trans-unit>
        <trans-unit id="3630213a83c6eeeff64f72e78908e323507bf7bd" translate="yes" xml:space="preserve">
          <source>On NetBSD, use either the FreeBSD or Linux start scripts, depending on preference.</source>
          <target state="translated">NetBSD에서는 환경 설정에 따라 FreeBSD 또는 Linux 시작 스크립트를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ba742d094af1abbc78f9a3859fd3be730c7188af" translate="yes" xml:space="preserve">
          <source>On OpenBSD, add the following lines to the file &lt;code&gt;/etc/rc.local&lt;/code&gt;:</source>
          <target state="translated">OpenBSD에서 &lt;code&gt;/etc/rc.local&lt;/code&gt; 파일에 다음 줄을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c2c1726b1c50e52c768b284b11ed29bfb8afb96" translate="yes" xml:space="preserve">
          <source>On Solaris, create a file called &lt;code&gt;/etc/init.d/postgresql&lt;/code&gt; that contains the following line:</source>
          <target state="translated">Solaris 에서 다음 행을 포함하는 &lt;code&gt;/etc/init.d/postgresql&lt;/code&gt; 이라는 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="2bb8949d83fc7ef1475b557895bfe563a925aea9" translate="yes" xml:space="preserve">
          <source>On Solaris, the disk write cache is controlled by &lt;code&gt;format -e&lt;/code&gt;. (The Solaris ZFS file system is safe with disk write-cache enabled because it issues its own disk cache flush commands.)</source>
          <target state="translated">Solaris에서 디스크 쓰기 캐시는 &lt;code&gt;format -e&lt;/code&gt; 로 제어됩니다 . (Solaris ZFS 파일 시스템은 자체 디스크 캐시 플러시 명령을 실행하기 때문에 디스크 쓰기 캐시를 사용하여 안전합니다.)</target>
        </trans-unit>
        <trans-unit id="d85af98780490009a295939145f84e031804f11c" translate="yes" xml:space="preserve">
          <source>On Unix systems this parameter reports the permissions of the data directory defined by (&lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt;) at startup. (On Microsoft Windows this parameter will always display &lt;code&gt;0700&lt;/code&gt;). See &lt;a href=&quot;app-initdb#APP-INITDB-ALLOW-GROUP-ACCESS&quot;&gt;group access&lt;/a&gt; for more information.</source>
          <target state="translated">Unix 시스템에서이 매개 변수 는 시작할 때 ( &lt;a href=&quot;runtime-config-file-locations#GUC-DATA-DIRECTORY&quot;&gt;data_directory&lt;/a&gt; )로 정의 된 데이터 디렉토리의 권한을보고합니다 . (Microsoft Windows에서이 매개 변수는 항상 &lt;code&gt;0700&lt;/code&gt; 을 표시합니다 ). 자세한 내용은 &lt;a href=&quot;app-initdb#APP-INITDB-ALLOW-GROUP-ACCESS&quot;&gt;그룹 액세스&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5d93a70eed193dd90ef032ea7d63d19a6516eb0a" translate="yes" xml:space="preserve">
          <source>On Unix systems this parameter sets the permissions for log files when &lt;code&gt;logging_collector&lt;/code&gt; is enabled. (On Microsoft Windows this parameter is ignored.) The parameter value is expected to be a numeric mode specified in the format accepted by the &lt;code&gt;chmod&lt;/code&gt; and &lt;code&gt;umask&lt;/code&gt; system calls. (To use the customary octal format the number must start with a &lt;code&gt;0&lt;/code&gt; (zero).)</source>
          <target state="translated">Unix 시스템에서이 매개 변수는 &lt;code&gt;logging_collector&lt;/code&gt; 가 사용 가능한 경우 로그 파일에 대한 권한을 설정합니다 . (Microsoft Windows에서는이 매개 변수가 무시됩니다.) 매개 변수 값은 &lt;code&gt;chmod&lt;/code&gt; 및 &lt;code&gt;umask&lt;/code&gt; 시스템 호출 에서 허용하는 형식으로 지정된 숫자 모드 일 것으로 예상됩니다 . (일반적인 8 진수 형식을 사용하려면 숫자는 &lt;code&gt;0&lt;/code&gt; 으로 시작해야합니다 .)</target>
        </trans-unit>
        <trans-unit id="aec768083a143a16efefa19e77bcef93265299f5" translate="yes" xml:space="preserve">
          <source>On Unix systems, the permissions on &lt;code&gt;server.key&lt;/code&gt; must disallow any access to world or group; achieve this by the command &lt;code&gt;chmod 0600 server.key&lt;/code&gt;. Alternatively, the file can be owned by root and have group read access (that is, &lt;code&gt;0640&lt;/code&gt; permissions). That setup is intended for installations where certificate and key files are managed by the operating system. The user under which the PostgreSQL server runs should then be made a member of the group that has access to those certificate and key files.</source>
          <target state="translated">Unix 시스템에서 &lt;code&gt;server.key&lt;/code&gt; 에 대한 권한은 월드 또는 그룹에 대한 액세스를 허용하지 않아야합니다. &lt;code&gt;chmod 0600 server.key&lt;/code&gt; 명령으로이를 수행하십시오 . 또는 파일을 루트가 소유하고 그룹 읽기 권한 (즉, &lt;code&gt;0640&lt;/code&gt; 권한)을 가질 수 있습니다 . 해당 설정은 운영 체제에서 인증서 및 키 파일을 관리하는 설치를위한 것입니다. 그런 다음 PostgreSQL 서버가 실행되는 사용자는 해당 인증서 및 키 파일에 액세스 할 수있는 그룹의 구성원이되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e0de69e7d7ec6add644868e783650d15d55a6f2e" translate="yes" xml:space="preserve">
          <source>On Windows hosts, preloading a library at server start will not reduce the time required to start each new server process; each server process will re-load all preload libraries. However, &lt;code&gt;shared_preload_libraries&lt;/code&gt; is still useful on Windows hosts for libraries that need to perform operations at postmaster start time.</source>
          <target state="translated">Windows 호스트에서 서버 시작시 라이브러리를 사전로드해도 새로운 각 서버 프로세스를 시작하는 데 필요한 시간이 줄어들지 않습니다. 각 서버 프로세스는 모든 사전로드 라이브러리를 다시로드합니다. 그러나 &lt;code&gt;shared_preload_libraries&lt;/code&gt; 는 포스트 마스터 시작 시간에 작업을 수행해야하는 라이브러리의 Windows 호스트에서 여전히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="08c92789aa023ae69cee69a7db7a2ae77f278c4c" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;code&gt;wal_sync_method&lt;/code&gt; is &lt;code&gt;open_datasync&lt;/code&gt; (the default), write caching can be disabled by unchecking &lt;code&gt;My Computer\Open\disk drive\Properties\Hardware\Properties\Policies\Enable write caching on the disk&lt;/code&gt;. Alternatively, set &lt;code&gt;wal_sync_method&lt;/code&gt; to &lt;code&gt;fsync&lt;/code&gt; or &lt;code&gt;fsync_writethrough&lt;/code&gt;, which prevent write caching.</source>
          <target state="translated">Windows에서 &lt;code&gt;wal_sync_method&lt;/code&gt; 가 &lt;code&gt;open_datasync&lt;/code&gt; (기본값)이면 &lt;code&gt;My Computer\Open\disk drive\Properties\Hardware\Properties\Policies\Enable write caching on the disk&lt;/code&gt; 에서 쓰기 캐싱 사용을 선택 취소하여 쓰기 캐싱을 사용하지 않도록 설정할 수 있습니다 . 또는 &lt;code&gt;wal_sync_method&lt;/code&gt; 를 &lt;code&gt;fsync&lt;/code&gt; 또는 &lt;code&gt;fsync_writethrough&lt;/code&gt; 로 설정 하여 쓰기 캐싱을 방지하십시오.</target>
        </trans-unit>
        <trans-unit id="81eec3e42d4f18ead15b1e929550fb213358fb1f" translate="yes" xml:space="preserve">
          <source>On Windows, setting a value of 0 will set this parameter to 1 second, since Windows does not provide a way to read the system default value.</source>
          <target state="translated">Windows에서 값을 0으로 설정하면 Windows가 시스템 기본값을 읽는 방법을 제공하지 않으므로이 매개 변수를 1 초로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="53478c470af75305cb8745b03e7cb49bde700061" translate="yes" xml:space="preserve">
          <source>On Windows, setting a value of 0 will set this parameter to 2 hours, since Windows does not provide a way to read the system default value.</source>
          <target state="translated">Windows에서 값을 0으로 설정하면 Windows가 시스템 기본값을 읽는 방법을 제공하지 않으므로이 매개 변수를 2 시간으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c0312ea0b4215b07b7b0ad5539831203f3c1aa4d" translate="yes" xml:space="preserve">
          <source>On Windows, when you use the &lt;code&gt;eventlog&lt;/code&gt; option for &lt;code&gt;log_destination&lt;/code&gt;, you should register an event source and its library with the operating system so that the Windows Event Viewer can display event log messages cleanly. See &lt;a href=&quot;event-log-registration&quot;&gt;Section 18.12&lt;/a&gt; for details.</source>
          <target state="translated">Windows에서 &lt;code&gt;log_destination&lt;/code&gt; 에 &lt;code&gt;eventlog&lt;/code&gt; 옵션을 사용 하는 경우 Windows 이벤트 뷰어가 이벤트 로그 메시지를 깨끗하게 표시 할 수 있도록 이벤트 소스 및 해당 라이브러리를 운영 체제에 등록해야합니다. 자세한 내용은 &lt;a href=&quot;event-log-registration&quot;&gt;섹션 18.12&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fed4544374a90927980cc01194ee5bade4dcaae9" translate="yes" xml:space="preserve">
          <source>On a hot standby, the status of the WAL receiver process can be retrieved via the &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;&lt;code&gt;pg_stat_wal_receiver&lt;/code&gt;&lt;/a&gt; view. A large difference between &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; and the view's &lt;code&gt;flushed_lsn&lt;/code&gt; indicates that WAL is being received faster than it can be replayed.</source>
          <target state="translated">핫 스탠바이에서 WAL 수신기 프로세스의 상태는 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-WAL-RECEIVER-VIEW&quot;&gt; &lt;code&gt;pg_stat_wal_receiver&lt;/code&gt; &lt;/a&gt; 뷰 를 통해 검색 할 수 있습니다 . &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; 과 뷰의 &lt;code&gt;flushed_lsn&lt;/code&gt; 사이의 큰 차이는 WAL이 재생 될 수있는 것보다 더 빨리 수신되고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b5ae51b938e943ee6107b7e5c25bdb8c42c5ee40" translate="yes" xml:space="preserve">
          <source>On a hot standby, the status of the WAL receiver process can be retrieved via the &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; view. A large difference between &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; and the view's &lt;code&gt;received_lsn&lt;/code&gt; indicates that WAL is being received faster than it can be replayed.</source>
          <target state="translated">상시 대기 상태에서 &lt;a href=&quot;monitoring-stats#PG-STAT-WAL-RECEIVER-VIEW&quot;&gt;pg_stat_wal_receiver&lt;/a&gt; 보기 를 통해 WAL 수신자 프로세스의 상태를 검색 할 수 있습니다 . &lt;code&gt;pg_last_wal_replay_lsn&lt;/code&gt; 과 뷰의 &lt;code&gt;received_lsn&lt;/code&gt; 의 큰 차이는 WAL이 재생 될 수있는 것보다 빠르게 수신되고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a87ef11e5bf076fa4c6ca218448b2458c3ebe4c9" translate="yes" xml:space="preserve">
          <source>On all currently supported platforms, the &lt;code&gt;real&lt;/code&gt; type has a range of around 1E-37 to 1E+37 with a precision of at least 6 decimal digits. The &lt;code&gt;double precision&lt;/code&gt; type has a range of around 1E-307 to 1E+308 with a precision of at least 15 digits. Values that are too large or too small will cause an error. Rounding might take place if the precision of an input number is too high. Numbers too close to zero that are not representable as distinct from zero will cause an underflow error.</source>
          <target state="translated">현재 지원되는 모든 플랫폼에서 &lt;code&gt;real&lt;/code&gt; 유형은 최소 6 자리의 정밀도로 약 1E-37에서 1E + 37 범위입니다. &lt;code&gt;double precision&lt;/code&gt; 형 주위의 1E-1E + 307 (308)에 적어도 15 자리의 정밀도의 범위를 갖는다. 너무 크거나 작은 값은 오류를 발생시킵니다. 입력 숫자의 정밀도가 너무 높으면 반올림이 발생할 수 있습니다. 0과 구별 할 수없는 0에 너무 가까운 숫자는 언더 플로 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="fc9f60ea02e43afcbb3f8733c606556d9627a339" translate="yes" xml:space="preserve">
          <source>On all platforms, the collations named &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, and &lt;code&gt;POSIX&lt;/code&gt; are available. Additional collations may be available depending on operating system support. The &lt;code&gt;default&lt;/code&gt; collation selects the &lt;code&gt;LC_COLLATE&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; values specified at database creation time. The &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;POSIX&lt;/code&gt; collations both specify &amp;ldquo;traditional C&amp;rdquo; behavior, in which only the ASCII letters &amp;ldquo;&lt;code&gt;A&lt;/code&gt;&amp;rdquo; through &amp;ldquo;&lt;code&gt;Z&lt;/code&gt;&amp;rdquo; are treated as letters, and sorting is done strictly by character code byte values.</source>
          <target state="translated">모든 플랫폼에서 &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;POSIX&lt;/code&gt; 라는 데이터 정렬 을 사용할 수 있습니다. 운영 체제 지원에 따라 추가 데이터 정렬이 제공 될 수 있습니다. &lt;code&gt;default&lt;/code&gt; 정렬은 선택 &lt;code&gt;LC_COLLATE&lt;/code&gt; 와 &lt;code&gt;LC_CTYPE&lt;/code&gt; 데이터베이스 작성 시간에 지정된 값을. &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;POSIX&lt;/code&gt; 정렬 모두 만 ASCII 문자 &quot;하는&quot;전통적인 C &quot;동작을 지정 &lt;code&gt;A&lt;/code&gt; &quot;통해 &quot; &lt;code&gt;Z&lt;/code&gt; 는 &quot;문자로 취급을하고, 문자 코드 바이트 값으로 엄격하게 이루어집니다 정렬이.</target>
        </trans-unit>
        <trans-unit id="1c0634f5bf5f884787664141e116cb74ad234b48" translate="yes" xml:space="preserve">
          <source>On error, the server can abort the authentication at any stage, and send an ErrorMessage.</source>
          <target state="translated">오류가 발생하면 서버는 모든 단계에서 인증을 중단하고 ErrorMessage를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5350086780663aaf1bd7a44ba47818175298a073" translate="yes" xml:space="preserve">
          <source>On macOS, write caching can be prevented by setting &lt;code&gt;wal_sync_method&lt;/code&gt; to &lt;code&gt;fsync_writethrough&lt;/code&gt;.</source>
          <target state="translated">macOS에서는 &lt;code&gt;wal_sync_method&lt;/code&gt; 를 &lt;code&gt;fsync_writethrough&lt;/code&gt; 로 설정하여 쓰기 캐싱을 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="befd8f0dca607b26fc6d2d970cd74ce25f6b225a" translate="yes" xml:space="preserve">
          <source>On many systems, however, syslog is not very reliable, particularly with large log messages; it might truncate or drop messages just when you need them the most. Also, on Linux, syslog will flush each message to disk, yielding poor performance. (You can use a &amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo; at the start of the file name in the syslog configuration file to disable syncing.)</source>
          <target state="translated">그러나 많은 시스템에서 syslog는 특히 큰 로그 메시지에서 신뢰성이 떨어집니다. 가장 필요할 때 메시지를 자르거나 삭제할 수 있습니다. 또한 Linux에서 syslog는 각 메시지를 디스크로 플러시하여 성능이 저하됩니다. syslog 구성 파일에서 파일 이름의 시작 부분에 &amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;를 사용하여 동기화를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb6093f7e35a1c20e326af32dcefbf608a486601" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, PostgreSQL modifies its command title as reported by &lt;code&gt;ps&lt;/code&gt;, so that individual server processes can readily be identified. A sample display is</source>
          <target state="translated">대부분의 Unix 플랫폼에서 PostgreSQL은 &lt;code&gt;ps&lt;/code&gt; 가보고 한대로 명령 제목을 수정하여 개별 서버 프로세스를 쉽게 식별 할 수 있습니다. 샘플 디스플레이는</target>
        </trans-unit>
        <trans-unit id="d3b91e78aa6712803e0d5864f8e480013e5bf3c9" translate="yes" xml:space="preserve">
          <source>On most Unix systems, you will need to alter the configuration of your system's syslog daemon in order to make use of the syslog option for &lt;code&gt;log_destination&lt;/code&gt;. PostgreSQL can log to syslog facilities &lt;code&gt;LOCAL0&lt;/code&gt; through &lt;code&gt;LOCAL7&lt;/code&gt; (see &lt;a href=&quot;runtime-config-logging#GUC-SYSLOG-FACILITY&quot;&gt;syslog_facility&lt;/a&gt;), but the default syslog configuration on most platforms will discard all such messages. You will need to add something like:</source>
          <target state="translated">대부분의 Unix 시스템에서 &lt;code&gt;log_destination&lt;/code&gt; 에 syslog 옵션을 사용하려면 시스템의 syslog 데몬 구성을 변경해야합니다 . PostgreSQL는 시스템 로그 시설에 로그인 할 수 있습니다 &lt;code&gt;LOCAL0&lt;/code&gt; 을 통해 &lt;code&gt;LOCAL7&lt;/code&gt; (참조 &lt;a href=&quot;runtime-config-logging#GUC-SYSLOG-FACILITY&quot;&gt;SYSLOG_FACILITY를&lt;/a&gt; )하지만, 대부분의 플랫폼에서 기본 시스템 로그 구성은 이러한 모든 메시지를 삭제합니다. 다음과 같은 것을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="50e3c6b1dcc491688ab2b7696ca3d74d8a9db77d" translate="yes" xml:space="preserve">
          <source>On most modern operating systems, PostgreSQL can determine which character set is implied by the &lt;code&gt;LC_CTYPE&lt;/code&gt; setting, and it will enforce that only the matching database encoding is used. On older systems it is your responsibility to ensure that you use the encoding expected by the locale you have selected. A mistake in this area is likely to lead to strange behavior of locale-dependent operations such as sorting.</source>
          <target state="translated">대부분의 최신 운영 체제에서 PostgreSQL은 &lt;code&gt;LC_CTYPE&lt;/code&gt; 설정에 따라 어떤 문자 집합이 포함되는지 확인할 수 있으며 일치하는 데이터베이스 인코딩 만 사용하도록 강제합니다. 이전 시스템에서는 선택한 로케일이 예상 한 인코딩을 사용해야합니다. 이 영역에서의 실수는 정렬과 같은 로케일 종속 조작의 이상한 동작으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2260de2d5df529fa47da0a7e6dd5d8bb23e03ee" translate="yes" xml:space="preserve">
          <source>On most platforms, if PostgreSQL is built with &lt;code&gt;--enable-dtrace&lt;/code&gt;, the arguments to a trace macro will be evaluated whenever control passes through the macro, &lt;em&gt;even if no tracing is being done&lt;/em&gt;. This is usually not worth worrying about if you are just reporting the values of a few local variables. But beware of putting expensive function calls into the arguments. If you need to do that, consider protecting the macro with a check to see if the trace is actually enabled:</source>
          <target state="translated">대부분의 플랫폼에서 PostgreSQL이 &lt;code&gt;--enable-dtrace&lt;/code&gt; 로 빌드 된 &lt;em&gt;경우 추적이 수행되지 않더라도&lt;/em&gt; 제어가 매크로를 통과 할 때마다 추적 매크로에 대한 인수가 평가 &lt;em&gt;됩니다&lt;/em&gt; . 몇 개의 지역 변수 값만보고하는 경우에는 일반적으로 걱정할 필요가 없습니다. 그러나 값 비싼 함수 호출을 인수에 넣지 않도록주의하십시오. 이를 수행해야하는 경우 추적이 실제로 사용 가능한지 확인하여 매크로를 보호하십시오.</target>
        </trans-unit>
        <trans-unit id="d1a020e1e97e31739abdd2c2ef2354878b9e297e" translate="yes" xml:space="preserve">
          <source>On one system, an &lt;code&gt;EXPLAIN&lt;/code&gt; showed a query with a cost of 8488 was reduced to a cost of 329. The original query was a join involving the &lt;code&gt;one_to_many&lt;/code&gt; table, which was replaced by:</source>
          <target state="translated">한 시스템에서 &lt;code&gt;EXPLAIN&lt;/code&gt; 은 비용이 8488 인 쿼리가 329의 비용으로 줄어든 것으로 나타났습니다. 원래 쿼리는 &lt;code&gt;one_to_many&lt;/code&gt; 테이블 과 관련된 조인으로 다음과 같이 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="46913037bc93da8c08a056c91624219985822221" translate="yes" xml:space="preserve">
          <source>On output, double quotes always surround keys and values, even when it's not strictly necessary.</source>
          <target state="translated">출력시 큰 따옴표는 꼭 필요한 것은 아니지만 키와 값을 항상 둘러 쌉니다.</target>
        </trans-unit>
        <trans-unit id="bac2b8b67734755e62d6acef24655269b5ebc6a2" translate="yes" xml:space="preserve">
          <source>On some newer Linux systems, it's possible to change the clock source used to collect timing data at any time. A second example shows the slowdown possible from switching to the slower acpi_pm time source, on the same system used for the fast results above:</source>
          <target state="translated">일부 최신 Linux 시스템에서는 언제든지 타이밍 데이터를 수집하는 데 사용되는 클럭 소스를 변경할 수 있습니다. 두 번째 예는 위의 빠른 결과에 사용 된 것과 동일한 시스템에서 느린 acpi_pm 시간 소스로 전환 할 수있는 속도 저하를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9ce5931c68b8a455769ec944aab5c902a50f0a9b" translate="yes" xml:space="preserve">
          <source>On some operating systems, the status of data in the kernel's page cache is unknown after a write-back failure. In some cases it might have been entirely forgotten, making it unsafe to retry; the second attempt may be reported as successful, when in fact the data has been lost. In these circumstances, the only way to avoid data loss is to recover from the WAL after any failure is reported, preferably after investigating the root cause of the failure and replacing any faulty hardware.</source>
          <target state="translated">일부 운영 체제에서는 쓰기 실패 후 커널 페이지 캐시의 데이터 상태를 알 수 없습니다. 어떤 경우에는 완전히 잊혀져 다시 시도하는 것이 안전하지 않을 수 있습니다. 실제로 데이터가 손실 된 경우 두 번째 시도는 성공한 것으로보고 될 수 있습니다. 이러한 상황에서 데이터 손실을 방지하는 유일한 방법은 고장이보고 된 후, 바람직하게는 고장의 근본 원인을 조사하고 결함이있는 하드웨어를 교체 한 후 WAL에서 복구하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eee21b404ba214868f7afb4e8cb293a79759405b" translate="yes" xml:space="preserve">
          <source>On some systems, this locale category does not exist. Setting this variable will still work, but there will be no effect. Also, there is a chance that no translated messages for the desired language exist. In that case you will continue to see the English messages.</source>
          <target state="translated">일부 시스템에서는이 로케일 범주가 존재하지 않습니다. 이 변수를 설정해도 여전히 작동하지만 효과는 없습니다. 또한 원하는 언어로 번역 된 메시지가 없을 수도 있습니다. 이 경우 영어 메시지가 계속 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d8426bc3d71cab36b2e69aeb3bfdd7499b750f4a" translate="yes" xml:space="preserve">
          <source>On success, &lt;code&gt;*recheck&lt;/code&gt; should be set to true if the heap tuple needs to be rechecked against the query operator, or false if the index test is exact. That is, a false return value guarantees that the heap tuple does not match the query; a true return value with &lt;code&gt;*recheck&lt;/code&gt; set to false guarantees that the heap tuple does match the query; and a true return value with &lt;code&gt;*recheck&lt;/code&gt; set to true means that the heap tuple might match the query, so it needs to be fetched and rechecked by evaluating the query operator directly against the originally indexed item.</source>
          <target state="translated">성공 하면 힙 튜플을 쿼리 연산자에 대해 &lt;code&gt;*recheck&lt;/code&gt; 해야하는 경우 * recheck 를 true로 설정하고 인덱스 테스트가 정확한 경우 false를 설정해야합니다. 즉, 잘못된 반환 값은 힙 튜플이 쿼리와 일치하지 않도록합니다. &lt;code&gt;*recheck&lt;/code&gt; 가 false로 설정된 true 리턴 값 은 힙 튜플이 쿼리와 일치 함을 보장합니다. &lt;code&gt;*recheck&lt;/code&gt; 를 true로 설정 한 true 반환 값 은 힙 튜플이 쿼리와 일치 할 수 있으므로 원래 인덱스 된 항목에 대해 쿼리 연산자를 직접 평가하여 가져오고 다시 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="471ab7df5323b9c1beeab9b6ad11a4a3d81ba199" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;COPY&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">성공적으로 완료되면 &lt;code&gt;COPY&lt;/code&gt; 명령은 다음 형식의 명령 태그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a330b5f61b3e5eaefa54001cda5edd47cd225306" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;DELETE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">성공적으로 완료되면 &lt;code&gt;DELETE&lt;/code&gt; 명령은 다음 형식의 명령 태그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="606df5c042bda87282091ed6e870632af55a409b" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;FETCH&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">성공적으로 완료되면 &lt;code&gt;FETCH&lt;/code&gt; 명령은 다음 형식의 명령 태그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="522cefa61331276f75d9354dde07beed068c55b2" translate="yes" xml:space="preserve">
          <source>On successful completion, a &lt;code&gt;MOVE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">성공적으로 완료되면 &lt;code&gt;MOVE&lt;/code&gt; 명령은 다음 형식의 명령 태그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="10a00a825ef1af18a74c6369608739640c2c6694" translate="yes" xml:space="preserve">
          <source>On successful completion, an &lt;code&gt;INSERT&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">성공적으로 완료되면 &lt;code&gt;INSERT&lt;/code&gt; 명령은 다음 형식의 명령 태그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="adea3b7cb9bb8d678c08759a0633a3db722c1eb8" translate="yes" xml:space="preserve">
          <source>On successful completion, an &lt;code&gt;UPDATE&lt;/code&gt; command returns a command tag of the form</source>
          <target state="translated">성공적으로 완료되면 &lt;code&gt;UPDATE&lt;/code&gt; 명령은 다음 형식의 명령 태그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="17c3054fe4ff4e4031ec1aca452c9f2fbf414b42" translate="yes" xml:space="preserve">
          <source>On systems that have PostgreSQL started at boot time, there is probably a start-up file that will accomplish the same thing. For example, on a Red Hat Linux system one might find that this works:</source>
          <target state="translated">부팅시 PostgreSQL이 시작된 시스템에는 동일한 작업을 수행하는 시작 파일이있을 수 있습니다. 예를 들어, Red Hat Linux 시스템에서는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5c79b94518a5311140dc7e0d3b2812f742d2b393" translate="yes" xml:space="preserve">
          <source>On systems that support the keepalive socket option, setting &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-IDLE&quot;&gt;tcp_keepalives_idle&lt;/a&gt;, &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-INTERVAL&quot;&gt;tcp_keepalives_interval&lt;/a&gt; and &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-COUNT&quot;&gt;tcp_keepalives_count&lt;/a&gt; helps the primary promptly notice a broken connection.</source>
          <target state="translated">keepalive 소켓 옵션을 지원하는 시스템에서 &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-IDLE&quot;&gt;tcp_keepalives_idle&lt;/a&gt; , &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-INTERVAL&quot;&gt;tcp_keepalives_interval&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-connection#GUC-TCP-KEEPALIVES-COUNT&quot;&gt;tcp_keepalives_count를&lt;/a&gt; 설정 하면 기본 연결이 즉시 끊어진 연결을 발견하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="1fa1a4c2c8b8530e986a78ada66b4ce0e77848ad" translate="yes" xml:space="preserve">
          <source>On systems with less than 1GB of RAM, a smaller percentage of RAM is appropriate, so as to leave adequate space for the operating system.</source>
          <target state="translated">RAM이 1GB 미만인 시스템에서는 운영 체제에 적합한 공간을 확보하기 위해 더 적은 비율의 RAM이 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f7c83da74a1e6d13c844e01daa0931d96bf79bb8" translate="yes" xml:space="preserve">
          <source>On that date, there were two possible interpretations of 2:30AM; there was 2:30AM EDT, and then an hour later after the reversion to standard time, there was 2:30AM EST. Again, PostgreSQL interprets the given time as if it were standard time (UTC-5). We can force the matter by specifying daylight-savings time:</source>
          <target state="translated">그날 오전 2시 30 분에 가능한 두 가지 해석이있었습니다. EDT는 2:30 AM이었고 표준 시간으로 복귀 한 후 1 시간 후에는 EST가 2시 30 분이되었습니다. 다시 PostgreSQL은 주어진 시간을 표준 시간 인 것처럼 해석합니다 (UTC-5). 일광 절약 시간을 지정하여 문제를 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="108bc1acbd3eb627957c49ac13cf1805b058d6fd" translate="yes" xml:space="preserve">
          <source>On the other hand, the JSON existence operator is not nested: it will only look for the specified key or array element at top level of the JSON value.</source>
          <target state="translated">반면에 JSON 존재 연산자는 중첩되지 않습니다. JSON 값의 최상위 수준에서 지정된 키 또는 배열 요소 만 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0944856f78282776625887773317f5e5a29f6901" translate="yes" xml:space="preserve">
          <source>On the other hand, the following query finds all the cities that are not state capitals and are situated at an altitude over 500 feet:</source>
          <target state="translated">한편, 다음 쿼리는 주 수도가 아니고 500 피트 이상의 고도에있는 모든 도시를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="dc15ca0265b44e308c416ac01f3b8fd4dd23be18" translate="yes" xml:space="preserve">
          <source>On the other hand, the following query finds all the cities that are not state capitals and are situated at an elevation over 500 feet:</source>
          <target state="translated">반면에 다음 쿼리는 주도가 아니고 고도가 500 피트 이상인 모든 도시를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="8d66d041f4d766c1f0ee27254b9b736aa4e0885c" translate="yes" xml:space="preserve">
          <source>On the other hand, the prefix operator &lt;code&gt;~&lt;/code&gt; (bitwise negation) is defined only for integer data types, not for &lt;code&gt;float8&lt;/code&gt;. So, if we try a similar case with &lt;code&gt;~&lt;/code&gt;, we get:</source>
          <target state="translated">반면 접두사 연산자 &lt;code&gt;~&lt;/code&gt; (비트 단위 부정)는 &lt;code&gt;float8&lt;/code&gt; 이 아닌 정수 데이터 유형에 대해서만 정의됩니다 . 따라서 &lt;code&gt;~&lt;/code&gt; 와 비슷한 사례를 시도하면 다음과 같은 결과 가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e3fb0b420bf61dd2f01fedc471af93946522a689" translate="yes" xml:space="preserve">
          <source>On the other hand, the structurally similar case</source>
          <target state="translated">반면에 구조적으로 유사한 경우</target>
        </trans-unit>
        <trans-unit id="aa512d53935676cc08f57c9480c2f5a40cb3a7f6" translate="yes" xml:space="preserve">
          <source>On the other side of the coin, some systems allow individual processes to open large numbers of files; if more than a few processes do so then the system-wide limit can easily be exceeded. If you find this happening, and you do not want to alter the system-wide limit, you can set PostgreSQL's &lt;a href=&quot;runtime-config-resource#GUC-MAX-FILES-PER-PROCESS&quot;&gt;max_files_per_process&lt;/a&gt; configuration parameter to limit the consumption of open files.</source>
          <target state="translated">코인의 다른 측면에서 일부 시스템은 개별 프로세스가 많은 수의 파일을 열 수 있도록합니다. 프로세스가 몇 개 이상이면 시스템 전체 한계를 쉽게 초과 할 수 있습니다. 이러한 상황이 발생하고 시스템 전체 제한을 변경하지 않으려는 경우 PostgreSQL의 &lt;a href=&quot;runtime-config-resource#GUC-MAX-FILES-PER-PROCESS&quot;&gt;max_files_per_process&lt;/a&gt; 구성 매개 변수를 설정하여 열린 파일 소비를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e90706123ac00808e07c484e32d4635f07e67a74" translate="yes" xml:space="preserve">
          <source>On the primary server, these cases simply result in waiting; and the user might choose to cancel either of the conflicting actions. However, on the standby there is no choice: the WAL-logged action already occurred on the primary so the standby must not fail to apply it. Furthermore, allowing WAL application to wait indefinitely may be very undesirable, because the standby's state will become increasingly far behind the primary's. Therefore, a mechanism is provided to forcibly cancel standby queries that conflict with to-be-applied WAL records.</source>
          <target state="translated">기본 서버에서 이러한 경우는 단순히 대기 상태가됩니다. 사용자는 충돌하는 동작 중 하나를 취소하도록 선택할 수 있습니다. 그러나 대기에서는 선택 사항이 없습니다. WAL 로깅 조치는 기본에서 이미 발생 했으므로 대기를 적용하지 않아야합니다. 또한 WAL 응용 프로그램이 무기한 대기하는 것은 매우 바람직하지 않을 수 있습니다. 대기 상태가 기본 상태보다 점점 더 뒤떨어지기 때문입니다. 따라서 적용 할 WAL 레코드와 충돌하는 대기 쿼리를 강제로 취소하는 메커니즘이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="12047b5caa5d65a62660b71617de0d4a759ef067" translate="yes" xml:space="preserve">
          <source>On the primary, parameters &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; can be used. &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; have no effect if set on the primary.</source>
          <target state="translated">기본에서 &lt;a href=&quot;runtime-config-wal#GUC-WAL-LEVEL&quot;&gt;wal_level&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; 매개 변수를 사용할 수 있습니다. &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; 는 기본에 설정된 경우 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4d2789c0f0275ad798be7e6d4e299236ebe91e1" translate="yes" xml:space="preserve">
          <source>On the publisher side, &lt;code&gt;wal_level&lt;/code&gt; must be set to &lt;code&gt;logical&lt;/code&gt;, and &lt;code&gt;max_replication_slots&lt;/code&gt; must be set to at least the number of subscriptions expected to connect, plus some reserve for table synchronization. And &lt;code&gt;max_wal_senders&lt;/code&gt; should be set to at least the same as &lt;code&gt;max_replication_slots&lt;/code&gt; plus the number of physical replicas that are connected at the same time.</source>
          <target state="translated">게시자 측에서 &lt;code&gt;wal_level&lt;/code&gt; 은 &lt;code&gt;logical&lt;/code&gt; 로 설정해야 하고 &lt;code&gt;max_replication_slots&lt;/code&gt; 는 최소한 연결할 것으로 예상되는 구독 수와 테이블 동기화 예약을 설정해야합니다. 그리고 &lt;code&gt;max_wal_senders&lt;/code&gt; 는 &lt;code&gt;max_replication_slots&lt;/code&gt; 와 동시에 연결된 물리적 복제본 수 에 적어도 동일하게 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="35745b04684e80ded8dc5507c072fa2674283617" translate="yes" xml:space="preserve">
          <source>On the standby, parameters &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt;, &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; can be used. &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; has no effect as long as the server remains in standby mode, though it will become relevant if the standby becomes primary.</source>
          <target state="translated">대기에서는 &lt;a href=&quot;runtime-config-replication#GUC-HOT-STANDBY&quot;&gt;hot_standby&lt;/a&gt; , &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-ARCHIVE-DELAY&quot;&gt;max_standby_archive_delay&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-replication#GUC-MAX-STANDBY-STREAMING-DELAY&quot;&gt;max_standby_streaming_delay&lt;/a&gt; 매개 변수를 사용할 수 있습니다. &lt;a href=&quot;runtime-config-replication#GUC-VACUUM-DEFER-CLEANUP-AGE&quot;&gt;vacuum_defer_cleanup_age&lt;/a&gt; 는 서버가 대기 모드에있는 한 아무런 영향을 미치지 않지만 대기는 기본 서버가되면 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="70715c6fbe3e407765f6386cd308c88b6865cc56" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;UNLISTEN&lt;/code&gt; has been executed, further &lt;code&gt;NOTIFY&lt;/code&gt; messages will be ignored:</source>
          <target state="translated">일단 &lt;code&gt;UNLISTEN&lt;/code&gt; 가 실행 된, 더 &lt;code&gt;NOTIFY&lt;/code&gt; 메시지는 무시됩니다 :</target>
        </trans-unit>
        <trans-unit id="ec65ec416b46f0c02b02945a4d9803e7d39332ca" translate="yes" xml:space="preserve">
          <source>Once a client is connected to the database, PostgreSQL provides two additional SQL commands (and equivalent functions) to interact with session-local configuration settings:</source>
          <target state="translated">클라이언트가 데이터베이스에 연결되면 PostgreSQL은 세션 로컬 구성 설정과 상호 작용하기 위해 두 개의 추가 SQL 명령 (및 동등한 기능)을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="356c49cf82618dc4e123a48d759d153fd0e38847" translate="yes" xml:space="preserve">
          <source>Once a connection is established the client process can send a query to the &lt;em&gt;backend&lt;/em&gt; (server). The query is transmitted using plain text, i.e., there is no parsing done in the &lt;em&gt;frontend&lt;/em&gt; (client). The server parses the query, creates an &lt;em&gt;execution plan&lt;/em&gt;, executes the plan and returns the retrieved rows to the client by transmitting them over the established connection.</source>
          <target state="translated">연결이 설정되면 클라이언트 프로세스는 &lt;em&gt;백엔드&lt;/em&gt; (서버) 로 쿼리를 보낼 수 있습니다 . 쿼리는 일반 텍스트를 사용하여 전송됩니다. 즉, &lt;em&gt;프런트 엔드&lt;/em&gt; (클라이언트) 에서 구문 분석이 수행되지 않습니다 . 서버는 쿼리를 구문 분석하고, &lt;em&gt;실행 계획을&lt;/em&gt; 작성하고 , &lt;em&gt;계획&lt;/em&gt; 을 실행하고, 검색된 행을 설정된 연결을 통해 클라이언트에 전송하여 클라이언트에 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5ad9c4a6213a012c3300efd580e40047d30505b8" translate="yes" xml:space="preserve">
          <source>Once acquired, a lock is normally held till end of transaction. But if a lock is acquired after establishing a savepoint, the lock is released immediately if the savepoint is rolled back to. This is consistent with the principle that &lt;code&gt;ROLLBACK&lt;/code&gt; cancels all effects of the commands since the savepoint. The same holds for locks acquired within a PL/pgSQL exception block: an error escape from the block releases locks acquired within it.</source>
          <target state="translated">일단 획득되면 일반적으로 트랜잭션이 끝날 때까지 잠금이 유지됩니다. 그러나 저장 점을 설정 한 후 잠금이 획득되면 저장 점이 롤백되면 즉시 잠금이 해제됩니다. 이는 &lt;code&gt;ROLLBACK&lt;/code&gt; 이 세이브 포인트 이후 명령의 모든 효과를 취소 한다는 원칙과 일치 합니다. PL / pgSQL 예외 블록 내에서 획득 한 잠금도 마찬가지입니다. 블록에서 오류 이스케이프하면 블록 내에서 획득 한 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e9243ef6651a8f1bff8b046ab3cebbec0d9033" translate="yes" xml:space="preserve">
          <source>Once acquired, a lock is normally held until the end of the transaction. But if a lock is acquired after establishing a savepoint, the lock is released immediately if the savepoint is rolled back to. This is consistent with the principle that &lt;code&gt;ROLLBACK&lt;/code&gt; cancels all effects of the commands since the savepoint. The same holds for locks acquired within a PL/pgSQL exception block: an error escape from the block releases locks acquired within it.</source>
          <target state="translated">일단 획득되면 일반적으로 트랜잭션이 끝날 때까지 잠금이 유지됩니다. 그러나 세이브 포인트를 설정 한 후 잠금을 획득하면 세이브 포인트가 롤백되면 즉시 잠금이 해제됩니다. 이것은 &lt;code&gt;ROLLBACK&lt;/code&gt; 이 저장 점 이후 명령의 모든 효과를 취소 한다는 원칙과 일치 합니다. PL / pgSQL 예외 블록 내에서 획득 한 잠금에 대해서도 동일하게 유지됩니다. 블록의 오류 이스케이프는 내부에서 획득 한 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="41f916b016e9381b5815b3e4089f244578b1cdbc" translate="yes" xml:space="preserve">
          <source>Once an index is created, no further intervention is required: the system will update the index when the table is modified, and it will use the index in queries when it thinks doing so would be more efficient than a sequential table scan. But you might have to run the &lt;code&gt;ANALYZE&lt;/code&gt; command regularly to update statistics to allow the query planner to make educated decisions. See &lt;a href=&quot;https://www.postgresql.org/docs/12/performance-tips.html&quot;&gt;Chapter 14&lt;/a&gt; for information about how to find out whether an index is used and when and why the planner might choose &lt;em&gt;not&lt;/em&gt; to use an index.</source>
          <target state="translated">인덱스가 작성되면 추가 개입이 필요하지 않습니다. 시스템은 테이블이 수정 될 때 인덱스를 업데이트하며, 인덱스가 순차적 인 테이블 스캔보다 더 효율적이라고 생각할 때 쿼리에서 인덱스를 사용합니다. 그러나 쿼리 플래너가 교육 된 결정을 내릴 수 있도록 통계를 업데이트 하려면 &lt;code&gt;ANALYZE&lt;/code&gt; 명령을 정기적으로 실행해야 할 수도 있습니다 . 인덱스 사용 여부 및 플래너가 인덱스를 사용 &lt;em&gt;하지 않기로&lt;/em&gt; 선택할 수있는시기 및 이유에 대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/performance-tips.html&quot;&gt;14 장을&lt;/a&gt; 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="642332a00907b7ff64fd98bc7d16bd9934680cd4" translate="yes" xml:space="preserve">
          <source>Once an index is created, no further intervention is required: the system will update the index when the table is modified, and it will use the index in queries when it thinks doing so would be more efficient than a sequential table scan. But you might have to run the &lt;code&gt;ANALYZE&lt;/code&gt; command regularly to update statistics to allow the query planner to make educated decisions. See &lt;a href=&quot;https://www.postgresql.org/docs/13/performance-tips.html&quot;&gt;Chapter 14&lt;/a&gt; for information about how to find out whether an index is used and when and why the planner might choose &lt;em&gt;not&lt;/em&gt; to use an index.</source>
          <target state="translated">인덱스가 생성되면 추가 개입이 필요하지 않습니다. 시스템은 테이블이 수정 될 때 인덱스를 업데이트하고 순차 테이블 스캔보다 더 효율적이라고 생각할 때 쿼리에서 인덱스를 사용합니다. 그러나 쿼리 플래너가 교육적인 결정을 내릴 수 있도록 통계를 업데이트하기 위해 &lt;code&gt;ANALYZE&lt;/code&gt; 명령을 정기적으로 실행해야 할 수도 있습니다 . 인덱스 사용 여부를 확인하는 방법과 플래너가 인덱스를 사용 &lt;em&gt;하지 않는&lt;/em&gt; 시기와 이유에 대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/13/performance-tips.html&quot;&gt;14 장을&lt;/a&gt; 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e5421d611a483b4f3357d11ff23a5acc44acb58" translate="yes" xml:space="preserve">
          <source>Once any valuable objects have been transferred to new owners, any remaining objects owned by the role-to-be-dropped can be dropped with the &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; command. Again, this command cannot access objects in other databases, so it is necessary to run it in each database that contains objects owned by the role. Also, &lt;code&gt;DROP OWNED&lt;/code&gt; will not drop entire databases or tablespaces, so it is necessary to do that manually if the role owns any databases or tablespaces that have not been transferred to new owners.</source>
          <target state="translated">중요한 객체가 새 소유자에게 전송되면, 삭제할 역할이 소유 한 나머지 객체는 &lt;a href=&quot;sql-drop-owned&quot;&gt;DROP OWNED&lt;/a&gt; 명령 으로 삭제할 수 있습니다 . 이 명령은 다른 데이터베이스의 개체에 액세스 할 수 없으므로 역할이 소유 한 개체가 포함 된 각 데이터베이스에서 실행해야합니다. 또한 &lt;code&gt;DROP OWNED&lt;/code&gt; 는 전체 데이터베이스 또는 테이블 스페이스를 삭제하지 않으므로 역할이 새 소유자에게 전송되지 않은 데이터베이스 또는 테이블 스페이스를 소유 한 경우 수동으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e81389b8f98e0c4fa0978b0ecbccf3ec2c7326c5" translate="yes" xml:space="preserve">
          <source>Once created, a tablespace can be used from any database, provided the requesting user has sufficient privilege. This means that a tablespace cannot be dropped until all objects in all databases using the tablespace have been removed.</source>
          <target state="translated">요청한 사용자에게 충분한 권한이 있으면 테이블 스페이스를 모든 데이터베이스에서 사용할 수 있습니다. 이는 테이블 스페이스를 사용하는 모든 데이터베이스의 모든 오브젝트가 제거 될 때까지 테이블 스페이스를 삭제할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="73da0c6102d03c025cdbc83b1b38fc971869013e" translate="yes" xml:space="preserve">
          <source>Once created, the enum type can be used in table and function definitions much like any other type:</source>
          <target state="translated">생성 된 열거 형은 다른 유형과 마찬가지로 테이블 및 함수 정의에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9f4d5e2b4aa9fc314da7481d260ca60dd53ed46" translate="yes" xml:space="preserve">
          <source>Once failover to the standby occurs, there is only a single server in operation. This is known as a degenerate state. The former standby is now the primary, but the former primary is down and might stay down. To return to normal operation, a standby server must be recreated, either on the former primary system when it comes up, or on a third, possibly new, system. The &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind&lt;/a&gt; utility can be used to speed up this process on large clusters. Once complete, the primary and standby can be considered to have switched roles. Some people choose to use a third server to provide backup for the new primary until the new standby server is recreated, though clearly this complicates the system configuration and operational processes.</source>
          <target state="translated">대기에 대한 장애 조치가 발생하면 운영중인 단일 서버 만 있습니다. 이것을 퇴화 상태라고합니다. 이전 대기는 이제 기본이지만 이전 기본은 다운되어 계속 유지 될 수 있습니다. 정상 작동 상태로 돌아가려면 대기 서버는 이전 기본 시스템이 시작될 때 또는 새 시스템 인 세 번째 시스템에서 다시 작성되어야합니다. &lt;a href=&quot;app-pgrewind&quot;&gt;pg_rewind의&lt;/a&gt; 유틸리티는 대형 클러스터에서이 과정을 빠르게하는 데 사용할 수 있습니다. 완료되면 기본 및 대기가 전환 된 역할을 가진 것으로 간주 될 수 있습니다. 새로운 대기 서버가 재 작성 될 때까지 세 번째 서버를 사용하여 새 기본 서버에 대한 백업을 제공하는 사람들이 있지만 이는 분명히 시스템 구성 및 운영 프로세스를 복잡하게합니다.</target>
        </trans-unit>
        <trans-unit id="99eb90b007ab371c4c054db1b4a14dc72baaf9ae" translate="yes" xml:space="preserve">
          <source>Once prepared, a transaction can later be committed or rolled back with &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt; or &lt;a href=&quot;sql-rollback-prepared&quot;&gt;ROLLBACK PREPARED&lt;/a&gt;, respectively. Those commands can be issued from any session, not only the one that executed the original transaction.</source>
          <target state="translated">일단 준비되면 나중에 &lt;a href=&quot;sql-commit-prepared&quot;&gt;COMMIT PREPARED&lt;/a&gt; 또는 &lt;a href=&quot;sql-rollback-prepared&quot;&gt;ROLLBACK PREPARED&lt;/a&gt; 로 트랜잭션을 커미트하거나 롤백 할 수 있습니다 . 이러한 명령은 원래 트랜잭션을 실행 한 세션뿐만 아니라 모든 세션에서 발행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a26efc323b5a3b586fc58ac6b6adb6fb3937603a" translate="yes" xml:space="preserve">
          <source>Once restored, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; on each database so the optimizer has useful statistics. You can also run &lt;code&gt;vacuumdb -a -z&lt;/code&gt; to analyze all databases.</source>
          <target state="translated">일단 복원되면 옵티마이 &lt;code&gt;ANALYZE&lt;/code&gt; 유용한 통계를 갖도록 각 데이터베이스 에서 ANALYZE 를 실행하는 것이 좋습니다 . &lt;code&gt;vacuumdb -a -z&lt;/code&gt; 를 실행 하여 모든 데이터베이스를 분석 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1c807b866ed2972017d5380e0a876fec0d03a30" translate="yes" xml:space="preserve">
          <source>Once restored, it is wise to run &lt;code&gt;ANALYZE&lt;/code&gt; on each restored table so the optimizer has useful statistics; see &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;Section 24.1.3&lt;/a&gt; and &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;Section 24.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">리스토어 된 후에 는 옵티마이 저가 유용한 통계를 갖도록 각 리스토어 된 테이블 에서 &lt;code&gt;ANALYZE&lt;/code&gt; 를 실행하는 것이 좋습니다 . 참조 &lt;a href=&quot;routine-vacuuming#VACUUM-FOR-STATISTICS&quot;&gt;섹션 24.1.3&lt;/a&gt; 및 &lt;a href=&quot;routine-vacuuming#AUTOVACUUM&quot;&gt;섹션 24.1.6을&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="4f22ae97ca76db6661c3c1f5a88b003eb151976f" translate="yes" xml:space="preserve">
          <source>Once started, &lt;code&gt;pg_upgrade&lt;/code&gt; will verify the two clusters are compatible and then do the upgrade. You can use &lt;code&gt;pg_upgrade --check&lt;/code&gt; to perform only the checks, even if the old server is still running. &lt;code&gt;pg_upgrade --check&lt;/code&gt; will also outline any manual adjustments you will need to make after the upgrade. If you are going to be using link or clone mode, you should use the option &lt;code&gt;--link&lt;/code&gt; or &lt;code&gt;--clone&lt;/code&gt; with &lt;code&gt;--check&lt;/code&gt; to enable mode-specific checks. &lt;code&gt;pg_upgrade&lt;/code&gt; requires write permission in the current directory.</source>
          <target state="translated">시작되면 &lt;code&gt;pg_upgrade&lt;/code&gt; 는 두 클러스터가 호환되는지 확인한 다음 업그레이드를 수행합니다. &lt;code&gt;pg_upgrade --check&lt;/code&gt; 를 사용 하면 기존 서버가 여전히 실행중인 경우에도 검사 만 수행 할 수 있습니다 . &lt;code&gt;pg_upgrade --check&lt;/code&gt; 는 업그레이드 후 수행해야 할 수동 조정 사항도 간략하게 보여줍니다. 당신이 링크 또는 복제 모드를 사용하려는 경우, 당신은 옵션을 사용해야합니다 &lt;code&gt;--link&lt;/code&gt; 또는 &lt;code&gt;--clone&lt;/code&gt; 와 &lt;code&gt;--check&lt;/code&gt; 을 모드 별 검사를 가능하게 할 수 있습니다. &lt;code&gt;pg_upgrade&lt;/code&gt; 는 현재 디렉토리에서 쓰기 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c713ae812f1782bcff8d86ab36ed9c6d151c330d" translate="yes" xml:space="preserve">
          <source>Once streaming replication has been configured, configuring synchronous replication requires only one additional configuration step: &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; must be set to a non-empty value. &lt;code&gt;synchronous_commit&lt;/code&gt; must also be set to &lt;code&gt;on&lt;/code&gt;, but since this is the default value, typically no change is required. (See &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-SETTINGS&quot;&gt;Section 19.5.1&lt;/a&gt; and &lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-MASTER&quot;&gt;Section 19.6.2&lt;/a&gt;.) This configuration will cause each commit to wait for confirmation that the standby has written the commit record to durable storage. &lt;code&gt;synchronous_commit&lt;/code&gt; can be set by individual users, so it can be configured in the configuration file, for particular users or databases, or dynamically by applications, in order to control the durability guarantee on a per-transaction basis.</source>
          <target state="translated">스트리밍 복제가 구성된 후에는 동기 복제를 구성하는 데 하나의 추가 구성 단계 만 필요합니다. &lt;a href=&quot;runtime-config-replication#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;synchronous_standby_names&lt;/a&gt; 는 비어 있지 않은 값으로 설정해야합니다. &lt;code&gt;synchronous_commit&lt;/code&gt; 도 &lt;code&gt;on&lt;/code&gt; 으로 설정해야 하지만 이것이 기본값이므로 일반적으로 변경하지 않아도됩니다. ( &lt;a href=&quot;runtime-config-wal#RUNTIME-CONFIG-WAL-SETTINGS&quot;&gt;19.5.1 절&lt;/a&gt; 및 &lt;a href=&quot;runtime-config-replication#RUNTIME-CONFIG-REPLICATION-MASTER&quot;&gt;19.6.2 &lt;/a&gt;절 참조 )이 구성은 각 확약이 대기가 확약 레코드를 내구성있는 저장 영역에 기록했음을 확인하기 위해 대기합니다. &lt;code&gt;synchronous_commit&lt;/code&gt; 개별 사용자에 의해 설정 될 수 있으므로 트랜잭션별로 내구성 보증을 제어하기 위해 구성 파일, 특정 사용자 또는 데이터베이스에 대해 또는 응용 프로그램에 의해 동적으로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9871853da7c650c2f0dd2795f59e948ae7531634" translate="yes" xml:space="preserve">
          <source>Once the WAL segment files active during the backup are archived, you are done. The file identified by &lt;code&gt;pg_stop_backup&lt;/code&gt;'s first return value is the last segment that is required to form a complete set of backup files. On a primary, if &lt;code&gt;archive_mode&lt;/code&gt; is enabled and the &lt;code&gt;wait_for_archive&lt;/code&gt; parameter is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;pg_stop_backup&lt;/code&gt; does not return until the last segment has been archived. On a standby, &lt;code&gt;archive_mode&lt;/code&gt; must be &lt;code&gt;always&lt;/code&gt; in order for &lt;code&gt;pg_stop_backup&lt;/code&gt; to wait. Archiving of these files happens automatically since you have already configured &lt;code&gt;archive_command&lt;/code&gt;. In most cases this happens quickly, but you are advised to monitor your archive system to ensure there are no delays. If the archive process has fallen behind because of failures of the archive command, it will keep retrying until the archive succeeds and the backup is complete. If you wish to place a time limit on the execution of &lt;code&gt;pg_stop_backup&lt;/code&gt;, set an appropriate &lt;code&gt;statement_timeout&lt;/code&gt; value, but make note that if &lt;code&gt;pg_stop_backup&lt;/code&gt; terminates because of this your backup may not be valid.</source>
          <target state="translated">백업 중에 활성화 된 WAL 세그먼트 파일이 아카이브되면 완료됩니다. &lt;code&gt;pg_stop_backup&lt;/code&gt; 의 첫 번째 반환 값으로 식별되는 파일 은 전체 백업 파일 세트를 형성하는 데 필요한 마지막 세그먼트입니다. 기본에서 &lt;code&gt;archive_mode&lt;/code&gt; 가 사용 가능하고 &lt;code&gt;wait_for_archive&lt;/code&gt; 매개 변수가 &lt;code&gt;true&lt;/code&gt; 인 경우 마지막 세그먼트가 아카이브 될 때까지 &lt;code&gt;pg_stop_backup&lt;/code&gt; 이 리턴되지 않습니다. 대기에서 &lt;code&gt;pg_stop_backup&lt;/code&gt; 이 대기 하려면 &lt;code&gt;archive_mode&lt;/code&gt; 가 &lt;code&gt;always&lt;/code&gt; 있어야합니다 . &lt;code&gt;archive_command&lt;/code&gt; 를 이미 구성 했으므로 이러한 파일의 아카이브는 자동으로 수행됩니다.. 대부분의 경우이 문제는 빠르게 발생하지만 지연이 없도록 보관 시스템을 모니터링하는 것이 좋습니다. 아카이브 명령의 실패로 인해 아카이브 프로세스가 실패한 경우 아카이브가 성공하고 백업이 완료 될 때까지 계속 재 시도합니다. &lt;code&gt;pg_stop_backup&lt;/code&gt; 실행에 시간 제한을 설정하려면 적절한 &lt;code&gt;statement_timeout&lt;/code&gt; 값을 설정 하되 이로 인해 &lt;code&gt;pg_stop_backup&lt;/code&gt; 이 종료 되면 백업이 유효하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32e5f3f159f9a76e583d7e4dd4b47490f3262b2b" translate="yes" xml:space="preserve">
          <source>Once the WAL segment files active during the backup are archived, you are done. The file identified by &lt;code&gt;pg_stop_backup&lt;/code&gt;'s result is the last segment that is required to form a complete set of backup files. If &lt;code&gt;archive_mode&lt;/code&gt; is enabled, &lt;code&gt;pg_stop_backup&lt;/code&gt; does not return until the last segment has been archived. Archiving of these files happens automatically since you have already configured &lt;code&gt;archive_command&lt;/code&gt;. In most cases this happens quickly, but you are advised to monitor your archive system to ensure there are no delays. If the archive process has fallen behind because of failures of the archive command, it will keep retrying until the archive succeeds and the backup is complete.</source>
          <target state="translated">백업 중에 활성화 된 WAL 세그먼트 파일이 아카이브되면 완료됩니다. &lt;code&gt;pg_stop_backup&lt;/code&gt; 의 결과로 식별 된 파일 은 전체 백업 파일 세트를 형성하는 데 필요한 마지막 세그먼트입니다. 경우 &lt;code&gt;archive_mode&lt;/code&gt; 가 활성화되어, &lt;code&gt;pg_stop_backup&lt;/code&gt; 는 마지막 세그먼트가 보관 될 때까지 반환하지 않습니다. 이러한 파일의 아카이브는 &lt;code&gt;archive_command&lt;/code&gt; 를 이미 구성 했으므로 자동으로 수행됩니다 . 대부분의 경우이 문제는 빠르게 발생하지만 지연이 없도록 보관 시스템을 모니터링하는 것이 좋습니다. 아카이브 명령의 실패로 인해 아카이브 프로세스가 실패한 경우 아카이브가 성공하고 백업이 완료 될 때까지 계속 재 시도합니다.</target>
        </trans-unit>
        <trans-unit id="5f47c9896865faba1d610987fd3b05badac486b3" translate="yes" xml:space="preserve">
          <source>Once the delay specified by &lt;code&gt;max_standby_archive_delay&lt;/code&gt; or &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; has been exceeded, conflicting queries will be canceled. This usually results just in a cancellation error, although in the case of replaying a &lt;code&gt;DROP DATABASE&lt;/code&gt; the entire conflicting session will be terminated. Also, if the conflict is over a lock held by an idle transaction, the conflicting session is terminated (this behavior might change in the future).</source>
          <target state="translated">&lt;code&gt;max_standby_archive_delay&lt;/code&gt; 또는 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 에 의해 지정된 지연 이 초과되면 충돌하는 쿼리가 취소됩니다. &lt;code&gt;DROP DATABASE&lt;/code&gt; 를 재생하는 경우 전체 충돌 세션이 종료 되지만 일반적으로 취소 오류가 발생 합니다. 또한 충돌이 유휴 트랜잭션에 의해 보유 된 잠금을 초과하면 충돌 세션이 종료됩니다 (이 동작은 나중에 변경 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="b8e1074216e0451321cd3f251827b2e9872eaede" translate="yes" xml:space="preserve">
          <source>Once the group role exists, you can add and remove members using the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; and &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; commands:</source>
          <target state="translated">그룹 역할이 존재하면 &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; 및 &lt;a href=&quot;sql-revoke&quot;&gt;REVOKE&lt;/a&gt; 명령을 사용하여 구성원을 추가 및 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69a71607e88d378416ed92ac7ffd6286dc445378" translate="yes" xml:space="preserve">
          <source>Once you are satisfied with the upgrade, you can delete the old cluster's data directories by running the script mentioned when &lt;code&gt;pg_upgrade&lt;/code&gt; completes. (Automatic deletion is not possible if you have user-defined tablespaces inside the old data directory.) You can also delete the old installation directories (e.g. &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;share&lt;/code&gt;).</source>
          <target state="translated">업그레이드에 만족하면 &lt;code&gt;pg_upgrade&lt;/code&gt; 가 완료 될 때 언급 된 스크립트를 실행하여 이전 클러스터의 데이터 디렉토리를 삭제할 수 있습니다 . (이전 데이터 디렉토리 내에 사용자 정의 테이블 스페이스가있는 경우 자동 삭제가 불가능합니다.) 이전 설치 디렉토리 (예 : &lt;code&gt;bin&lt;/code&gt; , &lt;code&gt;share&lt;/code&gt; )를 삭제할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddbea494f64cf75943b4997efd25a70a79386e0d" translate="yes" xml:space="preserve">
          <source>Once you are satisfied with the upgrade, you can delete the old cluster's data directories by running the script mentioned when &lt;code&gt;pg_upgrade&lt;/code&gt; completes. (Automatic deletion is not possible if you have user-defined tablespaces inside the old data directory.) You can also delete the old installation directories (e.g., &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;share&lt;/code&gt;).</source>
          <target state="translated">업그레이드에 만족하면 &lt;code&gt;pg_upgrade&lt;/code&gt; 가 완료 될 때 언급 된 스크립트를 실행하여 이전 클러스터의 데이터 디렉토리를 삭제할 수 있습니다 . (이전 데이터 디렉토리 내에 사용자 정의 테이블 스페이스가있는 경우 자동 삭제가 불가능합니다.) 이전 설치 디렉토리 (예 : &lt;code&gt;bin&lt;/code&gt; , &lt;code&gt;share&lt;/code&gt; )를 삭제할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5a7bdde6e82e682c3584d24535e62c92a86edd3" translate="yes" xml:space="preserve">
          <source>Once you have created a database, you can access it by:</source>
          <target state="translated">데이터베이스를 작성하면 다음을 통해 데이터베이스에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a17a3f555279791537a8bafe938cf8c6379fa784" translate="yes" xml:space="preserve">
          <source>Once you have done the necessary setup, you can run your benchmark with a command that doesn't include &lt;code&gt;-i&lt;/code&gt;, that is</source>
          <target state="translated">당신이 필요한 설정을 완료 한 후에는 포함되지 않은 명령으로 벤치 마크를 실행할 수 있습니다 &lt;code&gt;-i&lt;/code&gt; 를 즉,</target>
        </trans-unit>
        <trans-unit id="61eda2a3b905b905ee98026b455b6eb92908a307" translate="yes" xml:space="preserve">
          <source>One &lt;code&gt;postgres&lt;/code&gt; instance always manages the data of exactly one database cluster. A database cluster is a collection of databases that is stored at a common file system location (the &amp;ldquo;data area&amp;rdquo;). More than one &lt;code&gt;postgres&lt;/code&gt; instance can run on a system at one time, so long as they use different data areas and different communication ports (see below). When &lt;code&gt;postgres&lt;/code&gt; starts it needs to know the location of the data area. The location must be specified by the &lt;code&gt;-D&lt;/code&gt; option or the &lt;code&gt;PGDATA&lt;/code&gt; environment variable; there is no default. Typically, &lt;code&gt;-D&lt;/code&gt; or &lt;code&gt;PGDATA&lt;/code&gt; points directly to the data area directory created by &lt;a href=&quot;app-initdb&quot;&gt;initdb&lt;/a&gt;. Other possible file layouts are discussed in &lt;a href=&quot;runtime-config-file-locations&quot;&gt;Section 19.2&lt;/a&gt;.</source>
          <target state="translated">하나의 &lt;code&gt;postgres&lt;/code&gt; 인스턴스는 항상 정확히 하나의 데이터베이스 클러스터의 데이터를 관리합니다. 데이터베이스 클러스터는 공통 파일 시스템 위치 ( &quot;데이터 영역&quot;)에 저장된 데이터베이스 모음입니다. 서로 다른 데이터 영역과 다른 통신 포트를 사용하는 한 시스템에서 한 번에 둘 이상의 &lt;code&gt;postgres&lt;/code&gt; 인스턴스를 실행할 수 있습니다 (아래 참조). &lt;code&gt;postgres&lt;/code&gt; 가 시작 되면 데이터 영역의 위치를 ​​알아야합니다. 위치는 &lt;code&gt;-D&lt;/code&gt; 옵션 또는 &lt;code&gt;PGDATA&lt;/code&gt; 환경 변수 로 지정해야합니다 . 기본값이 없습니다. 일반적으로 &lt;code&gt;-D&lt;/code&gt; 또는 &lt;code&gt;PGDATA&lt;/code&gt; 는 &lt;a href=&quot;app-initdb&quot;&gt;initdb에&lt;/a&gt; 의해 작성된 데이터 영역 디렉토리를 직접 가리 킵니다.. 다른 가능한 파일 레이아웃은 &lt;a href=&quot;runtime-config-file-locations&quot;&gt;섹션 19.2&lt;/a&gt; 에서 논의됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d2b8f4e1b139546c73a22f8f91fadc862c3170c" translate="yes" xml:space="preserve">
          <source>One advantage of GIN is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert. This is much the same advantage as using GiST.</source>
          <target state="translated">GIN의 한 가지 장점은 데이터베이스 전문가가 아닌 데이터 유형의 도메인 전문가가 적절한 액세스 방법으로 사용자 정의 데이터 유형을 개발할 수 있다는 것입니다. 이것은 GiST를 사용하는 것과 거의 같은 이점입니다.</target>
        </trans-unit>
        <trans-unit id="e058cfc0d2adb864aa10f7c9c5f44bcfe8be50f0" translate="yes" xml:space="preserve">
          <source>One advantage of GiST is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</source>
          <target state="translated">GiST의 장점 중 하나는 데이터베이스 전문가가 아닌 데이터 유형의 도메인 전문가가 적절한 액세스 방법으로 사용자 정의 데이터 유형을 개발할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f48b87ea34b25adefa4f3efa4a97db47fb753d95" translate="yes" xml:space="preserve">
          <source>One advantage of the separate-column approach over an expression index is that it is not necessary to explicitly specify the text search configuration in queries in order to make use of the index. As shown in the example above, the query can depend on &lt;code&gt;default_text_search_config&lt;/code&gt;. Another advantage is that searches will be faster, since it will not be necessary to redo the &lt;code&gt;to_tsvector&lt;/code&gt; calls to verify index matches. (This is more important when using a GiST index than a GIN index; see &lt;a href=&quot;textsearch-indexes&quot;&gt;Section 12.9&lt;/a&gt;.) The expression-index approach is simpler to set up, however, and it requires less disk space since the &lt;code&gt;tsvector&lt;/code&gt; representation is not stored explicitly.</source>
          <target state="translated">식 인덱스에 대한 개별 열 방식의 한 가지 장점은 인덱스를 사용하기 위해 쿼리에서 텍스트 검색 구성을 명시 적으로 지정할 필요가 없다는 것입니다. 위의 예와 같이 쿼리는 &lt;code&gt;default_text_search_config&lt;/code&gt; 에 따라 달라질 수 있습니다 . 또 다른 장점은 인덱스 일치를 확인하기 위해 &lt;code&gt;to_tsvector&lt;/code&gt; 호출을 다시 실행할 필요가 없기 때문에 검색 속도가 더 빠릅니다 . (GIN 인덱스보다 GiST 인덱스를 사용할 때 더 중요합니다 . &lt;a href=&quot;textsearch-indexes&quot;&gt;섹션 12.9&lt;/a&gt; 참조 ) expression-index 접근 방식은 설정이 더 간단하지만 &lt;code&gt;tsvector&lt;/code&gt; 표현이 명시 적으로 저장되지 않기 때문에 디스크 공간이 더 적게 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c591e2a82e983192d18fdc29edda9221e37c6723" translate="yes" xml:space="preserve">
          <source>One advantage of using concatenation in the vector form, rather than concatenating text before applying &lt;code&gt;to_tsvector&lt;/code&gt;, is that you can use different configurations to parse different sections of the document. Also, because the &lt;code&gt;setweight&lt;/code&gt; function marks all lexemes of the given vector the same way, it is necessary to parse the text and do &lt;code&gt;setweight&lt;/code&gt; before concatenating if you want to label different parts of the document with different weights.</source>
          <target state="translated">&lt;code&gt;to_tsvector&lt;/code&gt; 를 적용하기 전에 텍스트를 연결하지 않고 벡터 형식으로 연결을 사용하는 한 가지 장점은 다른 구성을 사용하여 문서의 다른 섹션을 구문 분석 할 수 있다는 것입니다. 또한 &lt;code&gt;setweight&lt;/code&gt; 함수는 주어진 벡터의 모든 텍스쳐를 동일한 방식 으로 표시하므로 문서의 다른 부분에 다른 가중치를 부여하려면 연결하기 전에 텍스트를 구문 분석하고 &lt;code&gt;setweight&lt;/code&gt; 를 수행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7aa492c47d8ea5d45e5da9a09ed3c6c96f7a96e5" translate="yes" xml:space="preserve">
          <source>One application of the rewrite system is in the realization of &lt;em&gt;views&lt;/em&gt;. Whenever a query against a view (i.e., a &lt;em&gt;virtual table&lt;/em&gt;) is made, the rewrite system rewrites the user's query to a query that accesses the &lt;em&gt;base tables&lt;/em&gt; given in the &lt;em&gt;view definition&lt;/em&gt; instead.</source>
          <target state="translated">재 작성 시스템의 하나의 응용은 &lt;em&gt;뷰&lt;/em&gt; 구현에있다 . 뷰 (즉, &lt;em&gt;가상 테이블&lt;/em&gt; ) 에 대한 쿼리가 작성 될 때마다 다시 쓰기 시스템은 대신 사용자 &lt;em&gt;정의&lt;/em&gt; 쿼리를 &lt;em&gt;뷰 정의에&lt;/em&gt; 제공된 &lt;em&gt;기본 테이블에&lt;/em&gt; 액세스하는 쿼리에 다시 씁니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bee7fd28573b33fce2d46ef1ac5fa8251ec94562" translate="yes" xml:space="preserve">
          <source>One component of the statistics is the total number of entries in each table and index, as well as the number of disk blocks occupied by each table and index. This information is kept in the table &lt;a href=&quot;catalog-pg-class&quot;&gt;&lt;code&gt;pg_class&lt;/code&gt;&lt;/a&gt;, in the columns &lt;code&gt;reltuples&lt;/code&gt; and &lt;code&gt;relpages&lt;/code&gt;. We can look at it with queries similar to this one:</source>
          <target state="translated">통계의 한 구성 요소는 각 테이블 및 인덱스의 총 항목 수와 각 테이블 및 인덱스가 차지하는 디스크 블록 수입니다. 이 정보는 &lt;code&gt;reltuples&lt;/code&gt; 및 &lt;code&gt;relpages&lt;/code&gt; 열의 &lt;a href=&quot;catalog-pg-class&quot;&gt; &lt;code&gt;pg_class&lt;/code&gt; &lt;/a&gt; 테이블에 보관됩니다 . 다음과 비슷한 쿼리로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bd99552b099beafc96cbe7829988f7a06eb967b" translate="yes" xml:space="preserve">
          <source>One convenient way to create a compatible table that will later be made a new child is to use the &lt;code&gt;LIKE&lt;/code&gt; clause in &lt;code&gt;CREATE TABLE&lt;/code&gt;. This creates a new table with the same columns as the source table. If there are any &lt;code&gt;CHECK&lt;/code&gt; constraints defined on the source table, the &lt;code&gt;INCLUDING CONSTRAINTS&lt;/code&gt; option to &lt;code&gt;LIKE&lt;/code&gt; should be specified, as the new child must have constraints matching the parent to be considered compatible.</source>
          <target state="translated">나중에 새 자식이 될 호환 테이블을 작성하는 편리한 방법 중 하나 는 &lt;code&gt;CREATE TABLE&lt;/code&gt; 에서 &lt;code&gt;LIKE&lt;/code&gt; 절 을 사용하는 것 입니다. 소스 테이블과 동일한 열이있는 새 테이블이 작성됩니다. 소스 테이블에 정의 된 &lt;code&gt;CHECK&lt;/code&gt; 제한 조건 이있는 경우 새 하위는 호환 가능한 것으로 간주되는 상위와 일치하는 제한 조건을 가져야하므로 &lt;code&gt;INCLUDING CONSTRAINTS&lt;/code&gt; 옵션을 &lt;code&gt;LIKE&lt;/code&gt; 로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="313d199647b14e908c91b6831b2ac1803fbc36c9" translate="yes" xml:space="preserve">
          <source>One could accomplish the same thing with, say,</source>
          <target state="translated">예를 들어 같은 일을 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7bcb03e673340a4965d50eadd319bf1730dddebc" translate="yes" xml:space="preserve">
          <source>One disadvantage of decreasing &lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; is that it might cause &lt;code&gt;VACUUM&lt;/code&gt; to do useless work: freezing a row version is a waste of time if the row is modified soon thereafter (causing it to acquire a new XID). So the setting should be large enough that rows are not frozen until they are unlikely to change any more.</source>
          <target state="translated">&lt;code&gt;vacuum_freeze_min_age&lt;/code&gt; 를 줄이는 데 따른 한 가지 단점은 &lt;code&gt;VACUUM&lt;/code&gt; 이 쓸모없는 작업을 수행 할 수 있다는 것입니다. 즉 , 행 버전을 중지하면 곧 행을 수정하면 새 XID를 얻게되므로 시간이 낭비됩니다. 따라서 설정이 더 이상 변경되지 않을 때까지 행이 고정되지 않도록 충분히 커야합니다.</target>
        </trans-unit>
        <trans-unit id="d99c8486b08ccc8839ea87cdfcd9e4516a4d63fc" translate="yes" xml:space="preserve">
          <source>One disadvantage of the longitude/latitude representation is that you need to be careful about the edge conditions near the poles and near +/- 180 degrees of longitude. The &lt;code&gt;cube&lt;/code&gt;-based representation avoids these discontinuities.</source>
          <target state="translated">경도 / 위도 표현의 한 가지 단점은 극 근처와 경도 +/- 180도 근처의 가장자리 조건에주의해야한다는 것입니다. &lt;code&gt;cube&lt;/code&gt; 기반의 표현은 이러한 불연속성을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17918ae437c6b6c4eb55d620ac26a6167c3d73b5" translate="yes" xml:space="preserve">
          <source>One example use of this mechanism is to copy the contents of a file into a table column. First load the file into a variable and then interpolate the variable's value as a quoted string:</source>
          <target state="translated">이 메커니즘을 사용하는 한 가지 예는 파일 내용을 테이블 열에 복사하는 것입니다. 먼저 파일을 변수에로드 한 다음 변수의 값을 따옴표로 묶은 문자열로 보간하십시오.</target>
        </trans-unit>
        <trans-unit id="11e396823958b9942ef20dabe2804d32c8c47de7" translate="yes" xml:space="preserve">
          <source>One fairly large constraint of the table access method API is that, currently, if the AM wants to support modifications and/or indexes, it is necessary for each tuple to have a tuple identifier (TID) consisting of a block number and an item number (see also &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;). It is not strictly necessary that the sub-parts of TIDs have the same meaning they e.g. have for &lt;code&gt;heap&lt;/code&gt;, but if bitmap scan support is desired (it is optional), the block number needs to provide locality.</source>
          <target state="translated">테이블 액세스 방법 API의 상당히 큰 제약 중 하나는 현재 AM이 수정 및 / 또는 인덱스를 지원하려는 경우 각 튜플에 블록 번호와 항목 번호로 구성된 튜플 식별자 (TID)가 있어야한다는 것입니다. ( &lt;a href=&quot;storage-page-layout&quot;&gt;섹션 68.6&lt;/a&gt; 참조 ). TID의 하위 부분이 예를 들어 &lt;code&gt;heap&lt;/code&gt; 과 동일한 의미를 가질 필요 는 없지만 비트 맵 스캔 지원이 필요한 경우 (선택적임) 블록 번호는 로컬 성을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0040d1980e299cbab932d09606b61e2f45cdab4" translate="yes" xml:space="preserve">
          <source>One fairly large constraint of the table access method API is that, currently, if the AM wants to support modifications and/or indexes, it is necessary for each tuple to have a tuple identifier (TID) consisting of a block number and an item number (see also &lt;a href=&quot;storage-page-layout&quot;&gt;Section 68.6&lt;/a&gt;). It is not strictly necessary that the sub-parts of TIDs have the same meaning they e.g., have for &lt;code&gt;heap&lt;/code&gt;, but if bitmap scan support is desired (it is optional), the block number needs to provide locality.</source>
          <target state="translated">테이블 액세스 방법 API의 상당히 큰 제약은 현재 AM이 수정 및 / 또는 인덱스를 지원하려면 각 튜플이 블록 번호와 항목 번호로 구성된 튜플 식별자 (TID)를 가져야한다는 것입니다. ( &lt;a href=&quot;storage-page-layout&quot;&gt;섹션 68.6&lt;/a&gt; 참조 ). TID의 하위 부분이 예를 들어 &lt;code&gt;heap&lt;/code&gt; 과 같은 의미를 가질 필요 는 없지만 비트 맵 스캔 지원이 필요한 경우 (선택 사항) 블록 번호는 지역성을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea6157e87abd7338811eb2303b2c46792b171e86" translate="yes" xml:space="preserve">
          <source>One major reason for using a partial index is to avoid indexing common values. Since a query searching for a common value (one that accounts for more than a few percent of all the table rows) will not use the index anyway, there is no point in keeping those rows in the index at all. This reduces the size of the index, which will speed up those queries that do use the index. It will also speed up many table update operations because the index does not need to be updated in all cases. &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX1&quot;&gt;Example 11.1&lt;/a&gt; shows a possible application of this idea.</source>
          <target state="translated">부분 인덱스를 사용하는 주요 이유 중 하나는 공통 값을 인덱싱하지 않기위한 것입니다. 공통 값 (모든 테이블 행의 몇 퍼센트를 차지하는 값)을 검색하는 쿼리는 어쨌든 인덱스를 사용하지 않으므로 해당 행을 인덱스에 전혀 유지할 필요가 없습니다. 이렇게하면 인덱스 크기가 줄어들어 인덱스를 사용하는 쿼리 속도가 빨라집니다. 또한 모든 경우에 인덱스를 업데이트 할 필요가 없기 때문에 많은 테이블 업데이트 작업의 속도가 빨라집니다. &lt;a href=&quot;indexes-partial#INDEXES-PARTIAL-EX1&quot;&gt;Example 11.1&lt;/a&gt; 은이 아이디어의 가능한 적용을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d407807dcbba44e4e2aa91e451040ac8b91fe898" translate="yes" xml:space="preserve">
          <source>One might need to insert a large amount of data when first populating a database. This section contains some suggestions on how to make this process as efficient as possible.</source>
          <target state="translated">데이터베이스를 처음 채울 때 많은 양의 데이터를 삽입해야 할 수도 있습니다. 이 섹션에는이 프로세스를 가능한 효율적으로 만드는 방법에 대한 몇 가지 제안이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="af46cf06b4b2b1ea8a95f9146c144e8cb5a4d7fb" translate="yes" xml:space="preserve">
          <source>One must have the PostgreSQL superuser privilege to register a new language or change an existing language's parameters. However, once the language is created it is valid to assign ownership of it to a non-superuser, who may then drop it, change its permissions, rename it, or assign it to a new owner. (Do not, however, assign ownership of the underlying C functions to a non-superuser; that would create a privilege escalation path for that user.)</source>
          <target state="translated">새 언어를 등록하거나 기존 언어의 매개 변수를 변경하려면 PostgreSQL 수퍼 유저 권한이 있어야합니다. 그러나 언어가 생성 된 후에는 비 슈퍼 유저에게 해당 언어의 소유권을 할당하는 것이 유효합니다. 그러면 해당 언어를 삭제하거나 권한을 변경하거나 이름을 바꾸거나 새 소유자에게 할당 할 수 있습니다. (그러나 기본 C 함수의 소유권을 수퍼 유저가 아닌 사용자에게 할당하지 마십시오. 그러면 해당 사용자에 대한 권한 에스컬레이션 경로가 생성됩니다.)</target>
        </trans-unit>
        <trans-unit id="b8bb08b9cf98dd6c73c6dc0c7e52247a78ee67c4" translate="yes" xml:space="preserve">
          <source>One of</source>
          <target state="translated">중 하나</target>
        </trans-unit>
        <trans-unit id="0e3d57db8bbc433a035cda8e815f996da30de43e" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, or &lt;code&gt;TRUNCATE&lt;/code&gt;; this specifies the event that will fire the trigger. Multiple events can be specified using &lt;code&gt;OR&lt;/code&gt;, except when transition relations are requested.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; 또는 &lt;code&gt;TRUNCATE&lt;/code&gt; 중 하나입니다 . 트리거를 발생시키는 이벤트를 지정합니다. 전이 관계가 요청되는 경우를 제외하고 &lt;code&gt;OR&lt;/code&gt; 를 사용하여 여러 이벤트를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5e814c340c50927afd7b76075dffb81341dc8b6" translate="yes" xml:space="preserve">
          <source>One of several disjoint (not overlapping) subsets of a larger set.</source>
          <target state="translated">더 큰 집합의 여러 분리 된 (겹치지 않는) 하위 집합 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="1d58cd9872ba6b984b5aaf4db1dd4f254a5318e3" translate="yes" xml:space="preserve">
          <source>One of the most critical design decisions will be the column or columns by which you partition your data. Often the best choice will be to partition by the column or set of columns which most commonly appear in &lt;code&gt;WHERE&lt;/code&gt; clauses of queries being executed on the partitioned table. &lt;code&gt;WHERE&lt;/code&gt; clause items that match and are compatible with the partition key can be used to prune unneeded partitions. However, you may be forced into making other decisions by requirements for the &lt;code&gt;PRIMARY KEY&lt;/code&gt; or a &lt;code&gt;UNIQUE&lt;/code&gt; constraint. Removal of unwanted data is also a factor to consider when planning your partitioning strategy. An entire partition can be detached fairly quickly, so it may be beneficial to design the partition strategy in such a way that all data to be removed at once is located in a single partition.</source>
          <target state="translated">가장 중요한 디자인 결정 중 하나는 데이터를 분할하는 열입니다. 가장 좋은 선택은 파티션 된 테이블에서 실행되는 쿼리의 &lt;code&gt;WHERE&lt;/code&gt; 절에 가장 일반적으로 나타나는 열 또는 열 세트로 파티션하는 것입니다. 파티션 키와 일치하고 호환되는 &lt;code&gt;WHERE&lt;/code&gt; 절 항목을 사용하여 불필요한 파티션을 제거 할 수 있습니다. 그러나 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 또는 &lt;code&gt;UNIQUE&lt;/code&gt; 요구 사항에 따라 다른 결정을 내려야 할 수도 있습니다.강제. 원하지 않는 데이터를 제거하는 것도 파티셔닝 전략을 계획 할 때 고려해야 할 요소입니다. 전체 파티션을 상당히 빠르게 분리 할 수 ​​있으므로 한 번에 제거 할 모든 데이터가 단일 파티션에있는 방식으로 파티션 전략을 설계하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="511f9e4f8bd3667e3b6d755989f295209cbb7bb6" translate="yes" xml:space="preserve">
          <source>One of the obvious uses for &lt;code&gt;file_fdw&lt;/code&gt; is to make the PostgreSQL activity log available as a table for querying. To do this, first you must be &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;logging to a CSV file,&lt;/a&gt; which here we will call &lt;code&gt;pglog.csv&lt;/code&gt;. First, install &lt;code&gt;file_fdw&lt;/code&gt; as an extension:</source>
          <target state="translated">&lt;code&gt;file_fdw&lt;/code&gt; 의 명백한 용도 중 하나는 PostgreSQL 활동 로그를 쿼리 용 테이블로 사용할 수 있도록하는 것입니다. 이렇게하려면 먼저 &lt;a href=&quot;runtime-config-logging#RUNTIME-CONFIG-LOGGING-CSVLOG&quot;&gt;CSV 파일에 로깅&lt;/a&gt; 해야합니다 . &lt;code&gt;pglog.csv&lt;/code&gt; 라고 합니다 . 먼저 &lt;code&gt;file_fdw&lt;/code&gt; 를 확장으로 설치 합니다.</target>
        </trans-unit>
        <trans-unit id="dd64b8780a8987f51d6cf827b3649d1c335b7dcc" translate="yes" xml:space="preserve">
          <source>One of the obvious uses for &lt;code&gt;file_fdw&lt;/code&gt; is to make the PostgreSQL activity log available as a table for querying. To do this, first you must be logging to a CSV file, which here we will call &lt;code&gt;pglog.csv&lt;/code&gt;. First, install &lt;code&gt;file_fdw&lt;/code&gt; as an extension:</source>
          <target state="translated">&lt;code&gt;file_fdw&lt;/code&gt; 의 명백한 용도 중 하나는 PostgreSQL 활동 로그를 쿼리 테이블로 사용할 수있게하는 것입니다. 이렇게하려면 먼저 CSV 파일에 로깅해야합니다 . 여기서 &lt;code&gt;pglog.csv&lt;/code&gt; 라고 합니다 . 먼저, &lt;code&gt;file_fdw&lt;/code&gt; 를 확장으로 설치 하십시오 :</target>
        </trans-unit>
        <trans-unit id="01a9a0754bb2d47df04d6f754f8a9d26cef931fd" translate="yes" xml:space="preserve">
          <source>One of the problems with the JDBC driver (and this affects the ODBC driver also), is that the specification assumes that references to BLOBs (Binary Large OBjects) are stored within a table, and if that entry is changed, the associated BLOB is deleted from the database.</source>
          <target state="translated">JDBC 드라이버의 문제점 중 하나 (이는 ODBC 드라이버에도 영향을 미침)는 스펙이 BLOB (Binary Large OBjects)에 대한 참조가 테이블에 저장되어 있다고 가정하고 해당 항목이 변경되면 연관된 BLOB가 삭제된다는 것입니다. 데이터베이스에서.</target>
        </trans-unit>
        <trans-unit id="5e5610f45b959ec0066fbadc6e622bf504204314" translate="yes" xml:space="preserve">
          <source>One of the values estimated by &lt;code&gt;ANALYZE&lt;/code&gt; is the number of distinct values that appear in each column. Because only a subset of the rows are examined, this estimate can sometimes be quite inaccurate, even with the largest possible statistics target. If this inaccuracy leads to bad query plans, a more accurate value can be determined manually and then installed with &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...)&lt;/code&gt; (see &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; 에 의해 추정 된 값 중 하나는 각 열에 나타나는 고유 값의 수입니다. 행의 서브 세트 만 검사하므로 통계 목표가 가장 큰 경우에도이 추정치가 매우 부정확 할 수 있습니다. 이 부정확성으로 인해 잘못된 쿼리 계획이 발생하면보다 정확한 값을 수동으로 결정한 다음 &lt;code&gt;ALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...)&lt;/code&gt; 하여 설치할 수 있습니다 ( &lt;a href=&quot;sql-altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="493483fbe186caeb533f2587ea2f5c9911b94b74" translate="yes" xml:space="preserve">
          <source>One or more server-challenge and client-response message will follow. Each server-challenge is sent in an AuthenticationSASLContinue message, followed by a response from client in an SASLResponse message. The particulars of the messages are mechanism specific.</source>
          <target state="translated">하나 이상의 서버 챌린지 및 클라이언트 응답 메시지가 이어집니다. 각 서버 챌린지는 AuthenticationSASLContinue 메시지로 전송 된 후 SASLResponse 메시지의 클라이언트 응답이 이어집니다. 메시지의 세부 사항은 메커니즘에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="425be19de627a14da7ab3bb185d550dfbfe3423c" translate="yes" xml:space="preserve">
          <source>One parameter is specified per line. The equal sign between name and value is optional. Whitespace is insignificant (except within a quoted parameter value) and blank lines are ignored. Hash marks (&lt;code&gt;#&lt;/code&gt;) designate the remainder of the line as a comment. Parameter values that are not simple identifiers or numbers must be single-quoted. To embed a single quote in a parameter value, write either two quotes (preferred) or backslash-quote. If the file contains multiple entries for the same parameter, all but the last one are ignored.</source>
          <target state="translated">라인 당 하나의 매개 변수가 지정됩니다. 이름과 값 사이의 등호는 선택 사항입니다. 공백은 중요하지 않으며 (인용 된 매개 변수 값을 제외하고) 빈 줄은 무시됩니다. 해시 표시 ( &lt;code&gt;#&lt;/code&gt; )는 줄의 나머지 부분을 주석으로 지정합니다. 간단한 식별자 나 숫자가 아닌 매개 변수 값은 작은 따옴표로 묶어야합니다. 매개 변수 값에 작은 따옴표를 포함 시키려면 두 개의 따옴표 (선호) 또는 백 슬래시 따옴표를 쓰십시오. 파일에 동일한 매개 변수에 대한 여러 항목이 포함 된 경우 마지막 항목을 제외한 모든 항목이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="71b216cd8704d27b44cb581f634267f6e26f6ef5" translate="yes" xml:space="preserve">
          <source>One past the highest completed transaction ID. All transaction IDs greater than or equal to &lt;code&gt;xmax&lt;/code&gt; had not yet completed as of the time of the snapshot, and thus are invisible.</source>
          <target state="translated">완료된 가장 높은 거래 ID를 지나는 것입니다. &lt;code&gt;xmax&lt;/code&gt; 보다 크거나 같은 모든 트랜잭션 ID 는 스냅 샷 시점에 아직 완료되지 않았으므로 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3fe47df2bc317685fd9b966bcab8a9f820096f2" translate="yes" xml:space="preserve">
          <source>One row for each WAL sender process streaming a base backup, showing current progress. See &lt;a href=&quot;progress-reporting#BASEBACKUP-PROGRESS-REPORTING&quot;&gt;Section 27.4.5&lt;/a&gt;.</source>
          <target state="translated">현재 진행 상황을 보여주는 기본 백업을 스트리밍하는 각 WAL 발신자 프로세스에 대해 한 행입니다. &lt;a href=&quot;progress-reporting#BASEBACKUP-PROGRESS-REPORTING&quot;&gt;27.4.5 항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82642c7d45248923778a2209d5f115330d366506" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;ANALYZE&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#ANALYZE-PROGRESS-REPORTING&quot;&gt;Section 27.4.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ANALYZE&lt;/code&gt; 를 실행하는 각 백엔드 (autovacuum 작업자 프로세스 포함)에 대해 한 행으로 현재 진행 상황을 보여줍니다. &lt;a href=&quot;progress-reporting#ANALYZE-PROGRESS-REPORTING&quot;&gt;27.4.1 항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="80b5eb3c3d07dabe60de983aaa0a3518afd885a7" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;VACUUM&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;Section 27.4.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 을 실행하는 각 백엔드 (자동 진공 작업자 프로세스 포함)에 대해 한 행씩 현재 진행 상황을 보여줍니다. &lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;27.4.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="effeab1715906cd694d7b1852e9b8750b001e4c5" translate="yes" xml:space="preserve">
          <source>One row for each backend (including autovacuum worker processes) running &lt;code&gt;VACUUM&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;VACUUM&lt;/code&gt; 을 실행하는 각 백엔드 (autovacuum 작업자 프로세스 포함)에 대해 하나의 행으로 현재 진행 상황을 보여줍니다. &lt;a href=&quot;progress-reporting#VACUUM-PROGRESS-REPORTING&quot;&gt;27.4.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e814a8df1ec5e7ba9113e201d150026719d20049" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; 또는 &lt;code&gt;VACUUM FULL&lt;/code&gt; 을 실행하는 각 백엔드 당 하나의 행으로 현재 진행률을 보여줍니다. &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;섹션 27.4.3&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="3fefdce83b8168d66ba70cfd9d6be8231c7483a5" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CLUSTER&lt;/code&gt; or &lt;code&gt;VACUUM FULL&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;Section 27.4.4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CLUSTER&lt;/code&gt; 또는 &lt;code&gt;VACUUM FULL&lt;/code&gt; 을 실행하는 각 백엔드에 대해 한 행으로 현재 진행 상황을 보여줍니다. &lt;a href=&quot;progress-reporting#CLUSTER-PROGRESS-REPORTING&quot;&gt;27.4.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="592609ed9243ae5def10fa9f090855998b555b8d" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;Section 27.4.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; 또는 &lt;code&gt;REINDEX&lt;/code&gt; 를 실행하는 각 백엔드 당 하나의 행으로 현재 진행 상황을 보여줍니다. &lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;섹션 27.4.1&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="7c1c91b429aaf8e67212422dcd282876be59a3b8" translate="yes" xml:space="preserve">
          <source>One row for each backend running &lt;code&gt;CREATE INDEX&lt;/code&gt; or &lt;code&gt;REINDEX&lt;/code&gt;, showing current progress. See &lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;Section 27.4.2&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE INDEX&lt;/code&gt; 또는 &lt;code&gt;REINDEX&lt;/code&gt; 를 실행하는 각 백엔드에 대해 한 행으로 현재 진행 상황을 보여줍니다. &lt;a href=&quot;progress-reporting#CREATE-INDEX-PROGRESS-REPORTING&quot;&gt;27.4.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e27c3edf1970037c5b38d9980359c2a682d83e63" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about I/O on that specific index. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;&lt;code&gt;pg_statio_all_indexes&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">현재 데이터베이스의 각 인덱스에 대해 하나의 행으로 특정 인덱스의 I / O에 대한 통계를 표시합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-INDEXES-VIEW&quot;&gt; &lt;code&gt;pg_statio_all_indexes&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="636789b8fa3526dcb7ffa47252873c271555303c" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about I/O on that specific index. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-INDEXES-VIEW&quot;&gt;pg_statio_all_indexes&lt;/a&gt; for details.</source>
          <target state="translated">현재 데이터베이스의 각 인덱스마다 하나의 행으로, 해당 특정 인덱스의 I / O에 대한 통계가 표시됩니다. 보다&lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-INDEXES-VIEW&quot;&gt; pg_statio_all_indexes&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d77f2cdac8ddfb746a4ceaac2099e52076e9af7" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about accesses to that specific index. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ALL-INDEXES-VIEW&quot;&gt;&lt;code&gt;pg_stat_all_indexes&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">현재 데이터베이스의 각 인덱스에 대한 하나의 행으로 특정 인덱스에 대한 액세스 통계를 보여줍니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ALL-INDEXES-VIEW&quot;&gt; &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c843f1eedf963b1dea0a4c471c30395c4850fb0a" translate="yes" xml:space="preserve">
          <source>One row for each index in the current database, showing statistics about accesses to that specific index. See &lt;a href=&quot;monitoring-stats#PG-STAT-ALL-INDEXES-VIEW&quot;&gt;pg_stat_all_indexes&lt;/a&gt; for details.</source>
          <target state="translated">현재 데이터베이스의 각 인덱스에 대해 하나의 행으로, 해당 특정 인덱스에 대한 액세스에 대한 통계가 표시됩니다. 보다&lt;a href=&quot;monitoring-stats#PG-STAT-ALL-INDEXES-VIEW&quot;&gt; pg_stat_all_indexes&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5fdb86eec2a29466a4d1044e6a5602fb45a47381" translate="yes" xml:space="preserve">
          <source>One row for each sequence in the current database, showing statistics about I/O on that specific sequence. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;&lt;code&gt;pg_statio_all_sequences&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">현재 데이터베이스의 각 시퀀스에 대해 하나의 행으로 특정 시퀀스의 I / O에 대한 통계를 표시합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt; &lt;code&gt;pg_statio_all_sequences&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c2a19a27308f1c1e0f487d86ec09bd9389b70b95" translate="yes" xml:space="preserve">
          <source>One row for each sequence in the current database, showing statistics about I/O on that specific sequence. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt;pg_statio_all_sequences&lt;/a&gt; for details.</source>
          <target state="translated">현재 데이터베이스의 각 시퀀스에 대해 하나의 행으로, 해당 특정 시퀀스의 I / O에 대한 통계가 표시됩니다. 보다&lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-SEQUENCES-VIEW&quot;&gt; pg_statio_all_sequences&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="af3494e4cc13caccb2edb628436f0d6fc2950bc0" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about I/O on that specific table. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-TABLES-VIEW&quot;&gt;&lt;code&gt;pg_statio_all_tables&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">특정 테이블의 I / O에 대한 통계를 표시하는 현재 데이터베이스의 각 테이블에 대해 한 행입니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STATIO-ALL-TABLES-VIEW&quot;&gt; &lt;code&gt;pg_statio_all_tables&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="876cb7f3198f93830f07de3b355cbda033ba5c5c" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about I/O on that specific table. See &lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-TABLES-VIEW&quot;&gt;pg_statio_all_tables&lt;/a&gt; for details.</source>
          <target state="translated">현재 데이터베이스의 각 테이블에 대해 한 행씩 해당 테이블의 I / O에 대한 통계를 표시합니다. 보다&lt;a href=&quot;monitoring-stats#PG-STATIO-ALL-TABLES-VIEW&quot;&gt; pg_statio_all_tables&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b933ef4e80b93a79e66696a5ea76c78fbf07acf1" translate="yes" xml:space="preserve">
          <source>One row for each table in the current database, showing statistics about accesses to that specific table. See &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ALL-TABLES-VIEW&quot;&gt;&lt;code&gt;pg_stat_all_tables&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">현재 데이터베이스의 각 테이블에 대한 하나의 행으로 해당 특정 테이블에 대한 액세스 통계를 표시합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#MONITORING-PG-STAT-ALL-TABLES-VIEW&quot;&gt; &lt;code&gt;pg_stat_all_tables&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
