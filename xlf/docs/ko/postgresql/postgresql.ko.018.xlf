<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="postgresql">
    <body>
      <group id="postgresql">
        <trans-unit id="c3a99e9a4728dc2bda56a78db524b67989b4e597" translate="yes" xml:space="preserve">
          <source>Read all configuration variables, even those normally visible only to superusers.</source>
          <target state="translated">일반적으로 수퍼 유저 만 볼 수있는 모든 구성 변수를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="38c5a7218bb22d1b28959f625c6bfbea27ffbf82" translate="yes" xml:space="preserve">
          <source>Read all pg_stat_* views and use various statistics related extensions, even those normally visible only to superusers.</source>
          <target state="translated">모든 pg_stat_ * 뷰를 읽고 일반적으로 수퍼 유저에게만 표시되는 다양한 통계 관련 확장을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f317af3bdf1a98cfc777a36424de3b09eb202cb2" translate="yes" xml:space="preserve">
          <source>Read commands from the file &lt;code&gt;filename&lt;/code&gt;, rather than standard input. This option can be repeated and combined in any order with the &lt;code&gt;-c&lt;/code&gt; option. When either &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;-f&lt;/code&gt; is specified, psql does not read commands from standard input; instead it terminates after processing all the &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-f&lt;/code&gt; options in sequence. Except for that, this option is largely equivalent to the meta-command &lt;code&gt;\i&lt;/code&gt;.</source>
          <target state="translated">표준 입력이 아닌 &lt;code&gt;filename&lt;/code&gt; 파일에서 명령을 읽으십시오 . 이 옵션은 &lt;code&gt;-c&lt;/code&gt; 옵션 과 함께 임의의 순서로 반복 및 결합 될 수 있습니다 . 때 중 하나 &lt;code&gt;-c&lt;/code&gt; 또는 &lt;code&gt;-f&lt;/code&gt; 이 , psql의 표준 입력에서 명령을 읽지 않습니다 지정; 대신 모든 &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-f&lt;/code&gt; 옵션을 순서대로 처리 한 후 종료 됩니다. 이를 제외하고이 옵션은 메타 명령 &lt;code&gt;\i&lt;/code&gt; 와 거의 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9076a937057025c12698c82a06c40b255a1ab2fe" translate="yes" xml:space="preserve">
          <source>Read committed</source>
          <target state="translated">커밋 된 읽기</target>
        </trans-unit>
        <trans-unit id="a95dbf92f08a3c417ee95bdad4ed061db64fdec6" translate="yes" xml:space="preserve">
          <source>Read only transactions and transaction rollbacks need not wait for replies from standby servers. Subtransaction commits do not wait for responses from standby servers, only top-level commits. Long running actions such as data loading or index building do not wait until the very final commit message. All two-phase commit actions require commit waits, including both prepare and commit.</source>
          <target state="translated">읽기 전용 트랜잭션 및 트랜잭션 롤백은 대기 서버의 응답을 기다릴 필요가 없습니다. 서브 트랜잭션 커밋은 대기 서버의 응답을 기다리지 않고 최상위 커밋 만합니다. 데이터로드 또는 인덱스 작성과 같은 장기 실행 조치는 최종 커밋 메시지까지 기다리지 않습니다. 모든 2 단계 커밋 작업에는 준비 및 커밋을 포함하여 커밋 대기가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6be205ecd14d327027894365b4c4da763eabaefb" translate="yes" xml:space="preserve">
          <source>Read uncommitted</source>
          <target state="translated">커밋되지 않은 읽기</target>
        </trans-unit>
        <trans-unit id="6eb06aa586fee4fadd30e615b431af9599c0f350" translate="yes" xml:space="preserve">
          <source>Read/execute various monitoring views and functions. This role is a member of &lt;code&gt;pg_read_all_settings&lt;/code&gt;, &lt;code&gt;pg_read_all_stats&lt;/code&gt; and &lt;code&gt;pg_stat_scan_tables&lt;/code&gt;.</source>
          <target state="translated">다양한 모니터링보기 및 기능을 읽고 실행합니다. 이 역할은 &lt;code&gt;pg_read_all_settings&lt;/code&gt; , &lt;code&gt;pg_read_all_stats&lt;/code&gt; 및 &lt;code&gt;pg_stat_scan_tables&lt;/code&gt; 의 멤버입니다 .</target>
        </trans-unit>
        <trans-unit id="208855ca97c0a555c27eb1fe53c1f9d25c951c72" translate="yes" xml:space="preserve">
          <source>Reads input from the file &lt;code&gt;filename&lt;/code&gt; and executes it as though it had been typed on the keyboard.</source>
          <target state="translated">파일 파일 &lt;code&gt;filename&lt;/code&gt; 에서 입력을 읽고 키보드에서 입력 한 것처럼 실행합니다.</target>
        </trans-unit>
        <trans-unit id="8c6e304c0494e1083fecdbe3327bbaf955efd2c7" translate="yes" xml:space="preserve">
          <source>Reads the large object with OID &lt;code&gt;loid&lt;/code&gt; from the database and writes it to &lt;code&gt;filename&lt;/code&gt;. Note that this is subtly different from the server function &lt;code&gt;lo_export&lt;/code&gt;, which acts with the permissions of the user that the database server runs as and on the server's file system.</source>
          <target state="translated">데이터베이스에서 OID &lt;code&gt;loid&lt;/code&gt; 가 있는 큰 오브젝트를 읽고 &lt;code&gt;filename&lt;/code&gt; 에 씁니다 . 이는 데이터베이스 서버가 서버의 파일 시스템으로 실행하는 사용자의 권한으로 작동 하는 서버 기능 &lt;code&gt;lo_export&lt;/code&gt; 와는 미묘한 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b773130a64ad2044832f0c09fb6170f96c3c7a41" translate="yes" xml:space="preserve">
          <source>Real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</source>
          <target state="translated">실제 사용법은 &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;12 장에&lt;/a&gt; 설명 된대로 텍스트 검색 구성에 포함하는 것입니다 . 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adc221fa25debab944173bf594530b5f4af077cb" translate="yes" xml:space="preserve">
          <source>Real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</source>
          <target state="translated">Real-world usage will involve including it in a text search configuration as described in &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt;. That might look like this:</target>
        </trans-unit>
        <trans-unit id="ae23f1294951923b0cc23537cc39645d564d2aab" translate="yes" xml:space="preserve">
          <source>Rebuild a single index:</source>
          <target state="translated">단일 인덱스를 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7641f144c3aa51f565ab278ebea2baf02cb12776" translate="yes" xml:space="preserve">
          <source>Rebuild all indexes in a particular database, without trusting the system indexes to be valid already:</source>
          <target state="translated">시스템 인덱스가 이미 유효한 것으로 신뢰하지 않고 특정 데이터베이스의 모든 인덱스를 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="4bafd726bbf407899b495d1dbf54642ee4ba4831" translate="yes" xml:space="preserve">
          <source>Rebuild all the indexes on the table &lt;code&gt;my_table&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;my_table&lt;/code&gt; 테이블의 모든 인덱스를 다시 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e240124d901fd858d5ecb298dbf587210bc9d05" translate="yes" xml:space="preserve">
          <source>Rebuild indexes for a table, without blocking read and write operations on involved relations while reindexing is in progress:</source>
          <target state="translated">재 인덱싱이 진행되는 동안 관련 관계에 대한 읽기 및 쓰기 작업을 차단하지 않고 테이블에 대한 색인을 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9a65666fb054ac024fe44494209417a92c10f6a1" translate="yes" xml:space="preserve">
          <source>Rebuilding Indexes Concurrently</source>
          <target state="translated">동시에 인덱스 재 구축</target>
        </trans-unit>
        <trans-unit id="988c4afb32e29d0f56df1f4ce3ed4b7fe8a47d56" translate="yes" xml:space="preserve">
          <source>Rebuilding an index can interfere with regular operation of a database. Normally PostgreSQL locks the table whose index is rebuilt against writes and performs the entire index build with a single scan of the table. Other transactions can still read the table, but if they try to insert, update, or delete rows in the table they will block until the index rebuild is finished. This could have a severe effect if the system is a live production database. Very large tables can take many hours to be indexed, and even for smaller tables, an index rebuild can lock out writers for periods that are unacceptably long for a production system.</source>
          <target state="translated">인덱스를 다시 작성하면 데이터베이스의 정기적 인 작동을 방해 할 수 있습니다. 일반적으로 PostgreSQL은 쓰기에 대해 인덱스가 재 빌드 된 테이블을 잠그고 테이블을 한 번 스캔하여 전체 인덱스 빌드를 수행합니다. 다른 트랜잭션은 여전히 ​​테이블을 읽을 수 있지만 테이블에서 행을 삽입, 업데이트 또는 삭제하려고하면 인덱스 재 구축이 완료 될 때까지 차단됩니다. 시스템이 실제 프로덕션 데이터베이스 인 경우 심각한 영향을 줄 수 있습니다. 매우 큰 테이블은 인덱싱하는 데 많은 시간이 소요될 수 있으며, 더 작은 테이블의 경우에도 인덱스 재 구축은 프로덕션 시스템에서 허용 할 수 없을 정도로 긴 기간 동안 기록기를 잠글 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82bd8c2397d7ac2c1c641075498f1fce81c5df27" translate="yes" xml:space="preserve">
          <source>Recall from &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; that SQL does not, in general, provide a unique identifier for rows. Therefore it is not always possible to directly specify which row to update. Instead, you specify which conditions a row must meet in order to be updated. Only if you have a primary key in the table (independent of whether you declared it or not) can you reliably address individual rows by choosing a condition that matches the primary key. Graphical database access tools rely on this fact to allow you to update rows individually.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;5 장&lt;/a&gt; 에서 SQL은 일반적으로 행에 고유 식별자를 제공하지 않는다는 점을 상기하십시오 . 따라서 항상 업데이트 할 행을 직접 지정할 수있는 것은 아닙니다. 대신 업데이트하기 위해 행이 충족해야하는 조건을 지정합니다. 선언 여부에 관계없이 테이블에 기본 키가있는 경우에만 기본 키와 일치하는 조건을 선택하여 개별 행을 안정적으로 처리 할 수 ​​있습니다. 그래픽 데이터베이스 액세스 도구는이 사실에 따라 행을 개별적으로 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4efef42b9260b682732a87952d0c648c37aa88b4" translate="yes" xml:space="preserve">
          <source>Recall from &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; that the PostgreSQL server provides a large number of run-time configuration variables. You can set database-specific default values for many of these settings.</source>
          <target state="translated">PostgreSQL 서버는 많은 런타임 구성 변수를 제공한다는 사실을 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장&lt;/a&gt; 에서 기억 하십시오. 이러한 많은 설정에 대해 데이터베이스 별 기본값을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77cd62a2253e34b3d74388d11184bc8e1468ac9d" translate="yes" xml:space="preserve">
          <source>Recall from &lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; that SQL does not, in general, provide a unique identifier for rows. Therefore it is not always possible to directly specify which row to update. Instead, you specify which conditions a row must meet in order to be updated. Only if you have a primary key in the table (independent of whether you declared it or not) can you reliably address individual rows by choosing a condition that matches the primary key. Graphical database access tools rely on this fact to allow you to update rows individually.</source>
          <target state="translated">Recall from &lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; that SQL does not, in general, provide a unique identifier for rows. Therefore it is not always possible to directly specify which row to update. Instead, you specify which conditions a row must meet in order to be updated. Only if you have a primary key in the table (independent of whether you declared it or not) can you reliably address individual rows by choosing a condition that matches the primary key. Graphical database access tools rely on this fact to allow you to update rows individually.</target>
        </trans-unit>
        <trans-unit id="82793ec90bd6064f7072f59976ab7a7f56b90d80" translate="yes" xml:space="preserve">
          <source>Recall from &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; that the PostgreSQL server provides a large number of run-time configuration variables. You can set database-specific default values for many of these settings.</source>
          <target state="translated">Recall from &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; that the PostgreSQL server provides a large number of run-time configuration variables. You can set database-specific default values for many of these settings.</target>
        </trans-unit>
        <trans-unit id="2f93654028aee4dea14c9a1eae10f967b20dc5e9" translate="yes" xml:space="preserve">
          <source>Recall the &lt;code&gt;weather&lt;/code&gt; and &lt;code&gt;cities&lt;/code&gt; tables from &lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;Chapter 2&lt;/a&gt;. Consider the following problem: You want to make sure that no one can insert rows in the &lt;code&gt;weather&lt;/code&gt; table that do not have a matching entry in the &lt;code&gt;cities&lt;/code&gt; table. This is called maintaining the &lt;em&gt;referential integrity&lt;/em&gt; of your data. In simplistic database systems this would be implemented (if at all) by first looking at the &lt;code&gt;cities&lt;/code&gt; table to check if a matching record exists, and then inserting or rejecting the new &lt;code&gt;weather&lt;/code&gt; records. This approach has a number of problems and is very inconvenient, so PostgreSQL can do this for you.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/tutorial-sql.html&quot;&gt;2 장의 &lt;/a&gt; &lt;code&gt;weather&lt;/code&gt; 및 &lt;code&gt;cities&lt;/code&gt; 표를 상기하십시오 . 다음 문제점을 고려하십시오 . &lt;code&gt;cities&lt;/code&gt; 테이블 에서 일치하는 항목이없는 &lt;code&gt;weather&lt;/code&gt; 테이블에 행을 삽입 할 수 없도록하십시오 . 이를 데이터 의 &lt;em&gt;참조 무결성&lt;/em&gt; 유지라고 합니다. 단순한 데이터베이스 시스템에서는 &lt;code&gt;cities&lt;/code&gt; 테이블을 보고 일치하는 레코드가 있는지 확인한 다음 새 &lt;code&gt;weather&lt;/code&gt; 레코드 를 삽입하거나 거부하여 구현 합니다. 이 접근 방식에는 여러 가지 문제가 있으며 매우 불편하므로 PostgreSQL이이를 수행 할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ba1105c79d510fd5595ccc9a894da13d04f18bda" translate="yes" xml:space="preserve">
          <source>Recall the &lt;code&gt;weather&lt;/code&gt; and &lt;code&gt;cities&lt;/code&gt; tables from &lt;a href=&quot;https://www.postgresql.org/docs/13/tutorial-sql.html&quot;&gt;Chapter 2&lt;/a&gt;. Consider the following problem: You want to make sure that no one can insert rows in the &lt;code&gt;weather&lt;/code&gt; table that do not have a matching entry in the &lt;code&gt;cities&lt;/code&gt; table. This is called maintaining the &lt;em&gt;referential integrity&lt;/em&gt; of your data. In simplistic database systems this would be implemented (if at all) by first looking at the &lt;code&gt;cities&lt;/code&gt; table to check if a matching record exists, and then inserting or rejecting the new &lt;code&gt;weather&lt;/code&gt; records. This approach has a number of problems and is very inconvenient, so PostgreSQL can do this for you.</source>
          <target state="translated">Recall the &lt;code&gt;weather&lt;/code&gt; and &lt;code&gt;cities&lt;/code&gt; tables from &lt;a href=&quot;https://www.postgresql.org/docs/13/tutorial-sql.html&quot;&gt;Chapter 2&lt;/a&gt;. Consider the following problem: You want to make sure that no one can insert rows in the &lt;code&gt;weather&lt;/code&gt; table that do not have a matching entry in the &lt;code&gt;cities&lt;/code&gt; table. This is called maintaining the &lt;em&gt;referential integrity&lt;/em&gt; of your data. In simplistic database systems this would be implemented (if at all) by first looking at the &lt;code&gt;cities&lt;/code&gt; table to check if a matching record exists, and then inserting or rejecting the new &lt;code&gt;weather&lt;/code&gt; records. This approach has a number of problems and is very inconvenient, so PostgreSQL can do this for you.</target>
        </trans-unit>
        <trans-unit id="0eaa953826e935204b6a44cd6a2370cac662b344" translate="yes" xml:space="preserve">
          <source>Receipt time of last message received from origin WAL sender</source>
          <target state="translated">오리진 WAL 발신자로부터 마지막으로받은 메시지 수신 시간</target>
        </trans-unit>
        <trans-unit id="3cc37caa6d46528f9045d282984fbf57211a9456" translate="yes" xml:space="preserve">
          <source>Recent SATA drives (those following ATAPI-6 or later) offer a drive cache flush command (&lt;code&gt;FLUSH CACHE EXT&lt;/code&gt;), while SCSI drives have long supported a similar command &lt;code&gt;SYNCHRONIZE CACHE&lt;/code&gt;. These commands are not directly accessible to PostgreSQL, but some file systems (e.g., ZFS, ext4) can use them to flush data to the platters on write-back-enabled drives. Unfortunately, such file systems behave suboptimally when combined with battery-backup unit (BBU) disk controllers. In such setups, the synchronize command forces all data from the controller cache to the disks, eliminating much of the benefit of the BBU. You can run the &lt;a href=&quot;pgtestfsync&quot;&gt;pg_test_fsync&lt;/a&gt; program to see if you are affected. If you are affected, the performance benefits of the BBU can be regained by turning off write barriers in the file system or reconfiguring the disk controller, if that is an option. If write barriers are turned off, make sure the battery remains functional; a faulty battery can potentially lead to data loss. Hopefully file system and disk controller designers will eventually address this suboptimal behavior.</source>
          <target state="translated">최근 SATA 드라이브 (ATAPI-6 이후 버전)는 드라이브 캐시 플러시 명령 ( &lt;code&gt;FLUSH CACHE EXT&lt;/code&gt; )을 제공하는 반면 SCSI 드라이브는 오랫동안 유사한 명령 &lt;code&gt;SYNCHRONIZE CACHE&lt;/code&gt; 를 지원했습니다 . 이러한 명령은 PostgreSQL에서 직접 액세스 할 수 없지만 일부 파일 시스템 (예 : ZFS, ext4)은이 명령을 사용하여 쓰기 가능 드라이브의 플래터로 데이터를 플러시 할 수 있습니다. 불행히도, 이러한 파일 시스템은 배터리 백업 장치 (BBU) 디스크 컨트롤러와 결합 될 때 차선책으로 작동합니다. 이러한 설정에서, 동기화 명령은 제어기 캐시에서 디스크로 모든 데이터를 강제 실행하므로 BBU의 이점을 상당 부분 제거합니다. &lt;a href=&quot;pgtestfsync&quot;&gt;pg_test_fsync를&lt;/a&gt; 실행할 수 있습니다영향을 받는지 확인하는 프로그램입니다. 영향을받는 경우 파일 시스템에서 쓰기 장벽을 끄거나 옵션 인 경우 디스크 컨트롤러를 재구성하면 BBU의 성능 이점을 다시 얻을 수 있습니다. 쓰기 장벽이 꺼져 있으면 배터리가 작동 상태를 유지하는지 확인하십시오. 결함이있는 배터리는 잠재적으로 데이터 손실로 이어질 수 있습니다. 파일 시스템 및 디스크 컨트롤러 디자이너가 결국이 차선책을 해결할 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="bb81291c24a22a0d7ee2d0164ff6f4bb7150f01b" translate="yes" xml:space="preserve">
          <source>Recent XPath versions begin to offer capabilities overlapping with these (such as functional-style &lt;code&gt;for-each&lt;/code&gt; and &lt;code&gt;sort&lt;/code&gt;, anonymous functions, and &lt;code&gt;parse-xml&lt;/code&gt; to create a node from a string), but such features were not available before XPath 3.0.</source>
          <target state="translated">최신 XPath 버전은 기능별 &lt;code&gt;for-each&lt;/code&gt; 및 &lt;code&gt;sort&lt;/code&gt; , 익명 함수 및 &lt;code&gt;parse-xml&lt;/code&gt; 과 같은 기능과 중복되는 기능을 제공하기 시작 했지만 XPath 3.0 이전에는 이러한 기능을 사용할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="e74ab6cfa0460d1693f4b9e4a5ccdbb1ddbfa73f" translate="yes" xml:space="preserve">
          <source>Recompile and verify that the new probes are available</source>
          <target state="translated">새 프로브를 사용할 수 있는지 다시 컴파일하고 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="233ddacb43f29512ec238d1ffd7cc462619376d6" translate="yes" xml:space="preserve">
          <source>Reconstructs the &lt;code id=&quot;returns&quot;&gt;RETURNS&lt;/code&gt; clause of a function, in the form it would need to appear in within &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Returns &lt;code&gt;NULL&lt;/code&gt; for a procedure.</source>
          <target state="translated">Reconstructs the &lt;code id=&quot;returns&quot;&gt;RETURNS&lt;/code&gt; clause of a function, in the form it would need to appear in within &lt;code&gt;CREATE FUNCTION&lt;/code&gt; . Returns &lt;code&gt;NULL&lt;/code&gt; for a procedure.</target>
        </trans-unit>
        <trans-unit id="45b7fe5adabb864a7afdc5e5231e1b7068035b22" translate="yes" xml:space="preserve">
          <source>Reconstructs the argument list necessary to identify a function or procedure, in the form it would need to appear in within commands such as &lt;code&gt;ALTER FUNCTION&lt;/code&gt;. This form omits default values.</source>
          <target state="translated">Reconstructs the argument list necessary to identify a function or procedure, in the form it would need to appear in within commands such as &lt;code&gt;ALTER FUNCTION&lt;/code&gt; . This form omits default values.</target>
        </trans-unit>
        <trans-unit id="3c9e3088c08d7c18d9d4ad9b891abeb9fecbb2da" translate="yes" xml:space="preserve">
          <source>Reconstructs the argument list of a function or procedure, in the form it would need to appear in within &lt;code&gt;CREATE FUNCTION&lt;/code&gt; (including default values).</source>
          <target state="translated">Reconstructs the argument list of a function or procedure, in the form it would need to appear in within &lt;code&gt;CREATE FUNCTION&lt;/code&gt; (including default values).</target>
        </trans-unit>
        <trans-unit id="9e92df60e108b27770587240c505c7500e979344" translate="yes" xml:space="preserve">
          <source>Reconstructs the creating command for a constraint. (This is a decompiled reconstruction, not the original text of the command.)</source>
          <target state="translated">Reconstructs the creating command for a constraint. (This is a decompiled reconstruction, not the original text of the command.)</target>
        </trans-unit>
        <trans-unit id="317173d17289abf774bea088b955ff9953ced270" translate="yes" xml:space="preserve">
          <source>Reconstructs the creating command for a function or procedure. (This is a decompiled reconstruction, not the original text of the command.) The result is a complete &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; statement.</source>
          <target state="translated">Reconstructs the creating command for a function or procedure. (This is a decompiled reconstruction, not the original text of the command.) The result is a complete &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; or &lt;code&gt;CREATE OR REPLACE PROCEDURE&lt;/code&gt; statement.</target>
        </trans-unit>
        <trans-unit id="df27182c38243818e36644705f1fe180c429aa90" translate="yes" xml:space="preserve">
          <source>Reconstructs the creating command for a rule. (This is a decompiled reconstruction, not the original text of the command.)</source>
          <target state="translated">Reconstructs the creating command for a rule. (This is a decompiled reconstruction, not the original text of the command.)</target>
        </trans-unit>
        <trans-unit id="9d43de436923e75445a468a3658a03356a4c5b92" translate="yes" xml:space="preserve">
          <source>Reconstructs the creating command for a trigger. (This is a decompiled reconstruction, not the original text of the command.)</source>
          <target state="translated">Reconstructs the creating command for a trigger. (This is a decompiled reconstruction, not the original text of the command.)</target>
        </trans-unit>
        <trans-unit id="f4d261f834a56609dc9e71fc639161eae09c790f" translate="yes" xml:space="preserve">
          <source>Reconstructs the creating command for an extended statistics object. (This is a decompiled reconstruction, not the original text of the command.)</source>
          <target state="translated">Reconstructs the creating command for an extended statistics object. (This is a decompiled reconstruction, not the original text of the command.)</target>
        </trans-unit>
        <trans-unit id="04852759df3fa7ad4535ea4a4cf5ed6aeaa8ae35" translate="yes" xml:space="preserve">
          <source>Reconstructs the creating command for an index. (This is a decompiled reconstruction, not the original text of the command.) If &lt;em&gt;&lt;code&gt;column&lt;/code&gt;&lt;/em&gt; is supplied and is not zero, only the definition of that column is reconstructed.</source>
          <target state="translated">Reconstructs the creating command for an index. (This is a decompiled reconstruction, not the original text of the command.) If &lt;em&gt; &lt;code&gt;column&lt;/code&gt; &lt;/em&gt; is supplied and is not zero, only the definition of that column is reconstructed.</target>
        </trans-unit>
        <trans-unit id="b683f4369b47ca440d3dbd43f988ad898ac3fca5" translate="yes" xml:space="preserve">
          <source>Reconstructs the underlying &lt;code&gt;SELECT&lt;/code&gt; command for a view or materialized view, working from a textual name for the view rather than its OID. (This is deprecated; use the OID variant instead.)</source>
          <target state="translated">Reconstructs the underlying &lt;code&gt;SELECT&lt;/code&gt; command for a view or materialized view, working from a textual name for the view rather than its OID. (This is deprecated; use the OID variant instead.)</target>
        </trans-unit>
        <trans-unit id="3957d8bebe6eceb3271369127cad18cc51da0f77" translate="yes" xml:space="preserve">
          <source>Reconstructs the underlying &lt;code&gt;SELECT&lt;/code&gt; command for a view or materialized view. (This is a decompiled reconstruction, not the original text of the command.)</source>
          <target state="translated">Reconstructs the underlying &lt;code&gt;SELECT&lt;/code&gt; command for a view or materialized view. (This is a decompiled reconstruction, not the original text of the command.)</target>
        </trans-unit>
        <trans-unit id="64e7a87e9e279d9f585ba1cd59e356580701de99" translate="yes" xml:space="preserve">
          <source>Reconstructs the underlying &lt;code&gt;SELECT&lt;/code&gt; command for a view or materialized view. (This is a decompiled reconstruction, not the original text of the command.) In this form of the function, pretty-printing is always enabled, and long lines are wrapped to try to keep them shorter than the specified number of columns.</source>
          <target state="translated">Reconstructs the underlying &lt;code&gt;SELECT&lt;/code&gt; command for a view or materialized view. (This is a decompiled reconstruction, not the original text of the command.) In this form of the function, pretty-printing is always enabled, and long lines are wrapped to try to keep them shorter than the specified number of columns.</target>
        </trans-unit>
        <trans-unit id="1c54132b8e5a9fa44a9a1a7d30b1be36ab3c4247" translate="yes" xml:space="preserve">
          <source>Record</source>
          <target state="translated">Record</target>
        </trans-unit>
        <trans-unit id="c56b9211f3ee693b17cfa7d6c447d7f6c0a97469" translate="yes" xml:space="preserve">
          <source>Record commit time of transactions. This parameter can only be set in &lt;code&gt;postgresql.conf&lt;/code&gt; file or on the server command line. The default value is &lt;code&gt;off&lt;/code&gt;.</source>
          <target state="translated">트랜잭션의 커밋 시간을 기록하십시오. 이 매개 변수는 &lt;code&gt;postgresql.conf&lt;/code&gt; 파일 또는 서버 명령 줄 에서만 설정할 수 있습니다 . 기본값은 &lt;code&gt;off&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e1e650b68eeccef8d69d91d12499b2ffe7f56b1b" translate="yes" xml:space="preserve">
          <source>Recovery performance is sufficiently good that the standby will typically be only moments away from full availability once it has been activated. As a result, this is called a warm standby configuration which offers high availability. Restoring a server from an archived base backup and rollforward will take considerably longer, so that technique only offers a solution for disaster recovery, not high availability. A standby server can also be used for read-only queries, in which case it is called a Hot Standby server. See &lt;a href=&quot;hot-standby&quot;&gt;Section 26.5&lt;/a&gt; for more information.</source>
          <target state="translated">복구 성능은 대기가 활성화 된 후에는 항상 전체 가용성에서 한 순간 떨어져있을 정도로 충분히 좋습니다. 결과적으로이를 고 가용성을 제공하는 웜 대기 구성이라고합니다. 아카이브 된 기본 백업 및 롤 포워드에서 서버를 복원하는 데 시간이 오래 걸리므로이 기술은 고 가용성이 아닌 재해 복구 솔루션 만 제공합니다. 대기 서버는 읽기 전용 쿼리에도 사용할 수 있으며이 경우 핫 대기 서버라고합니다. 자세한 정보는 &lt;a href=&quot;hot-standby&quot;&gt;26.5 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fc32ecc375b8a61098de0a79de9f7d52b34ebeb9" translate="yes" xml:space="preserve">
          <source>Recovery treats the WAL archive as read-only, so once a WAL file has been copied to the standby system it can be copied to tape at the same time as it is being read by the standby database server. Thus, running a standby server for high availability can be performed at the same time as files are stored for longer term disaster recovery purposes.</source>
          <target state="translated">복구는 WAL 아카이브를 읽기 전용으로 취급하므로 일단 WAL 파일이 대기 시스템에 복사되면 대기 데이터베이스 서버가 읽는 것과 동시에 테이프에 복사 될 수 있습니다. 따라서 파일을 장기적인 재해 복구 목적으로 저장하는 것과 동시에 고 가용성을 위해 대기 서버를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3bc2f178f62154c386cd90668f7442aeca7ac4b" translate="yes" xml:space="preserve">
          <source>Recreate &lt;code&gt;index&lt;/code&gt; only. Multiple indexes can be recreated by writing multiple &lt;code&gt;-i&lt;/code&gt; switches.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 만 다시 작성하십시오 . 여러 개의 &lt;code&gt;-i&lt;/code&gt; 스위치를 작성하여 여러 개의 색인을 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ab8e4cf2bee361b549d0a7652eba7adf3a2e36d" translate="yes" xml:space="preserve">
          <source>Recreate all indexes of the specified schema. If a table of this schema has a secondary &amp;ldquo;TOAST&amp;rdquo; table, that is reindexed as well. Indexes on shared system catalogs are also processed. This form of &lt;code&gt;REINDEX&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">지정된 스키마의 모든 인덱스를 다시 작성하십시오. 이 스키마의 테이블에 보조 &quot;TOAST&quot;테이블이 있으면 테이블도 다시 인덱싱됩니다. 공유 시스템 카탈로그의 인덱스도 처리됩니다. 이 형식의 &lt;code&gt;REINDEX&lt;/code&gt; 는 트랜잭션 블록 내에서 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="54a36c0b2b1b570c5b51a6a3b47c25f473f3cfb8" translate="yes" xml:space="preserve">
          <source>Recreate all indexes of the specified table. If the table has a secondary &amp;ldquo;TOAST&amp;rdquo; table, that is reindexed as well.</source>
          <target state="translated">지정된 테이블의 모든 인덱스를 다시 작성하십시오. 테이블에 보조 &quot;TOAST&quot;테이블이 있으면 인덱스도 다시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b3546f5e2e55d429c2387304c29dfa4c36ee5973" translate="yes" xml:space="preserve">
          <source>Recreate all indexes on system catalogs within the current database. Indexes on shared system catalogs are included. Indexes on user tables are not processed. This form of &lt;code&gt;REINDEX&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">현재 데이터베이스 내의 시스템 카탈로그에서 모든 색인을 재 작성하십시오. 공유 시스템 카탈로그의 색인이 포함됩니다. 사용자 테이블의 인덱스는 처리되지 않습니다. 이 형식의 &lt;code&gt;REINDEX&lt;/code&gt; 는 트랜잭션 블록 내에서 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b8026b4ad3f9457c0e184493f3e0aa052fee5538" translate="yes" xml:space="preserve">
          <source>Recreate all indexes within the current database. Indexes on shared system catalogs are also processed. This form of &lt;code&gt;REINDEX&lt;/code&gt; cannot be executed inside a transaction block.</source>
          <target state="translated">현재 데이터베이스 내에서 모든 인덱스를 다시 작성하십시오. 공유 시스템 카탈로그의 인덱스도 처리됩니다. 이 형식의 &lt;code&gt;REINDEX&lt;/code&gt; 는 트랜잭션 블록 내에서 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f367bbdd5ee6e1f68b6c0cdb73aa6b90920b34b" translate="yes" xml:space="preserve">
          <source>Recreate the specified index.</source>
          <target state="translated">지정된 색인을 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="03e087e4deee73a53d2927c0137b964b66c223d9" translate="yes" xml:space="preserve">
          <source>Rectangular box</source>
          <target state="translated">직사각형 상자</target>
        </trans-unit>
        <trans-unit id="978b1b93b222e22c8f18cadc02048782f7e02890" translate="yes" xml:space="preserve">
          <source>Recursive queries are typically used to deal with hierarchical or tree-structured data. A useful example is this query to find all the direct and indirect sub-parts of a product, given only a table that shows immediate inclusions:</source>
          <target state="translated">재귀 쿼리는 일반적으로 계층 적 또는 트리 구조 데이터를 처리하는 데 사용됩니다. 유용한 예는 즉각적인 포함을 보여주는 표만 제공된 경우 제품의 모든 직접 및 간접 하위 부품을 찾는이 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="dee4703f115772790755710d6bfeb6dc272e019e" translate="yes" xml:space="preserve">
          <source>Recursive self-references in data-modifying statements are not allowed. In some cases it is possible to work around this limitation by referring to the output of a recursive &lt;code&gt;WITH&lt;/code&gt;, for example:</source>
          <target state="translated">데이터 수정 명령문에서 재귀적인 자체 참조는 허용되지 않습니다. 어떤 경우에는 다음과 같이 재귀 &lt;code&gt;WITH&lt;/code&gt; 출력을 참조하여이 제한을 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb286d186d58a11b4ff049aa94d4a850a545db60" translate="yes" xml:space="preserve">
          <source>Recursive wildcard member accessor that processes all levels of the JSON hierarchy of the current object and returns all the member values, regardless of their nesting level. This is a PostgreSQL extension of the SQL/JSON standard.</source>
          <target state="translated">현재 객체의 모든 수준의 JSON 계층 구조를 처리하고 중첩 수준에 관계없이 모든 멤버 값을 반환하는 재귀 와일드 카드 멤버 접근 자입니다. 이것은 SQL / JSON 표준의 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="170881344897f672ebed562b0d42c4dfc0416658" translate="yes" xml:space="preserve">
          <source>Recycling</source>
          <target state="translated">Recycling</target>
        </trans-unit>
        <trans-unit id="8a65f2683d038caef7cd978720876b3004872fd2" translate="yes" xml:space="preserve">
          <source>Reduces the value's scale (number of fractional decimal digits) by removing trailing zeroes</source>
          <target state="translated">Reduces the value's scale (number of fractional decimal digits) by removing trailing zeroes</target>
        </trans-unit>
        <trans-unit id="598f9976006d7832dfe0186ff7402baf44e23a91" translate="yes" xml:space="preserve">
          <source>Reducing &lt;code&gt;checkpoint_timeout&lt;/code&gt; and/or &lt;code&gt;max_wal_size&lt;/code&gt; causes checkpoints to occur more often. This allows faster after-crash recovery, since less work will need to be redone. However, one must balance this against the increased cost of flushing dirty data pages more often. If &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes&lt;/a&gt; is set (as is the default), there is another factor to consider. To ensure data page consistency, the first modification of a data page after each checkpoint results in logging the entire page content. In that case, a smaller checkpoint interval increases the volume of output to the WAL log, partially negating the goal of using a smaller interval, and in any case causing more disk I/O.</source>
          <target state="translated">&lt;code&gt;checkpoint_timeout&lt;/code&gt; 및 / 또는 &lt;code&gt;max_wal_size&lt;/code&gt; 를 줄이면 검사 점이 더 자주 발생합니다. 이렇게하면 작업을 다시 수행해야하는 작업이 줄어들 기 때문에 충돌 후 복구 속도가 빨라집니다. 그러나 더티 데이터 페이지를 더 자주 플러시하는 비용 증가와이를 균형을 맞춰야합니다. 경우 &lt;a href=&quot;runtime-config-wal#GUC-FULL-PAGE-WRITES&quot;&gt;full_page_writes가&lt;/a&gt; (같은 기본값은) 설정, 고려해야 할 또 다른 요소가있다. 데이터 페이지 일관성을 보장하기 위해 각 체크 포인트 후 데이터 페이지를 처음 수정하면 전체 페이지 컨텐츠가 로깅됩니다. 이 경우 검사 점 간격이 작을수록 WAL 로그에 대한 출력 볼륨이 증가하여 더 작은 간격을 사용한다는 목표를 부분적으로 무시하고 더 많은 디스크 I / O가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="494a1fc98607c2b79eb20bb477bcd9be2cf06f26" translate="yes" xml:space="preserve">
          <source>Reducing this value relative to &lt;code&gt;seq_page_cost&lt;/code&gt; will cause the system to prefer index scans; raising it will make index scans look relatively more expensive. You can raise or lower both values together to change the importance of disk I/O costs relative to CPU costs, which are described by the following parameters.</source>
          <target state="translated">&lt;code&gt;seq_page_cost&lt;/code&gt; 와 관련하여이 값을 줄이면 시스템이 인덱스 스캔을 선호합니다. 이 값을 올리면 인덱스 스캔이 상대적으로 비싸게 보입니다. 두 값을 함께 올리거나 낮추면 CPU 비용에 비해 디스크 I / O 비용의 중요도를 변경할 수 있습니다. 이는 다음 매개 변수로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="251ad29b4411d43a3a9a30b406875d5a65389db8" translate="yes" xml:space="preserve">
          <source>Refer back to the queries in &lt;a href=&quot;tutorial-join&quot;&gt;Section 2.6&lt;/a&gt;. Suppose the combined listing of weather records and city location is of particular interest to your application, but you do not want to type the query each time you need it. You can create a &lt;em&gt;view&lt;/em&gt; over the query, which gives a name to the query that you can refer to like an ordinary table:</source>
          <target state="translated">&lt;a href=&quot;tutorial-join&quot;&gt;섹션 2.6&lt;/a&gt; 의 쿼리를 다시 참조하십시오 . 날씨 기록과 도시 위치의 결합 된 목록이 응용 프로그램에 특히 중요하다고 생각하지만 필요할 때마다 쿼리를 입력하고 싶지는 않습니다. 쿼리에 대한 &lt;em&gt;뷰&lt;/em&gt; 를 만들면 일반 테이블처럼 참조 할 수있는 쿼리 이름이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5341f0a986aadb7626dd320ff543ffcc47c2af62" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt; for more information on how to specify time zones.</source>
          <target state="translated">시간대를 지정하는 방법에 대한 자세한 내용 &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;은 8.5.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02b2f7b17bdaaa710224a6f2d9a2726f153fa045" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;ddl-partitioning#DDL-PARTITIONING-CONSTRAINT-EXCLUSION&quot;&gt;Section 5.11.5&lt;/a&gt; for more information on using constraint exclusion to implement partitioning.</source>
          <target state="translated">파티셔닝 구현을위한 제약 조건 제외 사용에 대한 자세한 내용 &lt;a href=&quot;ddl-partitioning#DDL-PARTITIONING-CONSTRAINT-EXCLUSION&quot;&gt;은 5.11.5 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7964fa10016da66ba834552c5f6f3d79c42b983" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;functions-comparison&quot;&gt;Section 9.2&lt;/a&gt; for related information.</source>
          <target state="translated">관련 정보는 &lt;a href=&quot;functions-comparison&quot;&gt;9.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="932cd8269f413b99acbf9dda316973dd905d3f3c" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for further information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/textsearch.html&quot;&gt;12 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac5208d4dfd6aaebe17f294e56aadc09a8ee2371" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;Chapter 38&lt;/a&gt; for more information about triggers.</source>
          <target state="translated">트리거에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/triggers.html&quot;&gt;38 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b126e4c9c2b3fa7a55338cb7c3fde69bffbdfc6b" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt; for further information on writing functions.</source>
          <target state="translated">함수 작성에 대한 자세한 내용 &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc.html&quot;&gt;은 37.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49ee5e1da059c3b24e417da3dd10d0688c87f134" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;Section 37.16&lt;/a&gt; for further information.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html&quot;&gt;37.16 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6675af0c392d5af8b7c55e0161f1192b2c0614b4" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper.html&quot;&gt;Section 37.14&lt;/a&gt; for further information.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/xoper.html&quot;&gt;37.14 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a568592e88f815e69618d69d251426d0b7faf7e9" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;Chapter 12&lt;/a&gt; for further information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/textsearch.html&quot;&gt;12 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d8f2141391887a6ad8a6b957170897e601bc581" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;Chapter 38&lt;/a&gt; for more information about triggers.</source>
          <target state="translated">트리거에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/triggers.html&quot;&gt;38 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cd2c2a1609e6fe73a2dd875e46b4f6ded1e624d" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;Section 37.3&lt;/a&gt; for further information on writing functions.</source>
          <target state="translated">함수 작성에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc.html&quot;&gt;섹션 37.3&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69092c11ec932440a8ca6566f5f0f9283c9ab97a" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;Section 37.16&lt;/a&gt; for further information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html&quot;&gt;섹션 37.16&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="204963a988bdbe963f228879ccc1b98894c2e16d" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;https://www.postgresql.org/docs/13/xoper.html&quot;&gt;Section 37.14&lt;/a&gt; for further information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/xoper.html&quot;&gt;섹션 37.14&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81c0d22e543b8fbbfd78441a6db5d3bcb9732152" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; for a further description of valid parameters.</source>
          <target state="translated">유효한 매개 변수에 대한 자세한 설명은 &lt;a href=&quot;sql-createforeigntable&quot;&gt;CREATE FOREIGN TABLE&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="529ebf827d15794539adf323c0b5dd84c2ef037e" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for a further description of valid parameters. &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; has further information on inheritance.</source>
          <target state="translated">유효한 매개 변수에 대한 자세한 설명은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오 . &lt;a href=&quot;https://www.postgresql.org/docs/12/ddl.html&quot;&gt;5 장&lt;/a&gt; 에는 상속에 대한 추가 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eb2e08111875b3eebbdda5de7eb4d333a032749" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; for a further description of valid parameters. &lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;Chapter 5&lt;/a&gt; has further information on inheritance.</source>
          <target state="translated">유효한 매개 변수에 대한 자세한 설명은 &lt;a href=&quot;sql-createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 참조하십시오 . &lt;a href=&quot;https://www.postgresql.org/docs/13/ddl.html&quot;&gt;5 장&lt;/a&gt; 에는 상속에 대한 추가 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d776c1e96ee0d53dc452c6e906582e94ed8c8a3" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="609c2795f7a690913912d5e264816e4e9164d450" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; for information on the meaning of the other parameters to this statement.</source>
          <target state="translated">이 명령문에 대한 다른 매개 변수의 의미에 대한 정보는 &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d06e508a800c4c40dd3731e649c715fcaf29e325" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; for information on the meaning of the parameters to this statement.</source>
          <target state="translated">이 명령문에 대한 매개 변수의 의미에 대한 정보는 &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="caf3a3cb58a59c5e7d0b671f4b23ae6f1ac82bbd" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-BIT-STRINGS&quot;&gt;Section 4.1.2.5&lt;/a&gt; for information about the syntax of bit string constants. Bit-logical operators and string manipulation functions are available; see &lt;a href=&quot;functions-bitstring&quot;&gt;Section 9.6&lt;/a&gt;.</source>
          <target state="translated">비트 문자열 상수의 구문에 대한 정보는 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-BIT-STRINGS&quot;&gt;4.1.2.5 섹션을&lt;/a&gt; 참조하십시오 . 비트 논리 연산자 및 문자열 조작 기능을 사용할 수 있습니다. &lt;a href=&quot;functions-bitstring&quot;&gt;섹션 9.6&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="d35d3dc5bce3759ad0df28ccf9adfdcb5eaef1cd" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for information about the syntax of string literals, and to &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;Chapter 9&lt;/a&gt; for information about available operators and functions. The database character set determines the character set used to store textual values; for more information on character set support, refer to &lt;a href=&quot;multibyte&quot;&gt;Section 23.3&lt;/a&gt;.</source>
          <target state="translated">문자열 리터럴 구문에 대한 정보는 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;4.1.2.1 절을&lt;/a&gt; 참조하고 사용 가능한 연산자 및 함수에 대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/functions.html&quot;&gt;9 장&lt;/a&gt; 을 참조하십시오. 데이터베이스 문자 세트는 텍스트 값을 저장하는 데 사용되는 문자 세트를 결정합니다. 문자 집합 지원에 대한 자세한 내용 &lt;a href=&quot;multibyte&quot;&gt;은 23.3 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd33522d287c689996be4ad33839d1fb9ea883c6" translate="yes" xml:space="preserve">
          <source>Refer to &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;Section 4.1.2.1&lt;/a&gt; for information about the syntax of string literals, and to &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;Chapter 9&lt;/a&gt; for information about available operators and functions. The database character set determines the character set used to store textual values; for more information on character set support, refer to &lt;a href=&quot;multibyte&quot;&gt;Section 23.3&lt;/a&gt;.</source>
          <target state="translated">참조 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-STRINGS&quot;&gt;섹션 4.1.2.1&lt;/a&gt; 문자열 리터럴의 구문에 대한 정보, 그리고에 &lt;a href=&quot;https://www.postgresql.org/docs/13/functions.html&quot;&gt;제 9 장&lt;/a&gt; 사용 가능한 연산자와 함수에 대한 정보를 얻을 수 있습니다. 데이터베이스 문자 집합은 텍스트 값을 저장하는 데 사용되는 문자 집합을 결정합니다. 문자 집합 지원에 대한 자세한 내용은 &lt;a href=&quot;multibyte&quot;&gt;섹션 23.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68f526fdb1027db9af7b4687b7d1042dee620292" translate="yes" xml:space="preserve">
          <source>Reference to publication</source>
          <target state="translated">출판물 참조</target>
        </trans-unit>
        <trans-unit id="c91d0d87e60cb20990141bbe02d9f237a55e0121" translate="yes" xml:space="preserve">
          <source>Reference to relation</source>
          <target state="translated">관계에 대한 참조</target>
        </trans-unit>
        <trans-unit id="24af67776500e9991887cc83519acb42d9245d67" translate="yes" xml:space="preserve">
          <source>Reference to subscription</source>
          <target state="translated">구독에 대한 참조</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="7755b6b0268cbada41bfc99a6d01239ad804fdd5" translate="yes" xml:space="preserve">
          <source>References a handler function that is responsible for supplying execution routines for the foreign-data wrapper. Zero if no handler is provided</source>
          <target state="translated">외부 데이터 랩퍼에 대한 실행 루틴을 제공하는 처리기 함수를 참조하십시오. 처리기가 제공되지 않으면 0</target>
        </trans-unit>
        <trans-unit id="81f8ea3c3b2029895b80bf94078cee9ca10e2aad" translate="yes" xml:space="preserve">
          <source>References a validator function that is responsible for checking the validity of the options given to the foreign-data wrapper, as well as options for foreign servers and user mappings using the foreign-data wrapper. Zero if no validator is provided</source>
          <target state="translated">외부 데이터 랩퍼를 사용하는 외부 서버 및 사용자 맵핑 옵션뿐만 아니라 외부 데이터 랩퍼에 제공된 옵션의 유효성을 검사하는 유효성 검증기 함수를 참조합니다. 유효성 검사기가 제공되지 않으면 0</target>
        </trans-unit>
        <trans-unit id="94aee6d482ecb3f09069cf7385eb4b5f9994e8b3" translate="yes" xml:space="preserve">
          <source>References to the grouping columns or expressions are replaced by null values in result rows for grouping sets in which those columns do not appear. To distinguish which grouping a particular output row resulted from, see &lt;a href=&quot;functions-aggregate#FUNCTIONS-GROUPING-TABLE&quot;&gt;Table 9.59&lt;/a&gt;.</source>
          <target state="translated">그룹화 열 또는 표현식에 대한 참조는 해당 열이 표시되지 않는 그룹화 세트의 결과 행에서 널 (NULL) 값으로 대체됩니다. 특정 출력 행의 결과 그룹을 구별하려면 &lt;a href=&quot;functions-aggregate#FUNCTIONS-GROUPING-TABLE&quot;&gt;표 9.59를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fba017ac7720c88551d64e2d0ce5b1e36f4cc9f" translate="yes" xml:space="preserve">
          <source>Referential integrity</source>
          <target state="translated">참조 무결성</target>
        </trans-unit>
        <trans-unit id="66e02725ebd9aa9311d4a6b9c921ba2f715b0338" translate="yes" xml:space="preserve">
          <source>Referential integrity checks, such as unique or primary key constraints and foreign key references, always bypass row security to ensure that data integrity is maintained. Care must be taken when developing schemas and row level policies to avoid &amp;ldquo;covert channel&amp;rdquo; leaks of information through such referential integrity checks.</source>
          <target state="translated">고유 또는 기본 키 제약 조건 및 외래 키 참조와 같은 참조 무결성 검사는 데이터 무결성이 유지되도록 항상 행 보안을 무시합니다. 스키마 및 행 수준 정책을 개발할 때 이러한 참조 무결성 검사를 통해 정보의 &quot;비밀 한 채널&quot;유출을 피하기 위해주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="0e2b9c0f115444e379a6c97308738cfbdce59cf7" translate="yes" xml:space="preserve">
          <source>Refresh the materialized view without locking out concurrent selects on the materialized view. Without this option a refresh which affects a lot of rows will tend to use fewer resources and complete more quickly, but could block other connections which are trying to read from the materialized view. This option may be faster in cases where a small number of rows are affected.</source>
          <target state="translated">구체화 된보기에서 동시 선택을 잠그지 않고 구체화 된보기를 새로 고칩니다. 이 옵션을 사용하지 않으면 많은 행에 영향을주는 새로 고침이 더 적은 리소스를 사용하고 더 빨리 완료하는 경향이 있지만 구체화 된보기에서 읽으려는 다른 연결을 차단할 수 있습니다. 적은 수의 행이 영향을받는 경우이 옵션이 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bff75355c49691c7ddaa3736614750dd687bc9f" translate="yes" xml:space="preserve">
          <source>Refuse the operation if the type being altered is the type of a typed table. This is the default.</source>
          <target state="translated">변경되는 유형이 유형이 지정된 테이블의 유형 인 경우 조작을 거부하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="43dd73a807dfb39f857a0c4012b2a8804e8b8b55" translate="yes" xml:space="preserve">
          <source>Refuse to drop the access method if any objects depend on it. This is the default.</source>
          <target state="translated">액세스 방법에 의존하는 액세스 방법을 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c53c26491a1120ccd155c89dcd8b789b3da1f457" translate="yes" xml:space="preserve">
          <source>Refuse to drop the aggregate function if any objects depend on it. This is the default.</source>
          <target state="translated">객체가 의존하는 경우 집계 함수를 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="e7ddcc98242405d6ad6360c6007375ba7b09a193" translate="yes" xml:space="preserve">
          <source>Refuse to drop the collation if any objects depend on it. This is the default.</source>
          <target state="translated">데이터에 의존하는 데이터 정렬을 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="0eff259136cd7b78338514e5569fa22606ca59c2" translate="yes" xml:space="preserve">
          <source>Refuse to drop the column or constraint if there are any dependent objects. This is the default behavior.</source>
          <target state="translated">종속 개체가있는 경우 열 또는 제약 조건을 삭제하지 마십시오. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="c6e443e66ae892ab268aea2de27d2612ffcf26e8" translate="yes" xml:space="preserve">
          <source>Refuse to drop the constraint if there are any dependent objects. This is the default behavior.</source>
          <target state="translated">종속 개체가있는 경우 제약 조건을 삭제하지 마십시오. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="878d584397c7ef1b4398ad588dd45eaaa81e9f7e" translate="yes" xml:space="preserve">
          <source>Refuse to drop the domain if any objects depend on it. This is the default.</source>
          <target state="translated">도메인에 의존하는 도메인을 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="494cbc679f9ac7b42ef7100e5a73a27cd1613e1b" translate="yes" xml:space="preserve">
          <source>Refuse to drop the extension if any objects depend on it (other than its own member objects and other extensions listed in the same &lt;code&gt;DROP&lt;/code&gt; command). This is the default.</source>
          <target state="translated">개체가 종속 된 경우 확장을 삭제하지 마십시오 (자체 구성원 개체 및 동일한 &lt;code&gt;DROP&lt;/code&gt; 명령에 나열된 다른 확장명 제외). 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="1046e4eddd9a2d6c8d68bfedbc03eeced957bcb1" translate="yes" xml:space="preserve">
          <source>Refuse to drop the foreign table if any objects depend on it. This is the default.</source>
          <target state="translated">외부 테이블에 의존하는 외부 테이블을 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="defd51323ef723de63599b001264ee39e90d8913" translate="yes" xml:space="preserve">
          <source>Refuse to drop the foreign-data wrapper if any objects depend on it. This is the default.</source>
          <target state="translated">외부 데이터 랩퍼가 종속되어 있으면 외부 데이터 랩퍼를 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="0150383dd8d94436742bd8fd7109148d3d619e45" translate="yes" xml:space="preserve">
          <source>Refuse to drop the function if any objects depend on it. This is the default.</source>
          <target state="translated">객체가 의존하는 경우 함수를 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="9b7a0f391b0ee774d2c975d18104a182ee301c81" translate="yes" xml:space="preserve">
          <source>Refuse to drop the index if any objects depend on it. This is the default.</source>
          <target state="translated">객체가 의존하는 경우 인덱스 삭제를 거부하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="3f9ba1d7f006867a6e704b36618e8a1351cdf3a9" translate="yes" xml:space="preserve">
          <source>Refuse to drop the language if any objects depend on it. This is the default.</source>
          <target state="translated">언어에 의존하는 언어가 있으면 거부하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="2d9a2ecee02d4c9fc22f2f195b05c81bbb5dffdc" translate="yes" xml:space="preserve">
          <source>Refuse to drop the materialized view if any objects depend on it. This is the default.</source>
          <target state="translated">객체가 의존하는 경우 구체화 된 뷰를 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="621dea1a7e1320a745fbf978ba4106f8310bbce1" translate="yes" xml:space="preserve">
          <source>Refuse to drop the objects owned by a role if any other database objects depend on one of the affected objects. This is the default.</source>
          <target state="translated">다른 데이터베이스 개체가 영향을받는 개체 중 하나에 종속 된 경우 역할이 소유 한 개체를 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="8a789cc33300014ee350c2eb48b143dc9ddebad7" translate="yes" xml:space="preserve">
          <source>Refuse to drop the operator class if any objects depend on it. This is the default.</source>
          <target state="translated">객체에 의존하는 연산자 클래스를 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="870b2fe64c0ea33ce1b281919cc1325534fa4bad" translate="yes" xml:space="preserve">
          <source>Refuse to drop the operator family if any objects depend on it. This is the default.</source>
          <target state="translated">객체가 의존하는 경우 운영자 패밀리를 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c71f16d7b4f2d42d0daf40e50982f5b9c648cd4b" translate="yes" xml:space="preserve">
          <source>Refuse to drop the operator if any objects depend on it. This is the default.</source>
          <target state="translated">객체가 의존하는 경우 작업자를 떨어 뜨리지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="71b5d483fad1c4f863c70e262ab735a9835b4fc7" translate="yes" xml:space="preserve">
          <source>Refuse to drop the procedure if any objects depend on it. This is the default.</source>
          <target state="translated">개체가 종속되어 있으면 프로 시저 삭제를 거부하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="9fe1b207b360ccd2e50ad5d39db13b5f4dab9a8a" translate="yes" xml:space="preserve">
          <source>Refuse to drop the rule if any objects depend on it. This is the default.</source>
          <target state="translated">규칙에 종속 된 개체가 있으면 규칙을 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="a8c49b5275bc8ec12dcbae343b6866fe07992886" translate="yes" xml:space="preserve">
          <source>Refuse to drop the schema if it contains any objects. This is the default.</source>
          <target state="translated">스키마에 개체가 포함 된 스키마를 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="36dcab33503541d5152b5e1895fe66ce96d3c09a" translate="yes" xml:space="preserve">
          <source>Refuse to drop the sequence if any objects depend on it. This is the default.</source>
          <target state="translated">개체가 종속 된 경우 시퀀스 삭제를 거부하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="1c1316beeb6baf08045ac2b15886dc7a03419182" translate="yes" xml:space="preserve">
          <source>Refuse to drop the server if any objects depend on it. This is the default.</source>
          <target state="translated">서버에 개체가 있으면 서버를 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="712a6b7070757e2267379b7401ecb5c67a456fd4" translate="yes" xml:space="preserve">
          <source>Refuse to drop the table if any objects depend on it. This is the default.</source>
          <target state="translated">테이블에 의존하는 오브젝트가 있으면 테이블 삭제를 거부하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f1e9e5e684b308d1b0c8c4d05875be920d7482a1" translate="yes" xml:space="preserve">
          <source>Refuse to drop the text search configuration if any objects depend on it. This is the default.</source>
          <target state="translated">텍스트 검색 구성이 종속 된 경우 텍스트 검색 구성을 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="12d21ebdd940bb597e0dd37ed52c4791930900e2" translate="yes" xml:space="preserve">
          <source>Refuse to drop the text search dictionary if any objects depend on it. This is the default.</source>
          <target state="translated">텍스트 검색 사전이 의존하는 경우 텍스트 검색 사전을 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="fe470a506597a8b33a6ab332b146913b4a76f0f1" translate="yes" xml:space="preserve">
          <source>Refuse to drop the text search parser if any objects depend on it. This is the default.</source>
          <target state="translated">객체가 의존하는 경우 텍스트 검색 파서를 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="1d8bf83634871f4e22640603535dc9bbd13fc3ed" translate="yes" xml:space="preserve">
          <source>Refuse to drop the text search template if any objects depend on it. This is the default.</source>
          <target state="translated">텍스트 검색 템플릿이 의존하는 경우 텍스트 검색 템플릿을 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b9e6091f591793e8ad9c77664c041f40588c6069" translate="yes" xml:space="preserve">
          <source>Refuse to drop the transform if any objects depend on it. This is the default.</source>
          <target state="translated">오브젝트가 종속 된 경우 변환을 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="12837c5fd79e7a5b19bcb5f0dfa233e329516cdc" translate="yes" xml:space="preserve">
          <source>Refuse to drop the trigger if any objects depend on it. This is the default.</source>
          <target state="translated">어떤 물체에 의존하면 트리거를 떨어 뜨리지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="00c3304296f4b2519f194fc867b59cd8843fce10" translate="yes" xml:space="preserve">
          <source>Refuse to drop the type if any objects depend on it. This is the default.</source>
          <target state="translated">객체에 의존하는 유형을 삭제하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="df94617ebcdd5028135e035215bed2adcbba22e7" translate="yes" xml:space="preserve">
          <source>Refuse to drop the view if any objects depend on it. This is the default.</source>
          <target state="translated">객체가 의존하는 경우 뷰 삭제를 거부합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="a53ab26c76373620c2b1c6ead162b9dfbdb34341" translate="yes" xml:space="preserve">
          <source>Refuse to truncate if any of the tables have foreign-key references from tables that are not listed in the command. This is the default.</source>
          <target state="translated">명령에 나열되지 않은 테이블의 외래 키 참조가있는 테이블이 있으면 자르기를 거부하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c4174e7eda86d07af88d6484dd6458272b1bfb72" translate="yes" xml:space="preserve">
          <source>Registering Event Log on Windows</source>
          <target state="translated">Windows에서 이벤트 로그 등록</target>
        </trans-unit>
        <trans-unit id="34cd131c395b1f1047df22c0836fe7e66ca70df9" translate="yes" xml:space="preserve">
          <source>Registrations of buffers (step 2) and modifications of page images (step 3) can be mixed freely, i.e., both steps may be repeated in any sequence. Keep in mind that buffers should be registered in the same order in which locks are to be obtained on them during replay.</source>
          <target state="translated">버퍼의 등록 (단계 2) 및 페이지 이미지의 수정 (단계 3)은 자유롭게 혼합 될 수 있으며, 즉 두 단계는 임의의 순서로 반복 될 수있다. 버퍼는 재생 중에 잠금을 얻는 순서와 동일한 순서로 등록되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2fe3be7115c5a4aaa140d5f74508a43962501a6f" translate="yes" xml:space="preserve">
          <source>Regular expressions (REs), as defined in POSIX 1003.2, come in two forms: &lt;em&gt;extended&lt;/em&gt; REs or EREs (roughly those of &lt;code&gt;egrep&lt;/code&gt;), and &lt;em&gt;basic&lt;/em&gt; REs or BREs (roughly those of &lt;code&gt;ed&lt;/code&gt;). PostgreSQL supports both forms, and also implements some extensions that are not in the POSIX standard, but have become widely used due to their availability in programming languages such as Perl and Tcl. REs using these non-POSIX extensions are called &lt;em&gt;advanced&lt;/em&gt; REs or AREs in this documentation. AREs are almost an exact superset of EREs, but BREs have several notational incompatibilities (as well as being much more limited). We first describe the ARE and ERE forms, noting features that apply only to AREs, and then describe how BREs differ.</source>
          <target state="translated">POSIX 1003.2에 정의 된 정규 표현식 (RE)은 &lt;em&gt;확장&lt;/em&gt; RE 또는 ERE (대략 &lt;code&gt;egrep&lt;/code&gt; ) 및 &lt;em&gt;기본&lt;/em&gt; RE 또는 BRE (대략 &lt;code&gt;ed&lt;/code&gt; )의 두 가지 형식으로 제공됩니다 . PostgreSQL은 두 가지 형식을 모두 지원하며 POSIX 표준에는 없지만 Perl 및 Tcl과 같은 프로그래밍 언어에서 사용할 수 있기 때문에 널리 사용되는 일부 확장을 구현합니다. 이 비 POSIX 확장을 사용하는 RE를 이 문서에서 &lt;em&gt;고급&lt;/em&gt; RE 또는 ARE 라고 합니다. ARE는 거의 정확한 ERE의 상위 집합이지만 BRE에는 몇 가지 표기법 비 호환성 (더 제한적 임)이 있습니다. 먼저 ARE 및 ERE 양식을 설명하고 ARE에만 적용되는 기능을 언급 한 다음 BRE의 차이점을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6ef6a627f81168779c110d4a2624ef60760ec025" translate="yes" xml:space="preserve">
          <source>Regular index builds permit other regular index builds on the same table to occur simultaneously, but only one concurrent index build can occur on a table at a time. In both cases, no other types of schema modification on the table are allowed meanwhile. Another difference is that a regular &lt;code&gt;REINDEX TABLE&lt;/code&gt; or &lt;code&gt;REINDEX INDEX&lt;/code&gt; command can be performed within a transaction block, but &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; cannot.</source>
          <target state="translated">일반 인덱스 빌드를 사용하면 동일한 테이블에있는 다른 일반 인덱스 빌드가 동시에 발생할 수 있지만 한 번에 하나의 테이블에서 하나의 동시 인덱스 빌드 만 발생할 수 있습니다. 두 경우 모두 테이블에 대한 다른 유형의 스키마 수정은 허용되지 않습니다. 또 다른 차이점은 일반 &lt;code&gt;REINDEX TABLE&lt;/code&gt; 또는 &lt;code&gt;REINDEX INDEX&lt;/code&gt; 명령을 트랜잭션 블록 내에서 수행 할 수 있지만 &lt;code&gt;REINDEX CONCURRENTLY&lt;/code&gt; 는 수행 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d75179b4f5b958195a40c299fe90c950530340c8" translate="yes" xml:space="preserve">
          <source>Regular index builds permit other regular index builds on the same table to occur simultaneously, but only one concurrent index build can occur on a table at a time. In either case, schema modification of the table is not allowed while the index is being built. Another difference is that a regular &lt;code&gt;CREATE INDEX&lt;/code&gt; command can be performed within a transaction block, but &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; cannot.</source>
          <target state="translated">일반 인덱스 빌드를 사용하면 동일한 테이블에있는 다른 일반 인덱스 빌드가 동시에 발생할 수 있지만 한 번에 하나의 테이블에서 하나의 동시 인덱스 빌드 만 발생할 수 있습니다. 두 경우 모두 인덱스가 작성되는 동안 테이블의 스키마 수정이 허용되지 않습니다. 또 다른 차이점은 일반 &lt;code&gt;CREATE INDEX&lt;/code&gt; 명령을 트랜잭션 블록 내에서 수행 할 수 있지만 &lt;code&gt;CREATE INDEX CONCURRENTLY&lt;/code&gt; 는 수행 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ae8d3d81d2d5e40cfc055a729eccc7a81b64aa8" translate="yes" xml:space="preserve">
          <source>Regularly running commands that acquire locks conflicting with a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock (e.g., ANALYZE) can effectively prevent autovacuums from ever completing.</source>
          <target state="translated">&lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금 (예 : ANALYZE) 과 충돌하는 잠금을 획득하는 정기적으로 실행되는 명령은 자동 진공이 완료되는 것을 효과적으로 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8813ae31d27dcc310eb1f6124468134f135d4954" translate="yes" xml:space="preserve">
          <source>Reindex &lt;code&gt;schema&lt;/code&gt; only. Multiple schemas can be reindexed by writing multiple &lt;code&gt;-S&lt;/code&gt; switches.</source>
          <target state="translated">&lt;code&gt;schema&lt;/code&gt; 만 다시 색인화하십시오 . 여러 개의 &lt;code&gt;-S&lt;/code&gt; 스위치 를 작성하여 여러 스키마를 다시 인덱싱 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e1d5b57c9b34e9f9ada1758ccfa40ababc88563" translate="yes" xml:space="preserve">
          <source>Reindex &lt;code&gt;table&lt;/code&gt; only. Multiple tables can be reindexed by writing multiple &lt;code&gt;-t&lt;/code&gt; switches.</source>
          <target state="translated">&lt;code&gt;table&lt;/code&gt; 만 다시 색인화 하십시오 . 여러 개의 &lt;code&gt;-t&lt;/code&gt; 스위치 를 작성하여 여러 테이블을 다시 인덱싱 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d910fecb0d2357bf86c3b0ef74602bc6afd5b0e" translate="yes" xml:space="preserve">
          <source>Reindex all databases.</source>
          <target state="translated">모든 데이터베이스를 다시 색인화하십시오.</target>
        </trans-unit>
        <trans-unit id="6a3108bf4eb4882d7cc0b0d57cc25dc139c37e59" translate="yes" xml:space="preserve">
          <source>Reindex database's system catalogs.</source>
          <target state="translated">데이터베이스의 시스템 카탈로그를 재 색인하십시오.</target>
        </trans-unit>
        <trans-unit id="f58b3bd9c05456ac78d5c2219e30310661ebc6c0" translate="yes" xml:space="preserve">
          <source>Reindexing a single index or table requires being the owner of that index or table. Reindexing a schema or database requires being the owner of that schema or database. Note specifically that it's thus possible for non-superusers to rebuild indexes of tables owned by other users. However, as a special exception, when &lt;code&gt;REINDEX DATABASE&lt;/code&gt;, &lt;code&gt;REINDEX SCHEMA&lt;/code&gt; or &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; is issued by a non-superuser, indexes on shared catalogs will be skipped unless the user owns the catalog (which typically won't be the case). Of course, superusers can always reindex anything.</source>
          <target state="translated">단일 인덱스 또는 테이블을 다시 인덱싱하려면 해당 인덱스 또는 테이블의 소유자 여야합니다. 스키마 또는 데이터베이스를 다시 색인화하려면 해당 스키마 또는 데이터베이스의 소유자 여야합니다. 따라서 슈퍼 유저가 아닌 사용자가 다른 사용자가 소유 한 테이블의 인덱스를 다시 작성할 수 있습니다. 그러나 특별한 예외로 &lt;code&gt;REINDEX DATABASE&lt;/code&gt; , &lt;code&gt;REINDEX SCHEMA&lt;/code&gt; 또는 &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; 이 슈퍼 유저가 아닌 사용자가 발행 한 경우 사용자가 카탈로그를 소유하지 않는 한 공유 카탈로그의 인덱스를 건너 뜁니다 (일반적으로 그렇지 않음). 물론 수퍼 유저는 항상 무엇이든 재 색인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c38215271064777a005780ed0f0064fff7109bf4" translate="yes" xml:space="preserve">
          <source>Reindexing a single index or table requires being the owner of that index or table. Reindexing a schema or database requires being the owner of that schema or database. Note that is therefore sometimes possible for non-superusers to rebuild indexes of tables owned by other users. However, as a special exception, when &lt;code&gt;REINDEX DATABASE&lt;/code&gt;, &lt;code&gt;REINDEX SCHEMA&lt;/code&gt; or &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; is issued by a non-superuser, indexes on shared catalogs will be skipped unless the user owns the catalog (which typically won't be the case). Of course, superusers can always reindex anything.</source>
          <target state="translated">단일 인덱스 또는 테이블을 다시 인덱싱하려면 해당 인덱스 또는 테이블의 소유자 여야합니다. 스키마 또는 데이터베이스를 다시 색인화하려면 해당 스키마 또는 데이터베이스의 소유자 여야합니다. 따라서 수퍼 유저가 아닌 사용자가 다른 사용자가 소유 한 테이블의 인덱스를 재 빌드 할 수도 있습니다. 그러나 특별한 예외로, 수퍼 유저가 아닌 사용자가 &lt;code&gt;REINDEX DATABASE&lt;/code&gt; , &lt;code&gt;REINDEX SCHEMA&lt;/code&gt; 또는 &lt;code&gt;REINDEX SYSTEM&lt;/code&gt; 을 발행하는 경우, 사용자가 카탈로그를 소유하지 않으면 공유 카탈로그의 인덱스를 건너 뜁니다 (일반적으로 그렇지 않음). 물론, 수퍼 유저는 항상 무엇이든 다시 색인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3732c3e767e76fa61edf003049e8c01441bc75bd" translate="yes" xml:space="preserve">
          <source>Reindexing partitioned tables or partitioned indexes is not supported. Each individual partition can be reindexed separately instead.</source>
          <target state="translated">파티션 된 테이블 또는 파티션 된 인덱스 재 인덱싱은 지원되지 않습니다. 대신 개별 파티션을 개별적으로 다시 색인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59606e6327ee4c4f80cae8423c5dd84ab8e91cff" translate="yes" xml:space="preserve">
          <source>Reject the connection unconditionally. This is useful for &amp;ldquo;filtering out&amp;rdquo; certain hosts from a group, for example a &lt;code&gt;reject&lt;/code&gt; line could block a specific host from connecting, while a later line allows the remaining hosts in a specific network to connect.</source>
          <target state="translated">무조건 연결을 거부하십시오. 이는 그룹에서 특정 호스트를 &quot;필터링&quot;하는 데 유용합니다. 예를 들어 &lt;code&gt;reject&lt;/code&gt; 라인은 특정 호스트의 연결을 차단할 수있는 반면, 이후 라인은 특정 네트워크의 나머지 호스트를 연결할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="7c1dec438ab80dc49300e564a043eac51485c03c" translate="yes" xml:space="preserve">
          <source>Related operator classes can be grouped into &lt;em&gt;operator families&lt;/em&gt;. To add a new operator class to an existing family, specify the &lt;code&gt;FAMILY&lt;/code&gt; option in &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt;. Without this option, the new class is placed into a family named the same as the new class (creating that family if it doesn't already exist).</source>
          <target state="translated">관련 운영자 클래스는 &lt;em&gt;운영자 제품군&lt;/em&gt; 으로 그룹화 할 수 있습니다 . 기존 패밀리에 새 연산자 클래스를 추가하려면 &lt;code&gt;CREATE OPERATOR CLASS&lt;/code&gt; 에서 &lt;code&gt;FAMILY&lt;/code&gt; 옵션을 지정하십시오 . 이 옵션을 사용하지 않으면 새 클래스는 새 클래스와 같은 이름의 패밀리에 배치됩니다 (해당 패밀리가없는 경우 작성).</target>
        </trans-unit>
        <trans-unit id="33a5a7571bf686aab9c742d3d618a2dde6a4506e" translate="yes" xml:space="preserve">
          <source>Relation</source>
          <target state="translated">Relation</target>
        </trans-unit>
        <trans-unit id="f369ed623733cd6f463273c0aa73628b7ba95c1b" translate="yes" xml:space="preserve">
          <source>Relational Database Management System</source>
          <target state="translated">관계형 데이터베이스 관리 시스템</target>
        </trans-unit>
        <trans-unit id="cc77773ed3150c2411e560f9daf299ff511a8d6e" translate="yes" xml:space="preserve">
          <source>Release a shared session level advisory lock</source>
          <target state="translated">공유 세션 수준 자문 잠금 해제</target>
        </trans-unit>
        <trans-unit id="fd621b22b99e9ff0f3d224c0eaf33f077ebf084b" translate="yes" xml:space="preserve">
          <source>Release all session level advisory locks held by the current session</source>
          <target state="translated">현재 세션이 보유한 모든 세션 레벨 권고 잠금 해제</target>
        </trans-unit>
        <trans-unit id="ff6eabe4bcbd036e3fe085528fe5c290de6bb028" translate="yes" xml:space="preserve">
          <source>Release an exclusive session level advisory lock</source>
          <target state="translated">독점 세션 수준 자문 잠금 해제</target>
        </trans-unit>
        <trans-unit id="b17c46c1e06efd225afcd6a19ee115883c9d4cce" translate="yes" xml:space="preserve">
          <source>Releases a previously-acquired exclusive session-level advisory lock. Returns &lt;code&gt;true&lt;/code&gt; if the lock is successfully released. If the lock was not held, &lt;code&gt;false&lt;/code&gt; is returned, and in addition, an SQL warning will be reported by the server.</source>
          <target state="translated">이전에 획득 한 독점 세션 레벨 권고 잠금을 해제합니다. 잠금이 성공적으로 해제되면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 잠금이 유지되지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환되고 서버에서 SQL 경고가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="f9bf382980148e1eca3ac49ae95b205205a32ec8" translate="yes" xml:space="preserve">
          <source>Releases a previously-acquired shared session-level advisory lock. Returns &lt;code&gt;true&lt;/code&gt; if the lock is successfully released. If the lock was not held, &lt;code&gt;false&lt;/code&gt; is returned, and in addition, an SQL warning will be reported by the server.</source>
          <target state="translated">이전에 획득 한 공유 세션 레벨 권고 잠금을 해제합니다. 잠금이 성공적으로 해제되면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 잠금이 유지되지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환되고 서버에서 SQL 경고가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="c61f66f1507721e3f1b8e44c214575cedfff651c" translate="yes" xml:space="preserve">
          <source>Releases all cached query plans, forcing re-planning to occur the next time the associated prepared statement is used.</source>
          <target state="translated">캐시 된 모든 쿼리 계획을 해제하여 다음에 연관된 준비된 명령문이 사용될 때 재 계획이 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="d6e686a3f3a34208e6d58a83096d105074bc1e27" translate="yes" xml:space="preserve">
          <source>Releases all session-level advisory locks held by the current session. (This function is implicitly invoked at session end, even if the client disconnects ungracefully.)</source>
          <target state="translated">현재 세션이 보유한 모든 세션 레벨 권고 잠금을 해제합니다. (이 함수는 클라이언트가 비정상적으로 연결이 끊긴 경우에도 세션 종료시 암시 적으로 호출됩니다.)</target>
        </trans-unit>
        <trans-unit id="2a838b417fcda4f30e1a492d3ddbe99c9726ccc7" translate="yes" xml:space="preserve">
          <source>Releases all temporary resources associated with the current session and resets the session to its initial state. Currently, this has the same effect as executing the following sequence of statements:</source>
          <target state="translated">현재 세션과 관련된 모든 임시 리소스를 해제하고 세션을 초기 상태로 재설정합니다. 현재 이것은 다음 명령문 시퀀스를 실행하는 것과 동일한 효과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6780c7503406d5c808023f1dbc6dcca47d00fc73" translate="yes" xml:space="preserve">
          <source>Reliability</source>
          <target state="translated">Reliability</target>
        </trans-unit>
        <trans-unit id="f94181d90df67988ed71b6a4ef21359762c0df31" translate="yes" xml:space="preserve">
          <source>Reliability is an important property of any serious database system, and PostgreSQL does everything possible to guarantee reliable operation. One aspect of reliable operation is that all data recorded by a committed transaction should be stored in a nonvolatile area that is safe from power loss, operating system failure, and hardware failure (except failure of the nonvolatile area itself, of course). Successfully writing the data to the computer's permanent storage (disk drive or equivalent) ordinarily meets this requirement. In fact, even if a computer is fatally damaged, if the disk drives survive they can be moved to another computer with similar hardware and all committed transactions will remain intact.</source>
          <target state="translated">안정성은 모든 심각한 데이터베이스 시스템의 중요한 속성이며 PostgreSQL은 안정적인 작동을 보장하기 위해 가능한 모든 작업을 수행합니다. 신뢰할 수있는 작업의 한 측면은 커밋 된 트랜잭션에 의해 기록 된 모든 데이터가 전원 손실, 운영 체제 오류 및 하드웨어 오류 (비 휘발성 영역 자체의 오류는 제외)로부터 안전한 비 휘발성 영역에 저장되어야한다는 것입니다. 데이터를 컴퓨터의 영구 저장소 (디스크 드라이브 또는 이와 동등한 장치)에 성공적으로 쓰면 일반적으로이 요구 사항을 충족합니다. 실제로 컴퓨터가 심각하게 손상 되어도 디스크 드라이브가 살아남 으면 비슷한 하드웨어를 가진 다른 컴퓨터로 이동할 수 있으며 커밋 된 모든 트랜잭션은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="48ae4daa25d9b79feca4544e95c804ed055f470c" translate="yes" xml:space="preserve">
          <source>Reload with:</source>
          <target state="translated">다음으로 다시로드 :</target>
        </trans-unit>
        <trans-unit id="95e357c875cc07a5addf3d5db392d3a90e7e665e" translate="yes" xml:space="preserve">
          <source>Relocate the tablespace in directory &lt;code&gt;olddir&lt;/code&gt; to &lt;code&gt;newdir&lt;/code&gt; during the backup. To be effective, &lt;code&gt;olddir&lt;/code&gt; must exactly match the path specification of the tablespace as it is currently defined. (But it is not an error if there is no tablespace in &lt;code&gt;olddir&lt;/code&gt; contained in the backup.) Both &lt;code&gt;olddir&lt;/code&gt; and &lt;code&gt;newdir&lt;/code&gt; must be absolute paths. If a path happens to contain a &lt;code&gt;=&lt;/code&gt; sign, escape it with a backslash. This option can be specified multiple times for multiple tablespaces. See examples below.</source>
          <target state="translated">백업 중에 &lt;code&gt;olddir&lt;/code&gt; 디렉토리의 테이블 스페이스 를 &lt;code&gt;newdir&lt;/code&gt; 로 재배치하십시오 . 유효하려면 &lt;code&gt;olddir&lt;/code&gt; 이 현재 정의 된 테이블 스페이스의 경로 스펙과 정확히 일치해야합니다. (하지만 백업에 포함 된 &lt;code&gt;olddir&lt;/code&gt; 에 테이블 스페이스가없는 경우 오류가 아닙니다 .) &lt;code&gt;olddir&lt;/code&gt; 과 &lt;code&gt;newdir&lt;/code&gt; 은 모두 절대 경로 여야합니다. 경로에 &lt;code&gt;=&lt;/code&gt; 기호 가 있으면 백 슬래시로 이스케이프하십시오. 이 옵션은 여러 테이블 스페이스에 대해 여러 번 지정할 수 있습니다. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="81e6a2586f2d3c3c83745f7f7899a45449238ae9" translate="yes" xml:space="preserve">
          <source>Relocates the tablespace in directory &lt;code&gt;olddir&lt;/code&gt; to &lt;code&gt;newdir&lt;/code&gt; during the backup. To be effective, &lt;code&gt;olddir&lt;/code&gt; must exactly match the path specification of the tablespace as it is defined on the source server. (But it is not an error if there is no tablespace in &lt;code&gt;olddir&lt;/code&gt; on the source server.) Meanwhile &lt;code&gt;newdir&lt;/code&gt; is a directory in the receiving host's filesystem. As with the main target directory, &lt;code&gt;newdir&lt;/code&gt; need not exist already, but if it does exist it must be empty. Both &lt;code&gt;olddir&lt;/code&gt; and &lt;code&gt;newdir&lt;/code&gt; must be absolute paths. If either path needs to contain an equal sign (&lt;code&gt;=&lt;/code&gt;), precede that with a backslash. This option can be specified multiple times for multiple tablespaces.</source>
          <target state="translated">백업 중에 &lt;code&gt;olddir&lt;/code&gt; 디렉토리의 테이블 스페이스 를 &lt;code&gt;newdir&lt;/code&gt; 로 재배치합니다 . 유효하려면 &lt;code&gt;olddir&lt;/code&gt; 이 소스 서버에 정의 된 테이블 스페이스의 경로 사양과 정확히 일치해야합니다. (그러나 소스 서버의 &lt;code&gt;olddir&lt;/code&gt; 에 테이블 스페이스가없는 경우 오류가 아닙니다 .) 한편 &lt;code&gt;newdir&lt;/code&gt; 은 수신 호스트의 파일 시스템에있는 디렉토리입니다. 기본 대상 디렉토리와 마찬가지로 &lt;code&gt;newdir&lt;/code&gt; 이 이미 존재할 필요는 없지만 존재하는 경우 비어 있어야합니다. 두 &lt;code&gt;olddir&lt;/code&gt; 및 &lt;code&gt;newdir&lt;/code&gt; 절대 경로 여야합니다. 두 경로 중 하나에 등호 ( &lt;code&gt;=&lt;/code&gt; ), 그 앞에 백 슬래시가 붙습니다. 이 옵션은 여러 테이블 스페이스에 대해 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="185df7f99307bee7290fe4135ad35d38e9802de9" translate="yes" xml:space="preserve">
          <source>Remainder of &lt;em&gt;&lt;code&gt;y&lt;/code&gt;&lt;/em&gt;/&lt;em&gt;&lt;code&gt;x&lt;/code&gt;&lt;/em&gt;; available for &lt;code&gt;smallint&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;numeric&lt;/code&gt;</source>
          <target state="translated">나머지 &lt;em&gt; &lt;code&gt;y&lt;/code&gt; &lt;/em&gt; / &lt;em&gt; &lt;code&gt;x&lt;/code&gt; &lt;/em&gt; ; 사용할 수 &lt;code&gt;smallint&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; 및 &lt;code&gt;numeric&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e78ca558b7b645306875698b9871b0c8ac592f9" translate="yes" xml:space="preserve">
          <source>Remedial possibilities exist if the number of standby-query cancellations is found to be unacceptable. The first option is to set the parameter &lt;code&gt;hot_standby_feedback&lt;/code&gt;, which prevents &lt;code&gt;VACUUM&lt;/code&gt; from removing recently-dead rows and so cleanup conflicts do not occur. If you do this, you should note that this will delay cleanup of dead rows on the primary, which may result in undesirable table bloat. However, the cleanup situation will be no worse than if the standby queries were running directly on the primary server, and you are still getting the benefit of off-loading execution onto the standby. If standby servers connect and disconnect frequently, you might want to make adjustments to handle the period when &lt;code&gt;hot_standby_feedback&lt;/code&gt; feedback is not being provided. For example, consider increasing &lt;code&gt;max_standby_archive_delay&lt;/code&gt; so that queries are not rapidly canceled by conflicts in WAL archive files during disconnected periods. You should also consider increasing &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; to avoid rapid cancellations by newly-arrived streaming WAL entries after reconnection.</source>
          <target state="translated">대기 쿼리 취소 수가 허용되지 않는 것으로 확인되면 치료 가능성이 존재합니다. 첫 번째 옵션은 &lt;code&gt;hot_standby_feedback&lt;/code&gt; 매개 변수를 설정하는 것입니다. &lt;code&gt;VACUUM&lt;/code&gt; 이 최근에 죽은 행을 제거 하지 못하도록 하여 정리 충돌이 발생하지 않도록합니다. 이렇게하면 기본 행에서 사용 불능 행 정리가 지연되어 원하지 않는 테이블 팽창이 발생할 수 있습니다. 그러나 정리 쿼리는 대기 쿼리가 기본 서버에서 직접 실행되고 대기에서 오프로드 실행의 이점을 얻는 것보다 나쁘지 않습니다. 대기 서버가 자주 연결하고 연결을 끊는 경우 &lt;code&gt;hot_standby_feedback&lt;/code&gt; 기간을 처리하도록 조정할 수 있습니다.피드백이 제공되지 않습니다. 예를 들어, 연결이 끊어진 기간 동안 WAL 아카이브 파일의 충돌로 인해 쿼리가 빠르게 취소되지 않도록 &lt;code&gt;max_standby_archive_delay&lt;/code&gt; 를 늘리 십시오 . 또한 재 연결 후 새로 도착한 스트리밍 WAL 항목으로 인한 빠른 취소를 피하기 위해 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 를 늘리는 것도 고려해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e523c36981a750e68c1786cf70abb1c30ac3ee96" translate="yes" xml:space="preserve">
          <source>Remember that any date or time literal input needs to be enclosed in single quotes, like text strings. Refer to &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;Section 4.1.2.7&lt;/a&gt; for more information. SQL requires the following syntax</source>
          <target state="translated">날짜 또는 시간 리터럴 입력은 텍스트 문자열과 같이 작은 따옴표로 묶어야합니다. 자세한 정보는 &lt;a href=&quot;sql-syntax-lexical#SQL-SYNTAX-CONSTANTS-GENERIC&quot;&gt;4.1.2.7 절&lt;/a&gt; 을 참조하십시오. SQL에는 다음 구문이 필요합니다</target>
        </trans-unit>
        <trans-unit id="3e0b3a6925f48fde9d3773981544c11f88b9b699" translate="yes" xml:space="preserve">
          <source>Remember that if you want to be able to convert types both ways you need to declare casts both ways explicitly.</source>
          <target state="translated">두 가지 방식으로 유형을 변환하려면 캐스트를 명시 적으로 두 가지 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="9aaf166105bc52b3f7e13a48e1504eda53fe5b72" translate="yes" xml:space="preserve">
          <source>Remember that the extension itself is not considered to be within any schema: extensions have unqualified names that must be unique database-wide. But objects belonging to the extension can be within schemas.</source>
          <target state="translated">확장 자체는 스키마 내에있는 것으로 간주되지 않습니다. 확장에는 데이터베이스 전체에서 고유해야하는 규정되지 않은 이름이 있습니다. 그러나 확장에 속하는 개체는 스키마 내에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95621284dae010dd385d5ead41a0123ebd3423b7" translate="yes" xml:space="preserve">
          <source>Remember that what you write in an SQL command will first be interpreted as a string literal, and then as a composite. This doubles the number of backslashes you need (assuming escape string syntax is used). For example, to insert a &lt;code&gt;text&lt;/code&gt; field containing a double quote and a backslash in a composite value, you'd need to write:</source>
          <target state="translated">SQL 명령으로 작성한 내용은 먼저 문자열 리터럴로 해석 된 다음 복합으로 해석됩니다. 이렇게하면 필요한 백 슬래시 수가 두 배가됩니다 (이스케이프 문자열 구문이 사용되는 것으로 가정). 예를 들어, 복합 값에 큰 따옴표와 백 슬래시가 포함 된 &lt;code&gt;text&lt;/code&gt; 필드 를 삽입하려면 다음 과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="1bb0c9f245c255eae850f56ff9563deccd9b1a9f" translate="yes" xml:space="preserve">
          <source>Remember to take the sampling rate into account when processing the log file. For example, when computing TPS values, you need to multiply the numbers accordingly (e.g. with 0.01 sample rate, you'll only get 1/100 of the actual TPS).</source>
          <target state="translated">로그 파일을 처리 할 때 샘플링 속도를 고려해야합니다. 예를 들어, TPS 값을 계산할 때 그에 따라 숫자를 곱해야합니다 (예 : 0.01 샘플 레이트의 경우 실제 TPS의 1/100 만 얻음).</target>
        </trans-unit>
        <trans-unit id="a162e1d808039eb480796b36d2e29c9a1edbedbe" translate="yes" xml:space="preserve">
          <source>Remember to take the sampling rate into account when processing the log file. For example, when computing TPS values, you need to multiply the numbers accordingly (e.g., with 0.01 sample rate, you'll only get 1/100 of the actual TPS).</source>
          <target state="translated">로그 파일을 처리 할 때 샘플링 속도를 고려해야합니다. 예를 들어 TPS 값을 계산할 때 그에 따라 숫자를 곱해야합니다 (예 : 0.01 샘플 속도에서는 실제 TPS의 1/100 만 얻습니다).</target>
        </trans-unit>
        <trans-unit id="ab6cf957dae0dc19a48a039cf0750609cf67ca48" translate="yes" xml:space="preserve">
          <source>Remembering the bank database, suppose we debit $100.00 from Alice's account, and credit Bob's account, only to find later that we should have credited Wally's account. We could do it using savepoints like this:</source>
          <target state="translated">은행 데이터베이스를 기억하면 Alice의 계정에서 $ 100.00를 인출하고 Bob의 계정에 크레딧을 제공한다고 나중에 Wally의 계정에 크레딧을 부여했음을 알기 만하면됩니다. 다음과 같은 세이브 포인트를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56110fd2fcca6d08cb71eb3c8047529b3653ecf1" translate="yes" xml:space="preserve">
          <source>Remote LSN of the state change used for synchronization coordination when in &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;r&lt;/code&gt; states, otherwise null</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 또는 &lt;code&gt;r&lt;/code&gt; 상태에 있을 때 동기화 조정에 사용되는 상태 변경의 원격 LSN , 그렇지 않으면 null</target>
        </trans-unit>
        <trans-unit id="842c822478c504e35eeff8c45bae2b8ce6031242" translate="yes" xml:space="preserve">
          <source>Remote TCP/IP connections will not be possible unless the server is started with an appropriate value for the &lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt; configuration parameter, since the default behavior is to listen for TCP/IP connections only on the local loopback address &lt;code&gt;localhost&lt;/code&gt;.</source>
          <target state="translated">기본 동작은 로컬 루프백 주소 &lt;code&gt;localhost&lt;/code&gt; 에서만 TCP / IP 연결을 청취하는 것이므로 , 서버가 &lt;a href=&quot;runtime-config-connection#GUC-LISTEN-ADDRESSES&quot;&gt;listen_addresses&lt;/a&gt; 구성 매개 변수에 적절한 값으로 시작되지 않으면 원격 TCP / IP 연결이 불가능합니다 .</target>
        </trans-unit>
        <trans-unit id="a879f2dbaf3964d8aba5cd82556984ba4338d912" translate="yes" xml:space="preserve">
          <source>Remote host name or IP address</source>
          <target state="translated">원격 호스트 이름 또는 IP 주소</target>
        </trans-unit>
        <trans-unit id="6b71007d1384eab408c5512869ba7b411e571003" translate="yes" xml:space="preserve">
          <source>Remote host name or IP address, and remote port</source>
          <target state="translated">원격 호스트 이름 또는 IP 주소 및 원격 포트</target>
        </trans-unit>
        <trans-unit id="b1194dba360cbb280f4209079650ec51d43f8d7c" translate="yes" xml:space="preserve">
          <source>Remove a file</source>
          <target state="translated">파일 제거</target>
        </trans-unit>
        <trans-unit id="57552c6da0adf1c54f6663ca41f7250ccec030eb" translate="yes" xml:space="preserve">
          <source>Remove a role's password:</source>
          <target state="translated">역할의 비밀번호를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="2d0fbd4b60f564325702ec011fd855fb24a1415f" translate="yes" xml:space="preserve">
          <source>Remove a user from a group:</source>
          <target state="translated">그룹에서 사용자를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="3e428af973dad7ff57398c6b5295c67e6b45c8cb" translate="yes" xml:space="preserve">
          <source>Remove all existing files and subdirectories under the cluster data directory and under the root directories of any tablespaces you are using.</source>
          <target state="translated">클러스터 데이터 디렉토리 및 사용중인 테이블 스페이스의 루트 디렉토리 아래에있는 기존 파일 및 서브 디렉토리를 모두 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="b61e23de7ea2b18fa7cb28186fbc220e9900c0a6" translate="yes" xml:space="preserve">
          <source>Remove any files present in &lt;code&gt;pg_wal/&lt;/code&gt;; these came from the file system backup and are therefore probably obsolete rather than current. If you didn't archive &lt;code&gt;pg_wal/&lt;/code&gt; at all, then recreate it with proper permissions, being careful to ensure that you re-establish it as a symbolic link if you had it set up that way before.</source>
          <target state="translated">&lt;code&gt;pg_wal/&lt;/code&gt; 에있는 파일을 모두 제거하십시오 . 이것들은 파일 시스템 백업에서 나왔으므로 아마도 현재가 아니라 쓸모없는 것입니다. &lt;code&gt;pg_wal/&lt;/code&gt; 을 전혀 아카이브하지 않았다면 적절한 권한으로 다시 작성하여 이전에 그렇게 설정 한 경우 심볼릭 링크로 다시 설정하도록주의하십시오.</target>
        </trans-unit>
        <trans-unit id="c0a9f637f70e6e6b34b98189949106a438deac6c" translate="yes" xml:space="preserve">
          <source>Remove columns</source>
          <target state="translated">열 제거</target>
        </trans-unit>
        <trans-unit id="f54dd505a2435a6862e82a8c6260592aec8db2cf" translate="yes" xml:space="preserve">
          <source>Remove constraints</source>
          <target state="translated">구속 조건 제거</target>
        </trans-unit>
        <trans-unit id="f977a675b654e90cde5fe0899c4392ae4eaeb56b" translate="yes" xml:space="preserve">
          <source>Remove it again:</source>
          <target state="translated">다시 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="6a88d5788127cfbb7d39008266be2eedc60a62c8" translate="yes" xml:space="preserve">
          <source>Remove multiple operators in one command:</source>
          <target state="translated">하나의 명령으로 여러 연산자를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="dcd8ca723dcb2b36f8831966ed638adde36dfcc4" translate="yes" xml:space="preserve">
          <source>Remove the B-tree operator class &lt;code&gt;widget_ops&lt;/code&gt;:</source>
          <target state="translated">B- 트리 연산자 클래스 &lt;code&gt;widget_ops&lt;/code&gt; 를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="28566c3cc60824030f5ebb73b37b207275614f18" translate="yes" xml:space="preserve">
          <source>Remove the B-tree operator family &lt;code&gt;float_ops&lt;/code&gt;:</source>
          <target state="translated">B- 트리 연산자 패밀리 &lt;code&gt;float_ops&lt;/code&gt; 를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="94c59770db5398910f1083ac29d26d81a4f7d92e" translate="yes" xml:space="preserve">
          <source>Remove the left unary bitwise complement operator &lt;code&gt;~b&lt;/code&gt; for type &lt;code&gt;bit&lt;/code&gt;:</source>
          <target state="translated">왼쪽 단항 비트 보수 연산자를 제거 &lt;code&gt;~b&lt;/code&gt; 타입에 대한 &lt;code&gt;bit&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f864c9512e439d9745abb1e0507baeb680b4e245" translate="yes" xml:space="preserve">
          <source>Remove the longest string consisting only of characters in &lt;em&gt;&lt;code&gt;characters&lt;/code&gt;&lt;/em&gt; (a space by default) from the start and end of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">만 문자로 구성된 긴 문자열 분리 &lt;em&gt; &lt;code&gt;characters&lt;/code&gt; &lt;/em&gt; 처음부터 (기본적으로 공간)과 끝 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f70f796651f43a979a736adfe45570af5b33860a" translate="yes" xml:space="preserve">
          <source>Remove the longest string containing only bytes appearing in &lt;em&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/em&gt; from the start and end of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">단지에서 나타나는 바이트가 포함 된 긴 문자열을 제거 &lt;em&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/em&gt; 시작과 끝에서 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1ea63f4db46e23ebd666d0584c6061b7223bc43" translate="yes" xml:space="preserve">
          <source>Remove the longest string containing only characters from &lt;em&gt;&lt;code&gt;characters&lt;/code&gt;&lt;/em&gt; (a space by default) from the end of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">에서 문자 만 포함 된 긴 문자열 분리 &lt;em&gt; &lt;code&gt;characters&lt;/code&gt; &lt;/em&gt; 의 끝에서 (기본적으로 공간) &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9ff04983cdea8b96af38e8e4b6ccc20f3cf9809" translate="yes" xml:space="preserve">
          <source>Remove the longest string containing only characters from &lt;em&gt;&lt;code&gt;characters&lt;/code&gt;&lt;/em&gt; (a space by default) from the start of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">에서 문자 만 포함 된 긴 문자열 분리 &lt;em&gt; &lt;code&gt;characters&lt;/code&gt; &lt;/em&gt; 의 시작에서 (기본적으로 공간) &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a347ca08af9a1d623690133ccbe521d71621afa" translate="yes" xml:space="preserve">
          <source>Remove the longest string containing only characters from &lt;em&gt;&lt;code&gt;characters&lt;/code&gt;&lt;/em&gt; (a space by default) from the start, end, or both ends (&lt;code&gt;both&lt;/code&gt; is the default) of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">단지의 문자가 포함 된 긴 문자열 분리 &lt;em&gt; &lt;code&gt;characters&lt;/code&gt; &lt;/em&gt; 시작, 끝에서 (기본적으로 공간), 또는 양쪽을 ( &lt;code&gt;both&lt;/code&gt; 의 기본값) &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="772e09cb6631f01fb89f619f8b6f941d1bda1cb6" translate="yes" xml:space="preserve">
          <source>Remove the old columns from &lt;code&gt;pg_proc.h&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;pg_proc.h&lt;/code&gt; 에서 이전 열을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fd24a9c6e5dd730697527e9868cc7553497f755" translate="yes" xml:space="preserve">
          <source>Remove the power operator &lt;code&gt;a^b&lt;/code&gt; for type &lt;code&gt;integer&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 유형 의 거듭 제곱 연산자 &lt;code&gt;a^b&lt;/code&gt; 를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="620fad1ae165dd2bdce7daf265521745f6d3caa9" translate="yes" xml:space="preserve">
          <source>Remove the public EXECUTE permission that is normally granted on functions, for all functions subsequently created by role &lt;code&gt;admin&lt;/code&gt;:</source>
          <target state="translated">역할 &lt;code&gt;admin&lt;/code&gt; 에 의해 이후에 생성 된 모든 기능에 대해 일반적으로 기능에 부여 된 공개 EXECUTE 권한을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="29977f0371bbb0e075323c59b2545a05c552b320" translate="yes" xml:space="preserve">
          <source>Remove the public schema from &lt;code&gt;search_path&lt;/code&gt; in &lt;a href=&quot;config-setting#CONFIG-SETTING-CONFIGURATION-FILE&quot;&gt;&lt;code&gt;postgresql.conf&lt;/code&gt;&lt;/a&gt;. The ensuing user experience matches the previous pattern. In addition to that pattern's implications for functions and &lt;code&gt;CREATEROLE&lt;/code&gt;, this trusts database owners like &lt;code&gt;CREATEROLE&lt;/code&gt;. If you create functions or extensions in the public schema or assign the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege, &lt;code&gt;CREATEDB&lt;/code&gt; privilege or individual database ownership to users not warranting almost-superuser access, use the first pattern instead.</source>
          <target state="translated">&lt;a href=&quot;config-setting#CONFIG-SETTING-CONFIGURATION-FILE&quot;&gt; &lt;code&gt;postgresql.conf&lt;/code&gt; 의&lt;/a&gt; &lt;code&gt;search_path&lt;/code&gt; 에서 공개 스키마를 제거하십시오 . 계속되는 사용자 경험은 이전 패턴과 일치합니다. 기능에 대한 그 패턴의 의미뿐만 아니라 &lt;code&gt;CREATEROLE&lt;/code&gt; 같은이 신뢰 데이터베이스 소유자 &lt;code&gt;CREATEROLE&lt;/code&gt; . 공용 스키마에서 함수 또는 확장을 작성하거나 거의 수퍼 유저 액세스를 보증하지 않는 사용자에게 &lt;code&gt;CREATEROLE&lt;/code&gt; 권한, &lt;code&gt;CREATEDB&lt;/code&gt; 권한 또는 개별 데이터베이스 소유권을 지정하는 경우 첫 번째 패턴을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9070961546dc3808ef6a815af2f37a85fa483815" translate="yes" xml:space="preserve">
          <source>Remove the public schema from each user's default search path using &lt;code&gt;ALTER ROLE user SET search_path = &quot;$user&quot;&lt;/code&gt;. Everyone retains the ability to create objects in the public schema, but only qualified names will choose those objects. While qualified table references are fine, calls to functions in the public schema &lt;a href=&quot;typeconv-func&quot;&gt;will be unsafe or unreliable&lt;/a&gt;. Also, a user holding the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege can undo this setting and issue arbitrary queries under the identity of users relying on the setting. If you create functions or extensions in the public schema or grant &lt;code&gt;CREATEROLE&lt;/code&gt; to users not warranting this almost-superuser ability, use the first pattern instead.</source>
          <target state="translated">&lt;code&gt;ALTER ROLE user SET search_path = &quot;$user&quot;&lt;/code&gt; 사용하여 각 사용자의 기본 검색 경로에서 공용 스키마를 제거하십시오 . 모든 사람은 퍼블릭 스키마에서 객체를 생성 할 수 있지만 자격을 갖춘 이름 만 해당 객체를 선택합니다. 규정 된 테이블 참조는 양호하지만 공개 스키마의 함수 호출 &lt;a href=&quot;typeconv-func&quot;&gt;은 안전하지 않거나 신뢰할 수 없습니다&lt;/a&gt; . 또한 &lt;code&gt;CREATEROLE&lt;/code&gt; 권한을 가진 사용자 는이 설정을 실행 취소하고 해당 설정에 의존하는 사용자의 신분으로 임의의 쿼리를 발행 할 수 있습니다. 공용 스키마에서 함수 또는 확장을 작성 &lt;code&gt;CREATEROLE&lt;/code&gt; 수퍼 유저 기능을 보증하지 않는 사용자 에게 CREATEROLE 을 부여 하는 경우 첫 번째 패턴을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b4fc676aa8f5d6866cf23ebe901175d34e6835a4" translate="yes" xml:space="preserve">
          <source>Remove the public schema from the default search path, by modifying &lt;a href=&quot;config-setting#CONFIG-SETTING-CONFIGURATION-FILE&quot;&gt;&lt;code&gt;postgresql.conf&lt;/code&gt;&lt;/a&gt; or by issuing &lt;code&gt;ALTER ROLE ALL SET search_path = &quot;$user&quot;&lt;/code&gt;. Everyone retains the ability to create objects in the public schema, but only qualified names will choose those objects. While qualified table references are fine, calls to functions in the public schema &lt;a href=&quot;typeconv-func&quot;&gt;will be unsafe or unreliable&lt;/a&gt;. If you create functions or extensions in the public schema, use the first pattern instead. Otherwise, like the first pattern, this is secure unless an untrusted user is the database owner or holds the &lt;code&gt;CREATEROLE&lt;/code&gt; privilege.</source>
          <target state="translated">&lt;a href=&quot;config-setting#CONFIG-SETTING-CONFIGURATION-FILE&quot;&gt; &lt;code&gt;postgresql.conf&lt;/code&gt; &lt;/a&gt; 를 수정 하거나 &lt;code&gt;ALTER ROLE ALL SET search_path = &quot;$user&quot;&lt;/code&gt; 를 실행 하여 기본 검색 경로에서 공용 스키마를 제거하십시오 . 모든 사람이 공용 스키마에서 개체를 만들 수있는 기능을 보유하지만 정규화 된 이름 만 해당 개체를 선택합니다. 정규화 된 테이블 참조는 괜찮지 만 공개 스키마의 함수 호출 &lt;a href=&quot;typeconv-func&quot;&gt;은 안전하지 않거나 신뢰할 수 없습니다&lt;/a&gt; . 공용 스키마에서 함수 또는 확장을 생성하는 경우 대신 첫 번째 패턴을 사용합니다. 그렇지 않으면 첫 번째 패턴과 마찬가지로 신뢰할 수없는 사용자가 데이터베이스 소유자이거나 &lt;code&gt;CREATEROLE&lt;/code&gt; 권한을 보유하지 않는 한 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="eb2878da56d196bee52e23112b4f5efbc8eb5558" translate="yes" xml:space="preserve">
          <source>Remove the right unary factorial operator &lt;code&gt;x!&lt;/code&gt; for type &lt;code&gt;bigint&lt;/code&gt;:</source>
          <target state="translated">올바른 단항 계승 연산자 &lt;code&gt;x!&lt;/code&gt; 제거하십시오 ! &lt;code&gt;bigint&lt;/code&gt; 유형의 경우 :</target>
        </trans-unit>
        <trans-unit id="44f80c9ad85ce03c49b4438220d5965fc1a2da97" translate="yes" xml:space="preserve">
          <source>Remove the text search configuration &lt;code&gt;my_english&lt;/code&gt;:</source>
          <target state="translated">텍스트 검색 구성 &lt;code&gt;my_english&lt;/code&gt; 를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d5c793ba57aab45e30717fbdc0de286d4732569" translate="yes" xml:space="preserve">
          <source>Remove the text search dictionary &lt;code&gt;english&lt;/code&gt;:</source>
          <target state="translated">텍스트 검색 사전 &lt;code&gt;english&lt;/code&gt; 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d8c8148a34e2ed3b9a5e2f1b8e0e66aae753bce" translate="yes" xml:space="preserve">
          <source>Remove the text search parser &lt;code&gt;my_parser&lt;/code&gt;:</source>
          <target state="translated">텍스트 검색 파서 &lt;code&gt;my_parser&lt;/code&gt; 를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="027cddf95c7556fe219bf2b77e4616a66db9ed80" translate="yes" xml:space="preserve">
          <source>Remove the text search template &lt;code&gt;thesaurus&lt;/code&gt;:</source>
          <target state="translated">텍스트 검색 템플릿 &lt;code&gt;thesaurus&lt;/code&gt; 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="544c333ed1db6e1a8e344123e155991c21a9636d" translate="yes" xml:space="preserve">
          <source>Removes a file.</source>
          <target state="translated">파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="40078f30e14ce9f8008e35ee8d5b7cf8b67dca8e" translate="yes" xml:space="preserve">
          <source>Removes adjacent duplicates.</source>
          <target state="translated">인접한 중복을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="ce5e340b08bfa5fe98cd1e3185e6fc59b6b760e8" translate="yes" xml:space="preserve">
          <source>Removes all elements equal to the given value from the array. The array must be one-dimensional. Comparisons are done using &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; semantics, so it is possible to remove &lt;code&gt;NULL&lt;/code&gt;s.</source>
          <target state="translated">배열에서 주어진 값과 같은 모든 요소를 ​​제거합니다. 배열은 1 차원이어야합니다. 비교는 &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; 의미 체계를 사용하여 수행 되므로 &lt;code&gt;NULL&lt;/code&gt; 을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8eef00670aeb4613a0180beab86763c3ed6e8516" translate="yes" xml:space="preserve">
          <source>Removes any occurrence of the given &lt;em&gt;&lt;code&gt;lexeme&lt;/code&gt;&lt;/em&gt; from the &lt;em&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;vector&lt;/code&gt; &lt;/em&gt; 에서 지정된 &lt;em&gt; &lt;code&gt;lexeme&lt;/code&gt; &lt;/em&gt; 항목을 제거합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71bf8dcc3aa70cbba799dfa82b8a1b39139fe322" translate="yes" xml:space="preserve">
          <source>Removes any occurrences of the lexemes in &lt;em&gt;&lt;code&gt;lexemes&lt;/code&gt;&lt;/em&gt; from the &lt;em&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">의 어휘의 발생을 제거 &lt;em&gt; &lt;code&gt;lexemes&lt;/code&gt; &lt;/em&gt; 로부터 &lt;em&gt; &lt;code&gt;vector&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0e9919eeb323a0f7b2985db30e3bc679ba1b1859" translate="yes" xml:space="preserve">
          <source>Removes elements of the right array from the left array.</source>
          <target state="translated">왼쪽 배열에서 오른쪽 배열의 요소를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="7a9da4ccf8b704ea73a81ea1491d54ed3c0d1e40" translate="yes" xml:space="preserve">
          <source>Removes entries matching the right argument from the array.</source>
          <target state="translated">배열에서 오른쪽 인수와 일치하는 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3dd30350e5ecfa55655a556a8741304daef7adcd" translate="yes" xml:space="preserve">
          <source>Removes positions and weights from the &lt;code&gt;tsvector&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 에서 위치와 가중치를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="0fe672f1509983b56fb51037eb6302f58575f17b" translate="yes" xml:space="preserve">
          <source>Removes the BRIN index tuple that summarizes the page range covering the given table block, if there is one.</source>
          <target state="translated">주어진 테이블 블록이있는 경우 해당 테이블 블록을 포함하는 페이지 범위를 요약하는 BRIN 인덱스 튜플을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4c85efeb5a8a54da47e4bbae96b514efab99cf0e" translate="yes" xml:space="preserve">
          <source>Removes the longest string containing only bytes appearing in &lt;em&gt;&lt;code&gt;bytesremoved&lt;/code&gt;&lt;/em&gt; from the start and end of &lt;em&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">단지에서 나타나는 바이트가 포함 된 긴 문자열을 제거 &lt;em&gt; &lt;code&gt;bytesremoved&lt;/code&gt; &lt;/em&gt; 시작과 끝에서 &lt;em&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="63085021a7a5f28ec5ea645a4b6254efba0a058c" translate="yes" xml:space="preserve">
          <source>Removes the longest string containing only characters in &lt;em&gt;&lt;code&gt;characters&lt;/code&gt;&lt;/em&gt; (a space by default) from the end of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">만 문자가 포함 된 가장 긴 문자열을 제거 &lt;em&gt; &lt;code&gt;characters&lt;/code&gt; &lt;/em&gt; 의 끝에서 (기본적으로 공간) &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bc6b1eb890f1388c5bba505e455fd727ccaae0cb" translate="yes" xml:space="preserve">
          <source>Removes the longest string containing only characters in &lt;em&gt;&lt;code&gt;characters&lt;/code&gt;&lt;/em&gt; (a space by default) from the start and end of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">만 문자가 포함 된 가장 긴 문자열을 제거 &lt;em&gt; &lt;code&gt;characters&lt;/code&gt; &lt;/em&gt; 의 시작과 끝에서 (기본적으로 공백) &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c7c2be14a8139b2738fdb2998a63fefb98fe8104" translate="yes" xml:space="preserve">
          <source>Removes the longest string containing only characters in &lt;em&gt;&lt;code&gt;characters&lt;/code&gt;&lt;/em&gt; (a space by default) from the start of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">만 문자가 포함 된 가장 긴 문자열을 제거 &lt;em&gt; &lt;code&gt;characters&lt;/code&gt; &lt;/em&gt; 의 시작에서 (기본적으로 공간) &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3113ff257957df81012ca8ddc6809c55e730b2ba" translate="yes" xml:space="preserve">
          <source>Removes the longest string containing only characters in &lt;em&gt;&lt;code&gt;characters&lt;/code&gt;&lt;/em&gt; (a space by default) from the start, end, or both ends (&lt;code&gt;BOTH&lt;/code&gt; is the default) of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">만 문자가 포함 된 가장 긴 문자열을 제거 &lt;em&gt; &lt;code&gt;characters&lt;/code&gt; &lt;/em&gt; (시작, 끝에서 (기본적으로 공간), 또는 양쪽 끝을 &lt;code&gt;BOTH&lt;/code&gt; 의 기본값) &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c0904861ebe57004a8eb3d40b476d16313409d99" translate="yes" xml:space="preserve">
          <source>Rename a file</source>
          <target state="translated">파일 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="983127fc3b4932782da0b343978a6d5a28fd3cb0" translate="yes" xml:space="preserve">
          <source>Rename columns</source>
          <target state="translated">열 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="c3dfbff60f6bb713f73dd6688d55659fd85340de" translate="yes" xml:space="preserve">
          <source>Rename tables</source>
          <target state="translated">테이블 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="1b379e85bf09554c4ba4e4fedb5d295b72bdfb82" translate="yes" xml:space="preserve">
          <source>Rename tablespace &lt;code&gt;index_space&lt;/code&gt; to &lt;code&gt;fast_raid&lt;/code&gt;:</source>
          <target state="translated">테이블 스페이스 &lt;code&gt;index_space&lt;/code&gt; 의 이름을 fast_raid 로 &lt;code&gt;fast_raid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edaeaa943e0e73b9842f314411a15b5c733b0b00" translate="yes" xml:space="preserve">
          <source>Renames a file.</source>
          <target state="translated">파일의 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="b4634ecaac0ff1ac1f0be3e805b594d7787cdbea" translate="yes" xml:space="preserve">
          <source>Renaming an index acquires a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock.</source>
          <target state="translated">인덱스 이름을 바꾸면 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금이 획득 됩니다.</target>
        </trans-unit>
        <trans-unit id="dd51402825de5813421c28b307b2961d0bd344ad" translate="yes" xml:space="preserve">
          <source>Repeat &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; the specified &lt;em&gt;&lt;code&gt;number&lt;/code&gt;&lt;/em&gt; of times</source>
          <target state="translated">반복 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 지정된 &lt;em&gt; &lt;code&gt;number&lt;/code&gt; &lt;/em&gt; 시간</target>
        </trans-unit>
        <trans-unit id="6652d4ac01f0857bd97cf41fb36cb38527592b64" translate="yes" xml:space="preserve">
          <source>Repeatable read</source>
          <target state="translated">반복 가능한 읽기</target>
        </trans-unit>
        <trans-unit id="a78e4d34bd573771f51cd07e7f7e6bc4165b167d" translate="yes" xml:space="preserve">
          <source>Repeatedly execute the current query buffer (as &lt;code&gt;\g&lt;/code&gt; does) until interrupted or the query fails. Wait the specified number of seconds (default 2) between executions. Each query result is displayed with a header that includes the &lt;code&gt;\pset title&lt;/code&gt; string (if any), the time as of query start, and the delay interval.</source>
          <target state="translated">중단되거나 쿼리가 실패 할 때까지 현재 쿼리 버퍼를 &lt;code&gt;\g&lt;/code&gt; 처럼 반복해서 실행하십시오 . 실행 사이에 지정된 시간 (초)을 기다립니다 (기본값 2). 각 쿼리 결과는 &lt;code&gt;\pset title&lt;/code&gt; 문자열 (있는 경우), 쿼리 시작 시간 및 지연 간격 을 포함하는 헤더와 함께 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="8bab0590c3cabc8329af39557bcecd064567aac6" translate="yes" xml:space="preserve">
          <source>Repeats &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; the specified &lt;em&gt;&lt;code&gt;number&lt;/code&gt;&lt;/em&gt; of times.</source>
          <target state="translated">지정된 &lt;em&gt; &lt;code&gt;number&lt;/code&gt; &lt;/em&gt;&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 반복 &lt;em&gt;합니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4acbc8176a46ccfec5ce02471e187112ad89fe22" translate="yes" xml:space="preserve">
          <source>Repeats the most recent server error message at maximum verbosity, as though &lt;code&gt;VERBOSITY&lt;/code&gt; were set to &lt;code&gt;verbose&lt;/code&gt; and &lt;code&gt;SHOW_CONTEXT&lt;/code&gt; were set to &lt;code&gt;always&lt;/code&gt;.</source>
          <target state="translated">비록, 최대 상세에서 가장 최근의 서버 오류 메시지가 반복 &lt;code&gt;VERBOSITY&lt;/code&gt; 설정 한 &lt;code&gt;verbose&lt;/code&gt; 및 &lt;code&gt;SHOW_CONTEXT&lt;/code&gt; 이 설정되었습니다 &lt;code&gt;always&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="985bff2e66b26070f9eba4257882e74b1881d3fd" translate="yes" xml:space="preserve">
          <source>Replace all occurrences in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; of substring &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; with substring &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">모든 발생 바꾸기 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 문자열의를 &lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt; 하위 문자열과 &lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="52538fb3b2939a956fb894433be904beaeb513f9" translate="yes" xml:space="preserve">
          <source>Replace substring</source>
          <target state="translated">부분 문자열 바꾸기</target>
        </trans-unit>
        <trans-unit id="346914142a41e369762f438f2de4bd85c9d64449" translate="yes" xml:space="preserve">
          <source>Replace substring(s) matching a POSIX regular expression. See &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt; for more information.</source>
          <target state="translated">POSIX 정규식과 일치하는 하위 문자열을 교체하십시오. 자세한 정보는 &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;9.7.3 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d1d2947a40abfbdc9d683203869535afbcafc82" translate="yes" xml:space="preserve">
          <source>Replace the contents of the working table with the contents of the intermediate table, then empty the intermediate table.</source>
          <target state="translated">작업 테이블의 내용을 중간 테이블의 내용으로 바꾸고 중간 테이블을 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="d9d20440418bfc8c893b271b4337d368899af254" translate="yes" xml:space="preserve">
          <source>Replaces all occurrences in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; of substring &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; with substring &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">에있는 모든 항목을 대체 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 하위 문자열의 &lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt; 하위 문자열과 &lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e1940671ddd8eff4c98b2ec4716f232970912677" translate="yes" xml:space="preserve">
          <source>Replaces each array element equal to the second argument with the third argument.</source>
          <target state="translated">두 번째 인수와 동일한 각 배열 요소를 세 번째 인수로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="b73fbf2ad52b871d1a430a0f39d6e3b753039c7f" translate="yes" xml:space="preserve">
          <source>Replaces each character in &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; that matches a character in the &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; set with the corresponding character in the &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt; set. If &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; is longer than &lt;em&gt;&lt;code&gt;to&lt;/code&gt;&lt;/em&gt;, occurrences of the extra characters in &lt;em&gt;&lt;code&gt;from&lt;/code&gt;&lt;/em&gt; are deleted.</source>
          <target state="translated">각 문자 대체 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 의 문자와 일치 &lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt; 에 대응하는 문자 세트 &lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt; 세트. 경우 &lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt; 보다 더 이상 &lt;em&gt; &lt;code&gt;to&lt;/code&gt; &lt;/em&gt; ,에 추가 문자의 발생 &lt;em&gt; &lt;code&gt;from&lt;/code&gt; &lt;/em&gt; 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="845194f9892e139e86c109c774f60849979f81ab" translate="yes" xml:space="preserve">
          <source>Replaces fields in the left operand (which must be a composite type) with matching values from &lt;code&gt;hstore&lt;/code&gt;.</source>
          <target state="translated">왼쪽 피연산자 (복합 유형이어야 함)의 필드를 &lt;code&gt;hstore&lt;/code&gt; 의 일치하는 값으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="780419290a23bd115a82387286764efbb75f94f7" translate="yes" xml:space="preserve">
          <source>Replaces occurrences of &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; with &lt;em&gt;&lt;code&gt;substitute&lt;/code&gt;&lt;/em&gt; within the &lt;em&gt;&lt;code&gt;query&lt;/code&gt;&lt;/em&gt;. See &lt;a href=&quot;textsearch-features#TEXTSEARCH-QUERY-REWRITING&quot;&gt;Section 12.4.2.1&lt;/a&gt; for details.</source>
          <target state="translated">의 발생 대체 &lt;em&gt; &lt;code&gt;target&lt;/code&gt; &lt;/em&gt; 로 &lt;em&gt; &lt;code&gt;substitute&lt;/code&gt; &lt;/em&gt; 내에서 &lt;em&gt; &lt;code&gt;query&lt;/code&gt; &lt;/em&gt; . 자세한 내용은 &lt;a href=&quot;textsearch-features#TEXTSEARCH-QUERY-REWRITING&quot;&gt;섹션 12.4.2.1&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b6fcb0d5c49f6356f8457f0a3e87071d175aceda" translate="yes" xml:space="preserve">
          <source>Replaces portions of the &lt;em&gt;&lt;code&gt;query&lt;/code&gt;&lt;/em&gt; according to target(s) and substitute(s) obtained by executing a &lt;code&gt;SELECT&lt;/code&gt; command. See &lt;a href=&quot;textsearch-features#TEXTSEARCH-QUERY-REWRITING&quot;&gt;Section 12.4.2.1&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 명령 을 실행하여 얻은 대상 및 대체 항목에 따라 &lt;em&gt; &lt;code&gt;query&lt;/code&gt; &lt;/em&gt; 일부를 바꿉니다 . 자세한 내용은 &lt;a href=&quot;textsearch-features#TEXTSEARCH-QUERY-REWRITING&quot;&gt;섹션 12.4.2.1&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03bd8e67a7a9e63fc46f83333c283846a6adf942" translate="yes" xml:space="preserve">
          <source>Replaces substring(s) matching a POSIX regular expression; see &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;.</source>
          <target state="translated">POSIX 정규식과 일치하는 하위 문자열을 대체합니다. &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;9.7.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83f62be056c8794825658f48ac3e869bd065d20e" translate="yes" xml:space="preserve">
          <source>Replaces the substring of &lt;em&gt;&lt;code&gt;bits&lt;/code&gt;&lt;/em&gt; that starts at the &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt;'th bit and extends for &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; bits with &lt;em&gt;&lt;code&gt;newsubstring&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; is omitted, it defaults to the length of &lt;em&gt;&lt;code&gt;newsubstring&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">대체 문자열의 &lt;em&gt; &lt;code&gt;bits&lt;/code&gt; &lt;/em&gt; 상기 시작하는 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 번째의 비트가 확장 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 와 비트 &lt;em&gt; &lt;code&gt;newsubstring&lt;/code&gt; 를&lt;/em&gt; . 경우 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 의 길이 생략, 기본값 &lt;em&gt; &lt;code&gt;newsubstring&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0d5d4c590eecac7047224b612476400d48aa3d75" translate="yes" xml:space="preserve">
          <source>Replaces the substring of &lt;em&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/em&gt; that starts at the &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt;'th byte and extends for &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; bytes with &lt;em&gt;&lt;code&gt;newsubstring&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; is omitted, it defaults to the length of &lt;em&gt;&lt;code&gt;newsubstring&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 번째 바이트 에서 &lt;em&gt;시작&lt;/em&gt; 하고 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 바이트 까지 확장 되는 &lt;em&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/em&gt; 의 하위 문자열을 &lt;em&gt; &lt;code&gt;newsubstring&lt;/code&gt; &lt;/em&gt; 으로 &lt;em&gt;바꿉니다&lt;/em&gt; . 경우 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 의 길이 생략, 기본값 &lt;em&gt; &lt;code&gt;newsubstring&lt;/code&gt; &lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed45d4683718344fdf487a21fd38bb3ddd1cf3c7" translate="yes" xml:space="preserve">
          <source>Replaces the substring of &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; that starts at the &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt;'th character and extends for &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; characters with &lt;em&gt;&lt;code&gt;newsubstring&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; is omitted, it defaults to the length of &lt;em&gt;&lt;code&gt;newsubstring&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">첫 번째 문자 에서 &lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 하고 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 문자 까지 확장 되는 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 의 부분 &lt;em&gt;문자열&lt;/em&gt; 을 &lt;em&gt; &lt;code&gt;newsubstring&lt;/code&gt; &lt;/em&gt; 으로 &lt;em&gt;대체&lt;/em&gt; 합니다. 경우 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 의 길이 생략, 기본값 &lt;em&gt; &lt;code&gt;newsubstring&lt;/code&gt; &lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39a1b992938e47b31d1b7475fb6a1c6649dfe37a" translate="yes" xml:space="preserve">
          <source>Replica (server)</source>
          <target state="translated">복제본 (서버)</target>
        </trans-unit>
        <trans-unit id="a39800a0c59941c74fe3ff53e8f936d8cf8bafab" translate="yes" xml:space="preserve">
          <source>Replicas accept read-only queries</source>
          <target state="translated">복제본은 읽기 전용 쿼리를 허용</target>
        </trans-unit>
        <trans-unit id="722a8bb542ea393f48ca936e084109b805daa87a" translate="yes" xml:space="preserve">
          <source>Replication</source>
          <target state="translated">Replication</target>
        </trans-unit>
        <trans-unit id="6f09fb875fe3a38f5c516ac01b6a0f360fb74e68" translate="yes" xml:space="preserve">
          <source>Replication is only possible from base tables to base tables. That is, the tables on the publication and on the subscription side must be normal tables, not views, materialized views, partition root tables, or foreign tables. In the case of partitions, you can therefore replicate a partition hierarchy one-to-one, but you cannot currently replicate to a differently partitioned setup. Attempts to replicate tables other than base tables will result in an error.</source>
          <target state="translated">기본 테이블에서 기본 테이블로만 복제 할 수 있습니다. 즉, 발행 및 구독 측의 테이블은 뷰, 구체화 된 뷰, 파티션 루트 테이블 또는 외부 테이블이 아닌 일반 테이블이어야합니다. 파티션의 경우 파티션 계층 구조를 일대일로 복제 할 수 있지만 현재는 다르게 분할 된 설정으로 복제 할 수 없습니다. 기본 테이블 이외의 테이블을 복제하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79c532e556845959d1c358e85de054c0f1cfba78" translate="yes" xml:space="preserve">
          <source>Replication is only supported by tables, including partitioned tables. Attempts to replicate other types of relations, such as views, materialized views, or foreign tables, will result in an error.</source>
          <target state="translated">복제는 파티션 된 테이블을 포함하여 테이블에서만 지원됩니다. 뷰, 구체화 된 뷰 또는 외부 테이블과 같은 다른 유형의 관계를 복제하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f1f12470b4ef6c8cb7c1354648de3fd389be1165" translate="yes" xml:space="preserve">
          <source>Replication of &lt;code&gt;TRUNCATE&lt;/code&gt; commands is supported, but some care must be taken when truncating groups of tables connected by foreign keys. When replicating a truncate action, the subscriber will truncate the same group of tables that was truncated on the publisher, either explicitly specified or implicitly collected via &lt;code&gt;CASCADE&lt;/code&gt;, minus tables that are not part of the subscription. This will work correctly if all affected tables are part of the same subscription. But if some tables to be truncated on the subscriber have foreign-key links to tables that are not part of the same (or any) subscription, then the application of the truncate action on the subscriber will fail.</source>
          <target state="translated">&lt;code&gt;TRUNCATE&lt;/code&gt; 명령의 복제 가 지원되지만 외래 키로 연결된 테이블 그룹을자를 때는주의를 기울여야합니다. 자르기 조치를 복제 할 때 구독자는 명시 적으로 지정되거나 내재적으로 &lt;code&gt;CASCADE&lt;/code&gt; 를 통해 내재적으로 수집 된 발행자에서 잘린 동일한 테이블 그룹을 구독의 일부가 아닌 테이블 에서 자릅니다 . 영향을받는 모든 테이블이 동일한 구독의 일부인 경우 올바르게 작동합니다. 그러나 구독자에서 잘리는 일부 테이블에 동일한 (또는 다른) 구독의 일부가 아닌 테이블에 대한 외래 키 링크가있는 경우 구독자에서 자르기 작업을 적용하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="43a5ca330e60a751d1b568887d69d1006363638c" translate="yes" xml:space="preserve">
          <source>Replication slot name used by this WAL receiver</source>
          <target state="translated">이 WAL 수신자가 사용하는 복제 슬롯 이름</target>
        </trans-unit>
        <trans-unit id="1d2d71c0380e4834aaf46c99ba1ffb1a8b30df8c" translate="yes" xml:space="preserve">
          <source>Replication slots provide an automated way to ensure that the master does not remove WAL segments until they have been received by all standbys, and that the master does not remove rows which could cause a &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;recovery conflict&lt;/a&gt; even when the standby is disconnected.</source>
          <target state="translated">복제 슬롯은 마스터가 모든 대기에서 수신 될 때까지 마스터가 WAL 세그먼트를 제거하지 못하도록 하고 대기가 연결 해제 된 경우에도 &lt;a href=&quot;hot-standby#HOT-STANDBY-CONFLICT&quot;&gt;복구 충돌을&lt;/a&gt; 일으킬 수있는 행을 제거하지 않도록 자동화 된 방법을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c694ca7535113be29774a178a3c7065aa27cbae7" translate="yes" xml:space="preserve">
          <source>Report the average per-statement latency (execution time from the perspective of the client) of each command after the benchmark finishes. See below for details.</source>
          <target state="translated">벤치 마크가 완료된 후 각 명령의 평균 상태 별 대기 시간 (클라이언트 관점에서 실행 시간)을보고하십시오. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b9dd22f01446ace65614fd4ab08f76707d9d9443" translate="yes" xml:space="preserve">
          <source>Report the specified scale factor in pgbench's output. With the built-in tests, this is not necessary; the correct scale factor will be detected by counting the number of rows in the &lt;code&gt;pgbench_branches&lt;/code&gt; table. However, when testing only custom benchmarks (&lt;code&gt;-f&lt;/code&gt; option), the scale factor will be reported as 1 unless this option is used.</source>
          <target state="translated">pgbench의 출력에서 ​​지정된 배율을보고합니다. 내장 테스트에서는 필요하지 않습니다. &lt;code&gt;pgbench_branches&lt;/code&gt; 테이블 의 행 수를 세면 올바른 배율이 감지됩니다 . 그러나 사용자 지정 벤치 마크 ( &lt;code&gt;-f&lt;/code&gt; 옵션) 만 테스트 할 경우이 옵션을 사용하지 않으면 배율이 1로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="2d83062c6a01e8b746b30b163b41d66312c1d063" translate="yes" xml:space="preserve">
          <source>Reports an error that caused all database sessions to abort.</source>
          <target state="translated">모든 데이터베이스 세션이 중단 된 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="634362caeb68a2478dfff4d7450be36e15342477" translate="yes" xml:space="preserve">
          <source>Reports an error that caused the current command to abort.</source>
          <target state="translated">현재 명령이 중단 된 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="a0c0ba295058bb797fc1c18d0e77e23b1df7c51b" translate="yes" xml:space="preserve">
          <source>Reports an error that caused the current session to abort.</source>
          <target state="translated">현재 세션이 중단 된 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="083e20585228364d83f96aba60d408f319ad22e3" translate="yes" xml:space="preserve">
          <source>Reports information of interest to administrators, e.g., checkpoint activity.</source>
          <target state="translated">검사 점 활동과 같이 관리자에게 관심있는 정보를보고합니다.</target>
        </trans-unit>
        <trans-unit id="079787438557ad9e9bf288e78cc8f82d185e130c" translate="yes" xml:space="preserve">
          <source>Reports the commit status of a recent transaction. The result is one of &lt;code id=&quot;in32progress&quot;&gt;in progress&lt;/code&gt;, &lt;code&gt;committed&lt;/code&gt;, or &lt;code&gt;aborted&lt;/code&gt;, provided that the transaction is recent enough that the system retains the commit status of that transaction. If it is old enough that no references to the transaction survive in the system and the commit status information has been discarded, the result is &lt;code&gt;NULL&lt;/code&gt;. Applications might use this function, for example, to determine whether their transaction committed or aborted after the application and database server become disconnected while a &lt;code&gt;COMMIT&lt;/code&gt; is in progress. Note that prepared transactions are reported as &lt;code&gt;in progress&lt;/code&gt;; applications must check &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt;&lt;code&gt;pg_prepared_xacts&lt;/code&gt;&lt;/a&gt; if they need to determine whether a transaction ID belongs to a prepared transaction.</source>
          <target state="translated">최근 트랜잭션의 커밋 상태를보고합니다. 결과는 &lt;code id=&quot;in32progress&quot;&gt;in progress&lt;/code&gt; , &lt;code&gt;committed&lt;/code&gt; 또는 &lt;code&gt;aborted&lt;/code&gt; 중 하나입니다 . 단, 트랜잭션이 시스템이 해당 트랜잭션의 커밋 상태를 유지할 수있을만큼 최신 상태이면됩니다. 트랜잭션에 대한 참조가 시스템에 남아 있지 않고 커밋 상태 정보가 삭제 될만큼 충분히 오래된 경우 결과는 &lt;code&gt;NULL&lt;/code&gt; 입니다. 예를 들어, 애플리케이션은이 기능을 사용하여 &lt;code&gt;COMMIT&lt;/code&gt; 가 진행중인 동안 애플리케이션 및 데이터베이스 서버의 연결이 끊어진 후 트랜잭션이 커미트되었는지 또는 중단되었는지를 판별 할 수 있습니다 . 준비된 트랜잭션은 &lt;code&gt;in progress&lt;/code&gt; 것으로보고됩니다 . 응용 프로그램은 &lt;a href=&quot;view-pg-prepared-xacts&quot;&gt; &lt;code&gt;pg_prepared_xacts&lt;/code&gt; &lt;/a&gt; 를 확인해야합니다. 트랜잭션 ID가 준비된 트랜잭션에 속하는지 확인해야하는 경우</target>
        </trans-unit>
        <trans-unit id="04c20be8d98825fc019eb5064b5b3f242104a49b" translate="yes" xml:space="preserve">
          <source>Reports the database encoding (character set). It is determined when the database is created. Ordinarily, clients need only be concerned with the value of &lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding&lt;/a&gt;.</source>
          <target state="translated">데이터베이스 인코딩 (문자 세트)을보고합니다. 데이터베이스가 작성 될 때 결정됩니다. 일반적으로 클라이언트는 &lt;a href=&quot;runtime-config-client#GUC-CLIENT-ENCODING&quot;&gt;client_encoding&lt;/a&gt; 값에만 관심이 있으면됩니다 .</target>
        </trans-unit>
        <trans-unit id="215d9b58c6f8de6a32caee9722c29bb401984167" translate="yes" xml:space="preserve">
          <source>Reports the locale in which sorting of textual data is done. See &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt; for more information. This value is determined when a database is created.</source>
          <target state="translated">텍스트 데이터 정렬이 수행되는 로캘을보고합니다. 자세한 정보는 &lt;a href=&quot;locale&quot;&gt;23.1 절&lt;/a&gt; 을 참조하십시오. 이 값은 데이터베이스가 작성 될 때 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="6839a2a576833aec64f3dc89ff503898eaf1c409" translate="yes" xml:space="preserve">
          <source>Reports the locale that determines character classifications. See &lt;a href=&quot;locale&quot;&gt;Section 23.1&lt;/a&gt; for more information. This value is determined when a database is created. Ordinarily this will be the same as &lt;code&gt;lc_collate&lt;/code&gt;, but for special applications it might be set differently.</source>
          <target state="translated">문자 분류를 결정하는 로캘을보고합니다. 자세한 정보는 &lt;a href=&quot;locale&quot;&gt;23.1 절&lt;/a&gt; 을 참조하십시오. 이 값은 데이터베이스가 작성 될 때 결정됩니다. 일반적으로 이것은 &lt;code&gt;lc_collate&lt;/code&gt; 와 동일 하지만 특수 응용 프로그램의 경우 다르게 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="133ec403fdec744b56409d77e26f2f62824fc43b" translate="yes" xml:space="preserve">
          <source>Reports the maximum identifier length. It is determined as one less than the value of &lt;code&gt;NAMEDATALEN&lt;/code&gt; when building the server. The default value of &lt;code&gt;NAMEDATALEN&lt;/code&gt; is 64; therefore the default &lt;code&gt;max_identifier_length&lt;/code&gt; is 63 bytes, which can be less than 63 characters when using multibyte encodings.</source>
          <target state="translated">최대 식별자 길이를보고합니다. 서버 를 &lt;code&gt;NAMEDATALEN&lt;/code&gt; 할 때 NAMEDATALEN 값보다 작은 것으로 결정됩니다 . &lt;code&gt;NAMEDATALEN&lt;/code&gt; 의 기본값 은 64입니다. 따라서 기본 &lt;code&gt;max_identifier_length&lt;/code&gt; 는 63 바이트이며 멀티 바이트 인코딩을 사용하는 경우 63 자 미만일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="799a25e0c8bcd91d436e1fdd4d1b36d57467e8f5" translate="yes" xml:space="preserve">
          <source>Reports the maximum number of function arguments. It is determined by the value of &lt;code&gt;FUNC_MAX_ARGS&lt;/code&gt; when building the server. The default value is 100 arguments.</source>
          <target state="translated">최대 함수 인수 수를보고합니다. 서버 를 &lt;code&gt;FUNC_MAX_ARGS&lt;/code&gt; 할 때 FUNC_MAX_ARGS 값에 의해 결정됩니다 . 기본값은 100 개의 인수입니다.</target>
        </trans-unit>
        <trans-unit id="2e39bec50a64eb33dfcefff7f0512d78a414a231" translate="yes" xml:space="preserve">
          <source>Reports the maximum number of index keys. It is determined by the value of &lt;code&gt;INDEX_MAX_KEYS&lt;/code&gt; when building the server. The default value is 32 keys.</source>
          <target state="translated">최대 인덱스 키 수를보고합니다. 서버 를 &lt;code&gt;INDEX_MAX_KEYS&lt;/code&gt; 할 때 INDEX_MAX_KEYS 값에 의해 결정됩니다 . 기본값은 32 키입니다.</target>
        </trans-unit>
        <trans-unit id="44943d2e139b56c2c67784809c638bce6d77f7a7" translate="yes" xml:space="preserve">
          <source>Reports the name of the SSL library that this PostgreSQL server was built with (even if SSL is not currently configured or in use on this instance), for example &lt;code&gt;OpenSSL&lt;/code&gt;, or an empty string if none.</source>
          <target state="translated">이 PostgreSQL 서버가 구축 된 SSL 라이브러리의 이름을보고합니다 (SSL이 현재 구성되어 있지 &lt;code&gt;OpenSSL&lt;/code&gt; 인스턴스에서 사용 중이더라도) (예 : OpenSSL ) 비어있는 문자열이없는 경우 빈 문자열.</target>
        </trans-unit>
        <trans-unit id="15ae5e19224c54b7edd2214e6ede4a313d82ebb5" translate="yes" xml:space="preserve">
          <source>Reports the number of blocks (pages) that can be stored within a file segment. It is determined by the value of &lt;code&gt;RELSEG_SIZE&lt;/code&gt; when building the server. The maximum size of a segment file in bytes is equal to &lt;code&gt;segment_size&lt;/code&gt; multiplied by &lt;code&gt;block_size&lt;/code&gt;; by default this is 1GB.</source>
          <target state="translated">파일 세그먼트 내에 저장할 수있는 블록 (페이지) 수를보고합니다. 서버 를 &lt;code&gt;RELSEG_SIZE&lt;/code&gt; 할 때 RELSEG_SIZE 값에 의해 결정됩니다 . 바이트 세그먼트 파일의 최대 사이즈가 같은지 &lt;code&gt;segment_size&lt;/code&gt; 승산 &lt;code&gt;block_size&lt;/code&gt; ; 기본적으로 1GB입니다.</target>
        </trans-unit>
        <trans-unit id="cb331d77cf4705e0f8df49014aeb0027a810f55e" translate="yes" xml:space="preserve">
          <source>Reports the size of a WAL disk block. It is determined by the value of &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; when building the server. The default value is 8192 bytes.</source>
          <target state="translated">WAL 디스크 블록의 크기를보고합니다. 서버 를 &lt;code&gt;XLOG_BLCKSZ&lt;/code&gt; 할 때 XLOG_BLCKSZ 값에 의해 결정됩니다 . 기본값은 8192 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="c79f7039bd9d8d820003b68f17f8e83482934deb" translate="yes" xml:space="preserve">
          <source>Reports the size of a disk block. It is determined by the value of &lt;code&gt;BLCKSZ&lt;/code&gt; when building the server. The default value is 8192 bytes. The meaning of some configuration variables (such as &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers&lt;/a&gt;) is influenced by &lt;code&gt;block_size&lt;/code&gt;. See &lt;a href=&quot;runtime-config-resource&quot;&gt;Section 19.4&lt;/a&gt; for information.</source>
          <target state="translated">디스크 블록의 크기를보고합니다. 서버 를 &lt;code&gt;BLCKSZ&lt;/code&gt; 할 때 BLCKSZ 값에 의해 결정됩니다 . 기본값은 8192 바이트입니다. (같은 일부 구성 변수의 의미 &lt;a href=&quot;runtime-config-resource#GUC-SHARED-BUFFERS&quot;&gt;shared_buffers를는&lt;/a&gt; )에 의해 영향을 받는다 &lt;code&gt;block_size&lt;/code&gt; . 자세한 내용 &lt;a href=&quot;runtime-config-resource&quot;&gt;은 19.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95d6c92a6e0872d3f5543d6e209f7d8c656bbb1b" translate="yes" xml:space="preserve">
          <source>Reports the size of write ahead log segments. The default value is 16MB. See &lt;a href=&quot;wal-configuration&quot;&gt;Section 29.4&lt;/a&gt; for more information.</source>
          <target state="translated">미리 쓰기 로그 세그먼트의 크기를보고합니다. 기본값은 16MB입니다. 자세한 정보는 &lt;a href=&quot;wal-configuration&quot;&gt;29.4 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b05298534a10e0596a512e46fce83803ee71164c" translate="yes" xml:space="preserve">
          <source>Reports the version number of the server as an integer. It is determined by the value of &lt;code&gt;PG_VERSION_NUM&lt;/code&gt; when building the server.</source>
          <target state="translated">서버의 버전 번호를 정수로보고합니다. 서버를 빌드 할 때 &lt;code&gt;PG_VERSION_NUM&lt;/code&gt; 값에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2102c190e614e506ba029216961013061e92c185" translate="yes" xml:space="preserve">
          <source>Reports the version number of the server. It is determined by the value of &lt;code&gt;PG_VERSION&lt;/code&gt; when building the server.</source>
          <target state="translated">서버의 버전 번호를보고합니다. 서버를 빌드 할 때 &lt;code&gt;PG_VERSION&lt;/code&gt; 값에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e5caa6a9c11f9b17dfc30ca4f361130e7ffbffb" translate="yes" xml:space="preserve">
          <source>Reports whether PostgreSQL has been built with assertions enabled. That is the case if the macro &lt;code&gt;USE_ASSERT_CHECKING&lt;/code&gt; is defined when PostgreSQL is built (accomplished e.g. by the &lt;code&gt;configure&lt;/code&gt; option &lt;code&gt;--enable-cassert&lt;/code&gt;). By default PostgreSQL is built without assertions.</source>
          <target state="translated">어설 션을 사용하여 PostgreSQL을 빌드했는지 여부를보고합니다. PostgreSQL이 빌드 될 때 매크로 &lt;code&gt;USE_ASSERT_CHECKING&lt;/code&gt; 이 정의 된 경우입니다 (예 : &lt;code&gt;configure&lt;/code&gt; 옵션 &lt;code&gt;--enable-cassert&lt;/code&gt; 에 의해 수행됨 ). 기본적으로 PostgreSQL은 어설 션없이 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="d23ff730d728788481fc7f705a6f10422d822450" translate="yes" xml:space="preserve">
          <source>Reports whether PostgreSQL has been built with assertions enabled. That is the case if the macro &lt;code&gt;USE_ASSERT_CHECKING&lt;/code&gt; is defined when PostgreSQL is built (accomplished e.g., by the &lt;code&gt;configure&lt;/code&gt; option &lt;code&gt;--enable-cassert&lt;/code&gt;). By default PostgreSQL is built without assertions.</source>
          <target state="translated">어설 션이 활성화 된 상태로 PostgreSQL이 빌드되었는지 여부를보고합니다. PostgreSQL이 빌드 될 때 매크로 &lt;code&gt;USE_ASSERT_CHECKING&lt;/code&gt; 이 정의 된 경우입니다 (예 : &lt;code&gt;configure&lt;/code&gt; 옵션 &lt;code&gt;--enable-cassert&lt;/code&gt; 로 수행됨 ). 기본적으로 PostgreSQL은 어설 션없이 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="09ff4a3a0d4960f7372602a42263bbd9655d4d97" translate="yes" xml:space="preserve">
          <source>Reports whether PostgreSQL was built with support for 64-bit-integer dates and times. As of PostgreSQL 10, this is always &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">PostgreSQL이 64 비트 정수 날짜 및 시간을 지원하도록 빌드되었는지 여부를보고합니다. PostgreSQL 10부터는 항상 &lt;code&gt;on&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1d5abce92cc5273f66418437c3f192f01669f6c" translate="yes" xml:space="preserve">
          <source>Reports whether data checksums are enabled for this cluster. See &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;data checksums&lt;/a&gt; for more information.</source>
          <target state="translated">이 클러스터에 데이터 체크섬을 사용할 수 있는지 여부를보고합니다. 자세한 내용은 &lt;a href=&quot;app-initdb#APP-INITDB-DATA-CHECKSUMS&quot;&gt;데이터 체크섬&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="360bc539904b3901915f57b0aead8cb40373f0de" translate="yes" xml:space="preserve">
          <source>Representation</source>
          <target state="translated">Representation</target>
        </trans-unit>
        <trans-unit id="03e7bce3807c3a4cf4dcc58550a69557f7afa5fc" translate="yes" xml:space="preserve">
          <source>Representing data as JSON can be considerably more flexible than the traditional relational data model, which is compelling in environments where requirements are fluid. It is quite possible for both approaches to co-exist and complement each other within the same application. However, even for applications where maximal flexibility is desired, it is still recommended that JSON documents have a somewhat fixed structure. The structure is typically unenforced (though enforcing some business rules declaratively is possible), but having a predictable structure makes it easier to write queries that usefully summarize a set of &amp;ldquo;documents&amp;rdquo; (datums) in a table.</source>
          <target state="translated">JSON으로 데이터를 표현하는 것은 기존의 관계형 데이터 모델보다 훨씬 유연 할 수 있으며 요구 사항이 유동적 인 환경에서 강력합니다. 두 가지 접근 방식이 동일한 응용 프로그램 내에서 공존하고 서로 보완하는 것이 가능합니다. 그러나 최대한의 유연성이 필요한 응용 프로그램의 경우에도 JSON 문서의 구조는 다소 고정 된 것이 좋습니다. 구조는 일반적으로 적용되지 않지만 (일부 비즈니스 규칙을 선언적으로 적용하는 것이 가능하지만) 예측 가능한 구조를 사용하면 테이블에있는 &quot;문서&quot;(데이텀) 세트를 유용하게 요약하는 쿼리를보다 쉽게 ​​작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cef36dafdcabba4dbf5fee579fee0bc28a1b898" translate="yes" xml:space="preserve">
          <source>Represents</source>
          <target state="translated">Represents</target>
        </trans-unit>
        <trans-unit id="450e545f258454903db061f0d08097035b20ae56" translate="yes" xml:space="preserve">
          <source>Request For Comments</source>
          <target state="translated">의견 요청</target>
        </trans-unit>
        <trans-unit id="42605f8990d221376a9352954b711b9b4a2d1393" translate="yes" xml:space="preserve">
          <source>Requested Lock Mode</source>
          <target state="translated">요청 된 잠금 모드</target>
        </trans-unit>
        <trans-unit id="dbd1082386f55fd320bdd79e87b73081fe27827a" translate="yes" xml:space="preserve">
          <source>Requesting exclusive locks on database objects while running a parallel dump could cause the dump to fail. The reason is that the pg_dump master process requests shared locks on the objects that the worker processes are going to dump later in order to make sure that nobody deletes them and makes them go away while the dump is running. If another client then requests an exclusive lock on a table, that lock will not be granted but will be queued waiting for the shared lock of the master process to be released. Consequently any other access to the table will not be granted either and will queue after the exclusive lock request. This includes the worker process trying to dump the table. Without any precautions this would be a classic deadlock situation. To detect this conflict, the pg_dump worker process requests another shared lock using the &lt;code&gt;NOWAIT&lt;/code&gt; option. If the worker process is not granted this shared lock, somebody else must have requested an exclusive lock in the meantime and there is no way to continue with the dump, so pg_dump has no choice but to abort the dump.</source>
          <target state="translated">병렬 덤프를 실행하는 동안 데이터베이스 오브젝트에 대한 독점 잠금을 요청하면 덤프가 실패 할 수 있습니다. 그 이유는 pg_dump 마스터 프로세스가 작업자 프로세스가 나중에 덤프하지 않을 오브젝트에 대한 공유 잠금을 요청하여 덤프가 실행되는 동안 아무도 삭제하지 않도록하기 때문입니다. 다른 클라이언트가 테이블에 대한 독점 잠금을 요청하면 해당 잠금은 부여되지 않지만 마스터 프로세스의 공유 잠금이 해제 될 때까지 대기합니다. 결과적으로 테이블에 대한 다른 액세스 권한도 부여되지 않으며 독점 ​​잠금 요청 후에 큐에 대기합니다. 여기에는 테이블을 덤프하려는 작업자 프로세스가 포함됩니다. 예방 조치가 없으면 이것이 전형적인 교착 상태입니다. 이 충돌을 감지하기 위해 pg_dump 작업자 프로세스는 &lt;code&gt;NOWAIT&lt;/code&gt; 옵션. 작업자 프로세스에이 공유 잠금이 부여되지 않으면 다른 사람이 그 동안 독점 잠금을 요청해야하며 덤프를 계속할 방법이 없으므로 pg_dump는 덤프를 중단 할 수밖에 없습니다.</target>
        </trans-unit>
        <trans-unit id="c98a917aac5e5d4f0dec7f637bf05dd08be540d5" translate="yes" xml:space="preserve">
          <source>Requests copying the data with rows already frozen, just as they would be after running the &lt;code&gt;VACUUM FREEZE&lt;/code&gt; command. This is intended as a performance option for initial data loading. Rows will be frozen only if the table being loaded has been created or truncated in the current subtransaction, there are no cursors open and there are no older snapshots held by this transaction. It is currently not possible to perform a &lt;code&gt;COPY FREEZE&lt;/code&gt; on a partitioned table.</source>
          <target state="translated">&lt;code&gt;VACUUM FREEZE&lt;/code&gt; 명령을 실행 한 후와 같이 이미 고정 된 행으로 데이터 복사를 요청합니다 . 이는 초기 데이터로드를위한 성능 옵션으로 사용됩니다. 로드중인 테이블이 현재 서브 트랜잭션에서 작성되거나 잘린 경우에만 행이 고정되며 커서가 열리지 않고이 트랜잭션이 보유한 이전 스냅 샷이 없습니다. 현재 파티션 된 테이블에서 &lt;code&gt;COPY FREEZE&lt;/code&gt; 를 수행 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2aa5dcbad187bcd9ce0d0f82c94976028cac05e5" translate="yes" xml:space="preserve">
          <source>Require pg_receivewal to use an existing replication slot (see &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;Section 26.2.6&lt;/a&gt;). When this option is used, pg_receivewal will report a flush position to the server, indicating when each segment has been synchronized to disk so that the server can remove that segment if it is not otherwise needed.</source>
          <target state="translated">기존 복제 슬롯을 사용하려면 pg_receivewal이 필요합니다 ( &lt;a href=&quot;warm-standby#STREAMING-REPLICATION-SLOTS&quot;&gt;26.2.6 절&lt;/a&gt; 참조 ). 이 옵션을 사용하면 pg_receivewal은 서버에 플러시 위치를보고하여 각 세그먼트가 디스크에 동기화 된 시점을 나타내므로 서버는 해당 세그먼트가 필요하지 않은 경우 해당 세그먼트를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39c132992eaf551e608f483baf45dd594e123137" translate="yes" xml:space="preserve">
          <source>Require that each schema (&lt;code&gt;-n&lt;/code&gt;/&lt;code&gt;--schema&lt;/code&gt;) and table (&lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--table&lt;/code&gt;) qualifier match at least one schema/table in the backup file.</source>
          <target state="translated">각 스키마 ( &lt;code&gt;-n&lt;/code&gt; / &lt;code&gt;--schema&lt;/code&gt; ) 및 테이블 ( &lt;code&gt;-t&lt;/code&gt; / &lt;code&gt;--table&lt;/code&gt; ) 한정자가 백업 파일에서 하나 이상의 스키마 / 테이블과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="09f649ea02d81273e1e69ee30fa4b6cb52f20736" translate="yes" xml:space="preserve">
          <source>Require that each schema (&lt;code&gt;-n&lt;/code&gt;/&lt;code&gt;--schema&lt;/code&gt;) and table (&lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--table&lt;/code&gt;) qualifier match at least one schema/table in the database to be dumped. Note that if none of the schema/table qualifiers find matches, pg_dump will generate an error even without &lt;code&gt;--strict-names&lt;/code&gt;.</source>
          <target state="translated">각 스키마 ( &lt;code&gt;-n&lt;/code&gt; / &lt;code&gt;--schema&lt;/code&gt; ) 및 테이블 ( &lt;code&gt;-t&lt;/code&gt; / &lt;code&gt;--table&lt;/code&gt; ) 한정자가 덤프 할 데이터베이스에서 하나 이상의 스키마 / 테이블과 일치해야합니다. 일치하는 스키마 / 테이블 한정자가 없으면 pg_dump는 &lt;code&gt;--strict-names&lt;/code&gt; 없이도 오류를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="e6e361115e1183ff1cb7acf4feaf95f5086c65fc" translate="yes" xml:space="preserve">
          <source>Require the client to supply an unencrypted password for authentication. Since the password is sent in clear text over the network, this should not be used on untrusted networks. See &lt;a href=&quot;auth-password&quot;&gt;Section 20.5&lt;/a&gt; for details.</source>
          <target state="translated">클라이언트가 인증을 위해 암호화되지 않은 비밀번호를 제공해야합니다. 암호는 네트워크를 통해 일반 텍스트로 전송되므로 신뢰할 수없는 네트워크에서는 사용하지 않아야합니다. 자세한 내용 &lt;a href=&quot;auth-password&quot;&gt;은 20.5 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f3c2477b77154167391f3c1364dc6a6eadce08d6" translate="yes" xml:space="preserve">
          <source>Required to invoke initialization mode.</source>
          <target state="translated">초기화 모드를 호출하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="38bd9ce2cc05e7a0fc3a449b82bd3413a381dafa" translate="yes" xml:space="preserve">
          <source>Reset all statistics counters for the current database to zero (requires superuser privileges by default, but EXECUTE for this function can be granted to others.)</source>
          <target state="translated">현재 데이터베이스의 모든 통계 카운터를 0으로 재설정하십시오 (기본적으로 수퍼 유저 권한이 필요하지만이 기능에 대한 EXECUTE는 다른 사용자에게 부여 될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="e5cbc88dcef6f894227fd836d5359b0b8b433831" translate="yes" xml:space="preserve">
          <source>Reset some cluster-wide statistics counters to zero, depending on the argument (requires superuser privileges by default, but EXECUTE for this function can be granted to others). Calling &lt;code&gt;pg_stat_reset_shared('bgwriter')&lt;/code&gt; will zero all the counters shown in the &lt;code&gt;pg_stat_bgwriter&lt;/code&gt; view. Calling &lt;code&gt;pg_stat_reset_shared('archiver')&lt;/code&gt; will zero all the counters shown in the &lt;code&gt;pg_stat_archiver&lt;/code&gt; view.</source>
          <target state="translated">인수에 따라 일부 클러스터 전체 통계 카운터를 0으로 재설정하십시오 (기본적으로 수퍼 유저 권한이 필요하지만이 기능에 대한 EXECUTE는 다른 사용자에게 부여 될 수 있음). &lt;code&gt;pg_stat_reset_shared('bgwriter')&lt;/code&gt; 를 호출 하면 &lt;code&gt;pg_stat_bgwriter&lt;/code&gt; 보기에 표시된 모든 카운터가 0이됩니다 . &lt;code&gt;pg_stat_reset_shared('archiver')&lt;/code&gt; 를 호출 하면 &lt;code&gt;pg_stat_archiver&lt;/code&gt; 뷰에 표시된 모든 카운터가 0이됩니다 .</target>
        </trans-unit>
        <trans-unit id="f806044bb4f58255ea7f1237af0ed7185031a43f" translate="yes" xml:space="preserve">
          <source>Reset statistics for a single function in the current database to zero (requires superuser privileges by default, but EXECUTE for this function can be granted to others)</source>
          <target state="translated">현재 데이터베이스의 단일 함수에 대한 통계를 0으로 재설정 (기본적으로 수퍼 유저 권한이 필요하지만이 함수에 대한 EXECUTE는 다른 사용자에게 부여 될 수 있음)</target>
        </trans-unit>
        <trans-unit id="d348272b7007212085eae9a1a69701536144e331" translate="yes" xml:space="preserve">
          <source>Reset statistics for a single table or index in the current database to zero (requires superuser privileges by default, but EXECUTE for this function can be granted to others)</source>
          <target state="translated">현재 데이터베이스의 단일 테이블 또는 인덱스에 대한 통계를 0으로 재설정 (기본적으로 수퍼 유저 권한이 필요하지만이 기능에 대한 EXECUTE는 다른 사용자에게 부여 될 수 있음)</target>
        </trans-unit>
        <trans-unit id="0e61cc12da5ed1835d8f4611f3962fed5df0285d" translate="yes" xml:space="preserve">
          <source>Reset the sequence object's counter value. The two-parameter form sets the sequence's &lt;code&gt;last_value&lt;/code&gt; field to the specified value and sets its &lt;code&gt;is_called&lt;/code&gt; field to &lt;code&gt;true&lt;/code&gt;, meaning that the next &lt;code&gt;nextval&lt;/code&gt; will advance the sequence before returning a value. The value reported by &lt;code&gt;currval&lt;/code&gt; is also set to the specified value. In the three-parameter form, &lt;code&gt;is_called&lt;/code&gt; can be set to either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;true&lt;/code&gt; has the same effect as the two-parameter form. If it is set to &lt;code&gt;false&lt;/code&gt;, the next &lt;code&gt;nextval&lt;/code&gt; will return exactly the specified value, and sequence advancement commences with the following &lt;code&gt;nextval&lt;/code&gt;. Furthermore, the value reported by &lt;code&gt;currval&lt;/code&gt; is not changed in this case. For example,</source>
          <target state="translated">시퀀스 객체의 카운터 값을 재설정합니다. 두 매개 변수 형식은 시퀀스의 &lt;code&gt;last_value&lt;/code&gt; 필드를 지정된 값으로 설정하고 &lt;code&gt;is_called&lt;/code&gt; 필드를 &lt;code&gt;true&lt;/code&gt; 로 설정 합니다 . 즉, 다음 &lt;code&gt;nextval&lt;/code&gt; 은 값을 반환하기 전에 시퀀스를 진행합니다. &lt;code&gt;currval&lt;/code&gt; 이 보고 한 값 도 지정된 값으로 설정됩니다. 3 개의 매개 변수 형식에서 &lt;code&gt;is_called&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 설정할 수 있습니다 . &lt;code&gt;true&lt;/code&gt; 는 두 매개 변수 형식과 동일한 효과를 갖습니다. &lt;code&gt;false&lt;/code&gt; 로 설정 되면 다음 &lt;code&gt;nextval&lt;/code&gt; 지정된 값을 정확하게 반환하고 시퀀스 진행은 다음 &lt;code&gt;nextval&lt;/code&gt; 로 시작합니다 . 또한 &lt;code&gt;currval&lt;/code&gt; 에 의해보고 된 값 은이 경우 변경되지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="54f8cb663de0b7cace333df931e93c52752ca59d" translate="yes" xml:space="preserve">
          <source>Resets (clears) the query buffer.</source>
          <target state="translated">쿼리 버퍼를 재설정 (클리어)합니다.</target>
        </trans-unit>
        <trans-unit id="07b8804bd424e241a6174ecc27bcfae832682878" translate="yes" xml:space="preserve">
          <source>Resets all settable run-time parameters to default values.</source>
          <target state="translated">설정 가능한 모든 런타임 매개 변수를 기본값으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="9fda2c7ae6de548396c9b852f30012d510ad959a" translate="yes" xml:space="preserve">
          <source>Resets all statistics counters for the current database to zero.</source>
          <target state="translated">현재 데이터베이스의 모든 통계 카운터를 0으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="407f3646db4bff539faa68fd2fdc07c9a3f845e1" translate="yes" xml:space="preserve">
          <source>Resets some cluster-wide statistics counters to zero, depending on the argument. The argument can be &lt;code&gt;bgwriter&lt;/code&gt; to reset all the counters shown in the &lt;code&gt;pg_stat_bgwriter&lt;/code&gt; view, or &lt;code&gt;archiver&lt;/code&gt; to reset all the counters shown in the &lt;code&gt;pg_stat_archiver&lt;/code&gt; view.</source>
          <target state="translated">인수에 따라 일부 클러스터 전체 통계 카운터를 0으로 재설정합니다. 인자가 될 수 &lt;code&gt;bgwriter&lt;/code&gt; 에 나타낸 모든 카운터를 리셋 &lt;code&gt;pg_stat_bgwriter&lt;/code&gt; 의 보기 또는 &lt;code&gt;archiver&lt;/code&gt; 에 나타낸 모든 카운터를 리셋 &lt;code&gt;pg_stat_archiver&lt;/code&gt; 의 뷰.</target>
        </trans-unit>
        <trans-unit id="4c94715a97dd2e09e499f61a5bba12229f06864e" translate="yes" xml:space="preserve">
          <source>Resets statistics for a single function in the current database to zero.</source>
          <target state="translated">현재 데이터베이스의 단일 함수에 대한 통계를 0으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="6d03ab30b9b64f6eec81725243e7b8681ada1d44" translate="yes" xml:space="preserve">
          <source>Resets statistics for a single table or index in the current database to zero.</source>
          <target state="translated">현재 데이터베이스의 단일 테이블 또는 인덱스에 대한 통계를 0으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="4ece0582190d1df7ff706dbe568726e536823085" translate="yes" xml:space="preserve">
          <source>Resets statistics to zero for a single SLRU cache, or for all SLRUs in the cluster. If the argument is NULL, all counters shown in the &lt;code&gt;pg_stat_slru&lt;/code&gt; view for all SLRU caches are reset. The argument can be one of &lt;code&gt;CommitTs&lt;/code&gt;, &lt;code&gt;MultiXactMember&lt;/code&gt;, &lt;code&gt;MultiXactOffset&lt;/code&gt;, &lt;code&gt;Notify&lt;/code&gt;, &lt;code&gt;Serial&lt;/code&gt;, &lt;code&gt;Subtrans&lt;/code&gt;, or &lt;code&gt;Xact&lt;/code&gt; to reset the counters for only that entry. If the argument is &lt;code&gt;other&lt;/code&gt; (or indeed, any unrecognized name), then the counters for all other SLRU caches, such as extension-defined caches, are reset.</source>
          <target state="translated">단일 SLRU 캐시 또는 클러스터의 모든 SLRU에 대해 통계를 0으로 재설정합니다. 인수가 NULL이면 모든 SLRU 캐시 에 대해 &lt;code&gt;pg_stat_slru&lt;/code&gt; 보기에 표시된 모든 카운터 가 재설정됩니다. 인수 중 하나가 될 수 있습니다 &lt;code&gt;CommitTs&lt;/code&gt; , &lt;code&gt;MultiXactMember&lt;/code&gt; , &lt;code&gt;MultiXactOffset&lt;/code&gt; , &lt;code&gt;Notify&lt;/code&gt; , &lt;code&gt;Serial&lt;/code&gt; , &lt;code&gt;Subtrans&lt;/code&gt; , 또는 &lt;code&gt;Xact&lt;/code&gt; 해당 항목에 대한 카운터를 재설정합니다. 인수가 &lt;code&gt;other&lt;/code&gt; (또는 실제로 인식 할 수없는 이름)이면 확장 정의 캐시와 같은 다른 모든 SLRU 캐시에 대한 카운터가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="516aae52959dcf5398a9985414a78b8c24a4f0e5" translate="yes" xml:space="preserve">
          <source>Resolution</source>
          <target state="translated">Resolution</target>
        </trans-unit>
        <trans-unit id="0f9d42c9270c0ec8b9978c654938a3fda35cd075" translate="yes" xml:space="preserve">
          <source>Resource Consumption</source>
          <target state="translated">자원 소비</target>
        </trans-unit>
        <trans-unit id="43c182983159d1d95ce6de080236b07cc610f25e" translate="yes" xml:space="preserve">
          <source>Restart a sequence called &lt;code&gt;serial&lt;/code&gt;, at 105:</source>
          <target state="translated">105에서 &lt;code&gt;serial&lt;/code&gt; 이라는 시퀀스를 다시 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="be0ed1ec4356de35c270412ac99585872239a672" translate="yes" xml:space="preserve">
          <source>Restarting the Server</source>
          <target state="translated">서버 재시작</target>
        </trans-unit>
        <trans-unit id="7569b188ab01cd0e95751a72317a9eeb7a8756a3" translate="yes" xml:space="preserve">
          <source>Restarting the server is almost equivalent to stopping the server and starting it again, except that by default, &lt;code&gt;pg_ctl&lt;/code&gt; saves and reuses the command line options that were passed to the previously-running instance. To restart the server using the same options as before, use:</source>
          <target state="translated">서버를 다시 시작하는 것은 기본적으로 &lt;code&gt;pg_ctl&lt;/code&gt; 이 이전에 실행중인 인스턴스에 전달 된 명령 줄 옵션을 저장하고 재사용 한다는 점을 제외하고 서버를 중지했다가 다시 시작하는 것과 거의 같습니다 . 이전과 동일한 옵션을 사용하여 서버를 다시 시작하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5567296a67c64996c56058acf955d5ad87aac914" translate="yes" xml:space="preserve">
          <source>Restarts recovery if it was paused (restricted to superusers by default, but other users can be granted EXECUTE to run the function).</source>
          <target state="translated">일시 중지 된 경우 복구를 다시 시작합니다 (기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있음).</target>
        </trans-unit>
        <trans-unit id="d0f7672c0e14c7d0be0c6f1025769c22522e8d4d" translate="yes" xml:space="preserve">
          <source>Restarts recovery if it was paused.</source>
          <target state="translated">일시 중지 된 경우 복구를 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="655ac4339a6d21ce050ff27e73304e42e3631431" translate="yes" xml:space="preserve">
          <source>Restore definition and/or data of only the named table. For this purpose, &amp;ldquo;table&amp;rdquo; includes views, materialized views, sequences, and foreign tables. Multiple tables can be selected by writing multiple &lt;code&gt;-t&lt;/code&gt; switches. This option can be combined with the &lt;code&gt;-n&lt;/code&gt; option to specify table(s) in a particular schema.</source>
          <target state="translated">명명 된 테이블의 정의 및 / 또는 데이터를 복원합니다. 이를 위해&amp;ldquo;테이블&amp;rdquo;에는 뷰, 구체화 된 뷰, 시퀀스 및 외부 테이블이 포함됩니다. 여러 개의 &lt;code&gt;-t&lt;/code&gt; 스위치 를 작성하여 여러 테이블을 선택할 수 있습니다 . 이 옵션을 &lt;code&gt;-n&lt;/code&gt; 옵션 과 결합 하여 특정 스키마에서 테이블을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="623195e281db5418bbf569f1e1992b38d957ceeb" translate="yes" xml:space="preserve">
          <source>Restore definition of named index only. Multiple indexes may be specified with multiple &lt;code&gt;-I&lt;/code&gt; switches.</source>
          <target state="translated">명명 된 인덱스의 정의 만 복원하십시오. 여러 개의 &lt;code&gt;-I&lt;/code&gt; 스위치를 사용 하여 여러 개의 인덱스를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4075c46556585fbb73f83724d8a9b4ab5f0b0882" translate="yes" xml:space="preserve">
          <source>Restore named trigger only. Multiple triggers may be specified with multiple &lt;code&gt;-T&lt;/code&gt; switches.</source>
          <target state="translated">명명 된 트리거 만 복원하십시오. 여러 개의 &lt;code&gt;-T&lt;/code&gt; 스위치 로 여러 트리거를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21e27a35ceb0ae1abe3966da51bcd75af8594c6d" translate="yes" xml:space="preserve">
          <source>Restore only objects that are in the named schema. Multiple schemas may be specified with multiple &lt;code&gt;-n&lt;/code&gt; switches. This can be combined with the &lt;code&gt;-t&lt;/code&gt; option to restore just a specific table.</source>
          <target state="translated">명명 된 스키마에있는 오브젝트 만 복원하십시오. 여러 개의 &lt;code&gt;-n&lt;/code&gt; 스위치를 사용 하여 여러 스키마를 지정할 수 있습니다 . &lt;code&gt;-t&lt;/code&gt; 옵션 과 결합 하여 특정 테이블 만 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9782cae50d1097c39f4de92fa740f242782eeef" translate="yes" xml:space="preserve">
          <source>Restore only the data, not the schema (data definitions). Table data, large objects, and sequence values are restored, if present in the archive.</source>
          <target state="translated">스키마가 아닌 데이터 만 복원하십시오 (데이터 정의). 아카이브에있는 경우 테이블 데이터, 큰 개체 및 시퀀스 값이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="b7c59f7eab51db1bd7970fee7102ace189aeb6d3" translate="yes" xml:space="preserve">
          <source>Restore only the schema (data definitions), not data, to the extent that schema entries are present in the archive.</source>
          <target state="translated">아카이브에 스키마 항목이 존재하는 정도까지 데이터가 아닌 스키마 (데이터 정의) 만 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="3a84f942a3445ce47e7219837e340e3ec2ec76a5" translate="yes" xml:space="preserve">
          <source>Restore only those archive elements that are listed in &lt;code&gt;list-file&lt;/code&gt;, and restore them in the order they appear in the file. Note that if filtering switches such as &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-t&lt;/code&gt; are used with &lt;code&gt;-L&lt;/code&gt;, they will further restrict the items restored.</source>
          <target state="translated">&lt;code&gt;list-file&lt;/code&gt; 에 나열된 아카이브 요소 만 복원하고 파일에 나타나는 순서대로 복원하십시오. &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;-t&lt;/code&gt; 와 같은 필터링 스위치 를 &lt;code&gt;-L&lt;/code&gt; 과 함께 사용 하면 복원 된 항목이 추가로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="380edb761adddb8b866c4c1fbcae7db94c9fcb6e" translate="yes" xml:space="preserve">
          <source>Restore the database files from your file system backup. Be sure that they are restored with the right ownership (the database system user, not &lt;code&gt;root&lt;/code&gt;!) and with the right permissions. If you are using tablespaces, you should verify that the symbolic links in &lt;code&gt;pg_tblspc/&lt;/code&gt; were correctly restored.</source>
          <target state="translated">파일 시스템 백업에서 데이터베이스 파일을 복원하십시오. 올바른 소유권 ( &lt;code&gt;root&lt;/code&gt; 아닌 데이터베이스 시스템 사용자 )과 올바른 권한 으로 복원해야합니다 . 테이블 스페이스를 사용하는 경우 &lt;code&gt;pg_tblspc/&lt;/code&gt; 의 심볼릭 링크 가 올바르게 복원 되었는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3191bbaf27e82dc7be5f93a88e9a86a5c064f0b8" translate="yes" xml:space="preserve">
          <source>Restore the named function only. Be careful to spell the function name and arguments exactly as they appear in the dump file's table of contents. Multiple functions may be specified with multiple &lt;code&gt;-P&lt;/code&gt; switches.</source>
          <target state="translated">명명 된 기능 만 복원하십시오. 덤프 파일의 목차에 나타나는대로 함수 이름과 인수의 철자를 정확히주의하십시오. 여러 개의 &lt;code&gt;-P&lt;/code&gt; 스위치 로 여러 기능을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41181b5cc8144a05bbcab44700c270b0c5848fdf" translate="yes" xml:space="preserve">
          <source>Restore the scan to the most recently marked position.</source>
          <target state="translated">스캔을 가장 최근에 표시된 위치로 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="3da0c5779f0f7d48a16980bbbed99755ffed4f3d" translate="yes" xml:space="preserve">
          <source>Restore your previous &lt;code&gt;pg_hba.conf&lt;/code&gt; and any &lt;code&gt;postgresql.conf&lt;/code&gt; modifications.</source>
          <target state="translated">이전 &lt;code&gt;pg_hba.conf&lt;/code&gt; 및 &lt;code&gt;postgresql.conf&lt;/code&gt; 수정 사항을 복원하십시오 .</target>
        </trans-unit>
        <trans-unit id="25f7ceb141e29257b66ea98aeeba48c79636a1e0" translate="yes" xml:space="preserve">
          <source>Restricting and cascading deletes are the two most common options. &lt;code&gt;RESTRICT&lt;/code&gt; prevents deletion of a referenced row. &lt;code&gt;NO ACTION&lt;/code&gt; means that if any referencing rows still exist when the constraint is checked, an error is raised; this is the default behavior if you do not specify anything. (The essential difference between these two choices is that &lt;code&gt;NO ACTION&lt;/code&gt; allows the check to be deferred until later in the transaction, whereas &lt;code&gt;RESTRICT&lt;/code&gt; does not.) &lt;code&gt;CASCADE&lt;/code&gt; specifies that when a referenced row is deleted, row(s) referencing it should be automatically deleted as well. There are two other options: &lt;code&gt;SET NULL&lt;/code&gt; and &lt;code&gt;SET DEFAULT&lt;/code&gt;. These cause the referencing column(s) in the referencing row(s) to be set to nulls or their default values, respectively, when the referenced row is deleted. Note that these do not excuse you from observing any constraints. For example, if an action specifies &lt;code&gt;SET DEFAULT&lt;/code&gt; but the default value would not satisfy the foreign key constraint, the operation will fail.</source>
          <target state="translated">제한 및 계단식 삭제가 가장 일반적인 두 가지 옵션입니다. &lt;code&gt;RESTRICT&lt;/code&gt; 는 참조 된 행의 삭제를 방지합니다. &lt;code&gt;NO ACTION&lt;/code&gt; 은 제한 조건을 점검 할 때 참조 행이 여전히 존재하면 오류가 발생 함을 의미합니다. 아무것도 지정하지 않으면 이것이 기본 동작입니다. (이 두 가지 선택의 근본적인 차이점은 &lt;code&gt;NO ACTION&lt;/code&gt; 은 트랜잭션 후반까지 검사가 연기 될 수 있지만 &lt;code&gt;RESTRICT&lt;/code&gt; 는 그렇지 않다는 점입니다.) &lt;code&gt;CASCADE&lt;/code&gt; 는 참조 된 행이 삭제 될 때이를 참조하는 행이 자동으로 삭제되도록 지정합니다. 게다가. &lt;code&gt;SET NULL&lt;/code&gt; 및 &lt;code&gt;SET DEFAULT&lt;/code&gt; 의 두 가지 다른 옵션이 있습니다.. 이로 인해 참조 행이 삭제 될 때 참조 행의 참조 열이 각각 널 또는 기본값으로 설정됩니다. 이것들은 어떤 제약 조건을 관찰하는 것을 막을 수는 없습니다. 예를 들어, 조치가 &lt;code&gt;SET DEFAULT&lt;/code&gt; 를 지정 하지만 기본값이 외래 키 제한 조건을 만족하지 않으면 조작이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3d5c2e1889f58afab9c5af759b800e34de165147" translate="yes" xml:space="preserve">
          <source>Restriction selectivity estimation function for this operator</source>
          <target state="translated">이 연산자에 대한 제한 선택성 추정 기능</target>
        </trans-unit>
        <trans-unit id="38ad8517f1dfe99e4d87fbdbdd90a3a14b28b872" translate="yes" xml:space="preserve">
          <source>Restrictions</source>
          <target state="translated">Restrictions</target>
        </trans-unit>
        <trans-unit id="e4030936d5011845f4167d015ff214a58e320e9d" translate="yes" xml:space="preserve">
          <source>Restrictions are that &lt;code&gt;frame_start&lt;/code&gt; cannot be &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt;, &lt;code&gt;frame_end&lt;/code&gt; cannot be &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt;, and the &lt;code&gt;frame_end&lt;/code&gt; choice cannot appear earlier in the above list of &lt;code&gt;frame_start&lt;/code&gt; and &lt;code&gt;frame_end&lt;/code&gt; options than the &lt;code&gt;frame_start&lt;/code&gt; choice does &amp;mdash; for example &lt;code&gt;RANGE BETWEEN CURRENT ROW AND offset PRECEDING&lt;/code&gt; is not allowed. But, for example, &lt;code&gt;ROWS BETWEEN 7 PRECEDING AND 8 PRECEDING&lt;/code&gt; is allowed, even though it would never select any rows.</source>
          <target state="translated">제한 사항이 있습니다 &lt;code&gt;frame_start&lt;/code&gt; 이 될 수 없다 &lt;code&gt;UNBOUNDED FOLLOWING&lt;/code&gt; , &lt;code&gt;frame_end&lt;/code&gt; 될 수 없습니다 &lt;code&gt;UNBOUNDED PRECEDING&lt;/code&gt; 하고 &lt;code&gt;frame_end&lt;/code&gt; 선택의 위의 목록에서 이전에 나타날 수 없습니다 &lt;code&gt;frame_start&lt;/code&gt; 및 &lt;code&gt;frame_end&lt;/code&gt; 댄 옵션 &lt;code&gt;frame_start&lt;/code&gt; 의 선택은 않습니다 - 예에 대한 &lt;code&gt;RANGE BETWEEN CURRENT ROW AND offset PRECEDING&lt;/code&gt; 할 수 없습니다. 그러나 예를 들어 행을 선택하지 않더라도 &lt;code&gt;ROWS BETWEEN 7 PRECEDING AND 8 PRECEDING&lt;/code&gt; 가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5faa59d4bc3756040b8ce9e673c09f929e6ee9ba" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Result</target>
        </trans-unit>
        <trans-unit id="a40a33eb4d7139460df1b250a4fca52bce5bab7d" translate="yes" xml:space="preserve">
          <source>Result set</source>
          <target state="translated">결과 세트</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="88f2b3f5a0eff8fce83b5ded45c3cac6f39abfd9" translate="yes" xml:space="preserve">
          <source>Return Type</source>
          <target state="translated">반품 유형</target>
        </trans-unit>
        <trans-unit id="9a9d63eb1d17793ba8ab33ff34bf6ace7f3ed600" translate="yes" xml:space="preserve">
          <source>Return a record containing multiple output parameters:</source>
          <target state="translated">여러 출력 매개 변수를 포함하는 레코드를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="2afbe0e3b0b76fd48a64868e31283baed1a5b6b9" translate="yes" xml:space="preserve">
          <source>Return actual version of collation from operating system</source>
          <target state="translated">운영 체제에서 실제 데이터 정렬 버전 반환</target>
        </trans-unit>
        <trans-unit id="d41c59510ee376d764f6de483cc519bc177516f0" translate="yes" xml:space="preserve">
          <source>Return captured substring(s) resulting from matching a POSIX regular expression to the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;. See &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt; for more information.</source>
          <target state="translated">POSIX 정규 표현식을 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 과 일치 시켜서 캡처 된 하위 문자열을 리턴 &lt;em&gt;합니다&lt;/em&gt; . 자세한 정보는 &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;9.7.3 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0842b7e99ec161977782ca8251e39a35af13f0b6" translate="yes" xml:space="preserve">
          <source>Return captured substring(s) resulting from the first match of a POSIX regular expression to the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;. See &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt; for more information.</source>
          <target state="translated">POSIX 정규 표현식이 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 과 처음 일치하여 캡처 된 하위 문자열을 리턴 &lt;em&gt;합니다&lt;/em&gt; . 자세한 정보는 &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;9.7.3 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9ad4ba0bb690df0ea2fad8b27bd0acbb52a9118e" translate="yes" xml:space="preserve">
          <source>Return first &lt;code&gt;n&lt;/code&gt; characters in the string. When &lt;code&gt;n&lt;/code&gt; is negative, return all but last |&lt;code&gt;n&lt;/code&gt;| characters.</source>
          <target state="translated">문자열에서 처음 &lt;code&gt;n&lt;/code&gt; 자를 반환 합니다. 때 &lt;code&gt;n&lt;/code&gt; 은 음이며, 모두를 반환하지만 마지막 | &lt;code&gt;n&lt;/code&gt; | 문자.</target>
        </trans-unit>
        <trans-unit id="d880c554d23a84d7fb943adfbea35de8b403868e" translate="yes" xml:space="preserve">
          <source>Return information about a file. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">파일에 대한 정보를 반환합니다. 기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44887d1d39bfa8f8d486246dd192b841ad31f183" translate="yes" xml:space="preserve">
          <source>Return last &lt;code&gt;n&lt;/code&gt; characters in the string. When &lt;code&gt;n&lt;/code&gt; is negative, return all but first |&lt;code&gt;n&lt;/code&gt;| characters.</source>
          <target state="translated">문자열에서 마지막 &lt;code&gt;n&lt;/code&gt; 자를 반환 합니다. 때 &lt;code&gt;n&lt;/code&gt; 은 음이며, 모두를 반환하지만 첫 번째 | &lt;code&gt;n&lt;/code&gt; | 문자.</target>
        </trans-unit>
        <trans-unit id="51144c7057388a9ddd52fc2f768884b9089ef475" translate="yes" xml:space="preserve">
          <source>Return reversed string.</source>
          <target state="translated">반전 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc0eb20772a44bc552722a28742f8c7c5d090982" translate="yes" xml:space="preserve">
          <source>Return the contents of a file. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">파일의 내용을 돌려줍니다. 기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff6f193117a2e28dfd9bf976d03f27e993088606" translate="yes" xml:space="preserve">
          <source>Return the contents of a text file. Restricted to superusers by default, but other users can be granted EXECUTE to run the function.</source>
          <target state="translated">텍스트 파일의 내용을 반환합니다. 기본적으로 수퍼 유저로 제한되지만 다른 사용자에게 EXECUTE를 부여하여 기능을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f24e6a36cf89cb9e95870a3143de3ec68700671" translate="yes" xml:space="preserve">
          <source>Return the given string suitably quoted to be used as a string literal in an SQL statement string. Embedded single-quotes and backslashes are properly doubled. Note that &lt;code&gt;quote_literal&lt;/code&gt; returns null on null input; if the argument might be null, &lt;code&gt;quote_nullable&lt;/code&gt; is often more suitable. See also &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;Example 42.1&lt;/a&gt;.</source>
          <target state="translated">SQL 문 문자열에서 문자열 리터럴로 사용하기 위해 적절하게 인용 된 지정된 문자열을 리턴하십시오. 포함 된 작은 따옴표와 백 슬래시는 올바르게 두 배입니다. 참고 것을 &lt;code&gt;quote_literal&lt;/code&gt; NULL을 반환 입력에 널 (null); 인수가 널인 경우, &lt;code&gt;quote_nullable&lt;/code&gt; 이 더 적합합니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;예 42.1&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53525574dae97c82a2a3a894b1e737a2f25851b9" translate="yes" xml:space="preserve">
          <source>Return the given string suitably quoted to be used as a string literal in an SQL statement string; or, if the argument is null, return &lt;code&gt;NULL&lt;/code&gt;. Embedded single-quotes and backslashes are properly doubled. See also &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;Example 42.1&lt;/a&gt;.</source>
          <target state="translated">SQL 문 문자열에서 문자열 리터럴로 사용하기 위해 적절하게 인용 된 지정된 문자열을 리턴하십시오. 또는, 인수가 널 (null), 반환의 경우 &lt;code&gt;NULL&lt;/code&gt; 은 . 포함 된 작은 따옴표와 백 슬래시는 올바르게 두 배입니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;예 42.1&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d57ac7b7e9c16ea588ceab9134ea36165a2bd992" translate="yes" xml:space="preserve">
          <source>Return the given string suitably quoted to be used as an identifier in an SQL statement string. Quotes are added only if necessary (i.e., if the string contains non-identifier characters or would be case-folded). Embedded quotes are properly doubled. See also &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;Example 42.1&lt;/a&gt;.</source>
          <target state="translated">SQL 문 문자열에서 식별자로 사용하기 위해 적절하게 인용 된 주어진 문자열을 리턴하십시오. 따옴표는 필요한 경우에만 추가됩니다 (예 : 문자열에 식별자가 아닌 문자가 포함되거나 대소 문자가 접힌 경우). 포함 된 따옴표는 올바르게 두 배가됩니다. &lt;a href=&quot;https://www.postgresql.org/docs/12/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;예 42.1&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fae87cdc51cc109aeafda44315fb90823f2fa6e" translate="yes" xml:space="preserve">
          <source>Return the replay location for the given replication origin. The parameter &lt;em&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/em&gt; determines whether the corresponding local transaction will be guaranteed to have been flushed to disk or not.</source>
          <target state="translated">주어진 복제 원점의 재생 위치를 반환합니다. &lt;em&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/em&gt; 매개 변수 는 해당 로컬 트랜잭션이 디스크로 &lt;em&gt;플러시&lt;/em&gt; 되는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3299483f42517bcadeb6d426f26ff9253356c589" translate="yes" xml:space="preserve">
          <source>Return the replay location for the replication origin configured in the current session. The parameter &lt;em&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/em&gt; determines whether the corresponding local transaction will be guaranteed to have been flushed to disk or not.</source>
          <target state="translated">현재 세션에서 구성된 복제 오리진의 재생 위치를 반환합니다. &lt;em&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/em&gt; 매개 변수 는 해당 로컬 트랜잭션이 디스크로 &lt;em&gt;플러시&lt;/em&gt; 되는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="ef843faa85518666fe64ecde17adff0a4d03d5b0" translate="yes" xml:space="preserve">
          <source>Return the textual name of the given build phase number. The phase numbers are those reported during an index build via the &lt;code&gt;pgstat_progress_update_param&lt;/code&gt; interface. The phase names are then exposed in the &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; view.</source>
          <target state="translated">주어진 빌드 단계 번호의 텍스트 이름을 반환합니다. 단계 번호는 &lt;code&gt;pgstat_progress_update_param&lt;/code&gt; 인터페이스 를 통해 인덱스 빌드 중에보고 된 단계 번호 입니다. 그러면 위상 이름이 &lt;code&gt;pg_stat_progress_create_index&lt;/code&gt; 보기에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="eba0d2ed796a8b65e235d55b26d6558b63ea4b0e" translate="yes" xml:space="preserve">
          <source>Return the top-most parent of a partition tree to which the given relation belongs.</source>
          <target state="translated">주어진 관계가 속한 파티션 트리의 최상위 부모를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e3960f5434772d8c3f4a1c34458060eaa3b172c6" translate="yes" xml:space="preserve">
          <source>Return the value most recently obtained by &lt;code&gt;nextval&lt;/code&gt; for this sequence in the current session. (An error is reported if &lt;code&gt;nextval&lt;/code&gt; has never been called for this sequence in this session.) Because this is returning a session-local value, it gives a predictable answer whether or not other sessions have executed &lt;code&gt;nextval&lt;/code&gt; since the current session did.</source>
          <target state="translated">현재 세션에서이 시퀀스에 대해 &lt;code&gt;nextval&lt;/code&gt; 에 의해 가장 최근에 얻은 값을 반환합니다 . (경우는 오류가보고됩니다 &lt;code&gt;nextval&lt;/code&gt; 이 세션에서이 순서를 요구 한 적이있다.)이 세션 - 로컬 값을 반환하기 때문에, 다른 세션이 실행 여부에 관계없이 예측 가능한 답변을 제공 &lt;code&gt;nextval&lt;/code&gt; 현재 세션이 한 이후입니다.</target>
        </trans-unit>
        <trans-unit id="0a196bd2fd1eb37dd31397901c76c6bfc41811ae" translate="yes" xml:space="preserve">
          <source>Return the value most recently returned by &lt;code&gt;nextval&lt;/code&gt; in the current session. This function is identical to &lt;code&gt;currval&lt;/code&gt;, except that instead of taking the sequence name as an argument it refers to whichever sequence &lt;code&gt;nextval&lt;/code&gt; was most recently applied to in the current session. It is an error to call &lt;code&gt;lastval&lt;/code&gt; if &lt;code&gt;nextval&lt;/code&gt; has not yet been called in the current session.</source>
          <target state="translated">현재 세션에서 &lt;code&gt;nextval&lt;/code&gt; 에 의해 가장 최근에 반환 된 값을 반환합니다 . 이 함수는 시퀀스 이름을 인수로 사용하는 대신 &lt;code&gt;nextval&lt;/code&gt; 이 현재 세션에서 가장 최근에 적용된 시퀀스를 참조한다는 점을 제외하고 &lt;code&gt;currval&lt;/code&gt; 과 동일합니다 . 현재 세션에서 &lt;code&gt;nextval&lt;/code&gt; 이 아직 호출되지 않은 경우 &lt;code&gt;lastval&lt;/code&gt; 을 호출하는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="41b1fb407b7fa442b77381701968fb175362cf78" translate="yes" xml:space="preserve">
          <source>Return type</source>
          <target state="translated">반품 유형</target>
        </trans-unit>
        <trans-unit id="2a104fa6924d6cf1b5f735046301d423f6bbcc52" translate="yes" xml:space="preserve">
          <source>Return value most recently obtained with &lt;code&gt;nextval&lt;/code&gt; for any sequence</source>
          <target state="translated">시퀀스에 대해 &lt;code&gt;nextval&lt;/code&gt; 을 사용 하여 가장 최근에 얻은 반환 값</target>
        </trans-unit>
        <trans-unit id="75189bfb93d24f7f318bad8af560b8904d6e2990" translate="yes" xml:space="preserve">
          <source>Return value most recently obtained with &lt;code&gt;nextval&lt;/code&gt; for specified sequence</source>
          <target state="translated">지정된 시퀀스에 대해 &lt;code&gt;nextval&lt;/code&gt; 로 가장 최근에 얻은 반환 값</target>
        </trans-unit>
        <trans-unit id="4b104f79c1174b5dd88b2cc520aaa0fd42a5cae0" translate="yes" xml:space="preserve">
          <source>Returning Data From Modified Rows</source>
          <target state="translated">수정 된 행에서 데이터 반환</target>
        </trans-unit>
        <trans-unit id="dc396fa56aa8e66178deab117de589f741f60c34" translate="yes" xml:space="preserve">
          <source>Returning Data from Modified Rows</source>
          <target state="translated">수정 된 행에서 데이터 반환</target>
        </trans-unit>
        <trans-unit id="c30f45bfe474f8bbdabef9be767996cc9538e7a6" translate="yes" xml:space="preserve">
          <source>Returning to our example:</source>
          <target state="translated">우리의 예로 돌아 가기 :</target>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="translated">Returns</target>
        </trans-unit>
        <trans-unit id="f5f925aa7de398f7d5494e55a7ca7d4b56d7f414" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;from_json&lt;/code&gt; as indented JSON text.</source>
          <target state="translated">들여 쓰기 된 JSON 텍스트로 &lt;code&gt;from_json&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f66332ffcc126cd7c481e7192be5159684c325b0" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;from_json&lt;/code&gt; with all object fields that have null values omitted. Other null values are untouched.</source>
          <target state="translated">널값이 생략 된 모든 오브젝트 필드와 함께 &lt;code&gt;from_json&lt;/code&gt; 을 리턴 합니다. 다른 널값은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d5a41ae98f5a243e8cd966447774299a8f77a10" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;target&lt;/code&gt; with &lt;code&gt;new_value&lt;/code&gt; inserted. If &lt;code&gt;target&lt;/code&gt; section designated by &lt;code&gt;path&lt;/code&gt; is in a JSONB array, &lt;code&gt;new_value&lt;/code&gt; will be inserted before target or after if &lt;code&gt;insert_after&lt;/code&gt; is true (default is &lt;code&gt;false&lt;/code&gt;). If &lt;code&gt;target&lt;/code&gt; section designated by &lt;code&gt;path&lt;/code&gt; is in JSONB object, &lt;code&gt;new_value&lt;/code&gt; will be inserted only if &lt;code&gt;target&lt;/code&gt; does not exist. As with the path oriented operators, negative integers that appear in &lt;code&gt;path&lt;/code&gt; count from the end of JSON arrays.</source>
          <target state="translated">&lt;code&gt;new_value&lt;/code&gt; 가 삽입 된 &lt;code&gt;target&lt;/code&gt; 을 리턴합니다 . 경우 &lt;code&gt;target&lt;/code&gt; 에 의해 지정된 부분 &lt;code&gt;path&lt;/code&gt; JSONB 배열이다 &lt;code&gt;new_value&lt;/code&gt; 타겟 전 또는 후에 만약 삽입 될 &lt;code&gt;insert_after&lt;/code&gt; 는 (디폴트는 참 &lt;code&gt;false&lt;/code&gt; ). 경우 &lt;code&gt;target&lt;/code&gt; 에 의해 지정된 부분 &lt;code&gt;path&lt;/code&gt; JSONB 개체이다 &lt;code&gt;new_value&lt;/code&gt; 경우에만 삽입 될 &lt;code&gt;target&lt;/code&gt; 존재하지 않는다. 경로 중심의 사업자와 같이 나타납니다 음수 &lt;code&gt;path&lt;/code&gt; JSON 배열의 끝에서 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ba58fee75e015b43343a8b7d351b30ae053d3178" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;target&lt;/code&gt; with the section designated by &lt;code&gt;path&lt;/code&gt; replaced by &lt;code&gt;new_value&lt;/code&gt;, or with &lt;code&gt;new_value&lt;/code&gt; added if &lt;code&gt;create_missing&lt;/code&gt; is true (default is &lt;code&gt;true&lt;/code&gt;) and the item designated by &lt;code&gt;path&lt;/code&gt; does not exist. As with the path oriented operators, negative integers that appear in &lt;code&gt;path&lt;/code&gt; count from the end of JSON arrays.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 로 지정된 섹션 이 &lt;code&gt;new_value&lt;/code&gt; 로 대체 되거나 &lt;code&gt;create_missing&lt;/code&gt; 이 true (기본값은 &lt;code&gt;true&lt;/code&gt; )이고 &lt;code&gt;path&lt;/code&gt; 지정된 항목 이없는 경우 &lt;code&gt;new_value&lt;/code&gt; 가 추가 된 &lt;code&gt;target&lt;/code&gt; 을 리턴 합니다. 경로 중심의 사업자와 같이 나타납니다 음수 &lt;code&gt;path&lt;/code&gt; JSON 배열의 끝에서 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ae93e6635a64d536df458004d5daf3ba8aabc741" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if its arguments have a similarity that is greater than the current similarity threshold set by &lt;code&gt;pg_trgm.similarity_threshold&lt;/code&gt;.</source>
          <target state="translated">인수의 유사성이 &lt;code&gt;pg_trgm.similarity_threshold&lt;/code&gt; 에 의해 설정된 현재 유사성 임계 값보다 큰 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="293852056bf3418b664b171c1fd96c9051d1c28c" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if its second argument has a continuous extent of an ordered trigram set that matches word boundaries, and its similarity to the trigram set of the first argument is greater than the current strict word similarity threshold set by the &lt;code&gt;pg_trgm.strict_word_similarity_threshold&lt;/code&gt; parameter.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 두 번째 인수가 단어 경계와 일치하는 주문 괘 세트의 연속 범위를 가지고 있으며, 첫 번째 인수의 괘 세트에 유사성이하여 현재 엄격한 단어의 유사성 임계 값 설정보다 큰 경우 &lt;code&gt;pg_trgm.strict_word_similarity_threshold&lt;/code&gt; 의 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="c0f88f55e3dce9a819ae48b5b56c0c8abcc7a87d" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the similarity between the trigram set in the first argument and a continuous extent of an ordered trigram set in the second argument is greater than the current word similarity threshold set by &lt;code&gt;pg_trgm.word_similarity_threshold&lt;/code&gt; parameter.</source>
          <target state="translated">첫 번째 인수의 트라이 그램 세트와 두 번째 인수의 정렬 된 트라이 그램 세트의 연속 범위 간의 유사성이 &lt;code&gt;pg_trgm.word_similarity_threshold&lt;/code&gt; 매개 변수로 설정된 현재 단어 유사성 임계 값보다 큰 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="c12d3bbbf747cdec9370085b1f308f38081489e5" translate="yes" xml:space="preserve">
          <source>Returns &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; cryptographically strong random bytes. At most 1024 bytes can be extracted at a time. This is to avoid draining the randomness generator pool.</source>
          <target state="translated">암호화 적으로 강한 임의의 바이트 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 리턴 합니다. 한 번에 최대 1024 바이트를 추출 할 수 있습니다. 이는 임의 생성기 풀의 배수를 피하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d30daca13616c8f1ae449e627e32041135ae816d" translate="yes" xml:space="preserve">
          <source>Returns &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; with &lt;em&gt;&lt;code&gt;new_value&lt;/code&gt;&lt;/em&gt; inserted. If the item designated by the &lt;em&gt;&lt;code&gt;path&lt;/code&gt;&lt;/em&gt; is an array element, &lt;em&gt;&lt;code&gt;new_value&lt;/code&gt;&lt;/em&gt; will be inserted before that item if &lt;em&gt;&lt;code&gt;insert_after&lt;/code&gt;&lt;/em&gt; is false (which is the default), or after it if &lt;em&gt;&lt;code&gt;insert_after&lt;/code&gt;&lt;/em&gt; is true. If the item designated by the &lt;em&gt;&lt;code&gt;path&lt;/code&gt;&lt;/em&gt; is an object field, &lt;em&gt;&lt;code&gt;new_value&lt;/code&gt;&lt;/em&gt; will be inserted only if the object does not already contain that key. All earlier steps in the path must exist, or the &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; is returned unchanged. As with the path oriented operators, negative integers that appear in the &lt;em&gt;&lt;code&gt;path&lt;/code&gt;&lt;/em&gt; count from the end of JSON arrays. If the last path step is an array index that is out of range, the new value is added at the beginning of the array if the index is negative, or at the end of the array if it is positive.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;new_value&lt;/code&gt; 가&lt;/em&gt; 삽입 된 &lt;em&gt; &lt;code&gt;target&lt;/code&gt; &lt;/em&gt; 을 반환합니다 . &lt;em&gt; &lt;code&gt;path&lt;/code&gt; &lt;/em&gt; 로 지정된 항목 이 배열 요소 인 경우 &lt;em&gt; &lt;code&gt;insert_after&lt;/code&gt; &lt;/em&gt; 가 false (기본값) 이면 해당 항목 앞에 , &lt;em&gt; &lt;code&gt;insert_after&lt;/code&gt; &lt;/em&gt; 가 true이면 그 뒤에 &lt;em&gt; &lt;code&gt;new_value&lt;/code&gt; &lt;/em&gt; 가 삽입됩니다 . &lt;em&gt; &lt;code&gt;path&lt;/code&gt; &lt;/em&gt; 로 지정된 항목 이 개체 필드 인 경우 개체에 해당 키가 아직 포함되지 않은 경우에만 &lt;em&gt; &lt;code&gt;new_value&lt;/code&gt; &lt;/em&gt; 가 삽입됩니다. 경로의 모든 이전 단계가 존재해야합니다. 그렇지 않으면 &lt;em&gt; &lt;code&gt;target&lt;/code&gt; &lt;/em&gt; 이 변경되지 않고 반환됩니다. 경로 중심의 사업자와 마찬가지로 음의 정수는에 나타나는 &lt;em&gt; &lt;code&gt;path&lt;/code&gt; &lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;JSON 배열의 끝에서 계산합니다. 마지막 경로 단계가 범위를 벗어난 배열 인덱스 인 경우 새 값은 인덱스가 음수이면 배열의 시작 부분에 추가되고 양수이면 배열 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="28aa438b5cdf00bce4f085f26bf5acc7f64772d4" translate="yes" xml:space="preserve">
          <source>Returns &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; with the item designated by &lt;em&gt;&lt;code&gt;path&lt;/code&gt;&lt;/em&gt; replaced by &lt;em&gt;&lt;code&gt;new_value&lt;/code&gt;&lt;/em&gt;, or with &lt;em&gt;&lt;code&gt;new_value&lt;/code&gt;&lt;/em&gt; added if &lt;em&gt;&lt;code&gt;create_if_missing&lt;/code&gt;&lt;/em&gt; is true (which is the default) and the item designated by &lt;em&gt;&lt;code&gt;path&lt;/code&gt;&lt;/em&gt; does not exist. All earlier steps in the path must exist, or the &lt;em&gt;&lt;code&gt;target&lt;/code&gt;&lt;/em&gt; is returned unchanged. As with the path oriented operators, negative integers that appear in the &lt;em&gt;&lt;code&gt;path&lt;/code&gt;&lt;/em&gt; count from the end of JSON arrays. If the last path step is an array index that is out of range, and &lt;em&gt;&lt;code&gt;create_if_missing&lt;/code&gt;&lt;/em&gt; is true, the new value is added at the beginning of the array if the index is negative, or at the end of the array if it is positive.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;path&lt;/code&gt; &lt;/em&gt; 로 지정된 항목 이 &lt;em&gt; &lt;code&gt;new_value&lt;/code&gt; &lt;/em&gt;&lt;em&gt;로&lt;/em&gt; 대체 되거나 &lt;em&gt; &lt;code&gt;create_if_missing&lt;/code&gt; &lt;/em&gt; 이 true (기본값)이고 &lt;em&gt; &lt;code&gt;path&lt;/code&gt; 로&lt;/em&gt; 지정된 항목 이 존재하지 않는 경우 &lt;em&gt; &lt;code&gt;new_value&lt;/code&gt; 가&lt;/em&gt; 추가 된 &lt;em&gt; &lt;code&gt;target&lt;/code&gt; &lt;/em&gt; 을 반환 합니다. 경로의 모든 이전 단계가 존재해야합니다. 그렇지 않으면 &lt;em&gt; &lt;code&gt;target&lt;/code&gt; &lt;/em&gt; 이 변경되지 않고 반환됩니다. 경로 중심의 사업자와 마찬가지로 나타납니다 음수 &lt;em&gt; &lt;code&gt;path&lt;/code&gt; &lt;/em&gt; JSON 배열의 끝에서 계산합니다. 마지막 경로 단계가 범위를 벗어난 배열 인덱스이고 &lt;em&gt; &lt;code&gt;create_if_missing&lt;/code&gt; &lt;/em&gt; 이 true이면 새 값이 인덱스가 음수이면 배열의 시작 부분에 추가되고 양수이면 배열 끝에 추가됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ebfa6078f258aebaa8d35349bb99b05bcebc127" translate="yes" xml:space="preserve">
          <source>Returns &lt;em&gt;&lt;code&gt;value&lt;/code&gt;&lt;/em&gt; evaluated at the row that is &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; rows after the current row within the partition; if there is no such row, instead returns &lt;em&gt;&lt;code&gt;default&lt;/code&gt;&lt;/em&gt; (which must be of the same type as &lt;em&gt;&lt;code&gt;value&lt;/code&gt;&lt;/em&gt;). Both &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;default&lt;/code&gt;&lt;/em&gt; are evaluated with respect to the current row. If omitted, &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; defaults to 1 and &lt;em&gt;&lt;code&gt;default&lt;/code&gt;&lt;/em&gt; to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">파티션 내에서 현재 행 뒤의 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 행인 행에서 평가 된 &lt;em&gt; &lt;code&gt;value&lt;/code&gt; &lt;/em&gt; 반환 합니다. 그러한 행이 없으면 대신 &lt;em&gt; &lt;code&gt;default&lt;/code&gt; &lt;/em&gt; ( &lt;em&gt; &lt;code&gt;value&lt;/code&gt; &lt;/em&gt; 와 동일한 유형이어야 함)를 반환 합니다 . &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 과 &lt;em&gt; &lt;code&gt;default&lt;/code&gt; &lt;/em&gt; 은 모두 현재 행을 기준으로 평가됩니다. 생략하면 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 기본값은 1이고 &lt;em&gt; &lt;code&gt;default&lt;/code&gt; &lt;/em&gt; 은 &lt;code&gt;NULL&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bea151af13f944890fa332332f6bd6b136957db7" translate="yes" xml:space="preserve">
          <source>Returns &lt;em&gt;&lt;code&gt;value&lt;/code&gt;&lt;/em&gt; evaluated at the row that is &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; rows before the current row within the partition; if there is no such row, instead returns &lt;em&gt;&lt;code&gt;default&lt;/code&gt;&lt;/em&gt; (which must be of the same type as &lt;em&gt;&lt;code&gt;value&lt;/code&gt;&lt;/em&gt;). Both &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;default&lt;/code&gt;&lt;/em&gt; are evaluated with respect to the current row. If omitted, &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; defaults to 1 and &lt;em&gt;&lt;code&gt;default&lt;/code&gt;&lt;/em&gt; to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">파티션 내에서 현재 행 이전의 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 행인 행에서 평가 된 &lt;em&gt; &lt;code&gt;value&lt;/code&gt; &lt;/em&gt; 반환 합니다. 그러한 행이 없으면 대신 &lt;em&gt; &lt;code&gt;default&lt;/code&gt; &lt;/em&gt; ( &lt;em&gt; &lt;code&gt;value&lt;/code&gt; &lt;/em&gt; 와 동일한 유형이어야 함)를 반환 합니다 . &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 과 &lt;em&gt; &lt;code&gt;default&lt;/code&gt; &lt;/em&gt; 은 모두 현재 행을 기준으로 평가됩니다. 생략하면 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 기본값은 1이고 &lt;em&gt; &lt;code&gt;default&lt;/code&gt; &lt;/em&gt; 은 &lt;code&gt;NULL&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d584ab94929a3b0566c8e2e204af944f5eb26ae" translate="yes" xml:space="preserve">
          <source>Returns &lt;em&gt;&lt;code&gt;value&lt;/code&gt;&lt;/em&gt; evaluated at the row that is the &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt;'th row of the window frame (counting from 1); returns &lt;code&gt;NULL&lt;/code&gt; if there is no such row.</source>
          <target state="translated">창 프레임 의 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; 번째 행인 행에서 평가 된 &lt;em&gt; &lt;code&gt;value&lt;/code&gt; &lt;/em&gt; 반환 &lt;em&gt;합니다&lt;/em&gt; (1부터 계산). 그러한 행이 없으면 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ad445bc888630288225659338bdcd3d620fdd86" translate="yes" xml:space="preserve">
          <source>Returns &lt;em&gt;&lt;code&gt;value&lt;/code&gt;&lt;/em&gt; evaluated at the row that is the first row of the window frame.</source>
          <target state="translated">창 프레임의 첫 번째 행인 행에서 평가 된 &lt;em&gt; &lt;code&gt;value&lt;/code&gt; &lt;/em&gt; 반환 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c70d770722000739a535ed6fa0cd081e977df2c4" translate="yes" xml:space="preserve">
          <source>Returns &lt;em&gt;&lt;code&gt;value&lt;/code&gt;&lt;/em&gt; evaluated at the row that is the last row of the window frame.</source>
          <target state="translated">창 프레임의 마지막 행인 행에서 평가 된 &lt;em&gt; &lt;code&gt;value&lt;/code&gt; &lt;/em&gt; 반환 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="835184550533b99bc7dafe08c0d025af6c40ae96" translate="yes" xml:space="preserve">
          <source>Returns JSON value pointed to by &lt;code&gt;path_elems&lt;/code&gt; (equivalent to &lt;code&gt;#&amp;gt;&lt;/code&gt; operator).</source>
          <target state="translated">&lt;code&gt;path_elems&lt;/code&gt; ( &lt;code&gt;#&amp;gt;&lt;/code&gt; 연산자 와 동일)가 가리키는 JSON 값을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="fba032e696c17ba56d0f3438443e5bc4c78dbdc1" translate="yes" xml:space="preserve">
          <source>Returns JSON value pointed to by &lt;code&gt;path_elems&lt;/code&gt; as &lt;code&gt;text&lt;/code&gt; (equivalent to &lt;code&gt;#&amp;gt;&amp;gt;&lt;/code&gt; operator).</source>
          <target state="translated">&lt;code&gt;path_elems&lt;/code&gt; 가 가리키는 JSON 값 을 &lt;code&gt;text&lt;/code&gt; ( &lt;code&gt;#&amp;gt;&amp;gt;&lt;/code&gt; 연산자 와 동일) 로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0d595ff43747967562b82d244ba0d2563a55f34a" translate="yes" xml:space="preserve">
          <source>Returns a &amp;ldquo;nil&amp;rdquo; UUID constant, which does not occur as a real UUID.</source>
          <target state="translated">실제 UUID로 발생하지 않는 &quot;nil&quot;UUID 상수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fde26741442a3eed8544af2085223472a63b0c1e" translate="yes" xml:space="preserve">
          <source>Returns a bit mask indicating which &lt;code id=&quot;group32by&quot;&gt;GROUP BY&lt;/code&gt; expressions are not included in the current grouping set. Bits are assigned with the rightmost argument corresponding to the least-significant bit; each bit is 0 if the corresponding expression is included in the grouping criteria of the grouping set generating the current result row, and 1 if it is not included.</source>
          <target state="translated">현재 그룹화 집합에 포함되지 않은 &lt;code id=&quot;group32by&quot;&gt;GROUP BY&lt;/code&gt; 식을 나타내는 비트 마스크를 반환합니다 . 비트는 최하위 비트에 해당하는 가장 오른쪽 인수로 할당됩니다. 현재 결과 행을 생성하는 그룹화 집합의 그룹화 기준에 해당 표현식이 포함되면 각 비트는 0이고 포함되지 않으면 1입니다.</target>
        </trans-unit>
        <trans-unit id="d44289ecf56e056feb69feae6c3f34e980e46c1a" translate="yes" xml:space="preserve">
          <source>Returns a box suitable for an indexed search using the &lt;code&gt;cube&lt;/code&gt;&lt;code&gt;@&amp;gt;&lt;/code&gt; operator for points within a given great circle distance of a location. Some points in this box are further than the specified great circle distance from the location, so a second check using &lt;code&gt;earth_distance&lt;/code&gt; should be included in the query.</source>
          <target state="translated">특정 위치의 대원 거리 내에있는 점에 대해 &lt;code&gt;cube&lt;/code&gt; &lt;code&gt;@&amp;gt;&lt;/code&gt; 연산자를 사용하여 색인화 된 검색에 적합한 상자를 반환합니다 . 이 상자의 일부 지점은 위치로부터 지정된 &lt;code&gt;earth_distance&lt;/code&gt; 거리보다 멀기 때문에 earth_distance 를 사용하는 두 번째 검사 가 쿼리에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f48450bfe5044cdcafdc1ff3faaa7a1be7332d36" translate="yes" xml:space="preserve">
          <source>Returns a box suitable for an indexed search using the cube &lt;code&gt;@&amp;gt;&lt;/code&gt; operator for points within a given great circle distance of a location. Some points in this box are further than the specified great circle distance from the location, so a second check using &lt;code&gt;earth_distance&lt;/code&gt; should be included in the query.</source>
          <target state="translated">주어진 위치에서 지정된 원 거리 내에있는 큐브에 대해 &lt;code&gt;@&amp;gt;&lt;/code&gt; 연산자를 사용하여 인덱스 검색에 적합한 상자를 반환합니다 . 이 상자의 일부 점은 위치에서 지정된 원호 거리보다 &lt;code&gt;earth_distance&lt;/code&gt; 때문에 earth_distance 를 사용한 두 번째 검사 가 쿼리에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3c3c927d6f7ca3c093439ef12bd4cb53ddb4df10" translate="yes" xml:space="preserve">
          <source>Returns a constant designating the DNS namespace for UUIDs.</source>
          <target state="translated">UUID에 대한 DNS 네임 스페이스를 지정하는 상수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8bde2767b82e50baf65e075c702f2641e3fc781" translate="yes" xml:space="preserve">
          <source>Returns a constant designating the ISO object identifier (OID) namespace for UUIDs. (This pertains to ASN.1 OIDs, which are unrelated to the OIDs used in PostgreSQL.)</source>
          <target state="translated">UUID에 대한 ISO OID (개체 식별자) 네임 스페이스를 지정하는 상수를 반환합니다. (이는 PostgreSQL에서 사용되는 OID와 관련이없는 ASN.1 OID와 관련이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8d0012c3b702dbfb1e491b79d747761aad025023" translate="yes" xml:space="preserve">
          <source>Returns a constant designating the URL namespace for UUIDs.</source>
          <target state="translated">UUID의 URL 네임 스페이스를 지정하는 상수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7cd14efc8370f27fe522641af571a56421dd153a" translate="yes" xml:space="preserve">
          <source>Returns a constant designating the X.500 distinguished name (DN) namespace for UUIDs.</source>
          <target state="translated">UUID에 대한 X.500 DN (고유 이름) 네임 스페이스를 지정하는 상수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2d24a91bbdab74c15fd20824e25ffe8be6b10eb3" translate="yes" xml:space="preserve">
          <source>Returns a current &lt;em&gt;snapshot&lt;/em&gt;, a data structure showing which transaction IDs are now in-progress.</source>
          <target state="translated">현재 진행중인 트랜잭션 ID를 보여주는 데이터 구조 인 현재 &lt;em&gt;스냅 샷을&lt;/em&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3ad43f1eda8ab056ea70c29cb1f77c38968d5179" translate="yes" xml:space="preserve">
          <source>Returns a number that indicates how similar the two arguments are. The range of the result is zero (indicating that the two strings are completely dissimilar) to one (indicating that the two strings are identical).</source>
          <target state="translated">두 인수가 얼마나 유사한 지 나타내는 숫자를 반환합니다. 결과 범위는 0 (두 문자열이 완전히 유사하지 않음을 나타냄)에서 1 (두 문자열이 동일 함을 나타냄)입니다.</target>
        </trans-unit>
        <trans-unit id="c0f48283f4ca73ac011523d34651f6d7fec13564" translate="yes" xml:space="preserve">
          <source>Returns a number that indicates the greatest similarity between the set of trigrams in the first string and any continuous extent of an ordered set of trigrams in the second string. For details, see the explanation below.</source>
          <target state="translated">첫 번째 문자열의 트라이 그램 세트와 두 번째 문자열의 정렬 된 트라이 그램 세트의 연속 범위 사이에서 가장 큰 유사성을 나타내는 숫자를 반환합니다. 자세한 내용은 아래 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb17021f648dcd2ab7c36183aa2a866ee7f5508f" translate="yes" xml:space="preserve">
          <source>Returns a palloc'd array of keys given a value to be queried; that is, &lt;code&gt;query&lt;/code&gt; is the value on the right-hand side of an indexable operator whose left-hand side is the indexed column. &lt;code&gt;n&lt;/code&gt; is the strategy number of the operator within the operator class (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-STRATEGIES&quot;&gt;Section 37.16.2&lt;/a&gt;). Often, &lt;code&gt;extractQuery&lt;/code&gt; will need to consult &lt;code&gt;n&lt;/code&gt; to determine the data type of &lt;code&gt;query&lt;/code&gt; and the method it should use to extract key values. The number of returned keys must be stored into &lt;code&gt;*nkeys&lt;/code&gt;. If any of the keys can be null, also palloc an array of &lt;code&gt;*nkeys&lt;/code&gt;&lt;code&gt;bool&lt;/code&gt; fields, store its address at &lt;code&gt;*nullFlags&lt;/code&gt;, and set these null flags as needed. &lt;code&gt;*nullFlags&lt;/code&gt; can be left &lt;code&gt;NULL&lt;/code&gt; (its initial value) if all keys are non-null. The return value can be &lt;code&gt;NULL&lt;/code&gt; if the &lt;code&gt;query&lt;/code&gt; contains no keys.</source>
          <target state="translated">쿼리 할 값이 지정된 palloc의 키 배열을 반환합니다. 즉, &lt;code&gt;query&lt;/code&gt; 는 왼쪽이 색인 된 열인 색인 가능한 연산자의 오른쪽에있는 값입니다. &lt;code&gt;n&lt;/code&gt; 은 연산자 클래스 내 연산자의 전략 번호입니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/xindex.html#XINDEX-STRATEGIES&quot;&gt;37.16.2 절&lt;/a&gt; 참조 ). 종종 &lt;code&gt;extractQuery&lt;/code&gt; 는 &lt;code&gt;query&lt;/code&gt; 의 데이터 유형 과 키 값을 추출하는 데 사용해야하는 방법 을 결정하기 위해 &lt;code&gt;n&lt;/code&gt; 을 참조 해야합니다. 리턴 된 키 수는 &lt;code&gt;*nkeys&lt;/code&gt; 에 저장해야합니다 . 키 중 하나라도 널이 될 수 있으면 &lt;code&gt;*nkeys&lt;/code&gt; &lt;code&gt;bool&lt;/code&gt; 필드 배열을 palloc 하고 주소를 &lt;code&gt;*nullFlags&lt;/code&gt; 에 저장 하십시오.필요에 따라 이러한 null 플래그를 설정하십시오. &lt;code&gt;*nullFlags&lt;/code&gt; 는 모든 키가 널이 아닌 경우 &lt;code&gt;NULL&lt;/code&gt; (초기 값) 로 남겨 둘 수 있습니다 . &lt;code&gt;query&lt;/code&gt; 에 키가없는 경우 반환 값은 &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db2ea970016be0131d4b27281a5918acd5a7745b" translate="yes" xml:space="preserve">
          <source>Returns a palloc'd array of keys given a value to be queried; that is, &lt;code&gt;query&lt;/code&gt; is the value on the right-hand side of an indexable operator whose left-hand side is the indexed column. &lt;code&gt;n&lt;/code&gt; is the strategy number of the operator within the operator class (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-STRATEGIES&quot;&gt;Section 37.16.2&lt;/a&gt;). Often, &lt;code&gt;extractQuery&lt;/code&gt; will need to consult &lt;code&gt;n&lt;/code&gt; to determine the data type of &lt;code&gt;query&lt;/code&gt; and the method it should use to extract key values. The number of returned keys must be stored into &lt;code&gt;*nkeys&lt;/code&gt;. If any of the keys can be null, also palloc an array of &lt;code&gt;*nkeys&lt;/code&gt;&lt;code&gt;bool&lt;/code&gt; fields, store its address at &lt;code&gt;*nullFlags&lt;/code&gt;, and set these null flags as needed. &lt;code&gt;*nullFlags&lt;/code&gt; can be left &lt;code&gt;NULL&lt;/code&gt; (its initial value) if all keys are non-null. The return value can be &lt;code&gt;NULL&lt;/code&gt; if the &lt;code&gt;query&lt;/code&gt; contains no keys.</source>
          <target state="translated">쿼리 할 값이 주어지면 palloc의 키 배열을 반환합니다. 즉, &lt;code&gt;query&lt;/code&gt; 는 왼쪽이 인덱싱 된 열인 인덱싱 가능한 연산자의 오른쪽에있는 값입니다. &lt;code&gt;n&lt;/code&gt; 은 연산자 클래스 내 연산자의 전략 번호입니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/xindex.html#XINDEX-STRATEGIES&quot;&gt;섹션 37.16.2&lt;/a&gt; 참조 ). 종종 &lt;code&gt;extractQuery&lt;/code&gt; 는 &lt;code&gt;query&lt;/code&gt; 의 데이터 유형 과 키 값을 추출하는 데 사용해야하는 방법 을 결정하기 위해 &lt;code&gt;n&lt;/code&gt; 을 참조 해야합니다. 반환 된 키의 수는 &lt;code&gt;*nkeys&lt;/code&gt; 에 저장되어야합니다 . 키가 null 일 수있는 경우 &lt;code&gt;*nkeys&lt;/code&gt; &lt;code&gt;bool&lt;/code&gt; 필드 의 배열을 palloc하고 해당 주소를 &lt;code&gt;*nullFlags&lt;/code&gt; 에 저장합니다., 필요에 따라 이러한 null 플래그를 설정합니다. &lt;code&gt;*nullFlags&lt;/code&gt; 는 모든 키가 널이 아닌 경우 &lt;code&gt;NULL&lt;/code&gt; (초기 값)로 남을 수 있습니다 . &lt;code&gt;query&lt;/code&gt; 에 키가없는 경우 반환 값은 &lt;code&gt;NULL&lt;/code&gt; 이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7aa4a42d2008a74656fb447440aceef698c69463" translate="yes" xml:space="preserve">
          <source>Returns a palloc'd array of keys given an item to be indexed. The number of returned keys must be stored into &lt;code&gt;*nkeys&lt;/code&gt;. If any of the keys can be null, also palloc an array of &lt;code&gt;*nkeys&lt;/code&gt;&lt;code&gt;bool&lt;/code&gt; fields, store its address at &lt;code&gt;*nullFlags&lt;/code&gt;, and set these null flags as needed. &lt;code&gt;*nullFlags&lt;/code&gt; can be left &lt;code&gt;NULL&lt;/code&gt; (its initial value) if all keys are non-null. The return value can be &lt;code&gt;NULL&lt;/code&gt; if the item contains no keys.</source>
          <target state="translated">색인을 생성 할 항목이 지정된 palloc의 키 배열을 반환합니다. 리턴 된 키 수는 &lt;code&gt;*nkeys&lt;/code&gt; 에 저장해야합니다 . 키 중 하나가 널이 될 수있는 경우 &lt;code&gt;*nkeys&lt;/code&gt; &lt;code&gt;bool&lt;/code&gt; 필드 배열을 palloc 하고 주소를 &lt;code&gt;*nullFlags&lt;/code&gt; 에 저장하고 필요에 따라 이러한 널 플래그를 설정하십시오. &lt;code&gt;*nullFlags&lt;/code&gt; 는 모든 키가 널이 아닌 경우 &lt;code&gt;NULL&lt;/code&gt; (초기 값) 로 남겨 둘 수 있습니다 . 항목에 키가없는 경우 반환 값은 &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3463ce6e00d031335609f51b52f15924592d3c3a" translate="yes" xml:space="preserve">
          <source>Returns a query that searches for a match to the first given query followed by a match to the second given query at a distance of at &lt;code&gt;distance&lt;/code&gt; lexemes, using the &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt;&lt;code&gt;tsquery&lt;/code&gt; operator. For example:</source>
          <target state="translated">&lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; &lt;code&gt;tsquery&lt;/code&gt; 연산자를 사용하여 첫 번째 주어진 쿼리와 일치 한 다음 거리 렉 세스 &lt;code&gt;distance&lt;/code&gt; 에서 두 번째 제공된 쿼리와 일치하는 쿼리를 반환합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1941b7745c7faedda19a242cdb6402f169231a45" translate="yes" xml:space="preserve">
          <source>Returns a query that searches for a match to the first given query followed by a match to the second given query at a distance of exactly &lt;code&gt;distance&lt;/code&gt; lexemes, using the &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt;&lt;code&gt;tsquery&lt;/code&gt; operator. For example:</source>
          <target state="translated">&lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; &lt;code&gt;tsquery&lt;/code&gt; 연산자를 사용하여 정확히 &lt;code&gt;distance&lt;/code&gt; lexemes 의 거리에서 주어진 첫 번째 쿼리에 대한 일치를 검색 한 다음 두 번째 지정된 쿼리에 대한 일치를 검색하는 쿼리를 반환합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="a9598e183f78ab270e992d26b5cf02dd7e71f41a" translate="yes" xml:space="preserve">
          <source>Returns a query that searches for a match to the first given query immediately followed by a match to the second given query, using the &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY) &lt;code&gt;tsquery&lt;/code&gt; operator. For example:</source>
          <target state="translated">&lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; ( &lt;code&gt;tsquery&lt;/code&gt; BY) tsquery 연산자를 사용하여 첫 번째 지정된 쿼리와 즉시 일치 한 다음 두 번째 쿼리와 일치하는 쿼리를 반환합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7ba37436ffdccc251fec05e5b370edba5fa24dd" translate="yes" xml:space="preserve">
          <source>Returns a random value in the range 0.0 &amp;lt;= x &amp;lt; 1.0</source>
          <target state="translated">0.0 &amp;lt;= x &amp;lt;1.0 범위의 임의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c6e88c46eccb894be16a6017bc2850f4b9c8159" translate="yes" xml:space="preserve">
          <source>Returns a record containing the file's size, last access time stamp, last modification time stamp, last file status change time stamp (Unix platforms only), file creation time stamp (Windows only), and a flag indicating if it is a directory.</source>
          <target state="translated">파일 크기, 마지막 액세스 타임 스탬프, 마지막 수정 타임 스탬프, 마지막 파일 상태 변경 타임 스탬프 (Unix 플랫폼 만 해당), 파일 생성 타임 스탬프 (Windows 만 해당) 및 디렉토리인지 여부를 나타내는 플래그를 포함하는 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5bd36d08963122a7d85e2e702a408b2ac783158a" translate="yes" xml:space="preserve">
          <source>Returns a record of information about the backend with the specified PID, or one record for each active backend in the system if &lt;code&gt;NULL&lt;/code&gt; is specified. The fields returned are a subset of those in the &lt;code&gt;pg_stat_activity&lt;/code&gt; view.</source>
          <target state="translated">지정된 PID를 가진 백엔드에 대한 정보 레코드 또는 &lt;code&gt;NULL&lt;/code&gt; 이 지정된 경우 시스템에서 각 활성 백엔드에 대한 하나의 레코드를 리턴 합니다. 리턴 된 필드는 &lt;code&gt;pg_stat_activity&lt;/code&gt; 보기 에있는 필드의 서브 세트입니다 .</target>
        </trans-unit>
        <trans-unit id="f9695acbf72b46aad729e7912f12b2aec9b1183b" translate="yes" xml:space="preserve">
          <source>Returns a record of information about the backend with the specified process ID, or one record for each active backend in the system if &lt;code&gt;NULL&lt;/code&gt; is specified. The fields returned are a subset of those in the &lt;code&gt;pg_stat_activity&lt;/code&gt; view.</source>
          <target state="translated">지정된 프로세스 ID가있는 백엔드에 대한 정보 레코드를 반환하거나 &lt;code&gt;NULL&lt;/code&gt; 이 지정된 경우 시스템의 각 활성 백엔드에 대해 하나의 레코드를 반환 합니다. 반환 된 필드는 &lt;code&gt;pg_stat_activity&lt;/code&gt; 뷰 에있는 필드의 하위 집합입니다 .</target>
        </trans-unit>
        <trans-unit id="2096d08de234e1e2c8fafa5c108557974fc179ef" translate="yes" xml:space="preserve">
          <source>Returns a relation's OID given the tablespace OID and filenode it is stored under. This is essentially the inverse mapping of &lt;code&gt;pg_relation_filepath&lt;/code&gt;. For a relation in the database's default tablespace, the tablespace can be specified as zero. Returns &lt;code&gt;NULL&lt;/code&gt; if no relation in the current database is associated with the given values.</source>
          <target state="translated">테이블 스페이스 OID 및 파일 노드가 저장된 관계의 OID를 반환합니다. 이것은 본질적으로 &lt;code&gt;pg_relation_filepath&lt;/code&gt; 의 역 매핑입니다 . 데이터베이스의 기본 테이블 스페이스에있는 관계의 경우 테이블 스페이스를 0으로 지정할 수 있습니다. 현재 데이터베이스에 지정된 값과 연결된 관계가 없으면 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f32bd677990bf7398dcd83e804be275112aac8c2" translate="yes" xml:space="preserve">
          <source>Returns a role's name given its OID.</source>
          <target state="translated">OID가 주어진 역할의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8baa98af7c07b6a5363bd3b3da56d49ea985e67" translate="yes" xml:space="preserve">
          <source>Returns a row containing enough information to uniquely identify the database object specified by a type code and object name and argument arrays. The returned values are the ones that would be used in system catalogs such as &lt;code&gt;pg_depend&lt;/code&gt;; they can be passed to other system functions such as &lt;code&gt;pg_describe_object&lt;/code&gt; or &lt;code&gt;pg_identify_object&lt;/code&gt;. &lt;em&gt;&lt;code&gt;classid&lt;/code&gt;&lt;/em&gt; is the OID of the system catalog containing the object; &lt;em&gt;&lt;code&gt;objid&lt;/code&gt;&lt;/em&gt; is the OID of the object itself, and &lt;em&gt;&lt;code&gt;objsubid&lt;/code&gt;&lt;/em&gt; is the sub-object ID, or zero if none. This function is the inverse of &lt;code&gt;pg_identify_object_as_address&lt;/code&gt;.</source>
          <target state="translated">형식 코드와 개체 이름 및 인수 배열로 지정된 데이터베이스 개체를 고유하게 식별하기에 충분한 정보가 포함 된 행을 반환합니다. 반환 된 값은 &lt;code&gt;pg_depend&lt;/code&gt; 와 같은 시스템 카탈로그에서 사용되는 값입니다 . &lt;code&gt;pg_describe_object&lt;/code&gt; 또는 &lt;code&gt;pg_identify_object&lt;/code&gt; 와 같은 다른 시스템 함수에 전달할 수 있습니다 . &lt;em&gt; &lt;code&gt;classid&lt;/code&gt; &lt;/em&gt; 는 개체를 포함하는 시스템 카탈로그의 OID입니다. &lt;em&gt; &lt;code&gt;objid&lt;/code&gt; &lt;/em&gt; 는 개체 자체의 OID이고 &lt;em&gt; &lt;code&gt;objsubid&lt;/code&gt; &lt;/em&gt; 는 하위 개체 ID이거나없는 경우 0입니다. 이 함수는 &lt;code&gt;pg_identify_object_as_address&lt;/code&gt; 의 역입니다 .</target>
        </trans-unit>
        <trans-unit id="87a41c93e94e69fb57c2601184d283c844f7344a" translate="yes" xml:space="preserve">
          <source>Returns a row containing enough information to uniquely identify the database object specified by catalog OID, object OID and sub-object ID. The returned information is independent of the current server, that is, it could be used to identify an identically named object in another server. &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; identifies the type of database object; &lt;em&gt;&lt;code&gt;object_names&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;object_args&lt;/code&gt;&lt;/em&gt; are text arrays that together form a reference to the object. These three values can be passed to &lt;code&gt;pg_get_object_address&lt;/code&gt; to obtain the internal address of the object.</source>
          <target state="translated">카탈로그 OID, 개체 OID 및 하위 개체 ID로 지정된 데이터베이스 개체를 고유하게 식별하기에 충분한 정보가 포함 된 행을 반환합니다. 반환 된 정보는 현재 서버와 무관합니다. 즉, 다른 서버에서 동일한 이름의 개체를 식별하는 데 사용될 수 있습니다. &lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt; 은 데이터베이스 개체의 유형을 식별합니다. &lt;em&gt; &lt;code&gt;object_names&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;object_args&lt;/code&gt; &lt;/em&gt; 는 함께 개체에 대한 참조를 형성하는 텍스트 배열입니다. 이 세 가지 값은 &lt;code&gt;pg_get_object_address&lt;/code&gt; 에 전달되어 객체의 내부 주소를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93e21616abd3aa30176d4d8ef83cd97664795866" translate="yes" xml:space="preserve">
          <source>Returns a row containing enough information to uniquely identify the database object specified by catalog OID, object OID and sub-object ID. This information is intended to be machine-readable, and is never translated. &lt;em&gt;&lt;code&gt;type&lt;/code&gt;&lt;/em&gt; identifies the type of database object; &lt;em&gt;&lt;code&gt;schema&lt;/code&gt;&lt;/em&gt; is the schema name that the object belongs in, or &lt;code&gt;NULL&lt;/code&gt; for object types that do not belong to schemas; &lt;em&gt;&lt;code&gt;name&lt;/code&gt;&lt;/em&gt; is the name of the object, quoted if necessary, if the name (along with schema name, if pertinent) is sufficient to uniquely identify the object, otherwise &lt;code&gt;NULL&lt;/code&gt;; &lt;em&gt;&lt;code&gt;identity&lt;/code&gt;&lt;/em&gt; is the complete object identity, with the precise format depending on object type, and each name within the format being schema-qualified and quoted as necessary.</source>
          <target state="translated">카탈로그 OID, 개체 OID 및 하위 개체 ID로 지정된 데이터베이스 개체를 고유하게 식별하기에 충분한 정보가 포함 된 행을 반환합니다. 이 정보는 기계가 읽을 수 있도록 작성되었으며 번역되지 않습니다. &lt;em&gt; &lt;code&gt;type&lt;/code&gt; &lt;/em&gt; 은 데이터베이스 개체의 유형을 식별합니다. &lt;em&gt; &lt;code&gt;schema&lt;/code&gt; &lt;/em&gt; 는 객체가 속한 스키마 이름이거나 스키마에 속하지 않는 객체 유형의 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다. &lt;em&gt; &lt;code&gt;name&lt;/code&gt; &lt;/em&gt; 은 객체의 이름이며 필요한 경우 따옴표로 묶습니다. 이름 (해당되는 경우 스키마 이름과 함께)이 객체를 고유하게 식별하기에 충분한 경우, 그렇지 않으면 &lt;code&gt;NULL&lt;/code&gt; 입니다 . &lt;em&gt; &lt;code&gt;identity&lt;/code&gt; &lt;/em&gt; 객체 유형에 따른 정확한 형식과 스키마 규정 및 필요에 따라 인용되는 형식 내의 각 이름을 갖는 완전한 객체 ID입니다.</target>
        </trans-unit>
        <trans-unit id="670285a1038aa6033f06f9c2f2de29dee80665d3" translate="yes" xml:space="preserve">
          <source>Returns a set of records describing the SQL keywords recognized by the server. The &lt;em&gt;&lt;code&gt;word&lt;/code&gt;&lt;/em&gt; column contains the keyword. The &lt;em&gt;&lt;code&gt;catcode&lt;/code&gt;&lt;/em&gt; column contains a category code: &lt;code&gt;U&lt;/code&gt; for an unreserved keyword, &lt;code&gt;C&lt;/code&gt; for a keyword that can be a column name, &lt;code&gt;T&lt;/code&gt; for a keyword that can be a type or function name, or &lt;code&gt;R&lt;/code&gt; for a fully reserved keyword. The &lt;em&gt;&lt;code&gt;catdesc&lt;/code&gt;&lt;/em&gt; column contains a possibly-localized string describing the category.</source>
          <target state="translated">서버가 인식하는 SQL 키워드를 설명하는 레코드 세트를 리턴합니다. &lt;em&gt; &lt;code&gt;word&lt;/code&gt; &lt;/em&gt; 열은 키워드가 포함되어 있습니다. &lt;em&gt; &lt;code&gt;catcode&lt;/code&gt; 에&lt;/em&gt; 열이 카테고리 코드를 포함 : &lt;code&gt;U&lt;/code&gt; 예약되지 않은 키워드에 대해, &lt;code&gt;C&lt;/code&gt; 열 이름, 될 수있는 키워드에 대한 &lt;code&gt;T&lt;/code&gt; 유형 또는 함수 이름, 또는 될 수있는 키워드에 대한 &lt;code&gt;R&lt;/code&gt; 완전 예약 키워드. &lt;em&gt; &lt;code&gt;catdesc&lt;/code&gt; 의&lt;/em&gt; 열이 카테고리를 기술하는 가능성 지역화 문자열을 포함한다.</target>
        </trans-unit>
        <trans-unit id="296cd8c6998ac7394b024d95b390136a239b741d" translate="yes" xml:space="preserve">
          <source>Returns a string describing the PostgreSQL server's version. You can also get this information from &lt;a href=&quot;runtime-config-preset#GUC-SERVER-VERSION&quot;&gt;server_version&lt;/a&gt;, or for a machine-readable version use &lt;a href=&quot;runtime-config-preset#GUC-SERVER-VERSION-NUM&quot;&gt;server_version_num&lt;/a&gt;. Software developers should use &lt;code&gt;server_version_num&lt;/code&gt; (available since 8.2) or &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-status.html#LIBPQ-PQSERVERVERSION&quot;&gt;&lt;code&gt;PQserverVersion&lt;/code&gt;&lt;/a&gt; instead of parsing the text version.</source>
          <target state="translated">PostgreSQL 서버의 버전을 설명하는 문자열을 반환합니다. 이 정보는 &lt;a href=&quot;runtime-config-preset#GUC-SERVER-VERSION&quot;&gt;server_version&lt;/a&gt; 에서 가져 오거나 시스템에서 읽을 수있는 버전의 경우 &lt;a href=&quot;runtime-config-preset#GUC-SERVER-VERSION-NUM&quot;&gt;server_version_num을&lt;/a&gt; 사용할 수도 있습니다 . 소프트웨어 개발자는 텍스트 버전을 구문 분석하는 대신 &lt;code&gt;server_version_num&lt;/code&gt; (8.2 이후 사용 가능) 또는 &lt;a href=&quot;https://www.postgresql.org/docs/13/libpq-status.html#LIBPQ-PQSERVERVERSION&quot;&gt; &lt;code&gt;PQserverVersion&lt;/code&gt; 을 사용해야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c23b770cd3f6dda67abe733ea19f8c82d145524c" translate="yes" xml:space="preserve">
          <source>Returns a table that describes each type of token a parser specified by OID can recognize. See &lt;a href=&quot;textsearch-debugging#TEXTSEARCH-PARSER-TESTING&quot;&gt;Section 12.8.2&lt;/a&gt; for details.</source>
          <target state="translated">OID로 지정된 구문 분석기가 인식 할 수있는 각 토큰 유형을 설명하는 테이블을 리턴합니다. 자세한 내용은 &lt;a href=&quot;textsearch-debugging#TEXTSEARCH-PARSER-TESTING&quot;&gt;섹션 12.8.2&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="58e97c1f074a1cb6a70dfe06788a44c63cdb35e8" translate="yes" xml:space="preserve">
          <source>Returns a table that describes each type of token the named parser can recognize. See &lt;a href=&quot;textsearch-debugging#TEXTSEARCH-PARSER-TESTING&quot;&gt;Section 12.8.2&lt;/a&gt; for details.</source>
          <target state="translated">명명 된 파서가 인식 할 수있는 각 토큰 유형을 설명하는 테이블을 반환합니다. 자세한 내용은 &lt;a href=&quot;textsearch-debugging#TEXTSEARCH-PARSER-TESTING&quot;&gt;섹션 12.8.2&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f08733d82d5f0eb9f1c48d5ae27e2f5fc51063a0" translate="yes" xml:space="preserve">
          <source>Returns a text representation of the array's dimensions.</source>
          <target state="translated">배열 차원의 텍스트 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b79d359f7eafaec61e3972ab221fc2cfe13e240" translate="yes" xml:space="preserve">
          <source>Returns a textual description of a database object identified by catalog OID, object OID, and sub-object ID (such as a column number within a table; the sub-object ID is zero when referring to a whole object). This description is intended to be human-readable, and might be translated, depending on server configuration. This is especially useful to determine the identity of an object referenced in the &lt;code&gt;pg_depend&lt;/code&gt; catalog.</source>
          <target state="translated">카탈로그 OID, 개체 OID 및 하위 개체 ID (예 : 테이블 내의 열 번호, 전체 개체를 참조 할 때 하위 개체 ID는 0 임)로 식별되는 데이터베이스 개체의 텍스트 설명을 반환합니다. 이 설명은 사람이 읽을 수 있도록 작성되었으며 서버 구성에 따라 번역 될 수 있습니다. 이것은 &lt;code&gt;pg_depend&lt;/code&gt; 카탈로그 에서 참조되는 객체의 신원을 확인하는 데 특히 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="b8f02168cf846c33a8dd7dcdfca1542689a739b7" translate="yes" xml:space="preserve">
          <source>Returns a value indicating the &amp;ldquo;cost&amp;rdquo; of inserting the new entry into a particular branch of the tree. Items will be inserted down the path of least &lt;code&gt;penalty&lt;/code&gt; in the tree. Values returned by &lt;code&gt;penalty&lt;/code&gt; should be non-negative. If a negative value is returned, it will be treated as zero.</source>
          <target state="translated">트리의 특정 분기에 새 항목을 삽입하는 &quot;비용&quot;을 나타내는 값을 반환합니다. 트리에서 최소 &lt;code&gt;penalty&lt;/code&gt; 경로 아래에 항목이 삽입됩니다 . &lt;code&gt;penalty&lt;/code&gt; 로 반환 된 값은 음수가 아니어야합니다. 음수 값이 반환되면 0으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a38079832b711512e236337de21aed3e2d6d2987" translate="yes" xml:space="preserve">
          <source>Returns a vector that lists the same lexemes as the given vector, but lacks any position or weight information. The result is usually much smaller than an unstripped vector, but it is also less useful. Relevance ranking does not work as well on stripped vectors as unstripped ones. Also, the &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY) &lt;code&gt;tsquery&lt;/code&gt; operator will never match stripped input, since it cannot determine the distance between lexeme occurrences.</source>
          <target state="translated">주어진 벡터와 같은 텍스쳐를 나열하지만 위치 나 무게 정보가없는 벡터를 반환합니다. 결과는 일반적으로 고정되지 않은 벡터보다 훨씬 작지만 유용하지 않습니다. 벗겨지지 않은 벡터처럼 제거 된 벡터에서는 관련성 순위가 제대로 작동하지 않습니다. 또한 &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; ( &lt;code&gt;tsquery&lt;/code&gt; BY) tsquery 연산자는 lexeme 발생 사이의 거리를 판별 할 수 없으므로 제거 된 입력과 절대 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36f6090c359bd9ab41ad3656b2c2008d34919deb" translate="yes" xml:space="preserve">
          <source>Returns a version 4 (random) UUID.</source>
          <target state="translated">버전 4 (무작위) UUID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a0bc47771323c0eff9538aaa16424c350abd643" translate="yes" xml:space="preserve">
          <source>Returns a version 4 (random) UUID. (Obsolete, this function is now also included in core PostgreSQL.)</source>
          <target state="translated">버전 4 (무작위) UUID를 반환합니다. (더 이상 사용되지 않는이 함수는 이제 핵심 PostgreSQL에도 포함됩니다.)</target>
        </trans-unit>
        <trans-unit id="385a79b58799defb9194c9a6df4f08ed14475d33" translate="yes" xml:space="preserve">
          <source>Returns all JSON items returned by the JSON path for the specified JSON value, as a JSON array. The optional &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;silent&lt;/code&gt;&lt;/em&gt; arguments act the same as for &lt;code&gt;jsonb_path_exists&lt;/code&gt;.</source>
          <target state="translated">지정된 JSON 값에 대해 JSON 경로에서 반환 한 모든 JSON 항목을 JSON 배열로 반환합니다. 선택적 &lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;silent&lt;/code&gt; &lt;/em&gt; 인수는 &lt;code&gt;jsonb_path_exists&lt;/code&gt; 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="5bf980b362022aa3c61f78ea2a005c360352c37d" translate="yes" xml:space="preserve">
          <source>Returns all JSON items returned by the JSON path for the specified JSON value. The optional &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;silent&lt;/code&gt;&lt;/em&gt; arguments act the same as for &lt;code&gt;jsonb_path_exists&lt;/code&gt;.</source>
          <target state="translated">지정된 JSON 값에 대해 JSON 경로에서 반환 된 모든 JSON 항목을 반환합니다. 선택적 &lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;silent&lt;/code&gt; &lt;/em&gt; 인수는 &lt;code&gt;jsonb_path_exists&lt;/code&gt; 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b44f77ee019771c4a711b6af82f4e52438951d20" translate="yes" xml:space="preserve">
          <source>Returns all or part of a file. This function is identical to &lt;code&gt;pg_read_file&lt;/code&gt; except that it can read arbitrary binary data, returning the result as &lt;code&gt;bytea&lt;/code&gt; not &lt;code&gt;text&lt;/code&gt;; accordingly, no encoding checks are performed.</source>
          <target state="translated">파일의 전체 또는 일부를 반환합니다. 이 함수는 임의의 바이너리 데이터를 읽을 수 있다는 점을 제외 하면 &lt;code&gt;pg_read_file&lt;/code&gt; 과 동일하며 , 결과를 &lt;code&gt;text&lt;/code&gt; 아닌 &lt;code&gt;bytea&lt;/code&gt; 로 반환합니다 . 따라서 인코딩 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d203094fd95d1197cb000e54f70a798d47a15a1" translate="yes" xml:space="preserve">
          <source>Returns all or part of a text file, starting at the given byte &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt;, returning at most &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; bytes (less if the end of file is reached first). If &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; is negative, it is relative to the end of the file. If &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;length&lt;/code&gt;&lt;/em&gt; are omitted, the entire file is returned. The bytes read from the file are interpreted as a string in the database's encoding; an error is thrown if they are not valid in that encoding.</source>
          <target state="translated">주어진 바이트 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 에서 시작 하여 최대 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 바이트 (파일의 끝에 도달하면 더 적음) 까지 반환 하는 텍스트 파일의 전체 또는 일부를 반환합니다 . 경우 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 부정적이고, 파일의 끝 부분에 상대적입니다. 경우 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;length&lt;/code&gt; &lt;/em&gt; 생략, 전체 파일이 반환됩니다. 파일에서 읽은 바이트는 데이터베이스 인코딩의 문자열로 해석됩니다. 해당 인코딩에서 유효하지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1acea8098e7cd5d49d5a2f08983b1c8dea6d032f" translate="yes" xml:space="preserve">
          <source>Returns all values of the input enum type in an ordered array</source>
          <target state="translated">입력 된 열거 형의 모든 값을 정렬 된 배열로 반환</target>
        </trans-unit>
        <trans-unit id="c33ddf7f5456051ba675fc454b4aa32640df3e58" translate="yes" xml:space="preserve">
          <source>Returns all values of the input enum type in an ordered array.</source>
          <target state="translated">입력 열거 형의 모든 값을 정렬 된 배열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c6bc9c7f371fbc80a6c47bdfb6e5dfa12c278b82" translate="yes" xml:space="preserve">
          <source>Returns an array filled with copies of the given value, having dimensions of the lengths specified by the second argument. The optional third argument supplies lower-bound values for each dimension (which default to all &lt;code id=&quot;1&quot;&gt;1&lt;/code&gt;).</source>
          <target state="translated">두 번째 인수로 지정된 길이의 차원을 갖는 주어진 값의 복사본으로 채워진 배열을 반환합니다. 선택적 세 번째 인수는 각 차원에 대해 하한 값을 제공합니다 (기본값은 모두 &lt;code id=&quot;1&quot;&gt;1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9fc478b8335b03662cc293cce9f3cdeecd2c897e" translate="yes" xml:space="preserve">
          <source>Returns an array of all the trigrams in the given string. (In practice this is seldom useful except for debugging.)</source>
          <target state="translated">주어진 문자열에있는 모든 트라이 그램의 배열을 반환합니다. 실제로는 디버깅을 제외하고는 거의 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19e2b4ae0f6d81aa9e8ad49388f1ee4fa4d2c3a3" translate="yes" xml:space="preserve">
          <source>Returns an array of replacement lexemes if the input token is known to the dictionary, or an empty array if the token is known to the dictionary but it is a stop word, or NULL if it is not a known word. See &lt;a href=&quot;textsearch-debugging#TEXTSEARCH-DICTIONARY-TESTING&quot;&gt;Section 12.8.3&lt;/a&gt; for details.</source>
          <target state="translated">입력 토큰이 사전에 알려진 경우 대체 용어 배열을 반환하고, 토큰이 사전에 알려져 있지만 중지 단어 인 경우 빈 배열을, 알려진 단어가 아닌 경우 NULL을 반환합니다. 자세한 내용은 &lt;a href=&quot;textsearch-debugging#TEXTSEARCH-DICTIONARY-TESTING&quot;&gt;섹션 12.8.3&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61b00fb872594d11fc14bdcb6fd1f33be30d12f3" translate="yes" xml:space="preserve">
          <source>Returns an array of the names of all schemas presently in the effective search path, in their priority order. (Items in the current &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; setting that do not correspond to existing, searchable schemas are omitted.) If the Boolean argument is &lt;code&gt;true&lt;/code&gt;, then implicitly-searched system schemas such as &lt;code&gt;pg_catalog&lt;/code&gt; are included in the result.</source>
          <target state="translated">현재 유효 검색 경로에있는 모든 스키마 이름의 배열을 우선 순위에 따라 반환합니다. ( 기존의 검색 가능한 스키마와 일치하지 않는 현재 &lt;a href=&quot;runtime-config-client#GUC-SEARCH-PATH&quot;&gt;search_path&lt;/a&gt; 설정의 항목 은 생략됩니다.) Boolean 인수가 &lt;code&gt;true&lt;/code&gt; 이면 &lt;code&gt;pg_catalog&lt;/code&gt; 와 같이 암시 적으로 검색된 시스템 스키마 가 결과에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6417fbc3f48cfd4a2dae5b2791934d64998f5590" translate="yes" xml:space="preserve">
          <source>Returns an array of the process ID(s) of the sessions that are blocking the server process with the specified process ID from acquiring a lock, or an empty array if there is no such server process or it is not blocked.</source>
          <target state="translated">지정된 프로세스 ID를 가진 서버 프로세스가 잠금을 획득하지 못하도록 차단하는 세션의 프로세스 ID 배열을 반환하거나, 그러한 서버 프로세스가 없거나 차단되지 않은 경우 빈 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4cb47a5d2b7a6132dad7b15d07ca4b4411058625" translate="yes" xml:space="preserve">
          <source>Returns an array of the process ID(s) of the sessions that are blocking the server process with the specified process ID from acquiring a safe snapshot, or an empty array if there is no such server process or it is not blocked.</source>
          <target state="translated">지정된 프로세스 ID를 가진 서버 프로세스가 안전한 스냅 샷을 획득하지 못하도록 차단하는 세션의 프로세스 ID 배열을 반환하거나, 그러한 서버 프로세스가 없거나 차단되지 않은 경우 빈 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="00b57b7323451132324170a8c1773c740df9783e" translate="yes" xml:space="preserve">
          <source>Returns an array of the subscripts of all occurrences of the second argument in the array given as first argument. The array must be one-dimensional. Comparisons are done using &lt;code id=&quot;is32not32distinct32from&quot;&gt;IS NOT DISTINCT FROM&lt;/code&gt; semantics, so it is possible to search for &lt;code&gt;NULL&lt;/code&gt;. &lt;code&gt;NULL&lt;/code&gt; is returned only if the array is &lt;code&gt;NULL&lt;/code&gt;; if the value is not found in the array, an empty array is returned.</source>
          <target state="translated">첫 번째 인수로 지정된 배열에서 두 번째 인수의 모든 발생에 대한 첨자의 배열을 반환합니다. 배열은 1 차원이어야합니다. 비교는 &lt;code id=&quot;is32not32distinct32from&quot;&gt;IS NOT DISTINCT FROM&lt;/code&gt; 의미론을 사용하여 수행 되므로 &lt;code&gt;NULL&lt;/code&gt; 검색이 가능 합니다 . &lt;code&gt;NULL&lt;/code&gt; 은 배열이 &lt;code&gt;NULL&lt;/code&gt; 인 경우에만 반환됩니다 . 배열에 값이 없으면 빈 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f5f9b17433125e984026637fa8f86d8c919b8d19" translate="yes" xml:space="preserve">
          <source>Returns an integer ranging from 1 to the argument value, dividing the partition as equally as possible.</source>
          <target state="translated">1에서 인수 값까지의 정수를 반환하여 파티션을 가능한 균등하게 나눕니다.</target>
        </trans-unit>
        <trans-unit id="dffbcb2b77db90d1f53f4173ac97307dfac17a79" translate="yes" xml:space="preserve">
          <source>Returns captured substring(s) resulting from matching a POSIX regular expression to the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;; see &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;.</source>
          <target state="translated">POSIX 정규식을 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 과 일치시켜 캡처 된 부분 문자열을 반환 &lt;em&gt;합니다&lt;/em&gt; . &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;9.7.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c571a5b895526391d86ae7ee44ca0b0f3ca936bb" translate="yes" xml:space="preserve">
          <source>Returns captured substring(s) resulting from the first match of a POSIX regular expression to the &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;; see &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;Section 9.7.3&lt;/a&gt;.</source>
          <target state="translated">문자열에 대한 POSIX 정규식의 첫 번째 일치 결과로 캡처 된 하위 문자열을 반환 &lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; . &lt;a href=&quot;functions-matching#FUNCTIONS-POSIX-REGEXP&quot;&gt;9.7.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="478f0a9dae63088d59bf6b73f1fa784f74c9ccaf" translate="yes" xml:space="preserve">
          <source>Returns changes in the slot &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;, starting from the point at which since changes have been consumed last. If &lt;em&gt;&lt;code&gt;upto_lsn&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;upto_nchanges&lt;/code&gt;&lt;/em&gt; are NULL, logical decoding will continue until end of WAL. If &lt;em&gt;&lt;code&gt;upto_lsn&lt;/code&gt;&lt;/em&gt; is non-NULL, decoding will include only those transactions which commit prior to the specified LSN. If &lt;em&gt;&lt;code&gt;upto_nchanges&lt;/code&gt;&lt;/em&gt; is non-NULL, decoding will stop when the number of rows produced by decoding exceeds the specified value. Note, however, that the actual number of rows returned may be larger, since this limit is only checked after adding the rows produced when decoding each new transaction commit.</source>
          <target state="translated">변경 사항이 마지막으로 소비 된 이후부터 &lt;em&gt; &lt;code&gt;slot_name&lt;/code&gt; &lt;/em&gt; 슬롯의 변경 사항을 리턴 합니다. 경우 &lt;em&gt; &lt;code&gt;upto_lsn&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;upto_nchanges&lt;/code&gt; 은&lt;/em&gt; NULL이며, 논리적 디코딩은 WAL의 말까지 계속됩니다. &lt;em&gt; &lt;code&gt;upto_lsn&lt;/code&gt; &lt;/em&gt; 이 NULL이 아닌 경우 디코딩에는 지정된 LSN보다 먼저 커밋하는 트랜잭션 만 포함됩니다. &lt;em&gt; &lt;code&gt;upto_nchanges&lt;/code&gt; &lt;/em&gt; 가 NULL이 아닌 경우 디코딩으로 생성 된 행 수가 지정된 값을 초과하면 디코딩이 중지됩니다. 그러나 반환되는 실제 행 수는 더 클 수 있습니다.이 제한은 각 새 트랜잭션 커밋을 디코딩 할 때 생성 된 행을 추가 한 후에 만 ​​확인되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f4a6bf80af6ad178d880ada27f4281eb6525a871" translate="yes" xml:space="preserve">
          <source>Returns changes in the slot &lt;em&gt;&lt;code&gt;slot_name&lt;/code&gt;&lt;/em&gt;, starting from the point from which changes have been consumed last. If &lt;em&gt;&lt;code&gt;upto_lsn&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;upto_nchanges&lt;/code&gt;&lt;/em&gt; are NULL, logical decoding will continue until end of WAL. If &lt;em&gt;&lt;code&gt;upto_lsn&lt;/code&gt;&lt;/em&gt; is non-NULL, decoding will include only those transactions which commit prior to the specified LSN. If &lt;em&gt;&lt;code&gt;upto_nchanges&lt;/code&gt;&lt;/em&gt; is non-NULL, decoding will stop when the number of rows produced by decoding exceeds the specified value. Note, however, that the actual number of rows returned may be larger, since this limit is only checked after adding the rows produced when decoding each new transaction commit.</source>
          <target state="translated">변경 사항이 마지막으로 소비 된 지점부터 시작하여 &lt;em&gt; &lt;code&gt;slot_name&lt;/code&gt; &lt;/em&gt; 슬롯의 변경 사항을 반환 합니다. 경우 &lt;em&gt; &lt;code&gt;upto_lsn&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;upto_nchanges&lt;/code&gt; 은&lt;/em&gt; NULL이며, 논리적 디코딩은 WAL의 말까지 계속됩니다. &lt;em&gt; &lt;code&gt;upto_lsn&lt;/code&gt; &lt;/em&gt; 이 NULL이 아닌 경우 디코딩은 지정된 LSN 이전에 커밋 된 트랜잭션 만 포함합니다. &lt;em&gt; &lt;code&gt;upto_nchanges&lt;/code&gt; &lt;/em&gt; 가 NULL이 아닌 경우 디코딩으로 생성 된 행 수가 지정된 값을 초과하면 디코딩이 중지됩니다. 그러나 반환되는 실제 행 수는 더 클 수 있습니다.이 제한은 각각의 새 트랜잭션 커밋을 디코딩 할 때 생성 된 행을 추가 한 후에 만 ​​확인되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c65132018d23cc74be36a0ddfb3c1b8bf4955c99" translate="yes" xml:space="preserve">
          <source>Returns current client encoding name.</source>
          <target state="translated">현재 클라이언트 인코딩 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="25ebac473a4d1554db8e6d7395be0a43ca75eb39" translate="yes" xml:space="preserve">
          <source>Returns first &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; characters in the string, or when &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; is negative, returns all but last |&lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt;| characters.</source>
          <target state="translated">문자열에서 처음 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; 개의&lt;/em&gt; 문자를 반환 하거나 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; 이 음수이면 마지막 | &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; | 문자.</target>
        </trans-unit>
        <trans-unit id="13d877b5396e5525c40b5c2f3dee3ab1c6c14aec" translate="yes" xml:space="preserve">
          <source>Returns first array entry that is a descendant of &lt;code&gt;ltree&lt;/code&gt;, or &lt;code&gt;NULL&lt;/code&gt; if none.</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 의 후손 인 첫 번째 배열 항목을 반환 하거나 없는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2fb9c3313fb7a0dc634a06488275d8803c39ce57" translate="yes" xml:space="preserve">
          <source>Returns first array entry that is an ancestor of &lt;code&gt;ltree&lt;/code&gt;, or &lt;code&gt;NULL&lt;/code&gt; if none.</source>
          <target state="translated">&lt;code&gt;ltree&lt;/code&gt; 의 조상 인 첫 번째 배열 항목을 반환 하거나 없는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="700160fea52e589541d868034f446b43d17a34ce" translate="yes" xml:space="preserve">
          <source>Returns first array entry that matches &lt;code&gt;lquery&lt;/code&gt;, or &lt;code&gt;NULL&lt;/code&gt; if none.</source>
          <target state="translated">&lt;code&gt;lquery&lt;/code&gt; 와 일치하는 첫 번째 배열 항목을 반환 하거나 없는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b92ae8c9024b44611377e4503a36a2d15c0f6b2" translate="yes" xml:space="preserve">
          <source>Returns first array entry that matches &lt;code&gt;ltxtquery&lt;/code&gt;, or &lt;code&gt;NULL&lt;/code&gt; if none.</source>
          <target state="translated">&lt;code&gt;ltxtquery&lt;/code&gt; 와 일치하는 첫 번째 배열 항목을 반환 하거나 없는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ab67f5bc64c0c2de97517f1bd75474ecc1dac94" translate="yes" xml:space="preserve">
          <source>Returns index of the first array element matching &lt;em&gt;&lt;code&gt;item&lt;/code&gt;&lt;/em&gt;, or 0 if no match.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;item&lt;/code&gt; &lt;/em&gt; 과 일치하는 첫 번째 배열 요소의 인덱스를 반환 하거나 일치하지 않는 경우 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="33666d96553b61cdf914acbedc262e9e77370048" translate="yes" xml:space="preserve">
          <source>Returns index of the first array element matching the right argument, or 0 if no match. (Same as &lt;code&gt;idx&lt;/code&gt; function.)</source>
          <target state="translated">오른쪽 인수와 일치하는 첫 번째 배열 요소의 인덱스를 반환하거나 일치하지 않는 경우 0을 반환합니다. ( &lt;code&gt;idx&lt;/code&gt; 함수 와 동일 합니다.)</target>
        </trans-unit>
        <trans-unit id="c5ae839d644d5c6015df41502af5f0c10aab1d29" translate="yes" xml:space="preserve">
          <source>Returns information about cluster initialization state, as shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-INIT&quot;&gt;Table 9.81&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-INIT&quot;&gt;Table 9.81에&lt;/a&gt; 표시된대로 클러스터 초기화 상태에 대한 정보를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a27e8a277fbb21ba600cced17405fd8d485d4498" translate="yes" xml:space="preserve">
          <source>Returns information about cluster initialization state.</source>
          <target state="translated">클러스터 초기화 상태에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55076d9c163df89ba20793e4a1847ea58dfdc81a" translate="yes" xml:space="preserve">
          <source>Returns information about current checkpoint state, as shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-CHECKPOINT&quot;&gt;Table 9.79&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-CHECKPOINT&quot;&gt;Table 9.79에&lt;/a&gt; 표시된대로 현재 체크 포인트 상태에 대한 정보를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="763f519436bbc94f33f5cc934beac9a0056e24cd" translate="yes" xml:space="preserve">
          <source>Returns information about current checkpoint state.</source>
          <target state="translated">현재 검사 점 상태에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="87e5dce1d08a12bbc3bc0dda751a4a2ecdbfe784" translate="yes" xml:space="preserve">
          <source>Returns information about current control file state, as shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-SYSTEM&quot;&gt;Table 9.80&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-SYSTEM&quot;&gt;Table 9.80에&lt;/a&gt; 표시된대로 현재 제어 파일 상태에 대한 정보를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fe00dcb79370817badaa5645198d0523960140b5" translate="yes" xml:space="preserve">
          <source>Returns information about current control file state.</source>
          <target state="translated">현재 제어 파일 상태에 대한 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ba58f72da003c2b545c29152e157be6f28ebd3b9" translate="yes" xml:space="preserve">
          <source>Returns information about recovery state, as shown in &lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-RECOVERY&quot;&gt;Table 9.82&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions-info#FUNCTIONS-PG-CONTROL-RECOVERY&quot;&gt;Table 9.82에&lt;/a&gt; 표시된대로 복구 상태에 대한 정보를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="94374ce523a7946cfd2c763e8c1f45c8b8526166" translate="yes" xml:space="preserve">
          <source>Returns information about recovery state.</source>
          <target state="translated">복구 상태에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e187b05e2932593c6282c4f72c780b597557fc12" translate="yes" xml:space="preserve">
          <source>Returns internal information about the indexed columns' summary data. The return value must point to a palloc'd &lt;code&gt;BrinOpcInfo&lt;/code&gt;, which has this definition:</source>
          <target state="translated">인덱싱 된 열의 요약 데이터에 대한 내부 정보를 반환합니다. 반환 값 은 다음과 같은 정의 를 가진 palloc'd &lt;code&gt;BrinOpcInfo&lt;/code&gt; 를 가리켜 야 합니다.</target>
        </trans-unit>
        <trans-unit id="1d4f29ad4e573f8aab48dac3259a0784f9446730" translate="yes" xml:space="preserve">
          <source>Returns last &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; characters in the string, or when &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt; is negative, returns all but first |&lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt;| characters.</source>
          <target state="translated">문자열의 마지막 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; 개&lt;/em&gt; 문자를 반환 하거나 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; 이 음수이면 처음 | &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; | 문자.</target>
        </trans-unit>
        <trans-unit id="195796602666f879c432081663335355dcd305cf" translate="yes" xml:space="preserve">
          <source>Returns number of bits in the binary string (8 times the &lt;code id=&quot;octet_length&quot;&gt;octet_length&lt;/code&gt;).</source>
          <target state="translated">이진 문자열의 비트 수를 반환합니다 ( &lt;code id=&quot;octet_length&quot;&gt;octet_length&lt;/code&gt; 의 8 배 ).</target>
        </trans-unit>
        <trans-unit id="ae85184033ac5ab28bdafcf09623d6bc6a4347e8" translate="yes" xml:space="preserve">
          <source>Returns number of bits in the bit string.</source>
          <target state="translated">비트 문자열의 비트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3ea9580aefae2c19d15bbc631a76f116ca9cad0c" translate="yes" xml:space="preserve">
          <source>Returns number of bits in the string (8 times the &lt;code&gt;octet_length&lt;/code&gt;).</source>
          <target state="translated">문자열의 비트 수를 반환합니다 ( &lt;code&gt;octet_length&lt;/code&gt; 의 8 배 ).</target>
        </trans-unit>
        <trans-unit id="805b3eecfda99cff91548d76a03853412820e0a6" translate="yes" xml:space="preserve">
          <source>Returns number of bytes in the binary string.</source>
          <target state="translated">이진 문자열의 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="29948cfe9465d2e29490d88c19b195a43f82c1ef" translate="yes" xml:space="preserve">
          <source>Returns number of bytes in the bit string.</source>
          <target state="translated">비트 문자열의 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4f538d7ad4d61093f0d881909c36fcfd43ce88d" translate="yes" xml:space="preserve">
          <source>Returns number of bytes in the string.</source>
          <target state="translated">문자열의 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7bf7f6324c889b704e1b1b34ea91acb75a28f8cb" translate="yes" xml:space="preserve">
          <source>Returns number of bytes in the string. Since this version of the function accepts type &lt;code&gt;character&lt;/code&gt; directly, it will not strip trailing spaces.</source>
          <target state="translated">문자열의 바이트 수를 반환합니다. 이 버전의 함수는 유형 &lt;code&gt;character&lt;/code&gt; 직접 받아들이 기 때문에 후행 공백을 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca2dd84826cff8fc5704db2edcf783c0c1e5936d" translate="yes" xml:space="preserve">
          <source>Returns number of characters in the string.</source>
          <target state="translated">문자열의 문자 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80374aeb7928f070343716048923f0e5505b9090" translate="yes" xml:space="preserve">
          <source>Returns number of labels in path.</source>
          <target state="translated">경로의 레이블 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d1c94d9e558a7ebcd684e130ce7db15c201f2e6" translate="yes" xml:space="preserve">
          <source>Returns position of first occurrence of &lt;em&gt;&lt;code&gt;b&lt;/code&gt;&lt;/em&gt; in &lt;em&gt;&lt;code&gt;a&lt;/code&gt;&lt;/em&gt;, or -1 if not found.</source>
          <target state="translated">처음 나타나는 반환 위치 &lt;em&gt; &lt;code&gt;b&lt;/code&gt; &lt;/em&gt; 의 &lt;em&gt; &lt;code&gt;a&lt;/code&gt; &lt;/em&gt; , 또는 발견되지 않으면 -1.</target>
        </trans-unit>
        <trans-unit id="974516afbeb3c54c81be32d00f0350b0a8544af3" translate="yes" xml:space="preserve">
          <source>Returns position of first occurrence of &lt;em&gt;&lt;code&gt;b&lt;/code&gt;&lt;/em&gt; in &lt;em&gt;&lt;code&gt;a&lt;/code&gt;&lt;/em&gt;, or -1 if not found. The search starts at position &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt;; negative &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; means start &lt;em&gt;&lt;code&gt;-offset&lt;/code&gt;&lt;/em&gt; labels from the end of the path.</source>
          <target state="translated">처음 나타나는 반환 위치 &lt;em&gt; &lt;code&gt;b&lt;/code&gt; &lt;/em&gt; 의 &lt;em&gt; &lt;code&gt;a&lt;/code&gt; &lt;/em&gt; , 또는 발견되지 않으면 -1. 검색은 위치 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 에서 시작됩니다 . 음수 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 은 경로 끝에서 시작 &lt;em&gt; &lt;code&gt;-offset&lt;/code&gt; &lt;/em&gt; 레이블을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="3d4a226d93129508393d26718b33747d3a312c25" translate="yes" xml:space="preserve">
          <source>Returns serial number of current client certificate. The combination of certificate serial number and certificate issuer is guaranteed to uniquely identify a certificate (but not its owner &amp;mdash; the owner ought to regularly change their keys, and get new certificates from the issuer).</source>
          <target state="translated">현재 클라이언트 인증서의 일련 번호를 반환합니다. 인증서 일련 번호와 인증서 발급자의 조합으로 인증서를 고유하게 식별 할 수 있습니다 (소유자는 아님). 정기적으로 키를 변경하고 발급자로부터 새 인증서를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="b8bb9df3a9fe7c7254cc51f8ca1bfa607e2b8cf2" translate="yes" xml:space="preserve">
          <source>Returns set of keys in the outermost JSON object.</source>
          <target state="translated">가장 바깥 쪽 JSON 객체의 키 집합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6149a0c35cf199410e63b02c919df4f72b2a252c" translate="yes" xml:space="preserve">
          <source>Returns set of nodes (branches) to follow during tree search.</source>
          <target state="translated">트리 검색 중에 따라야하는 노드 세트 (분기)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d49bf69e8cadbd5d1a46d43d735bf7be8cba5976" translate="yes" xml:space="preserve">
          <source>Returns starting index of specified &lt;em&gt;&lt;code&gt;substring&lt;/code&gt;&lt;/em&gt; within &lt;em&gt;&lt;code&gt;bits&lt;/code&gt;&lt;/em&gt;, or zero if it's not present.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;bits&lt;/code&gt; &lt;/em&gt; 내에서 지정된 &lt;em&gt; &lt;code&gt;substring&lt;/code&gt; &lt;/em&gt; 의 시작 인덱스를 반환 하거나없는 경우 0을 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5d7b5253035ad1b8a55065e7c7fb22bea0542e4" translate="yes" xml:space="preserve">
          <source>Returns starting index of specified &lt;em&gt;&lt;code&gt;substring&lt;/code&gt;&lt;/em&gt; within &lt;em&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/em&gt;, or zero if it's not present.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/em&gt; 내에서 지정된 &lt;em&gt; &lt;code&gt;substring&lt;/code&gt; &lt;/em&gt; 의 시작 인덱스를 반환 하거나없는 경우 0을 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="837e889f4180b7f1c88de2bc5641d2f40f660695" translate="yes" xml:space="preserve">
          <source>Returns starting index of specified &lt;em&gt;&lt;code&gt;substring&lt;/code&gt;&lt;/em&gt; within &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;, or zero if it's not present.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 내에 지정된 &lt;em&gt; &lt;code&gt;substring&lt;/code&gt; &lt;/em&gt; 의 시작 인덱스를 반환 하거나없는 경우 0을 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ffc50276a0d77092b8778e4d243540d105d5cc42" translate="yes" xml:space="preserve">
          <source>Returns starting index of specified &lt;em&gt;&lt;code&gt;substring&lt;/code&gt;&lt;/em&gt; within &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt;, or zero if it's not present. (Same as &lt;code&gt;position(&lt;em&gt;substring&lt;/em&gt; in &lt;em&gt;string&lt;/em&gt;)&lt;/code&gt;, but note the reversed argument order.)</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 내에 지정된 &lt;em&gt; &lt;code&gt;substring&lt;/code&gt; &lt;/em&gt; 의 시작 인덱스를 반환 하거나없는 경우 0을 반환합니다. ( &lt;code&gt;position(&lt;em&gt;substring&lt;/em&gt; in &lt;em&gt;string&lt;/em&gt;)&lt;/code&gt; &lt;em&gt;substring&lt;/em&gt; in &lt;em&gt;string&lt;/em&gt; ) 과 동일 하지만 반대의 인수 순서에 유의하십시오.)&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d0597704e8ca0a8ebc65a287230875a8a4665e5" translate="yes" xml:space="preserve">
          <source>Returns static information about the index implementation, including the data type OIDs of the prefix and node label data types.</source>
          <target state="translated">접두사 및 노드 레이블 데이터 형식의 데이터 형식 OID를 포함하여 인덱스 구현에 대한 정적 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="408bf35de10f75e3a7015363b7ebc6d5ac929063" translate="yes" xml:space="preserve">
          <source>Returns subpath of &lt;code&gt;ltree&lt;/code&gt; from position &lt;em&gt;&lt;code&gt;start&lt;/code&gt;&lt;/em&gt; to position &lt;em&gt;&lt;code&gt;end&lt;/code&gt;&lt;/em&gt;-1 (counting from 0).</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;start&lt;/code&gt; &lt;/em&gt; 위치에서 &lt;em&gt; &lt;code&gt;end&lt;/code&gt; &lt;/em&gt; 위치 -1 까지 &lt;code&gt;ltree&lt;/code&gt; 의 하위 경로를 반환합니다 (0부터 계산).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f7a8cf42b1a6789544c100bea17d902c175faf14" translate="yes" xml:space="preserve">
          <source>Returns subpath of &lt;code&gt;ltree&lt;/code&gt; starting at position &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt;, extending to end of path. If &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; is negative, subpath starts that far from the end of the path.</source>
          <target state="translated">위치 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 에서 시작하여 경로 끝까지 확장되는 &lt;code&gt;ltree&lt;/code&gt; 의 하위 경로를 반환 합니다. 경우 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 부정, 서브 패스의 시작입니다까지 경로의 끝에서.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7007fb31c291bbf4d2b8e4627e082327c7e29d41" translate="yes" xml:space="preserve">
          <source>Returns subpath of &lt;code&gt;ltree&lt;/code&gt; starting at position &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt;, with length &lt;em&gt;&lt;code&gt;len&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;offset&lt;/code&gt;&lt;/em&gt; is negative, subpath starts that far from the end of the path. If &lt;em&gt;&lt;code&gt;len&lt;/code&gt;&lt;/em&gt; is negative, leaves that many labels off the end of the path.</source>
          <target state="translated">길이가 &lt;em&gt; &lt;code&gt;len&lt;/code&gt; 인&lt;/em&gt;&lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 위치에서 시작 하는 &lt;code&gt;ltree&lt;/code&gt; 의 하위 경로를 반환 합니다. 경우 &lt;em&gt; &lt;code&gt;offset&lt;/code&gt; &lt;/em&gt; 부정, 서브 패스의 시작입니다까지 경로의 끝에서. 경우 &lt;em&gt; &lt;code&gt;len&lt;/code&gt; &lt;/em&gt; 부정적, 잎이며 많은 레이블 경로의 끝에 끕니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8fa361007b675d09ec5c4535e3385c82bd5b607c" translate="yes" xml:space="preserve">
          <source>Returns the &amp;ldquo;distance&amp;rdquo; between the arguments, that is one minus the &lt;code&gt;similarity()&lt;/code&gt; value.</source>
          <target state="translated">인수 사이의 &quot;거리&quot;를 반환합니다. 즉, 1에서 &lt;code&gt;similarity()&lt;/code&gt; 값을 뺀 값입니다.</target>
        </trans-unit>
        <trans-unit id="ac7ff362080d4db6c458a6342843ca4fb83bbcc1" translate="yes" xml:space="preserve">
          <source>Returns the &amp;ldquo;distance&amp;rdquo; between the arguments, that is one minus the &lt;code&gt;strict_word_similarity()&lt;/code&gt; value.</source>
          <target state="translated">인수 사이의 &quot;거리&quot;, 즉 &lt;code&gt;strict_word_similarity()&lt;/code&gt; 값을 뺀 값을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2cf1cbb6e41d5400a8f5b7933861dd56b69a3bdf" translate="yes" xml:space="preserve">
          <source>Returns the &amp;ldquo;distance&amp;rdquo; between the arguments, that is one minus the &lt;code&gt;word_similarity()&lt;/code&gt; value.</source>
          <target state="translated">인수 사이의 &quot;거리&quot;, 즉 &lt;code&gt;word_similarity()&lt;/code&gt; 값을 뺀 값을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d99d82ca1f3d3ad16bdafb62930e1363a80463b6" translate="yes" xml:space="preserve">
          <source>Returns the &amp;ldquo;filenode&amp;rdquo; number currently assigned to the specified relation. The filenode is the base component of the file name(s) used for the relation (see &lt;a href=&quot;storage-file-layout&quot;&gt;Section 68.1&lt;/a&gt; for more information). For most relations the result is the same as &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;relfilenode&lt;/code&gt;, but for certain system catalogs &lt;code&gt;relfilenode&lt;/code&gt; is zero and this function must be used to get the correct value. The function returns NULL if passed a relation that does not have storage, such as a view.</source>
          <target state="translated">지정된 관계에 현재 할당 된 &quot;filenode&quot;번호를 반환합니다. 파일 노드는 관계에 사용되는 파일 이름의 기본 구성 요소입니다 ( 자세한 내용 은 &lt;a href=&quot;storage-file-layout&quot;&gt;섹션 68.1&lt;/a&gt; 참조 ). 대부분의 관계에서 결과는 &lt;code&gt;pg_class&lt;/code&gt; 와 동일합니다 . &lt;code&gt;relfilenode&lt;/code&gt; 이지만 특정 시스템 카탈로그의 경우 &lt;code&gt;relfilenode&lt;/code&gt; 는 0 이며이 함수를 사용하여 올바른 값을 가져와야 합니다. 뷰와 같이 스토리지가없는 관계가 전달되면 함수는 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37aa8958d75a1582df6d76272819aa7798092ef7" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;aclitem&lt;/code&gt; array as a set of rows. If the grantee is the pseudo-role PUBLIC, it is represented by zero in the &lt;em&gt;&lt;code&gt;grantee&lt;/code&gt;&lt;/em&gt; column. Each granted privilege is represented as &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, etc. Note that each privilege is broken out as a separate row, so only one keyword appears in the &lt;em&gt;&lt;code&gt;privilege_type&lt;/code&gt;&lt;/em&gt; column.</source>
          <target state="translated">&lt;code&gt;aclitem&lt;/code&gt; 배열을 행 집합으로 반환합니다 . 피부 여자가 의사 역할 PUBLIC이면 &lt;em&gt; &lt;code&gt;grantee&lt;/code&gt; &lt;/em&gt; 열 에서 0으로 표시 됩니다. 부여 된 각 권한은 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; 등 으로 표시됩니다 . 각 권한은 별도의 행으로 구분되므로 &lt;em&gt; &lt;code&gt;privilege_type&lt;/code&gt; &lt;/em&gt; 열에 는 하나의 키워드 만 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="281d34aa9da9a13493722f7652be5e6c72cabbc9" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;n&lt;/code&gt;-th coordinate value for the lower left corner of the cube.</source>
          <target state="translated">큐브의 왼쪽 아래 모서리에 대한 &lt;code&gt;n&lt;/code&gt; 번째 좌표 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b9dcaf0d09d07ac76586a9bbcb0fb2a275f2a7c3" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;n&lt;/code&gt;-th coordinate value for the upper right corner of the cube.</source>
          <target state="translated">큐브의 오른쪽 위 모서리에 대한 &lt;code&gt;n&lt;/code&gt; 번째 좌표 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="24efb0040251234218760c6d94b1c0fbe816ffa0" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;xmax&lt;/code&gt; of a snapshot.</source>
          <target state="translated">스냅 샷 의 &lt;code&gt;xmax&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6ad561429eff4ff27cd023ad2644f9e05c65dcdf" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;xmin&lt;/code&gt; of a snapshot.</source>
          <target state="translated">스냅 샷 의 &lt;code&gt;xmin&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b5c802f78d9f766d96023430726d9d8fed847f5c" translate="yes" xml:space="preserve">
          <source>Returns the &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt;-th coordinate value for the lower left corner of the cube.</source>
          <target state="translated">큐브의 왼쪽 아래 모서리에 대한 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; 번째 좌표 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e1ad7424ba9198bdb22623a561a0e5817a6cad06" translate="yes" xml:space="preserve">
          <source>Returns the &lt;em&gt;&lt;code&gt;n&lt;/code&gt;&lt;/em&gt;-th coordinate value for the upper right corner of the cube.</source>
          <target state="translated">큐브의 오른쪽 위 모서리에 대한 &lt;em&gt; &lt;code&gt;n&lt;/code&gt; &lt;/em&gt; 번째 좌표 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="932fcaf01eb90a9b4451fe67cc8df0d84322e352" translate="yes" xml:space="preserve">
          <source>Returns the AND-combination of the two given queries.</source>
          <target state="translated">주어진 두 쿼리의 AND 조합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="478cbe64d5a7b4ba0e9516857e9c9b79b6177331" translate="yes" xml:space="preserve">
          <source>Returns the IP address as text, ignoring the netmask.</source>
          <target state="translated">넷 마스크를 무시하고 IP 주소를 텍스트로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c576827d2f135563dee3caaa44913ae5c420ad3" translate="yes" xml:space="preserve">
          <source>Returns the IP address of the client connected to this backend.</source>
          <target state="translated">이 백엔드에 연결된 클라이언트의 IP 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f48733af648ea7678c2f536caa7c6201433cb919" translate="yes" xml:space="preserve">
          <source>Returns the IP address of the current client, or &lt;code id=&quot;null&quot;&gt;NULL&lt;/code&gt; if the current connection is via a Unix-domain socket.</source>
          <target state="translated">현재 클라이언트의 IP 주소를 반환하거나 현재 연결이 Unix 도메인 소켓을 통해 이루어지는 경우 &lt;code id=&quot;null&quot;&gt;NULL&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="27e424ceb3291be82f08023706db51f71afab61e" translate="yes" xml:space="preserve">
          <source>Returns the IP address on which the server accepted the current connection, or &lt;code&gt;NULL&lt;/code&gt; if the current connection is via a Unix-domain socket.</source>
          <target state="translated">서버가 현재 연결을 수락 한 IP 주소를 반환하거나 현재 연결이 Unix 도메인 소켓을 통한 경우 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28effe37de3360f104f40d8f3249aab71a9a1b1b" translate="yes" xml:space="preserve">
          <source>Returns the IP port number of the current client, or &lt;code&gt;NULL&lt;/code&gt; if the current connection is via a Unix-domain socket.</source>
          <target state="translated">현재 클라이언트의 IP 포트 번호를 반환하거나 현재 연결이 Unix 도메인 소켓을 통해 이루어지는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="17be3a68fafed9eadbe2953fc17d99d3d393a1db" translate="yes" xml:space="preserve">
          <source>Returns the IP port number on which the server accepted the current connection, or &lt;code&gt;NULL&lt;/code&gt; if the current connection is via a Unix-domain socket.</source>
          <target state="translated">서버가 현재 연결을 수락 한 IP 포트 번호를 반환하거나 현재 연결이 Unix 도메인 소켓을 통한 경우 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="483700c34738640df0d5a853533680a49a4b76b9" translate="yes" xml:space="preserve">
          <source>Returns the OID of the current default text search configuration (as set by &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt;).</source>
          <target state="translated">현재 기본 텍스트 검색 구성의 OID를 반환합니다 ( &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TEXT-SEARCH-CONFIG&quot;&gt;default_text_search_config&lt;/a&gt; 로 설정 됨 ).</target>
        </trans-unit>
        <trans-unit id="abb76624847aeef73a0cea05827b8de4beb08ca9" translate="yes" xml:space="preserve">
          <source>Returns the OID of the current session's temporary schema, or zero if it has none (because it has not created any temporary tables).</source>
          <target state="translated">현재 세션의 임시 스키마의 OID를 반환하거나,없는 경우 0 (임시 테이블을 생성하지 않았기 때문에)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="14a3385e184654f45b27bc9d160d5db8e41ed518" translate="yes" xml:space="preserve">
          <source>Returns the OID of the data type of the value that is passed to it. This can be helpful for troubleshooting or dynamically constructing SQL queries. The function is declared as returning &lt;code&gt;regtype&lt;/code&gt;, which is an OID alias type (see &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt;); this means that it is the same as an OID for comparison purposes but displays as a type name.</source>
          <target state="translated">전달 된 값의 데이터 유형에 대한 OID를 리턴합니다. 이는 SQL 쿼리의 문제를 해결하거나 동적으로 구성하는 데 유용 할 수 있습니다. 함수는 OID 별칭 유형 인 &lt;code&gt;regtype&lt;/code&gt; 반환으로 선언됩니다 ( &lt;a href=&quot;datatype-oid&quot;&gt;섹션 8.19&lt;/a&gt; 참조 ). 이는 비교 목적으로 OID와 동일하지만 유형 이름으로 표시됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1f1bee53f6d95030fb9af3b471c597f775ea4a05" translate="yes" xml:space="preserve">
          <source>Returns the OID of the database this backend is connected to.</source>
          <target state="translated">이 백엔드가 연결된 데이터베이스의 OID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f7885ec5531b27ad1a870218d58f0092e0c7beb8" translate="yes" xml:space="preserve">
          <source>Returns the OID of the user logged into this backend.</source>
          <target state="translated">이 백엔드에 로그인 한 사용자의 OID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d28e0e1cb3750bbce8961cb532ce551f5bb32269" translate="yes" xml:space="preserve">
          <source>Returns the OR-combination of the two given queries.</source>
          <target state="translated">주어진 두 쿼리의 OR 조합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46c6d06799a0bd3164b4fb2eeb3a3e8b36ebb8bc" translate="yes" xml:space="preserve">
          <source>Returns the SQL name for a data type that is identified by its type OID and possibly a type modifier. Pass NULL for the type modifier if no specific modifier is known.</source>
          <target state="translated">유형 OID 및 가능하면 유형 수정 자로 식별되는 데이터 유형에 대한 SQL 이름을 리턴합니다. 특정 수정자를 알 수없는 경우 유형 수정 자에 NULL을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="10ee6a712cc2787f2c8b64e46eee3f37b7d3487d" translate="yes" xml:space="preserve">
          <source>Returns the TCP port number that the client is using for communication.</source>
          <target state="translated">클라이언트가 통신에 사용하는 TCP 포트 번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="daf4fb8ae530402bf18ba41e41556832f117ebb1" translate="yes" xml:space="preserve">
          <source>Returns the TIDs of non-all-visible tuples stored in pages marked all-visible in the visibility map. If this function returns a non-empty set of TIDs, the visibility map is corrupt.</source>
          <target state="translated">가시성 맵에서 all-visible로 표시된 페이지에 저장된 모든 보이지 않는 튜플의 TID를 반환합니다. 이 함수가 비어 있지 않은 TID 세트를 리턴하면 가시성 맵이 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="d54c4189d60394ab28dd0d2c93b4b6da39309b2d" translate="yes" xml:space="preserve">
          <source>Returns the TIDs of non-frozen tuples stored in pages marked all-frozen in the visibility map. If this function returns a non-empty set of TIDs, the visibility map is corrupt.</source>
          <target state="translated">가시성 맵에서 모두 고정으로 표시된 페이지에 저장된 고정되지 않은 튜플의 TID를 반환합니다. 이 함수가 비어 있지 않은 TID 세트를 리턴하면 가시성 맵이 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="0fb835170a801f3fee847fed53d71159711b221d" translate="yes" xml:space="preserve">
          <source>Returns the actual version of the collation object as it is currently installed in the operating system. If this is different from the value in &lt;code&gt;pg_collation&lt;/code&gt;.&lt;code&gt;collversion&lt;/code&gt;, then objects depending on the collation might need to be rebuilt. See also &lt;a href=&quot;sql-altercollation&quot;&gt;ALTER COLLATION&lt;/a&gt;.</source>
          <target state="translated">현재 운영 체제에 설치된 데이터 정렬 개체의 실제 버전을 반환합니다. 이것이 &lt;code&gt;pg_collation&lt;/code&gt; 의 값과 다른 경우 . &lt;code&gt;collversion&lt;/code&gt; 이면 데이터 정렬에 따른 객체를 다시 빌드해야 할 수 있습니다. &lt;a href=&quot;sql-altercollation&quot;&gt;ALTER COLLATION&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb03b81136fa978e92893136d0bb216f7e83828a" translate="yes" xml:space="preserve">
          <source>Returns the address's family: &lt;code id=&quot;4&quot;&gt;4&lt;/code&gt; for IPv4, &lt;code&gt;6&lt;/code&gt; for IPv6.</source>
          <target state="translated">주소의 패밀리를 반환합니다 . IPv4의 경우 &lt;code id=&quot;4&quot;&gt;4&lt;/code&gt; , IPv6의 경우 &lt;code&gt;6&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9e9c08991cd6d19b770d0249d21a843d3a99434a" translate="yes" xml:space="preserve">
          <source>Returns the all-visible and all-frozen bits in the visibility map for each block of the given relation, plus the &lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; bit of each block.</source>
          <target state="translated">주어진 관계의 각 블록에 대한 가시성 맵에서 모든 표시 가능 및 고정 된 비트와 각 블록의 &lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; 비트를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="437e42a28dd5daaee260c590f40a9dc5d49be478" translate="yes" xml:space="preserve">
          <source>Returns the all-visible and all-frozen bits in the visibility map for each block of the given relation.</source>
          <target state="translated">주어진 관계의 각 블록에 대한 가시성 맵에서 모든 표시 및 고정 된 비트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="89f9d0f2181564598be194a9772f01742cf256e9" translate="yes" xml:space="preserve">
          <source>Returns the all-visible and all-frozen bits in the visibility map for the given block of the given relation, plus the &lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; bit of that block.</source>
          <target state="translated">주어진 관계의 주어진 블록에 대한 가시성 맵에서 모든 가시적 및 모든 고정 된 비트와 그 블록의 &lt;code&gt;PD_ALL_VISIBLE&lt;/code&gt; 비트를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="511adc479b6586a44c22190f1555d28dee4b1f40" translate="yes" xml:space="preserve">
          <source>Returns the all-visible and all-frozen bits in the visibility map for the given block of the given relation.</source>
          <target state="translated">주어진 관계의 주어진 블록에 대한 가시성 맵에서 모든 보이는 비트와 모든 고정 된 비트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3487c55606d89ac8ac54bd3b8cef88dae17b0a26" translate="yes" xml:space="preserve">
          <source>Returns the amount of free space on the page of the relation, specified by &lt;code&gt;blkno&lt;/code&gt;, according to the FSM.</source>
          <target state="translated">FSM에 따라 관계 페이지에서 여유 공간의 크기를 &lt;code&gt;blkno&lt;/code&gt; 로 지정하여 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="86e6a85c877a0b7f2dabfd0fe8f850a63385d480" translate="yes" xml:space="preserve">
          <source>Returns the array as a JSON array. A PostgreSQL multidimensional array becomes a JSON array of arrays. Line feeds will be added between dimension-1 elements if &lt;em&gt;&lt;code&gt;pretty_bool&lt;/code&gt;&lt;/em&gt; is true.</source>
          <target state="translated">배열을 JSON 배열로 반환합니다. PostgreSQL 다차원 배열은 JSON 배열 배열이됩니다. &lt;em&gt; &lt;code&gt;pretty_bool&lt;/code&gt; &lt;/em&gt; 이 true 인 경우 차원 -1 요소 사이에 줄 바꿈이 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddd178aff046aabfc6149931e4deb214a8d5055d" translate="yes" xml:space="preserve">
          <source>Returns the assumed radius of the Earth.</source>
          <target state="translated">지구의 추정 반경을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40d8388f1bff9717e499af1f0cb756f0f714602a" translate="yes" xml:space="preserve">
          <source>Returns the character with the given code. In UTF8 encoding the argument is treated as a Unicode code point. In other multibyte encodings the argument must designate an ASCII character. &lt;code&gt;chr(0)&lt;/code&gt; is disallowed because text data types cannot store that character.</source>
          <target state="translated">주어진 코드를 가진 문자를 반환합니다. UTF8 인코딩에서 인수는 유니 코드 코드 포인트로 처리됩니다. 다른 멀티 바이트 인코딩에서 인수는 ASCII 문자를 지정해야합니다. &lt;code&gt;chr(0)&lt;/code&gt; 은 텍스트 데이터 유형이 해당 문자를 저장할 수 없기 때문에 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64a8e0f91336826c249a710a1dd7109fa959567e" translate="yes" xml:space="preserve">
          <source>Returns the client domain, the current security label of the client.</source>
          <target state="translated">클라이언트의 현재 보안 레이블 인 클라이언트 도메인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="79fde1775c1f4f716cdfe893da291e165e06416c" translate="yes" xml:space="preserve">
          <source>Returns the comment for a database object specified by its OID alone. This is &lt;em&gt;deprecated&lt;/em&gt; since there is no guarantee that OIDs are unique across different system catalogs; therefore, the wrong comment might be returned.</source>
          <target state="translated">OID만으로 지정된 데이터베이스 개체에 대한 설명을 반환합니다. 이되어 &lt;em&gt;사용되지 않는&lt;/em&gt; OID를 다른 시스템 카탈로그에서 고유 것이라는 보장이 없기 때문에, 따라서 잘못된 주석이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58a691ced95341e8b905ecffe0b1d23e020481a7" translate="yes" xml:space="preserve">
          <source>Returns the comment for a database object specified by its OID and the name of the containing system catalog. For example, &lt;code id=&quot;obj_description&quot;&gt;obj_description(123456, 'pg_class')&lt;/code&gt; would retrieve the comment for the table with OID 123456.</source>
          <target state="translated">OID 및 포함하는 시스템 카탈로그의 이름으로 지정된 데이터베이스 개체에 대한 설명을 반환합니다. 예를 들어, &lt;code id=&quot;obj_description&quot;&gt;obj_description(123456, 'pg_class')&lt;/code&gt; 는 OID가 123456 인 테이블에 대한 주석을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="4fec60133a08afae916ede5f6198e03898f477fc" translate="yes" xml:space="preserve">
          <source>Returns the comment for a shared database object specified by its OID and the name of the containing system catalog. This is just like &lt;code&gt;obj_description&lt;/code&gt; except that it is used for retrieving comments on shared objects (that is, databases, roles, and tablespaces). Some system catalogs are global to all databases within each cluster, and the descriptions for objects in them are stored globally as well.</source>
          <target state="translated">OID 및 포함하는 시스템 카탈로그의 이름으로 지정된 공유 데이터베이스 객체에 대한 주석을 반환합니다. 이는 공유 객체 (즉, 데이터베이스, 역할 및 테이블 스페이스)에 대한 주석을 검색하는 데 사용된다는 점을 제외하면 &lt;code&gt;obj_description&lt;/code&gt; 과 같습니다 . 일부 시스템 카탈로그는 각 클러스터 내의 모든 데이터베이스에 대해 전역 적이며 그 안에있는 개체에 대한 설명도 전역 적으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a6bdddbd38f3689e98d7896b2dc9866138fb69a0" translate="yes" xml:space="preserve">
          <source>Returns the comment for a table column, which is specified by the OID of its table and its column number. (&lt;code id=&quot;obj_description&quot;&gt;obj_description&lt;/code&gt; cannot be used for table columns, since columns do not have OIDs of their own.)</source>
          <target state="translated">테이블의 OID와 해당 열 번호로 지정된 테이블 열에 대한 설명을 반환합니다. ( &lt;code id=&quot;obj_description&quot;&gt;obj_description&lt;/code&gt; 은 열에 자체 OID가 없기 때문에 테이블 열에 사용할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="942671200c7a0b84fa51a257ba59b9ea9508b259" translate="yes" xml:space="preserve">
          <source>Returns the commit timestamp of a transaction.</source>
          <target state="translated">트랜잭션의 커밋 타임 스탬프를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="67ca9674249160c4aa7b16c70806889f5f45cb67" translate="yes" xml:space="preserve">
          <source>Returns the cumulative distribution, that is (number of partition rows preceding or peers with current row) / (total partition rows). The value thus ranges from 1/&lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt; to 1.</source>
          <target state="translated">누적 분포, 즉 (이전 파티션 행 수 또는 현재 행과 피어) / (총 파티션 행)을 반환합니다. 따라서 값의 범위는 1 / &lt;em&gt; &lt;code&gt;N&lt;/code&gt; &lt;/em&gt; 에서 1입니다.</target>
        </trans-unit>
        <trans-unit id="8e7c1fb8be638855577ed4c2223b208a1e773615" translate="yes" xml:space="preserve">
          <source>Returns the current nesting level of PostgreSQL triggers (0 if not called, directly or indirectly, from inside a trigger).</source>
          <target state="translated">PostgreSQL 트리거의 현재 중첩 수준을 반환합니다 (트리거 내부에서 직접 또는 간접적으로 호출되지 않은 경우 0).</target>
        </trans-unit>
        <trans-unit id="65ee03cf7b6073ea9bc76c1758552b4c3914ffd8" translate="yes" xml:space="preserve">
          <source>Returns the current similarity threshold used by the &lt;code&gt;%&lt;/code&gt; operator. This sets the minimum similarity between two words for them to be considered similar enough to be misspellings of each other, for example (&lt;em&gt;deprecated&lt;/em&gt;).</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 연산자가 사용하는 현재 유사성 임계 값을 반환합니다 . 예를 들어 ( &lt;em&gt;더 이상 사용되지 않음&lt;/em&gt; ) 서로 철자가 틀릴 정도로 유사하게 간주되도록 두 단어 사이의 최소 유사성을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="6b4aebcfc0d76b2983dbcac424c40a7196e7896e" translate="yes" xml:space="preserve">
          <source>Returns the current similarity threshold used by the &lt;code&gt;%&lt;/code&gt; operator. This sets the minimum similarity between two words for them to be considered similar enough to be misspellings of each other, for example. (&lt;em&gt;Deprecated&lt;/em&gt;; instead use &lt;code&gt;SHOW&lt;/code&gt;&lt;code&gt;pg_trgm.similarity_threshold&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 연산자가 사용하는 현재 유사성 임계 값을 반환합니다 . 예를 들어 두 단어가 서로 철자가 틀릴 정도로 유사하다고 간주되도록 두 단어 사이의 최소 유사성을 설정합니다. (더 이상 &lt;em&gt;사용되지 않습니다&lt;/em&gt; . 대신 &lt;code&gt;SHOW&lt;/code&gt; &lt;code&gt;pg_trgm.similarity_threshold&lt;/code&gt; 를 사용 하십시오 .)</target>
        </trans-unit>
        <trans-unit id="d7daab2712c45588d0fe45ff88bc543f3a6f6a10" translate="yes" xml:space="preserve">
          <source>Returns the current status of the weak mode.</source>
          <target state="translated">약한 모드의 현재 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8d4b88cc4bd170548c26513b594e222eb0984161" translate="yes" xml:space="preserve">
          <source>Returns the current transaction's ID, or &lt;code&gt;NULL&lt;/code&gt; if no ID is assigned yet. (It's best to use this variant if the transaction might otherwise be read-only, to avoid unnecessary consumption of an XID.)</source>
          <target state="translated">현재 트랜잭션의 ID를 반환하거나 아직 할당 된 ID가 없으면 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다 . (불필요한 XID 사용을 방지하기 위해 트랜잭션이 읽기 전용 일 수있는 경우이 변형을 사용하는 것이 가장 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="a3b89df05890fb30871265947558d5eb0ef8fd21" translate="yes" xml:space="preserve">
          <source>Returns the current transaction's ID. It will assign a new one if the current transaction does not have one already (because it has not performed any database updates).</source>
          <target state="translated">현재 트랜잭션의 ID를 반환합니다. 현재 트랜잭션에 데이터베이스 업데이트를 수행하지 않았기 때문에 아직 트랜잭션이없는 경우 새 트랜잭션을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="0f8db912268926ba268088c90144109bfa6fa638" translate="yes" xml:space="preserve">
          <source>Returns the current value of the setting &lt;em&gt;&lt;code&gt;setting_name&lt;/code&gt;&lt;/em&gt;. If there is no such setting, &lt;code&gt;current_setting&lt;/code&gt; throws an error unless &lt;em&gt;&lt;code&gt;missing_ok&lt;/code&gt;&lt;/em&gt; is supplied and is &lt;code&gt;true&lt;/code&gt;. This function corresponds to the SQL command &lt;code&gt;SHOW&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;setting_name&lt;/code&gt; &lt;/em&gt; 설정의 현재 값을 반환합니다 . 이러한 설정이 없으면 &lt;em&gt; &lt;code&gt;missing_ok&lt;/code&gt; &lt;/em&gt; 가 제공되고 &lt;code&gt;true&lt;/code&gt; 가 아닌 한 &lt;code&gt;current_setting&lt;/code&gt; 에서 오류가 발생 합니다 . 이 함수는 SQL 명령 &lt;code&gt;SHOW&lt;/code&gt; 에 해당합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d448e5970aace207439f94b9ca06191a8e2d8551" translate="yes" xml:space="preserve">
          <source>Returns the current write-ahead log flush location (see notes below).</source>
          <target state="translated">현재 미리 쓰기 로그 플러시 위치를 반환합니다 (아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="2cab36aecf2727611e5ff91af5e0dd40a919e462" translate="yes" xml:space="preserve">
          <source>Returns the current write-ahead log insert location (see notes below).</source>
          <target state="translated">현재 미리 쓰기 로그 삽입 위치를 반환합니다 (아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="330af95aa7d3ab07f49a8bb8b9e2ff401d3c54c9" translate="yes" xml:space="preserve">
          <source>Returns the current write-ahead log write location (see notes below).</source>
          <target state="translated">현재 미리 쓰기 로그 쓰기 위치를 반환합니다 (아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="31eae9e9b69d7fe499dd5538a60cbd5e0a0587de" translate="yes" xml:space="preserve">
          <source>Returns the distance between two cubes. If both cubes are points, this is the normal distance function.</source>
          <target state="translated">두 큐브 사이의 거리를 반환합니다. 두 큐브가 모두 점이면, 이것은 정상적인 거리 함수입니다.</target>
        </trans-unit>
        <trans-unit id="70d5f4e0fbe8da055a62735afd1fe0b22535e708" translate="yes" xml:space="preserve">
          <source>Returns the entire file path name (relative to the database cluster's data directory, &lt;code&gt;PGDATA&lt;/code&gt;) of the relation.</source>
          <target state="translated">관계의 전체 파일 경로 이름 (데이터베이스 클러스터의 데이터 디렉토리 &lt;code&gt;PGDATA&lt;/code&gt; 에 상대적)을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c83ea65bd18247bb52351ff6bef1326c37839b8e" translate="yes" xml:space="preserve">
          <source>Returns the file system path that this tablespace is located in.</source>
          <target state="translated">이 테이블 스페이스가있는 파일 시스템 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f71f8463c36241f81041020b46796d08f821af98" translate="yes" xml:space="preserve">
          <source>Returns the first JSON item returned by the JSON path for the specified JSON value. Returns &lt;code&gt;NULL&lt;/code&gt; if there are no results. The optional &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;silent&lt;/code&gt;&lt;/em&gt; arguments act the same as for &lt;code&gt;jsonb_path_exists&lt;/code&gt;.</source>
          <target state="translated">지정된 JSON 값에 대해 JSON 경로에서 반환 한 첫 번째 JSON 항목을 반환합니다. 결과가 없으면 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 선택적 &lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;silent&lt;/code&gt; &lt;/em&gt; 인수는 &lt;code&gt;jsonb_path_exists&lt;/code&gt; 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="9f86ad5eae0402acda72bd78d67143ab90e61887" translate="yes" xml:space="preserve">
          <source>Returns the first value of the input enum type</source>
          <target state="translated">입력 열거 형의 최초의 값을 돌려줍니다</target>
        </trans-unit>
        <trans-unit id="695c11b95ef9b7ac99f3f138c82c205d4902fc66" translate="yes" xml:space="preserve">
          <source>Returns the first value of the input enum type.</source>
          <target state="translated">입력 열거 형 유형의 첫 번째 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="274a567d9332d87b5e7803b49c1ebe35c796d83f" translate="yes" xml:space="preserve">
          <source>Returns the fraction (0&amp;ndash;1) of the asynchronous notification queue's maximum size that is currently occupied by notifications that are waiting to be processed. See &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; and &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt; for more information.</source>
          <target state="translated">처리 대기중인 알림이 현재 차지하고있는 비동기 알림 대기열의 최대 크기 중 일부 (0&amp;ndash;1)를 반환합니다. 자세한 내용은 &lt;a href=&quot;sql-listen&quot;&gt;LISTEN&lt;/a&gt; 및 &lt;a href=&quot;sql-notify&quot;&gt;NOTIFY&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ce565a5a7dc19462d2eae354fe4d4ac2c31cce50" translate="yes" xml:space="preserve">
          <source>Returns the full issuer name of the current client certificate, converting character data into the current database encoding. Encoding conversions are handled the same as for &lt;code&gt;ssl_client_dn&lt;/code&gt;.</source>
          <target state="translated">문자 데이터를 현재 데이터베이스 인코딩으로 변환하여 현재 클라이언트 인증서의 전체 발급자 이름을 반환합니다. 인코딩 변환은 &lt;code&gt;ssl_client_dn&lt;/code&gt; 과 동일하게 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="5016794d2ec70f3c2d09e0e6cc9b28f25f648bea" translate="yes" xml:space="preserve">
          <source>Returns the full subject of the current client certificate, converting character data into the current database encoding. It is assumed that if you use non-ASCII characters in the certificate names, your database is able to represent these characters, too. If your database uses the SQL_ASCII encoding, non-ASCII characters in the name will be represented as UTF-8 sequences.</source>
          <target state="translated">문자 데이터를 현재 데이터베이스 인코딩으로 변환하여 현재 클라이언트 인증서의 전체 주제를 리턴합니다. 인증서 이름에 ASCII가 아닌 문자를 사용하면 데이터베이스도 이러한 문자를 나타낼 수 있다고 가정합니다. 데이터베이스가 SQL_ASCII 인코딩을 사용하는 경우 이름의 비 ASCII 문자는 UTF-8 시퀀스로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="663715e193b4c92bd890a4f04a11752f1e4fb4b7" translate="yes" xml:space="preserve">
          <source>Returns the given string suitably quoted to be used as a string literal in an SQL statement string. Embedded single-quotes and backslashes are properly doubled. Note that &lt;code&gt;quote_literal&lt;/code&gt; returns null on null input; if the argument might be null, &lt;code&gt;quote_nullable&lt;/code&gt; is often more suitable. See also &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;Example 42.1&lt;/a&gt;.</source>
          <target state="translated">SQL 문 문자열에서 문자열 리터럴로 사용하기 위해 적절하게 인용 된 주어진 문자열을 반환합니다. 삽입 된 작은 따옴표와 백 슬래시는 올바르게 두 배가됩니다. 참고 것을 &lt;code&gt;quote_literal&lt;/code&gt; NULL을 반환 입력에 널 (null); 인수가 null 일 수있는 경우 &lt;code&gt;quote_nullable&lt;/code&gt; 이 더 적합합니다. &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;Example 42.1&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90bb8735b1473284e7b0d424c8c0f2e4bb2290a1" translate="yes" xml:space="preserve">
          <source>Returns the given string suitably quoted to be used as a string literal in an SQL statement string; or, if the argument is null, returns &lt;code&gt;NULL&lt;/code&gt;. Embedded single-quotes and backslashes are properly doubled. See also &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;Example 42.1&lt;/a&gt;.</source>
          <target state="translated">SQL 문 문자열에서 문자열 리터럴로 사용하기 위해 적절하게 인용 된 주어진 문자열을 반환합니다. 또는 인수가 null이면 NULL을 반환 &lt;code&gt;NULL&lt;/code&gt; . 삽입 된 작은 따옴표와 백 슬래시는 올바르게 두 배가됩니다. &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;Example 42.1&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2086270d723617d5bbe0287474ee9aaed5ec4330" translate="yes" xml:space="preserve">
          <source>Returns the given string suitably quoted to be used as an identifier in an SQL statement string. Quotes are added only if necessary (i.e., if the string contains non-identifier characters or would be case-folded). Embedded quotes are properly doubled. See also &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;Example 42.1&lt;/a&gt;.</source>
          <target state="translated">SQL 문 문자열에서 식별자로 사용하기 위해 적절하게 인용 된 주어진 문자열을 반환합니다. 따옴표는 필요한 경우에만 추가됩니다 (즉, 문자열에 비 식별자 문자가 포함되어 있거나 대소 문자가 접혀있는 경우). 포함 된 따옴표는 올바르게 두 배가됩니다. &lt;a href=&quot;https://www.postgresql.org/docs/13/plpgsql-statements.html#PLPGSQL-QUOTE-LITERAL-EXAMPLE&quot;&gt;Example 42.1&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c669de864ddb48ed1f9d7f861a95a69d070730e" translate="yes" xml:space="preserve">
          <source>Returns the great circle distance between two points on the surface of the Earth.</source>
          <target state="translated">지구 표면의 두 점 사이의 큰 원 거리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95647a28d7c23079322b947e8a1a361851738716" translate="yes" xml:space="preserve">
          <source>Returns the last value of the input enum type</source>
          <target state="translated">입력 열거 형의 마지막 값을 돌려줍니다</target>
        </trans-unit>
        <trans-unit id="cca57b8982537ee0608ed08a45b470fe003f7182" translate="yes" xml:space="preserve">
          <source>Returns the last value of the input enum type.</source>
          <target state="translated">입력 열거 형 유형의 마지막 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ee7f2ed92c74a8ec06b60d22558c935e20c26148" translate="yes" xml:space="preserve">
          <source>Returns the last write-ahead log location that has been received and synced to disk by streaming replication. While streaming replication is in progress this will increase monotonically. If recovery has completed then this will remain static at the location of the last WAL record received and synced to disk during recovery. If streaming replication is disabled, or if it has not yet started, the function returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">스트리밍 복제를 통해 수신되고 디스크에 동기화 된 마지막 미리 쓰기 로그 위치를 반환합니다. 스트리밍 복제가 진행되는 동안 이것은 단조롭게 증가합니다. 복구가 완료되면 마지막 WAL 레코드가 수신 된 위치에서 고정되어 복구 중에 디스크에 동기화됩니다. 스트리밍 복제가 비활성화되어 있거나 아직 시작되지 않은 경우 함수는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="e765bad43569c54ce0c2c15a300d0b2fbc69e997" translate="yes" xml:space="preserve">
          <source>Returns the last write-ahead log location that has been replayed during recovery. If recovery is still in progress this will increase monotonically. If recovery has completed then this will remain static at the location of the last WAL record applied during recovery. When the server has been started normally without recovery, the function returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">복구 중에 재생 된 마지막 미리 쓰기 로그 위치를 반환합니다. 복구가 아직 진행 중이면 단조롭게 증가합니다. 복구가 완료되면 복구 중에 적용된 마지막 WAL 레코드 위치에서 고정 상태로 유지됩니다. 서버가 복구없이 정상적으로 시작되면 함수는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="543975e34373a3857609d9202d116cb196708d8d" translate="yes" xml:space="preserve">
          <source>Returns the latitude in degrees of a point on the surface of the Earth.</source>
          <target state="translated">지구 표면의 한 위도를도 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="93b37c82ba9830e0463ecc112961b7f0fe4fc063" translate="yes" xml:space="preserve">
          <source>Returns the length of the requested array dimension.</source>
          <target state="translated">요청 된 배열 차원의 길이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="19dbc4feb41af25ba7e91f2b3b0d089c7381e055" translate="yes" xml:space="preserve">
          <source>Returns the location of a point on the surface of the Earth given its latitude (argument 1) and longitude (argument 2) in degrees.</source>
          <target state="translated">위도 (인수 1)와 경도 (인수 2)가 주어진 지구 표면의 한 지점의 위치를 ​​반환합니다.</target>
        </trans-unit>
        <trans-unit id="ff3907e7aa605252b170d681fac75a870920a63b" translate="yes" xml:space="preserve">
          <source>Returns the longitude in degrees of a point on the surface of the Earth.</source>
          <target state="translated">지구 표면의 점의 경도를도 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="24739d017864829713a3db0cf23626038e3a1cd1" translate="yes" xml:space="preserve">
          <source>Returns the lower bound of the requested array dimension.</source>
          <target state="translated">요청 된 배열 차원의 하한을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66c5e29144b8e24d53aa661b779bc97243e82e8d" translate="yes" xml:space="preserve">
          <source>Returns the name of the cipher used for the SSL connection (e.g. DHE-RSA-AES256-SHA).</source>
          <target state="translated">SSL 연결에 사용 된 암호 이름을 반환합니다 (예 : DHE-RSA-AES256-SHA).</target>
        </trans-unit>
        <trans-unit id="b95bb0d1027d11571330b2e49eeeb04e254a9747" translate="yes" xml:space="preserve">
          <source>Returns the name of the cipher used for the SSL connection (e.g., DHE-RSA-AES256-SHA).</source>
          <target state="translated">SSL 연결에 사용되는 암호의 이름을 반환합니다 (예 : DHE-RSA-AES256-SHA).</target>
        </trans-unit>
        <trans-unit id="599db34bcc990df13e49ea2d844fe3c477192e73" translate="yes" xml:space="preserve">
          <source>Returns the name of the collation of the value that is passed to it. The value is quoted and schema-qualified if necessary. If no collation was derived for the argument expression, then &lt;code&gt;NULL&lt;/code&gt; is returned. If the argument is not of a collatable data type, then an error is raised.</source>
          <target state="translated">전달 된 값의 데이터 정렬 이름을 반환합니다. 값은 인용되고 필요한 경우 스키마로 규정됩니다. 인수 표현식에 대해 데이터 정렬이 파생되지 않은 경우 &lt;code&gt;NULL&lt;/code&gt; 이 리턴됩니다. 인수가 결합 가능한 데이터 유형이 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="61f30eec85a3c98ac2e5f80be9bb41dacd9a3252" translate="yes" xml:space="preserve">
          <source>Returns the name of the current database. (Databases are called &amp;ldquo;catalogs&amp;rdquo; in the SQL standard, so &lt;code&gt;current_catalog&lt;/code&gt; is the standard's spelling.)</source>
          <target state="translated">현재 데이터베이스의 이름을 반환합니다. (SQL 표준에서는 데이터베이스를 &quot;카탈로그&quot;라고하므로 &lt;code&gt;current_catalog&lt;/code&gt; 가 표준의 철자입니다.)</target>
        </trans-unit>
        <trans-unit id="82bd205eb968248e9c07aea802c527c24bad365b" translate="yes" xml:space="preserve">
          <source>Returns the name of the protocol used for the SSL connection (e.g. TLSv1.0 TLSv1.1, or TLSv1.2).</source>
          <target state="translated">SSL 연결에 사용 된 프로토콜 이름을 반환합니다 (예 : TLSv1.0 TLSv1.1 또는 TLSv1.2).</target>
        </trans-unit>
        <trans-unit id="1c2580ae52b99e9cb8c5192c807511dc7bf8ee63" translate="yes" xml:space="preserve">
          <source>Returns the name of the protocol used for the SSL connection (e.g., TLSv1.0, TLSv1.1, or TLSv1.2).</source>
          <target state="translated">SSL 연결에 사용되는 프로토콜의 이름을 반환합니다 (예 : TLSv1.0, TLSv1.1 또는 TLSv1.2).</target>
        </trans-unit>
        <trans-unit id="8800d79228a315cf23c9179b389ce506cfbbc648" translate="yes" xml:space="preserve">
          <source>Returns the name of the schema that is first in the search path (or a null value if the search path is empty). This is the schema that will be used for any tables or other named objects that are created without specifying a target schema.</source>
          <target state="translated">검색 경로에서 첫 번째 인 스키마의 이름을 반환합니다 (또는 검색 경로가 비어있는 경우 null 값). 이는 대상 스키마를 지정하지 않고 생성 된 테이블 또는 기타 명명 된 개체에 사용되는 스키마입니다.</target>
        </trans-unit>
        <trans-unit id="ccd6f71dde05da2a321c2f0714e10b781d93ff60" translate="yes" xml:space="preserve">
          <source>Returns the name of the sequence associated with a column, or NULL if no sequence is associated with the column. If the column is an identity column, the associated sequence is the sequence internally created for that column. For columns created using one of the serial types (&lt;code&gt;serial&lt;/code&gt;, &lt;code&gt;smallserial&lt;/code&gt;, &lt;code&gt;bigserial&lt;/code&gt;), it is the sequence created for that serial column definition. In the latter case, the association can be modified or removed with &lt;code&gt;ALTER SEQUENCE OWNED BY&lt;/code&gt;. (This function probably should have been called &lt;code&gt;pg_get_owned_sequence&lt;/code&gt;; its current name reflects the fact that it has historically been used with serial-type columns.) The first parameter is a table name with optional schema, and the second parameter is a column name. Because the first parameter potentially contains both schema and table names, it is parsed per usual SQL rules, meaning it is lower-cased by default. The second parameter, being just a column name, is treated literally and so has its case preserved. The result is suitably formatted for passing to the sequence functions (see &lt;a href=&quot;functions-sequence&quot;&gt;Section 9.17&lt;/a&gt;).</source>
          <target state="translated">열과 연관된 시퀀스의 이름을 반환하거나 열과 연관된 시퀀스가 ​​없으면 NULL을 반환합니다. 열이 식별 열인 경우 연관된 시퀀스는 해당 열에 대해 내부적으로 생성 된 시퀀스입니다. 직렬 유형 ( &lt;code&gt;serial&lt;/code&gt; , &lt;code&gt;smallserial&lt;/code&gt; , &lt;code&gt;bigserial&lt;/code&gt; ) 중 하나를 사용하여 생성 된 열의 경우 해당 직렬 열 정의에 대해 생성 된 시퀀스입니다. 후자의 경우 &lt;code&gt;ALTER SEQUENCE OWNED BY&lt;/code&gt; 로 연결을 수정하거나 제거 할 수 있습니다 . (이 함수는 아마도 &lt;code&gt;pg_get_owned_sequence&lt;/code&gt; ; 현재 이름은 역사적으로 직렬 유형 열과 함께 사용되었다는 사실을 반영합니다. 첫 번째 매개 변수는 선택적 스키마가있는 테이블 이름이고 두 번째 매개 변수는 열 이름입니다. 첫 번째 매개 변수는 잠재적으로 스키마와 테이블 이름을 모두 포함하므로 일반적인 SQL 규칙에 따라 구문 분석됩니다. 즉, 기본적으로 소문자입니다. 두 번째 매개 변수는 열 이름 일 뿐이며 문자 그대로 처리되므로 대소 문자가 유지됩니다. 결과는 시퀀스 함수에 전달할 수 있도록 적절하게 형식이 지정됩니다 ( &lt;a href=&quot;functions-sequence&quot;&gt;9.17 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="86c6192325de699cb109352167e8dd087f57e114" translate="yes" xml:space="preserve">
          <source>Returns the name, size, and last modification time (mtime) of each ordinary file in the server's WAL archive status directory (&lt;code&gt;pg_wal/archive_status&lt;/code&gt;). Filenames beginning with a dot, directories, and other special files are excluded.</source>
          <target state="translated">서버의 WAL 아카이브 상태 디렉토리 ( &lt;code&gt;pg_wal/archive_status&lt;/code&gt; ) 에있는 각 일반 파일의 이름, 크기 및 마지막 수정 시간 (mtime)을 반환합니다 . 점, 디렉토리 및 기타 특수 파일로 시작하는 파일 이름은 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="919c684738f0a74089801730f0210a5f0d918921" translate="yes" xml:space="preserve">
          <source>Returns the name, size, and last modification time (mtime) of each ordinary file in the server's log directory. Filenames beginning with a dot, directories, and other special files are excluded.</source>
          <target state="translated">서버의 로그 디렉터리에있는 각 일반 파일의 이름, 크기 및 마지막 수정 시간 (mtime)을 반환합니다. 점, 디렉토리 및 기타 특수 파일로 시작하는 파일 이름은 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="b5efc3e35a27beb687b2ca038a86973b35b2a7e8" translate="yes" xml:space="preserve">
          <source>Returns the name, size, and last modification time (mtime) of each ordinary file in the server's write-ahead log (WAL) directory. Filenames beginning with a dot, directories, and other special files are excluded.</source>
          <target state="translated">서버의 미리 쓰기 로그 (WAL) 디렉토리에있는 각 일반 파일의 이름, 크기 및 마지막 수정 시간 (mtime)을 리턴합니다. 점, 디렉토리 및 기타 특수 파일로 시작하는 파일 이름은 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="c2a077f1292723ec17211f060063a34cac65d87e" translate="yes" xml:space="preserve">
          <source>Returns the name, size, and last modification time (mtime) of each ordinary file in the temporary file directory for the specified &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt;. If &lt;em&gt;&lt;code&gt;tablespace&lt;/code&gt;&lt;/em&gt; is not provided, the &lt;code&gt;pg_default&lt;/code&gt; tablespace is examined. Filenames beginning with a dot, directories, and other special files are excluded.</source>
          <target state="translated">지정된 &lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt; 에 대한 임시 파일 디렉토리에있는 각 일반 파일의 이름, 크기 및 마지막 수정 시간 (mtime)을 반환합니다 . 경우 &lt;em&gt; &lt;code&gt;tablespace&lt;/code&gt; &lt;/em&gt; 제공되지는 &lt;code&gt;pg_default&lt;/code&gt; 의 테이블을 조사한다. 점, 디렉토리 및 기타 특수 파일로 시작하는 파일 이름은 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="973b3b9972155cbc3fcb610ec6faa9d614d8340d" translate="yes" xml:space="preserve">
          <source>Returns the names of all files (and directories and other special files) in the specified directory. The &lt;em&gt;&lt;code&gt;include_dot_dirs&lt;/code&gt;&lt;/em&gt; parameter indicates whether &amp;ldquo;.&amp;rdquo; and &amp;ldquo;..&amp;rdquo; are to be included in the result set; the default is to exclude them. Including them can be useful when &lt;em&gt;&lt;code&gt;missing_ok&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;true&lt;/code&gt;, to distinguish an empty directory from a non-existent directory.</source>
          <target state="translated">지정된 디렉토리에있는 모든 파일 (및 디렉토리 및 기타 특수 파일)의 이름을 반환합니다. &lt;em&gt; &lt;code&gt;include_dot_dirs&lt;/code&gt; 의&lt;/em&gt; 매개 변수는 여부를 나타냅니다 &quot;.&quot; 및 &quot;..&quot;이 결과 집합에 포함됩니다. 기본값은 제외하는 것입니다. 이들을 포함하면 &lt;em&gt; &lt;code&gt;missing_ok&lt;/code&gt; &lt;/em&gt; 가 &lt;code&gt;true&lt;/code&gt; 일 때 빈 디렉토리를 존재하지 않는 디렉토리와 구별하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42882e5a776856ef2eaac0885239976fbf50716c" translate="yes" xml:space="preserve">
          <source>Returns the negation (NOT) of the given query.</source>
          <target state="translated">주어진 쿼리의 부정 (NOT)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="657b894f2f39cab430b1d5646ba4f93ba35d43a1" translate="yes" xml:space="preserve">
          <source>Returns the netmask length in bits.</source>
          <target state="translated">넷 마스크 길이를 비트 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ade797d1cf6c2ed04ff32e7c176870f3d22cdd6" translate="yes" xml:space="preserve">
          <source>Returns the network part of the address, zeroing out whatever is to the right of the netmask. (This is equivalent to casting the value to &lt;code&gt;cidr&lt;/code&gt;.)</source>
          <target state="translated">주소의 네트워크 부분을 반환하여 넷 마스크 오른쪽에있는 항목을 0으로 만듭니다. (이것은 값을 &lt;code&gt;cidr&lt;/code&gt; 로 캐스팅하는 것과 동일합니다 .)</target>
        </trans-unit>
        <trans-unit id="57ef53b6d165d885995f3b10028d69c83d0db19d" translate="yes" xml:space="preserve">
          <source>Returns the number of all-visible pages and the number of all-frozen pages in the relation according to the visibility map.</source>
          <target state="translated">가시성 맵에 따라 모든 표시 가능한 페이지 수와 고정 된 모든 페이지 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aaaeb23434a2778cbe34f93de33770323f19d5ba" translate="yes" xml:space="preserve">
          <source>Returns the number of bytes in the binary string.</source>
          <target state="translated">이진 문자열의 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b4f2318b1974cf3eeac044bd597fa03ec78605e" translate="yes" xml:space="preserve">
          <source>Returns the number of characters in the binary string, assuming that it is text in the given &lt;em&gt;&lt;code&gt;encoding&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">주어진 &lt;em&gt; &lt;code&gt;encoding&lt;/code&gt; &lt;/em&gt; 텍스트라고 가정하고 이진 문자열의 문자 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="917c5974421361361cc95aaec9a7bc9aadb8a03d" translate="yes" xml:space="preserve">
          <source>Returns the number of characters in the string.</source>
          <target state="translated">문자열의 문자 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2521887cc2e17aff56224bf00d2a1f72ed6cdf24" translate="yes" xml:space="preserve">
          <source>Returns the number of dimensions of the array.</source>
          <target state="translated">배열의 차원 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8fb41aa8699f545d0cac9c04bfc05840ff9f808" translate="yes" xml:space="preserve">
          <source>Returns the number of dimensions of the cube.</source>
          <target state="translated">큐브의 차원 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2d4beed58f26f66976d2d26980a8559d762abfa2" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the array.</source>
          <target state="translated">배열의 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="75df8d1c595738e8673e9cf269dfbc2e5a1268cf" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the outermost JSON array.</source>
          <target state="translated">가장 바깥 쪽 JSON 배열의 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="353e4b5f12e1cf23c6f71534387bb8413e995622" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the top-level JSON array.</source>
          <target state="translated">최상위 JSON 배열의 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95679730355f4f0d76f5e43322d6ceb679f82ebd" translate="yes" xml:space="preserve">
          <source>Returns the number of lexemes in the &lt;code&gt;tsvector&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsvector&lt;/code&gt; 에있는 lexemes 의 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1c4da5e2595cc4c0e4a924cb6b4142b2b902ed97" translate="yes" xml:space="preserve">
          <source>Returns the number of lexemes plus operators in the &lt;code&gt;tsquery&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; 에서 lexemes 와 연산자의 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="417683899ad74902fb8d34af73e8fc9b79a96279" translate="yes" xml:space="preserve">
          <source>Returns the number of lexemes stored in the vector.</source>
          <target state="translated">벡터에 저장된 렉스 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a212de166f4305c7d7e8b9d327a9bd5292e26bdd" translate="yes" xml:space="preserve">
          <source>Returns the number of nodes (lexemes plus operators) in a &lt;code&gt;tsquery&lt;/code&gt;. This function is useful to determine if the &lt;code&gt;query&lt;/code&gt; is meaningful (returns &amp;gt; 0), or contains only stop words (returns 0). Examples:</source>
          <target state="translated">&lt;code&gt;tsquery&lt;/code&gt; 에서 노드 수 ( lexemes 와 operator)를 리턴 합니다. 이 함수는 &lt;code&gt;query&lt;/code&gt; 가 의미가 있는지 (&amp;gt; 0을 반환) 또는 중지 단어 만 포함 (0을 반환) 하는지 확인하는 데 유용합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="56bdd78c098f2d0c5348bb6bb6b9d9221652dd41" translate="yes" xml:space="preserve">
          <source>Returns the number of non-null arguments.</source>
          <target state="translated">널이 아닌 인수의 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="34c5ba9f6cae03536b52a58f9b9970a9ec7964b1" translate="yes" xml:space="preserve">
          <source>Returns the number of null arguments.</source>
          <target state="translated">널 인수의 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fec052ef65fffae66a3d3a1d936a9804cedee184" translate="yes" xml:space="preserve">
          <source>Returns the number of points. Available for &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;polygon&lt;/code&gt;.</source>
          <target state="translated">포인트 수를 반환합니다. &lt;code&gt;path&lt;/code&gt; , &lt;code&gt;polygon&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cea22ed08354a1902a554990cb979d0b544c590d" translate="yes" xml:space="preserve">
          <source>Returns the number of the bucket in which &lt;em&gt;&lt;code&gt;operand&lt;/code&gt;&lt;/em&gt; falls given an array listing the lower bounds of the buckets. Returns &lt;code&gt;0&lt;/code&gt; for an input less than the first lower bound. &lt;em&gt;&lt;code&gt;operand&lt;/code&gt;&lt;/em&gt; and the array elements can be of any type having standard comparison operators. The &lt;em&gt;&lt;code&gt;thresholds&lt;/code&gt;&lt;/em&gt; array &lt;em&gt;must be sorted&lt;/em&gt;, smallest first, or unexpected results will be obtained.</source>
          <target state="translated">버킷 의 하한을 나열하는 배열 에서 &lt;em&gt; &lt;code&gt;operand&lt;/code&gt; &lt;/em&gt; 가 속하는 버킷의 수를 반환합니다 . 첫 번째 하한보다 작은 입력에 대해 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다. &lt;em&gt; &lt;code&gt;operand&lt;/code&gt; &lt;/em&gt; 와 배열 요소는 표준 비교 연산자가있는 모든 유형이 될 수 있습니다. &lt;em&gt; &lt;code&gt;thresholds&lt;/code&gt; &lt;/em&gt; 어레이 &lt;em&gt;정렬되어야&lt;/em&gt; 작은 제, 또는 예기치 않은 결과가 얻어진다.</target>
        </trans-unit>
        <trans-unit id="fd72fa2c3ab1d63a049aeb8778869b4d7b094a1a" translate="yes" xml:space="preserve">
          <source>Returns the number of the bucket in which &lt;em&gt;&lt;code&gt;operand&lt;/code&gt;&lt;/em&gt; falls in a histogram having &lt;em&gt;&lt;code&gt;count&lt;/code&gt;&lt;/em&gt; equal-width buckets spanning the range &lt;em&gt;&lt;code&gt;low&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;high&lt;/code&gt;&lt;/em&gt;. Returns &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&lt;em&gt;count&lt;/em&gt;+1&lt;/code&gt; for an input outside that range.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;low&lt;/code&gt; &lt;/em&gt; 범위 에서 &lt;em&gt; &lt;code&gt;high&lt;/code&gt; &lt;/em&gt; 범위에 걸쳐있는 동일한 너비의 버킷 &lt;em&gt; &lt;code&gt;count&lt;/code&gt; &lt;/em&gt; 가있는 히스토그램에 &lt;em&gt; &lt;code&gt;operand&lt;/code&gt; &lt;/em&gt; 가 속하는 버킷의 수를 반환합니다 . 해당 범위를 벗어난 입력에 대해 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;&lt;em&gt;count&lt;/em&gt;+1&lt;/code&gt; +1 을 반환 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d37690fd04e0af625417cc442f59dab0a9b0dedc" translate="yes" xml:space="preserve">
          <source>Returns the number of the current row within its partition, counting from 1.</source>
          <target state="translated">파티션 내 현재 행의 수를 1부터 계산하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="de40164b6179bde0d17fe4d3c55dad4a9734b5c3" translate="yes" xml:space="preserve">
          <source>Returns the numeric code of the first character of the argument. In UTF8 encoding, returns the Unicode code point of the character. In other multibyte encodings, the argument must be an ASCII character.</source>
          <target state="translated">인수의 첫 번째 문자의 숫자 코드를 반환합니다. UTF8 인코딩에서 문자의 유니 코드 코드 포인트를 반환합니다. 다른 멀티 바이트 인코딩에서 인수는 ASCII 문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8d58e2b37a19dce35a48aa0491628e9afed9867f" translate="yes" xml:space="preserve">
          <source>Returns the path name of the log file currently in use by the logging collector. The path includes the &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; directory and the individual log file name. The result is &lt;code&gt;NULL&lt;/code&gt; if the logging collector is disabled. When multiple log files exist, each in a different format, &lt;code&gt;pg_current_logfile&lt;/code&gt; without an argument returns the path of the file having the first format found in the ordered list: &lt;code&gt;stderr&lt;/code&gt;, &lt;code&gt;csvlog&lt;/code&gt;. &lt;code&gt;NULL&lt;/code&gt; is returned if no log file has any of these formats. To request information about a specific log file format, supply either &lt;code&gt;csvlog&lt;/code&gt; or &lt;code&gt;stderr&lt;/code&gt; as the value of the optional parameter. The result is &lt;code&gt;NULL&lt;/code&gt; if the log format requested is not configured in &lt;a href=&quot;runtime-config-logging#GUC-LOG-DESTINATION&quot;&gt;log_destination&lt;/a&gt;. The result reflects the contents of the &lt;code&gt;current_logfiles&lt;/code&gt; file.</source>
          <target state="translated">로깅 수집기에서 현재 사용중인 로그 파일의 경로 이름을 반환합니다. 경로에는 &lt;a href=&quot;runtime-config-logging#GUC-LOG-DIRECTORY&quot;&gt;log_directory&lt;/a&gt; 디렉토리와 개별 로그 파일 이름이 포함됩니다. 로깅 콜렉터가 비활성화 된 경우 결과는 &lt;code&gt;NULL&lt;/code&gt; 입니다. 각각 다른 형식의 여러 로그 파일이있는 경우 &lt;code&gt;pg_current_logfile&lt;/code&gt; 없는 pg_current_logfile 은 정렬 된 목록에서 찾은 첫 번째 형식 인 &lt;code&gt;stderr&lt;/code&gt; , &lt;code&gt;csvlog&lt;/code&gt; 를 갖는 파일의 경로를 반환합니다 . 로그 파일에 이러한 형식이없는 경우 &lt;code&gt;NULL&lt;/code&gt; 이 반환됩니다. 특정 로그 파일 형식에 대한 정보를 요청하려면 선택적 매개 변수의 값으로 &lt;code&gt;csvlog&lt;/code&gt; 또는 &lt;code&gt;stderr&lt;/code&gt; 을 제공하십시오. 결과는 &lt;code&gt;NULL&lt;/code&gt; 입니다.요청 된 로그 형식이 &lt;a href=&quot;runtime-config-logging#GUC-LOG-DESTINATION&quot;&gt;log_destination에&lt;/a&gt; 구성되지 않은 경우 . 결과는 &lt;code&gt;current_logfiles&lt;/code&gt; 파일 의 내용을 반영 합니다.</target>
        </trans-unit>
        <trans-unit id="ef01dcc094cc93fbd12697ddf163c5470c5a3e83" translate="yes" xml:space="preserve">
          <source>Returns the portion of a &lt;code&gt;tsquery&lt;/code&gt; that can be used for searching an index. This function is useful for detecting unindexable queries, for example those containing only stop words or only negated terms. For example:</source>
          <target state="translated">색인을 검색하는 데 사용할 수 있는 &lt;code&gt;tsquery&lt;/code&gt; 부분을 ​​리턴합니다 . 이 기능은 색인을 생성 할 수없는 쿼리 (예 : 중지 단어 만 포함되거나 부정 용어 만 포함)를 검색하는 데 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aec2db3290513f7463eab0eacdbd0f4d091eff36" translate="yes" xml:space="preserve">
          <source>Returns the process ID of the server process attached to the current session.</source>
          <target state="translated">현재 세션에 연결된 서버 프로세스의 프로세스 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d955cff594048c461378162560b20dfc2c2931b8" translate="yes" xml:space="preserve">
          <source>Returns the process ID of this backend.</source>
          <target state="translated">이 백엔드의 프로세스 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d95824a3f1a82f80778aa32733385fc40948a39" translate="yes" xml:space="preserve">
          <source>Returns the range between the two given enum values, as an ordered array. The values must be from the same enum type. If the first parameter is null, the result will start with the first value of the enum type. If the second parameter is null, the result will end with the last value of the enum type.</source>
          <target state="translated">주어진 두 열거 형 값 사이의 범위를 정렬 된 배열로 반환합니다. 값은 동일한 열거 형이어야합니다. 첫 번째 매개 변수가 null이면 결과는 열거 형의 첫 번째 값으로 시작합니다. 두 번째 매개 변수가 null이면 결과는 열거 형의 마지막 값으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="7dfe312bf611eb82e05d80224d0a160fd18b3320" translate="yes" xml:space="preserve">
          <source>Returns the rank of the current row, with gaps; that is, the &lt;code&gt;row_number&lt;/code&gt; of the first row in its peer group.</source>
          <target state="translated">간격이있는 현재 행의 순위를 반환합니다. 즉, 피어 그룹에있는 첫 번째 행 의 &lt;code&gt;row_number&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7d4346a7d1d1859ac47c2e664b47476e4566142" translate="yes" xml:space="preserve">
          <source>Returns the rank of the current row, without gaps; this function effectively counts peer groups.</source>
          <target state="translated">간격없이 현재 행의 순위를 반환합니다. 이 기능은 동료 그룹을 효과적으로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="3c222db0723571d29fed3c9d1b07340b498cb59b" translate="yes" xml:space="preserve">
          <source>Returns the relative rank of the current row, that is (&lt;code&gt;rank&lt;/code&gt; - 1) / (total partition rows - 1). The value thus ranges from 0 to 1 inclusive.</source>
          <target state="translated">현재 행의 상대적 순위, 즉 ( &lt;code&gt;rank&lt;/code&gt; -1) / (총 파티션 행-1)을 반환합니다 . 따라서 값의 범위는 0에서 1까지입니다.</target>
        </trans-unit>
        <trans-unit id="1378e4b2ba9c8c18b985f4cde31026b3da4e45a3" translate="yes" xml:space="preserve">
          <source>Returns the replay location for the given replication origin. The parameter &lt;em&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/em&gt; determines whether the corresponding local transaction will be guaranteed to have been flushed to disk or not.</source>
          <target state="translated">주어진 복제 오리진에 대한 재생 위치를 반환합니다. &lt;em&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/em&gt; 매개 변수 는 해당 로컬 트랜잭션이 디스크로 &lt;em&gt;플러시&lt;/em&gt; 되었는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="9fded5fb8388308c3d013198718cc88446498420" translate="yes" xml:space="preserve">
          <source>Returns the replay location for the replication origin selected in the current session. The parameter &lt;em&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/em&gt; determines whether the corresponding local transaction will be guaranteed to have been flushed to disk or not.</source>
          <target state="translated">현재 세션에서 선택한 복제 오리진의 재생 위치를 반환합니다. &lt;em&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/em&gt; 매개 변수 는 해당 로컬 트랜잭션이 디스크로 &lt;em&gt;플러시&lt;/em&gt; 되었는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="f6660f79eeec147f4684b1b528f25e278c71fe84" translate="yes" xml:space="preserve">
          <source>Returns the result of JSON path predicate check for the specified JSON value. Only the first item of the result is taken into account. If the result is not Boolean, then &lt;code&gt;null&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 JSON 값에 대한 JSON 경로 술어 검사 결과를 리턴합니다. 결과의 첫 번째 항목 만 고려됩니다. 결과가 부울이 아닌 경우 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7de370050985a1b85184ece44bddf88ff757439d" translate="yes" xml:space="preserve">
          <source>Returns the result of a JSON path predicate check for the specified JSON value. Only the first item of the result is taken into account. If the result is not Boolean, then &lt;code&gt;NULL&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 JSON 값에 대한 JSON 경로 조건 자 검사의 결과를 반환합니다. 결과의 첫 번째 항목 만 고려됩니다. 결과가 부울이 아니면 &lt;code&gt;NULL&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e7f2c871989317e3fdbdd04b6e63d5f282bd9c3e" translate="yes" xml:space="preserve">
          <source>Returns the result of a JSON path predicate check for the specified JSON value. Only the first item of the result is taken into account. If the result is not Boolean, then &lt;code&gt;NULL&lt;/code&gt; is returned. The optional &lt;em&gt;&lt;code&gt;vars&lt;/code&gt;&lt;/em&gt; and &lt;em&gt;&lt;code&gt;silent&lt;/code&gt;&lt;/em&gt; arguments act the same as for &lt;code&gt;jsonb_path_exists&lt;/code&gt;.</source>
          <target state="translated">지정된 JSON 값에 대한 JSON 경로 조건 자 검사의 결과를 반환합니다. 결과의 첫 번째 항목 만 고려됩니다. 결과가 부울이 아니면 &lt;code&gt;NULL&lt;/code&gt; 이 반환됩니다. 선택적 &lt;em&gt; &lt;code&gt;vars&lt;/code&gt; &lt;/em&gt; 및 &lt;em&gt; &lt;code&gt;silent&lt;/code&gt; &lt;/em&gt; 인수는 &lt;code&gt;jsonb_path_exists&lt;/code&gt; 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="f57c834bfba36bb8ba15bf423833edfeeab40984" translate="yes" xml:space="preserve">
          <source>Returns the row as a JSON object. Line feeds will be added between level-1 elements if &lt;em&gt;&lt;code&gt;pretty_bool&lt;/code&gt;&lt;/em&gt; is true.</source>
          <target state="translated">행을 JSON 객체로 반환합니다. &lt;em&gt; &lt;code&gt;pretty_bool&lt;/code&gt; &lt;/em&gt; 이 true 인 경우 레벨 1 요소 사이에 줄 바꿈이 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="99dbb84a70b8759dd48243232454be7e25574398" translate="yes" xml:space="preserve">
          <source>Returns the session user's name.</source>
          <target state="translated">세션 사용자의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="79474ed30845c883e7ab8dbf90952cbd91bcf1bb" translate="yes" xml:space="preserve">
          <source>Returns the set of OIDs of databases that have objects stored in the specified tablespace. If this function returns any rows, the tablespace is not empty and cannot be dropped. To identify the specific objects populating the tablespace, you will need to connect to the database(s) identified by &lt;code&gt;pg_tablespace_databases&lt;/code&gt; and query their &lt;code&gt;pg_class&lt;/code&gt; catalogs.</source>
          <target state="translated">지정된 테이블 스페이스에 저장된 개체가있는 데이터베이스의 OID 집합을 반환합니다. 이 함수가 행을 반환하는 경우 테이블 스페이스는 비어 있지 않으며 삭제할 수 없습니다. 테이블 스페이스를 채우는 특정 개체를 식별하려면 &lt;code&gt;pg_tablespace_databases&lt;/code&gt; 로 식별 된 데이터베이스에 연결하고 해당 &lt;code&gt;pg_class&lt;/code&gt; 카탈로그를 쿼리해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c5bb70268a0d96f1c2ec9d10e121d956ccf97893" translate="yes" xml:space="preserve">
          <source>Returns the set of currently active backend ID numbers (from 1 to the number of active backends).</source>
          <target state="translated">현재 활성 백엔드 ID 번호 집합을 반환합니다 (1에서 활성 백엔드 수까지).</target>
        </trans-unit>
        <trans-unit id="296eafd9df7df5eff39f88f043ef5a3649bef0fe" translate="yes" xml:space="preserve">
          <source>Returns the set of in-progress transaction IDs contained in a snapshot.</source>
          <target state="translated">스냅 샷에 포함 된 진행중인 트랜잭션 ID 집합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f43507f8fd5fafbc2bbba06196cc43d60f663f82" translate="yes" xml:space="preserve">
          <source>Returns the set of keys in the top-level JSON object.</source>
          <target state="translated">최상위 JSON 개체의 키 집합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="829f21775daf0c47b43b92c7d844d288c6cda7cb" translate="yes" xml:space="preserve">
          <source>Returns the set of names of asynchronous notification channels that the current session is listening to.</source>
          <target state="translated">현재 세션이 수신하는 비동기 알림 채널의 이름 집합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="271907378902c95ccca9adba2a368b65fb877f69" translate="yes" xml:space="preserve">
          <source>Returns the set of storage options represented by a value from &lt;code&gt;pg_class&lt;/code&gt;.&lt;code&gt;reloptions&lt;/code&gt; or &lt;code&gt;pg_attribute&lt;/code&gt;.&lt;code&gt;attoptions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_class&lt;/code&gt; 의 값으로 표시되는 스토리지 옵션 세트를 반환합니다 . &lt;code&gt;reloptions&lt;/code&gt; 또는 &lt;code&gt;pg_attribute&lt;/code&gt; . &lt;code&gt;attoptions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a96126b32b5abdeaf086b30fc1f4efe4eed8e4d" translate="yes" xml:space="preserve">
          <source>Returns the start time of the current on-line exclusive backup if one is in progress, otherwise &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">진행중인 경우 현재 온라인 배타적 백업의 시작 시간을 반환하고 그렇지 않으면 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="508a1a4f41021748419ac1c1945bf023af665134" translate="yes" xml:space="preserve">
          <source>Returns the subscript of the first occurrence of the second argument in the array, or &lt;code id=&quot;null&quot;&gt;NULL&lt;/code&gt; if it's not present. If the third argument is given, the search begins at that subscript. The array must be one-dimensional. Comparisons are done using &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; semantics, so it is possible to search for &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">배열에서 두 번째 인수의 첫 번째 발생의 첨자를 반환하거나 없는 경우 &lt;code id=&quot;null&quot;&gt;NULL&lt;/code&gt; 을 반환합니다. 세 번째 인수가 제공되면 해당 첨자에서 검색이 시작됩니다. 배열은 1 차원이어야합니다. 비교는 &lt;code&gt;IS NOT DISTINCT FROM&lt;/code&gt; 의미론을 사용하여 수행 되므로 &lt;code&gt;NULL&lt;/code&gt; 검색이 가능 합니다 .</target>
        </trans-unit>
        <trans-unit id="e1d3f5a2af1d85ccbc31e9015c67feb931aba2d3" translate="yes" xml:space="preserve">
          <source>Returns the text of the currently executing query, as submitted by the client (which might contain more than one statement).</source>
          <target state="translated">클라이언트가 제출 한대로 현재 실행중인 쿼리의 텍스트를 반환합니다 (둘 이상의 문을 포함 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="5bc6d34502800e1c17fa298fe4e6818420a6df9a" translate="yes" xml:space="preserve">
          <source>Returns the text of this backend's most recent query.</source>
          <target state="translated">이 백엔드의 가장 최근 쿼리 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f69dadaf1969a73e954d447e293c3787a16ff8d2" translate="yes" xml:space="preserve">
          <source>Returns the time stamp of the last transaction replayed during recovery. This is the time at which the commit or abort WAL record for that transaction was generated on the primary. If no transactions have been replayed during recovery, the function returns &lt;code&gt;NULL&lt;/code&gt;. Otherwise, if recovery is still in progress this will increase monotonically. If recovery has completed then this will remain static at the time of the last transaction applied during recovery. When the server has been started normally without recovery, the function returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">복구 중에 재생 된 마지막 트랜잭션의 타임 스탬프를 반환합니다. 이것은 해당 트랜잭션에 대한 커밋 또는 중단 WAL 레코드가 기본에서 생성 된 시간입니다. 복구 중에 트랜잭션이 재생되지 않은 경우 함수는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 그렇지 않으면 복구가 아직 진행 중이면 단조롭게 증가합니다. 복구가 완료되면 복구 중 마지막 트랜잭션이 적용된 시점에 고정 상태로 유지됩니다. 서버가 복구없이 정상적으로 시작되면 함수는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="8e6f498c945498320f7da27722706326255aad6c" translate="yes" xml:space="preserve">
          <source>Returns the time when the backend's current transaction was started.</source>
          <target state="translated">백엔드의 현재 트랜잭션이 시작된 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a552f48ad6ce22dc5c85a66d64b895e2520a769d" translate="yes" xml:space="preserve">
          <source>Returns the time when the backend's most recent query was started.</source>
          <target state="translated">백엔드의 가장 최근 쿼리가 시작된 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9681622fc3d42e2d292084c6471c0aa2ae3fdb4a" translate="yes" xml:space="preserve">
          <source>Returns the time when the server configuration files were last loaded. If the current session was alive at the time, this will be the time when the session itself re-read the configuration files (so the reading will vary a little in different sessions). Otherwise it is the time when the postmaster process re-read the configuration files.</source>
          <target state="translated">서버 구성 파일이 마지막으로로드 된 시간을 반환합니다. 현재 세션이 활성 상태 였다면 세션 자체가 구성 파일을 다시 읽는 시간이됩니다 (따라서 읽기는 세션마다 약간 씩 다릅니다). 그렇지 않으면 포스트 마스터 프로세스가 구성 파일을 다시 읽을 때입니다.</target>
        </trans-unit>
        <trans-unit id="56e16d95039b10dc2bb7e7cb75638475517e669e" translate="yes" xml:space="preserve">
          <source>Returns the time when the server started.</source>
          <target state="translated">서버가 시작된 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="59a9a0fb7063919cff89f7fd7bfc3af3b4a1bb57" translate="yes" xml:space="preserve">
          <source>Returns the time when this process was started.</source>
          <target state="translated">이 프로세스가 시작된 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="267da4976346f49097371b8fcc3114a7bceac6e9" translate="yes" xml:space="preserve">
          <source>Returns the timestamp of the current statistics snapshot</source>
          <target state="translated">현재 통계 스냅 샷의 타임 스탬프를 반환합니다</target>
        </trans-unit>
        <trans-unit id="278b5c4f957c4bde23e9f382d03f136a22496eeb" translate="yes" xml:space="preserve">
          <source>Returns the timestamp of the current statistics snapshot.</source>
          <target state="translated">현재 통계 스냅 샷의 타임 스탬프를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3f5baf29f6038bd336773c01e3884ba3963986d4" translate="yes" xml:space="preserve">
          <source>Returns the top-most parent of the partition tree to which the given relation belongs. Returns &lt;code&gt;NULL&lt;/code&gt; if the relation does not exist or is not a partition or partitioned table.</source>
          <target state="translated">주어진 관계가 속한 파티션 트리의 최상위 부모를 반환합니다. 관계가 존재하지 않거나 파티션 또는 파티션 된 테이블이 아닌 경우 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="43bb640227519bfd3bf19a42ab5d9bea80dbe724" translate="yes" xml:space="preserve">
          <source>Returns the total number of elements in the array, or 0 if the array is empty.</source>
          <target state="translated">배열의 총 요소 수를 반환하거나 배열이 비어있는 경우 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3bcb43017234ee30feec1332c4c8f0866a813a75" translate="yes" xml:space="preserve">
          <source>Returns the transaction ID and commit timestamp of the latest committed transaction.</source>
          <target state="translated">최근 커밋 된 트랜잭션의 트랜잭션 ID 및 커밋 타임 스탬프를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4763586ac2cee79326f4d7cf5064c57368486f65" translate="yes" xml:space="preserve">
          <source>Returns the type of the outermost JSON value as a text string. Possible types are &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;array&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, and &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">가장 바깥 쪽 JSON 값의 유형을 텍스트 문자열로 반환합니다. 가능한 유형은 &lt;code&gt;object&lt;/code&gt; , &lt;code&gt;array&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8f814a86a9c0cb5ef4e429c985c1a2c544212b55" translate="yes" xml:space="preserve">
          <source>Returns the type of the top-level JSON value as a text string. Possible types are &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;array&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, and &lt;code&gt;null&lt;/code&gt;. (The &lt;code&gt;null&lt;/code&gt; result should not be confused with a SQL NULL; see the examples.)</source>
          <target state="translated">최상위 JSON 값의 유형을 텍스트 문자열로 반환합니다. 가능한 유형은 &lt;code&gt;object&lt;/code&gt; , &lt;code&gt;array&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; 입니다. ( &lt;code&gt;null&lt;/code&gt; 결과를 SQL NULL과 혼동해서는 안됩니다. 예를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="51ccfbac28e07386a38b5a255edfa9e4e42f8cce" translate="yes" xml:space="preserve">
          <source>Returns the unabbreviated IP address and netmask length as text. (This has the same result as an explicit cast to &lt;code&gt;text&lt;/code&gt;.)</source>
          <target state="translated">축약되지 않은 IP 주소와 넷 마스크 길이를 텍스트로 반환합니다. (이것은 명시적인 &lt;code&gt;text&lt;/code&gt; 캐스트와 동일한 결과를 갖습니다 .)</target>
        </trans-unit>
        <trans-unit id="31d1438666257c3bcab132e0f68f1e71cceac834" translate="yes" xml:space="preserve">
          <source>Returns the upper bound of the requested array dimension.</source>
          <target state="translated">요청 된 배열 차원의 상한을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed4493686731d1ffafb3736a96578beb603de3e8" translate="yes" xml:space="preserve">
          <source>Returns the user name of the current execution context.</source>
          <target state="translated">현재 실행 컨텍스트의 사용자 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="11bd45e92996808c1fe1b83fd3205581620fd400" translate="yes" xml:space="preserve">
          <source>Returns the value as &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt;. Arrays and composites are converted (recursively) to arrays and objects; otherwise, if there is a cast from the type to &lt;code&gt;json&lt;/code&gt;, the cast function will be used to perform the conversion; otherwise, a scalar value is produced. For any scalar type other than a number, a Boolean, or a null value, the text representation will be used, in such a fashion that it is a valid &lt;code&gt;json&lt;/code&gt; or &lt;code&gt;jsonb&lt;/code&gt; value.</source>
          <target state="translated">값을 &lt;code&gt;json&lt;/code&gt; 또는 &lt;code&gt;jsonb&lt;/code&gt; 로 리턴합니다 . 배열과 합성물은 (재귀 적으로) 배열과 객체로 변환됩니다. 그렇지 않으면, 유형에서 &lt;code&gt;json&lt;/code&gt; 으로 캐스트 된 경우 캐스트 함수를 사용하여 변환을 수행합니다. 그렇지 않으면 스칼라 값이 생성됩니다. 숫자, 부울 또는 널값 이외의 스칼라 유형의 경우 유효한 &lt;code&gt;json&lt;/code&gt; 또는 &lt;code&gt;jsonb&lt;/code&gt; 값 과 같은 방식으로 텍스트 표시가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="badeab9fdba2e6b79b0a9bf9e5660f2ad204368b" translate="yes" xml:space="preserve">
          <source>Returns the value most recently obtained by &lt;code&gt;nextval&lt;/code&gt; for this sequence in the current session. (An error is reported if &lt;code&gt;nextval&lt;/code&gt; has never been called for this sequence in this session.) Because this is returning a session-local value, it gives a predictable answer whether or not other sessions have executed &lt;code&gt;nextval&lt;/code&gt; since the current session did.</source>
          <target state="translated">현재 세션에서이 시퀀스에 대해 &lt;code&gt;nextval&lt;/code&gt; 에서 가장 최근에 얻은 값을 반환합니다 . ( 이 세션에서이 시퀀스에 대해 &lt;code&gt;nextval&lt;/code&gt; 이 호출되지 않은 경우 오류가보고됩니다 .) 이것은 세션 로컬 값을 반환하기 때문에 현재 세션이 수행 한 이후 다른 세션이 &lt;code&gt;nextval&lt;/code&gt; 을 실행했는지 여부에 대한 예측 가능한 응답을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e3b60c341ffdcf7e62c09c3dbd25ec5733b888f0" translate="yes" xml:space="preserve">
          <source>Returns the value most recently returned by &lt;code&gt;nextval&lt;/code&gt; in the current session. This function is identical to &lt;code&gt;currval&lt;/code&gt;, except that instead of taking the sequence name as an argument it refers to whichever sequence &lt;code&gt;nextval&lt;/code&gt; was most recently applied to in the current session. It is an error to call &lt;code&gt;lastval&lt;/code&gt; if &lt;code&gt;nextval&lt;/code&gt; has not yet been called in the current session.</source>
          <target state="translated">현재 세션에서 &lt;code&gt;nextval&lt;/code&gt; 이 가장 최근에 반환 한 값을 반환합니다 . 이 함수는 시퀀스 이름을 인수로 사용하는 대신 현재 세션에서 가장 최근에 적용된 시퀀스 &lt;code&gt;nextval&lt;/code&gt; 을 참조한다는 점을 제외하고 &lt;code&gt;currval&lt;/code&gt; 과 동일합니다 . 현재 세션에서 &lt;code&gt;nextval&lt;/code&gt; 이 아직 호출되지 않은 경우 &lt;code&gt;lastval&lt;/code&gt; 을 호출하는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="1d33240cb7cee67e63963e9326d0bb76b61a23f2" translate="yes" xml:space="preserve">
          <source>Returns the wait event name if this backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;Table 27.5&lt;/a&gt; through &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;Table 27.13&lt;/a&gt;.</source>
          <target state="translated">이 백엔드가 현재 대기 중이면 대기 이벤트 이름을 반환하고, 그렇지 않으면 NULL을 반환합니다. &lt;a href=&quot;monitoring-stats#WAIT-EVENT-ACTIVITY-TABLE&quot;&gt;표 27.5&lt;/a&gt; ~ &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TIMEOUT-TABLE&quot;&gt;표 27.13을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fe67a07e57517cdc87e4edce1121d57bbc0907a" translate="yes" xml:space="preserve">
          <source>Returns the wait event type name if this backend is currently waiting, otherwise NULL. See &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;Table 27.4&lt;/a&gt; for details.</source>
          <target state="translated">이 백엔드가 현재 대기 중이면 대기 이벤트 유형 이름을 반환하고, 그렇지 않으면 NULL을 반환합니다. 자세한 내용은 &lt;a href=&quot;monitoring-stats#WAIT-EVENT-TABLE&quot;&gt;표 27.4&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="217bfb657ace163b79b3fb7198a40e6eb7a74f59" translate="yes" xml:space="preserve">
          <source>Returns true if &lt;em&gt;&lt;code&gt;string&lt;/code&gt;&lt;/em&gt; starts with &lt;em&gt;&lt;code&gt;prefix&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;string&lt;/code&gt; &lt;/em&gt; 이 &lt;em&gt; &lt;code&gt;prefix&lt;/code&gt; 로&lt;/em&gt; 시작 하면 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8019e612e288e3113ce3f40ad0a5e5971e725eb1" translate="yes" xml:space="preserve">
          <source>Returns true if a JIT compiler extension is available (see &lt;a href=&quot;https://www.postgresql.org/docs/13/jit.html&quot;&gt;Chapter 31&lt;/a&gt;) and the &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; configuration parameter is set to &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">JIT 컴파일러 확장을 사용할 수 있고 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/jit.html&quot;&gt;31 장&lt;/a&gt; 참조 ) &lt;a href=&quot;runtime-config-query#GUC-JIT&quot;&gt;jit&lt;/a&gt; 구성 매개 변수가 &lt;code&gt;on&lt;/code&gt; 으로 설정된 경우 true를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ce75e337af091484d9c810cd4e05e56fcb324043" translate="yes" xml:space="preserve">
          <source>Returns true if a leaf tuple satisfies a query.</source>
          <target state="translated">리프 튜플이 쿼리를 만족하면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa8550eef7c87deaef340339f6f59b2a4ae0a2a7" translate="yes" xml:space="preserve">
          <source>Returns true if a replication origin has been selected in the current session.</source>
          <target state="translated">현재 세션에서 복제 오리진이 선택된 경우 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9c89b6d31ccb486daeffe98b9e39269d9d020b4d" translate="yes" xml:space="preserve">
          <source>Returns true if all non-null input values are true, otherwise false.</source>
          <target state="translated">null이 아닌 모든 입력 값이 true이면 true를 반환하고 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4251595d61752b7c49d562b79f49882d84bf3788" translate="yes" xml:space="preserve">
          <source>Returns true if an indexed item satisfies the query operator with strategy number &lt;code&gt;n&lt;/code&gt; (or might satisfy it, if the recheck indication is returned). This function does not have direct access to the indexed item's value, since GIN does not store items explicitly. Rather, what is available is knowledge about which key values extracted from the query appear in a given indexed item. The &lt;code&gt;check&lt;/code&gt; array has length &lt;code&gt;nkeys&lt;/code&gt;, which is the same as the number of keys previously returned by &lt;code&gt;extractQuery&lt;/code&gt; for this &lt;code&gt;query&lt;/code&gt; datum. Each element of the &lt;code&gt;check&lt;/code&gt; array is true if the indexed item contains the corresponding query key, i.e., if (check[i] == true) the i-th key of the &lt;code&gt;extractQuery&lt;/code&gt; result array is present in the indexed item. The original &lt;code&gt;query&lt;/code&gt; datum is passed in case the &lt;code&gt;consistent&lt;/code&gt; method needs to consult it, and so are the &lt;code&gt;queryKeys[]&lt;/code&gt; and &lt;code&gt;nullFlags[]&lt;/code&gt; arrays previously returned by &lt;code&gt;extractQuery&lt;/code&gt;. &lt;code&gt;extra_data&lt;/code&gt; is the extra-data array returned by &lt;code&gt;extractQuery&lt;/code&gt;, or &lt;code&gt;NULL&lt;/code&gt; if none.</source>
          <target state="translated">인덱싱 된 항목이 전략 번호 &lt;code&gt;n&lt;/code&gt; 인 쿼리 연산자를 충족 시키거나 다시 확인 표시가 반환되면이를 충족시킬 수 있으면 true를 반환합니다 . GIN은 명시 적으로 항목을 저장하지 않기 때문에이 함수는 색인화 된 항목 값에 직접 액세스 할 수 없습니다. 대신, 사용 가능한 것은 쿼리에서 추출 된 키 값이 주어진 인덱스 항목에 나타나는지에 대한 지식입니다. &lt;code&gt;check&lt;/code&gt; 배열 길이 갖는다 &lt;code&gt;nkeys&lt;/code&gt; 이전 의해 리턴 키의 개수와 동일 &lt;code&gt;extractQuery&lt;/code&gt; 이것을 &lt;code&gt;query&lt;/code&gt; 데이텀. 인덱스 된 항목에 해당 쿼리 키가 포함되어 있으면 (예 : &lt;code&gt;extractQuery&lt;/code&gt; 의 i 번째 키인 경우 (check [i] == true)) &lt;code&gt;check&lt;/code&gt; 배열 의 각 요소 는 true입니다.인덱싱 된 항목에 결과 배열이 있습니다. &lt;code&gt;consistent&lt;/code&gt; 메소드가 참조해야 할 경우를 위해 원래 &lt;code&gt;query&lt;/code&gt; 데이텀이 전달 되며, &lt;code&gt;queryKeys[]&lt;/code&gt; 이전에 리턴 한 &lt;code&gt;extractQuery&lt;/code&gt; [] 및 &lt;code&gt;nullFlags[]&lt;/code&gt; 배열도 마찬가지 입니다. &lt;code&gt;extra_data&lt;/code&gt; 는 extractQuery 가 반환 한 여분의 데이터 배열 &lt;code&gt;extractQuery&lt;/code&gt; , 없으면 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e20efff1a025ddb44dbcdc398424024855c6bcf" translate="yes" xml:space="preserve">
          <source>Returns true if an on-line exclusive backup is in progress.</source>
          <target state="translated">온라인 독점 백업이 진행중인 경우 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd8d42c0c6dcc3abc0e58615d84d07d344740c44" translate="yes" xml:space="preserve">
          <source>Returns true if any non-null input value is true, otherwise false.</source>
          <target state="translated">null이 아닌 입력 값이 true이면 true를 반환하고 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8cbe1dec3539cdca4938e0349b6f66f881ddbc4e" translate="yes" xml:space="preserve">
          <source>Returns true if current client has presented a valid SSL client certificate to the server, and false otherwise. (The server might or might not be configured to require a client certificate.)</source>
          <target state="translated">현재 클라이언트가 서버에 유효한 SSL 클라이언트 인증서를 제공 한 경우 true를, 그렇지 않으면 false를 반환합니다. 서버는 클라이언트 인증서를 요구하도록 구성되거나 구성되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7500349575d0e3f503a55711c0e5c31d767de6ec" translate="yes" xml:space="preserve">
          <source>Returns true if current connection to server uses SSL, and false otherwise.</source>
          <target state="translated">서버에 대한 현재 연결에서 SSL을 사용하면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="50d4c5926149b02572c17f380bc3298f7567bd3b" translate="yes" xml:space="preserve">
          <source>Returns true if recovery is paused.</source>
          <target state="translated">복구가 일시 중지 된 경우 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ff1a5bc31fed2c02ed95cc4eb2feb7274c741d4" translate="yes" xml:space="preserve">
          <source>Returns true if recovery is still in progress.</source>
          <target state="translated">복구가 아직 진행중인 경우 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5bc21ccfc844291339f09373a7c81202eef66f69" translate="yes" xml:space="preserve">
          <source>Returns true if the cube is a point, that is, the two defining corners are the same.</source>
          <target state="translated">큐브가 점, 즉 두 정의 모서리가 동일한 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f5462e0783b551c7dd942b0c1fd847e768e3b52d" translate="yes" xml:space="preserve">
          <source>Returns true if the given OID is the OID of another session's temporary schema. (This can be useful, for example, to exclude other sessions' temporary tables from a catalog display.)</source>
          <target state="translated">주어진 OID가 다른 세션의 임시 스키마의 OID이면 true를 반환합니다. (예를 들어, 카탈로그 디스플레이에서 다른 세션의 임시 테이블을 제외하는 데 유용 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="be4aa2ed56eaef039697a872f548c395d7c2cc2a" translate="yes" xml:space="preserve">
          <source>Returns true if two index entries are identical, false otherwise. (An &amp;ldquo;index entry&amp;rdquo; is a value of the index's storage type, not necessarily the original indexed column's type.)</source>
          <target state="translated">두 개의 인덱스 항목이 동일한 경우 true를, 그렇지 않으면 false를 반환합니다. &quot;인덱스 항목&quot;은 인덱스의 저장 유형 값이며 반드시 원래의 인덱스 열 유형은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3e52cfee49201aac3cf35591a0208cf277e0e987" translate="yes" xml:space="preserve">
          <source>Returns value associated with given key, or &lt;code&gt;NULL&lt;/code&gt; if not present.</source>
          <target state="translated">주어진 키와 관련된 값을 반환하거나 없는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="78089cb5b93d380d1833e2c458bfc7a8823c2852" translate="yes" xml:space="preserve">
          <source>Returns values associated with given keys, or &lt;code&gt;NULL&lt;/code&gt; if not present.</source>
          <target state="translated">주어진 키와 관련된 값을 반환하거나 없는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d92b40b8a8cb821d7fa3d23e392e9b9ca5992b32" translate="yes" xml:space="preserve">
          <source>Returns whether the ScanKey is consistent with the given indexed values for a range. The attribute number to use is passed as part of the scan key.</source>
          <target state="translated">ScanKey가 범위에 대해 주어진 색인 값과 일치하는지 여부를 반환합니다. 사용할 속성 번호는 스캔 키의 일부로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ae78db6a826e24f88d0917b830b0185f0e919938" translate="yes" xml:space="preserve">
          <source>Reverses the order of the characters in the string.</source>
          <target state="translated">문자열의 문자 순서를 반대로합니다.</target>
        </trans-unit>
        <trans-unit id="0be720759ff04d13c5706881d5d227a2621f91a6" translate="yes" xml:space="preserve">
          <source>Revoke</source>
          <target state="translated">Revoke</target>
        </trans-unit>
        <trans-unit id="e3fe0cd14154a3767505b0d3be7715d57f2e5254" translate="yes" xml:space="preserve">
          <source>Revoke all privileges from user &lt;code&gt;manuel&lt;/code&gt; on view &lt;code&gt;kinds&lt;/code&gt;:</source>
          <target state="translated">보기 &lt;code&gt;kinds&lt;/code&gt; 에 대해 사용자 &lt;code&gt;manuel&lt;/code&gt; 의 모든 권한을 취소하십시오 .</target>
        </trans-unit>
        <trans-unit id="35e6e9cec307502c52713b2eecb56bef27c61f41" translate="yes" xml:space="preserve">
          <source>Revoke insert privilege for the public on table &lt;code&gt;films&lt;/code&gt;:</source>
          <target state="translated">테이블 &lt;code&gt;films&lt;/code&gt; 에서 일반인에 대한 삽입 권한 취소 :</target>
        </trans-unit>
        <trans-unit id="7a5f4d52d4dd8cc3afa62b0a3067968b8fdaad6e" translate="yes" xml:space="preserve">
          <source>Revoke membership in role &lt;code&gt;admins&lt;/code&gt; from user &lt;code&gt;joe&lt;/code&gt;:</source>
          <target state="translated">역할의 멤버 취소 &lt;code&gt;admins&lt;/code&gt; 사용자로부터 &lt;code&gt;joe&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6248970f19f2f6c9f9a1fc432a48fcc10df598e3" translate="yes" xml:space="preserve">
          <source>Rewriting can be slow when there are many rewriting rules, since it checks every rule for a possible match. To filter out obvious non-candidate rules we can use the containment operators for the &lt;code&gt;tsquery&lt;/code&gt; type. In the example below, we select only those rules which might match the original query:</source>
          <target state="translated">다시 쓰기 규칙이 많은 경우 다시 쓰기 속도가 느려질 수 있습니다. 가능한 규칙이 있는지 모든 규칙을 검사하기 때문입니다. 명백한 비 후보 규칙을 필터링하기 위해 &lt;code&gt;tsquery&lt;/code&gt; 유형에 대해 포함 연산자를 사용할 수 있습니다 . 아래 예에서는 원래 쿼리와 일치 할 수있는 규칙 만 선택합니다.</target>
        </trans-unit>
        <trans-unit id="2b5c3d2df469cdad1d1980603060435a26bf3190" translate="yes" xml:space="preserve">
          <source>Right Operand Type</source>
          <target state="translated">오른쪽 피연산자 유형</target>
        </trans-unit>
        <trans-unit id="d800d962cbbcc7a3babf7587a3adc23b1854d8df" translate="yes" xml:space="preserve">
          <source>Right unary, also called postfix, operators are deprecated and will be removed in PostgreSQL version 14.</source>
          <target state="translated">postfix라고도하는 오른쪽 단항 연산자는 더 이상 사용되지 않으며 PostgreSQL 버전 14에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="fbb823098e08f37230332f6252057ac4669316b7" translate="yes" xml:space="preserve">
          <source>Right-hand input data type of associated operator</source>
          <target state="translated">관련 연산자의 오른손 입력 데이터 유형</target>
        </trans-unit>
        <trans-unit id="f59d88d1847754a88addf790048ccac612afccf3" translate="yes" xml:space="preserve">
          <source>Right-hand input data type of operator</source>
          <target state="translated">연산자의 오른손 입력 데이터 유형</target>
        </trans-unit>
        <trans-unit id="c019f3e6ea125cc861fc5ef94a849aacd396c74d" translate="yes" xml:space="preserve">
          <source>Rijndael cipher</source>
          <target state="translated">Rijndael 암호</target>
        </trans-unit>
        <trans-unit id="55860be98c63406b5191317990ab4ff698425494" translate="yes" xml:space="preserve">
          <source>Robert Haas &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:rhaas@postgresql.org&quot;&gt;rhaas@postgresql.org&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">로버트 하스 &lt;code&gt;&amp;lt;&lt;a href=&quot;mailto:rhaas@postgresql.org&quot;&gt;rhaas@postgresql.org&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c3f104d1365744b538bfde9f4adb6a6df4b80355" translate="yes" xml:space="preserve">
          <source>Role</source>
          <target state="translated">Role</target>
        </trans-unit>
        <trans-unit id="eb6e98d5428e19f460eca55972b5be21db84a627" translate="yes" xml:space="preserve">
          <source>Role Attributes</source>
          <target state="translated">역할 속성</target>
        </trans-unit>
        <trans-unit id="55d928292e0ac1823705341e38908e9270209175" translate="yes" xml:space="preserve">
          <source>Role Membership</source>
          <target state="translated">역할 멤버십</target>
        </trans-unit>
        <trans-unit id="997aba76f087a6bc1ce552e91893ce39e11e4d3a" translate="yes" xml:space="preserve">
          <source>Role automatically inherits privileges of roles it is a member of</source>
          <target state="translated">역할은 구성원 인 역할의 권한을 자동으로 상속합니다.</target>
        </trans-unit>
        <trans-unit id="ff36769e4a00d50f0802e283044405aa6c9a0c69" translate="yes" xml:space="preserve">
          <source>Role bypasses every row level security policy, see &lt;a href=&quot;ddl-rowsecurity&quot;&gt;Section 5.8&lt;/a&gt; for more information.</source>
          <target state="translated">역할은 모든 행 수준 보안 정책을 무시합니다 . 자세한 내용 은 &lt;a href=&quot;ddl-rowsecurity&quot;&gt;섹션 5.8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="afc7a51f03b0a0fc9190f9d14ce83ffe49cd85ea" translate="yes" xml:space="preserve">
          <source>Role can create databases</source>
          <target state="translated">역할은 데이터베이스를 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0196ff58ec5fe921f810cd3c3cb4c4b55c84e6e0" translate="yes" xml:space="preserve">
          <source>Role can create more roles</source>
          <target state="translated">역할은 더 많은 역할을 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="93dbe5db61333f7ddf3bd92c4ed7fe8b19455560" translate="yes" xml:space="preserve">
          <source>Role can log in. That is, this role can be given as the initial session authorization identifier</source>
          <target state="translated">역할은 로그인 할 수 있습니다. 즉,이 역할은 초기 세션 권한 부여 식별자로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39fb3e11561f61e9f68e84907acdc21a8e910555" translate="yes" xml:space="preserve">
          <source>Role can log in. That is, this role can be given as the initial session authorization identifier.</source>
          <target state="translated">역할은 로그인 할 수 있습니다. 즉,이 역할은 초기 세션 권한 부여 식별자로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e11ef76ad0b2bec45a6b65ff3706a08d5e931d24" translate="yes" xml:space="preserve">
          <source>Role has superuser privileges</source>
          <target state="translated">역할에는 수퍼 유저 권한이 있습니다</target>
        </trans-unit>
        <trans-unit id="d87b5b57ae4546f3b619c8a4534f225b1b24c815" translate="yes" xml:space="preserve">
          <source>Role is a replication role. A replication role can initiate replication connections and create and drop replication slots.</source>
          <target state="translated">역할은 복제 역할입니다. 복제 역할은 복제 연결을 시작하고 복제 슬롯을 생성 및 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4204d818543e404ab9954ff39126b09abf1c29d0" translate="yes" xml:space="preserve">
          <source>Role name</source>
          <target state="translated">역할 이름</target>
        </trans-unit>
        <trans-unit id="cf9a1d977579931f3d09d8923cfd993412eb28f6" translate="yes" xml:space="preserve">
          <source>Role-specific defaults for run-time configuration variables</source>
          <target state="translated">런타임 구성 변수에 대한 역할 별 기본값</target>
        </trans-unit>
        <trans-unit id="2881883464f348ff298e08348bc67564e1c59e1c" translate="yes" xml:space="preserve">
          <source>Role-specific variable settings take effect only at login; &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; and &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt; do not process role-specific variable settings.</source>
          <target state="translated">역할 별 변수 설정은 로그인시에만 적용됩니다. &lt;a href=&quot;sql-set-role&quot;&gt;SET ROLE&lt;/a&gt; 및 &lt;a href=&quot;sql-set-session-authorization&quot;&gt;SET SESSION AUTHORIZATION&lt;/a&gt; 은 역할 별 변수 설정을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5485ed95782ed384efb35eb2b43dbe52dfe42fdb" translate="yes" xml:space="preserve">
          <source>Roll back all commands that were executed after the savepoint was established. The savepoint remains valid and can be rolled back to again later, if needed.</source>
          <target state="translated">세이브 포인트가 설정된 후 실행 된 모든 명령을 롤백하십시오. 저장 점은 계속 유효하며 필요한 경우 나중에 다시 롤백 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a49833a3786b82b90ad4a045732bd530907fbaf6" translate="yes" xml:space="preserve">
          <source>Roll back the transaction identified by the transaction identifier &lt;code&gt;foobar&lt;/code&gt;:</source>
          <target state="translated">트랜잭션 식별자 &lt;code&gt;foobar&lt;/code&gt; 로 식별 된 트랜잭션을 롤백하십시오 .</target>
        </trans-unit>
        <trans-unit id="f28daee2c0f5b7710d2e3058da131e8e57520725" translate="yes" xml:space="preserve">
          <source>Rollback</source>
          <target state="translated">Rollback</target>
        </trans-unit>
        <trans-unit id="576aa9e54d679a1374299fe11109f95cb12af924" translate="yes" xml:space="preserve">
          <source>Roman numeral (input between 1 and 3999)</source>
          <target state="translated">로마 숫자 (1 ~ 3999 입력)</target>
        </trans-unit>
        <trans-unit id="cfd5233f6c25112a7ae3ff91e4acc195f899f25f" translate="yes" xml:space="preserve">
          <source>Romanian</source>
          <target state="translated">Romanian</target>
        </trans-unit>
        <trans-unit id="c7203941830e6b8852fc805973ff9909ff84f94b" translate="yes" xml:space="preserve">
          <source>Root DN to begin the search for the user in, when doing search+bind authentication.</source>
          <target state="translated">검색 + 바인드 인증을 수행 할 때 사용자 검색을 시작하는 루트 DN</target>
        </trans-unit>
        <trans-unit id="7472b9a144ec4caefdca4a82b485ab6edf88295b" translate="yes" xml:space="preserve">
          <source>Root collation with Emoji collation type, per Unicode Technical Standard #51</source>
          <target state="translated">유니 코드 기술 표준 # 51에 따라 Emoji 데이터 정렬 유형을 사용한 루트 데이터 정렬</target>
        </trans-unit>
        <trans-unit id="ba7af3578b294f6862af1a9c16afae26053c954a" translate="yes" xml:space="preserve">
          <source>Rotate server's log file</source>
          <target state="translated">서버의 로그 파일 회전</target>
        </trans-unit>
        <trans-unit id="2ac88f695137bc1c2c7268a54484b0753270fe65" translate="yes" xml:space="preserve">
          <source>Rounds &lt;em&gt;&lt;code&gt;v&lt;/code&gt;&lt;/em&gt; to &lt;em&gt;&lt;code&gt;s&lt;/code&gt;&lt;/em&gt; decimal places</source>
          <target state="translated">라운드는 &lt;em&gt; &lt;code&gt;v&lt;/code&gt; 에&lt;/em&gt; 로 &lt;em&gt; &lt;code&gt;s&lt;/code&gt; &lt;/em&gt; 소수점을</target>
        </trans-unit>
        <trans-unit id="e120b7188abc6c91dffc1e28136b64e8c6939e10" translate="yes" xml:space="preserve">
          <source>Rounds to nearest integer</source>
          <target state="translated">가장 가까운 정수로 반올림</target>
        </trans-unit>
        <trans-unit id="482273d7cc992a5c71daf517415b1b66b8f9b73c" translate="yes" xml:space="preserve">
          <source>Routine</source>
          <target state="translated">Routine</target>
        </trans-unit>
        <trans-unit id="750b890208d6dc8fee2d5800870cd4ee2d53a68e" translate="yes" xml:space="preserve">
          <source>Routine Reindexing</source>
          <target state="translated">일상적인 재색 인</target>
        </trans-unit>
        <trans-unit id="b9120cda3b64845a5c22f996c01888cde5b6ea9c" translate="yes" xml:space="preserve">
          <source>Routine Vacuuming</source>
          <target state="translated">일상적인 진공 청소</target>
        </trans-unit>
        <trans-unit id="9bf7a8e8909bfd491b38561a42bb2559669d5c63" translate="yes" xml:space="preserve">
          <source>Row</source>
          <target state="translated">Row</target>
        </trans-unit>
        <trans-unit id="d4bd12801e828062a23cc51816c4185edb49bf68" translate="yes" xml:space="preserve">
          <source>Row Estimation Examples</source>
          <target state="translated">행 추정 예</target>
        </trans-unit>
        <trans-unit id="49328d595db05d2620671f005a532c2227f7046e" translate="yes" xml:space="preserve">
          <source>Row Security Policies</source>
          <target state="translated">행 보안 정책</target>
        </trans-unit>
        <trans-unit id="23974c6f452933ec24b6bd0f8756f5d7111e421e" translate="yes" xml:space="preserve">
          <source>Row constructors can be used to build composite values to be stored in a composite-type table column, or to be passed to a function that accepts a composite parameter. Also, it is possible to compare two row values or test a row with &lt;code&gt;IS NULL&lt;/code&gt; or &lt;code&gt;IS NOT NULL&lt;/code&gt;, for example:</source>
          <target state="translated">행 생성자는 복합 유형 테이블 열에 저장되거나 복합 매개 변수를 허용하는 함수에 전달 될 복합 값을 빌드하는 데 사용될 수 있습니다. 또한 두 개의 행 값을 비교하거나 &lt;code&gt;IS NULL&lt;/code&gt; 또는 &lt;code&gt;IS NOT NULL&lt;/code&gt; 로 행을 테스트 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acbe7c0c38cb066c2d954166e75c80a880a78b0d" translate="yes" xml:space="preserve">
          <source>Row identifier</source>
          <target state="translated">행 식별자</target>
        </trans-unit>
        <trans-unit id="0c69805140819ad779b3d0d804d054b0754bc3db" translate="yes" xml:space="preserve">
          <source>Row security can also be disabled with the &lt;code&gt;ALTER TABLE&lt;/code&gt; command. Disabling row security does not remove any policies that are defined on the table; they are simply ignored. Then all rows in the table are visible and modifiable, subject to the standard SQL privileges system.</source>
          <target state="translated">&lt;code&gt;ALTER TABLE&lt;/code&gt; 명령으로 행 보안을 비활성화 할 수도 있습니다 . 행 보안을 비활성화해도 테이블에 정의 된 정책은 제거되지 않습니다. 그들은 단순히 무시됩니다. 그런 다음 표준 SQL 권한 시스템에 따라 테이블의 모든 행을보고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06562b0a99b89532266a3e2527391759220a1e5a" translate="yes" xml:space="preserve">
          <source>Row security policies can be specific to commands, or to roles, or to both. A policy can be specified to apply to &lt;code&gt;ALL&lt;/code&gt; commands, or to &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt;. Multiple roles can be assigned to a given policy, and normal role membership and inheritance rules apply.</source>
          <target state="translated">행 보안 정책은 명령, 역할 또는 둘 다에 고유 할 수 있습니다. &lt;code&gt;ALL&lt;/code&gt; 명령 또는 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 에 적용되도록 정책을 지정할 수 있습니다 . 주어진 정책에 여러 역할을 할당 할 수 있으며 일반적인 역할 멤버 자격 및 상속 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7968ef205b4aa4053b5c6c63ab1f777985b7e0cc" translate="yes" xml:space="preserve">
          <source>Row updates or deletions caused by foreign-key enforcement actions, such as &lt;code&gt;ON UPDATE CASCADE&lt;/code&gt; or &lt;code&gt;ON DELETE SET NULL&lt;/code&gt;, are treated as part of the SQL command that caused them (note that such actions are never deferred). Relevant triggers on the affected table will be fired, so that this provides another way in which a SQL command might fire triggers not directly matching its type. In simple cases, triggers that request transition relations will see all changes caused in their table by a single original SQL command as a single transition relation. However, there are cases in which the presence of an &lt;code&gt;AFTER ROW&lt;/code&gt; trigger that requests transition relations will cause the foreign-key enforcement actions triggered by a single SQL command to be split into multiple steps, each with its own transition relation(s). In such cases, any statement-level triggers that are present will be fired once per creation of a transition relation set, ensuring that the triggers see each affected row in a transition relation once and only once.</source>
          <target state="translated">&lt;code&gt;ON UPDATE CASCADE&lt;/code&gt; 또는 &lt;code&gt;ON DELETE SET NULL&lt;/code&gt; 과 같은 외래 키 시행 조치로 인한 행 업데이트 또는 삭제는이를 유발 한 SQL 명령의 일부로 처리됩니다 (이러한 조치는 결코 지연되지 않습니다). 영향을받는 테이블의 관련 트리거가 실행되므로 SQL 명령이 해당 유형과 직접 일치하지 않는 트리거를 실행하는 다른 방법을 제공합니다. 간단한 경우, 전이 관계를 요청하는 트리거는 단일 원본 SQL 명령에 의해 테이블에서 발생한 모든 변경 사항을 단일 전이 관계로 간주합니다. 그러나 &lt;code&gt;AFTER ROW&lt;/code&gt; 가있는 경우가 있습니다.전이 관계를 요청하는 트리거는 단일 SQL 명령에 의해 트리거 된 외래 키 시행 조치가 각각 고유 한 전이 관계를 갖는 여러 단계로 분할되게합니다. 이러한 경우, 존재하는 명령문 레벨 트리거는 전이 관계 세트 작성마다 한 번씩 실행되어 트리거가 전이 관계에서 영향을받는 각 행을 한 번만 보게합니다.</target>
        </trans-unit>
        <trans-unit id="1880c1b27e2fa6de43e06cd840214e1ebc6c7165" translate="yes" xml:space="preserve">
          <source>Row-level</source>
          <target state="translated">Row-level</target>
        </trans-unit>
        <trans-unit id="8fcfe76cf6751dd36ffcc6847e514026a8acb027" translate="yes" xml:space="preserve">
          <source>Row-level access control</source>
          <target state="translated">행 수준 액세스 제어</target>
        </trans-unit>
        <trans-unit id="4e3edf6d9ff58a7bd4365693f10058f6c59ed823" translate="yes" xml:space="preserve">
          <source>Rows can be removed from a table using the &lt;code&gt;DELETE&lt;/code&gt; command. Suppose you are no longer interested in the weather of Hayward. Then you can do the following to delete those rows from the table:</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; 명령을 사용하여 테이블에서 행을 제거 할 수 있습니다 . 더 이상 Hayward의 날씨에 관심이 없다고 가정하십시오. 그런 다음 테이블에서 해당 행을 삭제하기 위해 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0c31ba0e68802a3618d9d3326e6468b0dea8a34" translate="yes" xml:space="preserve">
          <source>Rows inserted into a partitioned table will be automatically routed to the correct partition. If no suitable partition exists, an error will occur.</source>
          <target state="translated">파티션 된 테이블에 삽입 된 행은 자동으로 올바른 파티션으로 라우팅됩니다. 적합한 파티션이 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d8631a3ec99afcfc0c6150a87cf0d4e747e6f9a0" translate="yes" xml:space="preserve">
          <source>Rule definition (a reconstructed creation command)</source>
          <target state="translated">규칙 정의 (재구성 된 작성 명령)</target>
        </trans-unit>
        <trans-unit id="9e84d721dc29380b88a37b0dd5ec0f925b4ac77f" translate="yes" xml:space="preserve">
          <source>Rule name</source>
          <target state="translated">규칙 이름</target>
        </trans-unit>
        <trans-unit id="19eb490bb6a3e7286eda32afd971e0be7d21a797" translate="yes" xml:space="preserve">
          <source>Rules on &lt;code&gt;SELECT&lt;/code&gt; statements that generate DML commands.</source>
          <target state="translated">DML 명령을 생성 하는 &lt;code&gt;SELECT&lt;/code&gt; 문 에 대한 규칙</target>
        </trans-unit>
        <trans-unit id="933a7264641d7d78f686c2a0c1ea09ab0a899add" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;ANALYZE&lt;/code&gt; afterwards.</source>
          <target state="translated">나중에 &lt;code&gt;ANALYZE&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="823b9330e269f7883e25c291c90ba88e19524085" translate="yes" xml:space="preserve">
          <source>Run built-in select-only script. Shorthand for &lt;code&gt;-b select-only&lt;/code&gt;.</source>
          <target state="translated">내장 선택 전용 스크립트를 실행하십시오. &lt;code&gt;-b select-only&lt;/code&gt; 의 약자 .</target>
        </trans-unit>
        <trans-unit id="24b0a9385b875d9b1346cafa6c8c8e3349b0f8ea" translate="yes" xml:space="preserve">
          <source>Run built-in simple-update script. Shorthand for &lt;code&gt;-b simple-update&lt;/code&gt;.</source>
          <target state="translated">내장 단순 업데이트 스크립트를 실행하십시오. &lt;code&gt;-b simple-update&lt;/code&gt; 의 약자 .</target>
        </trans-unit>
        <trans-unit id="4ada1a290e3435924302286454b87e5d8cdf99e0" translate="yes" xml:space="preserve">
          <source>Run in single-step mode. That means the user is prompted before each command is sent to the server, with the option to cancel execution as well. Use this to debug scripts.</source>
          <target state="translated">단일 단계 모드에서 실행하십시오. 즉, 각 명령이 서버로 전송되기 전에 사용자에게 프롬프트가 표시되며 실행 취소 옵션도 있습니다. 이를 사용하여 스크립트를 디버그하십시오.</target>
        </trans-unit>
        <trans-unit id="2d5dc7a8594b097a2ea91e686a66bf7ab6368ae2" translate="yes" xml:space="preserve">
          <source>Run the dump in parallel by dumping &lt;code&gt;njobs&lt;/code&gt; tables simultaneously. This option may reduce the time needed to perform the dump but it also increases the load on the database server. You can only use this option with the directory output format because this is the only output format where multiple processes can write their data at the same time.</source>
          <target state="translated">&lt;code&gt;njobs&lt;/code&gt; 테이블을 동시에 덤프하여 덤프를 병렬로 실행하십시오 . 이 옵션은 덤프를 수행하는 데 필요한 시간을 줄일 수 있지만 데이터베이스 서버의로드도 증가시킵니다. 이 옵션은 여러 프로세스가 동시에 데이터를 쓸 수있는 유일한 출력 형식이므로 디렉토리 출력 형식과 함께 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1be7e98070f25a7f7e53bb83439c1727051f37dc" translate="yes" xml:space="preserve">
          <source>Run the dump in parallel by dumping &lt;code&gt;njobs&lt;/code&gt; tables simultaneously. This option reduces the time of the dump but it also increases the load on the database server. You can only use this option with the directory output format because this is the only output format where multiple processes can write their data at the same time.</source>
          <target state="translated">&lt;code&gt;njobs&lt;/code&gt; 테이블을 동시에 덤프하여 덤프를 병렬로 실행하십시오 . 이 옵션은 덤프 시간을 줄이지 만 데이터베이스 서버의로드도 증가시킵니다. 이 옵션은 여러 프로세스가 동시에 데이터를 쓸 수있는 유일한 출력 형식이므로 디렉토리 출력 형식에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a5a19a4add5fbe88d90e258d947d8d0ffdfd872" translate="yes" xml:space="preserve">
          <source>Run the most time-consuming parts of pg_restore &amp;mdash; those which load data, create indexes, or create constraints &amp;mdash; using multiple concurrent jobs. This option can dramatically reduce the time to restore a large database to a server running on a multiprocessor machine.</source>
          <target state="translated">여러 개의 동시 작업을 사용하여 pg_restore에서 가장 시간이 많이 걸리는 부분 (데이터로드, 인덱스 생성 또는 제약 조건 생성)을 실행하십시오. 이 옵션을 사용하면 대용량 데이터베이스를 다중 프로세서 시스템에서 실행되는 서버로 복원하는 시간을 크게 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a5739e7fa13a079af21df584553187bc9689d48" translate="yes" xml:space="preserve">
          <source>Run the most time-consuming steps of pg_restore &amp;mdash; those that load data, create indexes, or create constraints &amp;mdash; concurrently, using up to &lt;code&gt;number-of-jobs&lt;/code&gt; concurrent sessions. This option can dramatically reduce the time to restore a large database to a server running on a multiprocessor machine. This option is ignored when emitting a script rather than connecting directly to a database server.</source>
          <target state="translated">최대 &lt;code&gt;number-of-jobs&lt;/code&gt; 동시 세션 을 사용하여 가장 시간이 많이 걸리는 pg_restore 단계 (데이터로드, 인덱스 생성 또는 제약 조건 생성)를 동시에 실행합니다. 이 옵션은 대용량 데이터베이스를 다중 프로세서 시스템에서 실행되는 서버로 복원하는 시간을 크게 줄일 수 있습니다. 이 옵션은 데이터베이스 서버에 직접 연결하지 않고 스크립트를 생성 할 때 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="306b49d675b536987906a8c1eaf0e9ffaf685957" translate="yes" xml:space="preserve">
          <source>Run the new script:</source>
          <target state="translated">새 스크립트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9b0806df128628173754d037af7b3f1c40843aa3" translate="yes" xml:space="preserve">
          <source>Run the test for this many seconds, rather than a fixed number of transactions per client. &lt;code&gt;-t&lt;/code&gt; and &lt;code&gt;-T&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">클라이언트 당 고정 된 수의 트랜잭션이 아니라이 초 동안 테스트를 실행하십시오. &lt;code&gt;-t&lt;/code&gt; 와 &lt;code&gt;-T&lt;/code&gt; 는 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="ef7242e1da9218c25ab49e603c7554daf3d3a11e" translate="yes" xml:space="preserve">
          <source>Run through all candidates and keep those that accept preferred types (of the input data type's type category) at the most positions where type conversion will be required. Keep all candidates if none accept preferred types. If only one candidate remains, use it; else continue to the next step.</source>
          <target state="translated">모든 후보를 실행하고 유형 변환이 필요한 대부분의 위치에 선호되는 유형 (입력 데이터 유형의 유형 범주)을 수용하는 후보를 유지하십시오. 선호되는 유형이없는 경우 모든 후보자를 유지하십시오. 후보자가 하나만 남아 있으면 사용하십시오. 그렇지 않으면 다음 단계로 계속 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="8d9f7b1b3e8ce9c7f41afc9156c0b0f0894d3208" translate="yes" xml:space="preserve">
          <source>Run through all candidates and keep those with the most exact matches on input types. Keep all candidates if none have exact matches. If only one candidate remains, use it; else continue to the next step.</source>
          <target state="translated">모든 후보를 실행하고 입력 유형에서 가장 정확하게 일치하는 후보를 유지하십시오. 정확히 일치하는 것이 없으면 모든 후보자를 유지하십시오. 후보자가 하나만 남아 있으면 사용하십시오. 그렇지 않으면 다음 단계로 계속 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="0009744aa716ceb939fafa8ed848fd29e766f0a9" translate="yes" xml:space="preserve">
          <source>Run-time Statistics</source>
          <target state="translated">런타임 통계</target>
        </trans-unit>
        <trans-unit id="dfad02711bc1b59eba645d8ebee3e6f2df5bcf65" translate="yes" xml:space="preserve">
          <source>Run-time configuration parameter name</source>
          <target state="translated">런타임 구성 매개 변수 이름</target>
        </trans-unit>
        <trans-unit id="8a3537e1b1141685ddea37a6bf3d62bd54b47173" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;DROP DATABASE&lt;/code&gt; or &lt;code&gt;ALTER DATABASE ... SET TABLESPACE&lt;/code&gt; on the primary will generate a WAL entry that will cause all users connected to that database on the standby to be forcibly disconnected. This action occurs immediately, whatever the setting of &lt;code&gt;max_standby_streaming_delay&lt;/code&gt;. Note that &lt;code&gt;ALTER DATABASE ... RENAME&lt;/code&gt; does not disconnect users, which in most cases will go unnoticed, though might in some cases cause a program confusion if it depends in some way upon database name.</source>
          <target state="translated">기본에서 &lt;code&gt;DROP DATABASE&lt;/code&gt; 또는 &lt;code&gt;ALTER DATABASE ... SET TABLESPACE&lt;/code&gt; 를 실행 하면 WAL 항목이 생성되어 대기에서 해당 데이터베이스에 연결된 모든 사용자의 연결이 강제로 끊어지게됩니다. 이 조치는 &lt;code&gt;max_standby_streaming_delay&lt;/code&gt; 설정에 관계없이 즉시 발생합니다 . 하는 것으로 &lt;code&gt;ALTER DATABASE ... RENAME&lt;/code&gt; 이 데이터베이스 이름에 따라 몇 가지 방법에 의존하는 경우 어떤 경우에는 힘이 프로그램 혼란을 야기하지만 대부분의 경우, 들키지 것이다 사용자의 연결을 끊하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71157cbfad52170782ef78b45e43fe59de81fafa" translate="yes" xml:space="preserve">
          <source>Running queries in hot standby mode is similar to normal query operation, though there are several usage and administrative differences explained below.</source>
          <target state="translated">핫 스탠바이 모드에서 쿼리를 실행하는 것은 일반적인 쿼리 작업과 비슷하지만 아래에 몇 가지 사용법과 관리상의 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="93362be79e5b1c35c85313b52f149b521a850ee5" translate="yes" xml:space="preserve">
          <source>Running the PostgreSQL interactive terminal program, called &lt;em&gt;psql&lt;/em&gt;, which allows you to interactively enter, edit, and execute SQL commands.</source>
          <target state="translated">&lt;em&gt;psql&lt;/em&gt; 이라는 PostgreSQL 대화식 터미널 프로그램 실행&lt;em&gt;&lt;/em&gt; 실행하면 SQL 명령을 대화식으로 입력, 편집 및 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81a885e4a05b7837bf89bc257dddd0ff56951c9d" translate="yes" xml:space="preserve">
          <source>Running with connection parameters to a PostgreSQL cluster in startup:</source>
          <target state="translated">시작시 PostgreSQL 클러스터에 연결 매개 변수를 사용하여 실행 :</target>
        </trans-unit>
        <trans-unit id="0fff922ce66314e8cfaf8cdfeac0e9f934608d16" translate="yes" xml:space="preserve">
          <source>Running with connection parameters to a non-responsive PostgreSQL cluster:</source>
          <target state="translated">무응답 PostgreSQL 클러스터에 대한 연결 매개 변수를 사용하여 실행 :</target>
        </trans-unit>
        <trans-unit id="f7cf597064714419ae36955f74efc83a4748a9d7" translate="yes" xml:space="preserve">
          <source>Runs in single-line mode where a newline terminates an SQL command, as a semicolon does.</source>
          <target state="translated">줄 바꾸기가 세미콜론처럼 SQL 명령을 종료하는 한 줄 모드로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="02aa629c8b16cd17a44f3a0efec2feed43937642" translate="yes" xml:space="preserve">
          <source>S</source>
          <target state="translated">S</target>
        </trans-unit>
        <trans-unit id="9a2833a68b2b5a8101cbef39bec23f0b3a9245c1" translate="yes" xml:space="preserve">
          <source>SASL Authentication</source>
          <target state="translated">SASL 인증</target>
        </trans-unit>
        <trans-unit id="fc5e17646da120752ee7e631a8a7f6cec0756eed" translate="yes" xml:space="preserve">
          <source>SASL Authentication: SCRAM-SHA-256 Authentication</source>
          <target state="translated">SASL 인증 : SCRAM-SHA-256 인증</target>
        </trans-unit>
        <trans-unit id="8c5e7d070ec0ab017535260be8b2a8640c2f6758" translate="yes" xml:space="preserve">
          <source>SAVEPOINT</source>
          <target state="translated">SAVEPOINT</target>
        </trans-unit>
        <trans-unit id="2968898746c112d95829f5ba43f3ab14d5a8ee5d" translate="yes" xml:space="preserve">
          <source>SAVEPOINT &amp;mdash; define a new savepoint within the current transaction</source>
          <target state="translated">SAVEPOINT &amp;mdash; 현재 트랜잭션 내에서 새 저장 점을 정의합니다</target>
        </trans-unit>
        <trans-unit id="1d54d461b0e93966e734b026dfe2118ed16f1a78" translate="yes" xml:space="preserve">
          <source>SCRAM with channel binding prevents such man-in-the-middle attacks by mixing the signature of the server's certificate into the transmitted password hash. While a fake server can retransmit the real server's certificate, it doesn't have access to the private key matching that certificate, and therefore cannot prove it is the owner, causing SSL connection failure.</source>
          <target state="translated">채널 바인딩이있는 SCRAM은 서버 인증서의 서명을 전송 된 비밀번호 해시에 혼합하여 이러한 MITM (Man-in-the-Middle) 공격을 방지합니다. 가짜 서버는 실제 서버의 인증서를 재전송 할 수 있지만 해당 인증서와 일치하는 개인 키에 액세스 할 수 없으므로 소유자임을 증명할 수 없으므로 SSL 연결이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1f15bccb6a4b6b1dfc8c3c1c8fad90ae83f94463" translate="yes" xml:space="preserve">
          <source>SE-PostgreSQL Introduction</source>
          <target state="translated">SE-PostgreSQL 소개</target>
        </trans-unit>
        <trans-unit id="5602d710f5ace4caf5686004b21ead1c001ffa04" translate="yes" xml:space="preserve">
          <source>SECURITY LABEL</source>
          <target state="translated">보안 레이블</target>
        </trans-unit>
        <trans-unit id="4bac9deee0ff8b69144f6c494a64bcef7fbb99dc" translate="yes" xml:space="preserve">
          <source>SECURITY LABEL &amp;mdash; define or change a security label applied to an object</source>
          <target state="translated">SECURITY LABEL &amp;mdash; 객체에 적용된 보안 레이블을 정의 또는 변경</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="c109d6ea26b33b8f0b1a2c16691c91b61b1f47cb" translate="yes" xml:space="preserve">
          <source>SELECT ... DISTINCT</source>
          <target state="translated">선택 ... 고유</target>
        </trans-unit>
        <trans-unit id="9f1d17dea1e56188a8f7a85a9fa0feb0643f7db6" translate="yes" xml:space="preserve">
          <source>SELECT ... EXCEPT</source>
          <target state="translated">선택 ... 제외</target>
        </trans-unit>
        <trans-unit id="549332f553955260423fbb630328c298c10b6076" translate="yes" xml:space="preserve">
          <source>SELECT ... FROM</source>
          <target state="translated">선택 ... FROM</target>
        </trans-unit>
        <trans-unit id="e99306609429d4ffb8a50f26f40eba41d3ee3c5c" translate="yes" xml:space="preserve">
          <source>SELECT ... GROUP BY</source>
          <target state="translated">선택 ... 그룹화 기준</target>
        </trans-unit>
        <trans-unit id="433714c6e39ac140bd21394a29cedbb7fc60a9b3" translate="yes" xml:space="preserve">
          <source>SELECT ... HAVING</source>
          <target state="translated">선택 ... HAVING</target>
        </trans-unit>
        <trans-unit id="a73b45bfd999b51a91b0b9b9ed54f345884bdea3" translate="yes" xml:space="preserve">
          <source>SELECT ... INTERSECT</source>
          <target state="translated">선택 ... 상호 작용</target>
        </trans-unit>
        <trans-unit id="2931cc0f46be4e8ce851ea645a1c5efd7fb4aa6e" translate="yes" xml:space="preserve">
          <source>SELECT ... LIMIT</source>
          <target state="translated">선택 ... 제한</target>
        </trans-unit>
        <trans-unit id="8a93a8812a9d37903b646b93126b8371980dd78f" translate="yes" xml:space="preserve">
          <source>SELECT ... ORDER BY</source>
          <target state="translated">선택 ... 주문</target>
        </trans-unit>
        <trans-unit id="5072dde920c520e6bf032e69f5ee5ec9a52d72a1" translate="yes" xml:space="preserve">
          <source>SELECT ... UNION</source>
          <target state="translated">선택 ... UNION</target>
        </trans-unit>
        <trans-unit id="76fd8400684291139689533af00a6695888dd449" translate="yes" xml:space="preserve">
          <source>SELECT ... WHERE</source>
          <target state="translated">선택 ... 어디</target>
        </trans-unit>
        <trans-unit id="4c85dcaf943d3c6b197884b4fca581471f89d511" translate="yes" xml:space="preserve">
          <source>SELECT ... WINDOW</source>
          <target state="translated">선택 ... 창</target>
        </trans-unit>
        <trans-unit id="bee9a601c0eb262445256d0a7ecc5438d432d191" translate="yes" xml:space="preserve">
          <source>SELECT ... WITH</source>
          <target state="translated">선택 ...</target>
        </trans-unit>
        <trans-unit id="7768caeabea6c20082aba945fd23ed5dfc00a60c" translate="yes" xml:space="preserve">
          <source>SELECT INTO</source>
          <target state="translated">안으로 선택</target>
        </trans-unit>
        <trans-unit id="e4a6ab2364aeebf690fa1f713d0dabe0ae95b18a" translate="yes" xml:space="preserve">
          <source>SELECT INTO &amp;mdash; define a new table from the results of a query</source>
          <target state="translated">SELECT INTO &amp;mdash; 쿼리 결과에서 새 테이블을 정의합니다</target>
        </trans-unit>
        <trans-unit id="aa8a4aa6ea022cf29ffdf6e3888dcd1cee0da2de" translate="yes" xml:space="preserve">
          <source>SELECT Lists</source>
          <target state="translated">리스트 선택</target>
        </trans-unit>
        <trans-unit id="96dd17a13e6fff2435b60a5f376e38039e737e64" translate="yes" xml:space="preserve">
          <source>SELECT Lists: Column Labels</source>
          <target state="translated">SELECT 목록 : 열 레이블</target>
        </trans-unit>
        <trans-unit id="dea0ef1027ae4ecb70602b4a4001c28929277e62" translate="yes" xml:space="preserve">
          <source>SELECT Lists: DISTINCT</source>
          <target state="translated">선택 목록 : DISTINCT</target>
        </trans-unit>
        <trans-unit id="492d193a017c3e59fc04b60927f171a28ae9ddfc" translate="yes" xml:space="preserve">
          <source>SELECT Lists: Select-List Items</source>
          <target state="translated">선택 목록 : 선택 목록 항목</target>
        </trans-unit>
        <trans-unit id="17002e6b6d7ff4c0ae74a77c468d57589e24fd6a" translate="yes" xml:space="preserve">
          <source>SELECT Output Columns</source>
          <target state="translated">SELECT 출력 열</target>
        </trans-unit>
        <trans-unit id="0369adca6ccf64b5d7c0d197ffc3a2f769e240b5" translate="yes" xml:space="preserve">
          <source>SELECT, TABLE, WITH &amp;mdash; retrieve rows from a table or view</source>
          <target state="translated">SELECT, TABLE, WITH &amp;mdash; 테이블 또는 뷰에서 행을 검색합니다</target>
        </trans-unit>
        <trans-unit id="44f7e965be1235f05e305a467631982e8069c34c" translate="yes" xml:space="preserve">
          <source>SELinux User's and Administrator's Guide</source>
          <target state="translated">SELinux 사용자 및 관리자 안내서</target>
        </trans-unit>
        <trans-unit id="cb318e1bb5fc77b4396492cdee9ce6459bc0b341" translate="yes" xml:space="preserve">
          <source>SELinux access control decisions are made using security labels, which are represented by strings such as &lt;code&gt;system_u:object_r:sepgsql_table_t:s0&lt;/code&gt;. Each access control decision involves two labels: the label of the subject attempting to perform the action, and the label of the object on which the operation is to be performed. Since these labels can be applied to any sort of object, access control decisions for objects stored within the database can be (and, with this module, are) subjected to the same general criteria used for objects of any other type, such as files. This design is intended to allow a centralized security policy to protect information assets independent of the particulars of how those assets are stored.</source>
          <target state="translated">SELinux 액세스 제어 결정은 &lt;code&gt;system_u:object_r:sepgsql_table_t:s0&lt;/code&gt; 과 같은 문자열로 표시되는 보안 레이블을 사용하여 결정됩니다 . 각 액세스 제어 결정에는 두 가지 레이블, 즉 작업을 수행하려는 주체의 레이블과 작업을 수행 할 개체의 레이블이 포함됩니다. 이러한 레이블은 모든 종류의 객체에 적용 할 수 있으므로 데이터베이스 내에 저장된 객체에 대한 액세스 제어 결정은 파일과 같은 다른 유형의 객체에 사용 된 것과 동일한 일반 기준을 따릅니다. 이 설계는 중앙 집중식 보안 정책이 해당 자산이 저장되는 방식에 관계없이 정보 자산을 보호 할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="baaadd42a98998ad54f9f7f0dc049575f8bcb06e" translate="yes" xml:space="preserve">
          <source>SELinux defines several permissions to control common operations for each object type; such as creation, alter, drop and relabel of security label. In addition, several object types have special permissions to control their characteristic operations; such as addition or deletion of name entries within a particular schema.</source>
          <target state="translated">SELinux는 각 객체 유형에 대한 공통 작업을 제어하기위한 여러 권한을 정의합니다. 보안 레이블 작성, 변경, 삭제 및 레이블 재 지정과 같은 또한 여러 개체 유형에는 특성 작업을 제어 할 수있는 특별한 권한이 있습니다. 특정 스키마 내에서 이름 항목 추가 또는 삭제와 같은</target>
        </trans-unit>
        <trans-unit id="55c5d81017a30edf1e47ba1b78c377a5e5ebfd50" translate="yes" xml:space="preserve">
          <source>SET</source>
          <target state="translated">SET</target>
        </trans-unit>
        <trans-unit id="ed50e3276003310a8e9fe68c9d0558543dc625db" translate="yes" xml:space="preserve">
          <source>SET &amp;mdash; change a run-time parameter</source>
          <target state="translated">SET &amp;mdash; 런타임 매개 변수 변경</target>
        </trans-unit>
        <trans-unit id="74fea83b8e29ed0d9baf2051ea0b6cbf4c781859" translate="yes" xml:space="preserve">
          <source>SET CONSTRAINTS</source>
          <target state="translated">구속 조건 설정</target>
        </trans-unit>
        <trans-unit id="151992ecd11aebbdfe70b48dd5706caf33551f93" translate="yes" xml:space="preserve">
          <source>SET CONSTRAINTS &amp;mdash; set constraint check timing for the current transaction</source>
          <target state="translated">SET CONSTRAINTS &amp;mdash; 현재 트랜잭션에 대한 제한 조건 점검 시간 설정</target>
        </trans-unit>
        <trans-unit id="48e764b927b1590ddbd9c82bf55e742796154628" translate="yes" xml:space="preserve">
          <source>SET ROLE</source>
          <target state="translated">역할 설정</target>
        </trans-unit>
        <trans-unit id="adf0107c1cf0989ac94cb9393a5c03d5526bfebd" translate="yes" xml:space="preserve">
          <source>SET ROLE &amp;mdash; set the current user identifier of the current session</source>
          <target state="translated">SET ROLE &amp;mdash; 현재 세션의 현재 사용자 식별자를 설정합니다</target>
        </trans-unit>
        <trans-unit id="7f8324a7bcedd239f742a57722fb4b5b2d84154d" translate="yes" xml:space="preserve">
          <source>SET SESSION AUTHORIZATION</source>
          <target state="translated">세션 인증 설정</target>
        </trans-unit>
        <trans-unit id="0b437edc175bcc6c087b4a76b7709936ccc7454a" translate="yes" xml:space="preserve">
          <source>SET SESSION AUTHORIZATION &amp;mdash; set the session user identifier and the current user identifier of the current session</source>
          <target state="translated">세션 권한 설정 &amp;mdash; 세션 사용자 식별자 및 현재 세션의 현재 사용자 식별자를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6f4b879a4b48823a45046d9fb3d07c9ee88879b4" translate="yes" xml:space="preserve">
          <source>SET TRANSACTION</source>
          <target state="translated">거래 설정</target>
        </trans-unit>
        <trans-unit id="e8432189084f1bc6f4e893c032c5d3ce6777ea57" translate="yes" xml:space="preserve">
          <source>SET TRANSACTION &amp;mdash; set the characteristics of the current transaction</source>
          <target state="translated">거래 설정 &amp;mdash; 현재 거래의 특성을 설정합니다</target>
        </trans-unit>
        <trans-unit id="4b9079dcb3b5d1ef1e40482f9c01179073a53f17" translate="yes" xml:space="preserve">
          <source>SGML</source>
          <target state="translated">SGML</target>
        </trans-unit>
        <trans-unit id="bb99119e95c8e6a227bc34a3ce384008860cd848" translate="yes" xml:space="preserve">
          <source>SHA-224 hash</source>
          <target state="translated">SHA-224 해시</target>
        </trans-unit>
        <trans-unit id="5b260b421bfc6ab475a987b7a1c5931415e226de" translate="yes" xml:space="preserve">
          <source>SHA-256 hash</source>
          <target state="translated">SHA-256 해시</target>
        </trans-unit>
        <trans-unit id="7394298d86c031077a91787405f5786ad9c7812d" translate="yes" xml:space="preserve">
          <source>SHA-384 hash</source>
          <target state="translated">SHA-384 해시</target>
        </trans-unit>
        <trans-unit id="9c4cdc245cabaa422a74ba60747103e9d93edb8e" translate="yes" xml:space="preserve">
          <source>SHA-512 hash</source>
          <target state="translated">SHA-512 해시</target>
        </trans-unit>
        <trans-unit id="e1744a525099d9a53c0460ef9cb7ab0e4c4fc939" translate="yes" xml:space="preserve">
          <source>SHA1</source>
          <target state="translated">SHA1</target>
        </trans-unit>
        <trans-unit id="694c58aaafb0c6dc9ac6113fda787fb752fd1fa6" translate="yes" xml:space="preserve">
          <source>SHA224/256/384/512</source>
          <target state="translated">SHA224/256/384/512</target>
        </trans-unit>
        <trans-unit id="5f048dbc0f9901d32b771c4583f8c05bf3099ed4" translate="yes" xml:space="preserve">
          <source>SHA256/384/512</source>
          <target state="translated">SHA256/384/512</target>
        </trans-unit>
        <trans-unit id="dd19b86ae45a271261a2769df9693b7eeeac1d33" translate="yes" xml:space="preserve">
          <source>SHARE</source>
          <target state="translated">SHARE</target>
        </trans-unit>
        <trans-unit id="75d04aa8efcc077848b5418389044c2e997b4339" translate="yes" xml:space="preserve">
          <source>SHARE ROW EXCLUSIVE</source>
          <target state="translated">행 독점</target>
        </trans-unit>
        <trans-unit id="116b0b7668c7a2f9618740565ec4bb084306eddb" translate="yes" xml:space="preserve">
          <source>SHARE UPDATE EXCLUSIVE</source>
          <target state="translated">독점 업데이트 공유</target>
        </trans-unit>
        <trans-unit id="40ae6fd23e318904854df6e040723138bba16421" translate="yes" xml:space="preserve">
          <source>SHOW</source>
          <target state="translated">SHOW</target>
        </trans-unit>
        <trans-unit id="8ee2ce05179dded29f3a5b52317a29c34826f3d5" translate="yes" xml:space="preserve">
          <source>SHOW &amp;mdash; show the value of a run-time parameter</source>
          <target state="translated">SHOW &amp;mdash; 런타임 매개 변수의 값을 표시합니다</target>
        </trans-unit>
        <trans-unit id="d14a2e1185b80296038156e7c70b8194935d3a8e" translate="yes" xml:space="preserve">
          <source>SIGINT</source>
          <target state="translated">SIGINT</target>
        </trans-unit>
        <trans-unit id="c17a4b6e8878d862728ca038a99603d61d7ca07f" translate="yes" xml:space="preserve">
          <source>SIGQUIT</source>
          <target state="translated">SIGQUIT</target>
        </trans-unit>
        <trans-unit id="e85f8b5c7eac9f932a93cbf9d03712194c0da0e2" translate="yes" xml:space="preserve">
          <source>SIGTERM</source>
          <target state="translated">SIGTERM</target>
        </trans-unit>
        <trans-unit id="3ac833a3df1ae61fe062d63f8b82ffba391eb78d" translate="yes" xml:space="preserve">
          <source>SP-GiST</source>
          <target state="translated">SP-GiST</target>
        </trans-unit>
        <trans-unit id="2add1e1e2bc766022fc5586d1f53200a86310220" translate="yes" xml:space="preserve">
          <source>SP-GiST Indexes: Built-in Operator Classes</source>
          <target state="translated">SP-GiST 인덱스 : 내장 연산자 클래스</target>
        </trans-unit>
        <trans-unit id="fa104075633d3201168a1bb39b0c4e539c83a68b" translate="yes" xml:space="preserve">
          <source>SP-GiST Indexes: Examples</source>
          <target state="translated">SP-GiST 인덱스 : 예</target>
        </trans-unit>
        <trans-unit id="95d5d0637d61ad8c3a8e44a2c45b55c37465c697" translate="yes" xml:space="preserve">
          <source>SP-GiST Indexes: Extensibility</source>
          <target state="translated">SP-GiST 지수 : 확장 성</target>
        </trans-unit>
        <trans-unit id="2e7dc6fa3a11c3934b44832416519adf68556f2f" translate="yes" xml:space="preserve">
          <source>SP-GiST Indexes: Implementation</source>
          <target state="translated">SP-GiST 인덱스 : 구현</target>
        </trans-unit>
        <trans-unit id="f6a66bb3e75623245ed5dea0220aa160fb0caabf" translate="yes" xml:space="preserve">
          <source>SP-GiST indexes, like GiST indexes, offer an infrastructure that supports various kinds of searches. SP-GiST permits implementation of a wide range of different non-balanced disk-based data structures, such as quadtrees, k-d trees, and radix trees (tries). As an example, the standard distribution of PostgreSQL includes SP-GiST operator classes for two-dimensional points, which support indexed queries using these operators:</source>
          <target state="translated">GiST 인덱스와 같은 SP-GiST 인덱스는 다양한 종류의 검색을 지원하는 인프라를 제공합니다. SP-GiST를 사용하면 쿼드 트리, kd 트리 및 기수 트리 (Tries)와 같은 다양한 비 균형 디스크 기반 데이터 구조를 구현할 수 있습니다. 예를 들어, PostgreSQL의 표준 배포에는 2 차원 점에 대한 SP-GiST 연산자 클래스가 포함되어 있으며이 연산자를 사용하여 인덱스 된 쿼리를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0cdd1caa127b3e88e8a1fed97cfbcba3d77e43ef" translate="yes" xml:space="preserve">
          <source>SP-GiST is an abbreviation for space-partitioned GiST. SP-GiST supports partitioned search trees, which facilitate development of a wide range of different non-balanced data structures, such as quad-trees, k-d trees, and radix trees (tries). The common feature of these structures is that they repeatedly divide the search space into partitions that need not be of equal size. Searches that are well matched to the partitioning rule can be very fast.</source>
          <target state="translated">SP-GiST는 공간 분할 된 GiST의 약자입니다. SP-GiST는 분할 된 검색 트리를 지원하여 쿼드 트리, kd 트리 및 기수 트리 (Tries)와 같은 다양한 비 균형 데이터 구조를 쉽게 개발할 수 있습니다. 이러한 구조의 공통적 인 특징은 검색 공간을 동일한 크기가 아닌 파티션으로 반복해서 분할한다는 것입니다. 파티셔닝 규칙과 잘 일치하는 검색은 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="cad58fcd1c84d93a1ccc36db2394a92b2702598f" translate="yes" xml:space="preserve">
          <source>SP-GiST offers an interface with a high level of abstraction, requiring the access method developer to implement only methods specific to a given data type. The SP-GiST core is responsible for efficient disk mapping and searching the tree structure. It also takes care of concurrency and logging considerations.</source>
          <target state="translated">SP-GiST는 추상화 수준이 높은 인터페이스를 제공하므로 액세스 방법 개발자는 지정된 데이터 유형에 특정한 방법 만 구현해야합니다. SP-GiST 코어는 효율적인 디스크 매핑 및 트리 구조 검색을 담당합니다. 또한 동시성 및 로깅 고려 사항도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="576bfa9599018ae4ab50451e1a4d78e4622222be" translate="yes" xml:space="preserve">
          <source>SPI</source>
          <target state="translated">SPI</target>
        </trans-unit>
        <trans-unit id="2064cb643caa8d9e1de12eea7f3e143ca9f8680d" translate="yes" xml:space="preserve">
          <source>SQL</source>
          <target state="translated">SQL</target>
        </trans-unit>
        <trans-unit id="50315be8d6d0ce57ead2a36e2bf8dc5de912c90f" translate="yes" xml:space="preserve">
          <source>SQL &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt; statements place the results of expressions into a table. The expressions in the statement must be matched up with, and perhaps converted to, the types of the target columns.</source>
          <target state="translated">SQL &lt;code&gt;INSERT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 문은 표현식 결과를 테이블에 배치합니다. 명령문의 표현식은 대상 컬럼의 유형과 일치하고 변환 될 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a31c0b48ed8450b0441203e59656b02b2047060f" translate="yes" xml:space="preserve">
          <source>SQL &lt;code&gt;NULL&lt;/code&gt; is a different concept</source>
          <target state="translated">SQL &lt;code&gt;NULL&lt;/code&gt; 은 다른 개념입니다</target>
        </trans-unit>
        <trans-unit id="2674b067b3f8cc79713bcbfdf8df6f784485d11b" translate="yes" xml:space="preserve">
          <source>SQL &lt;code&gt;UNION&lt;/code&gt; constructs must match up possibly dissimilar types to become a single result set. The resolution algorithm is applied separately to each output column of a union query. The &lt;code&gt;INTERSECT&lt;/code&gt; and &lt;code&gt;EXCEPT&lt;/code&gt; constructs resolve dissimilar types in the same way as &lt;code&gt;UNION&lt;/code&gt;. Some other constructs, including &lt;code&gt;CASE&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;VALUES&lt;/code&gt;, and the &lt;code&gt;GREATEST&lt;/code&gt; and &lt;code&gt;LEAST&lt;/code&gt; functions, use the identical algorithm to match up their component expressions and select a result data type.</source>
          <target state="translated">SQL &lt;code&gt;UNION&lt;/code&gt; 구문은 단일 결과 집합이 되려면 유사하지 않을 수있는 유형과 일치해야합니다. 해석 알고리즘은 통합 쿼리의 각 출력 열에 개별적으로 적용됩니다. &lt;code&gt;INTERSECT&lt;/code&gt; 및 &lt;code&gt;EXCEPT&lt;/code&gt; 구조는 같은 방법으로 서로 다른 유형을 해결 &lt;code&gt;UNION&lt;/code&gt; . &lt;code&gt;CASE&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;VALUES&lt;/code&gt; 및 &lt;code&gt;GREATEST&lt;/code&gt; 및 &lt;code&gt;LEAST&lt;/code&gt; 함수를 포함한 일부 다른 구성 은 동일한 알고리즘을 사용하여 구성 요소 표현식을 일치시키고 결과 데이터 유형을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="5118cabed55c518cba17e213be23757b2c695769" translate="yes" xml:space="preserve">
          <source>SQL &lt;code&gt;UNION&lt;/code&gt; constructs must match up possibly dissimilar types to become a single result set. The resolution algorithm is applied separately to each output column of a union query. The &lt;code&gt;INTERSECT&lt;/code&gt; and &lt;code&gt;EXCEPT&lt;/code&gt; constructs resolve dissimilar types in the same way as &lt;code&gt;UNION&lt;/code&gt;. The &lt;code&gt;CASE&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;VALUES&lt;/code&gt;, &lt;code&gt;GREATEST&lt;/code&gt; and &lt;code&gt;LEAST&lt;/code&gt; constructs use the identical algorithm to match up their component expressions and select a result data type.</source>
          <target state="translated">SQL &lt;code&gt;UNION&lt;/code&gt; 구문은 다른 유형과 일치하여 단일 결과 집합이되어야합니다. 확인 알고리즘은 통합 쿼리의 각 출력 열에 별도로 적용됩니다. &lt;code&gt;INTERSECT&lt;/code&gt; 및 &lt;code&gt;EXCEPT&lt;/code&gt; 구조는 같은 방법으로 서로 다른 유형을 해결 &lt;code&gt;UNION&lt;/code&gt; . &lt;code&gt;CASE&lt;/code&gt; 는 , &lt;code&gt;ARRAY&lt;/code&gt; 는 , &lt;code&gt;VALUES&lt;/code&gt; 는 , &lt;code&gt;GREATEST&lt;/code&gt; 와 &lt;code&gt;LEAST&lt;/code&gt; 구조는 구성 요소 표현을 일치하고 결과 데이터 유형을 선택 동일한 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5f8bafe5e0fb303a372d3d572cf81e76910f3189" translate="yes" xml:space="preserve">
          <source>SQL Commands</source>
          <target state="translated">SQL 명령</target>
        </trans-unit>
        <trans-unit id="1c2a139e3c7fca0485f190d4c35e4af784637120" translate="yes" xml:space="preserve">
          <source>SQL Dump</source>
          <target state="translated">SQL 덤프</target>
        </trans-unit>
        <trans-unit id="cda1b219180ae57eb8d6130a51d423ecf131c870" translate="yes" xml:space="preserve">
          <source>SQL Interpolation</source>
          <target state="translated">SQL 보간</target>
        </trans-unit>
        <trans-unit id="0c1f76dc7ad0afa25c5cf780385079fdfa6b9459" translate="yes" xml:space="preserve">
          <source>SQL Key Words</source>
          <target state="translated">SQL 키워드</target>
        </trans-unit>
        <trans-unit id="8356adde9b186bbe82e793e29f77f265d9cac033" translate="yes" xml:space="preserve">
          <source>SQL Repl. Middle-ware</source>
          <target state="translated">SQL Repl. 미들웨어</target>
        </trans-unit>
        <trans-unit id="52ee6949a082b9a1424784520adbb2a944201fb8" translate="yes" xml:space="preserve">
          <source>SQL defines some string functions that use key words, rather than commas, to separate arguments. Details are in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Table 9.11&lt;/a&gt;. PostgreSQL also provides versions of these functions that use the regular function invocation syntax (see &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;Table 9.12&lt;/a&gt;).</source>
          <target state="translated">SQL은 쉼표가 아닌 키워드를 사용하여 인수를 구분하는 일부 문자열 함수를 정의합니다. 자세한 내용은 &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;표 9.11&lt;/a&gt; 에 나와 있습니다. PostgreSQL은 또한 일반 함수 호출 구문을 사용하는 이러한 함수의 버전을 제공합니다 ( &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;표 9.12&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cc5f1a9e49159712d94151bb6eee565938bb9e46" translate="yes" xml:space="preserve">
          <source>SQL defines some string functions that use key words, rather than commas, to separate arguments. Details are in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;Table 9.12&lt;/a&gt;. PostgreSQL also provides versions of these functions that use the regular function invocation syntax (see &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;Table 9.13&lt;/a&gt;).</source>
          <target state="translated">SQL은 인수를 구분하기 위해 쉼표 대신 키워드를 사용하는 일부 문자열 함수를 정의합니다. 자세한 내용은 &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-SQL&quot;&gt;표 9.12에&lt;/a&gt; 있습니다. PostgreSQL은 일반 함수 호출 구문을 사용하는 이러한 함수 버전도 제공합니다 ( &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-OTHER&quot;&gt;표 9.13&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="215b8afae6c95fbdbc5864947d8f6ba84d83adca" translate="yes" xml:space="preserve">
          <source>SQL defines some string functions that use key words, rather than commas, to separate arguments. Details are in &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;Table 9.9&lt;/a&gt;. PostgreSQL also provides versions of these functions that use the regular function invocation syntax (see &lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;Table 9.10&lt;/a&gt;).</source>
          <target state="translated">SQL은 인수를 구분하기 위해 쉼표 대신 키워드를 사용하는 일부 문자열 함수를 정의합니다. 자세한 내용은 &lt;a href=&quot;functions-string#FUNCTIONS-STRING-SQL&quot;&gt;표 9.9에&lt;/a&gt; 있습니다. PostgreSQL은 일반 함수 호출 구문을 사용하는 이러한 함수 버전도 제공합니다 ( &lt;a href=&quot;functions-string#FUNCTIONS-STRING-OTHER&quot;&gt;표 9.10&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a497b6b015e330bfe740a1bf7d4ecce6f82a4e18" translate="yes" xml:space="preserve">
          <source>SQL defines two primary character types: &lt;code&gt;character varying(n)&lt;/code&gt; and &lt;code&gt;character(n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a positive integer. Both of these types can store strings up to &lt;code&gt;n&lt;/code&gt; characters (not bytes) in length. An attempt to store a longer string into a column of these types will result in an error, unless the excess characters are all spaces, in which case the string will be truncated to the maximum length. (This somewhat bizarre exception is required by the SQL standard.) If the string to be stored is shorter than the declared length, values of type &lt;code&gt;character&lt;/code&gt; will be space-padded; values of type &lt;code&gt;character varying&lt;/code&gt; will simply store the shorter string.</source>
          <target state="translated">SQL은 &lt;code&gt;character varying(n)&lt;/code&gt; 및 &lt;code&gt;character(n)&lt;/code&gt; 두 가지 기본 문자 유형을 정의합니다. 여기서 &lt;code&gt;n&lt;/code&gt; 은 양의 정수입니다. 이 두 유형 모두 문자열을 최대 &lt;code&gt;n&lt;/code&gt; 자 (바이트가 아님) 까지 저장할 수 있습니다 . 초과 문자가 모두 공백이 아닌 한, 더 긴 문자열을 이러한 유형의 열에 저장하려고하면 오류가 발생하며,이 경우 문자열이 최대 길이로 잘립니다. (이 표준은 다소 기괴한 예외가 SQL 표준에 필요합니다.) 저장 될 문자열이 선언 된 길이보다 짧은 경우, &lt;code&gt;character&lt;/code&gt; 유형의 값은 공백으로 채워집니다. &lt;code&gt;character varying&lt;/code&gt; 유형의 값은 더 짧은 문자열을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="30b0fb5e98403d1665277637d2af26848e3d9d16" translate="yes" xml:space="preserve">
          <source>SQL distinguishes between &lt;em&gt;reserved&lt;/em&gt; and &lt;em&gt;non-reserved&lt;/em&gt; key words. According to the standard, reserved key words are the only real key words; they are never allowed as identifiers. Non-reserved key words only have a special meaning in particular contexts and can be used as identifiers in other contexts. Most non-reserved key words are actually the names of built-in tables and functions specified by SQL. The concept of non-reserved key words essentially only exists to declare that some predefined meaning is attached to a word in some contexts.</source>
          <target state="translated">SQL은 &lt;em&gt;예약 &lt;/em&gt;&lt;em&gt;된&lt;/em&gt; 키워드 와 &lt;em&gt;예약 &lt;/em&gt;&lt;em&gt;되지 않은&lt;/em&gt; 키워드를 구별 합니다. 표준에 따르면, 예약 키워드는 유일한 실제 키워드입니다. 식별자로 허용되지 않습니다. 예약되지 않은 키워드는 특정 상황에서만 특별한 의미를 가지며 다른 상황에서 식별자로 사용될 수 있습니다. 예약되지 않은 대부분의 키워드는 실제로 SQL에서 지정한 내장 테이블 및 함수의 이름입니다. 예약되지 않은 키워드의 개념은 본질적으로 일부 사전 정의 된 의미가 일부 컨텍스트에서 단어에 첨부되어 있음을 선언하기 위해서만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="ec2a1f9054d07ada194d645f7dd19b745d42e99b" translate="yes" xml:space="preserve">
          <source>SQL identifiers and key words must begin with a letter (&lt;code&gt;a&lt;/code&gt;-&lt;code&gt;z&lt;/code&gt;, but also letters with diacritical marks and non-Latin letters) or an underscore (&lt;code&gt;_&lt;/code&gt;). Subsequent characters in an identifier or key word can be letters, underscores, digits (&lt;code&gt;0&lt;/code&gt;-&lt;code&gt;9&lt;/code&gt;), or dollar signs (&lt;code&gt;$&lt;/code&gt;). Note that dollar signs are not allowed in identifiers according to the letter of the SQL standard, so their use might render applications less portable. The SQL standard will not define a key word that contains digits or starts or ends with an underscore, so identifiers of this form are safe against possible conflict with future extensions of the standard.</source>
          <target state="translated">SQL ID 및 키워드는 문자 ( &lt;code&gt;a&lt;/code&gt; - &lt;code&gt;z&lt;/code&gt; 이지만 분음 기호 및 비 라틴 문자가있는 문자) 또는 밑줄 ( &lt;code&gt;_&lt;/code&gt; )로 시작해야합니다. 식별자 또는 키워드의 후속 문자는 문자, 밑줄, 숫자 (수 있습니다 &lt;code&gt;0&lt;/code&gt; - &lt;code&gt;9&lt;/code&gt; , 또는 달러 기호 () &lt;code&gt;$&lt;/code&gt; ). SQL 표준의 문자에 따라 식별자에 달러 기호를 사용할 수 없으므로 사용시 응용 프로그램의 이식성이 떨어질 수 있습니다. SQL 표준은 숫자를 포함하거나 밑줄로 시작하거나 밑줄로 끝나는 키워드를 정의하지 않으므로이 형식의 식별자는 향후 표준 확장과 충돌 할 가능성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="61673e852a4298e6fe28f40a88d7a0b73cb031b4" translate="yes" xml:space="preserve">
          <source>SQL input consists of a sequence of &lt;em&gt;commands&lt;/em&gt;. A command is composed of a sequence of &lt;em&gt;tokens&lt;/em&gt;, terminated by a semicolon (&amp;ldquo;;&amp;rdquo;). The end of the input stream also terminates a command. Which tokens are valid depends on the syntax of the particular command.</source>
          <target state="translated">SQL 입력은 일련의 &lt;em&gt;명령으로&lt;/em&gt; 구성됩니다 . 명령은 일련의 &lt;em&gt;토큰&lt;/em&gt; 으로 구성되며 세미콜론 ( &quot;;&quot;)으로 끝납니다. 입력 스트림의 끝도 명령을 종료합니다. 유효한 토큰은 특정 명령의 구문에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a0124049f46b5b7f47719e2938a3959c20ec2ce0" translate="yes" xml:space="preserve">
          <source>SQL is a strongly typed language. That is, every data item has an associated data type which determines its behavior and allowed usage. PostgreSQL has an extensible type system that is more general and flexible than other SQL implementations. Hence, most type conversion behavior in PostgreSQL is governed by general rules rather than by &lt;em&gt;ad hoc&lt;/em&gt; heuristics. This allows the use of mixed-type expressions even with user-defined types.</source>
          <target state="translated">SQL은 강력한 형식의 언어입니다. 즉, 모든 데이터 항목에는 동작 및 허용되는 사용량을 결정하는 관련 데이터 유형이 있습니다. PostgreSQL에는 다른 SQL 구현보다 더 일반적이고 유연한 확장 가능한 유형 시스템이 있습니다. 따라서 PostgreSQL의 대부분의 유형 변환 동작은 &lt;em&gt;임시&lt;/em&gt; 휴리스틱이 아닌 일반적인 규칙에 의해 관리됩니다 . 이를 통해 사용자 정의 형식에서도 혼합 형식 식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82e723af03d7112ba6e2fdad430227a5b2d24206" translate="yes" xml:space="preserve">
          <source>SQL object</source>
          <target state="translated">SQL 객체</target>
        </trans-unit>
        <trans-unit id="72a2f56fcbaf685b04bee00dedaa0944a11af68a" translate="yes" xml:space="preserve">
          <source>SQL only specifies the integer types &lt;code&gt;integer&lt;/code&gt; (or &lt;code&gt;int&lt;/code&gt;), &lt;code&gt;smallint&lt;/code&gt;, and &lt;code&gt;bigint&lt;/code&gt;. The type names &lt;code&gt;int2&lt;/code&gt;, &lt;code&gt;int4&lt;/code&gt;, and &lt;code&gt;int8&lt;/code&gt; are extensions, which are also used by some other SQL database systems.</source>
          <target state="translated">SQL은 정수 유형 &lt;code&gt;integer&lt;/code&gt; (또는 &lt;code&gt;int&lt;/code&gt; ), &lt;code&gt;smallint&lt;/code&gt; 및 &lt;code&gt;bigint&lt;/code&gt; 만 지정합니다 . &lt;code&gt;int2&lt;/code&gt; , &lt;code&gt;int4&lt;/code&gt; 및 &lt;code&gt;int8&lt;/code&gt; 유형 이름 은 확장명이며 다른 SQL 데이터베이스 시스템에서도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="26c0a0733071a752233b529d9be28bc34d094b1c" translate="yes" xml:space="preserve">
          <source>SQL requires a savepoint to be destroyed automatically when another savepoint with the same name is established. In PostgreSQL, the old savepoint is kept, though only the more recent one will be used when rolling back or releasing. (Releasing the newer savepoint with &lt;code&gt;RELEASE SAVEPOINT&lt;/code&gt; will cause the older one to again become accessible to &lt;code&gt;ROLLBACK TO SAVEPOINT&lt;/code&gt; and &lt;code&gt;RELEASE SAVEPOINT&lt;/code&gt;.) Otherwise, &lt;code&gt;SAVEPOINT&lt;/code&gt; is fully SQL conforming.</source>
          <target state="translated">이름이 같은 다른 저장 점이 설정되면 SQL에 저장 점이 자동으로 제거되어야합니다. PostgreSQL에서는 이전 세이브 포인트가 유지되지만 롤백하거나 릴리스 할 때는 최신 세이브 포인트 만 사용됩니다. &lt;code&gt;RELEASE SAVEPOINT&lt;/code&gt; 를 사용하여 새 저장 점을 해제 하면 이전 저장 점이 &lt;code&gt;ROLLBACK TO SAVEPOINT&lt;/code&gt; 및 &lt;code&gt;RELEASE SAVEPOINT&lt;/code&gt; 에 다시 액세스 할 수있게됩니다 . 그렇지 않으면 &lt;code&gt;SAVEPOINT&lt;/code&gt; 가 완전히 SQL을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="1c239e838c9d250a1fb9c5efb07b76cf00e7ef97" translate="yes" xml:space="preserve">
          <source>SQL specifies that &lt;code&gt;BEFORE DELETE&lt;/code&gt; triggers on cascaded deletes fire &lt;em&gt;after&lt;/em&gt; the cascaded &lt;code&gt;DELETE&lt;/code&gt; completes. The PostgreSQL behavior is for &lt;code&gt;BEFORE DELETE&lt;/code&gt; to always fire before the delete action, even a cascading one. This is considered more consistent. There is also nonstandard behavior if &lt;code&gt;BEFORE&lt;/code&gt; triggers modify rows or prevent updates during an update that is caused by a referential action. This can lead to constraint violations or stored data that does not honor the referential constraint.</source>
          <target state="translated">SQL 은 계단식 &lt;code&gt;DELETE&lt;/code&gt; 가 완료된 &lt;em&gt;후&lt;/em&gt; 계단식 삭제에서 &lt;code&gt;BEFORE DELETE&lt;/code&gt; 트리거가 실행 되도록 지정합니다 . PostgreSQL 비헤이비어는 &lt;code&gt;BEFORE DELETE&lt;/code&gt; 가 삭제 동작 전에 계단식으로 실행되기 전에 항상 발생합니다. 이것은 더 일관된 것으로 간주됩니다. &lt;code&gt;BEFORE&lt;/code&gt; 가 행 수정을 트리거하거나 참조 조치로 인해 업데이트 중에 업데이트를 방지하는 경우에도 비표준 동작이 있습니다 . 이로 인해 제한 조건 위반 또는 참조 제한 조건을 준수하지 않는 저장된 데이터가 발생할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11671fe053ce1592a4e16b009e40a2f5deac42c8" translate="yes" xml:space="preserve">
          <source>SQL specifies that multiple triggers should be fired in time-of-creation order. PostgreSQL uses name order, which was judged to be more convenient.</source>
          <target state="translated">SQL은 여러 트리거가 작성 시간 순서대로 실행되도록 지정합니다. PostgreSQL은보다 편리한 것으로 판단되는 이름 순서를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f90000aa91526b48e0716778b2523176a09fa0a8" translate="yes" xml:space="preserve">
          <source>SQL standard</source>
          <target state="translated">SQL 표준</target>
        </trans-unit>
        <trans-unit id="5ac61b1e5b5dc9089362bb1dfbdcf97bde7805b3" translate="yes" xml:space="preserve">
          <source>SQL standard format: 1 year 2 months</source>
          <target state="translated">SQL 표준 형식 : 1 년 2 개월</target>
        </trans-unit>
        <trans-unit id="7857b228e9efbb70f80b0029fe2e0f16e3eb640f" translate="yes" xml:space="preserve">
          <source>SQL standard format: 3 days 4 hours 5 minutes 6 seconds</source>
          <target state="translated">SQL 표준 형식 : 3 일 4 시간 5 분 6 초</target>
        </trans-unit>
        <trans-unit id="82c859d1f3667694d2494f25690cbab016f76960" translate="yes" xml:space="preserve">
          <source>SQL uses a three-valued logic system with true, false, and &lt;code&gt;null&lt;/code&gt;, which represents &amp;ldquo;unknown&amp;rdquo;. Observe the following truth tables:</source>
          <target state="translated">SQL은 &quot;알 수 없음&quot;을 나타내는 true, false 및 &lt;code&gt;null&lt;/code&gt; 과 함께 3 값 논리 시스템을 사용합니다 . 다음 진리표를 준수하십시오.</target>
        </trans-unit>
        <trans-unit id="f79470b3ee244f840e7d2d4a78791cf5daef595b" translate="yes" xml:space="preserve">
          <source>SQL-92</source>
          <target state="translated">SQL-92</target>
        </trans-unit>
        <trans-unit id="ed75c8b48831fe41ac7f21beeb8dfe2bcff55ab6" translate="yes" xml:space="preserve">
          <source>SQL-Based Replication Middleware</source>
          <target state="translated">SQL 기반 복제 미들웨어</target>
        </trans-unit>
        <trans-unit id="884b56143a83902d89ca94cfbf6e0c50f0a4b7ed" translate="yes" xml:space="preserve">
          <source>SQL-language functions that are simple enough to be &amp;ldquo;inlined&amp;rdquo; into the calling query will not be tracked, regardless of this setting.</source>
          <target state="translated">호출 쿼리에 &quot;인라인&quot;될 수있을 정도로 간단한 SQL 언어 함수는이 설정에 관계없이 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="396d530882aca889c386f5cfc0e495440f5d041a" translate="yes" xml:space="preserve">
          <source>SQL/JSON arrays are 0-relative, unlike regular SQL arrays that start from 1.</source>
          <target state="translated">SQL / JSON 배열은 1부터 시작하는 일반 SQL 배열과 달리 0을 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="72f791640f6b8591ac7a9f46ee935dda3c25679d" translate="yes" xml:space="preserve">
          <source>SQL/JSON path expressions allow matching text to a regular expression with the &lt;code&gt;like_regex&lt;/code&gt; filter. For example, the following SQL/JSON path query would case-insensitively match all strings in an array that start with an English vowel:</source>
          <target state="translated">SQL / JSON 경로 표현식을 사용하면 &lt;code&gt;like_regex&lt;/code&gt; 필터를 사용하여 텍스트를 정규 표현식에 일치 시킬 수 있습니다. 예를 들어, 다음 SQL / JSON 경로 쿼리는 영어 모음으로 시작하는 배열의 모든 문자열을 대소 문자를 구분하지 않고 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="1f723a202e85aa4a821b4382dc10a12a217b0e03" translate="yes" xml:space="preserve">
          <source>SQL/JSON path expressions specify the items to be retrieved from the JSON data, similar to XPath expressions used for SQL access to XML. In PostgreSQL, path expressions are implemented as the &lt;code&gt;jsonpath&lt;/code&gt; data type and can use any elements described in &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;Section 8.14.6&lt;/a&gt;.</source>
          <target state="translated">SQL / JSON 경로 표현식은 XML에 대한 SQL 액세스에 사용되는 XPath 표현식과 유사하게 JSON 데이터에서 검색 할 항목을 지정합니다. PostgreSQL에서 경로 표현식은 &lt;code&gt;jsonpath&lt;/code&gt; 데이터 형식 으로 구현되며 8.14.6 &lt;a href=&quot;datatype-json#DATATYPE-JSONPATH&quot;&gt;절에&lt;/a&gt; 설명 된 요소를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="176bb82da3b29b559ce48dbf3e06ea17f7de00a5" translate="yes" xml:space="preserve">
          <source>SQL:1999 and later use a slightly different definition which is not entirely upward compatible with SQL-92. In most cases, however, PostgreSQL will interpret an &lt;code&gt;ORDER BY&lt;/code&gt; or &lt;code&gt;GROUP BY&lt;/code&gt; expression the same way SQL:1999 does.</source>
          <target state="translated">SQL : 1999 이상은 SQL-92와 완전히 호환되지 않는 약간 다른 정의를 사용합니다. 그러나 대부분의 경우 PostgreSQL은 SQL : 1999와 같은 방식으로 &lt;code&gt;ORDER BY&lt;/code&gt; 또는 &lt;code&gt;GROUP BY&lt;/code&gt; 표현식 을 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="175caa438cc0c85490ce98c2d0dc3ecfa1e51adc" translate="yes" xml:space="preserve">
          <source>SQL:2008 introduced a different syntax to achieve the same result, which PostgreSQL also supports. It is:</source>
          <target state="translated">SQL : 2008은 PostgreSQL에서도 지원하는 동일한 결과를 얻기 위해 다른 구문을 도입했습니다. 그것은:</target>
        </trans-unit>
        <trans-unit id="984c51e54e6539d7d0b9df0afe24e6672f17c063" translate="yes" xml:space="preserve">
          <source>SQL:2011</source>
          <target state="translated">SQL:2011</target>
        </trans-unit>
        <trans-unit id="25a10c42e37bdc3f41e2ba28de017247195ceec9" translate="yes" xml:space="preserve">
          <source>SQL:2016</source>
          <target state="translated">SQL:2016</target>
        </trans-unit>
        <trans-unit id="a903e9c7ff9ddbfcd112771c78c6496174606de1" translate="yes" xml:space="preserve">
          <source>SQLSTATE error code</source>
          <target state="translated">SQLSTATE 오류 코드</target>
        </trans-unit>
        <trans-unit id="1c99e19efe064a97f1f0d667e41e711ee2ae8217" translate="yes" xml:space="preserve">
          <source>SRF</source>
          <target state="translated">SRF</target>
        </trans-unit>
        <trans-unit id="839226786b62bf95c9258e79140ac43890ceae07" translate="yes" xml:space="preserve">
          <source>SSH</source>
          <target state="translated">SSH</target>
        </trans-unit>
        <trans-unit id="78bb8826fcc2504583e625386c238563e6207595" translate="yes" xml:space="preserve">
          <source>SSL</source>
          <target state="translated">SSL</target>
        </trans-unit>
        <trans-unit id="75f5b809fd16f8c1f83643b71df6da31e8d39d40" translate="yes" xml:space="preserve">
          <source>SSL Host Authentication</source>
          <target state="translated">SSL 호스트 인증</target>
        </trans-unit>
        <trans-unit id="799d9c3ec94ba9c3e1fb61b95c4ea8663387f535" translate="yes" xml:space="preserve">
          <source>SSL connections encrypt all data sent across the network: the password, the queries, and the data returned. The &lt;code&gt;pg_hba.conf&lt;/code&gt; file allows administrators to specify which hosts can use non-encrypted connections (&lt;code&gt;host&lt;/code&gt;) and which require SSL-encrypted connections (&lt;code&gt;hostssl&lt;/code&gt;). Also, clients can specify that they connect to servers only via SSL.</source>
          <target state="translated">SSL 연결은 네트워크를 통해 전송 된 모든 데이터 (암호, 쿼리 및 반환 된 데이터)를 암호화합니다. &lt;code&gt;pg_hba.conf&lt;/code&gt; 파일 관리자는 호스트가 암호화되지 않은 연결 (사용할 수있는 지정할 수 있습니다 &lt;code&gt;host&lt;/code&gt; ) 및 SSL 암호화 연결 (필요 &lt;code&gt;hostssl&lt;/code&gt; 을 ). 또한 클라이언트는 SSL을 통해서만 서버에 연결하도록 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d50390961a0b32adc3073373e957f54be2007ad1" translate="yes" xml:space="preserve">
          <source>SSPI</source>
          <target state="translated">SSPI</target>
        </trans-unit>
        <trans-unit id="d05c3657583117ef9526aa06e8764eb1af739953" translate="yes" xml:space="preserve">
          <source>SSPI Authentication</source>
          <target state="translated">SSPI 인증</target>
        </trans-unit>
        <trans-unit id="52401dd05ffd3ca82cab3bd4cdf18c622b87752b" translate="yes" xml:space="preserve">
          <source>SSPI is a Windows technology for secure authentication with single sign-on. PostgreSQL will use SSPI in &lt;code&gt;negotiate&lt;/code&gt; mode, which will use Kerberos when possible and automatically fall back to NTLM in other cases. SSPI authentication only works when both server and client are running Windows, or, on non-Windows platforms, when GSSAPI is available.</source>
          <target state="translated">SSPI는 싱글 사인온을 통한 보안 인증을위한 Windows 기술입니다. PostgreSQL은 &lt;code&gt;negotiate&lt;/code&gt; 모드 에서 SSPI를 사용하며, 가능하면 Kerberos를 사용하고 다른 경우에는 자동으로 NTLM으로 대체됩니다. SSPI 인증은 서버와 클라이언트가 모두 Windows를 실행 중이거나 Windows 이외의 플랫폼에서 GSSAPI를 사용할 수있는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="31af9d39b417e9de78c051ce8339a8b204511160" translate="yes" xml:space="preserve">
          <source>START TRANSACTION</source>
          <target state="translated">거래 시작</target>
        </trans-unit>
        <trans-unit id="7a6120ce22115bdf90b8e5ee1fb574b72a4d3d6c" translate="yes" xml:space="preserve">
          <source>START TRANSACTION &amp;mdash; start a transaction block</source>
          <target state="translated">거래 시작 &amp;mdash; 거래 블록을 시작합니다</target>
        </trans-unit>
        <trans-unit id="7d900f37c21b42b857e58379babe502b8de7b073" translate="yes" xml:space="preserve">
          <source>SYSV</source>
          <target state="translated">SYSV</target>
        </trans-unit>
        <trans-unit id="2fbe56d80bc33f157b40f13705029851c03baa63" translate="yes" xml:space="preserve">
          <source>Safely write all database files to disk and exit. This does not perform any of the normal initdb operations.</source>
          <target state="translated">모든 데이터베이스 파일을 디스크에 안전하게 쓰고 종료하십시오. 일반적인 initdb 작업은 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="991f9ff1b1ca6d7141558d8175d57bda83d57350" translate="yes" xml:space="preserve">
          <source>Salt Bits</source>
          <target state="translated">소금 조금</target>
        </trans-unit>
        <trans-unit id="6293703460a43f11122394b7f0d04b7170d07c35" translate="yes" xml:space="preserve">
          <source>Same as &amp;mdash; The segments [a, b] and [c, d] are identical, that is, a = c and b = d.</source>
          <target state="translated">동일 &amp;mdash; 세그먼트 [a, b]와 [c, d]가 동일합니다. 즉 a = c와 b = d입니다.</target>
        </trans-unit>
        <trans-unit id="30116d0842065b110cb0105ab36a39499acf6dbd" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;.**&lt;/code&gt;, but with a filter over nesting levels of JSON hierarchy. Nesting levels are specified as integers. Zero level corresponds to the current object. To access the lowest nesting level, you can use the &lt;code&gt;last&lt;/code&gt; keyword. This is a PostgreSQL extension of the SQL/JSON standard.</source>
          <target state="translated">&lt;code&gt;.**&lt;/code&gt; 와 동일 하지만 중첩 수준의 JSON 계층 구조에 대한 필터가 있습니다. 중첩 수준은 정수로 지정됩니다. 제로 레벨은 현재 객체에 해당합니다. 가장 낮은 중첩 수준에 액세스하려면 &lt;code&gt;last&lt;/code&gt; 키워드를 사용할 수 있습니다 . 이것은 SQL / JSON 표준의 PostgreSQL 확장입니다.</target>
        </trans-unit>
        <trans-unit id="c34b09b66be40aef26e7e9ed1a4c53f473498d8e" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;\setshell&lt;/code&gt;, but the result of the command is discarded.</source>
          <target state="translated">&lt;code&gt;\setshell&lt;/code&gt; 과 동일 하지만 명령 결과는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3aa9c47501819277365c57d68d78a3dc1b716967" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;, except that only indexes on system tables are shown.</source>
          <target state="translated">동일 &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; 시스템 테이블 상에 인덱스를 제외하고는, 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6623d67b9186ea331111cca75554c88ad4177489" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;pg_stat_all_indexes&lt;/code&gt;, except that only indexes on user tables are shown.</source>
          <target state="translated">동일 &lt;code&gt;pg_stat_all_indexes&lt;/code&gt; 유저 테이블에 인덱스를 제외하고는, 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b0a09f23e5a698f94156c58b4dfcbfdb11a63992" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;pg_stat_all_tables&lt;/code&gt;, except that only system tables are shown.</source>
          <target state="translated">동일 &lt;code&gt;pg_stat_all_tables&lt;/code&gt; 만 시스템 테이블을 제외하고는, 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2fd36ceac7544411d132f394cfd51cf8cb5b9eb0" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;pg_stat_all_tables&lt;/code&gt;, except that only user tables are shown.</source>
          <target state="translated">동일 &lt;code&gt;pg_stat_all_tables&lt;/code&gt; 만 사용자 테이블을 제외하고는, 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3d18e7f77ee7d734f9d3c06caa22fa6d2381239e" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt;, except that only system tables are shown.</source>
          <target state="translated">동일 &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt; 만 시스템 테이블을 제외하고는, 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4bd260bbf827ee3015b6b0e21409fa4bcf543730" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt;, except that only user tables are shown.</source>
          <target state="translated">동일 &lt;code&gt;pg_stat_xact_all_tables&lt;/code&gt; 만 사용자 테이블을 제외하고는, 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e8efd1b61c42e9db6ce0135824836d5868a7be9d" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;pg_statio_all_indexes&lt;/code&gt;, except that only indexes on system tables are shown.</source>
          <target state="translated">동일 &lt;code&gt;pg_statio_all_indexes&lt;/code&gt; 시스템 테이블 상에 인덱스를 제외하고는, 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d2dfcc70130a65c4642e59f998a55a8bc204ba75" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;pg_statio_all_indexes&lt;/code&gt;, except that only indexes on user tables are shown.</source>
          <target state="translated">동일 &lt;code&gt;pg_statio_all_indexes&lt;/code&gt; 유저 테이블에 인덱스를 제외하고는, 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9a6baa118a4ad107eb8341fa0f670c417e86efec" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;pg_statio_all_sequences&lt;/code&gt;, except that only system sequences are shown. (Presently, no system sequences are defined, so this view is always empty.)</source>
          <target state="translated">동일 &lt;code&gt;pg_statio_all_sequences&lt;/code&gt; 유일한 시스템 시퀀스가 표시된다는 점을 제외하고. (현재 시스템 시퀀스가 ​​정의되어 있지 않으므로이 뷰는 항상 비어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="66c6e90b8b50ab3b105ec81afd9f726e9a0948f6" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;pg_statio_all_sequences&lt;/code&gt;, except that only user sequences are shown.</source>
          <target state="translated">동일 &lt;code&gt;pg_statio_all_sequences&lt;/code&gt; 유일한 사용자 시퀀스가 표시된다는 점을 제외하고.</target>
        </trans-unit>
        <trans-unit id="438a4c6f2d0c87790b8abacd03d7e84f41d3e681" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;pg_statio_all_tables&lt;/code&gt;, except that only system tables are shown.</source>
          <target state="translated">동일 &lt;code&gt;pg_statio_all_tables&lt;/code&gt; 만 시스템 테이블을 제외하고는, 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="164d2a01903e2d1159e6f8a5c1e4612c60aab48e" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;pg_statio_all_tables&lt;/code&gt;, except that only user tables are shown.</source>
          <target state="translated">동일 &lt;code&gt;pg_statio_all_tables&lt;/code&gt; 만 사용자 테이블을 제외하고는, 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a77043c28a680c2ab376ef9d079737021fff1194" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;ssl_client_dn_field&lt;/code&gt;, but for the certificate issuer rather than the certificate subject.</source>
          <target state="translated">&lt;code&gt;ssl_client_dn_field&lt;/code&gt; 와 동일 하지만 인증서 주체가 아닌 인증서 발급자의 경우</target>
        </trans-unit>
        <trans-unit id="1413a7ef2814fa6b0f5de019f0154a3e3c333237" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;word_similarity(text, text)&lt;/code&gt;, but forces extent boundaries to match word boundaries. Since we don't have cross-word trigrams, this function actually returns greatest similarity between first string and any continuous extent of words of the second string.</source>
          <target state="translated">&lt;code&gt;word_similarity(text, text)&lt;/code&gt; 와 동일 하지만 범위 경계가 단어 경계와 일치하도록합니다. 크로스 워드 트라이 그램이 없기 때문에이 함수는 실제로 첫 번째 문자열과 두 번째 문자열의 연속 된 단어 범위간에 가장 큰 유사성을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2bca3bb3942bc3c4db82b8457690f23b6a1b09a5" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;word_similarity&lt;/code&gt;, but forces extent boundaries to match word boundaries. Since we don't have cross-word trigrams, this function actually returns greatest similarity between first string and any continuous extent of words of the second string.</source>
          <target state="translated">&lt;code&gt;word_similarity&lt;/code&gt; 와 동일 하지만 범위 경계가 단어 경계와 일치하도록 강제합니다. 크로스 워드 트라이 그램이 없기 때문에이 함수는 실제로 첫 번째 문자열과 두 번째 문자열의 연속적인 단어 범위 사이에 가장 큰 유사성을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3ad74946392dd878bc042f0609aca2be883ed9b7" translate="yes" xml:space="preserve">
          <source>Same as above</source>
          <target state="translated">같은 상기와</target>
        </trans-unit>
        <trans-unit id="8215fd43b7fa7c92178d9857533890db2546d9e7" translate="yes" xml:space="preserve">
          <source>Same as?</source>
          <target state="translated">같은가요?</target>
        </trans-unit>
        <trans-unit id="437c1f3a262710aa22c56be425fd705652c3be30" translate="yes" xml:space="preserve">
          <source>Sampling rate, used when writing data into the log, to reduce the amount of log generated. If this option is given, only the specified fraction of transactions are logged. 1.0 means all transactions will be logged, 0.05 means only 5% of the transactions will be logged.</source>
          <target state="translated">로그에 데이터를 쓸 때 생성되는 로그의 양을 줄이기 위해 사용되는 샘플링 속도. 이 옵션을 지정하면 지정된 부분의 트랜잭션 만 기록됩니다. 1.0은 모든 트랜잭션이 기록됨을 의미하고 0.05는 트랜잭션의 5 % 만 기록됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6b782d41b0c29e2f39f93a8352c43300b042c6cd" translate="yes" xml:space="preserve">
          <source>Sat</source>
          <target state="translated">Sat</target>
        </trans-unit>
        <trans-unit id="17063c506b81a46c2eb7716af50cf19d4ed5a6c6" translate="yes" xml:space="preserve">
          <source>Saturday</source>
          <target state="translated">Saturday</target>
        </trans-unit>
        <trans-unit id="9903d5e707096f81b8c4f6f708ff17d88237c305" translate="yes" xml:space="preserve">
          <source>Save any configuration files from the old standbys' configuration directories you need to keep, e.g. &lt;code&gt;postgresql.conf&lt;/code&gt;, &lt;code&gt;pg_hba.conf&lt;/code&gt;, because these will be overwritten or removed in the next step.</source>
          <target state="translated">다음 단계에서 덮어 쓰거나 제거되므로 &lt;code&gt;postgresql.conf&lt;/code&gt; , &lt;code&gt;pg_hba.conf&lt;/code&gt; 와 같이 유지해야하는 이전 대기 구성 디렉토리에서 구성 파일을 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="197b51533f57e1682b1a7c1d1566dab9314b3b60" translate="yes" xml:space="preserve">
          <source>Save any configuration files from the old standbys' configuration directories you need to keep, e.g., &lt;code&gt;postgresql.conf&lt;/code&gt; (and any files included by it), &lt;code&gt;postgresql.auto.conf&lt;/code&gt;, &lt;code&gt;pg_hba.conf&lt;/code&gt;, because these will be overwritten or removed in the next step.</source>
          <target state="translated">유지해야하는 이전 대기의 구성 디렉토리 ( 예 : &lt;code&gt;postgresql.conf&lt;/code&gt; (및 그에 포함 된 모든 파일), &lt;code&gt;postgresql.auto.conf&lt;/code&gt; , &lt;code&gt;pg_hba.conf&lt;/code&gt; ) 에서 구성 파일을 저장하십시오 . 다음에서 덮어 쓰거나 제거됩니다. 단계.</target>
        </trans-unit>
        <trans-unit id="67ff8e5fefb96820266599c347303f3a5cb1d59c" translate="yes" xml:space="preserve">
          <source>Save the current snapshot and return its identifier</source>
          <target state="translated">현재 스냅 샷을 저장하고 식별자를 반환</target>
        </trans-unit>
        <trans-unit id="c739de5dc59a519ecc88e91c12cee776ddb9f8ec" translate="yes" xml:space="preserve">
          <source>Savepoint</source>
          <target state="translated">Savepoint</target>
        </trans-unit>
        <trans-unit id="00974b83a4583d069996b8466e13d0e8e4834890" translate="yes" xml:space="preserve">
          <source>Savepoints can only be established when inside a transaction block. There can be multiple savepoints defined within a transaction.</source>
          <target state="translated">저장 점은 트랜잭션 블록 내부에있을 때만 설정할 수 있습니다. 트랜잭션 내에 여러 저장 점이 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea9e15cef11ce177208340eca743c50c6ebdda91" translate="yes" xml:space="preserve">
          <source>Saves the transaction's current snapshot and returns a &lt;code&gt;text&lt;/code&gt; string identifying the snapshot. This string must be passed (outside the database) to clients that want to import the snapshot. The snapshot is available for import only until the end of the transaction that exported it.</source>
          <target state="translated">트랜잭션의 현재 스냅 샷을 저장하고 스냅 샷을 식별 하는 &lt;code&gt;text&lt;/code&gt; 문자열을 반환합니다 . 이 문자열은 스냅 샷을 가져 오려는 클라이언트에 전달되어야합니다 (데이터베이스 외부). 스냅 샷은 내 보낸 트랜잭션이 끝날 때까지만 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4d66c40739cf077a9f02a7b272e595edee0d893" translate="yes" xml:space="preserve">
          <source>Say you have the product table that we have used several times already:</source>
          <target state="translated">이미 여러 번 사용한 제품 테이블이 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="70179422480cc7a6be16892c0ded3ba925bba80d" translate="yes" xml:space="preserve">
          <source>Scale of the argument (the number of decimal digits in the fractional part)</source>
          <target state="translated">인수의 스케일 (소수 부분의 소수 자릿수)</target>
        </trans-unit>
        <trans-unit id="03e2e8c190b7bc78ca87cfad0aa006018914c37c" translate="yes" xml:space="preserve">
          <source>Scaling/rotation</source>
          <target state="translated">Scaling/rotation</target>
        </trans-unit>
        <trans-unit id="25433afa84d6a7243bf01819a4ead6aed2ca4602" translate="yes" xml:space="preserve">
          <source>Scan the WAL log of the target cluster, starting from the last checkpoint before the point where the source cluster's timeline history forked off from the target cluster. For each WAL record, record each data block that was touched. This yields a list of all the data blocks that were changed in the target cluster, after the source cluster forked off.</source>
          <target state="translated">소스 클러스터의 타임 라인 기록이 대상 클러스터에서 분기 된 지점 이전의 마지막 검사 점부터 시작하여 대상 클러스터의 WAL 로그를 스캔하십시오. 각 WAL 레코드에 대해 터치 한 각 데이터 블록을 기록하십시오. 그러면 소스 클러스터가 분기 된 후 대상 클러스터에서 변경된 모든 데이터 블록 목록이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7f54bb96b496274d400c5ef09c831d65b2d40365" translate="yes" xml:space="preserve">
          <source>Scan the WAL log of the target cluster, starting from the last checkpoint before the point where the source cluster's timeline history forked off from the target cluster. For each WAL record, record each data block that was touched. This yields a list of all the data blocks that were changed in the target cluster, after the source cluster forked off. If some of the WAL files are no longer available, try re-running pg_rewind with the &lt;code&gt;-c&lt;/code&gt; option to search for the missing files in the WAL archive.</source>
          <target state="translated">소스 클러스터의 타임 라인 기록이 대상 클러스터에서 분기 된 지점 이전의 마지막 체크 포인트부터 시작하여 대상 클러스터의 WAL 로그를 스캔합니다. 각 WAL 레코드에 대해 터치 된 각 데이터 블록을 기록합니다. 그러면 소스 클러스터가 분기 된 후 대상 클러스터에서 변경된 모든 데이터 블록 목록이 생성됩니다. 일부 WAL 파일을 더 이상 사용할 수없는 경우 &lt;code&gt;-c&lt;/code&gt; 옵션 과 함께 pg_rewind를 다시 실행 하여 WAL 아카이브에서 누락 된 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="ee03ab84f43bdf9fc596fbd2d181195ac9c0b33a" translate="yes" xml:space="preserve">
          <source>Scanning a large table to verify a new foreign key or check constraint can take a long time, and other updates to the table are locked out until the &lt;code&gt;ALTER TABLE ADD CONSTRAINT&lt;/code&gt; command is committed. The main purpose of the &lt;code&gt;NOT VALID&lt;/code&gt; constraint option is to reduce the impact of adding a constraint on concurrent updates. With &lt;code&gt;NOT VALID&lt;/code&gt;, the &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; command does not scan the table and can be committed immediately. After that, a &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; command can be issued to verify that existing rows satisfy the constraint. The validation step does not need to lock out concurrent updates, since it knows that other transactions will be enforcing the constraint for rows that they insert or update; only pre-existing rows need to be checked. Hence, validation acquires only a &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; lock on the table being altered. (If the constraint is a foreign key then a &lt;code&gt;ROW SHARE&lt;/code&gt; lock is also required on the table referenced by the constraint.) In addition to improving concurrency, it can be useful to use &lt;code&gt;NOT VALID&lt;/code&gt; and &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; in cases where the table is known to contain pre-existing violations. Once the constraint is in place, no new violations can be inserted, and the existing problems can be corrected at leisure until &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; finally succeeds.</source>
          <target state="translated">새 외래 키 또는 검사 제한 조건을 확인하기 위해 큰 테이블을 스캔하는 데 시간이 오래 걸릴 수 있으며 &lt;code&gt;ALTER TABLE ADD CONSTRAINT&lt;/code&gt; 명령이 커밋 될 때까지 테이블에 대한 다른 업데이트가 잠 깁니다 . &lt;code&gt;NOT VALID&lt;/code&gt; 제약 조건 옵션 의 주요 목적은 동시 업데이트에 제약 조건을 추가 할 때의 영향을 줄이는 것입니다. 로 &lt;code&gt;NOT VALID&lt;/code&gt; 의 &lt;code&gt;ADD CONSTRAINT&lt;/code&gt; 명령은 테이블을 스캔하지 않고 즉시 커밋 할 수 있습니다. 그 후, &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; 기존 행이 제한 조건을 만족하는지 확인하기 위해 명령을 실행할 수 있습니다. 유효성 검사 단계에서는 다른 트랜잭션이 삽입하거나 업데이트하는 행에 대한 제약 조건을 적용한다는 것을 알고 있기 때문에 동시 업데이트를 잠글 필요가 없습니다. 기존 행만 확인하면됩니다. 따라서 유효성 검증은 변경되는 테이블에 대한 &lt;code&gt;SHARE UPDATE EXCLUSIVE&lt;/code&gt; 잠금 만 획득합니다 . 제약 조건이 외래 키인 경우 제약 조건 에서 참조하는 테이블에 &lt;code&gt;ROW SHARE&lt;/code&gt; 잠금도 필요합니다. 동시성을 개선하는 것 외에도 &lt;code&gt;NOT VALID&lt;/code&gt; 및 &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; 를 사용하는 것이 유용 할 수 있습니다.테이블에 기존 위반이 포함 된 것으로 알려진 경우. 구속 조건이 설정되면 새로운 위반을 삽입 할 수 없으며 &lt;code&gt;VALIDATE CONSTRAINT&lt;/code&gt; 가 최종적으로 성공할 때까지 여가 시간에 기존 문제를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ff0f6c62975ef14225df2367c5a97d37335cd89" translate="yes" xml:space="preserve">
          <source>Scans of common table expressions (CTEs).</source>
          <target state="translated">공통 테이블 표현식 (CTE)을 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="7734d5050292021df5a3f59cadc2276fa46eab6c" translate="yes" xml:space="preserve">
          <source>Scans of foreign tables, unless the foreign data wrapper has an &lt;code&gt;IsForeignScanParallelSafe&lt;/code&gt; API which indicates otherwise.</source>
          <target state="translated">외부 데이터 랩퍼에 다른 방법으로 표시 하는 &lt;code&gt;IsForeignScanParallelSafe&lt;/code&gt; API 가없는 경우 외부 테이블의 스캔 .</target>
        </trans-unit>
        <trans-unit id="0af2fa08ad9416fdc99daa54c4628ea4316b4703" translate="yes" xml:space="preserve">
          <source>Scans of temporary tables.</source>
          <target state="translated">임시 테이블을 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="1800a2410200234f84590555f872495db13bd0de" translate="yes" xml:space="preserve">
          <source>Scans the specified BRIN index to find page ranges in the base table that are not currently summarized by the index; for any such range it creates a new summary index tuple by scanning those table pages. Returns the number of new page range summaries that were inserted into the index.</source>
          <target state="translated">지정된 BRIN 인덱스를 스캔하여 현재 인덱스로 요약되지 않은 기본 테이블의 페이지 범위를 찾습니다. 이러한 범위에 대해 해당 테이블 페이지를 스캔하여 새로운 요약 인덱스 튜플을 만듭니다. 색인에 삽입 된 새 페이지 범위 요약 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="55c9c1619579d6d58862bfb4678195a9a701b18b" translate="yes" xml:space="preserve">
          <source>Schema containing the extension's exported objects</source>
          <target state="translated">확장의 내 보낸 객체를 포함하는 스키마</target>
        </trans-unit>
        <trans-unit id="e822bade7555ec9a940ddf4e7370bf08bf08ae5c" translate="yes" xml:space="preserve">
          <source>Schema names beginning with &lt;code&gt;pg_&lt;/code&gt; are reserved for system purposes and cannot be created by users.</source>
          <target state="translated">&lt;code&gt;pg_&lt;/code&gt; 로 시작하는 스키마 이름 은 시스템 용으로 예약되어 있으며 사용자가 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="db77ed065e4e0ae24d5474707494552cb72cf711" translate="yes" xml:space="preserve">
          <source>Schemas</source>
          <target state="translated">Schemas</target>
        </trans-unit>
        <trans-unit id="b8b247157bec97dc65f9b4376bf7e57f06f5951b" translate="yes" xml:space="preserve">
          <source>Schemas are analogous to directories at the operating system level, except that schemas cannot be nested.</source>
          <target state="translated">스키마는 스키마를 중첩 할 수 없다는 점을 제외하고 운영 체제 레벨의 디렉토리와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="f2da0283730db3d2b7995123cd8465de0434e6bc" translate="yes" xml:space="preserve">
          <source>Schemas can be used to organize your data in many ways. A &lt;em&gt;secure schema usage pattern&lt;/em&gt; prevents untrusted users from changing the behavior of other users' queries. When a database does not use a secure schema usage pattern, users wishing to securely query that database would take protective action at the beginning of each session. Specifically, they would begin each session by setting &lt;code&gt;search_path&lt;/code&gt; to the empty string or otherwise removing non-superuser-writable schemas from &lt;code&gt;search_path&lt;/code&gt;. There are a few usage patterns easily supported by the default configuration:</source>
          <target state="translated">스키마는 다양한 방법으로 데이터를 구성하는 데 사용할 수 있습니다. &lt;em&gt;보안 스키마 사용 패턴은&lt;/em&gt; 다른 사용자의 쿼리의 동작을 변경하는 신뢰할 수없는 사용자를 방지 할 수 있습니다. 데이터베이스가 보안 스키마 사용 패턴을 사용하지 않는 경우 해당 데이터베이스를 안전하게 쿼리하려는 사용자는 각 세션이 시작될 때 보호 조치를 취합니다. 특히, 그들은 &lt;code&gt;search_path&lt;/code&gt; 를 빈 문자열 로 설정 하거나 그렇지 않으면 &lt;code&gt;search_path&lt;/code&gt; 에서 수퍼 유저 쓰기가 불가능한 스키마를 제거하여 각 세션을 시작합니다 . 기본 구성에서 쉽게 지원되는 몇 가지 사용 패턴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2e5935e7a8baaaec13839bf8d1afcd03a8e8dfd" translate="yes" xml:space="preserve">
          <source>Schemas can be used to organize your data in many ways. There are a few usage patterns easily supported by the default configuration, only one of which suffices when database users mistrust other database users:</source>
          <target state="translated">스키마는 여러 가지 방법으로 데이터를 구성하는 데 사용할 수 있습니다. 기본 구성에서 쉽게 지원되는 몇 가지 사용 패턴이 있으며, 데이터베이스 사용자가 다른 데이터베이스 사용자를 불신 할 경우 그 중 하나만 충분합니다.</target>
        </trans-unit>
        <trans-unit id="fe05c5f5e36c7ad3c233ad8d962f55161893038e" translate="yes" xml:space="preserve">
          <source>Schemas: Creating a Schema</source>
          <target state="translated">스키마 : 스키마 생성</target>
        </trans-unit>
        <trans-unit id="fdb81be608c6b5ac375fe714d4aa924af26ae0fa" translate="yes" xml:space="preserve">
          <source>Schemas: Public Schema</source>
          <target state="translated">스키마 : 공개 스키마</target>
        </trans-unit>
        <trans-unit id="f7705fc4d879045f4bfff8ed20c3c331b16e9f78" translate="yes" xml:space="preserve">
          <source>Schemas: Schema Search Path</source>
          <target state="translated">스키마 : 스키마 검색 경로</target>
        </trans-unit>
        <trans-unit id="2d3aaf9c6e41501899d83e6eee474131e49c4eab" translate="yes" xml:space="preserve">
          <source>Schemas: Schemas and Privileges</source>
          <target state="translated">스키마 : 스키마 및 권한</target>
        </trans-unit>
        <trans-unit id="300d79632baf61bfba173669d951a12fe402fc35" translate="yes" xml:space="preserve">
          <source>Schemas: System Catalog Schema</source>
          <target state="translated">스키마 : 시스템 카탈로그 스키마</target>
        </trans-unit>
        <trans-unit id="9d45329dfe8f96c785e74aa3c999aa9931e7b9ef" translate="yes" xml:space="preserve">
          <source>Scientific notation</source>
          <target state="translated">과학적 표기법</target>
        </trans-unit>
        <trans-unit id="639e77f4cb9172dbb261f81cbe49e759033825dc" translate="yes" xml:space="preserve">
          <source>Script file meta commands begin with a backslash (&lt;code&gt;\&lt;/code&gt;) and normally extend to the end of the line, although they can be continued to additional lines by writing backslash-return. Arguments to a meta command are separated by white space. These meta commands are supported:</source>
          <target state="translated">스크립트 파일 메타 명령은 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )로 시작 하고 일반적으로 줄 끝까지 확장되지만 백 슬래시 리턴을 작성하여 추가 행으로 계속 될 수 있습니다. 메타 명령에 대한 인수는 공백으로 구분됩니다. 이러한 메타 명령이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="acdba350042b55dc9008bebcefe90a96316c6910" translate="yes" xml:space="preserve">
          <source>Scrollable and &lt;code&gt;WITH HOLD&lt;/code&gt; cursors may give unexpected results if they invoke any volatile functions (see &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-volatility.html&quot;&gt;Section 37.7&lt;/a&gt;). When a previously fetched row is re-fetched, the functions might be re-executed, perhaps leading to results different from the first time. One workaround for such cases is to declare the cursor &lt;code&gt;WITH HOLD&lt;/code&gt; and commit the transaction before reading any rows from it. This will force the entire output of the cursor to be materialized in temporary storage, so that volatile functions are executed exactly once for each row.</source>
          <target state="translated">스크롤 가능 및 &lt;code&gt;WITH HOLD&lt;/code&gt; 커서는 휘발성 함수를 호출하면 예기치 않은 결과를 초래할 수 있습니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/12/xfunc-volatility.html&quot;&gt;37.7 절&lt;/a&gt; 참조 ). 이전에 가져온 행을 다시 페치하면 함수가 다시 실행되어 처음과 다른 결과가 발생할 수 있습니다. 이러한 경우의 한 가지 해결 방법은 커서를 &lt;code&gt;WITH HOLD&lt;/code&gt; 로 선언하고 행을 읽기 전에 트랜잭션을 커미트하는 것입니다. 이렇게하면 커서의 전체 출력이 임시 저장소에 구체화되어 각 행에 대해 휘발성 함수가 정확히 한 번만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="48b575a79c9f1a7546709cbffd9dd12989c8a09f" translate="yes" xml:space="preserve">
          <source>Scrollable and &lt;code&gt;WITH HOLD&lt;/code&gt; cursors may give unexpected results if they invoke any volatile functions (see &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-volatility.html&quot;&gt;Section 37.7&lt;/a&gt;). When a previously fetched row is re-fetched, the functions might be re-executed, perhaps leading to results different from the first time. One workaround for such cases is to declare the cursor &lt;code&gt;WITH HOLD&lt;/code&gt; and commit the transaction before reading any rows from it. This will force the entire output of the cursor to be materialized in temporary storage, so that volatile functions are executed exactly once for each row.</source>
          <target state="translated">스크롤 가능 및 &lt;code&gt;WITH HOLD&lt;/code&gt; 커서는 휘발성 함수를 호출하는 경우 예기치 않은 결과를 제공 할 수 있습니다 ( &lt;a href=&quot;https://www.postgresql.org/docs/13/xfunc-volatility.html&quot;&gt;섹션 37.7&lt;/a&gt; 참조 ). 이전에 페치 된 행을 다시 페치하면 함수가 다시 실행되어 결과가 처음과 다를 수 있습니다. 이러한 경우에 대한 한 가지 해결 방법은 커서를 &lt;code&gt;WITH HOLD&lt;/code&gt; 로 선언 하고 트랜잭션에서 행을 읽기 전에 트랜잭션을 커밋하는 것입니다. 이렇게하면 커서의 전체 출력이 임시 저장소에 구체화되어 휘발성 함수가 각 행에 대해 정확히 한 번 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c3f8b5e7722ab09d6e92f5aac6b25cb972d37aa2" translate="yes" xml:space="preserve">
          <source>Searches using &lt;code&gt;SIMILAR TO&lt;/code&gt; patterns have the same security hazards, since &lt;code&gt;SIMILAR TO&lt;/code&gt; provides many of the same capabilities as POSIX-style regular expressions.</source>
          <target state="translated">사용하여 검색 &lt;code&gt;SIMILAR TO&lt;/code&gt; 이후 패턴은 동일한 보안 위험이 &lt;code&gt;SIMILAR TO&lt;/code&gt; POSIX 스타일의 정규 표현식과 동일한 기능을 많이 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f207101e41aba87f6cbc5cd59185cc3e139ec5cc" translate="yes" xml:space="preserve">
          <source>Searching for phrases is possible with the help of the &lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; (FOLLOWED BY) &lt;code&gt;tsquery&lt;/code&gt; operator, which matches only if its arguments have matches that are adjacent and in the given order. For example:</source>
          <target state="translated">&lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt; ( &lt;code&gt;tsquery&lt;/code&gt; BY) tsquery 연산자를 사용하여 구를 검색 할 수 있습니다. tsquery 연산자는 인수에 인접하고 주어진 순서로 일치하는 항목이있는 경우에만 일치합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d42fb1f9ff5d10fc83a1b3d0d2e78355b104d3c7" translate="yes" xml:space="preserve">
          <source>Second, &lt;code&gt;pg_verifybackup&lt;/code&gt; will attempt to verify that the data files currently stored on disk are exactly the same as the data files which the server intended to send, with some exceptions that are described below. Extra and missing files will be detected, with a few exceptions. This step will ignore the presence or absence of, or any modifications to, &lt;code&gt;postgresql.auto.conf&lt;/code&gt;, &lt;code&gt;standby.signal&lt;/code&gt;, and &lt;code&gt;recovery.signal&lt;/code&gt;, because it is expected that these files may have been created or modified as part of the process of taking the backup. It also won't complain about a &lt;code&gt;backup_manifest&lt;/code&gt; file in the target directory or about anything inside &lt;code&gt;pg_wal&lt;/code&gt;, even though these files won't be listed in the backup manifest. Only files are checked; the presence or absence of directories is not verified, except indirectly: if a directory is missing, any files it should have contained will necessarily also be missing.</source>
          <target state="translated">둘째, &lt;code&gt;pg_verifybackup&lt;/code&gt; 은 현재 디스크에 저장된 데이터 파일이 아래에 설명 된 몇 가지 예외를 제외하고 서버가 전송하려는 데이터 파일과 정확히 동일한 지 확인하려고 시도합니다. 몇 가지 예외를 제외하고 추가 및 누락 된 파일이 감지됩니다. 이 단계는 &lt;code&gt;postgresql.auto.conf&lt;/code&gt; , &lt;code&gt;standby.signal&lt;/code&gt; 및 &lt;code&gt;recovery.signal&lt;/code&gt; 의 존재 여부 또는 수정 사항을 무시합니다. 이러한 파일은 작업 과정의 일부로 생성되거나 수정되었을 수 있기 때문입니다. 백업. 또한 대상 디렉토리 의 &lt;code&gt;backup_manifest&lt;/code&gt; 파일이나 &lt;code&gt;pg_wal&lt;/code&gt; 내부에 대해 불평하지 않습니다., 이러한 파일이 백업 매니페스트에 나열되지 않더라도. 파일 만 확인됩니다. 간접적 인 경우를 제외하고 디렉토리의 존재 여부는 확인되지 않습니다. 디렉토리가 누락 된 경우 포함해야했던 모든 파일도 반드시 누락됩니다.</target>
        </trans-unit>
        <trans-unit id="f500ddf82e1ad65d5e8497e624314fa87cee51ca" translate="yes" xml:space="preserve">
          <source>Second, build and install the policy package for the regression test. The &lt;code&gt;sepgsql-regtest&lt;/code&gt; policy is a special purpose policy package which provides a set of rules to be allowed during the regression tests. It should be built from the policy source file &lt;code&gt;sepgsql-regtest.te&lt;/code&gt;, which is done using &lt;code&gt;make&lt;/code&gt; with a Makefile supplied by SELinux. You will need to locate the appropriate Makefile on your system; the path shown below is only an example. (This Makefile is usually supplied by the &lt;code&gt;selinux-policy-devel&lt;/code&gt; or &lt;code&gt;selinux-policy&lt;/code&gt; RPM.) Once built, install this policy package using the &lt;code&gt;semodule&lt;/code&gt; command, which loads supplied policy packages into the kernel. If the package is correctly installed, &lt;code&gt;semodule -l&lt;/code&gt; should list &lt;code&gt;sepgsql-regtest&lt;/code&gt; as an available policy package:</source>
          <target state="translated">둘째, 회귀 테스트를위한 정책 패키지를 빌드하고 설치합니다. &lt;code&gt;sepgsql-regtest&lt;/code&gt; 의 정책은 회귀 시험 중에 허용하는 규칙의 집합을 제공하는 특수 목적의 정책 패키지입니다. SELinux에서 제공하는 Makefile과 함께 &lt;code&gt;make&lt;/code&gt; 를 사용하여 수행되는 정책 소스 파일 &lt;code&gt;sepgsql-regtest.te&lt;/code&gt; 에서 빌드해야합니다 . 시스템에서 적절한 Makefile을 찾아야합니다. 아래 표시된 경로는 예일뿐입니다. (이 Makefile은 일반적으로 &lt;code&gt;selinux-policy-devel&lt;/code&gt; 또는 &lt;code&gt;selinux-policy&lt;/code&gt; RPM 에 의해 제공됩니다 .) 일단 빌드되면 제공된 정책 패키지를 커널로로드 하는 &lt;code&gt;semodule&lt;/code&gt; 명령을 사용하여이 정책 패키지를 설치하십시오 . 패키지가 올바르게 설치된 경우 &lt;code&gt;semodule -l&lt;/code&gt; 은 &lt;code&gt;sepgsql-regtest&lt;/code&gt; 를 사용 가능한 정책 패키지로 나열해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1267e1be543bd1d1c9d15c26b60b124ab5fb8b25" translate="yes" xml:space="preserve">
          <source>Second, build and install the policy package for the regression test. The &lt;code&gt;sepgsql-regtest&lt;/code&gt; policy is a special purpose policy package which provides a set of rules to be allowed during the regression tests. It should be built from the policy source file &lt;code&gt;sepgsql-regtest.te&lt;/code&gt;, which is done using &lt;code&gt;make&lt;/code&gt; with a Makefile supplied by SELinux. You will need to locate the appropriate Makefile on your system; the path shown below is only an example. Once built, install this policy package using the &lt;code&gt;semodule&lt;/code&gt; command, which loads supplied policy packages into the kernel. If the package is correctly installed, &lt;code&gt;semodule -l&lt;/code&gt; should list &lt;code&gt;sepgsql-regtest&lt;/code&gt; as an available policy package:</source>
          <target state="translated">둘째, 회귀 테스트를위한 정책 패키지를 빌드하고 설치하십시오. &lt;code&gt;sepgsql-regtest&lt;/code&gt; 의 정책은 회귀 시험 중에 허용하는 규칙의 집합을 제공하는 특수 목적의 정책 패키지입니다. 이는 SELinux에서 제공 한 Makefile로 &lt;code&gt;make&lt;/code&gt; 를 사용하여 수행되는 정책 소스 파일 &lt;code&gt;sepgsql-regtest.te&lt;/code&gt; 에서 빌드해야합니다 . 시스템에서 적절한 Makefile을 찾아야합니다. 아래 표시된 경로는 단지 예일뿐입니다. 제공된 정책 패키지를 커널에로드 하는 &lt;code&gt;semodule&lt;/code&gt; 명령을 사용하여이 정책 패키지를 설치하십시오 . 패키지가 올바르게 설치되면 &lt;code&gt;semodule -l&lt;/code&gt; 은 &lt;code&gt;sepgsql-regtest&lt;/code&gt; 를 사용 가능한 정책 패키지로 나열해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4947ce66a60dd8dd783f54f1a65bb0bdcdc82416" translate="yes" xml:space="preserve">
          <source>Second, it allows PostgreSQL to answer some queries using only the index, without reference to the underlying table. Since PostgreSQL indexes don't contain tuple visibility information, a normal index scan fetches the heap tuple for each matching index entry, to check whether it should be seen by the current transaction. An &lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;index-only scan&lt;/em&gt;&lt;/a&gt;, on the other hand, checks the visibility map first. If it's known that all tuples on the page are visible, the heap fetch can be skipped. This is most useful on large data sets where the visibility map can prevent disk accesses. The visibility map is vastly smaller than the heap, so it can easily be cached even when the heap is very large.</source>
          <target state="translated">둘째, PostgreSQL은 기본 테이블을 참조하지 않고 인덱스 만 사용하여 일부 쿼리에 응답 할 수 있습니다. PostgreSQL 인덱스에는 튜플 가시성 정보가 포함되어 있지 않으므로 일반 인덱스 스캔은 일치하는 각 인덱스 항목에 대한 힙 튜플을 가져 와서 현재 트랜잭션에서 볼 수 있는지 확인합니다. &lt;a href=&quot;indexes-index-only-scans&quot;&gt;&lt;em&gt;인덱스 전용 스캔&lt;/em&gt;&lt;/a&gt; 검사 시인성 제 매핑 반면. 페이지의 모든 튜플이 보이는 것으로 알려진 경우 힙 가져 오기를 건너 뛸 수 있습니다. 가시성 맵이 디스크 액세스를 막을 수있는 대규모 데이터 세트에서 가장 유용합니다. 가시성 맵은 힙보다 훨씬 작으므로 힙이 매우 큰 경우에도 쉽게 캐시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b862ceb4146fba8b15eca2ac604e3b372a9b79d3" translate="yes" xml:space="preserve">
          <source>Second, tablespaces allow an administrator to use knowledge of the usage pattern of database objects to optimize performance. For example, an index which is very heavily used can be placed on a very fast, highly available disk, such as an expensive solid state device. At the same time a table storing archived data which is rarely used or not performance critical could be stored on a less expensive, slower disk system.</source>
          <target state="translated">둘째, 테이블 스페이스를 통해 관리자는 데이터베이스 객체의 사용 패턴에 대한 지식을 사용하여 성능을 최적화 할 수 있습니다. 예를 들어, 매우 많이 사용되는 인덱스는 고가의 솔리드 스테이트 장치와 같이 매우 빠르고 고가용 성인 디스크에 배치 할 수 있습니다. 동시에 거의 사용되지 않거나 성능이 중요하지 않은 아카이브 된 데이터를 저장하는 테이블을 저렴하고 느린 디스크 시스템에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f82ab476441f2fbfb5eecf3a3055620e0a9acbcf" translate="yes" xml:space="preserve">
          <source>Secondly, MCV lists handle a wider range of clause types, not just equality clauses like functional dependencies. For example, consider the following range query for the same table:</source>
          <target state="translated">두 번째로, MCV리스트는 기능적 종속성과 같은 동등 조항뿐만 아니라 더 넓은 범위의 조항 유형을 처리합니다. 예를 들어, 동일한 테이블에 대해 다음 범위 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5fb1db527825d2996e37c655e5dec49d4da80c09" translate="yes" xml:space="preserve">
          <source>Seconds</source>
          <target state="translated">Seconds</target>
        </trans-unit>
        <trans-unit id="9d7bbdc2872b96dc9d19fceb57b528b74a14e6c4" translate="yes" xml:space="preserve">
          <source>Section 29.5</source>
          <target state="translated">섹션 29.5</target>
        </trans-unit>
        <trans-unit id="f425733abb8c4273d7e995c4affb2b5e60be58ec" translate="yes" xml:space="preserve">
          <source>Secure Shell</source>
          <target state="translated">보안 쉘</target>
        </trans-unit>
        <trans-unit id="d46b48624d925b281d27f5cebf686d51528d2de1" translate="yes" xml:space="preserve">
          <source>Secure Sockets Layer</source>
          <target state="translated">보안 소켓 계층</target>
        </trans-unit>
        <trans-unit id="04cf3091a9dce3e81018c41460f530cc7fbf97a3" translate="yes" xml:space="preserve">
          <source>Secure TCP/IP Connections with GSSAPI Encryption</source>
          <target state="translated">GSSAPI 암호화를 통한 안전한 TCP / IP 연결</target>
        </trans-unit>
        <trans-unit id="adf40af6654d98fbc6f0a7f0fc3588b6e04d9d7a" translate="yes" xml:space="preserve">
          <source>Secure TCP/IP Connections with GSSAPI Encryption: Basic Setup</source>
          <target state="translated">GSSAPI 암호화를 사용한 안전한 TCP / IP 연결 : 기본 설정</target>
        </trans-unit>
        <trans-unit id="9c27716678c2aeede2d6d03d8fadd9c904fab429" translate="yes" xml:space="preserve">
          <source>Secure TCP/IP Connections with SSH Tunnels</source>
          <target state="translated">SSH 터널을 통한 안전한 TCP / IP 연결</target>
        </trans-unit>
        <trans-unit id="765d9d3c5cad6196564e715c97fcebff52d23d26" translate="yes" xml:space="preserve">
          <source>Secure TCP/IP Connections with SSL</source>
          <target state="translated">SSL을 사용한 안전한 TCP / IP 연결</target>
        </trans-unit>
        <trans-unit id="2b52f6f4e6b8b4b15f3b4e49aaabd8df3ecccc64" translate="yes" xml:space="preserve">
          <source>Secure TCP/IP Connections with SSL: Basic Setup</source>
          <target state="translated">SSL을 사용한 안전한 TCP / IP 연결 : 기본 설정</target>
        </trans-unit>
        <trans-unit id="f2932477bf8173ca0143855a2cc0fa440d4d9849" translate="yes" xml:space="preserve">
          <source>Secure TCP/IP Connections with SSL: Client Certificates</source>
          <target state="translated">SSL을 사용한 안전한 TCP / IP 연결 : 클라이언트 인증서</target>
        </trans-unit>
        <trans-unit id="75d825e571d0d525faf236643945b64a606840f3" translate="yes" xml:space="preserve">
          <source>Secure TCP/IP Connections with SSL: Creating Certificates</source>
          <target state="translated">SSL을 사용한 보안 TCP / IP 연결 : 인증서 작성</target>
        </trans-unit>
        <trans-unit id="f3865198733340ebf8251b57165e25b11db31d65" translate="yes" xml:space="preserve">
          <source>Secure TCP/IP Connections with SSL: OpenSSL Configuration</source>
          <target state="translated">SSL을 사용한 안전한 TCP / IP 연결 : OpenSSL 구성</target>
        </trans-unit>
        <trans-unit id="86cbeaec52ccc656d29df1ceb3ae9e96c2a078b4" translate="yes" xml:space="preserve">
          <source>Secure TCP/IP Connections with SSL: SSL Server File Usage</source>
          <target state="translated">SSL을 사용한 안전한 TCP / IP 연결 : SSL 서버 파일 사용</target>
        </trans-unit>
        <trans-unit id="f25ce1b8a399bd8621a57427a20039b4b13935db" translate="yes" xml:space="preserve">
          <source>Security</source>
          <target state="translated">Security</target>
        </trans-unit>
        <trans-unit id="b0e2b68fe5c77a1104089ba4786849d1c44ed4e7" translate="yes" xml:space="preserve">
          <source>Security Support Provider Interface</source>
          <target state="translated">보안 지원 제공자 인터페이스</target>
        </trans-unit>
        <trans-unit id="b8ebc21ba7feb1136ff11c4165f905e9afb9ee13" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;app-psql#APP-PSQL-ENVIRONMENT&quot;&gt;Environment&lt;/a&gt;, below, for how to configure and customize your editor.</source>
          <target state="translated">편집기를 구성하고 사용자 정의하는 방법은 아래 &lt;a href=&quot;app-psql#APP-PSQL-ENVIRONMENT&quot;&gt;환경을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="129594b2e81c3073c544da019624bf6380f10df8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;arrays&quot;&gt;Section 8.15&lt;/a&gt; for more details about array operator behavior. See &lt;a href=&quot;indexes-types&quot;&gt;Section 11.2&lt;/a&gt; for more details about which operators support indexed operations.</source>
          <target state="translated">배열 연산자 동작에 대한 자세한 내용은 &lt;a href=&quot;arrays&quot;&gt;8.15 절을&lt;/a&gt; 참조하십시오 . 인덱스 연산자를 지원하는 연산자에 대한 자세한 내용은 &lt;a href=&quot;indexes-types&quot;&gt;11.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="91fe439d07c9c7489eb06d1f888cd3c5425576d7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;collation#COLLATION-CREATE&quot;&gt;Section 23.2.2.3&lt;/a&gt; for more information on how to create collations.</source>
          <target state="translated">데이터 정렬을 만드는 방법에 대한 자세한 내용 &lt;a href=&quot;collation#COLLATION-CREATE&quot;&gt;은 23.2.2.3 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21dff2e6760e62802bf83321134c955aba4830c5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;config-setting&quot;&gt;Section 19.1&lt;/a&gt; for more information about the various ways to change run-time parameters.</source>
          <target state="translated">런타임 파라미터를 변경하는 다양한 방법에 대한 자세한 내용은 &lt;a href=&quot;config-setting&quot;&gt;19.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20044de8233785ce451ac7762b09dd959a52d7c6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;config-setting&quot;&gt;Section 19.1&lt;/a&gt; for more information about the various ways to change these parameters.</source>
          <target state="translated">이 파라미터를 변경하는 다양한 방법에 대한 자세한 내용은 &lt;a href=&quot;config-setting&quot;&gt;19.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8df945e5fb404f92c8a3a77f55aa7a33908d550" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;config-setting&quot;&gt;Section 19.1&lt;/a&gt; for other ways to set the parameters.</source>
          <target state="translated">파라미터를 설정하는 다른 방법 &lt;a href=&quot;config-setting&quot;&gt;은 19.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3aa2dabfa10b32ce3d3591d55b432af66d5f14e6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;Section 8.5.3&lt;/a&gt; for more information about time zones.</source>
          <target state="translated">시간대에 대한 자세한 정보는 &lt;a href=&quot;datatype-datetime#DATATYPE-TIMEZONES&quot;&gt;8.5.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8c362f3c080f6c399e1928c12a904e8f0377b84" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;datatype-oid&quot;&gt;Section 8.19&lt;/a&gt; for more information about &lt;code&gt;regclass&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;regclass&lt;/code&gt; 에 대한 자세한 내용은 &lt;a href=&quot;datatype-oid&quot;&gt;8.19 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6121942b911db00103c296046d2f56571852959" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;ddl-depend&quot;&gt;Section 5.14&lt;/a&gt; for a description of the general mechanism behind this.</source>
          <target state="translated">이것의 일반적인 메커니즘에 대한 설명은 &lt;a href=&quot;ddl-depend&quot;&gt;5.14 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5436fd6c7a9e0d4448841144cf08cf034fd03681" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;ddl-partitioning&quot;&gt;Section 5.11&lt;/a&gt; for more discussion on table partitioning.</source>
          <target state="translated">테이블 파티셔닝에 대한 자세한 내용 &lt;a href=&quot;ddl-partitioning&quot;&gt;은 5.11 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e5737db37680106cc30deed32f46d04081cb6ca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;ddl-priv&quot;&gt;Section 5.7&lt;/a&gt; for more information about specific privilege types, as well as how to inspect objects' privileges.</source>
          <target state="translated">특정 권한 유형에 대한 자세한 내용과 객체의 권한을 검사하는 방법에 대해서는 &lt;a href=&quot;ddl-priv&quot;&gt;5.7 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc1e49b4f43d37545c8f3f325e1aa810829424f6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.23.5&lt;/a&gt; for details about the meaning of a row constructor comparison.</source>
          <target state="translated">행 생성자 비교의 의미에 대한 자세한 내용 &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;은 9.23.5 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef6f74d5339ba13782069cb6ba83d477f4646291" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;Section 9.24.5&lt;/a&gt; for details about the meaning of a row constructor comparison.</source>
          <target state="translated">행 생성자 비교의 의미에 대한 자세한 내용은 &lt;a href=&quot;functions-comparisons#ROW-WISE-COMPARISON&quot;&gt;섹션 9.24.5&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99077fee3edc81ab2e900b38cc76283836ea98b1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;functions-range#RANGE-OPERATORS-TABLE&quot;&gt;Table 9.53&lt;/a&gt; and &lt;a href=&quot;functions-range#RANGE-FUNCTIONS-TABLE&quot;&gt;Table 9.54&lt;/a&gt; for complete lists of operators and functions on range types.</source>
          <target state="translated">범위 유형에 대한 전체 연산자 및 기능 목록은 &lt;a href=&quot;functions-range#RANGE-OPERATORS-TABLE&quot;&gt;표 9.53&lt;/a&gt; 및 &lt;a href=&quot;functions-range#RANGE-FUNCTIONS-TABLE&quot;&gt;표 9.54&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd2d35314436b98ffc25d0a1a3e0b8a0b71eb0ce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;functions-uuid&quot;&gt;Section 9.14&lt;/a&gt; for how to generate a UUID in PostgreSQL.</source>
          <target state="translated">PostgreSQL에서 UUID를 생성하는 방법 은 &lt;a href=&quot;functions-uuid&quot;&gt;섹션 9.14&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba76601bef149465ed57cdcfac9723e99053af87" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;glossary#GLOSSARY-DATA-DIRECTORY&quot;&gt;Data directory&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-DATA-DIRECTORY&quot;&gt;데이터 디렉토리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55e2c138851e3e26a7ec58aff78434964e528e5b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;glossary#GLOSSARY-FILE-SEGMENT&quot;&gt;File segment&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-FILE-SEGMENT&quot;&gt;파일 세그먼트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8dab4eac501e59a612b9510552bc6c7c36ac3c9f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;Instance&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-INSTANCE&quot;&gt;인스턴스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a698f3b7926eb471feaa7056cbf61af7db205bac" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;glossary#GLOSSARY-PLANNER&quot;&gt;Query planner&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-PLANNER&quot;&gt;쿼리 플래너를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9571870fca2f4a09e211238f864ee6a88af2705a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;Primary (server)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-PRIMARY-SERVER&quot;&gt;기본 (서버)을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="24354707836d3b7cb3af2afd8bd836b3b408570a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;Relation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-RELATION&quot;&gt;관계를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e28da47905066cde158f4ee3a39b6e829def2ef" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;glossary#GLOSSARY-REPLICA&quot;&gt;Replica (server)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-REPLICA&quot;&gt;복제본 (서버)을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="123960fd9033a39d5e75d070b81adba475f5ba3d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;Tuple&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-TUPLE&quot;&gt;Tuple을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf5a9087975af453ca06dcf6dddc655e765d00e7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;Write-ahead log&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-WAL&quot;&gt;미리 쓰기 로그를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6120eac1c0574af35461a78ddb76b988d9bc9673" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-WAL-FILE&quot;&gt;WAL 파일을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="52cb397d0f3dadd6974d94bb06bbcd0f9671c985" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;glossary#GLOSSARY-WINDOW-FUNCTION&quot;&gt;Window function (routine)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-WINDOW-FUNCTION&quot;&gt;창 기능 (루틴)을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7241429c69578e1ed391dde19aafc05fa7e786ae" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;glossary#GLOSSARY-XID&quot;&gt;Transaction ID&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#GLOSSARY-XID&quot;&gt;거래 ID를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7dc7bf166017c5ab01e8f179799ef718f15e4cc6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://unicode.org/reports/tr35/tr35-collation.html&quot;&gt;Unicode Technical Standard #35&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt; for details. The list of possible collation types (&lt;code&gt;co&lt;/code&gt; subtag) can be found in the &lt;a href=&quot;http://www.unicode.org/repos/cldr/trunk/common/bcp47/collation.xml&quot;&gt;CLDR repository&lt;/a&gt;. The &lt;a href=&quot;https://ssl.icu-project.org/icu-bin/locexp&quot;&gt;ICU Locale Explorer&lt;/a&gt; can be used to check the details of a particular locale definition. The examples using the &lt;code&gt;k*&lt;/code&gt; subtags require at least ICU version 54.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://unicode.org/reports/tr35/tr35-collation.html&quot;&gt;유니 코드 기술 표준 # 35&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt; 을 참조하십시오. 가능한 조합 유형 ( &lt;code&gt;co&lt;/code&gt; 서브 태그) 의 목록은 &lt;a href=&quot;http://www.unicode.org/repos/cldr/trunk/common/bcp47/collation.xml&quot;&gt;CLDR 저장소&lt;/a&gt; 에서 찾을 수 있습니다 . &lt;a href=&quot;https://ssl.icu-project.org/icu-bin/locexp&quot;&gt;ICU 로케일 Explorer가&lt;/a&gt; 특정 로케일 정의의 세부 사항을 확인하는 데 사용할 수 있습니다. &lt;code&gt;k*&lt;/code&gt; 서브 태그를 사용하는 예 에는 ICU 버전 54 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="582d4fa80677a54a1ee172dc48b0285a2eaa1864" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for more information about client authentication configuration.</source>
          <target state="translated">클라이언트 인증 구성에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/client-authentication.html&quot;&gt;20 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="38f1194916115ea94d91b361343fd5fa05583c78" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt; for more information about these operations.</source>
          <target state="translated">이러한 작업에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/extend-extensions.html&quot;&gt;37.17 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="892416cf396bca7c46f14f91d5f875eae43cb1ca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.postgresql.org/docs/12/indexes.html&quot;&gt;Chapter 11&lt;/a&gt; for information about when indexes can be used, when they are not used, and in which particular situations they can be useful.</source>
          <target state="translated">인덱스를 사용할 수있는시기, 사용할 수없는시기 및 유용한 특정 상황에 대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/12/indexes.html&quot;&gt;11 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5dc185077b13c96658273b13ce5ac4cae80ae9f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding-example.html&quot;&gt;Section 48.1&lt;/a&gt; for an example.</source>
          <target state="translated">예제는 &lt;a href=&quot;https://www.postgresql.org/docs/12/logicaldecoding-example.html&quot;&gt;섹션 48.1&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6786a791493e2be59f08be03325336baf1d9b56d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime.html&quot;&gt;Chapter 18&lt;/a&gt; for details about starting and stopping the server.</source>
          <target state="translated">서버 시작 및 중지에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime.html&quot;&gt;18 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab3cfe431becc967b2d8707ffa503148a0bf1ef7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html&quot;&gt;Section 37.12&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/12/xaggr.html&quot;&gt;섹션 37.12&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="96e21b20fad4882b3ea8b059a713e474bd684b3e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;Chapter 20&lt;/a&gt; for more information about client authentication configuration.</source>
          <target state="translated">클라이언트 인증 구성에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/client-authentication.html&quot;&gt;20 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7094796f164dea425ed63398bae7c2926a6444d3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-extensions.html&quot;&gt;Section 37.17&lt;/a&gt; for more information about these operations.</source>
          <target state="translated">이러한 작업에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/extend-extensions.html&quot;&gt;섹션 37.17&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fccb6e5fced65b27d7db4d52f25e0c49daba0bb1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.postgresql.org/docs/13/indexes.html&quot;&gt;Chapter 11&lt;/a&gt; for information about when indexes can be used, when they are not used, and in which particular situations they can be useful.</source>
          <target state="translated">인덱스를 사용할 수있는시기, 사용하지 않는시기 및 유용 할 수있는 특정 상황에 대한 정보는 &lt;a href=&quot;https://www.postgresql.org/docs/13/indexes.html&quot;&gt;11 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33bde747183ffd88b9882afaaa860ad9ee2b3270" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding-example.html&quot;&gt;Section 48.1&lt;/a&gt; for an example.</source>
          <target state="translated">예는 &lt;a href=&quot;https://www.postgresql.org/docs/13/logicaldecoding-example.html&quot;&gt;섹션 48.1&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ccf3a367a417e639d5c5c76e2de2aa77bc8fe90" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime.html&quot;&gt;Chapter 18&lt;/a&gt; for details about starting and stopping the server.</source>
          <target state="translated">서버 시작 및 중지에 대한 자세한 내용은 &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime.html&quot;&gt;18 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ab2e8b349ca47ebb1d981fa2e13667cb016323d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html&quot;&gt;Section 37.12&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/docs/13/xaggr.html&quot;&gt;섹션 37.12를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d2fca275ea18f55381557dcc1a844fe840b768d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.unicode.org/reports/tr35/tr35-collation.html&quot;&gt;Unicode Technical Standard #35&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt; for details. The list of possible collation types (&lt;code&gt;co&lt;/code&gt; subtag) can be found in the &lt;a href=&quot;https://github.com/unicode-org/cldr/blob/master/common/bcp47/collation.xml&quot;&gt;CLDR repository&lt;/a&gt;. The &lt;a href=&quot;https://ssl.icu-project.org/icu-bin/locexp&quot;&gt;ICU Locale Explorer&lt;/a&gt; can be used to check the details of a particular locale definition. The examples using the &lt;code&gt;k*&lt;/code&gt; subtags require at least ICU version 54.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.unicode.org/reports/tr35/tr35-collation.html&quot;&gt;유니 코드 기술 표준 # 35&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt; 을 참조하십시오. 가능한 데이터 정렬 유형 ( &lt;code&gt;co&lt;/code&gt; 하위 태그) 목록은 &lt;a href=&quot;https://github.com/unicode-org/cldr/blob/master/common/bcp47/collation.xml&quot;&gt;CLDR 저장소&lt;/a&gt; 에서 찾을 수 있습니다 . &lt;a href=&quot;https://ssl.icu-project.org/icu-bin/locexp&quot;&gt;ICU 로케일 Explorer가&lt;/a&gt; 특정 로케일 정의의 세부 사항을 확인하는 데 사용할 수 있습니다. &lt;code&gt;k*&lt;/code&gt; 하위 태그를 사용하는 예제 에는 ICU 버전 54 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c82056d140064babef823c90a745402bb0eaad0d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;logical-replication-security&quot;&gt;Section 30.7&lt;/a&gt; for details on how to configure access control between the subscription and the publication instance.</source>
          <target state="translated">구독과 게시 인스턴스 간의 액세스 제어를 구성하는 방법에 대한 자세한 내용 &lt;a href=&quot;logical-replication-security&quot;&gt;은 30.7 단원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fc6222de7f143b98f8f58d71a3c1ef0f2ed5e81" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;postgres-fdw&quot;&gt;postgres_fdw&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;postgres-fdw&quot;&gt;postgres_fdw&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6afe2a2cf993b290dad8327744ed47ff8cb76f26" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;queries-with&quot;&gt;Section 7.8&lt;/a&gt; for additional information.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;queries-with&quot;&gt;7.8 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d30023efb26270c0f643e34f708bf2c117a6dd98" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;rangetypes&quot;&gt;Section 8.17&lt;/a&gt; for an overview of range types.</source>
          <target state="translated">범위 유형에 대한 개요는 &lt;a href=&quot;rangetypes&quot;&gt;섹션 8.17&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f50140c0f54dcd737110b916618da4f2ed0d2b6f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;role-removal&quot;&gt;Section 21.4&lt;/a&gt; for more discussion.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;role-removal&quot;&gt;은 21.4 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1311c6be729433d7e0d41bc36cc94bcb9e04ac98" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;Section 8.16.5&lt;/a&gt; for more about the &lt;code&gt;table_name&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt; notation.</source>
          <target state="translated">&lt;code&gt;table_name&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; 표기법 에 대한 자세한 내용 &lt;a href=&quot;rowtypes#ROWTYPES-USAGE&quot;&gt;은 8.16.5 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2599d6941f298f4ebc6ff1c171836213c6e90dd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sepgsql#SEPGSQL-RESOURCES&quot;&gt;Section F.35.8&lt;/a&gt; for details on adjusting your working domain, if necessary.</source>
          <target state="translated">필요한 경우 작업 도메인 조정에 대한 자세한 내용 은 &lt;a href=&quot;sepgsql#SEPGSQL-RESOURCES&quot;&gt;섹션 F.35.8&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b63e06af771a4ffc188f17077941948fe6a397d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; for more details on function creation that also apply to procedures.</source>
          <target state="translated">프로 시저에도 적용되는 함수 작성에 대한 자세한 내용 은 &lt;a href=&quot;sql-createfunction&quot;&gt;CREATE FUNCTION&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a0b4602b13874b43e681e7cbb94d3bc21e2d3be" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; for more details about these type properties. Note that where appropriate, a change in these properties for a base type will be propagated automatically to domains based on that type.</source>
          <target state="translated">참조 &lt;a href=&quot;sql-createtype&quot;&gt;유형을 만들&lt;/a&gt; 이러한 유형의 속성에 대한 자세한 내용은. 해당하는 경우 기본 유형에 대한 이러한 속성의 변경 사항은 해당 유형을 기반으로하는 도메인에 자동으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="25aa6584689a54363475900a782425bf48c820bf" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; for more information about creating range types.</source>
          <target state="translated">범위 유형 작성에 대한 자세한 정보는 &lt;a href=&quot;sql-createtype&quot;&gt;CREATE TYPE&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cb868edee10c53ef3cb407a6108254e17240e80" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sql-fetch&quot;&gt;FETCH&lt;/a&gt; for more examples of cursor usage.</source>
          <target state="translated">커서 사용법에 대한 자세한 예는 &lt;a href=&quot;sql-fetch&quot;&gt;FETCH&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dee20c85d57efa9a03b8b80c0a54652b2cef0e62" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for more information about allowed parameter names and values.</source>
          <target state="translated">허용되는 매개 변수 이름과 값에 대한 자세한 내용은 &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/12/runtime-config.html&quot;&gt;19 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="026a89fe263241545cee04317a0280e98e418ee5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; and &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;Chapter 19&lt;/a&gt; for more information about allowed parameter names and values.</source>
          <target state="translated">허용되는 매개 변수 이름과 값에 대한 자세한 내용은 &lt;a href=&quot;sql-set&quot;&gt;SET&lt;/a&gt; 및 &lt;a href=&quot;https://www.postgresql.org/docs/13/runtime-config.html&quot;&gt;19 장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5a0f9a31c8d4cb8e95380e7154f328b18b2f1dc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; for details of how to use an exported snapshot.</source>
          <target state="translated">내 보낸 스냅 샷을 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="560351833cec2b456d077d537e6a8e36290f0101" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;Section 4.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;sql-syntax-lexical#SQL-PRECEDENCE&quot;&gt;4.1.6 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2b16e1b88e75eae9fac619972836298831a57a94" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;ssl-tcp&quot;&gt;Section 18.9&lt;/a&gt; for more information about setting up SSL.</source>
          <target state="translated">SSL 설정에 대한 자세한 내용은 &lt;a href=&quot;ssl-tcp&quot;&gt;18.9 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="563b7e65559e2ffd1dcd4b25a043a5d7ce41e394" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;Section 13.2.3&lt;/a&gt; for performance suggestions.</source>
          <target state="translated">성능 제안에 대해서는 &lt;a href=&quot;transaction-iso#XACT-SERIALIZABLE&quot;&gt;13.2.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5dba32263af0b1cd1c6087e0035c161633609c33" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;pg_current_snapshot()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_current_snapshot()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29c7bc584ab7baf6e04b23f550bacaf8367a2b8d" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;pg_current_xact_id()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_current_xact_id()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b55554f7fdec20efc7969ebc70fa911338b8482b" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;pg_current_xact_id_if_assigned()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_current_xact_id_if_assigned()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a2722a4771ac2a79f637759c12e6aac12656e72" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;pg_snapshot_xip()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_snapshot_xip()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="67c3c8a5508a4c431d1edc1535dcc68b6db9f419" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;pg_snapshot_xmax()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_snapshot_xmax()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6844630385a5e571829c9f6613ae0c210ac27d15" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;pg_snapshot_xmin()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_snapshot_xmin()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fb998a07a517c81d659954ac8dccd4e9aadedff" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;pg_visible_in_snapshot()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_visible_in_snapshot()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b21fb4231f81a1d5788a72c9ab7a09d3996a797f" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;pg_xact_status()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pg_xact_status()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="31d709bb26fab6d76bc114f179cc9b4a74012c23" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;src/backend/jit/README&lt;/code&gt; for further details.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;src/backend/jit/README&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a053a4027cc8f8f5331001723fdc0df313e812ce" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;src/backend/storage/freespace/README&lt;/code&gt; for more details on how the FSM is structured, and how it's updated and searched. The &lt;a href=&quot;pgfreespacemap&quot;&gt;pg_freespacemap&lt;/a&gt; module can be used to examine the information stored in free space maps.</source>
          <target state="translated">FSM의 구조와 업데이트 및 검색 방법에 대한 자세한 내용 은 &lt;code&gt;src/backend/storage/freespace/README&lt;/code&gt; 를 참조하십시오. &lt;a href=&quot;pgfreespacemap&quot;&gt;pg_freespacemap의&lt;/a&gt; 모듈은 여유 공간이 맵에 저장된 정보를 검사하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="982e2b1c8d12c35e58c724d217a408f75dbd560d" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;src/backend/storage/freespace/README&lt;/code&gt; for more information on the structure of an FSM page.</source>
          <target state="translated">FSM 페이지의 구조에 대한 자세한 내용 은 &lt;code&gt;src/backend/storage/freespace/README&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a51bb7106235ce58a540319c6cf97a50c32a4f7c" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt; for explanations of the flag names returned.</source>
          <target state="translated">반환 된 플래그 이름에 대한 설명은 &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ef0ebfd4fc78ddb23c7d11b428b37f7924c235c" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;src/include/storage/itemid.h&lt;/code&gt; and &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt; for explanations of the fields returned.</source>
          <target state="translated">리턴 된 필드에 대한 설명은 &lt;code&gt;src/include/storage/itemid.h&lt;/code&gt; 및 &lt;code&gt;src/include/access/htup_details.h&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="cb153ba9a557881d5299b48db83b8986a3df8b21" translate="yes" xml:space="preserve">
          <source>See Also &lt;a href=&quot;glossary#GLOSSARY-WINDOW-FUNCTION&quot;&gt;Window function (routine)&lt;/a&gt;.</source>
          <target state="translated">참조 &lt;a href=&quot;glossary#GLOSSARY-WINDOW-FUNCTION&quot;&gt;창 기능 (루틴)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1de983eb571c65e4cf91c99df72813ddd57b16b" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;catalog-pg-depend&quot;&gt;&lt;code&gt;pg_depend&lt;/code&gt;&lt;/a&gt;, which performs a similar function for dependencies involving objects within a single database.</source>
          <target state="translated">단일 데이터베이스 내의 객체와 관련된 종속성에 대해 유사한 기능을 수행하는 &lt;a href=&quot;catalog-pg-depend&quot;&gt; &lt;code&gt;pg_depend&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad7d639c3b0ac96867bd9b54da5256d9fa9187be" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;catalog-pg-description&quot;&gt;&lt;code&gt;pg_description&lt;/code&gt;&lt;/a&gt;, which performs a similar function for descriptions involving objects within a single database.</source>
          <target state="translated">단일 데이터베이스 내의 객체와 관련된 설명에 대해 유사한 기능을 수행하는 &lt;a href=&quot;catalog-pg-description&quot;&gt; &lt;code&gt;pg_description&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd53e36cfb7120641bdfde4b9debd109aae624c4" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;catalog-pg-seclabel&quot;&gt;&lt;code&gt;pg_seclabel&lt;/code&gt;&lt;/a&gt;, which performs a similar function for security labels involving objects within a single database.</source>
          <target state="translated">단일 데이터베이스 내의 객체와 관련된 보안 레이블에 대해 비슷한 기능을 수행하는 &lt;a href=&quot;catalog-pg-seclabel&quot;&gt; &lt;code&gt;pg_seclabel&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b279716a6e4c2d389ff8eb6891492dc3ea6c55aa" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;catalog-pg-shdepend&quot;&gt;&lt;code&gt;pg_shdepend&lt;/code&gt;&lt;/a&gt;, which performs a similar function for dependencies involving objects that are shared across a database cluster.</source>
          <target state="translated">데이터베이스 클러스터에서 공유되는 객체와 관련된 종속성에 대해 유사한 기능을 수행하는 &lt;a href=&quot;catalog-pg-shdepend&quot;&gt; &lt;code&gt;pg_shdepend&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f93abe962ae6fffe5b4393bf3a7a551bd9c115ab" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;catalog-pg-shdescription&quot;&gt;&lt;code&gt;pg_shdescription&lt;/code&gt;&lt;/a&gt;, which performs a similar function for descriptions involving objects that are shared across a database cluster.</source>
          <target state="translated">데이터베이스 클러스터에서 공유되는 객체와 관련된 설명에 대해서는 유사한 기능을 수행하는 &lt;a href=&quot;catalog-pg-shdescription&quot;&gt; &lt;code&gt;pg_shdescription&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6cea165f9c06f3d524bf490cd29cc33c55feee31" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;catalog-pg-shseclabel&quot;&gt;&lt;code&gt;pg_shseclabel&lt;/code&gt;&lt;/a&gt;, which performs a similar function for security labels of database objects that are shared across a database cluster.</source>
          <target state="translated">데이터베이스 클러스터에서 공유되는 데이터베이스 객체의 보안 레이블에 대해 비슷한 기능을 수행하는 &lt;a href=&quot;catalog-pg-shseclabel&quot;&gt; &lt;code&gt;pg_shseclabel&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1df8b632444bf92211ebacd4b3f224d866cac89c" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; about the aggregate function &lt;code&gt;array_agg&lt;/code&gt; for use with arrays.</source>
          <target state="translated">배열과 함께 사용 하는 집계 함수 &lt;code&gt;array_agg&lt;/code&gt; 에 대해서는 &lt;a href=&quot;functions-aggregate&quot;&gt;9.20 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bda9ba00d2498975f9b058d90e79b3b230025976" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; for the aggregate function &lt;code&gt;json_agg&lt;/code&gt; which aggregates record values as JSON, and the aggregate function &lt;code&gt;json_object_agg&lt;/code&gt; which aggregates pairs of values into a JSON object, and their &lt;code&gt;jsonb&lt;/code&gt; equivalents, &lt;code&gt;jsonb_agg&lt;/code&gt; and &lt;code&gt;jsonb_object_agg&lt;/code&gt;.</source>
          <target state="translated">참조 &lt;a href=&quot;functions-aggregate&quot;&gt;섹션 9.20을&lt;/a&gt; 집계 함수에 대한 &lt;code&gt;json_agg&lt;/code&gt; JSON으로 기록 값을 집계하고, 집계 함수 &lt;code&gt;json_object_agg&lt;/code&gt; JSON 개체에 값 쌍을 집계, 그들의 &lt;code&gt;jsonb&lt;/code&gt; 의 등가물, &lt;code&gt;jsonb_agg&lt;/code&gt; 및 &lt;code&gt;jsonb_object_agg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d70c20e9c833914e63b03056f83052a5f0e61b0" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt; about the aggregate function &lt;code&gt;array_agg&lt;/code&gt; for use with arrays.</source>
          <target state="translated">배열과 함께 사용하기위한 집계 함수 &lt;code&gt;array_agg&lt;/code&gt; 에 대해서는 &lt;a href=&quot;functions-aggregate&quot;&gt;섹션 9.21을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f846d23c37405fd26a4ef044faf3f0d72f0b511" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt; for the aggregate function &lt;code&gt;json_agg&lt;/code&gt; which aggregates record values as JSON, the aggregate function &lt;code&gt;json_object_agg&lt;/code&gt; which aggregates pairs of values into a JSON object, and their &lt;code&gt;jsonb&lt;/code&gt; equivalents, &lt;code&gt;jsonb_agg&lt;/code&gt; and &lt;code&gt;jsonb_object_agg&lt;/code&gt;.</source>
          <target state="translated">참조 &lt;a href=&quot;functions-aggregate&quot;&gt;섹션 9.21을&lt;/a&gt; 집계 함수에 대한 &lt;code&gt;json_agg&lt;/code&gt; JSON, 집계 함수 등의 기록 값 집계 &lt;code&gt;json_object_agg&lt;/code&gt; JSON 개체에 값 쌍을 집계, 그들의 &lt;code&gt;jsonb&lt;/code&gt; 의 등가물, &lt;code&gt;jsonb_agg&lt;/code&gt; 및 &lt;code&gt;jsonb_object_agg&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="e399735f139a89cd5c81b9d91b4af6f3ecfaaaba" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;functions-info&quot;&gt;Section 9.25&lt;/a&gt; for other ways to manipulate the schema search path.</source>
          <target state="translated">스키마 검색 경로를 조작하는 다른 방법 &lt;a href=&quot;functions-info&quot;&gt;은 9.25 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="617e2937a62e771519542c13bee0d628f95f5a2f" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;functions-info&quot;&gt;Section 9.26&lt;/a&gt; for other ways to manipulate the schema search path.</source>
          <target state="translated">스키마 검색 경로를 조작하는 다른 방법 은 &lt;a href=&quot;functions-info&quot;&gt;섹션 9.26&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f96d074ebf7693f0aebd0f259a5b12ef2c1d4a0" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;runtime-config-client#GUC-DEFAULT-TABLESPACE&quot;&gt;default_tablespace&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40e8bb395b4f7993ff9f91c724e85a4869d719c5" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;sql-altercollation&quot;&gt;ALTER COLLATION&lt;/a&gt; for how to handle collation version mismatches.</source>
          <target state="translated">데이터 정렬 버전 불일치를 처리하는 방법 은 &lt;a href=&quot;sql-altercollation&quot;&gt;ALTER COLLATION&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61ea69823fe6c6e4f5558b3086cfd393b0cb5762" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt;&lt;code&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDE&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;sql-createtable#SQL-CREATETABLE-EXCLUDE&quot;&gt; &lt;code&gt;CREATE TABLE ... CONSTRAINT ... EXCLUDE&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dee4f6c549e6186ad297cb4e513333334dbe6582" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; documentation for details on limitations of pg_dump.</source>
          <target state="translated">&lt;a href=&quot;app-pgdump&quot;&gt;pg_dump의&lt;/a&gt; 제한 사항에 대한 자세한 내용 은 pg_dump 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b819d0d15460a62d154724c598880fe9a3cdd1bd" translate="yes" xml:space="preserve">
          <source>See also the &lt;code&gt;&lt;a href=&quot;app-psql#APP-PSQL-META-COMMANDS-CROSSTABVIEW&quot;&gt;\crosstabview&lt;/a&gt;&lt;/code&gt; command in psql, which provides functionality similar to &lt;code&gt;crosstab()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;crosstab()&lt;/code&gt; 과 유사한 기능을 제공하는 psql 의 &lt;code&gt;&lt;a href=&quot;app-psql#APP-PSQL-META-COMMANDS-CROSSTABVIEW&quot;&gt;\crosstabview&lt;/a&gt;&lt;/code&gt; 명령 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21701b6a0c6bce35e4a7bac5e2f1c38753b42cfc" translate="yes" xml:space="preserve">
          <source>See also the aggregate function &lt;code&gt;string_agg&lt;/code&gt; in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt; and the large object functions in &lt;a href=&quot;https://www.postgresql.org/docs/12/lo-funcs.html&quot;&gt;Section 34.4&lt;/a&gt;.</source>
          <target state="translated">또한 집계 함수 참조 &lt;code&gt;string_agg&lt;/code&gt; 에서 &lt;a href=&quot;functions-aggregate&quot;&gt;제 9.20&lt;/a&gt; 와의 대형 개체 기능 &lt;a href=&quot;https://www.postgresql.org/docs/12/lo-funcs.html&quot;&gt;섹션 34.4을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad1bde271a1bd1beac102378f06fedfbe83bc709" translate="yes" xml:space="preserve">
          <source>See also the aggregate function &lt;code&gt;string_agg&lt;/code&gt; in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.20&lt;/a&gt;.</source>
          <target state="translated">또한 집계 함수 참조 &lt;code&gt;string_agg&lt;/code&gt; 의 &lt;a href=&quot;functions-aggregate&quot;&gt;섹션 9.20을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0b723b12a9357d0a7a713b5fe69c7f965a88ab0" translate="yes" xml:space="preserve">
          <source>See also the aggregate function &lt;code&gt;string_agg&lt;/code&gt; in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt; and the large object functions in &lt;a href=&quot;https://www.postgresql.org/docs/13/lo-funcs.html&quot;&gt;Section 34.4&lt;/a&gt;.</source>
          <target state="translated">또한 집계 함수 참조 &lt;code&gt;string_agg&lt;/code&gt; 에서 &lt;a href=&quot;functions-aggregate&quot;&gt;제 9.21&lt;/a&gt; 와의 대형 개체 기능 &lt;a href=&quot;https://www.postgresql.org/docs/13/lo-funcs.html&quot;&gt;섹션 34.4을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d244bfb6edea1d0e94b2adbad99d04f29524ada8" translate="yes" xml:space="preserve">
          <source>See also the aggregate function &lt;code&gt;string_agg&lt;/code&gt; in &lt;a href=&quot;functions-aggregate&quot;&gt;Section 9.21&lt;/a&gt;, and the functions for converting between strings and the &lt;code&gt;bytea&lt;/code&gt; type in &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-CONVERSIONS&quot;&gt;Table 9.13&lt;/a&gt;.</source>
          <target state="translated">또한, 집합 함수 참조 &lt;code&gt;string_agg&lt;/code&gt; 에서 &lt;a href=&quot;functions-aggregate&quot;&gt;제 9.21&lt;/a&gt; 문자열과 사이의 변환을 위해, 그리고 기능 &lt;code&gt;bytea&lt;/code&gt; 입력 &lt;a href=&quot;functions-binarystring#FUNCTIONS-BINARYSTRING-CONVERSIONS&quot;&gt;표 9.13&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a612d7fa4857adb5bc7b0df595dafd80b5feb11" translate="yes" xml:space="preserve">
          <source>See also the compatibility section of &lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sql-set-transaction&quot;&gt;SET TRANSACTION&lt;/a&gt; 의 호환성 섹션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8319be7b579e7e4a49dee750a5403a1584575fbd" translate="yes" xml:space="preserve">
          <source>See if the token matches any known time zone abbreviation. These abbreviations are supplied by the configuration file described in &lt;a href=&quot;datetime-config-files&quot;&gt;Section B.4&lt;/a&gt;.</source>
          <target state="translated">토큰이 알려진 시간대 약어와 일치하는지 확인하십시오. 이러한 약어는 &lt;a href=&quot;datetime-config-files&quot;&gt;섹션 B.4에&lt;/a&gt; 설명 된 구성 파일에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="db3af396acc6f9d65d6497b3a79795186833e19d" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; and &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; reference pages for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;app-pgdump&quot;&gt;pg_dump&lt;/a&gt; 및 &lt;a href=&quot;app-pgrestore&quot;&gt;pg_restore&lt;/a&gt; 참조 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="51522476ad0a924ea2975abf1b9ba1b7069b4d48" translate="yes" xml:space="preserve">
          <source>See the description of the &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; command for the meaning of the privilege types.</source>
          <target state="translated">권한 유형의 의미 는 &lt;a href=&quot;sql-grant&quot;&gt;GRANT&lt;/a&gt; 명령에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="943bbcc97100871ab9497a75cc44428d84d573b9" translate="yes" xml:space="preserve">
          <source>See under &lt;a href=&quot;app-psql#APP-PSQL-ENVIRONMENT&quot;&gt;Environment&lt;/a&gt; for how to configure and customize your editor.</source>
          <target state="translated">편집기를 구성하고 사용자 정의하는 방법 은 &lt;a href=&quot;app-psql#APP-PSQL-ENVIRONMENT&quot;&gt;환경&lt;/a&gt; 아래를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="44986cef8a397dae061d979c2eb0f5062a727e3b" translate="yes" xml:space="preserve">
          <source>Segment</source>
          <target state="translated">Segment</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
